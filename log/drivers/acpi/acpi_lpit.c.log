commit f8690227dd892600183c2bd8fc6b6fecfef28940
Author: Hanjun Guo <guohanjun@huawei.com>
Date:   Thu May 7 17:09:13 2020 +0800

    ACPI: LPIT: Put the low power idle table after using it
    
    The mapped LPIT table is not used for runtime after init,
    put the ACPI table to release the table mapping.
    
    Signed-off-by: Hanjun Guo <guohanjun@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpit.c b/drivers/acpi/acpi_lpit.c
index 953437a216f6..48e5059d67ca 100644
--- a/drivers/acpi/acpi_lpit.c
+++ b/drivers/acpi/acpi_lpit.c
@@ -151,10 +151,11 @@ void acpi_init_lpit(void)
 	struct acpi_table_lpit *lpit;
 
 	status = acpi_get_table(ACPI_SIG_LPIT, 0, (struct acpi_table_header **)&lpit);
-
 	if (ACPI_FAILURE(status))
 		return;
 
 	lpit_process((u64)lpit + sizeof(*lpit),
 		     (u64)lpit + lpit->header.length);
+
+	acpi_put_table((struct acpi_table_header *)lpit);
 }

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/acpi/acpi_lpit.c b/drivers/acpi/acpi_lpit.c
index 433376e819bb..953437a216f6 100644
--- a/drivers/acpi/acpi_lpit.c
+++ b/drivers/acpi/acpi_lpit.c
@@ -104,7 +104,7 @@ static void lpit_update_residency(struct lpit_residency_info *info,
 
 	info->gaddr = lpit_native->residency_counter;
 	if (info->gaddr.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {
-		info->iomem_addr = ioremap_nocache(info->gaddr.address,
+		info->iomem_addr = ioremap(info->gaddr.address,
 						   info->gaddr.bit_width / 8);
 		if (!info->iomem_addr)
 			return;

commit 50e163d43ab123193a7f381528a7485881f730e9
Merge: 5004efbb3611 ad5a449b707b 9ed411c06dd1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 8 10:49:36 2019 +0200

    Merge branches 'acpi-pm' and 'pm-pci'
    
    * acpi-pm:
      ACPI: PM: Make acpi_sleep_state_supported() non-static
      ACPI: PM: Allow transitions to D0 to occur in special cases
      ACPI: PM: Avoid evaluating _PS3 on transitions from D3hot to D3cold
      ACPI / sleep: Switch to use acpi_dev_get_first_match_dev()
      ACPI / LPIT: Correct LPIT end address for lpit_process()
    
    * pm-pci:
      ACPI: PM: Unexport acpi_device_get_power()
      PCI: PM/ACPI: Refresh all stale power state data in pci_pm_complete()
      PCI / ACPI: Add _PR0 dependent devices
      ACPI / PM: Introduce concept of a _PR0 dependent device
      PCI / ACPI: Use cached ACPI device state to get PCI device power state
      PCI: Do not poll for PME if the device is in D3cold
      PCI: Add missing link delays required by the PCIe spec
      PCI: PM: Replace pci_dev_keep_suspended() with two functions
      PCI: PM: Avoid resuming devices in D3hot during system suspend

commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/acpi_lpit.c b/drivers/acpi/acpi_lpit.c
index e43cb71b6972..6116b0fb86d4 100644
--- a/drivers/acpi/acpi_lpit.c
+++ b/drivers/acpi/acpi_lpit.c
@@ -1,17 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 
 /*
  * acpi_lpit.c - LPIT table processing functions
  *
  * Copyright (C) 2017 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/cpu.h>

commit 32865e3e010f0ea81e518878e9a6b1492ff07281
Author: Lenny Szubowicz <lszubowi@redhat.com>
Date:   Thu May 2 16:00:52 2019 -0400

    ACPI / LPIT: Correct LPIT end address for lpit_process()
    
    Correct the LPIT end address which is passed into lpit_process()
    and the end address limit test in lpit_process().
    
    The LPI state descriptor subtables follow the fixed sized
    acpi_lpit_header up to the end of the LPIT. The last LPI state
    descriptor can end at exactly the end of the LPIT.
    
    Note that this is a fix to a latent problem. Although incorrect,
    the unpatched version works because the passed in end address
    is just slightly beyond the actual end of the LPIT and the size
    of the ACPI LPIT header is smaller than the size of the only
    currently defined LPI state descriptor, acpi_lpit_native.
    
    Signed-off-by: Lenny Szubowicz <lszubowi@redhat.com>
    Reviewed-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpit.c b/drivers/acpi/acpi_lpit.c
index e43cb71b6972..8b170a07908a 100644
--- a/drivers/acpi/acpi_lpit.c
+++ b/drivers/acpi/acpi_lpit.c
@@ -137,7 +137,7 @@ static void lpit_update_residency(struct lpit_residency_info *info,
 
 static void lpit_process(u64 begin, u64 end)
 {
-	while (begin + sizeof(struct acpi_lpit_native) < end) {
+	while (begin + sizeof(struct acpi_lpit_native) <= end) {
 		struct acpi_lpit_native *lpit_native = (struct acpi_lpit_native *)begin;
 
 		if (!lpit_native->header.type && !lpit_native->header.flags) {
@@ -156,7 +156,6 @@ static void lpit_process(u64 begin, u64 end)
 void acpi_init_lpit(void)
 {
 	acpi_status status;
-	u64 lpit_begin;
 	struct acpi_table_lpit *lpit;
 
 	status = acpi_get_table(ACPI_SIG_LPIT, 0, (struct acpi_table_header **)&lpit);
@@ -164,6 +163,6 @@ void acpi_init_lpit(void)
 	if (ACPI_FAILURE(status))
 		return;
 
-	lpit_begin = (u64)lpit + sizeof(*lpit);
-	lpit_process(lpit_begin, lpit_begin + lpit->header.length);
+	lpit_process((u64)lpit + sizeof(*lpit),
+		     (u64)lpit + lpit->header.length);
 }

commit 1cdda9486f5103fb133f88e662e48c504adbb779
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
Date:   Fri Sep 28 14:24:02 2018 +0530

    ACPI / PM: LPIT: Register sysfs attributes based on FADT
    
    ACPI Low Power S0 Idle capabilities are announced via FADT table and can
    be used to inform the kernel about the presence of one or more Low Power
    Idle (LPI) entries as descried in LPIT table. LPIT table can exist
    independently even if the FADT S0 Idle flag is not set and thus it could
    confuse user since the following cpuidle attributes are created.
    
    /sys/devices/system/cpu/cpuidle/low_power_idle_cpu_residency_us
    /sys/devices/system/cpu/cpuidle/low_power_idle_system_residency_us
    
    Presence or absence of above attributes could mean that the given
    platform supports S0ix state or not.
    
    This change allows to create the above cpuidle attributes only if
    FADT table supports Low Power S0 Idle.
    
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpit.c b/drivers/acpi/acpi_lpit.c
index cf4fc0161164..e43cb71b6972 100644
--- a/drivers/acpi/acpi_lpit.c
+++ b/drivers/acpi/acpi_lpit.c
@@ -117,11 +117,17 @@ static void lpit_update_residency(struct lpit_residency_info *info,
 		if (!info->iomem_addr)
 			return;
 
+		if (!(acpi_gbl_FADT.flags & ACPI_FADT_LOW_POWER_S0))
+			return;
+
 		/* Silently fail, if cpuidle attribute group is not present */
 		sysfs_add_file_to_group(&cpu_subsys.dev_root->kobj,
 					&dev_attr_low_power_idle_system_residency_us.attr,
 					"cpuidle");
 	} else if (info->gaddr.space_id == ACPI_ADR_SPACE_FIXED_HARDWARE) {
+		if (!(acpi_gbl_FADT.flags & ACPI_FADT_LOW_POWER_S0))
+			return;
+
 		/* Silently fail, if cpuidle attribute group is not present */
 		sysfs_add_file_to_group(&cpu_subsys.dev_root->kobj,
 					&dev_attr_low_power_idle_cpu_residency_us.attr,

commit 9383bbadfe29fe8319e2245b75a508db9abd7b87
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Fri Feb 2 19:13:33 2018 +0530

    ACPI / LPIT: Export lpit_read_residency_count_address()
    
    Export lpit_read_residency_count_address(), so that it can be used from
    drivers built as module. With the recent changes, the builtin_pci
    functionality of the intel_pmc_core driver is removed and now it can be
    built as a module to read this exported interface to calculate the PMC base
    address.
    
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Len Brown <lenb@kernel.org>
    Cc: linux-acpi@vger.kernel.org
    
    Acked-by: Rafael J. Wysocki <rafael@kernel.org>
    Tested-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/acpi/acpi_lpit.c b/drivers/acpi/acpi_lpit.c
index e94e478dd18b..cf4fc0161164 100644
--- a/drivers/acpi/acpi_lpit.c
+++ b/drivers/acpi/acpi_lpit.c
@@ -100,6 +100,7 @@ int lpit_read_residency_count_address(u64 *address)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(lpit_read_residency_count_address);
 
 static void lpit_update_residency(struct lpit_residency_info *info,
 				 struct acpi_lpit_native *lpit_native)

commit eeb2d80d502af28e5660ff4bbe00f90ceb82c2db
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Oct 5 16:24:03 2017 -0700

    ACPI / LPIT: Add Low Power Idle Table (LPIT) support
    
    Add functionality to read LPIT table, which provides:
    
     - Sysfs interface to read residency counters via
       /sys/devices/system/cpu/cpuidle/low_power_idle_cpu_residency_us
       /sys/devices/system/cpu/cpuidle/low_power_idle_system_residency_us
    
    Here the count "low_power_idle_cpu_residency_us" shows the time spent
    by CPU package in low power state.  This is read via MSR interface,
    which points to MSR for PKG C10.
    
    Here the count "low_power_idle_system_residency_us" show the count the
    system was in low power state. This is read via MMIO interface. This
    is mapped to SLP_S0 residency on modern Intel systems. This residency
    is achieved only when CPU is in PKG C10 and all functional blocks are
    in low power state.
    
    It is possible that none of the above counters present or anyone of the
    counter present or all counters present.
    
    For example: On my Kabylake system both of the above counters present.
    After suspend to idle these counts updated and prints:
    
     6916179
     6998564
    
    This counter can be read by tools like turbostat to display. Or it can
    be used to debug, if modern systems are reaching desired low power state.
    
     - Provides an interface to read residency counter memory address
    
       This address can be used to get the base address of PMC memory
       mapped IO.  This is utilized by intel_pmc_core driver to print
       more debug information.
    
    In addition, to avoid code duplication to read iomem, removed the read of
    iomem from acpi_os_read_memory() in osl.c and made a common function
    acpi_os_read_iomem(). This new function is used for reading iomem in
    in both osl.c and acpi_lpit.c.
    
    Link: http://www.uefi.org/sites/default/files/resources/Intel_ACPI_Low_Power_S0_Idle.pdf
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpit.c b/drivers/acpi/acpi_lpit.c
new file mode 100644
index 000000000000..e94e478dd18b
--- /dev/null
+++ b/drivers/acpi/acpi_lpit.c
@@ -0,0 +1,162 @@
+
+/*
+ * acpi_lpit.c - LPIT table processing functions
+ *
+ * Copyright (C) 2017 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/cpu.h>
+#include <linux/acpi.h>
+#include <asm/msr.h>
+#include <asm/tsc.h>
+
+struct lpit_residency_info {
+	struct acpi_generic_address gaddr;
+	u64 frequency;
+	void __iomem *iomem_addr;
+};
+
+/* Storage for an memory mapped and FFH based entries */
+static struct lpit_residency_info residency_info_mem;
+static struct lpit_residency_info residency_info_ffh;
+
+static int lpit_read_residency_counter_us(u64 *counter, bool io_mem)
+{
+	int err;
+
+	if (io_mem) {
+		u64 count = 0;
+		int error;
+
+		error = acpi_os_read_iomem(residency_info_mem.iomem_addr, &count,
+					   residency_info_mem.gaddr.bit_width);
+		if (error)
+			return error;
+
+		*counter = div64_u64(count * 1000000ULL, residency_info_mem.frequency);
+		return 0;
+	}
+
+	err = rdmsrl_safe(residency_info_ffh.gaddr.address, counter);
+	if (!err) {
+		u64 mask = GENMASK_ULL(residency_info_ffh.gaddr.bit_offset +
+				       residency_info_ffh.gaddr. bit_width - 1,
+				       residency_info_ffh.gaddr.bit_offset);
+
+		*counter &= mask;
+		*counter >>= residency_info_ffh.gaddr.bit_offset;
+		*counter = div64_u64(*counter * 1000000ULL, residency_info_ffh.frequency);
+		return 0;
+	}
+
+	return -ENODATA;
+}
+
+static ssize_t low_power_idle_system_residency_us_show(struct device *dev,
+						       struct device_attribute *attr,
+						       char *buf)
+{
+	u64 counter;
+	int ret;
+
+	ret = lpit_read_residency_counter_us(&counter, true);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "%llu\n", counter);
+}
+static DEVICE_ATTR_RO(low_power_idle_system_residency_us);
+
+static ssize_t low_power_idle_cpu_residency_us_show(struct device *dev,
+						    struct device_attribute *attr,
+						    char *buf)
+{
+	u64 counter;
+	int ret;
+
+	ret = lpit_read_residency_counter_us(&counter, false);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "%llu\n", counter);
+}
+static DEVICE_ATTR_RO(low_power_idle_cpu_residency_us);
+
+int lpit_read_residency_count_address(u64 *address)
+{
+	if (!residency_info_mem.gaddr.address)
+		return -EINVAL;
+
+	*address = residency_info_mem.gaddr.address;
+
+	return 0;
+}
+
+static void lpit_update_residency(struct lpit_residency_info *info,
+				 struct acpi_lpit_native *lpit_native)
+{
+	info->frequency = lpit_native->counter_frequency ?
+				lpit_native->counter_frequency : tsc_khz * 1000;
+	if (!info->frequency)
+		info->frequency = 1;
+
+	info->gaddr = lpit_native->residency_counter;
+	if (info->gaddr.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {
+		info->iomem_addr = ioremap_nocache(info->gaddr.address,
+						   info->gaddr.bit_width / 8);
+		if (!info->iomem_addr)
+			return;
+
+		/* Silently fail, if cpuidle attribute group is not present */
+		sysfs_add_file_to_group(&cpu_subsys.dev_root->kobj,
+					&dev_attr_low_power_idle_system_residency_us.attr,
+					"cpuidle");
+	} else if (info->gaddr.space_id == ACPI_ADR_SPACE_FIXED_HARDWARE) {
+		/* Silently fail, if cpuidle attribute group is not present */
+		sysfs_add_file_to_group(&cpu_subsys.dev_root->kobj,
+					&dev_attr_low_power_idle_cpu_residency_us.attr,
+					"cpuidle");
+	}
+}
+
+static void lpit_process(u64 begin, u64 end)
+{
+	while (begin + sizeof(struct acpi_lpit_native) < end) {
+		struct acpi_lpit_native *lpit_native = (struct acpi_lpit_native *)begin;
+
+		if (!lpit_native->header.type && !lpit_native->header.flags) {
+			if (lpit_native->residency_counter.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY &&
+			    !residency_info_mem.gaddr.address) {
+				lpit_update_residency(&residency_info_mem, lpit_native);
+			} else if (lpit_native->residency_counter.space_id == ACPI_ADR_SPACE_FIXED_HARDWARE &&
+				   !residency_info_ffh.gaddr.address) {
+				lpit_update_residency(&residency_info_ffh, lpit_native);
+			}
+		}
+		begin += lpit_native->header.length;
+	}
+}
+
+void acpi_init_lpit(void)
+{
+	acpi_status status;
+	u64 lpit_begin;
+	struct acpi_table_lpit *lpit;
+
+	status = acpi_get_table(ACPI_SIG_LPIT, 0, (struct acpi_table_header **)&lpit);
+
+	if (ACPI_FAILURE(status))
+		return;
+
+	lpit_begin = (u64)lpit + sizeof(*lpit);
+	lpit_process(lpit_begin, lpit_begin + lpit->header.length);
+}
