commit 55716d26439f5c4008b0bcb7f17d1f7c0d8fbcfc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:42 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 428
    
    Based on 1 normalized pattern(s):
    
      this file is released under the gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 68 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190114.292346262@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index edd10b3c7ec8..36b24b0658cb 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -1,10 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Link physical devices with ACPI devices support
  *
  * Copyright (c) 2005 David Shaohua Li <shaohua.li@intel.com>
  * Copyright (c) 2005 Intel Corp.
- *
- * This file is released under the GPLv2.
  */
 
 #include <linux/acpi_iort.h>

commit 7847a1455fc4574d53e349d60feb1e1106cdc012
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Fri Nov 9 17:21:35 2018 +0300

    ACPI / glue: Add acpi_platform_notify() function
    
    Instead of relying on the "platform_notify" callback hook,
    introducing separate notification function
    acpi_platform_notify() and calling that directly from
    drivers core when device entries are added and removed.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 12ba2bee8789..edd10b3c7ec8 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -296,7 +296,7 @@ int acpi_unbind_one(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(acpi_unbind_one);
 
-static int acpi_platform_notify(struct device *dev)
+static int acpi_device_notify(struct device *dev)
 {
 	struct acpi_bus_type *type = acpi_get_bus_type(dev);
 	struct acpi_device *adev;
@@ -343,7 +343,7 @@ static int acpi_platform_notify(struct device *dev)
 	return ret;
 }
 
-static int acpi_platform_notify_remove(struct device *dev)
+static int acpi_device_notify_remove(struct device *dev)
 {
 	struct acpi_device *adev = ACPI_COMPANION(dev);
 	struct acpi_bus_type *type;
@@ -361,12 +361,17 @@ static int acpi_platform_notify_remove(struct device *dev)
 	return 0;
 }
 
-void __init init_acpi_device_notify(void)
+int acpi_platform_notify(struct device *dev, enum kobject_action action)
 {
-	if (platform_notify || platform_notify_remove) {
-		printk(KERN_ERR PREFIX "Can't use platform_notify\n");
-		return;
+	switch (action) {
+	case KOBJ_ADD:
+		acpi_device_notify(dev);
+		break;
+	case KOBJ_REMOVE:
+		acpi_device_notify_remove(dev);
+		break;
+	default:
+		break;
 	}
-	platform_notify = acpi_platform_notify;
-	platform_notify_remove = acpi_platform_notify_remove;
+	return 0;
 }

commit 719cf71cada1abc4f8727eac918b639a4a502a59
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Aug 20 16:45:41 2018 +0300

    ACPI / glue: Split dev_is_platform() out of module for wide use
    
    There would be useful to have in future the similar API in platform
    core, as we have, for example, for PCI subsystem, to check if device
    belongs to it.
    
    Thus, split out conditional to a macro dev_is_platform() for wide use.
    
    No functional change intended.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 3be1433853bf..12ba2bee8789 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -320,7 +320,7 @@ static int acpi_platform_notify(struct device *dev)
 	if (!adev)
 		goto out;
 
-	if (dev->bus == &platform_bus_type)
+	if (dev_is_platform(dev))
 		acpi_configure_pmsi_domain(dev);
 
 	if (type && type->setup)

commit 28b47809b2171a6cfbab839936b24280639c9f85
Merge: 4a1e31c68e9f 2c0248d68880
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 9 15:15:47 2017 -0700

    Merge tag 'iommu-updates-v4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu
    
    Pull IOMMU updates from Joerg Roedel:
    
     - code optimizations for the Intel VT-d driver
    
     - ability to switch off a previously enabled Intel IOMMU
    
     - support for 'struct iommu_device' for OMAP, Rockchip and Mediatek
       IOMMUs
    
     - header optimizations for IOMMU core code headers and a few fixes that
       became necessary in other parts of the kernel because of that
    
     - ACPI/IORT updates and fixes
    
     - Exynos IOMMU optimizations
    
     - updates for the IOMMU dma-api code to bring it closer to use per-cpu
       iova caches
    
     - new command-line option to set default domain type allocated by the
       iommu core code
    
     - another command line option to allow the Intel IOMMU switched off in
       a tboot environment
    
     - ARM/SMMU: TLB sync optimisations for SMMUv2, Support for using an
       IDENTITY domain in conjunction with DMA ops, Support for SMR masking,
       Support for 16-bit ASIDs (was previously broken)
    
     - various other small fixes and improvements
    
    * tag 'iommu-updates-v4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu: (63 commits)
      soc/qbman: Move dma-mapping.h include to qman_priv.h
      soc/qbman: Fix implicit header dependency now causing build fails
      iommu: Remove trace-events include from iommu.h
      iommu: Remove pci.h include from trace/events/iommu.h
      arm: dma-mapping: Don't override dma_ops in arch_setup_dma_ops()
      ACPI/IORT: Fix CONFIG_IOMMU_API dependency
      iommu/vt-d: Don't print the failure message when booting non-kdump kernel
      iommu: Move report_iommu_fault() to iommu.c
      iommu: Include device.h in iommu.h
      x86, iommu/vt-d: Add an option to disable Intel IOMMU force on
      iommu/arm-smmu: Return IOVA in iova_to_phys when SMMU is bypassed
      iommu/arm-smmu: Correct sid to mask
      iommu/amd: Fix incorrect error handling in amd_iommu_bind_pasid()
      iommu: Make iommu_bus_notifier return NOTIFY_DONE rather than error code
      omap3isp: Remove iommu_group related code
      iommu/omap: Add iommu-group support
      iommu/omap: Make use of 'struct iommu_device'
      iommu/omap: Store iommu_dev pointer in arch_data
      iommu/omap: Move data structures to omap-iommu.h
      iommu/omap: Drop legacy-style device support
      ...

commit ab182e67ec99ea0c8d7435a32a4a1ed9bb02559a
Merge: 7246f6006884 92f66f84d969
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 5 12:11:37 2017 -0700

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Catalin Marinas:
    
     - kdump support, including two necessary memblock additions:
       memblock_clear_nomap() and memblock_cap_memory_range()
    
     - ARMv8.3 HWCAP bits for JavaScript conversion instructions, complex
       numbers and weaker release consistency
    
     - arm64 ACPI platform MSI support
    
     - arm perf updates: ACPI PMU support, L3 cache PMU in some Qualcomm
       SoCs, Cortex-A53 L2 cache events and DTLB refills, MAINTAINERS update
       for DT perf bindings
    
     - architected timer errata framework (the arch/arm64 changes only)
    
     - support for DMA_ATTR_FORCE_CONTIGUOUS in the arm64 iommu DMA API
    
     - arm64 KVM refactoring to use common system register definitions
    
     - remove support for ASID-tagged VIVT I-cache (no ARMv8 implementation
       using it and deprecated in the architecture) together with some
       I-cache handling clean-up
    
     - PE/COFF EFI header clean-up/hardening
    
     - define BUG() instruction without CONFIG_BUG
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (92 commits)
      arm64: Fix the DMA mmap and get_sgtable API with DMA_ATTR_FORCE_CONTIGUOUS
      arm64: Print DT machine model in setup_machine_fdt()
      arm64: pmu: Wire-up Cortex A53 L2 cache events and DTLB refills
      arm64: module: split core and init PLT sections
      arm64: pmuv3: handle pmuv3+
      arm64: Add CNTFRQ_EL0 trap handler
      arm64: Silence spurious kbuild warning on menuconfig
      arm64: pmuv3: use arm_pmu ACPI framework
      arm64: pmuv3: handle !PMUv3 when probing
      drivers/perf: arm_pmu: add ACPI framework
      arm64: add function to get a cpu's MADT GICC table
      drivers/perf: arm_pmu: split out platform device probe logic
      drivers/perf: arm_pmu: move irq request/free into probe
      drivers/perf: arm_pmu: split cpu-local irq request/free
      drivers/perf: arm_pmu: rename irq request/free functions
      drivers/perf: arm_pmu: handle no platform_device
      drivers/perf: arm_pmu: simplify cpu_pmu_request_irqs()
      drivers/perf: arm_pmu: factor out pmu registration
      drivers/perf: arm_pmu: fold init into alloc
      drivers/perf: arm_pmu: define armpmu_init_fn
      ...

commit 2c0248d68880fc0e783af1048b3367ee5d4412f0
Merge: d5bf739dc762 fd8e2d4b3932 c9d9f2394c6a 6f66ea099fc2 bdf95923086f 26b37b946a5c 8e1218840066 73dbd4a42302 290d638e04e7
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu May 4 18:06:17 2017 +0200

    Merge branches 'arm/exynos', 'arm/omap', 'arm/rockchip', 'arm/mediatek', 'arm/smmu', 'arm/core', 'x86/vt-d', 'x86/amd' and 'core' into next

commit 09515ef5ddad71c7820e5e428da418b709feeb26
Author: Sricharan R <sricharan@codeaurora.org>
Date:   Mon Apr 10 16:51:01 2017 +0530

    of/acpi: Configure dma operations at probe time for platform/amba/pci bus devices
    
    Configuring DMA ops at probe time will allow deferring device probe when
    the IOMMU isn't available yet. The dma_configure for the device is
    now called from the generic device_attach callback just before the
    bus/driver probe is called. This way, configuring the DMA ops for the
    device would be called at the same place for all bus_types, hence the
    deferred probing mechanism should work for all buses as well.
    
    pci_bus_add_devices    (platform/amba)(_device_create/driver_register)
           |                         |
    pci_bus_add_device     (device_add/driver_register)
           |                         |
    device_attach           device_initial_probe
           |                         |
    __device_attach_driver    __device_attach_driver
           |
    driver_probe_device
           |
    really_probe
           |
    dma_configure
    
    Similarly on the device/driver_unregister path __device_release_driver is
    called which inturn calls dma_deconfigure.
    
    This patch changes the dma ops configuration to probe time for
    both OF and ACPI based platform/amba/pci bus devices.
    
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci part)
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sricharan R <sricharan@codeaurora.org>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index fb19e1cdb641..c05f24107bfc 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -176,7 +176,6 @@ int acpi_bind_one(struct device *dev, struct acpi_device *acpi_dev)
 	struct list_head *physnode_list;
 	unsigned int node_id;
 	int retval = -EINVAL;
-	enum dev_dma_attr attr;
 
 	if (has_acpi_companion(dev)) {
 		if (acpi_dev) {
@@ -233,10 +232,6 @@ int acpi_bind_one(struct device *dev, struct acpi_device *acpi_dev)
 	if (!has_acpi_companion(dev))
 		ACPI_COMPANION_SET(dev, acpi_dev);
 
-	attr = acpi_get_dma_attr(acpi_dev);
-	if (attr != DEV_DMA_NOT_SUPPORTED)
-		acpi_dma_configure(dev, attr);
-
 	acpi_physnode_link_name(physical_node_name, node_id);
 	retval = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,
 				   physical_node_name);

commit fdad4e7a876a2cb3d2c1f04e5418c324e79fffef
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 1 00:45:52 2017 +0200

    ACPI / scan: Prefer devices without _HID for _ADR matching
    
    Commit c2a6bbaf0c5f (ACPI / scan: Prefer devices without _HID/_CID
    for _ADR matching) added a list_empty(&adev->pnp.ids) check to
    find_child_checks() so as to catch situations in which the ACPI
    core attempts to decode _ADR for a device having a _HID too which
    is strictly against the spec.  However, it overlooked the fact that
    the adev->pnp.ids list for the devices taken into account by
    find_child_checks() may contain device IDs set internally by the
    kernel, like "LNXVIDEO" (thanks to Zhang Rui for that realization),
    and it broke the enumeration of those devices as a result.
    
    To unbreak it, replace the overly coarse grained list_empty()
    check with a much more precise check against the pnp.type.platform_id
    flag which is only set for devices having a _HID (that's how it
    should be done from the start, as having both _ADR and _CID is
    actually permitted).
    
    Fixes: c2a6bbaf0c5f (ACPI / scan: Prefer devices without _HID/_CID for _ADR matching)
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=194889
    Reported-and-tested-by: Mike <mike@mikewilson.me.uk>
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Cc: 4.10+ <stable@vger.kernel.org> # 4.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index fb19e1cdb641..edc8663b5db3 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -99,13 +99,13 @@ static int find_child_checks(struct acpi_device *adev, bool check_children)
 		return -ENODEV;
 
 	/*
-	 * If the device has a _HID (or _CID) returning a valid ACPI/PNP
-	 * device ID, it is better to make it look less attractive here, so that
-	 * the other device with the same _ADR value (that may not have a valid
-	 * device ID) can be matched going forward.  [This means a second spec
-	 * violation in a row, so whatever we do here is best effort anyway.]
+	 * If the device has a _HID returning a valid ACPI/PNP device ID, it is
+	 * better to make it look less attractive here, so that the other device
+	 * with the same _ADR value (that may not have a valid device ID) can be
+	 * matched going forward.  [This means a second spec violation in a row,
+	 * so whatever we do here is best effort anyway.]
 	 */
-	return sta_present && list_empty(&adev->pnp.ids) ?
+	return sta_present && !adev->pnp.type.platform_id ?
 			FIND_CHILD_MAX_SCORE : FIND_CHILD_MIN_SCORE;
 }
 

commit d4f54a186667ffd19eac8e3f48c51d940a9b9784
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Mar 7 20:40:06 2017 +0800

    ACPI: platform: setup MSI domain for ACPI based platform device
    
    By allowing platform MSI domain to be created on ACPI platforms,
    a platform device MSI domain can be set-up when it is probed.
    
    In order to do that, the MSI domain the platform device connects
    to should be retrieved, so the iort_get_platform_device_domain() is
    introduced to retrieve the domain from the IORT kernel layer.
    
    With the domain retrieved, we need a proper way to set the
    domain to platform device.
    
    Given that some platform devices (irqchips) require the MSI irqdomain
    to be their interrupt parent domain, the MSI irqdomain should be
    determined before platform device is probed but after the platform
    device is allocated which means that the code setting up the MSI
    irqdomain, ie acpi_configure_pmsi_domain() should be called in
    acpi_platform_notify() (that is triggered after adding a device but
    before the respective driver is probed) for the platform MSI domain
    code set-up path to work properly.
    
    Acked-by: Rafael J. Wysocki <rafael@kernel.org> [for glue.c]
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    [lorenzo.pieralisi@arm.com: rewrote commit log]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Tested-by: Ming Lei <ming.lei@canonical.com>
    Tested-by: Wei Xu <xuwei5@hisilicon.com>
    Tested-by: Sinan Kaya <okaya@codeaurora.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Tomasz Nowicki <tn@semihalf.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index fb19e1cdb641..ec31b439b4c8 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -6,6 +6,8 @@
  *
  * This file is released under the GPLv2.
  */
+
+#include <linux/acpi_iort.h>
 #include <linux/export.h>
 #include <linux/init.h>
 #include <linux/list.h>
@@ -14,6 +16,7 @@
 #include <linux/rwsem.h>
 #include <linux/acpi.h>
 #include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
 
 #include "internal.h"
 
@@ -322,6 +325,9 @@ static int acpi_platform_notify(struct device *dev)
 	if (!adev)
 		goto out;
 
+	if (dev->bus == &platform_bus_type)
+		acpi_configure_pmsi_domain(dev);
+
 	if (type && type->setup)
 		type->setup(dev);
 	else if (adev->handler && adev->handler->bind)

commit c2a6bbaf0c5f90463a7011a295bbdb7e33c80b51
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 30 02:27:31 2016 +0100

    ACPI / scan: Prefer devices without _HID/_CID for _ADR matching
    
    The way acpi_find_child_device() works currently is that, if there
    are two (or more) devices with the same _ADR value in the same
    namespace scope (which is not specifically allowed by the spec and
    the OS behavior in that case is not defined), the first one of them
    found to be present (with the help of _STA) will be returned.
    
    This covers the majority of cases, but is not sufficient if some of
    the devices in question have a _HID (or _CID) returning some valid
    ACPI/PNP device IDs (which is disallowed by the spec) and the
    ASL writers' expectation appears to be that the OS will match
    devices without a valid ACPI/PNP device ID against a given bus
    address first.
    
    To cover this special case as well, modify find_child_checks()
    to prefer devices without ACPI/PNP device IDs over devices that
    have them.
    
    Suggested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index eb709e7c9ffd..fb19e1cdb641 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -98,7 +98,15 @@ static int find_child_checks(struct acpi_device *adev, bool check_children)
 	if (check_children && list_empty(&adev->children))
 		return -ENODEV;
 
-	return sta_present ? FIND_CHILD_MAX_SCORE : FIND_CHILD_MIN_SCORE;
+	/*
+	 * If the device has a _HID (or _CID) returning a valid ACPI/PNP
+	 * device ID, it is better to make it look less attractive here, so that
+	 * the other device with the same _ADR value (that may not have a valid
+	 * device ID) can be matched going forward.  [This means a second spec
+	 * violation in a row, so whatever we do here is best effort anyway.]
+	 */
+	return sta_present && list_empty(&adev->pnp.ids) ?
+			FIND_CHILD_MAX_SCORE : FIND_CHILD_MIN_SCORE;
 }
 
 struct acpi_device *acpi_find_child_device(struct acpi_device *parent,

commit 709f94ff018a4403d0bb32643254058d5d9cfa24
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Fri Dec 16 14:43:56 2016 +0000

    ACPI: Drop misplaced acpi_dma_deconfigure() call from acpi_bind_one()
    
    The acpi_bind_one() error return path can be hit either on physical node
    allocation failure or if the device being configured is already
    associated with an ACPI node and its ACPI companion does not match the
    one acpi_bind_one() is setting it up with. In both cases the error
    return path is executed before DMA is configured for a device therefore
    there is no need to call acpi_dma_deconfigure() on the function error
    return path.
    
    Furthermore, if acpi_bind_one() does configure DMA for a device (ie it
    successfully executes acpi_dma_configure()) acpi_bind_one() always
    completes execution successfully hence there is no need to add an exit
    path to deconfigure the DMA set-up (ie by calling acpi_dma_deconfigure()).
    
    Remove the misplaced acpi_dma_deconfigure() in acpi_bind_one() to
    reinstate its correct error return path behaviour.
    
    Fixes: d760a1baf20e (ACPI: Implement acpi_dma_configure)
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index f8d65647ea79..eb709e7c9ffd 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -250,7 +250,6 @@ int acpi_bind_one(struct device *dev, struct acpi_device *acpi_dev)
 	return 0;
 
  err:
-	acpi_dma_deconfigure(dev);
 	ACPI_COMPANION_SET(dev, NULL);
 	put_device(dev);
 	put_device(&acpi_dev->dev);

commit d760a1baf20e067d3a063aa134834ddd3d183e2f
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Nov 21 10:01:39 2016 +0000

    ACPI: Implement acpi_dma_configure
    
    On DT based systems, the of_dma_configure() API implements DMA
    configuration for a given device. On ACPI systems an API equivalent to
    of_dma_configure() is missing which implies that it is currently not
    possible to set-up DMA operations for devices through the ACPI generic
    kernel layer.
    
    This patch fills the gap by introducing acpi_dma_configure/deconfigure()
    calls that for now are just wrappers around arch_setup_dma_ops() and
    arch_teardown_dma_ops() and also updates ACPI and PCI core code to use
    the newly introduced acpi_dma_configure/acpi_dma_deconfigure functions.
    
    Since acpi_dma_configure() is used to configure DMA operations, the
    function initializes the dma/coherent_dma masks to sane default values
    if the current masks are uninitialized (also to keep the default values
    consistent with DT systems) to make sure the device has a complete
    default DMA set-up.
    
    The DMA range size passed to arch_setup_dma_ops() is sized according
    to the device coherent_dma_mask (starting at address 0x0), mirroring the
    DT probing path behaviour when a dma-ranges property is not provided
    for the device being probed; this changes the current arch_setup_dma_ops()
    call parameters in the ACPI probing case, but since arch_setup_dma_ops()
    is a NOP on all architectures but ARM/ARM64 this patch does not change
    the current kernel behaviour on them.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> [pci]
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Tomasz Nowicki <tn@semihalf.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Tomasz Nowicki <tn@semihalf.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: Tomasz Nowicki <tn@semihalf.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 5ea5dc219f56..f8d65647ea79 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -227,8 +227,7 @@ int acpi_bind_one(struct device *dev, struct acpi_device *acpi_dev)
 
 	attr = acpi_get_dma_attr(acpi_dev);
 	if (attr != DEV_DMA_NOT_SUPPORTED)
-		arch_setup_dma_ops(dev, 0, 0, NULL,
-				   attr == DEV_DMA_COHERENT);
+		acpi_dma_configure(dev, attr);
 
 	acpi_physnode_link_name(physical_node_name, node_id);
 	retval = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,
@@ -251,6 +250,7 @@ int acpi_bind_one(struct device *dev, struct acpi_device *acpi_dev)
 	return 0;
 
  err:
+	acpi_dma_deconfigure(dev);
 	ACPI_COMPANION_SET(dev, NULL);
 	put_device(dev);
 	put_device(&acpi_dev->dev);

commit f2115faaf0df42623638dfbfc5bdaab6ef7375ab
Merge: 0d51ce9ca111 29dbe1f0af88
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Nov 7 01:30:10 2015 +0100

    Merge branch 'acpi-pci'
    
    * acpi-pci:
      PCI: ACPI: Add support for PCI device DMA coherency
      PCI: OF: Move of_pci_dma_configure() to pci_dma_configure()
      of/pci: Fix pci_get_host_bridge_device leak
      device property: ACPI: Remove unused DMA APIs
      device property: ACPI: Make use of the new DMA Attribute APIs
      device property: Adding DMA Attribute APIs for Generic Devices
      ACPI: Adding DMA Attribute APIs for ACPI Device
      device property: Introducing enum dev_dma_attr
      ACPI: Honor ACPI _CCA attribute setting
    
    Conflicts:
            drivers/crypto/ccp/ccp-platform.c

commit 1831eff876bd0bb8d64e9965a7ff47486c9a3ecd
Author: Suthikulpanit, Suravee <Suravee.Suthikulpanit@amd.com>
Date:   Wed Oct 28 15:50:50 2015 -0700

    device property: ACPI: Make use of the new DMA Attribute APIs
    
    Now that we have the new DMA attribute APIs, we can replace the older
    acpi_check_dma() and device_dma_is_coherent().
    
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index b9657af751d1..a66e77676b8a 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -168,7 +168,7 @@ int acpi_bind_one(struct device *dev, struct acpi_device *acpi_dev)
 	struct list_head *physnode_list;
 	unsigned int node_id;
 	int retval = -EINVAL;
-	bool coherent;
+	enum dev_dma_attr attr;
 
 	if (has_acpi_companion(dev)) {
 		if (acpi_dev) {
@@ -225,8 +225,10 @@ int acpi_bind_one(struct device *dev, struct acpi_device *acpi_dev)
 	if (!has_acpi_companion(dev))
 		ACPI_COMPANION_SET(dev, acpi_dev);
 
-	if (acpi_check_dma(acpi_dev, &coherent))
-		arch_setup_dma_ops(dev, 0, 0, NULL, coherent);
+	attr = acpi_get_dma_attr(acpi_dev);
+	if (attr != DEV_DMA_NOT_SUPPORTED)
+		arch_setup_dma_ops(dev, 0, 0, NULL,
+				   attr == DEV_DMA_COHERENT);
 
 	acpi_physnode_link_name(physical_node_name, node_id);
 	retval = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,

commit c33cab60bc0e05ddf1ef1b2cba8d16dd010f600a
Author: Rami Rosen <ramirose@gmail.com>
Date:   Thu Sep 10 23:48:09 2015 +0300

    ACPI: change init_acpi_device_notify() to return void
    
    This patch changes the type of the return value of the init_acpi_device_notify()
    method to be void, as this method never fails and its return value is never
    used.
    
    Signed-off-by: Rami Rosen <ramirose@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index b9657af751d1..1470ae4f98c0 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -351,13 +351,12 @@ static int acpi_platform_notify_remove(struct device *dev)
 	return 0;
 }
 
-int __init init_acpi_device_notify(void)
+void __init init_acpi_device_notify(void)
 {
 	if (platform_notify || platform_notify_remove) {
 		printk(KERN_ERR PREFIX "Can't use platform_notify\n");
-		return 0;
+		return;
 	}
 	platform_notify = acpi_platform_notify;
 	platform_notify_remove = acpi_platform_notify_remove;
-	return 0;
 }

commit d0562674838c08ff142c0e9a8e12634e133c4361
Author: Suthikulpanit, Suravee <Suravee.Suthikulpanit@amd.com>
Date:   Wed Jun 10 11:08:52 2015 -0500

    ACPI / scan: Parse _CCA and setup device coherency
    
    This patch implements support for ACPI _CCA object, which is introduced in
    ACPIv5.1, can be used for specifying device DMA coherency attribute.
    
    The parsing logic traverses device namespace to parse coherency
    information, and stores it in acpi_device_flags. Then uses it to call
    arch_setup_dma_ops() when creating each device enumerated in DSDT
    during ACPI scan.
    
    This patch also introduces acpi_dma_is_coherent(), which provides
    an interface for device drivers to check the coherency information
    similarly to the of_dma_is_coherent().
    
    Signed-off-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 39c485b0c25c..b9657af751d1 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -13,6 +13,7 @@
 #include <linux/slab.h>
 #include <linux/rwsem.h>
 #include <linux/acpi.h>
+#include <linux/dma-mapping.h>
 
 #include "internal.h"
 
@@ -167,6 +168,7 @@ int acpi_bind_one(struct device *dev, struct acpi_device *acpi_dev)
 	struct list_head *physnode_list;
 	unsigned int node_id;
 	int retval = -EINVAL;
+	bool coherent;
 
 	if (has_acpi_companion(dev)) {
 		if (acpi_dev) {
@@ -223,6 +225,9 @@ int acpi_bind_one(struct device *dev, struct acpi_device *acpi_dev)
 	if (!has_acpi_companion(dev))
 		ACPI_COMPANION_SET(dev, acpi_dev);
 
+	if (acpi_check_dma(acpi_dev, &coherent))
+		arch_setup_dma_ops(dev, 0, 0, NULL, coherent);
+
 	acpi_physnode_link_name(physical_node_name, node_id);
 	retval = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,
 				   physical_node_name);

commit ca5b74d2675a44f54aacb919c1cf022463e2f738
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 16 23:49:08 2015 +0100

    ACPI: Introduce has_acpi_companion()
    
    Now that the ACPI companions of devices are represented by pointers
    to struct fwnode_handle, it is not quite efficient to check whether
    or not an ACPI companion of a device is present by evaluating the
    ACPI_COMPANION() macro.
    
    For this reason, introduce a special static inline routine for that,
    has_acpi_companion(), and update the code to use it where applicable.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index f774c65ecb8b..39c485b0c25c 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -168,7 +168,7 @@ int acpi_bind_one(struct device *dev, struct acpi_device *acpi_dev)
 	unsigned int node_id;
 	int retval = -EINVAL;
 
-	if (ACPI_COMPANION(dev)) {
+	if (has_acpi_companion(dev)) {
 		if (acpi_dev) {
 			dev_warn(dev, "ACPI companion already set\n");
 			return -EINVAL;
@@ -220,7 +220,7 @@ int acpi_bind_one(struct device *dev, struct acpi_device *acpi_dev)
 	list_add(&physical_node->node, physnode_list);
 	acpi_dev->physical_node_count++;
 
-	if (!ACPI_COMPANION(dev))
+	if (!has_acpi_companion(dev))
 		ACPI_COMPANION_SET(dev, acpi_dev);
 
 	acpi_physnode_link_name(physical_node_name, node_id);

commit 9cb32acf095e806e864c29d060dd79580fcd3d4f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 11 00:35:46 2014 +0100

    ACPI / scan: Add bind/unbind callbacks to struct acpi_scan_handler
    
    In some cases it may be necessary to perform certain setup/cleanup
    operations on a device object representing a physical device after
    it has been associated with an ACPI companion by acpi_bind_one() or
    before disassociating it from that companion by acpi_unbind_one(),
    respectively.  If there is a struct acpi_bus_type object for the
    given device's bus type, the .setup()/.cleanup() callbacks from there
    are executed for these purposes.  However, an analogous mechanism will
    be necessary for devices whose bus types don't have corresponding
    struct acpi_bus_type objects and that have specific ACPI scan handlers.
    
    For those devices, add new .bind() and .unbind() callbacks to struct
    acpi_scan_handler that will be executed by acpi_platform_notify()
    right after the given device has been associated with an ACPI
    comapnion and by acpi_platform_notify_remove() right before calling
    acpi_unbind_one() for that device, respectively.
    
    To make that work for scan handlers registering new devices in their
    .attach() callbacks, modify acpi_scan_attach_handler() to set the
    ACPI device object's handler field before calling .attach() from the
    scan handler at hand.
    
    This changeset includes a fix from Mika Westerberg.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 0c789224d40d..f774c65ecb8b 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -287,6 +287,7 @@ EXPORT_SYMBOL_GPL(acpi_unbind_one);
 static int acpi_platform_notify(struct device *dev)
 {
 	struct acpi_bus_type *type = acpi_get_bus_type(dev);
+	struct acpi_device *adev;
 	int ret;
 
 	ret = acpi_bind_one(dev, NULL);
@@ -303,9 +304,14 @@ static int acpi_platform_notify(struct device *dev)
 		if (ret)
 			goto out;
 	}
+	adev = ACPI_COMPANION(dev);
+	if (!adev)
+		goto out;
 
 	if (type && type->setup)
 		type->setup(dev);
+	else if (adev->handler && adev->handler->bind)
+		adev->handler->bind(dev);
 
  out:
 #if ACPI_GLUE_DEBUG
@@ -324,11 +330,17 @@ static int acpi_platform_notify(struct device *dev)
 
 static int acpi_platform_notify_remove(struct device *dev)
 {
+	struct acpi_device *adev = ACPI_COMPANION(dev);
 	struct acpi_bus_type *type;
 
+	if (!adev)
+		return 0;
+
 	type = acpi_get_bus_type(dev);
 	if (type && type->cleanup)
 		type->cleanup(dev);
+	else if (adev->handler && adev->handler->unbind)
+		adev->handler->unbind(dev);
 
 	acpi_unbind_one(dev);
 	return 0;

commit bfecc2b3e34c6751343bacd317c4dfd1d695142c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 29 16:27:53 2013 +0100

    ACPI / bind: Move acpi_get_child() to drivers/ide/ide-acpi.c
    
    Since drivers/ide/ide-acpi.c is the only remaining user of
    acpi_get_child(), move that function into that file as a static
    routine.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 896351b9d483..0c789224d40d 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -151,18 +151,6 @@ struct acpi_device *acpi_find_child_device(struct acpi_device *parent,
 }
 EXPORT_SYMBOL_GPL(acpi_find_child_device);
 
-acpi_handle acpi_get_child(acpi_handle handle, u64 addr)
-{
-	struct acpi_device *adev;
-
-	if (!handle || acpi_bus_get_device(handle, &adev))
-		return NULL;
-
-	adev = acpi_find_child_device(adev, addr, false);
-	return adev ? adev->handle : NULL;
-}
-EXPORT_SYMBOL_GPL(acpi_get_child);
-
 static void acpi_physnode_link_name(char *buf, unsigned int node_id)
 {
 	if (node_id > 0)

commit 24dee1fc99fd6d38fc859d7f6dda1dab21493bef
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 29 16:27:43 2013 +0100

    ACPI / bind: Pass struct acpi_device pointer to acpi_bind_one()
    
    There is no reason to pass an ACPI handle to acpi_bind_one() instead
    of a struct acpi_device pointer to the target device object, so
    modify that function to take a struct acpi_device pointer as its
    second argument and update all code depending on it accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Lan Tianyu <tianyu.lan@intel.com> # for USB/ACPI

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 7608d66f289b..896351b9d483 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -172,9 +172,8 @@ static void acpi_physnode_link_name(char *buf, unsigned int node_id)
 		strcpy(buf, PHYSICAL_NODE_STRING);
 }
 
-int acpi_bind_one(struct device *dev, acpi_handle handle)
+int acpi_bind_one(struct device *dev, struct acpi_device *acpi_dev)
 {
-	struct acpi_device *acpi_dev = NULL;
 	struct acpi_device_physical_node *physical_node, *pn;
 	char physical_node_name[PHYSICAL_NODE_NAME_SIZE];
 	struct list_head *physnode_list;
@@ -182,14 +181,12 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 	int retval = -EINVAL;
 
 	if (ACPI_COMPANION(dev)) {
-		if (handle) {
+		if (acpi_dev) {
 			dev_warn(dev, "ACPI companion already set\n");
 			return -EINVAL;
 		} else {
 			acpi_dev = ACPI_COMPANION(dev);
 		}
-	} else {
-		acpi_bus_get_device(handle, &acpi_dev);
 	}
 	if (!acpi_dev)
 		return -EINVAL;
@@ -314,7 +311,7 @@ static int acpi_platform_notify(struct device *dev)
 			ret = -ENODEV;
 			goto out;
 		}
-		ret = acpi_bind_one(dev, adev->handle);
+		ret = acpi_bind_one(dev, adev);
 		if (ret)
 			goto out;
 	}

commit e3f02c5228c4b600abf6ca243301176f25553bd5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 29 16:27:34 2013 +0100

    ACPI / bind: Rework struct acpi_bus_type
    
    Replace the .find_device function pointer in struct acpi_bus_type
    with a new one, .find_companion, that is supposed to point to a
    function returning struct acpi_device pointer (instead of an int)
    and takes one argument (instead of two).  This way the role of
    this callback is more clear and the implementation of it can
    be more straightforward.
    
    Update all of the users of struct acpi_bus_type (PCI, PNP/ACPI and
    USB) to reflect the structure change.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Lan Tianyu <tianyu.lan@intel.com> # for USB/ACPI

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index c0d18b2145c1..7608d66f289b 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -37,7 +37,7 @@ int register_acpi_bus_type(struct acpi_bus_type *type)
 {
 	if (acpi_disabled)
 		return -ENODEV;
-	if (type && type->match && type->find_device) {
+	if (type && type->match && type->find_companion) {
 		down_write(&bus_type_sem);
 		list_add_tail(&type->list, &bus_type_list);
 		up_write(&bus_type_sem);
@@ -302,17 +302,19 @@ EXPORT_SYMBOL_GPL(acpi_unbind_one);
 static int acpi_platform_notify(struct device *dev)
 {
 	struct acpi_bus_type *type = acpi_get_bus_type(dev);
-	acpi_handle handle;
 	int ret;
 
 	ret = acpi_bind_one(dev, NULL);
 	if (ret && type) {
-		ret = type->find_device(dev, &handle);
-		if (ret) {
+		struct acpi_device *adev;
+
+		adev = type->find_companion(dev);
+		if (!adev) {
 			DBG("Unable to get handle for %s\n", dev_name(dev));
+			ret = -ENODEV;
 			goto out;
 		}
-		ret = acpi_bind_one(dev, handle);
+		ret = acpi_bind_one(dev, adev->handle);
 		if (ret)
 			goto out;
 	}

commit 9c5ad36d987a1b06f6b0b9dc7bc61a45d277455d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 28 23:58:28 2013 +0100

    ACPI / bind: Redefine acpi_preset_companion()
    
    Modify acpi_preset_companion() to take a struct acpi_device pointer
    instead of an ACPI handle as its second argument and redefine it as
    a static inline wrapper around ACPI_COMPANION_SET() passing the
    return value of acpi_find_child_device() directly as the second
    argument to it.  Update its users to pass struct acpi_device
    pointers instead of ACPI handles to it.
    
    This allows some unnecessary acpi_bus_get_device() calls to be
    avoided.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com>
    Tested-by: Aaron Lu <aaron.lu@intel.com> # for ATA binding

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 12b2acbaa116..c0d18b2145c1 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -149,6 +149,7 @@ struct acpi_device *acpi_find_child_device(struct acpi_device *parent,
 	}
 	return ret;
 }
+EXPORT_SYMBOL_GPL(acpi_find_child_device);
 
 acpi_handle acpi_get_child(acpi_handle handle, u64 addr)
 {
@@ -298,15 +299,6 @@ int acpi_unbind_one(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(acpi_unbind_one);
 
-void acpi_preset_companion(struct device *dev, acpi_handle parent, u64 addr)
-{
-	struct acpi_device *adev;
-
-	if (!acpi_bus_get_device(acpi_get_child(parent, addr), &adev))
-		ACPI_COMPANION_SET(dev, adev);
-}
-EXPORT_SYMBOL_GPL(acpi_preset_companion);
-
 static int acpi_platform_notify(struct device *dev)
 {
 	struct acpi_bus_type *type = acpi_get_bus_type(dev);

commit 11dcc75dba5bf8b69c4612de10e366c4e04cb123
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 28 23:58:18 2013 +0100

    ACPI / bind: Redefine acpi_get_child()
    
    Since acpi_get_child() is the only user of acpi_find_child() now,
    drop the static inline definition of the former and redefine the
    latter as new acpi_get_child().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com>
    Tested-by: Aaron Lu <aaron.lu@intel.com> # for ATA binding

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 9d200d5029ca..12b2acbaa116 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -150,17 +150,17 @@ struct acpi_device *acpi_find_child_device(struct acpi_device *parent,
 	return ret;
 }
 
-acpi_handle acpi_find_child(acpi_handle handle, u64 addr, bool is_bridge)
+acpi_handle acpi_get_child(acpi_handle handle, u64 addr)
 {
 	struct acpi_device *adev;
 
 	if (!handle || acpi_bus_get_device(handle, &adev))
 		return NULL;
 
-	adev = acpi_find_child_device(adev, addr, is_bridge);
+	adev = acpi_find_child_device(adev, addr, false);
 	return adev ? adev->handle : NULL;
 }
-EXPORT_SYMBOL_GPL(acpi_find_child);
+EXPORT_SYMBOL_GPL(acpi_get_child);
 
 static void acpi_physnode_link_name(char *buf, unsigned int node_id)
 {

commit 5ce79d201358d36f13d13b01d8614bd8e646036c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 28 23:58:08 2013 +0100

    PCI / ACPI: Use acpi_find_child_device() for child devices lookup
    
    It is much more efficient to use acpi_find_child_device()
    for child devices lookup in acpi_pci_find_device() and pass
    ACPI_COMPANION(dev->parent) to it directly instead of obtaining
    ACPI_HANDLE() of ACPI_COMPANION(dev->parent) and passing it to
    acpi_find_child() which has to run acpi_bus_get_device() to
    obtain ACPI_COMPANION(dev->parent) from that again.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index ea77512ad70c..9d200d5029ca 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -106,6 +106,9 @@ struct acpi_device *acpi_find_child_device(struct acpi_device *parent,
 	struct acpi_device *adev, *ret = NULL;
 	int ret_score = 0;
 
+	if (!parent)
+		return NULL;
+
 	list_for_each_entry(adev, &parent->children, node) {
 		unsigned long long addr;
 		acpi_status status;

commit d9fef0c4d2e08c3888add77f1dc54fb12afb3928
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 28 23:57:58 2013 +0100

    ACPI / bind: Simplify child device lookups
    
    Now that we create a struct acpi_device object for every ACPI
    namespace node representing a device, it is not necessary to
    use acpi_walk_namespace() for child device lookup in
    acpi_find_child() any more.  Instead, we can simply walk the
    list of children of the given struct acpi_device object and
    return the matching one (or the one which is the best match if
    there are more of them).  The checks done during the matching
    loop can be simplified too so that the secondary namespace walks
    in find_child_checks() are not necessary any more.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index a22a295edb69..ea77512ad70c 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -82,107 +82,80 @@ static struct acpi_bus_type *acpi_get_bus_type(struct device *dev)
 #define FIND_CHILD_MIN_SCORE	1
 #define FIND_CHILD_MAX_SCORE	2
 
-static acpi_status acpi_dev_present(acpi_handle handle, u32 lvl_not_used,
-				  void *not_used, void **ret_p)
-{
-	struct acpi_device *adev = NULL;
-
-	acpi_bus_get_device(handle, &adev);
-	if (adev) {
-		*ret_p = handle;
-		return AE_CTRL_TERMINATE;
-	}
-	return AE_OK;
-}
-
-static int do_find_child_checks(acpi_handle handle, bool is_bridge)
+static int find_child_checks(struct acpi_device *adev, bool check_children)
 {
 	bool sta_present = true;
 	unsigned long long sta;
 	acpi_status status;
 
-	status = acpi_evaluate_integer(handle, "_STA", NULL, &sta);
+	status = acpi_evaluate_integer(adev->handle, "_STA", NULL, &sta);
 	if (status == AE_NOT_FOUND)
 		sta_present = false;
 	else if (ACPI_FAILURE(status) || !(sta & ACPI_STA_DEVICE_ENABLED))
 		return -ENODEV;
 
-	if (is_bridge) {
-		void *test = NULL;
+	if (check_children && list_empty(&adev->children))
+		return -ENODEV;
 
-		/* Check if this object has at least one child device. */
-		acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,
-				    acpi_dev_present, NULL, NULL, &test);
-		if (!test)
-			return -ENODEV;
-	}
 	return sta_present ? FIND_CHILD_MAX_SCORE : FIND_CHILD_MIN_SCORE;
 }
 
-struct find_child_context {
-	u64 addr;
-	bool is_bridge;
-	acpi_handle ret;
-	int ret_score;
-};
-
-static acpi_status do_find_child(acpi_handle handle, u32 lvl_not_used,
-				 void *data, void **not_used)
+struct acpi_device *acpi_find_child_device(struct acpi_device *parent,
+					   u64 address, bool check_children)
 {
-	struct find_child_context *context = data;
-	unsigned long long addr;
-	acpi_status status;
-	int score;
-
-	status = acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL, &addr);
-	if (ACPI_FAILURE(status) || addr != context->addr)
-		return AE_OK;
-
-	if (!context->ret) {
-		/* This is the first matching object.  Save its handle. */
-		context->ret = handle;
-		return AE_OK;
-	}
-	/*
-	 * There is more than one matching object with the same _ADR value.
-	 * That really is unexpected, so we are kind of beyond the scope of the
-	 * spec here.  We have to choose which one to return, though.
-	 *
-	 * First, check if the previously found object is good enough and return
-	 * its handle if so.  Second, check the same for the object that we've
-	 * just found.
-	 */
-	if (!context->ret_score) {
-		score = do_find_child_checks(context->ret, context->is_bridge);
-		if (score == FIND_CHILD_MAX_SCORE)
-			return AE_CTRL_TERMINATE;
-		else
-			context->ret_score = score;
-	}
-	score = do_find_child_checks(handle, context->is_bridge);
-	if (score == FIND_CHILD_MAX_SCORE) {
-		context->ret = handle;
-		return AE_CTRL_TERMINATE;
-	} else if (score > context->ret_score) {
-		context->ret = handle;
-		context->ret_score = score;
+	struct acpi_device *adev, *ret = NULL;
+	int ret_score = 0;
+
+	list_for_each_entry(adev, &parent->children, node) {
+		unsigned long long addr;
+		acpi_status status;
+		int score;
+
+		status = acpi_evaluate_integer(adev->handle, METHOD_NAME__ADR,
+					       NULL, &addr);
+		if (ACPI_FAILURE(status) || addr != address)
+			continue;
+
+		if (!ret) {
+			/* This is the first matching object.  Save it. */
+			ret = adev;
+			continue;
+		}
+		/*
+		 * There is more than one matching device object with the same
+		 * _ADR value.  That really is unexpected, so we are kind of
+		 * beyond the scope of the spec here.  We have to choose which
+		 * one to return, though.
+		 *
+		 * First, check if the previously found object is good enough
+		 * and return it if so.  Second, do the same for the object that
+		 * we've just found.
+		 */
+		if (!ret_score) {
+			ret_score = find_child_checks(ret, check_children);
+			if (ret_score == FIND_CHILD_MAX_SCORE)
+				return ret;
+		}
+		score = find_child_checks(adev, check_children);
+		if (score == FIND_CHILD_MAX_SCORE) {
+			return adev;
+		} else if (score > ret_score) {
+			ret = adev;
+			ret_score = score;
+		}
 	}
-	return AE_OK;
+	return ret;
 }
 
-acpi_handle acpi_find_child(acpi_handle parent, u64 addr, bool is_bridge)
+acpi_handle acpi_find_child(acpi_handle handle, u64 addr, bool is_bridge)
 {
-	if (parent) {
-		struct find_child_context context = {
-			.addr = addr,
-			.is_bridge = is_bridge,
-		};
-
-		acpi_walk_namespace(ACPI_TYPE_DEVICE, parent, 1, do_find_child,
-				    NULL, &context, NULL);
-		return context.ret;
-	}
-	return NULL;
+	struct acpi_device *adev;
+
+	if (!handle || acpi_bus_get_device(handle, &adev))
+		return NULL;
+
+	adev = acpi_find_child_device(adev, addr, is_bridge);
+	return adev ? adev->handle : NULL;
 }
 EXPORT_SYMBOL_GPL(acpi_find_child);
 

commit a104b4d467d1c4a09727bac2816928aef3304d3a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 14 23:18:32 2013 +0100

    ACPI / bind: Use (put|get)_device() on ACPI device objects too
    
    When associating a "physical" device with an ACPI device object
    acpi_bind_one() only uses get_device() to increment the reference
    counter of the former, but there is no reason not to do that with
    the latter too.  Among other things, that may help to avoid
    use-after-free when an ACPI device object is freed without calling
    acpi_unbind_one() for all "physical" devices associated with it
    (that only can happen in buggy code, but then it's better if the
    kernel doesn't crash as a result of a bug).
    
    For this reason, modify acpi_bind_one() to apply get_device() to
    the ACPI device object too and update acpi_unbind_one() to drop
    that reference using put_device() as appropriate.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Lan Tianyu <tianyu.lan@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 782071fd3df3..a22a295edb69 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -217,6 +217,7 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 	if (!acpi_dev)
 		return -EINVAL;
 
+	get_device(&acpi_dev->dev);
 	get_device(dev);
 	physical_node = kzalloc(sizeof(*physical_node), GFP_KERNEL);
 	if (!physical_node) {
@@ -243,6 +244,7 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 				goto err;
 
 			put_device(dev);
+			put_device(&acpi_dev->dev);
 			return 0;
 		}
 		if (pn->node_id == node_id) {
@@ -282,6 +284,7 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
  err:
 	ACPI_COMPANION_SET(dev, NULL);
 	put_device(dev);
+	put_device(&acpi_dev->dev);
 	return retval;
 }
 EXPORT_SYMBOL_GPL(acpi_bind_one);
@@ -307,8 +310,9 @@ int acpi_unbind_one(struct device *dev)
 			sysfs_remove_link(&acpi_dev->dev.kobj, physnode_name);
 			sysfs_remove_link(&dev->kobj, "firmware_node");
 			ACPI_COMPANION_SET(dev, NULL);
-			/* acpi_bind_one() increase refcnt by one. */
+			/* Drop references taken by acpi_bind_one(). */
 			put_device(dev);
+			put_device(&acpi_dev->dev);
 			kfree(entry);
 			break;
 		}

commit 7b1998116bbb2f3e5dd6cb9a8ee6db479b0b50a9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 11 22:41:56 2013 +0100

    ACPI / driver core: Store an ACPI device pointer in struct acpi_dev_node
    
    Modify struct acpi_dev_node to contain a pointer to struct acpi_device
    associated with the given device object (that is, its ACPI companion
    device) instead of an ACPI handle corresponding to it.  Introduce two
    new macros for manipulating that pointer in a CONFIG_ACPI-safe way,
    ACPI_COMPANION() and ACPI_COMPANION_SET(), and rework the
    ACPI_HANDLE() macro to take the above changes into account.
    Drop the ACPI_HANDLE_SET() macro entirely and rework its users to
    use ACPI_COMPANION_SET() instead.  For some of them who used to
    pass the result of acpi_get_child() directly to ACPI_HANDLE_SET()
    introduce a helper routine acpi_preset_companion() doing an
    equivalent thing.
    
    The main motivation for doing this is that there are things
    represented by struct acpi_device objects that don't have valid
    ACPI handles (so called fixed ACPI hardware features, such as
    power and sleep buttons) and we would like to create platform
    device objects for them and "glue" them to their ACPI companions
    in the usual way (which currently is impossible due to the
    lack of valid ACPI handles).  However, there are more reasons
    why it may be useful.
    
    First, struct acpi_device pointers allow of much better type checking
    than void pointers which are ACPI handles, so it should be more
    difficult to write buggy code using modified struct acpi_dev_node
    and the new macros.  Second, the change should help to reduce (over
    time) the number of places in which the result of ACPI_HANDLE() is
    passed to acpi_bus_get_device() in order to obtain a pointer to the
    struct acpi_device associated with the given "physical" device,
    because now that pointer is returned by ACPI_COMPANION() directly.
    Finally, the change should make it easier to write generic code that
    will build both for CONFIG_ACPI set and unset without adding explicit
    compiler directives to it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com> # on Haswell
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com> # for ATA and SDIO part

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 10f0f40587bb..782071fd3df3 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -197,30 +197,27 @@ static void acpi_physnode_link_name(char *buf, unsigned int node_id)
 
 int acpi_bind_one(struct device *dev, acpi_handle handle)
 {
-	struct acpi_device *acpi_dev;
-	acpi_status status;
+	struct acpi_device *acpi_dev = NULL;
 	struct acpi_device_physical_node *physical_node, *pn;
 	char physical_node_name[PHYSICAL_NODE_NAME_SIZE];
 	struct list_head *physnode_list;
 	unsigned int node_id;
 	int retval = -EINVAL;
 
-	if (ACPI_HANDLE(dev)) {
+	if (ACPI_COMPANION(dev)) {
 		if (handle) {
-			dev_warn(dev, "ACPI handle is already set\n");
+			dev_warn(dev, "ACPI companion already set\n");
 			return -EINVAL;
 		} else {
-			handle = ACPI_HANDLE(dev);
+			acpi_dev = ACPI_COMPANION(dev);
 		}
+	} else {
+		acpi_bus_get_device(handle, &acpi_dev);
 	}
-	if (!handle)
+	if (!acpi_dev)
 		return -EINVAL;
 
 	get_device(dev);
-	status = acpi_bus_get_device(handle, &acpi_dev);
-	if (ACPI_FAILURE(status))
-		goto err;
-
 	physical_node = kzalloc(sizeof(*physical_node), GFP_KERNEL);
 	if (!physical_node) {
 		retval = -ENOMEM;
@@ -242,7 +239,7 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 
 			dev_warn(dev, "Already associated with ACPI node\n");
 			kfree(physical_node);
-			if (ACPI_HANDLE(dev) != handle)
+			if (ACPI_COMPANION(dev) != acpi_dev)
 				goto err;
 
 			put_device(dev);
@@ -259,8 +256,8 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 	list_add(&physical_node->node, physnode_list);
 	acpi_dev->physical_node_count++;
 
-	if (!ACPI_HANDLE(dev))
-		ACPI_HANDLE_SET(dev, acpi_dev->handle);
+	if (!ACPI_COMPANION(dev))
+		ACPI_COMPANION_SET(dev, acpi_dev);
 
 	acpi_physnode_link_name(physical_node_name, node_id);
 	retval = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,
@@ -283,7 +280,7 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 	return 0;
 
  err:
-	ACPI_HANDLE_SET(dev, NULL);
+	ACPI_COMPANION_SET(dev, NULL);
 	put_device(dev);
 	return retval;
 }
@@ -291,19 +288,12 @@ EXPORT_SYMBOL_GPL(acpi_bind_one);
 
 int acpi_unbind_one(struct device *dev)
 {
+	struct acpi_device *acpi_dev = ACPI_COMPANION(dev);
 	struct acpi_device_physical_node *entry;
-	struct acpi_device *acpi_dev;
-	acpi_status status;
 
-	if (!ACPI_HANDLE(dev))
+	if (!acpi_dev)
 		return 0;
 
-	status = acpi_bus_get_device(ACPI_HANDLE(dev), &acpi_dev);
-	if (ACPI_FAILURE(status)) {
-		dev_err(dev, "Oops, ACPI handle corrupt in %s()\n", __func__);
-		return -EINVAL;
-	}
-
 	mutex_lock(&acpi_dev->physical_node_lock);
 
 	list_for_each_entry(entry, &acpi_dev->physical_node_list, node)
@@ -316,7 +306,7 @@ int acpi_unbind_one(struct device *dev)
 			acpi_physnode_link_name(physnode_name, entry->node_id);
 			sysfs_remove_link(&acpi_dev->dev.kobj, physnode_name);
 			sysfs_remove_link(&dev->kobj, "firmware_node");
-			ACPI_HANDLE_SET(dev, NULL);
+			ACPI_COMPANION_SET(dev, NULL);
 			/* acpi_bind_one() increase refcnt by one. */
 			put_device(dev);
 			kfree(entry);
@@ -328,6 +318,15 @@ int acpi_unbind_one(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(acpi_unbind_one);
 
+void acpi_preset_companion(struct device *dev, acpi_handle parent, u64 addr)
+{
+	struct acpi_device *adev;
+
+	if (!acpi_bus_get_device(acpi_get_child(parent, addr), &adev))
+		ACPI_COMPANION_SET(dev, adev);
+}
+EXPORT_SYMBOL_GPL(acpi_preset_companion);
+
 static int acpi_platform_notify(struct device *dev)
 {
 	struct acpi_bus_type *type = acpi_get_bus_type(dev);

commit 11b88ee275ec8590a373396888c2460ee89364d6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Sep 9 23:07:47 2013 +0200

    ACPI / bind: Prefer device objects with _STA to those without it
    
    As reported at https://bugzilla.kernel.org/show_bug.cgi?id=60829,
    there still are cases in which do_find_child() doesn't choose the
    ACPI device object it is "expected" to choose if there are more such
    objects matching one PCI device present.  This particular problem may
    be worked around by making do_find_child() return device obejcts witn
    _STA whose result indicates that the device is enabled before device
    objects without _STA if there's more than one device object to choose
    from.
    
    This change doesn't affect the case in which there's only one
    matching ACPI device object per PCI device.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=60829
    Reported-by: Peter Wu <lekensteyn@gmail.com>
    Tested-by: Felix Lisczyk <felix.lisczyk@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 94672297e1b1..10f0f40587bb 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -79,6 +79,9 @@ static struct acpi_bus_type *acpi_get_bus_type(struct device *dev)
 	return ret;
 }
 
+#define FIND_CHILD_MIN_SCORE	1
+#define FIND_CHILD_MAX_SCORE	2
+
 static acpi_status acpi_dev_present(acpi_handle handle, u32 lvl_not_used,
 				  void *not_used, void **ret_p)
 {
@@ -92,14 +95,17 @@ static acpi_status acpi_dev_present(acpi_handle handle, u32 lvl_not_used,
 	return AE_OK;
 }
 
-static bool acpi_extra_checks_passed(acpi_handle handle, bool is_bridge)
+static int do_find_child_checks(acpi_handle handle, bool is_bridge)
 {
+	bool sta_present = true;
 	unsigned long long sta;
 	acpi_status status;
 
-	status = acpi_bus_get_status_handle(handle, &sta);
-	if (ACPI_FAILURE(status) || !(sta & ACPI_STA_DEVICE_ENABLED))
-		return false;
+	status = acpi_evaluate_integer(handle, "_STA", NULL, &sta);
+	if (status == AE_NOT_FOUND)
+		sta_present = false;
+	else if (ACPI_FAILURE(status) || !(sta & ACPI_STA_DEVICE_ENABLED))
+		return -ENODEV;
 
 	if (is_bridge) {
 		void *test = NULL;
@@ -107,16 +113,17 @@ static bool acpi_extra_checks_passed(acpi_handle handle, bool is_bridge)
 		/* Check if this object has at least one child device. */
 		acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,
 				    acpi_dev_present, NULL, NULL, &test);
-		return !!test;
+		if (!test)
+			return -ENODEV;
 	}
-	return true;
+	return sta_present ? FIND_CHILD_MAX_SCORE : FIND_CHILD_MIN_SCORE;
 }
 
 struct find_child_context {
 	u64 addr;
 	bool is_bridge;
 	acpi_handle ret;
-	bool ret_checked;
+	int ret_score;
 };
 
 static acpi_status do_find_child(acpi_handle handle, u32 lvl_not_used,
@@ -125,6 +132,7 @@ static acpi_status do_find_child(acpi_handle handle, u32 lvl_not_used,
 	struct find_child_context *context = data;
 	unsigned long long addr;
 	acpi_status status;
+	int score;
 
 	status = acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL, &addr);
 	if (ACPI_FAILURE(status) || addr != context->addr)
@@ -144,15 +152,20 @@ static acpi_status do_find_child(acpi_handle handle, u32 lvl_not_used,
 	 * its handle if so.  Second, check the same for the object that we've
 	 * just found.
 	 */
-	if (!context->ret_checked) {
-		if (acpi_extra_checks_passed(context->ret, context->is_bridge))
+	if (!context->ret_score) {
+		score = do_find_child_checks(context->ret, context->is_bridge);
+		if (score == FIND_CHILD_MAX_SCORE)
 			return AE_CTRL_TERMINATE;
 		else
-			context->ret_checked = true;
+			context->ret_score = score;
 	}
-	if (acpi_extra_checks_passed(handle, context->is_bridge)) {
+	score = do_find_child_checks(handle, context->is_bridge);
+	if (score == FIND_CHILD_MAX_SCORE) {
 		context->ret = handle;
 		return AE_CTRL_TERMINATE;
+	} else if (score > context->ret_score) {
+		context->ret = handle;
+		context->ret_score = score;
 	}
 	return AE_OK;
 }

commit 464c114717ae221202ebdbd9aa216035b4626f18
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 8 16:19:19 2013 +0200

    ACPI: Print diagnostic messages if device links cannot be created
    
    Although the device links created by acpi_bind_one() are not
    essential from the kernel functionality point of view, user space
    may be confused when they are missing, so print diagnostic messages
    to the kernel log if they can't be created.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index f3ead0ce37ab..94672297e1b1 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -252,8 +252,15 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 	acpi_physnode_link_name(physical_node_name, node_id);
 	retval = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,
 				   physical_node_name);
+	if (retval)
+		dev_err(&acpi_dev->dev, "Failed to create link %s (%d)\n",
+			physical_node_name, retval);
+
 	retval = sysfs_create_link(&dev->kobj, &acpi_dev->dev.kobj,
 				   "firmware_node");
+	if (retval)
+		dev_err(dev, "Failed to create link firmware_node (%d)\n",
+			retval);
 
 	mutex_unlock(&acpi_dev->physical_node_lock);
 

commit 3342c753bdeb29ec29d721c7ce38d283cc969174
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 8 16:19:10 2013 +0200

    ACPI: Drop unnecessary label from acpi_bind_one()
    
    The out_free label in acpi_bind_one() is only jumped to from one
    place, so in fact it is not necessary, because the code below it
    can be moved to that place directly.  Move that code and drop the
    label.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index dcba319ac3f1..f3ead0ce37ab 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -225,11 +225,15 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 	list_for_each_entry(pn, &acpi_dev->physical_node_list, node) {
 		/* Sanity check. */
 		if (pn->dev == dev) {
+			mutex_unlock(&acpi_dev->physical_node_lock);
+
 			dev_warn(dev, "Already associated with ACPI node\n");
-			if (ACPI_HANDLE(dev) == handle)
-				retval = 0;
+			kfree(physical_node);
+			if (ACPI_HANDLE(dev) != handle)
+				goto err;
 
-			goto out_free;
+			put_device(dev);
+			return 0;
 		}
 		if (pn->node_id == node_id) {
 			physnode_list = &pn->node;
@@ -262,15 +266,6 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 	ACPI_HANDLE_SET(dev, NULL);
 	put_device(dev);
 	return retval;
-
- out_free:
-	mutex_unlock(&acpi_dev->physical_node_lock);
-	kfree(physical_node);
-	if (retval)
-		goto err;
-
-	put_device(dev);
-	return 0;
 }
 EXPORT_SYMBOL_GPL(acpi_bind_one);
 

commit 38e88839eff8a3d2e8d3bcc2ad833fe51cca0496
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 7 01:22:51 2013 +0200

    ACPI: Clean up error code path in acpi_unbind_one()
    
    The error code path in acpi_unbind_one() is unnecessarily complicated
    (in particular, the err label is not really necessary) and the error
    message printed by it is inaccurate (there's nothing called
    'acpi_handle' in that function), so clean up those things.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 570628e1def3..dcba319ac3f1 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -284,8 +284,10 @@ int acpi_unbind_one(struct device *dev)
 		return 0;
 
 	status = acpi_bus_get_device(ACPI_HANDLE(dev), &acpi_dev);
-	if (ACPI_FAILURE(status))
-		goto err;
+	if (ACPI_FAILURE(status)) {
+		dev_err(dev, "Oops, ACPI handle corrupt in %s()\n", __func__);
+		return -EINVAL;
+	}
 
 	mutex_lock(&acpi_dev->physical_node_lock);
 
@@ -307,12 +309,7 @@ int acpi_unbind_one(struct device *dev)
 		}
 
 	mutex_unlock(&acpi_dev->physical_node_lock);
-
 	return 0;
-
-err:
-	dev_err(dev, "Oops, 'acpi_handle' corrupt\n");
-	return -EINVAL;
 }
 EXPORT_SYMBOL_GPL(acpi_unbind_one);
 

commit 3e3327837c180781960188563b4e4d5c004c2b29
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 7 01:22:08 2013 +0200

    ACPI: Use list_for_each_entry() in acpi_unbind_one()
    
    Since acpi_unbind_one() walks physical_node_list under the ACPI
    device object's physical_node_lock mutex and the walk may be
    terminated as soon as the matching entry has been found, it is
    not necessary to use list_for_each_safe() for that walk, so use
    list_for_each_entry() instead and make the code slightly more
    straightforward.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 69641c061619..570628e1def3 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -279,7 +279,6 @@ int acpi_unbind_one(struct device *dev)
 	struct acpi_device_physical_node *entry;
 	struct acpi_device *acpi_dev;
 	acpi_status status;
-	struct list_head *node, *next;
 
 	if (!ACPI_HANDLE(dev))
 		return 0;
@@ -289,25 +288,24 @@ int acpi_unbind_one(struct device *dev)
 		goto err;
 
 	mutex_lock(&acpi_dev->physical_node_lock);
-	list_for_each_safe(node, next, &acpi_dev->physical_node_list) {
-		char physical_node_name[PHYSICAL_NODE_NAME_SIZE];
-
-		entry = list_entry(node, struct acpi_device_physical_node,
-				   node);
-		if (entry->dev != dev)
-			continue;
-
-		list_del(node);
-		acpi_dev->physical_node_count--;
-
-		acpi_physnode_link_name(physical_node_name, entry->node_id);
-		sysfs_remove_link(&acpi_dev->dev.kobj, physical_node_name);
-		sysfs_remove_link(&dev->kobj, "firmware_node");
-		ACPI_HANDLE_SET(dev, NULL);
-		/* acpi_bind_one increase refcnt by one */
-		put_device(dev);
-		kfree(entry);
-	}
+
+	list_for_each_entry(entry, &acpi_dev->physical_node_list, node)
+		if (entry->dev == dev) {
+			char physnode_name[PHYSICAL_NODE_NAME_SIZE];
+
+			list_del(&entry->node);
+			acpi_dev->physical_node_count--;
+
+			acpi_physnode_link_name(physnode_name, entry->node_id);
+			sysfs_remove_link(&acpi_dev->dev.kobj, physnode_name);
+			sysfs_remove_link(&dev->kobj, "firmware_node");
+			ACPI_HANDLE_SET(dev, NULL);
+			/* acpi_bind_one() increase refcnt by one. */
+			put_device(dev);
+			kfree(entry);
+			break;
+		}
+
 	mutex_unlock(&acpi_dev->physical_node_lock);
 
 	return 0;

commit f501b6ec290f59b9c444bc061acf0e422347fb55
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 7 01:19:52 2013 +0200

    ACPI: acpi_bind_one()/acpi_unbind_one() whitespace cleanups
    
    Clean up some inconsistent use of whitespace in acpi_bind_one() and
    acpi_unbind_one().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 914a34601231..69641c061619 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -247,9 +247,9 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 
 	acpi_physnode_link_name(physical_node_name, node_id);
 	retval = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,
-			physical_node_name);
+				   physical_node_name);
 	retval = sysfs_create_link(&dev->kobj, &acpi_dev->dev.kobj,
-		"firmware_node");
+				   "firmware_node");
 
 	mutex_unlock(&acpi_dev->physical_node_lock);
 
@@ -293,12 +293,11 @@ int acpi_unbind_one(struct device *dev)
 		char physical_node_name[PHYSICAL_NODE_NAME_SIZE];
 
 		entry = list_entry(node, struct acpi_device_physical_node,
-			node);
+				   node);
 		if (entry->dev != dev)
 			continue;
 
 		list_del(node);
-
 		acpi_dev->physical_node_count--;
 
 		acpi_physnode_link_name(physical_node_name, entry->node_id);

commit 4005520648c7d6cf28e74addb52bc4a793eea3eb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 7 01:19:37 2013 +0200

    ACPI: Create symlinks in acpi_bind_one() under physical_node_lock
    
    Put the creation of symlinks in acpi_bind_one() under the
    physical_node_lock mutex of the given ACPI device object, because
    that is part of the binding operation logically (those links are
    already removed under that mutex too).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 92cacb12ef5c..914a34601231 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -242,8 +242,6 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 	list_add(&physical_node->node, physnode_list);
 	acpi_dev->physical_node_count++;
 
-	mutex_unlock(&acpi_dev->physical_node_lock);
-
 	if (!ACPI_HANDLE(dev))
 		ACPI_HANDLE_SET(dev, acpi_dev->handle);
 
@@ -253,6 +251,8 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 	retval = sysfs_create_link(&dev->kobj, &acpi_dev->dev.kobj,
 		"firmware_node");
 
+	mutex_unlock(&acpi_dev->physical_node_lock);
+
 	if (acpi_dev->wakeup.flags.valid)
 		device_set_wakeup_capable(dev, true);
 

commit bdbdbf91081250657d018fc66d7cd0c07f337070
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 7 01:19:23 2013 +0200

    ACPI: Reduce acpi_bind_one()/acpi_unbind_one() code duplication
    
    Move some duplicated code from acpi_bind_one() and acpi_unbind_one()
    into a separate function and make that function use snprintf()
    instead of sprintf() for extra safety.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 48cc4c98e18b..92cacb12ef5c 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -173,6 +173,15 @@ acpi_handle acpi_find_child(acpi_handle parent, u64 addr, bool is_bridge)
 }
 EXPORT_SYMBOL_GPL(acpi_find_child);
 
+static void acpi_physnode_link_name(char *buf, unsigned int node_id)
+{
+	if (node_id > 0)
+		snprintf(buf, PHYSICAL_NODE_NAME_SIZE,
+			 PHYSICAL_NODE_STRING "%u", node_id);
+	else
+		strcpy(buf, PHYSICAL_NODE_STRING);
+}
+
 int acpi_bind_one(struct device *dev, acpi_handle handle)
 {
 	struct acpi_device *acpi_dev;
@@ -238,11 +247,7 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 	if (!ACPI_HANDLE(dev))
 		ACPI_HANDLE_SET(dev, acpi_dev->handle);
 
-	if (!physical_node->node_id)
-		strcpy(physical_node_name, PHYSICAL_NODE_STRING);
-	else
-		sprintf(physical_node_name,
-			"physical_node%d", physical_node->node_id);
+	acpi_physnode_link_name(physical_node_name, node_id);
 	retval = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,
 			physical_node_name);
 	retval = sysfs_create_link(&dev->kobj, &acpi_dev->dev.kobj,
@@ -296,12 +301,7 @@ int acpi_unbind_one(struct device *dev)
 
 		acpi_dev->physical_node_count--;
 
-		if (!entry->node_id)
-			strcpy(physical_node_name, PHYSICAL_NODE_STRING);
-		else
-			sprintf(physical_node_name,
-				"physical_node%d", entry->node_id);
-
+		acpi_physnode_link_name(physical_node_name, entry->node_id);
 		sysfs_remove_link(&acpi_dev->dev.kobj, physical_node_name);
 		sysfs_remove_link(&dev->kobj, "firmware_node");
 		ACPI_HANDLE_SET(dev, NULL);

commit 3fe444ad7e3a6951fa0c9b552c5afe6f6df0d571
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 7 01:15:25 2013 +0200

    ACPI: Do not fail acpi_bind_one() if device is already bound correctly
    
    Modify acpi_bind_one() so that it doesn't fail if the device
    represented by its first argument has already been bound to the
    given ACPI handle (second argument), because that is not a good
    enough reason for returning an error code.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Lan Tianyu <tianyu.lan@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 408f6b2a5fa8..48cc4c98e18b 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -217,7 +217,10 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 		/* Sanity check. */
 		if (pn->dev == dev) {
 			dev_warn(dev, "Already associated with ACPI node\n");
-			goto err_free;
+			if (ACPI_HANDLE(dev) == handle)
+				retval = 0;
+
+			goto out_free;
 		}
 		if (pn->node_id == node_id) {
 			physnode_list = &pn->node;
@@ -255,10 +258,14 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 	put_device(dev);
 	return retval;
 
- err_free:
+ out_free:
 	mutex_unlock(&acpi_dev->physical_node_lock);
 	kfree(physical_node);
-	goto err;
+	if (retval)
+		goto err;
+
+	put_device(dev);
+	return 0;
 }
 EXPORT_SYMBOL_GPL(acpi_bind_one);
 

commit 60f75b8e97daf4a39790a20d962cb861b9220af5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 7 22:55:00 2013 +0200

    ACPI: Try harder to resolve _ADR collisions for bridges
    
    In theory, under a given ACPI namespace node there should be only
    one child device object with _ADR whose value matches a given bus
    address exactly.  In practice, however, there are systems in which
    multiple child device objects under a given parent have _ADR matching
    exactly the same address.  In those cases we use _STA to determine
    which of the multiple matching devices is enabled, since some systems
    are known to indicate which ACPI device object to associate with the
    given physical (usually PCI) device this way.
    
    Unfortunately, as it turns out, there are systems in which many
    device objects under the same parent have _ADR matching exactly the
    same bus address and none of them has _STA, in which case they all
    should be regarded as enabled according to the spec.  Still, if
    those device objects are supposed to represent bridges (e.g. this
    is the case for device objects corresponding to PCIe ports), we can
    try harder and skip the ones that have no child device objects in the
    ACPI namespace.  With luck, we can avoid using device objects that we
    are not expected to use this way.
    
    Although this only works for bridges whose children also have ACPI
    namespace representation, it is sufficient to address graphics
    adapter detection issues on some systems, so rework the code finding
    a matching device ACPI handle for a given bus address to implement
    this idea.
    
    Introduce a new function, acpi_find_child(), taking three arguments:
    the ACPI handle of the device's parent, a bus address suitable for
    the device's bus type and a bool indicating if the device is a
    bridge and make it work as outlined above.  Reimplement the function
    currently used for this purpose, acpi_get_child(), as a call to
    acpi_find_child() with the last argument set to 'false' and make
    the PCI subsystem use acpi_find_child() with the bridge information
    passed as the last argument to it.  [Lan Tianyu notices that it is
    not sufficient to use pci_is_bridge() for that, because the device's
    subordinate pointer hasn't been set yet at this point, so use
    hdr_type instead.]
    
    This change fixes a regression introduced inadvertently by commit
    33f767d (ACPI: Rework acpi_get_child() to be more efficient) which
    overlooked the fact that for acpi_walk_namespace() "post-order" means
    "after all children have been visited" rather than "on the way back",
    so for device objects without children and for namespace walks of
    depth 1, as in the acpi_get_child() case, the "post-order" callbacks
    ordering is actually the same as the ordering of "pre-order" ones.
    Since that commit changed the namespace walk in acpi_get_child() to
    terminate after finding the first matching object instead of going
    through all of them and returning the last one, it effectively
    changed the result returned by that function in some rare cases and
    that led to problems (the switch from a "pre-order" to a "post-order"
    callback was supposed to prevent that from happening, but it was
    ineffective).
    
    As it turns out, the systems where the change made by commit
    33f767d actually matters are those where there are multiple ACPI
    device objects representing the same PCIe port (which effectively
    is a bridge).  Moreover, only one of them, and the one we are
    expected to use, has child device objects in the ACPI namespace,
    so the regression can be addressed as described above.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=60561
    Reported-by: Peter Wu <lekensteyn@gmail.com>
    Tested-by: Vladimir Lalov <mail@vlalov.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: 3.9+ <stable@vger.kernel.org> # 3.9+

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 17e15d11bd39..408f6b2a5fa8 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -79,34 +79,99 @@ static struct acpi_bus_type *acpi_get_bus_type(struct device *dev)
 	return ret;
 }
 
-static acpi_status do_acpi_find_child(acpi_handle handle, u32 lvl_not_used,
-				      void *addr_p, void **ret_p)
+static acpi_status acpi_dev_present(acpi_handle handle, u32 lvl_not_used,
+				  void *not_used, void **ret_p)
 {
-	unsigned long long addr, sta;
-	acpi_status status;
+	struct acpi_device *adev = NULL;
 
-	status = acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL, &addr);
-	if (ACPI_SUCCESS(status) && addr == *((u64 *)addr_p)) {
+	acpi_bus_get_device(handle, &adev);
+	if (adev) {
 		*ret_p = handle;
-		status = acpi_bus_get_status_handle(handle, &sta);
-		if (ACPI_SUCCESS(status) && (sta & ACPI_STA_DEVICE_ENABLED))
-			return AE_CTRL_TERMINATE;
+		return AE_CTRL_TERMINATE;
 	}
 	return AE_OK;
 }
 
-acpi_handle acpi_get_child(acpi_handle parent, u64 address)
+static bool acpi_extra_checks_passed(acpi_handle handle, bool is_bridge)
 {
-	void *ret = NULL;
+	unsigned long long sta;
+	acpi_status status;
+
+	status = acpi_bus_get_status_handle(handle, &sta);
+	if (ACPI_FAILURE(status) || !(sta & ACPI_STA_DEVICE_ENABLED))
+		return false;
+
+	if (is_bridge) {
+		void *test = NULL;
+
+		/* Check if this object has at least one child device. */
+		acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,
+				    acpi_dev_present, NULL, NULL, &test);
+		return !!test;
+	}
+	return true;
+}
+
+struct find_child_context {
+	u64 addr;
+	bool is_bridge;
+	acpi_handle ret;
+	bool ret_checked;
+};
+
+static acpi_status do_find_child(acpi_handle handle, u32 lvl_not_used,
+				 void *data, void **not_used)
+{
+	struct find_child_context *context = data;
+	unsigned long long addr;
+	acpi_status status;
 
-	if (!parent)
-		return NULL;
+	status = acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL, &addr);
+	if (ACPI_FAILURE(status) || addr != context->addr)
+		return AE_OK;
 
-	acpi_walk_namespace(ACPI_TYPE_DEVICE, parent, 1, NULL,
-			    do_acpi_find_child, &address, &ret);
-	return (acpi_handle)ret;
+	if (!context->ret) {
+		/* This is the first matching object.  Save its handle. */
+		context->ret = handle;
+		return AE_OK;
+	}
+	/*
+	 * There is more than one matching object with the same _ADR value.
+	 * That really is unexpected, so we are kind of beyond the scope of the
+	 * spec here.  We have to choose which one to return, though.
+	 *
+	 * First, check if the previously found object is good enough and return
+	 * its handle if so.  Second, check the same for the object that we've
+	 * just found.
+	 */
+	if (!context->ret_checked) {
+		if (acpi_extra_checks_passed(context->ret, context->is_bridge))
+			return AE_CTRL_TERMINATE;
+		else
+			context->ret_checked = true;
+	}
+	if (acpi_extra_checks_passed(handle, context->is_bridge)) {
+		context->ret = handle;
+		return AE_CTRL_TERMINATE;
+	}
+	return AE_OK;
+}
+
+acpi_handle acpi_find_child(acpi_handle parent, u64 addr, bool is_bridge)
+{
+	if (parent) {
+		struct find_child_context context = {
+			.addr = addr,
+			.is_bridge = is_bridge,
+		};
+
+		acpi_walk_namespace(ACPI_TYPE_DEVICE, parent, 1, do_find_child,
+				    NULL, &context, NULL);
+		return context.ret;
+	}
+	return NULL;
 }
-EXPORT_SYMBOL(acpi_get_child);
+EXPORT_SYMBOL_GPL(acpi_find_child);
 
 int acpi_bind_one(struct device *dev, acpi_handle handle)
 {

commit 007ccfcf89401e764c33965b739310d86a94626d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 6 14:32:54 2013 +0200

    ACPI: Drop physical_node_id_bitmap from struct acpi_device
    
    The physical_node_id_bitmap in struct acpi_device is only used for
    looking up the first currently unused dependent phyiscal node ID
    by acpi_bind_one().  It is not really necessary, however, because
    acpi_bind_one() walks the entire physical_node_list of the given
    device object for sanity checking anyway and if that list is always
    sorted by node_id, it is straightforward to find the first gap
    between the currently used node IDs and use that number as the ID
    of the new list node.
    
    This also removes the artificial limit of the maximum number of
    dependent physical devices per ACPI device object, which now depends
    only on the capacity of unsigend int.  As a result, it fixes a
    regression introduced by commit e2ff394 (ACPI / memhotplug: Bind
    removable memory blocks to ACPI device nodes) that caused
    acpi_memory_enable_device() to fail when the number of 128 MB blocks
    within one removable memory module was greater than 32.
    
    Reported-and-tested-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Reviewed-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index f68095756fb7..17e15d11bd39 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -31,6 +31,7 @@ static LIST_HEAD(bus_type_list);
 static DECLARE_RWSEM(bus_type_sem);
 
 #define PHYSICAL_NODE_STRING "physical_node"
+#define PHYSICAL_NODE_NAME_SIZE (sizeof(PHYSICAL_NODE_STRING) + 10)
 
 int register_acpi_bus_type(struct acpi_bus_type *type)
 {
@@ -112,7 +113,9 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 	struct acpi_device *acpi_dev;
 	acpi_status status;
 	struct acpi_device_physical_node *physical_node, *pn;
-	char physical_node_name[sizeof(PHYSICAL_NODE_STRING) + 2];
+	char physical_node_name[PHYSICAL_NODE_NAME_SIZE];
+	struct list_head *physnode_list;
+	unsigned int node_id;
 	int retval = -EINVAL;
 
 	if (ACPI_HANDLE(dev)) {
@@ -139,25 +142,27 @@ int acpi_bind_one(struct device *dev, acpi_handle handle)
 
 	mutex_lock(&acpi_dev->physical_node_lock);
 
-	/* Sanity check. */
-	list_for_each_entry(pn, &acpi_dev->physical_node_list, node)
+	/*
+	 * Keep the list sorted by node_id so that the IDs of removed nodes can
+	 * be recycled easily.
+	 */
+	physnode_list = &acpi_dev->physical_node_list;
+	node_id = 0;
+	list_for_each_entry(pn, &acpi_dev->physical_node_list, node) {
+		/* Sanity check. */
 		if (pn->dev == dev) {
 			dev_warn(dev, "Already associated with ACPI node\n");
 			goto err_free;
 		}
-
-	/* allocate physical node id according to physical_node_id_bitmap */
-	physical_node->node_id =
-		find_first_zero_bit(acpi_dev->physical_node_id_bitmap,
-		ACPI_MAX_PHYSICAL_NODE);
-	if (physical_node->node_id >= ACPI_MAX_PHYSICAL_NODE) {
-		retval = -ENOSPC;
-		goto err_free;
+		if (pn->node_id == node_id) {
+			physnode_list = &pn->node;
+			node_id++;
+		}
 	}
 
-	set_bit(physical_node->node_id, acpi_dev->physical_node_id_bitmap);
+	physical_node->node_id = node_id;
 	physical_node->dev = dev;
-	list_add_tail(&physical_node->node, &acpi_dev->physical_node_list);
+	list_add(&physical_node->node, physnode_list);
 	acpi_dev->physical_node_count++;
 
 	mutex_unlock(&acpi_dev->physical_node_lock);
@@ -208,7 +213,7 @@ int acpi_unbind_one(struct device *dev)
 
 	mutex_lock(&acpi_dev->physical_node_lock);
 	list_for_each_safe(node, next, &acpi_dev->physical_node_list) {
-		char physical_node_name[sizeof(PHYSICAL_NODE_STRING) + 2];
+		char physical_node_name[PHYSICAL_NODE_NAME_SIZE];
 
 		entry = list_entry(node, struct acpi_device_physical_node,
 			node);
@@ -216,7 +221,6 @@ int acpi_unbind_one(struct device *dev)
 			continue;
 
 		list_del(node);
-		clear_bit(entry->node_id, acpi_dev->physical_node_id_bitmap);
 
 		acpi_dev->physical_node_count--;
 

commit bdc8f09685a25a12f2f5282f56672ba663ecb88c
Merge: f4c9f4023899 eff9a4b62b14
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 28 13:00:38 2013 +0200

    Merge branch 'acpi-assorted'
    
    * acpi-assorted:
      ACPI / EC: Add HP Folio 13 to ec_dmi_table in order to skip DSDT scan
      ACPI: Add CMOS RTC Operation Region handler support
      ACPI: Remove unused flags in acpi_device_flags
      ACPI: Remove useless initializers
      ACPI / battery: Make sure all spaces are in correct places
      ACPI: add _STA evaluation at do_acpi_find_child()
      ACPI / EC: access user space with get_user()/put_user()

commit c7d9ca90aa9497f0b6e301ec67c52dd4b57a7852
Author: Jeff Wu <zlinuxkernel@gmail.com>
Date:   Wed May 29 06:31:30 2013 +0000

    ACPI: add _STA evaluation at do_acpi_find_child()
    
    Once do_acpi_find_child() has found the first matching handle, it
    makes the acpi_get_child() loop stop and return that handle.  On some
    platforms, though, there are multiple devices with the same value of
    "_ADR" in the same namespace scope, and if one of them is enabled,
    the others will be disabled.  For example:
    
     Address : 0x1FFFF ; path : SB_PCI0.SATA.DEV0
     Address : 0x1FFFF ; path : SB_PCI0.SATA.DEV1
     Address : 0x1FFFF ; path : SB_PCI0.SATA.DEV2
    
    If DEV0 and DEV1 are disabled and DEV2 is enabled, the handle of DEV2
    should be returned, but actually the function always returns the
    handle of DEV0.
    
    To address that issue, make do_acpi_find_child() evaluate _STA to
    check the device status.  If a matching device object exists, but is
    disabled, acpi_get_child() will continue to walk the namespace in the
    hope of finding an enabled one.  If one is found, its handle will be
    returned, but otherwise the function will return the handle of the
    disabled object found before (in case it is enabled going forward).
    
    [rjw: Changelog]
    Signed-off-by: Jeff Wu <zlinuxkernel@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 40a84cc6740c..51ca764cffea 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -81,13 +81,15 @@ static struct acpi_bus_type *acpi_get_bus_type(struct device *dev)
 static acpi_status do_acpi_find_child(acpi_handle handle, u32 lvl_not_used,
 				      void *addr_p, void **ret_p)
 {
-	unsigned long long addr;
+	unsigned long long addr, sta;
 	acpi_status status;
 
 	status = acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL, &addr);
 	if (ACPI_SUCCESS(status) && addr == *((u64 *)addr_p)) {
 		*ret_p = handle;
-		return AE_CTRL_TERMINATE;
+		status = acpi_bus_get_status_handle(handle, &sta);
+		if (ACPI_SUCCESS(status) && (sta & ACPI_STA_DEVICE_ENABLED))
+			return AE_CTRL_TERMINATE;
 	}
 	return AE_OK;
 }

commit ac212b6980d8d5eda705864fc5a8ecddc6d6eacc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 3 00:26:22 2013 +0200

    ACPI / processor: Use common hotplug infrastructure
    
    Split the ACPI processor driver into two parts, one that is
    non-modular, resides in the ACPI core and handles the enumeration
    and hotplug of processors and one that implements the rest of the
    existing processor driver functionality.
    
    The non-modular part uses an ACPI scan handler object to enumerate
    processors on the basis of information provided by the ACPI namespace
    and to hook up with the common ACPI hotplug infrastructure.  It also
    populates the ACPI handle of each processor device having a
    corresponding object in the ACPI namespace, which allows the driver
    proper to bind to those devices, and makes the driver bind to them
    if it is readily available (i.e. loaded) when the scan handler's
    .attach() routine is running.
    
    There are a few reasons to make this change.
    
    First, switching the ACPI processor driver to using the common ACPI
    hotplug infrastructure reduces code duplication and size considerably,
    even though a new file is created along with a header comment etc.
    
    Second, since the common hotplug code attempts to offline devices
    before starting the (non-reversible) removal procedure, it will abort
    (and possibly roll back) hot-remove operations involving processors
    if cpu_down() returns an error code for one of them instead of
    continuing them blindly (if /sys/firmware/acpi/hotplug/force_remove
    is unset).  That is a more desirable behavior than what the current
    code does.
    
    Finally, the separation of the scan/hotplug part from the driver
    proper makes it possible to simplify the driver's .remove() routine,
    because it doesn't need to worry about the possible cleanup related
    to processor removal any more (the scan/hotplug part is responsible
    for that now) and can handle device removal and driver removal
    symmetricaly (i.e. as appropriate).
    
    Some user-visible changes in sysfs are made (for example, the
    'sysdev' link from the ACPI device node to the processor device's
    directory is gone and a 'physical_node' link is present instead
    and a corresponding 'firmware_node' is present in the processor
    device's directory, the processor driver is now visible under
    /sys/bus/cpu/drivers/ and bound to the processor device), but
    that shouldn't affect the functionality that users care about
    (frequency scaling, C-states and thermal management).
    
    Tested on my venerable Toshiba Portege R500.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 40a84cc6740c..9783f400d857 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -105,7 +105,7 @@ acpi_handle acpi_get_child(acpi_handle parent, u64 address)
 }
 EXPORT_SYMBOL(acpi_get_child);
 
-static int acpi_bind_one(struct device *dev, acpi_handle handle)
+int acpi_bind_one(struct device *dev, acpi_handle handle)
 {
 	struct acpi_device *acpi_dev;
 	acpi_status status;
@@ -188,8 +188,9 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 	kfree(physical_node);
 	goto err;
 }
+EXPORT_SYMBOL_GPL(acpi_bind_one);
 
-static int acpi_unbind_one(struct device *dev)
+int acpi_unbind_one(struct device *dev)
 {
 	struct acpi_device_physical_node *entry;
 	struct acpi_device *acpi_dev;
@@ -238,6 +239,7 @@ static int acpi_unbind_one(struct device *dev)
 	dev_err(dev, "Oops, 'acpi_handle' corrupt\n");
 	return -EINVAL;
 }
+EXPORT_SYMBOL_GPL(acpi_unbind_one);
 
 static int acpi_platform_notify(struct device *dev)
 {

commit 924144818cf0edc5d9d70d3a44e7cbbf4544796c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Mar 3 22:35:44 2013 +0100

    ACPI / glue: Drop .find_bridge() callback from struct acpi_bus_type
    
    After PCI and USB have stopped using the .find_bridge() callback in
    struct acpi_bus_type, the only remaining user of it is SATA, but SATA
    only pretends to be a user, because it points that callback to a stub
    always returning -ENODEV.
    
    For this reason, drop the SATA's dummy .find_bridge() callback and
    remove .find_bridge(), which is not used any more, from struct
    acpi_bus_type entirely.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index b94d14721af3..40a84cc6740c 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -78,22 +78,6 @@ static struct acpi_bus_type *acpi_get_bus_type(struct device *dev)
 	return ret;
 }
 
-static int acpi_find_bridge_device(struct device *dev, acpi_handle * handle)
-{
-	struct acpi_bus_type *tmp;
-	int ret = -ENODEV;
-
-	down_read(&bus_type_sem);
-	list_for_each_entry(tmp, &bus_type_list, list) {
-		if (tmp->find_bridge && !tmp->find_bridge(dev, handle)) {
-			ret = 0;
-			break;
-		}
-	}
-	up_read(&bus_type_sem);
-	return ret;
-}
-
 static acpi_status do_acpi_find_child(acpi_handle handle, u32 lvl_not_used,
 				      void *addr_p, void **ret_p)
 {
@@ -262,15 +246,7 @@ static int acpi_platform_notify(struct device *dev)
 	int ret;
 
 	ret = acpi_bind_one(dev, NULL);
-	if (ret) {
-		if (!type) {
-			ret = acpi_find_bridge_device(dev, &handle);
-			if (!ret)
-				ret = acpi_bind_one(dev, handle);
-
-			goto out;
-		}
-
+	if (ret && type) {
 		ret = type->find_device(dev, &handle);
 		if (ret) {
 			DBG("Unable to get handle for %s\n", dev_name(dev));

commit 53540098b23c3884b4a0b4f220b9d977bc496af3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Mar 3 22:35:20 2013 +0100

    ACPI / glue: Add .match() callback to struct acpi_bus_type
    
    USB uses the .find_bridge() callback from struct acpi_bus_type
    incorrectly, because as a result of the way it is used by USB every
    device in the system that doesn't have a bus type or parent is
    passed to usb_acpi_find_device() for inspection.
    
    What USB actually needs, though, is to call usb_acpi_find_device()
    for USB ports that don't have a bus type defined, but have
    usb_port_device_type as their device type, as well as for USB
    devices.
    
    To fix that replace the struct bus_type pointer in struct
    acpi_bus_type used for matching devices to specific subsystems
    with a .match() callback to be used for this purpose and update
    the users of struct acpi_bus_type, including USB, accordingly.
    Define the .match() callback routine for USB, usb_acpi_bus_match(),
    in such a way that it will cover both USB devices and USB ports
    and remove the now redundant .find_bridge() callback pointer from
    usb_acpi_bus.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index ef6f155469b5..b94d14721af3 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -36,12 +36,11 @@ int register_acpi_bus_type(struct acpi_bus_type *type)
 {
 	if (acpi_disabled)
 		return -ENODEV;
-	if (type && type->bus && type->find_device) {
+	if (type && type->match && type->find_device) {
 		down_write(&bus_type_sem);
 		list_add_tail(&type->list, &bus_type_list);
 		up_write(&bus_type_sem);
-		printk(KERN_INFO PREFIX "bus type %s registered\n",
-		       type->bus->name);
+		printk(KERN_INFO PREFIX "bus type %s registered\n", type->name);
 		return 0;
 	}
 	return -ENODEV;
@@ -56,24 +55,21 @@ int unregister_acpi_bus_type(struct acpi_bus_type *type)
 		down_write(&bus_type_sem);
 		list_del_init(&type->list);
 		up_write(&bus_type_sem);
-		printk(KERN_INFO PREFIX "ACPI bus type %s unregistered\n",
-		       type->bus->name);
+		printk(KERN_INFO PREFIX "bus type %s unregistered\n",
+		       type->name);
 		return 0;
 	}
 	return -ENODEV;
 }
 EXPORT_SYMBOL_GPL(unregister_acpi_bus_type);
 
-static struct acpi_bus_type *acpi_get_bus_type(struct bus_type *type)
+static struct acpi_bus_type *acpi_get_bus_type(struct device *dev)
 {
 	struct acpi_bus_type *tmp, *ret = NULL;
 
-	if (!type)
-		return NULL;
-
 	down_read(&bus_type_sem);
 	list_for_each_entry(tmp, &bus_type_list, list) {
-		if (tmp->bus == type) {
+		if (tmp->match(dev)) {
 			ret = tmp;
 			break;
 		}
@@ -261,26 +257,17 @@ static int acpi_unbind_one(struct device *dev)
 
 static int acpi_platform_notify(struct device *dev)
 {
-	struct acpi_bus_type *type;
+	struct acpi_bus_type *type = acpi_get_bus_type(dev);
 	acpi_handle handle;
 	int ret;
 
 	ret = acpi_bind_one(dev, NULL);
-	if (ret && (!dev->bus || !dev->parent)) {
-		/* bridge devices genernally haven't bus or parent */
-		ret = acpi_find_bridge_device(dev, &handle);
-		if (!ret) {
-			ret = acpi_bind_one(dev, handle);
-			if (ret)
-				goto out;
-		}
-	}
-
-	type = acpi_get_bus_type(dev->bus);
 	if (ret) {
-		if (!type || !type->find_device) {
-			DBG("No ACPI bus support for %s\n", dev_name(dev));
-			ret = -EINVAL;
+		if (!type) {
+			ret = acpi_find_bridge_device(dev, &handle);
+			if (!ret)
+				ret = acpi_bind_one(dev, handle);
+
 			goto out;
 		}
 
@@ -316,7 +303,7 @@ static int acpi_platform_notify_remove(struct device *dev)
 {
 	struct acpi_bus_type *type;
 
-	type = acpi_get_bus_type(dev->bus);
+	type = acpi_get_bus_type(dev);
 	if (type && type->cleanup)
 		type->cleanup(dev);
 

commit a68d35323b091f51e0957313f0f871f187879143
Merge: e8f71df72333 66f2fda93b67
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 15 13:58:43 2013 +0100

    Merge branch 'acpi-assorted'
    
    * acpi-assorted:
      ACPI: Add DMI entry for Sony VGN-FW41E_H
      ACPI: fix obsolete comment in custom_method.c
      ACPI / thermal: Use mode to enable/disable kernel thermal processing
      ACPI thermal: remove unnecessary newline from exception message
      ACPI sysfs: remove unnecessary newline from exception
      ACPI video: remove unnecessary newline from error messages
      ACPI: SRAT: report non-volatile memory in debug
      ACPI: Rework acpi_get_child() to be more efficient

commit 59893298947e0ca28cbaba6d02b9973181f14eea
Merge: 836dc9e3fbba 0613e1f7fd98
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Feb 11 13:20:02 2013 +0100

    Merge branch 'acpi-scan'
    
    * acpi-scan: (30 commits)
      ACPI / scan: Fix acpi_bus_get_device() check in acpi_match_device()
      ACPI / scan: Make namespace scanning and trimming mutually exclusive
      ACPI / scan: Make it clear that acpi_bus_trim() cannot fail
      ACPI / scan: Drop acpi_bus_add() and use acpi_bus_scan() instead
      ACPI: update ej_event interface to take acpi_device
      ACPI / scan: Add second pass to acpi_bus_trim()
      ACPI / scan: Change the implementation of acpi_bus_trim()
      ACPI / scan: Drop the second argument of acpi_bus_trim()
      ACPI / scan: Drop the second argument of acpi_device_unregister()
      ACPI: Remove the ops field from struct acpi_device
      ACPI: remove unused acpi_op_bind and acpi_op_unbind
      ACPI / scan: Fix check of device_attach() return value.
      ACPI / scan: Treat power resources in a special way
      ACPI: Remove unused struct acpi_pci_root.id member
      ACPI: Drop ACPI device .bind() and .unbind() callbacks
      ACPI / PCI: Move the _PRT setup and cleanup code to pci-acpi.c
      ACPI / PCI: Rework the setup and cleanup of device wakeup
      ACPI: Add .setup() and .cleanup() callbacks to struct acpi_bus_type
      ACPI: Make acpi_bus_scan() and acpi_bus_add() take only one argument
      ACPI: Replace ACPI device add_type field with a match_driver flag
      ...

commit 33f767d767e9a684e9cd60704d4c049a2014c8d5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 10 13:13:49 2013 +0100

    ACPI: Rework acpi_get_child() to be more efficient
    
    Observe that acpi_get_child() doesn't need to use the helper
    struct acpi_find_child structure and change it to work without it.
    Also, using acpi_get_object_info() to get the output of _ADR for the
    given device is overkill, because that function does much more than
    just evaluating _ADR (let alone the additional memory allocation
    done by it).
    
    Moreover, acpi_get_child() doesn't need to loop any more once it has
    found a matching handle, so make it stop in that case.  To prevent
    the results from changing, make it use do_acpi_find_child() as
    a post-order callback.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 35da18113216..e9e486f79b35 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -95,40 +95,31 @@ static int acpi_find_bridge_device(struct device *dev, acpi_handle * handle)
 	return ret;
 }
 
-/* Get device's handler per its address under its parent */
-struct acpi_find_child {
-	acpi_handle handle;
-	u64 address;
-};
-
-static acpi_status
-do_acpi_find_child(acpi_handle handle, u32 lvl, void *context, void **rv)
+static acpi_status do_acpi_find_child(acpi_handle handle, u32 lvl_not_used,
+				      void *addr_p, void **ret_p)
 {
+	unsigned long long addr;
 	acpi_status status;
-	struct acpi_device_info *info;
-	struct acpi_find_child *find = context;
-
-	status = acpi_get_object_info(handle, &info);
-	if (ACPI_SUCCESS(status)) {
-		if ((info->address == find->address)
-			&& (info->valid & ACPI_VALID_ADR))
-			find->handle = handle;
-		kfree(info);
+
+	status = acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL, &addr);
+	if (ACPI_SUCCESS(status) && addr == *((u64 *)addr_p)) {
+		*ret_p = handle;
+		return AE_CTRL_TERMINATE;
 	}
 	return AE_OK;
 }
 
 acpi_handle acpi_get_child(acpi_handle parent, u64 address)
 {
-	struct acpi_find_child find = { NULL, address };
+	void *ret = NULL;
 
 	if (!parent)
 		return NULL;
-	acpi_walk_namespace(ACPI_TYPE_DEVICE, parent,
-			    1, do_acpi_find_child, NULL, &find, NULL);
-	return find.handle;
-}
 
+	acpi_walk_namespace(ACPI_TYPE_DEVICE, parent, 1, NULL,
+			    do_acpi_find_child, &address, &ret);
+	return (acpi_handle)ret;
+}
 EXPORT_SYMBOL(acpi_get_child);
 
 static int acpi_bind_one(struct device *dev, acpi_handle handle)

commit a412a11d6a24aebb6a898ed5d4e1c0725b638da3
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Jan 12 14:00:06 2013 +0100

    ACPI / glue: Fix build with ACPI_GLUE_DEBUG set
    
    If ACPI_GLUE_DEBUG is different from 0 (setting this requires a
    manual change of glue.c), build breaks because of a leftover
    reference to dev->acpi_handle in acpi_platform_notify().  Fix this
    by using ACPI_HANDLE(dev) instead as appropriate.
    
    [rjw: Subject and changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 95af6f674a6c..35da18113216 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -297,7 +297,7 @@ static int acpi_platform_notify(struct device *dev)
 	if (!ret) {
 		struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 
-		acpi_get_name(dev->acpi_handle, ACPI_FULL_PATHNAME, &buffer);
+		acpi_get_name(ACPI_HANDLE(dev), ACPI_FULL_PATHNAME, &buffer);
 		DBG("Device %s -> %s\n", dev_name(dev), (char *)buffer.pointer);
 		kfree(buffer.pointer);
 	} else

commit 23415eb5233eb3c1939c4cb7d6235af98a3a2955
Author: Joe Perches <joe@perches.com>
Date:   Tue Dec 18 06:31:30 2012 +0000

    ACPI / glue: Update DBG macro to include KERN_DEBUG
    
    Currently these DBG statements are emitted at KERN_DEFAULT.
    Change the macro to emit at KERN_DEBUG.
    
    This can help avoid unexpected message interleaving.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 01551840d236..95af6f674a6c 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -18,9 +18,14 @@
 
 #define ACPI_GLUE_DEBUG	0
 #if ACPI_GLUE_DEBUG
-#define DBG(x...) printk(PREFIX x)
+#define DBG(fmt, ...)						\
+	printk(KERN_DEBUG PREFIX fmt, ##__VA_ARGS__)
 #else
-#define DBG(x...) do { } while(0)
+#define DBG(fmt, ...)						\
+do {								\
+	if (0)							\
+		printk(KERN_DEBUG PREFIX fmt, ##__VA_ARGS__);	\
+} while (0)
 #endif
 static LIST_HEAD(bus_type_list);
 static DECLARE_RWSEM(bus_type_sem);

commit 11909ca1cf614f9396b17d366f9e3cfcba7b4a99
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 23 00:02:13 2012 +0100

    ACPI: Add .setup() and .cleanup() callbacks to struct acpi_bus_type
    
    Add two new callbacks,.setup() and .cleanup(), struct acpi_bus_type
    and modify acpi_platform_notify() to call .setup() after executing
    acpi_bind_one() successfully and acpi_platform_notify_remove() to
    call .cleanup() before running acpi_unbind_one().  This will allow
    the users of struct acpi_bus_type, PCI in particular, to specify
    operations to be executed right after the given device has been
    associated with a companion struct acpi_device and right before
    it's going to be detached from that companion, respectively.
    
    The main motivation is to be able to get rid of acpi_pci_bind()
    and acpi_pci_unbind(), which are horrible horrible stuff.  [In short,
    there are three problems with them: The way they populate the .bind()
    and .unbind() callbacks of ACPI devices is rather less than
    straightforward, they require special hotplug-specific paths to be
    present in the ACPI namespace scanning code and by the time
    acpi_pci_unbind() is called the PCI device object in question may
    not exist any more.]
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 01551840d236..ac00b882e75d 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -63,6 +63,9 @@ static struct acpi_bus_type *acpi_get_bus_type(struct bus_type *type)
 {
 	struct acpi_bus_type *tmp, *ret = NULL;
 
+	if (!type)
+		return NULL;
+
 	down_read(&bus_type_sem);
 	list_for_each_entry(tmp, &bus_type_list, list) {
 		if (tmp->bus == type) {
@@ -264,28 +267,39 @@ static int acpi_platform_notify(struct device *dev)
 {
 	struct acpi_bus_type *type;
 	acpi_handle handle;
-	int ret = -EINVAL;
+	int ret;
 
 	ret = acpi_bind_one(dev, NULL);
-	if (!ret)
-		goto out;
-
-	if (!dev->bus || !dev->parent) {
+	if (ret && (!dev->bus || !dev->parent)) {
 		/* bridge devices genernally haven't bus or parent */
 		ret = acpi_find_bridge_device(dev, &handle);
-		goto end;
+		if (!ret) {
+			ret = acpi_bind_one(dev, handle);
+			if (ret)
+				goto out;
+		}
 	}
+
 	type = acpi_get_bus_type(dev->bus);
-	if (!type) {
-		DBG("No ACPI bus support for %s\n", dev_name(dev));
-		ret = -EINVAL;
-		goto end;
+	if (ret) {
+		if (!type || !type->find_device) {
+			DBG("No ACPI bus support for %s\n", dev_name(dev));
+			ret = -EINVAL;
+			goto out;
+		}
+
+		ret = type->find_device(dev, &handle);
+		if (ret) {
+			DBG("Unable to get handle for %s\n", dev_name(dev));
+			goto out;
+		}
+		ret = acpi_bind_one(dev, handle);
+		if (ret)
+			goto out;
 	}
-	if ((ret = type->find_device(dev, &handle)) != 0)
-		DBG("Can't get handler for %s\n", dev_name(dev));
- end:
-	if (!ret)
-		acpi_bind_one(dev, handle);
+
+	if (type && type->setup)
+		type->setup(dev);
 
  out:
 #if ACPI_GLUE_DEBUG
@@ -304,6 +318,12 @@ static int acpi_platform_notify(struct device *dev)
 
 static int acpi_platform_notify_remove(struct device *dev)
 {
+	struct acpi_bus_type *type;
+
+	type = acpi_get_bus_type(dev->bus);
+	if (type && type->cleanup)
+		type->cleanup(dev);
+
 	acpi_unbind_one(dev);
 	return 0;
 }

commit 95f8a082b9b1ead0c2859f2a7b1ac91ff63d8765
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Nov 21 00:21:50 2012 +0100

    ACPI / driver core: Introduce struct acpi_dev_node and related macros
    
    To avoid adding an ACPI handle pointer to struct device on
    architectures that don't use ACPI, or generally when CONFIG_ACPI is
    not set, in which cases that pointer is useless, define struct
    acpi_dev_node that will contain the handle pointer if CONFIG_ACPI is
    set and will be empty otherwise and use it to represent the ACPI
    device node field in struct device.
    
    In addition to that define macros for reading and setting the ACPI
    handle of a device that don't generate code when CONFIG_ACPI is
    unset.  Modify the ACPI subsystem to use those macros instead of
    referring to the given device's ACPI handle directly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 3e75d6e5a469..01551840d236 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -134,12 +134,12 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 	char physical_node_name[sizeof(PHYSICAL_NODE_STRING) + 2];
 	int retval = -EINVAL;
 
-	if (dev->acpi_handle) {
+	if (ACPI_HANDLE(dev)) {
 		if (handle) {
 			dev_warn(dev, "ACPI handle is already set\n");
 			return -EINVAL;
 		} else {
-			handle = dev->acpi_handle;
+			handle = ACPI_HANDLE(dev);
 		}
 	}
 	if (!handle)
@@ -181,8 +181,8 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 
 	mutex_unlock(&acpi_dev->physical_node_lock);
 
-	if (!dev->acpi_handle)
-		dev->acpi_handle = handle;
+	if (!ACPI_HANDLE(dev))
+		ACPI_HANDLE_SET(dev, acpi_dev->handle);
 
 	if (!physical_node->node_id)
 		strcpy(physical_node_name, PHYSICAL_NODE_STRING);
@@ -200,7 +200,7 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 	return 0;
 
  err:
-	dev->acpi_handle = NULL;
+	ACPI_HANDLE_SET(dev, NULL);
 	put_device(dev);
 	return retval;
 
@@ -217,10 +217,10 @@ static int acpi_unbind_one(struct device *dev)
 	acpi_status status;
 	struct list_head *node, *next;
 
-	if (!dev->acpi_handle)
+	if (!ACPI_HANDLE(dev))
 		return 0;
 
-	status = acpi_bus_get_device(dev->acpi_handle, &acpi_dev);
+	status = acpi_bus_get_device(ACPI_HANDLE(dev), &acpi_dev);
 	if (ACPI_FAILURE(status))
 		goto err;
 
@@ -246,7 +246,7 @@ static int acpi_unbind_one(struct device *dev)
 
 		sysfs_remove_link(&acpi_dev->dev.kobj, physical_node_name);
 		sysfs_remove_link(&dev->kobj, "firmware_node");
-		dev->acpi_handle = NULL;
+		ACPI_HANDLE_SET(dev, NULL);
 		/* acpi_bind_one increase refcnt by one */
 		put_device(dev);
 		kfree(entry);

commit f3fd0c8a7fc1e4f3107a09a75e622781d3007b56
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Nov 21 00:21:39 2012 +0100

    ACPI: Allow ACPI handles of devices to be initialized in advance
    
    Currently, the ACPI handles of devices are initialized from within
    device_add(), by acpi_bind_one() called from acpi_platform_notify()
    which first uses the .find_device() routine provided by the device's
    bus type to find the matching device node in the ACPI namespace.
    This is a source of some computational overhead and, moreover, the
    correctness of the result depends on the implementation of
    .find_device() which is known to fail occasionally for some bus types
    (e.g. PCI).  In some cases, however, the corresponding ACPI device
    node is known already before calling device_add() for the given
    struct device object and the whole .find_device() dance in
    acpi_platform_notify() is then simply unnecessary.
    
    For this reason, make it possible to initialize the ACPI handles of
    devices before calling device_add() for them.  Modify
    acpi_platform_notify() to call acpi_bind_one() in advance to check
    the device's existing ACPI handle and skip the .find_device()
    search if that is successful.  Change acpi_bind_one() accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 2f3849aedc97..3e75d6e5a469 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -130,46 +130,59 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 {
 	struct acpi_device *acpi_dev;
 	acpi_status status;
-	struct acpi_device_physical_node *physical_node;
+	struct acpi_device_physical_node *physical_node, *pn;
 	char physical_node_name[sizeof(PHYSICAL_NODE_STRING) + 2];
 	int retval = -EINVAL;
 
 	if (dev->acpi_handle) {
-		dev_warn(dev, "Drivers changed 'acpi_handle'\n");
-		return -EINVAL;
+		if (handle) {
+			dev_warn(dev, "ACPI handle is already set\n");
+			return -EINVAL;
+		} else {
+			handle = dev->acpi_handle;
+		}
 	}
+	if (!handle)
+		return -EINVAL;
 
 	get_device(dev);
 	status = acpi_bus_get_device(handle, &acpi_dev);
 	if (ACPI_FAILURE(status))
 		goto err;
 
-	physical_node = kzalloc(sizeof(struct acpi_device_physical_node),
-		GFP_KERNEL);
+	physical_node = kzalloc(sizeof(*physical_node), GFP_KERNEL);
 	if (!physical_node) {
 		retval = -ENOMEM;
 		goto err;
 	}
 
 	mutex_lock(&acpi_dev->physical_node_lock);
+
+	/* Sanity check. */
+	list_for_each_entry(pn, &acpi_dev->physical_node_list, node)
+		if (pn->dev == dev) {
+			dev_warn(dev, "Already associated with ACPI node\n");
+			goto err_free;
+		}
+
 	/* allocate physical node id according to physical_node_id_bitmap */
 	physical_node->node_id =
 		find_first_zero_bit(acpi_dev->physical_node_id_bitmap,
 		ACPI_MAX_PHYSICAL_NODE);
 	if (physical_node->node_id >= ACPI_MAX_PHYSICAL_NODE) {
 		retval = -ENOSPC;
-		mutex_unlock(&acpi_dev->physical_node_lock);
-		kfree(physical_node);
-		goto err;
+		goto err_free;
 	}
 
 	set_bit(physical_node->node_id, acpi_dev->physical_node_id_bitmap);
 	physical_node->dev = dev;
 	list_add_tail(&physical_node->node, &acpi_dev->physical_node_list);
 	acpi_dev->physical_node_count++;
+
 	mutex_unlock(&acpi_dev->physical_node_lock);
 
-	dev->acpi_handle = handle;
+	if (!dev->acpi_handle)
+		dev->acpi_handle = handle;
 
 	if (!physical_node->node_id)
 		strcpy(physical_node_name, PHYSICAL_NODE_STRING);
@@ -187,8 +200,14 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 	return 0;
 
  err:
+	dev->acpi_handle = NULL;
 	put_device(dev);
 	return retval;
+
+ err_free:
+	mutex_unlock(&acpi_dev->physical_node_lock);
+	kfree(physical_node);
+	goto err;
 }
 
 static int acpi_unbind_one(struct device *dev)
@@ -247,6 +266,10 @@ static int acpi_platform_notify(struct device *dev)
 	acpi_handle handle;
 	int ret = -EINVAL;
 
+	ret = acpi_bind_one(dev, NULL);
+	if (!ret)
+		goto out;
+
 	if (!dev->bus || !dev->parent) {
 		/* bridge devices genernally haven't bus or parent */
 		ret = acpi_find_bridge_device(dev, &handle);
@@ -260,10 +283,11 @@ static int acpi_platform_notify(struct device *dev)
 	}
 	if ((ret = type->find_device(dev, &handle)) != 0)
 		DBG("Can't get handler for %s\n", dev_name(dev));
-      end:
+ end:
 	if (!ret)
 		acpi_bind_one(dev, handle);
 
+ out:
 #if ACPI_GLUE_DEBUG
 	if (!ret) {
 		struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };

commit 06f64c8f239a47b359c60301914c783b56b32c13
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Oct 31 22:44:33 2012 +0100

    driver core / ACPI: Move ACPI support to core device and driver types
    
    With ACPI 5 we are starting to see devices that don't natively support
    discovery but can be enumerated with the help of the ACPI namespace.
    Typically, these devices can be represented in the Linux device driver
    model as platform devices or some serial bus devices, like SPI or I2C
    devices.
    
    Since we want to re-use existing drivers for those devices, we need a
    way for drivers to specify the ACPI IDs of supported devices, so that
    they can be matched against device nodes in the ACPI namespace.  To
    this end, it is sufficient to add a pointer to an array of supported
    ACPI device IDs, that can be provided by the driver, to struct device.
    
    Moreover, things like ACPI power management need to have access to
    the ACPI handle of each supported device, because that handle is used
    to invoke AML methods associated with the corresponding ACPI device
    node.  The ACPI handles of devices are now stored in the archdata
    member structure of struct device whose definition depends on the
    architecture and includes the ACPI handle only on x86 and ia64. Since
    the pointer to an array of supported ACPI IDs is added to struct
    device_driver in an architecture-independent way, it is logical to
    move the ACPI handle from archdata to struct device itself at the same
    time.  This also makes code more straightforward in some places and
    follows the example of Device Trees that have a poiter to struct
    device_node in there too.
    
    This changeset is based on Mika Westerberg's work.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 08373086cd7e..2f3849aedc97 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -134,7 +134,7 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 	char physical_node_name[sizeof(PHYSICAL_NODE_STRING) + 2];
 	int retval = -EINVAL;
 
-	if (dev->archdata.acpi_handle) {
+	if (dev->acpi_handle) {
 		dev_warn(dev, "Drivers changed 'acpi_handle'\n");
 		return -EINVAL;
 	}
@@ -169,7 +169,7 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 	acpi_dev->physical_node_count++;
 	mutex_unlock(&acpi_dev->physical_node_lock);
 
-	dev->archdata.acpi_handle = handle;
+	dev->acpi_handle = handle;
 
 	if (!physical_node->node_id)
 		strcpy(physical_node_name, PHYSICAL_NODE_STRING);
@@ -198,11 +198,10 @@ static int acpi_unbind_one(struct device *dev)
 	acpi_status status;
 	struct list_head *node, *next;
 
-	if (!dev->archdata.acpi_handle)
+	if (!dev->acpi_handle)
 		return 0;
 
-	status = acpi_bus_get_device(dev->archdata.acpi_handle,
-		&acpi_dev);
+	status = acpi_bus_get_device(dev->acpi_handle, &acpi_dev);
 	if (ACPI_FAILURE(status))
 		goto err;
 
@@ -228,7 +227,7 @@ static int acpi_unbind_one(struct device *dev)
 
 		sysfs_remove_link(&acpi_dev->dev.kobj, physical_node_name);
 		sysfs_remove_link(&dev->kobj, "firmware_node");
-		dev->archdata.acpi_handle = NULL;
+		dev->acpi_handle = NULL;
 		/* acpi_bind_one increase refcnt by one */
 		put_device(dev);
 		kfree(entry);
@@ -269,8 +268,7 @@ static int acpi_platform_notify(struct device *dev)
 	if (!ret) {
 		struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 
-		acpi_get_name(dev->archdata.acpi_handle,
-			      ACPI_FULL_PATHNAME, &buffer);
+		acpi_get_name(dev->acpi_handle, ACPI_FULL_PATHNAME, &buffer);
 		DBG("Device %s -> %s\n", dev_name(dev), (char *)buffer.pointer);
 		kfree(buffer.pointer);
 	} else

commit 2978af545b9a1ed221e23fb24ae4559bec6ad70d
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Tue Oct 23 00:53:58 2012 +0200

    ACPI: Fix memory leak in acpi_bind_one()
    
    Memory is allocated with kzalloc() and assigned to
    'physical_node'. Then 'physical_node->node_id' is initialized with a
    call to 'find_first_zero_bit()', if that results in a value greater
    than ACPI_MAX_PHYSICAL_NODE we'll end up jumping to the 'err:' label
    and there leave the function and let 'physical_node' go out of scope
    and leak the memory we allocated.
    This patch fixes the leak by simply freeing the unused/unneeded memory
    pointed to by 'physical_node' just before we jump to 'err:'.
    
    [rjw: The problem has been introduced by commit 1033f90 (ACPI: Allow
     ACPI binding with USB-3.0 hub), which is new in 3.7-rc.]
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Reviewed-by: Toshi Kani <toshi.kani@hp.com>
    Reviewed-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Acked-by: David Rientjes <rientjes@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index d1a2d74033e9..08373086cd7e 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -159,6 +159,7 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 	if (physical_node->node_id >= ACPI_MAX_PHYSICAL_NODE) {
 		retval = -ENOSPC;
 		mutex_unlock(&acpi_dev->physical_node_lock);
+		kfree(physical_node);
 		goto err;
 	}
 

commit 1033f9041d526dd694e2b2e12744e47c41040c4d
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Fri Aug 17 14:44:09 2012 +0800

    ACPI: Allow ACPI binding with USB-3.0 hub
    
    A USB port's position and connectability can't be identified on some boards
    via USB hub registers. ACPI _UPC and _PLD can help to resolve this issue
    and so it is necessary to bind USB with ACPI. This patch is to allow ACPI
    binding with USB-3.0 hub.
    
    Current ACPI only can bind one struct-device to one ACPI device node.
    This can not work with USB-3.0 hub, because the USB-3.0 hub has two logical
    devices. Each works for USB-2.0 and USB-3.0 devices. In the Linux USB subsystem,
    those two logical hubs are treated as two seperate devices that have two struct
    devices. But in the ACPI DSDT, these two logical hubs share one ACPI device
    node. So there is a requirement to bind multi struct-devices to one ACPI
    device node. This patch is to resolve such problem.
    
    Following is the ACPI device nodes' description under xhci hcd.
    
    Device (XHC)
                Device (RHUB)
                    Device (HSP1)
                    Device (HSP2)
                    Device (HSP3)
                    Device (HSP4)
                    Device (SSP1)
                    Device (SSP2)
                    Device (SSP3)
                    Device (SSP4)
    
    Topology in the Linux
    
            device XHC
               USB-2.0 logical hub    USB-3.0 logical hub
                    HSP1                    SSP1
                    HSP2                    SSP2
                    HSP3                    SSP3
                    HSP4                    SSP4
    
    This patch also modifies the output of /proc/acpi/wakeup. One ACPI node
    can be associated with multiple devices:
    
    XHC             S4      *enabled        pci:0000:00:14.0
    RHUB    S0      disabled        usb:usb1
                            disabled        usb:usb2
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Acked-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 243ee85e4d2e..d1a2d74033e9 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -25,6 +25,8 @@
 static LIST_HEAD(bus_type_list);
 static DECLARE_RWSEM(bus_type_sem);
 
+#define PHYSICAL_NODE_STRING "physical_node"
+
 int register_acpi_bus_type(struct acpi_bus_type *type)
 {
 	if (acpi_disabled)
@@ -124,84 +126,119 @@ acpi_handle acpi_get_child(acpi_handle parent, u64 address)
 
 EXPORT_SYMBOL(acpi_get_child);
 
-/* Link ACPI devices with physical devices */
-static void acpi_glue_data_handler(acpi_handle handle,
-				   void *context)
-{
-	/* we provide an empty handler */
-}
-
-/* Note: a success call will increase reference count by one */
-struct device *acpi_get_physical_device(acpi_handle handle)
-{
-	acpi_status status;
-	struct device *dev;
-
-	status = acpi_get_data(handle, acpi_glue_data_handler, (void **)&dev);
-	if (ACPI_SUCCESS(status))
-		return get_device(dev);
-	return NULL;
-}
-
-EXPORT_SYMBOL(acpi_get_physical_device);
-
 static int acpi_bind_one(struct device *dev, acpi_handle handle)
 {
 	struct acpi_device *acpi_dev;
 	acpi_status status;
+	struct acpi_device_physical_node *physical_node;
+	char physical_node_name[sizeof(PHYSICAL_NODE_STRING) + 2];
+	int retval = -EINVAL;
 
 	if (dev->archdata.acpi_handle) {
 		dev_warn(dev, "Drivers changed 'acpi_handle'\n");
 		return -EINVAL;
 	}
+
 	get_device(dev);
-	status = acpi_attach_data(handle, acpi_glue_data_handler, dev);
-	if (ACPI_FAILURE(status)) {
-		put_device(dev);
-		return -EINVAL;
+	status = acpi_bus_get_device(handle, &acpi_dev);
+	if (ACPI_FAILURE(status))
+		goto err;
+
+	physical_node = kzalloc(sizeof(struct acpi_device_physical_node),
+		GFP_KERNEL);
+	if (!physical_node) {
+		retval = -ENOMEM;
+		goto err;
 	}
-	dev->archdata.acpi_handle = handle;
 
-	status = acpi_bus_get_device(handle, &acpi_dev);
-	if (!ACPI_FAILURE(status)) {
-		int ret;
-
-		ret = sysfs_create_link(&dev->kobj, &acpi_dev->dev.kobj,
-				"firmware_node");
-		ret = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,
-				"physical_node");
-		if (acpi_dev->wakeup.flags.valid)
-			device_set_wakeup_capable(dev, true);
+	mutex_lock(&acpi_dev->physical_node_lock);
+	/* allocate physical node id according to physical_node_id_bitmap */
+	physical_node->node_id =
+		find_first_zero_bit(acpi_dev->physical_node_id_bitmap,
+		ACPI_MAX_PHYSICAL_NODE);
+	if (physical_node->node_id >= ACPI_MAX_PHYSICAL_NODE) {
+		retval = -ENOSPC;
+		mutex_unlock(&acpi_dev->physical_node_lock);
+		goto err;
 	}
 
+	set_bit(physical_node->node_id, acpi_dev->physical_node_id_bitmap);
+	physical_node->dev = dev;
+	list_add_tail(&physical_node->node, &acpi_dev->physical_node_list);
+	acpi_dev->physical_node_count++;
+	mutex_unlock(&acpi_dev->physical_node_lock);
+
+	dev->archdata.acpi_handle = handle;
+
+	if (!physical_node->node_id)
+		strcpy(physical_node_name, PHYSICAL_NODE_STRING);
+	else
+		sprintf(physical_node_name,
+			"physical_node%d", physical_node->node_id);
+	retval = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,
+			physical_node_name);
+	retval = sysfs_create_link(&dev->kobj, &acpi_dev->dev.kobj,
+		"firmware_node");
+
+	if (acpi_dev->wakeup.flags.valid)
+		device_set_wakeup_capable(dev, true);
+
 	return 0;
+
+ err:
+	put_device(dev);
+	return retval;
 }
 
 static int acpi_unbind_one(struct device *dev)
 {
+	struct acpi_device_physical_node *entry;
+	struct acpi_device *acpi_dev;
+	acpi_status status;
+	struct list_head *node, *next;
+
 	if (!dev->archdata.acpi_handle)
 		return 0;
-	if (dev == acpi_get_physical_device(dev->archdata.acpi_handle)) {
-		struct acpi_device *acpi_dev;
 
-		/* acpi_get_physical_device increase refcnt by one */
-		put_device(dev);
+	status = acpi_bus_get_device(dev->archdata.acpi_handle,
+		&acpi_dev);
+	if (ACPI_FAILURE(status))
+		goto err;
 
-		if (!acpi_bus_get_device(dev->archdata.acpi_handle,
-					&acpi_dev)) {
-			sysfs_remove_link(&dev->kobj, "firmware_node");
-			sysfs_remove_link(&acpi_dev->dev.kobj, "physical_node");
-		}
+	mutex_lock(&acpi_dev->physical_node_lock);
+	list_for_each_safe(node, next, &acpi_dev->physical_node_list) {
+		char physical_node_name[sizeof(PHYSICAL_NODE_STRING) + 2];
+
+		entry = list_entry(node, struct acpi_device_physical_node,
+			node);
+		if (entry->dev != dev)
+			continue;
+
+		list_del(node);
+		clear_bit(entry->node_id, acpi_dev->physical_node_id_bitmap);
 
-		acpi_detach_data(dev->archdata.acpi_handle,
-				 acpi_glue_data_handler);
+		acpi_dev->physical_node_count--;
+
+		if (!entry->node_id)
+			strcpy(physical_node_name, PHYSICAL_NODE_STRING);
+		else
+			sprintf(physical_node_name,
+				"physical_node%d", entry->node_id);
+
+		sysfs_remove_link(&acpi_dev->dev.kobj, physical_node_name);
+		sysfs_remove_link(&dev->kobj, "firmware_node");
 		dev->archdata.acpi_handle = NULL;
 		/* acpi_bind_one increase refcnt by one */
 		put_device(dev);
-	} else {
-		dev_err(dev, "Oops, 'acpi_handle' corrupt\n");
+		kfree(entry);
 	}
+	mutex_unlock(&acpi_dev->physical_node_lock);
+
 	return 0;
+
+err:
+	dev_err(dev, "Oops, 'acpi_handle' corrupt\n");
+	return -EINVAL;
 }
 
 static int acpi_platform_notify(struct device *dev)

commit 91e4d5a1d7d11ca0b08803a11cb8dc866d2d611f
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Jul 25 14:24:13 2012 -0400

    drivers/acpi/glue: revert accidental license-related 6b66d95895c bits
    
    Commit 6b66d95895c149cbc04d4fac5a2f5477c543a8ae should not have changed
    EXPORT_SYMBOL_GPL to EXPORT_SYMBOL.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 18d6812a699e..243ee85e4d2e 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -39,7 +39,7 @@ int register_acpi_bus_type(struct acpi_bus_type *type)
 	}
 	return -ENODEV;
 }
-EXPORT_SYMBOL(register_acpi_bus_type);
+EXPORT_SYMBOL_GPL(register_acpi_bus_type);
 
 int unregister_acpi_bus_type(struct acpi_bus_type *type)
 {
@@ -55,7 +55,7 @@ int unregister_acpi_bus_type(struct acpi_bus_type *type)
 	}
 	return -ENODEV;
 }
-EXPORT_SYMBOL(unregister_acpi_bus_type);
+EXPORT_SYMBOL_GPL(unregister_acpi_bus_type);
 
 static struct acpi_bus_type *acpi_get_bus_type(struct bus_type *type)
 {

commit 6b66d95895c149cbc04d4fac5a2f5477c543a8ae
Author: Matthew Garrett <mjg@redhat.com>
Date:   Mon Jun 25 16:13:03 2012 +0800

    libata: bind the Linux device tree to the ACPI device tree
    
    Associate the ACPI device tree and libata devices.
    This patch uses the generic ACPI glue framework to do so.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Holger Macht <holger@homac.de>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 1564e0927c21..18d6812a699e 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -39,6 +39,7 @@ int register_acpi_bus_type(struct acpi_bus_type *type)
 	}
 	return -ENODEV;
 }
+EXPORT_SYMBOL(register_acpi_bus_type);
 
 int unregister_acpi_bus_type(struct acpi_bus_type *type)
 {
@@ -54,6 +55,7 @@ int unregister_acpi_bus_type(struct acpi_bus_type *type)
 	}
 	return -ENODEV;
 }
+EXPORT_SYMBOL(unregister_acpi_bus_type);
 
 static struct acpi_bus_type *acpi_get_bus_type(struct bus_type *type)
 {
@@ -69,7 +71,6 @@ static struct acpi_bus_type *acpi_get_bus_type(struct bus_type *type)
 	up_read(&bus_type_sem);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(register_acpi_bus_type);
 
 static int acpi_find_bridge_device(struct device *dev, acpi_handle * handle)
 {
@@ -86,7 +87,6 @@ static int acpi_find_bridge_device(struct device *dev, acpi_handle * handle)
 	up_read(&bus_type_sem);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(unregister_acpi_bus_type);
 
 /* Get device's handler per its address under its parent */
 struct acpi_find_child {

commit 66886d6f8c9bcdee3d7fce5796dcffd6b4bc0b48
Author: Matthew Garrett <mjg@redhat.com>
Date:   Fri May 11 16:08:25 2012 +0800

    ACPI: Add stubs for (un)register_acpi_bus_type
    
    It's unreasonable to have CONFIG_ACPI for these in drivers, so add some
    stub functions.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 29a4a5c8ee00..1564e0927c21 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -69,6 +69,7 @@ static struct acpi_bus_type *acpi_get_bus_type(struct bus_type *type)
 	up_read(&bus_type_sem);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(register_acpi_bus_type);
 
 static int acpi_find_bridge_device(struct device *dev, acpi_handle * handle)
 {
@@ -85,6 +86,7 @@ static int acpi_find_bridge_device(struct device *dev, acpi_handle * handle)
 	up_read(&bus_type_sem);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(unregister_acpi_bus_type);
 
 /* Get device's handler per its address under its parent */
 struct acpi_find_child {

commit 214f2c90b970e098e75cf719c0c5b0f1fe69b716
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Oct 26 16:22:14 2011 -0400

    acpi: add export.h to files using THIS_MODULE/EXPORT_SYMBOL
    
    These files were relying on module.h to come in via the path
    in an include/acpi header file, but we don't want to have
    instances of module.h being included from include/* files
    if it can be avoided.  Have the files include export.h instead.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 7c47ed55e528..29a4a5c8ee00 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -6,6 +6,7 @@
  *
  * This file is released under the GPLv2.
  */
+#include <linux/export.h>
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/device.h>

commit 7fa69baf29de8c77a6b32c054df2abb8f11f8aa4
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jan 6 23:35:10 2011 +0100

    ACPI / PM: Drop special ACPI wakeup flags
    
    Drop special ACPI wakeup flags, wakeup.state.enabled and
    wakeup.flags.always_enabled, that aren't necessary any more after
    we've started to use standard device wakeup flags for handling ACPI
    wakeup devices.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 78b0164c35b2..7c47ed55e528 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -167,11 +167,8 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 				"firmware_node");
 		ret = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,
 				"physical_node");
-		if (acpi_dev->wakeup.flags.valid) {
+		if (acpi_dev->wakeup.flags.valid)
 			device_set_wakeup_capable(dev, true);
-			device_set_wakeup_enable(dev,
-						acpi_dev->wakeup.state.enabled);
-		}
 	}
 
 	return 0;

commit 108029ff84fcad8f9199d2d2e2583ae2747d45a4
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Tue Jul 13 03:36:08 2010 +0000

    ACPI: Add the check of ADR flag in course of finding ACPI handle for PCI device
    
    The _ADR object is used to provide OSPM with the address of one device on its
    parent bus. In course of finding ACPI handle for the corresponding PCI device,
    we will firstly evaluate the _ADR object and then compare the two addresses to
    see whether it is the target ACPI device. But for one PCI device(0000:00:00.0)
    under the PCI root bridge, the corresponding address will be constructed as
    zero.In such case maybe the ACPI device without _ADR object will be misdetected
    and then be used to create the relationship between PCI device and ACPI device.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=16422
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 4af6301601e7..78b0164c35b2 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -100,7 +100,8 @@ do_acpi_find_child(acpi_handle handle, u32 lvl, void *context, void **rv)
 
 	status = acpi_get_object_info(handle, &info);
 	if (ACPI_SUCCESS(status)) {
-		if (info->address == find->address)
+		if ((info->address == find->address)
+			&& (info->valid & ACPI_VALID_ADR))
 			find->handle = handle;
 		kfree(info);
 	}

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 6d5b64b7d526..4af6301601e7 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -9,6 +9,7 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/device.h>
+#include <linux/slab.h>
 #include <linux/rwsem.h>
 #include <linux/acpi.h>
 

commit 439913fffd39374c3737186b22d2d56c3a0ae526
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Thu Jan 28 10:53:19 2010 +0800

    ACPI: replace acpi_integer by u64
    
    acpi_integer is now obsolete and removed from the ACPICA code base,
    replaced by u64.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 4c8fcff662cf..6d5b64b7d526 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -87,7 +87,7 @@ static int acpi_find_bridge_device(struct device *dev, acpi_handle * handle)
 /* Get device's handler per its address under its parent */
 struct acpi_find_child {
 	acpi_handle handle;
-	acpi_integer address;
+	u64 address;
 };
 
 static acpi_status
@@ -106,7 +106,7 @@ do_acpi_find_child(acpi_handle handle, u32 lvl, void *context, void **rv)
 	return AE_OK;
 }
 
-acpi_handle acpi_get_child(acpi_handle parent, acpi_integer address)
+acpi_handle acpi_get_child(acpi_handle parent, u64 address)
 {
 	struct acpi_find_child find = { NULL, address };
 

commit 2263576cfc6e8f6ab038126c3254404b9fcb1c33
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Fri Nov 13 10:06:08 2009 +0800

    ACPICA: Add post-order callback to acpi_walk_namespace
    
    The existing interface only has a pre-order callback. This change
    adds an additional parameter for a post-order callback which will
    be more useful for bus scans. ACPICA BZ 779.
    
    Also update the external calls to acpi_walk_namespace.
    
    http://www.acpica.org/bugzilla/show_bug.cgi?id=779
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index c6645f26224b..4c8fcff662cf 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -113,7 +113,7 @@ acpi_handle acpi_get_child(acpi_handle parent, acpi_integer address)
 	if (!parent)
 		return NULL;
 	acpi_walk_namespace(ACPI_TYPE_DEVICE, parent,
-			    1, do_acpi_find_child, &find, NULL);
+			    1, do_acpi_find_child, NULL, &find, NULL);
 	return find.handle;
 }
 

commit 985f38781d19101aba121df423f92c87b208c6df
Merge: d093d70a81b0 c9766237afa9
Author: Len Brown <len.brown@intel.com>
Date:   Sat Sep 19 01:45:22 2009 -0400

    Merge branch 'acpica' into release

commit a192a9580bcc41692be1f36b77c3b681827f566a
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jul 28 16:45:54 2009 -0400

    ACPI: Move definition of PREFIX from acpi_bus.h to internal..h
    
    Linux/ACPI core files using internal.h all PREFIX "ACPI: ",
    however, not all ACPI drivers use/want it -- and they
    should not have to #undef PREFIX to define their own.
    
    Add GPL commment to internal.h while we are there.
    
    This does not change any actual console output,
    asside from a whitespace fix.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index a8a5c29958c8..dc36a448de43 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -12,6 +12,8 @@
 #include <linux/rwsem.h>
 #include <linux/acpi.h>
 
+#include "internal.h"
+
 #define ACPI_GLUE_DEBUG	0
 #if ACPI_GLUE_DEBUG
 #define DBG(x...) printk(PREFIX x)

commit 8e4319c425077c4cc540696a5bb6c4d12f017dcd
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jun 29 13:43:27 2009 +0800

    ACPICA: Fix several acpi_attach_data problems
    
    Handler was never invoked. Now invoked if/when host node is deleted.
    Data object was not automatically deleted when host node was deleted.
    Interface to handler had an unused parameter, removed it.
    ACPICA BZ 778.
    
    http://acpica.org/bugzilla/show_bug.cgi?id=778
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 27a7072347ea..9a4ce33f137e 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -119,7 +119,7 @@ EXPORT_SYMBOL(acpi_get_child);
 
 /* Link ACPI devices with physical devices */
 static void acpi_glue_data_handler(acpi_handle handle,
-				   u32 function, void *context)
+				   void *context)
 {
 	/* we provide an empty handler */
 }

commit 15b8dd53f5ffaf8e2d9095c423f713423f576c0f
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jun 29 13:39:29 2009 +0800

    ACPICA: Major update for acpi_get_object_info external interface
    
    Completed a major update for the acpi_get_object_info external interface.
    Changes include:
     - Support for variable, unlimited length HID, UID, and CID strings
     - Support Processor objects the same as Devices (HID,UID,CID,ADR,STA, etc.)
     - Call the _SxW power methods on behalf of a device object
     - Determine if a device is a PCI root bridge
     - Change the ACPI_BUFFER parameter to ACPI_DEVICE_INFO.
    These changes will require an update to all callers of this interface.
    See the ACPICA Programmer Reference for details.
    
    Also, update all invocations of acpi_get_object_info interface
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index a8a5c29958c8..27a7072347ea 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -93,15 +93,13 @@ do_acpi_find_child(acpi_handle handle, u32 lvl, void *context, void **rv)
 {
 	acpi_status status;
 	struct acpi_device_info *info;
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	struct acpi_find_child *find = context;
 
-	status = acpi_get_object_info(handle, &buffer);
+	status = acpi_get_object_info(handle, &info);
 	if (ACPI_SUCCESS(status)) {
-		info = buffer.pointer;
 		if (info->address == find->address)
 			find->handle = handle;
-		kfree(buffer.pointer);
+		kfree(info);
 	}
 	return AE_OK;
 }

commit 7fe2a6c275a5bcec52fb3ef643daaf8265b7af0d
Author: Alexander Chiang <achiang@hp.com>
Date:   Wed Jun 10 19:56:05 2009 +0000

    ACPI: kill acpi_get_physical_pci_device()
    
    acpi_get_pci_dev() is (hopefully) better, and all callers have been
    converted, so let's get rid of this duplicated functionality.
    
    Cc: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 8bd2c2a6884d..a8a5c29958c8 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -140,46 +140,6 @@ struct device *acpi_get_physical_device(acpi_handle handle)
 
 EXPORT_SYMBOL(acpi_get_physical_device);
 
-/* ToDo: When a PCI bridge is found, return the PCI device behind the bridge
- *       This should work in general, but did not on a Lenovo T61 for the
- *	 graphics card. But this must be fixed when the PCI device is
- *       bound and the kernel device struct is attached to the acpi device
- * Note: A success call will increase reference count by one
- *       Do call put_device(dev) on the returned device then
- */
-struct device *acpi_get_physical_pci_device(acpi_handle handle)
-{
-	struct device *dev;
-	long long device_id;
-	acpi_status status;
-
-	status =
-		acpi_evaluate_integer(handle, "_ADR", NULL, &device_id);
-
-	if (ACPI_FAILURE(status))
-		return NULL;
-
-	/* We need to attempt to determine whether the _ADR refers to a
-	   PCI device or not. There's no terribly good way to do this,
-	   so the best we can hope for is to assume that there'll never
-	   be a device in the host bridge */
-	if (device_id >= 0x10000) {
-		/* It looks like a PCI device. Does it exist? */
-		dev = acpi_get_physical_device(handle);
-	} else {
-		/* It doesn't look like a PCI device. Does its parent
-		   exist? */
-		acpi_handle phandle;
-		if (acpi_get_parent(handle, &phandle))
-			return NULL;
-		dev = acpi_get_physical_device(phandle);
-	}
-	if (!dev)
-		return NULL;
-	return dev;
-}
-EXPORT_SYMBOL(acpi_get_physical_pci_device);
-
 static int acpi_bind_one(struct device *dev, acpi_handle handle)
 {
 	struct acpi_device *acpi_dev;

commit 0e46517d9660ee6ae0a0c5d8a4e50451bc84d61d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 24 16:50:09 2009 -0600

    ACPI: call init_acpi_device_notify() explicitly rather than as initcall
    
    This patch makes acpi_init() call init_acpi_device_notify() directly.
    Previously, init_acpi_device_notify() was an arch_initcall (sequence 3),
    so it was called before acpi_init() (a subsys_initcall at sequence 4).
    
    init_acpi_device_notify() sets the platform_notify and
    platform_notify_remove function pointers.  These pointers
    are not used until acpi_init() enumerates ACPI devices in
    this path:
    
        acpi_init()
                acpi_scan_init()
                    acpi_bus_scan()
                        acpi_add_single_object()
                            acpi_device_register()
                                device_add()
                                    <use platform_notify>
    
    So it is sufficient to have acpi_init() call init_acpi_device_notify()
    directly before it enumerates devices.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 5479b9f42513..8bd2c2a6884d 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -286,10 +286,8 @@ static int acpi_platform_notify_remove(struct device *dev)
 	return 0;
 }
 
-static int __init init_acpi_device_notify(void)
+int __init init_acpi_device_notify(void)
 {
-	if (acpi_disabled)
-		return 0;
 	if (platform_notify || platform_notify_remove) {
 		printk(KERN_ERR PREFIX "Can't use platform_notify\n");
 		return 0;
@@ -298,5 +296,3 @@ static int __init init_acpi_device_notify(void)
 	platform_notify_remove = acpi_platform_notify_remove;
 	return 0;
 }
-
-arch_initcall(init_acpi_device_notify);

commit db1461ad431f0fd21afcd8ea6594ae38fdc57759
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sun Jan 25 23:40:56 2009 +0100

    ACPI: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index adec3d15810a..5479b9f42513 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -255,12 +255,12 @@ static int acpi_platform_notify(struct device *dev)
 	}
 	type = acpi_get_bus_type(dev->bus);
 	if (!type) {
-		DBG("No ACPI bus support for %s\n", dev->bus_id);
+		DBG("No ACPI bus support for %s\n", dev_name(dev));
 		ret = -EINVAL;
 		goto end;
 	}
 	if ((ret = type->find_device(dev, &handle)) != 0)
-		DBG("Can't get handler for %s\n", dev->bus_id);
+		DBG("Can't get handler for %s\n", dev_name(dev));
       end:
 	if (!ret)
 		acpi_bind_one(dev, handle);
@@ -271,10 +271,10 @@ static int acpi_platform_notify(struct device *dev)
 
 		acpi_get_name(dev->archdata.acpi_handle,
 			      ACPI_FULL_PATHNAME, &buffer);
-		DBG("Device %s -> %s\n", dev->bus_id, (char *)buffer.pointer);
+		DBG("Device %s -> %s\n", dev_name(dev), (char *)buffer.pointer);
 		kfree(buffer.pointer);
 	} else
-		DBG("Device %s -> No ACPI support\n", dev->bus_id);
+		DBG("Device %s -> No ACPI support\n", dev_name(dev));
 #endif
 
 	return ret;

commit 22c13f9d8179f4c9caecfcb60a95214562b9addc
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Aug 1 17:37:54 2008 +0200

    ACPI: video: Ignore devices that aren't present in hardware
    
    This is a reimplemention of commit
    0119509c4fbc9adcef1472817fda295334612976
    from Matthew Garrett <mjg59@srcf.ucam.org>
    
    This patch got removed because of a regression: ThinkPads with a
    Intel graphics card and an Integrated Graphics Device BIOS implementation
    stopped working.
    In fact, they only worked because the ACPI device of the discrete, the
    wrong one, got used (via int10). So ACPI functions were poking on the wrong
    hardware used which is a sever bug.
    The next patch provides support for above ThinkPads to be able to
    switch brightness via the legacy thinkpad_acpi driver and automatically
    detect when to use it.
    
    Original commit message from Matthew Garrett:
        Vendors often ship machines with a choice of integrated or discrete
        graphics, and use the same DSDT for both. As a result, the ACPI video
        module will locate devices that may not exist on this specific platform.
        Attempt to determine whether the device exists or not, and abort the
        device creation if it doesn't.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=9614
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 24649ada08df..adec3d15810a 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -140,6 +140,46 @@ struct device *acpi_get_physical_device(acpi_handle handle)
 
 EXPORT_SYMBOL(acpi_get_physical_device);
 
+/* ToDo: When a PCI bridge is found, return the PCI device behind the bridge
+ *       This should work in general, but did not on a Lenovo T61 for the
+ *	 graphics card. But this must be fixed when the PCI device is
+ *       bound and the kernel device struct is attached to the acpi device
+ * Note: A success call will increase reference count by one
+ *       Do call put_device(dev) on the returned device then
+ */
+struct device *acpi_get_physical_pci_device(acpi_handle handle)
+{
+	struct device *dev;
+	long long device_id;
+	acpi_status status;
+
+	status =
+		acpi_evaluate_integer(handle, "_ADR", NULL, &device_id);
+
+	if (ACPI_FAILURE(status))
+		return NULL;
+
+	/* We need to attempt to determine whether the _ADR refers to a
+	   PCI device or not. There's no terribly good way to do this,
+	   so the best we can hope for is to assume that there'll never
+	   be a device in the host bridge */
+	if (device_id >= 0x10000) {
+		/* It looks like a PCI device. Does it exist? */
+		dev = acpi_get_physical_device(handle);
+	} else {
+		/* It doesn't look like a PCI device. Does its parent
+		   exist? */
+		acpi_handle phandle;
+		if (acpi_get_parent(handle, &phandle))
+			return NULL;
+		dev = acpi_get_physical_device(phandle);
+	}
+	if (!dev)
+		return NULL;
+	return dev;
+}
+EXPORT_SYMBOL(acpi_get_physical_pci_device);
+
 static int acpi_bind_one(struct device *dev, acpi_handle handle)
 {
 	struct acpi_device *acpi_dev;

commit a474aaedac99ba86e28ef6c912a7647c482db6dd
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 14 13:50:21 2008 -0600

    rtc-cmos: move wake setup from ACPI glue into RTC driver
    
    Move rtc_wake_setup() from drivers/acpi/glue.c into the RTC driver
    in drivers/rtc/rtc-cmos.c.
    
    This removes the ordering constraint between the module_init(acpi_rtc_init)
    and the cmos_do_probe() code that depends on it.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 3c578ef78c48..24649ada08df 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -260,115 +260,3 @@ static int __init init_acpi_device_notify(void)
 }
 
 arch_initcall(init_acpi_device_notify);
-
-
-#if defined(CONFIG_RTC_DRV_CMOS) || defined(CONFIG_RTC_DRV_CMOS_MODULE)
-
-#ifdef CONFIG_PM
-static u32 rtc_handler(void *context)
-{
-	acpi_clear_event(ACPI_EVENT_RTC);
-	acpi_disable_event(ACPI_EVENT_RTC, 0);
-	return ACPI_INTERRUPT_HANDLED;
-}
-
-static inline void rtc_wake_setup(void)
-{
-	acpi_install_fixed_event_handler(ACPI_EVENT_RTC, rtc_handler, NULL);
-	/*
-	 * After the RTC handler is installed, the Fixed_RTC event should
-	 * be disabled. Only when the RTC alarm is set will it be enabled.
-	 */
-	acpi_clear_event(ACPI_EVENT_RTC);
-	acpi_disable_event(ACPI_EVENT_RTC, 0);
-}
-
-static void rtc_wake_on(struct device *dev)
-{
-	acpi_clear_event(ACPI_EVENT_RTC);
-	acpi_enable_event(ACPI_EVENT_RTC, 0);
-}
-
-static void rtc_wake_off(struct device *dev)
-{
-	acpi_disable_event(ACPI_EVENT_RTC, 0);
-}
-#else
-#define rtc_wake_setup()	do{}while(0)
-#define rtc_wake_on		NULL
-#define rtc_wake_off		NULL
-#endif
-
-/* Every ACPI platform has a mc146818 compatible "cmos rtc".  Here we find
- * its device node and pass extra config data.  This helps its driver use
- * capabilities that the now-obsolete mc146818 didn't have, and informs it
- * that this board's RTC is wakeup-capable (per ACPI spec).
- */
-#include <linux/mc146818rtc.h>
-
-static struct cmos_rtc_board_info rtc_info;
-
-
-/* PNP devices are registered in a subsys_initcall();
- * ACPI specifies the PNP IDs to use.
- */
-#include <linux/pnp.h>
-
-static int __init pnp_match(struct device *dev, void *data)
-{
-	static const char *ids[] = { "PNP0b00", "PNP0b01", "PNP0b02", };
-	struct pnp_dev *pnp = to_pnp_dev(dev);
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(ids); i++) {
-		if (compare_pnp_id(pnp->id, ids[i]) != 0)
-			return 1;
-	}
-	return 0;
-}
-
-static struct device *__init get_rtc_dev(void)
-{
-	return bus_find_device(&pnp_bus_type, NULL, NULL, pnp_match);
-}
-
-static int __init acpi_rtc_init(void)
-{
-	struct device *dev = get_rtc_dev();
-
-	if (acpi_disabled)
-		return 0;
-
-	if (dev) {
-		rtc_wake_setup();
-		rtc_info.wake_on = rtc_wake_on;
-		rtc_info.wake_off = rtc_wake_off;
-
-		/* workaround bug in some ACPI tables */
-		if (acpi_gbl_FADT.month_alarm && !acpi_gbl_FADT.day_alarm) {
-			DBG("bogus FADT month_alarm\n");
-			acpi_gbl_FADT.month_alarm = 0;
-		}
-
-		rtc_info.rtc_day_alarm = acpi_gbl_FADT.day_alarm;
-		rtc_info.rtc_mon_alarm = acpi_gbl_FADT.month_alarm;
-		rtc_info.rtc_century = acpi_gbl_FADT.century;
-
-		/* NOTE:  S4_RTC_WAKE is NOT currently useful to Linux */
-		if (acpi_gbl_FADT.flags & ACPI_FADT_S4_RTC_WAKE)
-			printk(PREFIX "RTC can wake from S4\n");
-
-
-		dev->platform_data = &rtc_info;
-
-		/* RTC always wakes from S1/S2/S3, and often S4/STD */
-		device_init_wakeup(dev, 1);
-
-		put_device(dev);
-	} else
-		DBG("RTC unavailable?\n");
-	return 0;
-}
-module_init(acpi_rtc_init);
-
-#endif

commit 1efd325fbadc02c1338e0ef676f0a6669b251c7a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 12 11:30:08 2008 -0700

    Fix RTC wakealarm sysfs interface breakage.
    
    Commit ed458df4d2470adc02762a87a9ad665d0b1a2bd4 ("PnP: move
    pnpacpi/pnpbios_init to after PCI init") moved the PnP RTC discovery
    later, and now the ACPI RTC glue code doesn't find it any more, breaking
    the RTC wakealarm sysfs interfaces, as reported by Rafael.
    
    This really is fairly messy, and we have several annoying ordering
    constraints here - the PnP code that sets up the RTC resources wants to
    run after the PCI resources have to be registered, which in turn needs
    to run after ACPI has at least enumerated the root PCI buses etc.  Our
    initcall ordering is not fine-grained enough to make this all painless.
    
    So this moves the ACPI RTC glue ("acpi_rtc_init()") down to a regular
    module call, which fixes the problem Rafael has.  The reason this isn't
    wonderful is that we really should do acpi_rtc_init before we do the
    rtc_cmos init, and now those two are in the same module_init() section.
    
    Which happens to work, but only because drivers/rtc is linked after
    drivers/acpi.  In other words, we still have a very subtle ordering
    issue here. Grr.
    
    Reported-and-tested-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: David Brownell <david-b@pacbell.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 8dd3336efd7e..3c578ef78c48 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -369,7 +369,6 @@ static int __init acpi_rtc_init(void)
 		DBG("RTC unavailable?\n");
 	return 0;
 }
-/* do this between RTC subsys_initcall() and rtc_cmos driver_initcall() */
-fs_initcall(acpi_rtc_init);
+module_init(acpi_rtc_init);
 
 #endif

commit 76acae04c892287949e1191e99600f3e952e43f7
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Oct 3 15:23:49 2008 -0700

    ACPI: Make /proc/acpi/wakeup interface handle PCI devices (again)
    
    Make the ACPI /proc/acpi/wakeup interface set the appropriate wake-up bits
    of physical devices corresponding to the ACPI devices and make those bits
    be set initially for devices that are enabled to wake up by default.  This
    is needed to restore the 2.6.26 and earlier behavior for the PCI devices
    that were previously handled correctly with the help of the
    /proc/acpi/wakeup interface.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 084109507c9f..8dd3336efd7e 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -165,8 +165,11 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 				"firmware_node");
 		ret = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,
 				"physical_node");
-		if (acpi_dev->wakeup.flags.valid)
+		if (acpi_dev->wakeup.flags.valid) {
 			device_set_wakeup_capable(dev, true);
+			device_set_wakeup_enable(dev,
+						acpi_dev->wakeup.state.enabled);
+		}
 	}
 
 	return 0;

commit fc3a8828b139c24aade3f9d608775e36c248f8f5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri May 2 06:02:41 2008 +0200

    driver core: fix a lot of printk usages of bus_id
    
    We have the dev_printk() variants for this kind of thing, use them
    instead of directly trying to access the bus_id field of struct device.
    
    This is done in order to remove bus_id entirely.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 2f173e83f8a7..084109507c9f 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -146,8 +146,7 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 	acpi_status status;
 
 	if (dev->archdata.acpi_handle) {
-		printk(KERN_WARNING PREFIX
-		       "Drivers changed 'acpi_handle' for %s\n", dev->bus_id);
+		dev_warn(dev, "Drivers changed 'acpi_handle'\n");
 		return -EINVAL;
 	}
 	get_device(dev);
@@ -195,8 +194,7 @@ static int acpi_unbind_one(struct device *dev)
 		/* acpi_bind_one increase refcnt by one */
 		put_device(dev);
 	} else {
-		printk(KERN_ERR PREFIX
-		       "Oops, 'acpi_handle' corrupt for %s\n", dev->bus_id);
+		dev_err(dev, "Oops, 'acpi_handle' corrupt\n");
 	}
 	return 0;
 }

commit 5e248ac9a5c465b356b936030d5a2e80887eb266
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 18 02:07:02 2008 +0200

    APCI: revert another duplicated patch
    
    commit d1857056904d5f313f11184fcfa624652ff9620a ("ACPI: don't walk
    tables if ACPI was disabled") is another superfluous duplicate commit
    caused by git -> quilt -> git conversion.
    
    Revert it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 0f2dd81736bd..2f173e83f8a7 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -335,9 +335,6 @@ static int __init acpi_rtc_init(void)
 {
 	struct device *dev = get_rtc_dev();
 
-	if (acpi_disabled)
-		return 0;
-
 	if (acpi_disabled)
 		return 0;
 

commit dc7c65db2845a8d17432d89252c4227a9a7cb15f
Merge: 8a0ca91e1db5 58b6e5538460
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 16 17:25:46 2008 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (72 commits)
      Revert "x86/PCI: ACPI based PCI gap calculation"
      PCI: remove unnecessary volatile in PCIe hotplug struct controller
      x86/PCI: ACPI based PCI gap calculation
      PCI: include linux/pm_wakeup.h for device_set_wakeup_capable
      PCI PM: Fix pci_prepare_to_sleep
      x86/PCI: Fix PCI config space for domains > 0
      Fix acpi_pm_device_sleep_wake() by providing a stub for CONFIG_PM_SLEEP=n
      PCI: Simplify PCI device PM code
      PCI PM: Introduce pci_prepare_to_sleep and pci_back_from_sleep
      PCI ACPI: Rework PCI handling of wake-up
      ACPI: Introduce new device wakeup flag 'prepared'
      ACPI: Introduce acpi_device_sleep_wake function
      PCI: rework pci_set_power_state function to call platform first
      PCI: Introduce platform_pci_power_manageable function
      ACPI: Introduce acpi_bus_power_manageable function
      PCI: make pci_name use dev_name
      PCI: handle pci_name() being const
      PCI: add stub for pci_set_consistent_dma_mask()
      PCI: remove unused arch pcibios_update_resource() functions
      PCI: fix pci_setup_device()'s sprinting into a const buffer
      ...
    
    Fixed up conflicts in various files (arch/x86/kernel/setup_64.c,
    arch/x86/pci/irq.c, arch/x86/pci/pci.h, drivers/acpi/sleep/main.c,
    drivers/pci/pci.c, drivers/pci/pci.h, include/acpi/acpi_bus.h) from x86
    and ACPI updates manually.

commit d1857056904d5f313f11184fcfa624652ff9620a
Author: Vegard Nossum <vegard.nossum@gmail.com>
Date:   Fri Jun 20 15:39:09 2008 +0200

    ACPI: don't walk tables if ACPI was disabled
    
    Ingo Molnar wrote:
    > -tip auto-testing started triggering this spinlock corruption message
    > yesterday:
    >
    > [    3.976213] calling  acpi_rtc_init+0x0/0xd3
    > [    3.980213] ACPI Exception (utmutex-0263): AE_BAD_PARAMETER, Thread F7C50000 could not acquire Mutex [3] [20080321]
    > [    3.992213] BUG: spinlock bad magic on CPU#0, swapper/1
    > [    3.992213]  lock: c2508dc4, .magic: 00000000, .owner: swapper/1, .owner_cpu: 0
    
    This is apparently because some parts of ACPI, including mutexes, are not
    initialized when acpi=off is passed to the kernel.
    
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Vegard Nossum <vegard.nossum@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 9b227d4dc9c9..6d18ca34b6aa 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -333,6 +333,9 @@ static int __init acpi_rtc_init(void)
 {
 	struct device *dev = get_rtc_dev();
 
+	if (acpi_disabled)
+		return 0;
+
 	if (acpi_disabled)
 		return 0;
 

commit eb9d0fe40e313c0a74115ef456a2e43a6c8da72f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 7 03:34:48 2008 +0200

    PCI ACPI: Rework PCI handling of wake-up
    
    * Introduce function acpi_pm_device_sleep_wake() for enabling and
      disabling the system wake-up capability of devices that are power
      manageable by ACPI.
    
    * Introduce function acpi_bus_can_wakeup() allowing other (dependent)
      subsystems to check if ACPI is able to enable the system wake-up
      capability of given device.
    
    * Introduce callback .sleep_wake() in struct pci_platform_pm_ops and
      for the ACPI PCI 'driver' make it use acpi_pm_device_sleep_wake().
    
    * Introduce callback .can_wakeup() in struct pci_platform_pm_ops and
      for the ACPI 'driver' make it use acpi_bus_can_wakeup().
    
    * Move the PME# handlig code out of pci_enable_wake() and split it
      into two functions, pci_pme_capable() and pci_pme_active(),
      allowing the caller to check if given device is capable of
      generating PME# from given power state and to enable/disable the
      device's PME# functionality, respectively.
    
    * Modify pci_enable_wake() to use the new ACPI callbacks and the new
      PME#-related functions.
    
    * Drop the generic .platform_enable_wakeup() callback that is not
      used any more.
    
    * Introduce device_set_wakeup_capable() that will set the
      power.can_wakeup flag of given device.
    
    * Rework PCI device PM initialization so that, if given device is
      capable of generating wake-up events, either natively through the
      PME# mechanism, or with the help of the platform, its
      power.can_wakeup flag is set and its power.should_wakeup flag is
      unset as appropriate.
    
    * Make ACPI set the power.can_wakeup flag for devices found to be
      wake-up capable by it.
    
    * Make the ACPI wake-up code enable/disable GPEs for devices that
      have the wakeup.flags.prepared flag set (which means that their
      wake-up power has been enabled).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 06f8634fe58b..87c5d456e180 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -166,6 +166,8 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 				"firmware_node");
 		ret = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,
 				"physical_node");
+		if (acpi_dev->wakeup.flags.valid)
+			device_set_wakeup_capable(dev, true);
 	}
 
 	return 0;

commit 4389ed2ff61de2b1485b31bf342da913dd342f59
Author: Vegard Nossum <vegard.nossum@gmail.com>
Date:   Fri Jun 20 15:39:09 2008 +0200

    ACPI: don't walk tables if ACPI was disabled
    
    Ingo Molnar wrote:
    > -tip auto-testing started triggering this spinlock corruption message
    > yesterday:
    >
    > [    3.976213] calling  acpi_rtc_init+0x0/0xd3
    > [    3.980213] ACPI Exception (utmutex-0263): AE_BAD_PARAMETER, Thread F7C50000 could not acquire Mutex [3] [20080321]
    > [    3.992213] BUG: spinlock bad magic on CPU#0, swapper/1
    > [    3.992213]  lock: c2508dc4, .magic: 00000000, .owner: swapper/1, .owner_cpu: 0
    
    This is apparently because some parts of ACPI, including mutexes, are not
    initialized when acpi=off is passed to the kernel.
    
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Vegard Nossum <vegard.nossum@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 2808dc60fd67..9b227d4dc9c9 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -333,6 +333,9 @@ static int __init acpi_rtc_init(void)
 {
 	struct device *dev = get_rtc_dev();
 
+	if (acpi_disabled)
+		return 0;
+
 	if (dev) {
 		rtc_wake_setup();
 		rtc_info.wake_on = rtc_wake_on;

commit e1094bfa26e5e94af2fea79e004614dbce42b008
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Wed May 14 11:32:59 2008 +0800

    ACPI: Disable Fixed_RTC event when installing RTC handler
    
    The Fixed_RTC event should be disabled when installing RTC handler.
    Only when RTC alarm is set will it be enabled again. If it is not
    disabled, maybe some machines will be powered on automatically after
    the system is shutdown even when the RTC alarm is not set.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=10010
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 06f8634fe58b..2808dc60fd67 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -272,6 +272,12 @@ static u32 rtc_handler(void *context)
 static inline void rtc_wake_setup(void)
 {
 	acpi_install_fixed_event_handler(ACPI_EVENT_RTC, rtc_handler, NULL);
+	/*
+	 * After the RTC handler is installed, the Fixed_RTC event should
+	 * be disabled. Only when the RTC alarm is set will it be enabled.
+	 */
+	acpi_clear_event(ACPI_EVENT_RTC);
+	acpi_disable_event(ACPI_EVENT_RTC, 0);
 }
 
 static void rtc_wake_on(struct device *dev)

commit 1071695f17daf050638e0bc550db647f8237c3bb
Author: David Brownell <david-b@pacbell.net>
Date:   Fri Feb 22 21:54:24 2008 -0800

    ACPI: crosslink ACPI and "real" device nodes
    
    Add cross-links between ACPI device and "real" devices in sysfs,
    exposing otherwise-hidden interrelationships between the various
    device nodes for ACPI stuff.  As a representative example, one
    hardware device is exposed as two logical devices (PNP and ACPI):
    
      .../pnp0/00:06/
      .../LNXSYSTM:00/device:00/PNP0A03:00/device:15/PNP0B00:00/
    
    The PNP device gets a "firmware_node" link pointing to the ACPI device,
    and is what a Linux device driver binds to.  The ACPI device has instead
    a "physical_node" link pointing back to the PNP device.  Other firmware
    frameworks, like OpenFirmware, could do the same thing to couple their
    firmware tables to the rest of the system.
    
    (Based on a patch from Zhang Rui.  This version is modified to not
    depend on the patch makig ACPI initialize driver model wakeup flags.)
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index eda0978b57c6..06f8634fe58b 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -142,6 +142,7 @@ EXPORT_SYMBOL(acpi_get_physical_device);
 
 static int acpi_bind_one(struct device *dev, acpi_handle handle)
 {
+	struct acpi_device *acpi_dev;
 	acpi_status status;
 
 	if (dev->archdata.acpi_handle) {
@@ -157,6 +158,16 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 	}
 	dev->archdata.acpi_handle = handle;
 
+	status = acpi_bus_get_device(handle, &acpi_dev);
+	if (!ACPI_FAILURE(status)) {
+		int ret;
+
+		ret = sysfs_create_link(&dev->kobj, &acpi_dev->dev.kobj,
+				"firmware_node");
+		ret = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,
+				"physical_node");
+	}
+
 	return 0;
 }
 
@@ -165,8 +176,17 @@ static int acpi_unbind_one(struct device *dev)
 	if (!dev->archdata.acpi_handle)
 		return 0;
 	if (dev == acpi_get_physical_device(dev->archdata.acpi_handle)) {
+		struct acpi_device *acpi_dev;
+
 		/* acpi_get_physical_device increase refcnt by one */
 		put_device(dev);
+
+		if (!acpi_bus_get_device(dev->archdata.acpi_handle,
+					&acpi_dev)) {
+			sysfs_remove_link(&dev->kobj, "firmware_node");
+			sysfs_remove_link(&acpi_dev->dev.kobj, "physical_node");
+		}
+
 		acpi_detach_data(dev->archdata.acpi_handle,
 				 acpi_glue_data_handler);
 		dev->archdata.acpi_handle = NULL;

commit e5685b9d35c2cc0a98425b05df30cb837dd1e632
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Oct 24 18:24:42 2007 +0200

    ACPI: misc cleanups
    
        This patch contains the following possible cleanups:
        - make the following needlessly global code static:
          - drivers/acpi/bay.c:dev_attr_eject
          - drivers/acpi/bay.c:dev_attr_present
          - drivers/acpi/dock.c:dev_attr_docked
          - drivers/acpi/dock.c:dev_attr_flags
          - drivers/acpi/dock.c:dev_attr_uid
          - drivers/acpi/dock.c:dev_attr_undock
          - drivers/acpi/pci_bind.c:acpi_pci_unbind()
          - drivers/acpi/pci_link.c:acpi_link_lock
          - drivers/acpi/sbs.c:acpi_sbs_callback()
          - drivers/acpi/sbshc.c:acpi_smbus_transaction()
          - drivers/acpi/sleep/main.c:acpi_sleep_prepare()
        - #if 0 the following unused global functions:
          - drivers/acpi/numa.c:acpi_unmap_pxm_to_node()
        - remove the following unused EXPORT_SYMBOL's:
          - acpi_register_gsi
          - acpi_unregister_gsi
          - acpi_strict
          - acpi_bus_receive_event
          - register_acpi_bus_type
          - unregister_acpi_bus_type
          - acpi_os_printf
          - acpi_os_sleep
          - acpi_os_stall
          - acpi_os_read_pci_configuration
          - acpi_os_create_semaphore
          - acpi_os_delete_semaphore
          - acpi_os_wait_semaphore
          - acpi_os_signal_semaphore
          - acpi_os_signal
          - acpi_pci_irq_enable
          - acpi_get_pxm
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 4893e256e399..eda0978b57c6 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -36,8 +36,6 @@ int register_acpi_bus_type(struct acpi_bus_type *type)
 	return -ENODEV;
 }
 
-EXPORT_SYMBOL(register_acpi_bus_type);
-
 int unregister_acpi_bus_type(struct acpi_bus_type *type)
 {
 	if (acpi_disabled)
@@ -53,8 +51,6 @@ int unregister_acpi_bus_type(struct acpi_bus_type *type)
 	return -ENODEV;
 }
 
-EXPORT_SYMBOL(unregister_acpi_bus_type);
-
 static struct acpi_bus_type *acpi_get_bus_type(struct bus_type *type)
 {
 	struct acpi_bus_type *tmp, *ret = NULL;

commit 4ebf83c8cf89ab13bc23e46b0fcb6178ca23b43c
Author: Dave Jones <davej@redhat.com>
Date:   Mon Jul 9 11:33:14 2007 -0700

    ACPI: fix empty macros found by -Wextra
    
    ACPI has a ton of macros which make a bunch of empty if's when configured
    in non-debug mode.
    
    [lenb: The code it complaines about is functionally correct,
     so this patch is just to make -Wextra happier]
    
    #define DBG()
    
    if(...)
            DBG();
    next_c_statement
    
    which turns into
    if(...) ;
    next_c_statement
    
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 41427a41f620..4893e256e399 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -16,7 +16,7 @@
 #if ACPI_GLUE_DEBUG
 #define DBG(x...) printk(PREFIX x)
 #else
-#define DBG(x...)
+#define DBG(x...) do { } while(0)
 #endif
 static LIST_HEAD(bus_type_list);
 static DECLARE_RWSEM(bus_type_sem);

commit 19bfe37caa8184768ecc15269302f42036625259
Author: David Brownell <david-b@pacbell.net>
Date:   Tue May 8 00:34:03 2007 -0700

    workaround rtc-related acpi table bugs
    
    This works around a bug seen in some RTC-related ACPI table entries, and
    tweaks related diagnostics to follow the ACPI convention.
    
    The bug prevents misleading boot-time messages: platforms affected by this
    bug wrongly report they can support alarms up to one year in the future,
    when in fact the longest alarm is just 24 hours.  That will surprise anyone
    trying to use those extended alarms.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 83768e9cf296..41427a41f620 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -316,13 +316,20 @@ static int __init acpi_rtc_init(void)
 		rtc_info.wake_on = rtc_wake_on;
 		rtc_info.wake_off = rtc_wake_off;
 
+		/* workaround bug in some ACPI tables */
+		if (acpi_gbl_FADT.month_alarm && !acpi_gbl_FADT.day_alarm) {
+			DBG("bogus FADT month_alarm\n");
+			acpi_gbl_FADT.month_alarm = 0;
+		}
+
 		rtc_info.rtc_day_alarm = acpi_gbl_FADT.day_alarm;
 		rtc_info.rtc_mon_alarm = acpi_gbl_FADT.month_alarm;
 		rtc_info.rtc_century = acpi_gbl_FADT.century;
 
 		/* NOTE:  S4_RTC_WAKE is NOT currently useful to Linux */
 		if (acpi_gbl_FADT.flags & ACPI_FADT_S4_RTC_WAKE)
-			printk("ACPI: RTC can wake from S4\n");
+			printk(PREFIX "RTC can wake from S4\n");
+
 
 		dev->platform_data = &rtc_info;
 
@@ -331,7 +338,7 @@ static int __init acpi_rtc_init(void)
 
 		put_device(dev);
 	} else
-		pr_debug("ACPI: RTC unavailable?\n");
+		DBG("RTC unavailable?\n");
 	return 0;
 }
 /* do this between RTC subsys_initcall() and rtc_cmos driver_initcall() */

commit f5f72b46c349fefcfd4421b2213c6ffb324c5e56
Author: David Brownell <david-b@pacbell.net>
Date:   Tue May 8 00:34:02 2007 -0700

    ACPI wakeup hooks for rtc-cmos
    
    Remove /proc/acpi/alarm file when the rtc-cmos "wakealarm" file is available.
    Instead, provide hooks that rtc-cmos will use.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 4334c208841a..83768e9cf296 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -245,6 +245,35 @@ arch_initcall(init_acpi_device_notify);
 
 #if defined(CONFIG_RTC_DRV_CMOS) || defined(CONFIG_RTC_DRV_CMOS_MODULE)
 
+#ifdef CONFIG_PM
+static u32 rtc_handler(void *context)
+{
+	acpi_clear_event(ACPI_EVENT_RTC);
+	acpi_disable_event(ACPI_EVENT_RTC, 0);
+	return ACPI_INTERRUPT_HANDLED;
+}
+
+static inline void rtc_wake_setup(void)
+{
+	acpi_install_fixed_event_handler(ACPI_EVENT_RTC, rtc_handler, NULL);
+}
+
+static void rtc_wake_on(struct device *dev)
+{
+	acpi_clear_event(ACPI_EVENT_RTC);
+	acpi_enable_event(ACPI_EVENT_RTC, 0);
+}
+
+static void rtc_wake_off(struct device *dev)
+{
+	acpi_disable_event(ACPI_EVENT_RTC, 0);
+}
+#else
+#define rtc_wake_setup()	do{}while(0)
+#define rtc_wake_on		NULL
+#define rtc_wake_off		NULL
+#endif
+
 /* Every ACPI platform has a mc146818 compatible "cmos rtc".  Here we find
  * its device node and pass extra config data.  This helps its driver use
  * capabilities that the now-obsolete mc146818 didn't have, and informs it
@@ -283,11 +312,17 @@ static int __init acpi_rtc_init(void)
 	struct device *dev = get_rtc_dev();
 
 	if (dev) {
+		rtc_wake_setup();
+		rtc_info.wake_on = rtc_wake_on;
+		rtc_info.wake_off = rtc_wake_off;
+
 		rtc_info.rtc_day_alarm = acpi_gbl_FADT.day_alarm;
 		rtc_info.rtc_mon_alarm = acpi_gbl_FADT.month_alarm;
 		rtc_info.rtc_century = acpi_gbl_FADT.century;
 
-		/* NOTE:  acpi_gbl_FADT->rtcs4 is NOT currently useful */
+		/* NOTE:  S4_RTC_WAKE is NOT currently useful to Linux */
+		if (acpi_gbl_FADT.flags & ACPI_FADT_S4_RTC_WAKE)
+			printk("ACPI: RTC can wake from S4\n");
 
 		dev->platform_data = &rtc_info;
 

commit 8d4956c201c2f7683289f70095443c59a39f94ef
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 15 22:46:42 2007 -0500

    ACPI: remove non-PNPACPI version of get_rtc_dev()
    
    It isn't needed in ACPI code anymore because
    now ACPI always includes PNPACPI.
    
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 99500871e3fe..4334c208841a 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -255,8 +255,6 @@ arch_initcall(init_acpi_device_notify);
 static struct cmos_rtc_board_info rtc_info;
 
 
-#ifdef CONFIG_PNPACPI
-
 /* PNP devices are registered in a subsys_initcall();
  * ACPI specifies the PNP IDs to use.
  */
@@ -280,31 +278,6 @@ static struct device *__init get_rtc_dev(void)
 	return bus_find_device(&pnp_bus_type, NULL, NULL, pnp_match);
 }
 
-#else
-
-/* We expect non-PNPACPI platforms to register an RTC device, usually
- * at or near arch_initcall().  That also helps for example PCs that
- * aren't configured with ACPI (where this code wouldn't run, but the
- * RTC would still be available).  The device name matches the driver;
- * that's how the platform bus works.
- */
-#include <linux/platform_device.h>
-
-static int __init platform_match(struct device *dev, void *data)
-{
-	struct platform_device	*pdev;
-
-	pdev = container_of(dev, struct platform_device, dev);
-	return strcmp(pdev->name, "rtc_cmos") == 0;
-}
-
-static struct device *__init get_rtc_dev(void)
-{
-	return bus_find_device(&platform_bus_type, NULL, NULL, platform_match);
-}
-
-#endif
-
 static int __init acpi_rtc_init(void)
 {
 	struct device *dev = get_rtc_dev();

commit a74388e21ef2adbba4450f7b3f05ffe88df630d5
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Feb 5 16:09:11 2007 -0800

    ACPI: updates rtc-cmos device platform_data
    
    Update ACPI to export its RTC extension information through platform_data
    to the PNPACPI or platform bus device node used on the system being set up.
    
    This will need to be updated later to provide a firmware hook to handle
    system suspend with an alarm pending.
    
    Len notes that "Eventually we may bundle ACPI/PNP/PNPACPI..." but if/when
    that happens, ACPI can simplify this without my help.
    
    And until it does, the separate patch creating a platform_device (on all
    X86_PC systems, even without ACPI) will be needed.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 7b6c9ff9bebe..99500871e3fe 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -241,3 +241,92 @@ static int __init init_acpi_device_notify(void)
 }
 
 arch_initcall(init_acpi_device_notify);
+
+
+#if defined(CONFIG_RTC_DRV_CMOS) || defined(CONFIG_RTC_DRV_CMOS_MODULE)
+
+/* Every ACPI platform has a mc146818 compatible "cmos rtc".  Here we find
+ * its device node and pass extra config data.  This helps its driver use
+ * capabilities that the now-obsolete mc146818 didn't have, and informs it
+ * that this board's RTC is wakeup-capable (per ACPI spec).
+ */
+#include <linux/mc146818rtc.h>
+
+static struct cmos_rtc_board_info rtc_info;
+
+
+#ifdef CONFIG_PNPACPI
+
+/* PNP devices are registered in a subsys_initcall();
+ * ACPI specifies the PNP IDs to use.
+ */
+#include <linux/pnp.h>
+
+static int __init pnp_match(struct device *dev, void *data)
+{
+	static const char *ids[] = { "PNP0b00", "PNP0b01", "PNP0b02", };
+	struct pnp_dev *pnp = to_pnp_dev(dev);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ids); i++) {
+		if (compare_pnp_id(pnp->id, ids[i]) != 0)
+			return 1;
+	}
+	return 0;
+}
+
+static struct device *__init get_rtc_dev(void)
+{
+	return bus_find_device(&pnp_bus_type, NULL, NULL, pnp_match);
+}
+
+#else
+
+/* We expect non-PNPACPI platforms to register an RTC device, usually
+ * at or near arch_initcall().  That also helps for example PCs that
+ * aren't configured with ACPI (where this code wouldn't run, but the
+ * RTC would still be available).  The device name matches the driver;
+ * that's how the platform bus works.
+ */
+#include <linux/platform_device.h>
+
+static int __init platform_match(struct device *dev, void *data)
+{
+	struct platform_device	*pdev;
+
+	pdev = container_of(dev, struct platform_device, dev);
+	return strcmp(pdev->name, "rtc_cmos") == 0;
+}
+
+static struct device *__init get_rtc_dev(void)
+{
+	return bus_find_device(&platform_bus_type, NULL, NULL, platform_match);
+}
+
+#endif
+
+static int __init acpi_rtc_init(void)
+{
+	struct device *dev = get_rtc_dev();
+
+	if (dev) {
+		rtc_info.rtc_day_alarm = acpi_gbl_FADT.day_alarm;
+		rtc_info.rtc_mon_alarm = acpi_gbl_FADT.month_alarm;
+		rtc_info.rtc_century = acpi_gbl_FADT.century;
+
+		/* NOTE:  acpi_gbl_FADT->rtcs4 is NOT currently useful */
+
+		dev->platform_data = &rtc_info;
+
+		/* RTC always wakes from S1/S2/S3, and often S4/STD */
+		device_init_wakeup(dev, 1);
+
+		put_device(dev);
+	} else
+		pr_debug("ACPI: RTC unavailable?\n");
+	return 0;
+}
+/* do this between RTC subsys_initcall() and rtc_cmos driver_initcall() */
+fs_initcall(acpi_rtc_init);
+
+#endif

commit d91a0078476ca536d76419f3b53196873b2931bc
Author: Justin Chen <justin.chen@hp.com>
Date:   Wed Dec 6 10:17:10 2006 -0700

    ACPI: Optimize acpi_get_pci_rootbridge_handle() to boot faster
    
    Move acpi_get_pci_rootbridge_handle() from glue.c to pci_root.c and get the
    root bridge ACPI handles by searching the &acpi_pci_roots list instead of
    walking through the ACPI name space.  This significantly reduces boot time
    on large I/O systems.
    
    Signed-off-by: Justin Chen <justin.chen@hp.com>
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 8a0324b43e53..7b6c9ff9bebe 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -86,129 +86,6 @@ static int acpi_find_bridge_device(struct device *dev, acpi_handle * handle)
 	return ret;
 }
 
-/* Get PCI root bridge's handle from its segment and bus number */
-struct acpi_find_pci_root {
-	unsigned int seg;
-	unsigned int bus;
-	acpi_handle handle;
-};
-
-static acpi_status
-do_root_bridge_busnr_callback(struct acpi_resource *resource, void *data)
-{
-	unsigned long *busnr = data;
-	struct acpi_resource_address64 address;
-
-	if (resource->type != ACPI_RESOURCE_TYPE_ADDRESS16 &&
-	    resource->type != ACPI_RESOURCE_TYPE_ADDRESS32 &&
-	    resource->type != ACPI_RESOURCE_TYPE_ADDRESS64)
-		return AE_OK;
-
-	acpi_resource_to_address64(resource, &address);
-	if ((address.address_length > 0) &&
-	    (address.resource_type == ACPI_BUS_NUMBER_RANGE))
-		*busnr = address.minimum;
-
-	return AE_OK;
-}
-
-static int get_root_bridge_busnr(acpi_handle handle)
-{
-	acpi_status status;
-	unsigned long bus, bbn;
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
-
-	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
-
-	status = acpi_evaluate_integer(handle, METHOD_NAME__BBN, NULL,
-				       &bbn);
-	if (status == AE_NOT_FOUND) {
-		/* Assume bus = 0 */
-		printk(KERN_INFO PREFIX
-		       "Assume root bridge [%s] bus is 0\n",
-		       (char *)buffer.pointer);
-		status = AE_OK;
-		bbn = 0;
-	}
-	if (ACPI_FAILURE(status)) {
-		bbn = -ENODEV;
-		goto exit;
-	}
-	if (bbn > 0)
-		goto exit;
-
-	/* _BBN in some systems return 0 for all root bridges */
-	bus = -1;
-	status = acpi_walk_resources(handle, METHOD_NAME__CRS,
-				     do_root_bridge_busnr_callback, &bus);
-	/* If _CRS failed, we just use _BBN */
-	if (ACPI_FAILURE(status) || (bus == -1))
-		goto exit;
-	/* We select _CRS */
-	if (bbn != bus) {
-		printk(KERN_INFO PREFIX
-		       "_BBN and _CRS returns different value for %s. Select _CRS\n",
-		       (char *)buffer.pointer);
-		bbn = bus;
-	}
-      exit:
-	kfree(buffer.pointer);
-	return (int)bbn;
-}
-
-static acpi_status
-find_pci_rootbridge(acpi_handle handle, u32 lvl, void *context, void **rv)
-{
-	struct acpi_find_pci_root *find = (struct acpi_find_pci_root *)context;
-	unsigned long seg, bus;
-	acpi_status status;
-	int tmp;
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
-
-	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
-
-	status = acpi_evaluate_integer(handle, METHOD_NAME__SEG, NULL, &seg);
-	if (status == AE_NOT_FOUND) {
-		/* Assume seg = 0 */
-		status = AE_OK;
-		seg = 0;
-	}
-	if (ACPI_FAILURE(status)) {
-		status = AE_CTRL_DEPTH;
-		goto exit;
-	}
-
-	tmp = get_root_bridge_busnr(handle);
-	if (tmp < 0) {
-		printk(KERN_ERR PREFIX
-		       "Find root bridge failed for %s\n",
-		       (char *)buffer.pointer);
-		status = AE_CTRL_DEPTH;
-		goto exit;
-	}
-	bus = tmp;
-
-	if (seg == find->seg && bus == find->bus)
-	{
-		find->handle = handle;
-		status = AE_CTRL_TERMINATE;
-	}
-	else
-		status = AE_OK;
-      exit:
-	kfree(buffer.pointer);
-	return status;
-}
-
-acpi_handle acpi_get_pci_rootbridge_handle(unsigned int seg, unsigned int bus)
-{
-	struct acpi_find_pci_root find = { seg, bus, NULL };
-
-	acpi_get_devices(PCI_ROOT_HID_STRING, find_pci_rootbridge, &find, NULL);
-	return find.handle;
-}
-EXPORT_SYMBOL_GPL(acpi_get_pci_rootbridge_handle);
-
 /* Get device's handler per its address under its parent */
 struct acpi_find_child {
 	acpi_handle handle;

commit cece901481bafbf14de8cbd3a89ae869ea881055
Merge: cfee47f99bc1 50dd096973f1
Author: Len Brown <len.brown@intel.com>
Date:   Sat Dec 16 01:04:27 2006 -0500

    Pull style into test branch
    
    Conflicts:
    
            drivers/acpi/button.c
            drivers/acpi/ec.c
            drivers/acpi/osl.c
            drivers/acpi/sbs.c

commit 463e7c7cf9aaf95dd05e97e1a47854fdf5454cdc
Merge: 25c68a33b7b7 7d63c6759188
Author: Len Brown <len.brown@intel.com>
Date:   Sat Dec 16 00:45:07 2006 -0500

    Pull trivial into test branch
    
    Conflicts:
    
            drivers/acpi/ec.c

commit 465ae641e4a3e5028aa9c85d3843259aa28a22ce
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sat Nov 11 17:18:42 2006 +1100

    ACPI: Change ACPI to use dev_archdata instead of firmware_data
    
    Change ACPI to use dev_archdata instead of firmware_data
    
    This patch changes ACPI to use the new dev_archdata on i386, x86_64
    and ia64 (is there any other arch using ACPI ?) to store it's
    acpi_handle.
    
    It also removes the firmware_data field from struct device as this
    was the only user.
    
    Only build-tested on x86
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 10f160dc75b1..a2f46d587d55 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -267,9 +267,9 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 {
 	acpi_status status;
 
-	if (dev->firmware_data) {
+	if (dev->archdata.acpi_handle) {
 		printk(KERN_WARNING PREFIX
-		       "Drivers changed 'firmware_data' for %s\n", dev->bus_id);
+		       "Drivers changed 'acpi_handle' for %s\n", dev->bus_id);
 		return -EINVAL;
 	}
 	get_device(dev);
@@ -278,25 +278,26 @@ static int acpi_bind_one(struct device *dev, acpi_handle handle)
 		put_device(dev);
 		return -EINVAL;
 	}
-	dev->firmware_data = handle;
+	dev->archdata.acpi_handle = handle;
 
 	return 0;
 }
 
 static int acpi_unbind_one(struct device *dev)
 {
-	if (!dev->firmware_data)
+	if (!dev->archdata.acpi_handle)
 		return 0;
-	if (dev == acpi_get_physical_device(dev->firmware_data)) {
+	if (dev == acpi_get_physical_device(dev->archdata.acpi_handle)) {
 		/* acpi_get_physical_device increase refcnt by one */
 		put_device(dev);
-		acpi_detach_data(dev->firmware_data, acpi_glue_data_handler);
-		dev->firmware_data = NULL;
+		acpi_detach_data(dev->archdata.acpi_handle,
+				 acpi_glue_data_handler);
+		dev->archdata.acpi_handle = NULL;
 		/* acpi_bind_one increase refcnt by one */
 		put_device(dev);
 	} else {
 		printk(KERN_ERR PREFIX
-		       "Oops, 'firmware_data' corrupt for %s\n", dev->bus_id);
+		       "Oops, 'acpi_handle' corrupt for %s\n", dev->bus_id);
 	}
 	return 0;
 }
@@ -328,7 +329,8 @@ static int acpi_platform_notify(struct device *dev)
 	if (!ret) {
 		struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 
-		acpi_get_name(dev->firmware_data, ACPI_FULL_PATHNAME, &buffer);
+		acpi_get_name(dev->archdata.acpi_handle,
+			      ACPI_FULL_PATHNAME, &buffer);
 		DBG("Device %s -> %s\n", dev->bus_id, (char *)buffer.pointer);
 		kfree(buffer.pointer);
 	} else

commit 2f000f5c153e984d5c166e42a9d38113de8693b3
Author: Chen, Justin <justin.chen@hp.com>
Date:   Tue Oct 10 17:07:00 2006 -0400

    ACPI: optimize pci_rootbridge search
    
    acpi_get_pci_rootbridge_handle() walks the ACPI name space
    searching for seg, bus and the PCI_ROOT_HID_STRING --
    returning the handle as soon as if find the match.
    
    But the current codes always parses through the whole namespace because
    the user_function find_pci_rootbridge() returns status=AE_OK when it finds the match.
    
    Make the find_pci_rootbridge() return AE_CTRL_TERMINATE when it finds the match.
    This reduces the ACPI namespace walk for acpi_get_pci_rootbridge_handle().
    
    Signed-off-by: Justin Chen <justin.chen@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 10f160dc75b1..ba8fe83c6298 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -189,8 +189,12 @@ find_pci_rootbridge(acpi_handle handle, u32 lvl, void *context, void **rv)
 	bus = tmp;
 
 	if (seg == find->seg && bus == find->bus)
+	{
 		find->handle = handle;
-	status = AE_OK;
+		status = AE_CTRL_TERMINATE;
+	}
+	else
+		status = AE_OK;
       exit:
 	kfree(buffer.pointer);
 	return status;

commit 50dd096973f1d95aa03c6a6d9e148d706b62b68e
Author: Jan Engelhardt <jengelh@linux01.gwdg.de>
Date:   Sun Oct 1 00:28:50 2006 +0200

    ACPI: Remove unnecessary from/to-void* and to-void casts in drivers/acpi
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 10f160dc75b1..ba5686fa4750 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -96,7 +96,7 @@ struct acpi_find_pci_root {
 static acpi_status
 do_root_bridge_busnr_callback(struct acpi_resource *resource, void *data)
 {
-	unsigned long *busnr = (unsigned long *)data;
+	unsigned long *busnr = data;
 	struct acpi_resource_address64 address;
 
 	if (resource->type != ACPI_RESOURCE_TYPE_ADDRESS16 &&
@@ -217,7 +217,7 @@ do_acpi_find_child(acpi_handle handle, u32 lvl, void *context, void **rv)
 	acpi_status status;
 	struct acpi_device_info *info;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
-	struct acpi_find_child *find = (struct acpi_find_child *)context;
+	struct acpi_find_child *find = context;
 
 	status = acpi_get_object_info(handle, &buffer);
 	if (ACPI_SUCCESS(status)) {

commit 02438d8771ae6a4b215938959827692026380bf9
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jun 30 03:19:10 2006 -0400

    ACPI: delete acpi_os_free(), use kfree() directly
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 8daef57b994c..10f160dc75b1 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -152,7 +152,7 @@ static int get_root_bridge_busnr(acpi_handle handle)
 		bbn = bus;
 	}
       exit:
-	acpi_os_free(buffer.pointer);
+	kfree(buffer.pointer);
 	return (int)bbn;
 }
 
@@ -192,7 +192,7 @@ find_pci_rootbridge(acpi_handle handle, u32 lvl, void *context, void **rv)
 		find->handle = handle;
 	status = AE_OK;
       exit:
-	acpi_os_free(buffer.pointer);
+	kfree(buffer.pointer);
 	return status;
 }
 
@@ -224,7 +224,7 @@ do_acpi_find_child(acpi_handle handle, u32 lvl, void *context, void **rv)
 		info = buffer.pointer;
 		if (info->address == find->address)
 			find->handle = handle;
-		acpi_os_free(buffer.pointer);
+		kfree(buffer.pointer);
 	}
 	return AE_OK;
 }
@@ -330,7 +330,7 @@ static int acpi_platform_notify(struct device *dev)
 
 		acpi_get_name(dev->firmware_data, ACPI_FULL_PATHNAME, &buffer);
 		DBG("Device %s -> %s\n", dev->bus_id, (char *)buffer.pointer);
-		acpi_os_free(buffer.pointer);
+		kfree(buffer.pointer);
 	} else
 		DBG("Device %s -> No ACPI support\n", dev->bus_id);
 #endif

commit 50eca3eb89d73d9f0aa070b126c7ee6a616016ab
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Sep 30 19:03:00 2005 -0400

    [ACPI] ACPICA 20050930
    
    Completed a major overhaul of the Resource Manager code -
    specifically, optimizations in the area of the AML/internal
    resource conversion code. The code has been optimized to
    simplify and eliminate duplicated code, CPU stack use has
    been decreased by optimizing function parameters and local
    variables, and naming conventions across the manager have
    been standardized for clarity and ease of maintenance (this
    includes function, parameter, variable, and struct/typedef
    names.)
    
    All Resource Manager dispatch and information tables have
    been moved to a single location for clarity and ease of
    maintenance. One new file was created, named "rsinfo.c".
    
    The ACPI return macros (return_ACPI_STATUS, etc.) have
    been modified to guarantee that the argument is
    not evaluated twice, making them less prone to macro
    side-effects. However, since there exists the possibility
    of additional stack use if a particular compiler cannot
    optimize them (such as in the debug generation case),
    the original macros are optionally available.  Note that
    some invocations of the return_VALUE macro may now cause
    size mismatch warnings; the return_UINT8 and return_UINT32
    macros are provided to eliminate these. (From Randy Dunlap)
    
    Implemented a new mechanism to enable debug tracing for
    individual control methods. A new external interface,
    acpi_debug_trace(), is provided to enable this mechanism. The
    intent is to allow the host OS to easily enable and disable
    tracing for problematic control methods. This interface
    can be easily exposed to a user or debugger interface if
    desired. See the file psxface.c for details.
    
    acpi_ut_callocate() will now return a valid pointer if a
    length of zero is specified - a length of one is used
    and a warning is issued. This matches the behavior of
    acpi_ut_allocate().
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index fcb881db5b0b..8daef57b994c 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -99,15 +99,15 @@ do_root_bridge_busnr_callback(struct acpi_resource *resource, void *data)
 	unsigned long *busnr = (unsigned long *)data;
 	struct acpi_resource_address64 address;
 
-	if (resource->type != ACPI_RSTYPE_ADDRESS16 &&
-	    resource->type != ACPI_RSTYPE_ADDRESS32 &&
-	    resource->type != ACPI_RSTYPE_ADDRESS64)
+	if (resource->type != ACPI_RESOURCE_TYPE_ADDRESS16 &&
+	    resource->type != ACPI_RESOURCE_TYPE_ADDRESS32 &&
+	    resource->type != ACPI_RESOURCE_TYPE_ADDRESS64)
 		return AE_OK;
 
 	acpi_resource_to_address64(resource, &address);
 	if ((address.address_length > 0) &&
 	    (address.resource_type == ACPI_BUS_NUMBER_RANGE))
-		*busnr = address.min_address_range;
+		*busnr = address.minimum;
 
 	return AE_OK;
 }

commit 3d5271f9883cba7b54762bc4fe027d4172f06db7
Merge: 378b2556f4e0 9115a6c78759
Author: Len Brown <len.brown@intel.com>
Date:   Tue Dec 6 17:31:30 2005 -0500

    Pull release into acpica branch

commit a3a45ec8f8edaf088449e37fe81c99cbf580b9bd
Author: rajesh.shah@intel.com <rajesh.shah@intel.com>
Date:   Mon Oct 31 16:20:12 2005 -0800

    [PATCH] pciehp: clean-up how we request control of hotplug hardware
    
    This patch further tweaks how we request control of hotplug
    controller hardware from BIOS. We first search the ACPI namespace
    corresponding to a specific hotplug controller looking for an
    _OSC or OSHP method. On failure, we successively move to the
    ACPI parent object, till we hit the highest level host bridge
    in the hierarchy. This allows for different types of BIOS's
    which place the _OSC/OSHP methods at various places in the acpi
    namespace, while still not encroaching on the namespace of
    some other root level host bridge.
    
    This patch also introduces a new load time option (pciehp_force)
    that allows us to bypass all _OSC/OSHP checking. Not supporting
    these methods seems to be be the most common ACPI firmware problem
    we've run into. This will still _not_ allow the pciehp driver to
    work correctly if the BIOS really doesn't support pciehp (i.e. if
    it doesn't generate a hotplug interrupt). Use this option with
    caution.  Some BIOS's may deliberately not build any _OSC/OSHP
    methods to make sure it retains control the hotplug hardware.
    Using the pciehp_force parameter for such systems can lead to
    two separate entities trying to control the same hardware.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 3937adf4e5e5..aa993715d644 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -203,6 +203,7 @@ acpi_handle acpi_get_pci_rootbridge_handle(unsigned int seg, unsigned int bus)
 	acpi_get_devices(PCI_ROOT_HID_STRING, find_pci_rootbridge, &find, NULL);
 	return find.handle;
 }
+EXPORT_SYMBOL_GPL(acpi_get_pci_rootbridge_handle);
 
 /* Get device's handler per its address under its parent */
 struct acpi_find_child {

commit 51b190b304bbeb1090ba20b0623d39917fa62997
Author: Peter Chubb <peterc@gelato.unsw.edu.au>
Date:   Wed Oct 19 22:45:14 2005 -0700

    [PATCH] `unaligned access' in acpi get_root_bridge_busnr()
    
    In drivers/acpi/glue.c the address of an integer is cast to the address of
    an unsigned long.  This breaks on systems where a long is larger than an
    int --- for a start the int can be misaligned; for a second the assignment
    through the pointer will overwrite part of the next variable.
    
    Signed-off-by: Peter Chubb <peterc@gelato.unsw.edu.au>
    Acked-by: "Brown, Len" <len.brown@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index e36c5da2b31a..3937adf4e5e5 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -96,7 +96,7 @@ struct acpi_find_pci_root {
 static acpi_status
 do_root_bridge_busnr_callback(struct acpi_resource *resource, void *data)
 {
-	int *busnr = (int *)data;
+	unsigned long *busnr = (unsigned long *)data;
 	struct acpi_resource_address64 address;
 
 	if (resource->id != ACPI_RSTYPE_ADDRESS16 &&
@@ -115,13 +115,13 @@ do_root_bridge_busnr_callback(struct acpi_resource *resource, void *data)
 static int get_root_bridge_busnr(acpi_handle handle)
 {
 	acpi_status status;
-	int bus, bbn;
+	unsigned long bus, bbn;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 
 	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
 
 	status = acpi_evaluate_integer(handle, METHOD_NAME__BBN, NULL,
-				       (unsigned long *)&bbn);
+				       &bbn);
 	if (status == AE_NOT_FOUND) {
 		/* Assume bus = 0 */
 		printk(KERN_INFO PREFIX
@@ -153,7 +153,7 @@ static int get_root_bridge_busnr(acpi_handle handle)
 	}
       exit:
 	acpi_os_free(buffer.pointer);
-	return bbn;
+	return (int)bbn;
 }
 
 static acpi_status

commit eca008c8134df15262a0362623edb59902628c95
Author: Len Brown <len.brown@intel.com>
Date:   Thu Sep 22 00:25:18 2005 -0400

    [ACPI] handle ACPICA 20050916's acpi_resource.type rename
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index e36c5da2b31a..00aeb4801d7a 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -99,9 +99,9 @@ do_root_bridge_busnr_callback(struct acpi_resource *resource, void *data)
 	int *busnr = (int *)data;
 	struct acpi_resource_address64 address;
 
-	if (resource->id != ACPI_RSTYPE_ADDRESS16 &&
-	    resource->id != ACPI_RSTYPE_ADDRESS32 &&
-	    resource->id != ACPI_RSTYPE_ADDRESS64)
+	if (resource->type != ACPI_RSTYPE_ADDRESS16 &&
+	    resource->type != ACPI_RSTYPE_ADDRESS32 &&
+	    resource->type != ACPI_RSTYPE_ADDRESS64)
 		return AE_OK;
 
 	acpi_resource_to_address64(resource, &address);

commit 1dadb3dadfaa01890fc10df03f0dd03a9f8774b2
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Jul 27 18:32:00 2005 -0400

    [ACPI] don't complain about PCI root bridges without _SEG
    
    There are lots of single-PCI-segment machines that don't
    supply _SEG for the root bridges.  The PCI root bridge driver
    silently assumes the segment to be zero in this case,
    so glue.c shouldn't complain either.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 1943461489c2..e36c5da2b31a 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -170,9 +170,6 @@ find_pci_rootbridge(acpi_handle handle, u32 lvl, void *context, void **rv)
 	status = acpi_evaluate_integer(handle, METHOD_NAME__SEG, NULL, &seg);
 	if (status == AE_NOT_FOUND) {
 		/* Assume seg = 0 */
-		printk(KERN_INFO PREFIX
-		       "Assume root bridge [%s] segment is 0\n",
-		       (char *)buffer.pointer);
 		status = AE_OK;
 		seg = 0;
 	}

commit 4be44fcd3bf648b782f4460fd06dfae6c42ded4b
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 5 00:44:28 2005 -0400

    [ACPI] Lindent all ACPI files
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 770cfc8b17e0..1943461489c2 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -29,7 +29,8 @@ int register_acpi_bus_type(struct acpi_bus_type *type)
 		down_write(&bus_type_sem);
 		list_add_tail(&type->list, &bus_type_list);
 		up_write(&bus_type_sem);
-		printk(KERN_INFO PREFIX "bus type %s registered\n", type->bus->name);
+		printk(KERN_INFO PREFIX "bus type %s registered\n",
+		       type->bus->name);
 		return 0;
 	}
 	return -ENODEV;
@@ -45,7 +46,8 @@ int unregister_acpi_bus_type(struct acpi_bus_type *type)
 		down_write(&bus_type_sem);
 		list_del_init(&type->list);
 		up_write(&bus_type_sem);
-		printk(KERN_INFO PREFIX "ACPI bus type %s unregistered\n", type->bus->name);
+		printk(KERN_INFO PREFIX "ACPI bus type %s unregistered\n",
+		       type->bus->name);
 		return 0;
 	}
 	return -ENODEV;

commit ef7b06cd905424aea7c31f27fef622e84e75e650
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Mon Apr 18 22:59:23 2005 -0400

    [ACPI] quiet dmesg related to ACPI PM of PCI devices
    
    DBG("No ACPI bus support for %s\n", dev->bus_id);
    http://bugzilla.kernel.org/show_bug.cgi?id=4277
    
    Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index b6d2045caf3e..770cfc8b17e0 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -29,7 +29,7 @@ int register_acpi_bus_type(struct acpi_bus_type *type)
 		down_write(&bus_type_sem);
 		list_add_tail(&type->list, &bus_type_list);
 		up_write(&bus_type_sem);
-		DBG("ACPI bus type %s registered\n", type->bus->name);
+		printk(KERN_INFO PREFIX "bus type %s registered\n", type->bus->name);
 		return 0;
 	}
 	return -ENODEV;
@@ -45,7 +45,7 @@ int unregister_acpi_bus_type(struct acpi_bus_type *type)
 		down_write(&bus_type_sem);
 		list_del_init(&type->list);
 		up_write(&bus_type_sem);
-		DBG("ACPI bus type %s unregistered\n", type->bus->name);
+		printk(KERN_INFO PREFIX "ACPI bus type %s unregistered\n", type->bus->name);
 		return 0;
 	}
 	return -ENODEV;
@@ -314,14 +314,12 @@ static int acpi_platform_notify(struct device *dev)
 	}
 	type = acpi_get_bus_type(dev->bus);
 	if (!type) {
-		printk(KERN_INFO PREFIX "No ACPI bus support for %s\n",
-		       dev->bus_id);
+		DBG("No ACPI bus support for %s\n", dev->bus_id);
 		ret = -EINVAL;
 		goto end;
 	}
 	if ((ret = type->find_device(dev, &handle)) != 0)
-		printk(KERN_INFO PREFIX "Can't get handler for %s\n",
-		       dev->bus_id);
+		DBG("Can't get handler for %s\n", dev->bus_id);
       end:
 	if (!ret)
 		acpi_bind_one(dev, handle);

commit 4e10d12a3d88c88fba3258809aa42d14fd8cf1d1
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Fri Mar 18 18:45:35 2005 -0500

    [ACPI] Bind PCI devices with ACPI devices
    
    Implement the framework for binding physical devices
    with ACPI devices. A physical bus like PCI bus
    should create a 'acpi_bus_type', with:
    
    .find_device:
            For device which has parent such as normal PCI devices.
    
    .find_bridge:
            It's for special devices, such as PCI root bridge
            or IDE controller.  Such devices generally haven't a
            parent or ->bus. We use the special method
            to get an ACPI handle.
    
    Uses new field in struct device: firmware_data
    
    http://bugzilla.kernel.org/show_bug.cgi?id=4277
    
    Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
new file mode 100644
index 000000000000..b6d2045caf3e
--- /dev/null
+++ b/drivers/acpi/glue.c
@@ -0,0 +1,362 @@
+/*
+ * Link physical devices with ACPI devices support
+ *
+ * Copyright (c) 2005 David Shaohua Li <shaohua.li@intel.com>
+ * Copyright (c) 2005 Intel Corp.
+ *
+ * This file is released under the GPLv2.
+ */
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/rwsem.h>
+#include <linux/acpi.h>
+
+#define ACPI_GLUE_DEBUG	0
+#if ACPI_GLUE_DEBUG
+#define DBG(x...) printk(PREFIX x)
+#else
+#define DBG(x...)
+#endif
+static LIST_HEAD(bus_type_list);
+static DECLARE_RWSEM(bus_type_sem);
+
+int register_acpi_bus_type(struct acpi_bus_type *type)
+{
+	if (acpi_disabled)
+		return -ENODEV;
+	if (type && type->bus && type->find_device) {
+		down_write(&bus_type_sem);
+		list_add_tail(&type->list, &bus_type_list);
+		up_write(&bus_type_sem);
+		DBG("ACPI bus type %s registered\n", type->bus->name);
+		return 0;
+	}
+	return -ENODEV;
+}
+
+EXPORT_SYMBOL(register_acpi_bus_type);
+
+int unregister_acpi_bus_type(struct acpi_bus_type *type)
+{
+	if (acpi_disabled)
+		return 0;
+	if (type) {
+		down_write(&bus_type_sem);
+		list_del_init(&type->list);
+		up_write(&bus_type_sem);
+		DBG("ACPI bus type %s unregistered\n", type->bus->name);
+		return 0;
+	}
+	return -ENODEV;
+}
+
+EXPORT_SYMBOL(unregister_acpi_bus_type);
+
+static struct acpi_bus_type *acpi_get_bus_type(struct bus_type *type)
+{
+	struct acpi_bus_type *tmp, *ret = NULL;
+
+	down_read(&bus_type_sem);
+	list_for_each_entry(tmp, &bus_type_list, list) {
+		if (tmp->bus == type) {
+			ret = tmp;
+			break;
+		}
+	}
+	up_read(&bus_type_sem);
+	return ret;
+}
+
+static int acpi_find_bridge_device(struct device *dev, acpi_handle * handle)
+{
+	struct acpi_bus_type *tmp;
+	int ret = -ENODEV;
+
+	down_read(&bus_type_sem);
+	list_for_each_entry(tmp, &bus_type_list, list) {
+		if (tmp->find_bridge && !tmp->find_bridge(dev, handle)) {
+			ret = 0;
+			break;
+		}
+	}
+	up_read(&bus_type_sem);
+	return ret;
+}
+
+/* Get PCI root bridge's handle from its segment and bus number */
+struct acpi_find_pci_root {
+	unsigned int seg;
+	unsigned int bus;
+	acpi_handle handle;
+};
+
+static acpi_status
+do_root_bridge_busnr_callback(struct acpi_resource *resource, void *data)
+{
+	int *busnr = (int *)data;
+	struct acpi_resource_address64 address;
+
+	if (resource->id != ACPI_RSTYPE_ADDRESS16 &&
+	    resource->id != ACPI_RSTYPE_ADDRESS32 &&
+	    resource->id != ACPI_RSTYPE_ADDRESS64)
+		return AE_OK;
+
+	acpi_resource_to_address64(resource, &address);
+	if ((address.address_length > 0) &&
+	    (address.resource_type == ACPI_BUS_NUMBER_RANGE))
+		*busnr = address.min_address_range;
+
+	return AE_OK;
+}
+
+static int get_root_bridge_busnr(acpi_handle handle)
+{
+	acpi_status status;
+	int bus, bbn;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+
+	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+
+	status = acpi_evaluate_integer(handle, METHOD_NAME__BBN, NULL,
+				       (unsigned long *)&bbn);
+	if (status == AE_NOT_FOUND) {
+		/* Assume bus = 0 */
+		printk(KERN_INFO PREFIX
+		       "Assume root bridge [%s] bus is 0\n",
+		       (char *)buffer.pointer);
+		status = AE_OK;
+		bbn = 0;
+	}
+	if (ACPI_FAILURE(status)) {
+		bbn = -ENODEV;
+		goto exit;
+	}
+	if (bbn > 0)
+		goto exit;
+
+	/* _BBN in some systems return 0 for all root bridges */
+	bus = -1;
+	status = acpi_walk_resources(handle, METHOD_NAME__CRS,
+				     do_root_bridge_busnr_callback, &bus);
+	/* If _CRS failed, we just use _BBN */
+	if (ACPI_FAILURE(status) || (bus == -1))
+		goto exit;
+	/* We select _CRS */
+	if (bbn != bus) {
+		printk(KERN_INFO PREFIX
+		       "_BBN and _CRS returns different value for %s. Select _CRS\n",
+		       (char *)buffer.pointer);
+		bbn = bus;
+	}
+      exit:
+	acpi_os_free(buffer.pointer);
+	return bbn;
+}
+
+static acpi_status
+find_pci_rootbridge(acpi_handle handle, u32 lvl, void *context, void **rv)
+{
+	struct acpi_find_pci_root *find = (struct acpi_find_pci_root *)context;
+	unsigned long seg, bus;
+	acpi_status status;
+	int tmp;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+
+	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+
+	status = acpi_evaluate_integer(handle, METHOD_NAME__SEG, NULL, &seg);
+	if (status == AE_NOT_FOUND) {
+		/* Assume seg = 0 */
+		printk(KERN_INFO PREFIX
+		       "Assume root bridge [%s] segment is 0\n",
+		       (char *)buffer.pointer);
+		status = AE_OK;
+		seg = 0;
+	}
+	if (ACPI_FAILURE(status)) {
+		status = AE_CTRL_DEPTH;
+		goto exit;
+	}
+
+	tmp = get_root_bridge_busnr(handle);
+	if (tmp < 0) {
+		printk(KERN_ERR PREFIX
+		       "Find root bridge failed for %s\n",
+		       (char *)buffer.pointer);
+		status = AE_CTRL_DEPTH;
+		goto exit;
+	}
+	bus = tmp;
+
+	if (seg == find->seg && bus == find->bus)
+		find->handle = handle;
+	status = AE_OK;
+      exit:
+	acpi_os_free(buffer.pointer);
+	return status;
+}
+
+acpi_handle acpi_get_pci_rootbridge_handle(unsigned int seg, unsigned int bus)
+{
+	struct acpi_find_pci_root find = { seg, bus, NULL };
+
+	acpi_get_devices(PCI_ROOT_HID_STRING, find_pci_rootbridge, &find, NULL);
+	return find.handle;
+}
+
+/* Get device's handler per its address under its parent */
+struct acpi_find_child {
+	acpi_handle handle;
+	acpi_integer address;
+};
+
+static acpi_status
+do_acpi_find_child(acpi_handle handle, u32 lvl, void *context, void **rv)
+{
+	acpi_status status;
+	struct acpi_device_info *info;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_find_child *find = (struct acpi_find_child *)context;
+
+	status = acpi_get_object_info(handle, &buffer);
+	if (ACPI_SUCCESS(status)) {
+		info = buffer.pointer;
+		if (info->address == find->address)
+			find->handle = handle;
+		acpi_os_free(buffer.pointer);
+	}
+	return AE_OK;
+}
+
+acpi_handle acpi_get_child(acpi_handle parent, acpi_integer address)
+{
+	struct acpi_find_child find = { NULL, address };
+
+	if (!parent)
+		return NULL;
+	acpi_walk_namespace(ACPI_TYPE_DEVICE, parent,
+			    1, do_acpi_find_child, &find, NULL);
+	return find.handle;
+}
+
+EXPORT_SYMBOL(acpi_get_child);
+
+/* Link ACPI devices with physical devices */
+static void acpi_glue_data_handler(acpi_handle handle,
+				   u32 function, void *context)
+{
+	/* we provide an empty handler */
+}
+
+/* Note: a success call will increase reference count by one */
+struct device *acpi_get_physical_device(acpi_handle handle)
+{
+	acpi_status status;
+	struct device *dev;
+
+	status = acpi_get_data(handle, acpi_glue_data_handler, (void **)&dev);
+	if (ACPI_SUCCESS(status))
+		return get_device(dev);
+	return NULL;
+}
+
+EXPORT_SYMBOL(acpi_get_physical_device);
+
+static int acpi_bind_one(struct device *dev, acpi_handle handle)
+{
+	acpi_status status;
+
+	if (dev->firmware_data) {
+		printk(KERN_WARNING PREFIX
+		       "Drivers changed 'firmware_data' for %s\n", dev->bus_id);
+		return -EINVAL;
+	}
+	get_device(dev);
+	status = acpi_attach_data(handle, acpi_glue_data_handler, dev);
+	if (ACPI_FAILURE(status)) {
+		put_device(dev);
+		return -EINVAL;
+	}
+	dev->firmware_data = handle;
+
+	return 0;
+}
+
+static int acpi_unbind_one(struct device *dev)
+{
+	if (!dev->firmware_data)
+		return 0;
+	if (dev == acpi_get_physical_device(dev->firmware_data)) {
+		/* acpi_get_physical_device increase refcnt by one */
+		put_device(dev);
+		acpi_detach_data(dev->firmware_data, acpi_glue_data_handler);
+		dev->firmware_data = NULL;
+		/* acpi_bind_one increase refcnt by one */
+		put_device(dev);
+	} else {
+		printk(KERN_ERR PREFIX
+		       "Oops, 'firmware_data' corrupt for %s\n", dev->bus_id);
+	}
+	return 0;
+}
+
+static int acpi_platform_notify(struct device *dev)
+{
+	struct acpi_bus_type *type;
+	acpi_handle handle;
+	int ret = -EINVAL;
+
+	if (!dev->bus || !dev->parent) {
+		/* bridge devices genernally haven't bus or parent */
+		ret = acpi_find_bridge_device(dev, &handle);
+		goto end;
+	}
+	type = acpi_get_bus_type(dev->bus);
+	if (!type) {
+		printk(KERN_INFO PREFIX "No ACPI bus support for %s\n",
+		       dev->bus_id);
+		ret = -EINVAL;
+		goto end;
+	}
+	if ((ret = type->find_device(dev, &handle)) != 0)
+		printk(KERN_INFO PREFIX "Can't get handler for %s\n",
+		       dev->bus_id);
+      end:
+	if (!ret)
+		acpi_bind_one(dev, handle);
+
+#if ACPI_GLUE_DEBUG
+	if (!ret) {
+		struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+
+		acpi_get_name(dev->firmware_data, ACPI_FULL_PATHNAME, &buffer);
+		DBG("Device %s -> %s\n", dev->bus_id, (char *)buffer.pointer);
+		acpi_os_free(buffer.pointer);
+	} else
+		DBG("Device %s -> No ACPI support\n", dev->bus_id);
+#endif
+
+	return ret;
+}
+
+static int acpi_platform_notify_remove(struct device *dev)
+{
+	acpi_unbind_one(dev);
+	return 0;
+}
+
+static int __init init_acpi_device_notify(void)
+{
+	if (acpi_disabled)
+		return 0;
+	if (platform_notify || platform_notify_remove) {
+		printk(KERN_ERR PREFIX "Can't use platform_notify\n");
+		return 0;
+	}
+	platform_notify = acpi_platform_notify;
+	platform_notify_remove = acpi_platform_notify_remove;
+	return 0;
+}
+
+arch_initcall(init_acpi_device_notify);
