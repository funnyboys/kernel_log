commit 1e05daca83bb42cde569f75f3bd7c8828b1ef30f
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Wed Jun 24 11:51:40 2020 -0700

    ACPI: DPTF: Add battery participant for TigerLake
    
    Add DPTF battery participant ACPI ID for platforms based on the Intel
    TigerLake SoC.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/dptf/dptf_power.c b/drivers/acpi/dptf/dptf_power.c
index 5fab7e350db8..92b996a564d0 100644
--- a/drivers/acpi/dptf/dptf_power.c
+++ b/drivers/acpi/dptf/dptf_power.c
@@ -228,6 +228,7 @@ static const struct acpi_device_id int3407_device_ids[] = {
 	{"INT3407", 0},
 	{"INT3532", 0},
 	{"INTC1047", 0},
+	{"INTC1050", 0},
 	{"", 0},
 };
 MODULE_DEVICE_TABLE(acpi, int3407_device_ids);

commit 7b52b200cf5bdd04f3ee22121960bd6f4ec5efa1
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Fri May 22 14:45:09 2020 -0700

    ACPI: DPTF: Add battery participant driver
    
    This driver adds support for Dynamic Platform and Thermal Framework
    battery participant device support.
    
    These attributes are presented via sysfs interface under the platform
    device for the battery participant:
    $ls /sys/bus/platform/devices/INT3532:00/dptf_battery
            current_discharge_capbility_ma
            max_platform_power_mw
            no_load_voltage_mv
            high_freq_impedance_mohm
            max_steady_state_power_mw
    
    Refer to the documentation at
    Documentation/ABI/testing/sysfs-platform-dptf
    for details.
    
    Here the implementation reuses existing dptf-power.c as the motivation and
    processing is same. It also shares one ACPI method. Here this change is
    using participant type, "PTYP" method to identify and do different
    processing. By using participant type, create/delete either "dptf_power"
    or "dptf_battery" attribute group and send notifications.
    
    The particpant type for for the battery participant is 0x0C.
    
    ACPI methods description:
    
    PMAX (Intel(R) Dynamic Tuning Platform Max Power Supplied by Battery):
    This object evaluates to the maximum platform power that can be supported
    by the battery in milli watts.
    
    PBSS (Intel(R) Dynamic Tuning Power Battery Steady State):
    This object returns the max sustained power for battery in milli watts.
    
    RBHF (Intel(R) Dynamic Tuning High Frequency Impedance):
    This object returns high frequency impedance value that can be obtained
    from battery fuel gauge.
    
    VBNL (Intel(R) Dynamic Tuning No-Load Voltage)
    This object returns battery instantaneous no-load voltage that can be
    obtained from battery fuel gauge in milli volts
    
    CMPP (Intel(R) Dynamic Tuning Current Discharge Capability)
    This object returns battery discharge current capability obtained from
    battery fuel gauge milli amps.
    
    Notifications:
    
    0x80: PMAX change. Used to notify Intel(R)Dynamic Tuning Battery
    participant driver when the PMAX has changed by 250mw.
    0x83: PBSS change. Used to notify Intel(R) Dynamic Tuning Battery
    participant driver when the power source has changed.
    0x85: RBHF change. Used to notify Intel(R)Dynamic Tuning Battery
    participant driver when the RBHF has changed over a threshold by
    5mOhm.
    0x86: Battery Capability change. Used to notify Intel(R)Dynamic Tuning
    Battery participant driver when the battery capability has changed.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    [ rjw: Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/dptf/dptf_power.c b/drivers/acpi/dptf/dptf_power.c
index abe99039af74..5fab7e350db8 100644
--- a/drivers/acpi/dptf/dptf_power.c
+++ b/drivers/acpi/dptf/dptf_power.c
@@ -10,13 +10,19 @@
 #include <linux/platform_device.h>
 
 /*
- * Presentation of attributes which are defined for INT3407. They are:
+ * Presentation of attributes which are defined for INT3407 and INT3532.
+ * They are:
  * PMAX : Maximum platform powe
  * PSRC : Platform power source
  * ARTG : Adapter rating
  * CTYP : Charger type
  * PBSS : Battery steady power
  * PROP : Rest of worst case platform Power
+ * PBSS : Power Battery Steady State
+ * PBSS : Power Battery Steady State
+ * RBHF : High Frequency Impedance
+ * VBNL : Instantaneous No-Load Voltage
+ * CMPP : Current Discharge Capability
  */
 #define DPTF_POWER_SHOW(name, object) \
 static ssize_t name##_show(struct device *dev,\
@@ -41,6 +47,10 @@ DPTF_POWER_SHOW(adapter_rating_mw, ARTG)
 DPTF_POWER_SHOW(battery_steady_power_mw, PBSS)
 DPTF_POWER_SHOW(charger_type, CTYP)
 DPTF_POWER_SHOW(rest_of_platform_power_mw, PROP)
+DPTF_POWER_SHOW(max_steady_state_power_mw, PBSS)
+DPTF_POWER_SHOW(high_freq_impedance_mohm, RBHF)
+DPTF_POWER_SHOW(no_load_voltage_mv, VBNL)
+DPTF_POWER_SHOW(current_discharge_capbility_ma, CMPP);
 
 static DEVICE_ATTR_RO(max_platform_power_mw);
 static DEVICE_ATTR_RO(platform_power_source);
@@ -48,6 +58,10 @@ static DEVICE_ATTR_RO(adapter_rating_mw);
 static DEVICE_ATTR_RO(battery_steady_power_mw);
 static DEVICE_ATTR_RO(charger_type);
 static DEVICE_ATTR_RO(rest_of_platform_power_mw);
+static DEVICE_ATTR_RO(max_steady_state_power_mw);
+static DEVICE_ATTR_RO(high_freq_impedance_mohm);
+static DEVICE_ATTR_RO(no_load_voltage_mv);
+static DEVICE_ATTR_RO(current_discharge_capbility_ma);
 
 static ssize_t prochot_confirm_store(struct device *dev,
 				     struct device_attribute *attr,
@@ -85,8 +99,38 @@ static const struct attribute_group dptf_power_attribute_group = {
 	.name = "dptf_power"
 };
 
+static struct attribute *dptf_battery_attrs[] = {
+	&dev_attr_max_platform_power_mw.attr,
+	&dev_attr_max_steady_state_power_mw.attr,
+	&dev_attr_high_freq_impedance_mohm.attr,
+	&dev_attr_no_load_voltage_mv.attr,
+	&dev_attr_current_discharge_capbility_ma.attr,
+	NULL
+};
+
+static const struct attribute_group dptf_battery_attribute_group = {
+	.attrs = dptf_battery_attrs,
+	.name = "dptf_battery"
+};
+
+#define MAX_POWER_CHANGED		0x80
 #define POWER_STATE_CHANGED		0x81
+#define STEADY_STATE_POWER_CHANGED	0x83
 #define POWER_PROP_CHANGE_EVENT	0x84
+#define IMPEDANCED_CHNGED		0x85
+#define VOLTAGE_CURRENT_CHANGED	0x86
+
+static long long dptf_participant_type(acpi_handle handle)
+{
+	unsigned long long ptype;
+	acpi_status status;
+
+	status = acpi_evaluate_integer(handle, "PTYP", NULL, &ptype);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	return ptype;
+}
 
 static void dptf_power_notify(acpi_handle handle, u32 event, void *data)
 {
@@ -100,6 +144,15 @@ static void dptf_power_notify(acpi_handle handle, u32 event, void *data)
 	case POWER_PROP_CHANGE_EVENT:
 		attr = "rest_of_platform_power_mw";
 		break;
+	case MAX_POWER_CHANGED:
+		attr = "max_platform_power_mw";
+		break;
+	case STEADY_STATE_POWER_CHANGED:
+		attr = "max_steady_state_power_mw";
+		break;
+	case VOLTAGE_CURRENT_CHANGED:
+		attr = "no_load_voltage_mv";
+		break;
 	default:
 		dev_err(&pdev->dev, "Unsupported event [0x%x]\n", event);
 		return;
@@ -109,13 +162,16 @@ static void dptf_power_notify(acpi_handle handle, u32 event, void *data)
 	 * Notify that an attribute is changed, so that user space can read
 	 * again.
 	 */
-	sysfs_notify(&pdev->dev.kobj, "dptf_power", attr);
+	if (dptf_participant_type(handle) == 0x0CULL)
+		sysfs_notify(&pdev->dev.kobj, "dptf_battery", attr);
+	else
+		sysfs_notify(&pdev->dev.kobj, "dptf_power", attr);
 }
 
 static int dptf_power_add(struct platform_device *pdev)
 {
+	const struct attribute_group *attr_group;
 	struct acpi_device *acpi_dev;
-	acpi_status status;
 	unsigned long long ptype;
 	int result;
 
@@ -123,11 +179,12 @@ static int dptf_power_add(struct platform_device *pdev)
 	if (!acpi_dev)
 		return -ENODEV;
 
-	status = acpi_evaluate_integer(acpi_dev->handle, "PTYP", NULL, &ptype);
-	if (ACPI_FAILURE(status))
-		return -ENODEV;
-
-	if (ptype != 0x11)
+	ptype = dptf_participant_type(acpi_dev->handle);
+	if (ptype == 0x11)
+		attr_group = &dptf_power_attribute_group;
+	else if (ptype == 0x0C)
+		attr_group = &dptf_battery_attribute_group;
+	else
 		return -ENODEV;
 
 	result = acpi_install_notify_handler(acpi_dev->handle,
@@ -138,7 +195,7 @@ static int dptf_power_add(struct platform_device *pdev)
 		return result;
 
 	result = sysfs_create_group(&pdev->dev.kobj,
-				    &dptf_power_attribute_group);
+				    attr_group);
 	if (result) {
 		acpi_remove_notify_handler(acpi_dev->handle,
 					   ACPI_DEVICE_NOTIFY,
@@ -158,13 +215,18 @@ static int dptf_power_remove(struct platform_device *pdev)
 	acpi_remove_notify_handler(acpi_dev->handle,
 				   ACPI_DEVICE_NOTIFY,
 				   dptf_power_notify);
-	sysfs_remove_group(&pdev->dev.kobj, &dptf_power_attribute_group);
+
+	if (dptf_participant_type(acpi_dev->handle) == 0x0CULL)
+		sysfs_remove_group(&pdev->dev.kobj, &dptf_battery_attribute_group);
+	else
+		sysfs_remove_group(&pdev->dev.kobj, &dptf_power_attribute_group);
 
 	return 0;
 }
 
 static const struct acpi_device_id int3407_device_ids[] = {
 	{"INT3407", 0},
+	{"INT3532", 0},
 	{"INTC1047", 0},
 	{"", 0},
 };

commit 668ce99e4ed4c07bb14465f80492bc6cf76ed3c9
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu May 21 13:30:15 2020 -0700

    ACPI: DPTF: Additional sysfs attributes for power participant driver
    
    Add two additional attributes to the existing power participant driver:
    rest_of_platform_power_mw: (RO) Shows the rest of worst case platform
    power in mW outside of S0C. This will help in power distribution to SoC
    and rest of the system. For example on a test system, this value is 2.5W
    with a 15W TDP SoC. Based on the adapter rating (adapter_rating_mw), user
    space software can decide on proper power allocation to SoC to improve
    short term performance via powercap/RAPL interface.
    
    prochot_confirm: (WO) Confirm EC about a prochot notification.
    
    Also userspace is notified via sysfs_notify(), whenever power source or
    rest of the platform power is changed. So user space can use poll()
    system call on those attributes.
    
    The ACPI methods used in this patch are as follows:
    
    PROP
    This object evaluates to the rest of worst case platform power in mW.
    Bits:
    23:0 Worst case rest of platform power in mW.
    
    PBOK
    PBOK is a method designed to provide a mechanism for OSPM to change power
    setting before EC can de-assert a PROCHOT from a device. The EC may
    receive several PROCHOTs, so it has a sequence number attached to PSRC
    (read via existing attribute "platform_power_source"). Once OSPM takes
    action for a PSRC change notification, it can call PBOK method to confirm
    with the sequence number.
    Bits:
    3:0 Power Delivery State Change Sequence number
    30  Reserved
    31  0 – Not OK to de-assert PROCHOT
        1 – OK to de-assert PROCHOT
    
    PSRC (Platform Power Source): Not new in this patch but for
    documentation for new bits
    This object evaluates to an integer that represents the system power
    source as well as the power delivery state change sequence number.
    Bits:
    3:0 The current power source as an integer for AC, DC, USB, Wireless.
    0 = DC, 1 = AC, 2 = USB, 3 = Wireless Charging
    7:4 Power Delivery State Change Sequence Number. Default value is 0
    
    Notifications:
    0x81: (Power State Change) Used to notify when the power source has
    changed.
    0x84: (PROP change) Used to notify when the platform rest of power has
    changed.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    [ rjw: Subject, minor ABI documentation edit ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/dptf/dptf_power.c b/drivers/acpi/dptf/dptf_power.c
index e4e8b75d39f0..abe99039af74 100644
--- a/drivers/acpi/dptf/dptf_power.c
+++ b/drivers/acpi/dptf/dptf_power.c
@@ -16,6 +16,7 @@
  * ARTG : Adapter rating
  * CTYP : Charger type
  * PBSS : Battery steady power
+ * PROP : Rest of worst case platform Power
  */
 #define DPTF_POWER_SHOW(name, object) \
 static ssize_t name##_show(struct device *dev,\
@@ -39,12 +40,34 @@ DPTF_POWER_SHOW(platform_power_source, PSRC)
 DPTF_POWER_SHOW(adapter_rating_mw, ARTG)
 DPTF_POWER_SHOW(battery_steady_power_mw, PBSS)
 DPTF_POWER_SHOW(charger_type, CTYP)
+DPTF_POWER_SHOW(rest_of_platform_power_mw, PROP)
 
 static DEVICE_ATTR_RO(max_platform_power_mw);
 static DEVICE_ATTR_RO(platform_power_source);
 static DEVICE_ATTR_RO(adapter_rating_mw);
 static DEVICE_ATTR_RO(battery_steady_power_mw);
 static DEVICE_ATTR_RO(charger_type);
+static DEVICE_ATTR_RO(rest_of_platform_power_mw);
+
+static ssize_t prochot_confirm_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct acpi_device *acpi_dev = dev_get_drvdata(dev);
+	acpi_status status;
+	int seq_no;
+
+	if (kstrtouint(buf, 0, &seq_no) < 0)
+		return -EINVAL;
+
+	status = acpi_execute_simple_method(acpi_dev->handle, "PBOK", seq_no);
+	if (ACPI_SUCCESS(status))
+		return count;
+
+	return -EINVAL;
+}
+
+static DEVICE_ATTR_WO(prochot_confirm);
 
 static struct attribute *dptf_power_attrs[] = {
 	&dev_attr_max_platform_power_mw.attr,
@@ -52,6 +75,8 @@ static struct attribute *dptf_power_attrs[] = {
 	&dev_attr_adapter_rating_mw.attr,
 	&dev_attr_battery_steady_power_mw.attr,
 	&dev_attr_charger_type.attr,
+	&dev_attr_rest_of_platform_power_mw.attr,
+	&dev_attr_prochot_confirm.attr,
 	NULL
 };
 
@@ -60,6 +85,33 @@ static const struct attribute_group dptf_power_attribute_group = {
 	.name = "dptf_power"
 };
 
+#define POWER_STATE_CHANGED		0x81
+#define POWER_PROP_CHANGE_EVENT	0x84
+
+static void dptf_power_notify(acpi_handle handle, u32 event, void *data)
+{
+	struct platform_device *pdev = data;
+	char *attr;
+
+	switch (event) {
+	case POWER_STATE_CHANGED:
+		attr = "platform_power_source";
+		break;
+	case POWER_PROP_CHANGE_EVENT:
+		attr = "rest_of_platform_power_mw";
+		break;
+	default:
+		dev_err(&pdev->dev, "Unsupported event [0x%x]\n", event);
+		return;
+	}
+
+	/*
+	 * Notify that an attribute is changed, so that user space can read
+	 * again.
+	 */
+	sysfs_notify(&pdev->dev.kobj, "dptf_power", attr);
+}
+
 static int dptf_power_add(struct platform_device *pdev)
 {
 	struct acpi_device *acpi_dev;
@@ -78,10 +130,21 @@ static int dptf_power_add(struct platform_device *pdev)
 	if (ptype != 0x11)
 		return -ENODEV;
 
+	result = acpi_install_notify_handler(acpi_dev->handle,
+					     ACPI_DEVICE_NOTIFY,
+					     dptf_power_notify,
+					     (void *)pdev);
+	if (result)
+		return result;
+
 	result = sysfs_create_group(&pdev->dev.kobj,
 				    &dptf_power_attribute_group);
-	if (result)
+	if (result) {
+		acpi_remove_notify_handler(acpi_dev->handle,
+					   ACPI_DEVICE_NOTIFY,
+					   dptf_power_notify);
 		return result;
+	}
 
 	platform_set_drvdata(pdev, acpi_dev);
 
@@ -90,7 +153,11 @@ static int dptf_power_add(struct platform_device *pdev)
 
 static int dptf_power_remove(struct platform_device *pdev)
 {
+	struct acpi_device *acpi_dev = platform_get_drvdata(pdev);
 
+	acpi_remove_notify_handler(acpi_dev->handle,
+				   ACPI_DEVICE_NOTIFY,
+				   dptf_power_notify);
 	sysfs_remove_group(&pdev->dev.kobj, &dptf_power_attribute_group);
 
 	return 0;

commit b62c770fee699a137359e1f1da9bf14a7f348567
Author: Gayatri Kammela <gayatri.kammela@intel.com>
Date:   Fri Mar 27 14:28:19 2020 -0700

    ACPI: Update Tiger Lake ACPI device IDs
    
    Tiger Lake's new unique ACPI device IDs for DPTF and fan drivers are not
    valid as the IDs are missing 'C'. Fix the IDs by updating them.
    
    After the update, the new IDs should now look like
    INT1047 --> INTC1047
    INT1040 --> INTC1040
    INT1043 --> INTC1043
    INT1044 --> INTC1044
    
    Fixes: 55cfe6a5c582 ("ACPI: DPTF: Add Tiger Lake ACPI device IDs")
    Fixes: c248dfe7e0ca ("ACPI: fan: Add Tiger Lake ACPI device ID")
    Suggested-by: Srinivas Pandruvada <srinivas.pandruvada@intel.com>
    Signed-off-by: Gayatri Kammela <gayatri.kammela@intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/dptf/dptf_power.c b/drivers/acpi/dptf/dptf_power.c
index 387f27ef3368..e4e8b75d39f0 100644
--- a/drivers/acpi/dptf/dptf_power.c
+++ b/drivers/acpi/dptf/dptf_power.c
@@ -97,8 +97,8 @@ static int dptf_power_remove(struct platform_device *pdev)
 }
 
 static const struct acpi_device_id int3407_device_ids[] = {
-	{"INT1047", 0},
 	{"INT3407", 0},
+	{"INTC1047", 0},
 	{"", 0},
 };
 MODULE_DEVICE_TABLE(acpi, int3407_device_ids);

commit 55cfe6a5c58223c51ee095693958738ee0d4c942
Author: Gayatri Kammela <gayatri.kammela@intel.com>
Date:   Mon Dec 16 10:31:48 2019 -0800

    ACPI: DPTF: Add Tiger Lake ACPI device IDs
    
    Tiger Lake has new unique ACPI device IDs that need to be added to the
    DPTF drivers to support it.
    
    Signed-off-by: Gayatri Kammela <gayatri.kammela@intel.com>
    [ rjw: Subject & changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/dptf/dptf_power.c b/drivers/acpi/dptf/dptf_power.c
index eb58fc475a03..387f27ef3368 100644
--- a/drivers/acpi/dptf/dptf_power.c
+++ b/drivers/acpi/dptf/dptf_power.c
@@ -97,6 +97,7 @@ static int dptf_power_remove(struct platform_device *pdev)
 }
 
 static const struct acpi_device_id int3407_device_ids[] = {
+	{"INT1047", 0},
 	{"INT3407", 0},
 	{"", 0},
 };

commit 2025cf9e193de05b0654570dd639acb49ebd3adf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:18:02 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 288
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 263 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141901.208660670@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/dptf/dptf_power.c b/drivers/acpi/dptf/dptf_power.c
index 0c081390930a..eb58fc475a03 100644
--- a/drivers/acpi/dptf/dptf_power.c
+++ b/drivers/acpi/dptf/dptf_power.c
@@ -1,16 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * dptf_power:  DPTF platform power driver
  * Copyright (c) 2016, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
  */
 
 #include <linux/kernel.h>

commit b0f65b917987dee71d0b1d3c65c0b52db00a55e0
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Tue Apr 23 15:49:56 2019 +0800

    ACPI / DPTF: Use dev_get_drvdata()
    
    Skip conversion to platform_device and use dev_get_drvdata() directly.
    
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/dptf/dptf_power.c b/drivers/acpi/dptf/dptf_power.c
index e1c242568341..0c081390930a 100644
--- a/drivers/acpi/dptf/dptf_power.c
+++ b/drivers/acpi/dptf/dptf_power.c
@@ -31,8 +31,7 @@ static ssize_t name##_show(struct device *dev,\
 			   struct device_attribute *attr,\
 			   char *buf)\
 {\
-	struct platform_device *pdev = to_platform_device(dev);\
-	struct acpi_device *acpi_dev = platform_get_drvdata(pdev);\
+	struct acpi_device *acpi_dev = dev_get_drvdata(dev);\
 	unsigned long long val;\
 	acpi_status status;\
 \

commit 9e4de6a8eee204af51d9e6a4d87f54c7b8b94f11
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Jun 30 18:32:49 2017 +0530

    ACPI / DPTF: constify attribute_group structures
    
    attribute_groups are not supposed to change at runtime. All functions
    working with attribute_groups provided by <linux/sysfs.h> work with const
    attribute_group. So mark the non-const structs as const.
    
    File size before:
       text    data     bss     dec     hex filename
        904     496       0    1400     578 drivers/acpi/dptf/dptf_power.o
    
    File size After adding 'const':
       text    data     bss     dec     hex filename
        944     432       0    1376     560 drivers/acpi/dptf/dptf_power.o
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/dptf/dptf_power.c b/drivers/acpi/dptf/dptf_power.c
index 734642dc5008..e1c242568341 100644
--- a/drivers/acpi/dptf/dptf_power.c
+++ b/drivers/acpi/dptf/dptf_power.c
@@ -65,7 +65,7 @@ static struct attribute *dptf_power_attrs[] = {
 	NULL
 };
 
-static struct attribute_group dptf_power_attribute_group = {
+static const struct attribute_group dptf_power_attribute_group = {
 	.attrs = dptf_power_attrs,
 	.name = "dptf_power"
 };

commit 6256ebd5daf93505f12b66916fb1b961b38f4cf2
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Sun Jul 17 13:45:32 2016 -0700

    ACPI / DPTF: Add DPTF power participant driver
    
    This driver adds support for Dynamic Platform and Thermal Framework
    (DPTF) Platform Power Participant device (INT3407) support.
    
    This participant is responsible for exposing platform telemetry such as:
        max_platform_power
        platform_power_source
        adapter_rating
        battery_steady_power
        charger_type
    
    These attributes are presented via sysfs interface under the INT3407
    platform device:
    $ls /sys/bus/platform/devices/INT3407\:00/dptf_power/
        adapter_rating_mw
        battery_steady_power_mw
        charger_type
        max_platform_power_mw
        platform_power_source
        `
    ACPI methods description used in this driver:
        PMAX: Maximum platform power that can be supported by the battery in
              mW.
        PSRC: System charge source,
                0x00 = DC
                0x01 = AC
                0x02 = USB
                0x03 = Wireless Charger
        ARTG: Adapter rating in mW (Maximum Adapter power) Must be 0 if no
              AC adapter is plugged in.
        CTYP: Charger Type,
                Traditional : 0x01
                Hybrid: 0x02
                NVDC: 0x03
        PBSS: Returns max sustained power for battery in milliWatts.
    
    The INT3407 also contains _BTS and _BIX objects, which are compliant to
    ACPI 5.0, specification. Those objects are already used by ACPI battery
    (PNP0C0A) driver and information about them is exported via Linux power
    supply class registration.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/dptf/dptf_power.c b/drivers/acpi/dptf/dptf_power.c
new file mode 100644
index 000000000000..734642dc5008
--- /dev/null
+++ b/drivers/acpi/dptf/dptf_power.c
@@ -0,0 +1,128 @@
+/*
+ * dptf_power:  DPTF platform power driver
+ * Copyright (c) 2016, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/acpi.h>
+#include <linux/platform_device.h>
+
+/*
+ * Presentation of attributes which are defined for INT3407. They are:
+ * PMAX : Maximum platform powe
+ * PSRC : Platform power source
+ * ARTG : Adapter rating
+ * CTYP : Charger type
+ * PBSS : Battery steady power
+ */
+#define DPTF_POWER_SHOW(name, object) \
+static ssize_t name##_show(struct device *dev,\
+			   struct device_attribute *attr,\
+			   char *buf)\
+{\
+	struct platform_device *pdev = to_platform_device(dev);\
+	struct acpi_device *acpi_dev = platform_get_drvdata(pdev);\
+	unsigned long long val;\
+	acpi_status status;\
+\
+	status = acpi_evaluate_integer(acpi_dev->handle, #object,\
+				       NULL, &val);\
+	if (ACPI_SUCCESS(status))\
+		return sprintf(buf, "%d\n", (int)val);\
+	else \
+		return -EINVAL;\
+}
+
+DPTF_POWER_SHOW(max_platform_power_mw, PMAX)
+DPTF_POWER_SHOW(platform_power_source, PSRC)
+DPTF_POWER_SHOW(adapter_rating_mw, ARTG)
+DPTF_POWER_SHOW(battery_steady_power_mw, PBSS)
+DPTF_POWER_SHOW(charger_type, CTYP)
+
+static DEVICE_ATTR_RO(max_platform_power_mw);
+static DEVICE_ATTR_RO(platform_power_source);
+static DEVICE_ATTR_RO(adapter_rating_mw);
+static DEVICE_ATTR_RO(battery_steady_power_mw);
+static DEVICE_ATTR_RO(charger_type);
+
+static struct attribute *dptf_power_attrs[] = {
+	&dev_attr_max_platform_power_mw.attr,
+	&dev_attr_platform_power_source.attr,
+	&dev_attr_adapter_rating_mw.attr,
+	&dev_attr_battery_steady_power_mw.attr,
+	&dev_attr_charger_type.attr,
+	NULL
+};
+
+static struct attribute_group dptf_power_attribute_group = {
+	.attrs = dptf_power_attrs,
+	.name = "dptf_power"
+};
+
+static int dptf_power_add(struct platform_device *pdev)
+{
+	struct acpi_device *acpi_dev;
+	acpi_status status;
+	unsigned long long ptype;
+	int result;
+
+	acpi_dev = ACPI_COMPANION(&(pdev->dev));
+	if (!acpi_dev)
+		return -ENODEV;
+
+	status = acpi_evaluate_integer(acpi_dev->handle, "PTYP", NULL, &ptype);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	if (ptype != 0x11)
+		return -ENODEV;
+
+	result = sysfs_create_group(&pdev->dev.kobj,
+				    &dptf_power_attribute_group);
+	if (result)
+		return result;
+
+	platform_set_drvdata(pdev, acpi_dev);
+
+	return 0;
+}
+
+static int dptf_power_remove(struct platform_device *pdev)
+{
+
+	sysfs_remove_group(&pdev->dev.kobj, &dptf_power_attribute_group);
+
+	return 0;
+}
+
+static const struct acpi_device_id int3407_device_ids[] = {
+	{"INT3407", 0},
+	{"", 0},
+};
+MODULE_DEVICE_TABLE(acpi, int3407_device_ids);
+
+static struct platform_driver dptf_power_driver = {
+	.probe = dptf_power_add,
+	.remove = dptf_power_remove,
+	.driver = {
+		.name = "DPTF Platform Power",
+		.acpi_match_table = int3407_device_ids,
+	},
+};
+
+module_platform_driver(dptf_power_driver);
+
+MODULE_AUTHOR("Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("ACPI DPTF platform power driver");
