commit 0c67f6b29715ff888cb967cc98336221a8a23916
Merge: 49f13b0921aa 50dd154ed7b1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 10 14:04:39 2020 -0700

    Merge tag 'pm-5.8-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more power management updates from Rafael Wysocki:
     "These are operating performance points (OPP) framework updates mostly,
      including support for interconnect bandwidth in the OPP core, plus a
      few cpufreq changes, including boost support in the CPPC cpufreq
      driver, an ACPI device power management fix and a hibernation code
      cleanup.
    
      Specifics:
    
       - Add support for interconnect bandwidth to the OPP core (Georgi
         Djakov, Saravana Kannan, Sibi Sankar, Viresh Kumar).
    
       - Add support for regulator enable/disable to the OPP core (Kamil
         Konieczny).
    
       - Add boost support to the CPPC cpufreq driver (Xiongfeng Wang).
    
       - Make the tegra186 cpufreq driver set the
         CPUFREQ_NEED_INITIAL_FREQ_CHECK flag (Mian Yousaf Kaukab).
    
       - Prevent the ACPI power management from using power resources with
         devices where the list of power resources for power state D0 (full
         power) is missing (Rafael Wysocki).
    
       - Annotate a hibernation-related function with __init (Christophe
         JAILLET)"
    
    * tag 'pm-5.8-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      ACPI: PM: Avoid using power resources if there are none for D0
      cpufreq: CPPC: add SW BOOST support
      cpufreq: change '.set_boost' to act on one policy
      PM: hibernate: Add __init annotation to swsusp_header_init()
      opp: Don't parse icc paths unnecessarily
      opp: Remove bandwidth votes when target_freq is zero
      opp: core: add regulators enable and disable
      opp: Reorder the code for !target_freq case
      opp: Expose bandwidth information via debugfs
      cpufreq: dt: Add support for interconnect bandwidth scaling
      opp: Update the bandwidth on OPP frequency changes
      opp: Add sanity checks in _read_opp_key()
      opp: Add support for parsing interconnect bandwidth
      cpufreq: tegra186: add CPUFREQ_NEED_INITIAL_FREQ_CHECK flag
      OPP: Add helpers for reading the binding properties
      dt-bindings: opp: Introduce opp-peak-kBps and opp-avg-kBps bindings

commit 65fddcfca8ad14778f71a57672fd01e8112d30fa
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:42 2020 -0700

    mm: reorder includes after introduction of linux/pgtable.h
    
    The replacement of <asm/pgrable.h> with <linux/pgtable.h> made the include
    of the latter in the middle of asm includes.  Fix this up with the aid of
    the below script and manual adjustments here and there.
    
            import sys
            import re
    
            if len(sys.argv) is not 3:
                print "USAGE: %s <file> <header>" % (sys.argv[0])
                sys.exit(1)
    
            hdr_to_move="#include <linux/%s>" % sys.argv[2]
            moved = False
            in_hdrs = False
    
            with open(sys.argv[1], "r") as f:
                lines = f.readlines()
                for _line in lines:
                    line = _line.rstrip('
    ')
                    if line == hdr_to_move:
                        continue
                    if line.startswith("#include <linux/"):
                        in_hdrs = True
                    elif not moved and in_hdrs:
                        moved = True
                        print hdr_to_move
                    print line
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-4-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8df00430e80a..4da23e751bce 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -15,7 +15,6 @@
 #include <linux/nls.h>
 #include <linux/dma-mapping.h>
 #include <linux/platform_data/x86/apple.h>
-
 #include <linux/pgtable.h>
 
 #include "internal.h"

commit ca5999fde0a1761665a38e4c9a72dbcd7d190a81
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:38 2020 -0700

    mm: introduce include/linux/pgtable.h
    
    The include/linux/pgtable.h is going to be the home of generic page table
    manipulation functions.
    
    Start with moving asm-generic/pgtable.h to include/linux/pgtable.h and
    make the latter include asm/pgtable.h.
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-3-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5287ab98b8c1..8df00430e80a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -16,7 +16,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/platform_data/x86/apple.h>
 
-#include <asm/pgtable.h>
+#include <linux/pgtable.h>
 
 #include "internal.h"
 

commit 956ad9d98b73f59e442cc119c98ba1e04e94fe6d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jun 4 19:22:26 2020 +0200

    ACPI: PM: Avoid using power resources if there are none for D0
    
    As recently reported, some platforms provide a list of power
    resources for device power state D3hot, through the _PR3 object,
    but they do not provide a list of power resources for device power
    state D0.
    
    Among other things, this causes acpi_device_get_power() to return
    D3hot as the current state of the device in question if all of the
    D3hot power resources are "on", because it sees the power_resources
    flag set and calls acpi_power_get_inferred_state() which finds that
    D3hot is the shallowest power state with all of the associated power
    resources turned "on", so that's what it returns.  Moreover, that
    value takes precedence over the acpi_dev_pm_explicit_get() return
    value, because it means a deeper power state.  The device may very
    well be in D0 physically at that point, however.
    
    Moreover, the presence of _PR3 without _PR0 for a given device
    means that only one D3-level power state can be supported by it.
    Namely, because there are no power resources to turn "off" when
    transitioning the device from D0 into D3cold (which should be
    supported since _PR3 is present), the evaluation of _PS3 should
    be sufficient to put it straight into D3cold, but this means that
    the effect of turning "on" the _PR3 power resources is unclear,
    so it is better to avoid doing that altogether.  Consequently,
    there is no practical way do distinguish D3cold from D3hot for
    the device in question and the power states of it can be labeled
    so that D3hot is the deepest supported one (and Linux assumes
    that putting a device into D3hot via ACPI may cause power to be
    removed from it anyway, for legacy reasons).
    
    To work around the problem described above modify the ACPI
    enumeration of devices so that power resources are only used
    for device power management if the list of D0 power resources
    is not empty and make it mart D3cold as supported only if that
    is the case and the D3hot list of power resources is not empty
    too.
    
    Fixes: ef85bdbec444 ("ACPI / scan: Consolidate extraction of power resources lists")
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=205057
    Link: https://lore.kernel.org/linux-acpi/20200603194659.185757-1-hdegoede@redhat.com/
    Reported-by: Hans de Goede <hdegoede@redhat.com>
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Tested-by: youling257@gmail.com
    Cc: 3.10+ <stable@vger.kernel.org> # 3.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 6d3448895382..1b255e98de4d 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -919,12 +919,9 @@ static void acpi_bus_init_power_state(struct acpi_device *device, int state)
 
 		if (buffer.length && package
 		    && package->type == ACPI_TYPE_PACKAGE
-		    && package->package.count) {
-			int err = acpi_extract_power_resources(package, 0,
-							       &ps->resources);
-			if (!err)
-				device->power.flags.power_resources = 1;
-		}
+		    && package->package.count)
+			acpi_extract_power_resources(package, 0, &ps->resources);
+
 		ACPI_FREE(buffer.pointer);
 	}
 
@@ -971,14 +968,27 @@ static void acpi_bus_get_power_flags(struct acpi_device *device)
 		acpi_bus_init_power_state(device, i);
 
 	INIT_LIST_HEAD(&device->power.states[ACPI_STATE_D3_COLD].resources);
-	if (!list_empty(&device->power.states[ACPI_STATE_D3_HOT].resources))
-		device->power.states[ACPI_STATE_D3_COLD].flags.valid = 1;
 
-	/* Set defaults for D0 and D3hot states (always valid) */
+	/* Set the defaults for D0 and D3hot (always supported). */
 	device->power.states[ACPI_STATE_D0].flags.valid = 1;
 	device->power.states[ACPI_STATE_D0].power = 100;
 	device->power.states[ACPI_STATE_D3_HOT].flags.valid = 1;
 
+	/*
+	 * Use power resources only if the D0 list of them is populated, because
+	 * some platforms may provide _PR3 only to indicate D3cold support and
+	 * in those cases the power resources list returned by it may be bogus.
+	 */
+	if (!list_empty(&device->power.states[ACPI_STATE_D0].resources)) {
+		device->power.flags.power_resources = 1;
+		/*
+		 * D3cold is supported if the D3hot list of power resources is
+		 * not empty.
+		 */
+		if (!list_empty(&device->power.states[ACPI_STATE_D3_HOT].resources))
+			device->power.states[ACPI_STATE_D3_COLD].flags.valid = 1;
+	}
+
 	if (acpi_bus_init_power(device))
 		device->flags.power_manageable = 0;
 }

commit ead7ba136267b4c36af855ab6e237c998d83df05
Author: Hanjun Guo <guohanjun@huawei.com>
Date:   Thu May 7 17:09:20 2020 +0800

    ACPI: scan: Put SPCR and STAO table after using it
    
    The SPCR and STAO table needs to be released after
    using it.
    
    Signed-off-by: Hanjun Guo <guohanjun@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 6d3448895382..5287ab98b8c1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2157,10 +2157,13 @@ static void __init acpi_get_spcr_uart_addr(void)
 
 	status = acpi_get_table(ACPI_SIG_SPCR, 0,
 				(struct acpi_table_header **)&spcr_ptr);
-	if (ACPI_SUCCESS(status))
-		spcr_uart_addr = spcr_ptr->serial_port.address;
-	else
-		printk(KERN_WARNING PREFIX "STAO table present, but SPCR is missing\n");
+	if (ACPI_FAILURE(status)) {
+		pr_warn(PREFIX "STAO table present, but SPCR is missing\n");
+		return;
+	}
+
+	spcr_uart_addr = spcr_ptr->serial_port.address;
+	acpi_put_table((struct acpi_table_header *)spcr_ptr);
 }
 
 static bool acpi_scan_initialized;
@@ -2196,10 +2199,12 @@ int __init acpi_scan_init(void)
 				(struct acpi_table_header **)&stao_ptr);
 	if (ACPI_SUCCESS(status)) {
 		if (stao_ptr->header.length > sizeof(struct acpi_table_stao))
-			printk(KERN_INFO PREFIX "STAO Name List not yet supported.");
+			pr_info(PREFIX "STAO Name List not yet supported.\n");
 
 		if (stao_ptr->ignore_uart)
 			acpi_get_spcr_uart_addr();
+
+		acpi_put_table((struct acpi_table_header *)stao_ptr);
 	}
 
 	acpi_gpe_apply_masked_gpes();

commit 45586c7078d42b932c5399953d21746800083691
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Feb 3 17:37:45 2020 -0800

    treewide: remove redundant IS_ERR() before error code check
    
    'PTR_ERR(p) == -E*' is a stronger condition than IS_ERR(p).
    Hence, IS_ERR(p) is unneeded.
    
    The semantic patch that generates this commit is as follows:
    
    // <smpl>
    @@
    expression ptr;
    constant error_code;
    @@
    -IS_ERR(ptr) && (PTR_ERR(ptr) == - error_code)
    +PTR_ERR(ptr) == - error_code
    // </smpl>
    
    Link: http://lkml.kernel.org/r/20200106045833.1725-1-masahiroy@kernel.org
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>
    Cc: Julia Lawall <julia.lawall@lip6.fr>
    Acked-by: Stephen Boyd <sboyd@kernel.org> [drivers/clk/clk.c]
    Acked-by: Bartosz Golaszewski <bgolaszewski@baylibre.com> [GPIO]
    Acked-by: Wolfram Sang <wsa@the-dreams.de> [drivers/i2c]
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com> [acpi/scan.c]
    Acked-by: Rob Herring <robh@kernel.org>
    Cc: Eric Biggers <ebiggers@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 915650bf519f..6d3448895382 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1462,7 +1462,7 @@ int acpi_dma_configure(struct device *dev, enum dev_dma_attr attr)
 	iort_dma_setup(dev, &dma_addr, &size);
 
 	iommu = iort_iommu_configure(dev);
-	if (IS_ERR(iommu) && PTR_ERR(iommu) == -EPROBE_DEFER)
+	if (PTR_ERR(iommu) == -EPROBE_DEFER)
 		return -EPROBE_DEFER;
 
 	arch_setup_dma_ops(dev, dma_addr, size,

commit cb0701acfa7e3fe9e919cf2aa2aa939b7fd603c2
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Aug 30 17:34:32 2019 +0300

    ACPI: platform: Unregister stale platform devices
    
    When commit 68bdb6773289 ("ACPI: add support for ACPI reconfiguration
    notifiers") introduced reconfiguration notifiers, it missed the point
    that the ACPI table, which might be loaded and then unloaded via
    ConfigFS, could contain devices that were not enumerated by their
    parents.
    
    In such cases, the stale platform device is dangling in the system
    while the rest of the devices from the same table are already gone.
    
    Introduce acpi_platform_device_remove_notify() notifier that, in
    similar way to I²C or SPI buses, unregisters the platform devices
    on table removal event.
    
    Fixes: 68bdb6773289 ("ACPI: add support for ACPI reconfiguration notifiers")
    Depends-on: 00500147cbd3 ("drivers: Introduce device lookup variants by ACPI_COMPANION device")
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    [ rjw: Changelog & function rename ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index aad6be5c0af0..915650bf519f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2174,6 +2174,7 @@ int __init acpi_scan_init(void)
 	acpi_pci_root_init();
 	acpi_pci_link_init();
 	acpi_processor_init();
+	acpi_platform_init();
 	acpi_lpss_init();
 	acpi_apd_init();
 	acpi_cmos_rtc_init();

commit 7291edca20215dfdf0eb841881d63753448ef09c
Author: David Hildenbrand <david@redhat.com>
Date:   Fri Aug 2 21:49:29 2019 -0700

    drivers/acpi/scan.c: document why we don't need the device_hotplug_lock
    
    Let's document why the lock is not needed in acpi_scan_init(), right now
    this is not really obvious.
    
    [akpm@linux-foundation.org: fix tpyo]
    Link: http://lkml.kernel.org/r/20190731135306.31524-1-david@redhat.com
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Oscar Salvador <osalvador@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 0e28270b0fd8..aad6be5c0af0 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2204,6 +2204,12 @@ int __init acpi_scan_init(void)
 	acpi_gpe_apply_masked_gpes();
 	acpi_update_all_gpes();
 
+	/*
+	 * Although we call __add_memory() that is documented to require the
+	 * device_hotplug_lock, it is not necessary here because this is an
+	 * early code when userspace or any other code path cannot trigger
+	 * hotplug/hotunplug operations.
+	 */
 	mutex_lock(&acpi_scan_lock);
 	/*
 	 * Enumerate devices in the ACPI namespace.

commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 566270d0e91a..0e28270b0fd8 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * scan.c - support for transforming the ACPI namespace into individual objects
  */

commit cf482a49af564a3044de3178ea28f10ad5921b38
Merge: 01e5d1830cf5 70e16a620e07
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 13:01:40 2019 -0700

    Merge tag 'driver-core-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core/kobject updates from Greg KH:
     "Here is the "big" set of driver core patches for 5.2-rc1
    
      There are a number of ACPI patches in here as well, as Rafael said
      they should go through this tree due to the driver core changes they
      required. They have all been acked by the ACPI developers.
    
      There are also a number of small subsystem-specific changes in here,
      due to some changes to the kobject core code. Those too have all been
      acked by the various subsystem maintainers.
    
      As for content, it's pretty boring outside of the ACPI changes:
       - spdx cleanups
       - kobject documentation updates
       - default attribute groups for kobjects
       - other minor kobject/driver core fixes
    
      All have been in linux-next for a while with no reported issues"
    
    * tag 'driver-core-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (47 commits)
      kobject: clean up the kobject add documentation a bit more
      kobject: Fix kernel-doc comment first line
      kobject: Remove docstring reference to kset
      firmware_loader: Fix a typo ("syfs" -> "sysfs")
      kobject: fix dereference before null check on kobj
      Revert "driver core: platform: Fix the usage of platform device name(pdev->name)"
      init/config: Do not select BUILD_BIN2C for IKCONFIG
      Provide in-kernel headers to make extending kernel easier
      kobject: Improve doc clarity kobject_init_and_add()
      kobject: Improve docs for kobject_add/del
      driver core: platform: Fix the usage of platform device name(pdev->name)
      livepatch: Replace klp_ktype_patch's default_attrs with groups
      cpufreq: schedutil: Replace default_attrs field with groups
      padata: Replace padata_attr_type default_attrs field with groups
      irqdesc: Replace irq_kobj_type's default_attrs field with groups
      net-sysfs: Replace ktype default_attrs field with groups
      block: Replace all ktype default_attrs with groups
      samples/kobject: Replace foo_ktype's default_attrs field with groups
      kobject: Add support for default attribute groups to kobj_type
      driver core: Postpone DMA tear-down until after devres release for probe failure
      ...

commit 91751459ecad7c12ef20e839fcba2ee573c0c5d5
Merge: 317e2cac4551 5ceb5f0522bd 2e018c59fe8f b0f65b917987 fbc9418f099d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon May 6 10:49:39 2019 +0200

    Merge branches 'acpi-scan', 'acpi-tables', 'acpi-misc' and 'acpi-pm'
    
    * acpi-scan:
      ACPI / scan: Add labels for PNP button devices
      ACPI / scan: Simplify acpi_bus_extract_wakeup_device_power_package()
    
    * acpi-tables:
      ACPI / tables: Clean up whitespace
    
    * acpi-misc:
      ACPI / DPTF: Use dev_get_drvdata()
      ACPI: event: replace strcpy() by strscpy()
      ACPI: Fix comment typos
    
    * acpi-pm:
      ACPI: PM: Print debug messages when enabling GPEs for wakeup

commit 5599fb69355d7a558f32206dac7539e945a1f604
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Apr 8 13:42:24 2019 -0700

    ACPICA: Rename nameseg compare macro for clarity
    
    ACPICA commit 92ec0935f27e217dff0b176fca02c2ec3d782bb5
    
    ACPI_COMPARE_NAME changed to ACPI_COMPARE_NAMESEG
    This clarifies (1) this is a compare on 4-byte namesegs, not
    a generic compare. Improves understanding of the code.
    
    Link: https://github.com/acpica/acpica/commit/92ec0935
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 446c959a8f08..3fb331fb6e82 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2260,7 +2260,7 @@ int __init __acpi_probe_device_table(struct acpi_probe_entry *ap_head, int nr)
 
 	mutex_lock(&acpi_probe_mutex);
 	for (ape = ap_head; nr; ape++, nr--) {
-		if (ACPI_COMPARE_NAME(ACPI_SIG_MADT, ape->id)) {
+		if (ACPI_COMPARE_NAMESEG(ACPI_SIG_MADT, ape->id)) {
 			acpi_probe_count = 0;
 			acpi_table_parse_madt(ape->type, acpi_match_madt, 0);
 			count += acpi_probe_count;

commit 60574d1e05b094d222162260dd9cac49f4d0996a
Author: Keith Busch <keith.busch@intel.com>
Date:   Mon Mar 11 14:55:57 2019 -0600

    acpi: Create subtable parsing infrastructure
    
    Parsing entries in an ACPI table had assumed a generic header
    structure. There is no standard ACPI header, though, so less common
    layouts with different field sizes required custom parsers to go through
    their subtable entry list.
    
    Create the infrastructure for adding different table types so parsing
    the entries array may be more reused for all ACPI system tables and
    the common code doesn't need to be duplicated.
    
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Tested-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Tested-by: Brice Goglin <Brice.Goglin@inria.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 446c959a8f08..f7771a3b4a3e 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2241,10 +2241,10 @@ static struct acpi_probe_entry *ape;
 static int acpi_probe_count;
 static DEFINE_MUTEX(acpi_probe_mutex);
 
-static int __init acpi_match_madt(struct acpi_subtable_header *header,
+static int __init acpi_match_madt(union acpi_subtable_headers *header,
 				  const unsigned long end)
 {
-	if (!ape->subtable_valid || ape->subtable_valid(header, ape))
+	if (!ape->subtable_valid || ape->subtable_valid(&header->common, ape))
 		if (!ape->probe_subtbl(header, end))
 			acpi_probe_count++;
 

commit 5ceb5f0522bdc20d507fef2cd77fec2caa4e541e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Mar 25 13:34:03 2019 -0500

    ACPI / scan: Add labels for PNP button devices
    
    Subsequent code treats button_device_ids[] entries differently, and
    it's hard to follow without a hint as to which is which.
    
    Add comments to identify the power button, lid, and sleep button
    devices.
    
    The "PNP" prefix is owned by Microsoft, so they distribute the
    canonical list of "PNP" IDs.
    
    Link: https://uefi.org/PNP_ACPI_Registry
    Link: https://download.microsoft.com/download/1/6/1/161ba512-40e2-4cc9-843a-923143f3456c/devids.txt
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f3fb1fa79429..2297440a0622 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -846,9 +846,9 @@ static int acpi_bus_extract_wakeup_device_power_package(struct acpi_device *dev)
 static bool acpi_wakeup_gpe_init(struct acpi_device *device)
 {
 	static const struct acpi_device_id button_device_ids[] = {
-		{"PNP0C0C", 0},
-		{"PNP0C0D", 0},
-		{"PNP0C0E", 0},
+		{"PNP0C0C", 0},		/* Power button */
+		{"PNP0C0D", 0},		/* Lid */
+		{"PNP0C0E", 0},		/* Sleep button */
 		{"", 0},
 	};
 	struct acpi_device_wakeup *wakeup = &device->wakeup;

commit 40381a3c1fa3ed37458c7f745e51fc81e9b48fe2
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Mar 25 13:34:02 2019 -0500

    ACPI / scan: Simplify acpi_bus_extract_wakeup_device_power_package()
    
    acpi_bus_extract_wakeup_device_power_package() is a static function
    with a single caller that supplies (device->handle, &device->wakeup).
    
    Simplify the interface so the caller need only supply "device".
    
    This makes it obvious that "wakeup", i.e., &device->wakeup, can never
    be NULL, so remove the unnecessary check for that.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 446c959a8f08..f3fb1fa79429 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -763,18 +763,16 @@ acpi_bus_get_ejd(acpi_handle handle, acpi_handle *ejd)
 }
 EXPORT_SYMBOL_GPL(acpi_bus_get_ejd);
 
-static int acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
-					struct acpi_device_wakeup *wakeup)
+static int acpi_bus_extract_wakeup_device_power_package(struct acpi_device *dev)
 {
+	acpi_handle handle = dev->handle;
+	struct acpi_device_wakeup *wakeup = &dev->wakeup;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *package = NULL;
 	union acpi_object *element = NULL;
 	acpi_status status;
 	int err = -ENODATA;
 
-	if (!wakeup)
-		return -EINVAL;
-
 	INIT_LIST_HEAD(&wakeup->resources);
 
 	/* _PRW */
@@ -883,8 +881,7 @@ static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	if (!acpi_has_method(device->handle, "_PRW"))
 		return;
 
-	err = acpi_bus_extract_wakeup_device_power_package(device->handle,
-							   &device->wakeup);
+	err = acpi_bus_extract_wakeup_device_power_package(device);
 	if (err) {
 		dev_err(&device->dev, "_PRW evaluation error: %d\n", err);
 		return;

commit 603fadf33604a2e170eb833f99f569d3597f1f09
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Mar 25 13:34:00 2019 -0500

    ACPI: Fix comment typos
    
    Fix some misspellings in comments.  No functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 446c959a8f08..1b66fc835e39 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -895,7 +895,7 @@ static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	/*
 	 * Call _PSW/_DSW object to disable its ability to wake the sleeping
 	 * system for the ACPI device with the _PRW object.
-	 * The _PSW object is depreciated in ACPI 3.0 and is replaced by _DSW.
+	 * The _PSW object is deprecated in ACPI 3.0 and is replaced by _DSW.
 	 * So it is necessary to call _DSW object first. Only when it is not
 	 * present will the _PSW object used.
 	 */

commit 96f984d3127e283265a6245dacc399967655fe54
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Dec 20 15:34:51 2018 +0100

    ACPI / scan: Create platform device for BSG2150 ACPI nodes
    
    The Point of View TAB-P1006W-232-3G tablet has an ACPI firmware node with
    a HID of BSG2150 describing the 2 Bosch sensors used in the device a
    BMC150 compatible accelerometer and a BMC150 compatible magnetometer.
    
    The ACPI firmware node actually contains 3 I2cSerialBusV2 resources,
    but this seems to be a copy and paste job from the BSG1160 firmware node
    on other devices, since there is no i2c-client listening to the 0x68
    address listed in the third resource and the 0x68 address is identical
    to the address of the third resource in the BSG1160 nodes, where as the
    other 2 addresses are different.
    
    Add the ID to the I2C multi instantiate list, so that the
    i2c-multi-instantiate.c driver can handle it;
    
    And add the necessary info to the i2c-multi-instantiate.c driver to
    enumerate all I2C slaves correctly.
    
    To avoid triggering the:
    
            if (i < multi->num_clients) {
                    dev_err(dev, "Error finding driver, idx %d\n", i);
    
    Error this commit lists the 3th device in the i2c_inst_data with a
    type of "bsg2150_dummy_dev".
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5efd4219f112..446c959a8f08 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1545,6 +1545,7 @@ static bool acpi_device_enumeration_by_parent(struct acpi_device *device)
 	 */
 	static const struct acpi_device_id i2c_multi_instantiate_ids[] = {
 		{"BSG1160", },
+		{"BSG2150", },
 		{"INT33FE", },
 		{"INT3515", },
 		{}

commit af7ddd8a627c62a835524b3f5b471edbbbcce025
Merge: fe2b0cdabcd9 8b1cce9f5832
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 28 14:12:21 2018 -0800

    Merge tag 'dma-mapping-4.21' of git://git.infradead.org/users/hch/dma-mapping
    
    Pull DMA mapping updates from Christoph Hellwig:
     "A huge update this time, but a lot of that is just consolidating or
      removing code:
    
       - provide a common DMA_MAPPING_ERROR definition and avoid indirect
         calls for dma_map_* error checking
    
       - use direct calls for the DMA direct mapping case, avoiding huge
         retpoline overhead for high performance workloads
    
       - merge the swiotlb dma_map_ops into dma-direct
    
       - provide a generic remapping DMA consistent allocator for
         architectures that have devices that perform DMA that is not cache
         coherent. Based on the existing arm64 implementation and also used
         for csky now.
    
       - improve the dma-debug infrastructure, including dynamic allocation
         of entries (Robin Murphy)
    
       - default to providing chaining scatterlist everywhere, with opt-outs
         for the few architectures (alpha, parisc, most arm32 variants) that
         can't cope with it
    
       - misc sparc32 dma-related cleanups
    
       - remove the dma_mark_clean arch hook used by swiotlb on ia64 and
         replace it with the generic noncoherent infrastructure
    
       - fix the return type of dma_set_max_seg_size (Niklas Söderlund)
    
       - move the dummy dma ops for not DMA capable devices from arm64 to
         common code (Robin Murphy)
    
       - ensure dma_alloc_coherent returns zeroed memory to avoid kernel
         data leaks through userspace. We already did this for most common
         architectures, but this ensures we do it everywhere.
         dma_zalloc_coherent has been deprecated and can hopefully be
         removed after -rc1 with a coccinelle script"
    
    * tag 'dma-mapping-4.21' of git://git.infradead.org/users/hch/dma-mapping: (73 commits)
      dma-mapping: fix inverted logic in dma_supported
      dma-mapping: deprecate dma_zalloc_coherent
      dma-mapping: zero memory returned from dma_alloc_*
      sparc/iommu: fix ->map_sg return value
      sparc/io-unit: fix ->map_sg return value
      arm64: default to the direct mapping in get_arch_dma_ops
      PCI: Remove unused attr variable in pci_dma_configure
      ia64: only select ARCH_HAS_DMA_COHERENT_TO_PFN if swiotlb is enabled
      dma-mapping: bypass indirect calls for dma-direct
      vmd: use the proper dma_* APIs instead of direct methods calls
      dma-direct: merge swiotlb_dma_ops into the dma_direct code
      dma-direct: use dma_direct_map_page to implement dma_direct_map_sg
      dma-direct: improve addressability error reporting
      swiotlb: remove dma_mark_clean
      swiotlb: remove SWIOTLB_MAP_ERROR
      ACPI / scan: Refactor _CCA enforcement
      dma-mapping: factor out dummy DMA ops
      dma-mapping: always build the direct mapping code
      dma-mapping: move dma_cache_sync out of line
      dma-mapping: move various slow path functions out of line
      ...

commit e5361ca29f2fea345c08d2b5cb5e3b1840cbafb8
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Thu Dec 6 13:20:49 2018 -0800

    ACPI / scan: Refactor _CCA enforcement
    
    Rather than checking the DMA attribute at each callsite, just pass it
    through for acpi_dma_configure() to handle directly. That can then deal
    with the relatively exceptional DEV_DMA_NOT_SUPPORTED case by explicitly
    installing dummy DMA ops instead of just skipping setup entirely. This
    will then free up the dev->dma_ops == NULL case for some valuable
    fastpath optimisations.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Jesper Dangaard Brouer <brouer@redhat.com>
    Tested-by: Jesper Dangaard Brouer <brouer@redhat.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Tony Luck <tony.luck@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index bd1c59fb0e17..b75ae34ed188 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1456,6 +1456,11 @@ int acpi_dma_configure(struct device *dev, enum dev_dma_attr attr)
 	const struct iommu_ops *iommu;
 	u64 dma_addr = 0, size = 0;
 
+	if (attr == DEV_DMA_NOT_SUPPORTED) {
+		set_dma_ops(dev, &dma_dummy_ops);
+		return 0;
+	}
+
 	iort_dma_setup(dev, &dma_addr, &size);
 
 	iommu = iort_iommu_configure(dev);

commit a3dd034a1707490119f32bd0c50e6047e42d2517
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Nov 28 13:45:34 2018 +0200

    ACPI / scan: Create platform device for INT3515 ACPI nodes
    
    The ACPI device with INT3515 _HID is representing a complex USB PD
    hardware infrastructure which includes several I2C slave ICs.
    
    We add an ID to the I2C multi instantiate list to enumerate
    all I2C slaves correctly.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index bd1c59fb0e17..e9eda5558c1f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1541,6 +1541,7 @@ static bool acpi_device_enumeration_by_parent(struct acpi_device *device)
 	static const struct acpi_device_id i2c_multi_instantiate_ids[] = {
 		{"BSG1160", },
 		{"INT33FE", },
+		{"INT3515", },
 		{}
 	};
 

commit 58a0228707870c8330917f919804986855443a19
Merge: 12dd08fa954f 0a1875ad29ef
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 23 10:33:16 2018 +0100

    Merge tag 'acpi-4.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI updates from Rafael Wysocki:
     "These fix ACPICA issues related to the handling of module-level AML,
      fix an ordering issue during ACPI initialization, update ACPICA to
      upstream revision 20181003 (including fixes mostly), fix issues with
      system-wide suspend/resume related to the ACPI driver for Intel SoCs
      (LPSS), fix device enumeration issues on boards with Dollar Cove or
      Whiskey Cove Intel PMICs, prevent ACPICA from calling ktime_get() in
      unsuitable conditions, update a few drivers and clean up some code in
      several places.
    
      Specifics:
    
       - Fix ACPICA issues related to the handling of module-level AML and
         make the ACPI initialization code parse ECDT before loading the
         definition block tables (Erik Schmauss).
    
       - Update ACPICA to upstream revision 20181003 including fixes related
         to the ill-defined "generic serial bus" and the handling of the
         _REG object (Bob Moore).
    
       - Fix some issues with system-wide suspend/resume on Intel BYT/CHT
         related to the handling of I2C controllers in the ACPI LPSS driver
         for Intel SoCs (Hans de Goede).
    
       - Modify the ACPI namespace scanning code to enumerate INT33FE HID
         devices as platform devices with I2C resources to avoid device
         enumeration problems on boards with Dollar Cove or Whiskey Cove
         Intel PMICs (Hans de Goede).
    
       - Prevent ACPICA from using ktime_get() during early resume from
         system-wide suspend before resuming the timekeeping which generally
         is unsafe and triggers a warning from the timekeeping code (Bart
         Van Assche).
    
       - Add low-level real time clock support to the ACPI Time and Aalarm
         Device (TAD) driver (Rafael Wysocki).
    
       - Fix the ACPI SBS driver to avoid GPE storms on MacBook Pro and
         Oopses when removing modules (Ronald Tschalär).
    
       - Fix the ACPI PPTT parsing code to handle architecturally unknown
         cache types properly (Jeffrey Hugo).
    
       - Fix initialization issue in the ACPI processor driver (Dou Liyang).
    
       - Clean up the code in several places (Andy Shevchenko, Bartlomiej
         Zolnierkiewicz, David Arcari, zhong jiang)"
    
    * tag 'acpi-4.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (33 commits)
      ACPI / scan: Create platform device for INT33FE ACPI nodes
      ACPI / OSL: Use 'jiffies' as the time bassis for acpi_os_get_timer()
      ACPI: probe ECDT before loading AML tables regardless of module-level code flag
      ACPICA: Remove acpi_gbl_group_module_level_code and only use acpi_gbl_execute_tables_as_methods instead
      ACPICA: AML Parser: fix parse loop to correctly skip erroneous extended opcodes
      ACPICA: AML interpreter: add region addresses in global list during initialization
      ACPI: TAD: Add low-level support for real time capability
      ACPI: remove redundant 'default n' from Kconfig
      ACPI / SBS: Fix rare oops when removing modules
      ACPI / SBS: Fix GPE storm on recent MacBookPro's
      ACPI/PPTT: Handle architecturally unknown cache types
      drivers: base: cacheinfo: Do not populate sysfs for unknown cache types
      ACPICA: Update version to 20181003
      ACPICA: Never run _REG on system_memory and system_IO
      ACPICA: Split large interpreter file
      ACPICA: Update for field unit access
      ACPICA: Rename some of the Field Attribute defines
      ACPICA: Update for generic_serial_bus and attrib_raw_process_bytes protocol
      ACPI / processor: Fix the return value of acpi_processor_ids_walk()
      ACPI / LPSS: Resume BYT/CHT I2C controllers from resume_noirq
      ...

commit 589edb56b424876cbbf61547b987a1f57d7ea99d
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Oct 17 10:59:28 2018 +0200

    ACPI / scan: Create platform device for INT33FE ACPI nodes
    
    Bay and Cherry Trail devices with a Dollar Cove or Whiskey Cove PMIC
    have an ACPI node with a HID of INT33FE which is a "virtual" battery
    device implementing a standard ACPI battery interface which depends upon
    a proprietary, undocument OpRegion called BMOP. Since we do have docs
    for the actual fuel-gauges used on these boards we instead use native
    fuel-gauge drivers talking directly to the fuel-gauge ICs on boards which
    rely on this INT33FE device for their battery monitoring.
    
    On boards with a Dollar Cove PMIC the INT33FE device's resources (_CRS)
    describe a non-existing I2C client at address 0x6b with a bus-speed of
    100KHz. This is a problem on some boards since there are actual devices
    on that same bus which need a speed of 400KHz to function properly.
    
    This commit adds the INT33FE HID to the list of devices with I2C resources
    which should be enumerated as a platform-device rather then letting the
    i2c-core instantiate an i2c-client matching the first I2C resource,
    so that its bus-speed will not influence the max speed of the I2C bus.
    This fixes e.g. the touchscreen not working on the Teclast X98 II Plus.
    
    The INT33FE device on boards with a Whiskey Cove PMIC is somewhat special.
    Its first I2C resource is for a secondary I2C address of the PMIC itself,
    which is already described in an ACPI device with an INT34D3 HID.
    
    But it has 3 more I2C resources describing 3 other chips for which we do
    need to instantiate I2C clients and which need device-connections added
    between them for things to work properly. This special case is handled by
    the drivers/platform/x86/intel_cht_int33fe.c code.
    
    Before this commit that code was binding to the i2c-client instantiated
    for the secondary I2C address of the PMIC, since we now instantiate a
    platform device for the INT33FE device instead, this commit also changes
    the intel_cht_int33fe driver from an i2c driver to a platform driver.
    
    This also brings the intel_cht_int33fe drv inline with how we instantiate
    multiple i2c clients from a single ACPI device in other cases, as done
    by the drivers/platform/x86/i2c-multi-instantiate.c code.
    
    Reported-and-tested-by: Alexander Meiler <alex.meiler@protonmail.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e1b6231cfa1c..1dcc48b9d33c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1550,6 +1550,7 @@ static bool acpi_device_enumeration_by_parent(struct acpi_device *device)
 	 */
 	static const struct acpi_device_id i2c_multi_instantiate_ids[] = {
 		{"BSG1160", },
+		{"INT33FE", },
 		{}
 	};
 

commit dc3c05504d38849f77149cb962caeaedd1efa127
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Aug 24 10:28:18 2018 +0200

    dma-mapping: remove dma_deconfigure
    
    This goes through a lot of hooks just to call arch_teardown_dma_ops.
    Replace it with a direct call instead.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e1b6231cfa1c..56676a56b3e3 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1469,16 +1469,6 @@ int acpi_dma_configure(struct device *dev, enum dev_dma_attr attr)
 }
 EXPORT_SYMBOL_GPL(acpi_dma_configure);
 
-/**
- * acpi_dma_deconfigure - Tear-down DMA configuration for the device.
- * @dev: The pointer to the device
- */
-void acpi_dma_deconfigure(struct device *dev)
-{
-	arch_teardown_dma_ops(dev);
-}
-EXPORT_SYMBOL_GPL(acpi_dma_deconfigure);
-
 static void acpi_init_coherency(struct acpi_device *adev)
 {
 	unsigned long long cca = 0;

commit aba941392aeef2d1bc064a1e4b09293473ef7b9b
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Aug 9 11:15:56 2018 +0200

    ACPI / scan: Create platform device for fwnodes with multiple i2c devices
    
    Some devices have multiple I2cSerialBus resources and for things to work
    an i2c-client must be instantiated for each, each with its own
    i2c_device_id.
    
    Normally we only instantiate an i2c-client for the first resource, using
    the ACPI HID as id.
    
    This commit adds a list of HIDs of devices, which need multiple i2c-clients
    instantiated from a single fwnode, to acpi_device_enumeration_by_parent and
    makes acpi_device_enumeration_by_parent return false for these devices so
    that a platform device will be instantiated.
    
    This allows the drivers/platform/x86/i2c-multi-instantiate.c driver, which
    knows which i2c_device_id to use for each resource, to bind to the fwnode
    and initiate an i2c-client for each resource.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 798a73416af8..e1b6231cfa1c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1540,6 +1540,18 @@ static bool acpi_device_enumeration_by_parent(struct acpi_device *device)
 {
 	struct list_head resource_list;
 	bool is_serial_bus_slave = false;
+	/*
+	 * These devices have multiple I2cSerialBus resources and an i2c-client
+	 * must be instantiated for each, each with its own i2c_device_id.
+	 * Normally we only instantiate an i2c-client for the first resource,
+	 * using the ACPI HID as id. These special cases are handled by the
+	 * drivers/platform/x86/i2c-multi-instantiate.c driver, which knows
+	 * which i2c_device_id to use for each resource.
+	 */
+	static const struct acpi_device_id i2c_multi_instantiate_ids[] = {
+		{"BSG1160", },
+		{}
+	};
 
 	if (acpi_is_indirect_io_slave(device))
 		return true;
@@ -1551,6 +1563,10 @@ static bool acpi_device_enumeration_by_parent(struct acpi_device *device)
 	     fwnode_property_present(&device->fwnode, "baud")))
 		return true;
 
+	/* Instantiate a pdev for the i2c-multi-instantiate drv to bind to */
+	if (!acpi_match_device_ids(device, i2c_multi_instantiate_ids))
+		return false;
+
 	INIT_LIST_HEAD(&resource_list);
 	acpi_dev_get_resources(device, &resource_list,
 			       acpi_check_serial_bus_slave,

commit 5971b0c1594d6c34e257101ed5fdffec65205c50
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Aug 8 10:30:03 2018 +0200

    ACPI / scan: Initialize status to ACPI_STA_DEFAULT
    
    Since commit 63347db0affa "ACPI / scan: Use acpi_bus_get_status() to
    initialize ACPI_TYPE_DEVICE devs" the status field of normal acpi_devices
    gets set to 0 by acpi_bus_type_and_status() and filled with its actual
    value later when acpi_add_single_object() calls acpi_bus_get_status().
    
    This means that any acpi_match_device_ids() calls in between will always
    fail with -ENOENT.
    
    We already have a workaround for this, which temporary forces status to
    ACPI_STA_DEFAULT in drivers/acpi/x86/utils.c: acpi_device_always_present()
    and the next commit in this series adds another acpi_match_device_ids()
    call between status being initialized as 0 and the acpi_bus_get_status()
    call.
    
    Rather then adding another workaround, this commit makes
    acpi_bus_type_and_status() initialize status to ACPI_STA_DEFAULT, this is
    safe to do as the only code looking at status between the initialization
    and the acpi_bus_get_status() call is those acpi_match_device_ids() calls.
    
    Note this does mean that we need to (re)set status to 0 in case the
    acpi_bus_get_status() call fails.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 199c8ea6896c..798a73416af8 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1612,7 +1612,8 @@ static int acpi_add_single_object(struct acpi_device **child,
 	 * Note this must be done before the get power-/wakeup_dev-flags calls.
 	 */
 	if (type == ACPI_BUS_TYPE_DEVICE)
-		acpi_bus_get_status(device);
+		if (acpi_bus_get_status(device) < 0)
+			acpi_set_device_status(device, 0);
 
 	acpi_bus_get_power_flags(device);
 	acpi_bus_get_wakeup_device_flags(device);
@@ -1690,7 +1691,7 @@ static int acpi_bus_type_and_status(acpi_handle handle, int *type,
 		 * acpi_add_single_object updates this once we've an acpi_device
 		 * so that acpi_bus_get_status' quirk handling can be used.
 		 */
-		*sta = 0;
+		*sta = ACPI_STA_DEFAULT;
 		break;
 	case ACPI_TYPE_PROCESSOR:
 		*type = ACPI_BUS_TYPE_PROCESSOR;

commit a6f0729508df6a067c4a074ec187ecd9d2457a6b
Author: John Garry <john.garry@huawei.com>
Date:   Tue Aug 7 21:15:05 2018 +0800

    ACPI / scan: Add static attribute to indirect_io_hosts[]
    
    Array indirect_io_hosts[] is declared in acpi_is_indirect_io_slave() as a
    const array, which means that the array will be re-built for each call.
    
    Optimise by adding the static attribute, which means that the array is
    added to const-data pool and not re-built per function call.
    
    Reported-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: John Garry <john.garry@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 970dd87d347c..199c8ea6896c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1528,7 +1528,7 @@ static int acpi_check_serial_bus_slave(struct acpi_resource *ares, void *data)
 static bool acpi_is_indirect_io_slave(struct acpi_device *device)
 {
 	struct acpi_device *parent = device->parent;
-	const struct acpi_device_id indirect_io_hosts[] = {
+	static const struct acpi_device_id indirect_io_hosts[] = {
 		{"HISI0191", 0},
 		{}
 	};

commit cc6a0e315a68e5db85bea347b0c5b0fe4a9a5904
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Apr 19 13:08:37 2018 +0300

    ACPI / scan: Initialize watchdog before PNP
    
    At least on one Dell system the PNP motherboard resources device
    includes resources used by WDAT table. Since PNP gets initialized before
    WDAT it results following error and no watchdog:
    
      platform wdat_wdt: failed to claim resource 3: [io  0x046a-0x046c]
      ACPI: watchdog: Device creation failed: -16
    
    Now, the PNP system driver is already accustomed with the situation that
    it cannot reserve all those motherboard resources because drivers using
    those might have reserved them already. In addition putting WDAT table
    resources under motherboard resources device makes sense in general.
    
    Fix this by initializing WDAT right before PNP. This allows WDAT to
    reserve all its resources and still keeps PNP system driver happy.
    
    Reported-by: Shubhrata.Priyadarsh@dell.com
    Reported-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index cc234e6a6297..970dd87d347c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2166,10 +2166,10 @@ int __init acpi_scan_init(void)
 	acpi_cmos_rtc_init();
 	acpi_container_init();
 	acpi_memory_hotplug_init();
+	acpi_watchdog_init();
 	acpi_pnp_init();
 	acpi_int340x_thermal_init();
 	acpi_amba_init();
-	acpi_watchdog_init();
 	acpi_init_lpit();
 
 	acpi_scan_add_handler(&generic_device_handler);

commit 3c0d551e02b2590fa71a1354f2f1994551a33315
Merge: 19fd08b85bc7 5f7644190986
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 6 18:31:06 2018 -0700

    Merge tag 'pci-v4.17-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - move pci_uevent_ers() out of pci.h (Michael Ellerman)
    
     - skip ASPM common clock warning if BIOS already configured it (Sinan
       Kaya)
    
     - fix ASPM Coverity warning about threshold_ns (Gustavo A. R. Silva)
    
     - remove last user of pci_get_bus_and_slot() and the function itself
       (Sinan Kaya)
    
     - add decoding for 16 GT/s link speed (Jay Fang)
    
     - add interfaces to get max link speed and width (Tal Gilboa)
    
     - add pcie_bandwidth_capable() to compute max supported link bandwidth
       (Tal Gilboa)
    
     - add pcie_bandwidth_available() to compute bandwidth available to
       device (Tal Gilboa)
    
     - add pcie_print_link_status() to log link speed and whether it's
       limited (Tal Gilboa)
    
     - use PCI core interfaces to report when device performance may be
       limited by its slot instead of doing it in each driver (Tal Gilboa)
    
     - fix possible cpqphp NULL pointer dereference (Shawn Lin)
    
     - rescan more of the hierarchy on ACPI hotplug to fix Thunderbolt/xHCI
       hotplug (Mika Westerberg)
    
     - add support for PCI I/O port space that's neither directly accessible
       via CPU in/out instructions nor directly mapped into CPU physical
       memory space. This is fairly intrusive and includes minor changes to
       interfaces used for I/O space on most platforms (Zhichang Yuan, John
       Garry)
    
     - add support for HiSilicon Hip06/Hip07 LPC I/O space (Zhichang Yuan,
       John Garry)
    
     - use PCI_EXP_DEVCTL2_COMP_TIMEOUT in rapidio/tsi721 (Bjorn Helgaas)
    
     - remove possible NULL pointer dereference in of_pci_bus_find_domain_nr()
       (Shawn Lin)
    
     - report quirk timings with dev_info (Bjorn Helgaas)
    
     - report quirks that take longer than 10ms (Bjorn Helgaas)
    
     - add and use Altera Vendor ID (Johannes Thumshirn)
    
     - tidy Makefiles and comments (Bjorn Helgaas)
    
     - don't set up INTx if MSI or MSI-X is enabled to align cris, frv,
       ia64, and mn10300 with x86 (Bjorn Helgaas)
    
     - move pcieport_if.h to drivers/pci/pcie/ to encapsulate it (Frederick
       Lawler)
    
     - merge pcieport_if.h into portdrv.h (Bjorn Helgaas)
    
     - move workaround for BIOS PME issue from portdrv to PCI core (Bjorn
       Helgaas)
    
     - completely disable portdrv with "pcie_ports=compat" (Bjorn Helgaas)
    
     - remove portdrv link order dependency (Bjorn Helgaas)
    
     - remove support for unused VC portdrv service (Bjorn Helgaas)
    
     - simplify portdrv feature permission checking (Bjorn Helgaas)
    
     - remove "pcie_hp=nomsi" parameter (use "pci=nomsi" instead) (Bjorn
       Helgaas)
    
     - remove unnecessary "pcie_ports=auto" parameter (Bjorn Helgaas)
    
     - use cached AER capability offset (Frederick Lawler)
    
     - don't enable DPC if BIOS hasn't granted AER control (Mika Westerberg)
    
     - rename pcie-dpc.c to dpc.c (Bjorn Helgaas)
    
     - use generic pci_mmap_resource_range() instead of powerpc and xtensa
       arch-specific versions (David Woodhouse)
    
     - support arbitrary PCI host bridge offsets on sparc (Yinghai Lu)
    
     - remove System and Video ROM reservations on sparc (Bjorn Helgaas)
    
     - probe for device reset support during enumeration instead of runtime
       (Bjorn Helgaas)
    
     - add ACS quirk for Ampere (née APM) root ports (Feng Kan)
    
     - add function 1 DMA alias quirk for Marvell 88SE9220 (Thomas
       Vincent-Cross)
    
     - protect device restore with device lock (Sinan Kaya)
    
     - handle failure of FLR gracefully (Sinan Kaya)
    
     - handle CRS (config retry status) after device resets (Sinan Kaya)
    
     - skip various config reads for SR-IOV VFs as an optimization
       (KarimAllah Ahmed)
    
     - consolidate VPD code in vpd.c (Bjorn Helgaas)
    
     - add Tegra dependency on PCI_MSI_IRQ_DOMAIN (Arnd Bergmann)
    
     - add DT support for R-Car r8a7743 (Biju Das)
    
     - fix a PCI_EJECT vs PCI_BUS_RELATIONS race condition in Hyper-V host
       bridge driver that causes a general protection fault (Dexuan Cui)
    
     - fix Hyper-V host bridge hang in MSI setup on 1-vCPU VMs with SR-IOV
       (Dexuan Cui)
    
     - fix Hyper-V host bridge hang when ejecting a VF before setting up MSI
       (Dexuan Cui)
    
     - make several structures static (Fengguang Wu)
    
     - increase number of MSI IRQs supported by Synopsys DesignWare bridges
       from 32 to 256 (Gustavo Pimentel)
    
     - implemented multiplexed IRQ domain API and remove obsolete MSI IRQ
       API from DesignWare drivers (Gustavo Pimentel)
    
     - add Tegra power management support (Manikanta Maddireddy)
    
     - add Tegra loadable module support (Manikanta Maddireddy)
    
     - handle 64-bit BARs correctly in endpoint support (Niklas Cassel)
    
     - support optional regulator for HiSilicon STB (Shawn Guo)
    
     - use regulator bulk API for Qualcomm apq8064 (Srinivas Kandagatla)
    
     - support power supplies for Qualcomm msm8996 (Srinivas Kandagatla)
    
    * tag 'pci-v4.17-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (123 commits)
      MAINTAINERS: Add John Garry as maintainer for HiSilicon LPC driver
      HISI LPC: Add ACPI support
      ACPI / scan: Do not enumerate Indirect IO host children
      ACPI / scan: Rename acpi_is_serial_bus_slave() for more general use
      HISI LPC: Support the LPC host on Hip06/Hip07 with DT bindings
      of: Add missing I/O range exception for indirect-IO devices
      PCI: Apply the new generic I/O management on PCI IO hosts
      PCI: Add fwnode handler as input param of pci_register_io_range()
      PCI: Remove __weak tag from pci_register_io_range()
      MAINTAINERS: Add missing /drivers/pci/cadence directory entry
      fm10k: Report PCIe link properties with pcie_print_link_status()
      net/mlx5e: Use pcie_bandwidth_available() to compute bandwidth
      net/mlx5: Report PCIe link properties with pcie_print_link_status()
      net/mlx4_core: Report PCIe link properties with pcie_print_link_status()
      PCI: Add pcie_print_link_status() to log link speed and whether it's limited
      PCI: Add pcie_bandwidth_available() to compute bandwidth available to device
      misc: pci_endpoint_test: Handle 64-bit BARs properly
      PCI: designware-ep: Make dw_pcie_ep_reset_bar() handle 64-bit BARs properly
      PCI: endpoint: Make sure that BAR_5 does not have 64-bit flag set when clearing
      PCI: endpoint: Make epc->ops->clear_bar()/pci_epc_clear_bar() take struct *epf_bar
      ...

commit dfda4492322ed0a1eb9c4d4715c4b90c9af57352
Author: John Garry <john.garry@huawei.com>
Date:   Thu Mar 15 02:15:57 2018 +0800

    ACPI / scan: Do not enumerate Indirect IO host children
    
    Through the logical PIO framework, systems which otherwise have no IO space
    access to legacy ISA/LPC devices may access these devices through so-called
    "indirect IO" method.  In this, IO space accesses for non-PCI hosts are
    redirected to a host LLDD to manually generate the IO space (bus) accesses.
    Hosts are able to register a region in logical PIO space to map to its bus
    address range.
    
    Indirect IO child devices have an associated host-specific bus address.
    Special translation is required to map between a logical PIO address for a
    device and its host bus address.
    
    Since in the ACPI tables the child device IO resources would be the
    host-specific values, it is required the ACPI scan code should not
    enumerate these devices, and that this should be the responsibility of the
    host driver so that it can "fixup" the resources so that they map to the
    appropriate logical PIO addresses.
    
    To avoid enumerating these child devices, add a check from
    acpi_device_enumeration_by_parent() as to whether the parent for a device
    is a member of a known list of "indirect IO" hosts.  For now, the HiSilicon
    LPC host controller ID is added.
    
    Tested-by: dann frazier <dann.frazier@canonical.com>
    Signed-off-by: John Garry <john.garry@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f9e790479059..a4cbf3efc809 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1524,11 +1524,25 @@ static int acpi_check_serial_bus_slave(struct acpi_resource *ares, void *data)
 	return -1;
 }
 
+static bool acpi_is_indirect_io_slave(struct acpi_device *device)
+{
+	struct acpi_device *parent = device->parent;
+	const struct acpi_device_id indirect_io_hosts[] = {
+		{"HISI0191", 0},
+		{}
+	};
+
+	return parent && !acpi_match_device_ids(parent, indirect_io_hosts);
+}
+
 static bool acpi_device_enumeration_by_parent(struct acpi_device *device)
 {
 	struct list_head resource_list;
 	bool is_serial_bus_slave = false;
 
+	if (acpi_is_indirect_io_slave(device))
+		return true;
+
 	/* Macs use device properties in lieu of _CRS resources */
 	if (x86_apple_machine &&
 	    (fwnode_property_present(&device->fwnode, "spiSclkPeriod") ||

commit d87fb0917a073d71300b2b31b3773f6690bd1712
Author: John Garry <john.garry@huawei.com>
Date:   Thu Mar 15 02:15:56 2018 +0800

    ACPI / scan: Rename acpi_is_serial_bus_slave() for more general use
    
    Currently the ACPI scan has special handling for serial bus slaves, in that
    it makes it the responsibility of the slave device's parent to enumerate
    the device.
    
    To support other types of slave devices which require the same special
    handling but where the bus is not strictly a serial bus, such as devices on
    the HiSilicon LPC controller bus, rename acpi_is_serial_bus_slave() to
    acpi_device_enumeration_by_parent(), so that the name can fit the wider
    purpose.
    
    Also rename the associated device flag acpi_device_flags.serial_bus_slave
    to .enumeration_by_parent.
    
    Signed-off-by: John Garry <john.garry@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8e63d937babb..f9e790479059 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1524,7 +1524,7 @@ static int acpi_check_serial_bus_slave(struct acpi_resource *ares, void *data)
 	return -1;
 }
 
-static bool acpi_is_serial_bus_slave(struct acpi_device *device)
+static bool acpi_device_enumeration_by_parent(struct acpi_device *device)
 {
 	struct list_head resource_list;
 	bool is_serial_bus_slave = false;
@@ -1560,7 +1560,8 @@ void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 	acpi_bus_get_flags(device);
 	device->flags.match_driver = false;
 	device->flags.initialized = true;
-	device->flags.serial_bus_slave = acpi_is_serial_bus_slave(device);
+	device->flags.enumeration_by_parent =
+		acpi_device_enumeration_by_parent(device);
 	acpi_device_clear_enumerated(device);
 	device_initialize(&device->dev);
 	dev_set_uevent_suppress(&device->dev, true);
@@ -1858,10 +1859,10 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 static void acpi_default_enumeration(struct acpi_device *device)
 {
 	/*
-	 * Do not enumerate SPI/I2C/UART slaves as they will be enumerated by
-	 * their respective parents.
+	 * Do not enumerate devices with enumeration_by_parent flag set as
+	 * they will be enumerated by their respective parents.
 	 */
-	if (!device->flags.serial_bus_slave) {
+	if (!device->flags.enumeration_by_parent) {
 		acpi_create_platform_device(device, NULL);
 		acpi_device_set_enumerated(device);
 	} else {
@@ -1958,7 +1959,7 @@ static void acpi_bus_attach(struct acpi_device *device)
 		return;
 
 	device->flags.match_driver = true;
-	if (ret > 0 && !device->flags.serial_bus_slave) {
+	if (ret > 0 && !device->flags.enumeration_by_parent) {
 		acpi_device_set_enumerated(device);
 		goto ok;
 	}
@@ -1967,10 +1968,10 @@ static void acpi_bus_attach(struct acpi_device *device)
 	if (ret < 0)
 		return;
 
-	if (!device->pnp.type.platform_id && !device->flags.serial_bus_slave)
-		acpi_device_set_enumerated(device);
-	else
+	if (device->pnp.type.platform_id || device->flags.enumeration_by_parent)
 		acpi_default_enumeration(device);
+	else
+		acpi_device_set_enumerated(device);
 
  ok:
 	list_for_each_entry(child, &device->children, node)

commit 27664c581866c950f31ac007ea2c63fc6e2b29d5
Author: Lee, Chun-Yi <joeyli.kernel@gmail.com>
Date:   Tue Mar 20 13:51:26 2018 +0800

    ACPI / scan: Send change uevent with offine environmental data
    
    In current design of ACPI container offline, Kernel emits
    KOBJ_CHANGE uevent to user space to indidate that the ejection of
    the container was triggered by platform. (caa73ea15 patch)
    
    A pure KOBJ_CHANGE uevent is not enough for user space to identify
    the purpose. For example, a "udevadm trigger" command can also
    be used to emit change event to all udev rules. A udev rule can not
    identify that the event is from kernel for offline or from udevadm
    for other purpose. Then the offline action in udev rule may also be
    triggered by udevadm tool.
    
    So, similar to the change uevent of dock, kernel sends the
    KOBJ_CHANGE uevent with a offline environmental data to indicate
    purpose. It's useful by udev rule for using ENV{EVENT} filter.
    
    Acked-by: Michal Hocko <mhocko@suse.com>
    Tested-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: "Lee, Chun-Yi" <jlee@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8e63d937babb..490498eca0d3 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -116,6 +116,7 @@ bool acpi_scan_is_offline(struct acpi_device *adev, bool uevent)
 {
 	struct acpi_device_physical_node *pn;
 	bool offline = true;
+	char *envp[] = { "EVENT=offline", NULL };
 
 	/*
 	 * acpi_container_offline() calls this for all of the container's
@@ -126,7 +127,7 @@ bool acpi_scan_is_offline(struct acpi_device *adev, bool uevent)
 	list_for_each_entry(pn, &adev->physical_node_list, node)
 		if (device_supports_offline(pn->dev) && !pn->dev->offline) {
 			if (uevent)
-				kobject_uevent(&pn->dev->kobj, KOBJ_CHANGE);
+				kobject_uevent_env(&pn->dev->kobj, KOBJ_CHANGE, envp);
 
 			offline = false;
 			break;

commit 63347db0affadcbccd5613116ea8431c70139b3e
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Jan 26 16:02:59 2018 +0100

    ACPI / scan: Use acpi_bus_get_status() to initialize ACPI_TYPE_DEVICE devs
    
    The acpi_get_bus_status wrapper for acpi_bus_get_status_handle has some
    code to handle certain device quirks, in some cases we also need this
    quirk handling for the initial _STA call.
    
    Specifically on some devices calling _STA before all _DEP dependencies
    are met results in errors like these:
    
    [    0.123579] ACPI Error: No handler for Region [ECRM] (00000000ba9edc4c)
                   [GenericSerialBus] (20170831/evregion-166)
    [    0.123601] ACPI Error: Region GenericSerialBus (ID=9) has no handler
                   (20170831/exfldio-299)
    [    0.123618] ACPI Error: Method parse/execution failed
                   \_SB.I2C1.BAT1._STA, AE_NOT_EXIST (20170831/psparse-550)
    
    acpi_get_bus_status already has code to avoid this, so by using it we
    also silence these errors from the initial _STA call.
    
    Note that in order for the acpi_get_bus_status handling for this to work,
    we initialize dep_unmet to 1 until acpi_device_dep_initialize gets called,
    this means that battery devices will be instantiated with an initial
    status of 0. This is not a problem, acpi_bus_attach will get called soon
    after the instantiation anyways and it will update the status as first
    point of order.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b0fe5272c76a..8e63d937babb 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1565,6 +1565,8 @@ void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 	device_initialize(&device->dev);
 	dev_set_uevent_suppress(&device->dev, true);
 	acpi_init_coherency(device);
+	/* Assume there are unmet deps until acpi_device_dep_initialize() runs */
+	device->dep_unmet = 1;
 }
 
 void acpi_device_add_finalize(struct acpi_device *device)
@@ -1588,6 +1590,14 @@ static int acpi_add_single_object(struct acpi_device **child,
 	}
 
 	acpi_init_device_object(device, handle, type, sta);
+	/*
+	 * For ACPI_BUS_TYPE_DEVICE getting the status is delayed till here so
+	 * that we can call acpi_bus_get_status() and use its quirk handling.
+	 * Note this must be done before the get power-/wakeup_dev-flags calls.
+	 */
+	if (type == ACPI_BUS_TYPE_DEVICE)
+		acpi_bus_get_status(device);
+
 	acpi_bus_get_power_flags(device);
 	acpi_bus_get_wakeup_device_flags(device);
 
@@ -1660,9 +1670,11 @@ static int acpi_bus_type_and_status(acpi_handle handle, int *type,
 			return -ENODEV;
 
 		*type = ACPI_BUS_TYPE_DEVICE;
-		status = acpi_bus_get_status_handle(handle, sta);
-		if (ACPI_FAILURE(status))
-			*sta = 0;
+		/*
+		 * acpi_add_single_object updates this once we've an acpi_device
+		 * so that acpi_bus_get_status' quirk handling can be used.
+		 */
+		*sta = 0;
 		break;
 	case ACPI_TYPE_PROCESSOR:
 		*type = ACPI_BUS_TYPE_PROCESSOR;
@@ -1760,6 +1772,8 @@ static void acpi_device_dep_initialize(struct acpi_device *adev)
 	acpi_status status;
 	int i;
 
+	adev->dep_unmet = 0;
+
 	if (!acpi_has_method(adev->handle, "_DEP"))
 		return;
 

commit b6c70268723bc89743b8aaaa7d17f6889d72497a
Merge: 10809bb97664 a64a62ce9a38
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 30 13:37:29 2017 +0100

    Merge branch 'acpi-ec' into acpi
    
    * acpi-ec:
      ACPI / EC: Fix regression related to PM ops support in ECDT device

commit a64a62ce9a380213dc9e192f762266d70c9b40ec
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Sep 26 16:54:09 2017 +0800

    ACPI / EC: Fix regression related to PM ops support in ECDT device
    
    On platforms (ASUS X550ZE and possibly all ASUS X series) with valid ECDT
    EC but invalid DSDT EC, EC PM ops won't be invoked as ECDT EC is not an
    ACPI device. Thus the following commit actually removed post-resume
    acpi_ec_enable_event() invocation for such platforms, and triggered a
    regression on them that after being resumed, EC (actually should be ECDT)
    driver stops handling EC events:
    
     Commit: c2b46d679b30c5c0d7eb47a21085943242bdd8dc
     Subject: ACPI / EC: Add PM operations to improve event handling for resume process
    
    Notice that the root cause actually is "ECDT is not an ACPI device" rather
    than "the timing of acpi_ec_enable_event() invocation", this patch fixes
    this issue by enumerating ECDT EC as an ACPI device. Due to the existence
    of the noirq stage, the ability of tuning the timing of
    acpi_ec_enable_event() invocation is still meaningful.
    
    This patch is a little bit different from the posted fix by moving
    acpi_config_boot_ec() from acpi_ec_ecdt_start() to acpi_ec_add() to make
    sure that EC event handling won't be stopped as long as the ACPI EC driver
    is bound. Thus the following sequence shouldn't disable EC event handling:
    unbind,suspend,resume,bind.
    
    Fixes: c2b46d679b30 (ACPI / EC: Add PM operations to improve event handling for resume process)
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=196847
    Reported-by: Luya Tshimbalanga <luya@fedoraproject.org>
    Tested-by: Luya Tshimbalanga <luya@fedoraproject.org>
    Cc: 4.9+ <stable@vger.kernel.org> # 4.9+
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 602f8ff212f2..2f2f50322ffb 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1024,6 +1024,9 @@ static void acpi_device_get_busid(struct acpi_device *device)
 	case ACPI_BUS_TYPE_SLEEP_BUTTON:
 		strcpy(device->pnp.bus_id, "SLPF");
 		break;
+	case ACPI_BUS_TYPE_ECDT_EC:
+		strcpy(device->pnp.bus_id, "ECDT");
+		break;
 	default:
 		acpi_get_name(device->handle, ACPI_SINGLE_NAME, &buffer);
 		/* Clean up trailing underscores (if any) */
@@ -1304,6 +1307,9 @@ static void acpi_set_pnp_ids(acpi_handle handle, struct acpi_device_pnp *pnp,
 	case ACPI_BUS_TYPE_SLEEP_BUTTON:
 		acpi_add_id(pnp, ACPI_BUTTON_HID_SLEEPF);
 		break;
+	case ACPI_BUS_TYPE_ECDT_EC:
+		acpi_add_id(pnp, ACPI_ECDT_HID);
+		break;
 	}
 }
 
@@ -2049,6 +2055,21 @@ void acpi_bus_trim(struct acpi_device *adev)
 }
 EXPORT_SYMBOL_GPL(acpi_bus_trim);
 
+int acpi_bus_register_early_device(int type)
+{
+	struct acpi_device *device = NULL;
+	int result;
+
+	result = acpi_add_single_object(&device, NULL,
+					type, ACPI_STA_DEFAULT);
+	if (result)
+		return result;
+
+	device->flags.match_driver = true;
+	return device_attach(&device->dev);
+}
+EXPORT_SYMBOL_GPL(acpi_bus_register_early_device);
+
 static int acpi_bus_scan_fixed(void)
 {
 	int result = 0;

commit fb0255fb2941ef6f21742b2bc146d6b9aef4fedc
Merge: 449fcf3ab0ba 57f5d648c45c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 21:05:31 2017 -0800

    Merge tag 'tty-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty
    
    Pull tty/serial updates from Greg KH:
     "Here is the big tty/serial driver pull request for 4.15-rc1.
    
      Lots of serial driver updates in here, some small vt cleanups, and a
      raft of SPDX and license boilerplate cleanups, messing up the diffstat
      a bit.
    
      Nothing major, with no realy functional changes except better hardware
      support for some platforms.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'tty-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty: (110 commits)
      tty: ehv_bytechan: fix spelling mistake
      tty: serial: meson: allow baud-rates lower than 9600
      serial: 8250_fintek: Fix crash with baud rate B0
      serial: 8250_fintek: Disable delays for ports != 0
      serial: 8250_fintek: Return -EINVAL on invalid configuration
      tty: Remove redundant license text
      tty: serdev: Remove redundant license text
      tty: hvc: Remove redundant license text
      tty: serial: Remove redundant license text
      tty: add SPDX identifiers to all remaining files in drivers/tty/
      tty: serial: jsm: remove redundant pointer ts
      tty: serial: jsm: add space before the open parenthesis '('
      tty: serial: jsm: fix coding style
      tty: serial: jsm: delete space between function name and '('
      tty: serial: jsm: add blank line after declarations
      tty: serial: jsm: change the type of local variable
      tty: serial: imx: remove dead code imx_dma_rxint
      tty: serial: imx: disable ageing timer interrupt if dma in use
      serial: 8250: fix potential deadlock in rs485-mode
      serial: m32r_sio: Drop redundant .data assignment
      ...

commit e361d1f85855ded967bd4803e8293445a6ce301a
Author: Frédéric Danis <frederic.danis.oss@gmail.com>
Date:   Wed Oct 11 10:32:14 2017 +0200

    ACPI / scan: Fix enumeration for special UART devices
    
    UART devices is expected to be enumerated by SerDev subsystem.
    
    During ACPI scan, serial devices behind SPI, I2C or UART buses are not
    enumerated, allowing them to be enumerated by their respective parents.
    
    Rename *spi_i2c_slave* to *serial_bus_slave* as this will be used for serial
    devices on serial buses (SPI, I2C or UART).
    
    On Macs an empty ResourceTemplate is returned for uart slaves.
    Instead the device properties "baud", "parity", "dataBits", "stopBits" are
    provided. Add a check for "baud" in acpi_is_serial_bus_slave().
    
    Signed-off-by: Frédéric Danis <frederic.danis.oss@gmail.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Tested-by: Ronald Tschalär <ronald@innovation.ch>
    Tested-by: Peter Y. Chuang <peteryuchuang@gmail.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 602f8ff212f2..860b6987c2d1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1505,41 +1505,38 @@ static void acpi_init_coherency(struct acpi_device *adev)
 	adev->flags.coherent_dma = cca;
 }
 
-static int acpi_check_spi_i2c_slave(struct acpi_resource *ares, void *data)
+static int acpi_check_serial_bus_slave(struct acpi_resource *ares, void *data)
 {
-	bool *is_spi_i2c_slave_p = data;
+	bool *is_serial_bus_slave_p = data;
 
 	if (ares->type != ACPI_RESOURCE_TYPE_SERIAL_BUS)
 		return 1;
 
-	/*
-	 * devices that are connected to UART still need to be enumerated to
-	 * platform bus
-	 */
-	if (ares->data.common_serial_bus.type != ACPI_RESOURCE_SERIAL_TYPE_UART)
-		*is_spi_i2c_slave_p = true;
+	*is_serial_bus_slave_p = true;
 
 	 /* no need to do more checking */
 	return -1;
 }
 
-static bool acpi_is_spi_i2c_slave(struct acpi_device *device)
+static bool acpi_is_serial_bus_slave(struct acpi_device *device)
 {
 	struct list_head resource_list;
-	bool is_spi_i2c_slave = false;
+	bool is_serial_bus_slave = false;
 
 	/* Macs use device properties in lieu of _CRS resources */
 	if (x86_apple_machine &&
 	    (fwnode_property_present(&device->fwnode, "spiSclkPeriod") ||
-	     fwnode_property_present(&device->fwnode, "i2cAddress")))
+	     fwnode_property_present(&device->fwnode, "i2cAddress") ||
+	     fwnode_property_present(&device->fwnode, "baud")))
 		return true;
 
 	INIT_LIST_HEAD(&resource_list);
-	acpi_dev_get_resources(device, &resource_list, acpi_check_spi_i2c_slave,
-			       &is_spi_i2c_slave);
+	acpi_dev_get_resources(device, &resource_list,
+			       acpi_check_serial_bus_slave,
+			       &is_serial_bus_slave);
 	acpi_dev_free_resource_list(&resource_list);
 
-	return is_spi_i2c_slave;
+	return is_serial_bus_slave;
 }
 
 void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
@@ -1557,7 +1554,7 @@ void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 	acpi_bus_get_flags(device);
 	device->flags.match_driver = false;
 	device->flags.initialized = true;
-	device->flags.spi_i2c_slave = acpi_is_spi_i2c_slave(device);
+	device->flags.serial_bus_slave = acpi_is_serial_bus_slave(device);
 	acpi_device_clear_enumerated(device);
 	device_initialize(&device->dev);
 	dev_set_uevent_suppress(&device->dev, true);
@@ -1841,10 +1838,10 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 static void acpi_default_enumeration(struct acpi_device *device)
 {
 	/*
-	 * Do not enumerate SPI/I2C slaves as they will be enumerated by their
-	 * respective parents.
+	 * Do not enumerate SPI/I2C/UART slaves as they will be enumerated by
+	 * their respective parents.
 	 */
-	if (!device->flags.spi_i2c_slave) {
+	if (!device->flags.serial_bus_slave) {
 		acpi_create_platform_device(device, NULL);
 		acpi_device_set_enumerated(device);
 	} else {
@@ -1941,7 +1938,7 @@ static void acpi_bus_attach(struct acpi_device *device)
 		return;
 
 	device->flags.match_driver = true;
-	if (ret > 0 && !device->flags.spi_i2c_slave) {
+	if (ret > 0 && !device->flags.serial_bus_slave) {
 		acpi_device_set_enumerated(device);
 		goto ok;
 	}
@@ -1950,7 +1947,7 @@ static void acpi_bus_attach(struct acpi_device *device)
 	if (ret < 0)
 		return;
 
-	if (!device->pnp.type.platform_id && !device->flags.spi_i2c_slave)
+	if (!device->pnp.type.platform_id && !device->flags.serial_bus_slave)
 		acpi_device_set_enumerated(device);
 	else
 		acpi_default_enumeration(device);

commit eeb2d80d502af28e5660ff4bbe00f90ceb82c2db
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Oct 5 16:24:03 2017 -0700

    ACPI / LPIT: Add Low Power Idle Table (LPIT) support
    
    Add functionality to read LPIT table, which provides:
    
     - Sysfs interface to read residency counters via
       /sys/devices/system/cpu/cpuidle/low_power_idle_cpu_residency_us
       /sys/devices/system/cpu/cpuidle/low_power_idle_system_residency_us
    
    Here the count "low_power_idle_cpu_residency_us" shows the time spent
    by CPU package in low power state.  This is read via MSR interface,
    which points to MSR for PKG C10.
    
    Here the count "low_power_idle_system_residency_us" show the count the
    system was in low power state. This is read via MMIO interface. This
    is mapped to SLP_S0 residency on modern Intel systems. This residency
    is achieved only when CPU is in PKG C10 and all functional blocks are
    in low power state.
    
    It is possible that none of the above counters present or anyone of the
    counter present or all counters present.
    
    For example: On my Kabylake system both of the above counters present.
    After suspend to idle these counts updated and prints:
    
     6916179
     6998564
    
    This counter can be read by tools like turbostat to display. Or it can
    be used to debug, if modern systems are reaching desired low power state.
    
     - Provides an interface to read residency counter memory address
    
       This address can be used to get the base address of PMC memory
       mapped IO.  This is utilized by intel_pmc_core driver to print
       more debug information.
    
    In addition, to avoid code duplication to read iomem, removed the read of
    iomem from acpi_os_read_memory() in osl.c and made a common function
    acpi_os_read_iomem(). This new function is used for reading iomem in
    in both osl.c and acpi_lpit.c.
    
    Link: http://www.uefi.org/sites/default/files/resources/Intel_ACPI_Low_Power_S0_Idle.pdf
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 602f8ff212f2..81367edc8a10 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2122,6 +2122,7 @@ int __init acpi_scan_init(void)
 	acpi_int340x_thermal_init();
 	acpi_amba_init();
 	acpi_watchdog_init();
+	acpi_init_lpit();
 
 	acpi_scan_add_handler(&generic_device_handler);
 

commit e7d0c41ecc2e372a81741a30894f556afec24315
Merge: 53ac64aac9af 3689d3d69072
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 5 12:50:00 2017 -0700

    Merge tag 'devprop-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull device properties framework updates from Rafael Wysocki:
     "These introduce fwnode operations for all of the separate types of
      'firmware nodes' that can be handled by the device properties
      framework, make the framework use const fwnode arguments all over, add
      a helper for the consolidated handling of node references and switch
      over the framework to the new UUID API.
    
      Specifics:
    
       - Introduce fwnode operations for all of the separate types of
         'firmware nodes' that can be handled by the device properties
         framework and drop the type field from struct fwnode_handle (Sakari
         Ailus, Arnd Bergmann).
    
       - Make the device properties framework use const fwnode arguments
         where possible (Sakari Ailus).
    
       - Add a helper for the consolidated handling of node references to
         the device properties framework (Sakari Ailus).
    
       - Switch over the ACPI part of the device properties framework to the
         new UUID API (Andy Shevchenko)"
    
    * tag 'devprop-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      ACPI: device property: Switch to use new generic UUID API
      device property: export irqchip_fwnode_ops
      device property: Introduce fwnode_property_get_reference_args
      device property: Constify fwnode property API
      device property: Constify argument to pset fwnode backend
      ACPI: Constify internal fwnode arguments
      ACPI: Constify acpi_bus helper functions, switch to macros
      ACPI: Prepare for constifying acpi_get_next_subnode() fwnode argument
      device property: Get rid of struct fwnode_handle type field
      ACPI: Use IS_ERR_OR_NULL() instead of non-NULL check in is_acpi_data_node()

commit 01d2f105a428bb2ebc248e71b8c86df569288b95
Merge: f928a49027ed 42d516ce3414 a4bb2b493355 58eefe2f3f53 8a2e487e6fc1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Sep 3 23:54:03 2017 +0200

    Merge branches 'acpi-x86', 'acpi-soc', 'acpi-pmic' and 'acpi-apple'
    
    * acpi-x86:
      ACPI / boot: Add number of legacy IRQs to debug output
      ACPI / boot: Correct address space of __acpi_map_table()
      ACPI / boot: Don't define unused variables
    
    * acpi-soc:
      ACPI / LPSS: Don't abort ACPI scan on missing mem resource
    
    * acpi-pmic:
      ACPI / PMIC: xpower: Do pinswitch magic when reading GPADC
    
    * acpi-apple:
      spi: Use Apple device properties in absence of ACPI resources
      ACPI / scan: Recognize Apple SPI and I2C slaves
      ACPI / property: Support Apple _DSM properties
      ACPI / property: Don't evaluate objects for devices w/o handle
      treewide: Consolidate Apple DMI checks

commit f928a49027ed4c5c35065102d150ada5e26bfc75
Merge: 4467ade90d62 56f77eeb6bca 10d8ab2c15b9 0ed780e316f4 66ed4cac669c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Sep 3 23:53:39 2017 +0200

    Merge branches 'acpi-ec', 'acpi-dma', 'acpi-processor' and 'acpi-cppc'
    
    * acpi-ec:
      ACPI / EC: Clean up EC GPE mask flag
      ACPI: EC: Fix possible issues related to EC initialization order
    
    * acpi-dma:
      ACPI/IORT: Add IORT named component memory address limits
      ACPI: Make acpi_dma_configure() DMA regions aware
      ACPI: Introduce DMA ranges parsing
      ACPI: Make acpi_dev_get_resources() method agnostic
    
    * acpi-processor:
      ACPI / processor: make function acpi_processor_check_duplicates() static
      ACPI: processor: use dev_dbg() instead of dev_warn() when CPPC probe failed
    
    * acpi-cppc:
      mailbox: pcc: Drop uninformative output during boot

commit eb7f43c4adb4a789f99f53916182c3401b4e33c7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 10 00:34:23 2017 +0200

    ACPI / scan: Enable GPEs before scanning the namespace
    
    On some systems the platform firmware expects GPEs to be enabled
    before the enumeration of devices and if that expectation is not
    met, the systems in question may not boot in some situations.
    
    For this reason, change the initialization ordering of the ACPI
    subsystem to make it enable GPEs before scanning the namespace
    for the first time in order to enumerate devices.
    
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Suggested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Lv Zheng <lv.zheng@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 70fd5502c284..b7bdf9d0f5c0 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2058,6 +2058,9 @@ int __init acpi_scan_init(void)
 			acpi_get_spcr_uart_addr();
 	}
 
+	acpi_gpe_apply_masked_gpes();
+	acpi_update_all_gpes();
+
 	mutex_lock(&acpi_scan_lock);
 	/*
 	 * Enumerate devices in the ACPI namespace.
@@ -2082,9 +2085,6 @@ int __init acpi_scan_init(void)
 		}
 	}
 
-	acpi_gpe_apply_masked_gpes();
-	acpi_update_all_gpes();
-
 	acpi_scan_initialized = true;
 
  out:

commit 98529b9272e06a7767034fb8a32e43cdecda240a
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Aug 16 15:29:49 2017 +0800

    ACPI: EC: Fix regression related to wrong ECDT initialization order
    
    Commit 2a5708409e4e (ACPI / EC: Fix a gap that ECDT EC cannot handle
    EC events) introduced acpi_ec_ecdt_start(), but that function is
    invoked before acpi_ec_query_init(), which is too early.  This causes
    the kernel to crash if an EC event occurs after boot, when ec_query_wq
    is not valid:
    
     BUG: unable to handle kernel NULL pointer dereference at 0000000000000102
     ...
     Workqueue: events acpi_ec_event_handler
     task: ffff9f539790dac0 task.stack: ffffb437c0e10000
     RIP: 0010:__queue_work+0x32/0x430
    
    Normally, the DSDT EC should always be valid, so acpi_ec_ecdt_start()
    is actually a no-op in the majority of cases.  However, commit
    c712bb58d827 (ACPI / EC: Add support to skip boot stage DSDT probe)
    caused the probing of the DSDT EC as the "boot EC" to be skipped when
    the ECDT EC is valid and uncovered the bug.
    
    Fix this issue by invoking acpi_ec_ecdt_start() after acpi_ec_query_init()
    in acpi_ec_init().
    
    Link: https://jira01.devtools.intel.com/browse/LCK-4348
    Fixes: 2a5708409e4e (ACPI / EC: Fix a gap that ECDT EC cannot handle EC events)
    Fixes: c712bb58d827 (ACPI / EC: Add support to skip boot stage DSDT probe)
    Reported-by: Wang Wendy <wendy.wang@intel.com>
    Tested-by: Feng Chenzhou <chenzhoux.feng@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 33897298f03e..70fd5502c284 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2084,7 +2084,6 @@ int __init acpi_scan_init(void)
 
 	acpi_gpe_apply_masked_gpes();
 	acpi_update_all_gpes();
-	acpi_ec_ecdt_start();
 
 	acpi_scan_initialized = true;
 

commit 7ad4263980826e8b02e121af22f4f4c9103fe86d
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Aug 7 11:29:49 2017 +0100

    ACPI: Make acpi_dma_configure() DMA regions aware
    
    Current ACPI DMA configuration set-up device DMA capabilities through
    kernel defaults that do not take into account platform specific DMA
    configurations reported by firmware.
    
    By leveraging the ACPI acpi_dev_get_dma_resources() API, add code
    in acpi_dma_configure() to retrieve the DMA regions to correctly
    set-up PCI devices DMA parameters.
    
    Rework the ACPI IORT kernel API to make sure they can accommodate
    the DMA set-up required by firmware. By making PCI devices DMA set-up
    ACPI IORT specific, the kernel is shielded from unwanted regressions
    that could be triggered by parsing DMA resources on arches that were
    previously ignoring them (ie x86/ia64), leaving kernel behaviour
    unchanged on those arches.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Tested-by: Nate Watterson <nwatters@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 94500d99f2d6..0483d36433ac 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1446,20 +1446,16 @@ int acpi_dma_get_range(struct device *dev, u64 *dma_addr, u64 *offset,
 int acpi_dma_configure(struct device *dev, enum dev_dma_attr attr)
 {
 	const struct iommu_ops *iommu;
-	u64 size;
+	u64 dma_addr = 0, size = 0;
 
-	iort_set_dma_mask(dev);
+	iort_dma_setup(dev, &dma_addr, &size);
 
 	iommu = iort_iommu_configure(dev);
 	if (IS_ERR(iommu) && PTR_ERR(iommu) == -EPROBE_DEFER)
 		return -EPROBE_DEFER;
 
-	size = max(dev->coherent_dma_mask, dev->coherent_dma_mask + 1);
-	/*
-	 * Assume dma valid range starts at 0 and covers the whole
-	 * coherent_dma_mask.
-	 */
-	arch_setup_dma_ops(dev, 0, size, iommu, attr == DEV_DMA_COHERENT);
+	arch_setup_dma_ops(dev, dma_addr, size,
+				iommu, attr == DEV_DMA_COHERENT);
 
 	return 0;
 }

commit c04ac679c6b86e4e36fbb675c6c061b4091f5810
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Aug 7 11:29:48 2017 +0100

    ACPI: Introduce DMA ranges parsing
    
    Some devices have limited addressing capabilities and cannot
    reference the whole memory address space while carrying out DMA
    operations (eg some devices with bus address bits range smaller than
    system bus - which prevents them from using bus addresses that are
    otherwise valid for the system).
    
    The ACPI _DMA object allows bus devices to define the DMA window that is
    actually addressable by devices that sit upstream the bus, therefore
    providing a means to parse and initialize the devices DMA masks and
    addressable DMA range size.
    
    By relying on the generic ACPI kernel layer to retrieve and parse
    resources, introduce ACPI core code to parse the _DMA object.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Tested-by: Nate Watterson <nwatters@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 33897298f03e..94500d99f2d6 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1359,6 +1359,85 @@ enum dev_dma_attr acpi_get_dma_attr(struct acpi_device *adev)
 		return DEV_DMA_NON_COHERENT;
 }
 
+/**
+ * acpi_dma_get_range() - Get device DMA parameters.
+ *
+ * @dev: device to configure
+ * @dma_addr: pointer device DMA address result
+ * @offset: pointer to the DMA offset result
+ * @size: pointer to DMA range size result
+ *
+ * Evaluate DMA regions and return respectively DMA region start, offset
+ * and size in dma_addr, offset and size on parsing success; it does not
+ * update the passed in values on failure.
+ *
+ * Return 0 on success, < 0 on failure.
+ */
+int acpi_dma_get_range(struct device *dev, u64 *dma_addr, u64 *offset,
+		       u64 *size)
+{
+	struct acpi_device *adev;
+	LIST_HEAD(list);
+	struct resource_entry *rentry;
+	int ret;
+	struct device *dma_dev = dev;
+	u64 len, dma_start = U64_MAX, dma_end = 0, dma_offset = 0;
+
+	/*
+	 * Walk the device tree chasing an ACPI companion with a _DMA
+	 * object while we go. Stop if we find a device with an ACPI
+	 * companion containing a _DMA method.
+	 */
+	do {
+		adev = ACPI_COMPANION(dma_dev);
+		if (adev && acpi_has_method(adev->handle, METHOD_NAME__DMA))
+			break;
+
+		dma_dev = dma_dev->parent;
+	} while (dma_dev);
+
+	if (!dma_dev)
+		return -ENODEV;
+
+	if (!acpi_has_method(adev->handle, METHOD_NAME__CRS)) {
+		acpi_handle_warn(adev->handle, "_DMA is valid only if _CRS is present\n");
+		return -EINVAL;
+	}
+
+	ret = acpi_dev_get_dma_resources(adev, &list);
+	if (ret > 0) {
+		list_for_each_entry(rentry, &list, node) {
+			if (dma_offset && rentry->offset != dma_offset) {
+				ret = -EINVAL;
+				dev_warn(dma_dev, "Can't handle multiple windows with different offsets\n");
+				goto out;
+			}
+			dma_offset = rentry->offset;
+
+			/* Take lower and upper limits */
+			if (rentry->res->start < dma_start)
+				dma_start = rentry->res->start;
+			if (rentry->res->end > dma_end)
+				dma_end = rentry->res->end;
+		}
+
+		if (dma_start >= dma_end) {
+			ret = -EINVAL;
+			dev_dbg(dma_dev, "Invalid DMA regions configuration\n");
+			goto out;
+		}
+
+		*dma_addr = dma_start - dma_offset;
+		len = dma_end - dma_start;
+		*size = max(len, len + 1);
+		*offset = dma_offset;
+	}
+ out:
+	acpi_dev_free_resource_list(&list);
+
+	return ret >= 0 ? 0 : ret;
+}
+
 /**
  * acpi_dma_configure - Set-up DMA configuration for the device.
  * @dev: The pointer to the device

commit ca9ef3ab68d3530ac93d4254f9e47724ea51758d
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Aug 1 14:10:41 2017 +0200

    ACPI / scan: Recognize Apple SPI and I2C slaves
    
    SPI and I2C slaves are enumerated by their respective parents rather
    than the ACPI core.  They are recognized by presence of _CRS resources,
    which however are missing on Macs.  Check for presence of device
    properties instead.
    
    Reported-and-tested-by: Ronald Tschalär <ronald@innovation.ch>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 33897298f03e..55fd248833cd 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -13,6 +13,7 @@
 #include <linux/dmi.h>
 #include <linux/nls.h>
 #include <linux/dma-mapping.h>
+#include <linux/platform_data/x86/apple.h>
 
 #include <asm/pgtable.h>
 
@@ -1452,6 +1453,12 @@ static bool acpi_is_spi_i2c_slave(struct acpi_device *device)
 	struct list_head resource_list;
 	bool is_spi_i2c_slave = false;
 
+	/* Macs use device properties in lieu of _CRS resources */
+	if (x86_apple_machine &&
+	    (fwnode_property_present(&device->fwnode, "spiSclkPeriod") ||
+	     fwnode_property_present(&device->fwnode, "i2cAddress")))
+		return true;
+
 	INIT_LIST_HEAD(&resource_list);
 	acpi_dev_get_resources(device, &resource_list, acpi_check_spi_i2c_slave,
 			       &is_spi_i2c_slave);

commit db3e50f3234ba1a477413f56a9e5800a73dca786
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Jul 21 14:39:31 2017 +0300

    device property: Get rid of struct fwnode_handle type field
    
    Instead of relying on the struct fwnode_handle type field, define
    fwnode_operations structs for all separate types of fwnodes. To find out
    the type, compare to the ops field to relevant ops structs.
    
    This change has two benefits:
    
    1. it avoids adding the type field to each and every instance of struct
    fwnode_handle, thus saving memory and
    
    2. makes the ops field the single factor that defines both the types of
    the fwnode as well as defines the implementation of its operations,
    decreasing the possibility of bugs when developing code dealing with
    fwnode internals.
    
    Suggested-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 33897298f03e..943536c9a2a8 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1467,8 +1467,7 @@ void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 	device->device_type = type;
 	device->handle = handle;
 	device->parent = acpi_bus_get_parent(handle);
-	device->fwnode.type = FWNODE_ACPI;
-	device->fwnode.ops = &acpi_fwnode_ops;
+	device->fwnode.ops = &acpi_device_fwnode_ops;
 	acpi_set_device_status(device, sta);
 	acpi_device_get_busid(device);
 	acpi_set_pnp_ids(handle, &device->pnp, type);

commit 548aa0e3c516d906dae5edb1fc9a1ad2e490120a
Merge: 322618684353 6a71d8d77795
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 10 15:23:45 2017 -0700

    Merge tag 'devprop-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull device properties framework updates from Rafael Wysocki:
     "These mostly rearrange the device properties core code and add a few
      helper functions to it as a foundation for future work.
    
      Specifics:
    
       - Rearrange the core device properties code by moving the code
         specific to each supported platform configuration framework (ACPI,
         DT and build-in) into a separate file (Sakari Ailus).
    
       - Add helper functions for accessing device properties in a
         firmware-agnostic way (Sakari Ailus, Kieran Bingham)"
    
    * tag 'devprop-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      device property: Add fwnode_graph_get_port_parent
      device property: Add FW type agnostic fwnode_graph_get_remote_node
      device property: Introduce fwnode_device_is_available()
      device property: Move fwnode graph ops to firmware specific locations
      device property: Move FW type specific functionality to FW specific files
      ACPI: Constify argument to acpi_device_is_present()

commit f19e80b394808ed763e2669b08aea480adcc46be
Merge: eceeae414edc 79a648328d2a 5438bc573a2c 9a4d8d60df3b d429e5c12269 9e4de6a8eee2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 10 22:46:21 2017 +0200

    Merge branches 'acpi-spcr', 'acpi-osi', 'acpi-bus', 'acpi-scan' and 'acpi-misc'
    
    * acpi-spcr:
      ACPI: SPCR: Workaround for APM X-Gene 8250 UART 32-alignment errata
      ACPI: SPCR: Use access width to determine mmio usage
    
    * acpi-osi:
      ACPI / osi: Make local function acpi_osi_dmi_linux() static
    
    * acpi-bus:
      ACPI / bus: handle ACPI hotplug schedule errors completely
    
    * acpi-scan:
      ACPI / scan: Indicate to platform when hot remove returns busy
    
    * acpi-misc:
      ACPI / DPTF: constify attribute_group structures
      ACPI / LPSS: constify attribute_group structures
      ACPI: BGRT: constify attribute_group structures
      ACPI / power: constify attribute_group structures

commit d429e5c12269a930b81d8b57b788bbe3cf12e815
Author: Lee, Chun-Yi <joeyli.kernel@gmail.com>
Date:   Mon Jul 3 21:26:10 2017 +0800

    ACPI / scan: Indicate to platform when hot remove returns busy
    
    In hotplug logic, it always indicates non-specific failure to
    platform through _OST when handing ACPI hot-remove event failed. Then
    platform terminates the hot-remove process but it can not identify
    the reason.
    
    Base on current hot-remove code, there have two situations that it
    returns busy:
    
     - OSPM try to offline an individual device, but the device offline
       function returns "busy".
    
     - When the ejection event is applied to an "not offlined yet"
       container.  OSPM sends a kobject change event to userspace and
       returns "busy".
    
    Both of them will returns -EBUSY to ACPI device hotplug function.
    Then, the hotplug function indicates non-specific failure to platform
    just like for any other error, e.g. -ENODEV or -EIO.
    
    The benefit to the platform for identifying the OS "busy" state is
    that it can use a different approach to handle the "busy" instead of
    simply terminating the hot-remove operation for an unknown reason.
    For example, the platform can wait for a while and then re-trigger
    hot-remove.
    
    Signed-off-by: "Lee, Chun-Yi" <jlee@suse.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    [ rjw: Changelog massage ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d53162997f32..ce8817503262 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -404,10 +404,6 @@ void acpi_device_hotplug(struct acpi_device *adev, u32 src)
 		error = dock_notify(adev, src);
 	} else if (adev->flags.hotplug_notify) {
 		error = acpi_generic_hotplug_event(adev, src);
-		if (error == -EPERM) {
-			ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
-			goto err_out;
-		}
 	} else {
 		int (*notify)(struct acpi_device *, u32);
 
@@ -423,8 +419,20 @@ void acpi_device_hotplug(struct acpi_device *adev, u32 src)
 		else
 			goto out;
 	}
-	if (!error)
+	switch (error) {
+	case 0:
 		ost_code = ACPI_OST_SC_SUCCESS;
+		break;
+	case -EPERM:
+		ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
+		break;
+	case -EBUSY:
+		ost_code = ACPI_OST_SC_DEVICE_BUSY;
+		break;
+	default:
+		ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
+		break;
+	}
 
  err_out:
 	acpi_evaluate_ost(adev->handle, src, ost_code, NULL);

commit 8f8e5c3e2796eaf150d6262115af12707c2616dd
Merge: 9a5f2c871af4 de3ef1eb1cd0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 3 14:23:09 2017 +0200

    Merge branch 'acpi-pm'
    
    * acpi-pm:
      PM / core: Drop run_wake flag from struct dev_pm_info
      PCI / PM: Simplify device wakeup settings code
      PCI / PM: Drop pme_interrupt flag from struct pci_dev
      ACPI / PM: Consolidate device wakeup settings code
      ACPI / PM: Drop run_wake from struct acpi_device_wakeup_flags
      ACPI / sleep: EC-based wakeup from suspend-to-idle on recent systems
      platform: x86: intel-hid: Wake up the system from suspend-to-idle
      platform: x86: intel-vbtn: Wake up the system from suspend-to-idle
      ACPI / PM: Ignore spurious SCI wakeups from suspend-to-idle
      platform/x86: Add driver for ACPI INT0002 Virtual GPIO device
      PCI / PM: Restore PME Enable if skipping wakeup setup
      PM / sleep: Print timing information if debug is enabled
      ACPI / PM: Clean up device wakeup enable/disable code
      ACPI / PM: Change log level of wakeup-related message
      USB / PCI / PM: Allow the PCI core to do the resume cleanup
      ACPI / PM: Run wakeup notify handlers synchronously
    
    Conflicts:
            drivers/base/power/main.c

commit a1a66393e39a97433bcc1737133ba7478993d247
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 24 01:53:14 2017 +0200

    ACPI / PM: Drop run_wake from struct acpi_device_wakeup_flags
    
    The run_wake flag in struct acpi_device_wakeup_flags stores the
    information on whether or not the device can generate wakeup
    signals at run time, but in ACPI that really is equivalent to
    being able to generate wakeup signals at all.
    
    In fact, run_wake will always be set after successful executeion of
    acpi_setup_gpe_for_wake(), but if that fails, the device will not be
    able to use a wakeup GPE at all, so it won't be able to wake up the
    systems from sleep states too.  Hence, run_wake actually means that
    the device is capable of triggering wakeup and so it is equivalent
    to the valid flag.
    
    For this reason, drop run_wake from struct acpi_device_wakeup_flags
    and make sure that the valid flag is only set if
    acpi_setup_gpe_for_wake() has been successful.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 3a10d7573477..49849667cd3f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -835,7 +835,7 @@ static int acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 	return err;
 }
 
-static void acpi_wakeup_gpe_init(struct acpi_device *device)
+static bool acpi_wakeup_gpe_init(struct acpi_device *device)
 {
 	static const struct acpi_device_id button_device_ids[] = {
 		{"PNP0C0C", 0},
@@ -845,13 +845,11 @@ static void acpi_wakeup_gpe_init(struct acpi_device *device)
 	};
 	struct acpi_device_wakeup *wakeup = &device->wakeup;
 	acpi_status status;
-	acpi_event_status event_status;
 
 	wakeup->flags.notifier_present = 0;
 
 	/* Power button, Lid switch always enable wakeup */
 	if (!acpi_match_device_ids(device, button_device_ids)) {
-		wakeup->flags.run_wake = 1;
 		if (!acpi_match_device_ids(device, &button_device_ids[1])) {
 			/* Do not use Lid/sleep button for S5 wakeup */
 			if (wakeup->sleep_state == ACPI_STATE_S5)
@@ -859,17 +857,12 @@ static void acpi_wakeup_gpe_init(struct acpi_device *device)
 		}
 		acpi_mark_gpe_for_wake(wakeup->gpe_device, wakeup->gpe_number);
 		device_set_wakeup_capable(&device->dev, true);
-		return;
+		return true;
 	}
 
-	acpi_setup_gpe_for_wake(device->handle, wakeup->gpe_device,
-				wakeup->gpe_number);
-	status = acpi_get_gpe_status(wakeup->gpe_device, wakeup->gpe_number,
-				     &event_status);
-	if (ACPI_FAILURE(status))
-		return;
-
-	wakeup->flags.run_wake = !!(event_status & ACPI_EVENT_FLAG_HAS_HANDLER);
+	status = acpi_setup_gpe_for_wake(device->handle, wakeup->gpe_device,
+					 wakeup->gpe_number);
+	return ACPI_SUCCESS(status);
 }
 
 static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
@@ -887,10 +880,10 @@ static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 		return;
 	}
 
-	device->wakeup.flags.valid = 1;
+	device->wakeup.flags.valid = acpi_wakeup_gpe_init(device);
 	device->wakeup.prepare_count = 0;
-	acpi_wakeup_gpe_init(device);
-	/* Call _PSW/_DSW object to disable its ability to wake the sleeping
+	/*
+	 * Call _PSW/_DSW object to disable its ability to wake the sleeping
 	 * system for the ACPI device with the _PRW object.
 	 * The _PSW object is depreciated in ACPI 3.0 and is replaced by _DSW.
 	 * So it is necessary to call _DSW object first. Only when it is not

commit 3708184afc77bb67709a67a35d9f367ebd32cbc4
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Jun 6 12:37:37 2017 +0300

    device property: Move FW type specific functionality to FW specific files
    
    The device and fwnode property API supports Devicetree, ACPI and pset
    properties. The implementation of this functionality for each firmware
    type was embedded in the fwnode property core. Move it out to firmware
    type specific locations, making it easier to maintain.
    
    Depends-on: ("of: Move OF property and graph API from base.c to property.c")
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c98f88b28948..bc2a525c495f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1436,6 +1436,7 @@ void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 	device->handle = handle;
 	device->parent = acpi_bus_get_parent(handle);
 	device->fwnode.type = FWNODE_ACPI;
+	device->fwnode.ops = &acpi_fwnode_ops;
 	acpi_set_device_status(device, sta);
 	acpi_device_get_busid(device);
 	acpi_set_pnp_ids(handle, &device->pnp, type);

commit cde1f95f407a593ad6baf1b7b01daa2c6cbd34fd
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Jun 6 12:37:36 2017 +0300

    ACPI: Constify argument to acpi_device_is_present()
    
    This will be needed in constifying the fwnode API.
    
    The side effects the function had have been moved to the callers.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 3a10d7573477..c98f88b28948 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1567,13 +1567,9 @@ static int acpi_bus_type_and_status(acpi_handle handle, int *type,
 	return 0;
 }
 
-bool acpi_device_is_present(struct acpi_device *adev)
+bool acpi_device_is_present(const struct acpi_device *adev)
 {
-	if (adev->status.present || adev->status.functional)
-		return true;
-
-	adev->flags.initialized = false;
-	return false;
+	return adev->status.present || adev->status.functional;
 }
 
 static bool acpi_scan_handler_matching(struct acpi_scan_handler *handler,
@@ -1831,6 +1827,7 @@ static void acpi_bus_attach(struct acpi_device *device)
 	acpi_bus_get_status(device);
 	/* Skip devices that are not present. */
 	if (!acpi_device_is_present(device)) {
+		device->flags.initialized = false;
 		acpi_device_clear_enumerated(device);
 		device->flags.power_manageable = 0;
 		return;

commit e4330d8bf669139a983255d1801733b64c2ae841
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Mon Jun 19 15:53:01 2017 +0300

    ACPI / scan: Fix enumeration for special SPI and I2C devices
    
    Commit f406270bf73d ("ACPI / scan: Set the visited flag for all
    enumerated devices") caused that two group of special SPI or I2C
    devices do not enumerate. SPI and I2C devices are expected to be
    enumerated by the SPI and I2C subsystems but change caused that
    acpi_bus_attach() marks those devices with acpi_device_set_enumerated().
    
    First group of devices are matched using Device Tree compatible property
    with special _HID "PRP0001". Those devices have matched scan handler,
    acpi_scan_attach_handler() retuns 1 and acpi_bus_attach() marks them
    with acpi_device_set_enumerated().
    
    Second group of devices without valid _HID such as "LNXVIDEO" have
    device->pnp.type.platform_id set to zero and change again marks them
    with acpi_device_set_enumerated().
    
    Fix this by flagging the SPI and I2C devices during struct acpi_device
    object initialization time and let the code in acpi_bus_attach() to go
    through the device_attach() and acpi_default_enumeration() path for all
    SPI and I2C devices.
    
    Fixes: f406270bf73d (ACPI / scan: Set the visited flag for all enumerated devices)
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: 4.11+ <stable@vger.kernel.org> # 4.11+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 3a10d7573477..d53162997f32 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1428,6 +1428,37 @@ static void acpi_init_coherency(struct acpi_device *adev)
 	adev->flags.coherent_dma = cca;
 }
 
+static int acpi_check_spi_i2c_slave(struct acpi_resource *ares, void *data)
+{
+	bool *is_spi_i2c_slave_p = data;
+
+	if (ares->type != ACPI_RESOURCE_TYPE_SERIAL_BUS)
+		return 1;
+
+	/*
+	 * devices that are connected to UART still need to be enumerated to
+	 * platform bus
+	 */
+	if (ares->data.common_serial_bus.type != ACPI_RESOURCE_SERIAL_TYPE_UART)
+		*is_spi_i2c_slave_p = true;
+
+	 /* no need to do more checking */
+	return -1;
+}
+
+static bool acpi_is_spi_i2c_slave(struct acpi_device *device)
+{
+	struct list_head resource_list;
+	bool is_spi_i2c_slave = false;
+
+	INIT_LIST_HEAD(&resource_list);
+	acpi_dev_get_resources(device, &resource_list, acpi_check_spi_i2c_slave,
+			       &is_spi_i2c_slave);
+	acpi_dev_free_resource_list(&resource_list);
+
+	return is_spi_i2c_slave;
+}
+
 void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 			     int type, unsigned long long sta)
 {
@@ -1443,6 +1474,7 @@ void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 	acpi_bus_get_flags(device);
 	device->flags.match_driver = false;
 	device->flags.initialized = true;
+	device->flags.spi_i2c_slave = acpi_is_spi_i2c_slave(device);
 	acpi_device_clear_enumerated(device);
 	device_initialize(&device->dev);
 	dev_set_uevent_suppress(&device->dev, true);
@@ -1727,38 +1759,13 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 	return AE_OK;
 }
 
-static int acpi_check_spi_i2c_slave(struct acpi_resource *ares, void *data)
-{
-	bool *is_spi_i2c_slave_p = data;
-
-	if (ares->type != ACPI_RESOURCE_TYPE_SERIAL_BUS)
-		return 1;
-
-	/*
-	 * devices that are connected to UART still need to be enumerated to
-	 * platform bus
-	 */
-	if (ares->data.common_serial_bus.type != ACPI_RESOURCE_SERIAL_TYPE_UART)
-		*is_spi_i2c_slave_p = true;
-
-	 /* no need to do more checking */
-	return -1;
-}
-
 static void acpi_default_enumeration(struct acpi_device *device)
 {
-	struct list_head resource_list;
-	bool is_spi_i2c_slave = false;
-
 	/*
 	 * Do not enumerate SPI/I2C slaves as they will be enumerated by their
 	 * respective parents.
 	 */
-	INIT_LIST_HEAD(&resource_list);
-	acpi_dev_get_resources(device, &resource_list, acpi_check_spi_i2c_slave,
-			       &is_spi_i2c_slave);
-	acpi_dev_free_resource_list(&resource_list);
-	if (!is_spi_i2c_slave) {
+	if (!device->flags.spi_i2c_slave) {
 		acpi_create_platform_device(device, NULL);
 		acpi_device_set_enumerated(device);
 	} else {
@@ -1854,7 +1861,7 @@ static void acpi_bus_attach(struct acpi_device *device)
 		return;
 
 	device->flags.match_driver = true;
-	if (ret > 0) {
+	if (ret > 0 && !device->flags.spi_i2c_slave) {
 		acpi_device_set_enumerated(device);
 		goto ok;
 	}
@@ -1863,10 +1870,10 @@ static void acpi_bus_attach(struct acpi_device *device)
 	if (ret < 0)
 		return;
 
-	if (device->pnp.type.platform_id)
-		acpi_default_enumeration(device);
-	else
+	if (!device->pnp.type.platform_id && !device->flags.spi_i2c_slave)
 		acpi_device_set_enumerated(device);
+	else
+		acpi_default_enumeration(device);
 
  ok:
 	list_for_each_entry(child, &device->children, node)

commit 058f8c3fb44d028ba44c2e3635d8bee9787018d6
Author: Sricharan R <sricharan@codeaurora.org>
Date:   Sat May 27 19:17:42 2017 +0530

    ACPI/IORT: Ignore all errors except EPROBE_DEFER
    
    While deferring the probe of IOMMU masters, xlate and
    add_device callbacks called from iort_iommu_configure
    can pass back error values like -ENODEV, which means
    the IOMMU cannot be connected with that master for real
    reasons. Before the IOMMU probe deferral, all such errors
    were ignored. Now all those errors are propagated back,
    killing the master's probe for such errors. Instead ignore
    all the errors except EPROBE_DEFER, which is the only one
    of concern and let the master work without IOMMU, thus
    restoring the old behavior. Also make explicit that
    acpi_dma_configure handles only -EPROBE_DEFER from
    iort_iommu_configure.
    
    Fixes: 5a1bb638d567 ("drivers: acpi: Handle IOMMU lookup failure with deferred probing or error")
    Signed-off-by: Sricharan R <sricharan@codeaurora.org>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e39ec7b7cb67..3a10d7573477 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1371,8 +1371,8 @@ int acpi_dma_configure(struct device *dev, enum dev_dma_attr attr)
 	iort_set_dma_mask(dev);
 
 	iommu = iort_iommu_configure(dev);
-	if (IS_ERR(iommu))
-		return PTR_ERR(iommu);
+	if (IS_ERR(iommu) && PTR_ERR(iommu) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
 
 	size = max(dev->coherent_dma_mask, dev->coherent_dma_mask + 1);
 	/*

commit 28b47809b2171a6cfbab839936b24280639c9f85
Merge: 4a1e31c68e9f 2c0248d68880
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 9 15:15:47 2017 -0700

    Merge tag 'iommu-updates-v4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu
    
    Pull IOMMU updates from Joerg Roedel:
    
     - code optimizations for the Intel VT-d driver
    
     - ability to switch off a previously enabled Intel IOMMU
    
     - support for 'struct iommu_device' for OMAP, Rockchip and Mediatek
       IOMMUs
    
     - header optimizations for IOMMU core code headers and a few fixes that
       became necessary in other parts of the kernel because of that
    
     - ACPI/IORT updates and fixes
    
     - Exynos IOMMU optimizations
    
     - updates for the IOMMU dma-api code to bring it closer to use per-cpu
       iova caches
    
     - new command-line option to set default domain type allocated by the
       iommu core code
    
     - another command line option to allow the Intel IOMMU switched off in
       a tboot environment
    
     - ARM/SMMU: TLB sync optimisations for SMMUv2, Support for using an
       IDENTITY domain in conjunction with DMA ops, Support for SMR masking,
       Support for 16-bit ASIDs (was previously broken)
    
     - various other small fixes and improvements
    
    * tag 'iommu-updates-v4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu: (63 commits)
      soc/qbman: Move dma-mapping.h include to qman_priv.h
      soc/qbman: Fix implicit header dependency now causing build fails
      iommu: Remove trace-events include from iommu.h
      iommu: Remove pci.h include from trace/events/iommu.h
      arm: dma-mapping: Don't override dma_ops in arch_setup_dma_ops()
      ACPI/IORT: Fix CONFIG_IOMMU_API dependency
      iommu/vt-d: Don't print the failure message when booting non-kdump kernel
      iommu: Move report_iommu_fault() to iommu.c
      iommu: Include device.h in iommu.h
      x86, iommu/vt-d: Add an option to disable Intel IOMMU force on
      iommu/arm-smmu: Return IOVA in iova_to_phys when SMMU is bypassed
      iommu/arm-smmu: Correct sid to mask
      iommu/amd: Fix incorrect error handling in amd_iommu_bind_pasid()
      iommu: Make iommu_bus_notifier return NOTIFY_DONE rather than error code
      omap3isp: Remove iommu_group related code
      iommu/omap: Add iommu-group support
      iommu/omap: Make use of 'struct iommu_device'
      iommu/omap: Store iommu_dev pointer in arch_data
      iommu/omap: Move data structures to omap-iommu.h
      iommu/omap: Drop legacy-style device support
      ...

commit 2c0248d68880fc0e783af1048b3367ee5d4412f0
Merge: d5bf739dc762 fd8e2d4b3932 c9d9f2394c6a 6f66ea099fc2 bdf95923086f 26b37b946a5c 8e1218840066 73dbd4a42302 290d638e04e7
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu May 4 18:06:17 2017 +0200

    Merge branches 'arm/exynos', 'arm/omap', 'arm/rockchip', 'arm/mediatek', 'arm/smmu', 'arm/core', 'x86/vt-d', 'x86/amd' and 'core' into next

commit 5a1bb638d5677053c7addcb228b56da6fccb5d68
Author: Sricharan R <sricharan@codeaurora.org>
Date:   Mon Apr 10 16:51:03 2017 +0530

    drivers: acpi: Handle IOMMU lookup failure with deferred probing or error
    
    This is an equivalent to the DT's handling of the iommu master's probe
    with deferred probing when the corrsponding iommu is not probed yet.
    The lack of a registered IOMMU can be caused by the lack of a driver for
    the IOMMU, the IOMMU device probe not having been performed yet, having
    been deferred, or having failed.
    
    The first case occurs when the firmware describes the bus master and
    IOMMU topology correctly but no device driver exists for the IOMMU yet
    or the device driver has not been compiled in. Return NULL, the caller
    will configure the device without an IOMMU.
    
    The second and third cases are handled by deferring the probe of the bus
    master device which will eventually get reprobed after the IOMMU.
    
    The last case is currently handled by deferring the probe of the bus
    master device as well. A mechanism to either configure the bus master
    device without an IOMMU or to fail the bus master device probe depending
    on whether the IOMMU is optional or mandatory would be a good
    enhancement.
    
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    [Lorenzo: Added fixes for dma_coherent_mask overflow, acpi_dma_configure
              called multiple times for same device]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Sricharan R <sricharan@codeaurora.org>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 192691880d55..2a513cce332e 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1373,20 +1373,25 @@ enum dev_dma_attr acpi_get_dma_attr(struct acpi_device *adev)
  * @dev: The pointer to the device
  * @attr: device dma attributes
  */
-void acpi_dma_configure(struct device *dev, enum dev_dma_attr attr)
+int acpi_dma_configure(struct device *dev, enum dev_dma_attr attr)
 {
 	const struct iommu_ops *iommu;
+	u64 size;
 
 	iort_set_dma_mask(dev);
 
 	iommu = iort_iommu_configure(dev);
+	if (IS_ERR(iommu))
+		return PTR_ERR(iommu);
 
+	size = max(dev->coherent_dma_mask, dev->coherent_dma_mask + 1);
 	/*
 	 * Assume dma valid range starts at 0 and covers the whole
 	 * coherent_dma_mask.
 	 */
-	arch_setup_dma_ops(dev, 0, dev->coherent_dma_mask + 1, iommu,
-			   attr == DEV_DMA_COHERENT);
+	arch_setup_dma_ops(dev, 0, size, iommu, attr == DEV_DMA_COHERENT);
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(acpi_dma_configure);
 

commit c381fc3a1bbfc9d780048a0b94afd162e4c3815b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Apr 17 01:20:48 2017 +0200

    ACPI / scan: Avoid enumerating devices more than once
    
    acpi_bus_attach() does not check the visited flag for devices that
    have been enumerated already and some of them may be enumerated
    for multiple times as a result, because some callers of
    acpi_bus_scan() don't check the visited flag either.
    
    For this reason, modify acpi_bus_attach() to check the visited flag
    and avoid enumerating devices that have already been enumerated.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Joey Lee <jlee@suse.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f74bc0d28692..c26931067415 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1840,6 +1840,8 @@ static void acpi_bus_attach(struct acpi_device *device)
 			device->flags.power_manageable = 0;
 
 		device->flags.initialized = true;
+	} else if (device->flags.visited) {
+		goto ok;
 	}
 
 	ret = acpi_scan_attach_handler(device);

commit f5beabfe61794d9a9d9549d387cda2bffd81e504
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Apr 17 01:19:50 2017 +0200

    ACPI / scan: Apply default enumeration to devices with ACPI drivers
    
    The current code in acpi_bus_attach() is inconsistent with respect
    to device objects with ACPI drivers bound to them, as it allows
    ACPI drivers to bind to device objects with existing "physical"
    device companions, but it doesn't allow "physical" device objects
    to be created for ACPI device objects with ACPI drivers bound to
    them.  Thus, in some cases, the outcome depends on the ordering
    of events which is confusing at best.
    
    For this reason, modify acpi_bus_attach() to call
    acpi_default_enumeration() for device objects with the
    pnp.type.platform_id flag set regardless of whether or not
    any ACPI drivers are bound to them.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Joey Lee <jlee@suse.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index acfa6c0831f2..f74bc0d28692 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1856,10 +1856,10 @@ static void acpi_bus_attach(struct acpi_device *device)
 	if (ret < 0)
 		return;
 
-	if (ret > 0 || !device->pnp.type.platform_id)
-		acpi_device_set_enumerated(device);
-	else
+	if (device->pnp.type.platform_id)
 		acpi_default_enumeration(device);
+	else
+		acpi_device_set_enumerated(device);
 
  ok:
 	list_for_each_entry(child, &device->children, node)

commit 27d6b97786ffd42be235553156c9bd4f075922aa
Merge: f406270bf73d ffc10d82ff5d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 15 00:22:00 2017 +0200

    Merge back ACPI namespace scan code changes for v4.12.

commit f406270bf73d71ea7b35ee3f7a08a44f6594c9b1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Apr 11 00:23:42 2017 +0200

    ACPI / scan: Set the visited flag for all enumerated devices
    
    Commit 10c7e20b2ff3 (ACPI / scan: fix enumeration (visited) flags for
    bus rescans) attempted to fix a problem with ACPI-based enumerateion
    of I2C/SPI devices, but it forgot to ensure that the visited flag
    will be set for all of the other enumerated devices, so fix that.
    
    Fixes: 10c7e20b2ff3 (ACPI / scan: fix enumeration (visited) flags for bus rescans)
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=194885
    Reported-and-tested-by: Kevin Locke <kevin@kevinlocke.name>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: 4.8+ <stable@vger.kernel.org> # 4.8+

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 192691880d55..2433569b02ef 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1857,15 +1857,20 @@ static void acpi_bus_attach(struct acpi_device *device)
 		return;
 
 	device->flags.match_driver = true;
-	if (!ret) {
-		ret = device_attach(&device->dev);
-		if (ret < 0)
-			return;
-
-		if (!ret && device->pnp.type.platform_id)
-			acpi_default_enumeration(device);
+	if (ret > 0) {
+		acpi_device_set_enumerated(device);
+		goto ok;
 	}
 
+	ret = device_attach(&device->dev);
+	if (ret < 0)
+		return;
+
+	if (ret > 0 || !device->pnp.type.platform_id)
+		acpi_device_set_enumerated(device);
+	else
+		acpi_default_enumeration(device);
+
  ok:
 	list_for_each_entry(child, &device->children, node)
 		acpi_bus_attach(child);

commit ffc10d82ff5df7087a9b737de55a69ac4f89bf56
Author: Michal Hocko <mhocko@suse.com>
Date:   Mon Apr 3 09:40:23 2017 +0200

    ACPI / scan: Drop support for force_remove
    
    /sys/firmware/acpi/hotplug/force_remove was presumably added to support
    auto offlining in the past. This is, however, inherently dangerous for
    some hotplugable resources like memory. The memory offlining fails when
    the memory is still in use and cannot be dropped or migrated. If we
    ignore the failure we are basically allowing for subtle memory
    corruption or a crash.
    
    We have actually noticed the later while hitting BUG() during the memory
    hotremove (remove_memory):
            ret = walk_memory_range(PFN_DOWN(start), PFN_UP(start + size - 1), NULL,
                            check_memblock_offlined_cb);
            if (ret)
                    BUG();
    
    it took us quite non-trivial time realize that the customer had
    force_remove enabled. Even if the BUG was removed here and we could
    propagate the error up the call chain it wouldn't help at all because
    then we would hit a crash or a memory corruption later and harder to
    debug. So force_remove is unfixable for the memory hotremove. We haven't
    checked other hotplugable resources to be prone to a similar problems.
    
    Remove the force_remove functionality because it is not fixable currently.
    Keep the sysfs file and report an error if somebody tries to enable it.
    Encourage users to report about the missing functionality and work with
    them with an alternative solution.
    
    Reviewed-by: Lee, Chun-Yi <jlee@suse.com>
    Signed-off-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 192691880d55..e2080b6e54aa 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -30,12 +30,6 @@ extern struct acpi_device *acpi_root;
 
 #define INVALID_ACPI_HANDLE	((acpi_handle)empty_zero_page)
 
-/*
- * If set, devices will be hot-removed even if they cannot be put offline
- * gracefully (from the kernel's standpoint).
- */
-bool acpi_force_hot_remove;
-
 static const char *dummy_hid = "device";
 
 static LIST_HEAD(acpi_dep_list);
@@ -170,9 +164,6 @@ static acpi_status acpi_bus_offline(acpi_handle handle, u32 lvl, void *data,
 			pn->put_online = false;
 		}
 		ret = device_offline(pn->dev);
-		if (acpi_force_hot_remove)
-			continue;
-
 		if (ret >= 0) {
 			pn->put_online = !ret;
 		} else {
@@ -241,11 +232,11 @@ static int acpi_scan_try_to_offline(struct acpi_device *device)
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
 				    NULL, acpi_bus_offline, (void *)true,
 				    (void **)&errdev);
-		if (!errdev || acpi_force_hot_remove)
+		if (!errdev)
 			acpi_bus_offline(handle, 0, (void *)true,
 					 (void **)&errdev);
 
-		if (errdev && !acpi_force_hot_remove) {
+		if (errdev) {
 			dev_warn(errdev, "Offline failed.\n");
 			acpi_bus_online(handle, 0, NULL, NULL);
 			acpi_walk_namespace(ACPI_TYPE_ANY, handle,
@@ -263,8 +254,7 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	unsigned long long sta;
 	acpi_status status;
 
-	if (device->handler && device->handler->hotplug.demand_offline
-	    && !acpi_force_hot_remove) {
+	if (device->handler && device->handler->hotplug.demand_offline) {
 		if (!acpi_scan_is_offline(device, true))
 			return -EBUSY;
 	} else {

commit 9c4aa1eecb48cfac18ed5e3aca9d9ae58fbafc11
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Dec 16 12:07:57 2016 +0800

    ACPI / sysfs: Provide quirk mechanism to prevent GPE flooding
    
    Sometimes, the users may require a quirk to be provided from ACPI subsystem
    core to prevent a GPE from flooding.
    Normally, if a GPE cannot be dispatched, ACPICA core automatically prevents
    the GPE from firing. But there are cases the GPE is dispatched by _Lxx/_Exx
    provided via AML table, and OSPM is lacking of the knowledge to get
    _Lxx/_Exx correctly executed to handle the GPE, thus the GPE flooding may
    still occur.
    
    The existing quirk mechanism can be enabled/disabled using the following
    commands to prevent such kind of GPE flooding during runtime:
     # echo mask > /sys/firmware/acpi/interrupts/gpe00
     # echo unmask > /sys/firmware/acpi/interrupts/gpe00
    To avoid GPE flooding during boot, we need a boot stage mechanism.
    
    This patch provides such a boot stage quirk mechanism to stop this kind of
    GPE flooding. This patch doesn't fix any feature gap but since the new
    feature gaps could be found in the future endlessly, and can disappear if
    the feature gaps are filled, providing a boot parameter rather than a DMI
    table should suffice.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=53071
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=117481
    Link: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/887793
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 45dec874ea55..192691880d55 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2074,6 +2074,7 @@ int __init acpi_scan_init(void)
 		}
 	}
 
+	acpi_gpe_apply_masked_gpes();
 	acpi_update_all_gpes();
 	acpi_ec_ecdt_start();
 

commit 9be962d5258ebb5a0f1edd3ede26bfd847c4ebe6
Merge: 85ba70b6ceff c8e008e2a6f9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 22 10:19:32 2016 -0800

    Merge tag 'acpi-extra-4.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more ACPI updates from Rafael Wysocki:
     "Here are new versions of two ACPICA changes that were deferred
      previously due to a problem they had introduced, two cleanups on top
      of them and the removal of a useless warning message from the ACPI
      core.
    
      Specifics:
    
       - Move some Linux-specific functionality to upstream ACPICA and
         update the in-kernel users of it accordingly (Lv Zheng)
    
       - Drop a useless warning (triggered by the lack of an optional
         object) from the ACPI namespace scanning code (Zhang Rui)"
    
    * tag 'acpi-extra-4.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      ACPI / osl: Remove deprecated acpi_get_table_with_size()/early_acpi_os_unmap_memory()
      ACPI / osl: Remove acpi_get_table_with_size()/early_acpi_os_unmap_memory() users
      ACPICA: Tables: Allow FADT to be customized with virtual address
      ACPICA: Tables: Back port acpi_get_table_with_size() and early_acpi_os_unmap_memory() from Linux kernel
      ACPI: do not warn if _BQC does not exist

commit 18b709beb503bfc9a96a2e4b93d3cae4f5b17df0
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Tue Dec 6 14:20:11 2016 +0000

    ACPI/IORT: Make dma masks set-up IORT specific
    
    The introduction of acpi_dma_configure() allows to configure DMA
    and related IOMMU for any device that is DMA capable. To achieve
    that goal it ensures DMA masks are set-up to sane default values
    before proceeding with IOMMU and DMA ops configuration.
    
    On x86/ia64 systems, through acpi_bind_one(), acpi_dma_configure() is
    called for every device that has an ACPI companion, in that every device
    is considered DMA capable on x86/ia64 systems (ie acpi_get_dma_attr() API),
    which has the side effect of initializing dma masks also for
    pseudo-devices (eg CPUs and memory nodes) and potentially for devices
    whose dma masks were not set-up before the acpi_dma_configure() API was
    introduced, which may have noxious side effects.
    
    Therefore, in preparation for IORT firmware specific DMA masks set-up,
    wrap the default DMA masks set-up in acpi_dma_configure() inside an IORT
    specific wrapper that reverts to a NOP on x86/ia64 systems, restoring the
    default expected behaviour on x86/ia64 systems and keeping DMA default
    masks set-up on IORT based (ie ARM) arch configurations.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: Tomasz Nowicki <tn@semihalf.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Sricharan R <sricharan@codeaurora.org>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 80698d3c5feb..93b00cf4eb39 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1380,19 +1380,7 @@ void acpi_dma_configure(struct device *dev, enum dev_dma_attr attr)
 {
 	const struct iommu_ops *iommu;
 
-	/*
-	 * Set default coherent_dma_mask to 32 bit.  Drivers are expected to
-	 * setup the correct supported mask.
-	 */
-	if (!dev->coherent_dma_mask)
-		dev->coherent_dma_mask = DMA_BIT_MASK(32);
-
-	/*
-	 * Set it to coherent_dma_mask by default if the architecture
-	 * code has not set it.
-	 */
-	if (!dev->dma_mask)
-		dev->dma_mask = &dev->coherent_dma_mask;
+	iort_set_dma_mask(dev);
 
 	iommu = iort_iommu_configure(dev);
 

commit 7020bcb82838006e23d058ff07b063b393ed3f10
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Nov 29 23:19:46 2016 +0100

    ACPI: do not warn if _BQC does not exist
    
    Starting from ACPI spec 3.0, it's only clarified that _BCM control
    method is required if _BCL is implemented. There is no word
    saying _BQC is required.
    
    And in ACPI spec 6.1 B.5.4, for _BQC, it is explicitly stated that
    "This optional method returns the current brightness level of a
    built-in display output device. If present, it must be set by
    the platform for initial brightness."
    
    Thus remove the obsolete warning message.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 3d1856f1f4d0..07aa2e649eb1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1119,9 +1119,6 @@ acpi_backlight_cap_match(acpi_handle handle, u32 level, void *context,
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found generic backlight "
 				  "support\n"));
 		*cap |= ACPI_VIDEO_BACKLIGHT;
-		if (!acpi_has_method(handle, "_BQC"))
-			printk(KERN_WARNING FW_BUG PREFIX "No _BQC method, "
-				"cannot determine initial brightness\n");
 		/* We have backlight support, no need to scan further */
 		return AE_CTRL_TERMINATE;
 	}

commit 643b8e4d86f8b1a62cf5cd9ea221e9bc0d531d18
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Nov 21 10:01:48 2016 +0000

    ACPI/IORT: Introduce iort_iommu_configure
    
    DT based systems have a generic kernel API to configure IOMMUs
    for devices (ie of_iommu_configure()).
    
    On ARM based ACPI systems, the of_iommu_configure() equivalent can
    be implemented atop ACPI IORT kernel API, with the corresponding
    functions to map device identifiers to IOMMUs and retrieve the
    corresponding IOMMU operations necessary for DMA operations set-up.
    
    By relying on the iommu_fwspec generic kernel infrastructure,
    implement the IORT based IOMMU configuration for ARM ACPI systems
    and hook it up in the ACPI kernel layer that implements DMA
    configuration for a device.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com> [ACPI core]
    Reviewed-by: Tomasz Nowicki <tn@semihalf.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Tomasz Nowicki <tn@semihalf.com>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Tomasz Nowicki <tn@semihalf.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 45b5710a0404..80698d3c5feb 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -7,6 +7,7 @@
 #include <linux/slab.h>
 #include <linux/kernel.h>
 #include <linux/acpi.h>
+#include <linux/acpi_iort.h>
 #include <linux/signal.h>
 #include <linux/kthread.h>
 #include <linux/dmi.h>
@@ -1377,6 +1378,8 @@ enum dev_dma_attr acpi_get_dma_attr(struct acpi_device *adev)
  */
 void acpi_dma_configure(struct device *dev, enum dev_dma_attr attr)
 {
+	const struct iommu_ops *iommu;
+
 	/*
 	 * Set default coherent_dma_mask to 32 bit.  Drivers are expected to
 	 * setup the correct supported mask.
@@ -1391,11 +1394,13 @@ void acpi_dma_configure(struct device *dev, enum dev_dma_attr attr)
 	if (!dev->dma_mask)
 		dev->dma_mask = &dev->coherent_dma_mask;
 
+	iommu = iort_iommu_configure(dev);
+
 	/*
 	 * Assume dma valid range starts at 0 and covers the whole
 	 * coherent_dma_mask.
 	 */
-	arch_setup_dma_ops(dev, 0, dev->coherent_dma_mask + 1, NULL,
+	arch_setup_dma_ops(dev, 0, dev->coherent_dma_mask + 1, iommu,
 			   attr == DEV_DMA_COHERENT);
 }
 EXPORT_SYMBOL_GPL(acpi_dma_configure);

commit d760a1baf20e067d3a063aa134834ddd3d183e2f
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Nov 21 10:01:39 2016 +0000

    ACPI: Implement acpi_dma_configure
    
    On DT based systems, the of_dma_configure() API implements DMA
    configuration for a given device. On ACPI systems an API equivalent to
    of_dma_configure() is missing which implies that it is currently not
    possible to set-up DMA operations for devices through the ACPI generic
    kernel layer.
    
    This patch fills the gap by introducing acpi_dma_configure/deconfigure()
    calls that for now are just wrappers around arch_setup_dma_ops() and
    arch_teardown_dma_ops() and also updates ACPI and PCI core code to use
    the newly introduced acpi_dma_configure/acpi_dma_deconfigure functions.
    
    Since acpi_dma_configure() is used to configure DMA operations, the
    function initializes the dma/coherent_dma masks to sane default values
    if the current masks are uninitialized (also to keep the default values
    consistent with DT systems) to make sure the device has a complete
    default DMA set-up.
    
    The DMA range size passed to arch_setup_dma_ops() is sized according
    to the device coherent_dma_mask (starting at address 0x0), mirroring the
    DT probing path behaviour when a dma-ranges property is not provided
    for the device being probed; this changes the current arch_setup_dma_ops()
    call parameters in the ACPI probing case, but since arch_setup_dma_ops()
    is a NOP on all architectures but ARM/ARM64 this patch does not change
    the current kernel behaviour on them.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> [pci]
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Tomasz Nowicki <tn@semihalf.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Tomasz Nowicki <tn@semihalf.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: Tomasz Nowicki <tn@semihalf.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 3d1856f1f4d0..45b5710a0404 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1370,6 +1370,46 @@ enum dev_dma_attr acpi_get_dma_attr(struct acpi_device *adev)
 		return DEV_DMA_NON_COHERENT;
 }
 
+/**
+ * acpi_dma_configure - Set-up DMA configuration for the device.
+ * @dev: The pointer to the device
+ * @attr: device dma attributes
+ */
+void acpi_dma_configure(struct device *dev, enum dev_dma_attr attr)
+{
+	/*
+	 * Set default coherent_dma_mask to 32 bit.  Drivers are expected to
+	 * setup the correct supported mask.
+	 */
+	if (!dev->coherent_dma_mask)
+		dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+	/*
+	 * Set it to coherent_dma_mask by default if the architecture
+	 * code has not set it.
+	 */
+	if (!dev->dma_mask)
+		dev->dma_mask = &dev->coherent_dma_mask;
+
+	/*
+	 * Assume dma valid range starts at 0 and covers the whole
+	 * coherent_dma_mask.
+	 */
+	arch_setup_dma_ops(dev, 0, dev->coherent_dma_mask + 1, NULL,
+			   attr == DEV_DMA_COHERENT);
+}
+EXPORT_SYMBOL_GPL(acpi_dma_configure);
+
+/**
+ * acpi_dma_deconfigure - Tear-down DMA configuration for the device.
+ * @dev: The pointer to the device
+ */
+void acpi_dma_deconfigure(struct device *dev)
+{
+	arch_teardown_dma_ops(dev);
+}
+EXPORT_SYMBOL_GPL(acpi_dma_deconfigure);
+
 static void acpi_init_coherency(struct acpi_device *adev)
 {
 	unsigned long long cca = 0;

commit 66f5854c6894dc028fc13345838c6f82bfcfef0c
Merge: bc33b0ca11e3 1571875beecd
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 11 23:23:02 2016 +0100

    Merge branch 'device-properties'
    
    * device-properties:
      ACPI / platform: Add support for build-in properties

commit 1571875beecd5de9657f73931449bda1b1329b6f
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Thu Nov 3 16:21:26 2016 +0200

    ACPI / platform: Add support for build-in properties
    
    We have a couple of drivers, acpi_apd.c and acpi_lpss.c,
    that need to pass extra build-in properties to the devices
    they create. Previously the drivers added those properties
    to the struct device which is member of the struct
    acpi_device, but that does not work. Those properties need
    to be assigned to the struct device of the platform device
    instead in order for them to become available to the
    drivers.
    
    To fix this, this patch changes acpi_create_platform_device
    function to take struct property_entry pointer as parameter.
    
    Fixes: 20a875e2e86e (serial: 8250_dw: Add quirk for APM X-Gene SoC)
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Tested-by: Yazen Ghannam <yazen.ghannam@amd.com>
    Tested-by: Jérôme de Bretagne <jerome.debretagne@gmail.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ad9fc84a8601..3d31ae3a482d 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1734,7 +1734,7 @@ static void acpi_default_enumeration(struct acpi_device *device)
 			       &is_spi_i2c_slave);
 	acpi_dev_free_resource_list(&resource_list);
 	if (!is_spi_i2c_slave) {
-		acpi_create_platform_device(device);
+		acpi_create_platform_device(device, NULL);
 		acpi_device_set_enumerated(device);
 	} else {
 		blocking_notifier_call_chain(&acpi_reconfig_chain,

commit 0137a337d7760c265a7d126964297e41ba9a1cb3
Merge: 0d573c6a0101 cda3b9178510 97cb159fd91d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Oct 2 01:40:07 2016 +0200

    Merge branches 'acpi-wdat' and 'acpi-ec'
    
    * acpi-wdat:
      watchdog: wdat_wdt: Fix warning for using 0 as NULL
      watchdog: wdat_wdt: fix return value check in wdat_wdt_probe()
      platform/x86: intel_pmc_ipc: Do not create iTCO watchdog when WDAT table exists
      i2c: i801: Do not create iTCO watchdog when WDAT table exists
      mfd: lpc_ich: Do not create iTCO watchdog when WDAT table exists
      ACPI / watchdog: Add support for WDAT hardware watchdog
    
    * acpi-ec:
      ACPI / EC: Fix issues related to boot_ec
      ACPI / EC: Fix a gap that ECDT EC cannot handle EC events
      ACPI / EC: Fix a memory leakage issue in acpi_ec_add()
      ACPI / EC: Cleanup first_ec/boot_ec code
      ACPI / EC: Enable event freeze mode to improve event handling for suspend process
      ACPI / EC: Add PM operations to improve event handling for suspend process
      ACPI / EC: Add PM operations to improve event handling for resume process
      ACPI / EC: Fix an issue that SCI_EVT cannot be detected after event is enabled
      ACPI / EC: Add EC_FLAGS_QUERY_ENABLED to reveal a hidden logic
      ACPI / EC: Add PM operations for suspend/resume noirq stage

commit 058dfc7670086edda8d34f0dbe93c596db5d4a6b
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Sep 20 15:30:51 2016 +0300

    ACPI / watchdog: Add support for WDAT hardware watchdog
    
    Starting from Intel Skylake the iTCO watchdog timer registers were moved to
    reside in the same register space with SMBus host controller.  Not all
    needed registers are available though and we need to unhide P2SB (Primary
    to Sideband) device briefly to be able to read status of required NO_REBOOT
    bit. The i2c-i801.c SMBus driver used to handle this and creation of the
    iTCO watchdog platform device.
    
    Windows, on the other hand, does not use the iTCO watchdog hardware
    directly even if it is available. Instead it relies on ACPI Watchdog Action
    Table (WDAT) table to describe the watchdog hardware to the OS. This table
    contains necessary information about the the hardware and also set of
    actions which are executed by a driver as needed.
    
    This patch implements a new watchdog driver that takes advantage of the
    ACPI WDAT table. We split the functionality into two parts: first part
    enumerates the WDAT table and if found, populates resources and creates
    platform device for the actual driver. The second part is the driver
    itself.
    
    The reason for the split is that this way we can make the driver itself to
    be a module and loaded automatically if the WDAT table is found. Otherwise
    the module is not loaded.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e878fc799af7..3b85d87021da 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2002,6 +2002,7 @@ int __init acpi_scan_init(void)
 	acpi_pnp_init();
 	acpi_int340x_thermal_init();
 	acpi_amba_init();
+	acpi_watchdog_init();
 
 	acpi_scan_add_handler(&generic_device_handler);
 

commit 2a5708409e4e05446eb1a89ecb48641d6fd5d5a9
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Sep 7 16:50:21 2016 +0800

    ACPI / EC: Fix a gap that ECDT EC cannot handle EC events
    
    It is possible to register _Qxx from namespace and use the ECDT EC to
    perform event handling. The reported bug reveals that Windows is using ECDT
    in this way in case the namespace EC is not present. This patch facilitates
    Linux to support ECDT in this way.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=115021
    Reported-and-tested-by: Luya Tshimbalanga <luya@fedoraproject.org>
    Tested-by: Jonh Henderson <jw.hendy@gmail.com>
    Reviewed-by: Peter Wu <peter@lekensteyn.nl>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ad9fc84a8601..763c0da506bf 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2044,6 +2044,7 @@ int __init acpi_scan_init(void)
 	}
 
 	acpi_update_all_gpes();
+	acpi_ec_ecdt_start();
 
 	acpi_scan_initialized = true;
 

commit 5331d9cab32ef640b4cd38a43b0858874fbb7168
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Tue Aug 16 16:59:53 2016 +0100

    ACPI / drivers: replace acpi_probe_lock spinlock with mutex
    
    Commit e647b532275b ("ACPI: Add early device probing infrastructure")
    introduced code that allows inserting driver specific
    struct acpi_probe_entry probe entries into ACPI linker sections
    (one per-subsystem, eg irqchip, clocksource) that are then walked
    to retrieve the data and function hooks required to probe the
    respective kernel components.
    
    Probing for all entries in a section is triggered through
    the __acpi_probe_device_table() function, that in turn, according
    to the table ID a given probe entry reports parses the table
    with the function retrieved from the respective section structures
    (ie struct acpi_probe_entry). Owing to the current ACPI table
    parsing implementation, the __acpi_probe_device_table() function
    has to share global variables with the acpi_match_madt() function, so
    in order to guarantee mutual exclusion locking is required
    between the two functions.
    
    Current kernel code implements the locking through the acpi_probe_lock
    spinlock; this has the side effect of requiring all code called
    within the lock (ie struct acpi_probe_entry.probe_{table/subtbl} hooks)
    not to sleep.
    
    However, kernel subsystems that make use of the early probing
    infrastructure are relying on kernel APIs that may sleep (eg
    irq_domain_alloc_fwnode(), among others) in the function calls
    pointed at by struct acpi_probe_entry.{probe_table/subtbl} entries
    (eg gic_v2_acpi_init()), which is a bug.
    
    Since __acpi_probe_device_table() is called from context
    that is allowed to sleep the acpi_probe_lock spinlock can be replaced
    with a mutex; this fixes the issue whilst still guaranteeing
    mutual exclusion.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Fixes: e647b532275b (ACPI: Add early device probing infrastructure)
    Cc: 4.4+ <stable@vger.kernel.org> # 4.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ad9fc84a8601..e878fc799af7 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2054,7 +2054,7 @@ int __init acpi_scan_init(void)
 
 static struct acpi_probe_entry *ape;
 static int acpi_probe_count;
-static DEFINE_SPINLOCK(acpi_probe_lock);
+static DEFINE_MUTEX(acpi_probe_mutex);
 
 static int __init acpi_match_madt(struct acpi_subtable_header *header,
 				  const unsigned long end)
@@ -2073,7 +2073,7 @@ int __init __acpi_probe_device_table(struct acpi_probe_entry *ap_head, int nr)
 	if (acpi_disabled)
 		return 0;
 
-	spin_lock(&acpi_probe_lock);
+	mutex_lock(&acpi_probe_mutex);
 	for (ape = ap_head; nr; ape++, nr--) {
 		if (ACPI_COMPARE_NAME(ACPI_SIG_MADT, ape->id)) {
 			acpi_probe_count = 0;
@@ -2086,7 +2086,7 @@ int __init __acpi_probe_device_table(struct acpi_probe_entry *ap_head, int nr)
 				count++;
 		}
 	}
-	spin_unlock(&acpi_probe_lock);
+	mutex_unlock(&acpi_probe_mutex);
 
 	return count;
 }

commit 08fd8c17686c6b09fa410a26d516548dd80ff147
Merge: e831101a73fb d34c30cc1fa8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 27 11:35:37 2016 -0700

    Merge tag 'for-linus-4.8-rc0-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip
    
    Pull xen updates from David Vrabel:
     "Features and fixes for 4.8-rc0:
    
       - ACPI support for guests on ARM platforms.
       - Generic steal time support for arm and x86.
       - Support cases where kernel cpu is not Xen VCPU number (e.g., if
         in-guest kexec is used).
       - Use the system workqueue instead of a custom workqueue in various
         places"
    
    * tag 'for-linus-4.8-rc0-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip: (47 commits)
      xen: add static initialization of steal_clock op to xen_time_ops
      xen/pvhvm: run xen_vcpu_setup() for the boot CPU
      xen/evtchn: use xen_vcpu_id mapping
      xen/events: fifo: use xen_vcpu_id mapping
      xen/events: use xen_vcpu_id mapping in events_base
      x86/xen: use xen_vcpu_id mapping when pointing vcpu_info to shared_info
      x86/xen: use xen_vcpu_id mapping for HYPERVISOR_vcpu_op
      xen: introduce xen_vcpu_id mapping
      x86/acpi: store ACPI ids from MADT for future usage
      x86/xen: update cpuid.h from Xen-4.7
      xen/evtchn: add IOCTL_EVTCHN_RESTRICT
      xen-blkback: really don't leak mode property
      xen-blkback: constify instance of "struct attribute_group"
      xen-blkfront: prefer xenbus_scanf() over xenbus_gather()
      xen-blkback: prefer xenbus_scanf() over xenbus_gather()
      xen: support runqueue steal time on xen
      arm/xen: add support for vm_assist hypercall
      xen: update xen headers
      xen-pciback: drop superfluous variables
      xen-pciback: short-circuit read path used for merging write values
      ...

commit 68bdb6773289f8c9a36633f9f6525b127c093258
Author: Octavian Purdila <octavian.purdila@intel.com>
Date:   Fri Jul 8 19:13:09 2016 +0300

    ACPI: add support for ACPI reconfiguration notifiers
    
    Add support for ACPI reconfiguration notifiers to allow subsystems
    to react to changes in the ACPI tables that happen after the initial
    enumeration. This is similar with the way dynamic device tree
    notifications work.
    
    The reconfigure notifications supported for now are device add and
    device remove.
    
    Since ACPICA allows only one table notification handler, this patch
    makes the table notifier function generic and moves it out of the
    sysfs specific code.
    
    Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f80f8a747294..405056b95b05 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -494,6 +494,8 @@ static void acpi_device_del(struct acpi_device *device)
 	device_del(&device->dev);
 }
 
+static BLOCKING_NOTIFIER_HEAD(acpi_reconfig_chain);
+
 static LIST_HEAD(acpi_device_del_list);
 static DEFINE_MUTEX(acpi_device_del_lock);
 
@@ -514,6 +516,9 @@ static void acpi_device_del_work_fn(struct work_struct *work_not_used)
 
 		mutex_unlock(&acpi_device_del_lock);
 
+		blocking_notifier_call_chain(&acpi_reconfig_chain,
+					     ACPI_RECONFIG_DEVICE_REMOVE, adev);
+
 		acpi_device_del(adev);
 		/*
 		 * Drop references to all power resources that might have been
@@ -1676,7 +1681,7 @@ static void acpi_default_enumeration(struct acpi_device *device)
 	bool is_spi_i2c_slave = false;
 
 	/*
-	 * Do not enemerate SPI/I2C slaves as they will be enuerated by their
+	 * Do not enumerate SPI/I2C slaves as they will be enumerated by their
 	 * respective parents.
 	 */
 	INIT_LIST_HEAD(&resource_list);
@@ -1686,6 +1691,9 @@ static void acpi_default_enumeration(struct acpi_device *device)
 	if (!is_spi_i2c_slave) {
 		acpi_create_platform_device(device);
 		acpi_device_set_enumerated(device);
+	} else {
+		blocking_notifier_call_chain(&acpi_reconfig_chain,
+					     ACPI_RECONFIG_DEVICE_ADD, device);
 	}
 }
 
@@ -1917,6 +1925,8 @@ static int acpi_bus_scan_fixed(void)
 	return result < 0 ? result : 0;
 }
 
+static bool acpi_scan_initialized;
+
 int __init acpi_scan_init(void)
 {
 	int result;
@@ -1961,6 +1971,8 @@ int __init acpi_scan_init(void)
 
 	acpi_update_all_gpes();
 
+	acpi_scan_initialized = true;
+
  out:
 	mutex_unlock(&acpi_scan_lock);
 	return result;
@@ -2004,3 +2016,57 @@ int __init __acpi_probe_device_table(struct acpi_probe_entry *ap_head, int nr)
 
 	return count;
 }
+
+struct acpi_table_events_work {
+	struct work_struct work;
+	void *table;
+	u32 event;
+};
+
+static void acpi_table_events_fn(struct work_struct *work)
+{
+	struct acpi_table_events_work *tew;
+
+	tew = container_of(work, struct acpi_table_events_work, work);
+
+	if (tew->event == ACPI_TABLE_EVENT_LOAD) {
+		acpi_scan_lock_acquire();
+		acpi_bus_scan(ACPI_ROOT_OBJECT);
+		acpi_scan_lock_release();
+	}
+
+	kfree(tew);
+}
+
+void acpi_scan_table_handler(u32 event, void *table, void *context)
+{
+	struct acpi_table_events_work *tew;
+
+	if (!acpi_scan_initialized)
+		return;
+
+	if (event != ACPI_TABLE_EVENT_LOAD)
+		return;
+
+	tew = kmalloc(sizeof(*tew), GFP_KERNEL);
+	if (!tew)
+		return;
+
+	INIT_WORK(&tew->work, acpi_table_events_fn);
+	tew->table = table;
+	tew->event = event;
+
+	schedule_work(&tew->work);
+}
+
+int acpi_reconfig_notifier_register(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&acpi_reconfig_chain, nb);
+}
+EXPORT_SYMBOL(acpi_reconfig_notifier_register);
+
+int acpi_reconfig_notifier_unregister(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&acpi_reconfig_chain, nb);
+}
+EXPORT_SYMBOL(acpi_reconfig_notifier_unregister);

commit 10c7e20b2ff3caa5a8c0e7d60aef5a9c86e60ce8
Author: Octavian Purdila <octavian.purdila@intel.com>
Date:   Fri Jul 8 19:13:08 2016 +0300

    ACPI / scan: fix enumeration (visited) flags for bus rescans
    
    If the ACPI tables change as a result of a dinamically loaded table
    and a bus rescan is required the enumeration/visited flag are not
    consistent.
    
    I2C/SPI are not directly enumerated in acpi_bus_attach(), however
    the visited flag is set. This makes it impossible to check if an
    ACPI device has already been enumerated by the I2C and SPI
    subsystems. To fix this issue we only set the visited flags if
    the device is not I2C or SPI.
    
    With this change we also need to remove setting visited to false
    from acpi_bus_attach(), otherwise if we rescan already enumerated
    I2C/SPI devices we try to re-enumerate them.
    
    Note that I2C/SPI devices can be enumerated either via a scan handler
    (when using PRP0001) or via regular device_attach(). In either case
    the flow goes through acpi_default_enumeration() which makes it the
    ideal place to mark the ACPI device as enumerated.
    
    Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5f28cf778349..f80f8a747294 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1406,7 +1406,7 @@ void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 	acpi_bus_get_flags(device);
 	device->flags.match_driver = false;
 	device->flags.initialized = true;
-	device->flags.visited = false;
+	acpi_device_clear_enumerated(device);
 	device_initialize(&device->dev);
 	dev_set_uevent_suppress(&device->dev, true);
 	acpi_init_coherency(device);
@@ -1683,8 +1683,10 @@ static void acpi_default_enumeration(struct acpi_device *device)
 	acpi_dev_get_resources(device, &resource_list, acpi_check_spi_i2c_slave,
 			       &is_spi_i2c_slave);
 	acpi_dev_free_resource_list(&resource_list);
-	if (!is_spi_i2c_slave)
+	if (!is_spi_i2c_slave) {
 		acpi_create_platform_device(device);
+		acpi_device_set_enumerated(device);
+	}
 }
 
 static const struct acpi_device_id generic_device_ids[] = {
@@ -1751,7 +1753,7 @@ static void acpi_bus_attach(struct acpi_device *device)
 	acpi_bus_get_status(device);
 	/* Skip devices that are not present. */
 	if (!acpi_device_is_present(device)) {
-		device->flags.visited = false;
+		acpi_device_clear_enumerated(device);
 		device->flags.power_manageable = 0;
 		return;
 	}
@@ -1766,7 +1768,7 @@ static void acpi_bus_attach(struct acpi_device *device)
 
 		device->flags.initialized = true;
 	}
-	device->flags.visited = false;
+
 	ret = acpi_scan_attach_handler(device);
 	if (ret < 0)
 		return;
@@ -1780,7 +1782,6 @@ static void acpi_bus_attach(struct acpi_device *device)
 		if (!ret && device->pnp.type.platform_id)
 			acpi_default_enumeration(device);
 	}
-	device->flags.visited = true;
 
  ok:
 	list_for_each_entry(child, &device->children, node)
@@ -1872,7 +1873,7 @@ void acpi_bus_trim(struct acpi_device *adev)
 	 */
 	acpi_device_set_power(adev, ACPI_STATE_D3_COLD);
 	adev->flags.initialized = false;
-	adev->flags.visited = false;
+	acpi_device_clear_enumerated(adev);
 }
 EXPORT_SYMBOL_GPL(acpi_bus_trim);
 

commit a4e081b0dd16780d960b1ef86985de40a6729fb5
Author: Shannon Zhao <shannon.zhao@linaro.org>
Date:   Thu Apr 7 20:03:18 2016 +0800

    Xen: ACPI: Hide UART used by Xen
    
    ACPI 6.0 introduces a new table STAO to list the devices which are used
    by Xen and can't be used by Dom0. On Xen virtual platforms, the physical
    UART is used by Xen. So here it hides UART from Dom0.
    
    CC: "Rafael J. Wysocki" <rjw@rjwysocki.net> (supporter:ACPI)
    CC: Len Brown <lenb@kernel.org> (supporter:ACPI)
    CC: linux-acpi@vger.kernel.org (open list:ACPI)
    Signed-off-by: Shannon Zhao <shannon.zhao@linaro.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5f28cf778349..cfc73fecaba4 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -46,6 +46,13 @@ DEFINE_MUTEX(acpi_device_lock);
 LIST_HEAD(acpi_wakeup_device_list);
 static DEFINE_MUTEX(acpi_hp_context_lock);
 
+/*
+ * The UART device described by the SPCR table is the only object which needs
+ * special-casing. Everything else is covered by ACPI namespace paths in STAO
+ * table.
+ */
+static u64 spcr_uart_addr;
+
 struct acpi_dep_data {
 	struct list_head node;
 	acpi_handle master;
@@ -1453,6 +1460,41 @@ static int acpi_add_single_object(struct acpi_device **child,
 	return 0;
 }
 
+static acpi_status acpi_get_resource_memory(struct acpi_resource *ares,
+					    void *context)
+{
+	struct resource *res = context;
+
+	if (acpi_dev_resource_memory(ares, res))
+		return AE_CTRL_TERMINATE;
+
+	return AE_OK;
+}
+
+static bool acpi_device_should_be_hidden(acpi_handle handle)
+{
+	acpi_status status;
+	struct resource res;
+
+	/* Check if it should ignore the UART device */
+	if (!(spcr_uart_addr && acpi_has_method(handle, METHOD_NAME__CRS)))
+		return false;
+
+	/*
+	 * The UART device described in SPCR table is assumed to have only one
+	 * memory resource present. So we only look for the first one here.
+	 */
+	status = acpi_walk_resources(handle, METHOD_NAME__CRS,
+				     acpi_get_resource_memory, &res);
+	if (ACPI_FAILURE(status) || res.start != spcr_uart_addr)
+		return false;
+
+	acpi_handle_info(handle, "The UART device @%pa in SPCR table will be hidden\n",
+			 &res.start);
+
+	return true;
+}
+
 static int acpi_bus_type_and_status(acpi_handle handle, int *type,
 				    unsigned long long *sta)
 {
@@ -1466,6 +1508,9 @@ static int acpi_bus_type_and_status(acpi_handle handle, int *type,
 	switch (acpi_type) {
 	case ACPI_TYPE_ANY:		/* for ACPI_ROOT_OBJECT */
 	case ACPI_TYPE_DEVICE:
+		if (acpi_device_should_be_hidden(handle))
+			return -ENODEV;
+
 		*type = ACPI_BUS_TYPE_DEVICE;
 		status = acpi_bus_get_status_handle(handle, sta);
 		if (ACPI_FAILURE(status))
@@ -1916,9 +1961,24 @@ static int acpi_bus_scan_fixed(void)
 	return result < 0 ? result : 0;
 }
 
+static void __init acpi_get_spcr_uart_addr(void)
+{
+	acpi_status status;
+	struct acpi_table_spcr *spcr_ptr;
+
+	status = acpi_get_table(ACPI_SIG_SPCR, 0,
+				(struct acpi_table_header **)&spcr_ptr);
+	if (ACPI_SUCCESS(status))
+		spcr_uart_addr = spcr_ptr->serial_port.address;
+	else
+		printk(KERN_WARNING PREFIX "STAO table present, but SPCR is missing\n");
+}
+
 int __init acpi_scan_init(void)
 {
 	int result;
+	acpi_status status;
+	struct acpi_table_stao *stao_ptr;
 
 	acpi_pci_root_init();
 	acpi_pci_link_init();
@@ -1934,6 +1994,20 @@ int __init acpi_scan_init(void)
 
 	acpi_scan_add_handler(&generic_device_handler);
 
+	/*
+	 * If there is STAO table, check whether it needs to ignore the UART
+	 * device in SPCR table.
+	 */
+	status = acpi_get_table(ACPI_SIG_STAO, 0,
+				(struct acpi_table_header **)&stao_ptr);
+	if (ACPI_SUCCESS(status)) {
+		if (stao_ptr->header.length > sizeof(struct acpi_table_stao))
+			printk(KERN_INFO PREFIX "STAO Name List not yet supported.");
+
+		if (stao_ptr->ignore_uart)
+			acpi_get_spcr_uart_addr();
+	}
+
 	mutex_lock(&acpi_scan_lock);
 	/*
 	 * Enumerate devices in the ACPI namespace.

commit 6ce2e188a6ae339340d9bbf5bb0b81db20454353
Author: Graeme Gregory <graeme.gregory@linaro.org>
Date:   Wed Jan 20 20:29:27 2016 +0600

    ACPI / scan: AMBA bus probing support
    
    On ARM64 some devices use the AMBA device and not the platform bus for
    probing so add support for this. Uses a dummy clock for apb_pclk as ACPI
    does not have a suitable clock representation and to keep the core
    AMBA bus code unchanged between probing methods.
    
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Graeme Gregory <graeme.gregory@linaro.org>
    Signed-off-by: Aleksey Makarov <aleksey.makarov@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 407a3760e8de..5f28cf778349 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1930,6 +1930,7 @@ int __init acpi_scan_init(void)
 	acpi_memory_hotplug_init();
 	acpi_pnp_init();
 	acpi_int340x_thermal_init();
+	acpi_amba_init();
 
 	acpi_scan_add_handler(&generic_device_handler);
 

commit 2d12b6b381ba059d5f92798f5ea739672a2f5fcf
Author: Lukas Wunner <lukas@wunner.de>
Date:   Wed Nov 25 21:19:55 2015 +0100

    ACPI / utils: Add acpi_dev_present()
    
    There's an idiom in use by 7 Linux drivers to detect the presence of a
    particular ACPI HID by walking the namespace with acpi_get_devices().
    The callback passed to acpi_get_devices() is mostly identical across
    the drivers, leading to lots of duplicate code.
    
    Add acpi_dev_present(), the ACPI equivalent to pci_dev_present(),
    allowing us to deduplicate all that boilerplate in the drivers.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index be1fc12a17ee..407a3760e8de 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -39,7 +39,7 @@ static const char *dummy_hid = "device";
 
 static LIST_HEAD(acpi_dep_list);
 static DEFINE_MUTEX(acpi_dep_list_lock);
-static LIST_HEAD(acpi_bus_id_list);
+LIST_HEAD(acpi_bus_id_list);
 static DEFINE_MUTEX(acpi_scan_lock);
 static LIST_HEAD(acpi_scan_handlers_list);
 DEFINE_MUTEX(acpi_device_lock);
@@ -52,12 +52,6 @@ struct acpi_dep_data {
 	acpi_handle slave;
 };
 
-struct acpi_device_bus_id{
-	char bus_id[15];
-	unsigned int instance_no;
-	struct list_head node;
-};
-
 void acpi_scan_lock_acquire(void)
 {
 	mutex_lock(&acpi_scan_lock);

commit ca9dc8d42b30e2d766b471fe5ecf0c71fd309c8f
Author: Lukas Wunner <lukas@wunner.de>
Date:   Wed Nov 25 21:19:55 2015 +0100

    ACPI / scan: Fix acpi_bus_id_list bookkeeping
    
    acpi_device_add() allocates and adds an element to acpi_bus_id_list
    (or increments the instance count if the device's HID is already
    present in the list), but the element is never deleted from the list
    nor freed. Fix it.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ddfed0d407e5..be1fc12a17ee 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -471,10 +471,24 @@ static void acpi_device_release(struct device *dev)
 
 static void acpi_device_del(struct acpi_device *device)
 {
+	struct acpi_device_bus_id *acpi_device_bus_id;
+
 	mutex_lock(&acpi_device_lock);
 	if (device->parent)
 		list_del(&device->node);
 
+	list_for_each_entry(acpi_device_bus_id, &acpi_bus_id_list, node)
+		if (!strcmp(acpi_device_bus_id->bus_id,
+			    acpi_device_hid(device))) {
+			if (acpi_device_bus_id->instance_no > 0)
+				acpi_device_bus_id->instance_no--;
+			else {
+				list_del(&acpi_device_bus_id->node);
+				kfree(acpi_device_bus_id);
+			}
+			break;
+		}
+
 	list_del(&device->wakeup_list);
 	mutex_unlock(&acpi_device_lock);
 

commit e399037e06beec6d190a302ff5e4fee4aae77c50
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Thu Nov 19 11:05:25 2015 +0800

    ACPI / scan: set status to 0 if _STA failed
    
    Some ACPI node's _STA will touch operation region field, since the
    evaluation of _STA in acpi_bus_type_and_status is very early, the
    operation region handler is not ready yet. Instead of fail that function
    and not creating the acpi_device node consequently, set status to 0 so
    that later when the driver for that device is probing, it can find
    the acpi_device node and proceed normally. And at that time, the
    handler for the operation region is ready and its _STA evaluation will
    succeed, its present status can be checked there.
    
    Even there will be no driver using this node later, it doesn't seem
    hurt to have one more acpi_device node created with status set to 0.
    
    This happens on Microsoft Surface 3, where the SPI device node NTRG's
    _STA touches GPIO fields and the SPI core driver will only enumerate SPI
    devices from ACPI if the acpi_device node is 1: created; 2: _STA
    indicates it's present.
    
    Note that due to another problem in SPI driver, for NTRG to be actually
    enumerated, some changes have to be made in the SPI layer, which is
    addressed by Mika(not send out yet):
    https://bugzilla.kernel.org/show_bug.cgi?id=104291#c23
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=104291
    Reported-by: Bastien Nocera <bugzilla@hadess.net>
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 78d5f02a073b..ddfed0d407e5 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1461,7 +1461,7 @@ static int acpi_bus_type_and_status(acpi_handle handle, int *type,
 		*type = ACPI_BUS_TYPE_DEVICE;
 		status = acpi_bus_get_status_handle(handle, sta);
 		if (ACPI_FAILURE(status))
-			return -ENODEV;
+			*sta = 0;
 		break;
 	case ACPI_TYPE_PROCESSOR:
 		*type = ACPI_BUS_TYPE_PROCESSOR;

commit f2115faaf0df42623638dfbfc5bdaab6ef7375ab
Merge: 0d51ce9ca111 29dbe1f0af88
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Nov 7 01:30:10 2015 +0100

    Merge branch 'acpi-pci'
    
    * acpi-pci:
      PCI: ACPI: Add support for PCI device DMA coherency
      PCI: OF: Move of_pci_dma_configure() to pci_dma_configure()
      of/pci: Fix pci_get_host_bridge_device leak
      device property: ACPI: Remove unused DMA APIs
      device property: ACPI: Make use of the new DMA Attribute APIs
      device property: Adding DMA Attribute APIs for Generic Devices
      ACPI: Adding DMA Attribute APIs for ACPI Device
      device property: Introducing enum dev_dma_attr
      ACPI: Honor ACPI _CCA attribute setting
    
    Conflicts:
            drivers/crypto/ccp/ccp-platform.c

commit b84f196d963c3159329f72ca1913b08679004a43
Author: Suthikulpanit, Suravee <Suravee.Suthikulpanit@amd.com>
Date:   Wed Oct 28 15:50:48 2015 -0700

    ACPI: Adding DMA Attribute APIs for ACPI Device
    
    Adding acpi_get_dma_attr() to query DMA attributes of ACPI devices.
    It returns the enum dev_dma_attr, which communicates DMA information
    more clearly. This API replaces the acpi_check_dma(), which will be
    removed in subsequent patch.
    
    This patch also provides a convenient function, acpi_dma_supported(),
    to check DMA support of the specified ACPI device.
    
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d1ce377db3e9..ed3d76fadccf 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1308,6 +1308,48 @@ void acpi_free_pnp_ids(struct acpi_device_pnp *pnp)
 	kfree(pnp->unique_id);
 }
 
+/**
+ * acpi_dma_supported - Check DMA support for the specified device.
+ * @adev: The pointer to acpi device
+ *
+ * Return false if DMA is not supported. Otherwise, return true
+ */
+bool acpi_dma_supported(struct acpi_device *adev)
+{
+	if (!adev)
+		return false;
+
+	if (adev->flags.cca_seen)
+		return true;
+
+	/*
+	* Per ACPI 6.0 sec 6.2.17, assume devices can do cache-coherent
+	* DMA on "Intel platforms".  Presumably that includes all x86 and
+	* ia64, and other arches will set CONFIG_ACPI_CCA_REQUIRED=y.
+	*/
+	if (!IS_ENABLED(CONFIG_ACPI_CCA_REQUIRED))
+		return true;
+
+	return false;
+}
+
+/**
+ * acpi_get_dma_attr - Check the supported DMA attr for the specified device.
+ * @adev: The pointer to acpi device
+ *
+ * Return enum dev_dma_attr.
+ */
+enum dev_dma_attr acpi_get_dma_attr(struct acpi_device *adev)
+{
+	if (!acpi_dma_supported(adev))
+		return DEV_DMA_NOT_SUPPORTED;
+
+	if (adev->flags.coherent_dma)
+		return DEV_DMA_COHERENT;
+	else
+		return DEV_DMA_NON_COHERENT;
+}
+
 static void acpi_init_coherency(struct acpi_device *adev)
 {
 	unsigned long long cca = 0;

commit e3ed766b4958bf7889539f09aec3f6a72d2c4dd2
Merge: 343ccb040e60 3722ed2380ad
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Oct 25 22:55:14 2015 +0100

    Merge branch 'acpi-init'
    
    * acpi-init:
      clocksource: cosmetic: Drop OF 'dependency' from symbols
      clocksource / arm_arch_timer: Convert to ACPI probing
      clocksource: Add new CLKSRC_{PROBE,ACPI} config symbols
      clocksource / ACPI: Add probing infrastructure for ACPI-based clocksources
      irqchip / GIC: Convert the GIC driver to ACPI probing
      irqchip / ACPI: Add probing infrastructure for ACPI-based irqchips
      ACPI: Add early device probing infrastructure

commit 343ccb040e60c3688d4413e839975fc3c8f9e287
Merge: ab736d7dc17e 6a0d12ef993c 362414d9d282 611975470740 f934c745079e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Oct 25 22:54:46 2015 +0100

    Merge branches 'acpi-scan', 'acpi-tables', 'acpi-ec' and 'acpi-assorted'
    
    * acpi-scan:
      ACPI / scan: use kstrdup_const() in acpi_add_id()
      ACPI / scan: constify struct acpi_hardware_id::id
      ACPI / scan: constify first argument of struct acpi_scan_handler::match
    
    * acpi-tables:
      ACPI / tables: test the correct variable
      x86, ACPI: Handle apic/x2apic entries in MADT in correct order
      ACPI / tables: Add acpi_subtable_proc to ACPI table parsers
    
    * acpi-ec:
      ACPI / EC: Fix a race issue in acpi_ec_guard_event()
      ACPI / EC: Fix query handler related issues
    
    * acpi-assorted:
      ACPI: change acpi_sleep_proc_init() to return void
      ACPI: change init_acpi_device_notify() to return void

commit e647b532275bb357e87272e052fccf5fcdb36a17
Author: Marc Zyngier <Marc.Zyngier@arm.com>
Date:   Mon Sep 28 15:49:12 2015 +0100

    ACPI: Add early device probing infrastructure
    
    IRQ controllers and timers are the two types of device the kernel
    requires before being able to use the device driver model.
    
    ACPI so far lacks a proper probing infrastructure similar to the one
    we have with DT, where we're able to declare IRQ chips and
    clocksources inside the driver code, and let the core code pick it up
    and call us back on a match. This leads to all kind of really ugly
    hacks all over the arm64 code and even in the ACPI layer.
    
    In order to allow some basic probing based on the ACPI tables,
    introduce "struct acpi_probe_entry" which contains just enough
    data and callbacks to match a table, an optional subtable, and
    call a probe function. A driver can, at build time, register itself
    and expect being called if the right entry exists in the ACPI
    table.
    
    A acpi_probe_device_table() is provided, taking an identifier for
    a set of acpi_prove_entries, and iterating over the registered
    entries.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d1ce377db3e9..1d6b55a6f501 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1913,3 +1913,42 @@ int __init acpi_scan_init(void)
 	mutex_unlock(&acpi_scan_lock);
 	return result;
 }
+
+static struct acpi_probe_entry *ape;
+static int acpi_probe_count;
+static DEFINE_SPINLOCK(acpi_probe_lock);
+
+static int __init acpi_match_madt(struct acpi_subtable_header *header,
+				  const unsigned long end)
+{
+	if (!ape->subtable_valid || ape->subtable_valid(header, ape))
+		if (!ape->probe_subtbl(header, end))
+			acpi_probe_count++;
+
+	return 0;
+}
+
+int __init __acpi_probe_device_table(struct acpi_probe_entry *ap_head, int nr)
+{
+	int count = 0;
+
+	if (acpi_disabled)
+		return 0;
+
+	spin_lock(&acpi_probe_lock);
+	for (ape = ap_head; nr; ape++, nr--) {
+		if (ACPI_COMPARE_NAME(ACPI_SIG_MADT, ape->id)) {
+			acpi_probe_count = 0;
+			acpi_table_parse_madt(ape->type, acpi_match_madt, 0);
+			count += acpi_probe_count;
+		} else {
+			int res;
+			res = acpi_table_parse(ape->id, ape->probe_table);
+			if (!res)
+				count++;
+		}
+	}
+	spin_unlock(&acpi_probe_lock);
+
+	return count;
+}

commit 6a0d12ef993c5291047d72e88d73d0aa2b967335
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Sep 9 23:59:43 2015 +0200

    ACPI / scan: use kstrdup_const() in acpi_add_id()
    
    Empirically, acpi_add_id is mostly called with string literals, so
    using kstrdup_const for initializing struct acpi_hardware_id::id saves
    a little run-time memory and a string copy.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a3eaf2080707..afaac47eefb4 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1184,7 +1184,7 @@ static void acpi_add_id(struct acpi_device_pnp *pnp, const char *dev_id)
 	if (!id)
 		return;
 
-	id->id = kstrdup(dev_id, GFP_KERNEL);
+	id->id = kstrdup_const(dev_id, GFP_KERNEL);
 	if (!id->id) {
 		kfree(id);
 		return;
@@ -1322,7 +1322,7 @@ void acpi_free_pnp_ids(struct acpi_device_pnp *pnp)
 	struct acpi_hardware_id *id, *tmp;
 
 	list_for_each_entry_safe(id, tmp, &pnp->ids, list) {
-		kfree(id->id);
+		kfree_const(id->id);
 		kfree(id);
 	}
 	kfree(pnp->unique_id);

commit 844142c3f80c66fb2c311b118d60abdfe02322cb
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Sep 9 23:59:42 2015 +0200

    ACPI / scan: constify struct acpi_hardware_id::id
    
    This is preparation for using kstrdup_const to initialize that member.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 01136b879038..a3eaf2080707 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1472,7 +1472,7 @@ bool acpi_device_is_present(struct acpi_device *adev)
 }
 
 static bool acpi_scan_handler_matching(struct acpi_scan_handler *handler,
-				       char *idstr,
+				       const char *idstr,
 				       const struct acpi_device_id **matchid)
 {
 	const struct acpi_device_id *devid;
@@ -1491,7 +1491,7 @@ static bool acpi_scan_handler_matching(struct acpi_scan_handler *handler,
 	return false;
 }
 
-static struct acpi_scan_handler *acpi_scan_match_handler(char *idstr,
+static struct acpi_scan_handler *acpi_scan_match_handler(const char *idstr,
 					const struct acpi_device_id **matchid)
 {
 	struct acpi_scan_handler *handler;

commit 504a33749971c36c54ba5ccb1364872dee1f17a7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 27 04:42:33 2015 +0200

    ACPI / property: Extend device_get_next_child_node() to data-only nodes
    
    Make device_get_next_child_node() work with ACPI data-only subnodes
    introduced previously.
    
    Namely, replace acpi_get_next_child() with acpi_get_next_subnode()
    that can handle (and return) child device objects as well as child
    data-only subnodes of the given device and modify the ACPI part
    of the GPIO subsystem to handle data-only subnodes returned by it.
    
    To that end, introduce acpi_node_get_gpiod() taking a struct
    fwnode_handle pointer as the first argument.  That argument may
    point to an ACPI device object as well as to a data-only subnode
    and the function should do the right thing (ie. look for the matching
    GPIO descriptor correctly) in either case.
    
    Next, modify fwnode_get_named_gpiod() to use acpi_node_get_gpiod()
    instead of acpi_get_gpiod_by_index() which automatically causes
    devm_get_gpiod_from_child() to work with ACPI data-only subnodes
    that may be returned by device_get_next_child_node() which in turn
    is required by the users of that function (the gpio_keys_polled
    and gpio-leds drivers).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 01136b879038..d1ce377db3e9 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -695,26 +695,6 @@ int acpi_device_add(struct acpi_device *device,
 	return result;
 }
 
-struct acpi_device *acpi_get_next_child(struct device *dev,
-					struct acpi_device *child)
-{
-	struct acpi_device *adev = ACPI_COMPANION(dev);
-	struct list_head *head, *next;
-
-	if (!adev)
-		return NULL;
-
-	head = &adev->children;
-	if (list_empty(head))
-		return NULL;
-
-	if (!child)
-		return list_first_entry(head, struct acpi_device, node);
-
-	next = child->node.next;
-	return next == head ? NULL : list_entry(next, struct acpi_device, node);
-}
-
 /* --------------------------------------------------------------------------
                                  Device Enumeration
    -------------------------------------------------------------------------- */

commit 3431e490b50356b56084305a2e93b3a980802b22
Merge: 5af310a8ee70 1dcc3d3362b0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 29 23:57:51 2015 +0200

    Merge branch 'acpi-scan' into acpi-pm
    
    Conflicts:
            drivers/acpi/scan.c
    
    The conflict is resolved by moving the just introduced
    acpi_device_is_first_physical_node() to bus.c and using
    the existing acpi_companion_match() from there.
    
    There will be an additional commit to combine the two.

commit 712e960f0ee9337f3473ba3de2bcfc7e87b7c5a4
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Jul 27 18:03:57 2015 +0300

    ACPI / PM: Attach ACPI power domain only once
    
    Some devices, like MFD subdevices, share a single ACPI companion device so
    that they are able to access their resources and children. However,
    currently all these subdevices are attached to the ACPI power domain and
    this might cause that the power methods for the companion device get called
    more than once.
    
    In order to solve this we attach the ACPI power domain only to the first
    physical device that is bound to the ACPI companion device. In case of MFD
    devices, this is the parent MFD device itself.
    
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ec256352f423..89ff6d2eef8a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -226,6 +226,35 @@ static int create_of_modalias(struct acpi_device *acpi_dev, char *modalias,
 	return len;
 }
 
+/**
+ * acpi_device_is_first_physical_node - Is given dev first physical node
+ * @adev: ACPI companion device
+ * @dev: Physical device to check
+ *
+ * Function checks if given @dev is the first physical devices attached to
+ * the ACPI companion device. This distinction is needed in some cases
+ * where the same companion device is shared between many physical devices.
+ *
+ * Note that the caller have to provide valid @adev pointer.
+ */
+bool acpi_device_is_first_physical_node(struct acpi_device *adev,
+					const struct device *dev)
+{
+	bool ret = false;
+
+	mutex_lock(&adev->physical_node_lock);
+	if (!list_empty(&adev->physical_node_list)) {
+		const struct acpi_device_physical_node *node;
+
+		node = list_first_entry(&adev->physical_node_list,
+					struct acpi_device_physical_node, node);
+		ret = node->dev == dev;
+	}
+	mutex_unlock(&adev->physical_node_lock);
+
+	return ret;
+}
+
 /*
  * acpi_companion_match() - Can we match via ACPI companion device
  * @dev: Device in question
@@ -250,7 +279,6 @@ static int create_of_modalias(struct acpi_device *acpi_dev, char *modalias,
 static struct acpi_device *acpi_companion_match(const struct device *dev)
 {
 	struct acpi_device *adev;
-	struct mutex *physical_node_lock;
 
 	adev = ACPI_COMPANION(dev);
 	if (!adev)
@@ -259,21 +287,7 @@ static struct acpi_device *acpi_companion_match(const struct device *dev)
 	if (list_empty(&adev->pnp.ids))
 		return NULL;
 
-	physical_node_lock = &adev->physical_node_lock;
-	mutex_lock(physical_node_lock);
-	if (list_empty(&adev->physical_node_list)) {
-		adev = NULL;
-	} else {
-		const struct acpi_device_physical_node *node;
-
-		node = list_first_entry(&adev->physical_node_list,
-					struct acpi_device_physical_node, node);
-		if (node->dev != dev)
-			adev = NULL;
-	}
-	mutex_unlock(physical_node_lock);
-
-	return adev;
+	return acpi_device_is_first_physical_node(adev, dev) ? adev : NULL;
 }
 
 static int __acpi_device_uevent_modalias(struct acpi_device *adev,

commit 1dcc3d3362b0c97e48290f7786be85b4cec2a147
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 17 22:54:09 2015 +0200

    ACPI / bus: Move ACPI bus type registration
    
    Move the registration of the ACPI bus type to acpi_bus_init() and
    avoid using ACPI going forward if it fails (too many things depend on
    the presence of the ACPI bus type).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f541f689ae80..2fe5a37c385c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1891,12 +1891,6 @@ int __init acpi_scan_init(void)
 {
 	int result;
 
-	result = bus_register(&acpi_bus_type);
-	if (result) {
-		/* We don't want to quit even if we failed to add suspend/resume */
-		printk(KERN_ERR PREFIX "Could not register bus type\n");
-	}
-
 	acpi_pci_root_init();
 	acpi_pci_link_init();
 	acpi_processor_init();

commit 5894b0c46e49b5ecc25f22b2d1b8232aab00ce97
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 17 22:54:01 2015 +0200

    ACPI / scan: Move bus operations and notification routines to bus.c
    
    To reduce the size of scan.c and improve the readability of it, move
    code related to device notification, the definitions of the ACPI bus
    operations and the driver management code to drivers/acpi/bus.c.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 68877bc22357..f541f689ae80 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -444,10 +444,6 @@ void acpi_device_hotplug(struct acpi_device *adev, u32 src)
 	unlock_device_hotplug();
 }
 
-/* --------------------------------------------------------------------------
-			ACPI Bus operations
-   -------------------------------------------------------------------------- */
-
 static void acpi_free_power_resources_lists(struct acpi_device *device)
 {
 	int i;
@@ -474,144 +470,6 @@ static void acpi_device_release(struct device *dev)
 	kfree(acpi_dev);
 }
 
-static int acpi_bus_match(struct device *dev, struct device_driver *drv)
-{
-	struct acpi_device *acpi_dev = to_acpi_device(dev);
-	struct acpi_driver *acpi_drv = to_acpi_driver(drv);
-
-	return acpi_dev->flags.match_driver
-		&& !acpi_match_device_ids(acpi_dev, acpi_drv->ids);
-}
-
-static int acpi_device_uevent(struct device *dev, struct kobj_uevent_env *env)
-{
-	return __acpi_device_uevent_modalias(to_acpi_device(dev), env);
-}
-
-static void acpi_device_notify(acpi_handle handle, u32 event, void *data)
-{
-	struct acpi_device *device = data;
-
-	device->driver->ops.notify(device, event);
-}
-
-static void acpi_device_notify_fixed(void *data)
-{
-	struct acpi_device *device = data;
-
-	/* Fixed hardware devices have no handles */
-	acpi_device_notify(NULL, ACPI_FIXED_HARDWARE_EVENT, device);
-}
-
-static u32 acpi_device_fixed_event(void *data)
-{
-	acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_device_notify_fixed, data);
-	return ACPI_INTERRUPT_HANDLED;
-}
-
-static int acpi_device_install_notify_handler(struct acpi_device *device)
-{
-	acpi_status status;
-
-	if (device->device_type == ACPI_BUS_TYPE_POWER_BUTTON)
-		status =
-		    acpi_install_fixed_event_handler(ACPI_EVENT_POWER_BUTTON,
-						     acpi_device_fixed_event,
-						     device);
-	else if (device->device_type == ACPI_BUS_TYPE_SLEEP_BUTTON)
-		status =
-		    acpi_install_fixed_event_handler(ACPI_EVENT_SLEEP_BUTTON,
-						     acpi_device_fixed_event,
-						     device);
-	else
-		status = acpi_install_notify_handler(device->handle,
-						     ACPI_DEVICE_NOTIFY,
-						     acpi_device_notify,
-						     device);
-
-	if (ACPI_FAILURE(status))
-		return -EINVAL;
-	return 0;
-}
-
-static void acpi_device_remove_notify_handler(struct acpi_device *device)
-{
-	if (device->device_type == ACPI_BUS_TYPE_POWER_BUTTON)
-		acpi_remove_fixed_event_handler(ACPI_EVENT_POWER_BUTTON,
-						acpi_device_fixed_event);
-	else if (device->device_type == ACPI_BUS_TYPE_SLEEP_BUTTON)
-		acpi_remove_fixed_event_handler(ACPI_EVENT_SLEEP_BUTTON,
-						acpi_device_fixed_event);
-	else
-		acpi_remove_notify_handler(device->handle, ACPI_DEVICE_NOTIFY,
-					   acpi_device_notify);
-}
-
-static int acpi_device_probe(struct device *dev)
-{
-	struct acpi_device *acpi_dev = to_acpi_device(dev);
-	struct acpi_driver *acpi_drv = to_acpi_driver(dev->driver);
-	int ret;
-
-	if (acpi_dev->handler && !acpi_is_pnp_device(acpi_dev))
-		return -EINVAL;
-
-	if (!acpi_drv->ops.add)
-		return -ENOSYS;
-
-	ret = acpi_drv->ops.add(acpi_dev);
-	if (ret)
-		return ret;
-
-	acpi_dev->driver = acpi_drv;
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			  "Driver [%s] successfully bound to device [%s]\n",
-			  acpi_drv->name, acpi_dev->pnp.bus_id));
-
-	if (acpi_drv->ops.notify) {
-		ret = acpi_device_install_notify_handler(acpi_dev);
-		if (ret) {
-			if (acpi_drv->ops.remove)
-				acpi_drv->ops.remove(acpi_dev);
-
-			acpi_dev->driver = NULL;
-			acpi_dev->driver_data = NULL;
-			return ret;
-		}
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found driver [%s] for device [%s]\n",
-			  acpi_drv->name, acpi_dev->pnp.bus_id));
-	get_device(dev);
-	return 0;
-}
-
-static int acpi_device_remove(struct device * dev)
-{
-	struct acpi_device *acpi_dev = to_acpi_device(dev);
-	struct acpi_driver *acpi_drv = acpi_dev->driver;
-
-	if (acpi_drv) {
-		if (acpi_drv->ops.notify)
-			acpi_device_remove_notify_handler(acpi_dev);
-		if (acpi_drv->ops.remove)
-			acpi_drv->ops.remove(acpi_dev);
-	}
-	acpi_dev->driver = NULL;
-	acpi_dev->driver_data = NULL;
-
-	put_device(dev);
-	return 0;
-}
-
-struct bus_type acpi_bus_type = {
-	.name		= "acpi",
-	.match		= acpi_bus_match,
-	.probe		= acpi_device_probe,
-	.remove		= acpi_device_remove,
-	.uevent		= acpi_device_uevent,
-};
-
 static void acpi_device_del(struct acpi_device *device)
 {
 	mutex_lock(&acpi_device_lock);
@@ -858,47 +716,6 @@ struct acpi_device *acpi_get_next_child(struct device *dev,
 	return next == head ? NULL : list_entry(next, struct acpi_device, node);
 }
 
-/* --------------------------------------------------------------------------
-                                 Driver Management
-   -------------------------------------------------------------------------- */
-/**
- * acpi_bus_register_driver - register a driver with the ACPI bus
- * @driver: driver being registered
- *
- * Registers a driver with the ACPI bus.  Searches the namespace for all
- * devices that match the driver's criteria and binds.  Returns zero for
- * success or a negative error status for failure.
- */
-int acpi_bus_register_driver(struct acpi_driver *driver)
-{
-	int ret;
-
-	if (acpi_disabled)
-		return -ENODEV;
-	driver->drv.name = driver->name;
-	driver->drv.bus = &acpi_bus_type;
-	driver->drv.owner = driver->owner;
-
-	ret = driver_register(&driver->drv);
-	return ret;
-}
-
-EXPORT_SYMBOL(acpi_bus_register_driver);
-
-/**
- * acpi_bus_unregister_driver - unregisters a driver with the ACPI bus
- * @driver: driver to unregister
- *
- * Unregisters a driver with the ACPI bus.  Searches the namespace for all
- * devices that match the driver's criteria and unbinds.
- */
-void acpi_bus_unregister_driver(struct acpi_driver *driver)
-{
-	driver_unregister(&driver->drv);
-}
-
-EXPORT_SYMBOL(acpi_bus_unregister_driver);
-
 /* --------------------------------------------------------------------------
                                  Device Enumeration
    -------------------------------------------------------------------------- */

commit 68c6b148daa6e45a85b31ef60ed9c9bfd556fff0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 17 22:53:52 2015 +0200

    ACPI / scan: Move device matching code to bus.c
    
    To reduce the size of scan.c and improve the readability of it, move
    code related device matching into drivers/acpi/bus.c.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 099831fc8449..68877bc22357 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -115,55 +115,6 @@ int acpi_scan_add_handler_with_hotplug(struct acpi_scan_handler *handler,
 	return 0;
 }
 
-/*
- * acpi_companion_match() - Can we match via ACPI companion device
- * @dev: Device in question
- *
- * Check if the given device has an ACPI companion and if that companion has
- * a valid list of PNP IDs, and if the device is the first (primary) physical
- * device associated with it.  Return the companion pointer if that's the case
- * or NULL otherwise.
- *
- * If multiple physical devices are attached to a single ACPI companion, we need
- * to be careful.  The usage scenario for this kind of relationship is that all
- * of the physical devices in question use resources provided by the ACPI
- * companion.  A typical case is an MFD device where all the sub-devices share
- * the parent's ACPI companion.  In such cases we can only allow the primary
- * (first) physical device to be matched with the help of the companion's PNP
- * IDs.
- *
- * Additional physical devices sharing the ACPI companion can still use
- * resources available from it but they will be matched normally using functions
- * provided by their bus types (and analogously for their modalias).
- */
-struct acpi_device *acpi_companion_match(const struct device *dev)
-{
-	struct acpi_device *adev;
-	struct mutex *physical_node_lock;
-
-	adev = ACPI_COMPANION(dev);
-	if (!adev)
-		return NULL;
-
-	if (list_empty(&adev->pnp.ids))
-		return NULL;
-
-	physical_node_lock = &adev->physical_node_lock;
-	mutex_lock(physical_node_lock);
-	if (list_empty(&adev->physical_node_list)) {
-		adev = NULL;
-	} else {
-		const struct acpi_device_physical_node *node;
-
-		node = list_first_entry(&adev->physical_node_list,
-					struct acpi_device_physical_node, node);
-		if (node->dev != dev)
-			adev = NULL;
-	}
-	mutex_unlock(physical_node_lock);
-
-	return adev;
-}
 
 bool acpi_scan_is_offline(struct acpi_device *adev, bool uevent)
 {
@@ -497,146 +448,6 @@ void acpi_device_hotplug(struct acpi_device *adev, u32 src)
 			ACPI Bus operations
    -------------------------------------------------------------------------- */
 
-/**
- * acpi_of_match_device - Match device object using the "compatible" property.
- * @adev: ACPI device object to match.
- * @of_match_table: List of device IDs to match against.
- *
- * If @dev has an ACPI companion which has ACPI_DT_NAMESPACE_HID in its list of
- * identifiers and a _DSD object with the "compatible" property, use that
- * property to match against the given list of identifiers.
- */
-static bool acpi_of_match_device(struct acpi_device *adev,
-				 const struct of_device_id *of_match_table)
-{
-	const union acpi_object *of_compatible, *obj;
-	int i, nval;
-
-	if (!adev)
-		return false;
-
-	of_compatible = adev->data.of_compatible;
-	if (!of_match_table || !of_compatible)
-		return false;
-
-	if (of_compatible->type == ACPI_TYPE_PACKAGE) {
-		nval = of_compatible->package.count;
-		obj = of_compatible->package.elements;
-	} else { /* Must be ACPI_TYPE_STRING. */
-		nval = 1;
-		obj = of_compatible;
-	}
-	/* Now we can look for the driver DT compatible strings */
-	for (i = 0; i < nval; i++, obj++) {
-		const struct of_device_id *id;
-
-		for (id = of_match_table; id->compatible[0]; id++)
-			if (!strcasecmp(obj->string.pointer, id->compatible))
-				return true;
-	}
-
-	return false;
-}
-
-static bool __acpi_match_device_cls(const struct acpi_device_id *id,
-				    struct acpi_hardware_id *hwid)
-{
-	int i, msk, byte_shift;
-	char buf[3];
-
-	if (!id->cls)
-		return false;
-
-	/* Apply class-code bitmask, before checking each class-code byte */
-	for (i = 1; i <= 3; i++) {
-		byte_shift = 8 * (3 - i);
-		msk = (id->cls_msk >> byte_shift) & 0xFF;
-		if (!msk)
-			continue;
-
-		sprintf(buf, "%02x", (id->cls >> byte_shift) & msk);
-		if (strncmp(buf, &hwid->id[(i - 1) * 2], 2))
-			return false;
-	}
-	return true;
-}
-
-static const struct acpi_device_id *__acpi_match_device(
-	struct acpi_device *device,
-	const struct acpi_device_id *ids,
-	const struct of_device_id *of_ids)
-{
-	const struct acpi_device_id *id;
-	struct acpi_hardware_id *hwid;
-
-	/*
-	 * If the device is not present, it is unnecessary to load device
-	 * driver for it.
-	 */
-	if (!device || !device->status.present)
-		return NULL;
-
-	list_for_each_entry(hwid, &device->pnp.ids, list) {
-		/* First, check the ACPI/PNP IDs provided by the caller. */
-		for (id = ids; id->id[0] || id->cls; id++) {
-			if (id->id[0] && !strcmp((char *) id->id, hwid->id))
-				return id;
-			else if (id->cls && __acpi_match_device_cls(id, hwid))
-				return id;
-		}
-
-		/*
-		 * Next, check ACPI_DT_NAMESPACE_HID and try to match the
-		 * "compatible" property if found.
-		 *
-		 * The id returned by the below is not valid, but the only
-		 * caller passing non-NULL of_ids here is only interested in
-		 * whether or not the return value is NULL.
-		 */
-		if (!strcmp(ACPI_DT_NAMESPACE_HID, hwid->id)
-		    && acpi_of_match_device(device, of_ids))
-			return id;
-	}
-	return NULL;
-}
-
-/**
- * acpi_match_device - Match a struct device against a given list of ACPI IDs
- * @ids: Array of struct acpi_device_id object to match against.
- * @dev: The device structure to match.
- *
- * Check if @dev has a valid ACPI handle and if there is a struct acpi_device
- * object for that handle and use that object to match against a given list of
- * device IDs.
- *
- * Return a pointer to the first matching ID on success or %NULL on failure.
- */
-const struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,
-					       const struct device *dev)
-{
-	return __acpi_match_device(acpi_companion_match(dev), ids, NULL);
-}
-EXPORT_SYMBOL_GPL(acpi_match_device);
-
-int acpi_match_device_ids(struct acpi_device *device,
-			  const struct acpi_device_id *ids)
-{
-	return __acpi_match_device(device, ids, NULL) ? 0 : -ENOENT;
-}
-EXPORT_SYMBOL(acpi_match_device_ids);
-
-bool acpi_driver_match_device(struct device *dev,
-			      const struct device_driver *drv)
-{
-	if (!drv->acpi_match_table)
-		return acpi_of_match_device(ACPI_COMPANION(dev),
-					    drv->of_match_table);
-
-	return !!__acpi_match_device(acpi_companion_match(dev),
-				     drv->acpi_match_table, drv->of_match_table);
-}
-EXPORT_SYMBOL_GPL(acpi_driver_match_device);
-
 static void acpi_free_power_resources_lists(struct acpi_device *device)
 {
 	int i;

commit c2efefb33abfb245395199137ece3c1e3df47f51
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 17 22:53:43 2015 +0200

    ACPI / scan: Move sysfs-related device code to a separate file
    
    To reduce the size of scan.c and improve the readability of it, move
    all code related to device sysfs, modalias creation etc. to a new
    file called device_sysfs.c.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ec256352f423..099831fc8449 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -115,117 +115,6 @@ int acpi_scan_add_handler_with_hotplug(struct acpi_scan_handler *handler,
 	return 0;
 }
 
-/**
- * create_pnp_modalias - Create hid/cid(s) string for modalias and uevent
- * @acpi_dev: ACPI device object.
- * @modalias: Buffer to print into.
- * @size: Size of the buffer.
- *
- * Creates hid/cid(s) string needed for modalias and uevent
- * e.g. on a device with hid:IBM0001 and cid:ACPI0001 you get:
- * char *modalias: "acpi:IBM0001:ACPI0001"
- * Return: 0: no _HID and no _CID
- *         -EINVAL: output error
- *         -ENOMEM: output is truncated
-*/
-static int create_pnp_modalias(struct acpi_device *acpi_dev, char *modalias,
-			       int size)
-{
-	int len;
-	int count;
-	struct acpi_hardware_id *id;
-
-	/*
-	 * Since we skip ACPI_DT_NAMESPACE_HID from the modalias below, 0 should
-	 * be returned if ACPI_DT_NAMESPACE_HID is the only ACPI/PNP ID in the
-	 * device's list.
-	 */
-	count = 0;
-	list_for_each_entry(id, &acpi_dev->pnp.ids, list)
-		if (strcmp(id->id, ACPI_DT_NAMESPACE_HID))
-			count++;
-
-	if (!count)
-		return 0;
-
-	len = snprintf(modalias, size, "acpi:");
-	if (len <= 0)
-		return len;
-
-	size -= len;
-
-	list_for_each_entry(id, &acpi_dev->pnp.ids, list) {
-		if (!strcmp(id->id, ACPI_DT_NAMESPACE_HID))
-			continue;
-
-		count = snprintf(&modalias[len], size, "%s:", id->id);
-		if (count < 0)
-			return -EINVAL;
-
-		if (count >= size)
-			return -ENOMEM;
-
-		len += count;
-		size -= count;
-	}
-	modalias[len] = '\0';
-	return len;
-}
-
-/**
- * create_of_modalias - Creates DT compatible string for modalias and uevent
- * @acpi_dev: ACPI device object.
- * @modalias: Buffer to print into.
- * @size: Size of the buffer.
- *
- * Expose DT compatible modalias as of:NnameTCcompatible.  This function should
- * only be called for devices having ACPI_DT_NAMESPACE_HID in their list of
- * ACPI/PNP IDs.
- */
-static int create_of_modalias(struct acpi_device *acpi_dev, char *modalias,
-			      int size)
-{
-	struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
-	const union acpi_object *of_compatible, *obj;
-	int len, count;
-	int i, nval;
-	char *c;
-
-	acpi_get_name(acpi_dev->handle, ACPI_SINGLE_NAME, &buf);
-	/* DT strings are all in lower case */
-	for (c = buf.pointer; *c != '\0'; c++)
-		*c = tolower(*c);
-
-	len = snprintf(modalias, size, "of:N%sT", (char *)buf.pointer);
-	ACPI_FREE(buf.pointer);
-
-	if (len <= 0)
-		return len;
-
-	of_compatible = acpi_dev->data.of_compatible;
-	if (of_compatible->type == ACPI_TYPE_PACKAGE) {
-		nval = of_compatible->package.count;
-		obj = of_compatible->package.elements;
-	} else { /* Must be ACPI_TYPE_STRING. */
-		nval = 1;
-		obj = of_compatible;
-	}
-	for (i = 0; i < nval; i++, obj++) {
-		count = snprintf(&modalias[len], size, "C%s",
-				 obj->string.pointer);
-		if (count < 0)
-			return -EINVAL;
-
-		if (count >= size)
-			return -ENOMEM;
-
-		len += count;
-		size -= count;
-	}
-	modalias[len] = '\0';
-	return len;
-}
-
 /*
  * acpi_companion_match() - Can we match via ACPI companion device
  * @dev: Device in question
@@ -247,7 +136,7 @@ static int create_of_modalias(struct acpi_device *acpi_dev, char *modalias,
  * resources available from it but they will be matched normally using functions
  * provided by their bus types (and analogously for their modalias).
  */
-static struct acpi_device *acpi_companion_match(const struct device *dev)
+struct acpi_device *acpi_companion_match(const struct device *dev)
 {
 	struct acpi_device *adev;
 	struct mutex *physical_node_lock;
@@ -276,103 +165,6 @@ static struct acpi_device *acpi_companion_match(const struct device *dev)
 	return adev;
 }
 
-static int __acpi_device_uevent_modalias(struct acpi_device *adev,
-					 struct kobj_uevent_env *env)
-{
-	int len;
-
-	if (!adev)
-		return -ENODEV;
-
-	if (list_empty(&adev->pnp.ids))
-		return 0;
-
-	if (add_uevent_var(env, "MODALIAS="))
-		return -ENOMEM;
-
-	len = create_pnp_modalias(adev, &env->buf[env->buflen - 1],
-				  sizeof(env->buf) - env->buflen);
-	if (len < 0)
-		return len;
-
-	env->buflen += len;
-	if (!adev->data.of_compatible)
-		return 0;
-
-	if (len > 0 && add_uevent_var(env, "MODALIAS="))
-		return -ENOMEM;
-
-	len = create_of_modalias(adev, &env->buf[env->buflen - 1],
-				 sizeof(env->buf) - env->buflen);
-	if (len < 0)
-		return len;
-
-	env->buflen += len;
-
-	return 0;
-}
-
-/*
- * Creates uevent modalias field for ACPI enumerated devices.
- * Because the other buses does not support ACPI HIDs & CIDs.
- * e.g. for a device with hid:IBM0001 and cid:ACPI0001 you get:
- * "acpi:IBM0001:ACPI0001"
- */
-int acpi_device_uevent_modalias(struct device *dev, struct kobj_uevent_env *env)
-{
-	return __acpi_device_uevent_modalias(acpi_companion_match(dev), env);
-}
-EXPORT_SYMBOL_GPL(acpi_device_uevent_modalias);
-
-static int __acpi_device_modalias(struct acpi_device *adev, char *buf, int size)
-{
-	int len, count;
-
-	if (!adev)
-		return -ENODEV;
-
-	if (list_empty(&adev->pnp.ids))
-		return 0;
-
-	len = create_pnp_modalias(adev, buf, size - 1);
-	if (len < 0) {
-		return len;
-	} else if (len > 0) {
-		buf[len++] = '\n';
-		size -= len;
-	}
-	if (!adev->data.of_compatible)
-		return len;
-
-	count = create_of_modalias(adev, buf + len, size - 1);
-	if (count < 0) {
-		return count;
-	} else if (count > 0) {
-		len += count;
-		buf[len++] = '\n';
-	}
-
-	return len;
-}
-
-/*
- * Creates modalias sysfs attribute for ACPI enumerated devices.
- * Because the other buses does not support ACPI HIDs & CIDs.
- * e.g. for a device with hid:IBM0001 and cid:ACPI0001 you get:
- * "acpi:IBM0001:ACPI0001"
- */
-int acpi_device_modalias(struct device *dev, char *buf, int size)
-{
-	return __acpi_device_modalias(acpi_companion_match(dev), buf, size);
-}
-EXPORT_SYMBOL_GPL(acpi_device_modalias);
-
-static ssize_t
-acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, char *buf) {
-	return __acpi_device_modalias(to_acpi_device(dev), buf, 1024);
-}
-static DEVICE_ATTR(modalias, 0444, acpi_device_modalias_show, NULL);
-
 bool acpi_scan_is_offline(struct acpi_device *adev, bool uevent)
 {
 	struct acpi_device_physical_node *pn;
@@ -701,279 +493,6 @@ void acpi_device_hotplug(struct acpi_device *adev, u32 src)
 	unlock_device_hotplug();
 }
 
-static ssize_t real_power_state_show(struct device *dev,
-				     struct device_attribute *attr, char *buf)
-{
-	struct acpi_device *adev = to_acpi_device(dev);
-	int state;
-	int ret;
-
-	ret = acpi_device_get_power(adev, &state);
-	if (ret)
-		return ret;
-
-	return sprintf(buf, "%s\n", acpi_power_state_string(state));
-}
-
-static DEVICE_ATTR(real_power_state, 0444, real_power_state_show, NULL);
-
-static ssize_t power_state_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	struct acpi_device *adev = to_acpi_device(dev);
-
-	return sprintf(buf, "%s\n", acpi_power_state_string(adev->power.state));
-}
-
-static DEVICE_ATTR(power_state, 0444, power_state_show, NULL);
-
-static ssize_t
-acpi_eject_store(struct device *d, struct device_attribute *attr,
-		const char *buf, size_t count)
-{
-	struct acpi_device *acpi_device = to_acpi_device(d);
-	acpi_object_type not_used;
-	acpi_status status;
-
-	if (!count || buf[0] != '1')
-		return -EINVAL;
-
-	if ((!acpi_device->handler || !acpi_device->handler->hotplug.enabled)
-	    && !acpi_device->driver)
-		return -ENODEV;
-
-	status = acpi_get_type(acpi_device->handle, &not_used);
-	if (ACPI_FAILURE(status) || !acpi_device->flags.ejectable)
-		return -ENODEV;
-
-	get_device(&acpi_device->dev);
-	status = acpi_hotplug_schedule(acpi_device, ACPI_OST_EC_OSPM_EJECT);
-	if (ACPI_SUCCESS(status))
-		return count;
-
-	put_device(&acpi_device->dev);
-	acpi_evaluate_ost(acpi_device->handle, ACPI_OST_EC_OSPM_EJECT,
-			  ACPI_OST_SC_NON_SPECIFIC_FAILURE, NULL);
-	return status == AE_NO_MEMORY ? -ENOMEM : -EAGAIN;
-}
-
-static DEVICE_ATTR(eject, 0200, NULL, acpi_eject_store);
-
-static ssize_t
-acpi_device_hid_show(struct device *dev, struct device_attribute *attr, char *buf) {
-	struct acpi_device *acpi_dev = to_acpi_device(dev);
-
-	return sprintf(buf, "%s\n", acpi_device_hid(acpi_dev));
-}
-static DEVICE_ATTR(hid, 0444, acpi_device_hid_show, NULL);
-
-static ssize_t acpi_device_uid_show(struct device *dev,
-				    struct device_attribute *attr, char *buf)
-{
-	struct acpi_device *acpi_dev = to_acpi_device(dev);
-
-	return sprintf(buf, "%s\n", acpi_dev->pnp.unique_id);
-}
-static DEVICE_ATTR(uid, 0444, acpi_device_uid_show, NULL);
-
-static ssize_t acpi_device_adr_show(struct device *dev,
-				    struct device_attribute *attr, char *buf)
-{
-	struct acpi_device *acpi_dev = to_acpi_device(dev);
-
-	return sprintf(buf, "0x%08x\n",
-		       (unsigned int)(acpi_dev->pnp.bus_address));
-}
-static DEVICE_ATTR(adr, 0444, acpi_device_adr_show, NULL);
-
-static ssize_t
-acpi_device_path_show(struct device *dev, struct device_attribute *attr, char *buf) {
-	struct acpi_device *acpi_dev = to_acpi_device(dev);
-	struct acpi_buffer path = {ACPI_ALLOCATE_BUFFER, NULL};
-	int result;
-
-	result = acpi_get_name(acpi_dev->handle, ACPI_FULL_PATHNAME, &path);
-	if (result)
-		goto end;
-
-	result = sprintf(buf, "%s\n", (char*)path.pointer);
-	kfree(path.pointer);
-end:
-	return result;
-}
-static DEVICE_ATTR(path, 0444, acpi_device_path_show, NULL);
-
-/* sysfs file that shows description text from the ACPI _STR method */
-static ssize_t description_show(struct device *dev,
-				struct device_attribute *attr,
-				char *buf) {
-	struct acpi_device *acpi_dev = to_acpi_device(dev);
-	int result;
-
-	if (acpi_dev->pnp.str_obj == NULL)
-		return 0;
-
-	/*
-	 * The _STR object contains a Unicode identifier for a device.
-	 * We need to convert to utf-8 so it can be displayed.
-	 */
-	result = utf16s_to_utf8s(
-		(wchar_t *)acpi_dev->pnp.str_obj->buffer.pointer,
-		acpi_dev->pnp.str_obj->buffer.length,
-		UTF16_LITTLE_ENDIAN, buf,
-		PAGE_SIZE);
-
-	buf[result++] = '\n';
-
-	return result;
-}
-static DEVICE_ATTR(description, 0444, description_show, NULL);
-
-static ssize_t
-acpi_device_sun_show(struct device *dev, struct device_attribute *attr,
-		     char *buf) {
-	struct acpi_device *acpi_dev = to_acpi_device(dev);
-	acpi_status status;
-	unsigned long long sun;
-
-	status = acpi_evaluate_integer(acpi_dev->handle, "_SUN", NULL, &sun);
-	if (ACPI_FAILURE(status))
-		return -ENODEV;
-
-	return sprintf(buf, "%llu\n", sun);
-}
-static DEVICE_ATTR(sun, 0444, acpi_device_sun_show, NULL);
-
-static ssize_t status_show(struct device *dev, struct device_attribute *attr,
-				char *buf) {
-	struct acpi_device *acpi_dev = to_acpi_device(dev);
-	acpi_status status;
-	unsigned long long sta;
-
-	status = acpi_evaluate_integer(acpi_dev->handle, "_STA", NULL, &sta);
-	if (ACPI_FAILURE(status))
-		return -ENODEV;
-
-	return sprintf(buf, "%llu\n", sta);
-}
-static DEVICE_ATTR_RO(status);
-
-static int acpi_device_setup_files(struct acpi_device *dev)
-{
-	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	acpi_status status;
-	int result = 0;
-
-	/*
-	 * Devices gotten from FADT don't have a "path" attribute
-	 */
-	if (dev->handle) {
-		result = device_create_file(&dev->dev, &dev_attr_path);
-		if (result)
-			goto end;
-	}
-
-	if (!list_empty(&dev->pnp.ids)) {
-		result = device_create_file(&dev->dev, &dev_attr_hid);
-		if (result)
-			goto end;
-
-		result = device_create_file(&dev->dev, &dev_attr_modalias);
-		if (result)
-			goto end;
-	}
-
-	/*
-	 * If device has _STR, 'description' file is created
-	 */
-	if (acpi_has_method(dev->handle, "_STR")) {
-		status = acpi_evaluate_object(dev->handle, "_STR",
-					NULL, &buffer);
-		if (ACPI_FAILURE(status))
-			buffer.pointer = NULL;
-		dev->pnp.str_obj = buffer.pointer;
-		result = device_create_file(&dev->dev, &dev_attr_description);
-		if (result)
-			goto end;
-	}
-
-	if (dev->pnp.type.bus_address)
-		result = device_create_file(&dev->dev, &dev_attr_adr);
-	if (dev->pnp.unique_id)
-		result = device_create_file(&dev->dev, &dev_attr_uid);
-
-	if (acpi_has_method(dev->handle, "_SUN")) {
-		result = device_create_file(&dev->dev, &dev_attr_sun);
-		if (result)
-			goto end;
-	}
-
-	if (acpi_has_method(dev->handle, "_STA")) {
-		result = device_create_file(&dev->dev, &dev_attr_status);
-		if (result)
-			goto end;
-	}
-
-        /*
-         * If device has _EJ0, 'eject' file is created that is used to trigger
-         * hot-removal function from userland.
-         */
-	if (acpi_has_method(dev->handle, "_EJ0")) {
-		result = device_create_file(&dev->dev, &dev_attr_eject);
-		if (result)
-			return result;
-	}
-
-	if (dev->flags.power_manageable) {
-		result = device_create_file(&dev->dev, &dev_attr_power_state);
-		if (result)
-			return result;
-
-		if (dev->power.flags.power_resources)
-			result = device_create_file(&dev->dev,
-						    &dev_attr_real_power_state);
-	}
-
-end:
-	return result;
-}
-
-static void acpi_device_remove_files(struct acpi_device *dev)
-{
-	if (dev->flags.power_manageable) {
-		device_remove_file(&dev->dev, &dev_attr_power_state);
-		if (dev->power.flags.power_resources)
-			device_remove_file(&dev->dev,
-					   &dev_attr_real_power_state);
-	}
-
-	/*
-	 * If device has _STR, remove 'description' file
-	 */
-	if (acpi_has_method(dev->handle, "_STR")) {
-		kfree(dev->pnp.str_obj);
-		device_remove_file(&dev->dev, &dev_attr_description);
-	}
-	/*
-	 * If device has _EJ0, remove 'eject' file.
-	 */
-	if (acpi_has_method(dev->handle, "_EJ0"))
-		device_remove_file(&dev->dev, &dev_attr_eject);
-
-	if (acpi_has_method(dev->handle, "_SUN"))
-		device_remove_file(&dev->dev, &dev_attr_sun);
-
-	if (dev->pnp.unique_id)
-		device_remove_file(&dev->dev, &dev_attr_uid);
-	if (dev->pnp.type.bus_address)
-		device_remove_file(&dev->dev, &dev_attr_adr);
-	device_remove_file(&dev->dev, &dev_attr_modalias);
-	device_remove_file(&dev->dev, &dev_attr_hid);
-	if (acpi_has_method(dev->handle, "_STA"))
-		device_remove_file(&dev->dev, &dev_attr_status);
-	if (dev->handle)
-		device_remove_file(&dev->dev, &dev_attr_path);
-}
 /* --------------------------------------------------------------------------
 			ACPI Bus operations
    -------------------------------------------------------------------------- */

commit 26095a01d359827eeccec5459c28ddd976183179
Author: Suthikulpanit, Suravee <Suravee.Suthikulpanit@amd.com>
Date:   Tue Jul 7 01:55:20 2015 +0200

    ACPI / scan: Add support for ACPI _CLS device matching
    
    Device drivers typically use ACPI _HIDs/_CIDs listed in struct device_driver
    acpi_match_table to match devices. However, for generic drivers, we do not
    want to list _HID for all supported devices. Also, certain classes of devices
    do not have _CID (e.g. SATA, USB). Instead, we can leverage ACPI _CLS,
    which specifies PCI-defined class code (i.e. base-class, subclass and
    programming interface). This patch adds support for matching ACPI devices using
    the _CLS method.
    
    To support loadable module, current design uses _HID or _CID to match device's
    modalias. With the new way of matching with _CLS this would requires modification
    to the current ACPI modalias key to include _CLS. This patch appends PCI-defined
    class-code to the existing ACPI modalias as following.
    
        acpi:<HID>:<CID1>:<CID2>:..:<CIDn>:<bbsspp>:
    E.g:
        # cat /sys/devices/platform/AMDI0600:00/modalias
        acpi:AMDI0600:010601:
    
    where bb is th base-class code, ss is te sub-class code, and pp is the
    programming interface code
    
    Since there would not be _HID/_CID in the ACPI matching table of the driver,
    this patch adds a field to acpi_device_id to specify the matching _CLS.
    
        static const struct acpi_device_id ahci_acpi_match[] = {
            { ACPI_DEVICE_CLASS(PCI_CLASS_STORAGE_SATA_AHCI, 0xffffff) },
            {},
        };
    
    In this case, the corresponded entry in modules.alias file would be:
    
        alias acpi*:010601:* ahci_platform
    
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 2649a068671d..ec256352f423 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1019,6 +1019,29 @@ static bool acpi_of_match_device(struct acpi_device *adev,
 	return false;
 }
 
+static bool __acpi_match_device_cls(const struct acpi_device_id *id,
+				    struct acpi_hardware_id *hwid)
+{
+	int i, msk, byte_shift;
+	char buf[3];
+
+	if (!id->cls)
+		return false;
+
+	/* Apply class-code bitmask, before checking each class-code byte */
+	for (i = 1; i <= 3; i++) {
+		byte_shift = 8 * (3 - i);
+		msk = (id->cls_msk >> byte_shift) & 0xFF;
+		if (!msk)
+			continue;
+
+		sprintf(buf, "%02x", (id->cls >> byte_shift) & msk);
+		if (strncmp(buf, &hwid->id[(i - 1) * 2], 2))
+			return false;
+	}
+	return true;
+}
+
 static const struct acpi_device_id *__acpi_match_device(
 	struct acpi_device *device,
 	const struct acpi_device_id *ids,
@@ -1036,9 +1059,12 @@ static const struct acpi_device_id *__acpi_match_device(
 
 	list_for_each_entry(hwid, &device->pnp.ids, list) {
 		/* First, check the ACPI/PNP IDs provided by the caller. */
-		for (id = ids; id->id[0]; id++)
-			if (!strcmp((char *) id->id, hwid->id))
+		for (id = ids; id->id[0] || id->cls; id++) {
+			if (id->id[0] && !strcmp((char *) id->id, hwid->id))
 				return id;
+			else if (id->cls && __acpi_match_device_cls(id, hwid))
+				return id;
+		}
 
 		/*
 		 * Next, check ACPI_DT_NAMESPACE_HID and try to match the
@@ -2101,6 +2127,8 @@ static void acpi_set_pnp_ids(acpi_handle handle, struct acpi_device_pnp *pnp,
 		if (info->valid & ACPI_VALID_UID)
 			pnp->unique_id = kstrdup(info->unique_id.string,
 							GFP_KERNEL);
+		if (info->valid & ACPI_VALID_CLS)
+			acpi_add_id(pnp, info->class_code.string);
 
 		kfree(info);
 

commit e193cd15ae98817ad82cc8bad61a200ac561e98c
Merge: 4def8a360fc6 e144cd045e12
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 19 01:17:35 2015 +0200

    Merge branch 'acpi-cca'
    
    * acpi-cca:
      ufs: fix TRUE and FALSE re-define build error
      megaraid_sas: fix TRUE and FALSE re-define build error
      amd-xgbe: Unify coherency checking logic with device_dma_is_coherent()
      crypto: ccp - Unify coherency checking logic with device_dma_is_coherent()
      device property: Introduces device_dma_is_coherent()
      arm64 : Introduce support for ACPI _CCA object
      ACPI / scan: Parse _CCA and setup device coherency

commit 4def8a360fc6119e09916708cca0977a1495ccf4
Merge: 763d949581ed e7d024c00a4a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 19 01:17:26 2015 +0200

    Merge branch 'acpi-video'
    
    * acpi-video: (38 commits)
      ACPI / video: Make acpi_video_unregister_backlight() private
      acpi-video-detect: Remove old API
      toshiba-acpi: Port to new backlight interface selection API
      thinkpad-acpi: Port to new backlight interface selection API
      sony-laptop: Port to new backlight interface selection API
      samsung-laptop: Port to new backlight interface selection API
      msi-wmi: Port to new backlight interface selection API
      msi-laptop: Port to new backlight interface selection API
      intel-oaktrail: Port to new backlight interface selection API
      ideapad-laptop: Port to new backlight interface selection API
      fujitsu-laptop: Port to new backlight interface selection API
      eeepc-laptop: Port to new backlight interface selection API
      dell-wmi: Port to new backlight interface selection API
      dell-laptop: Port to new backlight interface selection API
      compal-laptop: Port to new backlight interface selection API
      asus-wmi: Port to new backlight interface selection API
      asus-laptop: Port to new backlight interface selection API
      apple-gmux: Port to new backlight interface selection API
      acer-wmi: Port to new backlight interface selection API
      ACPI / video: Fix acpi_video _register vs _unregister_backlight race
      ...

commit 4f1fd900c2bd0bf36832d489745b5f78847a1534
Merge: 3a5cf05adf90 3d56402d3fa8 20f34165a924 2bad7e27e02c 302ebef8894d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 19 01:16:21 2015 +0200

    Merge branches 'acpi-pm', 'acpi-apei', 'acpi-osl' and 'acpi-pci'
    
    * acpi-pm:
      ACPI / PM: Add missing pm_generic_complete() invocation
      ACPI / PM: Turn power resources on and off in the right order during resume
      ACPI / PM: Rework device power management to follow ACPI 6
      ACPI / PM: Drop stale comment from acpi_power_transition()
    
    * acpi-apei:
      GHES: Make NMI handler have a single reader
      GHES: Elliminate double-loop in the NMI handler
      GHES: Panic right after detection
      GHES: Carve out the panic functionality
      GHES: Carve out error queueing in a separate function
    
    * acpi-osl:
      ACPI / osl: use same type for acpi_predefined_names values as in definition
    
    * acpi-pci:
      ACPI / PCI: remove stale list_head in struct acpi_prt_entry

commit adc8bb8e0fe005ed29366e6c4621652481878214
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Jun 16 16:27:45 2015 +0200

    acpi-video-detect: Move acpi_is_video_device() to acpi/scan.c
    
    This allows video_detect.c to be build as a module, this is a preparation
    patch for the backlight interface selection logic cleanup.
    
    Note this commit also causes acpi_is_video_device() to always be build
    indepedent of CONFIG_ACPI_VIDEO, as there is no reason to make its
    building depend on CONFIG_ACPI_VIDEO.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 0a099917a006..aa997c66d697 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1949,6 +1949,62 @@ bool acpi_dock_match(acpi_handle handle)
 	return acpi_has_method(handle, "_DCK");
 }
 
+static acpi_status
+acpi_backlight_cap_match(acpi_handle handle, u32 level, void *context,
+			  void **return_value)
+{
+	long *cap = context;
+
+	if (acpi_has_method(handle, "_BCM") &&
+	    acpi_has_method(handle, "_BCL")) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found generic backlight "
+				  "support\n"));
+		*cap |= ACPI_VIDEO_BACKLIGHT;
+		if (!acpi_has_method(handle, "_BQC"))
+			printk(KERN_WARNING FW_BUG PREFIX "No _BQC method, "
+				"cannot determine initial brightness\n");
+		/* We have backlight support, no need to scan further */
+		return AE_CTRL_TERMINATE;
+	}
+	return 0;
+}
+
+/* Returns true if the ACPI object is a video device which can be
+ * handled by video.ko.
+ * The device will get a Linux specific CID added in scan.c to
+ * identify the device as an ACPI graphics device
+ * Be aware that the graphics device may not be physically present
+ * Use acpi_video_get_capabilities() to detect general ACPI video
+ * capabilities of present cards
+ */
+long acpi_is_video_device(acpi_handle handle)
+{
+	long video_caps = 0;
+
+	/* Is this device able to support video switching ? */
+	if (acpi_has_method(handle, "_DOD") || acpi_has_method(handle, "_DOS"))
+		video_caps |= ACPI_VIDEO_OUTPUT_SWITCHING;
+
+	/* Is this device able to retrieve a video ROM ? */
+	if (acpi_has_method(handle, "_ROM"))
+		video_caps |= ACPI_VIDEO_ROM_AVAILABLE;
+
+	/* Is this device able to configure which video head to be POSTed ? */
+	if (acpi_has_method(handle, "_VPO") &&
+	    acpi_has_method(handle, "_GPD") &&
+	    acpi_has_method(handle, "_SPD"))
+		video_caps |= ACPI_VIDEO_DEVICE_POSTING;
+
+	/* Only check for backlight functionality if one of the above hit. */
+	if (video_caps)
+		acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
+				    ACPI_UINT32_MAX, acpi_backlight_cap_match, NULL,
+				    &video_caps, NULL);
+
+	return video_caps;
+}
+EXPORT_SYMBOL(acpi_is_video_device);
+
 const char *acpi_device_hid(struct acpi_device *device)
 {
 	struct acpi_hardware_id *hid;

commit d0562674838c08ff142c0e9a8e12634e133c4361
Author: Suthikulpanit, Suravee <Suravee.Suthikulpanit@amd.com>
Date:   Wed Jun 10 11:08:52 2015 -0500

    ACPI / scan: Parse _CCA and setup device coherency
    
    This patch implements support for ACPI _CCA object, which is introduced in
    ACPIv5.1, can be used for specifying device DMA coherency attribute.
    
    The parsing logic traverses device namespace to parse coherency
    information, and stores it in acpi_device_flags. Then uses it to call
    arch_setup_dma_ops() when creating each device enumerated in DSDT
    during ACPI scan.
    
    This patch also introduces acpi_dma_is_coherent(), which provides
    an interface for device drivers to check the coherency information
    similarly to the of_dma_is_coherent().
    
    Signed-off-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 0a099917a006..67509b23172c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -11,6 +11,7 @@
 #include <linux/kthread.h>
 #include <linux/dmi.h>
 #include <linux/nls.h>
+#include <linux/dma-mapping.h>
 
 #include <asm/pgtable.h>
 
@@ -2111,6 +2112,39 @@ void acpi_free_pnp_ids(struct acpi_device_pnp *pnp)
 	kfree(pnp->unique_id);
 }
 
+static void acpi_init_coherency(struct acpi_device *adev)
+{
+	unsigned long long cca = 0;
+	acpi_status status;
+	struct acpi_device *parent = adev->parent;
+
+	if (parent && parent->flags.cca_seen) {
+		/*
+		 * From ACPI spec, OSPM will ignore _CCA if an ancestor
+		 * already saw one.
+		 */
+		adev->flags.cca_seen = 1;
+		cca = parent->flags.coherent_dma;
+	} else {
+		status = acpi_evaluate_integer(adev->handle, "_CCA",
+					       NULL, &cca);
+		if (ACPI_SUCCESS(status))
+			adev->flags.cca_seen = 1;
+		else if (!IS_ENABLED(CONFIG_ACPI_CCA_REQUIRED))
+			/*
+			 * If architecture does not specify that _CCA is
+			 * required for DMA-able devices (e.g. x86),
+			 * we default to _CCA=1.
+			 */
+			cca = 1;
+		else
+			acpi_handle_debug(adev->handle,
+					  "ACPI device is missing _CCA.\n");
+	}
+
+	adev->flags.coherent_dma = cca;
+}
+
 void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 			     int type, unsigned long long sta)
 {
@@ -2129,6 +2163,7 @@ void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 	device->flags.visited = false;
 	device_initialize(&device->dev);
 	dev_set_uevent_suppress(&device->dev, true);
+	acpi_init_coherency(device);
 }
 
 void acpi_device_add_finalize(struct acpi_device *device)

commit 0519ade71852701ec76ee7f8a0b37fe5a5504f98
Author: Mathias Krause <minipli@googlemail.com>
Date:   Sat Jun 13 14:26:58 2015 +0200

    ACPI / scan: constify ACPI device ids
    
    Make the button ACPI device ID array static const. Safes us a little bit
    of code.
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b19283b336c7..0a099917a006 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1673,7 +1673,7 @@ static int acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 
 static void acpi_wakeup_gpe_init(struct acpi_device *device)
 {
-	struct acpi_device_id button_device_ids[] = {
+	static const struct acpi_device_id button_device_ids[] = {
 		{"PNP0C0C", 0},
 		{"PNP0C0D", 0},
 		{"PNP0C0E", 0},

commit ee89209402e0b9a733169901063afdf0ae7909db
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 22 04:24:34 2015 +0200

    ACPI / property: Define a symbol for PRP0001
    
    Use a #defined symbol ACPI_DT_NAMESPACE_HID instead of the PRP0001
    string.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 03141aa4ea95..b19283b336c7 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -135,12 +135,13 @@ static int create_pnp_modalias(struct acpi_device *acpi_dev, char *modalias,
 	struct acpi_hardware_id *id;
 
 	/*
-	 * Since we skip PRP0001 from the modalias below, 0 should be returned
-	 * if PRP0001 is the only ACPI/PNP ID in the device's list.
+	 * Since we skip ACPI_DT_NAMESPACE_HID from the modalias below, 0 should
+	 * be returned if ACPI_DT_NAMESPACE_HID is the only ACPI/PNP ID in the
+	 * device's list.
 	 */
 	count = 0;
 	list_for_each_entry(id, &acpi_dev->pnp.ids, list)
-		if (strcmp(id->id, "PRP0001"))
+		if (strcmp(id->id, ACPI_DT_NAMESPACE_HID))
 			count++;
 
 	if (!count)
@@ -153,7 +154,7 @@ static int create_pnp_modalias(struct acpi_device *acpi_dev, char *modalias,
 	size -= len;
 
 	list_for_each_entry(id, &acpi_dev->pnp.ids, list) {
-		if (!strcmp(id->id, "PRP0001"))
+		if (!strcmp(id->id, ACPI_DT_NAMESPACE_HID))
 			continue;
 
 		count = snprintf(&modalias[len], size, "%s:", id->id);
@@ -177,7 +178,8 @@ static int create_pnp_modalias(struct acpi_device *acpi_dev, char *modalias,
  * @size: Size of the buffer.
  *
  * Expose DT compatible modalias as of:NnameTCcompatible.  This function should
- * only be called for devices having PRP0001 in their list of ACPI/PNP IDs.
+ * only be called for devices having ACPI_DT_NAMESPACE_HID in their list of
+ * ACPI/PNP IDs.
  */
 static int create_of_modalias(struct acpi_device *acpi_dev, char *modalias,
 			      int size)
@@ -980,9 +982,9 @@ static void acpi_device_remove_files(struct acpi_device *dev)
  * @adev: ACPI device object to match.
  * @of_match_table: List of device IDs to match against.
  *
- * If @dev has an ACPI companion which has the special PRP0001 device ID in its
- * list of identifiers and a _DSD object with the "compatible" property, use
- * that property to match against the given list of identifiers.
+ * If @dev has an ACPI companion which has ACPI_DT_NAMESPACE_HID in its list of
+ * identifiers and a _DSD object with the "compatible" property, use that
+ * property to match against the given list of identifiers.
  */
 static bool acpi_of_match_device(struct acpi_device *adev,
 				 const struct of_device_id *of_match_table)
@@ -1038,14 +1040,14 @@ static const struct acpi_device_id *__acpi_match_device(
 				return id;
 
 		/*
-		 * Next, check the special "PRP0001" ID and try to match the
+		 * Next, check ACPI_DT_NAMESPACE_HID and try to match the
 		 * "compatible" property if found.
 		 *
 		 * The id returned by the below is not valid, but the only
 		 * caller passing non-NULL of_ids here is only interested in
 		 * whether or not the return value is NULL.
 		 */
-		if (!strcmp("PRP0001", hwid->id)
+		if (!strcmp(ACPI_DT_NAMESPACE_HID, hwid->id)
 		    && acpi_of_match_device(device, of_ids))
 			return id;
 	}
@@ -2405,7 +2407,7 @@ static void acpi_default_enumeration(struct acpi_device *device)
 }
 
 static const struct acpi_device_id generic_device_ids[] = {
-	{"PRP0001", },
+	{ACPI_DT_NAMESPACE_HID, },
 	{"", },
 };
 
@@ -2413,8 +2415,8 @@ static int acpi_generic_device_attach(struct acpi_device *adev,
 				      const struct acpi_device_id *not_used)
 {
 	/*
-	 * Since PRP0001 is the only ID handled here, the test below can be
-	 * unconditional.
+	 * Since ACPI_DT_NAMESPACE_HID is the only ID handled here, the test
+	 * below can be unconditional.
 	 */
 	if (adev->data.of_compatible)
 		acpi_default_enumeration(adev);

commit 20dacb71ad283b9506ee7e01286a424999fb8309
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat May 16 01:55:35 2015 +0200

    ACPI / PM: Rework device power management to follow ACPI 6
    
    The ACPI 6 specification has made some changes in the device power
    management area.  In particular:
    
     * The D3hot power state is now supposed to be always available
       (instead of D3cold) and D3cold is only regarded as valid if the
       _PR3 object is present for the given device.
    
     * The required ordering of transitions into power states deeper than
       D0 is now such that for a transition into state Dx the _PSx method
       is supposed to be executed first, if present, and the states of
       the power resources the device depends on are supposed to be
       changed after that.
    
     * It is now explicitly forbidden to transition devices from
       lower-power (deeper) into higher-power (shallower) power states
       other than D0.
    
    Those changes have been made so the specification reflects the
    Windows' device power management code that the vast majority of
    systems using ACPI is validated against.
    
    To avoid artificial differences in ACPI device power management
    between Windows and Linux, modify the ACPI device power management
    code to follow the new specification.  Add comments explaining the
    code flow in some unclear places.
    
    This only may affect some real corner cases in which the OS behavior
    expected by the firmware is different from the Windows one, but that's
    quite unlikely.  The transition ordering change affects transitions
    to D1 and D2 which are rarely used (if at all) and into D3hot and
    D3cold for devices actually having _PR3, but those are likely to
    be validated against Windows anyway.  The other changes may affect
    code calling acpi_device_get_power() or acpi_device_update_power()
    where ACPI_STATE_D3_HOT may be returned instead of ACPI_STATE_D3_COLD
    (that's why the ACPI fan driver needs to be updated too) and since
    transitions into ACPI_STATE_D3_HOT may remove power now, it is better
    to avoid this one in acpi_pm_device_sleep_state() if the "no power
    off" PM QoS flag is set.
    
    The only existing user of acpi_device_can_poweroff() really cares
    about the case when _PR3 is present, so the change in that function
    should not cause any problems to happen too.
    
    A plus is that PCI_D3hot can be mapped to ACPI_STATE_D3_HOT
    now and the compatibility with older systems should be covered
    automatically.
    
    In any case, if any real problems result from this, it still will
    be better to follow the Windows' behavior (which now is reflected
    by the specification too) in general and handle the cases when it
    doesn't work via quirks.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 03141aa4ea95..ccf15d754448 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1766,15 +1766,9 @@ static void acpi_bus_init_power_state(struct acpi_device *device, int state)
 	if (acpi_has_method(device->handle, pathname))
 		ps->flags.explicit_set = 1;
 
-	/*
-	 * State is valid if there are means to put the device into it.
-	 * D3hot is only valid if _PR3 present.
-	 */
-	if (!list_empty(&ps->resources)
-	    || (ps->flags.explicit_set && state < ACPI_STATE_D3_HOT)) {
+	/* State is valid if there are means to put the device into it. */
+	if (!list_empty(&ps->resources) || ps->flags.explicit_set)
 		ps->flags.valid = 1;
-		ps->flags.os_accessible = 1;
-	}
 
 	ps->power = -1;		/* Unknown - driver assigned */
 	ps->latency = -1;	/* Unknown - driver assigned */
@@ -1810,21 +1804,13 @@ static void acpi_bus_get_power_flags(struct acpi_device *device)
 		acpi_bus_init_power_state(device, i);
 
 	INIT_LIST_HEAD(&device->power.states[ACPI_STATE_D3_COLD].resources);
+	if (!list_empty(&device->power.states[ACPI_STATE_D3_HOT].resources))
+		device->power.states[ACPI_STATE_D3_COLD].flags.valid = 1;
 
-	/* Set defaults for D0 and D3 states (always valid) */
+	/* Set defaults for D0 and D3hot states (always valid) */
 	device->power.states[ACPI_STATE_D0].flags.valid = 1;
 	device->power.states[ACPI_STATE_D0].power = 100;
-	device->power.states[ACPI_STATE_D3_COLD].flags.valid = 1;
-	device->power.states[ACPI_STATE_D3_COLD].power = 0;
-
-	/* Set D3cold's explicit_set flag if _PS3 exists. */
-	if (device->power.states[ACPI_STATE_D3_HOT].flags.explicit_set)
-		device->power.states[ACPI_STATE_D3_COLD].flags.explicit_set = 1;
-
-	/* Presence of _PS3 or _PRx means we can put the device into D3 cold */
-	if (device->power.states[ACPI_STATE_D3_HOT].flags.explicit_set ||
-			device->power.flags.power_resources)
-		device->power.states[ACPI_STATE_D3_COLD].flags.os_accessible = 1;
+	device->power.states[ACPI_STATE_D3_HOT].flags.valid = 1;
 
 	if (acpi_bus_init_power(device))
 		device->flags.power_manageable = 0;

commit 7d284352f9cbc032f2294024b1a6b5c06765c246
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Apr 24 02:18:01 2015 +0200

    ACPI / scan: Add a scan handler for PRP0001
    
    If the special PRP0001 device ID is present in the given device's list
    of ACPI/PNP IDs and the device has a valid "compatible" property in
    the _DSD, it should be enumerated using the default mechanism,
    unless some scan handlers match the IDs preceding PRP0001 in the
    device's list of ACPI/PNP IDs.  In addition to that, no scan handlers
    matching the IDs following PRP0001 in that list should be attached
    to the device.
    
    To make that happen, define a scan handler that will match PRP0001
    and trigger the default enumeration for the matching devices if the
    "compatible" property is present for them.
    
    Since that requires the check for platform_id and device->handler
    to be removed from acpi_default_enumeration(), move the fallback
    invocation of acpi_default_enumeration() to acpi_bus_attach()
    (after it's checked if there's a matching ACPI driver for the
    device), which is a better place to call it, and do the platform_id
    check in there too (device->handler is guaranteed to be unset at
    the point where the function is looking for a matching ACPI driver).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8d40467d37f9..03141aa4ea95 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2392,9 +2392,6 @@ static void acpi_default_enumeration(struct acpi_device *device)
 	struct list_head resource_list;
 	bool is_spi_i2c_slave = false;
 
-	if (!device->pnp.type.platform_id || device->handler)
-		return;
-
 	/*
 	 * Do not enemerate SPI/I2C slaves as they will be enuerated by their
 	 * respective parents.
@@ -2407,6 +2404,29 @@ static void acpi_default_enumeration(struct acpi_device *device)
 		acpi_create_platform_device(device);
 }
 
+static const struct acpi_device_id generic_device_ids[] = {
+	{"PRP0001", },
+	{"", },
+};
+
+static int acpi_generic_device_attach(struct acpi_device *adev,
+				      const struct acpi_device_id *not_used)
+{
+	/*
+	 * Since PRP0001 is the only ID handled here, the test below can be
+	 * unconditional.
+	 */
+	if (adev->data.of_compatible)
+		acpi_default_enumeration(adev);
+
+	return 1;
+}
+
+static struct acpi_scan_handler generic_device_handler = {
+	.ids = generic_device_ids,
+	.attach = acpi_generic_device_attach,
+};
+
 static int acpi_scan_attach_handler(struct acpi_device *device)
 {
 	struct acpi_hardware_id *hwid;
@@ -2432,8 +2452,6 @@ static int acpi_scan_attach_handler(struct acpi_device *device)
 				break;
 		}
 	}
-	if (!ret)
-		acpi_default_enumeration(device);
 
 	return ret;
 }
@@ -2475,6 +2493,9 @@ static void acpi_bus_attach(struct acpi_device *device)
 		ret = device_attach(&device->dev);
 		if (ret < 0)
 			return;
+
+		if (!ret && device->pnp.type.platform_id)
+			acpi_default_enumeration(device);
 	}
 	device->flags.visited = true;
 
@@ -2633,6 +2654,8 @@ int __init acpi_scan_init(void)
 	acpi_pnp_init();
 	acpi_int340x_thermal_init();
 
+	acpi_scan_add_handler(&generic_device_handler);
+
 	mutex_lock(&acpi_scan_lock);
 	/*
 	 * Enumerate devices in the ACPI namespace.

commit 4c533c801d1c9b5c38458a0e7516e0cf50643782
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 01:25:46 2015 +0200

    ACPI / scan: Annotate physical_node_lock in acpi_scan_is_offline()
    
    acpi_scan_is_offline() may be called under the physical_node_lock
    lock of the given device object's parent, so prevent lockdep from
    complaining about that by annotating that instance with
    SINGLE_DEPTH_NESTING.
    
    Fixes: caa73ea158de (ACPI / hotplug / driver core: Handle containers in a special way)
    Reported-and-tested-by: Xie XiuQi <xiexiuqi@huawei.com>
    Reviewed-by: Toshi Kani <toshi.kani@hp.com>
    Cc: 3.14+ <stable@vger.kernel.org> # 3.14+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 69bc0d888c01..8d40467d37f9 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -375,7 +375,11 @@ bool acpi_scan_is_offline(struct acpi_device *adev, bool uevent)
 	struct acpi_device_physical_node *pn;
 	bool offline = true;
 
-	mutex_lock(&adev->physical_node_lock);
+	/*
+	 * acpi_container_offline() calls this for all of the container's
+	 * children under the container's physical_node_lock lock.
+	 */
+	mutex_lock_nested(&adev->physical_node_lock, SINGLE_DEPTH_NESTING);
 
 	list_for_each_entry(pn, &adev->physical_node_list, node)
 		if (device_supports_offline(pn->dev) && !pn->dev->offline) {

commit 5f2e3274e527ec52413b43b5a9b30422eda4cdd2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Apr 13 21:35:51 2015 +0200

    ACPI / scan: Fix NULL pointer dereference in acpi_companion_match()
    
    Commit e1acdeb0e770 "ACPI / scan: Simplify acpi_match_device()"
    introduced code that may lead to a NULL pointer dereference when
    trying to unlock a mutex.  Fix that.
    
    Fixes: e1acdeb0e770 "ACPI / scan: Simplify acpi_match_device()"
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d2e3c3e3f9c9..69bc0d888c01 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -247,6 +247,7 @@ static int create_of_modalias(struct acpi_device *acpi_dev, char *modalias,
 static struct acpi_device *acpi_companion_match(const struct device *dev)
 {
 	struct acpi_device *adev;
+	struct mutex *physical_node_lock;
 
 	adev = ACPI_COMPANION(dev);
 	if (!adev)
@@ -255,7 +256,8 @@ static struct acpi_device *acpi_companion_match(const struct device *dev)
 	if (list_empty(&adev->pnp.ids))
 		return NULL;
 
-	mutex_lock(&adev->physical_node_lock);
+	physical_node_lock = &adev->physical_node_lock;
+	mutex_lock(physical_node_lock);
 	if (list_empty(&adev->physical_node_list)) {
 		adev = NULL;
 	} else {
@@ -266,7 +268,7 @@ static struct acpi_device *acpi_companion_match(const struct device *dev)
 		if (node->dev != dev)
 			adev = NULL;
 	}
-	mutex_unlock(&adev->physical_node_lock);
+	mutex_unlock(physical_node_lock);
 
 	return adev;
 }

commit 8765c5ba19490c9167fe0c4e05c2dfdcc39873a3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Apr 13 00:29:36 2015 +0200

    ACPI / scan: Rework modalias creation when "compatible" is present
    
    Currently, the ACPI modalias creation covers two mutually exclusive
    cases: If the PRP0001 device ID is present in the device's list of
    ACPI/PNP IDs and the "compatible" property is present in _DSD, the
    created modalias will follow the OF rules of modalias creation.
    Otherwise, ACPI rules are used.
    
    However, that is not really desirable, because the presence of PRP0001
    in the list of device IDs generally does not preclude using other
    ACPI/PNP IDs with that device and those other IDs may be of higher
    priority.  In those cases, the other IDs should take preference over
    PRP0001 and therefore they also should be present in the modalias.
    
    For this reason, rework the modalias creation for ACPI so that it
    shows both the ACPI-style and OF-style modalias strings if the
    device has a non-empty list of ACPI/PNP IDs (other than PRP0001)
    and a valid "compatible" property at the same time.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8f3adf924e83..d2e3c3e3f9c9 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -114,7 +114,12 @@ int acpi_scan_add_handler_with_hotplug(struct acpi_scan_handler *handler,
 	return 0;
 }
 
-/*
+/**
+ * create_pnp_modalias - Create hid/cid(s) string for modalias and uevent
+ * @acpi_dev: ACPI device object.
+ * @modalias: Buffer to print into.
+ * @size: Size of the buffer.
+ *
  * Creates hid/cid(s) string needed for modalias and uevent
  * e.g. on a device with hid:IBM0001 and cid:ACPI0001 you get:
  * char *modalias: "acpi:IBM0001:ACPI0001"
@@ -122,68 +127,98 @@ int acpi_scan_add_handler_with_hotplug(struct acpi_scan_handler *handler,
  *         -EINVAL: output error
  *         -ENOMEM: output is truncated
 */
-static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
-			   int size)
+static int create_pnp_modalias(struct acpi_device *acpi_dev, char *modalias,
+			       int size)
 {
 	int len;
 	int count;
 	struct acpi_hardware_id *id;
 
-	if (list_empty(&acpi_dev->pnp.ids))
-		return 0;
-
 	/*
-	 * If the device has PRP0001 we expose DT compatible modalias
-	 * instead in form of of:NnameTCcompatible.
+	 * Since we skip PRP0001 from the modalias below, 0 should be returned
+	 * if PRP0001 is the only ACPI/PNP ID in the device's list.
 	 */
-	if (acpi_dev->data.of_compatible) {
-		struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
-		const union acpi_object *of_compatible, *obj;
-		int i, nval;
-		char *c;
-
-		acpi_get_name(acpi_dev->handle, ACPI_SINGLE_NAME, &buf);
-		/* DT strings are all in lower case */
-		for (c = buf.pointer; *c != '\0'; c++)
-			*c = tolower(*c);
-
-		len = snprintf(modalias, size, "of:N%sT", (char *)buf.pointer);
-		ACPI_FREE(buf.pointer);
-
-		of_compatible = acpi_dev->data.of_compatible;
-		if (of_compatible->type == ACPI_TYPE_PACKAGE) {
-			nval = of_compatible->package.count;
-			obj = of_compatible->package.elements;
-		} else { /* Must be ACPI_TYPE_STRING. */
-			nval = 1;
-			obj = of_compatible;
-		}
-		for (i = 0; i < nval; i++, obj++) {
-			count = snprintf(&modalias[len], size, "C%s",
-					 obj->string.pointer);
-			if (count < 0)
-				return -EINVAL;
-			if (count >= size)
-				return -ENOMEM;
-
-			len += count;
-			size -= count;
-		}
-	} else {
-		len = snprintf(modalias, size, "acpi:");
-		size -= len;
+	count = 0;
+	list_for_each_entry(id, &acpi_dev->pnp.ids, list)
+		if (strcmp(id->id, "PRP0001"))
+			count++;
 
-		list_for_each_entry(id, &acpi_dev->pnp.ids, list) {
-			count = snprintf(&modalias[len], size, "%s:", id->id);
-			if (count < 0)
-				return -EINVAL;
-			if (count >= size)
-				return -ENOMEM;
-			len += count;
-			size -= count;
-		}
+	if (!count)
+		return 0;
+
+	len = snprintf(modalias, size, "acpi:");
+	if (len <= 0)
+		return len;
+
+	size -= len;
+
+	list_for_each_entry(id, &acpi_dev->pnp.ids, list) {
+		if (!strcmp(id->id, "PRP0001"))
+			continue;
+
+		count = snprintf(&modalias[len], size, "%s:", id->id);
+		if (count < 0)
+			return -EINVAL;
+
+		if (count >= size)
+			return -ENOMEM;
+
+		len += count;
+		size -= count;
 	}
+	modalias[len] = '\0';
+	return len;
+}
+
+/**
+ * create_of_modalias - Creates DT compatible string for modalias and uevent
+ * @acpi_dev: ACPI device object.
+ * @modalias: Buffer to print into.
+ * @size: Size of the buffer.
+ *
+ * Expose DT compatible modalias as of:NnameTCcompatible.  This function should
+ * only be called for devices having PRP0001 in their list of ACPI/PNP IDs.
+ */
+static int create_of_modalias(struct acpi_device *acpi_dev, char *modalias,
+			      int size)
+{
+	struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
+	const union acpi_object *of_compatible, *obj;
+	int len, count;
+	int i, nval;
+	char *c;
 
+	acpi_get_name(acpi_dev->handle, ACPI_SINGLE_NAME, &buf);
+	/* DT strings are all in lower case */
+	for (c = buf.pointer; *c != '\0'; c++)
+		*c = tolower(*c);
+
+	len = snprintf(modalias, size, "of:N%sT", (char *)buf.pointer);
+	ACPI_FREE(buf.pointer);
+
+	if (len <= 0)
+		return len;
+
+	of_compatible = acpi_dev->data.of_compatible;
+	if (of_compatible->type == ACPI_TYPE_PACKAGE) {
+		nval = of_compatible->package.count;
+		obj = of_compatible->package.elements;
+	} else { /* Must be ACPI_TYPE_STRING. */
+		nval = 1;
+		obj = of_compatible;
+	}
+	for (i = 0; i < nval; i++, obj++) {
+		count = snprintf(&modalias[len], size, "C%s",
+				 obj->string.pointer);
+		if (count < 0)
+			return -EINVAL;
+
+		if (count >= size)
+			return -ENOMEM;
+
+		len += count;
+		size -= count;
+	}
 	modalias[len] = '\0';
 	return len;
 }
@@ -236,61 +271,100 @@ static struct acpi_device *acpi_companion_match(const struct device *dev)
 	return adev;
 }
 
-/*
- * Creates uevent modalias field for ACPI enumerated devices.
- * Because the other buses does not support ACPI HIDs & CIDs.
- * e.g. for a device with hid:IBM0001 and cid:ACPI0001 you get:
- * "acpi:IBM0001:ACPI0001"
- */
-int acpi_device_uevent_modalias(struct device *dev, struct kobj_uevent_env *env)
+static int __acpi_device_uevent_modalias(struct acpi_device *adev,
+					 struct kobj_uevent_env *env)
 {
 	int len;
 
-	if (!acpi_companion_match(dev))
+	if (!adev)
 		return -ENODEV;
 
+	if (list_empty(&adev->pnp.ids))
+		return 0;
+
 	if (add_uevent_var(env, "MODALIAS="))
 		return -ENOMEM;
-	len = create_modalias(ACPI_COMPANION(dev), &env->buf[env->buflen - 1],
-				sizeof(env->buf) - env->buflen);
-	if (len <= 0)
+
+	len = create_pnp_modalias(adev, &env->buf[env->buflen - 1],
+				  sizeof(env->buf) - env->buflen);
+	if (len < 0)
 		return len;
+
+	env->buflen += len;
+	if (!adev->data.of_compatible)
+		return 0;
+
+	if (len > 0 && add_uevent_var(env, "MODALIAS="))
+		return -ENOMEM;
+
+	len = create_of_modalias(adev, &env->buf[env->buflen - 1],
+				 sizeof(env->buf) - env->buflen);
+	if (len < 0)
+		return len;
+
 	env->buflen += len;
+
 	return 0;
 }
-EXPORT_SYMBOL_GPL(acpi_device_uevent_modalias);
 
 /*
- * Creates modalias sysfs attribute for ACPI enumerated devices.
+ * Creates uevent modalias field for ACPI enumerated devices.
  * Because the other buses does not support ACPI HIDs & CIDs.
  * e.g. for a device with hid:IBM0001 and cid:ACPI0001 you get:
  * "acpi:IBM0001:ACPI0001"
  */
-int acpi_device_modalias(struct device *dev, char *buf, int size)
+int acpi_device_uevent_modalias(struct device *dev, struct kobj_uevent_env *env)
 {
-	int len;
+	return __acpi_device_uevent_modalias(acpi_companion_match(dev), env);
+}
+EXPORT_SYMBOL_GPL(acpi_device_uevent_modalias);
+
+static int __acpi_device_modalias(struct acpi_device *adev, char *buf, int size)
+{
+	int len, count;
 
-	if (!acpi_companion_match(dev))
+	if (!adev)
 		return -ENODEV;
 
-	len = create_modalias(ACPI_COMPANION(dev), buf, size -1);
-	if (len <= 0)
+	if (list_empty(&adev->pnp.ids))
+		return 0;
+
+	len = create_pnp_modalias(adev, buf, size - 1);
+	if (len < 0) {
 		return len;
-	buf[len++] = '\n';
+	} else if (len > 0) {
+		buf[len++] = '\n';
+		size -= len;
+	}
+	if (!adev->data.of_compatible)
+		return len;
+
+	count = create_of_modalias(adev, buf + len, size - 1);
+	if (count < 0) {
+		return count;
+	} else if (count > 0) {
+		len += count;
+		buf[len++] = '\n';
+	}
+
 	return len;
 }
+
+/*
+ * Creates modalias sysfs attribute for ACPI enumerated devices.
+ * Because the other buses does not support ACPI HIDs & CIDs.
+ * e.g. for a device with hid:IBM0001 and cid:ACPI0001 you get:
+ * "acpi:IBM0001:ACPI0001"
+ */
+int acpi_device_modalias(struct device *dev, char *buf, int size)
+{
+	return __acpi_device_modalias(acpi_companion_match(dev), buf, size);
+}
 EXPORT_SYMBOL_GPL(acpi_device_modalias);
 
 static ssize_t
 acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, char *buf) {
-	struct acpi_device *acpi_dev = to_acpi_device(dev);
-	int len;
-
-	len = create_modalias(acpi_dev, buf, 1024);
-	if (len <= 0)
-		return len;
-	buf[len++] = '\n';
-	return len;
+	return __acpi_device_modalias(to_acpi_device(dev), buf, 1024);
 }
 static DEVICE_ATTR(modalias, 0444, acpi_device_modalias_show, NULL);
 
@@ -1046,20 +1120,7 @@ static int acpi_bus_match(struct device *dev, struct device_driver *drv)
 
 static int acpi_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
-	struct acpi_device *acpi_dev = to_acpi_device(dev);
-	int len;
-
-	if (list_empty(&acpi_dev->pnp.ids))
-		return 0;
-
-	if (add_uevent_var(env, "MODALIAS="))
-		return -ENOMEM;
-	len = create_modalias(acpi_dev, &env->buf[env->buflen - 1],
-			      sizeof(env->buf) - env->buflen);
-	if (len <= 0)
-		return len;
-	env->buflen += len;
-	return 0;
+	return __acpi_device_uevent_modalias(to_acpi_device(dev), env);
 }
 
 static void acpi_device_notify(acpi_handle handle, u32 event, void *data)

commit 2b9c698efa58bf7d9a0d3d3b28115cf9e55ca818
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Apr 10 16:07:51 2015 +0200

    ACPI / scan: Take the PRP0001 position in the list of IDs into account
    
    If the special PRP0001 device ID is present in a device's _CID list,
    it should not prevent any ACPI/PNP IDs preceding it in the device's
    list of identifiers from being matched first.  That is, only if none
    of the IDs preceding PRP0001 in the device's PNP/ACPI IDs list
    matches the IDs recognized by the driver, the driver's list of
    "compatible" IDs should be matched against the device's "compatible"
    property, if present.
    
    In addition to that, drivers can provide both acpi_match_table and
    of_match_table at the same time and the of_compatible matching
    should be used in that case too if PRP0001 is present in the
    device's list of identifiers.
    
    To make that happen, rework acpi_driver_match_device() to do the
    "compatible" property check in addition to matching the driver's
    list of ACPI IDs against the device's one.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b4d5549265ed..8f3adf924e83 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -895,8 +895,51 @@ static void acpi_device_remove_files(struct acpi_device *dev)
 			ACPI Bus operations
    -------------------------------------------------------------------------- */
 
+/**
+ * acpi_of_match_device - Match device object using the "compatible" property.
+ * @adev: ACPI device object to match.
+ * @of_match_table: List of device IDs to match against.
+ *
+ * If @dev has an ACPI companion which has the special PRP0001 device ID in its
+ * list of identifiers and a _DSD object with the "compatible" property, use
+ * that property to match against the given list of identifiers.
+ */
+static bool acpi_of_match_device(struct acpi_device *adev,
+				 const struct of_device_id *of_match_table)
+{
+	const union acpi_object *of_compatible, *obj;
+	int i, nval;
+
+	if (!adev)
+		return false;
+
+	of_compatible = adev->data.of_compatible;
+	if (!of_match_table || !of_compatible)
+		return false;
+
+	if (of_compatible->type == ACPI_TYPE_PACKAGE) {
+		nval = of_compatible->package.count;
+		obj = of_compatible->package.elements;
+	} else { /* Must be ACPI_TYPE_STRING. */
+		nval = 1;
+		obj = of_compatible;
+	}
+	/* Now we can look for the driver DT compatible strings */
+	for (i = 0; i < nval; i++, obj++) {
+		const struct of_device_id *id;
+
+		for (id = of_match_table; id->compatible[0]; id++)
+			if (!strcasecmp(obj->string.pointer, id->compatible))
+				return true;
+	}
+
+	return false;
+}
+
 static const struct acpi_device_id *__acpi_match_device(
-	struct acpi_device *device, const struct acpi_device_id *ids)
+	struct acpi_device *device,
+	const struct acpi_device_id *ids,
+	const struct of_device_id *of_ids)
 {
 	const struct acpi_device_id *id;
 	struct acpi_hardware_id *hwid;
@@ -908,11 +951,24 @@ static const struct acpi_device_id *__acpi_match_device(
 	if (!device || !device->status.present)
 		return NULL;
 
-	for (id = ids; id->id[0]; id++)
-		list_for_each_entry(hwid, &device->pnp.ids, list)
+	list_for_each_entry(hwid, &device->pnp.ids, list) {
+		/* First, check the ACPI/PNP IDs provided by the caller. */
+		for (id = ids; id->id[0]; id++)
 			if (!strcmp((char *) id->id, hwid->id))
 				return id;
 
+		/*
+		 * Next, check the special "PRP0001" ID and try to match the
+		 * "compatible" property if found.
+		 *
+		 * The id returned by the below is not valid, but the only
+		 * caller passing non-NULL of_ids here is only interested in
+		 * whether or not the return value is NULL.
+		 */
+		if (!strcmp("PRP0001", hwid->id)
+		    && acpi_of_match_device(device, of_ids))
+			return id;
+	}
 	return NULL;
 }
 
@@ -930,67 +986,26 @@ static const struct acpi_device_id *__acpi_match_device(
 const struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,
 					       const struct device *dev)
 {
-	return __acpi_match_device(acpi_companion_match(dev), ids);
+	return __acpi_match_device(acpi_companion_match(dev), ids, NULL);
 }
 EXPORT_SYMBOL_GPL(acpi_match_device);
 
 int acpi_match_device_ids(struct acpi_device *device,
 			  const struct acpi_device_id *ids)
 {
-	return __acpi_match_device(device, ids) ? 0 : -ENOENT;
+	return __acpi_match_device(device, ids, NULL) ? 0 : -ENOENT;
 }
 EXPORT_SYMBOL(acpi_match_device_ids);
 
-/**
- * acpi_of_match_device - Match device using the "compatible" property.
- * @dev: Device to match.
- * @of_match_table: List of device IDs to match against.
- *
- * If @dev has an ACPI companion which has the special PRP0001 device ID in its
- * list of identifiers and a _DSD object with the "compatible" property, use
- * that property to match against the given list of identifiers.
- */
-static bool acpi_of_match_device(struct device *dev,
-				 const struct of_device_id *of_match_table)
-{
-	const union acpi_object *of_compatible, *obj;
-	struct acpi_device *adev;
-	int i, nval;
-
-	adev = ACPI_COMPANION(dev);
-	if (!adev)
-		return false;
-
-	of_compatible = adev->data.of_compatible;
-	if (!of_match_table || !of_compatible)
-		return false;
-
-	if (of_compatible->type == ACPI_TYPE_PACKAGE) {
-		nval = of_compatible->package.count;
-		obj = of_compatible->package.elements;
-	} else { /* Must be ACPI_TYPE_STRING. */
-		nval = 1;
-		obj = of_compatible;
-	}
-	/* Now we can look for the driver DT compatible strings */
-	for (i = 0; i < nval; i++, obj++) {
-		const struct of_device_id *id;
-
-		for (id = of_match_table; id->compatible[0]; id++)
-			if (!strcasecmp(obj->string.pointer, id->compatible))
-				return true;
-	}
-
-	return false;
-}
-
 bool acpi_driver_match_device(struct device *dev,
 			      const struct device_driver *drv)
 {
 	if (!drv->acpi_match_table)
-		return acpi_of_match_device(dev, drv->of_match_table);
+		return acpi_of_match_device(ACPI_COMPANION(dev),
+					    drv->of_match_table);
 
-	return !!acpi_match_device(drv->acpi_match_table, dev);
+	return !!__acpi_match_device(acpi_companion_match(dev),
+				     drv->acpi_match_table, drv->of_match_table);
 }
 EXPORT_SYMBOL_GPL(acpi_driver_match_device);
 

commit e1acdeb0e7707f4220aa14ad6739102ba26e07c0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Apr 10 16:07:38 2015 +0200

    ACPI / scan: Simplify acpi_match_device()
    
    Redefine acpi_companion_match() to return an ACPI device object
    pointer instead of a bool and use it to remove some redundant code
    from acpi_match_device().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 99f97ac64aa4..b4d5549265ed 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -194,7 +194,8 @@ static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
  *
  * Check if the given device has an ACPI companion and if that companion has
  * a valid list of PNP IDs, and if the device is the first (primary) physical
- * device associated with it.
+ * device associated with it.  Return the companion pointer if that's the case
+ * or NULL otherwise.
  *
  * If multiple physical devices are attached to a single ACPI companion, we need
  * to be careful.  The usage scenario for this kind of relationship is that all
@@ -208,31 +209,31 @@ static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
  * resources available from it but they will be matched normally using functions
  * provided by their bus types (and analogously for their modalias).
  */
-static bool acpi_companion_match(const struct device *dev)
+static struct acpi_device *acpi_companion_match(const struct device *dev)
 {
 	struct acpi_device *adev;
-	bool ret;
 
 	adev = ACPI_COMPANION(dev);
 	if (!adev)
-		return false;
+		return NULL;
 
 	if (list_empty(&adev->pnp.ids))
-		return false;
+		return NULL;
 
 	mutex_lock(&adev->physical_node_lock);
 	if (list_empty(&adev->physical_node_list)) {
-		ret = false;
+		adev = NULL;
 	} else {
 		const struct acpi_device_physical_node *node;
 
 		node = list_first_entry(&adev->physical_node_list,
 					struct acpi_device_physical_node, node);
-		ret = node->dev == dev;
+		if (node->dev != dev)
+			adev = NULL;
 	}
 	mutex_unlock(&adev->physical_node_lock);
 
-	return ret;
+	return adev;
 }
 
 /*
@@ -904,7 +905,7 @@ static const struct acpi_device_id *__acpi_match_device(
 	 * If the device is not present, it is unnecessary to load device
 	 * driver for it.
 	 */
-	if (!device->status.present)
+	if (!device || !device->status.present)
 		return NULL;
 
 	for (id = ids; id->id[0]; id++)
@@ -929,16 +930,7 @@ static const struct acpi_device_id *__acpi_match_device(
 const struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,
 					       const struct device *dev)
 {
-	struct acpi_device *adev;
-	acpi_handle handle = ACPI_HANDLE(dev);
-
-	if (!ids || !handle || acpi_bus_get_device(handle, &adev))
-		return NULL;
-
-	if (!acpi_companion_match(dev))
-		return NULL;
-
-	return __acpi_match_device(adev, ids);
+	return __acpi_match_device(acpi_companion_match(dev), ids);
 }
 EXPORT_SYMBOL_GPL(acpi_match_device);
 

commit 54fe9ce385d499fe5a2bb0c68f092c97dad9365c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Apr 10 16:07:30 2015 +0200

    ACPI / scan: Generalize of_compatible matching
    
    Redefine the function used for matching the device's "compatible"
    property against a given list of "compatible" strings to take
    a pointer to that list instead of a driver object pointer to
    make it more general.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 3e5a2768c3b4..99f97ac64aa4 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -949,9 +949,17 @@ int acpi_match_device_ids(struct acpi_device *device,
 }
 EXPORT_SYMBOL(acpi_match_device_ids);
 
-/* Performs match against special "PRP0001" shoehorn ACPI ID */
-static bool acpi_of_driver_match_device(struct device *dev,
-					const struct device_driver *drv)
+/**
+ * acpi_of_match_device - Match device using the "compatible" property.
+ * @dev: Device to match.
+ * @of_match_table: List of device IDs to match against.
+ *
+ * If @dev has an ACPI companion which has the special PRP0001 device ID in its
+ * list of identifiers and a _DSD object with the "compatible" property, use
+ * that property to match against the given list of identifiers.
+ */
+static bool acpi_of_match_device(struct device *dev,
+				 const struct of_device_id *of_match_table)
 {
 	const union acpi_object *of_compatible, *obj;
 	struct acpi_device *adev;
@@ -962,7 +970,7 @@ static bool acpi_of_driver_match_device(struct device *dev,
 		return false;
 
 	of_compatible = adev->data.of_compatible;
-	if (!drv->of_match_table || !of_compatible)
+	if (!of_match_table || !of_compatible)
 		return false;
 
 	if (of_compatible->type == ACPI_TYPE_PACKAGE) {
@@ -976,7 +984,7 @@ static bool acpi_of_driver_match_device(struct device *dev,
 	for (i = 0; i < nval; i++, obj++) {
 		const struct of_device_id *id;
 
-		for (id = drv->of_match_table; id->compatible[0]; id++)
+		for (id = of_match_table; id->compatible[0]; id++)
 			if (!strcasecmp(obj->string.pointer, id->compatible))
 				return true;
 	}
@@ -988,7 +996,7 @@ bool acpi_driver_match_device(struct device *dev,
 			      const struct device_driver *drv)
 {
 	if (!drv->acpi_match_table)
-		return acpi_of_driver_match_device(dev, drv);
+		return acpi_of_match_device(dev, drv->of_match_table);
 
 	return !!acpi_match_device(drv->acpi_match_table, dev);
 }

commit fd9caef4e222a2c5e7ed63050780d215a6a263f3
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Fri Mar 13 13:52:50 2015 +0800

    ACPI / scan: fix fixed event handler return value
    
    The fixed event handler should return a value that is either 0 or 1
    meanning if the event is handled or not, instead of an acpi_status to
    mean if the handler runs well or not.
    
    Suggested-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index bbca7830e18a..3e5a2768c3b4 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1062,10 +1062,10 @@ static void acpi_device_notify_fixed(void *data)
 	acpi_device_notify(NULL, ACPI_FIXED_HARDWARE_EVENT, device);
 }
 
-static acpi_status acpi_device_fixed_event(void *data)
+static u32 acpi_device_fixed_event(void *data)
 {
 	acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_device_notify_fixed, data);
-	return AE_OK;
+	return ACPI_INTERRUPT_HANDLED;
 }
 
 static int acpi_device_install_notify_handler(struct acpi_device *device)

commit 92082a8886f30a1c492a31ac4b5a4966bb64b1a6
Author: Ken Xue <Ken.Xue@amd.com>
Date:   Fri Feb 6 08:27:51 2015 +0800

    ACPI: add AMD ACPI2Platform device support for x86 system
    
    This new feature is to interpret AMD specific ACPI device to
    platform device such as I2C, UART, GPIO found on AMD CZ and
    later chipsets. It based on example intel LPSS. Now, it can
    support AMD I2C, UART and GPIO.
    
    Signed-off-by: Ken Xue <Ken.Xue@amd.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index dc4d8960684a..bbca7830e18a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2544,6 +2544,7 @@ int __init acpi_scan_init(void)
 	acpi_pci_link_init();
 	acpi_processor_init();
 	acpi_lpss_init();
+	acpi_apd_init();
 	acpi_cmos_rtc_init();
 	acpi_container_init();
 	acpi_memory_hotplug_init();

commit 1b1f3e1699a9886f1070f94171097ab4ccdbfc95
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 1 23:38:28 2015 +0100

    ACPI / PM: Fix PM initialization for devices that are not present
    
    If an ACPI device object whose _STA returns 0 (not present and not
    functional) has _PR0 or _PS0, its power_manageable flag will be set
    and acpi_bus_init_power() will return 0 for it.  Consequently, if
    such a device object is passed to the ACPI device PM functions, they
    will attempt to carry out the requested operation on the device,
    although they should not do that for devices that are not present.
    
    To fix that problem make acpi_bus_init_power() return an error code
    for devices that are not present which will cause power_manageable to
    be cleared for them as appropriate in acpi_bus_get_power_flags().
    However, the lists of power resources should not be freed for the
    device in that case, so modify acpi_bus_get_power_flags() to keep
    those lists even if acpi_bus_init_power() returns an error.
    Accordingly, when deciding whether or not the lists of power
    resources need to be freed, acpi_free_power_resources_lists()
    should check the power.flags.power_resources flag instead of
    flags.power_manageable, so make that change too.
    
    Furthermore, if acpi_bus_attach() sees that flags.initialized is
    unset for the given device, it should reset the power management
    settings of the device and re-initialize them from scratch instead
    of relying on the previous settings (the device may have appeared
    after being not present previously, for example), so make it use
    the 'valid' flag of the D0 power state as the initial value of
    flags.power_manageable for it and call acpi_bus_init_power() to
    discover its current power state.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: 3.10+ <stable@vger.kernel.org> # 3.10+

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 16914cc30882..dc4d8960684a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1001,7 +1001,7 @@ static void acpi_free_power_resources_lists(struct acpi_device *device)
 	if (device->wakeup.flags.valid)
 		acpi_power_resources_list_free(&device->wakeup.resources);
 
-	if (!device->flags.power_manageable)
+	if (!device->power.flags.power_resources)
 		return;
 
 	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3_HOT; i++) {
@@ -1744,10 +1744,8 @@ static void acpi_bus_get_power_flags(struct acpi_device *device)
 			device->power.flags.power_resources)
 		device->power.states[ACPI_STATE_D3_COLD].flags.os_accessible = 1;
 
-	if (acpi_bus_init_power(device)) {
-		acpi_free_power_resources_lists(device);
+	if (acpi_bus_init_power(device))
 		device->flags.power_manageable = 0;
-	}
 }
 
 static void acpi_bus_get_flags(struct acpi_device *device)
@@ -2371,13 +2369,18 @@ static void acpi_bus_attach(struct acpi_device *device)
 	/* Skip devices that are not present. */
 	if (!acpi_device_is_present(device)) {
 		device->flags.visited = false;
+		device->flags.power_manageable = 0;
 		return;
 	}
 	if (device->handler)
 		goto ok;
 
 	if (!device->flags.initialized) {
-		acpi_bus_update_power(device, NULL);
+		device->flags.power_manageable =
+			device->power.states[ACPI_STATE_D0].flags.valid;
+		if (acpi_bus_init_power(device))
+			device->flags.power_manageable = 0;
+
 		device->flags.initialized = true;
 	}
 	device->flags.visited = false;

commit be10f60d29433f712bf0887431efb80975e64438
Merge: ae5056e8573c 80167a24a274 c48cf1b9dd8f 175f8e2650f7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Dec 18 18:42:56 2014 +0100

    Merge branches 'acpi-scan', 'acpi-utils' and 'acpi-pm'
    
    * acpi-scan:
      ACPI / scan: Change the level of _DEP-related messages to KERN_DEBUG
    
    * acpi-utils:
      ACPI / utils: Drop error messages from acpi_evaluate_reference()
    
    * acpi-pm:
      ACPI / PM: Do not disable wakeup GPEs that have not been enabled

commit 80167a24a27449c06fbbfb1b0f4a5b965c41b428
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 12 22:48:44 2014 +0100

    ACPI / scan: Change the level of _DEP-related messages to KERN_DEBUG
    
    Two _DEP-related failure messages are printed as dev_err() which is
    unnecessary and annoying.  Use dev_dbg() to print them.
    
    While at it, one of the messages should actually say it is related
    to _DEP, so modify it to that effect.
    
    Fixes: 40e7fcb19293 (ACPI: Add _DEP support to fix battery issue on Asus T100TA)
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 00189ad63c8f..d838b2f83e21 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2107,7 +2107,7 @@ static void acpi_device_dep_initialize(struct acpi_device *adev)
 	status = acpi_evaluate_reference(adev->handle, "_DEP", NULL,
 					&dep_devices);
 	if (ACPI_FAILURE(status)) {
-		dev_err(&adev->dev, "Failed to evaluate _DEP.\n");
+		dev_dbg(&adev->dev, "Failed to evaluate _DEP.\n");
 		return;
 	}
 
@@ -2117,7 +2117,7 @@ static void acpi_device_dep_initialize(struct acpi_device *adev)
 
 		status = acpi_get_object_info(dep_devices.handles[i], &info);
 		if (ACPI_FAILURE(status)) {
-			dev_err(&adev->dev, "Error reading device info\n");
+			dev_dbg(&adev->dev, "Error reading _DEP device info\n");
 			continue;
 		}
 

commit 69bad361e69ac0e9f96865f405439e7cbd8c0136
Merge: 1b07db3178ba 40e7fcb19293 c52fa70c79ac bb32baf76e56 6fd8050a3547
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Dec 8 19:52:16 2014 +0100

    Merge branches 'acpi-scan', 'acpi-pm', 'acpi-lpss' and 'acpi-processor'
    
    * acpi-scan:
      ACPI: Add _DEP support to fix battery issue on Asus T100TA
    
    * acpi-pm:
      ACPI / sleep: Drain outstanding events after disabling multiple GPEs
      ACPI / PM: Fixed a typo in a comment
    
    * acpi-lpss:
      dmaengine: dw: enable runtime PM
      ACPI / LPSS: introduce a 'proxy' device to power on LPSS for DMA
      ACPI / LPSS: allow to use specific PM domain during ->probe()
      ACPI / LPSS: add all LPSS devices to the specific power domain
    
    * acpi-processor:
      ACPI / cpuidle: avoid assigning signed errno to acpi_status
      ACPI / processor: remove unused variabled from acpi_processor_power structure
      ACPI / processor: Update the comments in processor.h

commit 40e7fcb19293cbdff02c74cb0668413480f82ea1
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Sun Nov 23 21:22:54 2014 +0800

    ACPI: Add _DEP support to fix battery issue on Asus T100TA
    
    ACPI 5.0 introduces _DEP (Operation Region Dependencies) to designate
    device objects that OSPM should assign a higher priority in start
    ordering due to future operation region accesses.
    
    On Asus T100TA, ACPI battery info are read from a I2C slave device via
    I2C operation region. Before I2C operation region handler is installed,
    battery _STA always returns 0. There is a _DEP method of designating
    start order under battery device node.
    
    This patch is to implement _DEP feature to fix battery issue on the
    Asus T100TA.  Introducing acpi_dep_list and adding dep_unmet count
    in struct acpi_device. During ACPI namespace scan, create struct
    acpi_dep_data for a valid pair of master (device pointed to by _DEP)/
    slave(device with _DEP), record master's and slave's ACPI handle in
    it and put it into acpi_dep_list. The dep_unmet count will increase
    by one if there is a device under its _DEP. Driver's probe() should
    return EPROBE_DEFER when find dep_unmet is larger than 0. When I2C
    operation region handler is installed, remove all struct acpi_dep_data
    on the acpi_dep_list whose master is pointed to I2C host controller
    and decrease slave's dep_unmet. When dep_unmet decreases to 0, all
    _DEP conditions are met and then do acpi_bus_attach() for the device
    in order to resolve battery _STA issue on the Asus T100TA.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=69011
    Tested-by: Jan-Michael Brummer <jan.brummer@tabos.org>
    Tested-by: Adam Williamson <adamw@happyassassin.net>
    Tested-by: Michael Shigorin <shigorin@gmail.com>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 0476e90b2091..00189ad63c8f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -36,6 +36,8 @@ bool acpi_force_hot_remove;
 
 static const char *dummy_hid = "device";
 
+static LIST_HEAD(acpi_dep_list);
+static DEFINE_MUTEX(acpi_dep_list_lock);
 static LIST_HEAD(acpi_bus_id_list);
 static DEFINE_MUTEX(acpi_scan_lock);
 static LIST_HEAD(acpi_scan_handlers_list);
@@ -43,6 +45,12 @@ DEFINE_MUTEX(acpi_device_lock);
 LIST_HEAD(acpi_wakeup_device_list);
 static DEFINE_MUTEX(acpi_hp_context_lock);
 
+struct acpi_dep_data {
+	struct list_head node;
+	acpi_handle master;
+	acpi_handle slave;
+};
+
 struct acpi_device_bus_id{
 	char bus_id[15];
 	unsigned int instance_no;
@@ -2086,6 +2094,59 @@ static void acpi_scan_init_hotplug(struct acpi_device *adev)
 	}
 }
 
+static void acpi_device_dep_initialize(struct acpi_device *adev)
+{
+	struct acpi_dep_data *dep;
+	struct acpi_handle_list dep_devices;
+	acpi_status status;
+	int i;
+
+	if (!acpi_has_method(adev->handle, "_DEP"))
+		return;
+
+	status = acpi_evaluate_reference(adev->handle, "_DEP", NULL,
+					&dep_devices);
+	if (ACPI_FAILURE(status)) {
+		dev_err(&adev->dev, "Failed to evaluate _DEP.\n");
+		return;
+	}
+
+	for (i = 0; i < dep_devices.count; i++) {
+		struct acpi_device_info *info;
+		int skip;
+
+		status = acpi_get_object_info(dep_devices.handles[i], &info);
+		if (ACPI_FAILURE(status)) {
+			dev_err(&adev->dev, "Error reading device info\n");
+			continue;
+		}
+
+		/*
+		 * Skip the dependency of Windows System Power
+		 * Management Controller
+		 */
+		skip = info->valid & ACPI_VALID_HID &&
+			!strcmp(info->hardware_id.string, "INT3396");
+
+		kfree(info);
+
+		if (skip)
+			continue;
+
+		dep = kzalloc(sizeof(struct acpi_dep_data), GFP_KERNEL);
+		if (!dep)
+			return;
+
+		dep->master = dep_devices.handles[i];
+		dep->slave  = adev->handle;
+		adev->dep_unmet++;
+
+		mutex_lock(&acpi_dep_list_lock);
+		list_add_tail(&dep->node , &acpi_dep_list);
+		mutex_unlock(&acpi_dep_list_lock);
+	}
+}
+
 static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 				      void *not_used, void **return_value)
 {
@@ -2112,6 +2173,7 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 		return AE_CTRL_DEPTH;
 
 	acpi_scan_init_hotplug(device);
+	acpi_device_dep_initialize(device);
 
  out:
 	if (!*return_value)
@@ -2232,6 +2294,29 @@ static void acpi_bus_attach(struct acpi_device *device)
 		device->handler->hotplug.notify_online(device);
 }
 
+void acpi_walk_dep_device_list(acpi_handle handle)
+{
+	struct acpi_dep_data *dep, *tmp;
+	struct acpi_device *adev;
+
+	mutex_lock(&acpi_dep_list_lock);
+	list_for_each_entry_safe(dep, tmp, &acpi_dep_list, node) {
+		if (dep->master == handle) {
+			acpi_bus_get_device(dep->slave, &adev);
+			if (!adev)
+				continue;
+
+			adev->dep_unmet--;
+			if (!adev->dep_unmet)
+				acpi_bus_attach(adev);
+			list_del(&dep->node);
+			kfree(dep);
+		}
+	}
+	mutex_unlock(&acpi_dep_list_lock);
+}
+EXPORT_SYMBOL_GPL(acpi_walk_dep_device_list);
+
 /**
  * acpi_bus_scan - Add ACPI device node objects in a given namespace scope.
  * @handle: Root of the namespace scope to scan.

commit 8a0662d9ed2968e1186208336a8e1fab3fdfea63
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Nov 4 14:03:59 2014 +0100

    Driver core: Unified interface for firmware node properties
    
    Add new generic routines are provided for retrieving properties from
    device description objects in the platform firmware in case there are
    no struct device objects for them (either those objects have not been
    created yet or they do not exist at all).
    
    The following functions are provided:
    
    fwnode_property_present()
    fwnode_property_read_u8()
    fwnode_property_read_u16()
    fwnode_property_read_u32()
    fwnode_property_read_u64()
    fwnode_property_read_string()
    fwnode_property_read_u8_array()
    fwnode_property_read_u16_array()
    fwnode_property_read_u32_array()
    fwnode_property_read_u64_array()
    fwnode_property_read_string_array()
    
    in analogy with the corresponding functions for struct device added
    previously.  For all of them, the first argument is a pointer to struct
    fwnode_handle (new type) that allows a device description object
    (depending on what platform firmware interface is in use) to be
    obtained.
    
    Add a new macro device_for_each_child_node() for iterating over the
    children of the device description object associated with a given
    device and a new function device_get_child_node_count() returning the
    number of a given device's child nodes.
    
    The interface covers both ACPI and Device Trees.
    
    Suggested-by: Grant Likely <grant.likely@linaro.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 3a8f66444532..9cb5cca3cfe3 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1389,6 +1389,26 @@ int acpi_device_add(struct acpi_device *device,
 	return result;
 }
 
+struct acpi_device *acpi_get_next_child(struct device *dev,
+					struct acpi_device *child)
+{
+	struct acpi_device *adev = ACPI_COMPANION(dev);
+	struct list_head *head, *next;
+
+	if (!adev)
+		return NULL;
+
+	head = &adev->children;
+	if (list_empty(head))
+		return NULL;
+
+	if (!child)
+		return list_first_entry(head, struct acpi_device, node);
+
+	next = child->node.next;
+	return next == head ? NULL : list_entry(next, struct acpi_device, node);
+}
+
 /* --------------------------------------------------------------------------
                                  Driver Management
    -------------------------------------------------------------------------- */
@@ -2008,6 +2028,7 @@ void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 	device->device_type = type;
 	device->handle = handle;
 	device->parent = acpi_bus_get_parent(handle);
+	device->fwnode.type = FWNODE_ACPI;
 	acpi_set_device_status(device, sta);
 	acpi_device_get_busid(device);
 	acpi_set_pnp_ids(handle, &device->pnp, type);

commit 733e625139fe455b4d910ac63c18c90f7cbe2d6f
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Oct 21 13:33:56 2014 +0200

    ACPI: Allow drivers to match using Device Tree compatible property
    
    We have lots of existing Device Tree enabled drivers and allocating
    separate _HID for each is not feasible. Instead we allocate special _HID
    "PRP0001" that means that the match should be done using Device Tree
    compatible property using driver's .of_match_table instead if the driver
    is missing .acpi_match_table.
    
    If there is a need to distinguish from where the device is enumerated
    (DT/ACPI) driver can check dev->of_node or ACPI_COMPATION(dev).
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 40d80ac0552f..3a8f66444532 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -124,17 +124,56 @@ static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
 	if (list_empty(&acpi_dev->pnp.ids))
 		return 0;
 
-	len = snprintf(modalias, size, "acpi:");
-	size -= len;
-
-	list_for_each_entry(id, &acpi_dev->pnp.ids, list) {
-		count = snprintf(&modalias[len], size, "%s:", id->id);
-		if (count < 0)
-			return -EINVAL;
-		if (count >= size)
-			return -ENOMEM;
-		len += count;
-		size -= count;
+	/*
+	 * If the device has PRP0001 we expose DT compatible modalias
+	 * instead in form of of:NnameTCcompatible.
+	 */
+	if (acpi_dev->data.of_compatible) {
+		struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
+		const union acpi_object *of_compatible, *obj;
+		int i, nval;
+		char *c;
+
+		acpi_get_name(acpi_dev->handle, ACPI_SINGLE_NAME, &buf);
+		/* DT strings are all in lower case */
+		for (c = buf.pointer; *c != '\0'; c++)
+			*c = tolower(*c);
+
+		len = snprintf(modalias, size, "of:N%sT", (char *)buf.pointer);
+		ACPI_FREE(buf.pointer);
+
+		of_compatible = acpi_dev->data.of_compatible;
+		if (of_compatible->type == ACPI_TYPE_PACKAGE) {
+			nval = of_compatible->package.count;
+			obj = of_compatible->package.elements;
+		} else { /* Must be ACPI_TYPE_STRING. */
+			nval = 1;
+			obj = of_compatible;
+		}
+		for (i = 0; i < nval; i++, obj++) {
+			count = snprintf(&modalias[len], size, "C%s",
+					 obj->string.pointer);
+			if (count < 0)
+				return -EINVAL;
+			if (count >= size)
+				return -ENOMEM;
+
+			len += count;
+			size -= count;
+		}
+	} else {
+		len = snprintf(modalias, size, "acpi:");
+		size -= len;
+
+		list_for_each_entry(id, &acpi_dev->pnp.ids, list) {
+			count = snprintf(&modalias[len], size, "%s:", id->id);
+			if (count < 0)
+				return -EINVAL;
+			if (count >= size)
+				return -ENOMEM;
+			len += count;
+			size -= count;
+		}
 	}
 
 	modalias[len] = '\0';
@@ -902,6 +941,51 @@ int acpi_match_device_ids(struct acpi_device *device,
 }
 EXPORT_SYMBOL(acpi_match_device_ids);
 
+/* Performs match against special "PRP0001" shoehorn ACPI ID */
+static bool acpi_of_driver_match_device(struct device *dev,
+					const struct device_driver *drv)
+{
+	const union acpi_object *of_compatible, *obj;
+	struct acpi_device *adev;
+	int i, nval;
+
+	adev = ACPI_COMPANION(dev);
+	if (!adev)
+		return false;
+
+	of_compatible = adev->data.of_compatible;
+	if (!drv->of_match_table || !of_compatible)
+		return false;
+
+	if (of_compatible->type == ACPI_TYPE_PACKAGE) {
+		nval = of_compatible->package.count;
+		obj = of_compatible->package.elements;
+	} else { /* Must be ACPI_TYPE_STRING. */
+		nval = 1;
+		obj = of_compatible;
+	}
+	/* Now we can look for the driver DT compatible strings */
+	for (i = 0; i < nval; i++, obj++) {
+		const struct of_device_id *id;
+
+		for (id = drv->of_match_table; id->compatible[0]; id++)
+			if (!strcasecmp(obj->string.pointer, id->compatible))
+				return true;
+	}
+
+	return false;
+}
+
+bool acpi_driver_match_device(struct device *dev,
+			      const struct device_driver *drv)
+{
+	if (!drv->acpi_match_table)
+		return acpi_of_driver_match_device(dev, drv);
+
+	return !!acpi_match_device(drv->acpi_match_table, dev);
+}
+EXPORT_SYMBOL_GPL(acpi_driver_match_device);
+
 static void acpi_free_power_resources_lists(struct acpi_device *device)
 {
 	int i;

commit ffdcd955c3078af3ce117edcfce80fde1a512bed
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Oct 21 13:33:55 2014 +0200

    ACPI: Add support for device specific properties
    
    Device Tree is used in many embedded systems to describe the system
    configuration to the OS. It supports attaching properties or name-value
    pairs to the devices it describe. With these properties one can pass
    additional information to the drivers that would not be available
    otherwise.
    
    ACPI is another configuration mechanism (among other things) typically
    seen, but not limited to, x86 machines. ACPI allows passing arbitrary
    data from methods but there has not been mechanism equivalent to Device
    Tree until the introduction of _DSD in the recent publication of the
    ACPI 5.1 specification.
    
    In order to facilitate ACPI usage in systems where Device Tree is
    typically used, it would be beneficial to standardize a way to retrieve
    Device Tree style properties from ACPI devices, which is what we do in
    this patch.
    
    If a given device described in ACPI namespace wants to export properties it
    must implement _DSD method (Device Specific Data, introduced with ACPI 5.1)
    that returns the properties in a package of packages. For example:
    
            Name (_DSD, Package () {
                    ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
                    Package () {
                            Package () {"name1", <VALUE1>},
                            Package () {"name2", <VALUE2>},
                            ...
                    }
            })
    
    The UUID reserved for properties is daffd814-6eba-4d8c-8a91-bc9bbf4aa301
    and is documented in the ACPI 5.1 companion document called "_DSD
    Implementation Guide" [1], [2].
    
    We add several helper functions that can be used to extract these
    properties and convert them to different Linux data types.
    
    The ultimate goal is that we only have one device property API that
    retrieves the requested properties from Device Tree or from ACPI
    transparent to the caller.
    
    [1] http://www.uefi.org/sites/default/files/resources/_DSD-implementation-guide-toplevel.htm
    [2] http://www.uefi.org/sites/default/files/resources/_DSD-device-properties-UUID.pdf
    
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 0476e90b2091..40d80ac0552f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -922,6 +922,7 @@ static void acpi_device_release(struct device *dev)
 {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 
+	acpi_free_properties(acpi_dev);
 	acpi_free_pnp_ids(&acpi_dev->pnp);
 	acpi_free_power_resources_lists(acpi_dev);
 	kfree(acpi_dev);
@@ -1926,6 +1927,7 @@ void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 	acpi_set_device_status(device, sta);
 	acpi_device_get_busid(device);
 	acpi_set_pnp_ids(handle, &device->pnp, type);
+	acpi_init_properties(device);
 	acpi_bus_get_flags(device);
 	device->flags.match_driver = false;
 	device->flags.initialized = true;

commit 52870786ff5d06540efacc64ca8faa74221f10dd
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Oct 24 16:40:54 2014 +0200

    ACPI: Use ACPI companion to match only the first physical device
    
    Commit 6ab3430129e2 ("mfd: Add ACPI support") made the MFD subdevices
    share the parent MFD ACPI companion if no _HID/_CID is specified for
    the subdevice in mfd_cell description. However, since all the subdevices
    share the ACPI companion, the match and modalias generation logic started
    to use the ACPI companion as well resulting this:
    
      # cat /sys/bus/platform/devices/HID-SENSOR-200041.6.auto/modalias
      acpi:INT33D1:PNP0C50:
    
    instead of the expected one
    
      # cat /sys/bus/platform/devices/HID-SENSOR-200041.6.auto/modalias
      platform:HID-SENSOR-200041
    
    In other words the subdevice modalias is overwritten by the one taken from
    ACPI companion. This causes udev not to load the driver anymore.
    
    It is useful to be able to share the ACPI companion so that MFD subdevices
    (and possibly other devices as well) can access the ACPI resources even if
    they do not have ACPI representation in the namespace themselves.
    
    An example where this is used is Minnowboard LPC driver that creates GPIO
    as a subdevice among other things. Without the ACPI companion gpiolib is
    not able to lookup the corresponding GPIO controller from ACPI GpioIo
    resource.
    
    To fix this, restrict the match and modalias logic to be limited to the
    first (primary) physical device associated with the given ACPI comapnion.
    The secondary devices will still be able to access the ACPI companion,
    but they will be matched in a different way.
    
    Fixes: 6ab3430129e2 (mfd: Add ACPI support)
    Reported-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d670158a26c5..0476e90b2091 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -141,6 +141,53 @@ static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
 	return len;
 }
 
+/*
+ * acpi_companion_match() - Can we match via ACPI companion device
+ * @dev: Device in question
+ *
+ * Check if the given device has an ACPI companion and if that companion has
+ * a valid list of PNP IDs, and if the device is the first (primary) physical
+ * device associated with it.
+ *
+ * If multiple physical devices are attached to a single ACPI companion, we need
+ * to be careful.  The usage scenario for this kind of relationship is that all
+ * of the physical devices in question use resources provided by the ACPI
+ * companion.  A typical case is an MFD device where all the sub-devices share
+ * the parent's ACPI companion.  In such cases we can only allow the primary
+ * (first) physical device to be matched with the help of the companion's PNP
+ * IDs.
+ *
+ * Additional physical devices sharing the ACPI companion can still use
+ * resources available from it but they will be matched normally using functions
+ * provided by their bus types (and analogously for their modalias).
+ */
+static bool acpi_companion_match(const struct device *dev)
+{
+	struct acpi_device *adev;
+	bool ret;
+
+	adev = ACPI_COMPANION(dev);
+	if (!adev)
+		return false;
+
+	if (list_empty(&adev->pnp.ids))
+		return false;
+
+	mutex_lock(&adev->physical_node_lock);
+	if (list_empty(&adev->physical_node_list)) {
+		ret = false;
+	} else {
+		const struct acpi_device_physical_node *node;
+
+		node = list_first_entry(&adev->physical_node_list,
+					struct acpi_device_physical_node, node);
+		ret = node->dev == dev;
+	}
+	mutex_unlock(&adev->physical_node_lock);
+
+	return ret;
+}
+
 /*
  * Creates uevent modalias field for ACPI enumerated devices.
  * Because the other buses does not support ACPI HIDs & CIDs.
@@ -149,20 +196,14 @@ static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
  */
 int acpi_device_uevent_modalias(struct device *dev, struct kobj_uevent_env *env)
 {
-	struct acpi_device *acpi_dev;
 	int len;
 
-	acpi_dev = ACPI_COMPANION(dev);
-	if (!acpi_dev)
-		return -ENODEV;
-
-	/* Fall back to bus specific way of modalias exporting */
-	if (list_empty(&acpi_dev->pnp.ids))
+	if (!acpi_companion_match(dev))
 		return -ENODEV;
 
 	if (add_uevent_var(env, "MODALIAS="))
 		return -ENOMEM;
-	len = create_modalias(acpi_dev, &env->buf[env->buflen - 1],
+	len = create_modalias(ACPI_COMPANION(dev), &env->buf[env->buflen - 1],
 				sizeof(env->buf) - env->buflen);
 	if (len <= 0)
 		return len;
@@ -179,18 +220,12 @@ EXPORT_SYMBOL_GPL(acpi_device_uevent_modalias);
  */
 int acpi_device_modalias(struct device *dev, char *buf, int size)
 {
-	struct acpi_device *acpi_dev;
 	int len;
 
-	acpi_dev = ACPI_COMPANION(dev);
-	if (!acpi_dev)
+	if (!acpi_companion_match(dev))
 		return -ENODEV;
 
-	/* Fall back to bus specific way of modalias exporting */
-	if (list_empty(&acpi_dev->pnp.ids))
-		return -ENODEV;
-
-	len = create_modalias(acpi_dev, buf, size -1);
+	len = create_modalias(ACPI_COMPANION(dev), buf, size -1);
 	if (len <= 0)
 		return len;
 	buf[len++] = '\n';
@@ -853,6 +888,9 @@ const struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,
 	if (!ids || !handle || acpi_bus_get_device(handle, &adev))
 		return NULL;
 
+	if (!acpi_companion_match(dev))
+		return NULL;
+
 	return __acpi_match_device(adev, ids);
 }
 EXPORT_SYMBOL_GPL(acpi_match_device);

commit 1c45d9a920e6ef4fce38921e4fc776c2abca3197
Merge: 8264fce6de03 a91e99e27a68
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 24 11:29:31 2014 -0700

    Merge tag 'pm+acpi-3.18-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "This is material that didn't make it to my 3.18-rc1 pull request for
      various reasons, mostly related to timing and travel (LinuxCon EU /
      LPC) plus a couple of fixes for recent bugs.
    
      The only really new thing here is the PM QoS class for memory
      bandwidth, but it is simple enough and users of it will be added in
      the next cycle.  One major change in behavior is that platform devices
      enumerated by ACPI will use 32-bit DMA mask by default.  Also included
      is an ACPICA update to a new upstream release, but that's mostly
      cleanups, changes in tools and similar.  The rest is fixes and
      cleanups mostly.
    
      Specifics:
    
       - Fix for a recent PCI power management change that overlooked the
         fact that some IRQ chips might not be able to configure PCIe PME
         for system wakeup from Lucas Stach.
    
       - Fix for a bug introduced in 3.17 where acpi_device_wakeup() is
         called with a wrong ordering of arguments from Zhang Rui.
    
       - A bunch of intel_pstate driver fixes (all -stable candidates) from
         Dirk Brandewie, Gabriele Mazzotta and Pali Rohár.
    
       - Fixes for a rather long-standing problem with the OOM killer and
         the freezer that frozen processes killed by the OOM do not actually
         release any memory until they are thawed, so OOM-killing them is
         rather pointless, with a couple of cleanups on top (Michal Hocko,
         Cong Wang, Rafael J Wysocki).
    
       - ACPICA update to upstream release 20140926, inlcuding mostly
         cleanups reducing differences between the upstream ACPICA and the
         kernel code, tools changes (acpidump, acpiexec) and support for the
         _DDN object (Bob Moore, Lv Zheng).
    
       - New PM QoS class for memory bandwidth from Tomeu Vizoso.
    
       - Default 32-bit DMA mask for platform devices enumerated by ACPI
         (this change is mostly needed for some drivers development in
         progress targeted at 3.19) from Heikki Krogerus.
    
       - ACPI EC driver cleanups, mostly related to debugging, from Lv
         Zheng.
    
       - cpufreq-dt driver updates from Thomas Petazzoni.
    
       - powernv cpuidle driver update from Preeti U Murthy"
    
    * tag 'pm+acpi-3.18-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (34 commits)
      intel_pstate: Correct BYT VID values.
      intel_pstate: Fix BYT frequency reporting
      intel_pstate: Don't lose sysfs settings during cpu offline
      cpufreq: intel_pstate: Reflect current no_turbo state correctly
      cpufreq: expose scaling_cur_freq sysfs file for set_policy() drivers
      cpufreq: intel_pstate: Fix setting max_perf_pct in performance policy
      PCI / PM: handle failure to enable wakeup on PCIe PME
      ACPI: invoke acpi_device_wakeup() with correct parameters
      PM / freezer: Clean up code after recent fixes
      PM: convert do_each_thread to for_each_process_thread
      OOM, PM: OOM killed task shouldn't escape PM suspend
      freezer: remove obsolete comments in __thaw_task()
      freezer: Do not freeze tasks killed by OOM killer
      ACPI / platform: provide default DMA mask
      cpuidle: powernv: Populate cpuidle state details by querying the device-tree
      cpufreq: cpufreq-dt: adjust message related to regulators
      cpufreq: cpufreq-dt: extend with platform_data
      cpufreq: allow driver-specific data
      ACPI / EC: Cleanup coding style.
      ACPI / EC: Refine event/query debugging messages.
      ...

commit 8264fce6de03f3915e2301f52f181a982718a8cb
Merge: 816fb4175c29 6ceaf58abe25
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 24 11:21:43 2014 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux
    
    Pull thermal management updates from Zhang Rui:
     "Sorry that I missed the merge window as there is a bug found in the
      last minute, and I have to fix it and wait for the code to be tested
      in linux-next tree for a few days.  Now the buggy patch has been
      dropped entirely from my next branch.  Thus I hope those changes can
      still be merged in 3.18-rc2 as most of them are platform thermal
      driver changes.
    
      Specifics:
    
       - introduce ACPI INT340X thermal drivers.
    
         Newer laptops and tablets may have thermal sensors and other
         devices with thermal control capabilities that are exposed for the
         OS to use via the ACPI INT340x device objects.  Several drivers are
         introduced to expose the temperature information and cooling
         ability from these objects to user-space via the normal thermal
         framework.
    
         From: Lu Aaron, Lan Tianyu, Jacob Pan and Zhang Rui.
    
       - introduce a new thermal governor, which just uses a hysteresis to
         switch abruptly on/off a cooling device.  This governor can be used
         to control certain fan devices that can not be throttled but just
         switched on or off.  From: Peter Feuerer.
    
       - introduce support for some new thermal interrupt functions on
         i.MX6SX, in IMX thermal driver.  From: Anson, Huang.
    
       - introduce tracing support on thermal framework.  From: Punit
         Agrawal.
    
       - small fixes in OF thermal and thermal step_wise governor"
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux: (25 commits)
      Thermal: int340x thermal: select ACPI fan driver
      Thermal: int3400_thermal: use acpi_thermal_rel parsing APIs
      Thermal: int340x_thermal: expose acpi thermal relationship tables
      Thermal: introduce int3403 thermal driver
      Thermal: introduce INT3402 thermal driver
      Thermal: move the KELVIN_TO_MILLICELSIUS macro to thermal.h
      ACPI / Fan: support INT3404 thermal device
      ACPI / Fan: add ACPI 4.0 style fan support
      ACPI / fan: convert to platform driver
      ACPI / fan: use acpi_device_xxx_power instead of acpi_bus equivelant
      ACPI / fan: remove no need check for device pointer
      ACPI / fan: remove unused macro
      Thermal: int3400 thermal: register to thermal framework
      Thermal: int3400 thermal: add capability to detect supporting UUIDs
      Thermal: introduce int3400 thermal driver
      ACPI: add ACPI_TYPE_LOCAL_REFERENCE support to acpi_extract_package()
      ACPI: make acpi_create_platform_device() an external API
      thermal: step_wise: fix: Prevent from binary overflow when trend is dropping
      ACPI: introduce ACPI int340x thermal scan handler
      thermal: Added Bang-bang thermal governor
      ...

commit 2f8572344e65296d13c1a771cacfea60916d91dc
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Oct 10 10:40:05 2014 +0800

    ACPICA: Events: Reduce source code difference for the ACPI_EVENT_FLAG_HANDLE renaming.
    
    This patch is partial linuxized result of the following ACPICA commit:
      ACPICA commit: a73b66c6aa1846d055bb6390d9c9b9902f7d804d
      Subject: Add "has handler" flag to event/gpe status interfaces.
      This change adds a new flag, ACPI_EVENT_FLAGS_HAS_HANDLER to the
      acpi_get_event_status and acpi_get_gpe_status external interfaces. It
      is set if the event/gpe currently has a handler associated with it.
    This patch contains the code to rename ACPI_EVENT_FLAG_HANDLE to
    ACPI_EVENT_FLAG_HAS_HANDLER, and the corresponding updates of its usages.
    
    Link: https://github.com/acpica/acpica/commit/a73b66c6
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ae44d8654c82..f1d96e7519cb 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1470,7 +1470,7 @@ static void acpi_wakeup_gpe_init(struct acpi_device *device)
 	if (ACPI_FAILURE(status))
 		return;
 
-	wakeup->flags.run_wake = !!(event_status & ACPI_EVENT_FLAG_HANDLE);
+	wakeup->flags.run_wake = !!(event_status & ACPI_EVENT_FLAG_HAS_HANDLER);
 }
 
 static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)

commit 9ef5a306ef1bc5a434030f3a70b23170bc0ca773
Merge: 8ab17fc92e49 98d28d0e5916 457920817e64 c15d821ddb9d 789eeea12892
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Sep 25 22:59:30 2014 +0200

    Merge branches 'acpi-hotplug', 'acpi-scan', 'acpi-lpss', 'acpi-gpio' and 'acpi-video'
    
    * acpi-hotplug:
      ACPI / hotplug: Generate online uevents for ACPI containers
    
    * acpi-scan:
      ACPI / scan: Correct error return value of create_modalias()
    
    * acpi-lpss:
      ACPI / platform / LPSS: disable async suspend/resume of LPSS devices
    
    * acpi-gpio:
      gpio / ACPI: Use pin index and bit length
      ACPICA: Update to GPIO region handler interface.
    
    * acpi-video:
      ACPI / video: disable native backlight for ThinkPad X201s

commit 98d28d0e59160d2d6cb3f6a9050723ac40f89669
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Sep 12 11:33:10 2014 +0300

    ACPI / scan: Correct error return value of create_modalias()
    
    There is a typo, it should be negative -errno instead.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 3bf7764659a4..d5e6ac5042d8 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -130,7 +130,7 @@ static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
 	list_for_each_entry(id, &acpi_dev->pnp.ids, list) {
 		count = snprintf(&modalias[len], size, "%s:", id->id);
 		if (count < 0)
-			return EINVAL;
+			return -EINVAL;
 		if (count >= size)
 			return -ENOMEM;
 		len += count;

commit 8ab17fc92e49bc2b8fff9d220c19bf50ec9c1158
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Sep 21 02:58:18 2014 +0200

    ACPI / hotplug: Generate online uevents for ACPI containers
    
    Commit 46394fd01 (ACPI / hotplug: Move container-specific code out of
    the core) removed the generation of "online" uevents for containers,
    because "add" uevents are now generated for them automatically when
    container system devices are registered.  However, there are user
    space tools that need to be notified when the container and all of
    its children have been enumerated, which doesn't happen any more.
    
    For this reason, add a mechanism allowing "online" uevents to be
    generated for ACPI containers after enumerating the container along
    with all of its children.
    
    Fixes: 46394fd01 (ACPI / hotplug: Move container-specific code out of the core)
    Reported-and-tested-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Cc: 3.14+ <stable@vger.kernel.org> # 3.14+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 3bf7764659a4..1c9a664c1705 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2189,6 +2189,9 @@ static void acpi_bus_attach(struct acpi_device *device)
  ok:
 	list_for_each_entry(child, &device->children, node)
 		acpi_bus_attach(child);
+
+	if (device->handler && device->handler->hotplug.notify_online)
+		device->handler->hotplug.notify_online(device);
 }
 
 /**

commit 3230bbfce8a9270acc77fafd0d9ff90e94f28993
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri Mar 14 00:34:05 2014 +0800

    ACPI: introduce ACPI int340x thermal scan handler
    
    Newer laptops and tablets that use ACPI may have thermal sensors and
    other devices with thermal control capabilities outside the core CPU/SOC,
    for thermal safety reasons.
    They are exposed for the OS to use via
    1) INT3400 ACPI device object as the master.
    2) INT3401 ~ INT340B ACPI device objects as the slaves.
    
    This patch introduces a scan handler to enumerate the INT3400
    ACPI device object to platform bus, and prevent its slaves
    from being enumerated before the controller driver being probed.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 0a817ad24f16..eed9740651f8 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2306,6 +2306,7 @@ int __init acpi_scan_init(void)
 	acpi_container_init();
 	acpi_memory_hotplug_init();
 	acpi_pnp_init();
+	acpi_int340x_thermal_init();
 
 	mutex_lock(&acpi_scan_lock);
 	/*

commit a383b68d9fe9864c4d3b86f67ad6488f58136435
Author: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
Date:   Wed Sep 3 13:39:13 2014 +0900

    ACPI / scan: not cache _SUN value in struct acpi_device_pnp
    
    The _SUN device indentification object is not guaranteed to return
    the same value every time it is executed, so we should not cache its
    return value, but rather execute it every time as needed.  If it is
    cached, an incorrect stale value may be used in some situations.
    
    This issue was exposed by commit 202317a573b2 (ACPI / scan: Add
    acpi_device objects for all device nodes in the namespace).  Fix it
    by avoiding to cache the return value of _SUN.
    
    Fixes: 202317a573b2 (ACPI / scan: Add acpi_device objects for all device nodes in the namespace)
    Signed-off-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Cc: 3.14+ <stable@vger.kernel.org> # 3.14+
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 9a9298994e26..3bf7764659a4 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -667,8 +667,14 @@ static ssize_t
 acpi_device_sun_show(struct device *dev, struct device_attribute *attr,
 		     char *buf) {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
+	acpi_status status;
+	unsigned long long sun;
+
+	status = acpi_evaluate_integer(acpi_dev->handle, "_SUN", NULL, &sun);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
 
-	return sprintf(buf, "%lu\n", acpi_dev->pnp.sun);
+	return sprintf(buf, "%llu\n", sun);
 }
 static DEVICE_ATTR(sun, 0444, acpi_device_sun_show, NULL);
 
@@ -690,7 +696,6 @@ static int acpi_device_setup_files(struct acpi_device *dev)
 {
 	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
 	acpi_status status;
-	unsigned long long sun;
 	int result = 0;
 
 	/*
@@ -731,14 +736,10 @@ static int acpi_device_setup_files(struct acpi_device *dev)
 	if (dev->pnp.unique_id)
 		result = device_create_file(&dev->dev, &dev_attr_uid);
 
-	status = acpi_evaluate_integer(dev->handle, "_SUN", NULL, &sun);
-	if (ACPI_SUCCESS(status)) {
-		dev->pnp.sun = (unsigned long)sun;
+	if (acpi_has_method(dev->handle, "_SUN")) {
 		result = device_create_file(&dev->dev, &dev_attr_sun);
 		if (result)
 			goto end;
-	} else {
-		dev->pnp.sun = (unsigned long)-1;
 	}
 
 	if (acpi_has_method(dev->handle, "_STA")) {

commit 236105db632c6279a020f78c83e22eaef746006b
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Tue Aug 26 01:29:24 2014 +0200

    ACPI: Run fixed event device notifications in process context
    
    Currently, notify callbacks for fixed button events are run from
    interrupt context.  That is not necessary and after commit 0bf6368ee8f2
    (ACPI / button: Add ACPI Button event via netlink routine) it causes
    netlink routines to be called from interrupt context which is not
    correct.
    
    Also, that is different from non-fixed device events (including
    non-fixed button events) whose notify callbacks are all executed from
    process context.
    
    For the above reasons, make fixed button device notify callbacks run
    in process context which will avoid the deadlock when using netlink
    to report button events to user space.
    
    Fixes: 0bf6368ee8f2 (ACPI / button: Add ACPI Button event via netlink routine)
    Link: https://lkml.org/lkml/2014/8/21/606
    Reported-by: Benjamin Block <bebl@mageta.org>
    Reported-by: Knut Petersen <Knut_Petersen@t-online.de>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    [rjw: Function names, subject and changelog.]
    Cc: 3.15+ <stable@vger.kernel.org> # 3.15+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index fd17fe7f93f2..9a9298994e26 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -922,12 +922,17 @@ static void acpi_device_notify(acpi_handle handle, u32 event, void *data)
 	device->driver->ops.notify(device, event);
 }
 
-static acpi_status acpi_device_notify_fixed(void *data)
+static void acpi_device_notify_fixed(void *data)
 {
 	struct acpi_device *device = data;
 
 	/* Fixed hardware devices have no handles */
 	acpi_device_notify(NULL, ACPI_FIXED_HARDWARE_EVENT, device);
+}
+
+static acpi_status acpi_device_fixed_event(void *data)
+{
+	acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_device_notify_fixed, data);
 	return AE_OK;
 }
 
@@ -938,12 +943,12 @@ static int acpi_device_install_notify_handler(struct acpi_device *device)
 	if (device->device_type == ACPI_BUS_TYPE_POWER_BUTTON)
 		status =
 		    acpi_install_fixed_event_handler(ACPI_EVENT_POWER_BUTTON,
-						     acpi_device_notify_fixed,
+						     acpi_device_fixed_event,
 						     device);
 	else if (device->device_type == ACPI_BUS_TYPE_SLEEP_BUTTON)
 		status =
 		    acpi_install_fixed_event_handler(ACPI_EVENT_SLEEP_BUTTON,
-						     acpi_device_notify_fixed,
+						     acpi_device_fixed_event,
 						     device);
 	else
 		status = acpi_install_notify_handler(device->handle,
@@ -960,10 +965,10 @@ static void acpi_device_remove_notify_handler(struct acpi_device *device)
 {
 	if (device->device_type == ACPI_BUS_TYPE_POWER_BUTTON)
 		acpi_remove_fixed_event_handler(ACPI_EVENT_POWER_BUTTON,
-						acpi_device_notify_fixed);
+						acpi_device_fixed_event);
 	else if (device->device_type == ACPI_BUS_TYPE_SLEEP_BUTTON)
 		acpi_remove_fixed_event_handler(ACPI_EVENT_SLEEP_BUTTON,
-						acpi_device_notify_fixed);
+						acpi_device_fixed_event);
 	else
 		acpi_remove_notify_handler(device->handle, ACPI_DEVICE_NOTIFY,
 					   acpi_device_notify);

commit fc2e0a8326d1b21d11ef8213298e5302867fed2c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 26 01:29:21 2014 +0200

    ACPI / scan: Allow ACPI drivers to bind to PNP device objects
    
    We generally don't allow ACPI drivers to bind to ACPI device objects
    that companion "physical" device objects are created for to avoid
    situations in which two different drivers may attempt to handle one
    device at the same time.  Recent ACPI device enumeration rework
    extended that approach to ACPI PNP devices by starting to use a scan
    handler for enumerating them.  However, we previously allowed ACPI
    drivers to bind to ACPI device objects with existing PNP device
    companions and changing that led to functional regressions on some
    systems.
    
    For this reason, add a special check for PNP devices in
    acpi_device_probe() so that ACPI drivers can bind to ACPI device
    objects having existing PNP device companions as before.
    
    Fixes: eec15edbb0e1 (ACPI / PNP: use device ID list for PNPACPI device enumeration)
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=81511
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=81971
    Reported-by: Gabriele Mazzotta <gabriele.mzt@gmail.com>
    Reported-by: Dirk Griesbach <spamthis@freenet.de>
    Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 0a817ad24f16..fd17fe7f93f2 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -975,7 +975,7 @@ static int acpi_device_probe(struct device *dev)
 	struct acpi_driver *acpi_drv = to_acpi_driver(dev->driver);
 	int ret;
 
-	if (acpi_dev->handler)
+	if (acpi_dev->handler && !acpi_is_pnp_device(acpi_dev))
 		return -EINVAL;
 
 	if (!acpi_drv->ops.add)

commit 21c806d9b189c2da652eb7fad96b662d3e2c82eb
Merge: 772513198247 ea9c167d93e6 dee1592638ab d719870b41e0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Aug 10 16:23:33 2014 +0200

    Merge branches 'acpi-processor', 'acpi-hotplug' and 'acpi-battery'
    
    * acpi-processor:
      ACPI / processor: Make acpi_cpu_soft_notify() process CPU FROZEN events
    
    * acpi-hotplug:
      ACPI / hotplug: Check scan handlers in acpi_scan_hot_remove()
    
    * acpi-battery:
      ACPI / battery: Fix warning message in acpi_battery_get_state()

commit dee1592638ab7ea35a32179b73f9284dead49c03
Author: Tang Chen <tangchen@cn.fujitsu.com>
Date:   Fri Aug 8 10:30:45 2014 +0800

    ACPI / hotplug: Check scan handlers in acpi_scan_hot_remove()
    
    When ACPI_HOTPLUG_MEMORY is not configured, memory_device_handler.attach
    is not set.  In acpi_scan_attach_handler(), the acpi_device->handler will
    not be initialized.
    
    In acpi_scan_hot_remove(), it doesn't check if acpi_device->handler is NULL.
    If we do memory hot-remove without ACPI_HOTPLUG_MEMORY configured, the kernel
    will panic.
    
     BUG: unable to handle kernel NULL pointer dereference at 0000000000000088
     IP: [<ffffffff813e318f>] acpi_device_hotplug+0x1d7/0x4c4
     PGD 0
     Oops: 0000 [#1] SMP
     Modules linked in: sd_mod(E) sr_mod(E) cdrom(E) crc_t10dif(E) crct10dif_common(E) ata_piix(E) libata(E)
     CPU: 0 PID: 41 Comm: kworker/u2:1 Tainted: G            E 3.16.0-rc7--3.16-rc7-tangchen+ #20
     Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.7.5-0-ge51488c-20140602_164612-nilsson.home.kraxel.org 04/01/2014
     Workqueue: kacpi_hotplug acpi_hotplug_work_fn
     task: ffff8800182436c0 ti: ffff880018254000 task.ti: ffff880018254000
     RIP: 0010:[<ffffffff813e318f>]  [<ffffffff813e318f>] acpi_device_hotplug+0x1d7/0x4c4
     RSP: 0000:ffff880018257da8  EFLAGS: 00000246
     RAX: 0000000000000000 RBX: ffff88001cd8d800 RCX: 0000000000000000
     RDX: 0000000000000000 RSI: ffff88001e40e6f8 RDI: 0000000000000246
     RBP: ffff880018257df0 R08: 0000000000000096 R09: 00000000000011a0
     R10: 63735f6970636120 R11: 725f746f685f6e61 R12: 0000000000000003
     R13: ffff88001cc1c400 R14: ffff88001e062028 R15: 0000000000000040
     FS:  0000000000000000(0000) GS:ffff88001e400000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
     CR2: 0000000000000088 CR3: 000000001a9a2000 CR4: 00000000000006f0
     DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
     DR3: 0000000000000000 DR6: 0000000000000000 DR7: 0000000000000000
     Stack:
      00000000523cab58 ffff88001cd8d9f8 ffff88001852d480 00000000523cab58
      ffff88001852d480 ffff880018221e40 ffff88001cc1c400 ffff88001cce2d00
      0000000000000040 ffff880018257e08 ffffffff813dc31d ffff88001852d480
     Call Trace:
      [<ffffffff813dc31d>] acpi_hotplug_work_fn+0x1e/0x29
      [<ffffffff8108eefb>] process_one_work+0x17b/0x460
      [<ffffffff8108f69d>] worker_thread+0x11d/0x5b0
      [<ffffffff8108f580>] ? rescuer_thread+0x3a0/0x3a0
      [<ffffffff81096811>] kthread+0xe1/0x100
      [<ffffffff81096730>] ? kthread_create_on_node+0x1a0/0x1a0
      [<ffffffff816cc6bc>] ret_from_fork+0x7c/0xb0
      [<ffffffff81096730>] ? kthread_create_on_node+0x1a0/0x1a0
    
    This patch fixes this problem by checking if acpi_device->handler is NULL
    in acpi_scan_hot_remove().
    
    Fixes: d22ddcbc4fb7 (ACPI / hotplug: Add demand_offline hotplug profile flag)
    Signed-off-by: Tang Chen <tangchen@cn.fujitsu.com>
    Cc: 3.14+ <stable@vger.kernel.org> # 3.14+
    [rjw: Subject]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 3ffc9306538b..9e4422bbe03d 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -353,7 +353,8 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	unsigned long long sta;
 	acpi_status status;
 
-	if (device->handler->hotplug.demand_offline && !acpi_force_hot_remove) {
+	if (device->handler && device->handler->hotplug.demand_offline
+	    && !acpi_force_hot_remove) {
 		if (!acpi_scan_is_offline(device, true))
 			return -EBUSY;
 	} else {

commit e5e0243e362c86f3694a140779949251e112c39e
Merge: 91af125c33af 6d6b20b2e949 902ee490fe84
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jul 27 23:55:54 2014 +0200

    Merge branches 'acpi-video' and 'acpi-hotplug'
    
    * acpi-video:
      ACPI: move models with win8 brightness problems from win8 blacklist to use_native_backlight
      ACPI / video: Fix backlight taking 2 steps on a brightness up/down keypress
    
    * acpi-hotplug:
      ACPI / hotplug / PCI: Fix sparse non static symbol warning
      ACPI / hotplug: Simplify acpi_set_hp_context()
      ACPI / hotplug / PCI: Eliminate acpiphp_dev_to_bridge()

commit bd9b2f9aff26c185c1f8e0cd08a850ee4ace391a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 14 22:41:41 2014 +0200

    ACPI / scan: No implicit wake notification for buttons
    
    The ACPI device enumeration code in Linux assumes that buttons always
    are wakeup devices, so it calls acpi_setup_gpe_for_wake() for them
    which leads to undesirable side effects.  Namely, that function sets
    up implicit device wake notification mechanism for a given GPE if
    there is no handler method in the ACPI namespace, which from the
    ACPICA's perspective means that there always is a way to handle
    that GPE if enabled.  However, we don't handle wake notify events
    for buttons, so if there are no handler methods for their GPEs in
    the namespace, enabling a button GPE at run time leads to a GPE
    storm in some cases (the GPE triggers, ACPICA carries out the
    implicit wake notification for it which isn't handled, so the
    GPE triggers again and so on).
    
    To prevent that from happening use acpi_mark_gpe_for_wake()
    instead of acpi_setup_gpe_for_wake() for buttons which will cause
    ACPICA to only enable button GPEs if there are handler methods for
    the in the namespace.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f775fa0d850f..0afa66050370 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1421,14 +1421,13 @@ static int acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 			wakeup->sleep_state = sleep_state;
 		}
 	}
-	acpi_setup_gpe_for_wake(handle, wakeup->gpe_device, wakeup->gpe_number);
 
  out:
 	kfree(buffer.pointer);
 	return err;
 }
 
-static void acpi_bus_set_run_wake_flags(struct acpi_device *device)
+static void acpi_wakeup_gpe_init(struct acpi_device *device)
 {
 	struct acpi_device_id button_device_ids[] = {
 		{"PNP0C0C", 0},
@@ -1436,29 +1435,33 @@ static void acpi_bus_set_run_wake_flags(struct acpi_device *device)
 		{"PNP0C0E", 0},
 		{"", 0},
 	};
+	struct acpi_device_wakeup *wakeup = &device->wakeup;
 	acpi_status status;
 	acpi_event_status event_status;
 
-	device->wakeup.flags.notifier_present = 0;
+	wakeup->flags.notifier_present = 0;
 
 	/* Power button, Lid switch always enable wakeup */
 	if (!acpi_match_device_ids(device, button_device_ids)) {
-		device->wakeup.flags.run_wake = 1;
+		wakeup->flags.run_wake = 1;
 		if (!acpi_match_device_ids(device, &button_device_ids[1])) {
 			/* Do not use Lid/sleep button for S5 wakeup */
-			if (device->wakeup.sleep_state == ACPI_STATE_S5)
-				device->wakeup.sleep_state = ACPI_STATE_S4;
+			if (wakeup->sleep_state == ACPI_STATE_S5)
+				wakeup->sleep_state = ACPI_STATE_S4;
 		}
+		acpi_mark_gpe_for_wake(wakeup->gpe_device, wakeup->gpe_number);
 		device_set_wakeup_capable(&device->dev, true);
 		return;
 	}
 
-	status = acpi_get_gpe_status(device->wakeup.gpe_device,
-					device->wakeup.gpe_number,
-						&event_status);
-	if (status == AE_OK)
-		device->wakeup.flags.run_wake =
-				!!(event_status & ACPI_EVENT_FLAG_HANDLE);
+	acpi_setup_gpe_for_wake(device->handle, wakeup->gpe_device,
+				wakeup->gpe_number);
+	status = acpi_get_gpe_status(wakeup->gpe_device, wakeup->gpe_number,
+				     &event_status);
+	if (ACPI_FAILURE(status))
+		return;
+
+	wakeup->flags.run_wake = !!(event_status & ACPI_EVENT_FLAG_HANDLE);
 }
 
 static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
@@ -1478,7 +1481,7 @@ static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 
 	device->wakeup.flags.valid = 1;
 	device->wakeup.prepare_count = 0;
-	acpi_bus_set_run_wake_flags(device);
+	acpi_wakeup_gpe_init(device);
 	/* Call _PSW/_DSW object to disable its ability to wake the sleeping
 	 * system for the ACPI device with the _PRW object.
 	 * The _PSW object is depreciated in ACPI 3.0 and is replaced by _DSW.

commit ba574dc8563c7c1d1d1c5bf3c1c99ec88513402e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 15 22:03:22 2014 +0200

    ACPI / hotplug: Simplify acpi_set_hp_context()
    
    Since all of the acpi_set_hp_context() callers pass at least one NULL
    function pointer and one caller passes NULL function pointers only
    to it, drop function pointer arguments from acpi_set_hp_context()
    and make the callers initialize the function pointers in struct
    acpi_hotplug_context by themselves before passing it to
    acpi_set_hp_context().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f775fa0d850f..3ffc9306538b 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -77,7 +77,9 @@ void acpi_initialize_hp_context(struct acpi_device *adev,
 				void (*uevent)(struct acpi_device *, u32))
 {
 	acpi_lock_hp_context();
-	acpi_set_hp_context(adev, hp, notify, uevent, NULL);
+	hp->notify = notify;
+	hp->uevent = uevent;
+	acpi_set_hp_context(adev, hp);
 	acpi_unlock_hp_context();
 }
 EXPORT_SYMBOL_GPL(acpi_initialize_hp_context);

commit b04c58b1ed26317bfb4b33d3a2d16377fc6acd0f
Merge: 864e055f44a5 48459340b92b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jun 3 23:12:20 2014 +0200

    Merge branch 'acpi-enumeration'
    
    * acpi-enumeration:
      ACPI / scan: use platform bus type by default for _HID enumeration
      ACPI / scan: always register ACPI LPSS scan handler
      ACPI / scan: always register memory hotplug scan handler
      ACPI / scan: always register container scan handler
      ACPI / scan: Change the meaning of missing .attach() in scan handlers
      ACPI / scan: introduce platform_id device PNP type flag
      ACPI / scan: drop unsupported serial IDs from PNP ACPI scan handler ID list
      ACPI / scan: drop IDs that do not comply with the ACPI PNP ID rule
      ACPI / PNP: use device ID list for PNPACPI device enumeration
      ACPI / scan: .match() callback for ACPI scan handlers

commit a392f7d4afb850934851fde5a8e298912650a6b8
Merge: f58c41cc0427 4cf563c5d97c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jun 3 23:11:42 2014 +0200

    Merge branch 'acpi-pm'
    
    * acpi-pm:
      ACPI / PM: Export rest of the subsys PM callbacks
      ACPI / PM: Avoid resuming devices in ACPI PM domain during system suspend
      ACPI / PM: Hold ACPI scan lock over the "freeze" sleep state
      ACPI / PM: Export acpi_target_system_state() to modules

commit 48459340b92b00ae1a75179f168ef20d3e61f264
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri May 30 14:35:34 2014 +0200

    ACPI / scan: use platform bus type by default for _HID enumeration
    
    Because of the growing demand for enumerating ACPI devices to
    platform bus, change the code to enumerate ACPI device objects to
    platform bus by default.  Namely, create platform devices for the
    ACPI device objects that
     1. Have pnp.type.platform_id set (device objects with _HID currently).
     2. Do not have a scan handler attached.
     3. Are not SPI/I2C slave devices (that should be enumerated to the
        appropriate buses bus by their parent).
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    [rjw: Subject and changelog, rebase and code cleanup]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 611bb5db7e57..df49fc8276b9 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2070,6 +2070,44 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 	return AE_OK;
 }
 
+static int acpi_check_spi_i2c_slave(struct acpi_resource *ares, void *data)
+{
+	bool *is_spi_i2c_slave_p = data;
+
+	if (ares->type != ACPI_RESOURCE_TYPE_SERIAL_BUS)
+		return 1;
+
+	/*
+	 * devices that are connected to UART still need to be enumerated to
+	 * platform bus
+	 */
+	if (ares->data.common_serial_bus.type != ACPI_RESOURCE_SERIAL_TYPE_UART)
+		*is_spi_i2c_slave_p = true;
+
+	 /* no need to do more checking */
+	return -1;
+}
+
+static void acpi_default_enumeration(struct acpi_device *device)
+{
+	struct list_head resource_list;
+	bool is_spi_i2c_slave = false;
+
+	if (!device->pnp.type.platform_id || device->handler)
+		return;
+
+	/*
+	 * Do not enemerate SPI/I2C slaves as they will be enuerated by their
+	 * respective parents.
+	 */
+	INIT_LIST_HEAD(&resource_list);
+	acpi_dev_get_resources(device, &resource_list, acpi_check_spi_i2c_slave,
+			       &is_spi_i2c_slave);
+	acpi_dev_free_resource_list(&resource_list);
+	if (!is_spi_i2c_slave)
+		acpi_create_platform_device(device);
+}
+
 static int acpi_scan_attach_handler(struct acpi_device *device)
 {
 	struct acpi_hardware_id *hwid;
@@ -2095,6 +2133,9 @@ static int acpi_scan_attach_handler(struct acpi_device *device)
 				break;
 		}
 	}
+	if (!ret)
+		acpi_default_enumeration(device);
+
 	return ret;
 }
 
@@ -2254,7 +2295,6 @@ int __init acpi_scan_init(void)
 	acpi_pci_root_init();
 	acpi_pci_link_init();
 	acpi_processor_init();
-	acpi_platform_init();
 	acpi_lpss_init();
 	acpi_cmos_rtc_init();
 	acpi_container_init();

commit d34afa9de4447367b734ec407e5a9e10617d6ec3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 30 04:27:31 2014 +0200

    ACPI / scan: Change the meaning of missing .attach() in scan handlers
    
    Currently, some scan handlers can be compiled out entirely, which
    leaves the device objects they normally attach to without a scan
    handler.  This isn't a problem as long as we don't have any default
    enumeration mechanism that applies to all devices without a scan
    handler.  However, if such a default enumeration is added, it still
    should not be applied to devices that are normally attached to by
    scan handlers, because that may result in creating "physical" device
    objects of a wrong type for them.
    
    Since we are going to create platform device objects for all ACPI
    device objects with pnp.type.platform_id set by default, clear
    pnp.type.platform_id where there is a matching scan handler without
    an .attach() callback and otherwise simply treat that scan handler
    as though the .attach() callback was present but always returned 0.
    
    This will allow us to compile out scan handler callbacks and leave
    the device ID lists used by them so as to prevent creating platform
    device objects for the matching ACPI devices.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ebbd23c94ba2..611bb5db7e57 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -84,7 +84,7 @@ EXPORT_SYMBOL_GPL(acpi_initialize_hp_context);
 
 int acpi_scan_add_handler(struct acpi_scan_handler *handler)
 {
-	if (!handler || !handler->attach)
+	if (!handler)
 		return -EINVAL;
 
 	list_add_tail(&handler->list_node, &acpi_scan_handlers_list);
@@ -2081,6 +2081,10 @@ static int acpi_scan_attach_handler(struct acpi_device *device)
 
 		handler = acpi_scan_match_handler(hwid->id, &devid);
 		if (handler) {
+			if (!handler->attach) {
+				device->pnp.type.platform_id = 0;
+				continue;
+			}
 			device->handler = handler;
 			ret = handler->attach(device, devid);
 			if (ret > 0)

commit 549e68455c6706796d9d244364dfbf5c575bd1a5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 30 04:26:18 2014 +0200

    ACPI / scan: introduce platform_id device PNP type flag
    
    Only certain types of ACPI device objects can be enumerated as
    platform devices, so in order to distinguish them from the others
    introduce a new ACPI device PNP type flag, platform_id, and set it
    for devices with a valid _HID to start with.
    
    This change is based on a Zhang Rui's prototype.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 19d524c5c0c8..ebbd23c94ba2 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1797,8 +1797,10 @@ static void acpi_set_pnp_ids(acpi_handle handle, struct acpi_device_pnp *pnp,
 			return;
 		}
 
-		if (info->valid & ACPI_VALID_HID)
+		if (info->valid & ACPI_VALID_HID) {
 			acpi_add_id(pnp, info->hardware_id.string);
+			pnp->type.platform_id = 1;
+		}
 		if (info->valid & ACPI_VALID_CID) {
 			cid_list = &info->compatible_id_list;
 			for (i = 0; i < cid_list->count; i++)

commit eec15edbb0e14485998635ea7c62e30911b465f0
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri May 30 04:23:01 2014 +0200

    ACPI / PNP: use device ID list for PNPACPI device enumeration
    
    ACPI can be used to enumerate PNP devices, but the code does not
    handle this in the right way currently.  Namely, if an ACPI device
    object
     1. Has a _CRS method,
     2. Has an identification of
        "three capital characters followed by four hex digits",
     3. Is not in the excluded IDs list,
    it will be enumerated to PNP bus (that is, a PNP device object will
    be create for it).  This means that, actually, the PNP bus type is
    used as the default bus type for enumerating _HID devices in ACPI.
    
    However, more and more _HID devices need to be enumerated to the
    platform bus instead (that is, platform device objects need to be
    created for them).  As a result, the device ID list in acpi_platform.c
    is used to enforce creating platform device objects rather than PNP
    device objects for matching devices.  That list has been continuously
    growing recently, unfortunately, and it is pretty much guaranteed to
    grow even more in the future.
    
    To address that problem it is better to enumerate _HID devices
    as platform devices by default.  To this end, change the way of
    enumerating PNP devices by adding a PNP ACPI scan handler that
    will use a device ID list to create PNP devices for the ACPI
    device objects whose device IDs are present in that list.
    
    The initial device ID list in the PNP ACPI scan handler contains
    all of the pnp_device_id strings from all the existing PNP drivers,
    so this change should be transparent to the PNP core and all of the
    PNP drivers.  Still, in the future it should be possible to reduce
    its size by converting PNP drivers that need not be PNP for any
    technical reasons into platform drivers.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    [rjw: Rewrote the changelog, modified the PNP ACPI scan handler code]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e44438f7917b..19d524c5c0c8 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2253,6 +2253,7 @@ int __init acpi_scan_init(void)
 	acpi_cmos_rtc_init();
 	acpi_container_init();
 	acpi_memory_hotplug_init();
+	acpi_pnp_init();
 
 	mutex_lock(&acpi_scan_lock);
 	/*

commit aca0a4eb4e325914ddb22a8ed06fcb0222da2a26
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 30 04:21:52 2014 +0200

    ACPI / scan: .match() callback for ACPI scan handlers
    
    Introduce a .match() callback for ACPI scan handlers to allow them to
    use more elaborate matching algorithms if necessary.  That is needed
    for the upcoming PNP scan handler in particular.
    
    This change is based on a Zhang Rui's prototype.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index df6e4c924b35..e44438f7917b 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1977,6 +1977,9 @@ static bool acpi_scan_handler_matching(struct acpi_scan_handler *handler,
 {
 	const struct acpi_device_id *devid;
 
+	if (handler->match)
+		return handler->match(idstr, matchid);
+
 	for (devid = handler->ids; devid->id[0]; devid++)
 		if (!strcmp((char *)devid->id, idstr)) {
 			if (matchid)

commit f25c0ae2b4c41996c1a6b609132c1788a6eea080
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat May 17 00:18:13 2014 +0200

    ACPI / PM: Avoid resuming devices in ACPI PM domain during system suspend
    
    Rework the ACPI PM domain's PM callbacks to avoid resuming devices
    during system suspend (in order to modify their wakeup settings etc.)
    if that isn't necessary.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 7efe546a8c42..df6e4c924b35 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1551,9 +1551,13 @@ static void acpi_bus_get_power_flags(struct acpi_device *device)
 	 */
 	if (acpi_has_method(device->handle, "_PSC"))
 		device->power.flags.explicit_get = 1;
+
 	if (acpi_has_method(device->handle, "_IRC"))
 		device->power.flags.inrush_current = 1;
 
+	if (acpi_has_method(device->handle, "_DSW"))
+		device->power.flags.dsw_present = 1;
+
 	/*
 	 * Enumerate supported power management states
 	 */

commit 2650ef42636848db858625bd933131e8835f8d23
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Mon Apr 28 10:38:04 2014 +0800

    ACPI / scan: do not scan fixed hardware on HW-reduced platform
    
    Fixed hardware does not exist on HW-reduced ACPI platforms since the
    programming interface for them is not implemented on them, so no need
    to scan that hardware on them.
    
    This patch avoids creating the fixed power button ACPI device and
    eliminates a probe error message from ACPI button driver on ASUS T100.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 7efe546a8c42..db5fc6f9628e 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2259,12 +2259,16 @@ int __init acpi_scan_init(void)
 	if (result)
 		goto out;
 
-	result = acpi_bus_scan_fixed();
-	if (result) {
-		acpi_detach_data(acpi_root->handle, acpi_scan_drop_device);
-		acpi_device_del(acpi_root);
-		put_device(&acpi_root->dev);
-		goto out;
+	/* Fixed feature devices do not exist on HW-reduced platform */
+	if (!acpi_gbl_reduced_hardware) {
+		result = acpi_bus_scan_fixed();
+		if (result) {
+			acpi_detach_data(acpi_root->handle,
+					 acpi_scan_drop_device);
+			acpi_device_del(acpi_root);
+			put_device(&acpi_root->dev);
+			goto out;
+		}
 	}
 
 	acpi_update_all_gpes();

commit 165f5fd04aa898fa7dbe4fbe2819cf80453d3bb9
Merge: cb97def86446 71d821fdaec0 7d1af287320b 37f204164dfb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Mar 20 13:25:36 2014 +0100

    Merge branches 'pm-qos', 'pm-domains' and 'pm-drivers'
    
    * pm-qos:
      PM / QoS: Add type to dev_pm_qos_add_ancestor_request() arguments
      ACPI / LPSS: Support for device latency tolerance PM QoS
      ACPI / scan: Add bind/unbind callbacks to struct acpi_scan_handler
      PM / QoS: Introcuce latency tolerance device PM QoS type
      PM / QoS: Add no_constraints_value field to struct pm_qos_constraints
      PM / QoS: Rename device resume latency QoS items
    
    * pm-domains:
      PM / domains: Turn latency warning into debug message
    
    * pm-drivers:
      PM: Add pm_runtime_suspend|resume_force functions
      PM / runtime: Fetch runtime PM callbacks using a macro

commit 2eb060975df2aaca635801dcfb99eaa45ede98fe
Merge: 75c44eddcb49 700b8422fb9e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 17 13:48:18 2014 +0100

    Merge branch 'acpi-ost'
    
    * acpi-ost:
      ACPI: Drop acpi_evaluate_hotplug_ost() and ACPI_HOTPLUG_OST
      ACPI: use device name LNXSYBUS.xx for ACPI \_SB and \_TZ objects
      ACPI / processor: use acpi_evaluate_ost() to replace open-coded version
      ACPI / PAD / xen: use acpi_evaluate_ost() to replace open-coded version
      ACPI / PAD: use acpi_evaluate_ost() to replace open-coded version
      ACPI: rename acpi_evaluate_hotplug_ost() to acpi_evaluate_ost()

commit 1e3bcb596c6b1cf6db93f8f506e2de260e771bad
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 3 00:40:38 2014 +0100

    ACPI / hotplug: Rework deferred execution of acpi_device_hotplug()
    
    Since the only function executed by acpi_hotplug_execute() is
    acpi_device_hotplug() and it only is called by the ACPI core,
    simplify its definition so that it only takes two arguments, the
    ACPI device object pointer and event code, rename it to
    acpi_hotplug_schedule() and move its header from acpi_bus.h to
    the ACPI core's internal header file internal.h.  Modify the
    definition of acpi_device_hotplug() so that its first argument is
    an ACPI device object pointer and modify the definition of
    struct acpi_hp_work accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f6bcc24f73dc..eb7a1ff224e7 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -481,10 +481,9 @@ static int acpi_generic_hotplug_event(struct acpi_device *adev, u32 type)
 	return -EINVAL;
 }
 
-void acpi_device_hotplug(void *data, u32 src)
+void acpi_device_hotplug(struct acpi_device *adev, u32 src)
 {
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
-	struct acpi_device *adev = data;
 	int error = -ENODEV;
 
 	lock_device_hotplug();
@@ -579,8 +578,7 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 		return -ENODEV;
 
 	get_device(&acpi_device->dev);
-	status = acpi_hotplug_execute(acpi_device_hotplug, acpi_device,
-				      ACPI_OST_EC_OSPM_EJECT);
+	status = acpi_hotplug_schedule(acpi_device, ACPI_OST_EC_OSPM_EJECT);
 	if (ACPI_SUCCESS(status))
 		return count;
 

commit 700b8422fb9e6041907bda45a15f4e2ab0438a04
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 21 01:07:17 2014 +0100

    ACPI: Drop acpi_evaluate_hotplug_ost() and ACPI_HOTPLUG_OST
    
    Replace acpi_evaluate_hotplug_ost() with acpi_evaluate_ost()
    everywhere and drop the ACPI_HOTPLUG_OST symbol so that hotplug
    _OST is supported unconditionally.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 3fc530a8d362..f2d8d1c1c391 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -463,8 +463,8 @@ static int acpi_generic_hotplug_event(struct acpi_device *adev, u32 type)
 			dev_info(&adev->dev, "Eject disabled\n");
 			return -EPERM;
 		}
-		acpi_evaluate_hotplug_ost(adev->handle, ACPI_NOTIFY_EJECT_REQUEST,
-					  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
+		acpi_evaluate_ost(adev->handle, ACPI_NOTIFY_EJECT_REQUEST,
+				  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 		return acpi_scan_hot_remove(adev);
 	}
 	return -EINVAL;
@@ -512,7 +512,7 @@ void acpi_device_hotplug(void *data, u32 src)
 		ost_code = ACPI_OST_SC_SUCCESS;
 
  err_out:
-	acpi_evaluate_hotplug_ost(adev->handle, src, ost_code, NULL);
+	acpi_evaluate_ost(adev->handle, src, ost_code, NULL);
 
  out:
 	acpi_bus_put_acpi_device(adev);
@@ -572,8 +572,8 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 		return count;
 
 	put_device(&acpi_device->dev);
-	acpi_evaluate_hotplug_ost(acpi_device->handle, ACPI_OST_EC_OSPM_EJECT,
-				  ACPI_OST_SC_NON_SPECIFIC_FAILURE, NULL);
+	acpi_evaluate_ost(acpi_device->handle, ACPI_OST_EC_OSPM_EJECT,
+			  ACPI_OST_SC_NON_SPECIFIC_FAILURE, NULL);
 	return status == AE_NO_MEMORY ? -ENOMEM : -EAGAIN;
 }
 

commit 5d5132059a1f652de9dc2d62a8ff15561e648d11
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Feb 22 00:48:31 2014 +0100

    ACPI / ATA: Add hotplug contexts to ACPI companions of SATA devices
    
    Modify the SATA subsystem to add hotplug contexts to ACPI companions
    of SATA devices and ports instead of registering special ACPI dock
    operations using register_hotplug_dock_device().
    
    That change will allow the entire code handling those special ACPI
    dock operations to be dropped in the next commit.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com>
    Acked-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e7d951032f85..f6bcc24f73dc 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -71,6 +71,17 @@ void acpi_unlock_hp_context(void)
 	mutex_unlock(&acpi_hp_context_lock);
 }
 
+void acpi_initialize_hp_context(struct acpi_device *adev,
+				struct acpi_hotplug_context *hp,
+				int (*notify)(struct acpi_device *, u32),
+				void (*uevent)(struct acpi_device *, u32))
+{
+	acpi_lock_hp_context();
+	acpi_set_hp_context(adev, hp, notify, uevent, NULL);
+	acpi_unlock_hp_context();
+}
+EXPORT_SYMBOL_GPL(acpi_initialize_hp_context);
+
 int acpi_scan_add_handler(struct acpi_scan_handler *handler)
 {
 	if (!handler || !handler->attach)

commit be27b3dcb02335ec093b81053fc8c84b32d3106e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 21 01:10:27 2014 +0100

    ACPI / dock: Add .uevent() callback to struct acpi_hotplug_context
    
    In order to avoid the need to register special ACPI dock
    operations for SATA devices add a .uevent() callback pointer to
    struct acpi_hotplug_context and make dock_hotplug_event() use that
    callback if available.  Also rename the existing .event() callback
    in struct acpi_hotplug_context to .notify() to avoid possible
    confusion in the future.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 518aae461a00..e7d951032f85 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -496,17 +496,17 @@ void acpi_device_hotplug(void *data, u32 src)
 			goto err_out;
 		}
 	} else {
-		int (*event)(struct acpi_device *, u32);
+		int (*notify)(struct acpi_device *, u32);
 
 		acpi_lock_hp_context();
-		event = adev->hp ? adev->hp->event : NULL;
+		notify = adev->hp ? adev->hp->notify : NULL;
 		acpi_unlock_hp_context();
 		/*
 		 * There may be additional notify handlers for device objects
 		 * without the .event() callback, so ignore them here.
 		 */
-		if (event)
-			error = event(adev, src);
+		if (notify)
+			error = notify(adev, src);
 		else
 			goto out;
 	}

commit 2bd74d91b1217d84d08db57b860d056d130248d3
Merge: ae3caa80a5d5 cc6254e00eb6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 21 01:06:58 2014 +0100

    Merge branch 'acpi-pci-hotplug' into acpi-ost

commit ae3caa80a5d532d334c7a4785d74104e3de5a9ae
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Feb 19 14:02:19 2014 +0800

    ACPI: use device name LNXSYBUS.xx for ACPI \_SB and \_TZ objects
    
    Use device name "LNXSYBUS:xx" instead  of "device.xx" for ACPI objects
    \_SB and \_TZ.
    
    BTW, the original check of "handle == ACPI_ROOT_OBJECT" in statment
    "else if (list_empty(&pnp->ids) && handle == ACPI_ROOT_OBJECT)"
    is always false because of the code at the begin of that block.
                    if (handle == ACPI_ROOT_OBJECT) {
                            acpi_add_id(pnp, ACPI_SYSTEM_HID);
                            break;
                    }
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 57b053f424d1..62ec4ba7ecef 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1706,6 +1706,20 @@ static bool acpi_ibm_smbus_match(acpi_handle handle)
 	return false;
 }
 
+static bool acpi_object_is_system_bus(acpi_handle handle)
+{
+	acpi_handle tmp;
+
+	if (ACPI_SUCCESS(acpi_get_handle(NULL, "\\_SB", &tmp)) &&
+	    tmp == handle)
+		return true;
+	if (ACPI_SUCCESS(acpi_get_handle(NULL, "\\_TZ", &tmp)) &&
+	    tmp == handle)
+		return true;
+
+	return false;
+}
+
 static void acpi_set_pnp_ids(acpi_handle handle, struct acpi_device_pnp *pnp,
 				int device_type)
 {
@@ -1757,8 +1771,10 @@ static void acpi_set_pnp_ids(acpi_handle handle, struct acpi_device_pnp *pnp,
 			acpi_add_id(pnp, ACPI_DOCK_HID);
 		else if (acpi_ibm_smbus_match(handle))
 			acpi_add_id(pnp, ACPI_SMBUS_IBM_HID);
-		else if (list_empty(&pnp->ids) && handle == ACPI_ROOT_OBJECT) {
-			acpi_add_id(pnp, ACPI_BUS_HID); /* \_SB, LNXSYBUS */
+		else if (list_empty(&pnp->ids) &&
+			 acpi_object_is_system_bus(handle)) {
+			/* \_SB, \_TZ, LNXSYBUS */
+			acpi_add_id(pnp, ACPI_BUS_HID);
 			strcpy(pnp->device_name, ACPI_BUS_DEVICE_NAME);
 			strcpy(pnp->device_class, ACPI_BUS_CLASS);
 		}

commit b43109fa466e6e29091b3e62e6a6c8a0bd099beb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Feb 16 00:09:34 2014 +0100

    ACPI / dock: Pass ACPI device pointer to acpi_device_is_battery()
    
    Since we already know what the device's PNP IDs are when
    acpi_device_is_battery() is called, it is not necessary to run
    acpi_get_object_info() for the device in that function.  Instead, if
    acpi_device_is_battery() is passed a pointer to a struct acpi_device
    object, it can use the list of PNP IDs from that object, so make that
    happen and modify the function's header accordingly
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ec12d970d78d..518aae461a00 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1662,24 +1662,22 @@ bool acpi_bay_match(acpi_handle handle)
 	return acpi_ata_match(phandle);
 }
 
-bool acpi_device_is_battery(acpi_handle handle)
+bool acpi_device_is_battery(struct acpi_device *adev)
 {
-	struct acpi_device_info *info;
-	bool ret = false;
-
-	if (!ACPI_SUCCESS(acpi_get_object_info(handle, &info)))
-		return false;
+	struct acpi_hardware_id *hwid;
 
-	if (info->valid & ACPI_VALID_HID)
-		ret = !strcmp("PNP0C0A", info->hardware_id.string);
+	list_for_each_entry(hwid, &adev->pnp.ids, list)
+		if (!strcmp("PNP0C0A", hwid->id))
+			return true;
 
-	kfree(info);
-	return ret;
+	return false;
 }
 
-static bool is_ejectable_bay(acpi_handle handle)
+static bool is_ejectable_bay(struct acpi_device *adev)
 {
-	if (acpi_has_method(handle, "_EJ0") && acpi_device_is_battery(handle))
+	acpi_handle handle = adev->handle;
+
+	if (acpi_has_method(handle, "_EJ0") && acpi_device_is_battery(adev))
 		return true;
 
 	return acpi_bay_match(handle);
@@ -1989,7 +1987,7 @@ static void acpi_scan_init_hotplug(struct acpi_device *adev)
 {
 	struct acpi_hardware_id *hwid;
 
-	if (acpi_dock_match(adev->handle) || is_ejectable_bay(adev->handle)) {
+	if (acpi_dock_match(adev->handle) || is_ejectable_bay(adev)) {
 		acpi_dock_add(adev);
 		return;
 	}

commit 1e2380cd144f6a9619f72f80ad9a93268f63b8dc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Feb 16 01:51:01 2014 +0100

    ACPI / dock: Dispatch dock notifications from the global notify handler
    
    The ACPI dock station code carries out an extra namespace scan
    before the main one in order to find and register all of the dock
    device objects.  Then, it registers a notify handler for each of
    them for handling dock events.
    
    However, dock device objects need not be scanned for upfront.  They
    very well can be enumerated and registered during the first phase
    of the main namespace scan, before attaching scan handlers and ACPI
    drivers to ACPI device objects.  Then, the dependent devices can be
    added to the in the second phase.  That makes it possible to drop
    the extra namespace scan, so do it.
    
    Moreover, it is not necessary to register notify handlers for all
    of the dock stations' namespace nodes, becuase notifications may
    be dispatched from the global notify handler for them.  Do that and
    drop two functions used for dock notify handling, acpi_dock_deferred_cb()
    and dock_notify_handler(), that aren't necessary any more.
    
    Finally, some dock station objects have _HID objects matching the
    ACPI container scan handler which causes it to claim those objects
    and try to handle their hotplug, but that is not a good idea,
    because those objects have their own special hotplug handling anyway.
    For this reason, the hotplug_notify flag should not be set for ACPI
    device objects representing dock stations and the container scan
    handler should be made ignore those objects, so make that happen.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8bb48bfab1df..ec12d970d78d 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -487,7 +487,9 @@ void acpi_device_hotplug(void *data, u32 src)
 	if (adev->handle == INVALID_ACPI_HANDLE)
 		goto err_out;
 
-	if (adev->flags.hotplug_notify) {
+	if (adev->flags.is_dock_station) {
+		error = dock_notify(adev, src);
+	} else if (adev->flags.hotplug_notify) {
 		error = acpi_generic_hotplug_event(adev, src);
 		if (error == -EPERM) {
 			ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
@@ -1660,6 +1662,29 @@ bool acpi_bay_match(acpi_handle handle)
 	return acpi_ata_match(phandle);
 }
 
+bool acpi_device_is_battery(acpi_handle handle)
+{
+	struct acpi_device_info *info;
+	bool ret = false;
+
+	if (!ACPI_SUCCESS(acpi_get_object_info(handle, &info)))
+		return false;
+
+	if (info->valid & ACPI_VALID_HID)
+		ret = !strcmp("PNP0C0A", info->hardware_id.string);
+
+	kfree(info);
+	return ret;
+}
+
+static bool is_ejectable_bay(acpi_handle handle)
+{
+	if (acpi_has_method(handle, "_EJ0") && acpi_device_is_battery(handle))
+		return true;
+
+	return acpi_bay_match(handle);
+}
+
 /*
  * acpi_dock_match - see if an acpi object has a _DCK method
  */
@@ -1964,6 +1989,10 @@ static void acpi_scan_init_hotplug(struct acpi_device *adev)
 {
 	struct acpi_hardware_id *hwid;
 
+	if (acpi_dock_match(adev->handle) || is_ejectable_bay(adev->handle)) {
+		acpi_dock_add(adev);
+		return;
+	}
 	list_for_each_entry(hwid, &adev->pnp.ids, list) {
 		struct acpi_scan_handler *handler;
 
@@ -2035,8 +2064,12 @@ static int acpi_scan_attach_handler(struct acpi_device *device)
 static void acpi_bus_attach(struct acpi_device *device)
 {
 	struct acpi_device *child;
+	acpi_handle ejd;
 	int ret;
 
+	if (ACPI_SUCCESS(acpi_bus_get_ejd(device->handle, &ejd)))
+		register_dock_dependent_device(device, ejd);
+
 	acpi_bus_get_status(device);
 	/* Skip devices that are not present. */
 	if (!acpi_device_is_present(device)) {
@@ -2189,7 +2222,6 @@ int __init acpi_scan_init(void)
 	acpi_cmos_rtc_init();
 	acpi_container_init();
 	acpi_memory_hotplug_init();
-	acpi_dock_init();
 
 	mutex_lock(&acpi_scan_lock);
 	/*

commit 9cb32acf095e806e864c29d060dd79580fcd3d4f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 11 00:35:46 2014 +0100

    ACPI / scan: Add bind/unbind callbacks to struct acpi_scan_handler
    
    In some cases it may be necessary to perform certain setup/cleanup
    operations on a device object representing a physical device after
    it has been associated with an ACPI companion by acpi_bind_one() or
    before disassociating it from that companion by acpi_unbind_one(),
    respectively.  If there is a struct acpi_bus_type object for the
    given device's bus type, the .setup()/.cleanup() callbacks from there
    are executed for these purposes.  However, an analogous mechanism will
    be necessary for devices whose bus types don't have corresponding
    struct acpi_bus_type objects and that have specific ACPI scan handlers.
    
    For those devices, add new .bind() and .unbind() callbacks to struct
    acpi_scan_handler that will be executed by acpi_platform_notify()
    right after the given device has been associated with an ACPI
    comapnion and by acpi_platform_notify_remove() right before calling
    acpi_unbind_one() for that device, respectively.
    
    To make that work for scan handlers registering new devices in their
    .attach() callbacks, modify acpi_scan_attach_handler() to set the
    ACPI device object's handler field before calling .attach() from the
    scan handler at hand.
    
    This changeset includes a fix from Mika Westerberg.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 57b053f424d1..9c4581fd5827 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2015,13 +2015,14 @@ static int acpi_scan_attach_handler(struct acpi_device *device)
 
 		handler = acpi_scan_match_handler(hwid->id, &devid);
 		if (handler) {
+			device->handler = handler;
 			ret = handler->attach(device, devid);
-			if (ret > 0) {
-				device->handler = handler;
+			if (ret > 0)
 				break;
-			} else if (ret < 0) {
+
+			device->handler = NULL;
+			if (ret < 0)
 				break;
-			}
 		}
 	}
 	return ret;

commit 1a699476e25814343766342672c655fb135224cc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Feb 6 13:58:13 2014 +0100

    ACPI / hotplug / PCI: Hotplug notifications from acpi_bus_notify()
    
    Since acpi_bus_notify() is executed on all notifications for all
    devices anyway, make it execute acpi_device_hotplug() for all
    hotplug events instead of installing notify handlers pointing to
    the same function for all hotplug devices.
    
    This change reduces both the size and complexity of ACPI-based device
    hotplug code.  Moreover, since acpi_device_hotplug() only does
    significant things for devices that have either an ACPI scan handler,
    or a hotplug context with .eject() defined, and those devices
    had notify handlers pointing to acpi_hotplug_notify_cb() installed
    before anyway, this modification shouldn't change functionality.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 59f9e272562e..8bb48bfab1df 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -470,7 +470,7 @@ static int acpi_generic_hotplug_event(struct acpi_device *adev, u32 type)
 	return -EINVAL;
 }
 
-static void acpi_device_hotplug(void *data, u32 src)
+void acpi_device_hotplug(void *data, u32 src)
 {
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 	struct acpi_device *adev = data;
@@ -520,75 +520,6 @@ static void acpi_device_hotplug(void *data, u32 src)
 	unlock_device_hotplug();
 }
 
-static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
-{
-	u32 ost_code = ACPI_OST_SC_SUCCESS;
-	struct acpi_device *adev;
-	acpi_status status;
-
-	switch (type) {
-	case ACPI_NOTIFY_BUS_CHECK:
-		acpi_handle_debug(handle, "ACPI_NOTIFY_BUS_CHECK event\n");
-		break;
-
-	case ACPI_NOTIFY_DEVICE_CHECK:
-		acpi_handle_debug(handle, "ACPI_NOTIFY_DEVICE_CHECK event\n");
-		break;
-
-	case ACPI_NOTIFY_EJECT_REQUEST:
-		acpi_handle_debug(handle, "ACPI_NOTIFY_EJECT_REQUEST event\n");
-		break;
-
-	case ACPI_NOTIFY_DEVICE_WAKE:
-		return;
-
-	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
-		acpi_handle_err(handle, "Device cannot be configured due "
-				"to a frequency mismatch\n");
-		goto out;
-
-	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
-		acpi_handle_err(handle, "Device cannot be configured due "
-				"to a bus mode mismatch\n");
-		goto out;
-
-	case ACPI_NOTIFY_POWER_FAULT:
-		acpi_handle_err(handle, "Device has suffered a power fault\n");
-		goto out;
-
-	default:
-		acpi_handle_warn(handle, "Unsupported event type 0x%x\n", type);
-		ost_code = ACPI_OST_SC_UNRECOGNIZED_NOTIFY;
-		goto out;
-	}
-
-	ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
-	adev = acpi_bus_get_acpi_device(handle);
-	if (!adev)
-		goto out;
-
-	status = acpi_hotplug_execute(acpi_device_hotplug, adev, type);
-	if (ACPI_SUCCESS(status))
-		return;
-
-	acpi_bus_put_acpi_device(adev);
-
- out:
-	acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
-}
-
-void acpi_install_hotplug_notify_handler(acpi_handle handle)
-{
-	acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
-				    acpi_hotplug_notify_cb, NULL);
-}
-
-void acpi_remove_hotplug_notify_handler(acpi_handle handle)
-{
-	acpi_remove_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
-				   acpi_hotplug_notify_cb);
-}
-
 static ssize_t real_power_state_show(struct device *dev,
 				     struct device_attribute *attr, char *buf)
 {
@@ -2037,12 +1968,10 @@ static void acpi_scan_init_hotplug(struct acpi_device *adev)
 		struct acpi_scan_handler *handler;
 
 		handler = acpi_scan_match_handler(hwid->id, NULL);
-		if (!handler)
-			continue;
-
-		acpi_install_hotplug_notify_handler(adev->handle);
-		adev->flags.hotplug_notify = true;
-		break;
+		if (handler) {
+			adev->flags.hotplug_notify = true;
+			break;
+		}
 	}
 }
 

commit 5e6f236c263117cef5f0d68e3fec241ba2adc4fc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Feb 6 13:57:58 2014 +0100

    ACPI / hotplug / PCI: Simplify acpi_install_hotplug_notify_handler()
    
    Since acpi_hotplug_notify_cb() does not use its data argument any
    more, the second argument of acpi_install_hotplug_notify_handler()
    can be dropped, so do that and update its callers accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a3f5d6eabe46..59f9e272562e 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -577,10 +577,10 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 	acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
 }
 
-void acpi_install_hotplug_notify_handler(acpi_handle handle, void *data)
+void acpi_install_hotplug_notify_handler(acpi_handle handle)
 {
 	acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
-				    acpi_hotplug_notify_cb, data);
+				    acpi_hotplug_notify_cb, NULL);
 }
 
 void acpi_remove_hotplug_notify_handler(acpi_handle handle)
@@ -2040,7 +2040,7 @@ static void acpi_scan_init_hotplug(struct acpi_device *adev)
 		if (!handler)
 			continue;
 
-		acpi_install_hotplug_notify_handler(adev->handle, handler);
+		acpi_install_hotplug_notify_handler(adev->handle);
 		adev->flags.hotplug_notify = true;
 		break;
 	}

commit dd2151be28b9ed734fc5738ac675ed7e234847e3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 4 00:44:02 2014 +0100

    ACPI / hotplug / PCI: Rework the handling of eject requests
    
    To avoid the need to install a hotplug notify handler for each ACPI
    namespace node representing a device and having a matching scan
    handler, move the check whether or not the ejection of the given
    device is enabled through its scan handler from acpi_hotplug_notify_cb()
    to acpi_generic_hotplug_event().  Also, move the execution of
    ACPI_OST_SC_EJECT_IN_PROGRESS _OST to acpi_generic_hotplug_event(),
    because in acpi_hotplug_notify_cb() or in acpi_eject_store() we really
    don't know whether or not the eject is going to be in progress (for
    example, acpi_hotplug_execute() may still fail without queuing up the
    work item).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 984eaff235df..a3f5d6eabe46 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -459,6 +459,12 @@ static int acpi_generic_hotplug_event(struct acpi_device *adev, u32 type)
 		return acpi_scan_device_check(adev);
 	case ACPI_NOTIFY_EJECT_REQUEST:
 	case ACPI_OST_EC_OSPM_EJECT:
+		if (adev->handler && !adev->handler->hotplug.enabled) {
+			dev_info(&adev->dev, "Eject disabled\n");
+			return -EPERM;
+		}
+		acpi_evaluate_hotplug_ost(adev->handle, ACPI_NOTIFY_EJECT_REQUEST,
+					  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 		return acpi_scan_hot_remove(adev);
 	}
 	return -EINVAL;
@@ -483,6 +489,10 @@ static void acpi_device_hotplug(void *data, u32 src)
 
 	if (adev->flags.hotplug_notify) {
 		error = acpi_generic_hotplug_event(adev, src);
+		if (error == -EPERM) {
+			ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
+			goto err_out;
+		}
 	} else {
 		int (*event)(struct acpi_device *, u32);
 
@@ -512,7 +522,6 @@ static void acpi_device_hotplug(void *data, u32 src)
 
 static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 {
-	struct acpi_scan_handler *handler = data;
 	u32 ost_code = ACPI_OST_SC_SUCCESS;
 	struct acpi_device *adev;
 	acpi_status status;
@@ -528,13 +537,6 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 
 	case ACPI_NOTIFY_EJECT_REQUEST:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_EJECT_REQUEST event\n");
-		if (handler && !handler->hotplug.enabled) {
-			acpi_handle_err(handle, "Eject disabled\n");
-			ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
-			goto out;
-		}
-		acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
-					  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 		break;
 
 	case ACPI_NOTIFY_DEVICE_WAKE:
@@ -632,8 +634,6 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 	if (ACPI_FAILURE(status) || !acpi_device->flags.ejectable)
 		return -ENODEV;
 
-	acpi_evaluate_hotplug_ost(acpi_device->handle, ACPI_OST_EC_OSPM_EJECT,
-				  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 	get_device(&acpi_device->dev);
 	status = acpi_hotplug_execute(acpi_device_hotplug, acpi_device,
 				      ACPI_OST_EC_OSPM_EJECT);

commit 3c2cc7ff9e2522e42468f8e81a7277be386c5ec4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Feb 6 17:31:37 2014 +0100

    ACPI / hotplug / PCI: Consolidate ACPIPHP with ACPI core hotplug
    
    The ACPI-based PCI hotplug (ACPIPHP) code currently attaches its
    hotplug context objects directly to ACPI namespace nodes representing
    hotplug devices.  However, after recent changes causing struct
    acpi_device to be created for every namespace node representing a
    device (regardless of its status), that is not necessary any more.
    Moreover, it's vulnerable to the theoretical issue that the ACPI
    handle passed in the context between handle_hotplug_event() and
    hotplug_event_work() may become invalid in the meantime (as a
    result of a concurrent table unload).
    
    In principle, this issue might be addressed by adding a non-empty
    release handler for ACPIPHP hotplug context objects analogous to
    acpi_scan_drop_device(), but that would duplicate the code in that
    function and in acpi_device_del_work_fn().  For this reason, it's
    better to modify ACPIPHP to attach its device hotplug contexts to
    struct device objects representing hotplug devices and make it
    use acpi_hotplug_notify_cb() as its notify handler.  At the same
    time, acpi_device_hotplug() can be modified to dispatch the new
    .hp.event() callback pointing to acpiphp_hotplug_event() from ACPI
    device objects associated with PCI devices or use the generic
    ACPI device hotplug code for device objects with matching scan
    handlers.
    
    This allows the existing code duplication between ACPIPHP and the
    ACPI core to be reduced too and makes further ACPI-based device
    hotplug consolidation possible.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d64a5826ef35..984eaff235df 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -450,43 +450,61 @@ static int acpi_scan_bus_check(struct acpi_device *adev)
 	return 0;
 }
 
+static int acpi_generic_hotplug_event(struct acpi_device *adev, u32 type)
+{
+	switch (type) {
+	case ACPI_NOTIFY_BUS_CHECK:
+		return acpi_scan_bus_check(adev);
+	case ACPI_NOTIFY_DEVICE_CHECK:
+		return acpi_scan_device_check(adev);
+	case ACPI_NOTIFY_EJECT_REQUEST:
+	case ACPI_OST_EC_OSPM_EJECT:
+		return acpi_scan_hot_remove(adev);
+	}
+	return -EINVAL;
+}
+
 static void acpi_device_hotplug(void *data, u32 src)
 {
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 	struct acpi_device *adev = data;
-	int error;
+	int error = -ENODEV;
 
 	lock_device_hotplug();
 	mutex_lock(&acpi_scan_lock);
 
 	/*
 	 * The device object's ACPI handle cannot become invalid as long as we
-	 * are holding acpi_scan_lock, but it may have become invalid before
+	 * are holding acpi_scan_lock, but it might have become invalid before
 	 * that lock was acquired.
 	 */
 	if (adev->handle == INVALID_ACPI_HANDLE)
-		goto out;
+		goto err_out;
 
-	switch (src) {
-	case ACPI_NOTIFY_BUS_CHECK:
-		error = acpi_scan_bus_check(adev);
-		break;
-	case ACPI_NOTIFY_DEVICE_CHECK:
-		error = acpi_scan_device_check(adev);
-		break;
-	case ACPI_NOTIFY_EJECT_REQUEST:
-	case ACPI_OST_EC_OSPM_EJECT:
-		error = acpi_scan_hot_remove(adev);
-		break;
-	default:
-		error = -EINVAL;
-		break;
+	if (adev->flags.hotplug_notify) {
+		error = acpi_generic_hotplug_event(adev, src);
+	} else {
+		int (*event)(struct acpi_device *, u32);
+
+		acpi_lock_hp_context();
+		event = adev->hp ? adev->hp->event : NULL;
+		acpi_unlock_hp_context();
+		/*
+		 * There may be additional notify handlers for device objects
+		 * without the .event() callback, so ignore them here.
+		 */
+		if (event)
+			error = event(adev, src);
+		else
+			goto out;
 	}
 	if (!error)
 		ost_code = ACPI_OST_SC_SUCCESS;
 
- out:
+ err_out:
 	acpi_evaluate_hotplug_ost(adev->handle, src, ost_code, NULL);
+
+ out:
 	acpi_bus_put_acpi_device(adev);
 	mutex_unlock(&acpi_scan_lock);
 	unlock_device_hotplug();
@@ -494,8 +512,8 @@ static void acpi_device_hotplug(void *data, u32 src)
 
 static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 {
-	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 	struct acpi_scan_handler *handler = data;
+	u32 ost_code = ACPI_OST_SC_SUCCESS;
 	struct acpi_device *adev;
 	acpi_status status;
 
@@ -503,26 +521,49 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 	case ACPI_NOTIFY_BUS_CHECK:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_BUS_CHECK event\n");
 		break;
+
 	case ACPI_NOTIFY_DEVICE_CHECK:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_DEVICE_CHECK event\n");
 		break;
+
 	case ACPI_NOTIFY_EJECT_REQUEST:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_EJECT_REQUEST event\n");
-		if (!handler->hotplug.enabled) {
+		if (handler && !handler->hotplug.enabled) {
 			acpi_handle_err(handle, "Eject disabled\n");
 			ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
-			goto err_out;
+			goto out;
 		}
 		acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
 					  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 		break;
-	default:
-		/* non-hotplug event; possibly handled by other handler */
+
+	case ACPI_NOTIFY_DEVICE_WAKE:
 		return;
+
+	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
+		acpi_handle_err(handle, "Device cannot be configured due "
+				"to a frequency mismatch\n");
+		goto out;
+
+	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
+		acpi_handle_err(handle, "Device cannot be configured due "
+				"to a bus mode mismatch\n");
+		goto out;
+
+	case ACPI_NOTIFY_POWER_FAULT:
+		acpi_handle_err(handle, "Device has suffered a power fault\n");
+		goto out;
+
+	default:
+		acpi_handle_warn(handle, "Unsupported event type 0x%x\n", type);
+		ost_code = ACPI_OST_SC_UNRECOGNIZED_NOTIFY;
+		goto out;
 	}
+
+	ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 	adev = acpi_bus_get_acpi_device(handle);
 	if (!adev)
-		goto err_out;
+		goto out;
 
 	status = acpi_hotplug_execute(acpi_device_hotplug, adev, type);
 	if (ACPI_SUCCESS(status))
@@ -530,10 +571,22 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 
 	acpi_bus_put_acpi_device(adev);
 
- err_out:
+ out:
 	acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
 }
 
+void acpi_install_hotplug_notify_handler(acpi_handle handle, void *data)
+{
+	acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
+				    acpi_hotplug_notify_cb, data);
+}
+
+void acpi_remove_hotplug_notify_handler(acpi_handle handle)
+{
+	acpi_remove_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
+				   acpi_hotplug_notify_cb);
+}
+
 static ssize_t real_power_state_show(struct device *dev,
 				     struct device_attribute *attr, char *buf)
 {
@@ -1976,33 +2029,21 @@ void acpi_scan_hotplug_enabled(struct acpi_hotplug_profile *hotplug, bool val)
 	mutex_unlock(&acpi_scan_lock);
 }
 
-static void acpi_scan_init_hotplug(acpi_handle handle, int type)
+static void acpi_scan_init_hotplug(struct acpi_device *adev)
 {
-	struct acpi_device_pnp pnp = {};
 	struct acpi_hardware_id *hwid;
-	struct acpi_scan_handler *handler;
 
-	INIT_LIST_HEAD(&pnp.ids);
-	acpi_set_pnp_ids(handle, &pnp, type);
-
-	if (!pnp.type.hardware_id)
-		goto out;
+	list_for_each_entry(hwid, &adev->pnp.ids, list) {
+		struct acpi_scan_handler *handler;
 
-	/*
-	 * This relies on the fact that acpi_install_notify_handler() will not
-	 * install the same notify handler routine twice for the same handle.
-	 */
-	list_for_each_entry(hwid, &pnp.ids, list) {
 		handler = acpi_scan_match_handler(hwid->id, NULL);
-		if (handler) {
-			acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
-					acpi_hotplug_notify_cb, handler);
-			break;
-		}
-	}
+		if (!handler)
+			continue;
 
-out:
-	acpi_free_pnp_ids(&pnp);
+		acpi_install_hotplug_notify_handler(adev->handle, handler);
+		adev->flags.hotplug_notify = true;
+		break;
+	}
 }
 
 static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
@@ -2026,12 +2067,12 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 		return AE_OK;
 	}
 
-	acpi_scan_init_hotplug(handle, type);
-
 	acpi_add_single_object(&device, handle, type, sta);
 	if (!device)
 		return AE_CTRL_DEPTH;
 
+	acpi_scan_init_hotplug(device);
+
  out:
 	if (!*return_value)
 		*return_value = device;

commit e525506fcb67a9bbd94f01eac84af802139004eb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 4 00:43:17 2014 +0100

    ACPI / hotplug / PCI: Define hotplug context lock in the core
    
    Subsequent changes will require the ACPI core to acquire the lock
    protecting the ACPIPHP hotplug contexts, so move the definition of
    the lock to the core and change its name to be more generic.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 59eba29a6066..d64a5826ef35 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -41,6 +41,7 @@ static DEFINE_MUTEX(acpi_scan_lock);
 static LIST_HEAD(acpi_scan_handlers_list);
 DEFINE_MUTEX(acpi_device_lock);
 LIST_HEAD(acpi_wakeup_device_list);
+static DEFINE_MUTEX(acpi_hp_context_lock);
 
 struct acpi_device_bus_id{
 	char bus_id[15];
@@ -60,6 +61,16 @@ void acpi_scan_lock_release(void)
 }
 EXPORT_SYMBOL_GPL(acpi_scan_lock_release);
 
+void acpi_lock_hp_context(void)
+{
+	mutex_lock(&acpi_hp_context_lock);
+}
+
+void acpi_unlock_hp_context(void)
+{
+	mutex_unlock(&acpi_hp_context_lock);
+}
+
 int acpi_scan_add_handler(struct acpi_scan_handler *handler)
 {
 	if (!handler || !handler->attach)

commit 78ea4639a7647f2fcc957c3a532bde49df9895c7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 4 00:43:05 2014 +0100

    ACPI / hotplug: Fix potential race in acpi_bus_notify()
    
    There is a slight possibility for the ACPI device object pointed to
    by adev in acpi_hotplug_notify_cb() to become invalid between the
    acpi_bus_get_device() that it comes from and the subsequent dereference
    of that pointer under get_device().  Namely, if acpi_scan_drop_device()
    runs in parallel with acpi_hotplug_notify_cb(), acpi_device_del_work_fn()
    queued up by it may delete the device object in question right after
    a successful execution of acpi_bus_get_device() in acpi_bus_notify().
    
    An analogous problem is present in acpi_bus_notify() where the device
    pointer coming from acpi_bus_get_device() may become invalid before
    it subsequent dereference in the "if" block.
    
    To prevent that from happening, introduce a new function,
    acpi_bus_get_acpi_device(), working analogously to acpi_bus_get_device()
    except that it will grab a reference to the ACPI device object returned
    by it and it will do that under the ACPICA's namespace mutex.  Then,
    make both acpi_hotplug_notify_cb() and acpi_bus_notify() use
    acpi_bus_get_acpi_device() instead of acpi_bus_get_device() so as to
    ensure that the pointers used by them will not become stale at one
    point.
    
    In addition to that, introduce acpi_bus_put_acpi_device() as a wrapper
    around put_device() to be used along with acpi_bus_get_acpi_device()
    and make the (new) users of the latter use acpi_bus_put_acpi_device()
    too.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 7384158c7f87..59eba29a6066 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -476,7 +476,7 @@ static void acpi_device_hotplug(void *data, u32 src)
 
  out:
 	acpi_evaluate_hotplug_ost(adev->handle, src, ost_code, NULL);
-	put_device(&adev->dev);
+	acpi_bus_put_acpi_device(adev);
 	mutex_unlock(&acpi_scan_lock);
 	unlock_device_hotplug();
 }
@@ -488,9 +488,6 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 	struct acpi_device *adev;
 	acpi_status status;
 
-	if (acpi_bus_get_device(handle, &adev))
-		goto err_out;
-
 	switch (type) {
 	case ACPI_NOTIFY_BUS_CHECK:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_BUS_CHECK event\n");
@@ -512,12 +509,15 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 		/* non-hotplug event; possibly handled by other handler */
 		return;
 	}
-	get_device(&adev->dev);
+	adev = acpi_bus_get_acpi_device(handle);
+	if (!adev)
+		goto err_out;
+
 	status = acpi_hotplug_execute(acpi_device_hotplug, adev, type);
 	if (ACPI_SUCCESS(status))
 		return;
 
-	put_device(&adev->dev);
+	acpi_bus_put_acpi_device(adev);
 
  err_out:
 	acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
@@ -1112,14 +1112,16 @@ static void acpi_scan_drop_device(acpi_handle handle, void *context)
 	mutex_unlock(&acpi_device_del_lock);
 }
 
-int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
+static int acpi_get_device_data(acpi_handle handle, struct acpi_device **device,
+				void (*callback)(void *))
 {
 	acpi_status status;
 
 	if (!device)
 		return -EINVAL;
 
-	status = acpi_get_data(handle, acpi_scan_drop_device, (void **)device);
+	status = acpi_get_data_full(handle, acpi_scan_drop_device,
+				    (void **)device, callback);
 	if (ACPI_FAILURE(status) || !*device) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No context for object [%p]\n",
 				  handle));
@@ -1127,8 +1129,32 @@ int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
 	}
 	return 0;
 }
+
+int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
+{
+	return acpi_get_device_data(handle, device, NULL);
+}
 EXPORT_SYMBOL(acpi_bus_get_device);
 
+static void get_acpi_device(void *dev)
+{
+	if (dev)
+		get_device(&((struct acpi_device *)dev)->dev);
+}
+
+struct acpi_device *acpi_bus_get_acpi_device(acpi_handle handle)
+{
+	struct acpi_device *adev = NULL;
+
+	acpi_get_device_data(handle, &adev, get_acpi_device);
+	return adev;
+}
+
+void acpi_bus_put_acpi_device(struct acpi_device *adev)
+{
+	put_device(&adev->dev);
+}
+
 int acpi_device_add(struct acpi_device *device,
 		    void (*release)(struct device *))
 {

commit 8fcfb99c8e29c73dd8945b6105ef54ca4eeb171e
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Tue Feb 4 17:48:28 2014 -0700

    ACPI / hotplug: Fix panic on eject to ejected device
    
    When an eject request is sent to an ejected ACPI device, the following
    panic occurs:
    
     ACPI: \_SB_.SCK3.CPU3: ACPI_NOTIFY_EJECT_REQUEST event
     BUG: unable to handle kernel NULL pointer dereference at 0000000000000070
     IP: [<ffffffff813a7cfe>] acpi_device_hotplug+0x10b/0x33b
            :
     Call Trace:
     [<ffffffff813a24da>] acpi_hotplug_work_fn+0x1c/0x27
     [<ffffffff8109cbe5>] process_one_work+0x175/0x430
     [<ffffffff8109d7db>] worker_thread+0x11b/0x3a0
    
    This is becase device->handler is NULL in acpi_device_hotplug().
    This case was used to fail in acpi_hotplug_notify_cb() as the target
    had no acpi_deivce.  However, acpi_device now exists after ejection.
    
    Added a check to verify if acpi_device->handler is valid for an
    eject request in acpi_hotplug_notify_cb().  Note that handler passed
    from an argument is still valid while acpi_device->handler is NULL.
    
    Fixes: 202317a573b2 (ACPI / scan: Add acpi_device objects for all device nodes in the namespace)
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 7384158c7f87..57b053f424d1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -484,7 +484,6 @@ static void acpi_device_hotplug(void *data, u32 src)
 static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 {
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
-	struct acpi_scan_handler *handler = data;
 	struct acpi_device *adev;
 	acpi_status status;
 
@@ -500,7 +499,10 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 		break;
 	case ACPI_NOTIFY_EJECT_REQUEST:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_EJECT_REQUEST event\n");
-		if (!handler->hotplug.enabled) {
+		if (!adev->handler)
+			goto err_out;
+
+		if (!adev->handler->hotplug.enabled) {
 			acpi_handle_err(handle, "Eject disabled\n");
 			ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
 			goto err_out;

commit 82e180598b54873553fb1d285fb0c90fc54f8f23
Merge: 09da8dfa9868 f778d1218f10 a951c773bc39 49a12877d277 79c0373f3e84 481c13814a4e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 29 11:47:18 2014 +0100

    Merge branches 'acpi-processor', 'acpi-hotplug', 'acpi-init', 'acpi-pm' and 'acpica'
    
    * acpi-processor:
      ACPI / scan: reduce log level of "ACPI: \_PR_.CPU4: failed to get CPU APIC ID"
      ACPI / processor: Return specific error value when mapping lapic id
    
    * acpi-hotplug:
      ACPI / scan: Clear match_driver flag in acpi_bus_trim()
    
    * acpi-init:
      ACPI / init: Flag use of ACPI and ACPI idioms for power supplies to regulator API
    
    * acpi-pm:
      ACPI / PM: Use ACPI_COMPANION() to get ACPI companions of devices
    
    * acpica:
      ACPICA: Remove bool usage from ACPICA.

commit a951c773bc39677ef3fa42814be7f5218a3100b2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jan 27 23:08:09 2014 +0100

    ACPI / scan: Clear match_driver flag in acpi_bus_trim()
    
    Drivers should not bind to struct acpi_device objects that
    acpi_bus_trim() has been called for, so make that function
    clear flags.match_driver for those objects.
    
    If that is not done, an ACPI driver may theoretically try to operate
    a device that is not physically present.
    
    Fixes: 202317a573b2 (ACPI / scan: Add acpi_device objects for all device nodes in the namespace)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c0f57ff15024..089dc403c43b 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2044,6 +2044,7 @@ void acpi_bus_trim(struct acpi_device *adev)
 	list_for_each_entry_reverse(child, &adev->children, node)
 		acpi_bus_trim(child);
 
+	adev->flags.match_driver = false;
 	if (handler) {
 		if (handler->detach)
 			handler->detach(adev);

commit bc411b8a643825b634916f9ba167546a88a0ac28
Merge: 8341ecc9f4eb b9f73067f325
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 17 01:59:38 2014 +0100

    Merge branch 'acpi-modules'
    
    * acpi-modules:
      platform: introduce OF style 'modalias' support for platform bus
      ACPI: fix module autoloading for ACPI enumerated devices
      ACPI: add module autoloading support for ACPI enumerated devices
      ACPI: fix create_modalias() return value handling

commit 6eb2451f7c43c4a7f84ae7b613ea975317b951f1
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Jan 14 16:46:36 2014 +0800

    ACPI: add module autoloading support for ACPI enumerated devices
    
    An ACPI enumerated device may have its compatible id strings.
    
    To support the compatible ACPI ids (acpi_device->pnp.ids),
    we introduced acpi_driver_match_device() to match
    the driver->acpi_match_table and acpi_device->pnp.ids.
    
    For those drivers, MODULE_DEVICE_TABLE(acpi, xxx) is used to
    exports the driver module alias in the format of
    "acpi:device_compatible_ids".
    But in the mean time, the current code does not export the
    ACPI compatible strings as part of the module_alias for the
    ACPI enumerated devices, which will break the module autoloading.
    
    Take the following piece of code for example,
    static const struct acpi_device_id xxx_acpi_match[] = {
            { "INTABCD", 0 },
            { }
    };
    MODULE_DEVICE_TABLE(acpi, xxx_acpi_match);
    
    If this piece of code is used in a platform driver for
    an ACPI enumerated platform device, the platform driver module_alias
    is "acpi:INTABCD", but the uevent attribute of its platform device node
    is "platform:INTABCD:00" (PREFIX:platform_device->name).
    If this piece of code is used in an i2c driver for an ACPI enumerated
    i2c device, the i2c driver module_alias is "acpi:INTABCD", but
    the uevent of its i2c device node is "i2c:INTABCD:00" (PREFIX:i2c_client->name).
    If this piece of code is used in an spi driver for an ACPI enumerated
    spi device, the spi driver module_alias is "acpi:INTABCD", but
    the uevent of its spi device node is "spi:INTABCD" (PREFIX:spi_device->modalias).
    
    The reason why the module autoloading is not broken for now is that
    the uevent file of the ACPI device node is "acpi:INTABCD".
    Thus it is the ACPI device node creation that loads the platform/i2c/spi driver.
    
    So this is a problem that will affect us the day when the ACPI bus
    is removed from device model.
    
    This patch introduces two new APIs,
    one for exporting ACPI ids in uevent MODALIAS field,
    and another for exporting ACPI ids in device' modalias sysfs attribute.
    
    For any bus that supports ACPI enumerated devices, it needs to invoke
    these two functions for their uevent and modalias attribute.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c92532158195..680bb5647701 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -116,6 +116,63 @@ static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
 	return len;
 }
 
+/*
+ * Creates uevent modalias field for ACPI enumerated devices.
+ * Because the other buses does not support ACPI HIDs & CIDs.
+ * e.g. for a device with hid:IBM0001 and cid:ACPI0001 you get:
+ * "acpi:IBM0001:ACPI0001"
+ */
+int acpi_device_uevent_modalias(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct acpi_device *acpi_dev;
+	int len;
+
+	acpi_dev = ACPI_COMPANION(dev);
+	if (!acpi_dev)
+		return -ENODEV;
+
+	/* Fall back to bus specific way of modalias exporting */
+	if (list_empty(&acpi_dev->pnp.ids))
+		return -ENODEV;
+
+	if (add_uevent_var(env, "MODALIAS="))
+		return -ENOMEM;
+	len = create_modalias(acpi_dev, &env->buf[env->buflen - 1],
+				sizeof(env->buf) - env->buflen);
+	if (len <= 0)
+		return len;
+	env->buflen += len;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(acpi_device_uevent_modalias);
+
+/*
+ * Creates modalias sysfs attribute for ACPI enumerated devices.
+ * Because the other buses does not support ACPI HIDs & CIDs.
+ * e.g. for a device with hid:IBM0001 and cid:ACPI0001 you get:
+ * "acpi:IBM0001:ACPI0001"
+ */
+int acpi_device_modalias(struct device *dev, char *buf, int size)
+{
+	struct acpi_device *acpi_dev;
+	int len;
+
+	acpi_dev = ACPI_COMPANION(dev);
+	if (!acpi_dev)
+		return -ENODEV;
+
+	/* Fall back to bus specific way of modalias exporting */
+	if (list_empty(&acpi_dev->pnp.ids))
+		return -ENODEV;
+
+	len = create_modalias(acpi_dev, buf, size -1);
+	if (len <= 0)
+		return len;
+	buf[len++] = '\n';
+	return len;
+}
+EXPORT_SYMBOL_GPL(acpi_device_modalias);
+
 static ssize_t
 acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, char *buf) {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);

commit 3d8e00909df96c2d3eace3996748be9c0a437e5a
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Jan 14 16:46:35 2014 +0800

    ACPI: fix create_modalias() return value handling
    
    Currently, create_modalias() handles the output truncated case in
    an improper way (return -EINVAL).
    Plus, acpi_device_uevent() and acpi_device_modalias_show() do
    improper check for the create_modalias() return value as well.
    
    This patch fixes create_modalias() to
    return -EINVAL if there is an output error,
    return -ENOMEM if the output is truncated,
    and also fixes both acpi_device_uevent() and acpi_device_modalias_show()
    to do proper return value check.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index fd39459926b1..c92532158195 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -85,6 +85,9 @@ int acpi_scan_add_handler_with_hotplug(struct acpi_scan_handler *handler,
  * Creates hid/cid(s) string needed for modalias and uevent
  * e.g. on a device with hid:IBM0001 and cid:ACPI0001 you get:
  * char *modalias: "acpi:IBM0001:ACPI0001"
+ * Return: 0: no _HID and no _CID
+ *         -EINVAL: output error
+ *         -ENOMEM: output is truncated
 */
 static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
 			   int size)
@@ -101,8 +104,10 @@ static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
 
 	list_for_each_entry(id, &acpi_dev->pnp.ids, list) {
 		count = snprintf(&modalias[len], size, "%s:", id->id);
-		if (count < 0 || count >= size)
-			return -EINVAL;
+		if (count < 0)
+			return EINVAL;
+		if (count >= size)
+			return -ENOMEM;
 		len += count;
 		size -= count;
 	}
@@ -116,10 +121,9 @@ acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, cha
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 	int len;
 
-	/* Device has no HID and no CID or string is >1024 */
 	len = create_modalias(acpi_dev, buf, 1024);
 	if (len <= 0)
-		return 0;
+		return len;
 	buf[len++] = '\n';
 	return len;
 }
@@ -782,8 +786,8 @@ static int acpi_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 		return -ENOMEM;
 	len = create_modalias(acpi_dev, &env->buf[env->buflen - 1],
 			      sizeof(env->buf) - env->buflen);
-	if (len >= (sizeof(env->buf) - env->buflen))
-		return -ENOMEM;
+	if (len <= 0)
+		return len;
 	env->buflen += len;
 	return 0;
 }

commit c713cd7f2d799c50a0721bf51d178ea9567215dd
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Fri Jan 10 16:00:05 2014 -0800

    ACPI / scan: ACPI device object sysfs attribute for _STA evaluation
    
    This patch adds a "status" attribute for an ACPI device. This status
    attribute shows the value of the _STA object. The _STA object returns
    current status of an ACPI device: enabled, disabled, functioning,
    present.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    [rjw: Subject and changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 32b340171d41..c0f57ff15024 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -602,6 +602,20 @@ acpi_device_sun_show(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR(sun, 0444, acpi_device_sun_show, NULL);
 
+static ssize_t status_show(struct device *dev, struct device_attribute *attr,
+				char *buf) {
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+	acpi_status status;
+	unsigned long long sta;
+
+	status = acpi_evaluate_integer(acpi_dev->handle, "_STA", NULL, &sta);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	return sprintf(buf, "%llu\n", sta);
+}
+static DEVICE_ATTR_RO(status);
+
 static int acpi_device_setup_files(struct acpi_device *dev)
 {
 	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
@@ -657,6 +671,12 @@ static int acpi_device_setup_files(struct acpi_device *dev)
 		dev->pnp.sun = (unsigned long)-1;
 	}
 
+	if (acpi_has_method(dev->handle, "_STA")) {
+		result = device_create_file(&dev->dev, &dev_attr_status);
+		if (result)
+			goto end;
+	}
+
         /*
          * If device has _EJ0, 'eject' file is created that is used to trigger
          * hot-removal function from userland.
@@ -712,6 +732,8 @@ static void acpi_device_remove_files(struct acpi_device *dev)
 		device_remove_file(&dev->dev, &dev_attr_adr);
 	device_remove_file(&dev->dev, &dev_attr_modalias);
 	device_remove_file(&dev->dev, &dev_attr_hid);
+	if (acpi_has_method(dev->handle, "_STA"))
+		device_remove_file(&dev->dev, &dev_attr_status);
 	if (dev->handle)
 		device_remove_file(&dev->dev, &dev_attr_path);
 }

commit caa73ea158de9419f08e456f2716c71d1f06012a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 29 15:25:48 2013 +0100

    ACPI / hotplug / driver core: Handle containers in a special way
    
    ACPI container devices require special hotplug handling, at least
    on some systems, since generally user space needs to carry out
    system-specific cleanup before it makes sense to offline devices in
    the container.  However, the current ACPI hotplug code for containers
    first attempts to offline devices in the container and only then it
    notifies user space of the container offline.
    
    Moreover, after commit 202317a573b2 (ACPI / scan: Add acpi_device
    objects for all device nodes in the namespace), ACPI device objects
    representing containers are present as long as the ACPI namespace
    nodes corresponding to them are present, which may be forever, even
    if the container devices are physically detached from the system (the
    return values of the corresponding _STA methods change in those
    cases, but generally the namespace nodes themselves are still there).
    Thus it is useful to introduce entities representing containers that
    will go away during container hot-unplug.
    
    The goal of this change is to address both the above issues.
    
    The idea is to create a "companion" container system device for each
    of the ACPI container device objects during the initial namespace
    scan or on a hotplug event making the container present.  That system
    device will be unregistered on container removal.  A new bus type
    for container devices is added for this purpose, because device
    offline and online operations need to be defined for them.  The
    online operation is a trivial function that is always successful
    and the offline uses a callback pointed to by the container device's
    offline member.
    
    For ACPI containers that callback simply walks the list of ACPI
    device objects right below the container object (its children) and
    checks if all of their physical companion devices are offline.  If
    that's not the case, it returns -EBUSY and the container system
    devivce cannot be put offline.  Consequently, to put the container
    system device offline, it is necessary to put all of the physical
    devices depending on its ACPI companion object offline beforehand.
    
    Container system devices created for ACPI container objects are
    initially online.  They are created by the container ACPI scan
    handler whose hotplug.demand_offline flag is set.  That causes
    acpi_scan_hot_remove() to check if the companion container system
    device is offline before attempting to remove an ACPI container or
    any devices below it.  If the check fails, a KOBJ_CHANGE uevent is
    emitted for the container system device in question and user space
    is expected to offline all devices below the container and the
    container itself in response to it.  Then, user space can finalize
    the removal of the container with the help of its ACPI device
    object's eject attribute in sysfs.
    
    Tested-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 65243b9dd868..32b340171d41 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -126,7 +126,7 @@ acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, cha
 }
 static DEVICE_ATTR(modalias, 0444, acpi_device_modalias_show, NULL);
 
-static bool acpi_scan_is_offline(struct acpi_device *adev)
+bool acpi_scan_is_offline(struct acpi_device *adev, bool uevent)
 {
 	struct acpi_device_physical_node *pn;
 	bool offline = true;
@@ -135,7 +135,9 @@ static bool acpi_scan_is_offline(struct acpi_device *adev)
 
 	list_for_each_entry(pn, &adev->physical_node_list, node)
 		if (device_supports_offline(pn->dev) && !pn->dev->offline) {
-			kobject_uevent(&pn->dev->kobj, KOBJ_CHANGE);
+			if (uevent)
+				kobject_uevent(&pn->dev->kobj, KOBJ_CHANGE);
+
 			offline = false;
 			break;
 		}
@@ -267,7 +269,7 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	acpi_status status;
 
 	if (device->handler->hotplug.demand_offline && !acpi_force_hot_remove) {
-		if (!acpi_scan_is_offline(device))
+		if (!acpi_scan_is_offline(device, true))
 			return -EBUSY;
 	} else {
 		int error = acpi_scan_try_to_offline(device);

commit d22ddcbc4fb7a483d0721eddfda3f0558821d372
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 29 15:25:35 2013 +0100

    ACPI / hotplug: Add demand_offline hotplug profile flag
    
    Add a new ACPI hotplug profile flag, demand_offline, such that if
    set for the given ACPI device object's scan handler, it will cause
    acpi_scan_hot_remove() to check if that device object's physical
    companions are offline upfront and fail the hot removal if that
    is not the case.
    
    That flag will be useful to overcome a problem with containers on
    some system where they can only be hot-removed after some cleanup
    operations carried out by user space, which needs to be notified
    of the container hot-removal before the kernel attempts to offline
    devices in the container.  In those cases the current implementation
    of acpi_scan_hot_remove() is not sufficient, because it first tries
    to offline the devices in the container and only if that is
    suffcessful it tries to offline the container itself.  As a result,
    the container hot-removal notification is not delivered to user space
    at the right time.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5383c81a8a1b..65243b9dd868 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -126,6 +126,24 @@ acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, cha
 }
 static DEVICE_ATTR(modalias, 0444, acpi_device_modalias_show, NULL);
 
+static bool acpi_scan_is_offline(struct acpi_device *adev)
+{
+	struct acpi_device_physical_node *pn;
+	bool offline = true;
+
+	mutex_lock(&adev->physical_node_lock);
+
+	list_for_each_entry(pn, &adev->physical_node_list, node)
+		if (device_supports_offline(pn->dev) && !pn->dev->offline) {
+			kobject_uevent(&pn->dev->kobj, KOBJ_CHANGE);
+			offline = false;
+			break;
+		}
+
+	mutex_unlock(&adev->physical_node_lock);
+	return offline;
+}
+
 static acpi_status acpi_bus_offline(acpi_handle handle, u32 lvl, void *data,
 				    void **ret_p)
 {
@@ -196,12 +214,11 @@ static acpi_status acpi_bus_online(acpi_handle handle, u32 lvl, void *data,
 	return AE_OK;
 }
 
-static int acpi_scan_hot_remove(struct acpi_device *device)
+static int acpi_scan_try_to_offline(struct acpi_device *device)
 {
 	acpi_handle handle = device->handle;
-	struct device *errdev;
+	struct device *errdev = NULL;
 	acpi_status status;
-	unsigned long long sta;
 
 	/*
 	 * Carry out two passes here and ignore errors in the first pass,
@@ -212,7 +229,6 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	 *
 	 * If the first pass is successful, the second one isn't needed, though.
 	 */
-	errdev = NULL;
 	status = acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
 				     NULL, acpi_bus_offline, (void *)false,
 				     (void **)&errdev);
@@ -241,6 +257,23 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 			return -EBUSY;
 		}
 	}
+	return 0;
+}
+
+static int acpi_scan_hot_remove(struct acpi_device *device)
+{
+	acpi_handle handle = device->handle;
+	unsigned long long sta;
+	acpi_status status;
+
+	if (device->handler->hotplug.demand_offline && !acpi_force_hot_remove) {
+		if (!acpi_scan_is_offline(device))
+			return -EBUSY;
+	} else {
+		int error = acpi_scan_try_to_offline(device);
+		if (error)
+			return error;
+	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 		"Hot-removing device %s...\n", dev_name(&device->dev)));

commit 9ccad66f0171578445175ecd3bf66b35a96aaf6e
Merge: 8ff47aafb25c 8b48463f8942
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Dec 7 01:05:17 2013 +0100

    Merge branch 'acpi-cleanup' into acpi-hotplug
    
    Conflicts:
            drivers/acpi/scan.c

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 15daa21fcd05..56421a921a2b 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -12,8 +12,6 @@
 #include <linux/dmi.h>
 #include <linux/nls.h>
 
-#include <acpi/acpi_drivers.h>
-
 #include "internal.h"
 
 #define _COMPONENT		ACPI_BUS_COMPONENT

commit 434a438af20865cd41ab08c07281b72637460e41
Merge: 6ce4eac1f600 ca499fc87ed9 de03beedb43f 51468a9d3a80
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 25 22:30:30 2013 +0100

    Merge branches 'acpi-hotplug', 'acpi-sysfs' and 'acpi-sleep'
    
    * acpi-hotplug:
      ACPI / hotplug: Fix conflicted PCI bridge notify handlers
    
    * acpi-sysfs:
      ACPI / sysfs: Fix incorrect ACPI tables walk in acpi_tables_sysfs_init()
      ACPI / sysfs: Set file size for each exposed ACPI table
    
    * acpi-sleep:
      ACPI / sleep: clean up compiler warning about uninitialized field

commit 2c22e6520ac87d8b12d4d9941e81d4119f2d903c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 25 00:52:21 2013 +0100

    ACPI / scan: Use direct recurrence for device hierarchy walks
    
    Rework acpi_bus_trim() and acpi_bus_device_attach(), which is
    renamed as acpi_bus_attach(), to walk the list of each device
    object's children directly and call themselves recursively for
    each child instead of using acpi_walk_namespace().  This
    simplifies the code quite a bit and avoids the overhead of
    callbacks and the ACPICA's internal processing which are not
    really necessary for these two routines.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index cf773c918102..311904c720b1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1909,54 +1909,40 @@ static int acpi_scan_attach_handler(struct acpi_device *device)
 	return ret;
 }
 
-static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
-					  void *not_used, void **ret_not_used)
+static void acpi_bus_attach(struct acpi_device *device)
 {
-	struct acpi_device *device;
-	unsigned long long sta;
+	struct acpi_device *child;
 	int ret;
 
-	/*
-	 * Ignore errors ignored by acpi_bus_check_add() to avoid terminating
-	 * namespace walks prematurely.
-	 */
-	if (acpi_bus_type_and_status(handle, &ret, &sta))
-		return AE_OK;
-
-	if (acpi_bus_get_device(handle, &device))
-		return AE_CTRL_DEPTH;
-
-	acpi_set_device_status(device, sta);
+	acpi_bus_get_status(device);
 	/* Skip devices that are not present. */
-	if (!acpi_device_is_present(device))
-		goto err;
-
+	if (!acpi_device_is_present(device)) {
+		device->flags.visited = false;
+		return;
+	}
 	if (device->handler)
-		return AE_OK;
+		goto ok;
 
 	if (!device->flags.initialized) {
 		acpi_bus_update_power(device, NULL);
 		device->flags.initialized = true;
 	}
+	device->flags.visited = false;
 	ret = acpi_scan_attach_handler(device);
 	if (ret < 0)
-		goto err;
+		return;
 
 	device->flags.match_driver = true;
-	if (ret > 0)
-		goto ok;
-
-	ret = device_attach(&device->dev);
-	if (ret < 0)
-		goto err;
-
- ok:
+	if (!ret) {
+		ret = device_attach(&device->dev);
+		if (ret < 0)
+			return;
+	}
 	device->flags.visited = true;
-	return AE_OK;
 
- err:
-	device->flags.visited = false;
-	return AE_CTRL_DEPTH;
+ ok:
+	list_for_each_entry(child, &device->children, node)
+		acpi_bus_attach(child);
 }
 
 /**
@@ -1976,64 +1962,48 @@ static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 int acpi_bus_scan(acpi_handle handle)
 {
 	void *device = NULL;
-	int error = 0;
 
 	if (ACPI_SUCCESS(acpi_bus_check_add(handle, 0, NULL, &device)))
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
 				    acpi_bus_check_add, NULL, NULL, &device);
 
-	if (!device)
-		error = -ENODEV;
-	else if (ACPI_SUCCESS(acpi_bus_device_attach(handle, 0, NULL, NULL)))
-		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
-				    acpi_bus_device_attach, NULL, NULL, NULL);
-
-	return error;
-}
-EXPORT_SYMBOL(acpi_bus_scan);
-
-static acpi_status acpi_bus_device_detach(acpi_handle handle, u32 lvl_not_used,
-					  void *not_used, void **ret_not_used)
-{
-	struct acpi_device *device = NULL;
-
-	if (!acpi_bus_get_device(handle, &device)) {
-		struct acpi_scan_handler *dev_handler = device->handler;
-
-		if (dev_handler) {
-			if (dev_handler->detach)
-				dev_handler->detach(device);
-
-			device->handler = NULL;
-		} else {
-			device_release_driver(&device->dev);
-		}
-		/*
-		 * Most likely, the device is going away, so put it into D3cold
-		 * before that.
-		 */
-		acpi_device_set_power(device, ACPI_STATE_D3_COLD);
-		device->flags.initialized = false;
-		device->flags.visited = false;
+	if (device) {
+		acpi_bus_attach(device);
+		return 0;
 	}
-	return AE_OK;
+	return -ENODEV;
 }
+EXPORT_SYMBOL(acpi_bus_scan);
 
 /**
- * acpi_bus_trim - Remove ACPI device node and all of its descendants
- * @start: Root of the ACPI device nodes subtree to remove.
+ * acpi_bus_trim - Detach scan handlers and drivers from ACPI device objects.
+ * @adev: Root of the ACPI namespace scope to walk.
  *
  * Must be called under acpi_scan_lock.
  */
-void acpi_bus_trim(struct acpi_device *start)
+void acpi_bus_trim(struct acpi_device *adev)
 {
+	struct acpi_scan_handler *handler = adev->handler;
+	struct acpi_device *child;
+
+	list_for_each_entry_reverse(child, &adev->children, node)
+		acpi_bus_trim(child);
+
+	if (handler) {
+		if (handler->detach)
+			handler->detach(adev);
+
+		adev->handler = NULL;
+	} else {
+		device_release_driver(&adev->dev);
+	}
 	/*
-	 * Execute acpi_bus_device_detach() as a post-order callback to detach
-	 * all ACPI drivers from the device nodes being removed.
+	 * Most likely, the device is going away, so put it into D3cold before
+	 * that.
 	 */
-	acpi_walk_namespace(ACPI_TYPE_ANY, start->handle, ACPI_UINT32_MAX, NULL,
-			    acpi_bus_device_detach, NULL, NULL);
-	acpi_bus_device_detach(start->handle, 0, NULL, NULL);
+	acpi_device_set_power(adev, ACPI_STATE_D3_COLD);
+	adev->flags.initialized = false;
+	adev->flags.visited = false;
 }
 EXPORT_SYMBOL_GPL(acpi_bus_trim);
 

commit 25db115b0bf72acfdf8a339fa8e37d8b895214d6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 22 21:56:06 2013 +0100

    ACPI: Introduce acpi_set_device_status()
    
    Introduce a static inline function for setting the status field
    of struct acpi_device on the basis of a supplied u32 number,
    acpi_set_device_status(), and use it instead of the horrible
    horrible STRUCT_TO_INT() macro wherever applicable.  Having done
    that, drop STRUCT_TO_INT() (and pretend that it has never existed).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 06db2c036085..cf773c918102 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -20,7 +20,6 @@
 
 #define _COMPONENT		ACPI_BUS_COMPONENT
 ACPI_MODULE_NAME("scan");
-#define STRUCT_TO_INT(s)	(*((int*)&s))
 extern struct acpi_device *acpi_root;
 
 #define ACPI_BUS_CLASS			"system_bus"
@@ -1683,7 +1682,7 @@ void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 	device->device_type = type;
 	device->handle = handle;
 	device->parent = acpi_bus_get_parent(handle);
-	STRUCT_TO_INT(device->status) = sta;
+	acpi_set_device_status(device, sta);
 	acpi_device_get_busid(device);
 	acpi_set_pnp_ids(handle, &device->pnp, type);
 	acpi_bus_get_flags(device);
@@ -1927,7 +1926,7 @@ static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 	if (acpi_bus_get_device(handle, &device))
 		return AE_CTRL_DEPTH;
 
-	STRUCT_TO_INT(device->status) = sta;
+	acpi_set_device_status(device, sta);
 	/* Skip devices that are not present. */
 	if (!acpi_device_is_present(device))
 		goto err;

commit 443fc8202272190c4693209b772edba46cd7fe61
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 22 21:55:43 2013 +0100

    ACPI / hotplug: Rework generic code to handle suprise removals
    
    The generic ACPI hotplug code used for several types of device
    doesn't handle surprise removals, mostly because those devices
    currently cannot be removed by surprise in the majority of systems.
    However, surprise removals should be handled by that code as well
    as surprise additions of devices, so make it do that.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b1b8f4304597..06db2c036085 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -276,18 +276,72 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	return 0;
 }
 
+static int acpi_scan_device_not_present(struct acpi_device *adev)
+{
+	if (!acpi_device_enumerated(adev)) {
+		dev_warn(&adev->dev, "Still not present\n");
+		return -EALREADY;
+	}
+	acpi_bus_trim(adev);
+	return 0;
+}
+
 static int acpi_scan_device_check(struct acpi_device *adev)
 {
 	int error;
 
+	acpi_bus_get_status(adev);
+	if (adev->status.present || adev->status.functional) {
+		/*
+		 * This function is only called for device objects for which
+		 * matching scan handlers exist.  The only situation in which
+		 * the scan handler is not attached to this device object yet
+		 * is when the device has just appeared (either it wasn't
+		 * present at all before or it was removed and then added
+		 * again).
+		 */
+		if (adev->handler) {
+			dev_warn(&adev->dev, "Already enumerated\n");
+			return -EALREADY;
+		}
+		error = acpi_bus_scan(adev->handle);
+		if (error) {
+			dev_warn(&adev->dev, "Namespace scan failure\n");
+			return error;
+		}
+		if (!adev->handler) {
+			dev_warn(&adev->dev, "Enumeration failure\n");
+			error = -ENODEV;
+		}
+	} else {
+		error = acpi_scan_device_not_present(adev);
+	}
+	return error;
+}
+
+static int acpi_scan_bus_check(struct acpi_device *adev)
+{
+	struct acpi_scan_handler *handler = adev->handler;
+	struct acpi_device *child;
+	int error;
+
+	acpi_bus_get_status(adev);
+	if (!(adev->status.present || adev->status.functional)) {
+		acpi_scan_device_not_present(adev);
+		return 0;
+	}
+	if (handler && handler->hotplug.scan_dependent)
+		return handler->hotplug.scan_dependent(adev);
+
 	error = acpi_bus_scan(adev->handle);
 	if (error) {
 		dev_warn(&adev->dev, "Namespace scan failure\n");
 		return error;
 	}
-	if (!adev->handler) {
-		dev_warn(&adev->dev, "Enumeration failure\n");
-		return -ENODEV;
+	list_for_each_entry(child, &adev->children, node) {
+		error = acpi_scan_bus_check(child);
+		if (error)
+			return error;
 	}
 	return 0;
 }
@@ -296,7 +350,6 @@ static void acpi_device_hotplug(void *data, u32 src)
 {
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 	struct acpi_device *adev = data;
-	struct acpi_scan_handler *handler;
 	int error;
 
 	lock_device_hotplug();
@@ -310,32 +363,12 @@ static void acpi_device_hotplug(void *data, u32 src)
 	if (adev->handle == INVALID_ACPI_HANDLE)
 		goto out;
 
-	handler = adev->handler;
-
 	switch (src) {
 	case ACPI_NOTIFY_BUS_CHECK:
-		if (handler) {
-			error = handler->hotplug.scan_dependent ?
-					handler->hotplug.scan_dependent(adev) :
-					acpi_bus_scan(adev->handle);
-		} else {
-			error = acpi_scan_device_check(adev);
-		}
+		error = acpi_scan_bus_check(adev);
 		break;
 	case ACPI_NOTIFY_DEVICE_CHECK:
-		/*
-		 * This code is only run for device objects for which matching
-		 * scan handlers exist.  The only situation in which the scan
-		 * handler is not attached to this device object yet is when the
-		 * device has just appeared (either it wasn't present at all
-		 * before or it was removed and then added again).
-		 */
-		if (adev->handler) {
-			dev_warn(&adev->dev, "Already enumerated\n");
-			error = -EBUSY;
-		} else {
-			error = acpi_scan_device_check(adev);
-		}
+		error = acpi_scan_device_check(adev);
 		break;
 	case ACPI_NOTIFY_EJECT_REQUEST:
 	case ACPI_OST_EC_OSPM_EJECT:

commit 46394fd017c0615982a3d29d45ced14bea9c526d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 22 21:55:32 2013 +0100

    ACPI / hotplug: Move container-specific code out of the core
    
    Move container-specific uevents from the core hotplug code to the
    container scan handler's .attach() and .detach() callbacks.
    
    This way the core will not have to special-case containers and
    the uevents will be guaranteed to happen every time a container
    is either scanned or trimmed as appropriate.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 18865c86c463..b1b8f4304597 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -206,9 +206,6 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	acpi_status status;
 	unsigned long long sta;
 
-	if (device->handler && device->handler->hotplug.mode == AHM_CONTAINER)
-		kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
-
 	/*
 	 * Carry out two passes here and ignore errors in the first pass,
 	 * because if the devices in question are memory blocks and
@@ -288,10 +285,7 @@ static int acpi_scan_device_check(struct acpi_device *adev)
 		dev_warn(&adev->dev, "Namespace scan failure\n");
 		return error;
 	}
-	if (adev->handler) {
-		if (adev->handler->hotplug.mode == AHM_CONTAINER)
-			kobject_uevent(&adev->dev.kobj, KOBJ_ONLINE);
-	} else {
+	if (!adev->handler) {
 		dev_warn(&adev->dev, "Enumeration failure\n");
 		return -ENODEV;
 	}

commit 3338db0057ed9f554050bd06863731c515d79672
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 22 21:55:20 2013 +0100

    ACPI / hotplug: Make ACPI PCI root hotplug use common hotplug code
    
    Rework the common ACPI device hotplug code so that it is suitable
    for PCI host bridge hotplug and switch the PCI host bridge scan
    handler to using the common hotplug code.
    
    This allows quite a few lines of code that are not necessary any more
    to be dropped from the PCI host bridge scan handler and removes
    arbitrary differences in behavior between PCI host bridge hotplug
    and ACPI-based hotplug of other components, like CPUs and memory.
    
    Also acpi_device_hotplug() can be static now.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index dd0ff9de9277..18865c86c463 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -283,17 +283,6 @@ static int acpi_scan_device_check(struct acpi_device *adev)
 {
 	int error;
 
-	/*
-	 * This function is only called for device objects for which matching
-	 * scan handlers exist.  The only situation in which the scan handler is
-	 * not attached to this device object yet is when the device has just
-	 * appeared (either it wasn't present at all before or it was removed
-	 * and then added again).
-	 */
-	if (adev->handler) {
-		dev_warn(&adev->dev, "Already enumerated\n");
-		return -EBUSY;
-	}
 	error = acpi_bus_scan(adev->handle);
 	if (error) {
 		dev_warn(&adev->dev, "Namespace scan failure\n");
@@ -309,10 +298,11 @@ static int acpi_scan_device_check(struct acpi_device *adev)
 	return 0;
 }
 
-void acpi_device_hotplug(void *data, u32 src)
+static void acpi_device_hotplug(void *data, u32 src)
 {
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 	struct acpi_device *adev = data;
+	struct acpi_scan_handler *handler;
 	int error;
 
 	lock_device_hotplug();
@@ -326,12 +316,32 @@ void acpi_device_hotplug(void *data, u32 src)
 	if (adev->handle == INVALID_ACPI_HANDLE)
 		goto out;
 
+	handler = adev->handler;
+
 	switch (src) {
 	case ACPI_NOTIFY_BUS_CHECK:
-		error = acpi_bus_scan(adev->handle);
+		if (handler) {
+			error = handler->hotplug.scan_dependent ?
+					handler->hotplug.scan_dependent(adev) :
+					acpi_bus_scan(adev->handle);
+		} else {
+			error = acpi_scan_device_check(adev);
+		}
 		break;
 	case ACPI_NOTIFY_DEVICE_CHECK:
-		error = acpi_scan_device_check(adev);
+		/*
+		 * This code is only run for device objects for which matching
+		 * scan handlers exist.  The only situation in which the scan
+		 * handler is not attached to this device object yet is when the
+		 * device has just appeared (either it wasn't present at all
+		 * before or it was removed and then added again).
+		 */
+		if (adev->handler) {
+			dev_warn(&adev->dev, "Already enumerated\n");
+			error = -EBUSY;
+		} else {
+			error = acpi_scan_device_check(adev);
+		}
 		break;
 	case ACPI_NOTIFY_EJECT_REQUEST:
 	case ACPI_OST_EC_OSPM_EJECT:
@@ -1805,7 +1815,7 @@ static void acpi_scan_init_hotplug(acpi_handle handle, int type)
 	 */
 	list_for_each_entry(hwid, &pnp.ids, list) {
 		handler = acpi_scan_match_handler(hwid->id, NULL);
-		if (handler && !handler->hotplug.ignore) {
+		if (handler) {
 			acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
 					acpi_hotplug_notify_cb, handler);
 			break;
@@ -2083,8 +2093,6 @@ int __init acpi_scan_init(void)
 
 	acpi_update_all_gpes();
 
-	acpi_pci_root_hp_init();
-
  out:
 	mutex_unlock(&acpi_scan_lock);
 	return result;

commit c27b2c33b6215eeb3d5c290ac889ab6d543f6207
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 22 21:55:07 2013 +0100

    ACPI / hotplug: Introduce common hotplug function acpi_device_hotplug()
    
    Modify the common ACPI device hotplug code to always queue up the
    same function, acpi_device_hotplug(), using acpi_hotplug_execute()
    and make the PCI host bridge hotplug code use that function too for
    device hot removal.
    
    This allows some code duplication to be reduced and a race condition
    where the relevant ACPI handle may become invalid between the
    notification handler and the function queued up by it via
    acpi_hotplug_execute() to be avoided.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 4fa416f94f52..dd0ff9de9277 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -206,12 +206,8 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	acpi_status status;
 	unsigned long long sta;
 
-	/* If there is no handle, the device node has been unregistered. */
-	if (!handle) {
-		dev_dbg(&device->dev, "ACPI handle missing\n");
-		put_device(&device->dev);
-		return -EINVAL;
-	}
+	if (device->handler && device->handler->hotplug.mode == AHM_CONTAINER)
+		kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
 
 	/*
 	 * Carry out two passes here and ignore errors in the first pass,
@@ -230,7 +226,6 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 		dev_warn(errdev, "Offline disabled.\n");
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
 				    acpi_bus_online, NULL, NULL, NULL);
-		put_device(&device->dev);
 		return -EPERM;
 	}
 	acpi_bus_offline(handle, 0, (void *)false, (void **)&errdev);
@@ -249,7 +244,6 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 			acpi_walk_namespace(ACPI_TYPE_ANY, handle,
 					    ACPI_UINT32_MAX, acpi_bus_online,
 					    NULL, NULL, NULL);
-			put_device(&device->dev);
 			return -EBUSY;
 		}
 	}
@@ -259,9 +253,6 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 
 	acpi_bus_trim(device);
 
-	put_device(&device->dev);
-	device = NULL;
-
 	acpi_evaluate_lck(handle, 0);
 	/*
 	 * TBD: _EJD support.
@@ -288,77 +279,74 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	return 0;
 }
 
-void acpi_bus_device_eject(void *data, u32 ost_src)
+static int acpi_scan_device_check(struct acpi_device *adev)
 {
-	struct acpi_device *device = data;
-	acpi_handle handle = device->handle;
-	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 	int error;
 
-	lock_device_hotplug();
-	mutex_lock(&acpi_scan_lock);
-
-	if (ost_src == ACPI_NOTIFY_EJECT_REQUEST)
-		acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
-					  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
-
-	if (device->handler && device->handler->hotplug.mode == AHM_CONTAINER)
-		kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
-
-	error = acpi_scan_hot_remove(device);
-	if (error == -EPERM) {
-		goto err_support;
-	} else if (error) {
-		goto err_out;
+	/*
+	 * This function is only called for device objects for which matching
+	 * scan handlers exist.  The only situation in which the scan handler is
+	 * not attached to this device object yet is when the device has just
+	 * appeared (either it wasn't present at all before or it was removed
+	 * and then added again).
+	 */
+	if (adev->handler) {
+		dev_warn(&adev->dev, "Already enumerated\n");
+		return -EBUSY;
 	}
-
- out:
-	mutex_unlock(&acpi_scan_lock);
-	unlock_device_hotplug();
-	return;
-
- err_support:
-	ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
- err_out:
-	acpi_evaluate_hotplug_ost(handle, ost_src, ost_code, NULL);
-	goto out;
+	error = acpi_bus_scan(adev->handle);
+	if (error) {
+		dev_warn(&adev->dev, "Namespace scan failure\n");
+		return error;
+	}
+	if (adev->handler) {
+		if (adev->handler->hotplug.mode == AHM_CONTAINER)
+			kobject_uevent(&adev->dev.kobj, KOBJ_ONLINE);
+	} else {
+		dev_warn(&adev->dev, "Enumeration failure\n");
+		return -ENODEV;
+	}
+	return 0;
 }
 
-static void acpi_scan_bus_device_check(void *data, u32 ost_source)
+void acpi_device_hotplug(void *data, u32 src)
 {
-	acpi_handle handle = data;
-	struct acpi_device *device;
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
+	struct acpi_device *adev = data;
 	int error;
 
 	lock_device_hotplug();
 	mutex_lock(&acpi_scan_lock);
 
-	if (ost_source != ACPI_NOTIFY_BUS_CHECK) {
-		device = NULL;
-		acpi_bus_get_device(handle, &device);
-		if (acpi_device_enumerated(device)) {
-			dev_warn(&device->dev, "Attempt to re-insert\n");
-			goto out;
-		}
-	}
-	error = acpi_bus_scan(handle);
-	if (error) {
-		acpi_handle_warn(handle, "Namespace scan failure\n");
-		goto out;
-	}
-	device = NULL;
-	acpi_bus_get_device(handle, &device);
-	if (!acpi_device_enumerated(device)) {
-		acpi_handle_warn(handle, "Device not enumerated\n");
+	/*
+	 * The device object's ACPI handle cannot become invalid as long as we
+	 * are holding acpi_scan_lock, but it may have become invalid before
+	 * that lock was acquired.
+	 */
+	if (adev->handle == INVALID_ACPI_HANDLE)
 		goto out;
+
+	switch (src) {
+	case ACPI_NOTIFY_BUS_CHECK:
+		error = acpi_bus_scan(adev->handle);
+		break;
+	case ACPI_NOTIFY_DEVICE_CHECK:
+		error = acpi_scan_device_check(adev);
+		break;
+	case ACPI_NOTIFY_EJECT_REQUEST:
+	case ACPI_OST_EC_OSPM_EJECT:
+		error = acpi_scan_hot_remove(adev);
+		break;
+	default:
+		error = -EINVAL;
+		break;
 	}
-	ost_code = ACPI_OST_SC_SUCCESS;
-	if (device->handler && device->handler->hotplug.mode == AHM_CONTAINER)
-		kobject_uevent(&device->dev.kobj, KOBJ_ONLINE);
+	if (!error)
+		ost_code = ACPI_OST_SC_SUCCESS;
 
  out:
-	acpi_evaluate_hotplug_ost(handle, ost_source, ost_code, NULL);
+	acpi_evaluate_hotplug_ost(adev->handle, src, ost_code, NULL);
+	put_device(&adev->dev);
 	mutex_unlock(&acpi_scan_lock);
 	unlock_device_hotplug();
 }
@@ -370,6 +358,9 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 	struct acpi_device *adev;
 	acpi_status status;
 
+	if (acpi_bus_get_device(handle, &adev))
+		goto err_out;
+
 	switch (type) {
 	case ACPI_NOTIFY_BUS_CHECK:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_BUS_CHECK event\n");
@@ -384,24 +375,20 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 			ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
 			goto err_out;
 		}
-		if (acpi_bus_get_device(handle, &adev))
-			goto err_out;
-
-		get_device(&adev->dev);
-		status = acpi_hotplug_execute(acpi_bus_device_eject, adev, type);
-		if (ACPI_SUCCESS(status))
-			return;
-
-		put_device(&adev->dev);
-		goto err_out;
+		acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
+					  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
+		break;
 	default:
 		/* non-hotplug event; possibly handled by other handler */
 		return;
 	}
-	status = acpi_hotplug_execute(acpi_scan_bus_device_check, handle, type);
+	get_device(&adev->dev);
+	status = acpi_hotplug_execute(acpi_device_hotplug, adev, type);
 	if (ACPI_SUCCESS(status))
 		return;
 
+	put_device(&adev->dev);
+
  err_out:
 	acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
 }
@@ -454,7 +441,7 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 	acpi_evaluate_hotplug_ost(acpi_device->handle, ACPI_OST_EC_OSPM_EJECT,
 				  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 	get_device(&acpi_device->dev);
-	status = acpi_hotplug_execute(acpi_bus_device_eject, acpi_device,
+	status = acpi_hotplug_execute(acpi_device_hotplug, acpi_device,
 				      ACPI_OST_EC_OSPM_EJECT);
 	if (ACPI_SUCCESS(status))
 		return count;

commit 1ceaba05b4afb4bd7b4b4801f2718c13f59321eb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 22 21:54:52 2013 +0100

    ACPI / hotplug: Do not fail bus and device checks for disabled hotplug
    
    If the scan handler for the given device has hotplug.enabled
    unset, it doesn't really make sense to fail bus check and device
    check notifications.
    
    First, bus check may not have anything to do with the device it is
    signaled for, but it may concern another device on the bus below
    this one.  For this reason, bus check notifications should not be
    failed if hotplug is disabled for the target device.
    
    Second, device check notifications are signaled only after a device
    has already appeared (or disappeared), so failing it can only prevent
    scan handlers and drivers from attaching to that (already existing)
    device, which is not very useful.
    
    Consequently, if device hotplug is disabled through the device's
    scan handler, fail eject request notifications only.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index bc52192785f1..4fa416f94f52 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -363,43 +363,13 @@ static void acpi_scan_bus_device_check(void *data, u32 ost_source)
 	unlock_device_hotplug();
 }
 
-static void acpi_hotplug_unsupported(acpi_handle handle, u32 type)
-{
-	u32 ost_status;
-
-	switch (type) {
-	case ACPI_NOTIFY_BUS_CHECK:
-		acpi_handle_debug(handle,
-			"ACPI_NOTIFY_BUS_CHECK event: unsupported\n");
-		ost_status = ACPI_OST_SC_INSERT_NOT_SUPPORTED;
-		break;
-	case ACPI_NOTIFY_DEVICE_CHECK:
-		acpi_handle_debug(handle,
-			"ACPI_NOTIFY_DEVICE_CHECK event: unsupported\n");
-		ost_status = ACPI_OST_SC_INSERT_NOT_SUPPORTED;
-		break;
-	case ACPI_NOTIFY_EJECT_REQUEST:
-		acpi_handle_debug(handle,
-			"ACPI_NOTIFY_EJECT_REQUEST event: unsupported\n");
-		ost_status = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
-		break;
-	default:
-		/* non-hotplug event; possibly handled by other handler */
-		return;
-	}
-
-	acpi_evaluate_hotplug_ost(handle, type, ost_status, NULL);
-}
-
 static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 {
+	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 	struct acpi_scan_handler *handler = data;
 	struct acpi_device *adev;
 	acpi_status status;
 
-	if (!handler->hotplug.enabled)
-		return acpi_hotplug_unsupported(handle, type);
-
 	switch (type) {
 	case ACPI_NOTIFY_BUS_CHECK:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_BUS_CHECK event\n");
@@ -409,6 +379,11 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 		break;
 	case ACPI_NOTIFY_EJECT_REQUEST:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_EJECT_REQUEST event\n");
+		if (!handler->hotplug.enabled) {
+			acpi_handle_err(handle, "Eject disabled\n");
+			ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
+			goto err_out;
+		}
 		if (acpi_bus_get_device(handle, &adev))
 			goto err_out;
 
@@ -428,8 +403,7 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 		return;
 
  err_out:
-	acpi_evaluate_hotplug_ost(handle, type,
-				  ACPI_OST_SC_NON_SPECIFIC_FAILURE, NULL);
+	acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
 }
 
 static ssize_t real_power_state_show(struct device *dev,

commit 202317a573b20d77a9abb7c16a3fd5b40cef3d9d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 22 21:54:37 2013 +0100

    ACPI / scan: Add acpi_device objects for all device nodes in the namespace
    
    Modify the ACPI namespace scanning code to register a struct
    acpi_device object for every namespace node representing a device,
    processor and so on, even if the device represented by that namespace
    node is reported to be not present and not functional by _STA.
    
    There are multiple reasons to do that.  First of all, it avoids
    quite a lot of overhead when struct acpi_device objects are
    deleted every time acpi_bus_trim() is run and then added again
    by a subsequent acpi_bus_scan() for the same scope, although the
    namespace objects they correspond to stay in memory all the time
    (which always is the case on a vast majority of systems).
    
    Second, it will allow user space to see that there are namespace
    nodes representing devices that are not present at the moment and may
    be added to the system.  It will also allow user space to evaluate
    _SUN for those nodes to check what physical slots the "missing"
    devices may be put into and it will make sense to add a sysfs
    attribute for _STA evaluation after this change (that will be
    useful for thermal management on some systems).
    
    Next, it will help to consolidate the ACPI hotplug handling among
    subsystems by making it possible to store hotplug-related information
    in struct acpi_device objects in a standard common way.
    
    Finally, it will help to avoid a race condition related to the
    deletion of ACPI namespace nodes.  Namely, namespace nodes may be
    deleted as a result of a table unload triggered by _EJ0 or _DCK.
    If a hotplug notification for one of those nodes is triggered
    right before the deletion and it executes a hotplug callback
    via acpi_hotplug_execute(), the ACPI handle passed to that
    callback may be stale when the callback actually runs.  One way
    to work around that is to always pass struct acpi_device pointers
    to hotplug callbacks after doing a get_device() on the objects in
    question which eliminates the use-after-free possibility (the ACPI
    handles in those objects are invalidated by acpi_scan_drop_device(),
    so they will trigger ACPICA errors on attempts to use them).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ad2522015e5e..bc52192785f1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -259,7 +259,6 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 
 	acpi_bus_trim(device);
 
-	/* Device node has been unregistered. */
 	put_device(&device->dev);
 	device = NULL;
 
@@ -328,7 +327,7 @@ void acpi_bus_device_eject(void *data, u32 ost_src)
 static void acpi_scan_bus_device_check(void *data, u32 ost_source)
 {
 	acpi_handle handle = data;
-	struct acpi_device *device = NULL;
+	struct acpi_device *device;
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 	int error;
 
@@ -336,8 +335,9 @@ static void acpi_scan_bus_device_check(void *data, u32 ost_source)
 	mutex_lock(&acpi_scan_lock);
 
 	if (ost_source != ACPI_NOTIFY_BUS_CHECK) {
+		device = NULL;
 		acpi_bus_get_device(handle, &device);
-		if (device) {
+		if (acpi_device_enumerated(device)) {
 			dev_warn(&device->dev, "Attempt to re-insert\n");
 			goto out;
 		}
@@ -347,9 +347,10 @@ static void acpi_scan_bus_device_check(void *data, u32 ost_source)
 		acpi_handle_warn(handle, "Namespace scan failure\n");
 		goto out;
 	}
-	error = acpi_bus_get_device(handle, &device);
-	if (error) {
-		acpi_handle_warn(handle, "Missing device node object\n");
+	device = NULL;
+	acpi_bus_get_device(handle, &device);
+	if (!acpi_device_enumerated(device)) {
+		acpi_handle_warn(handle, "Device not enumerated\n");
 		goto out;
 	}
 	ost_code = ACPI_OST_SC_SUCCESS;
@@ -1111,20 +1112,6 @@ int acpi_device_add(struct acpi_device *device,
 	return result;
 }
 
-static void acpi_device_unregister(struct acpi_device *device)
-{
-	acpi_detach_data(device->handle, acpi_scan_drop_device);
-	acpi_device_del(device);
-	/*
-	 * Transition the device to D3cold to drop the reference counts of all
-	 * power resources the device depends on and turn off the ones that have
-	 * no more references.
-	 */
-	acpi_device_set_power(device, ACPI_STATE_D3_COLD);
-	device->handle = NULL;
-	put_device(&device->dev);
-}
-
 /* --------------------------------------------------------------------------
                                  Driver Management
    -------------------------------------------------------------------------- */
@@ -1703,6 +1690,8 @@ void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 	acpi_set_pnp_ids(handle, &device->pnp, type);
 	acpi_bus_get_flags(device);
 	device->flags.match_driver = false;
+	device->flags.initialized = true;
+	device->flags.visited = false;
 	device_initialize(&device->dev);
 	dev_set_uevent_suppress(&device->dev, true);
 }
@@ -1787,6 +1776,15 @@ static int acpi_bus_type_and_status(acpi_handle handle, int *type,
 	return 0;
 }
 
+bool acpi_device_is_present(struct acpi_device *adev)
+{
+	if (adev->status.present || adev->status.functional)
+		return true;
+
+	adev->flags.initialized = false;
+	return false;
+}
+
 static bool acpi_scan_handler_matching(struct acpi_scan_handler *handler,
 				       char *idstr,
 				       const struct acpi_device_id **matchid)
@@ -1880,18 +1878,6 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 
 	acpi_scan_init_hotplug(handle, type);
 
-	if (!(sta & ACPI_STA_DEVICE_PRESENT) &&
-	    !(sta & ACPI_STA_DEVICE_FUNCTIONING)) {
-		struct acpi_device_wakeup wakeup;
-
-		if (acpi_has_method(handle, "_PRW")) {
-			acpi_bus_extract_wakeup_device_power_package(handle,
-								     &wakeup);
-			acpi_power_resources_list_free(&wakeup.resources);
-		}
-		return AE_CTRL_DEPTH;
-	}
-
 	acpi_add_single_object(&device, handle, type, sta);
 	if (!device)
 		return AE_CTRL_DEPTH;
@@ -1930,32 +1916,50 @@ static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 					  void *not_used, void **ret_not_used)
 {
 	struct acpi_device *device;
-	unsigned long long sta_not_used;
+	unsigned long long sta;
 	int ret;
 
 	/*
 	 * Ignore errors ignored by acpi_bus_check_add() to avoid terminating
 	 * namespace walks prematurely.
 	 */
-	if (acpi_bus_type_and_status(handle, &ret, &sta_not_used))
+	if (acpi_bus_type_and_status(handle, &ret, &sta))
 		return AE_OK;
 
 	if (acpi_bus_get_device(handle, &device))
 		return AE_CTRL_DEPTH;
 
+	STRUCT_TO_INT(device->status) = sta;
+	/* Skip devices that are not present. */
+	if (!acpi_device_is_present(device))
+		goto err;
+
 	if (device->handler)
 		return AE_OK;
 
+	if (!device->flags.initialized) {
+		acpi_bus_update_power(device, NULL);
+		device->flags.initialized = true;
+	}
 	ret = acpi_scan_attach_handler(device);
 	if (ret < 0)
-		return AE_CTRL_DEPTH;
+		goto err;
 
 	device->flags.match_driver = true;
 	if (ret > 0)
-		return AE_OK;
+		goto ok;
 
 	ret = device_attach(&device->dev);
-	return ret >= 0 ? AE_OK : AE_CTRL_DEPTH;
+	if (ret < 0)
+		goto err;
+
+ ok:
+	device->flags.visited = true;
+	return AE_OK;
+
+ err:
+	device->flags.visited = false;
+	return AE_CTRL_DEPTH;
 }
 
 /**
@@ -2007,21 +2011,17 @@ static acpi_status acpi_bus_device_detach(acpi_handle handle, u32 lvl_not_used,
 		} else {
 			device_release_driver(&device->dev);
 		}
+		/*
+		 * Most likely, the device is going away, so put it into D3cold
+		 * before that.
+		 */
+		acpi_device_set_power(device, ACPI_STATE_D3_COLD);
+		device->flags.initialized = false;
+		device->flags.visited = false;
 	}
 	return AE_OK;
 }
 
-static acpi_status acpi_bus_remove(acpi_handle handle, u32 lvl_not_used,
-				   void *not_used, void **ret_not_used)
-{
-	struct acpi_device *device = NULL;
-
-	if (!acpi_bus_get_device(handle, &device))
-		acpi_device_unregister(device);
-
-	return AE_OK;
-}
-
 /**
  * acpi_bus_trim - Remove ACPI device node and all of its descendants
  * @start: Root of the ACPI device nodes subtree to remove.
@@ -2037,13 +2037,6 @@ void acpi_bus_trim(struct acpi_device *start)
 	acpi_walk_namespace(ACPI_TYPE_ANY, start->handle, ACPI_UINT32_MAX, NULL,
 			    acpi_bus_device_detach, NULL, NULL);
 	acpi_bus_device_detach(start->handle, 0, NULL, NULL);
-	/*
-	 * Execute acpi_bus_remove() as a post-order callback to remove device
-	 * nodes in the given namespace scope.
-	 */
-	acpi_walk_namespace(ACPI_TYPE_ANY, start->handle, ACPI_UINT32_MAX, NULL,
-			    acpi_bus_remove, NULL, NULL);
-	acpi_bus_remove(start->handle, 0, NULL, NULL);
 }
 EXPORT_SYMBOL_GPL(acpi_bus_trim);
 
@@ -2121,7 +2114,9 @@ int __init acpi_scan_init(void)
 
 	result = acpi_bus_scan_fixed();
 	if (result) {
-		acpi_device_unregister(acpi_root);
+		acpi_detach_data(acpi_root->handle, acpi_scan_drop_device);
+		acpi_device_del(acpi_root);
+		put_device(&acpi_root->dev);
 		goto out;
 	}
 

commit d783156ea38431b20af0d4f910a6f9f9054d33b9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 22 21:52:12 2013 +0100

    ACPI / scan: Define non-empty device removal handler
    
    If an ACPI namespace node is removed (usually, as a result of a
    table unload), and there is a data object attached to that node,
    acpi_ns_delete_node() executes the removal handler submitted to
    acpi_attach_data() for that object.  That handler is currently empty
    for struct acpi_device objects, so it is necessary to detach those
    objects from the corresponding ACPI namespace nodes in advance every
    time a table unload may happen.  That is cumbersome and inefficient
    and leads to some design constraints that turn out to be quite
    inconvenient (in particular, struct acpi_device objects cannot be
    registered for namespace nodes representing devices that are not
    reported as present or functional by _STA).
    
    For this reason, introduce a non-empty removal handler for ACPI
    device objects that will unregister them when their ACPI namespace
    nodes go away.
    
    This code modification alone should not change functionality except
    for the ordering of the ACPI hotplug workqueue which should not
    matter (without subsequent code changes).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index fd39459926b1..ad2522015e5e 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -14,6 +14,8 @@
 
 #include <acpi/acpi_drivers.h>
 
+#include <asm/pgtable.h>
+
 #include "internal.h"
 
 #define _COMPONENT		ACPI_BUS_COMPONENT
@@ -27,6 +29,8 @@ extern struct acpi_device *acpi_root;
 
 #define ACPI_IS_ROOT_DEVICE(device)    (!(device)->parent)
 
+#define INVALID_ACPI_HANDLE	((acpi_handle)empty_zero_page)
+
 /*
  * If set, devices will be hot-removed even if they cannot be put offline
  * gracefully (from the kernel's standpoint).
@@ -907,9 +911,91 @@ struct bus_type acpi_bus_type = {
 	.uevent		= acpi_device_uevent,
 };
 
-static void acpi_bus_data_handler(acpi_handle handle, void *context)
+static void acpi_device_del(struct acpi_device *device)
+{
+	mutex_lock(&acpi_device_lock);
+	if (device->parent)
+		list_del(&device->node);
+
+	list_del(&device->wakeup_list);
+	mutex_unlock(&acpi_device_lock);
+
+	acpi_power_add_remove_device(device, false);
+	acpi_device_remove_files(device);
+	if (device->remove)
+		device->remove(device);
+
+	device_del(&device->dev);
+}
+
+static LIST_HEAD(acpi_device_del_list);
+static DEFINE_MUTEX(acpi_device_del_lock);
+
+static void acpi_device_del_work_fn(struct work_struct *work_not_used)
+{
+	for (;;) {
+		struct acpi_device *adev;
+
+		mutex_lock(&acpi_device_del_lock);
+
+		if (list_empty(&acpi_device_del_list)) {
+			mutex_unlock(&acpi_device_del_lock);
+			break;
+		}
+		adev = list_first_entry(&acpi_device_del_list,
+					struct acpi_device, del_list);
+		list_del(&adev->del_list);
+
+		mutex_unlock(&acpi_device_del_lock);
+
+		acpi_device_del(adev);
+		/*
+		 * Drop references to all power resources that might have been
+		 * used by the device.
+		 */
+		acpi_power_transition(adev, ACPI_STATE_D3_COLD);
+		put_device(&adev->dev);
+	}
+}
+
+/**
+ * acpi_scan_drop_device - Drop an ACPI device object.
+ * @handle: Handle of an ACPI namespace node, not used.
+ * @context: Address of the ACPI device object to drop.
+ *
+ * This is invoked by acpi_ns_delete_node() during the removal of the ACPI
+ * namespace node the device object pointed to by @context is attached to.
+ *
+ * The unregistration is carried out asynchronously to avoid running
+ * acpi_device_del() under the ACPICA's namespace mutex and the list is used to
+ * ensure the correct ordering (the device objects must be unregistered in the
+ * same order in which the corresponding namespace nodes are deleted).
+ */
+static void acpi_scan_drop_device(acpi_handle handle, void *context)
 {
-	/* Intentionally empty. */
+	static DECLARE_WORK(work, acpi_device_del_work_fn);
+	struct acpi_device *adev = context;
+
+	mutex_lock(&acpi_device_del_lock);
+
+	/*
+	 * Use the ACPI hotplug workqueue which is ordered, so this work item
+	 * won't run after any hotplug work items submitted subsequently.  That
+	 * prevents attempts to register device objects identical to those being
+	 * deleted from happening concurrently (such attempts result from
+	 * hotplug events handled via the ACPI hotplug workqueue).  It also will
+	 * run after all of the work items submitted previosuly, which helps
+	 * those work items to ensure that they are not accessing stale device
+	 * objects.
+	 */
+	if (list_empty(&acpi_device_del_list))
+		acpi_queue_hotplug_work(&work);
+
+	list_add_tail(&adev->del_list, &acpi_device_del_list);
+	/* Make acpi_ns_validate_handle() return NULL for this handle. */
+	adev->handle = INVALID_ACPI_HANDLE;
+
+	mutex_unlock(&acpi_device_del_lock);
 }
 
 int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
@@ -919,7 +1005,7 @@ int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
 	if (!device)
 		return -EINVAL;
 
-	status = acpi_get_data(handle, acpi_bus_data_handler, (void **)device);
+	status = acpi_get_data(handle, acpi_scan_drop_device, (void **)device);
 	if (ACPI_FAILURE(status) || !*device) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No context for object [%p]\n",
 				  handle));
@@ -939,7 +1025,7 @@ int acpi_device_add(struct acpi_device *device,
 	if (device->handle) {
 		acpi_status status;
 
-		status = acpi_attach_data(device->handle, acpi_bus_data_handler,
+		status = acpi_attach_data(device->handle, acpi_scan_drop_device,
 					  device);
 		if (ACPI_FAILURE(status)) {
 			acpi_handle_err(device->handle,
@@ -957,6 +1043,7 @@ int acpi_device_add(struct acpi_device *device,
 	INIT_LIST_HEAD(&device->node);
 	INIT_LIST_HEAD(&device->wakeup_list);
 	INIT_LIST_HEAD(&device->physical_node_list);
+	INIT_LIST_HEAD(&device->del_list);
 	mutex_init(&device->physical_node_lock);
 
 	new_bus_id = kzalloc(sizeof(struct acpi_device_bus_id), GFP_KERNEL);
@@ -1020,27 +1107,14 @@ int acpi_device_add(struct acpi_device *device,
 	mutex_unlock(&acpi_device_lock);
 
  err_detach:
-	acpi_detach_data(device->handle, acpi_bus_data_handler);
+	acpi_detach_data(device->handle, acpi_scan_drop_device);
 	return result;
 }
 
 static void acpi_device_unregister(struct acpi_device *device)
 {
-	mutex_lock(&acpi_device_lock);
-	if (device->parent)
-		list_del(&device->node);
-
-	list_del(&device->wakeup_list);
-	mutex_unlock(&acpi_device_lock);
-
-	acpi_detach_data(device->handle, acpi_bus_data_handler);
-
-	acpi_power_add_remove_device(device, false);
-	acpi_device_remove_files(device);
-	if (device->remove)
-		device->remove(device);
-
-	device_del(&device->dev);
+	acpi_detach_data(device->handle, acpi_scan_drop_device);
+	acpi_device_del(device);
 	/*
 	 * Transition the device to D3cold to drop the reference counts of all
 	 * power resources the device depends on and turn off the ones that have

commit 76540969b1cf26349eb8867b57657b03c89025e5
Merge: 6ce4eac1f600 ca499fc87ed9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 22 21:48:00 2013 +0100

    Merge back earlier acpi-hotplug material.

commit ca499fc87ed945094d952da0eb7eea7dbeb1feec
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Wed Nov 20 14:25:34 2013 +0100

    ACPI / hotplug: Fix conflicted PCI bridge notify handlers
    
    The PCI host bridge scan handler installs its own notify handler,
    handle_hotplug_event_root(), by itself.  Nevertheless, the ACPI
    hotplug framework also installs the common notify handler,
    acpi_hotplug_notify_cb(), for PCI root bridges.  This causes
    acpi_hotplug_notify_cb() to call _OST method with unsupported
    error as hotplug.enabled is not set.
    
    To address this issue, introduce hotplug.ignore flag, which
    indicates that the scan handler installs its own notify handler by
    itself.  The ACPI hotplug framework does not install the common
    notify handler when this flag is set.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    [rjw: Changed the name of the new flag]
    Cc: 3.9+ <stable@vger.kernel.org> # 3.9+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ce518867a18a..e76b5230f476 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1773,7 +1773,7 @@ static void acpi_scan_init_hotplug(acpi_handle handle, int type)
 	 */
 	list_for_each_entry(hwid, &pnp.ids, list) {
 		handler = acpi_scan_match_handler(hwid->id, NULL);
-		if (handler) {
+		if (handler && !handler->hotplug.ignore) {
 			acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
 					acpi_hotplug_notify_cb, handler);
 			break;

commit 614d7426ec109501e9e77be66963caf3041e566c
Merge: f86e7bc9683e 883461679ad1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Nov 19 01:05:46 2013 +0100

    Merge branch 'acpi-hotplug'
    
    * acpi-hotplug:
      ACPI / scan: Set flags.match_driver in acpi_bus_scan_fixed()
      ACPI / PCI root: Clear driver_data before failing enumeration
      ACPI / hotplug: Fix PCI host bridge hot removal
      ACPI / hotplug: Fix acpi_bus_get_device() return value check

commit 883461679ad1ed6e09135adf8c02bb98d7962623
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 18 14:18:47 2013 +0100

    ACPI / scan: Set flags.match_driver in acpi_bus_scan_fixed()
    
    Before commit 6931007cc90b (ACPI / scan: Start matching drivers
    after trying scan handlers) the match_driver flag for all devices
    was set in acpi_add_single_object(), but now it is set by
    acpi_bus_device_attach() which is not called for the "fixed"
    devices added by acpi_bus_scan_fixed().  This means that
    flags.match_driver is never set for those devices now, so make
    acpi_bus_scan_fixed() set it before calling device_attach().
    
    Fixes: 6931007cc90b (ACPI / scan: Start matching drivers after trying scan handlers)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 821d154221d5..ce518867a18a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1990,6 +1990,7 @@ static int acpi_bus_scan_fixed(void)
 		if (result)
 			return result;
 
+		device->flags.match_driver = true;
 		result = device_attach(&device->dev);
 		if (result < 0)
 			return result;
@@ -2006,6 +2007,7 @@ static int acpi_bus_scan_fixed(void)
 		if (result)
 			return result;
 
+		device->flags.match_driver = true;
 		result = device_attach(&device->dev);
 	}
 

commit c1beb0bdb5b3ef670af3ab946434f7fc55d4c7a3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 14 00:54:08 2013 +0100

    ACPI / hotplug: Fix PCI host bridge hot removal
    
    Since the PCI host bridge scan handler does not set hotplug.enabled,
    the check of it in acpi_bus_device_eject() effectively prevents the
    root bridge hot removal from working after commit a3b1b1ef78cd
    (ACPI / hotplug: Merge device hot-removal routines).  However, that
    check is not necessary, because the other acpi_bus_device_eject()
    users, acpi_hotplug_notify_cb and acpi_eject_store(), do the same
    check by themselves before executing that function.
    
    For this reason, remove the scan handler check from
    acpi_bus_device_eject() to make PCI hot bridge hot removal work
    again.
    
    Fixes: a3b1b1ef78cd (ACPI / hotplug: Merge device hot-removal routines)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 4698060ba3f0..821d154221d5 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -289,24 +289,17 @@ void acpi_bus_device_eject(void *data, u32 ost_src)
 {
 	struct acpi_device *device = data;
 	acpi_handle handle = device->handle;
-	struct acpi_scan_handler *handler;
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 	int error;
 
 	lock_device_hotplug();
 	mutex_lock(&acpi_scan_lock);
 
-	handler = device->handler;
-	if (!handler || !handler->hotplug.enabled) {
-		put_device(&device->dev);
-		goto err_support;
-	}
-
 	if (ost_src == ACPI_NOTIFY_EJECT_REQUEST)
 		acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
 					  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 
-	if (handler->hotplug.mode == AHM_CONTAINER)
+	if (device->handler && device->handler->hotplug.mode == AHM_CONTAINER)
 		kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
 
 	error = acpi_scan_hot_remove(device);

commit 5beaee4f195d0297473da9a45459050b561e10cf
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 14 00:54:00 2013 +0100

    ACPI / hotplug: Fix acpi_bus_get_device() return value check
    
    Since acpi_bus_get_device() returns a plain int and not acpi_status,
    ACPI_FAILURE() should not be used for checking its return value.  Fix
    that.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 276cde70a514..4698060ba3f0 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -411,8 +411,7 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 		break;
 	case ACPI_NOTIFY_EJECT_REQUEST:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_EJECT_REQUEST event\n");
-		status = acpi_bus_get_device(handle, &adev);
-		if (ACPI_FAILURE(status))
+		if (acpi_bus_get_device(handle, &adev))
 			goto err_out;
 
 		get_device(&adev->dev);

commit 63ff4d0765a4e30afa659edbf09006987fc62499
Merge: 679d9980f991 7b98118aaa5d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 7 19:31:15 2013 +0100

    Merge branch 'acpi-hotplug'
    
    * acpi-hotplug:
      ACPI / hotplug: Consolidate deferred execution of ACPI hotplug routines
      ACPI / hotplug: Do not execute "insert in progress" _OST
      ACPI / hotplug: Carry out PCI root eject directly
      ACPI / hotplug: Merge device hot-removal routines
      ACPI / hotplug: Make acpi_bus_hot_remove_device() internal
      ACPI / hotplug: Simplify device ejection routines
      ACPI / hotplug: Fix handle_root_bridge_removal()
      ACPI / hotplug: Refuse to hot-remove all objects with disabled hotplug
      ACPI / scan: Start matching drivers after trying scan handlers
      ACPI: Remove acpi_pci_slot_init() headers from internal.h
    
    Conflicts:
            include/acpi/acpiosxf.h (with the 'acpica' branch)

commit 7b98118aaa5d75644c48f41fc5d0cc181e478383
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 7 01:45:40 2013 +0100

    ACPI / hotplug: Consolidate deferred execution of ACPI hotplug routines
    
    There are two different interfaces for queuing up work items on the
    ACPI hotplug workqueue, alloc_acpi_hp_work() used by PCI and PCI host
    bridge hotplug code and acpi_os_hotplug_execute() used by the common
    ACPI hotplug code and docking stations.  They both are somewhat
    cumbersome to use and work slightly differently.
    
    The users of alloc_acpi_hp_work() have to submit a work function that
    will extract the necessary data items from a struct acpi_hp_work
    object allocated by alloc_acpi_hp_work() and then will free that
    object, while it would be more straightforward to simply use a work
    function with one more argument and let the interface take care of
    the execution details.
    
    The users of acpi_os_hotplug_execute() also have to deal with the
    fact that it takes only one argument in addition to the work function
    pointer, although acpi_os_execute_deferred() actually takes care of
    the allocation and freeing of memory, so it would have been able to
    pass more arguments to the work function if it hadn't been
    constrained by the connection with acpi_os_execute().
    
    Moreover, while alloc_acpi_hp_work() makes GFP_KERNEL memory
    allocations, which is correct, because hotplug work items are
    always queued up from process context, acpi_os_hotplug_execute()
    uses GFP_ATOMIC, as that is needed by acpi_os_execute().  Also,
    acpi_os_execute_deferred() queued up by it waits for the ACPI event
    workqueues to flush before executing the work function, whereas
    alloc_acpi_hp_work() can't do anything similar.  That leads to
    somewhat arbitrary differences in behavior between various ACPI
    hotplug code paths and has to be straightened up.
    
    For this reason, replace both alloc_acpi_hp_work() and
    acpi_os_hotplug_execute() with a single interface,
    acpi_hotplug_execute(), combining their behavior and being more
    friendly to its users than any of the two.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5cd7f8c5666a..276cde70a514 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -285,8 +285,9 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	return 0;
 }
 
-void acpi_bus_device_eject(struct acpi_device *device, u32 ost_src)
+void acpi_bus_device_eject(void *data, u32 ost_src)
 {
+	struct acpi_device *device = data;
 	acpi_handle handle = device->handle;
 	struct acpi_scan_handler *handler;
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
@@ -327,8 +328,9 @@ void acpi_bus_device_eject(struct acpi_device *device, u32 ost_src)
 	goto out;
 }
 
-static void acpi_scan_bus_device_check(acpi_handle handle, u32 ost_source)
+static void acpi_scan_bus_device_check(void *data, u32 ost_source)
 {
+	acpi_handle handle = data;
 	struct acpi_device *device = NULL;
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 	int error;
@@ -363,18 +365,6 @@ static void acpi_scan_bus_device_check(acpi_handle handle, u32 ost_source)
 	unlock_device_hotplug();
 }
 
-static void acpi_scan_bus_check(void *context)
-{
-	acpi_scan_bus_device_check((acpi_handle)context,
-				   ACPI_NOTIFY_BUS_CHECK);
-}
-
-static void acpi_scan_device_check(void *context)
-{
-	acpi_scan_bus_device_check((acpi_handle)context,
-				   ACPI_NOTIFY_DEVICE_CHECK);
-}
-
 static void acpi_hotplug_unsupported(acpi_handle handle, u32 type)
 {
 	u32 ost_status;
@@ -403,18 +393,8 @@ static void acpi_hotplug_unsupported(acpi_handle handle, u32 type)
 	acpi_evaluate_hotplug_ost(handle, type, ost_status, NULL);
 }
 
-/**
- * acpi_bus_hot_remove_device: Hot-remove a device and its children.
- * @context: Address of the ACPI device object to hot-remove.
- */
-static void acpi_bus_hot_remove_device(void *context)
-{
-	acpi_bus_device_eject(context, ACPI_NOTIFY_EJECT_REQUEST);
-}
-
 static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 {
-	acpi_osd_exec_callback callback;
 	struct acpi_scan_handler *handler = data;
 	struct acpi_device *adev;
 	acpi_status status;
@@ -425,11 +405,9 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 	switch (type) {
 	case ACPI_NOTIFY_BUS_CHECK:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_BUS_CHECK event\n");
-		callback = acpi_scan_bus_check;
 		break;
 	case ACPI_NOTIFY_DEVICE_CHECK:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_DEVICE_CHECK event\n");
-		callback = acpi_scan_device_check;
 		break;
 	case ACPI_NOTIFY_EJECT_REQUEST:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_EJECT_REQUEST event\n");
@@ -438,8 +416,7 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 			goto err_out;
 
 		get_device(&adev->dev);
-		callback = acpi_bus_hot_remove_device;
-		status = acpi_os_hotplug_execute(callback, adev);
+		status = acpi_hotplug_execute(acpi_bus_device_eject, adev, type);
 		if (ACPI_SUCCESS(status))
 			return;
 
@@ -449,7 +426,7 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 		/* non-hotplug event; possibly handled by other handler */
 		return;
 	}
-	status = acpi_os_hotplug_execute(callback, handle);
+	status = acpi_hotplug_execute(acpi_scan_bus_device_check, handle, type);
 	if (ACPI_SUCCESS(status))
 		return;
 
@@ -484,11 +461,6 @@ static ssize_t power_state_show(struct device *dev,
 
 static DEVICE_ATTR(power_state, 0444, power_state_show, NULL);
 
-static void acpi_eject_store_work(void *context)
-{
-	acpi_bus_device_eject(context, ACPI_OST_EC_OSPM_EJECT);
-}
-
 static ssize_t
 acpi_eject_store(struct device *d, struct device_attribute *attr,
 		const char *buf, size_t count)
@@ -511,7 +483,8 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 	acpi_evaluate_hotplug_ost(acpi_device->handle, ACPI_OST_EC_OSPM_EJECT,
 				  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 	get_device(&acpi_device->dev);
-	status = acpi_os_hotplug_execute(acpi_eject_store_work, acpi_device);
+	status = acpi_hotplug_execute(acpi_bus_device_eject, acpi_device,
+				      ACPI_OST_EC_OSPM_EJECT);
 	if (ACPI_SUCCESS(status))
 		return count;
 

commit 176a88d79d6b5aebabaff16734e8b3107efcaaad
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 7 01:42:17 2013 +0100

    ACPI / hotplug: Do not execute "insert in progress" _OST
    
    According to the ACPI spec (5.0, Section 6.3.5), the "Device
    insertion in progress (pending)" (0x80) _OST status code is
    reserved for the "Insertion Processing" (0x200) source event
    which is "a result of an OSPM action".  Specifically, it is not
    a notification, so that status code should not be used during
    notification processing, which unfortunately is done by
    acpi_scan_bus_device_check().
    
    For this reason, drop the ACPI_OST_SC_INSERT_IN_PROGRESS _OST
    status evaluation from there (it was a mistake to put it in there
    in the first place).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: All applicable <stable@vger.kernel.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c7317fe213bf..5cd7f8c5666a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -343,8 +343,6 @@ static void acpi_scan_bus_device_check(acpi_handle handle, u32 ost_source)
 			goto out;
 		}
 	}
-	acpi_evaluate_hotplug_ost(handle, ost_source,
-				  ACPI_OST_SC_INSERT_IN_PROGRESS, NULL);
 	error = acpi_bus_scan(handle);
 	if (error) {
 		acpi_handle_warn(handle, "Namespace scan failure\n");

commit 43d388832bd3e413e9b5e6f3caef4b0844b901af
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 7 01:42:09 2013 +0100

    ACPI / hotplug: Carry out PCI root eject directly
    
    Since _handle_hotplug_event_root() is run from the ACPI hotplug
    workqueue, it doesn't need to queue up a work item to eject a PCI
    host bridge on the same workqueue.  Instead, it can just carry out
    the eject by calling acpi_bus_device_eject() directly, so make that
    happen.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 4a0a591feed3..c7317fe213bf 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -285,7 +285,7 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	return 0;
 }
 
-static void acpi_bus_device_eject(struct acpi_device *device, u32 ost_src)
+void acpi_bus_device_eject(struct acpi_device *device, u32 ost_src)
 {
 	acpi_handle handle = device->handle;
 	struct acpi_scan_handler *handler;
@@ -409,7 +409,7 @@ static void acpi_hotplug_unsupported(acpi_handle handle, u32 type)
  * acpi_bus_hot_remove_device: Hot-remove a device and its children.
  * @context: Address of the ACPI device object to hot-remove.
  */
-void acpi_bus_hot_remove_device(void *context)
+static void acpi_bus_hot_remove_device(void *context)
 {
 	acpi_bus_device_eject(context, ACPI_NOTIFY_EJECT_REQUEST);
 }

commit a3b1b1ef78cd2ffb5d3a223465064dee05929dc3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 7 01:41:58 2013 +0100

    ACPI / hotplug: Merge device hot-removal routines
    
    There is no real reasn why acpi_bus_device_eject() and
    acpi_bus_hot_remove_device() should work differently, so rework
    acpi_bus_device_eject() so that it can be called internally by
    both acpi_bus_hot_remove_device() and acpi_eject_store_work().
    Accordingly, rework acpi_hotplug_notify_cb() to queue up the
    execution of acpi_bus_hot_remove_device() through
    acpi_os_hotplug_execute() on eject request notifications.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 1217ba33f8bf..4a0a591feed3 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -285,10 +285,9 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	return 0;
 }
 
-static void acpi_bus_device_eject(void *context)
+static void acpi_bus_device_eject(struct acpi_device *device, u32 ost_src)
 {
-	acpi_handle handle = context;
-	struct acpi_device *device = NULL;
+	acpi_handle handle = device->handle;
 	struct acpi_scan_handler *handler;
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 	int error;
@@ -296,20 +295,19 @@ static void acpi_bus_device_eject(void *context)
 	lock_device_hotplug();
 	mutex_lock(&acpi_scan_lock);
 
-	acpi_bus_get_device(handle, &device);
-	if (!device)
-		goto err_out;
-
 	handler = device->handler;
-	if (!handler || !handler->hotplug.enabled)
+	if (!handler || !handler->hotplug.enabled) {
+		put_device(&device->dev);
 		goto err_support;
+	}
+
+	if (ost_src == ACPI_NOTIFY_EJECT_REQUEST)
+		acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
+					  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 
-	acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
-				  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 	if (handler->hotplug.mode == AHM_CONTAINER)
 		kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
 
-	get_device(&device->dev);
 	error = acpi_scan_hot_remove(device);
 	if (error == -EPERM) {
 		goto err_support;
@@ -325,8 +323,7 @@ static void acpi_bus_device_eject(void *context)
  err_support:
 	ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
  err_out:
-	acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST, ost_code,
-				  NULL);
+	acpi_evaluate_hotplug_ost(handle, ost_src, ost_code, NULL);
 	goto out;
 }
 
@@ -408,10 +405,20 @@ static void acpi_hotplug_unsupported(acpi_handle handle, u32 type)
 	acpi_evaluate_hotplug_ost(handle, type, ost_status, NULL);
 }
 
+/**
+ * acpi_bus_hot_remove_device: Hot-remove a device and its children.
+ * @context: Address of the ACPI device object to hot-remove.
+ */
+void acpi_bus_hot_remove_device(void *context)
+{
+	acpi_bus_device_eject(context, ACPI_NOTIFY_EJECT_REQUEST);
+}
+
 static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 {
 	acpi_osd_exec_callback callback;
 	struct acpi_scan_handler *handler = data;
+	struct acpi_device *adev;
 	acpi_status status;
 
 	if (!handler->hotplug.enabled)
@@ -428,44 +435,29 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 		break;
 	case ACPI_NOTIFY_EJECT_REQUEST:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_EJECT_REQUEST event\n");
-		callback = acpi_bus_device_eject;
-		break;
+		status = acpi_bus_get_device(handle, &adev);
+		if (ACPI_FAILURE(status))
+			goto err_out;
+
+		get_device(&adev->dev);
+		callback = acpi_bus_hot_remove_device;
+		status = acpi_os_hotplug_execute(callback, adev);
+		if (ACPI_SUCCESS(status))
+			return;
+
+		put_device(&adev->dev);
+		goto err_out;
 	default:
 		/* non-hotplug event; possibly handled by other handler */
 		return;
 	}
 	status = acpi_os_hotplug_execute(callback, handle);
-	if (ACPI_FAILURE(status))
-		acpi_evaluate_hotplug_ost(handle, type,
-					  ACPI_OST_SC_NON_SPECIFIC_FAILURE,
-					  NULL);
-}
-
-void __acpi_bus_hot_remove_device(struct acpi_device *device, u32 ost_src)
-{
-	acpi_handle handle = device->handle;
-	int error;
-
-	lock_device_hotplug();
-	mutex_lock(&acpi_scan_lock);
-
-	error = acpi_scan_hot_remove(device);
-	if (error && handle)
-		acpi_evaluate_hotplug_ost(handle, ost_src,
-					  ACPI_OST_SC_NON_SPECIFIC_FAILURE,
-					  NULL);
-
-	mutex_unlock(&acpi_scan_lock);
-	unlock_device_hotplug();
-}
+	if (ACPI_SUCCESS(status))
+		return;
 
-/**
- * acpi_bus_hot_remove_device: Hot-remove a device and its children.
- * @context: Address of the ACPI device object to hot-remove.
- */
-void acpi_bus_hot_remove_device(void *context)
-{
-	__acpi_bus_hot_remove_device(context, ACPI_NOTIFY_EJECT_REQUEST);
+ err_out:
+	acpi_evaluate_hotplug_ost(handle, type,
+				  ACPI_OST_SC_NON_SPECIFIC_FAILURE, NULL);
 }
 
 static ssize_t real_power_state_show(struct device *dev,
@@ -496,7 +488,7 @@ static DEVICE_ATTR(power_state, 0444, power_state_show, NULL);
 
 static void acpi_eject_store_work(void *context)
 {
-	__acpi_bus_hot_remove_device(context, ACPI_OST_EC_OSPM_EJECT);
+	acpi_bus_device_eject(context, ACPI_OST_EC_OSPM_EJECT);
 }
 
 static ssize_t

commit ace8238b00eafd493b8dbcc7db813ed72b8b6e87
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 7 01:41:48 2013 +0100

    ACPI / hotplug: Make acpi_bus_hot_remove_device() internal
    
    Notice that handle_root_bridge_removal() is the only user of
    acpi_bus_hot_remove_device(), so it doesn't have to be exported
    any more and can be made internal to the ACPI core.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index cc19d623a18f..1217ba33f8bf 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -467,7 +467,6 @@ void acpi_bus_hot_remove_device(void *context)
 {
 	__acpi_bus_hot_remove_device(context, ACPI_NOTIFY_EJECT_REQUEST);
 }
-EXPORT_SYMBOL(acpi_bus_hot_remove_device);
 
 static ssize_t real_power_state_show(struct device *dev,
 				     struct device_attribute *attr, char *buf)

commit 5add99cfef416487d32b4b7075fe1a409f3a5e82
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 7 01:41:39 2013 +0100

    ACPI / hotplug: Simplify device ejection routines
    
    Simplify handle_root_bridge_removal() and acpi_eject_store() by
    getting rid of struct acpi_eject_event and passing device objects
    directly to async routines executed via acpi_os_hotplug_execute().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 9bdcc187bf4b..cc19d623a18f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -441,18 +441,8 @@ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 					  NULL);
 }
 
-/**
- * acpi_bus_hot_remove_device: hot-remove a device and its children
- * @context: struct acpi_eject_event pointer (freed in this func)
- *
- * Hot-remove a device and its children. This function frees up the
- * memory space passed by arg context, so that the caller may call
- * this function asynchronously through acpi_os_hotplug_execute().
- */
-void acpi_bus_hot_remove_device(void *context)
+void __acpi_bus_hot_remove_device(struct acpi_device *device, u32 ost_src)
 {
-	struct acpi_eject_event *ej_event = context;
-	struct acpi_device *device = ej_event->device;
 	acpi_handle handle = device->handle;
 	int error;
 
@@ -461,13 +451,21 @@ void acpi_bus_hot_remove_device(void *context)
 
 	error = acpi_scan_hot_remove(device);
 	if (error && handle)
-		acpi_evaluate_hotplug_ost(handle, ej_event->event,
+		acpi_evaluate_hotplug_ost(handle, ost_src,
 					  ACPI_OST_SC_NON_SPECIFIC_FAILURE,
 					  NULL);
 
 	mutex_unlock(&acpi_scan_lock);
 	unlock_device_hotplug();
-	kfree(context);
+}
+
+/**
+ * acpi_bus_hot_remove_device: Hot-remove a device and its children.
+ * @context: Address of the ACPI device object to hot-remove.
+ */
+void acpi_bus_hot_remove_device(void *context)
+{
+	__acpi_bus_hot_remove_device(context, ACPI_NOTIFY_EJECT_REQUEST);
 }
 EXPORT_SYMBOL(acpi_bus_hot_remove_device);
 
@@ -497,15 +495,18 @@ static ssize_t power_state_show(struct device *dev,
 
 static DEVICE_ATTR(power_state, 0444, power_state_show, NULL);
 
+static void acpi_eject_store_work(void *context)
+{
+	__acpi_bus_hot_remove_device(context, ACPI_OST_EC_OSPM_EJECT);
+}
+
 static ssize_t
 acpi_eject_store(struct device *d, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
 	struct acpi_device *acpi_device = to_acpi_device(d);
-	struct acpi_eject_event *ej_event;
 	acpi_object_type not_used;
 	acpi_status status;
-	int ret;
 
 	if (!count || buf[0] != '1')
 		return -EINVAL;
@@ -518,28 +519,17 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 	if (ACPI_FAILURE(status) || !acpi_device->flags.ejectable)
 		return -ENODEV;
 
-	ej_event = kmalloc(sizeof(*ej_event), GFP_KERNEL);
-	if (!ej_event) {
-		ret = -ENOMEM;
-		goto err_out;
-	}
 	acpi_evaluate_hotplug_ost(acpi_device->handle, ACPI_OST_EC_OSPM_EJECT,
 				  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
-	ej_event->device = acpi_device;
-	ej_event->event = ACPI_OST_EC_OSPM_EJECT;
 	get_device(&acpi_device->dev);
-	status = acpi_os_hotplug_execute(acpi_bus_hot_remove_device, ej_event);
+	status = acpi_os_hotplug_execute(acpi_eject_store_work, acpi_device);
 	if (ACPI_SUCCESS(status))
 		return count;
 
 	put_device(&acpi_device->dev);
-	kfree(ej_event);
-	ret = status == AE_NO_MEMORY ? -ENOMEM : -EAGAIN;
-
- err_out:
 	acpi_evaluate_hotplug_ost(acpi_device->handle, ACPI_OST_EC_OSPM_EJECT,
 				  ACPI_OST_SC_NON_SPECIFIC_FAILURE, NULL);
-	return ret;
+	return status == AE_NO_MEMORY ? -ENOMEM : -EAGAIN;
 }
 
 static DEVICE_ATTR(eject, 0200, NULL, acpi_eject_store);

commit 7f28ddeccea453fd20b1c74a88df19590ad9203c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 7 01:41:14 2013 +0100

    ACPI / hotplug: Refuse to hot-remove all objects with disabled hotplug
    
    In theory, an ACPI device object may be the parent of another
    device object whose hotplug is disabled by user space through its
    scan handler.  In that case, the eject operation targeting the
    parent should fail as though the parent's own hotplug was disabled,
    but currently this is not the case, because acpi_scan_hot_remove()
    doesn't check the disable/enable hotplug status of the children
    of the top-most object passed to it.
    
    To fix this, modify acpi_bus_offline_companions() to return an
    error code if hotplug is disabled for the given device object.
    [Also change the name of the function to acpi_bus_offline(),
    because it is not only about companions any more, and change
    the name of acpi_bus_online_companions() accordingly.]  Make
    acpi_scan_hot_remove() propagate that error to its callers.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 4d377a22622a..9bdcc187bf4b 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -125,8 +125,8 @@ acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, cha
 }
 static DEVICE_ATTR(modalias, 0444, acpi_device_modalias_show, NULL);
 
-static acpi_status acpi_bus_offline_companions(acpi_handle handle, u32 lvl,
-					       void *data, void **ret_p)
+static acpi_status acpi_bus_offline(acpi_handle handle, u32 lvl, void *data,
+				    void **ret_p)
 {
 	struct acpi_device *device = NULL;
 	struct acpi_device_physical_node *pn;
@@ -136,6 +136,11 @@ static acpi_status acpi_bus_offline_companions(acpi_handle handle, u32 lvl,
 	if (acpi_bus_get_device(handle, &device))
 		return AE_OK;
 
+	if (device->handler && !device->handler->hotplug.enabled) {
+		*ret_p = &device->dev;
+		return AE_SUPPORT;
+	}
+
 	mutex_lock(&device->physical_node_lock);
 
 	list_for_each_entry(pn, &device->physical_node_list, node) {
@@ -168,8 +173,8 @@ static acpi_status acpi_bus_offline_companions(acpi_handle handle, u32 lvl,
 	return status;
 }
 
-static acpi_status acpi_bus_online_companions(acpi_handle handle, u32 lvl,
-					      void *data, void **ret_p)
+static acpi_status acpi_bus_online(acpi_handle handle, u32 lvl, void *data,
+				   void **ret_p)
 {
 	struct acpi_device *device = NULL;
 	struct acpi_device_physical_node *pn;
@@ -214,26 +219,32 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	 * If the first pass is successful, the second one isn't needed, though.
 	 */
 	errdev = NULL;
-	acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
-			    NULL, acpi_bus_offline_companions,
-			    (void *)false, (void **)&errdev);
-	acpi_bus_offline_companions(handle, 0, (void *)false, (void **)&errdev);
+	status = acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
+				     NULL, acpi_bus_offline, (void *)false,
+				     (void **)&errdev);
+	if (status == AE_SUPPORT) {
+		dev_warn(errdev, "Offline disabled.\n");
+		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
+				    acpi_bus_online, NULL, NULL, NULL);
+		put_device(&device->dev);
+		return -EPERM;
+	}
+	acpi_bus_offline(handle, 0, (void *)false, (void **)&errdev);
 	if (errdev) {
 		errdev = NULL;
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
-				    NULL, acpi_bus_offline_companions,
-				    (void *)true , (void **)&errdev);
+				    NULL, acpi_bus_offline, (void *)true,
+				    (void **)&errdev);
 		if (!errdev || acpi_force_hot_remove)
-			acpi_bus_offline_companions(handle, 0, (void *)true,
-						    (void **)&errdev);
+			acpi_bus_offline(handle, 0, (void *)true,
+					 (void **)&errdev);
 
 		if (errdev && !acpi_force_hot_remove) {
 			dev_warn(errdev, "Offline failed.\n");
-			acpi_bus_online_companions(handle, 0, NULL, NULL);
+			acpi_bus_online(handle, 0, NULL, NULL);
 			acpi_walk_namespace(ACPI_TYPE_ANY, handle,
-					    ACPI_UINT32_MAX,
-					    acpi_bus_online_companions, NULL,
-					    NULL, NULL);
+					    ACPI_UINT32_MAX, acpi_bus_online,
+					    NULL, NULL, NULL);
 			put_device(&device->dev);
 			return -EBUSY;
 		}
@@ -290,10 +301,9 @@ static void acpi_bus_device_eject(void *context)
 		goto err_out;
 
 	handler = device->handler;
-	if (!handler || !handler->hotplug.enabled) {
-		ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
-		goto err_out;
-	}
+	if (!handler || !handler->hotplug.enabled)
+		goto err_support;
+
 	acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
 				  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 	if (handler->hotplug.mode == AHM_CONTAINER)
@@ -301,14 +311,19 @@ static void acpi_bus_device_eject(void *context)
 
 	get_device(&device->dev);
 	error = acpi_scan_hot_remove(device);
-	if (error)
+	if (error == -EPERM) {
+		goto err_support;
+	} else if (error) {
 		goto err_out;
+	}
 
  out:
 	mutex_unlock(&acpi_scan_lock);
 	unlock_device_hotplug();
 	return;
 
+ err_support:
+	ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
  err_out:
 	acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST, ost_code,
 				  NULL);

commit 6931007cc90ba94b3c2b29179d0a7cde194dabe8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 7 01:41:01 2013 +0100

    ACPI / scan: Start matching drivers after trying scan handlers
    
    ACPI scan handlers should always be attached to struct acpi_device
    objects before any ACPI drivers, but there is a window during which
    a driver may be attached to a struct acpi_device before checking if
    there is a matching scan handler.  Namely, that will happen if an
    ACPI driver module is loaded during acpi_bus_scan() right after
    the first namespace walk is complete and before the given device
    is processed by the second namespace walk.
    
    To prevent that from happening, set the match_driver flags of
    struct acpi_device objects right before running device_attach()
    for them in acpi_bus_device_attach().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index fbdb82e70d10..4d377a22622a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1677,7 +1677,6 @@ void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 
 void acpi_device_add_finalize(struct acpi_device *device)
 {
-	device->flags.match_driver = true;
 	dev_set_uevent_suppress(&device->dev, false);
 	kobject_uevent(&device->dev.kobj, KOBJ_ADD);
 }
@@ -1916,8 +1915,12 @@ static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 		return AE_OK;
 
 	ret = acpi_scan_attach_handler(device);
-	if (ret)
-		return ret > 0 ? AE_OK : AE_CTRL_DEPTH;
+	if (ret < 0)
+		return AE_CTRL_DEPTH;
+
+	device->flags.match_driver = true;
+	if (ret > 0)
+		return AE_OK;
 
 	ret = device_attach(&device->dev);
 	return ret >= 0 ? AE_OK : AE_CTRL_DEPTH;

commit 2421ad48f4aed63bc890e8f3c53ed581a542fb66
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 17 15:44:48 2013 +0200

    ACPI / PM: Drop two functions that are not used any more
    
    Two functions defined in device_pm.c, acpi_dev_pm_add_dependent()
    and acpi_dev_pm_remove_dependent(), have no callers and may be
    dropped, so drop them.
    
    Moreover, they are the only functions adding entries to and removing
    entries from the power_dependent list in struct acpi_device, so drop
    that list too.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 407ad13cac2f..fee8a297c7d9 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -999,7 +999,6 @@ int acpi_device_add(struct acpi_device *device,
 	INIT_LIST_HEAD(&device->wakeup_list);
 	INIT_LIST_HEAD(&device->physical_node_list);
 	mutex_init(&device->physical_node_lock);
-	INIT_LIST_HEAD(&device->power_dependent);
 
 	new_bus_id = kzalloc(sizeof(struct acpi_device_bus_id), GFP_KERNEL);
 	if (!new_bus_id) {

commit 6585925b62fa4dd2f4aecf634b0f8956577aa981
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Oct 1 23:02:43 2013 +0200

    ACPI: Use EXPORT_SYMBOL() for acpi_bus_get_device()
    
    Commit caf5c03f (ACPI: Move acpi_bus_get_device() from bus.c to
    scan.c) caused acpi_bus_get_device() to be exported using
    EXPORT_SYMBOL_GPL(), but that broke some binary drivers in
    existence, so revert that change.
    
    Reported-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 611ce9061dc5..407ad13cac2f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -968,7 +968,7 @@ int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
 	}
 	return 0;
 }
-EXPORT_SYMBOL_GPL(acpi_bus_get_device);
+EXPORT_SYMBOL(acpi_bus_get_device);
 
 int acpi_device_add(struct acpi_device *device,
 		    void (*release)(struct device *))

commit b27b14cebfdb687e6d281d2cf82858a30796dc2a
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Sun Sep 22 15:42:41 2013 +0800

    ACPI / scan: fix typo in comments of acpi_bus_unregister_driver()
    
    "APIC" should be "ACPI" here.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index fbdb82e70d10..611ce9061dc5 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1121,7 +1121,7 @@ int acpi_bus_register_driver(struct acpi_driver *driver)
 EXPORT_SYMBOL(acpi_bus_register_driver);
 
 /**
- * acpi_bus_unregister_driver - unregisters a driver with the APIC bus
+ * acpi_bus_unregister_driver - unregisters a driver with the ACPI bus
  * @driver: driver to unregister
  *
  * Unregisters a driver with the ACPI bus.  Searches the namespace for all

commit 85fb0a1c35d86ed9a4de8d6cba79ba0801f7a1f7
Merge: a92387419873 942f40155a74
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 10 23:14:53 2013 +0200

    Merge branch 'acpi-hotplug'
    
    * acpi-hotplug:
      PM / hibernate / memory hotplug: Rework mutual exclusion
      PM / hibernate: Create memory bitmaps after freezing user space
      ACPI / scan: Change ordering of locks for device hotplug

commit e0ae8fee0e11c1a8e9b45ab14ab5fe58d87f031d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Aug 30 14:19:29 2013 +0200

    ACPI / scan: Change ordering of locks for device hotplug
    
    Change the ordering of device hotplug locks in scan.c so that
    acpi_scan_lock is always acquired after device_hotplug_lock.
    
    This will make it possible to use device_hotplug_lock around some
    code paths that acquire acpi_scan_lock safely (most importantly
    system suspend and hibernation).  Apart from that, acpi_scan_lock
    is platform-specific and device_hotplug_lock is general, so the
    new ordering appears to be more appropriate from the overall
    design viewpoint.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e2f6d9dbdf0d..42982b522b36 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -207,8 +207,6 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 		return -EINVAL;
 	}
 
-	lock_device_hotplug();
-
 	/*
 	 * Carry out two passes here and ignore errors in the first pass,
 	 * because if the devices in question are memory blocks and
@@ -239,9 +237,6 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 					    ACPI_UINT32_MAX,
 					    acpi_bus_online_companions, NULL,
 					    NULL, NULL);
-
-			unlock_device_hotplug();
-
 			put_device(&device->dev);
 			return -EBUSY;
 		}
@@ -252,8 +247,6 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 
 	acpi_bus_trim(device);
 
-	unlock_device_hotplug();
-
 	/* Device node has been unregistered. */
 	put_device(&device->dev);
 	device = NULL;
@@ -309,6 +302,7 @@ static void acpi_bus_device_eject(void *context)
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 	int error;
 
+	lock_device_hotplug();
 	mutex_lock(&acpi_scan_lock);
 
 	acpi_bus_get_device(handle, &device);
@@ -332,6 +326,7 @@ static void acpi_bus_device_eject(void *context)
 
  out:
 	mutex_unlock(&acpi_scan_lock);
+	unlock_device_hotplug();
 	return;
 
  err_out:
@@ -346,8 +341,8 @@ static void acpi_scan_bus_device_check(acpi_handle handle, u32 ost_source)
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 	int error;
 
-	mutex_lock(&acpi_scan_lock);
 	lock_device_hotplug();
+	mutex_lock(&acpi_scan_lock);
 
 	if (ost_source != ACPI_NOTIFY_BUS_CHECK) {
 		acpi_bus_get_device(handle, &device);
@@ -373,9 +368,9 @@ static void acpi_scan_bus_device_check(acpi_handle handle, u32 ost_source)
 		kobject_uevent(&device->dev.kobj, KOBJ_ONLINE);
 
  out:
-	unlock_device_hotplug();
 	acpi_evaluate_hotplug_ost(handle, ost_source, ost_code, NULL);
 	mutex_unlock(&acpi_scan_lock);
+	unlock_device_hotplug();
 }
 
 static void acpi_scan_bus_check(void *context)
@@ -466,6 +461,7 @@ void acpi_bus_hot_remove_device(void *context)
 	acpi_handle handle = device->handle;
 	int error;
 
+	lock_device_hotplug();
 	mutex_lock(&acpi_scan_lock);
 
 	error = acpi_scan_hot_remove(device);
@@ -475,6 +471,7 @@ void acpi_bus_hot_remove_device(void *context)
 					  NULL);
 
 	mutex_unlock(&acpi_scan_lock);
+	unlock_device_hotplug();
 	kfree(context);
 }
 EXPORT_SYMBOL(acpi_bus_hot_remove_device);

commit 7bc583d102d6f89c3dc4b502caec6ba03c9d318f
Merge: da48afb26b40 f943db40c29f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Aug 30 14:14:25 2013 +0200

    Merge branch 'acpi-hotplug'
    
    * acpi-hotplug:
      ACPI / hotplug: Remove containers synchronously
      driver core / ACPI: Avoid device hot remove locking issues

commit f943db40c29f3c82a56956e9ca36f21d6d855db9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 28 21:41:07 2013 +0200

    ACPI / hotplug: Remove containers synchronously
    
    The current protocol for handling hot remove of containers is very
    fragile and causes acpi_eject_store() to acquire acpi_scan_lock
    which may deadlock with the removal of the device that it is called
    for (the reason is that device sysfs attributes cannot be removed
    while their callbacks are being executed and ACPI device objects
    are removed under acpi_scan_lock).
    
    The problem is related to the fact that containers are handled by
    acpi_bus_device_eject() in a special way, which is to emit an
    offline uevent instead of just removing the container.  Then, user
    space is expected to handle that uevent and use the container's
    "eject" attribute to actually remove it.  That is fragile, because
    user space may fail to complete the ejection (for example, by not
    using the container's "eject" attribute at all) leaving the BIOS
    kind of in a limbo.  Moreover, if the eject event is not signaled
    for a container itself, but for its parent device object (or
    generally, for an ancestor above it in the ACPI namespace), the
    container will be removed straight away without doing that whole
    dance.
    
    For this reason, modify acpi_bus_device_eject() to remove containers
    synchronously like any other objects (user space will get its uevent
    anyway in case it does some other things in response to it) and
    remove the eject_pending ACPI device flag that is not used any more.
    This way acpi_eject_store() doesn't have a reason to acquire
    acpi_scan_lock any more and one possible deadlock scenario goes
    away (plus the code is simplified a bit).
    
    Reported-and-tested-by: Gu Zheng <guz.fnst@cn.fujitsu.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8a46c924effd..e2f6d9dbdf0d 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -307,6 +307,7 @@ static void acpi_bus_device_eject(void *context)
 	struct acpi_device *device = NULL;
 	struct acpi_scan_handler *handler;
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
+	int error;
 
 	mutex_lock(&acpi_scan_lock);
 
@@ -321,17 +322,13 @@ static void acpi_bus_device_eject(void *context)
 	}
 	acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
 				  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
-	if (handler->hotplug.mode == AHM_CONTAINER) {
-		device->flags.eject_pending = true;
+	if (handler->hotplug.mode == AHM_CONTAINER)
 		kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
-	} else {
-		int error;
 
-		get_device(&device->dev);
-		error = acpi_scan_hot_remove(device);
-		if (error)
-			goto err_out;
-	}
+	get_device(&device->dev);
+	error = acpi_scan_hot_remove(device);
+	if (error)
+		goto err_out;
 
  out:
 	mutex_unlock(&acpi_scan_lock);
@@ -516,7 +513,6 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 	struct acpi_eject_event *ej_event;
 	acpi_object_type not_used;
 	acpi_status status;
-	u32 ost_source;
 	int ret;
 
 	if (!count || buf[0] != '1')
@@ -530,43 +526,28 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 	if (ACPI_FAILURE(status) || !acpi_device->flags.ejectable)
 		return -ENODEV;
 
-	mutex_lock(&acpi_scan_lock);
-
-	if (acpi_device->flags.eject_pending) {
-		/* ACPI eject notification event. */
-		ost_source = ACPI_NOTIFY_EJECT_REQUEST;
-		acpi_device->flags.eject_pending = 0;
-	} else {
-		/* Eject initiated by user space. */
-		ost_source = ACPI_OST_EC_OSPM_EJECT;
-	}
 	ej_event = kmalloc(sizeof(*ej_event), GFP_KERNEL);
 	if (!ej_event) {
 		ret = -ENOMEM;
 		goto err_out;
 	}
-	acpi_evaluate_hotplug_ost(acpi_device->handle, ost_source,
+	acpi_evaluate_hotplug_ost(acpi_device->handle, ACPI_OST_EC_OSPM_EJECT,
 				  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 	ej_event->device = acpi_device;
-	ej_event->event = ost_source;
+	ej_event->event = ACPI_OST_EC_OSPM_EJECT;
 	get_device(&acpi_device->dev);
 	status = acpi_os_hotplug_execute(acpi_bus_hot_remove_device, ej_event);
-	if (ACPI_FAILURE(status)) {
-		put_device(&acpi_device->dev);
-		kfree(ej_event);
-		ret = status == AE_NO_MEMORY ? -ENOMEM : -EAGAIN;
-		goto err_out;
-	}
-	ret = count;
+	if (ACPI_SUCCESS(status))
+		return count;
 
- out:
-	mutex_unlock(&acpi_scan_lock);
-	return ret;
+	put_device(&acpi_device->dev);
+	kfree(ej_event);
+	ret = status == AE_NO_MEMORY ? -ENOMEM : -EAGAIN;
 
  err_out:
-	acpi_evaluate_hotplug_ost(acpi_device->handle, ost_source,
+	acpi_evaluate_hotplug_ost(acpi_device->handle, ACPI_OST_EC_OSPM_EJECT,
 				  ACPI_OST_SC_NON_SPECIFIC_FAILURE, NULL);
-	goto out;
+	return ret;
 }
 
 static DEVICE_ATTR(eject, 0200, NULL, acpi_eject_store);

commit 0c581415b522267138d807814e526aa7534b9a61
Merge: afdca01c9821 7702ae0dd9b4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 27 01:29:04 2013 +0200

    Merge branch 'acpi-assorted'
    
    * acpi-assorted:
      ACPI / osl: Kill macro INVALID_TABLE().
      earlycpio.c: Fix the confusing comment of find_cpio_data().
      ACPI / x86: Print Hot-Pluggable Field in SRAT.
      ACPI / thermal: Use THERMAL_TRIPS_NONE macro to replace number
      ACPI / thermal: Remove unused macros in the driver/acpi/thermal.c
      ACPI / thermal: Remove the unused lock of struct acpi_thermal
      ACPI / osl: Fix osi_setup_entries[] __initdata attribute location
      ACPI / numa: Fix __init attribute location in slit_valid()
      ACPI / dock: Fix __init attribute location in find_dock_and_bay()
      ACPI / Sleep: Fix incorrect placement of __initdata
      ACPI / processor: Fix incorrect placement of __initdata
      ACPI / EC: Fix incorrect placement of __initdata
      ACPI / scan: Drop unnecessary label from acpi_create_platform_device()
      ACPI: Move acpi_bus_get_device() from bus.c to scan.c
      ACPI / scan: Allow platform device creation without any IO resources
      ACPI: Cleanup sparse warning on acpi_os_initialize1()
      platform / thinkpad: Remove deprecated hotkey_report_mode parameter
      ACPI: Remove the old /proc/acpi/event interface

commit 0ad4c9a9848fdd46dc422160efd947489a98bbc1
Merge: abe5430e9d53 593298e68a3a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 27 01:28:17 2013 +0200

    Merge branch 'acpi-pm'
    
    * acpi-pm:
      ACPI / PM: Add state information to error message in acpi_device_set_power()
      ACPI / PM: Remove redundant power manageable check from acpi_bus_set_power()
      ACPI / PM: Use ACPI_STATE_D3_COLD instead of ACPI_STATE_D3 everywhere
      ACPI / PM: Make messages in acpi_device_set_power() print device names
      ACPI / PM: Only set power states of devices that are power manageable

commit c92f56cbdfc08c8c207c9476c69c99fdbadbd77b
Merge: d8dfad3876e4 0177f29fea53
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 27 01:25:28 2013 +0200

    Merge branch 'acpi-cleanup'
    
    * acpi-cleanup: (21 commits)
      ACPI / dock: fix error return code in dock_add()
      ACPI / dock: Drop unnecessary local variable from dock_add()
      ACPI / dock / PCI: Drop ACPI dock notifier chain
      ACPI / dock: Do not check CONFIG_ACPI_DOCK_MODULE
      ACPI / dock: Do not leak memory on falilures to add a dock station
      ACPI: Drop ACPI bus notifier call chain
      ACPI / dock: Rework the handling of notifications
      ACPI / dock: Simplify dock_init_hotplug() and dock_release_hotplug()
      ACPI / dock: Walk list in reverse order during removal of devices
      ACPI / dock: Rework and simplify find_dock_devices()
      ACPI / dock: Drop the hp_lock mutex from struct dock_station
      ACPI: simplify acpiphp driver with new helper functions
      ACPI: simplify dock driver with new helper functions
      ACPI: Export acpi_(bay)|(dock)_match() from scan.c
      ACPI: introduce two helper functions for _EJ0 and _LCK
      ACPI: introduce helper function acpi_execute_simple_method()
      ACPI: introduce helper function acpi_has_method()
      ACPI / dock: simplify dock_create_acpi_device()
      ACPI / dock: mark initialization functions with __init
      ACPI / dock: drop redundant spin lock in dock station object
      ...

commit f3ce717e60572421f56d89c9a85ac42e634d16e7
Merge: d4e4ab86bcba e73d3136355f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 14 23:22:45 2013 +0200

    Merge back earlier 'acpi-assorted' material

commit caf5c03f17c33a14ef0e7033000f89e4d0910f5a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 30 14:38:34 2013 +0200

    ACPI: Move acpi_bus_get_device() from bus.c to scan.c
    
    Move acpi_bus_get_device() from bus.c to scan.c which allows
    acpi_bus_data_handler() to become static and clean up the latter.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 10985573aaa7..4b2679342e82 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -997,6 +997,28 @@ struct bus_type acpi_bus_type = {
 	.uevent		= acpi_device_uevent,
 };
 
+static void acpi_bus_data_handler(acpi_handle handle, void *context)
+{
+	/* Intentionally empty. */
+}
+
+int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
+{
+	acpi_status status;
+
+	if (!device)
+		return -EINVAL;
+
+	status = acpi_get_data(handle, acpi_bus_data_handler, (void **)device);
+	if (ACPI_FAILURE(status) || !*device) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No context for object [%p]\n",
+				  handle));
+		return -ENODEV;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(acpi_bus_get_device);
+
 int acpi_device_add(struct acpi_device *device,
 		    void (*release)(struct device *))
 {
@@ -1208,14 +1230,6 @@ acpi_bus_get_ejd(acpi_handle handle, acpi_handle *ejd)
 }
 EXPORT_SYMBOL_GPL(acpi_bus_get_ejd);
 
-void acpi_bus_data_handler(acpi_handle handle, void *context)
-{
-
-	/* TBD */
-
-	return;
-}
-
 static int acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 					struct acpi_device_wakeup *wakeup)
 {

commit 8ad928d52e63a9b7d69f0873d7318c4561e2f8cd
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 30 14:36:20 2013 +0200

    ACPI / PM: Use ACPI_STATE_D3_COLD instead of ACPI_STATE_D3 everywhere
    
    There are several places in the tree where ACPI_STATE_D3 is used
    instead of ACPI_STATE_D3_COLD which should be used instead for
    clarity.  Modify them all to use ACPI_STATE_D3_COLD as appropriate.
    
    [The definition of ACPI_STATE_D3 itself cannot go away at this point
     as it is part of ACPICA.]
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8a46c924effd..c30df3ad2d71 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1450,8 +1450,8 @@ static void acpi_bus_get_power_flags(struct acpi_device *device)
 	/* Set defaults for D0 and D3 states (always valid) */
 	device->power.states[ACPI_STATE_D0].flags.valid = 1;
 	device->power.states[ACPI_STATE_D0].power = 100;
-	device->power.states[ACPI_STATE_D3].flags.valid = 1;
-	device->power.states[ACPI_STATE_D3].power = 0;
+	device->power.states[ACPI_STATE_D3_COLD].flags.valid = 1;
+	device->power.states[ACPI_STATE_D3_COLD].power = 0;
 
 	/* Set D3cold's explicit_set flag if _PS3 exists. */
 	if (device->power.states[ACPI_STATE_D3_HOT].flags.explicit_set)

commit ebf4df8db0e7e5db9f7fca5fcd0c2b90ac954385
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Sat Jun 29 00:24:41 2013 +0800

    ACPI: Export acpi_(bay)|(dock)_match() from scan.c
    
    Functions acpi_dock_match() and acpi_bay_match() in scan.c can be
    shared with dock.c to reduce code duplication, so export them as
    global functions.
    
    Also add a new function acpi_ata_match() to check whether an ACPI
    device object represents an ATA device.
    
    [rjw: Changelog]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 4c25c3b7ef81..62e2055e8806 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1479,44 +1479,46 @@ static void acpi_device_get_busid(struct acpi_device *device)
 	}
 }
 
+/*
+ * acpi_ata_match - see if an acpi object is an ATA device
+ *
+ * If an acpi object has one of the ACPI ATA methods defined,
+ * then we can safely call it an ATA device.
+ */
+bool acpi_ata_match(acpi_handle handle)
+{
+	return acpi_has_method(handle, "_GTF") ||
+	       acpi_has_method(handle, "_GTM") ||
+	       acpi_has_method(handle, "_STM") ||
+	       acpi_has_method(handle, "_SDD");
+}
+
 /*
  * acpi_bay_match - see if an acpi object is an ejectable driver bay
  *
  * If an acpi object is ejectable and has one of the ACPI ATA methods defined,
  * then we can safely call it an ejectable drive bay
  */
-static int acpi_bay_match(acpi_handle handle)
+bool acpi_bay_match(acpi_handle handle)
 {
 	acpi_handle phandle;
 
 	if (!acpi_has_method(handle, "_EJ0"))
-		return -ENODEV;
+		return false;
+	if (acpi_ata_match(handle))
+		return true;
+	if (ACPI_FAILURE(acpi_get_parent(handle, &phandle)))
+		return false;
 
-	if (acpi_has_method(handle, "_GTF") ||
-	    acpi_has_method(handle, "_GTM") ||
-	    acpi_has_method(handle, "_STM") ||
-	    acpi_has_method(handle, "_SDD"))
-		return 0;
-
-	if (acpi_get_parent(handle, &phandle))
-		return -ENODEV;
-
-	if (acpi_has_method(phandle, "_GTF") ||
-	    acpi_has_method(phandle, "_GTM") ||
-	    acpi_has_method(phandle, "_STM") ||
-	    acpi_has_method(phandle, "_SDD"))
-                return 0;
-
-	return -ENODEV;
+	return acpi_ata_match(phandle);
 }
 
 /*
  * acpi_dock_match - see if an acpi object has a _DCK method
  */
-static int acpi_dock_match(acpi_handle handle)
+bool acpi_dock_match(acpi_handle handle)
 {
-	acpi_handle tmp;
-	return acpi_get_handle(handle, "_DCK", &tmp);
+	return acpi_has_method(handle, "_DCK");
 }
 
 const char *acpi_device_hid(struct acpi_device *device)
@@ -1554,33 +1556,26 @@ static void acpi_add_id(struct acpi_device_pnp *pnp, const char *dev_id)
  * lacks the SMBUS01 HID and the methods do not have the necessary "_"
  * prefix.  Work around this.
  */
-static int acpi_ibm_smbus_match(acpi_handle handle)
+static bool acpi_ibm_smbus_match(acpi_handle handle)
 {
-	struct acpi_buffer path = {ACPI_ALLOCATE_BUFFER, NULL};
-	int result;
+	char node_name[ACPI_PATH_SEGMENT_LENGTH];
+	struct acpi_buffer path = { sizeof(node_name), node_name };
 
 	if (!dmi_name_in_vendors("IBM"))
-		return -ENODEV;
+		return false;
 
 	/* Look for SMBS object */
-	result = acpi_get_name(handle, ACPI_SINGLE_NAME, &path);
-	if (result)
-		return result;
-
-	if (strcmp("SMBS", path.pointer)) {
-		result = -ENODEV;
-		goto out;
-	}
+	if (ACPI_FAILURE(acpi_get_name(handle, ACPI_SINGLE_NAME, &path)) ||
+	    strcmp("SMBS", path.pointer))
+		return false;
 
 	/* Does it have the necessary (but misnamed) methods? */
-	result = -ENODEV;
 	if (acpi_has_method(handle, "SBI") &&
 	    acpi_has_method(handle, "SBR") &&
 	    acpi_has_method(handle, "SBW"))
-		result = 0;
-out:
-	kfree(path.pointer);
-	return result;
+		return true;
+
+	return false;
 }
 
 static void acpi_set_pnp_ids(acpi_handle handle, struct acpi_device_pnp *pnp,
@@ -1628,11 +1623,11 @@ static void acpi_set_pnp_ids(acpi_handle handle, struct acpi_device_pnp *pnp,
 		 */
 		if (acpi_is_video_device(handle))
 			acpi_add_id(pnp, ACPI_VIDEO_HID);
-		else if (ACPI_SUCCESS(acpi_bay_match(handle)))
+		else if (acpi_bay_match(handle))
 			acpi_add_id(pnp, ACPI_BAY_HID);
-		else if (ACPI_SUCCESS(acpi_dock_match(handle)))
+		else if (acpi_dock_match(handle))
 			acpi_add_id(pnp, ACPI_DOCK_HID);
-		else if (!acpi_ibm_smbus_match(handle))
+		else if (acpi_ibm_smbus_match(handle))
 			acpi_add_id(pnp, ACPI_SMBUS_IBM_HID);
 		else if (list_empty(&pnp->ids) && handle == ACPI_ROOT_OBJECT) {
 			acpi_add_id(pnp, ACPI_BUS_HID); /* \_SB, LNXSYBUS */

commit 7d2421f84b445dc48c68d33911f1fd6ce6853ee3
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Sat Jun 29 00:24:40 2013 +0800

    ACPI: introduce two helper functions for _EJ0 and _LCK
    
    Introduce two helper functions, acpi_evaluate_ej0() and
    acpi_evaluate_lck(), that will execute the _EJ0 and _LCK ACPI
    control methods, respectively, and use them to simplify the
    ACPI scan code.
    
    [rjw: Changelog]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ada0b4cf2ba5..4c25c3b7ef81 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -193,8 +193,6 @@ static acpi_status acpi_bus_online_companions(acpi_handle handle, u32 lvl,
 static int acpi_scan_hot_remove(struct acpi_device *device)
 {
 	acpi_handle handle = device->handle;
-	struct acpi_object_list arg_list;
-	union acpi_object arg;
 	struct device *errdev;
 	acpi_status status;
 	unsigned long long sta;
@@ -257,32 +255,15 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	put_device(&device->dev);
 	device = NULL;
 
-	if (acpi_has_method(handle, "_LCK")) {
-		arg_list.count = 1;
-		arg_list.pointer = &arg;
-		arg.type = ACPI_TYPE_INTEGER;
-		arg.integer.value = 0;
-		acpi_evaluate_object(handle, "_LCK", &arg_list, NULL);
-	}
-
-	arg_list.count = 1;
-	arg_list.pointer = &arg;
-	arg.type = ACPI_TYPE_INTEGER;
-	arg.integer.value = 1;
-
+	acpi_evaluate_lck(handle, 0);
 	/*
 	 * TBD: _EJD support.
 	 */
-	status = acpi_evaluate_object(handle, "_EJ0", &arg_list, NULL);
-	if (ACPI_FAILURE(status)) {
-		if (status == AE_NOT_FOUND) {
-			return -ENODEV;
-		} else {
-			acpi_handle_warn(handle, "Eject failed (0x%x)\n",
-								status);
-			return -EIO;
-		}
-	}
+	status = acpi_evaluate_ej0(handle);
+	if (status == AE_NOT_FOUND)
+		return -ENODEV;
+	else if (ACPI_FAILURE(status))
+		return -EIO;
 
 	/*
 	 * Verify if eject was indeed successful.  If not, log an error

commit 952c63e9512b63220886105cfc791507046fa39a
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Sat Jun 29 00:24:38 2013 +0800

    ACPI: introduce helper function acpi_has_method()
    
    Introduce helper function acpi_has_method() and use it in a number
    of places to simplify code.
    
    [rjw: Changelog]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 10985573aaa7..ada0b4cf2ba5 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -193,7 +193,6 @@ static acpi_status acpi_bus_online_companions(acpi_handle handle, u32 lvl,
 static int acpi_scan_hot_remove(struct acpi_device *device)
 {
 	acpi_handle handle = device->handle;
-	acpi_handle not_used;
 	struct acpi_object_list arg_list;
 	union acpi_object arg;
 	struct device *errdev;
@@ -258,7 +257,7 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	put_device(&device->dev);
 	device = NULL;
 
-	if (ACPI_SUCCESS(acpi_get_handle(handle, "_LCK", &not_used))) {
+	if (acpi_has_method(handle, "_LCK")) {
 		arg_list.count = 1;
 		arg_list.pointer = &arg;
 		arg.type = ACPI_TYPE_INTEGER;
@@ -652,7 +651,6 @@ static int acpi_device_setup_files(struct acpi_device *dev)
 {
 	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
 	acpi_status status;
-	acpi_handle temp;
 	unsigned long long sun;
 	int result = 0;
 
@@ -678,8 +676,7 @@ static int acpi_device_setup_files(struct acpi_device *dev)
 	/*
 	 * If device has _STR, 'description' file is created
 	 */
-	status = acpi_get_handle(dev->handle, "_STR", &temp);
-	if (ACPI_SUCCESS(status)) {
+	if (acpi_has_method(dev->handle, "_STR")) {
 		status = acpi_evaluate_object(dev->handle, "_STR",
 					NULL, &buffer);
 		if (ACPI_FAILURE(status))
@@ -709,8 +706,7 @@ static int acpi_device_setup_files(struct acpi_device *dev)
          * If device has _EJ0, 'eject' file is created that is used to trigger
          * hot-removal function from userland.
          */
-	status = acpi_get_handle(dev->handle, "_EJ0", &temp);
-	if (ACPI_SUCCESS(status)) {
+	if (acpi_has_method(dev->handle, "_EJ0")) {
 		result = device_create_file(&dev->dev, &dev_attr_eject);
 		if (result)
 			return result;
@@ -732,9 +728,6 @@ static int acpi_device_setup_files(struct acpi_device *dev)
 
 static void acpi_device_remove_files(struct acpi_device *dev)
 {
-	acpi_status status;
-	acpi_handle temp;
-
 	if (dev->flags.power_manageable) {
 		device_remove_file(&dev->dev, &dev_attr_power_state);
 		if (dev->power.flags.power_resources)
@@ -745,20 +738,17 @@ static void acpi_device_remove_files(struct acpi_device *dev)
 	/*
 	 * If device has _STR, remove 'description' file
 	 */
-	status = acpi_get_handle(dev->handle, "_STR", &temp);
-	if (ACPI_SUCCESS(status)) {
+	if (acpi_has_method(dev->handle, "_STR")) {
 		kfree(dev->pnp.str_obj);
 		device_remove_file(&dev->dev, &dev_attr_description);
 	}
 	/*
 	 * If device has _EJ0, remove 'eject' file.
 	 */
-	status = acpi_get_handle(dev->handle, "_EJ0", &temp);
-	if (ACPI_SUCCESS(status))
+	if (acpi_has_method(dev->handle, "_EJ0"))
 		device_remove_file(&dev->dev, &dev_attr_eject);
 
-	status = acpi_get_handle(dev->handle, "_SUN", &temp);
-	if (ACPI_SUCCESS(status))
+	if (acpi_has_method(dev->handle, "_SUN"))
 		device_remove_file(&dev->dev, &dev_attr_sun);
 
 	if (dev->pnp.unique_id)
@@ -1334,13 +1324,10 @@ static void acpi_bus_set_run_wake_flags(struct acpi_device *device)
 
 static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 {
-	acpi_handle temp;
-	acpi_status status = 0;
 	int err;
 
 	/* Presence of _PRW indicates wake capable */
-	status = acpi_get_handle(device->handle, "_PRW", &temp);
-	if (ACPI_FAILURE(status))
+	if (!acpi_has_method(device->handle, "_PRW"))
 		return;
 
 	err = acpi_bus_extract_wakeup_device_power_package(device->handle,
@@ -1370,7 +1357,6 @@ static void acpi_bus_init_power_state(struct acpi_device *device, int state)
 	struct acpi_device_power_state *ps = &device->power.states[state];
 	char pathname[5] = { '_', 'P', 'R', '0' + state, '\0' };
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
-	acpi_handle handle;
 	acpi_status status;
 
 	INIT_LIST_HEAD(&ps->resources);
@@ -1393,8 +1379,7 @@ static void acpi_bus_init_power_state(struct acpi_device *device, int state)
 
 	/* Evaluate "_PSx" to see if we can do explicit sets */
 	pathname[2] = 'S';
-	status = acpi_get_handle(device->handle, pathname, &handle);
-	if (ACPI_SUCCESS(status))
+	if (acpi_has_method(device->handle, pathname))
 		ps->flags.explicit_set = 1;
 
 	/*
@@ -1413,28 +1398,21 @@ static void acpi_bus_init_power_state(struct acpi_device *device, int state)
 
 static void acpi_bus_get_power_flags(struct acpi_device *device)
 {
-	acpi_status status;
-	acpi_handle handle;
 	u32 i;
 
 	/* Presence of _PS0|_PR0 indicates 'power manageable' */
-	status = acpi_get_handle(device->handle, "_PS0", &handle);
-	if (ACPI_FAILURE(status)) {
-		status = acpi_get_handle(device->handle, "_PR0", &handle);
-		if (ACPI_FAILURE(status))
-			return;
-	}
+	if (!acpi_has_method(device->handle, "_PS0") &&
+	    !acpi_has_method(device->handle, "_PR0"))
+		return;
 
 	device->flags.power_manageable = 1;
 
 	/*
 	 * Power Management Flags
 	 */
-	status = acpi_get_handle(device->handle, "_PSC", &handle);
-	if (ACPI_SUCCESS(status))
+	if (acpi_has_method(device->handle, "_PSC"))
 		device->power.flags.explicit_get = 1;
-	status = acpi_get_handle(device->handle, "_IRC", &handle);
-	if (ACPI_SUCCESS(status))
+	if (acpi_has_method(device->handle, "_IRC"))
 		device->power.flags.inrush_current = 1;
 
 	/*
@@ -1468,28 +1446,18 @@ static void acpi_bus_get_power_flags(struct acpi_device *device)
 
 static void acpi_bus_get_flags(struct acpi_device *device)
 {
-	acpi_status status = AE_OK;
-	acpi_handle temp = NULL;
-
 	/* Presence of _STA indicates 'dynamic_status' */
-	status = acpi_get_handle(device->handle, "_STA", &temp);
-	if (ACPI_SUCCESS(status))
+	if (acpi_has_method(device->handle, "_STA"))
 		device->flags.dynamic_status = 1;
 
 	/* Presence of _RMV indicates 'removable' */
-	status = acpi_get_handle(device->handle, "_RMV", &temp);
-	if (ACPI_SUCCESS(status))
+	if (acpi_has_method(device->handle, "_RMV"))
 		device->flags.removable = 1;
 
 	/* Presence of _EJD|_EJ0 indicates 'ejectable' */
-	status = acpi_get_handle(device->handle, "_EJD", &temp);
-	if (ACPI_SUCCESS(status))
+	if (acpi_has_method(device->handle, "_EJD") ||
+	    acpi_has_method(device->handle, "_EJ0"))
 		device->flags.ejectable = 1;
-	else {
-		status = acpi_get_handle(device->handle, "_EJ0", &temp);
-		if (ACPI_SUCCESS(status))
-			device->flags.ejectable = 1;
-	}
 }
 
 static void acpi_device_get_busid(struct acpi_device *device)
@@ -1538,27 +1506,24 @@ static void acpi_device_get_busid(struct acpi_device *device)
  */
 static int acpi_bay_match(acpi_handle handle)
 {
-	acpi_status status;
-	acpi_handle tmp;
 	acpi_handle phandle;
 
-	status = acpi_get_handle(handle, "_EJ0", &tmp);
-	if (ACPI_FAILURE(status))
+	if (!acpi_has_method(handle, "_EJ0"))
 		return -ENODEV;
 
-	if ((ACPI_SUCCESS(acpi_get_handle(handle, "_GTF", &tmp))) ||
-		(ACPI_SUCCESS(acpi_get_handle(handle, "_GTM", &tmp))) ||
-		(ACPI_SUCCESS(acpi_get_handle(handle, "_STM", &tmp))) ||
-		(ACPI_SUCCESS(acpi_get_handle(handle, "_SDD", &tmp))))
+	if (acpi_has_method(handle, "_GTF") ||
+	    acpi_has_method(handle, "_GTM") ||
+	    acpi_has_method(handle, "_STM") ||
+	    acpi_has_method(handle, "_SDD"))
 		return 0;
 
 	if (acpi_get_parent(handle, &phandle))
 		return -ENODEV;
 
-        if ((ACPI_SUCCESS(acpi_get_handle(phandle, "_GTF", &tmp))) ||
-                (ACPI_SUCCESS(acpi_get_handle(phandle, "_GTM", &tmp))) ||
-                (ACPI_SUCCESS(acpi_get_handle(phandle, "_STM", &tmp))) ||
-                (ACPI_SUCCESS(acpi_get_handle(phandle, "_SDD", &tmp))))
+	if (acpi_has_method(phandle, "_GTF") ||
+	    acpi_has_method(phandle, "_GTM") ||
+	    acpi_has_method(phandle, "_STM") ||
+	    acpi_has_method(phandle, "_SDD"))
                 return 0;
 
 	return -ENODEV;
@@ -1610,7 +1575,6 @@ static void acpi_add_id(struct acpi_device_pnp *pnp, const char *dev_id)
  */
 static int acpi_ibm_smbus_match(acpi_handle handle)
 {
-	acpi_handle h_dummy;
 	struct acpi_buffer path = {ACPI_ALLOCATE_BUFFER, NULL};
 	int result;
 
@@ -1629,9 +1593,9 @@ static int acpi_ibm_smbus_match(acpi_handle handle)
 
 	/* Does it have the necessary (but misnamed) methods? */
 	result = -ENODEV;
-	if (ACPI_SUCCESS(acpi_get_handle(handle, "SBI", &h_dummy)) &&
-	    ACPI_SUCCESS(acpi_get_handle(handle, "SBR", &h_dummy)) &&
-	    ACPI_SUCCESS(acpi_get_handle(handle, "SBW", &h_dummy)))
+	if (acpi_has_method(handle, "SBI") &&
+	    acpi_has_method(handle, "SBR") &&
+	    acpi_has_method(handle, "SBW"))
 		result = 0;
 out:
 	kfree(path.pointer);
@@ -1898,7 +1862,6 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 	struct acpi_device *device = NULL;
 	int type;
 	unsigned long long sta;
-	acpi_status status;
 	int result;
 
 	acpi_bus_get_device(handle, &device);
@@ -1919,10 +1882,8 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 	if (!(sta & ACPI_STA_DEVICE_PRESENT) &&
 	    !(sta & ACPI_STA_DEVICE_FUNCTIONING)) {
 		struct acpi_device_wakeup wakeup;
-		acpi_handle temp;
 
-		status = acpi_get_handle(handle, "_PRW", &temp);
-		if (ACPI_SUCCESS(status)) {
+		if (acpi_has_method(handle, "_PRW")) {
 			acpi_bus_extract_wakeup_device_power_package(handle,
 								     &wakeup);
 			acpi_power_resources_list_free(&wakeup.resources);

commit 8832f7e43fa7f0f19bd54e13766a825dd1ed4d6f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 8 02:01:53 2013 +0200

    ACPI / scan: Always call acpi_bus_scan() for bus check notifications
    
    An ACPI_NOTIFY_BUS_CHECK notification means that we should scan the
    entire namespace starting from the given handle even if the device
    represented by that handle is present (other devices below it may
    just have appeared).
    
    For this reason, modify acpi_scan_bus_device_check() to always run
    acpi_bus_scan() if the notification being handled is of type
    ACPI_NOTIFY_BUS_CHECK.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Cc: 3.10+ <stable@vger.kernel.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 080d75962c57..8a46c924effd 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -352,10 +352,12 @@ static void acpi_scan_bus_device_check(acpi_handle handle, u32 ost_source)
 	mutex_lock(&acpi_scan_lock);
 	lock_device_hotplug();
 
-	acpi_bus_get_device(handle, &device);
-	if (device) {
-		dev_warn(&device->dev, "Attempt to re-insert\n");
-		goto out;
+	if (ost_source != ACPI_NOTIFY_BUS_CHECK) {
+		acpi_bus_get_device(handle, &device);
+		if (device) {
+			dev_warn(&device->dev, "Attempt to re-insert\n");
+			goto out;
+		}
 	}
 	acpi_evaluate_hotplug_ost(handle, ost_source,
 				  ACPI_OST_SC_INSERT_IN_PROGRESS, NULL);

commit 3a391a39593b48341f0908511590a6c0e55cc069
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 12 13:45:59 2013 +0200

    ACPI / scan: Do not try to attach scan handlers to devices having them
    
    In acpi_bus_device_attach(), if there is an ACPI device object
    for the given handle and that device object has a scan handler
    attached to it already, there's nothing more to do for that handle.
    Moreover, if acpi_scan_attach_handler() is called then, it may
    execute the .attach() callback of the ACPI scan handler already
    attached to the device object and that may lead to interesting
    breakage.
    
    For this reason, make acpi_bus_device_attach() return success
    immediately when the handle's device object has a scan handler
    attached to it.
    
    Reported-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Cc: 3.10+ <stable@vger.kernel.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 10985573aaa7..080d75962c57 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1981,6 +1981,9 @@ static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 	if (acpi_bus_get_device(handle, &device))
 		return AE_CTRL_DEPTH;
 
+	if (device->handler)
+		return AE_OK;
+
 	ret = acpi_scan_attach_handler(device);
 	if (ret)
 		return ret > 0 ? AE_OK : AE_CTRL_DEPTH;

commit b67cf7c44c7e6b485f1c255ac3c1fe98cc99b677
Author: Haicheng Li <haicheng.li@linux.intel.com>
Date:   Thu Jul 4 12:07:11 2013 +0800

    ACPI / scan: remove unused LIST_HEAD(acpi_device_list)
    
    The acpi_device_list list is not used, so removed it.
    
    [rjw: Changelog]
    Signed-off-by: Haicheng Li <haicheng.li@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index dfe76f17cfc4..10985573aaa7 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -35,7 +35,6 @@ bool acpi_force_hot_remove;
 
 static const char *dummy_hid = "device";
 
-static LIST_HEAD(acpi_device_list);
 static LIST_HEAD(acpi_bus_id_list);
 static DEFINE_MUTEX(acpi_scan_lock);
 static LIST_HEAD(acpi_scan_handlers_list);

commit bdc8f09685a25a12f2f5282f56672ba663ecb88c
Merge: f4c9f4023899 eff9a4b62b14
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 28 13:00:38 2013 +0200

    Merge branch 'acpi-assorted'
    
    * acpi-assorted:
      ACPI / EC: Add HP Folio 13 to ec_dmi_table in order to skip DSDT scan
      ACPI: Add CMOS RTC Operation Region handler support
      ACPI: Remove unused flags in acpi_device_flags
      ACPI: Remove useless initializers
      ACPI / battery: Make sure all spaces are in correct places
      ACPI: add _STA evaluation at do_acpi_find_child()
      ACPI / EC: access user space with get_user()/put_user()

commit 8e9914d5efe460600f5948da7ae4c1b6c038a4c0
Merge: 80338681bbc5 24071f472d81
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 28 12:58:21 2013 +0200

    Merge branch 'acpi-scan'
    
    * acpi-scan:
      ACPI / scan: Do not bind ACPI drivers to objects with scan handlers
      ACPI / ia64 / sba_iommu: Use ACPI scan handler for device discovery
      ACPI / scan: Simplify ACPI driver probing

commit a204dbc61b7f4cb1a7e2cb3ad057b135164782da
Merge: 45e00374db94 08f502c1c343
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 28 12:58:05 2013 +0200

    Merge branch 'acpi-hotplug'
    
    * acpi-hotplug:
      ACPI: Do not use CONFIG_ACPI_HOTPLUG_MEMORY_MODULE
      ACPI / cpufreq: Add ACPI processor device IDs to acpi-cpufreq
      Memory hotplug: Move alternative function definitions to header
      ACPI / processor: Fix potential NULL pointer dereference in acpi_processor_add()
      Memory hotplug / ACPI: Simplify memory removal
      ACPI / scan: Add second pass of companion offlining to hot-remove code
      Driver core / MM: Drop offline_memory_block()
      ACPI / processor: Pass processor object handle to acpi_bind_one()
      ACPI: Drop removal_type field from struct acpi_device
      Driver core / memory: Simplify __memory_block_change_state()
      ACPI / processor: Initialize per_cpu(processors, pr->id) properly
      CPU: Fix sysfs cpu/online of offlined CPUs
      Driver core: Introduce offline/online callbacks for memory blocks
      ACPI / memhotplug: Bind removable memory blocks to ACPI device nodes
      ACPI / processor: Use common hotplug infrastructure
      ACPI / hotplug: Use device offline/online for graceful hot-removal
      Driver core: Use generic offline/online for CPU offline/online
      Driver core: Add offline/online device operations

commit 2fa97feb4406c546b52e35b6b6c50cb8f63425d2
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Jun 5 02:27:50 2013 +0000

    ACPI: Add CMOS RTC Operation Region handler support
    
    On HP Folio 13-2000, the BIOS defines a CMOS RTC Operation Region and
    the EC's _REG methord accesses that region.  Thus an appropriate
    address space handler must be registered for that region before the
    EC driver is loaded.
    
    Introduce a mechanism for adding CMOS RTC address space handlers.
    Register an ACPI scan handler for CMOS RTC devices such that, when
    a device of that kind is detected during an ACPI namespace scan, a
    common CMOS RTC operation region address space handler will be
    installed for it.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=54621
    Reported-and-tested-by: Stefan Nagy <public@stefan-nagy.at>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Cc: 3.9+ <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b14ac46948c9..a514be216440 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2040,6 +2040,7 @@ int __init acpi_scan_init(void)
 	acpi_pci_link_init();
 	acpi_platform_init();
 	acpi_lpss_init();
+	acpi_cmos_rtc_init();
 	acpi_container_init();
 	acpi_memory_hotplug_init();
 

commit 94add0f82469fa3c4ff978d03a34da90813c819d
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Sun Jun 23 00:59:55 2013 +0200

    ACPI / dock: Initialize ACPI dock subsystem upfront
    
    Commit 3b63aaa70e1 (PCI: acpiphp: Do not use ACPI PCI subdriver
    mechanism) introduced an ACPI dock support regression, because it
    changed the relative initialization order of the ACPI dock subsystem
    and the ACPI-based PCI hotplug (acpiphp).
    
    Namely, the ACPI dock subsystem has to be initialized before
    acpiphp_enumerate_slots() is first run, which after commit
    3b63aaa70e1 happens during the initial enumeration of the PCI
    hierarchy triggered by the initial ACPI namespace scan in
    acpi_scan_init().  For this reason, the dock subsystem has to be
    initialized before the initial ACPI namespace scan in
    acpi_scan_init().
    
    To make that happen, modify the ACPI dock subsystem to be
    non-modular and add the invocation of its initialization routine,
    acpi_dock_init(), to acpi_scan_init() directly before the initial
    namespace scan.
    
    [rjw: Changelog, removal of dock_exit().]
    References: https://bugzilla.kernel.org/show_bug.cgi?id=59501
    Reported-and-tested-by: Alexander E. Patrakov <patrakov@gmail.com>
    Tested-by: Illya Klymov <xanf@xanf.me>
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Cc: 3.9+ <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b14ac46948c9..27da63061e11 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2042,6 +2042,7 @@ int __init acpi_scan_init(void)
 	acpi_lpss_init();
 	acpi_container_init();
 	acpi_memory_hotplug_init();
+	acpi_dock_init();
 
 	mutex_lock(&acpi_scan_lock);
 	/*

commit 24071f472d813fccacc1ef7356b1f41422a1b968
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jun 16 00:36:41 2013 +0200

    ACPI / scan: Do not bind ACPI drivers to objects with scan handlers
    
    ACPI drivers must not be bound to device objects having scan handlers
    attatched to them, so make acpi_device_probe() fail with -EINVAL if the
    device object being probed has an ACPI scan handler.
    
    After this change the analogous check introduced into the ACPI video
    driver by commit 8c9b7a7 (ACPI / video: Do not bind to device objects
    with a scan handler) is not necessary any more and may be dropped, so
    drop it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Tony Luck <tony.luck@gmail.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 4eeea2262454..54529424a0a5 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -822,6 +822,9 @@ static int acpi_device_probe(struct device *dev)
 	struct acpi_driver *acpi_drv = to_acpi_driver(dev->driver);
 	int ret;
 
+	if (acpi_dev->handler)
+		return -EINVAL;
+
 	if (!acpi_drv->ops.add)
 		return -ENOSYS;
 

commit d9e455f53f6fb93c764de2399c3894bbdfd2caa7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 10 13:00:50 2013 +0200

    ACPI / scan: Simplify ACPI driver probing
    
    There is no particular reason why acpi_bus_driver_init() needs to be
    a separate function and its location with respect to its only caller,
    acpi_device_probe(), makes the code a bit difficult to follow.
    
    Besides, it doesn't really make sense to check if 'device' is not
    NULL in acpi_bus_driver_init(), because we've already dereferenced
    dev->driver in acpi_device_probe() at that point and, moreover,
    'device' cannot be NULL then, because acpi_device_probe() is called
    via really_probe() (which also sets dev->driver for that matter).
    
    For these reasons, drop acpi_bus_driver_init() altogether and move
    the remaining code from it directly into acpi_device_probe().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b14ac46948c9..4eeea2262454 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -816,32 +816,40 @@ static void acpi_device_remove_notify_handler(struct acpi_device *device)
 					   acpi_device_notify);
 }
 
-static int acpi_bus_driver_init(struct acpi_device *, struct acpi_driver *);
-static int acpi_device_probe(struct device * dev)
+static int acpi_device_probe(struct device *dev)
 {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 	struct acpi_driver *acpi_drv = to_acpi_driver(dev->driver);
 	int ret;
 
-	ret = acpi_bus_driver_init(acpi_dev, acpi_drv);
-	if (!ret) {
-		if (acpi_drv->ops.notify) {
-			ret = acpi_device_install_notify_handler(acpi_dev);
-			if (ret) {
-				if (acpi_drv->ops.remove)
-					acpi_drv->ops.remove(acpi_dev);
-				acpi_dev->driver = NULL;
-				acpi_dev->driver_data = NULL;
-				return ret;
-			}
-		}
+	if (!acpi_drv->ops.add)
+		return -ENOSYS;
 
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			"Found driver [%s] for device [%s]\n",
-			acpi_drv->name, acpi_dev->pnp.bus_id));
-		get_device(dev);
+	ret = acpi_drv->ops.add(acpi_dev);
+	if (ret)
+		return ret;
+
+	acpi_dev->driver = acpi_drv;
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "Driver [%s] successfully bound to device [%s]\n",
+			  acpi_drv->name, acpi_dev->pnp.bus_id));
+
+	if (acpi_drv->ops.notify) {
+		ret = acpi_device_install_notify_handler(acpi_dev);
+		if (ret) {
+			if (acpi_drv->ops.remove)
+				acpi_drv->ops.remove(acpi_dev);
+
+			acpi_dev->driver = NULL;
+			acpi_dev->driver_data = NULL;
+			return ret;
+		}
 	}
-	return ret;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found driver [%s] for device [%s]\n",
+			  acpi_drv->name, acpi_dev->pnp.bus_id));
+	get_device(dev);
+	return 0;
 }
 
 static int acpi_device_remove(struct device * dev)
@@ -997,41 +1005,6 @@ static void acpi_device_unregister(struct acpi_device *device)
 /* --------------------------------------------------------------------------
                                  Driver Management
    -------------------------------------------------------------------------- */
-/**
- * acpi_bus_driver_init - add a device to a driver
- * @device: the device to add and initialize
- * @driver: driver for the device
- *
- * Used to initialize a device via its device driver.  Called whenever a
- * driver is bound to a device.  Invokes the driver's add() ops.
- */
-static int
-acpi_bus_driver_init(struct acpi_device *device, struct acpi_driver *driver)
-{
-	int result = 0;
-
-	if (!device || !driver)
-		return -EINVAL;
-
-	if (!driver->ops.add)
-		return -ENOSYS;
-
-	result = driver->ops.add(device);
-	if (result)
-		return result;
-
-	device->driver = driver;
-
-	/*
-	 * TBD - Configuration Management: Assign resources to device based
-	 * upon possible configuration and currently allocated resources.
-	 */
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			  "Driver successfully bound to device\n"));
-	return 0;
-}
-
 /**
  * acpi_bus_register_driver - register a driver with the ACPI bus
  * @driver: driver being registered

commit 8c9b7a7b2fc2750af418ddc28e707c42e78aa0bf
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 10 13:00:29 2013 +0200

    ACPI / video: Do not bind to device objects with a scan handler
    
    With the introduction of ACPI scan handlers, ACPI device objects
    with an ACPI scan handler attached to them must not be bound to
    by ACPI drivers any more.  Unfortunately, however, the ACPI video
    driver attempts to do just that if there is a _ROM ACPI control
    method defined under a device object with an ACPI scan handler.
    
    Prevent that from happening by making the video driver's "add"
    routine check if the device object already has an ACPI scan handler
    attached to it and return an error code in that case.
    
    That is not sufficient, though, because acpi_bus_driver_init() would
    then clear the device object's driver_data that may be set by its
    scan handler, so for the fix to work acpi_bus_driver_init() has to be
    modified to leave driver_data as is on errors.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=58091
    Bisected-and-tested-by: Dmitry S. Demin <dmitryy.demin@gmail.com>
    Reported-and-tested-by: Jason Cassell <bluesloth600@gmail.com>
    Tracked-down-by: Aaron Lu <aaron.lu@intel.com>
    Cc: 3.9+ <stable@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 44225cb15f3a..b14ac46948c9 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1017,11 +1017,8 @@ acpi_bus_driver_init(struct acpi_device *device, struct acpi_driver *driver)
 		return -ENOSYS;
 
 	result = driver->ops.add(device);
-	if (result) {
-		device->driver = NULL;
-		device->driver_data = NULL;
+	if (result)
 		return result;
-	}
 
 	device->driver = driver;
 

commit ea7f665612fcc73da6b7698f468cd5fc03a30d47
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 8 02:55:07 2013 +0200

    Revert "ACPI / scan: do not match drivers against objects having scan handlers"
    
    Commit 9f29ab11ddbf ("ACPI / scan: do not match drivers against objects
    having scan handlers") introduced a boot regression on Tony's ia64 HP
    rx2600.  Tony says:
    
      "It panics with the message:
    
       Kernel panic - not syncing: Unable to find SBA IOMMU: Try a generic or DIG kernel
    
       [...] my problem comes from arch/ia64/hp/common/sba_iommu.c
       where the code in sba_init() says:
    
            acpi_bus_register_driver(&acpi_sba_ioc_driver);
            if (!ioc_list) {
    
       but because of this change we never managed to call ioc_init()
       so ioc_list doesn't get set up, and we die."
    
    Revert it to avoid this breakage and we'll fix the problem it attempted
    to address later.
    
    Reported-by: Tony Luck <tony.luck@gmail.com>
    Cc: 3.9+ <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 90c5759e1355..44225cb15f3a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -740,10 +740,6 @@ static int acpi_bus_match(struct device *dev, struct device_driver *drv)
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 	struct acpi_driver *acpi_drv = to_acpi_driver(drv);
 
-	/* Skip ACPI device objects with scan handlers attached. */
-	if (acpi_dev->handler)
-		return 0;
-
 	return acpi_dev->flags.match_driver
 		&& !acpi_match_device_ids(acpi_dev, acpi_drv->ids);
 }

commit 9f29ab11ddbfc12db54df5a66dab22b39ad94e8e
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Tue Jun 4 23:02:58 2013 +0200

    ACPI / scan: do not match drivers against objects having scan handlers
    
    With the introduction of ACPI scan handlers, an ACPI device object
    with an ACPI scan handler attached to it must not be bound to an ACPI
    driver any more.  Therefore it doesn't make sense to match those
    ACPI device objects against a newly registered ACPI driver in
    acpi_bus_match(), so make that function return 0 if the device
    object passed to it has an ACPI scan handler attached.
    
    This also addresses a regression related to a broken ACPI table in
    the BIOS, where it has defined a _ROM method under the PCI root
    bridge object.  This causes the video module to treat that object
    as a display controller device (since only display devices are
    supposed to have a _ROM method defined according to the ACPI spec).
    As a result, the ACPI video driver binds to the PCI root bridge
    object and overwrites the previously assigned driver_data field of
    it, causing subsequent calls to acpi_get_pci_dev() to fail.
    
    [rjw: Subject and changelog]
    References: https://bugzilla.kernel.org/show_bug.cgi?id=58091
    Reported-by: Jason Cassell <bluesloth600@gmail.com>
    Reported-and-bisected-by: Dmitry S. Demin <dmitryy.demin@gmail.com>
    Cc: 3.9+ <stable@kernel.org>
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 44225cb15f3a..90c5759e1355 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -740,6 +740,10 @@ static int acpi_bus_match(struct device *dev, struct device_driver *drv)
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 	struct acpi_driver *acpi_drv = to_acpi_driver(drv);
 
+	/* Skip ACPI device objects with scan handlers attached. */
+	if (acpi_dev->handler)
+		return 0;
+
 	return acpi_dev->flags.match_driver
 		&& !acpi_match_device_ids(acpi_dev, acpi_drv->ids);
 }

commit 303bfdb1a14d0460feb859cd008ff81da36b517c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 23 10:43:13 2013 +0200

    ACPI / scan: Add second pass of companion offlining to hot-remove code
    
    As indicated by comments in mm/memory_hotplug.c:remove_memory(),
    if CONFIG_MEMCG is set, it may not be possible to offline all of the
    memory blocks held by one module (FRU) in one pass (because one of
    them may be used by the others to store page cgroup in that case
    and that block has to be offlined before the other ones).
    
    To handle that arguably corner case, add a second pass of companion
    device offlining to acpi_scan_hot_remove() and make it ignore errors
    returned in the first pass (and make it skip the second pass if the
    first one is successful).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ba8ee6cbf0f1..2959fe1ce43e 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -131,6 +131,7 @@ static acpi_status acpi_bus_offline_companions(acpi_handle handle, u32 lvl,
 {
 	struct acpi_device *device = NULL;
 	struct acpi_device_physical_node *pn;
+	bool second_pass = (bool)data;
 	acpi_status status = AE_OK;
 
 	if (acpi_bus_get_device(handle, &device))
@@ -141,15 +142,26 @@ static acpi_status acpi_bus_offline_companions(acpi_handle handle, u32 lvl,
 	list_for_each_entry(pn, &device->physical_node_list, node) {
 		int ret;
 
+		if (second_pass) {
+			/* Skip devices offlined by the first pass. */
+			if (pn->put_online)
+				continue;
+		} else {
+			pn->put_online = false;
+		}
 		ret = device_offline(pn->dev);
 		if (acpi_force_hot_remove)
 			continue;
 
-		if (ret < 0) {
-			status = AE_ERROR;
-			break;
+		if (ret >= 0) {
+			pn->put_online = !ret;
+		} else {
+			*ret_p = pn->dev;
+			if (second_pass) {
+				status = AE_ERROR;
+				break;
+			}
 		}
-		pn->put_online = !ret;
 	}
 
 	mutex_unlock(&device->physical_node_lock);
@@ -185,6 +197,7 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	acpi_handle not_used;
 	struct acpi_object_list arg_list;
 	union acpi_object arg;
+	struct device *errdev;
 	acpi_status status;
 	unsigned long long sta;
 
@@ -197,22 +210,42 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 
 	lock_device_hotplug();
 
-	status = acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
-				     NULL, acpi_bus_offline_companions, NULL,
-				     NULL);
-	if (ACPI_SUCCESS(status) || acpi_force_hot_remove)
-		status = acpi_bus_offline_companions(handle, 0, NULL, NULL);
-
-	if (ACPI_FAILURE(status) && !acpi_force_hot_remove) {
-		acpi_bus_online_companions(handle, 0, NULL, NULL);
+	/*
+	 * Carry out two passes here and ignore errors in the first pass,
+	 * because if the devices in question are memory blocks and
+	 * CONFIG_MEMCG is set, one of the blocks may hold data structures
+	 * that the other blocks depend on, but it is not known in advance which
+	 * block holds them.
+	 *
+	 * If the first pass is successful, the second one isn't needed, though.
+	 */
+	errdev = NULL;
+	acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
+			    NULL, acpi_bus_offline_companions,
+			    (void *)false, (void **)&errdev);
+	acpi_bus_offline_companions(handle, 0, (void *)false, (void **)&errdev);
+	if (errdev) {
+		errdev = NULL;
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
-				    acpi_bus_online_companions, NULL, NULL,
-				    NULL);
-
-		unlock_device_hotplug();
-
-		put_device(&device->dev);
-		return -EBUSY;
+				    NULL, acpi_bus_offline_companions,
+				    (void *)true , (void **)&errdev);
+		if (!errdev || acpi_force_hot_remove)
+			acpi_bus_offline_companions(handle, 0, (void *)true,
+						    (void **)&errdev);
+
+		if (errdev && !acpi_force_hot_remove) {
+			dev_warn(errdev, "Offline failed.\n");
+			acpi_bus_online_companions(handle, 0, NULL, NULL);
+			acpi_walk_namespace(ACPI_TYPE_ANY, handle,
+					    ACPI_UINT32_MAX,
+					    acpi_bus_online_companions, NULL,
+					    NULL, NULL);
+
+			unlock_device_hotplug();
+
+			put_device(&device->dev);
+			return -EBUSY;
+		}
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,

commit 2e199192df85eb936a7829dc28b57b85c59c86fc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 23 10:40:35 2013 +0200

    ACPI: Drop removal_type field from struct acpi_device
    
    The ACPI processor driver was the only user of the removal_type
    field in struct acpi_device, but it doesn't use that field any more
    after recent changes.  Thus, removal_type has no more users, so drop
    it along with the associated data type.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ad82bb2a37e0..ba8ee6cbf0f1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1036,7 +1036,6 @@ int acpi_device_add(struct acpi_device *device,
 		printk(KERN_ERR PREFIX "Error creating sysfs interface for device %s\n",
 		       dev_name(&device->dev));
 
-	device->removal_type = ACPI_BUS_REMOVAL_NORMAL;
 	return 0;
 
  err:
@@ -2025,7 +2024,6 @@ static acpi_status acpi_bus_device_detach(acpi_handle handle, u32 lvl_not_used,
 	if (!acpi_bus_get_device(handle, &device)) {
 		struct acpi_scan_handler *dev_handler = device->handler;
 
-		device->removal_type = ACPI_BUS_REMOVAL_EJECT;
 		if (dev_handler) {
 			if (dev_handler->detach)
 				dev_handler->detach(device);

commit 27a24cfa04c6f041c0191847d047f25e5627cd63
Merge: 6b3f7b5c2221 b59cc200ac02
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat May 25 20:30:31 2013 -0700

    Merge branch 'fixes' of git://git.infradead.org/users/vkoul/slave-dma
    
    Pull slave-dma fixes from Vinod Koul:
     "We have two patches from Andy & Rafael fixing the Lynxpoint dma"
    
    * 'fixes' of git://git.infradead.org/users/vkoul/slave-dma:
      ACPI / LPSS: register clock device for Lynxpoint DMA properly
      dma: acpi-dma: parse CSRT to extract additional resources

commit 7a26b53070f0099dfcfc9d499458de861c5c4859
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Wed May 15 16:49:35 2013 +0000

    ACPI / scan: Fix memory leak on acpi_scan_init_hotplug() error path
    
    Following commit 6b772e8f9 (ACPI: Update PNPID match handling for
    notify), the acpi_scan_init_hotplug() calls acpi_set_pnp_ids() which
    allocates acpi_hardware_id and copies a few strings (kstrdup). If the
    devices does not have hardware_id set, the function exits without
    freeing the previously allocated ids (and kmemleak complains). This
    patch calls simply changes 'return' on error to a 'goto out' which
    calls acpi_free_pnp_ids().
    
    Reported-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Toshi Kani <toshi.kani@hp.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index fe158fd4f1df..c1bc608339a6 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1785,7 +1785,7 @@ static void acpi_scan_init_hotplug(acpi_handle handle, int type)
 	acpi_set_pnp_ids(handle, &pnp, type);
 
 	if (!pnp.type.hardware_id)
-		return;
+		goto out;
 
 	/*
 	 * This relies on the fact that acpi_install_notify_handler() will not
@@ -1800,6 +1800,7 @@ static void acpi_scan_init_hotplug(acpi_handle handle, int type)
 		}
 	}
 
+out:
 	acpi_free_pnp_ids(&pnp);
 }
 

commit ee8209fd026b074bb8eb75bece516a338a281b1b
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed May 8 11:55:48 2013 +0300

    dma: acpi-dma: parse CSRT to extract additional resources
    
    Since we have CSRT only to get additional DMA controller resources, let's get
    rid of drivers/acpi/csrt.c and move its logic inside ACPI DMA helpers code.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index fe158fd4f1df..aacc08f951aa 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2042,7 +2042,6 @@ int __init acpi_scan_init(void)
 	acpi_pci_link_init();
 	acpi_platform_init();
 	acpi_lpss_init();
-	acpi_csrt_init();
 	acpi_container_init();
 	acpi_memory_hotplug_init();
 

commit ac212b6980d8d5eda705864fc5a8ecddc6d6eacc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 3 00:26:22 2013 +0200

    ACPI / processor: Use common hotplug infrastructure
    
    Split the ACPI processor driver into two parts, one that is
    non-modular, resides in the ACPI core and handles the enumeration
    and hotplug of processors and one that implements the rest of the
    existing processor driver functionality.
    
    The non-modular part uses an ACPI scan handler object to enumerate
    processors on the basis of information provided by the ACPI namespace
    and to hook up with the common ACPI hotplug infrastructure.  It also
    populates the ACPI handle of each processor device having a
    corresponding object in the ACPI namespace, which allows the driver
    proper to bind to those devices, and makes the driver bind to them
    if it is readily available (i.e. loaded) when the scan handler's
    .attach() routine is running.
    
    There are a few reasons to make this change.
    
    First, switching the ACPI processor driver to using the common ACPI
    hotplug infrastructure reduces code duplication and size considerably,
    even though a new file is created along with a header comment etc.
    
    Second, since the common hotplug code attempts to offline devices
    before starting the (non-reversible) removal procedure, it will abort
    (and possibly roll back) hot-remove operations involving processors
    if cpu_down() returns an error code for one of them instead of
    continuing them blindly (if /sys/firmware/acpi/hotplug/force_remove
    is unset).  That is a more desirable behavior than what the current
    code does.
    
    Finally, the separation of the scan/hotplug part from the driver
    proper makes it possible to simplify the driver's .remove() routine,
    because it doesn't need to worry about the possible cleanup related
    to processor removal any more (the scan/hotplug part is responsible
    for that now) and can handle device removal and driver removal
    symmetricaly (i.e. as appropriate).
    
    Some user-visible changes in sysfs are made (for example, the
    'sysdev' link from the ACPI device node to the processor device's
    directory is gone and a 'physical_node' link is present instead
    and a corresponding 'firmware_node' is present in the processor
    device's directory, the processor driver is now visible under
    /sys/bus/cpu/drivers/ and bound to the processor device), but
    that shouldn't affect the functionality that users care about
    (frequency scaling, C-states and thermal management).
    
    Tested on my venerable Toshiba Portege R500.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 4fd392005ef1..ad82bb2a37e0 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2124,6 +2124,7 @@ int __init acpi_scan_init(void)
 
 	acpi_pci_root_init();
 	acpi_pci_link_init();
+	acpi_processor_init();
 	acpi_platform_init();
 	acpi_lpss_init();
 	acpi_csrt_init();

commit 683058e315f00a216fd6c79df4f63bc9945ca434
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 3 00:26:16 2013 +0200

    ACPI / hotplug: Use device offline/online for graceful hot-removal
    
    Modify the generic ACPI hotplug code to be able to check if devices
    scheduled for hot-removal may be gracefully removed from the system
    using the device offline/online mechanism introduced previously.
    
    Namely, make acpi_scan_hot_remove() handling device hot-removal call
    device_offline() for all physical companions of the ACPI device nodes
    involved in the operation and check the results.  If any of the
    device_offline() calls fails, the function will not progress to the
    removal phase (which cannot be aborted), unless its (new) force
    argument is set (in case of a failing offline it will put the devices
    offlined by it back online).
    
    In support of 'forced' device hot-removal, add a new sysfs attribute
    'force_remove' that will reside under /sys/firmware/acpi/hotplug/.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index fe158fd4f1df..4fd392005ef1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -27,6 +27,12 @@ extern struct acpi_device *acpi_root;
 
 #define ACPI_IS_ROOT_DEVICE(device)    (!(device)->parent)
 
+/*
+ * If set, devices will be hot-removed even if they cannot be put offline
+ * gracefully (from the kernel's standpoint).
+ */
+bool acpi_force_hot_remove;
+
 static const char *dummy_hid = "device";
 
 static LIST_HEAD(acpi_device_list);
@@ -120,6 +126,59 @@ acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, cha
 }
 static DEVICE_ATTR(modalias, 0444, acpi_device_modalias_show, NULL);
 
+static acpi_status acpi_bus_offline_companions(acpi_handle handle, u32 lvl,
+					       void *data, void **ret_p)
+{
+	struct acpi_device *device = NULL;
+	struct acpi_device_physical_node *pn;
+	acpi_status status = AE_OK;
+
+	if (acpi_bus_get_device(handle, &device))
+		return AE_OK;
+
+	mutex_lock(&device->physical_node_lock);
+
+	list_for_each_entry(pn, &device->physical_node_list, node) {
+		int ret;
+
+		ret = device_offline(pn->dev);
+		if (acpi_force_hot_remove)
+			continue;
+
+		if (ret < 0) {
+			status = AE_ERROR;
+			break;
+		}
+		pn->put_online = !ret;
+	}
+
+	mutex_unlock(&device->physical_node_lock);
+
+	return status;
+}
+
+static acpi_status acpi_bus_online_companions(acpi_handle handle, u32 lvl,
+					      void *data, void **ret_p)
+{
+	struct acpi_device *device = NULL;
+	struct acpi_device_physical_node *pn;
+
+	if (acpi_bus_get_device(handle, &device))
+		return AE_OK;
+
+	mutex_lock(&device->physical_node_lock);
+
+	list_for_each_entry(pn, &device->physical_node_list, node)
+		if (pn->put_online) {
+			device_online(pn->dev);
+			pn->put_online = false;
+		}
+
+	mutex_unlock(&device->physical_node_lock);
+
+	return AE_OK;
+}
+
 static int acpi_scan_hot_remove(struct acpi_device *device)
 {
 	acpi_handle handle = device->handle;
@@ -136,10 +195,33 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 		return -EINVAL;
 	}
 
+	lock_device_hotplug();
+
+	status = acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
+				     NULL, acpi_bus_offline_companions, NULL,
+				     NULL);
+	if (ACPI_SUCCESS(status) || acpi_force_hot_remove)
+		status = acpi_bus_offline_companions(handle, 0, NULL, NULL);
+
+	if (ACPI_FAILURE(status) && !acpi_force_hot_remove) {
+		acpi_bus_online_companions(handle, 0, NULL, NULL);
+		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
+				    acpi_bus_online_companions, NULL, NULL,
+				    NULL);
+
+		unlock_device_hotplug();
+
+		put_device(&device->dev);
+		return -EBUSY;
+	}
+
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 		"Hot-removing device %s...\n", dev_name(&device->dev)));
 
 	acpi_bus_trim(device);
+
+	unlock_device_hotplug();
+
 	/* Device node has been unregistered. */
 	put_device(&device->dev);
 	device = NULL;
@@ -236,6 +318,7 @@ static void acpi_scan_bus_device_check(acpi_handle handle, u32 ost_source)
 	int error;
 
 	mutex_lock(&acpi_scan_lock);
+	lock_device_hotplug();
 
 	acpi_bus_get_device(handle, &device);
 	if (device) {
@@ -259,6 +342,7 @@ static void acpi_scan_bus_device_check(acpi_handle handle, u32 ost_source)
 		kobject_uevent(&device->dev.kobj, KOBJ_ONLINE);
 
  out:
+	unlock_device_hotplug();
 	acpi_evaluate_hotplug_ost(handle, ost_source, ost_code, NULL);
 	mutex_unlock(&acpi_scan_lock);
 }

commit 3ed1c478eff8db80e234d5446cb378b503135888
Merge: 151173e8ce9b 371deb950083
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 30 15:21:02 2013 -0700

    Merge tag 'pm+acpi-3.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael J Wysocki:
    
     - ARM big.LITTLE cpufreq driver from Viresh Kumar.
    
     - exynos5440 cpufreq driver from Amit Daniel Kachhap.
    
     - cpufreq core cleanup and code consolidation from Viresh Kumar and
       Stratos Karafotis.
    
     - cpufreq scalability improvement from Nathan Zimmer.
    
     - AMD "frequency sensitivity feedback" powersave bias for the ondemand
       cpufreq governor from Jacob Shin.
    
     - cpuidle code consolidation and cleanups from Daniel Lezcano.
    
     - ARM OMAP cpuidle fixes from Santosh Shilimkar and Daniel Lezcano.
    
     - ACPICA fixes and other improvements from Bob Moore, Jung-uk Kim, Lv
       Zheng, Yinghai Lu, Tang Chen, Colin Ian King, and Linn Crosetto.
    
     - ACPI core updates related to hotplug from Toshi Kani, Paul Bolle,
       Yasuaki Ishimatsu, and Rafael J Wysocki.
    
     - Intel Lynxpoint LPSS (Low-Power Subsystem) support improvements from
       Rafael J Wysocki and Andy Shevchenko.
    
    * tag 'pm+acpi-3.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (192 commits)
      cpufreq: Revert incorrect commit 5800043
      cpufreq: MAINTAINERS: Add co-maintainer
      cpuidle: add maintainer entry
      ACPI / thermal: do not always return THERMAL_TREND_RAISING for active trip points
      ARM: s3c64xx: cpuidle: use init/exit common routine
      cpufreq: pxa2xx: initialize variables
      ACPI: video: correct acpi_video_bus_add error processing
      SH: cpuidle: use init/exit common routine
      ARM: S5pv210: compiling issue, ARM_S5PV210_CPUFREQ needs CONFIG_CPU_FREQ_TABLE=y
      ACPI: Fix wrong parameter passed to memblock_reserve
      cpuidle: fix comment format
      pnp: use %*phC to dump small buffers
      isapnp: remove debug leftovers
      ARM: imx: cpuidle: use init/exit common routine
      ARM: davinci: cpuidle: use init/exit common routine
      ARM: kirkwood: cpuidle: use init/exit common routine
      ARM: calxeda: cpuidle: use init/exit common routine
      ARM: tegra: cpuidle: use init/exit common routine for tegra3
      ARM: tegra: cpuidle: use init/exit common routine for tegra2
      ARM: OMAP4: cpuidle: use init/exit common routine
      ...

commit 2467d7b7037438f2d1fed826fc5217dddf4b37fb
Merge: 929c6dd4195f cf8df962aa83
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Apr 28 01:53:41 2013 +0200

    Merge branch 'acpi-lpss'
    
    * acpi-lpss:
      ACPI / LPSS: make code less confusing for reader
      ACPI / LPSS: Add support for exposing LTR registers to user space
      ACPI / scan: Add special handler for Intel Lynxpoint LPSS devices

commit 5c0b04e3d913c91aee6e48e567e20a3f67849618
Author: Jiang Liu <liuj97@gmail.com>
Date:   Fri Apr 12 05:44:24 2013 +0000

    PCI/ACPI: Handle PCI slot devices when creating/destroying PCI buses
    
    Currently the pci_slot driver doesn't update PCI slot devices when PCI
    device hotplug event happens, which may cause memory leak and returning
    stale information to user.
    
    Now the pci_slot driver has been changed as built-in driver, so invoke
    PCI slot enumeration and destroy routines directly from the PCI core.
    And remove ACPI PCI sub-driver related code because it isn't needed
    any more.
    
    [bhelgas: removed "extern" from function declarations]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5e7e991717d7..f54d1985e594 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1790,7 +1790,6 @@ int __init acpi_scan_init(void)
 	acpi_platform_init();
 	acpi_csrt_init();
 	acpi_container_init();
-	acpi_pci_slot_init();
 
 	mutex_lock(&acpi_scan_lock);
 	/*

commit 882fd12e641b612bcf31620f9b1b7bb03f8e9ab5
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Wed Mar 13 19:29:26 2013 +0000

    ACPI: Verify device status after eject
    
    ACPI spec states that the OS evaluates _STA after calling _EJ0
    in order to verify if eject was successful.  Added a check to
    verify if the enabled bit of the status value is cleared after
    _EJ0.
    
    Note, the present bit is not checked since some FW implementations
    do not clear the present bit until the hardware is physically
    removed.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index dfdbcfdd9def..8cacc16af6e7 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -127,6 +127,7 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	struct acpi_object_list arg_list;
 	union acpi_object arg;
 	acpi_status status;
+	unsigned long long sta;
 
 	/* If there is no handle, the device node has been unregistered. */
 	if (!handle) {
@@ -164,10 +165,25 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 		if (status == AE_NOT_FOUND) {
 			return -ENODEV;
 		} else {
-			acpi_handle_warn(handle, "Eject failed\n");
+			acpi_handle_warn(handle, "Eject failed (0x%x)\n",
+								status);
 			return -EIO;
 		}
 	}
+
+	/*
+	 * Verify if eject was indeed successful.  If not, log an error
+	 * message.  No need to call _OST since _EJ0 call was made OK.
+	 */
+	status = acpi_evaluate_integer(handle, "_STA", NULL, &sta);
+	if (ACPI_FAILURE(status)) {
+		acpi_handle_warn(handle,
+			"Status check after eject failed (0x%x)\n", status);
+	} else if (sta & ACPI_STA_DEVICE_ENABLED) {
+		acpi_handle_warn(handle,
+			"Eject incomplete - status 0x%llx\n", sta);
+	}
+
 	return 0;
 }
 

commit 2cbb14fb7065b0cc08ef03ee69dce93d65197c29
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Tue Mar 5 22:33:31 2013 +0000

    ACPI: Update _OST handling for notify
    
    When the kernel calls _OSC with OSC_SB_HOTPLUG_OST_SUPPORT bit
    set at boot-time, the OS is responsible for calling _OST for
    ACPI hotplug events.  However, when hotplug.enabled attribute
    is unset for ACPI scan drivers, their notify handlers are removed
    and _OST is not called for ACPI hotplug events as a result.
    
    This patch keeps the notify handler of ACPI scan drivers,
    acpi_hotplug_notify_cb(), installed regardless of the state of
    hotplug.enabled.  The notify handler then checks if hotplug.enabled
    is set for the associated scan handler.  If unset, the notify
    handler calls _OST with a proper error code.  The patch also
    eliminates ACPI namespace walk when hotplug.enabled is changed
    via sysfs.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 3f6ec0dd4fb6..dfdbcfdd9def 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -259,11 +259,43 @@ static void acpi_scan_device_check(void *context)
 				   ACPI_NOTIFY_DEVICE_CHECK);
 }
 
-static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *not_used)
+static void acpi_hotplug_unsupported(acpi_handle handle, u32 type)
+{
+	u32 ost_status;
+
+	switch (type) {
+	case ACPI_NOTIFY_BUS_CHECK:
+		acpi_handle_debug(handle,
+			"ACPI_NOTIFY_BUS_CHECK event: unsupported\n");
+		ost_status = ACPI_OST_SC_INSERT_NOT_SUPPORTED;
+		break;
+	case ACPI_NOTIFY_DEVICE_CHECK:
+		acpi_handle_debug(handle,
+			"ACPI_NOTIFY_DEVICE_CHECK event: unsupported\n");
+		ost_status = ACPI_OST_SC_INSERT_NOT_SUPPORTED;
+		break;
+	case ACPI_NOTIFY_EJECT_REQUEST:
+		acpi_handle_debug(handle,
+			"ACPI_NOTIFY_EJECT_REQUEST event: unsupported\n");
+		ost_status = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
+		break;
+	default:
+		/* non-hotplug event; possibly handled by other handler */
+		return;
+	}
+
+	acpi_evaluate_hotplug_ost(handle, type, ost_status, NULL);
+}
+
+static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 {
 	acpi_osd_exec_callback callback;
+	struct acpi_scan_handler *handler = data;
 	acpi_status status;
 
+	if (!handler->hotplug.enabled)
+		return acpi_hotplug_unsupported(handle, type);
+
 	switch (type) {
 	case ACPI_NOTIFY_BUS_CHECK:
 		acpi_handle_debug(handle, "ACPI_NOTIFY_BUS_CHECK event\n");
@@ -1715,61 +1747,14 @@ static struct acpi_scan_handler *acpi_scan_match_handler(char *idstr,
 	return NULL;
 }
 
-static acpi_status acpi_scan_hotplug_modify(acpi_handle handle,
-					    u32 lvl_not_used, void *data,
-					    void **ret_not_used)
-{
-	struct acpi_device_pnp pnp = {};
-	struct acpi_scan_handler *tgt_handler = data, *handler;
-	struct acpi_hardware_id *hwid;
-	unsigned long long sta_not_used;
-	int type;
-	bool match = false;
-
-	if (acpi_bus_type_and_status(handle, &type, &sta_not_used))
-		return AE_OK;
-
-	INIT_LIST_HEAD(&pnp.ids);
-	acpi_set_pnp_ids(handle, &pnp, type);
-
-	if (!pnp.type.hardware_id)
-		return AE_OK;
-
-	list_for_each_entry(hwid, &pnp.ids, list) {
-		handler = acpi_scan_match_handler(hwid->id, NULL);
-		if (handler && handler == tgt_handler) {
-			match = true;
-			break;
-		}
-	}
-	if (!match)
-		goto out;
-
-	if (handler->hotplug.enabled)
-		acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
-					    acpi_hotplug_notify_cb, NULL);
-	else
-		acpi_remove_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
-					   acpi_hotplug_notify_cb);
-
-out:
-	acpi_free_pnp_ids(&pnp);
-	return AE_OK;
-}
-
 void acpi_scan_hotplug_enabled(struct acpi_hotplug_profile *hotplug, bool val)
 {
-	struct acpi_scan_handler *handler;
-
 	if (!!hotplug->enabled == !!val)
 		return;
 
 	mutex_lock(&acpi_scan_lock);
 
 	hotplug->enabled = val;
-	handler = container_of(hotplug, struct acpi_scan_handler, hotplug);
-	acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
-			    acpi_scan_hotplug_modify, NULL, handler, NULL);
 
 	mutex_unlock(&acpi_scan_lock);
 }
@@ -1793,10 +1778,8 @@ static void acpi_scan_init_hotplug(acpi_handle handle, int type)
 	list_for_each_entry(hwid, &pnp.ids, list) {
 		handler = acpi_scan_match_handler(hwid->id, NULL);
 		if (handler) {
-			if (handler->hotplug.enabled)
-				acpi_install_notify_handler(handle,
-					ACPI_SYSTEM_NOTIFY,
-					acpi_hotplug_notify_cb, NULL);
+			acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
+					acpi_hotplug_notify_cb, handler);
 			break;
 		}
 	}

commit 6b772e8f9e9deb3528402ac14fd0aa186d84ae75
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Mon Mar 4 21:30:43 2013 +0000

    ACPI: Update PNPID match handling for notify
    
    When installing/removing a notify handler to/from an ACPI device
    object, ACPI core tries to match its associated scan handler to
    see if it supports hotplug.  However, the matching logic of the
    notify handler is different from the matching logic of attaching
    a scan handler to an ACPI device object.  This patch updates the
    matching logic of the notify handlers to be consistent with the
    attach handling.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e9a71ed9954a..3f6ec0dd4fb6 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1703,24 +1703,47 @@ static bool acpi_scan_handler_matching(struct acpi_scan_handler *handler,
 	return false;
 }
 
+static struct acpi_scan_handler *acpi_scan_match_handler(char *idstr,
+					const struct acpi_device_id **matchid)
+{
+	struct acpi_scan_handler *handler;
+
+	list_for_each_entry(handler, &acpi_scan_handlers_list, list_node)
+		if (acpi_scan_handler_matching(handler, idstr, matchid))
+			return handler;
+
+	return NULL;
+}
+
 static acpi_status acpi_scan_hotplug_modify(acpi_handle handle,
 					    u32 lvl_not_used, void *data,
 					    void **ret_not_used)
 {
-	struct acpi_scan_handler *handler = data;
-	struct acpi_device_info *info;
+	struct acpi_device_pnp pnp = {};
+	struct acpi_scan_handler *tgt_handler = data, *handler;
+	struct acpi_hardware_id *hwid;
+	unsigned long long sta_not_used;
+	int type;
 	bool match = false;
 
-	if (ACPI_FAILURE(acpi_get_object_info(handle, &info)))
+	if (acpi_bus_type_and_status(handle, &type, &sta_not_used))
+		return AE_OK;
+
+	INIT_LIST_HEAD(&pnp.ids);
+	acpi_set_pnp_ids(handle, &pnp, type);
+
+	if (!pnp.type.hardware_id)
 		return AE_OK;
 
-	if (info->valid & ACPI_VALID_HID) {
-		char *idstr = info->hardware_id.string;
-		match = acpi_scan_handler_matching(handler, idstr, NULL);
+	list_for_each_entry(hwid, &pnp.ids, list) {
+		handler = acpi_scan_match_handler(hwid->id, NULL);
+		if (handler && handler == tgt_handler) {
+			match = true;
+			break;
+		}
 	}
-	kfree(info);
 	if (!match)
-		return AE_OK;
+		goto out;
 
 	if (handler->hotplug.enabled)
 		acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
@@ -1729,6 +1752,8 @@ static acpi_status acpi_scan_hotplug_modify(acpi_handle handle,
 		acpi_remove_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
 					   acpi_hotplug_notify_cb);
 
+out:
+	acpi_free_pnp_ids(&pnp);
 	return AE_OK;
 }
 
@@ -1749,40 +1774,34 @@ void acpi_scan_hotplug_enabled(struct acpi_hotplug_profile *hotplug, bool val)
 	mutex_unlock(&acpi_scan_lock);
 }
 
-static struct acpi_scan_handler *acpi_scan_match_handler(char *idstr,
-					const struct acpi_device_id **matchid)
-{
-	struct acpi_scan_handler *handler;
-
-	list_for_each_entry(handler, &acpi_scan_handlers_list, list_node)
-		if (acpi_scan_handler_matching(handler, idstr, matchid))
-			return handler;
-
-	return NULL;
-}
-
-static void acpi_scan_init_hotplug(acpi_handle handle)
+static void acpi_scan_init_hotplug(acpi_handle handle, int type)
 {
-	struct acpi_device_info *info;
+	struct acpi_device_pnp pnp = {};
+	struct acpi_hardware_id *hwid;
 	struct acpi_scan_handler *handler;
 
-	if (ACPI_FAILURE(acpi_get_object_info(handle, &info)))
-		return;
+	INIT_LIST_HEAD(&pnp.ids);
+	acpi_set_pnp_ids(handle, &pnp, type);
 
-	if (!(info->valid & ACPI_VALID_HID)) {
-		kfree(info);
+	if (!pnp.type.hardware_id)
 		return;
-	}
 
 	/*
 	 * This relies on the fact that acpi_install_notify_handler() will not
 	 * install the same notify handler routine twice for the same handle.
 	 */
-	handler = acpi_scan_match_handler(info->hardware_id.string, NULL);
-	kfree(info);
-	if (handler && handler->hotplug.enabled)
-		acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
-					    acpi_hotplug_notify_cb, NULL);
+	list_for_each_entry(hwid, &pnp.ids, list) {
+		handler = acpi_scan_match_handler(hwid->id, NULL);
+		if (handler) {
+			if (handler->hotplug.enabled)
+				acpi_install_notify_handler(handle,
+					ACPI_SYSTEM_NOTIFY,
+					acpi_hotplug_notify_cb, NULL);
+			break;
+		}
+	}
+
+	acpi_free_pnp_ids(&pnp);
 }
 
 static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
@@ -1807,7 +1826,7 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 		return AE_OK;
 	}
 
-	acpi_scan_init_hotplug(handle);
+	acpi_scan_init_hotplug(handle, type);
 
 	if (!(sta & ACPI_STA_DEVICE_PRESENT) &&
 	    !(sta & ACPI_STA_DEVICE_FUNCTIONING)) {

commit c0af41757f406651cdd32de3e915753746c2948a
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Mon Mar 4 21:30:42 2013 +0000

    ACPI: Update PNPID set/free interfaces
    
    This patch introduces acpi_set_pnp_ids() and acpi_free_pnp_ids(),
    which are updated from acpi_device_set_id() and acpi_free_ids(),
    to setup and free acpi_device_pnp for a given acpi_handle.  They
    can be called without acpi_device.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f9c698d766f1..e9a71ed9954a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -662,17 +662,6 @@ int acpi_match_device_ids(struct acpi_device *device,
 }
 EXPORT_SYMBOL(acpi_match_device_ids);
 
-void acpi_free_ids(struct acpi_device *device)
-{
-	struct acpi_hardware_id *id, *tmp;
-
-	list_for_each_entry_safe(id, tmp, &device->pnp.ids, list) {
-		kfree(id->id);
-		kfree(id);
-	}
-	kfree(device->pnp.unique_id);
-}
-
 static void acpi_free_power_resources_lists(struct acpi_device *device)
 {
 	int i;
@@ -693,7 +682,7 @@ static void acpi_device_release(struct device *dev)
 {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 
-	acpi_free_ids(acpi_dev);
+	acpi_free_pnp_ids(&acpi_dev->pnp);
 	acpi_free_power_resources_lists(acpi_dev);
 	kfree(acpi_dev);
 }
@@ -1513,39 +1502,41 @@ static int acpi_ibm_smbus_match(acpi_handle handle)
 	return result;
 }
 
-static void acpi_device_set_id(struct acpi_device *device)
+static void acpi_set_pnp_ids(acpi_handle handle, struct acpi_device_pnp *pnp,
+				int device_type)
 {
 	acpi_status status;
 	struct acpi_device_info *info;
 	struct acpi_pnp_device_id_list *cid_list;
 	int i;
 
-	switch (device->device_type) {
+	switch (device_type) {
 	case ACPI_BUS_TYPE_DEVICE:
-		if (ACPI_IS_ROOT_DEVICE(device)) {
-			acpi_add_id(&device->pnp, ACPI_SYSTEM_HID);
+		if (handle == ACPI_ROOT_OBJECT) {
+			acpi_add_id(pnp, ACPI_SYSTEM_HID);
 			break;
 		}
 
-		status = acpi_get_object_info(device->handle, &info);
+		status = acpi_get_object_info(handle, &info);
 		if (ACPI_FAILURE(status)) {
-			printk(KERN_ERR PREFIX "%s: Error reading device info\n", __func__);
+			pr_err(PREFIX "%s: Error reading device info\n",
+					__func__);
 			return;
 		}
 
 		if (info->valid & ACPI_VALID_HID)
-			acpi_add_id(&device->pnp, info->hardware_id.string);
+			acpi_add_id(pnp, info->hardware_id.string);
 		if (info->valid & ACPI_VALID_CID) {
 			cid_list = &info->compatible_id_list;
 			for (i = 0; i < cid_list->count; i++)
-				acpi_add_id(&device->pnp, cid_list->ids[i].string);
+				acpi_add_id(pnp, cid_list->ids[i].string);
 		}
 		if (info->valid & ACPI_VALID_ADR) {
-			device->pnp.bus_address = info->address;
-			device->pnp.type.bus_address = 1;
+			pnp->bus_address = info->address;
+			pnp->type.bus_address = 1;
 		}
 		if (info->valid & ACPI_VALID_UID)
-			device->pnp.unique_id = kstrdup(info->unique_id.string,
+			pnp->unique_id = kstrdup(info->unique_id.string,
 							GFP_KERNEL);
 
 		kfree(info);
@@ -1554,40 +1545,50 @@ static void acpi_device_set_id(struct acpi_device *device)
 		 * Some devices don't reliably have _HIDs & _CIDs, so add
 		 * synthetic HIDs to make sure drivers can find them.
 		 */
-		if (acpi_is_video_device(device->handle))
-			acpi_add_id(&device->pnp, ACPI_VIDEO_HID);
-		else if (ACPI_SUCCESS(acpi_bay_match(device->handle)))
-			acpi_add_id(&device->pnp, ACPI_BAY_HID);
-		else if (ACPI_SUCCESS(acpi_dock_match(device->handle)))
-			acpi_add_id(&device->pnp, ACPI_DOCK_HID);
-		else if (!acpi_ibm_smbus_match(device->handle))
-			acpi_add_id(&device->pnp, ACPI_SMBUS_IBM_HID);
-		else if (list_empty(&device->pnp.ids) &&
-			 ACPI_IS_ROOT_DEVICE(device->parent)) {
-			acpi_add_id(&device->pnp, ACPI_BUS_HID); /* \_SB, LNXSYBUS */
-			strcpy(device->pnp.device_name, ACPI_BUS_DEVICE_NAME);
-			strcpy(device->pnp.device_class, ACPI_BUS_CLASS);
+		if (acpi_is_video_device(handle))
+			acpi_add_id(pnp, ACPI_VIDEO_HID);
+		else if (ACPI_SUCCESS(acpi_bay_match(handle)))
+			acpi_add_id(pnp, ACPI_BAY_HID);
+		else if (ACPI_SUCCESS(acpi_dock_match(handle)))
+			acpi_add_id(pnp, ACPI_DOCK_HID);
+		else if (!acpi_ibm_smbus_match(handle))
+			acpi_add_id(pnp, ACPI_SMBUS_IBM_HID);
+		else if (list_empty(&pnp->ids) && handle == ACPI_ROOT_OBJECT) {
+			acpi_add_id(pnp, ACPI_BUS_HID); /* \_SB, LNXSYBUS */
+			strcpy(pnp->device_name, ACPI_BUS_DEVICE_NAME);
+			strcpy(pnp->device_class, ACPI_BUS_CLASS);
 		}
 
 		break;
 	case ACPI_BUS_TYPE_POWER:
-		acpi_add_id(&device->pnp, ACPI_POWER_HID);
+		acpi_add_id(pnp, ACPI_POWER_HID);
 		break;
 	case ACPI_BUS_TYPE_PROCESSOR:
-		acpi_add_id(&device->pnp, ACPI_PROCESSOR_OBJECT_HID);
+		acpi_add_id(pnp, ACPI_PROCESSOR_OBJECT_HID);
 		break;
 	case ACPI_BUS_TYPE_THERMAL:
-		acpi_add_id(&device->pnp, ACPI_THERMAL_HID);
+		acpi_add_id(pnp, ACPI_THERMAL_HID);
 		break;
 	case ACPI_BUS_TYPE_POWER_BUTTON:
-		acpi_add_id(&device->pnp, ACPI_BUTTON_HID_POWERF);
+		acpi_add_id(pnp, ACPI_BUTTON_HID_POWERF);
 		break;
 	case ACPI_BUS_TYPE_SLEEP_BUTTON:
-		acpi_add_id(&device->pnp, ACPI_BUTTON_HID_SLEEPF);
+		acpi_add_id(pnp, ACPI_BUTTON_HID_SLEEPF);
 		break;
 	}
 }
 
+void acpi_free_pnp_ids(struct acpi_device_pnp *pnp)
+{
+	struct acpi_hardware_id *id, *tmp;
+
+	list_for_each_entry_safe(id, tmp, &pnp->ids, list) {
+		kfree(id->id);
+		kfree(id);
+	}
+	kfree(pnp->unique_id);
+}
+
 void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 			     int type, unsigned long long sta)
 {
@@ -1597,7 +1598,7 @@ void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 	device->parent = acpi_bus_get_parent(handle);
 	STRUCT_TO_INT(device->status) = sta;
 	acpi_device_get_busid(device);
-	acpi_device_set_id(device);
+	acpi_set_pnp_ids(handle, &device->pnp, type);
 	acpi_bus_get_flags(device);
 	device->flags.match_driver = false;
 	device_initialize(&device->dev);

commit d4e1a692e9e85f9cbee090ea8d6158b133d32157
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Mon Mar 4 21:30:41 2013 +0000

    ACPI: Remove acpi_device dependency in acpi_device_set_id()
    
    This patch updates the internal operations of acpi_device_set_id()
    to setup acpi_device_pnp without using acpi_device.  There is no
    functional change to acpi_device_set_id() in this patch.
    
    acpi_pnp_type is added to acpi_device_pnp, so that PNPID type is
    self-contained within acpi_device_pnp.  acpi_add_id(), acpi_bay_match(),
    acpi_dock_match(), acpi_ibm_smbus_match() and acpi_is_video_device()
    are changed to take acpi_handle as an argument, instead of acpi_device.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d69d77ab9c7e..f9c698d766f1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -526,7 +526,7 @@ static int acpi_device_setup_files(struct acpi_device *dev)
 			goto end;
 	}
 
-	if (dev->flags.bus_address)
+	if (dev->pnp.type.bus_address)
 		result = device_create_file(&dev->dev, &dev_attr_adr);
 	if (dev->pnp.unique_id)
 		result = device_create_file(&dev->dev, &dev_attr_uid);
@@ -599,7 +599,7 @@ static void acpi_device_remove_files(struct acpi_device *dev)
 
 	if (dev->pnp.unique_id)
 		device_remove_file(&dev->dev, &dev_attr_uid);
-	if (dev->flags.bus_address)
+	if (dev->pnp.type.bus_address)
 		device_remove_file(&dev->dev, &dev_attr_adr);
 	device_remove_file(&dev->dev, &dev_attr_modalias);
 	device_remove_file(&dev->dev, &dev_attr_hid);
@@ -1406,19 +1406,17 @@ static void acpi_device_get_busid(struct acpi_device *device)
 }
 
 /*
- * acpi_bay_match - see if a device is an ejectable driver bay
+ * acpi_bay_match - see if an acpi object is an ejectable driver bay
  *
  * If an acpi object is ejectable and has one of the ACPI ATA methods defined,
  * then we can safely call it an ejectable drive bay
  */
-static int acpi_bay_match(struct acpi_device *device){
+static int acpi_bay_match(acpi_handle handle)
+{
 	acpi_status status;
-	acpi_handle handle;
 	acpi_handle tmp;
 	acpi_handle phandle;
 
-	handle = device->handle;
-
 	status = acpi_get_handle(handle, "_EJ0", &tmp);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
@@ -1442,12 +1440,12 @@ static int acpi_bay_match(struct acpi_device *device){
 }
 
 /*
- * acpi_dock_match - see if a device has a _DCK method
+ * acpi_dock_match - see if an acpi object has a _DCK method
  */
-static int acpi_dock_match(struct acpi_device *device)
+static int acpi_dock_match(acpi_handle handle)
 {
 	acpi_handle tmp;
-	return acpi_get_handle(device->handle, "_DCK", &tmp);
+	return acpi_get_handle(handle, "_DCK", &tmp);
 }
 
 const char *acpi_device_hid(struct acpi_device *device)
@@ -1462,7 +1460,7 @@ const char *acpi_device_hid(struct acpi_device *device)
 }
 EXPORT_SYMBOL(acpi_device_hid);
 
-static void acpi_add_id(struct acpi_device *device, const char *dev_id)
+static void acpi_add_id(struct acpi_device_pnp *pnp, const char *dev_id)
 {
 	struct acpi_hardware_id *id;
 
@@ -1476,7 +1474,8 @@ static void acpi_add_id(struct acpi_device *device, const char *dev_id)
 		return;
 	}
 
-	list_add_tail(&id->list, &device->pnp.ids);
+	list_add_tail(&id->list, &pnp->ids);
+	pnp->type.hardware_id = 1;
 }
 
 /*
@@ -1484,7 +1483,7 @@ static void acpi_add_id(struct acpi_device *device, const char *dev_id)
  * lacks the SMBUS01 HID and the methods do not have the necessary "_"
  * prefix.  Work around this.
  */
-static int acpi_ibm_smbus_match(struct acpi_device *device)
+static int acpi_ibm_smbus_match(acpi_handle handle)
 {
 	acpi_handle h_dummy;
 	struct acpi_buffer path = {ACPI_ALLOCATE_BUFFER, NULL};
@@ -1494,7 +1493,7 @@ static int acpi_ibm_smbus_match(struct acpi_device *device)
 		return -ENODEV;
 
 	/* Look for SMBS object */
-	result = acpi_get_name(device->handle, ACPI_SINGLE_NAME, &path);
+	result = acpi_get_name(handle, ACPI_SINGLE_NAME, &path);
 	if (result)
 		return result;
 
@@ -1505,9 +1504,9 @@ static int acpi_ibm_smbus_match(struct acpi_device *device)
 
 	/* Does it have the necessary (but misnamed) methods? */
 	result = -ENODEV;
-	if (ACPI_SUCCESS(acpi_get_handle(device->handle, "SBI", &h_dummy)) &&
-	    ACPI_SUCCESS(acpi_get_handle(device->handle, "SBR", &h_dummy)) &&
-	    ACPI_SUCCESS(acpi_get_handle(device->handle, "SBW", &h_dummy)))
+	if (ACPI_SUCCESS(acpi_get_handle(handle, "SBI", &h_dummy)) &&
+	    ACPI_SUCCESS(acpi_get_handle(handle, "SBR", &h_dummy)) &&
+	    ACPI_SUCCESS(acpi_get_handle(handle, "SBW", &h_dummy)))
 		result = 0;
 out:
 	kfree(path.pointer);
@@ -1524,7 +1523,7 @@ static void acpi_device_set_id(struct acpi_device *device)
 	switch (device->device_type) {
 	case ACPI_BUS_TYPE_DEVICE:
 		if (ACPI_IS_ROOT_DEVICE(device)) {
-			acpi_add_id(device, ACPI_SYSTEM_HID);
+			acpi_add_id(&device->pnp, ACPI_SYSTEM_HID);
 			break;
 		}
 
@@ -1535,15 +1534,15 @@ static void acpi_device_set_id(struct acpi_device *device)
 		}
 
 		if (info->valid & ACPI_VALID_HID)
-			acpi_add_id(device, info->hardware_id.string);
+			acpi_add_id(&device->pnp, info->hardware_id.string);
 		if (info->valid & ACPI_VALID_CID) {
 			cid_list = &info->compatible_id_list;
 			for (i = 0; i < cid_list->count; i++)
-				acpi_add_id(device, cid_list->ids[i].string);
+				acpi_add_id(&device->pnp, cid_list->ids[i].string);
 		}
 		if (info->valid & ACPI_VALID_ADR) {
 			device->pnp.bus_address = info->address;
-			device->flags.bus_address = 1;
+			device->pnp.type.bus_address = 1;
 		}
 		if (info->valid & ACPI_VALID_UID)
 			device->pnp.unique_id = kstrdup(info->unique_id.string,
@@ -1555,36 +1554,36 @@ static void acpi_device_set_id(struct acpi_device *device)
 		 * Some devices don't reliably have _HIDs & _CIDs, so add
 		 * synthetic HIDs to make sure drivers can find them.
 		 */
-		if (acpi_is_video_device(device))
-			acpi_add_id(device, ACPI_VIDEO_HID);
-		else if (ACPI_SUCCESS(acpi_bay_match(device)))
-			acpi_add_id(device, ACPI_BAY_HID);
-		else if (ACPI_SUCCESS(acpi_dock_match(device)))
-			acpi_add_id(device, ACPI_DOCK_HID);
-		else if (!acpi_ibm_smbus_match(device))
-			acpi_add_id(device, ACPI_SMBUS_IBM_HID);
+		if (acpi_is_video_device(device->handle))
+			acpi_add_id(&device->pnp, ACPI_VIDEO_HID);
+		else if (ACPI_SUCCESS(acpi_bay_match(device->handle)))
+			acpi_add_id(&device->pnp, ACPI_BAY_HID);
+		else if (ACPI_SUCCESS(acpi_dock_match(device->handle)))
+			acpi_add_id(&device->pnp, ACPI_DOCK_HID);
+		else if (!acpi_ibm_smbus_match(device->handle))
+			acpi_add_id(&device->pnp, ACPI_SMBUS_IBM_HID);
 		else if (list_empty(&device->pnp.ids) &&
 			 ACPI_IS_ROOT_DEVICE(device->parent)) {
-			acpi_add_id(device, ACPI_BUS_HID); /* \_SB, LNXSYBUS */
+			acpi_add_id(&device->pnp, ACPI_BUS_HID); /* \_SB, LNXSYBUS */
 			strcpy(device->pnp.device_name, ACPI_BUS_DEVICE_NAME);
 			strcpy(device->pnp.device_class, ACPI_BUS_CLASS);
 		}
 
 		break;
 	case ACPI_BUS_TYPE_POWER:
-		acpi_add_id(device, ACPI_POWER_HID);
+		acpi_add_id(&device->pnp, ACPI_POWER_HID);
 		break;
 	case ACPI_BUS_TYPE_PROCESSOR:
-		acpi_add_id(device, ACPI_PROCESSOR_OBJECT_HID);
+		acpi_add_id(&device->pnp, ACPI_PROCESSOR_OBJECT_HID);
 		break;
 	case ACPI_BUS_TYPE_THERMAL:
-		acpi_add_id(device, ACPI_THERMAL_HID);
+		acpi_add_id(&device->pnp, ACPI_THERMAL_HID);
 		break;
 	case ACPI_BUS_TYPE_POWER_BUTTON:
-		acpi_add_id(device, ACPI_BUTTON_HID_POWERF);
+		acpi_add_id(&device->pnp, ACPI_BUTTON_HID_POWERF);
 		break;
 	case ACPI_BUS_TYPE_SLEEP_BUTTON:
-		acpi_add_id(device, ACPI_BUTTON_HID_SLEEPF);
+		acpi_add_id(&device->pnp, ACPI_BUTTON_HID_SLEEPF);
 		break;
 	}
 }

commit f58b082aed43400c03e53beacc50a9f9eb23ac91
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Mar 6 23:46:20 2013 +0100

    ACPI / scan: Add special handler for Intel Lynxpoint LPSS devices
    
    Devices on the Intel Lynxpoint Low Power Subsystem (LPSS) have some
    common features that aren't shared with any other platform devices,
    including the clock and LTR (Latency Tolerance Reporting) registers.
    It is better to handle those features in common code than to bother
    device drivers with doing that (I/O functionality-wise the LPSS
    devices are generally compatible with other devices that don't
    have those special registers and may be handled by the same drivers).
    
    The clock registers of the LPSS devices are now taken care of by
    the special clk-x86-lpss driver, but the MMIO mappings used for
    accessing those registers can also be used for accessing the LTR
    registers on those devices (LTR support for the Lynxpoint LPSS is
    going to be added by a subsequent patch).  Thus it is convenient
    to add a special ACPI scan handler for the Lynxpoint LPSS devices
    that will create the MMIO mappings for accessing the clock (and
    LTR in the future) registers and will register the LPSS devices'
    clocks, so the clk-x86-lpss driver will only need to take care of
    the main Lynxpoint LPSS clock.
    
    Introduce a special ACPI scan handler for Intel Lynxpoint LPSS
    devices as described above.  This also reduces overhead related to
    browsing the ACPI namespace in search of the LPSS devices before the
    registration of their clocks, removes some LPSS-specific (and
    somewhat ugly) code from acpi_platform.c and shrinks the overall code
    size slightly.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5e7e991717d7..433a4e15019c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1788,6 +1788,7 @@ int __init acpi_scan_init(void)
 	acpi_pci_root_init();
 	acpi_pci_link_init();
 	acpi_platform_init();
+	acpi_lpss_init();
 	acpi_csrt_init();
 	acpi_container_init();
 	acpi_pci_slot_init();

commit 0a34764411aaab0114aa3f3656fda33a69a46d10
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Mar 3 23:18:03 2013 +0100

    ACPI / scan: Make memory hotplug driver use struct acpi_scan_handler
    
    Make the ACPI memory hotplug driver use struct acpi_scan_handler
    for representing the object used to set up ACPI memory hotplug
    functionality and to remove hotplug memory ranges and data
    structures used by the driver before unregistering ACPI device
    nodes representing memory.  Register the new struct acpi_scan_handler
    object with the help of acpi_scan_add_handler_with_hotplug() to allow
    user space to manipulate the attributes of the memory hotplug
    profile.
    
    This results in a significant reduction of the drvier's code size
    and removes some ACPI hotplug code duplication.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5458403c8249..d69d77ab9c7e 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2026,6 +2026,7 @@ int __init acpi_scan_init(void)
 	acpi_csrt_init();
 	acpi_container_init();
 	acpi_pci_slot_init();
+	acpi_memory_hotplug_init();
 
 	mutex_lock(&acpi_scan_lock);
 	/*

commit 3f8055c3583640ed3e4c81864dd76e06a7faa505
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Mar 3 23:08:16 2013 +0100

    ACPI / hotplug: Introduce user space interface for hotplug profiles
    
    Introduce user space interface for manipulating hotplug profiles
    associated with ACPI scan handlers.
    
    The interface consists of sysfs directories under
    /sys/firmware/acpi/hotplug/, one for each hotplug profile, containing
    an attribute allowing user space to manipulate the enabled field of
    the corresponding profile.  Namely, switching the enabled attribute
    from '0' to '1' will cause the common hotplug notify handler to be
    installed for all ACPI namespace objects representing devices matching
    the scan handler associated with the given hotplug profile (and
    analogously for the converse switch).
    
    Drivers willing to use the new user space interface should add their
    ACPI scan handlers with the help of new funtion
    acpi_scan_add_handler_with_hotplug().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 45fbe95ba1f3..5458403c8249 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -63,6 +63,19 @@ int acpi_scan_add_handler(struct acpi_scan_handler *handler)
 	return 0;
 }
 
+int acpi_scan_add_handler_with_hotplug(struct acpi_scan_handler *handler,
+				       const char *hotplug_profile_name)
+{
+	int error;
+
+	error = acpi_scan_add_handler(handler);
+	if (error)
+		return error;
+
+	acpi_sysfs_add_hotplug_profile(&handler->hotplug, hotplug_profile_name);
+	return 0;
+}
+
 /*
  * Creates hid/cid(s) string needed for modalias and uevent
  * e.g. on a device with hid:IBM0001 and cid:ACPI0001 you get:
@@ -1690,6 +1703,52 @@ static bool acpi_scan_handler_matching(struct acpi_scan_handler *handler,
 	return false;
 }
 
+static acpi_status acpi_scan_hotplug_modify(acpi_handle handle,
+					    u32 lvl_not_used, void *data,
+					    void **ret_not_used)
+{
+	struct acpi_scan_handler *handler = data;
+	struct acpi_device_info *info;
+	bool match = false;
+
+	if (ACPI_FAILURE(acpi_get_object_info(handle, &info)))
+		return AE_OK;
+
+	if (info->valid & ACPI_VALID_HID) {
+		char *idstr = info->hardware_id.string;
+		match = acpi_scan_handler_matching(handler, idstr, NULL);
+	}
+	kfree(info);
+	if (!match)
+		return AE_OK;
+
+	if (handler->hotplug.enabled)
+		acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
+					    acpi_hotplug_notify_cb, NULL);
+	else
+		acpi_remove_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
+					   acpi_hotplug_notify_cb);
+
+	return AE_OK;
+}
+
+void acpi_scan_hotplug_enabled(struct acpi_hotplug_profile *hotplug, bool val)
+{
+	struct acpi_scan_handler *handler;
+
+	if (!!hotplug->enabled == !!val)
+		return;
+
+	mutex_lock(&acpi_scan_lock);
+
+	hotplug->enabled = val;
+	handler = container_of(hotplug, struct acpi_scan_handler, hotplug);
+	acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
+			    acpi_scan_hotplug_modify, NULL, handler, NULL);
+
+	mutex_unlock(&acpi_scan_lock);
+}
+
 static struct acpi_scan_handler *acpi_scan_match_handler(char *idstr,
 					const struct acpi_device_id **matchid)
 {

commit 4b59cc1fd6fd1dac1d4468b4f327ae9f59d1c0aa
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Mar 3 23:06:21 2013 +0100

    ACPI / scan: Introduce acpi_scan_handler_matching()
    
    Introduce new helper routine acpi_scan_handler_matching() for
    checking if the given ACPI scan handler matches a given device ID
    and rework acpi_scan_match_handler() to use the new routine (that
    routine will also be useful for other purposes in the future).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index de73fdf89598..45fbe95ba1f3 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1673,22 +1673,32 @@ static int acpi_bus_type_and_status(acpi_handle handle, int *type,
 	return 0;
 }
 
+static bool acpi_scan_handler_matching(struct acpi_scan_handler *handler,
+				       char *idstr,
+				       const struct acpi_device_id **matchid)
+{
+	const struct acpi_device_id *devid;
+
+	for (devid = handler->ids; devid->id[0]; devid++)
+		if (!strcmp((char *)devid->id, idstr)) {
+			if (matchid)
+				*matchid = devid;
+
+			return true;
+		}
+
+	return false;
+}
+
 static struct acpi_scan_handler *acpi_scan_match_handler(char *idstr,
 					const struct acpi_device_id **matchid)
 {
 	struct acpi_scan_handler *handler;
 
-	list_for_each_entry(handler, &acpi_scan_handlers_list, list_node) {
-		const struct acpi_device_id *devid;
-
-		for (devid = handler->ids; devid->id[0]; devid++)
-			if (!strcmp((char *)devid->id, idstr)) {
-				if (matchid)
-					*matchid = devid;
+	list_for_each_entry(handler, &acpi_scan_handlers_list, list_node)
+		if (acpi_scan_handler_matching(handler, idstr, matchid))
+			return handler;
 
-				return handler;
-			}
-	}
 	return NULL;
 }
 

commit a33ec399e9fc266ba20f9b71d693aa63658bf2aa
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Mar 3 23:05:29 2013 +0100

    ACPI / scan: Introduce common code for ACPI-based device hotplug
    
    Multiple drivers handling hotplug-capable ACPI device nodes install
    notify handlers covering the same types of events in a very similar
    way.  Moreover, those handlers are installed in separate namespace
    walks, although that really should be done during namespace scans
    carried out by acpi_bus_scan().  This leads to substantial code
    duplication, unnecessary overhead and behavior that is hard to
    follow.
    
    For this reason, introduce common code in drivers/acpi/scan.c for
    handling hotplug-related notification and carrying out device
    insertion and eject operations in a generic fashion, such that it
    may be used by all of the relevant drivers in the future.  To cover
    the existing differences between those drivers introduce struct
    acpi_hotplug_profile for representing collections of hotplug
    settings associated with different ACPI scan handlers that can be
    used by the drivers to make the common code reflect their current
    behavior.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index cc1b0020478b..de73fdf89598 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -107,32 +107,19 @@ acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, cha
 }
 static DEVICE_ATTR(modalias, 0444, acpi_device_modalias_show, NULL);
 
-/**
- * acpi_bus_hot_remove_device: hot-remove a device and its children
- * @context: struct acpi_eject_event pointer (freed in this func)
- *
- * Hot-remove a device and its children. This function frees up the
- * memory space passed by arg context, so that the caller may call
- * this function asynchronously through acpi_os_hotplug_execute().
- */
-void acpi_bus_hot_remove_device(void *context)
+static int acpi_scan_hot_remove(struct acpi_device *device)
 {
-	struct acpi_eject_event *ej_event = context;
-	struct acpi_device *device = ej_event->device;
 	acpi_handle handle = device->handle;
-	acpi_handle temp;
+	acpi_handle not_used;
 	struct acpi_object_list arg_list;
 	union acpi_object arg;
-	acpi_status status = AE_OK;
-	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE; /* default */
-
-	mutex_lock(&acpi_scan_lock);
+	acpi_status status;
 
 	/* If there is no handle, the device node has been unregistered. */
-	if (!device->handle) {
+	if (!handle) {
 		dev_dbg(&device->dev, "ACPI handle missing\n");
 		put_device(&device->dev);
-		goto out;
+		return -EINVAL;
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
@@ -143,7 +130,7 @@ void acpi_bus_hot_remove_device(void *context)
 	put_device(&device->dev);
 	device = NULL;
 
-	if (ACPI_SUCCESS(acpi_get_handle(handle, "_LCK", &temp))) {
+	if (ACPI_SUCCESS(acpi_get_handle(handle, "_LCK", &not_used))) {
 		arg_list.count = 1;
 		arg_list.pointer = &arg;
 		arg.type = ACPI_TYPE_INTEGER;
@@ -161,18 +148,158 @@ void acpi_bus_hot_remove_device(void *context)
 	 */
 	status = acpi_evaluate_object(handle, "_EJ0", &arg_list, NULL);
 	if (ACPI_FAILURE(status)) {
-		if (status != AE_NOT_FOUND)
+		if (status == AE_NOT_FOUND) {
+			return -ENODEV;
+		} else {
 			acpi_handle_warn(handle, "Eject failed\n");
+			return -EIO;
+		}
+	}
+	return 0;
+}
 
-		/* Tell the firmware the hot-remove operation has failed. */
-		acpi_evaluate_hotplug_ost(handle, ej_event->event,
-					  ost_code, NULL);
+static void acpi_bus_device_eject(void *context)
+{
+	acpi_handle handle = context;
+	struct acpi_device *device = NULL;
+	struct acpi_scan_handler *handler;
+	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
+
+	mutex_lock(&acpi_scan_lock);
+
+	acpi_bus_get_device(handle, &device);
+	if (!device)
+		goto err_out;
+
+	handler = device->handler;
+	if (!handler || !handler->hotplug.enabled) {
+		ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
+		goto err_out;
+	}
+	acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
+				  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
+	if (handler->hotplug.mode == AHM_CONTAINER) {
+		device->flags.eject_pending = true;
+		kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
+	} else {
+		int error;
+
+		get_device(&device->dev);
+		error = acpi_scan_hot_remove(device);
+		if (error)
+			goto err_out;
 	}
 
  out:
 	mutex_unlock(&acpi_scan_lock);
-	kfree(context);
 	return;
+
+ err_out:
+	acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST, ost_code,
+				  NULL);
+	goto out;
+}
+
+static void acpi_scan_bus_device_check(acpi_handle handle, u32 ost_source)
+{
+	struct acpi_device *device = NULL;
+	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
+	int error;
+
+	mutex_lock(&acpi_scan_lock);
+
+	acpi_bus_get_device(handle, &device);
+	if (device) {
+		dev_warn(&device->dev, "Attempt to re-insert\n");
+		goto out;
+	}
+	acpi_evaluate_hotplug_ost(handle, ost_source,
+				  ACPI_OST_SC_INSERT_IN_PROGRESS, NULL);
+	error = acpi_bus_scan(handle);
+	if (error) {
+		acpi_handle_warn(handle, "Namespace scan failure\n");
+		goto out;
+	}
+	error = acpi_bus_get_device(handle, &device);
+	if (error) {
+		acpi_handle_warn(handle, "Missing device node object\n");
+		goto out;
+	}
+	ost_code = ACPI_OST_SC_SUCCESS;
+	if (device->handler && device->handler->hotplug.mode == AHM_CONTAINER)
+		kobject_uevent(&device->dev.kobj, KOBJ_ONLINE);
+
+ out:
+	acpi_evaluate_hotplug_ost(handle, ost_source, ost_code, NULL);
+	mutex_unlock(&acpi_scan_lock);
+}
+
+static void acpi_scan_bus_check(void *context)
+{
+	acpi_scan_bus_device_check((acpi_handle)context,
+				   ACPI_NOTIFY_BUS_CHECK);
+}
+
+static void acpi_scan_device_check(void *context)
+{
+	acpi_scan_bus_device_check((acpi_handle)context,
+				   ACPI_NOTIFY_DEVICE_CHECK);
+}
+
+static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *not_used)
+{
+	acpi_osd_exec_callback callback;
+	acpi_status status;
+
+	switch (type) {
+	case ACPI_NOTIFY_BUS_CHECK:
+		acpi_handle_debug(handle, "ACPI_NOTIFY_BUS_CHECK event\n");
+		callback = acpi_scan_bus_check;
+		break;
+	case ACPI_NOTIFY_DEVICE_CHECK:
+		acpi_handle_debug(handle, "ACPI_NOTIFY_DEVICE_CHECK event\n");
+		callback = acpi_scan_device_check;
+		break;
+	case ACPI_NOTIFY_EJECT_REQUEST:
+		acpi_handle_debug(handle, "ACPI_NOTIFY_EJECT_REQUEST event\n");
+		callback = acpi_bus_device_eject;
+		break;
+	default:
+		/* non-hotplug event; possibly handled by other handler */
+		return;
+	}
+	status = acpi_os_hotplug_execute(callback, handle);
+	if (ACPI_FAILURE(status))
+		acpi_evaluate_hotplug_ost(handle, type,
+					  ACPI_OST_SC_NON_SPECIFIC_FAILURE,
+					  NULL);
+}
+
+/**
+ * acpi_bus_hot_remove_device: hot-remove a device and its children
+ * @context: struct acpi_eject_event pointer (freed in this func)
+ *
+ * Hot-remove a device and its children. This function frees up the
+ * memory space passed by arg context, so that the caller may call
+ * this function asynchronously through acpi_os_hotplug_execute().
+ */
+void acpi_bus_hot_remove_device(void *context)
+{
+	struct acpi_eject_event *ej_event = context;
+	struct acpi_device *device = ej_event->device;
+	acpi_handle handle = device->handle;
+	int error;
+
+	mutex_lock(&acpi_scan_lock);
+
+	error = acpi_scan_hot_remove(device);
+	if (error && handle)
+		acpi_evaluate_hotplug_ost(handle, ej_event->event,
+					  ACPI_OST_SC_NON_SPECIFIC_FAILURE,
+					  NULL);
+
+	mutex_unlock(&acpi_scan_lock);
+	kfree(context);
 }
 EXPORT_SYMBOL(acpi_bus_hot_remove_device);
 
@@ -206,51 +333,61 @@ static ssize_t
 acpi_eject_store(struct device *d, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
-	int ret = count;
-	acpi_status status;
-	acpi_object_type type = 0;
 	struct acpi_device *acpi_device = to_acpi_device(d);
 	struct acpi_eject_event *ej_event;
+	acpi_object_type not_used;
+	acpi_status status;
+	u32 ost_source;
+	int ret;
 
-	if ((!count) || (buf[0] != '1')) {
+	if (!count || buf[0] != '1')
 		return -EINVAL;
-	}
-	if (!acpi_device->driver && !acpi_device->handler) {
-		ret = -ENODEV;
-		goto err;
-	}
-	status = acpi_get_type(acpi_device->handle, &type);
-	if (ACPI_FAILURE(status) || (!acpi_device->flags.ejectable)) {
-		ret = -ENODEV;
-		goto err;
-	}
 
-	ej_event = kmalloc(sizeof(*ej_event), GFP_KERNEL);
-	if (!ej_event) {
-		ret = -ENOMEM;
-		goto err;
-	}
+	if ((!acpi_device->handler || !acpi_device->handler->hotplug.enabled)
+	    && !acpi_device->driver)
+		return -ENODEV;
+
+	status = acpi_get_type(acpi_device->handle, &not_used);
+	if (ACPI_FAILURE(status) || !acpi_device->flags.ejectable)
+		return -ENODEV;
+
+	mutex_lock(&acpi_scan_lock);
 
-	get_device(&acpi_device->dev);
-	ej_event->device = acpi_device;
 	if (acpi_device->flags.eject_pending) {
-		/* event originated from ACPI eject notification */
-		ej_event->event = ACPI_NOTIFY_EJECT_REQUEST;
+		/* ACPI eject notification event. */
+		ost_source = ACPI_NOTIFY_EJECT_REQUEST;
 		acpi_device->flags.eject_pending = 0;
 	} else {
-		/* event originated from user */
-		ej_event->event = ACPI_OST_EC_OSPM_EJECT;
-		(void) acpi_evaluate_hotplug_ost(acpi_device->handle,
-			ej_event->event, ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
+		/* Eject initiated by user space. */
+		ost_source = ACPI_OST_EC_OSPM_EJECT;
 	}
-
+	ej_event = kmalloc(sizeof(*ej_event), GFP_KERNEL);
+	if (!ej_event) {
+		ret = -ENOMEM;
+		goto err_out;
+	}
+	acpi_evaluate_hotplug_ost(acpi_device->handle, ost_source,
+				  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
+	ej_event->device = acpi_device;
+	ej_event->event = ost_source;
+	get_device(&acpi_device->dev);
 	status = acpi_os_hotplug_execute(acpi_bus_hot_remove_device, ej_event);
 	if (ACPI_FAILURE(status)) {
 		put_device(&acpi_device->dev);
 		kfree(ej_event);
+		ret = status == AE_NO_MEMORY ? -ENOMEM : -EAGAIN;
+		goto err_out;
 	}
-err:
+	ret = count;
+
+ out:
+	mutex_unlock(&acpi_scan_lock);
 	return ret;
+
+ err_out:
+	acpi_evaluate_hotplug_ost(acpi_device->handle, ost_source,
+				  ACPI_OST_SC_NON_SPECIFIC_FAILURE, NULL);
+	goto out;
 }
 
 static DEVICE_ATTR(eject, 0200, NULL, acpi_eject_store);
@@ -1555,6 +1692,30 @@ static struct acpi_scan_handler *acpi_scan_match_handler(char *idstr,
 	return NULL;
 }
 
+static void acpi_scan_init_hotplug(acpi_handle handle)
+{
+	struct acpi_device_info *info;
+	struct acpi_scan_handler *handler;
+
+	if (ACPI_FAILURE(acpi_get_object_info(handle, &info)))
+		return;
+
+	if (!(info->valid & ACPI_VALID_HID)) {
+		kfree(info);
+		return;
+	}
+
+	/*
+	 * This relies on the fact that acpi_install_notify_handler() will not
+	 * install the same notify handler routine twice for the same handle.
+	 */
+	handler = acpi_scan_match_handler(info->hardware_id.string, NULL);
+	kfree(info);
+	if (handler && handler->hotplug.enabled)
+		acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
+					    acpi_hotplug_notify_cb, NULL);
+}
+
 static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 				      void *not_used, void **return_value)
 {
@@ -1577,6 +1738,8 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 		return AE_OK;
 	}
 
+	acpi_scan_init_hotplug(handle);
+
 	if (!(sta & ACPI_STA_DEVICE_PRESENT) &&
 	    !(sta & ACPI_STA_DEVICE_FUNCTIONING)) {
 		struct acpi_device_wakeup wakeup;

commit c56980744ed99994799850903627c4bbb5fed006
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Mar 3 23:05:14 2013 +0100

    ACPI / scan: Introduce acpi_scan_match_handler()
    
    Introduce helper routine acpi_scan_match_handler() that will find the
    ACPI scan handler matching a given device ID, if there is one, and
    rework acpi_scan_attach_handler() to use the new routine (that
    routine will also be useful for other purposes going forward).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5e7e991717d7..cc1b0020478b 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1536,6 +1536,25 @@ static int acpi_bus_type_and_status(acpi_handle handle, int *type,
 	return 0;
 }
 
+static struct acpi_scan_handler *acpi_scan_match_handler(char *idstr,
+					const struct acpi_device_id **matchid)
+{
+	struct acpi_scan_handler *handler;
+
+	list_for_each_entry(handler, &acpi_scan_handlers_list, list_node) {
+		const struct acpi_device_id *devid;
+
+		for (devid = handler->ids; devid->id[0]; devid++)
+			if (!strcmp((char *)devid->id, idstr)) {
+				if (matchid)
+					*matchid = devid;
+
+				return handler;
+			}
+	}
+	return NULL;
+}
+
 static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 				      void *not_used, void **return_value)
 {
@@ -1583,42 +1602,26 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 	return AE_OK;
 }
 
-static int acpi_scan_do_attach_handler(struct acpi_device *device, char *id)
+static int acpi_scan_attach_handler(struct acpi_device *device)
 {
-	struct acpi_scan_handler *handler;
+	struct acpi_hardware_id *hwid;
+	int ret = 0;
 
-	list_for_each_entry(handler, &acpi_scan_handlers_list, list_node) {
+	list_for_each_entry(hwid, &device->pnp.ids, list) {
 		const struct acpi_device_id *devid;
+		struct acpi_scan_handler *handler;
 
-		for (devid = handler->ids; devid->id[0]; devid++) {
-			int ret;
-
-			if (strcmp((char *)devid->id, id))
-				continue;
-
+		handler = acpi_scan_match_handler(hwid->id, &devid);
+		if (handler) {
 			ret = handler->attach(device, devid);
 			if (ret > 0) {
 				device->handler = handler;
-				return ret;
+				break;
 			} else if (ret < 0) {
-				return ret;
+				break;
 			}
 		}
 	}
-	return 0;
-}
-
-static int acpi_scan_attach_handler(struct acpi_device *device)
-{
-	struct acpi_hardware_id *hwid;
-	int ret = 0;
-
-	list_for_each_entry(hwid, &device->pnp.ids, list) {
-		ret = acpi_scan_do_attach_handler(device, hwid->id);
-		if (ret)
-			break;
-
-	}
 	return ret;
 }
 

commit c41b3810c09e60664433548c5218cc6ece6a8903
Merge: 556f12f602ac 4383822020c5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 21:25:17 2013 -0800

    Merge tag 'pm+acpi-fixes-3.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management fixes from Rafael Wysocki:
    
     - Fixes for blackfin and microblaze build problems introduced by the
       removal of global pm_idle.  From Lars-Peter Clausen.
    
     - OPP core build fix from Shawn Guo.
    
     - Error condition check fix for the new imx6q-cpufreq driver from Wei
       Yongjun.
    
     - Fix for an AER driver crash related to the lack of APEI
       initialization for acpi=off.  From Rafael J Wysocki.
    
     - Fix for a USB breakage on Thinkpad T430 related to ACPI power
       resources and PCI wakeup from Rafael J.  Wysocki.
    
    * tag 'pm+acpi-fixes-3.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      ACPI / PM: Take unusual configurations of power resources into account
      imx6q-cpufreq: fix return value check in imx6q_cpufreq_probe()
      PM / OPP: fix condition for empty of_init_opp_table()
      ACPI / APEI: Fix crash in apei_hest_parse() for acpi=off
      microblaze idle: Fix compile error
      blackfin idle: Fix compile error

commit 556f12f602ac0a18a82ca83e9f8e8547688fc633
Merge: fffddfd6c8e0 018ba0a6efad
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 21:18:18 2013 -0800

    Merge tag 'pci-v3.9-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI changes from Bjorn Helgaas:
     "Host bridge hotplug
        - Major overhaul of ACPI host bridge add/start (Rafael Wysocki, Yinghai Lu)
        - Major overhaul of PCI/ACPI binding (Rafael Wysocki, Yinghai Lu)
        - Split out ACPI host bridge and ACPI PCI device hotplug (Yinghai Lu)
        - Stop caching _PRT and make independent of bus numbers (Yinghai Lu)
    
      PCI device hotplug
        - Clean up cpqphp dead code (Sasha Levin)
        - Disable ARI unless device and upstream bridge support it (Yijing Wang)
        - Initialize all hot-added devices (not functions 0-7) (Yijing Wang)
    
      Power management
        - Don't touch ASPM if disabled (Joe Lawrence)
        - Fix ASPM link state management (Myron Stowe)
    
      Miscellaneous
        - Fix PCI_EXP_FLAGS accessor (Alex Williamson)
        - Disable Bus Master in pci_device_shutdown (Konstantin Khlebnikov)
        - Document hotplug resource and MPS parameters (Yijing Wang)
        - Add accessor for PCIe capabilities (Myron Stowe)
        - Drop pciehp suspend/resume messages (Paul Bolle)
        - Make pci_slot built-in only (not a module) (Jiang Liu)
        - Remove unused PCI/ACPI bind ops (Jiang Liu)
        - Removed used pci_root_bus (Bjorn Helgaas)"
    
    * tag 'pci-v3.9-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (51 commits)
      PCI/ACPI: Don't cache _PRT, and don't associate them with bus numbers
      PCI: Fix PCI Express Capability accessors for PCI_EXP_FLAGS
      ACPI / PCI: Make pci_slot built-in only, not a module
      PCI/PM: Clear state_saved during suspend
      PCI: Use atomic_inc_return() rather than atomic_add_return()
      PCI: Catch attempts to disable already-disabled devices
      PCI: Disable Bus Master unconditionally in pci_device_shutdown()
      PCI: acpiphp: Remove dead code for PCI host bridge hotplug
      PCI: acpiphp: Create companion ACPI devices before creating PCI devices
      PCI: Remove unused "rc" in virtfn_add_bus()
      PCI: pciehp: Drop suspend/resume ENTRY messages
      PCI/ASPM: Don't touch ASPM if forcibly disabled
      PCI/ASPM: Deallocate upstream link state even if device is not PCIe
      PCI: Document MPS parameters pci=pcie_bus_safe, pci=pcie_bus_perf, etc
      PCI: Document hpiosize= and hpmemsize= resource reservation parameters
      PCI: Use PCI Express Capability accessor
      PCI: Introduce accessor to retrieve PCIe Capabilities Register
      PCI: Put pci_dev in device tree as early as possible
      PCI: Skip attaching driver in device_add()
      PCI: acpiphp: Keep driver loaded even if no slots found
      ...

commit 4383822020c54c21eb2eb939a3233b44a51e8ca0
Merge: bf900afba96b b5d667eb392e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Feb 23 23:15:43 2013 +0100

    Merge branch 'acpi-pm' into fixes
    
    * acpi-pm:
      ACPI / PM: Take unusual configurations of power resources into account

commit b5d667eb392ed901fc7ae76869c7a130559e193c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Feb 23 23:15:21 2013 +0100

    ACPI / PM: Take unusual configurations of power resources into account
    
    Commit d2e5f0c (ACPI / PCI: Rework the setup and cleanup of device
    wakeup) moved the initial disabling of system wakeup for PCI devices
    into a place where it can actually work and that exposed a hidden old
    issue with crap^Wunusual system designs where the same power
    resources are used for both wakeup power and device power control at
    run time.
    
    Namely, say there is one power resource such that the ACPI power
    state D0 of a PCI device depends on that power resource (i.e. the
    device is in D0 when that power resource is "on") and it is used
    as a wakeup power resource for the same device.  Then, calling
    acpi_pci_sleep_wake(pci_dev, false) for the device in question will
    cause the reference counter of that power resource to drop to 0,
    which in turn will cause it to be turned off.  As a result, the
    device will go into D3cold at that point, although it should have
    stayed in D0.
    
    As it turns out, that happens to USB controllers on some laptops
    and USB becomes unusable on those machines as a result, which is
    a major regression from v3.8.
    
    To fix this problem, (1) increment the reference counters of wakup
    power resources during their initialization if they are "on"
    initially, (2) prevent acpi_disable_wakeup_device_power() from
    decrementing the reference counters of wakeup power resources that
    were not enabled for wakeup power previously, and (3) prevent
    acpi_enable_wakeup_device_power() from incrementing the reference
    counters of wakeup power resources that already are enabled for
    wakeup power.
    
    In addition to that, if it is impossible to determine the initial
    states of wakeup power resources, avoid enabling wakeup for devices
    whose wakeup power depends on those power resources.
    
    Reported-by: Dave Jones <davej@redhat.com>
    Reported-by: Fabio Baltieri <fabio.baltieri@linaro.org>
    Tested-by: Fabio Baltieri <fabio.baltieri@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f75f25c2e455..560b05566f3b 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1004,7 +1004,14 @@ static int acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 	if (!list_empty(&wakeup->resources)) {
 		int sleep_state;
 
-		sleep_state = acpi_power_min_system_level(&wakeup->resources);
+		err = acpi_power_wakeup_list_init(&wakeup->resources,
+						  &sleep_state);
+		if (err) {
+			acpi_handle_warn(handle, "Retrieving current states "
+					 "of wakeup power resources failed\n");
+			acpi_power_resources_list_free(&wakeup->resources);
+			goto out;
+		}
 		if (sleep_state < wakeup->sleep_state) {
 			acpi_handle_warn(handle, "Overriding _PRW sleep state "
 					 "(S%d) by S%d from power resources\n",

commit ad06bff31fbf0aba4e5faae936e12292a7972b05
Merge: 20f24208f631 ab1a2e038ff2
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 15 17:44:01 2013 -0700

    Merge branch 'pci/jiang-pci_slot-kconfig' into next
    
    * pci/jiang-pci_slot-kconfig:
      ACPI / PCI: Make pci_slot built-in only, not a module

commit ab1a2e038ff2336502e95ec6492c0364a9fc70d0
Author: Jiang Liu <liuj97@gmail.com>
Date:   Sat Jan 19 00:07:42 2013 +0800

    ACPI / PCI: Make pci_slot built-in only, not a module
    
    As discussed in thread at https://patchwork.kernel.org/patch/1946851/,
    there's no value in supporting CONFIG_ACPI_PCI_SLOT=m any more.
    So change Kconfig and code to only support building pci_slot as
    built-in driver.
    
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 7c43bdc36abc..236e476b09c9 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1687,6 +1687,7 @@ int __init acpi_scan_init(void)
 
 	acpi_power_init();
 	acpi_pci_root_init();
+	acpi_pci_slot_init();
 
 	/*
 	 * Enumerate devices in the ACPI namespace.

commit e8f71df723339b6d3861886f58c245812d1994f8
Merge: b34bf8e3cd50 3757b94802fb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 15 13:58:30 2013 +0100

    Merge branch 'acpi-cleanup'
    
    * acpi-cleanup: (21 commits)
      ACPI / hotplug: Fix concurrency issues and memory leaks
      ACPI: Remove the use of CONFIG_ACPI_CONTAINER_MODULE
      ACPI / scan: Full transition to D3cold in acpi_device_unregister()
      ACPI / scan: Make acpi_bus_hot_remove_device() acquire the scan lock
      ACPI: Drop the container.h header file
      ACPI / Documentation: refer to correct file for acpi_platform_device_ids[] table
      ACPI / scan: Make container driver use struct acpi_scan_handler
      ACPI / scan: Remove useless #ifndef from acpi_eject_store()
      ACPI: Unbind ACPI drv when probe failed
      ACPI: sysfs eject support for ACPI scan handlers
      ACPI / scan: Follow priorities of IDs when matching scan handlers
      ACPI / PCI: pci_slot: replace printk(KERN_xxx) with pr_xxx()
      ACPI / dock: Fix acpi_bus_get_device() check in drivers/acpi/dock.c
      ACPI / scan: Clean up acpi_bus_get_parent()
      ACPI / platform: Use struct acpi_scan_handler for creating devices
      ACPI / PCI: Make PCI IRQ link driver use struct acpi_scan_handler
      ACPI / PCI: Make PCI root driver use struct acpi_scan_handler
      ACPI / scan: Introduce struct acpi_scan_handler
      ACPI / scan: Make scanning of fixed devices follow the general scheme
      ACPI: Drop device start operation that is not used
      ...

commit 3757b94802fb65d8f696597a74053cf21738da0b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 13 14:36:47 2013 +0100

    ACPI / hotplug: Fix concurrency issues and memory leaks
    
    This changeset is aimed at fixing a few different but related
    problems in the ACPI hotplug infrastructure.
    
    First of all, since notify handlers may be run in parallel with
    acpi_bus_scan(), acpi_bus_trim() and acpi_bus_hot_remove_device()
    and some of them are installed for ACPI handles that have no struct
    acpi_device objects attached (i.e. before those objects are created),
    those notify handlers have to take acpi_scan_lock to prevent races
    from taking place (e.g. a struct acpi_device is found to be present
    for the given ACPI handle, but right after that it is removed by
    acpi_bus_trim() running in parallel to the given notify handler).
    Moreover, since some of them call acpi_bus_scan() and
    acpi_bus_trim(), this leads to the conclusion that acpi_scan_lock
    should be acquired by the callers of these two funtions rather by
    these functions themselves.
    
    For these reasons, make all notify handlers that can handle device
    addition and eject events take acpi_scan_lock and remove the
    acpi_scan_lock locking from acpi_bus_scan() and acpi_bus_trim().
    Accordingly, update all of their users to make sure that they
    are always called under acpi_scan_lock.
    
    Furthermore, since eject operations are carried out asynchronously
    with respect to the notify events that trigger them, with the help
    of acpi_bus_hot_remove_device(), even if notify handlers take the
    ACPI scan lock, it still is possible that, for example,
    acpi_bus_trim() will run between acpi_bus_hot_remove_device() and
    the notify handler that scheduled its execution and that
    acpi_bus_trim() will remove the device node passed to
    acpi_bus_hot_remove_device() for ejection.  In that case, the struct
    acpi_device object obtained by acpi_bus_hot_remove_device() will be
    invalid and not-so-funny things will ensue.  To protect agaist that,
    make the users of acpi_bus_hot_remove_device() run get_device() on
    ACPI device node objects that are about to be passed to it and make
    acpi_bus_hot_remove_device() run put_device() on them and check if
    their ACPI handles are not NULL (make acpi_device_unregister() clear
    the device nodes' ACPI handles for that check to work).
    
    Finally, observe that acpi_os_hotplug_execute() actually can fail,
    in which case its caller ought to free memory allocated for the
    context object to prevent leaks from happening.  It also needs to
    run put_device() on the device node that it ran get_device() on
    previously in that case.  Modify the code accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c7676ee8eca4..d16a94ef0baf 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -42,6 +42,18 @@ struct acpi_device_bus_id{
 	struct list_head node;
 };
 
+void acpi_scan_lock_acquire(void)
+{
+	mutex_lock(&acpi_scan_lock);
+}
+EXPORT_SYMBOL_GPL(acpi_scan_lock_acquire);
+
+void acpi_scan_lock_release(void)
+{
+	mutex_unlock(&acpi_scan_lock);
+}
+EXPORT_SYMBOL_GPL(acpi_scan_lock_release);
+
 int acpi_scan_add_handler(struct acpi_scan_handler *handler)
 {
 	if (!handler || !handler->attach)
@@ -95,8 +107,6 @@ acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, cha
 }
 static DEVICE_ATTR(modalias, 0444, acpi_device_modalias_show, NULL);
 
-static void __acpi_bus_trim(struct acpi_device *start);
-
 /**
  * acpi_bus_hot_remove_device: hot-remove a device and its children
  * @context: struct acpi_eject_event pointer (freed in this func)
@@ -107,7 +117,7 @@ static void __acpi_bus_trim(struct acpi_device *start);
  */
 void acpi_bus_hot_remove_device(void *context)
 {
-	struct acpi_eject_event *ej_event = (struct acpi_eject_event *) context;
+	struct acpi_eject_event *ej_event = context;
 	struct acpi_device *device = ej_event->device;
 	acpi_handle handle = device->handle;
 	acpi_handle temp;
@@ -118,11 +128,19 @@ void acpi_bus_hot_remove_device(void *context)
 
 	mutex_lock(&acpi_scan_lock);
 
+	/* If there is no handle, the device node has been unregistered. */
+	if (!device->handle) {
+		dev_dbg(&device->dev, "ACPI handle missing\n");
+		put_device(&device->dev);
+		goto out;
+	}
+
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 		"Hot-removing device %s...\n", dev_name(&device->dev)));
 
-	__acpi_bus_trim(device);
-	/* Device node has been released. */
+	acpi_bus_trim(device);
+	/* Device node has been unregistered. */
+	put_device(&device->dev);
 	device = NULL;
 
 	if (ACPI_SUCCESS(acpi_get_handle(handle, "_LCK", &temp))) {
@@ -151,6 +169,7 @@ void acpi_bus_hot_remove_device(void *context)
 					  ost_code, NULL);
 	}
 
+ out:
 	mutex_unlock(&acpi_scan_lock);
 	kfree(context);
 	return;
@@ -212,6 +231,7 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 		goto err;
 	}
 
+	get_device(&acpi_device->dev);
 	ej_event->device = acpi_device;
 	if (acpi_device->flags.eject_pending) {
 		/* event originated from ACPI eject notification */
@@ -224,7 +244,11 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 			ej_event->event, ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 	}
 
-	acpi_os_hotplug_execute(acpi_bus_hot_remove_device, (void *)ej_event);
+	status = acpi_os_hotplug_execute(acpi_bus_hot_remove_device, ej_event);
+	if (ACPI_FAILURE(status)) {
+		put_device(&acpi_device->dev);
+		kfree(ej_event);
+	}
 err:
 	return ret;
 }
@@ -779,6 +803,7 @@ static void acpi_device_unregister(struct acpi_device *device)
 	 * no more references.
 	 */
 	acpi_device_set_power(device, ACPI_STATE_D3_COLD);
+	device->handle = NULL;
 	put_device(&device->dev);
 }
 
@@ -1623,14 +1648,14 @@ static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
  * there has been a real error.  There just have been no suitable ACPI objects
  * in the table trunk from which the kernel could create a device and add an
  * appropriate driver.
+ *
+ * Must be called under acpi_scan_lock.
  */
 int acpi_bus_scan(acpi_handle handle)
 {
 	void *device = NULL;
 	int error = 0;
 
-	mutex_lock(&acpi_scan_lock);
-
 	if (ACPI_SUCCESS(acpi_bus_check_add(handle, 0, NULL, &device)))
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
 				    acpi_bus_check_add, NULL, NULL, &device);
@@ -1641,7 +1666,6 @@ int acpi_bus_scan(acpi_handle handle)
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
 				    acpi_bus_device_attach, NULL, NULL, NULL);
 
-	mutex_unlock(&acpi_scan_lock);
 	return error;
 }
 EXPORT_SYMBOL(acpi_bus_scan);
@@ -1678,7 +1702,13 @@ static acpi_status acpi_bus_remove(acpi_handle handle, u32 lvl_not_used,
 	return AE_OK;
 }
 
-static void __acpi_bus_trim(struct acpi_device *start)
+/**
+ * acpi_bus_trim - Remove ACPI device node and all of its descendants
+ * @start: Root of the ACPI device nodes subtree to remove.
+ *
+ * Must be called under acpi_scan_lock.
+ */
+void acpi_bus_trim(struct acpi_device *start)
 {
 	/*
 	 * Execute acpi_bus_device_detach() as a post-order callback to detach
@@ -1695,13 +1725,6 @@ static void __acpi_bus_trim(struct acpi_device *start)
 			    acpi_bus_remove, NULL, NULL);
 	acpi_bus_remove(start->handle, 0, NULL, NULL);
 }
-
-void acpi_bus_trim(struct acpi_device *start)
-{
-	mutex_lock(&acpi_scan_lock);
-	__acpi_bus_trim(start);
-	mutex_unlock(&acpi_scan_lock);
-}
 EXPORT_SYMBOL_GPL(acpi_bus_trim);
 
 static int acpi_bus_scan_fixed(void)
@@ -1758,23 +1781,27 @@ int __init acpi_scan_init(void)
 	acpi_csrt_init();
 	acpi_container_init();
 
+	mutex_lock(&acpi_scan_lock);
 	/*
 	 * Enumerate devices in the ACPI namespace.
 	 */
 	result = acpi_bus_scan(ACPI_ROOT_OBJECT);
 	if (result)
-		return result;
+		goto out;
 
 	result = acpi_bus_get_device(ACPI_ROOT_OBJECT, &acpi_root);
 	if (result)
-		return result;
+		goto out;
 
 	result = acpi_bus_scan_fixed();
 	if (result) {
 		acpi_device_unregister(acpi_root);
-		return result;
+		goto out;
 	}
 
 	acpi_update_all_gpes();
-	return 0;
+
+ out:
+	mutex_unlock(&acpi_scan_lock);
+	return result;
 }

commit 0aa120a0138398d6597350f4c1dcb46d14be1a0b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Feb 9 15:29:20 2013 +0100

    ACPI / scan: Full transition to D3cold in acpi_device_unregister()
    
    In order to drop reference counts of all power resources used by an
    ACPI device node being removed, acpi_device_unregister() calls
    acpi_power_transition(device, ACPI_STATE_D3_COLD), which effectively
    transitions the device node into D3cold if it uses any power
    resources.  However, for some device nodes it may not be appropriate
    to remove power from them entirely before putting them into D3hot
    before.  On the other hand, executing _PS3 for devices that don't
    use power resources before removing them shouldn't really hurt.
    In fact, that is done by acpi_bus_hot_remove_device(), but this is
    not the right place to do it, because the bus trimming may have
    caused power to be removed from the device node in question already
    before.
    
    For these reasons, make acpi_device_unregister() carry out full
    power-off transition for all device nodes supporting that and remove
    the direct evaluation of _PS3 from acpi_bus_hot_remove_device().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 75fb14fc19e8..c7676ee8eca4 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -125,12 +125,6 @@ void acpi_bus_hot_remove_device(void *context)
 	/* Device node has been released. */
 	device = NULL;
 
-	/* power off device */
-	status = acpi_evaluate_object(handle, "_PS3", NULL, NULL);
-	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND)
-		printk(KERN_WARNING PREFIX
-				"Power-off device failed\n");
-
 	if (ACPI_SUCCESS(acpi_get_handle(handle, "_LCK", &temp))) {
 		arg_list.count = 1;
 		arg_list.pointer = &arg;
@@ -780,10 +774,11 @@ static void acpi_device_unregister(struct acpi_device *device)
 
 	device_del(&device->dev);
 	/*
-	 * Drop the reference counts of all power resources the device depends
-	 * on and turn off the ones that have no more references.
+	 * Transition the device to D3cold to drop the reference counts of all
+	 * power resources the device depends on and turn off the ones that have
+	 * no more references.
 	 */
-	acpi_power_transition(device, ACPI_STATE_D3_COLD);
+	acpi_device_set_power(device, ACPI_STATE_D3_COLD);
 	put_device(&device->dev);
 }
 

commit f058cdf4cf3e5181172455f90fc73f2127b6ddf8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Feb 9 15:29:11 2013 +0100

    ACPI / scan: Make acpi_bus_hot_remove_device() acquire the scan lock
    
    The ACPI scan lock has been introduced to prevent acpi_bus_scan()
    and acpi_bus_trim() from running in parallel with each other for
    overlapping ACPI namespace scopes.  However, it is not sufficient
    to do that, because if acpi_bus_scan() is run (for an overlapping
    namespace scope) right after the acpi_bus_trim() in
    acpi_bus_hot_remove_device(), the subsequent eject will remove
    devices without removing the corresponding struct acpi_device
    objects (and possibly companion "physical" device objects).
    Therefore acpi_bus_hot_remove_device() has to acquire the scan
    lock before carrying out the bus trimming and hold it through
    the evaluation of _EJ0, so make that happen.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a48b6e92f9f8..75fb14fc19e8 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -95,6 +95,8 @@ acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, cha
 }
 static DEVICE_ATTR(modalias, 0444, acpi_device_modalias_show, NULL);
 
+static void __acpi_bus_trim(struct acpi_device *start);
+
 /**
  * acpi_bus_hot_remove_device: hot-remove a device and its children
  * @context: struct acpi_eject_event pointer (freed in this func)
@@ -114,10 +116,12 @@ void acpi_bus_hot_remove_device(void *context)
 	acpi_status status = AE_OK;
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE; /* default */
 
+	mutex_lock(&acpi_scan_lock);
+
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 		"Hot-removing device %s...\n", dev_name(&device->dev)));
 
-	acpi_bus_trim(device);
+	__acpi_bus_trim(device);
 	/* Device node has been released. */
 	device = NULL;
 
@@ -146,18 +150,14 @@ void acpi_bus_hot_remove_device(void *context)
 	status = acpi_evaluate_object(handle, "_EJ0", &arg_list, NULL);
 	if (ACPI_FAILURE(status)) {
 		if (status != AE_NOT_FOUND)
-			printk(KERN_WARNING PREFIX
-					"Eject device failed\n");
-		goto err_out;
-	}
+			acpi_handle_warn(handle, "Eject failed\n");
 
-	kfree(context);
-	return;
+		/* Tell the firmware the hot-remove operation has failed. */
+		acpi_evaluate_hotplug_ost(handle, ej_event->event,
+					  ost_code, NULL);
+	}
 
-err_out:
-	/* Inform firmware the hot-remove operation has completed w/ error */
-	(void) acpi_evaluate_hotplug_ost(handle,
-				ej_event->event, ost_code, NULL);
+	mutex_unlock(&acpi_scan_lock);
 	kfree(context);
 	return;
 }
@@ -1683,10 +1683,8 @@ static acpi_status acpi_bus_remove(acpi_handle handle, u32 lvl_not_used,
 	return AE_OK;
 }
 
-void acpi_bus_trim(struct acpi_device *start)
+static void __acpi_bus_trim(struct acpi_device *start)
 {
-	mutex_lock(&acpi_scan_lock);
-
 	/*
 	 * Execute acpi_bus_device_detach() as a post-order callback to detach
 	 * all ACPI drivers from the device nodes being removed.
@@ -1701,7 +1699,12 @@ void acpi_bus_trim(struct acpi_device *start)
 	acpi_walk_namespace(ACPI_TYPE_ANY, start->handle, ACPI_UINT32_MAX, NULL,
 			    acpi_bus_remove, NULL, NULL);
 	acpi_bus_remove(start->handle, 0, NULL, NULL);
+}
 
+void acpi_bus_trim(struct acpi_device *start)
+{
+	mutex_lock(&acpi_scan_lock);
+	__acpi_bus_trim(start);
 	mutex_unlock(&acpi_scan_lock);
 }
 EXPORT_SYMBOL_GPL(acpi_bus_trim);

commit 737f1a9f808280c481681b1f46254fd67023ec2f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 8 23:52:39 2013 +0100

    ACPI / scan: Make container driver use struct acpi_scan_handler
    
    Make the ACPI container driver use struct acpi_scan_handler for
    representing the object used to initialize ACPI containers and remove
    the ACPI driver structure used previously and the data structures
    created by it, since in fact they were not used for any purpose.
    
    This simplifies the code and reduces the kernel's memory footprint by
    avoiding the registration of a struct device_driver object with the
    driver core and creation of its sysfs directory which is unnecessary.
    
    In addition to that, make the namespace walk callback used for
    installing the notify handlers for ACPI containers more
    straightforward.
    
    This change includes fixes from Toshi Kani.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Tested-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Reviewed-by: Toshi Kani <toshi.kani@hp.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5bc2641fba8a..a48b6e92f9f8 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1758,6 +1758,7 @@ int __init acpi_scan_init(void)
 	acpi_pci_link_init();
 	acpi_platform_init();
 	acpi_csrt_init();
+	acpi_container_init();
 
 	/*
 	 * Enumerate devices in the ACPI namespace.

commit 38475b3be1517a16d263b0b04dae862bf7027d48
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 8 23:52:23 2013 +0100

    ACPI / scan: Remove useless #ifndef from acpi_eject_store()
    
    Since the FORCE_EJECT symbol is never defined, the
    #ifndef FORCE_EJECT in acpi_eject_store() is always true, so drop it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Tested-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Reviewed-by: Toshi Kani <toshi.kani@hp.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index bf6e2c26f52d..5bc2641fba8a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -202,12 +202,10 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 	if ((!count) || (buf[0] != '1')) {
 		return -EINVAL;
 	}
-#ifndef FORCE_EJECT
 	if (!acpi_device->driver && !acpi_device->handler) {
 		ret = -ENODEV;
 		goto err;
 	}
-#endif
 	status = acpi_get_type(acpi_device->handle, &type);
 	if (ACPI_FAILURE(status) || (!acpi_device->flags.ejectable)) {
 		ret = -ENODEV;

commit 5f27ee8e1261e47ec2e9dbebf17e87e55f568d75
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Thu Feb 7 21:19:13 2013 +0000

    ACPI: Unbind ACPI drv when probe failed
    
    When acpi_device_install_notify_handler() failed in acpi_device_probe(),
    it calls acpi_drv->ops.remove() and fails the probe.  However, the ACPI
    driver is left bound to the acpi_device.  Fix it by clearing the driver
    and driver_data fields.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 95547efcffe0..bf6e2c26f52d 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -627,6 +627,8 @@ static int acpi_device_probe(struct device * dev)
 			if (ret) {
 				if (acpi_drv->ops.remove)
 					acpi_drv->ops.remove(acpi_dev);
+				acpi_dev->driver = NULL;
+				acpi_dev->driver_data = NULL;
 				return ret;
 			}
 		}

commit ce7685ad764f070a9234df6a12a17eb92471d126
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Thu Feb 7 12:50:53 2013 +0100

    ACPI: sysfs eject support for ACPI scan handlers
    
    Changed sysfs eject, acpi_eject_store(), so that it doesn't return
    error codes for devices nodes with ACPI scan handlers attached and
    no ACPI drivers.
    
    [rjw: Changelog]
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 688b7f7c23dd..95547efcffe0 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -203,7 +203,7 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 		return -EINVAL;
 	}
 #ifndef FORCE_EJECT
-	if (acpi_device->driver == NULL) {
+	if (!acpi_device->driver && !acpi_device->handler) {
 		ret = -ENODEV;
 		goto err;
 	}

commit 87b85b3c8a4ac286d41a1c6419014b7562e4663b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 6 13:05:22 2013 +0100

    ACPI / scan: Follow priorities of IDs when matching scan handlers
    
    The IDs of ACPI device nodes stored in their pnp.ids member arrays
    are sorted by decreasing priority (i.e. the highest-priority ID is
    the first entry).  This means that when matching scan handlers to
    device nodes, the namespace scanning code should walk the list of
    scan handlers for each device node ID instead of walking the list
    of device node IDs for each handler (the latter causes the first
    handler matching any of the device node IDs to be chosen, although
    there may be another handler matching an ID of a higher priority
    which should be preferred).  Make the code follow this observation.
    
    This change has been suggested and justified by Toshi Kani.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 360f1338749b..688b7f7c23dd 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1553,26 +1553,42 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 	return AE_OK;
 }
 
-static int acpi_scan_attach_handler(struct acpi_device *device)
+static int acpi_scan_do_attach_handler(struct acpi_device *device, char *id)
 {
 	struct acpi_scan_handler *handler;
-	int ret = 0;
 
 	list_for_each_entry(handler, &acpi_scan_handlers_list, list_node) {
-		const struct acpi_device_id *id;
+		const struct acpi_device_id *devid;
 
-		id = __acpi_match_device(device, handler->ids);
-		if (!id)
-			continue;
+		for (devid = handler->ids; devid->id[0]; devid++) {
+			int ret;
 
-		ret = handler->attach(device, id);
-		if (ret > 0) {
-			device->handler = handler;
-			break;
-		} else if (ret < 0) {
-			break;
+			if (strcmp((char *)devid->id, id))
+				continue;
+
+			ret = handler->attach(device, devid);
+			if (ret > 0) {
+				device->handler = handler;
+				return ret;
+			} else if (ret < 0) {
+				return ret;
+			}
 		}
 	}
+	return 0;
+}
+
+static int acpi_scan_attach_handler(struct acpi_device *device)
+{
+	struct acpi_hardware_id *hwid;
+	int ret = 0;
+
+	list_for_each_entry(hwid, &device->pnp.ids, list) {
+		ret = acpi_scan_do_attach_handler(device, hwid->id);
+		if (ret)
+			break;
+
+	}
 	return ret;
 }
 

commit 17b1639b30e080dc577cbffe7a08d063708ec789
Merge: a9834cb205bf e375325ce55e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Feb 11 13:21:27 2013 +0100

    Merge branch 'acpi-lpss'
    
    * acpi-lpss:
      ACPI / platform: create LPSS clocks if Lynxpoint devices are found during scan
      clk: x86: add support for Lynxpoint LPSS clocks
      x86: add support for Intel Low Power Subsystem
      ACPI / platform: fix comment about the platform device name
      ACPI: add support for CSRT table

commit a9834cb205bf0d2b52da7f603f43b62a09f503b7
Merge: 48694bdb3876 511d5c421294
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Feb 11 13:20:56 2013 +0100

    Merge branch 'acpi-pm'
    
    * acpi-pm: (35 commits)
      ACPI / PM: Handle missing _PSC in acpi_bus_update_power()
      ACPI / PM: Do not power manage devices in unknown initial states
      ACPI / PM: Fix acpi_bus_get_device() check in drivers/acpi/device_pm.c
      ACPI / PM: Fix /proc/acpi/wakeup for devices w/o bus or parent
      ACPI / PM: Fix consistency check for power resources during resume
      ACPI / PM: Expose lists of device power resources to user space
      sysfs: Functions for adding/removing symlinks to/from attribute groups
      ACPI / PM: Expose current status of ACPI power resources
      ACPI / PM: Expose power states of ACPI devices to user space
      ACPI / scan: Prevent device add uevents from racing with user space
      ACPI / PM: Fix device power state value after transitions to D3cold
      ACPI / PM: Use string "D3cold" to represent ACPI_STATE_D3_COLD
      ACPI / PM: Sanitize checks in acpi_power_on_resources()
      ACPI / PM: Always evaluate _PSn after setting power resources
      ACPI / PM: Introduce helper for executing _PSn methods
      ACPI / PM: Make acpi_bus_init_power() more robust
      ACPI / PM: Fix build for unusual combination of Kconfig options
      ACPI / PM: remove leading whitespace from #ifdef
      ACPI / PM: Consolidate suspend-specific and hibernate-specific code
      ACPI / PM: Move device power management functions to device_pm.c
      ...

commit 59893298947e0ca28cbaba6d02b9973181f14eea
Merge: 836dc9e3fbba 0613e1f7fd98
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Feb 11 13:20:02 2013 +0100

    Merge branch 'acpi-scan'
    
    * acpi-scan: (30 commits)
      ACPI / scan: Fix acpi_bus_get_device() check in acpi_match_device()
      ACPI / scan: Make namespace scanning and trimming mutually exclusive
      ACPI / scan: Make it clear that acpi_bus_trim() cannot fail
      ACPI / scan: Drop acpi_bus_add() and use acpi_bus_scan() instead
      ACPI: update ej_event interface to take acpi_device
      ACPI / scan: Add second pass to acpi_bus_trim()
      ACPI / scan: Change the implementation of acpi_bus_trim()
      ACPI / scan: Drop the second argument of acpi_bus_trim()
      ACPI / scan: Drop the second argument of acpi_device_unregister()
      ACPI: Remove the ops field from struct acpi_device
      ACPI: remove unused acpi_op_bind and acpi_op_unbind
      ACPI / scan: Fix check of device_attach() return value.
      ACPI / scan: Treat power resources in a special way
      ACPI: Remove unused struct acpi_pci_root.id member
      ACPI: Drop ACPI device .bind() and .unbind() callbacks
      ACPI / PCI: Move the _PRT setup and cleanup code to pci-acpi.c
      ACPI / PCI: Rework the setup and cleanup of device wakeup
      ACPI: Add .setup() and .cleanup() callbacks to struct acpi_bus_type
      ACPI: Make acpi_bus_scan() and acpi_bus_add() take only one argument
      ACPI: Replace ACPI device add_type field with a match_driver flag
      ...

commit b3785492268f9f3cdaa9722facb84b266dcf8bf6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 1 23:43:02 2013 +0100

    ACPI / PM: Do not power manage devices in unknown initial states
    
    In general, for ACPI device power management to work, the initial
    power states of devices must be known (otherwise, we wouldn't be able
    to keep track of power resources, for example).  Hence, if it is
    impossible to determine the initial ACPI power states of some
    devices, they can't be regarded as power-manageable using ACPI.
    
    For this reason, modify acpi_bus_get_power_flags() to clear the
    power_manageable flag if acpi_bus_init_power() fails and add some
    extra fallback code to acpi_bus_init_power() to cover broken
    BIOSes that provide _PS0/_PS3 without _PSC for some devices.
    
    Verified to work on my HP nx6325 that has this problem.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Peter Wu <lekensteyn@gmail.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 9801837876b7..f75f25c2e455 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1180,7 +1180,10 @@ static void acpi_bus_get_power_flags(struct acpi_device *device)
 			device->power.flags.power_resources)
 		device->power.states[ACPI_STATE_D3_COLD].flags.os_accessible = 1;
 
-	acpi_bus_init_power(device);
+	if (acpi_bus_init_power(device)) {
+		acpi_free_power_resources_lists(device);
+		device->flags.power_manageable = 0;
+	}
 }
 
 static void acpi_bus_get_flags(struct acpi_device *device)

commit 456de893ea1a693dc266c5464a6d857bfed0875f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 31 20:57:40 2013 +0100

    ACPI / scan: Clean up acpi_bus_get_parent()
    
    Make acpi_bus_get_parent() more straightforward and remove an
    unnecessary local variable ret from it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a849d2430dff..360f1338749b 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -871,29 +871,23 @@ EXPORT_SYMBOL(acpi_bus_unregister_driver);
    -------------------------------------------------------------------------- */
 static struct acpi_device *acpi_bus_get_parent(acpi_handle handle)
 {
+	struct acpi_device *device = NULL;
 	acpi_status status;
-	int ret;
-	struct acpi_device *device;
 
 	/*
 	 * Fixed hardware devices do not appear in the namespace and do not
 	 * have handles, but we fabricate acpi_devices for them, so we have
 	 * to deal with them specially.
 	 */
-	if (handle == NULL)
+	if (!handle)
 		return acpi_root;
 
 	do {
 		status = acpi_get_parent(handle, &handle);
-		if (status == AE_NULL_ENTRY)
-			return NULL;
 		if (ACPI_FAILURE(status))
-			return acpi_root;
-
-		ret = acpi_bus_get_device(handle, &device);
-		if (ret == 0)
-			return device;
-	} while (1);
+			return status == AE_NULL_ENTRY ? NULL : acpi_root;
+	} while (acpi_bus_get_device(handle, &device));
+	return device;
 }
 
 acpi_status

commit 0613e1f7fd98a0cef2a7add1368a87cdd86a1106
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 31 20:54:05 2013 +0100

    ACPI / scan: Fix acpi_bus_get_device() check in acpi_match_device()
    
    Since acpi_bus_get_device() returns int and not acpi_status, change
    acpi_match_device() so that it doesn't apply ACPI_FAILURE() to the
    return value of acpi_bus_get_device().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 43754655c156..a4224727f09c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -444,9 +444,9 @@ const struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,
 					       const struct device *dev)
 {
 	struct acpi_device *adev;
+	acpi_handle handle = ACPI_HANDLE(dev);
 
-	if (!ids || !ACPI_HANDLE(dev)
-	    || ACPI_FAILURE(acpi_bus_get_device(ACPI_HANDLE(dev), &adev)))
+	if (!ids || !handle || acpi_bus_get_device(handle, &adev))
 		return NULL;
 
 	return __acpi_match_device(adev, ids);

commit 141a297bd02e8ddc5ab625cc3a1a5926b1ff929a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 30 14:27:40 2013 +0100

    ACPI / platform: Use struct acpi_scan_handler for creating devices
    
    Currently, the ACPI namespace scanning code creates platform device
    objects for ACPI device nodes whose IDs match the contents of the
    acpi_platform_device_ids[] table.  However, this adds a superfluous
    special case into acpi_bus_device_attach() and makes it more
    difficult to follow than it has to be.  It also will make it more
    difficult to implement removal code for those platform device objects
    in the future.
    
    For the above reasons, introduce a struct acpi_scan_handler object
    for creating platform devices and move the code related to that from
    acpi_bus_device_attach() to the .attach() callback of that object.
    Also move the acpi_platform_device_ids[] table to acpi_platform.c.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c2821699bc49..a849d2430dff 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -29,27 +29,6 @@ extern struct acpi_device *acpi_root;
 
 static const char *dummy_hid = "device";
 
-/*
- * The following ACPI IDs are known to be suitable for representing as
- * platform devices.
- */
-static const struct acpi_device_id acpi_platform_device_ids[] = {
-
-	{ "PNP0D40" },
-
-	/* Haswell LPSS devices */
-	{ "INT33C0", ACPI_PLATFORM_CLK },
-	{ "INT33C1", ACPI_PLATFORM_CLK },
-	{ "INT33C2", ACPI_PLATFORM_CLK },
-	{ "INT33C3", ACPI_PLATFORM_CLK },
-	{ "INT33C4", ACPI_PLATFORM_CLK },
-	{ "INT33C5", ACPI_PLATFORM_CLK },
-	{ "INT33C6", ACPI_PLATFORM_CLK },
-	{ "INT33C7", ACPI_PLATFORM_CLK },
-
-	{ }
-};
-
 static LIST_HEAD(acpi_device_list);
 static LIST_HEAD(acpi_bus_id_list);
 static DEFINE_MUTEX(acpi_scan_lock);
@@ -1606,7 +1585,6 @@ static int acpi_scan_attach_handler(struct acpi_device *device)
 static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 					  void *not_used, void **ret_not_used)
 {
-	const struct acpi_device_id *id;
 	struct acpi_device *device;
 	unsigned long long sta_not_used;
 	int ret;
@@ -1621,13 +1599,6 @@ static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 	if (acpi_bus_get_device(handle, &device))
 		return AE_CTRL_DEPTH;
 
-	id = __acpi_match_device(device, acpi_platform_device_ids);
-	if (id) {
-		/* This is a known good platform device. */
-		acpi_create_platform_device(device, id->driver_data);
-		return AE_OK;
-	}
-
 	ret = acpi_scan_attach_handler(device);
 	if (ret)
 		return ret > 0 ? AE_OK : AE_CTRL_DEPTH;
@@ -1775,6 +1746,7 @@ int __init acpi_scan_init(void)
 
 	acpi_pci_root_init();
 	acpi_pci_link_init();
+	acpi_platform_init();
 	acpi_csrt_init();
 
 	/*

commit 4daeaf68379f75dedd120582add5206c7c5ad72e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 30 14:27:37 2013 +0100

    ACPI / PCI: Make PCI IRQ link driver use struct acpi_scan_handler
    
    Make the ACPI PCI IRQ link driver use struct acpi_scan_handler
    for representing the object used to set up ACPI interrupt links and
    to remove data structures used for this purpose before unregistering
    the corresponding ACPI device nodes.
    
    This simplifies the code slightly and reduces the kernel's memory
    footprint by avoiding the registration of a struct device_driver
    object with the driver core and creation of its sysfs directory
    which is unnecessary.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 1453cd0672fb..c2821699bc49 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1774,6 +1774,7 @@ int __init acpi_scan_init(void)
 	}
 
 	acpi_pci_root_init();
+	acpi_pci_link_init();
 	acpi_csrt_init();
 
 	/*

commit ca589f9469641916f4f9bd6a820012a27102ef63
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 30 14:27:29 2013 +0100

    ACPI / scan: Introduce struct acpi_scan_handler
    
    Introduce struct acpi_scan_handler for representing objects that
    will do configuration tasks depending on ACPI device nodes'
    hardware IDs (HIDs).
    
    Currently, those tasks are done either directly by the ACPI namespace
    scanning code or by ACPI device drivers designed specifically for
    this purpose.  None of the above is desirable, however, because
    doing that directly in the namespace scanning code makes that code
    overly complicated and difficult to follow and doing that in
    "special" device drivers leads to a great deal of confusion about
    their role and to confusing interactions with the driver core (for
    example, sysfs directories are created for those drivers, but they
    are completely unnecessary and only increase the kernel's memory
    footprint in vain).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index fe9f2c926663..1453cd0672fb 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -53,6 +53,7 @@ static const struct acpi_device_id acpi_platform_device_ids[] = {
 static LIST_HEAD(acpi_device_list);
 static LIST_HEAD(acpi_bus_id_list);
 static DEFINE_MUTEX(acpi_scan_lock);
+static LIST_HEAD(acpi_scan_handlers_list);
 DEFINE_MUTEX(acpi_device_lock);
 LIST_HEAD(acpi_wakeup_device_list);
 
@@ -62,6 +63,15 @@ struct acpi_device_bus_id{
 	struct list_head node;
 };
 
+int acpi_scan_add_handler(struct acpi_scan_handler *handler)
+{
+	if (!handler || !handler->attach)
+		return -EINVAL;
+
+	list_add_tail(&handler->list_node, &acpi_scan_handlers_list);
+	return 0;
+}
+
 /*
  * Creates hid/cid(s) string needed for modalias and uevent
  * e.g. on a device with hid:IBM0001 and cid:ACPI0001 you get:
@@ -1570,20 +1580,42 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 	return AE_OK;
 }
 
+static int acpi_scan_attach_handler(struct acpi_device *device)
+{
+	struct acpi_scan_handler *handler;
+	int ret = 0;
+
+	list_for_each_entry(handler, &acpi_scan_handlers_list, list_node) {
+		const struct acpi_device_id *id;
+
+		id = __acpi_match_device(device, handler->ids);
+		if (!id)
+			continue;
+
+		ret = handler->attach(device, id);
+		if (ret > 0) {
+			device->handler = handler;
+			break;
+		} else if (ret < 0) {
+			break;
+		}
+	}
+	return ret;
+}
+
 static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 					  void *not_used, void **ret_not_used)
 {
 	const struct acpi_device_id *id;
-	acpi_status status = AE_OK;
 	struct acpi_device *device;
 	unsigned long long sta_not_used;
-	int type_not_used;
+	int ret;
 
 	/*
 	 * Ignore errors ignored by acpi_bus_check_add() to avoid terminating
 	 * namespace walks prematurely.
 	 */
-	if (acpi_bus_type_and_status(handle, &type_not_used, &sta_not_used))
+	if (acpi_bus_type_and_status(handle, &ret, &sta_not_used))
 		return AE_OK;
 
 	if (acpi_bus_get_device(handle, &device))
@@ -1593,10 +1625,15 @@ static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 	if (id) {
 		/* This is a known good platform device. */
 		acpi_create_platform_device(device, id->driver_data);
-	} else if (device_attach(&device->dev) < 0) {
-		status = AE_CTRL_DEPTH;
+		return AE_OK;
 	}
-	return status;
+
+	ret = acpi_scan_attach_handler(device);
+	if (ret)
+		return ret > 0 ? AE_OK : AE_CTRL_DEPTH;
+
+	ret = device_attach(&device->dev);
+	return ret >= 0 ? AE_OK : AE_CTRL_DEPTH;
 }
 
 /**
@@ -1639,8 +1676,17 @@ static acpi_status acpi_bus_device_detach(acpi_handle handle, u32 lvl_not_used,
 	struct acpi_device *device = NULL;
 
 	if (!acpi_bus_get_device(handle, &device)) {
+		struct acpi_scan_handler *dev_handler = device->handler;
+
 		device->removal_type = ACPI_BUS_REMOVAL_EJECT;
-		device_release_driver(&device->dev);
+		if (dev_handler) {
+			if (dev_handler->detach)
+				dev_handler->detach(device);
+
+			device->handler = NULL;
+		} else {
+			device_release_driver(&device->dev);
+		}
 	}
 	return AE_OK;
 }

commit 8b4e2fa4ff72ba2c9f01af8def15d4c4eeeeed64
Merge: 64e94e7e0ffb e375325ce55e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 29 13:59:00 2013 +0100

    Merge branch 'acpi-lpss' into acpi-cleanup
    
    The following commits depend on the 'acpi-lpss' material.

commit 64e94e7e0ffb20ee11a596aa04fcdeefb33e000d
Merge: 2c0d4fe0189a c511cc1990bb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 29 13:58:34 2013 +0100

    Merge branch 'acpi-scan' into acpi-cleanup
    
    The following commits depend on the 'acpi-scan' material.

commit 2c0d4fe0189ae5e29fd9602d5b83f3b2b169bd1b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 29 13:57:20 2013 +0100

    ACPI / scan: Make scanning of fixed devices follow the general scheme
    
    Make acpi_bus_scan_fixed() use device_attach() directly to attach
    drivers, if any, to the fixed devices in analogy with how
    acpi_bus_scan() works, which allows the last argument of
    acpi_add_single_object() to be dropped and the manipulation of the
    flags.match_driver bit to be moved to acpi_init_device_object()
    and acpi_device_add_finalize().
    
    After these changes all of the functions for the initialization
    and registration of struct acpi_device objects work in the same
    way for all of them.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a4a2595b6d88..b206ce5e1faf 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1441,19 +1441,21 @@ void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 	acpi_device_get_busid(device);
 	acpi_device_set_id(device);
 	acpi_bus_get_flags(device);
+	device->flags.match_driver = false;
 	device_initialize(&device->dev);
 	dev_set_uevent_suppress(&device->dev, true);
 }
 
 void acpi_device_add_finalize(struct acpi_device *device)
 {
+	device->flags.match_driver = true;
 	dev_set_uevent_suppress(&device->dev, false);
 	kobject_uevent(&device->dev.kobj, KOBJ_ADD);
 }
 
 static int acpi_add_single_object(struct acpi_device **child,
 				  acpi_handle handle, int type,
-				  unsigned long long sta, bool match_driver)
+				  unsigned long long sta)
 {
 	int result;
 	struct acpi_device *device;
@@ -1469,7 +1471,6 @@ static int acpi_add_single_object(struct acpi_device **child,
 	acpi_bus_get_power_flags(device);
 	acpi_bus_get_wakeup_device_flags(device);
 
-	device->flags.match_driver = match_driver;
 	result = acpi_device_add(device, acpi_device_release);
 	if (result) {
 		acpi_device_release(&device->dev);
@@ -1562,12 +1563,10 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 		return AE_CTRL_DEPTH;
 	}
 
-	acpi_add_single_object(&device, handle, type, sta, false);
+	acpi_add_single_object(&device, handle, type, sta);
 	if (!device)
 		return AE_CTRL_DEPTH;
 
-	device->flags.match_driver = true;
-
  out:
 	if (!*return_value)
 		*return_value = device;
@@ -1679,25 +1678,39 @@ EXPORT_SYMBOL_GPL(acpi_bus_trim);
 static int acpi_bus_scan_fixed(void)
 {
 	int result = 0;
-	struct acpi_device *device = NULL;
 
 	/*
 	 * Enumerate all fixed-feature devices.
 	 */
-	if ((acpi_gbl_FADT.flags & ACPI_FADT_POWER_BUTTON) == 0) {
+	if (!(acpi_gbl_FADT.flags & ACPI_FADT_POWER_BUTTON)) {
+		struct acpi_device *device = NULL;
+
 		result = acpi_add_single_object(&device, NULL,
 						ACPI_BUS_TYPE_POWER_BUTTON,
-						ACPI_STA_DEFAULT, true);
+						ACPI_STA_DEFAULT);
+		if (result)
+			return result;
+
+		result = device_attach(&device->dev);
+		if (result < 0)
+			return result;
+
 		device_init_wakeup(&device->dev, true);
 	}
 
-	if ((acpi_gbl_FADT.flags & ACPI_FADT_SLEEP_BUTTON) == 0) {
+	if (!(acpi_gbl_FADT.flags & ACPI_FADT_SLEEP_BUTTON)) {
+		struct acpi_device *device = NULL;
+
 		result = acpi_add_single_object(&device, NULL,
 						ACPI_BUS_TYPE_SLEEP_BUTTON,
-						ACPI_STA_DEFAULT, true);
+						ACPI_STA_DEFAULT);
+		if (result)
+			return result;
+
+		result = device_attach(&device->dev);
 	}
 
-	return result;
+	return result < 0 ? result : 0;
 }
 
 int __init acpi_scan_init(void)

commit 8a78cf70fae587b0691b4b982bc69c1261e05e76
Merge: 09212fddc866 65ab96f60621
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 29 13:56:05 2013 +0100

    Merge branch 'acpi-pm' into acpi-cleanup
    
    The following commits depend on the 'acpi-pm' material.

commit c511cc1990bbc263c3f8a2ef4d7d613a3b40ffe2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 27 21:17:29 2013 +0100

    ACPI / scan: Make namespace scanning and trimming mutually exclusive
    
    There is no guarantee that acpi_bus_scan() and acpi_bus_trim() will
    not be run in parallel for the same scope of the ACPI namespace,
    which may lead to a great deal of confusion, so introduce a new mutex
    to prevent that from happening.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d37f290be44c..43754655c156 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -52,6 +52,7 @@ static const struct acpi_device_id acpi_platform_device_ids[] = {
 
 static LIST_HEAD(acpi_device_list);
 static LIST_HEAD(acpi_bus_id_list);
+static DEFINE_MUTEX(acpi_scan_lock);
 DEFINE_MUTEX(acpi_device_lock);
 LIST_HEAD(acpi_wakeup_device_list);
 
@@ -1587,19 +1588,22 @@ static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 int acpi_bus_scan(acpi_handle handle)
 {
 	void *device = NULL;
+	int error = 0;
+
+	mutex_lock(&acpi_scan_lock);
 
 	if (ACPI_SUCCESS(acpi_bus_check_add(handle, 0, NULL, &device)))
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
 				    acpi_bus_check_add, NULL, NULL, &device);
 
 	if (!device)
-		return -ENODEV;
-
-	if (ACPI_SUCCESS(acpi_bus_device_attach(handle, 0, NULL, NULL)))
+		error = -ENODEV;
+	else if (ACPI_SUCCESS(acpi_bus_device_attach(handle, 0, NULL, NULL)))
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
 				    acpi_bus_device_attach, NULL, NULL, NULL);
 
-	return 0;
+	mutex_unlock(&acpi_scan_lock);
+	return error;
 }
 EXPORT_SYMBOL(acpi_bus_scan);
 
@@ -1628,6 +1632,8 @@ static acpi_status acpi_bus_remove(acpi_handle handle, u32 lvl_not_used,
 
 void acpi_bus_trim(struct acpi_device *start)
 {
+	mutex_lock(&acpi_scan_lock);
+
 	/*
 	 * Execute acpi_bus_device_detach() as a post-order callback to detach
 	 * all ACPI drivers from the device nodes being removed.
@@ -1642,6 +1648,8 @@ void acpi_bus_trim(struct acpi_device *start)
 	acpi_walk_namespace(ACPI_TYPE_ANY, start->handle, ACPI_UINT32_MAX, NULL,
 			    acpi_bus_remove, NULL, NULL);
 	acpi_bus_remove(start->handle, 0, NULL, NULL);
+
+	mutex_unlock(&acpi_scan_lock);
 }
 EXPORT_SYMBOL_GPL(acpi_bus_trim);
 

commit 51fac8388a0325a43f0ae67453ece2c373e2ec28
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 24 00:24:48 2013 +0100

    ACPI: Remove useless type argument of driver .remove() operation
    
    The second argument of ACPI driver .remove() operation is only used
    by the ACPI processor driver and the value passed to that driver
    through it is always available from the given struct acpi_device
    object's removal_type field.  For this reason, the second ACPI driver
    .remove() argument is in fact useless, so drop it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Jiang Liu <jiang.liu@huawei.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index bc8077f173da..0989b323e65f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -577,8 +577,7 @@ static int acpi_device_probe(struct device * dev)
 			ret = acpi_device_install_notify_handler(acpi_dev);
 			if (ret) {
 				if (acpi_drv->ops.remove)
-					acpi_drv->ops.remove(acpi_dev,
-						     acpi_dev->removal_type);
+					acpi_drv->ops.remove(acpi_dev);
 				return ret;
 			}
 		}
@@ -600,7 +599,7 @@ static int acpi_device_remove(struct device * dev)
 		if (acpi_drv->ops.notify)
 			acpi_device_remove_notify_handler(acpi_dev);
 		if (acpi_drv->ops.remove)
-			acpi_drv->ops.remove(acpi_dev, acpi_dev->removal_type);
+			acpi_drv->ops.remove(acpi_dev);
 	}
 	acpi_dev->driver = NULL;
 	acpi_dev->driver_data = NULL;

commit cc38e519132f62d52db0a04d2eaed0d7c52fb165
Merge: 949db153b646 b8bd759acd05
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jan 26 00:36:44 2013 +0100

    Merge branch 'acpi-scan' into acpi-cleanup
    
    The following commits depend on the 'acpi-scan' material.

commit bfee26dba0f373ebe4e6f0b293d078b02f9f7f69
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jan 26 00:27:44 2013 +0100

    ACPI / scan: Make it clear that acpi_bus_trim() cannot fail
    
    Since acpi_bus_trim() cannot fail, change its definition to a void
    function, so that its callers don't check the return value in vain
    and update the callers.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 7c43bdc36abc..d37f290be44c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -127,13 +127,8 @@ void acpi_bus_hot_remove_device(void *context)
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 		"Hot-removing device %s...\n", dev_name(&device->dev)));
 
-	if (acpi_bus_trim(device)) {
-		printk(KERN_ERR PREFIX
-				"Removing device failed\n");
-		goto err_out;
-	}
-
-	/* device has been freed */
+	acpi_bus_trim(device);
+	/* Device node has been released. */
 	device = NULL;
 
 	/* power off device */
@@ -1631,7 +1626,7 @@ static acpi_status acpi_bus_remove(acpi_handle handle, u32 lvl_not_used,
 	return AE_OK;
 }
 
-int acpi_bus_trim(struct acpi_device *start)
+void acpi_bus_trim(struct acpi_device *start)
 {
 	/*
 	 * Execute acpi_bus_device_detach() as a post-order callback to detach
@@ -1647,7 +1642,6 @@ int acpi_bus_trim(struct acpi_device *start)
 	acpi_walk_namespace(ACPI_TYPE_ANY, start->handle, ACPI_UINT32_MAX, NULL,
 			    acpi_bus_remove, NULL, NULL);
 	acpi_bus_remove(start->handle, 0, NULL, NULL);
-	return 0;
 }
 EXPORT_SYMBOL_GPL(acpi_bus_trim);
 

commit 668192b678201d2fff27c6cc76bb003c1ec4a52a
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jan 21 13:20:48 2013 -0800

    PCI: acpiphp: Move host bridge hotplug to pci_root.c
    
    The acpiphp driver is confusing because it contains partial support for PCI
    host bridge hotplug as well as support for hotplug of PCI devices.
    
    This patch moves the host bridge hot-add support to pci_root.c and adds
    hot-remove support in pci_root.c.
    
    How to test it: if sci_emu patch is applied, find out root bus number to
    ACPI root name mapping from dmesg or /sys.  To remove root bus:
    
      echo "\_SB.PCIB 3" > /sys/kernel/debug/acpi/sci_notify
    
    To add back root bus:
    
      echo "\_SB.PCIB 1" > /sys/kernel/debug/acpi/sci_notify
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 7c43bdc36abc..bc2f33790e83 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1706,5 +1706,8 @@ int __init acpi_scan_init(void)
 	}
 
 	acpi_update_all_gpes();
+
+	acpi_pci_root_hp_init();
+
 	return 0;
 }

commit b1c0f99bfb89cd9b42e3119ab822a8102fa87909
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 24 12:50:09 2013 +0100

    ACPI / PM: Expose current status of ACPI power resources
    
    Since ACPI power resources are going to be used more extensively on
    new hardware platforms, it becomes necessary for user space (powertop
    in particular) to observe some properties of those resources for
    diagnostics purposes.
    
    For this reason, expose the current status of each ACPI power
    resource to user space via sysfs by adding a new resource_in_use
    attribute to the sysfs directory representing the given power
    resource.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 9761d589f3f5..9801837876b7 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -791,6 +791,9 @@ static void acpi_device_unregister(struct acpi_device *device)
 
 	acpi_power_add_remove_device(device, false);
 	acpi_device_remove_files(device);
+	if (device->remove)
+		device->remove(device);
+
 	device_del(&device->dev);
 	/*
 	 * Drop the reference counts of all power resources the device depends

commit 836aedb1414d4724b2ec68dd19810960c593720c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 24 12:49:59 2013 +0100

    ACPI / PM: Expose power states of ACPI devices to user space
    
    Make it possible to retrieve the current power state of a device with
    ACPI power management from user space via sysfs by adding two new
    attributes, power_state and real_power_state, to the sysfs directory
    associated with the struct acpi_device object representing the
    device's ACPI node.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8b3b18846c8c..9761d589f3f5 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -178,6 +178,32 @@ void acpi_bus_hot_remove_device(void *context)
 }
 EXPORT_SYMBOL(acpi_bus_hot_remove_device);
 
+static ssize_t real_power_state_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct acpi_device *adev = to_acpi_device(dev);
+	int state;
+	int ret;
+
+	ret = acpi_device_get_power(adev, &state);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "%s\n", acpi_power_state_string(state));
+}
+
+static DEVICE_ATTR(real_power_state, 0444, real_power_state_show, NULL);
+
+static ssize_t power_state_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct acpi_device *adev = to_acpi_device(dev);
+
+	return sprintf(buf, "%s\n", acpi_power_state_string(adev->power.state));
+}
+
+static DEVICE_ATTR(power_state, 0444, power_state_show, NULL);
+
 static ssize_t
 acpi_eject_store(struct device *d, struct device_attribute *attr,
 		const char *buf, size_t count)
@@ -369,8 +395,22 @@ static int acpi_device_setup_files(struct acpi_device *dev)
          * hot-removal function from userland.
          */
 	status = acpi_get_handle(dev->handle, "_EJ0", &temp);
-	if (ACPI_SUCCESS(status))
+	if (ACPI_SUCCESS(status)) {
 		result = device_create_file(&dev->dev, &dev_attr_eject);
+		if (result)
+			return result;
+	}
+
+	if (dev->flags.power_manageable) {
+		result = device_create_file(&dev->dev, &dev_attr_power_state);
+		if (result)
+			return result;
+
+		if (dev->power.flags.power_resources)
+			result = device_create_file(&dev->dev,
+						    &dev_attr_real_power_state);
+	}
+
 end:
 	return result;
 }
@@ -380,6 +420,13 @@ static void acpi_device_remove_files(struct acpi_device *dev)
 	acpi_status status;
 	acpi_handle temp;
 
+	if (dev->flags.power_manageable) {
+		device_remove_file(&dev->dev, &dev_attr_power_state);
+		if (dev->power.flags.power_resources)
+			device_remove_file(&dev->dev,
+					   &dev_attr_real_power_state);
+	}
+
 	/*
 	 * If device has _STR, remove 'description' file
 	 */

commit cf860be639d86ed77af179c925085ae0721ae602
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 24 12:49:49 2013 +0100

    ACPI / scan: Prevent device add uevents from racing with user space
    
    ACPI core adds sysfs device files after the given devices have been
    registered with device_register(), which is not appropriate, because
    it may lead to race conditions with user space tools using those
    files.
    
    Fix the problem by delaying the KOBJ_ADD uevent for ACPI devices
    until after all of the devices' sysfs files have been created.
    
    This also fixes a use-after-free in acpi_device_unregister().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 1fc57a349a3c..8b3b18846c8c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -634,8 +634,8 @@ struct bus_type acpi_bus_type = {
 	.uevent		= acpi_device_uevent,
 };
 
-int acpi_device_register(struct acpi_device *device,
-			 void (*release)(struct device *))
+int acpi_device_add(struct acpi_device *device,
+		    void (*release)(struct device *))
 {
 	int result;
 	struct acpi_device_bus_id *acpi_device_bus_id, *new_bus_id;
@@ -705,7 +705,7 @@ int acpi_device_register(struct acpi_device *device,
 		device->dev.parent = &device->parent->dev;
 	device->dev.bus = &acpi_bus_type;
 	device->dev.release = release;
-	result = device_register(&device->dev);
+	result = device_add(&device->dev);
 	if (result) {
 		dev_err(&device->dev, "Error registering device\n");
 		goto err;
@@ -744,12 +744,13 @@ static void acpi_device_unregister(struct acpi_device *device)
 
 	acpi_power_add_remove_device(device, false);
 	acpi_device_remove_files(device);
-	device_unregister(&device->dev);
+	device_del(&device->dev);
 	/*
 	 * Drop the reference counts of all power resources the device depends
 	 * on and turn off the ones that have no more references.
 	 */
 	acpi_power_transition(device, ACPI_STATE_D3_COLD);
+	put_device(&device->dev);
 }
 
 /* --------------------------------------------------------------------------
@@ -1391,6 +1392,14 @@ void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 	acpi_device_get_busid(device);
 	acpi_device_set_id(device);
 	acpi_bus_get_flags(device);
+	device_initialize(&device->dev);
+	dev_set_uevent_suppress(&device->dev, true);
+}
+
+void acpi_device_add_finalize(struct acpi_device *device)
+{
+	dev_set_uevent_suppress(&device->dev, false);
+	kobject_uevent(&device->dev.kobj, KOBJ_ADD);
 }
 
 static int acpi_add_single_object(struct acpi_device **child,
@@ -1412,13 +1421,14 @@ static int acpi_add_single_object(struct acpi_device **child,
 	acpi_bus_get_wakeup_device_flags(device);
 
 	device->flags.match_driver = match_driver;
-	result = acpi_device_register(device, acpi_device_release);
+	result = acpi_device_add(device, acpi_device_release);
 	if (result) {
 		acpi_device_release(&device->dev);
 		return result;
 	}
 
 	acpi_power_add_remove_device(device, true);
+	acpi_device_add_finalize(device);
 	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Added %s [%s] parent %s\n",
 		dev_name(&device->dev), (char *) buffer.pointer,

commit e375325ce55eb841ccda54a4472cf3b0139ea5f2
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Jan 18 13:46:01 2013 +0000

    ACPI / platform: create LPSS clocks if Lynxpoint devices are found during scan
    
    Intel Lynxpoint LPSS peripheral drivers depend on LPSS clock tree being
    created in order to function properly. The clock tree is exposed as a
    platform driver that binds to a device named 'clk-lpt'.
    
    To support this we modify the acpi_create_platform_device() to take one
    additional parameter called flags. This is passed from
    acpi_platform_device_ids[] array when acpi_create_platform_device() is
    called.
    
    We then introduce a new flag ACPI_PLATFORM_CLK which is used to tell
    acpi_create_platform_device() to create the platform clocks as well.
    
    Finally we set the ACPI_PLATFORM_CLK flags for all the Lynxpoint LPSS
    devices and make sure that when this flag is set we create the
    corresponding clock tree platform device.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a85b4080c3ca..fe171aa7a98c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -38,14 +38,14 @@ static const struct acpi_device_id acpi_platform_device_ids[] = {
 	{ "PNP0D40" },
 
 	/* Haswell LPSS devices */
-	{ "INT33C0", 0 },
-	{ "INT33C1", 0 },
-	{ "INT33C2", 0 },
-	{ "INT33C3", 0 },
-	{ "INT33C4", 0 },
-	{ "INT33C5", 0 },
-	{ "INT33C6", 0 },
-	{ "INT33C7", 0 },
+	{ "INT33C0", ACPI_PLATFORM_CLK },
+	{ "INT33C1", ACPI_PLATFORM_CLK },
+	{ "INT33C2", ACPI_PLATFORM_CLK },
+	{ "INT33C3", ACPI_PLATFORM_CLK },
+	{ "INT33C4", ACPI_PLATFORM_CLK },
+	{ "INT33C5", ACPI_PLATFORM_CLK },
+	{ "INT33C6", ACPI_PLATFORM_CLK },
+	{ "INT33C7", ACPI_PLATFORM_CLK },
 
 	{ }
 };
@@ -1553,6 +1553,7 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 					  void *not_used, void **ret_not_used)
 {
+	const struct acpi_device_id *id;
 	acpi_status status = AE_OK;
 	struct acpi_device *device;
 	unsigned long long sta_not_used;
@@ -1568,9 +1569,10 @@ static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 	if (acpi_bus_get_device(handle, &device))
 		return AE_CTRL_DEPTH;
 
-	if (!acpi_match_device_ids(device, acpi_platform_device_ids)) {
+	id = __acpi_match_device(device, acpi_platform_device_ids);
+	if (id) {
 		/* This is a known good platform device. */
-		acpi_create_platform_device(device);
+		acpi_create_platform_device(device, id->driver_data);
 	} else if (device_attach(&device->dev) < 0) {
 		status = AE_CTRL_DEPTH;
 	}

commit 13176bbf183c82281a0e65519780ffebff5abc9d
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Jan 17 09:59:33 2013 +0000

    ACPI: add support for CSRT table
    
    Core System Resources Table (CSRT) is a proprietary ACPI table that
    contains resources for certain devices that are not found in the DSDT
    table. Typically a shared DMA controller might be found here.
    
    This patch adds support for this table. We go through all entries in the
    table and make platform devices of them. The resources from the table are
    passed with the platform device.
    
    There is one special resource in the table and it is the DMA request line
    base and number of request lines. This information might be needed by the
    DMA controller driver as it needs to map the ACPI DMA request line number
    to the actual request line understood by the hardware. This range is passed
    as IORESOURCE_DMA resource.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 7d164a966b0d..a85b4080c3ca 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1699,6 +1699,7 @@ int __init acpi_scan_init(void)
 
 	acpi_power_init();
 	acpi_pci_root_init();
+	acpi_csrt_init();
 
 	/*
 	 * Enumerate devices in the ACPI namespace.

commit b8bd759acd05281abf88cddef30c57313c109697
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jan 19 01:27:35 2013 +0100

    ACPI / scan: Drop acpi_bus_add() and use acpi_bus_scan() instead
    
    The only difference between acpi_bus_scan() and acpi_bus_add() is the
    invocation of acpi_update_all_gpes() in the latter which in fact is
    unnecessary, because acpi_update_all_gpes() has already been called
    by acpi_scan_init() and the way it is implemented guarantees the next
    invocations of it to do nothing.
    
    For this reason, drop acpi_bus_add() and make all its callers use
    acpi_bus_scan() directly instead of it.  Additionally, rearrange the
    code in acpi_scan_init() slightly to improve the visibility of the
    acpi_update_all_gpes() call in there.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 388b59c096dc..7c43bdc36abc 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1577,26 +1577,8 @@ static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 	return status;
 }
 
-static int acpi_bus_scan(acpi_handle handle)
-{
-	void *device = NULL;
-
-	if (ACPI_SUCCESS(acpi_bus_check_add(handle, 0, NULL, &device)))
-		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
-				    acpi_bus_check_add, NULL, NULL, &device);
-
-	if (!device)
-		return -ENODEV;
-
-	if (ACPI_SUCCESS(acpi_bus_device_attach(handle, 0, NULL, NULL)))
-		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
-				    acpi_bus_device_attach, NULL, NULL, NULL);
-
-	return 0;
-}
-
 /**
- * acpi_bus_add - Add ACPI device node objects in a given namespace scope.
+ * acpi_bus_scan - Add ACPI device node objects in a given namespace scope.
  * @handle: Root of the namespace scope to scan.
  *
  * Scan a given ACPI tree (probably recently hot-plugged) and create and add
@@ -1607,18 +1589,24 @@ static int acpi_bus_scan(acpi_handle handle)
  * in the table trunk from which the kernel could create a device and add an
  * appropriate driver.
  */
-int acpi_bus_add(acpi_handle handle)
+int acpi_bus_scan(acpi_handle handle)
 {
-	int err;
+	void *device = NULL;
 
-	err = acpi_bus_scan(handle);
-	if (err)
-		return err;
+	if (ACPI_SUCCESS(acpi_bus_check_add(handle, 0, NULL, &device)))
+		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
+				    acpi_bus_check_add, NULL, NULL, &device);
+
+	if (!device)
+		return -ENODEV;
+
+	if (ACPI_SUCCESS(acpi_bus_device_attach(handle, 0, NULL, NULL)))
+		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
+				    acpi_bus_device_attach, NULL, NULL, NULL);
 
-	acpi_update_all_gpes();
 	return 0;
 }
-EXPORT_SYMBOL(acpi_bus_add);
+EXPORT_SYMBOL(acpi_bus_scan);
 
 static acpi_status acpi_bus_device_detach(acpi_handle handle, u32 lvl_not_used,
 					  void *not_used, void **ret_not_used)
@@ -1708,13 +1696,15 @@ int __init acpi_scan_init(void)
 		return result;
 
 	result = acpi_bus_get_device(ACPI_ROOT_OBJECT, &acpi_root);
-	if (!result)
-		result = acpi_bus_scan_fixed();
-
 	if (result)
+		return result;
+
+	result = acpi_bus_scan_fixed();
+	if (result) {
 		acpi_device_unregister(acpi_root);
-	else
-		acpi_update_all_gpes();
+		return result;
+	}
 
-	return result;
+	acpi_update_all_gpes();
+	return 0;
 }

commit 0b3571274b8ff53c0e08bc667ecd3d8a43bd8714
Merge: 7d1f9aeff1ee 5993c4670ea2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 18 13:48:30 2013 +0100

    Merge branch 'acpi-scan' into acpi-lpss
    
    The following commits depend on the 'acpi-scan' material.

commit 0596a52b8357b25185e06af32973225baeb7196a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:07 2013 +0100

    ACPI: Use system level attribute of wakeup power resources
    
    The system level attribute of ACPI power resources is the lowest
    system sleep level (S0, S2 etc.) in which the given resource can be
    "on" (ACPI 5.0, Section 7.1).  On the other hand, wakeup power
    resources have to be "on" for devices depending on them to be able to
    signal wakeup.  Therefore devices cannot wake up the system from
    sleep states higher than the minimum of the system level attributes
    of their wakeup power resources.
    
    Use the wakeup power resources' system level values to get the
    deepest system sleep state (highest system sleep level) the given
    device can wake up the system from.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 0b6a6b4febd6..1fc57a349a3c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -950,6 +950,17 @@ static int acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 	if (err)
 		goto out;
 
+	if (!list_empty(&wakeup->resources)) {
+		int sleep_state;
+
+		sleep_state = acpi_power_min_system_level(&wakeup->resources);
+		if (sleep_state < wakeup->sleep_state) {
+			acpi_handle_warn(handle, "Overriding _PRW sleep state "
+					 "(S%d) by S%d from power resources\n",
+					 (int)wakeup->sleep_state, sleep_state);
+			wakeup->sleep_state = sleep_state;
+		}
+	}
 	acpi_setup_gpe_for_wake(handle, wakeup->gpe_device, wakeup->gpe_number);
 
  out:

commit e88c9c603b2ad0cd0fbe90afedba3f1becbbeb79
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:07 2013 +0100

    ACPI: Take power resource initialization errors into account
    
    Some ACPI power resource initialization errors, like memory
    allocation errors, are not taken into account appropriately in some
    cases, which may lead to a device having an incomplete list of power
    resources that one of its power states depends on, for one example.
    
    Rework the power resource initialization and namespace scanning code
    so that power resource initialization errors are treated more
    seriously.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d80df969f64a..0b6a6b4febd6 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -892,17 +892,17 @@ void acpi_bus_data_handler(acpi_handle handle, void *context)
 	return;
 }
 
-static acpi_status
-acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
-					     struct acpi_device_wakeup *wakeup)
+static int acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
+					struct acpi_device_wakeup *wakeup)
 {
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *package = NULL;
 	union acpi_object *element = NULL;
 	acpi_status status;
+	int err = -ENODATA;
 
 	if (!wakeup)
-		return AE_BAD_PARAMETER;
+		return -EINVAL;
 
 	INIT_LIST_HEAD(&wakeup->resources);
 
@@ -910,29 +910,25 @@ acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 	status = acpi_evaluate_object(handle, "_PRW", NULL, &buffer);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRW"));
-		return status;
+		return err;
 	}
 
 	package = (union acpi_object *)buffer.pointer;
 
-	if (!package || (package->package.count < 2)) {
-		status = AE_BAD_DATA;
+	if (!package || package->package.count < 2)
 		goto out;
-	}
 
 	element = &(package->package.elements[0]);
-	if (!element) {
-		status = AE_BAD_DATA;
+	if (!element)
 		goto out;
-	}
+
 	if (element->type == ACPI_TYPE_PACKAGE) {
 		if ((element->package.count < 2) ||
 		    (element->package.elements[0].type !=
 		     ACPI_TYPE_LOCAL_REFERENCE)
-		    || (element->package.elements[1].type != ACPI_TYPE_INTEGER)) {
-			status = AE_BAD_DATA;
+		    || (element->package.elements[1].type != ACPI_TYPE_INTEGER))
 			goto out;
-		}
+
 		wakeup->gpe_device =
 		    element->package.elements[0].reference.handle;
 		wakeup->gpe_number =
@@ -941,27 +937,24 @@ acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 		wakeup->gpe_device = NULL;
 		wakeup->gpe_number = element->integer.value;
 	} else {
-		status = AE_BAD_DATA;
 		goto out;
 	}
 
 	element = &(package->package.elements[1]);
-	if (element->type != ACPI_TYPE_INTEGER) {
-		status = AE_BAD_DATA;
+	if (element->type != ACPI_TYPE_INTEGER)
 		goto out;
-	}
+
 	wakeup->sleep_state = element->integer.value;
 
-	status = acpi_extract_power_resources(package, 2, &wakeup->resources);
-	if (ACPI_FAILURE(status))
+	err = acpi_extract_power_resources(package, 2, &wakeup->resources);
+	if (err)
 		goto out;
 
 	acpi_setup_gpe_for_wake(handle, wakeup->gpe_device, wakeup->gpe_number);
 
  out:
 	kfree(buffer.pointer);
-
-	return status;
+	return err;
 }
 
 static void acpi_bus_set_run_wake_flags(struct acpi_device *device)
@@ -1001,17 +994,17 @@ static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 {
 	acpi_handle temp;
 	acpi_status status = 0;
-	int psw_error;
+	int err;
 
 	/* Presence of _PRW indicates wake capable */
 	status = acpi_get_handle(device->handle, "_PRW", &temp);
 	if (ACPI_FAILURE(status))
 		return;
 
-	status = acpi_bus_extract_wakeup_device_power_package(device->handle,
-							      &device->wakeup);
-	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, status, "Extracting _PRW package"));
+	err = acpi_bus_extract_wakeup_device_power_package(device->handle,
+							   &device->wakeup);
+	if (err) {
+		dev_err(&device->dev, "_PRW evaluation error: %d\n", err);
 		return;
 	}
 
@@ -1024,8 +1017,8 @@ static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	 * So it is necessary to call _DSW object first. Only when it is not
 	 * present will the _PSW object used.
 	 */
-	psw_error = acpi_device_sleep_wake(device, 0, 0, 0);
-	if (psw_error)
+	err = acpi_device_sleep_wake(device, 0, 0, 0);
+	if (err)
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				"error in _DSW or _PSW evaluation\n"));
 }
@@ -1048,9 +1041,9 @@ static void acpi_bus_init_power_state(struct acpi_device *device, int state)
 		if (buffer.length && package
 		    && package->type == ACPI_TYPE_PACKAGE
 		    && package->package.count) {
-			status = acpi_extract_power_resources(package, 0,
-							      &ps->resources);
-			if (ACPI_SUCCESS(status))
+			int err = acpi_extract_power_resources(package, 0,
+							       &ps->resources);
+			if (!err)
 				device->power.flags.power_resources = 1;
 		}
 		ACPI_FREE(buffer.pointer);

commit ef85bdbec444b42775a18580c6bfe1307a63ef0f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:07 2013 +0100

    ACPI / scan: Consolidate extraction of power resources lists
    
    The lists of ACPI power resources are currently extracted in two
    different ways, one for wakeup power resources and one for power
    resources that device power states depend on.  There is no reason
    why it should be done differently in those two cases, so introduce
    a common routine for extracting power resources lists from data
    returned by AML, acpi_extract_power_resources(), and make the
    namespace scanning code use it for both wakeup and device power
    states power resources.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8da315418d94..d80df969f64a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -900,7 +900,6 @@ acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 	union acpi_object *package = NULL;
 	union acpi_object *element = NULL;
 	acpi_status status;
-	int i = 0;
 
 	if (!wakeup)
 		return AE_BAD_PARAMETER;
@@ -953,18 +952,9 @@ acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 	}
 	wakeup->sleep_state = element->integer.value;
 
-	for (i = 2; i < package->package.count; i++) {
-		acpi_handle rhandle;
-
-		element = &(package->package.elements[i]);
-		if (element->type != ACPI_TYPE_LOCAL_REFERENCE) {
-			status = AE_BAD_DATA;
-			goto out;
-		}
-		rhandle = element->reference.handle;
-		acpi_add_power_resource(rhandle);
-		acpi_power_resources_list_add(rhandle, &wakeup->resources);
-	}
+	status = acpi_extract_power_resources(package, 2, &wakeup->resources);
+	if (ACPI_FAILURE(status))
+		goto out;
 
 	acpi_setup_gpe_for_wake(handle, wakeup->gpe_device, wakeup->gpe_number);
 
@@ -1021,7 +1011,6 @@ static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	status = acpi_bus_extract_wakeup_device_power_package(device->handle,
 							      &device->wakeup);
 	if (ACPI_FAILURE(status)) {
-		acpi_power_resources_list_free(&device->wakeup.resources);
 		ACPI_EXCEPTION((AE_INFO, status, "Extracting _PRW package"));
 		return;
 	}
@@ -1044,30 +1033,32 @@ static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 static void acpi_bus_init_power_state(struct acpi_device *device, int state)
 {
 	struct acpi_device_power_state *ps = &device->power.states[state];
-	char object_name[5] = { '_', 'P', 'R', '0' + state, '\0' };
-	struct acpi_handle_list resources;
+	char pathname[5] = { '_', 'P', 'R', '0' + state, '\0' };
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	acpi_handle handle;
 	acpi_status status;
 
 	INIT_LIST_HEAD(&ps->resources);
 
-	/* Evaluate "_PRx" to se if power resources are referenced */
-	acpi_evaluate_reference(device->handle, object_name, NULL, &resources);
-	if (resources.count) {
-		int j;
-
-		device->power.flags.power_resources = 1;
-		for (j = 0; j < resources.count; j++) {
-			acpi_handle rhandle = resources.handles[j];
-
-			acpi_add_power_resource(rhandle);
-			acpi_power_resources_list_add(rhandle, &ps->resources);
+	/* Evaluate "_PRx" to get referenced power resources */
+	status = acpi_evaluate_object(device->handle, pathname, NULL, &buffer);
+	if (ACPI_SUCCESS(status)) {
+		union acpi_object *package = buffer.pointer;
+
+		if (buffer.length && package
+		    && package->type == ACPI_TYPE_PACKAGE
+		    && package->package.count) {
+			status = acpi_extract_power_resources(package, 0,
+							      &ps->resources);
+			if (ACPI_SUCCESS(status))
+				device->power.flags.power_resources = 1;
 		}
+		ACPI_FREE(buffer.pointer);
 	}
 
 	/* Evaluate "_PSx" to see if we can do explicit sets */
-	object_name[2] = 'S';
-	status = acpi_get_handle(device->handle, object_name, &handle);
+	pathname[2] = 'S';
+	status = acpi_get_handle(device->handle, pathname, &handle);
 	if (ACPI_SUCCESS(status))
 		ps->flags.explicit_set = 1;
 
@@ -1075,7 +1066,7 @@ static void acpi_bus_init_power_state(struct acpi_device *device, int state)
 	 * State is valid if there are means to put the device into it.
 	 * D3hot is only valid if _PR3 present.
 	 */
-	if (resources.count
+	if (!list_empty(&ps->resources)
 	    || (ps->flags.explicit_set && state < ACPI_STATE_D3_HOT)) {
 		ps->flags.valid = 1;
 		ps->flags.os_accessible = 1;

commit 8bc5053bcdff09a6d1c6a61a79a9014884aa0a14
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:07 2013 +0100

    ACPI / scan: Remove unnecessary initialization of local variables
    
    The local variables in acpi_bus_get_power_flags() need not be
    initialized upfront, so change the code accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 10c98ff6b026..8da315418d94 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1087,9 +1087,9 @@ static void acpi_bus_init_power_state(struct acpi_device *device, int state)
 
 static void acpi_bus_get_power_flags(struct acpi_device *device)
 {
-	acpi_status status = 0;
-	acpi_handle handle = NULL;
-	u32 i = 0;
+	acpi_status status;
+	acpi_handle handle;
+	u32 i;
 
 	/* Presence of _PS0|_PR0 indicates 'power manageable' */
 	status = acpi_get_handle(device->handle, "_PS0", &handle);

commit f33ce568366ab61b5685bae07306e40f17beb943
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:06 2013 +0100

    ACPI / scan: Move power state initialization to a separate routine
    
    To reduce indentation level and improve code readability, move the
    initialization code related to device power states from
    acpi_bus_get_power_flags() to a new routine,
    acpi_bus_init_power_state().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e4ac46a9c664..10c98ff6b026 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1041,6 +1041,50 @@ static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 				"error in _DSW or _PSW evaluation\n"));
 }
 
+static void acpi_bus_init_power_state(struct acpi_device *device, int state)
+{
+	struct acpi_device_power_state *ps = &device->power.states[state];
+	char object_name[5] = { '_', 'P', 'R', '0' + state, '\0' };
+	struct acpi_handle_list resources;
+	acpi_handle handle;
+	acpi_status status;
+
+	INIT_LIST_HEAD(&ps->resources);
+
+	/* Evaluate "_PRx" to se if power resources are referenced */
+	acpi_evaluate_reference(device->handle, object_name, NULL, &resources);
+	if (resources.count) {
+		int j;
+
+		device->power.flags.power_resources = 1;
+		for (j = 0; j < resources.count; j++) {
+			acpi_handle rhandle = resources.handles[j];
+
+			acpi_add_power_resource(rhandle);
+			acpi_power_resources_list_add(rhandle, &ps->resources);
+		}
+	}
+
+	/* Evaluate "_PSx" to see if we can do explicit sets */
+	object_name[2] = 'S';
+	status = acpi_get_handle(device->handle, object_name, &handle);
+	if (ACPI_SUCCESS(status))
+		ps->flags.explicit_set = 1;
+
+	/*
+	 * State is valid if there are means to put the device into it.
+	 * D3hot is only valid if _PR3 present.
+	 */
+	if (resources.count
+	    || (ps->flags.explicit_set && state < ACPI_STATE_D3_HOT)) {
+		ps->flags.valid = 1;
+		ps->flags.os_accessible = 1;
+	}
+
+	ps->power = -1;		/* Unknown - driver assigned */
+	ps->latency = -1;	/* Unknown - driver assigned */
+}
+
 static void acpi_bus_get_power_flags(struct acpi_device *device)
 {
 	acpi_status status = 0;
@@ -1070,47 +1114,8 @@ static void acpi_bus_get_power_flags(struct acpi_device *device)
 	/*
 	 * Enumerate supported power management states
 	 */
-	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3_HOT; i++) {
-		struct acpi_device_power_state *ps = &device->power.states[i];
-		char object_name[5] = { '_', 'P', 'R', '0' + i, '\0' };
-		struct acpi_handle_list resources;
-
-		INIT_LIST_HEAD(&ps->resources);
-		/* Evaluate "_PRx" to se if power resources are referenced */
-		acpi_evaluate_reference(device->handle, object_name, NULL,
-					&resources);
-		if (resources.count) {
-			int j;
-
-			device->power.flags.power_resources = 1;
-			for (j = 0; j < resources.count; j++) {
-				acpi_handle rhandle = resources.handles[j];
-
-				acpi_add_power_resource(rhandle);
-				acpi_power_resources_list_add(rhandle,
-							      &ps->resources);
-			}
-		}
-
-		/* Evaluate "_PSx" to see if we can do explicit sets */
-		object_name[2] = 'S';
-		status = acpi_get_handle(device->handle, object_name, &handle);
-		if (ACPI_SUCCESS(status))
-			ps->flags.explicit_set = 1;
-
-		/*
-		 * State is valid if there are means to put the device into it.
-		 * D3hot is only valid if _PR3 present.
-		 */
-		if (resources.count ||
-		    (ps->flags.explicit_set && i < ACPI_STATE_D3_HOT)) {
-			ps->flags.valid = 1;
-			ps->flags.os_accessible = 1;
-		}
-
-		ps->power = -1;	/* Unknown - driver assigned */
-		ps->latency = -1;	/* Unknown - driver assigned */
-	}
+	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3_HOT; i++)
+		acpi_bus_init_power_state(device, i);
 
 	INIT_LIST_HEAD(&device->power.states[ACPI_STATE_D3_COLD].resources);
 

commit 993cbe595dda731471a07f4f65575fadedc570dc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:06 2013 +0100

    ACPI / PM: Take order attribute of wakeup power resources into account
    
    ACPI power resources have an order attribute that should be taken
    into account when turning them on and off, but it is not used now.
    
    Modify the power resources management code to preserve the
    spec-compliant ordering of wakeup power resources.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d557868c0081..e4ac46a9c664 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -479,6 +479,9 @@ static void acpi_free_power_resources_lists(struct acpi_device *device)
 {
 	int i;
 
+	if (device->wakeup.flags.valid)
+		acpi_power_resources_list_free(&device->wakeup.resources);
+
 	if (!device->flags.power_manageable)
 		return;
 
@@ -902,6 +905,8 @@ acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 	if (!wakeup)
 		return AE_BAD_PARAMETER;
 
+	INIT_LIST_HEAD(&wakeup->resources);
+
 	/* _PRW */
 	status = acpi_evaluate_object(handle, "_PRW", NULL, &buffer);
 	if (ACPI_FAILURE(status)) {
@@ -948,19 +953,17 @@ acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 	}
 	wakeup->sleep_state = element->integer.value;
 
-	if ((package->package.count - 2) > ACPI_MAX_HANDLES) {
-		status = AE_NO_MEMORY;
-		goto out;
-	}
-	wakeup->resources.count = package->package.count - 2;
-	for (i = 0; i < wakeup->resources.count; i++) {
-		element = &(package->package.elements[i + 2]);
+	for (i = 2; i < package->package.count; i++) {
+		acpi_handle rhandle;
+
+		element = &(package->package.elements[i]);
 		if (element->type != ACPI_TYPE_LOCAL_REFERENCE) {
 			status = AE_BAD_DATA;
 			goto out;
 		}
-
-		wakeup->resources.handles[i] = element->reference.handle;
+		rhandle = element->reference.handle;
+		acpi_add_power_resource(rhandle);
+		acpi_power_resources_list_add(rhandle, &wakeup->resources);
 	}
 
 	acpi_setup_gpe_for_wake(handle, wakeup->gpe_device, wakeup->gpe_number);
@@ -1018,6 +1021,7 @@ static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	status = acpi_bus_extract_wakeup_device_power_package(device->handle,
 							      &device->wakeup);
 	if (ACPI_FAILURE(status)) {
+		acpi_power_resources_list_free(&device->wakeup.resources);
 		ACPI_EXCEPTION((AE_INFO, status, "Extracting _PRW package"));
 		return;
 	}
@@ -1491,9 +1495,11 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 		acpi_handle temp;
 
 		status = acpi_get_handle(handle, "_PRW", &temp);
-		if (ACPI_SUCCESS(status))
+		if (ACPI_SUCCESS(status)) {
 			acpi_bus_extract_wakeup_device_power_package(handle,
 								     &wakeup);
+			acpi_power_resources_list_free(&wakeup.resources);
+		}
 		return AE_CTRL_DEPTH;
 	}
 

commit 0b224527323669c66e0a37ae05b04034bfcdce14
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:06 2013 +0100

    ACPI / PM: Take order attribute of power resources into account
    
    ACPI power resources have an order attribute that should be taken
    into account when turning them on and off, but it is not used now.
    
    Modify the power resources management code to preserve the
    spec-compliant ordering of power resources that power states of
    devices depend on (analogous changes will be done separately for
    power resources used for wakeup).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c7ea9c2649a4..d557868c0081 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -475,11 +475,25 @@ void acpi_free_ids(struct acpi_device *device)
 	kfree(device->pnp.unique_id);
 }
 
+static void acpi_free_power_resources_lists(struct acpi_device *device)
+{
+	int i;
+
+	if (!device->flags.power_manageable)
+		return;
+
+	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3_HOT; i++) {
+		struct acpi_device_power_state *ps = &device->power.states[i];
+		acpi_power_resources_list_free(&ps->resources);
+	}
+}
+
 static void acpi_device_release(struct device *dev)
 {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 
 	acpi_free_ids(acpi_dev);
+	acpi_free_power_resources_lists(acpi_dev);
 	kfree(acpi_dev);
 }
 
@@ -1055,17 +1069,22 @@ static void acpi_bus_get_power_flags(struct acpi_device *device)
 	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3_HOT; i++) {
 		struct acpi_device_power_state *ps = &device->power.states[i];
 		char object_name[5] = { '_', 'P', 'R', '0' + i, '\0' };
+		struct acpi_handle_list resources;
 
+		INIT_LIST_HEAD(&ps->resources);
 		/* Evaluate "_PRx" to se if power resources are referenced */
 		acpi_evaluate_reference(device->handle, object_name, NULL,
-					&ps->resources);
-		if (ps->resources.count) {
+					&resources);
+		if (resources.count) {
 			int j;
 
 			device->power.flags.power_resources = 1;
-			for (j = 0; j < ps->resources.count; j++) {
-				acpi_handle rhandle = ps->resources.handles[j];
+			for (j = 0; j < resources.count; j++) {
+				acpi_handle rhandle = resources.handles[j];
+
 				acpi_add_power_resource(rhandle);
+				acpi_power_resources_list_add(rhandle,
+							      &ps->resources);
 			}
 		}
 
@@ -1079,7 +1098,7 @@ static void acpi_bus_get_power_flags(struct acpi_device *device)
 		 * State is valid if there are means to put the device into it.
 		 * D3hot is only valid if _PR3 present.
 		 */
-		if (ps->resources.count ||
+		if (resources.count ||
 		    (ps->flags.explicit_set && i < ACPI_STATE_D3_HOT)) {
 			ps->flags.valid = 1;
 			ps->flags.os_accessible = 1;
@@ -1089,6 +1108,8 @@ static void acpi_bus_get_power_flags(struct acpi_device *device)
 		ps->latency = -1;	/* Unknown - driver assigned */
 	}
 
+	INIT_LIST_HEAD(&device->power.states[ACPI_STATE_D3_COLD].resources);
+
 	/* Set defaults for D0 and D3 states (always valid) */
 	device->power.states[ACPI_STATE_D0].flags.valid = 1;
 	device->power.states[ACPI_STATE_D0].power = 100;

commit 781d737c7466845035e5ce02885c7436b5278b90
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:06 2013 +0100

    ACPI: Drop power resources driver
    
    The ACPI power resources driver is not very useful, because the only
    thing it really does is to restore the state of the power resources
    that were "on" before system suspend or hibernation, but that may be
    achieved in a different way.
    
    Drop the ACPI power resources driver entirely and add
    acpi_resume_power_resources() that will walk the list of all
    registered power resources during system resume and turn on the ones
    that were "on" before the preceding system suspend or hibernation.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 952b08af91de..c7ea9c2649a4 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1636,7 +1636,6 @@ int __init acpi_scan_init(void)
 		printk(KERN_ERR PREFIX "Could not register bus type\n");
 	}
 
-	acpi_power_init();
 	acpi_pci_root_init();
 
 	/*

commit 82c7d5efaadf99fb4a26500cd5b59b6fd7659772
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:05 2013 +0100

    ACPI / scan: Treat power resources in a special way
    
    ACPI power resources need to be treated in a special way by the
    namespace scanning code, because they need to be ready to use as
    soon as they have been discovered (even before registering ACPI
    device nodes using them for power management).
    
    For this reason, it doesn't make sense to separate the preparation
    of struct acpi_device objects representing them in the device
    hierarchy from the creation of struct acpi_power_resource objects
    actually used for power resource manipulation.  Accordingly, it
    doesn't make sense to define non-empty .add() and .remove() callbacks
    in the power resources "driver" (in fact, it is questionable whether
    or not it is useful to register such a "driver" at all).
    
    Rearrange the code in scan.c and power.c so that power resources are
    initialized entirely by one routine, acpi_add_power_resource(), that
    also prepares their struct acpi_device objects and registers them
    with the driver core, telling it to use a special release routine,
    acpi_release_power_resource(), for removing objects that represent
    power resources from memory.  Make the ACPI namespace scanning code
    in scan.c always use acpi_add_power_resource() for preparing and
    registering objects that represent power resources.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 02629a810c04..952b08af91de 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -464,7 +464,7 @@ int acpi_match_device_ids(struct acpi_device *device,
 }
 EXPORT_SYMBOL(acpi_match_device_ids);
 
-static void acpi_free_ids(struct acpi_device *device)
+void acpi_free_ids(struct acpi_device *device)
 {
 	struct acpi_hardware_id *id, *tmp;
 
@@ -617,7 +617,8 @@ struct bus_type acpi_bus_type = {
 	.uevent		= acpi_device_uevent,
 };
 
-static int acpi_device_register(struct acpi_device *device)
+int acpi_device_register(struct acpi_device *device,
+			 void (*release)(struct device *))
 {
 	int result;
 	struct acpi_device_bus_id *acpi_device_bus_id, *new_bus_id;
@@ -686,7 +687,7 @@ static int acpi_device_register(struct acpi_device *device)
 	if (device->parent)
 		device->dev.parent = &device->parent->dev;
 	device->dev.bus = &acpi_bus_type;
-	device->dev.release = &acpi_device_release;
+	device->dev.release = release;
 	result = device_register(&device->dev);
 	if (result) {
 		dev_err(&device->dev, "Error registering device\n");
@@ -1022,18 +1023,12 @@ static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 				"error in _DSW or _PSW evaluation\n"));
 }
 
-static void acpi_bus_add_power_resource(acpi_handle handle);
-
 static void acpi_bus_get_power_flags(struct acpi_device *device)
 {
 	acpi_status status = 0;
 	acpi_handle handle = NULL;
 	u32 i = 0;
 
-	/* Power resources cannot be power manageable. */
-	if (device->device_type == ACPI_BUS_TYPE_POWER)
-		return;
-
 	/* Presence of _PS0|_PR0 indicates 'power manageable' */
 	status = acpi_get_handle(device->handle, "_PS0", &handle);
 	if (ACPI_FAILURE(status)) {
@@ -1068,8 +1063,10 @@ static void acpi_bus_get_power_flags(struct acpi_device *device)
 			int j;
 
 			device->power.flags.power_resources = 1;
-			for (j = 0; j < ps->resources.count; j++)
-				acpi_bus_add_power_resource(ps->resources.handles[j]);
+			for (j = 0; j < ps->resources.count; j++) {
+				acpi_handle rhandle = ps->resources.handles[j];
+				acpi_add_power_resource(rhandle);
+			}
 		}
 
 		/* Evaluate "_PSx" to see if we can do explicit sets */
@@ -1358,9 +1355,8 @@ static void acpi_device_set_id(struct acpi_device *device)
 	}
 }
 
-static void acpi_init_device_object(struct acpi_device *device,
-				     acpi_handle handle,
-				     int type, unsigned long long sta)
+void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
+			     int type, unsigned long long sta)
 {
 	INIT_LIST_HEAD(&device->pnp.ids);
 	device->device_type = type;
@@ -1391,7 +1387,7 @@ static int acpi_add_single_object(struct acpi_device **child,
 	acpi_bus_get_wakeup_device_flags(device);
 
 	device->flags.match_driver = match_driver;
-	result = acpi_device_register(device);
+	result = acpi_device_register(device, acpi_device_release);
 	if (result) {
 		acpi_device_release(&device->dev);
 		return result;
@@ -1407,19 +1403,6 @@ static int acpi_add_single_object(struct acpi_device **child,
 	return 0;
 }
 
-#define ACPI_STA_DEFAULT (ACPI_STA_DEVICE_PRESENT | ACPI_STA_DEVICE_ENABLED | \
-			  ACPI_STA_DEVICE_UI      | ACPI_STA_DEVICE_FUNCTIONING)
-
-static void acpi_bus_add_power_resource(acpi_handle handle)
-{
-	struct acpi_device *device = NULL;
-
-	acpi_bus_get_device(handle, &device);
-	if (!device)
-		acpi_add_single_object(&device, handle, ACPI_BUS_TYPE_POWER,
-					ACPI_STA_DEFAULT, true);
-}
-
 static int acpi_bus_type_and_status(acpi_handle handle, int *type,
 				    unsigned long long *sta)
 {
@@ -1476,6 +1459,11 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 	if (result)
 		return AE_OK;
 
+	if (type == ACPI_BUS_TYPE_POWER) {
+		acpi_add_power_resource(handle);
+		return AE_OK;
+	}
+
 	if (!(sta & ACPI_STA_DEVICE_PRESENT) &&
 	    !(sta & ACPI_STA_DEVICE_FUNCTIONING)) {
 		struct acpi_device_wakeup wakeup;
@@ -1488,8 +1476,7 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 		return AE_CTRL_DEPTH;
 	}
 
-	acpi_add_single_object(&device, handle, type, sta,
-			       type == ACPI_BUS_TYPE_POWER);
+	acpi_add_single_object(&device, handle, type, sta, false);
 	if (!device)
 		return AE_CTRL_DEPTH;
 

commit d43e167db44b37bb284dc72fff2c3b61bb155752
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:05 2013 +0100

    ACPI / scan: More straightforward preparation of ACPI device objects
    
    Simplify the code preparing struct acpi_device objects for
    registration by removing useless code, moving different pieces of
    code into the functions they belong to and making a couple of int
    functions always returning 0 void.
    
    This also fixes a possible memory leak in ACPI device registration
    error code path by making acpi_device_register() detach data from
    device->handle if device_register() fails and prepares the scanning
    code for special-casing ACPI power resources (next patch).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c6d60910e8a8..02629a810c04 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -472,6 +472,7 @@ static void acpi_free_ids(struct acpi_device *device)
 		kfree(id->id);
 		kfree(id);
 	}
+	kfree(device->pnp.unique_id);
 }
 
 static void acpi_device_release(struct device *dev)
@@ -479,7 +480,6 @@ static void acpi_device_release(struct device *dev)
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 
 	acpi_free_ids(acpi_dev);
-	kfree(acpi_dev->pnp.unique_id);
 	kfree(acpi_dev);
 }
 
@@ -623,6 +623,18 @@ static int acpi_device_register(struct acpi_device *device)
 	struct acpi_device_bus_id *acpi_device_bus_id, *new_bus_id;
 	int found = 0;
 
+	if (device->handle) {
+		acpi_status status;
+
+		status = acpi_attach_data(device->handle, acpi_bus_data_handler,
+					  device);
+		if (ACPI_FAILURE(status)) {
+			acpi_handle_err(device->handle,
+					"Unable to attach device data\n");
+			return -ENODEV;
+		}
+	}
+
 	/*
 	 * Linkage
 	 * -------
@@ -637,8 +649,9 @@ static int acpi_device_register(struct acpi_device *device)
 
 	new_bus_id = kzalloc(sizeof(struct acpi_device_bus_id), GFP_KERNEL);
 	if (!new_bus_id) {
-		printk(KERN_ERR PREFIX "Memory allocation error\n");
-		return -ENOMEM;
+		pr_err(PREFIX "Memory allocation error\n");
+		result = -ENOMEM;
+		goto err_detach;
 	}
 
 	mutex_lock(&acpi_device_lock);
@@ -677,7 +690,7 @@ static int acpi_device_register(struct acpi_device *device)
 	result = device_register(&device->dev);
 	if (result) {
 		dev_err(&device->dev, "Error registering device\n");
-		goto end;
+		goto err;
 	}
 
 	result = acpi_device_setup_files(device);
@@ -687,12 +700,16 @@ static int acpi_device_register(struct acpi_device *device)
 
 	device->removal_type = ACPI_BUS_REMOVAL_NORMAL;
 	return 0;
-end:
+
+ err:
 	mutex_lock(&acpi_device_lock);
 	if (device->parent)
 		list_del(&device->node);
 	list_del(&device->wakeup_list);
 	mutex_unlock(&acpi_device_lock);
+
+ err_detach:
+	acpi_detach_data(device->handle, acpi_bus_data_handler);
 	return result;
 }
 
@@ -857,12 +874,6 @@ void acpi_bus_data_handler(acpi_handle handle, void *context)
 	return;
 }
 
-static int acpi_bus_get_perf_flags(struct acpi_device *device)
-{
-	device->performance.state = ACPI_STATE_UNKNOWN;
-	return 0;
-}
-
 static acpi_status
 acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 					     struct acpi_device_wakeup *wakeup)
@@ -1013,12 +1024,25 @@ static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 
 static void acpi_bus_add_power_resource(acpi_handle handle);
 
-static int acpi_bus_get_power_flags(struct acpi_device *device)
+static void acpi_bus_get_power_flags(struct acpi_device *device)
 {
 	acpi_status status = 0;
 	acpi_handle handle = NULL;
 	u32 i = 0;
 
+	/* Power resources cannot be power manageable. */
+	if (device->device_type == ACPI_BUS_TYPE_POWER)
+		return;
+
+	/* Presence of _PS0|_PR0 indicates 'power manageable' */
+	status = acpi_get_handle(device->handle, "_PS0", &handle);
+	if (ACPI_FAILURE(status)) {
+		status = acpi_get_handle(device->handle, "_PR0", &handle);
+		if (ACPI_FAILURE(status))
+			return;
+	}
+
+	device->flags.power_manageable = 1;
 
 	/*
 	 * Power Management Flags
@@ -1084,16 +1108,13 @@ static int acpi_bus_get_power_flags(struct acpi_device *device)
 		device->power.states[ACPI_STATE_D3_COLD].flags.os_accessible = 1;
 
 	acpi_bus_init_power(device);
-
-	return 0;
 }
 
-static int acpi_bus_get_flags(struct acpi_device *device)
+static void acpi_bus_get_flags(struct acpi_device *device)
 {
 	acpi_status status = AE_OK;
 	acpi_handle temp = NULL;
 
-
 	/* Presence of _STA indicates 'dynamic_status' */
 	status = acpi_get_handle(device->handle, "_STA", &temp);
 	if (ACPI_SUCCESS(status))
@@ -1113,21 +1134,6 @@ static int acpi_bus_get_flags(struct acpi_device *device)
 		if (ACPI_SUCCESS(status))
 			device->flags.ejectable = 1;
 	}
-
-	/* Power resources cannot be power manageable. */
-	if (device->device_type == ACPI_BUS_TYPE_POWER)
-		return 0;
-
-	/* Presence of _PS0|_PR0 indicates 'power manageable' */
-	status = acpi_get_handle(device->handle, "_PS0", &temp);
-	if (ACPI_FAILURE(status))
-		status = acpi_get_handle(device->handle, "_PR0", &temp);
-	if (ACPI_SUCCESS(status))
-		device->flags.power_manageable = 1;
-
-	/* TBD: Performance management */
-
-	return 0;
 }
 
 static void acpi_device_get_busid(struct acpi_device *device)
@@ -1352,27 +1358,18 @@ static void acpi_device_set_id(struct acpi_device *device)
 	}
 }
 
-static int acpi_device_set_context(struct acpi_device *device)
+static void acpi_init_device_object(struct acpi_device *device,
+				     acpi_handle handle,
+				     int type, unsigned long long sta)
 {
-	acpi_status status;
-
-	/*
-	 * Context
-	 * -------
-	 * Attach this 'struct acpi_device' to the ACPI object.  This makes
-	 * resolutions from handle->device very efficient.  Fixed hardware
-	 * devices have no handles, so we skip them.
-	 */
-	if (!device->handle)
-		return 0;
-
-	status = acpi_attach_data(device->handle,
-				  acpi_bus_data_handler, device);
-	if (ACPI_SUCCESS(status))
-		return 0;
-
-	printk(KERN_ERR PREFIX "Error attaching device data\n");
-	return -ENODEV;
+	INIT_LIST_HEAD(&device->pnp.ids);
+	device->device_type = type;
+	device->handle = handle;
+	device->parent = acpi_bus_get_parent(handle);
+	STRUCT_TO_INT(device->status) = sta;
+	acpi_device_get_busid(device);
+	acpi_device_set_id(device);
+	acpi_bus_get_flags(device);
 }
 
 static int acpi_add_single_object(struct acpi_device **child,
@@ -1389,78 +1386,25 @@ static int acpi_add_single_object(struct acpi_device **child,
 		return -ENOMEM;
 	}
 
-	INIT_LIST_HEAD(&device->pnp.ids);
-	device->device_type = type;
-	device->handle = handle;
-	device->parent = acpi_bus_get_parent(handle);
-	STRUCT_TO_INT(device->status) = sta;
-
-	acpi_device_get_busid(device);
-
-	/*
-	 * Flags
-	 * -----
-	 * Note that we only look for object handles -- cannot evaluate objects
-	 * until we know the device is present and properly initialized.
-	 */
-	result = acpi_bus_get_flags(device);
-	if (result)
-		goto end;
-
-	/*
-	 * Initialize Device
-	 * -----------------
-	 * TBD: Synch with Core's enumeration/initialization process.
-	 */
-	acpi_device_set_id(device);
-
-	/*
-	 * Power Management
-	 * ----------------
-	 */
-	if (device->flags.power_manageable) {
-		result = acpi_bus_get_power_flags(device);
-		if (result)
-			goto end;
-	}
-
-	/*
-	 * Wakeup device management
-	 *-----------------------
-	 */
+	acpi_init_device_object(device, handle, type, sta);
+	acpi_bus_get_power_flags(device);
 	acpi_bus_get_wakeup_device_flags(device);
 
-	/*
-	 * Performance Management
-	 * ----------------------
-	 */
-	if (device->flags.performance_manageable) {
-		result = acpi_bus_get_perf_flags(device);
-		if (result)
-			goto end;
-	}
-
-	if ((result = acpi_device_set_context(device)))
-		goto end;
-
 	device->flags.match_driver = match_driver;
 	result = acpi_device_register(device);
-
-end:
-	if (!result) {
-		acpi_power_add_remove_device(device, true);
-		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			"Adding %s [%s] parent %s\n", dev_name(&device->dev),
-			 (char *) buffer.pointer,
-			 device->parent ? dev_name(&device->parent->dev) :
-					  "(null)"));
-		kfree(buffer.pointer);
-		*child = device;
-	} else
+	if (result) {
 		acpi_device_release(&device->dev);
+		return result;
+	}
 
-	return result;
+	acpi_power_add_remove_device(device, true);
+	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Added %s [%s] parent %s\n",
+		dev_name(&device->dev), (char *) buffer.pointer,
+		device->parent ? dev_name(&device->parent->dev) : "(null)"));
+	kfree(buffer.pointer);
+	*child = device;
+	return 0;
 }
 
 #define ACPI_STA_DEFAULT (ACPI_STA_DEVICE_PRESENT | ACPI_STA_DEVICE_ENABLED | \

commit bc9b6407bd6df3ab7189e5622816bbc11ae9d2d8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:05 2013 +0100

    ACPI / PM: Rework the handling of devices depending on power resources
    
    Commit 0090def6 (ACPI: Add interface to register/unregister device
    to/from power resources) made it possible to indicate to the ACPI
    core that if the given device depends on any power resources, then
    it should be resumed as soon as all of the power resources required
    by it to transition to the D0 power state have been turned on.
    
    Unfortunately, however, this was a mistake, because all devices
    depending on power resources should be treated this way (i.e. they
    should be resumed when all power resources required by their D0
    state have been turned on) and for the majority of those devices
    the ACPI core can figure out by itself which (physical) devices
    depend on what power resources.
    
    For this reason, replace the code added by commit 0090def6 with a
    new, much more straightforward, mechanism that will be used
    internally by the ACPI core and remove all references to that code
    from kernel subsystems using ACPI.
    
    For the cases when there are (physical) devices that should be
    resumed whenever a not directly related ACPI device node goes into
    D0 as a result of power resources configuration changes, like in
    the SATA case, add two new routines, acpi_dev_pm_add_dependent()
    and acpi_dev_pm_remove_dependent(), allowing subsystems to manage
    such dependencies.  Convert the SATA subsystem to use the new
    functions accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 7d164a966b0d..c6d60910e8a8 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -633,6 +633,7 @@ static int acpi_device_register(struct acpi_device *device)
 	INIT_LIST_HEAD(&device->wakeup_list);
 	INIT_LIST_HEAD(&device->physical_node_list);
 	mutex_init(&device->physical_node_lock);
+	INIT_LIST_HEAD(&device->power_dependent);
 
 	new_bus_id = kzalloc(sizeof(struct acpi_device_bus_id), GFP_KERNEL);
 	if (!new_bus_id) {
@@ -706,8 +707,14 @@ static void acpi_device_unregister(struct acpi_device *device)
 
 	acpi_detach_data(device->handle, acpi_bus_data_handler);
 
+	acpi_power_add_remove_device(device, false);
 	acpi_device_remove_files(device);
 	device_unregister(&device->dev);
+	/*
+	 * Drop the reference counts of all power resources the device depends
+	 * on and turn off the ones that have no more references.
+	 */
+	acpi_power_transition(device, ACPI_STATE_D3_COLD);
 }
 
 /* --------------------------------------------------------------------------
@@ -1441,6 +1448,7 @@ static int acpi_add_single_object(struct acpi_device **child,
 
 end:
 	if (!result) {
+		acpi_power_add_remove_device(device, true);
 		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			"Adding %s [%s] parent %s\n", dev_name(&device->dev),

commit 6a8dd80821c215bc49bf6b108e85c1738c82bf43
Merge: 9931faca02c6 5993c4670ea2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:10:27 2013 +0100

    Merge branch 'acpi-scan' into acpi-pm
    
    The following commits depend on the 'acpi-scan' material.

commit 5993c4670ea2453ef5abb45b312f150e994e6eb9
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Jan 11 22:40:41 2013 +0000

    ACPI: update ej_event interface to take acpi_device
    
    Should use acpi_device pointer directly instead of use handle and
    get the device pointer again later.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d04d0b33656c..388b59c096dc 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -116,20 +116,14 @@ static DEVICE_ATTR(modalias, 0444, acpi_device_modalias_show, NULL);
 void acpi_bus_hot_remove_device(void *context)
 {
 	struct acpi_eject_event *ej_event = (struct acpi_eject_event *) context;
-	struct acpi_device *device;
-	acpi_handle handle = ej_event->handle;
+	struct acpi_device *device = ej_event->device;
+	acpi_handle handle = device->handle;
 	acpi_handle temp;
 	struct acpi_object_list arg_list;
 	union acpi_object arg;
 	acpi_status status = AE_OK;
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE; /* default */
 
-	if (acpi_bus_get_device(handle, &device))
-		goto err_out;
-
-	if (!device)
-		goto err_out;
-
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 		"Hot-removing device %s...\n", dev_name(&device->dev)));
 
@@ -215,7 +209,7 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 		goto err;
 	}
 
-	ej_event->handle = acpi_device->handle;
+	ej_event->device = acpi_device;
 	if (acpi_device->flags.eject_pending) {
 		/* event originated from ACPI eject notification */
 		ej_event->event = ACPI_NOTIFY_EJECT_REQUEST;
@@ -223,7 +217,7 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 	} else {
 		/* event originated from user */
 		ej_event->event = ACPI_OST_EC_OSPM_EJECT;
-		(void) acpi_evaluate_hotplug_ost(ej_event->handle,
+		(void) acpi_evaluate_hotplug_ost(acpi_device->handle,
 			ej_event->event, ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 	}
 

commit 05404d8f7b5c831e1a2c24bb782f0fe8ea02354c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 15 13:24:13 2013 +0100

    ACPI / scan: Add second pass to acpi_bus_trim()
    
    Make acpi_bus_trim() work in analogy with acpi_bus_scan() and carry
    out two passes such that ACPI drivers will be detached from device
    nodes being removed in the first pass and the device nodes themselves
    will be removed in the second pass.
    
    For this purpose split the driver unregistration out of
    acpi_bus_remove() into a new routine, acpi_bus_device_detach(), that
    will be executed by acpi_bus_trim() in the additional first pass as
    a post-order callback.
    
    This is necessary, because some ACPI drivers' .remove() routines
    unregister struct device objects associated with the ACPI device
    nodes being removed and that needs to happen while the ACPI
    device nodes are still around (for example, in case they need to be
    used for power management or similar things at that time).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 1ee62bd25828..d04d0b33656c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1374,22 +1374,6 @@ static int acpi_device_set_context(struct acpi_device *device)
 	return -ENODEV;
 }
 
-static acpi_status acpi_bus_remove(acpi_handle handle, u32 lvl_not_used,
-				   void *not_used, void **ret_not_used)
-{
-	struct acpi_device *dev = NULL;
-
-	if (acpi_bus_get_device(handle, &dev))
-		return AE_OK;
-
-	dev->removal_type = ACPI_BUS_REMOVAL_EJECT;
-	device_release_driver(&dev->dev);
-
-	acpi_device_unregister(dev);
-
-	return AE_OK;
-}
-
 static int acpi_add_single_object(struct acpi_device **child,
 				  acpi_handle handle, int type,
 				  unsigned long long sta, bool match_driver)
@@ -1642,8 +1626,38 @@ int acpi_bus_add(acpi_handle handle)
 }
 EXPORT_SYMBOL(acpi_bus_add);
 
+static acpi_status acpi_bus_device_detach(acpi_handle handle, u32 lvl_not_used,
+					  void *not_used, void **ret_not_used)
+{
+	struct acpi_device *device = NULL;
+
+	if (!acpi_bus_get_device(handle, &device)) {
+		device->removal_type = ACPI_BUS_REMOVAL_EJECT;
+		device_release_driver(&device->dev);
+	}
+	return AE_OK;
+}
+
+static acpi_status acpi_bus_remove(acpi_handle handle, u32 lvl_not_used,
+				   void *not_used, void **ret_not_used)
+{
+	struct acpi_device *device = NULL;
+
+	if (!acpi_bus_get_device(handle, &device))
+		acpi_device_unregister(device);
+
+	return AE_OK;
+}
+
 int acpi_bus_trim(struct acpi_device *start)
 {
+	/*
+	 * Execute acpi_bus_device_detach() as a post-order callback to detach
+	 * all ACPI drivers from the device nodes being removed.
+	 */
+	acpi_walk_namespace(ACPI_TYPE_ANY, start->handle, ACPI_UINT32_MAX, NULL,
+			    acpi_bus_device_detach, NULL, NULL);
+	acpi_bus_device_detach(start->handle, 0, NULL, NULL);
 	/*
 	 * Execute acpi_bus_remove() as a post-order callback to remove device
 	 * nodes in the given namespace scope.

commit cecdb193c8d91a42d9489d00618cc3dfff92e55a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 15 13:24:02 2013 +0100

    ACPI / scan: Change the implementation of acpi_bus_trim()
    
    The current acpi_bus_trim() implementation is not really
    straightforward and may be simplified significantly by using
    acpi_walk_namespace() with acpi_bus_remove() as a post-order
    callback.
    
    Observe that acpi_bus_remove(), as called by acpi_bus_trim(), cannot
    actually fail, because its first argument is guaranteed not to be
    NULL thanks to the acpi_bus_get_device() check in acpi_bus_trim(),
    so simply move the acpi_bus_get_device() check to acpi_bus_remove()
    and use acpi_walk_namespace() to execute it for every device under
    start->handle as a post-order callback.  The, run it directly for
    start->handle itself.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d14ce446b469..1ee62bd25828 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1374,17 +1374,20 @@ static int acpi_device_set_context(struct acpi_device *device)
 	return -ENODEV;
 }
 
-static int acpi_bus_remove(struct acpi_device *dev)
+static acpi_status acpi_bus_remove(acpi_handle handle, u32 lvl_not_used,
+				   void *not_used, void **ret_not_used)
 {
-	if (!dev)
-		return -EINVAL;
+	struct acpi_device *dev = NULL;
+
+	if (acpi_bus_get_device(handle, &dev))
+		return AE_OK;
 
 	dev->removal_type = ACPI_BUS_REMOVAL_EJECT;
 	device_release_driver(&dev->dev);
 
 	acpi_device_unregister(dev);
 
-	return 0;
+	return AE_OK;
 }
 
 static int acpi_add_single_object(struct acpi_device **child,
@@ -1641,51 +1644,14 @@ EXPORT_SYMBOL(acpi_bus_add);
 
 int acpi_bus_trim(struct acpi_device *start)
 {
-	acpi_status status;
-	struct acpi_device *parent, *child;
-	acpi_handle phandle, chandle;
-	acpi_object_type type;
-	u32 level = 1;
-	int err = 0;
-
-	parent = start;
-	phandle = start->handle;
-	child = chandle = NULL;
-
-	while ((level > 0) && parent && (!err)) {
-		status = acpi_get_next_object(ACPI_TYPE_ANY, phandle,
-					      chandle, &chandle);
-
-		/*
-		 * If this scope is exhausted then move our way back up.
-		 */
-		if (ACPI_FAILURE(status)) {
-			level--;
-			chandle = phandle;
-			acpi_get_parent(phandle, &phandle);
-			child = parent;
-			parent = parent->parent;
-			err = acpi_bus_remove(child);
-			continue;
-		}
-
-		status = acpi_get_type(chandle, &type);
-		if (ACPI_FAILURE(status)) {
-			continue;
-		}
-		/*
-		 * If there is a device corresponding to chandle then
-		 * parse it (depth-first).
-		 */
-		if (acpi_bus_get_device(chandle, &child) == 0) {
-			level++;
-			phandle = chandle;
-			chandle = NULL;
-			parent = child;
-		}
-		continue;
-	}
-	return err;
+	/*
+	 * Execute acpi_bus_remove() as a post-order callback to remove device
+	 * nodes in the given namespace scope.
+	 */
+	acpi_walk_namespace(ACPI_TYPE_ANY, start->handle, ACPI_UINT32_MAX, NULL,
+			    acpi_bus_remove, NULL, NULL);
+	acpi_bus_remove(start->handle, 0, NULL, NULL);
+	return 0;
 }
 EXPORT_SYMBOL_GPL(acpi_bus_trim);
 

commit ae281795ec92d35dd1631401829124acab965b1f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 15 13:23:53 2013 +0100

    ACPI / scan: Drop the second argument of acpi_bus_trim()
    
    All callers of acpi_bus_trim() pass 1 (true) as the second argument
    of it, so remove that argument entirely and change acpi_bus_trim()
    to always behave as though it were 1.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a26c09efc286..d14ce446b469 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -133,7 +133,7 @@ void acpi_bus_hot_remove_device(void *context)
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 		"Hot-removing device %s...\n", dev_name(&device->dev)));
 
-	if (acpi_bus_trim(device, 1)) {
+	if (acpi_bus_trim(device)) {
 		printk(KERN_ERR PREFIX
 				"Removing device failed\n");
 		goto err_out;
@@ -1374,7 +1374,7 @@ static int acpi_device_set_context(struct acpi_device *device)
 	return -ENODEV;
 }
 
-static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
+static int acpi_bus_remove(struct acpi_device *dev)
 {
 	if (!dev)
 		return -EINVAL;
@@ -1382,9 +1382,6 @@ static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 	dev->removal_type = ACPI_BUS_REMOVAL_EJECT;
 	device_release_driver(&dev->dev);
 
-	if (!rmdevice)
-		return 0;
-
 	acpi_device_unregister(dev);
 
 	return 0;
@@ -1642,7 +1639,7 @@ int acpi_bus_add(acpi_handle handle)
 }
 EXPORT_SYMBOL(acpi_bus_add);
 
-int acpi_bus_trim(struct acpi_device *start, int rmdevice)
+int acpi_bus_trim(struct acpi_device *start)
 {
 	acpi_status status;
 	struct acpi_device *parent, *child;
@@ -1668,12 +1665,7 @@ int acpi_bus_trim(struct acpi_device *start, int rmdevice)
 			acpi_get_parent(phandle, &phandle);
 			child = parent;
 			parent = parent->parent;
-
-			if (level == 0)
-				err = acpi_bus_remove(child, rmdevice);
-			else
-				err = acpi_bus_remove(child, 1);
-
+			err = acpi_bus_remove(child);
 			continue;
 		}
 

commit b17b537ac1429a609addb55bf985f5ebfcf4ae7b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 15 13:23:44 2013 +0100

    ACPI / scan: Drop the second argument of acpi_device_unregister()
    
    Drop the second argument of acpi_device_unregister(), type, which is
    not used by that function.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index bac357da3f29..a26c09efc286 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -701,7 +701,7 @@ static int acpi_device_register(struct acpi_device *device)
 	return result;
 }
 
-static void acpi_device_unregister(struct acpi_device *device, int type)
+static void acpi_device_unregister(struct acpi_device *device)
 {
 	mutex_lock(&acpi_device_lock);
 	if (device->parent)
@@ -1385,7 +1385,7 @@ static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 	if (!rmdevice)
 		return 0;
 
-	acpi_device_unregister(dev, ACPI_BUS_REMOVAL_EJECT);
+	acpi_device_unregister(dev);
 
 	return 0;
 }
@@ -1746,7 +1746,7 @@ int __init acpi_scan_init(void)
 		result = acpi_bus_scan_fixed();
 
 	if (result)
-		acpi_device_unregister(acpi_root, ACPI_BUS_REMOVAL_NORMAL);
+		acpi_device_unregister(acpi_root);
 	else
 		acpi_update_all_gpes();
 

commit abe99210e0f624cea39f1dc375ba818b201c0d7f
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Jan 11 22:08:09 2013 +0100

    ACPI / scan: Fix check of device_attach() return value.
    
    Since device_attach() returns 1 on success (a driver has been bound
    to the device), the check against its return value in
    acpi_bus_device_attach() should modified to take that into accout.
    Make it so.
    
    [rjw: Subject and changelog.]
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e380345b643a..bac357da3f29 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1593,7 +1593,7 @@ static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 	if (!acpi_match_device_ids(device, acpi_platform_device_ids)) {
 		/* This is a known good platform device. */
 		acpi_create_platform_device(device);
-	} else if (device_attach(&device->dev)) {
+	} else if (device_attach(&device->dev) < 0) {
 		status = AE_CTRL_DEPTH;
 	}
 	return status;

commit f95988de06ea62ef5bd861f06e9ef56cea405ed1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jan 7 21:17:02 2013 +0100

    ACPI / scan: Treat power resources in a special way
    
    Commit 805d410 (ACPI: Separate adding ACPI device objects from
    probing ACPI drivers) introduced an ACPI power resources management
    regression, because it didn't ensure that the power resources
    driver bind to the struct acpi_device objects corresponding
    to power resources as soon as they were created.  As a result,
    ACPI power management routines may attempt to access power resource
    objects before they are ready to use.
    
    To fix this problem, tell the acpi_add_single_object() in
    acpi_bus_check_add() to probe the driver for objects of type
    ACPI_BUS_TYPE_POWER.  This fix has been verified to work on
    HP nx6325 where the problem was first observed.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f8a0d0f7d197..e380345b643a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1558,7 +1558,8 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 		return AE_CTRL_DEPTH;
 	}
 
-	acpi_add_single_object(&device, handle, type, sta, false);
+	acpi_add_single_object(&device, handle, type, sta,
+			       type == ACPI_BUS_TYPE_POWER);
 	if (!device)
 		return AE_CTRL_DEPTH;
 

commit 4f5f64cf0cc916220aaa055992e31195470cfe37
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 4 23:00:54 2013 +0100

    ACPI / scan: Do not use dummy HID for system bus ACPI nodes
    
    At one point acpi_device_set_id() checks if acpi_device_hid(device)
    returns NULL, but that never happens, so system bus devices with an
    empty list of PNP IDs are given the dummy HID ("device") instead of
    the "system bus HID" ("LNXSYBUS").  Fix the code to use the right
    check.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: <stable@vger.kernel.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 53502d1bbf26..c88be6c37c30 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1346,7 +1346,7 @@ static void acpi_device_set_id(struct acpi_device *device)
 			acpi_add_id(device, ACPI_DOCK_HID);
 		else if (!acpi_ibm_smbus_match(device))
 			acpi_add_id(device, ACPI_SMBUS_IBM_HID);
-		else if (!acpi_device_hid(device) &&
+		else if (list_empty(&device->pnp.ids) &&
 			 ACPI_IS_ROOT_DEVICE(device->parent)) {
 			acpi_add_id(device, ACPI_BUS_HID); /* \_SB, LNXSYBUS */
 			strcpy(device->pnp.device_name, ACPI_BUS_DEVICE_NAME);

commit 3eec5f7a1955ead549020ec2f60235ea6a4a2252
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 23 00:03:03 2012 +0100

    ACPI: Drop ACPI device .bind() and .unbind() callbacks
    
    Drop the .bind() and .unbind() that have no more users from
    struct acpi_device_ops and remove all of the code referring to
    them from drivers/acpi/scan.c.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 3d44c705a3a2..f8a0d0f7d197 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1385,29 +1385,11 @@ static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 	if (!rmdevice)
 		return 0;
 
-	/*
-	 * unbind _ADR-Based Devices when hot removal
-	 */
-	if (dev->flags.bus_address) {
-		if ((dev->parent) && (dev->parent->ops.unbind))
-			dev->parent->ops.unbind(dev);
-	}
 	acpi_device_unregister(dev, ACPI_BUS_REMOVAL_EJECT);
 
 	return 0;
 }
 
-/*
- * acpi_hot_add_bind - Bind _ADR-based devices on hot-add.
- * @device: ACPI device node to bind.
- */
-static void acpi_hot_add_bind(struct acpi_device *device)
-{
-	if (device->flags.bus_address
-	    && device->parent && device->parent->ops.bind)
-		device->parent->ops.bind(device);
-}
-
 static int acpi_add_single_object(struct acpi_device **child,
 				  acpi_handle handle, int type,
 				  unsigned long long sta, bool match_driver)
@@ -1479,9 +1461,6 @@ static int acpi_add_single_object(struct acpi_device **child,
 	device->flags.match_driver = match_driver;
 	result = acpi_device_register(device);
 
-	if (device->flags.match_driver)
-		acpi_hot_add_bind(device);
-
 end:
 	if (!result) {
 		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
@@ -1584,7 +1563,6 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 		return AE_CTRL_DEPTH;
 
 	device->flags.match_driver = true;
-	acpi_hot_add_bind(device);
 
  out:
 	if (!*return_value)

commit 0cd6ac52b333f66ee64e50ed216ec99231092dcd
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 21 00:36:49 2012 +0100

    ACPI: Make acpi_bus_scan() and acpi_bus_add() take only one argument
    
    The callers of acpi_bus_add() usually assume that if it has
    succeeded, then a struct acpi_device object has been attached to
    the handle passed as the first argument.  Unfortunately, however,
    this assumption is wrong, because acpi_bus_scan(), and acpi_bus_add()
    too as a result, may return a pointer to a different struct
    acpi_device object on success (it may be an object corresponding to
    one of the descendant ACPI nodes in the namespace scope below that
    handle).
    
    For this reason, the callers of acpi_bus_add() who care about
    whether or not a struct acpi_device object has been created for
    its first argument need to check that using acpi_bus_get_device()
    anyway, so the second argument of acpi_bus_add() is not really
    useful for them.  The same observation applies to acpi_bus_scan()
    executed directly from acpi_scan_init().
    
    Therefore modify the relevant callers of acpi_bus_add() to check the
    existence of the struct acpi_device in question with the help of
    acpi_bus_get_device() and drop the no longer necessary second
    argument of acpi_bus_add().  Accordingly, modify acpi_scan_init() to
    use acpi_bus_get_device() to get acpi_root and drop the no longer
    needed second argument of acpi_bus_scan().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e3aed481aed2..3d44c705a3a2 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1620,37 +1620,27 @@ static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 	return status;
 }
 
-static int acpi_bus_scan(acpi_handle handle, struct acpi_device **child)
+static int acpi_bus_scan(acpi_handle handle)
 {
 	void *device = NULL;
-	acpi_status status;
-	int ret = -ENODEV;
 
-	status = acpi_bus_check_add(handle, 0, NULL, &device);
-	if (ACPI_SUCCESS(status))
+	if (ACPI_SUCCESS(acpi_bus_check_add(handle, 0, NULL, &device)))
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
 				    acpi_bus_check_add, NULL, NULL, &device);
 
 	if (!device)
-		goto out;
+		return -ENODEV;
 
-	ret = 0;
-	status = acpi_bus_device_attach(handle, 0, NULL, NULL);
-	if (ACPI_SUCCESS(status))
+	if (ACPI_SUCCESS(acpi_bus_device_attach(handle, 0, NULL, NULL)))
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
 				    acpi_bus_device_attach, NULL, NULL, NULL);
 
- out:
-	if (child)
-		*child = device;
-
-	return ret;
+	return 0;
 }
 
 /**
  * acpi_bus_add - Add ACPI device node objects in a given namespace scope.
  * @handle: Root of the namespace scope to scan.
- * @ret: Location to store a return struct acpi_device pointer.
  *
  * Scan a given ACPI tree (probably recently hot-plugged) and create and add
  * found devices.
@@ -1659,21 +1649,12 @@ static int acpi_bus_scan(acpi_handle handle, struct acpi_device **child)
  * there has been a real error.  There just have been no suitable ACPI objects
  * in the table trunk from which the kernel could create a device and add an
  * appropriate driver.
- *
- * If 0 is returned, the memory location pointed to by @ret will be populated
- * with a pointer to a struct acpi_device created while scanning the namespace.
- * If @handle corresponds to a device node, that will be a pointer to the struct
- * acpi_device object corresponding to @handle.  Otherwise, it will be a pointer
- * to a struct acpi_device corresponding to one of its descendants.
- *
- * If an error code is returned, NULL will be stored in the memory location
- * pointed to by @ret.
  */
-int acpi_bus_add(acpi_handle handle, struct acpi_device **ret)
+int acpi_bus_add(acpi_handle handle)
 {
 	int err;
 
-	err = acpi_bus_scan(handle, ret);
+	err = acpi_bus_scan(handle);
 	if (err)
 		return err;
 
@@ -1777,8 +1758,11 @@ int __init acpi_scan_init(void)
 	/*
 	 * Enumerate devices in the ACPI namespace.
 	 */
-	result = acpi_bus_scan(ACPI_ROOT_OBJECT, &acpi_root);
+	result = acpi_bus_scan(ACPI_ROOT_OBJECT);
+	if (result)
+		return result;
 
+	result = acpi_bus_get_device(ACPI_ROOT_OBJECT, &acpi_root);
 	if (!result)
 		result = acpi_bus_scan_fixed();
 

commit 209d3b1743c8187c67cc75dbe9fefbcd3121fba0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 21 00:36:48 2012 +0100

    ACPI: Replace ACPI device add_type field with a match_driver flag
    
    After the removal of the second argument of acpi_bus_scan() there is
    no difference between the ACPI_BUS_ADD_MATCH and ACPI_BUS_ADD_START
    add types, so the add_type field in struct acpi_device may be
    replaced with a single flag.  Do that calling the flag match_driver.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index eb54f98bb728..e3aed481aed2 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -494,7 +494,7 @@ static int acpi_bus_match(struct device *dev, struct device_driver *drv)
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 	struct acpi_driver *acpi_drv = to_acpi_driver(drv);
 
-	return acpi_dev->add_type >= ACPI_BUS_ADD_MATCH
+	return acpi_dev->flags.match_driver
 		&& !acpi_match_device_ids(acpi_dev, acpi_drv->ids);
 }
 
@@ -1410,8 +1410,7 @@ static void acpi_hot_add_bind(struct acpi_device *device)
 
 static int acpi_add_single_object(struct acpi_device **child,
 				  acpi_handle handle, int type,
-				  unsigned long long sta,
-				  enum acpi_bus_add_type add_type)
+				  unsigned long long sta, bool match_driver)
 {
 	int result;
 	struct acpi_device *device;
@@ -1427,7 +1426,6 @@ static int acpi_add_single_object(struct acpi_device **child,
 	device->device_type = type;
 	device->handle = handle;
 	device->parent = acpi_bus_get_parent(handle);
-	device->add_type = add_type;
 	STRUCT_TO_INT(device->status) = sta;
 
 	acpi_device_get_busid(device);
@@ -1478,9 +1476,10 @@ static int acpi_add_single_object(struct acpi_device **child,
 	if ((result = acpi_device_set_context(device)))
 		goto end;
 
+	device->flags.match_driver = match_driver;
 	result = acpi_device_register(device);
 
-	if (device->add_type >= ACPI_BUS_ADD_MATCH)
+	if (device->flags.match_driver)
 		acpi_hot_add_bind(device);
 
 end:
@@ -1509,7 +1508,7 @@ static void acpi_bus_add_power_resource(acpi_handle handle)
 	acpi_bus_get_device(handle, &device);
 	if (!device)
 		acpi_add_single_object(&device, handle, ACPI_BUS_TYPE_POWER,
-					ACPI_STA_DEFAULT, ACPI_BUS_ADD_START);
+					ACPI_STA_DEFAULT, true);
 }
 
 static int acpi_bus_type_and_status(acpi_handle handle, int *type,
@@ -1580,11 +1579,11 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 		return AE_CTRL_DEPTH;
 	}
 
-	acpi_add_single_object(&device, handle, type, sta, ACPI_BUS_ADD_BASIC);
+	acpi_add_single_object(&device, handle, type, sta, false);
 	if (!device)
 		return AE_CTRL_DEPTH;
 
-	device->add_type = ACPI_BUS_ADD_START;
+	device->flags.match_driver = true;
 	acpi_hot_add_bind(device);
 
  out:
@@ -1749,16 +1748,14 @@ static int acpi_bus_scan_fixed(void)
 	if ((acpi_gbl_FADT.flags & ACPI_FADT_POWER_BUTTON) == 0) {
 		result = acpi_add_single_object(&device, NULL,
 						ACPI_BUS_TYPE_POWER_BUTTON,
-						ACPI_STA_DEFAULT,
-						ACPI_BUS_ADD_START);
+						ACPI_STA_DEFAULT, true);
 		device_init_wakeup(&device->dev, true);
 	}
 
 	if ((acpi_gbl_FADT.flags & ACPI_FADT_SLEEP_BUTTON) == 0) {
 		result = acpi_add_single_object(&device, NULL,
 						ACPI_BUS_TYPE_SLEEP_BUTTON,
-						ACPI_STA_DEFAULT,
-						ACPI_BUS_ADD_START);
+						ACPI_STA_DEFAULT, true);
 	}
 
 	return result;

commit e3863094c6f9b2f980d6e7a5cad6b4d03a4dd579
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 21 00:36:47 2012 +0100

    ACPI: Drop the second argument of acpi_bus_scan()
    
    After the removal of acpi_start_single_object() and acpi_bus_start()
    the second argument of acpi_bus_scan() is not necessary any more,
    so drop it and update acpi_bus_check_add() accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 25095bf57bba..eb54f98bb728 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1551,8 +1551,8 @@ static int acpi_bus_type_and_status(acpi_handle handle, int *type,
 	return 0;
 }
 
-static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
-				      void *context, void **return_value)
+static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
+				      void *not_used, void **return_value)
 {
 	struct acpi_device *device = NULL;
 	int type;
@@ -1584,7 +1584,7 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 	if (!device)
 		return AE_CTRL_DEPTH;
 
-	device->add_type = context ? ACPI_BUS_ADD_START : ACPI_BUS_ADD_MATCH;
+	device->add_type = ACPI_BUS_ADD_START;
 	acpi_hot_add_bind(device);
 
  out:
@@ -1621,18 +1621,16 @@ static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 	return status;
 }
 
-static int acpi_bus_scan(acpi_handle handle, bool start,
-			 struct acpi_device **child)
+static int acpi_bus_scan(acpi_handle handle, struct acpi_device **child)
 {
 	void *device = NULL;
 	acpi_status status;
 	int ret = -ENODEV;
 
-	status = acpi_bus_check_add(handle, 0, (void *)start, &device);
+	status = acpi_bus_check_add(handle, 0, NULL, &device);
 	if (ACPI_SUCCESS(status))
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
-				    acpi_bus_check_add, NULL, (void *)start,
-				    &device);
+				    acpi_bus_check_add, NULL, NULL, &device);
 
 	if (!device)
 		goto out;
@@ -1676,7 +1674,7 @@ int acpi_bus_add(acpi_handle handle, struct acpi_device **ret)
 {
 	int err;
 
-	err = acpi_bus_scan(handle, false, ret);
+	err = acpi_bus_scan(handle, ret);
 	if (err)
 		return err;
 
@@ -1782,7 +1780,7 @@ int __init acpi_scan_init(void)
 	/*
 	 * Enumerate devices in the ACPI namespace.
 	 */
-	result = acpi_bus_scan(ACPI_ROOT_OBJECT, true, &acpi_root);
+	result = acpi_bus_scan(ACPI_ROOT_OBJECT, &acpi_root);
 
 	if (!result)
 		result = acpi_bus_scan_fixed();

commit 636458de36f1fb4cdd318387d2f45604e451b17a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 21 00:36:47 2012 +0100

    ACPI: Remove the arguments of acpi_bus_add() that are not used
    
    Notice that acpi_bus_add() uses only 2 of its 4 arguments and
    redefine its header to match the body.  Update all of its callers as
    necessary and observe that this leads to quite a number of removed
    lines of code (Linus will like that).
    
    Add a kerneldoc comment documenting acpi_bus_add() and wonder how
    its callers make wrong assumptions about the second argument (make
    note to self to take care of that later).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 6321cab4e5ff..25095bf57bba 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1650,25 +1650,33 @@ static int acpi_bus_scan(acpi_handle handle, bool start,
 	return ret;
 }
 
-/*
- * acpi_bus_add
+/**
+ * acpi_bus_add - Add ACPI device node objects in a given namespace scope.
+ * @handle: Root of the namespace scope to scan.
+ * @ret: Location to store a return struct acpi_device pointer.
+ *
+ * Scan a given ACPI tree (probably recently hot-plugged) and create and add
+ * found devices.
  *
- * scan a given ACPI tree and (probably recently hot-plugged)
- * create and add found devices.
+ * If no devices were found, -ENODEV is returned, but it does not mean that
+ * there has been a real error.  There just have been no suitable ACPI objects
+ * in the table trunk from which the kernel could create a device and add an
+ * appropriate driver.
  *
- * If no devices were found -ENODEV is returned which does not
- * mean that this is a real error, there just have been no suitable
- * ACPI objects in the table trunk from which the kernel could create
- * a device and add an appropriate driver.
+ * If 0 is returned, the memory location pointed to by @ret will be populated
+ * with a pointer to a struct acpi_device created while scanning the namespace.
+ * If @handle corresponds to a device node, that will be a pointer to the struct
+ * acpi_device object corresponding to @handle.  Otherwise, it will be a pointer
+ * to a struct acpi_device corresponding to one of its descendants.
+ *
+ * If an error code is returned, NULL will be stored in the memory location
+ * pointed to by @ret.
  */
-
-int
-acpi_bus_add(struct acpi_device **child,
-	     struct acpi_device *parent, acpi_handle handle, int type)
+int acpi_bus_add(acpi_handle handle, struct acpi_device **ret)
 {
 	int err;
 
-	err = acpi_bus_scan(handle, false, child);
+	err = acpi_bus_scan(handle, false, ret);
 	if (err)
 		return err;
 

commit 02f57c67a8677ae55dcdd256a2a7abaf41e4cc1f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 21 00:36:46 2012 +0100

    ACPI: Remove acpi_start_single_object() and acpi_bus_start()
    
    The ACPI PCI root bridge driver was the only ACPI driver implementing
    the .start() callback, which isn't used by any ACPI drivers any more
    now.
    
    For this reason, acpi_start_single_object() has no purpose any more,
    so remove it and all references to it.  Also remove
    acpi_bus_start_device(), whose only purpose was to call
    acpi_start_single_object().
    
    Moreover, since after the removal of acpi_bus_start_device() the
    only purpose of acpi_bus_start() remains to call
    acpi_update_all_gpes(), move that into acpi_bus_add() and drop
    acpi_bus_start() too, remove its header from acpi_bus.h and
    update all of its former users accordingly.
    
    This change was previously proposed in a different from by
    Yinghai Lu.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index eb7ecb1f2032..6321cab4e5ff 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -571,7 +571,6 @@ static void acpi_device_remove_notify_handler(struct acpi_device *device)
 }
 
 static int acpi_bus_driver_init(struct acpi_device *, struct acpi_driver *);
-static int acpi_start_single_object(struct acpi_device *);
 static int acpi_device_probe(struct device * dev)
 {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
@@ -580,9 +579,6 @@ static int acpi_device_probe(struct device * dev)
 
 	ret = acpi_bus_driver_init(acpi_dev, acpi_drv);
 	if (!ret) {
-		if (acpi_dev->add_type == ACPI_BUS_ADD_START)
-			acpi_start_single_object(acpi_dev);
-
 		if (acpi_drv->ops.notify) {
 			ret = acpi_device_install_notify_handler(acpi_dev);
 			if (ret) {
@@ -761,24 +757,6 @@ acpi_bus_driver_init(struct acpi_device *device, struct acpi_driver *driver)
 	return 0;
 }
 
-static int acpi_start_single_object(struct acpi_device *device)
-{
-	int result = 0;
-	struct acpi_driver *driver;
-
-
-	if (!(driver = device->driver))
-		return 0;
-
-	if (driver->ops.start) {
-		result = driver->ops.start(device);
-		if (result && driver->ops.remove)
-			driver->ops.remove(device, ACPI_BUS_REMOVAL_NORMAL);
-	}
-
-	return result;
-}
-
 /**
  * acpi_bus_register_driver - register a driver with the ACPI bus
  * @driver: driver being registered
@@ -1673,59 +1651,31 @@ static int acpi_bus_scan(acpi_handle handle, bool start,
 }
 
 /*
- * acpi_bus_add and acpi_bus_start
+ * acpi_bus_add
  *
  * scan a given ACPI tree and (probably recently hot-plugged)
- * create and add or starts found devices.
+ * create and add found devices.
  *
  * If no devices were found -ENODEV is returned which does not
  * mean that this is a real error, there just have been no suitable
  * ACPI objects in the table trunk from which the kernel could create
- * a device and add/start an appropriate driver.
+ * a device and add an appropriate driver.
  */
 
 int
 acpi_bus_add(struct acpi_device **child,
 	     struct acpi_device *parent, acpi_handle handle, int type)
 {
-	return acpi_bus_scan(handle, false, child);
-}
-EXPORT_SYMBOL(acpi_bus_add);
-
-static acpi_status acpi_bus_start_device(acpi_handle handle, u32 lvl,
-					 void *not_used, void **ret_not_used)
-{
-	struct acpi_device *device;
-	unsigned long long sta_not_used;
-	int type_not_used;
-
-	/*
-	 * Ignore errors ignored by acpi_bus_check_add() to avoid terminating
-	 * namespace walks prematurely.
-	 */
-	if (acpi_bus_type_and_status(handle, &type_not_used, &sta_not_used))
-		return AE_OK;
-
-	if (acpi_bus_get_device(handle, &device))
-		return AE_CTRL_DEPTH;
-
-	return acpi_start_single_object(device);
-}
-
-int acpi_bus_start(struct acpi_device *device)
-{
-	if (!device)
-		return -EINVAL;
+	int err;
 
-	if (ACPI_SUCCESS(acpi_start_single_object(device)))
-		acpi_walk_namespace(ACPI_TYPE_ANY, device->handle,
-				    ACPI_UINT32_MAX, acpi_bus_start_device,
-				    NULL, NULL, NULL);
+	err = acpi_bus_scan(handle, false, child);
+	if (err)
+		return err;
 
 	acpi_update_all_gpes();
 	return 0;
 }
-EXPORT_SYMBOL(acpi_bus_start);
+EXPORT_SYMBOL(acpi_bus_add);
 
 int acpi_bus_trim(struct acpi_device *start, int rmdevice)
 {

commit 4002bf384cc567a843a7d16c95db54a7d77b16c6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 21 00:36:44 2012 +0100

    ACPI: Change the ordering of acpi_bus_check_add()
    
    If acpi_bus_check_add() is called for a handle already having an
    existing struct acpi_device object attached, it is not necessary to
    check the type and status of the device correspondig to it, so
    change the ordering of acpi_bus_check_add() to avoid that.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 7082d11ce5d2..eb7ecb1f2032 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1582,6 +1582,10 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 	acpi_status status;
 	int result;
 
+	acpi_bus_get_device(handle, &device);
+	if (device)
+		goto out;
+
 	result = acpi_bus_type_and_status(handle, &type, &sta);
 	if (result)
 		return AE_OK;
@@ -1598,18 +1602,14 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 		return AE_CTRL_DEPTH;
 	}
 
-	acpi_bus_get_device(handle, &device);
-	if (!device) {
-		acpi_add_single_object(&device, handle, type, sta,
-				       ACPI_BUS_ADD_BASIC);
-		if (!device)
-			return AE_CTRL_DEPTH;
+	acpi_add_single_object(&device, handle, type, sta, ACPI_BUS_ADD_BASIC);
+	if (!device)
+		return AE_CTRL_DEPTH;
 
-		device->add_type = context ?
-					ACPI_BUS_ADD_START : ACPI_BUS_ADD_MATCH;
-		acpi_hot_add_bind(device);
-	}
+	device->add_type = context ? ACPI_BUS_ADD_START : ACPI_BUS_ADD_MATCH;
+	acpi_hot_add_bind(device);
 
+ out:
 	if (!*return_value)
 		*return_value = device;
 

commit a2d06a1a0851fb3d7e775b9d878cdffb9e0300ee
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 21 00:36:43 2012 +0100

    ACPI: Replace struct acpi_bus_ops with enum type
    
    Notice that one member of struct acpi_bus_ops, acpi_op_add, is not
    used anywhere any more and the relationship between its remaining
    members, acpi_op_match and acpi_op_start, is such that it doesn't
    make sense to set the latter without setting the former at the same
    time.  Therefore, replace struct acpi_bus_ops with new a enum type,
    enum acpi_bus_add_type, with three values, ACPI_BUS_ADD_BASIC,
    ACPI_BUS_ADD_MATCH, ACPI_BUS_ADD_START, corresponding to
    both acpi_op_match and acpi_op_start unset, acpi_op_match set and
    acpi_op_start unset, and both acpi_op_match and acpi_op_start set,
    respectively.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8dde0e7f68d8..7082d11ce5d2 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -494,7 +494,7 @@ static int acpi_bus_match(struct device *dev, struct device_driver *drv)
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 	struct acpi_driver *acpi_drv = to_acpi_driver(drv);
 
-	return acpi_dev->bus_ops.acpi_op_match
+	return acpi_dev->add_type >= ACPI_BUS_ADD_MATCH
 		&& !acpi_match_device_ids(acpi_dev, acpi_drv->ids);
 }
 
@@ -580,7 +580,7 @@ static int acpi_device_probe(struct device * dev)
 
 	ret = acpi_bus_driver_init(acpi_dev, acpi_drv);
 	if (!ret) {
-		if (acpi_dev->bus_ops.acpi_op_start)
+		if (acpi_dev->add_type == ACPI_BUS_ADD_START)
 			acpi_start_single_object(acpi_dev);
 
 		if (acpi_drv->ops.notify) {
@@ -1433,7 +1433,7 @@ static void acpi_hot_add_bind(struct acpi_device *device)
 static int acpi_add_single_object(struct acpi_device **child,
 				  acpi_handle handle, int type,
 				  unsigned long long sta,
-				  struct acpi_bus_ops *ops)
+				  enum acpi_bus_add_type add_type)
 {
 	int result;
 	struct acpi_device *device;
@@ -1449,7 +1449,7 @@ static int acpi_add_single_object(struct acpi_device **child,
 	device->device_type = type;
 	device->handle = handle;
 	device->parent = acpi_bus_get_parent(handle);
-	device->bus_ops = *ops; /* workround for not call .start */
+	device->add_type = add_type;
 	STRUCT_TO_INT(device->status) = sta;
 
 	acpi_device_get_busid(device);
@@ -1502,7 +1502,7 @@ static int acpi_add_single_object(struct acpi_device **child,
 
 	result = acpi_device_register(device);
 
-	if (device->bus_ops.acpi_op_match)
+	if (device->add_type >= ACPI_BUS_ADD_MATCH)
 		acpi_hot_add_bind(device);
 
 end:
@@ -1526,16 +1526,12 @@ static int acpi_add_single_object(struct acpi_device **child,
 
 static void acpi_bus_add_power_resource(acpi_handle handle)
 {
-	struct acpi_bus_ops ops = {
-		.acpi_op_start = 1,
-		.acpi_op_match = 1,
-	};
 	struct acpi_device *device = NULL;
 
 	acpi_bus_get_device(handle, &device);
 	if (!device)
 		acpi_add_single_object(&device, handle, ACPI_BUS_TYPE_POWER,
-					ACPI_STA_DEFAULT, &ops);
+					ACPI_STA_DEFAULT, ACPI_BUS_ADD_START);
 }
 
 static int acpi_bus_type_and_status(acpi_handle handle, int *type,
@@ -1604,16 +1600,13 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 
 	acpi_bus_get_device(handle, &device);
 	if (!device) {
-		struct acpi_bus_ops ops = {
-			.acpi_op_start = !!context,
-			.acpi_op_match = 0,
-		};
-
-		acpi_add_single_object(&device, handle, type, sta, &ops);
+		acpi_add_single_object(&device, handle, type, sta,
+				       ACPI_BUS_ADD_BASIC);
 		if (!device)
 			return AE_CTRL_DEPTH;
 
-		device->bus_ops.acpi_op_match = 1;
+		device->add_type = context ?
+					ACPI_BUS_ADD_START : ACPI_BUS_ADD_MATCH;
 		acpi_hot_add_bind(device);
 	}
 
@@ -1793,10 +1786,6 @@ static int acpi_bus_scan_fixed(void)
 {
 	int result = 0;
 	struct acpi_device *device = NULL;
-	struct acpi_bus_ops ops = {
-		.acpi_op_start = 1,
-		.acpi_op_match = 1,
-	};
 
 	/*
 	 * Enumerate all fixed-feature devices.
@@ -1805,7 +1794,7 @@ static int acpi_bus_scan_fixed(void)
 		result = acpi_add_single_object(&device, NULL,
 						ACPI_BUS_TYPE_POWER_BUTTON,
 						ACPI_STA_DEFAULT,
-						&ops);
+						ACPI_BUS_ADD_START);
 		device_init_wakeup(&device->dev, true);
 	}
 
@@ -1813,7 +1802,7 @@ static int acpi_bus_scan_fixed(void)
 		result = acpi_add_single_object(&device, NULL,
 						ACPI_BUS_TYPE_SLEEP_BUTTON,
 						ACPI_STA_DEFAULT,
-						&ops);
+						ACPI_BUS_ADD_START);
 	}
 
 	return result;

commit ca7b3c4f3d85bf7ec225eebb43b6af0a25499c6c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 21 00:36:42 2012 +0100

    ACPI: Reduce the usage of struct acpi_bus_ops
    
    Objects of type struct acpi_bus_ops are currently used to pass
    information between different parts of the ACPI namespace scanning
    code, sometimes in quite convoluted ways.  It turns out that that
    is not necessary in some cases, so simplify the code by reducing
    the utilization of struct acpi_bus_ops objects where clearly
    possible.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f3bcaf6c6bd4..8dde0e7f68d8 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1527,7 +1527,6 @@ static int acpi_add_single_object(struct acpi_device **child,
 static void acpi_bus_add_power_resource(acpi_handle handle)
 {
 	struct acpi_bus_ops ops = {
-		.acpi_op_add = 1,
 		.acpi_op_start = 1,
 		.acpi_op_match = 1,
 	};
@@ -1581,7 +1580,6 @@ static int acpi_bus_type_and_status(acpi_handle handle, int *type,
 static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 				      void *context, void **return_value)
 {
-	struct acpi_bus_ops *ops = context;
 	struct acpi_device *device = NULL;
 	int type;
 	unsigned long long sta;
@@ -1605,11 +1603,13 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 	}
 
 	acpi_bus_get_device(handle, &device);
-	if (ops->acpi_op_add && !device) {
-		struct acpi_bus_ops add_ops = *ops;
+	if (!device) {
+		struct acpi_bus_ops ops = {
+			.acpi_op_start = !!context,
+			.acpi_op_match = 0,
+		};
 
-		add_ops.acpi_op_match = 0;
-		acpi_add_single_object(&device, handle, type, sta, &add_ops);
+		acpi_add_single_object(&device, handle, type, sta, &ops);
 		if (!device)
 			return AE_CTRL_DEPTH;
 
@@ -1650,17 +1650,18 @@ static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
 	return status;
 }
 
-static int acpi_bus_scan(acpi_handle handle, struct acpi_bus_ops *ops,
+static int acpi_bus_scan(acpi_handle handle, bool start,
 			 struct acpi_device **child)
 {
 	void *device = NULL;
 	acpi_status status;
 	int ret = -ENODEV;
 
-	status = acpi_bus_check_add(handle, 0, ops, &device);
+	status = acpi_bus_check_add(handle, 0, (void *)start, &device);
 	if (ACPI_SUCCESS(status))
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
-				    acpi_bus_check_add, NULL, ops, &device);
+				    acpi_bus_check_add, NULL, (void *)start,
+				    &device);
 
 	if (!device)
 		goto out;
@@ -1694,9 +1695,7 @@ int
 acpi_bus_add(struct acpi_device **child,
 	     struct acpi_device *parent, acpi_handle handle, int type)
 {
-	struct acpi_bus_ops ops = { .acpi_op_add = 1, };
-
-	return acpi_bus_scan(handle, &ops, child);
+	return acpi_bus_scan(handle, false, child);
 }
 EXPORT_SYMBOL(acpi_bus_add);
 
@@ -1794,12 +1793,10 @@ static int acpi_bus_scan_fixed(void)
 {
 	int result = 0;
 	struct acpi_device *device = NULL;
-	struct acpi_bus_ops ops;
-
-	memset(&ops, 0, sizeof(ops));
-	ops.acpi_op_add = 1;
-	ops.acpi_op_start = 1;
-	ops.acpi_op_match = 1;
+	struct acpi_bus_ops ops = {
+		.acpi_op_start = 1,
+		.acpi_op_match = 1,
+	};
 
 	/*
 	 * Enumerate all fixed-feature devices.
@@ -1825,11 +1822,6 @@ static int acpi_bus_scan_fixed(void)
 int __init acpi_scan_init(void)
 {
 	int result;
-	struct acpi_bus_ops ops;
-
-	memset(&ops, 0, sizeof(ops));
-	ops.acpi_op_add = 1;
-	ops.acpi_op_start = 1;
 
 	result = bus_register(&acpi_bus_type);
 	if (result) {
@@ -1843,7 +1835,7 @@ int __init acpi_scan_init(void)
 	/*
 	 * Enumerate devices in the ACPI namespace.
 	 */
-	result = acpi_bus_scan(ACPI_ROOT_OBJECT, &ops, &acpi_root);
+	result = acpi_bus_scan(ACPI_ROOT_OBJECT, true, &acpi_root);
 
 	if (!result)
 		result = acpi_bus_scan_fixed();

commit 0fc300b0537c6a6a7f2b261b6c339dc498cd1702
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 21 00:36:41 2012 +0100

    ACPI: Make acpi_bus_add() and acpi_bus_start() visibly different
    
    The current ACPI namespace scanning code suggests that acpi_bus_add()
    and acpi_bus_start() share some code.  In fact, however, they are
    completely different code paths (except for the initial checks), so
    refactor the code to make that distinction visibly clear.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a7e81ac2cd0c..f3bcaf6c6bd4 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1623,10 +1623,9 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 	return AE_OK;
 }
 
-static acpi_status acpi_bus_probe_start(acpi_handle handle, u32 lvl,
-					void *context, void **not_used)
+static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
+					  void *not_used, void **ret_not_used)
 {
-	struct acpi_bus_ops *ops = context;
 	acpi_status status = AE_OK;
 	struct acpi_device *device;
 	unsigned long long sta_not_used;
@@ -1642,16 +1641,11 @@ static acpi_status acpi_bus_probe_start(acpi_handle handle, u32 lvl,
 	if (acpi_bus_get_device(handle, &device))
 		return AE_CTRL_DEPTH;
 
-	if (ops->acpi_op_add) {
-		if (!acpi_match_device_ids(device, acpi_platform_device_ids)) {
-			/* This is a known good platform device. */
-			acpi_create_platform_device(device);
-		} else if (device_attach(&device->dev)) {
-			status = AE_CTRL_DEPTH;
-		}
-	} else if (ops->acpi_op_start) {
-		if (ACPI_FAILURE(acpi_start_single_object(device)))
-			status = AE_CTRL_DEPTH;
+	if (!acpi_match_device_ids(device, acpi_platform_device_ids)) {
+		/* This is a known good platform device. */
+		acpi_create_platform_device(device);
+	} else if (device_attach(&device->dev)) {
+		status = AE_CTRL_DEPTH;
 	}
 	return status;
 }
@@ -1672,10 +1666,10 @@ static int acpi_bus_scan(acpi_handle handle, struct acpi_bus_ops *ops,
 		goto out;
 
 	ret = 0;
-	status = acpi_bus_probe_start(handle, 0, ops, NULL);
+	status = acpi_bus_device_attach(handle, 0, NULL, NULL);
 	if (ACPI_SUCCESS(status))
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
-				    acpi_bus_probe_start, NULL, ops, NULL);
+				    acpi_bus_device_attach, NULL, NULL, NULL);
 
  out:
 	if (child)
@@ -1700,31 +1694,44 @@ int
 acpi_bus_add(struct acpi_device **child,
 	     struct acpi_device *parent, acpi_handle handle, int type)
 {
-	struct acpi_bus_ops ops;
-
-	memset(&ops, 0, sizeof(ops));
-	ops.acpi_op_add = 1;
+	struct acpi_bus_ops ops = { .acpi_op_add = 1, };
 
 	return acpi_bus_scan(handle, &ops, child);
 }
 EXPORT_SYMBOL(acpi_bus_add);
 
-int acpi_bus_start(struct acpi_device *device)
+static acpi_status acpi_bus_start_device(acpi_handle handle, u32 lvl,
+					 void *not_used, void **ret_not_used)
 {
-	struct acpi_bus_ops ops;
-	int result;
+	struct acpi_device *device;
+	unsigned long long sta_not_used;
+	int type_not_used;
+
+	/*
+	 * Ignore errors ignored by acpi_bus_check_add() to avoid terminating
+	 * namespace walks prematurely.
+	 */
+	if (acpi_bus_type_and_status(handle, &type_not_used, &sta_not_used))
+		return AE_OK;
+
+	if (acpi_bus_get_device(handle, &device))
+		return AE_CTRL_DEPTH;
+
+	return acpi_start_single_object(device);
+}
 
+int acpi_bus_start(struct acpi_device *device)
+{
 	if (!device)
 		return -EINVAL;
 
-	memset(&ops, 0, sizeof(ops));
-	ops.acpi_op_start = 1;
-
-	result = acpi_bus_scan(device->handle, &ops, NULL);
+	if (ACPI_SUCCESS(acpi_start_single_object(device)))
+		acpi_walk_namespace(ACPI_TYPE_ANY, device->handle,
+				    ACPI_UINT32_MAX, acpi_bus_start_device,
+				    NULL, NULL, NULL);
 
 	acpi_update_all_gpes();
-
-	return result;
+	return 0;
 }
 EXPORT_SYMBOL(acpi_bus_start);
 

commit 92ef2a25c763338905dce8344a0584606f842920
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 21 00:36:40 2012 +0100

    ACPI: Change the ordering of PCI root bridge driver registrarion
    
    Instead of running acpi_pci_root_init() from a separate subsys
    initcall, call it directly from acpi_scan_init() before scanning the
    ACPI namespace for the first time, so that the PCI root bridge
    driver's .add() routine, acpi_pci_root_start(), is always run
    before binding ACPI drivers or attaching "companion" device objects
    to struct acpi_device objects below the root bridge's device node in
    the ACPI namespace.
    
    The first, simpler reason for doing this is that it makes the
    situation during boot more similar to the situation during hotplug,
    in which the ACPI PCI root bridge driver is always present.
    
    The second reason is that acpi_pci_root_init() causes struct pci_dev
    objects to be created for all PCI devices below the bridge and
    these objects may be necessary for whatever is done with the other
    ACPI device nodes in that namespace scope.  For example, devices
    created by acpi_create_platform_device() sometimes may need to be
    added to the device hierarchy as children of PCI bridges.  For this
    purpose, however, the struct pci_dev objects representing those
    bridges need to exist before the platform devices in question are
    registered.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 726f0d1ace4b..a7e81ac2cd0c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1831,6 +1831,7 @@ int __init acpi_scan_init(void)
 	}
 
 	acpi_power_init();
+	acpi_pci_root_init();
 
 	/*
 	 * Enumerate devices in the ACPI namespace.

commit 805d410fb0dbd65e1a57a810858fa2491e75822d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 21 00:36:39 2012 +0100

    ACPI: Separate adding ACPI device objects from probing ACPI drivers
    
    Split the ACPI namespace scanning for devices into two passes, such
    that struct acpi_device objects are registerd in the first pass
    without probing ACPI drivers and the drivers are probed against them
    directly in the second pass.
    
    There are two main reasons for doing that.
    
    First, the ACPI PCI root bridge driver's .add() routine,
    acpi_pci_root_add(), causes struct pci_dev objects to be created for
    all PCI devices under the given root bridge.  Usually, there are
    corresponding ACPI device nodes in the ACPI namespace for some of
    those devices and therefore there should be "companion" struct
    acpi_device objects to attach those struct pci_dev objects to.  These
    struct acpi_device objects should exist when the corresponding
    struct pci_dev objects are created, but that is only guaranteed
    during boot and not during hotplug.  This leads to a number of
    functional differences between the boot and the hotplug cases which
    are not strictly necessary and make the code more complicated.
    
    For example, this forces the ACPI PCI root bridge driver to defer the
    registration of the just created struct pci_dev objects and to use a
    special .start() callback routine, acpi_pci_root_start(), to make
    sure that all of the "companion" struct acpi_device objects will be
    present at PCI devices registration time during hotplug.
    
    If those differences can be eliminated, we will be able to
    consolidate the boot and hotplug code paths for the enumeration and
    registration of PCI devices and to reduce the complexity of that
    code quite a bit.
    
    The second reason is that, in general, it should be possible to
    resolve conflicts of resources assigned by the BIOS to different
    devices represented by ACPI namespace nodes before any drivers bind
    to them and before they are attached to "companion" objects
    representing physical devices (such as struct pci_dev).  However, for
    this purpose we first need to enumerate all ACPI device nodes in the
    given namespace scope.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 53502d1bbf26..726f0d1ace4b 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -494,7 +494,8 @@ static int acpi_bus_match(struct device *dev, struct device_driver *drv)
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 	struct acpi_driver *acpi_drv = to_acpi_driver(drv);
 
-	return !acpi_match_device_ids(acpi_dev, acpi_drv->ids);
+	return acpi_dev->bus_ops.acpi_op_match
+		&& !acpi_match_device_ids(acpi_dev, acpi_drv->ids);
 }
 
 static int acpi_device_uevent(struct device *dev, struct kobj_uevent_env *env)
@@ -1418,6 +1419,17 @@ static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 	return 0;
 }
 
+/*
+ * acpi_hot_add_bind - Bind _ADR-based devices on hot-add.
+ * @device: ACPI device node to bind.
+ */
+static void acpi_hot_add_bind(struct acpi_device *device)
+{
+	if (device->flags.bus_address
+	    && device->parent && device->parent->ops.bind)
+		device->parent->ops.bind(device);
+}
+
 static int acpi_add_single_object(struct acpi_device **child,
 				  acpi_handle handle, int type,
 				  unsigned long long sta,
@@ -1490,13 +1502,8 @@ static int acpi_add_single_object(struct acpi_device **child,
 
 	result = acpi_device_register(device);
 
-	/*
-	 * Bind _ADR-Based Devices when hot add
-	 */
-	if (device->flags.bus_address) {
-		if (device->parent && device->parent->ops.bind)
-			device->parent->ops.bind(device);
-	}
+	if (device->bus_ops.acpi_op_match)
+		acpi_hot_add_bind(device);
 
 end:
 	if (!result) {
@@ -1522,6 +1529,7 @@ static void acpi_bus_add_power_resource(acpi_handle handle)
 	struct acpi_bus_ops ops = {
 		.acpi_op_add = 1,
 		.acpi_op_start = 1,
+		.acpi_op_match = 1,
 	};
 	struct acpi_device *device = NULL;
 
@@ -1574,9 +1582,9 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 				      void *context, void **return_value)
 {
 	struct acpi_bus_ops *ops = context;
+	struct acpi_device *device = NULL;
 	int type;
 	unsigned long long sta;
-	struct acpi_device *device;
 	acpi_status status;
 	int result;
 
@@ -1596,52 +1604,84 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 		return AE_CTRL_DEPTH;
 	}
 
-	/*
-	 * We may already have an acpi_device from a previous enumeration.  If
-	 * so, we needn't add it again, but we may still have to start it.
-	 */
-	device = NULL;
 	acpi_bus_get_device(handle, &device);
 	if (ops->acpi_op_add && !device) {
-		acpi_add_single_object(&device, handle, type, sta, ops);
-		/* Is the device a known good platform device? */
-		if (device
-		    && !acpi_match_device_ids(device, acpi_platform_device_ids))
-			acpi_create_platform_device(device);
-	}
+		struct acpi_bus_ops add_ops = *ops;
 
-	if (!device)
-		return AE_CTRL_DEPTH;
-
-	if (ops->acpi_op_start && !(ops->acpi_op_add)) {
-		status = acpi_start_single_object(device);
-		if (ACPI_FAILURE(status))
+		add_ops.acpi_op_match = 0;
+		acpi_add_single_object(&device, handle, type, sta, &add_ops);
+		if (!device)
 			return AE_CTRL_DEPTH;
+
+		device->bus_ops.acpi_op_match = 1;
+		acpi_hot_add_bind(device);
 	}
 
 	if (!*return_value)
 		*return_value = device;
+
 	return AE_OK;
 }
 
+static acpi_status acpi_bus_probe_start(acpi_handle handle, u32 lvl,
+					void *context, void **not_used)
+{
+	struct acpi_bus_ops *ops = context;
+	acpi_status status = AE_OK;
+	struct acpi_device *device;
+	unsigned long long sta_not_used;
+	int type_not_used;
+
+	/*
+	 * Ignore errors ignored by acpi_bus_check_add() to avoid terminating
+	 * namespace walks prematurely.
+	 */
+	if (acpi_bus_type_and_status(handle, &type_not_used, &sta_not_used))
+		return AE_OK;
+
+	if (acpi_bus_get_device(handle, &device))
+		return AE_CTRL_DEPTH;
+
+	if (ops->acpi_op_add) {
+		if (!acpi_match_device_ids(device, acpi_platform_device_ids)) {
+			/* This is a known good platform device. */
+			acpi_create_platform_device(device);
+		} else if (device_attach(&device->dev)) {
+			status = AE_CTRL_DEPTH;
+		}
+	} else if (ops->acpi_op_start) {
+		if (ACPI_FAILURE(acpi_start_single_object(device)))
+			status = AE_CTRL_DEPTH;
+	}
+	return status;
+}
+
 static int acpi_bus_scan(acpi_handle handle, struct acpi_bus_ops *ops,
 			 struct acpi_device **child)
 {
-	acpi_status status;
 	void *device = NULL;
+	acpi_status status;
+	int ret = -ENODEV;
 
 	status = acpi_bus_check_add(handle, 0, ops, &device);
 	if (ACPI_SUCCESS(status))
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
 				    acpi_bus_check_add, NULL, ops, &device);
 
+	if (!device)
+		goto out;
+
+	ret = 0;
+	status = acpi_bus_probe_start(handle, 0, ops, NULL);
+	if (ACPI_SUCCESS(status))
+		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
+				    acpi_bus_probe_start, NULL, ops, NULL);
+
+ out:
 	if (child)
 		*child = device;
 
-	if (device)
-		return 0;
-	else
-		return -ENODEV;
+	return ret;
 }
 
 /*
@@ -1752,6 +1792,7 @@ static int acpi_bus_scan_fixed(void)
 	memset(&ops, 0, sizeof(ops));
 	ops.acpi_op_add = 1;
 	ops.acpi_op_start = 1;
+	ops.acpi_op_match = 1;
 
 	/*
 	 * Enumerate all fixed-feature devices.

commit 1a14f30b36e5d20a2a1be24888c2158541d97bab
Merge: 583bdc598206 cdc87c5a30f4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 7 23:14:35 2012 +0100

    Merge branch 'acpi-general'
    
    * acpi-general:
      pnpacpi: fix incorrect TEST_ALPHA() test
      ACPI / video: ignore BIOS initial backlight value for HP Folio 13-2000
      ACPI : do not use Lid and Sleep button for S5 wakeup

commit 583bdc59820692eead7868e816d08bee4c55c1c6
Merge: 8ab788f00263 5e7779f03958
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 7 23:14:25 2012 +0100

    Merge branch 'acpi-enumeration'
    
    * acpi-enumeration:
      ACPI: add Haswell LPSS devices to acpi_platform_device_ids list
      ACPI: add documentation about ACPI 5 enumeration

commit 5e7779f0395833d80d8fa15933737c8dc48759ec
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Dec 7 23:12:01 2012 +0100

    ACPI: add Haswell LPSS devices to acpi_platform_device_ids list
    
    All devices behind Haswell LPSS (Low Power Subsystem) should be represented
    as platform devices so add them to the acpi_platform_device_ids list.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d59a60736e1c..3db115acea50 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -37,6 +37,16 @@ static const struct acpi_device_id acpi_platform_device_ids[] = {
 
 	{ "PNP0D40" },
 
+	/* Haswell LPSS devices */
+	{ "INT33C0", 0 },
+	{ "INT33C1", 0 },
+	{ "INT33C2", 0 },
+	{ "INT33C3", 0 },
+	{ "INT33C4", 0 },
+	{ "INT33C5", 0 },
+	{ "INT33C6", 0 },
+	{ "INT33C7", 0 },
+
 	{ }
 };
 

commit b7e383046c2c7c13ad928cd7407eafff758ddd4b
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Dec 4 23:23:16 2012 +0100

    ACPI : do not use Lid and Sleep button for S5 wakeup
    
    When system enters power off, the _PSW of Lid device is enabled.
    But this may cause the system to reboot instead of power off.
    
    A proper way to fix this is to always disable lid wakeup capability for S5.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=35262
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d0b38ab47ab5..bd523bfbaad1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -917,8 +917,8 @@ acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 static void acpi_bus_set_run_wake_flags(struct acpi_device *device)
 {
 	struct acpi_device_id button_device_ids[] = {
-		{"PNP0C0D", 0},
 		{"PNP0C0C", 0},
+		{"PNP0C0D", 0},
 		{"PNP0C0E", 0},
 		{"", 0},
 	};
@@ -930,6 +930,11 @@ static void acpi_bus_set_run_wake_flags(struct acpi_device *device)
 	/* Power button, Lid switch always enable wakeup */
 	if (!acpi_match_device_ids(device, button_device_ids)) {
 		device->wakeup.flags.run_wake = 1;
+		if (!acpi_match_device_ids(device, &button_device_ids[1])) {
+			/* Do not use Lid/sleep button for S5 wakeup */
+			if (device->wakeup.sleep_state == ACPI_STATE_S5)
+				device->wakeup.sleep_state = ACPI_STATE_S4;
+		}
 		device_set_wakeup_capable(&device->dev, true);
 		return;
 	}

commit d4c091f13dc4d30e4af43c0ccf8c82b3277574ca
Merge: 08ab72980a77 261cba2deb7d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 29 21:43:06 2012 +0100

    Merge branch 'acpi-general'
    
    * acpi-general: (38 commits)
      ACPI / thermal: _TMP and _CRT/_HOT/_PSV/_ACx dependency fix
      ACPI: drop unnecessary local variable from acpi_system_write_wakeup_device()
      ACPI: Fix logging when no pci_irq is allocated
      ACPI: Update Dock hotplug error messages
      ACPI: Update Container hotplug error messages
      ACPI: Update Memory hotplug error messages
      ACPI: Update CPU hotplug error messages
      ACPI: Add acpi_handle_<level>() interfaces
      ACPI: remove use of __devexit
      ACPI / PM: Add Sony Vaio VPCEB1S1E to nonvs blacklist.
      ACPI / battery: Correct battery capacity values on Thinkpads
      Revert "ACPI / x86: Add quirk for "CheckPoint P-20-00" to not use bridge _CRS_ info"
      ACPI: create _SUN sysfs file
      ACPI / memhotplug: bind the memory device when the driver is being loaded
      ACPI / memhotplug: don't allow to eject the memory device if it is being used
      ACPI / memhotplug: free memory device if acpi_memory_enable_device() failed
      ACPI / memhotplug: fix memory leak when memory device is unbound from acpi_memhotplug
      ACPI / memhotplug: deal with eject request in hotplug queue
      ACPI / memory-hotplug: add memory offline code to acpi_memory_device_remove()
      ACPI / memory-hotplug: call acpi_bus_trim() to remove memory device
      ...
    
    Conflicts:
            include/linux/acpi.h (two additions at the end of the same file)

commit 08ab72980a7747a7615c8ba5a797b651fb1aa976
Merge: bcacbdbdc8d2 a19ec8a607f8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 29 21:41:41 2012 +0100

    Merge branch 'acpica'
    
    * acpica: (26 commits)
      ACPICA: Update version to 20121018
      ACPICA: AcpiGetObjectInfo: Add support for ACPI 5 _SUB method
      ACPICA: Update for 64-bit generation of recent error message changes
      ACPICA: Fix externalize name to complete migration to ACPI_MOVE_NAME
      ACPICA: Add starting offset parameter to common dump buffer routine
      ACPICA: Deploy ACPI_MOVE_NAME across ACPICA source base
      ACPICA: Update support for ACPI 5 MPST table
      ACPICA: Enhance error reporting for invalid opcodes and bad ACPI_NAMEs
      ACPICA: Add ACPI_MOVE_NAME macro to optimize 4-byte ACPI_NAME copies
      ACPICA: AcpiExec: Improve algorithm for tracking memory leaks
      ACPICA: Add debug print message for mutex objects that are force-released
      ACPICA: Resource Mgr: Small fix for buffer size calculation
      ACPICA: Remove extra spaces after periods in the Intel license
      ACPICA: Remove extra spaces after periods within comments
      ACPICA: Update local C library module comments for ASCII table
      ACPICA: Fix for predefined name loop during ACPICA initialization
      ACPICA: Fix some typos in comments
      ACPICA: ACPICA core: Cleanup empty lines at file start and end
      ACPICA: Audit/update for ACPICA return macros and debug depth counter
      ACPICA: Fix unmerged acmacros.h divergences.
      ...

commit 45c36462aef0cccadb7755ea4edc78d13334a2be
Merge: c4e050376c69 b88ce2a41562
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Nov 27 13:42:42 2012 +0100

    Merge branch 'acpi-dev-pm' into acpi-enumeration
    
    Subsequent commits in this branch will depend on 'acpi-dev-pm'
    material.

commit 142b007b65aa763957627ea5c343a1001d5ed449
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Nov 23 21:11:47 2012 +0100

    ACPI: add SDHCI to ACPI platform devices
    
    Add the generic ACPI SDHCI device ID to acpi_platform_device_ids[]
    to make the ACPI core create a platform device object for the ACPI
    device node of that ID.
    
    [rjw: Added the changelog.]
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e92ca67d0e46..671bbe68b96c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -35,6 +35,8 @@ static const char *dummy_hid = "device";
  */
 static const struct acpi_device_id acpi_platform_device_ids[] = {
 
+	{ "PNP0D40" },
+
 	{ }
 };
 

commit 1399dfcdfe89898ccd791216f9679ba734aea910
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Wed Nov 21 23:33:40 2012 +0100

    ACPI / PM: Introduce os_accessible flag for power_state
    
    Currently we have valid flag to represent if this ACPI device power
    state is valid. A device power state is valid does not necessarily
    mean we, as OSPM, has a mean to put the device into that power state,
    e.g. D3 cold is always a valid power state for any ACPI device, but if
    there is no _PS3 or _PRx for this device, we can't really put that
    device into D3 cold power state. The same is true for D0 power state.
    
    So here comes the os_accessible flag, which is only set if the device
    has provided us the required means to put it into that power state,
    e.g. if we have _PS3 or _PRx, we can put the device into D3 cold state
    and thus, D3 cold power state's os_accessible flag will be set in this
    case.
    
    And a new wrapper inline function is added to be used to check if
    firmware has provided us a way to power off the device during runtime.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 1fcb8678665c..da1416af0c8b 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -965,8 +965,10 @@ static int acpi_bus_get_power_flags(struct acpi_device *device)
 		 * D3hot is only valid if _PR3 present.
 		 */
 		if (ps->resources.count ||
-		    (ps->flags.explicit_set && i < ACPI_STATE_D3_HOT))
+		    (ps->flags.explicit_set && i < ACPI_STATE_D3_HOT)) {
 			ps->flags.valid = 1;
+			ps->flags.os_accessible = 1;
+		}
 
 		ps->power = -1;	/* Unknown - driver assigned */
 		ps->latency = -1;	/* Unknown - driver assigned */
@@ -982,6 +984,11 @@ static int acpi_bus_get_power_flags(struct acpi_device *device)
 	if (device->power.states[ACPI_STATE_D3_HOT].flags.explicit_set)
 		device->power.states[ACPI_STATE_D3_COLD].flags.explicit_set = 1;
 
+	/* Presence of _PS3 or _PRx means we can put the device into D3 cold */
+	if (device->power.states[ACPI_STATE_D3_HOT].flags.explicit_set ||
+			device->power.flags.power_resources)
+		device->power.states[ACPI_STATE_D3_COLD].flags.os_accessible = 1;
+
 	acpi_bus_init_power(device);
 
 	return 0;

commit 95f8a082b9b1ead0c2859f2a7b1ac91ff63d8765
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Nov 21 00:21:50 2012 +0100

    ACPI / driver core: Introduce struct acpi_dev_node and related macros
    
    To avoid adding an ACPI handle pointer to struct device on
    architectures that don't use ACPI, or generally when CONFIG_ACPI is
    not set, in which cases that pointer is useless, define struct
    acpi_dev_node that will contain the handle pointer if CONFIG_ACPI is
    set and will be empty otherwise and use it to represent the ACPI
    device node field in struct device.
    
    In addition to that define macros for reading and setting the ACPI
    handle of a device that don't generate code when CONFIG_ACPI is
    unset.  Modify the ACPI subsystem to use those macros instead of
    referring to the given device's ACPI handle directly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d842569395a9..e92ca67d0e46 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -386,8 +386,8 @@ const struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,
 {
 	struct acpi_device *adev;
 
-	if (!ids || !dev->acpi_handle
-	    || ACPI_FAILURE(acpi_bus_get_device(dev->acpi_handle, &adev)))
+	if (!ids || !ACPI_HANDLE(dev)
+	    || ACPI_FAILURE(acpi_bus_get_device(ACPI_HANDLE(dev), &adev)))
 		return NULL;
 
 	return __acpi_match_device(adev, ids);

commit bb74ac23b10820d8722c3e1f4add9ef59e703f63
Author: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
Date:   Fri Nov 16 02:56:59 2012 +0100

    ACPI: create _SUN sysfs file
    
    _SUN method provides the slot unique-ID in the ACPI namespace. And The value
    is written in Advanced Configuration and Power Interface Specification as
    follows:
    
    "The _SUN value is required to be unique among the slots ofthe same type.
    It is also recommended that this number match the slot number printed on
    the physical slot whenever possible."
    
    So if we can know the value, we can identify the physical position of the
    slot in the system.
    
    The patch creates "sun" file in sysfs for identifying physical position
    of the slot.
    
    Signed-off-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Reviewed-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 9d43532d69b1..d0b38ab47ab5 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -283,11 +283,21 @@ static ssize_t description_show(struct device *dev,
 }
 static DEVICE_ATTR(description, 0444, description_show, NULL);
 
+static ssize_t
+acpi_device_sun_show(struct device *dev, struct device_attribute *attr,
+		     char *buf) {
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+
+	return sprintf(buf, "%lu\n", acpi_dev->pnp.sun);
+}
+static DEVICE_ATTR(sun, 0444, acpi_device_sun_show, NULL);
+
 static int acpi_device_setup_files(struct acpi_device *dev)
 {
 	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
 	acpi_status status;
 	acpi_handle temp;
+	unsigned long long sun;
 	int result = 0;
 
 	/*
@@ -329,6 +339,16 @@ static int acpi_device_setup_files(struct acpi_device *dev)
 	if (dev->pnp.unique_id)
 		result = device_create_file(&dev->dev, &dev_attr_uid);
 
+	status = acpi_evaluate_integer(dev->handle, "_SUN", NULL, &sun);
+	if (ACPI_SUCCESS(status)) {
+		dev->pnp.sun = (unsigned long)sun;
+		result = device_create_file(&dev->dev, &dev_attr_sun);
+		if (result)
+			goto end;
+	} else {
+		dev->pnp.sun = (unsigned long)-1;
+	}
+
         /*
          * If device has _EJ0, 'eject' file is created that is used to trigger
          * hot-removal function from userland.
@@ -360,6 +380,10 @@ static void acpi_device_remove_files(struct acpi_device *dev)
 	if (ACPI_SUCCESS(status))
 		device_remove_file(&dev->dev, &dev_attr_eject);
 
+	status = acpi_get_handle(dev->handle, "_SUN", &temp);
+	if (ACPI_SUCCESS(status))
+		device_remove_file(&dev->dev, &dev_attr_sun);
+
 	if (dev->pnp.unique_id)
 		device_remove_file(&dev->dev, &dev_attr_uid);
 	if (dev->flags.bus_address)

commit 78e25fef2751434f38c7f711ecbf8762f79f7318
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Oct 31 02:25:24 2012 +0000

    ACPICA: Fix divergences of definition conflicts.
    
    There are conflicts in the "acpi_device_id*" definitions between the
    Linux and the ACPICA.  The definitions of acpi_device_id* in ACPICA
    have been changed to the "acpi_pnp_device_id*".  This patch changes
    the corresponding "acpica_device_id*" definitiions in the Linux.
    
    This patch will not affect the generated vmlinx binary.
    This will decrease 298 lines of 20120913 divergence.diff.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 1fcb8678665c..db127100bd9d 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1185,7 +1185,7 @@ static void acpi_device_set_id(struct acpi_device *device)
 {
 	acpi_status status;
 	struct acpi_device_info *info;
-	struct acpica_device_id_list *cid_list;
+	struct acpi_pnp_device_id_list *cid_list;
 	int i;
 
 	switch (device->device_type) {

commit 91e5687805885f9fceb60b95e950a3d3bdcf4764
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Oct 31 22:45:02 2012 +0100

    ACPI: Add support for platform bus type
    
    With ACPI 5 it is now possible to enumerate traditional SoC
    peripherals, like serial bus controllers and slave devices behind
    them.  These devices are typically based on IP-blocks used in many
    existing SoC platforms and platform drivers for them may already
    be present in the kernel tree.
    
    To make driver "porting" more straightforward, add ACPI support to
    the platform bus type.  Instead of writing ACPI "glue" drivers for
    the existing platform drivers, register the platform bus type with
    ACPI to create platform device objects for the drivers and bind the
    corresponding ACPI handles to those platform devices.
    
    This should allow us to reuse the existing platform drivers for the
    devices in question with the minimum amount of modifications.
    
    This changeset is based on Mika Westerberg's and Mathias Nyman's
    work.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a0dfdffe54d4..d842569395a9 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -29,6 +29,15 @@ extern struct acpi_device *acpi_root;
 
 static const char *dummy_hid = "device";
 
+/*
+ * The following ACPI IDs are known to be suitable for representing as
+ * platform devices.
+ */
+static const struct acpi_device_id acpi_platform_device_ids[] = {
+
+	{ }
+};
+
 static LIST_HEAD(acpi_device_list);
 static LIST_HEAD(acpi_bus_id_list);
 DEFINE_MUTEX(acpi_device_lock);
@@ -1513,8 +1522,13 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 	 */
 	device = NULL;
 	acpi_bus_get_device(handle, &device);
-	if (ops->acpi_op_add && !device)
+	if (ops->acpi_op_add && !device) {
 		acpi_add_single_object(&device, handle, type, sta, ops);
+		/* Is the device a known good platform device? */
+		if (device
+		    && !acpi_match_device_ids(device, acpi_platform_device_ids))
+			acpi_create_platform_device(device);
+	}
 
 	if (!device)
 		return AE_CTRL_DEPTH;

commit cf761af9ee0f2c172710ad2b7ca029016b5d4c45
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Oct 31 22:44:41 2012 +0100

    ACPI: Provide generic functions for matching ACPI device nodes
    
    Introduce function acpi_match_device() allowing callers to match
    struct device objects with populated acpi_handle fields against
    arrays of ACPI device IDs.  Also introduce function
    acpi_driver_match_device() using acpi_match_device() internally and
    allowing callers to match a struct device object against an array of
    ACPI device IDs provided by a device driver.
    
    Additionally, introduce macro ACPI_PTR() that may be used by device
    drivers to escape pointers to data structures whose definitions
    depend on CONFIG_ACPI.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 1fcb8678665c..a0dfdffe54d4 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -340,8 +340,8 @@ static void acpi_device_remove_files(struct acpi_device *dev)
 			ACPI Bus operations
    -------------------------------------------------------------------------- */
 
-int acpi_match_device_ids(struct acpi_device *device,
-			  const struct acpi_device_id *ids)
+static const struct acpi_device_id *__acpi_match_device(
+	struct acpi_device *device, const struct acpi_device_id *ids)
 {
 	const struct acpi_device_id *id;
 	struct acpi_hardware_id *hwid;
@@ -351,14 +351,44 @@ int acpi_match_device_ids(struct acpi_device *device,
 	 * driver for it.
 	 */
 	if (!device->status.present)
-		return -ENODEV;
+		return NULL;
 
 	for (id = ids; id->id[0]; id++)
 		list_for_each_entry(hwid, &device->pnp.ids, list)
 			if (!strcmp((char *) id->id, hwid->id))
-				return 0;
+				return id;
+
+	return NULL;
+}
 
-	return -ENOENT;
+/**
+ * acpi_match_device - Match a struct device against a given list of ACPI IDs
+ * @ids: Array of struct acpi_device_id object to match against.
+ * @dev: The device structure to match.
+ *
+ * Check if @dev has a valid ACPI handle and if there is a struct acpi_device
+ * object for that handle and use that object to match against a given list of
+ * device IDs.
+ *
+ * Return a pointer to the first matching ID on success or %NULL on failure.
+ */
+const struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,
+					       const struct device *dev)
+{
+	struct acpi_device *adev;
+
+	if (!ids || !dev->acpi_handle
+	    || ACPI_FAILURE(acpi_bus_get_device(dev->acpi_handle, &adev)))
+		return NULL;
+
+	return __acpi_match_device(adev, ids);
+}
+EXPORT_SYMBOL_GPL(acpi_match_device);
+
+int acpi_match_device_ids(struct acpi_device *device,
+			  const struct acpi_device_id *ids)
+{
+	return __acpi_match_device(device, ids) ? 0 : -ENOENT;
 }
 EXPORT_SYMBOL(acpi_match_device_ids);
 

commit 61622accd05b158d05f967b627e72da23d64f2ed
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Thu Nov 1 14:42:12 2012 +0000

    ACPI: Export functions for hot-remove
    
    Exported acpi_os_hotplug_execute() and acpi_bus_hot_remove_device()
    so that they can be called from modules for hot-remove operations.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 86bfa690bc6f..9d43532d69b1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -161,6 +161,7 @@ void acpi_bus_hot_remove_device(void *context)
 	kfree(context);
 	return;
 }
+EXPORT_SYMBOL(acpi_bus_hot_remove_device);
 
 static ssize_t
 acpi_eject_store(struct device *d, struct device_attribute *attr,

commit 923d4a45a9d2e350c27b7b7e1c724c19eb921c92
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Oct 30 14:43:26 2012 +0100

    ACPI: Add user space interface for identification objects
    
    ACPI devices are glued with physical devices through _ADR object, ACPI
    enumerated devices are identified with _UID object.  Currently we can
    observe _HID/_CID through sysfs interfaces (hid/modalias), but there's
    no way for us to check _ADR/_UID from user space.  This patch closes
    this gap for ACPI developers and users.
    
    [rjw: Modified the subject and changelog slightly.]
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index daa88d527e84..86bfa690bc6f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -220,6 +220,25 @@ acpi_device_hid_show(struct device *dev, struct device_attribute *attr, char *bu
 }
 static DEVICE_ATTR(hid, 0444, acpi_device_hid_show, NULL);
 
+static ssize_t acpi_device_uid_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+
+	return sprintf(buf, "%s\n", acpi_dev->pnp.unique_id);
+}
+static DEVICE_ATTR(uid, 0444, acpi_device_uid_show, NULL);
+
+static ssize_t acpi_device_adr_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+
+	return sprintf(buf, "0x%08x\n",
+		       (unsigned int)(acpi_dev->pnp.bus_address));
+}
+static DEVICE_ATTR(adr, 0444, acpi_device_adr_show, NULL);
+
 static ssize_t
 acpi_device_path_show(struct device *dev, struct device_attribute *attr, char *buf) {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
@@ -304,6 +323,11 @@ static int acpi_device_setup_files(struct acpi_device *dev)
 			goto end;
 	}
 
+	if (dev->flags.bus_address)
+		result = device_create_file(&dev->dev, &dev_attr_adr);
+	if (dev->pnp.unique_id)
+		result = device_create_file(&dev->dev, &dev_attr_uid);
+
         /*
          * If device has _EJ0, 'eject' file is created that is used to trigger
          * hot-removal function from userland.
@@ -335,6 +359,10 @@ static void acpi_device_remove_files(struct acpi_device *dev)
 	if (ACPI_SUCCESS(status))
 		device_remove_file(&dev->dev, &dev_attr_eject);
 
+	if (dev->pnp.unique_id)
+		device_remove_file(&dev->dev, &dev_attr_uid);
+	if (dev->flags.bus_address)
+		device_remove_file(&dev->dev, &dev_attr_adr);
 	device_remove_file(&dev->dev, &dev_attr_modalias);
 	device_remove_file(&dev->dev, &dev_attr_hid);
 	if (dev->handle)

commit ccf78040265bfce2aac5766e1ddf4fc3dde36899
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Oct 30 14:41:07 2012 +0100

    ACPI: Add _UID support for ACPI devices.
    
    The _UID object is optional, but is required when the device has no
    other way to report a persistent unique device ID.
    This patch is required for ACPI 5.0 ACPI enumerated IP cores.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rui Zhang <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 19d3d4a1274a..daa88d527e84 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -381,6 +381,7 @@ static void acpi_device_release(struct device *dev)
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 
 	acpi_free_ids(acpi_dev);
+	kfree(acpi_dev->pnp.unique_id);
 	kfree(acpi_dev);
 }
 
@@ -1211,6 +1212,9 @@ static void acpi_device_set_id(struct acpi_device *device)
 			device->pnp.bus_address = info->address;
 			device->flags.bus_address = 1;
 		}
+		if (info->valid & ACPI_VALID_UID)
+			device->pnp.unique_id = kstrdup(info->unique_id.string,
+							GFP_KERNEL);
 
 		kfree(info);
 

commit f4fa0e018a175ea92a3187ade8f678599dc5980a
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Fri Oct 26 13:39:06 2012 +0200

    ACPI: Remove unused lockable in acpi_device_flags
    
    Removed lockable in struct acpi_device_flags since it is no
    longer used by any code. acpi_bus_hot_remove_device() cannot
    use this flag because acpi_bus_trim() frees up its acpi_device
    object. Furthermore, the dock driver calls _LCK method without
    using this lockable flag.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Reviewed-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ed87f433cec2..19d3d4a1274a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1017,11 +1017,6 @@ static int acpi_bus_get_flags(struct acpi_device *device)
 			device->flags.ejectable = 1;
 	}
 
-	/* Presence of _LCK indicates 'lockable' */
-	status = acpi_get_handle(device->handle, "_LCK", &temp);
-	if (ACPI_SUCCESS(status))
-		device->flags.lockable = 1;
-
 	/* Power resources cannot be power manageable. */
 	if (device->device_type == ACPI_BUS_TYPE_POWER)
 		return 0;

commit b3c450c38075f414077e58439cff6bdce9e47df8
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Fri Oct 26 13:38:57 2012 +0200

    ACPI: Fix stale pointer access to flags.lockable
    
    During hot-remove, acpi_bus_hot_remove_device() calls ACPI _LCK
    method when device->flags.lockable is set. However, this device
    pointer is stale since the target acpi_device object has been
    already kfree'd by acpi_bus_trim().
    
    The flags.lockable indicates whether or not this ACPI object
    implements _LCK method. Fix the stable pointer access by replacing
    it with acpi_get_handle() to check if _LCK is implemented.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Reviewed-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 1fcb8678665c..ed87f433cec2 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -97,6 +97,7 @@ void acpi_bus_hot_remove_device(void *context)
 	struct acpi_eject_event *ej_event = (struct acpi_eject_event *) context;
 	struct acpi_device *device;
 	acpi_handle handle = ej_event->handle;
+	acpi_handle temp;
 	struct acpi_object_list arg_list;
 	union acpi_object arg;
 	acpi_status status = AE_OK;
@@ -117,13 +118,16 @@ void acpi_bus_hot_remove_device(void *context)
 		goto err_out;
 	}
 
+	/* device has been freed */
+	device = NULL;
+
 	/* power off device */
 	status = acpi_evaluate_object(handle, "_PS3", NULL, NULL);
 	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND)
 		printk(KERN_WARNING PREFIX
 				"Power-off device failed\n");
 
-	if (device->flags.lockable) {
+	if (ACPI_SUCCESS(acpi_get_handle(handle, "_LCK", &temp))) {
 		arg_list.count = 1;
 		arg_list.pointer = &arg;
 		arg.type = ACPI_TYPE_INTEGER;

commit 3f44ea0d1c3835872033a6633135e16f87161202
Merge: a0d271cbfed1 8fa6b970ff42 45e1424be7cf 23795e580cad d1efe3c324ea a509d228b690 f9240813e61c 1033f9041d52
Author: Len Brown <len.brown@intel.com>
Date:   Sat Oct 6 16:00:32 2012 -0400

    Merge branches 'acpica', 'acpidump', 'intel-idle', 'misc', 'module_acpi_driver-simplify', 'turbostat' and 'usb3' into release
    
    add acpidump utility
    intel_idle driver now supports IVB Xeon
    turbostat can now count SMIs
    ACPI can now bind to USB3 hubs
    misc fixes

commit d1efe3c324ead77d3f6cd85093b50f6bd2e17aba
Author: Lance Ortiz <lance.ortiz@hp.com>
Date:   Tue Oct 2 12:43:23 2012 -0600

    ACPI: Add new sysfs interface to export device description
    
    Add support to export the device description obtained from the ACPI _STR
    method, if one exists for a device, to user-space via a sysfs interface.
    This new interface provides a standard and platform neutral way for users
    to obtain the description text stored in the ACPI _STR method.  If no
    _STR method exists for the device, no sysfs 'description' file will be
    created.  The 'description' file will be located in the /sys/devices/
    directory using the device's path.
    
    /sys/device/<bus>/<bridge path>/<device path>.../firmware_node/description
    
    Example:
    
    /sys/devices/pci0000:00/0000:00.07.0/0000:0e:00.0/firmware_node/description
    
    It can also be located using the ACPI device path, for example:
    
    /sys/devices/LNXSYSTM:00/device:00/ACPI0004:00/PNP0A08:00/device:13/device:15/description
    /sys/devices/LNXSYSTM:00/device:00/ACPI0004:00/ACPI0004:01/ACPI0007:02/description
    
    Execute the 'cat' command on the 'description' file to obtain the
    description string for that device.
    
    This patch also includes documentation describing how the new sysfs
    interface works
    
    Changes from v1-v2 based on comments by Len Brown and Fengguang Wu
    * Removed output "No Description" and leaving a NULL attribute if the
    _STR method failed to evaluate.
    
    * In acpi_device_remove_files() removed the redundent check of
    dev->pnp.str_obj before calling free.  This check triggered a message
    from smatch.
    
    Signed-off-by: Lance Ortiz <lance.ortiz@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d1ecca2b641a..04302835723d 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -10,6 +10,7 @@
 #include <linux/signal.h>
 #include <linux/kthread.h>
 #include <linux/dmi.h>
+#include <linux/nls.h>
 
 #include <acpi/acpi_drivers.h>
 
@@ -232,8 +233,35 @@ acpi_device_path_show(struct device *dev, struct device_attribute *attr, char *b
 }
 static DEVICE_ATTR(path, 0444, acpi_device_path_show, NULL);
 
+/* sysfs file that shows description text from the ACPI _STR method */
+static ssize_t description_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf) {
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+	int result;
+
+	if (acpi_dev->pnp.str_obj == NULL)
+		return 0;
+
+	/*
+	 * The _STR object contains a Unicode identifier for a device.
+	 * We need to convert to utf-8 so it can be displayed.
+	 */
+	result = utf16s_to_utf8s(
+		(wchar_t *)acpi_dev->pnp.str_obj->buffer.pointer,
+		acpi_dev->pnp.str_obj->buffer.length,
+		UTF16_LITTLE_ENDIAN, buf,
+		PAGE_SIZE);
+
+	buf[result++] = '\n';
+
+	return result;
+}
+static DEVICE_ATTR(description, 0444, description_show, NULL);
+
 static int acpi_device_setup_files(struct acpi_device *dev)
 {
+	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
 	acpi_status status;
 	acpi_handle temp;
 	int result = 0;
@@ -257,6 +285,21 @@ static int acpi_device_setup_files(struct acpi_device *dev)
 			goto end;
 	}
 
+	/*
+	 * If device has _STR, 'description' file is created
+	 */
+	status = acpi_get_handle(dev->handle, "_STR", &temp);
+	if (ACPI_SUCCESS(status)) {
+		status = acpi_evaluate_object(dev->handle, "_STR",
+					NULL, &buffer);
+		if (ACPI_FAILURE(status))
+			buffer.pointer = NULL;
+		dev->pnp.str_obj = buffer.pointer;
+		result = device_create_file(&dev->dev, &dev_attr_description);
+		if (result)
+			goto end;
+	}
+
         /*
          * If device has _EJ0, 'eject' file is created that is used to trigger
          * hot-removal function from userland.
@@ -274,8 +317,15 @@ static void acpi_device_remove_files(struct acpi_device *dev)
 	acpi_handle temp;
 
 	/*
-	 * If device has _EJ0, 'eject' file is created that is used to trigger
-	 * hot-removal function from userland.
+	 * If device has _STR, remove 'description' file
+	 */
+	status = acpi_get_handle(dev->handle, "_STR", &temp);
+	if (ACPI_SUCCESS(status)) {
+		kfree(dev->pnp.str_obj);
+		device_remove_file(&dev->dev, &dev_attr_description);
+	}
+	/*
+	 * If device has _EJ0, remove 'eject' file.
 	 */
 	status = acpi_get_handle(dev->handle, "_EJ0", &temp);
 	if (ACPI_SUCCESS(status))

commit 1033f9041d526dd694e2b2e12744e47c41040c4d
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Fri Aug 17 14:44:09 2012 +0800

    ACPI: Allow ACPI binding with USB-3.0 hub
    
    A USB port's position and connectability can't be identified on some boards
    via USB hub registers. ACPI _UPC and _PLD can help to resolve this issue
    and so it is necessary to bind USB with ACPI. This patch is to allow ACPI
    binding with USB-3.0 hub.
    
    Current ACPI only can bind one struct-device to one ACPI device node.
    This can not work with USB-3.0 hub, because the USB-3.0 hub has two logical
    devices. Each works for USB-2.0 and USB-3.0 devices. In the Linux USB subsystem,
    those two logical hubs are treated as two seperate devices that have two struct
    devices. But in the ACPI DSDT, these two logical hubs share one ACPI device
    node. So there is a requirement to bind multi struct-devices to one ACPI
    device node. This patch is to resolve such problem.
    
    Following is the ACPI device nodes' description under xhci hcd.
    
    Device (XHC)
                Device (RHUB)
                    Device (HSP1)
                    Device (HSP2)
                    Device (HSP3)
                    Device (HSP4)
                    Device (SSP1)
                    Device (SSP2)
                    Device (SSP3)
                    Device (SSP4)
    
    Topology in the Linux
    
            device XHC
               USB-2.0 logical hub    USB-3.0 logical hub
                    HSP1                    SSP1
                    HSP2                    SSP2
                    HSP3                    SSP3
                    HSP4                    SSP4
    
    This patch also modifies the output of /proc/acpi/wakeup. One ACPI node
    can be associated with multiple devices:
    
    XHC             S4      *enabled        pci:0000:00:14.0
    RHUB    S0      disabled        usb:usb1
                            disabled        usb:usb2
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Acked-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d1ecca2b641a..d730a939ead1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -481,6 +481,8 @@ static int acpi_device_register(struct acpi_device *device)
 	INIT_LIST_HEAD(&device->children);
 	INIT_LIST_HEAD(&device->node);
 	INIT_LIST_HEAD(&device->wakeup_list);
+	INIT_LIST_HEAD(&device->physical_node_list);
+	mutex_init(&device->physical_node_lock);
 
 	new_bus_id = kzalloc(sizeof(struct acpi_device_bus_id), GFP_KERNEL);
 	if (!new_bus_id) {

commit 476525004ac7e2f990b6956efcd44d0780c2ab4c
Merge: bd22dc17e499 ec033d0a0290
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 26 14:28:55 2012 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux
    
    Pull ACPI & power management update from Len Brown:
     "Re-write of the turbostat tool.
         lower overhead was necessary for measuring very large system when
         they are very idle.
    
      IVB support in intel_idle
         It's what I run on my IVB, others should be able to also:-)
    
      ACPICA core update
         We have found some bugs due to divergence between Linux and the
         upstream ACPICA base.  Most of these patches are to reduce that
         divergence to reduce the risk of future bugs.
    
      Some cpuidle updates, mostly for non-Intel
         More will be coming, as they depend on this part.
    
      Some thermal management changes needed by non-ACPI systems.
    
      Some _OST (OS Status Indication) updates for hot ACPI hot-plug."
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux: (51 commits)
      Thermal: Documentation update
      Thermal: Add Hysteresis attributes
      Thermal: Make Thermal trip points writeable
      ACPI/AC: prevent OOPS on some boxes due to missing check power_supply_register() return value check
      tools/power: turbostat: fix large c1% issue
      tools/power: turbostat v2 - re-write for efficiency
      ACPICA: Update to version 20120711
      ACPICA: AcpiSrc: Fix some translation issues for Linux conversion
      ACPICA: Update header files copyrights to 2012
      ACPICA: Add new ACPI table load/unload external interfaces
      ACPICA: Split file: tbxface.c -> tbxfload.c
      ACPICA: Add PCC address space to space ID decode function
      ACPICA: Fix some comment fields
      ACPICA: Table manager: deploy new firmware error/warning interfaces
      ACPICA: Add new interfaces for BIOS(firmware) errors and warnings
      ACPICA: Split exception code utilities to a new file, utexcep.c
      ACPI: acpi_pad: tune round_robin_time
      ACPICA: Update to version 20120620
      ACPICA: Add support for implicit notify on multiple devices
      ACPICA: Update comments; no functional change
      ...

commit ec033d0a02901551346b9f43f8ff9bad51378891
Merge: fa7584e13ac8 819f1a64beb6 f712c71f7b2b a58e1150225c 20ff51a36b2c 1b0a0e9a15b9 6edab08c24f9 c2f4191a9c4d f197ac13f6ee 8eaa8d6ca277 b9c7aff481f1 c3ae331d1c2f
Author: Len Brown <len.brown@intel.com>
Date:   Thu Jul 26 00:03:58 2012 -0400

    Merge branches 'acpi_pad', 'acpica', 'apei-bugzilla-43282', 'battery', 'cpuidle-coupled', 'cpuidle-tweaks', 'intel_idle-ivb', 'ost', 'red-hat-bz-772730', 'thermal', 'thermal-spear' and 'turbostat-v2' into release

commit d91ee328c1e8b3992ffbf84a1a984c2a7f4ebff7
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jun 29 23:40:29 2012 +0200

    ACPI / PM: Drop PM callbacks from the ACPI bus type
    
    Since the ACPI bus type's PM callbacks only execute the driver ones
    without doing anything else, they can be dropped, because the driver
    callbacks will be executed by the PM core directly if bus type
    (or other subsystem) callbacks are not present.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c384e59c3d9a..fdda49336560 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -290,56 +290,6 @@ static void acpi_device_release(struct device *dev)
 	kfree(acpi_dev);
 }
 
-#define ACPI_DEV_PM_CALLBACK(dev, callback)		\
-({								\
-	struct device_driver *__drv = dev->driver;		\
-	int __ret = 0;						\
-								\
-	if (__drv && __drv->pm && __drv->pm->callback)		\
-		__ret = __drv->pm->callback(dev);		\
-								\
-	__ret;							\
-})
-
-static int acpi_pm_suspend(struct device *dev)
-{
-	return ACPI_DEV_PM_CALLBACK(dev, suspend);
-}
-
-static int acpi_pm_resume(struct device *dev)
-{
-	return ACPI_DEV_PM_CALLBACK(dev, resume);
-}
-
-static int acpi_pm_freeze(struct device *dev)
-{
-	return ACPI_DEV_PM_CALLBACK(dev, freeze);
-}
-
-static int acpi_pm_thaw(struct device *dev)
-{
-	return ACPI_DEV_PM_CALLBACK(dev, thaw);
-}
-
-static int acpi_pm_poweroff(struct device *dev)
-{
-	return ACPI_DEV_PM_CALLBACK(dev, poweroff);
-}
-
-static int acpi_pm_restore(struct device *dev)
-{
-	return ACPI_DEV_PM_CALLBACK(dev, restore);
-}
-
-static const struct dev_pm_ops acpi_bus_pm = {
-	.suspend = acpi_pm_suspend,
-	.resume = acpi_pm_resume,
-	.freeze = acpi_pm_freeze,
-	.thaw = acpi_pm_thaw,
-	.poweroff = acpi_pm_poweroff,
-	.restore = acpi_pm_restore,
-};
-
 static int acpi_bus_match(struct device *dev, struct device_driver *drv)
 {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
@@ -475,7 +425,6 @@ struct bus_type acpi_bus_type = {
 	.probe		= acpi_device_probe,
 	.remove		= acpi_device_remove,
 	.uevent		= acpi_device_uevent,
-	.pm		= &acpi_bus_pm,
 };
 
 static int acpi_device_register(struct acpi_device *device)

commit 13db85528fd606b2dfd8f1a5952158e4ad6ce51a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jun 29 23:40:13 2012 +0200

    ACPI / PM: Do not execute legacy driver PM callbacks
    
    Since all ACPI drivers in the tree should have been switched
    to power management handling based on struct dev_pm_ops,
    modify the ACPI bus type driver so that is doesn't execute
    legacy driver power management callbacks from the functions
    pointed to by the members of the acpi_bus_pm structure.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index af924ba85148..c384e59c3d9a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -290,51 +290,45 @@ static void acpi_device_release(struct device *dev)
 	kfree(acpi_dev);
 }
 
-#define ACPI_DEV_PM_CALLBACK(dev, callback, legacy_cb)		\
+#define ACPI_DEV_PM_CALLBACK(dev, callback)		\
 ({								\
-	struct acpi_device *__acpi_dev = to_acpi_device(dev);	\
-	struct acpi_driver *__acpi_drv = __acpi_dev->driver;	\
 	struct device_driver *__drv = dev->driver;		\
-	int __ret;						\
+	int __ret = 0;						\
 								\
-	if (__acpi_drv && __acpi_drv->ops.legacy_cb)		\
-		__ret = __acpi_drv->ops.legacy_cb(__acpi_dev);	\
-	else if (__drv && __drv->pm && __drv->pm->callback)	\
+	if (__drv && __drv->pm && __drv->pm->callback)		\
 		__ret = __drv->pm->callback(dev);		\
-	else							\
-		__ret = 0;					\
 								\
 	__ret;							\
 })
 
 static int acpi_pm_suspend(struct device *dev)
 {
-	return ACPI_DEV_PM_CALLBACK(dev, suspend, suspend);
+	return ACPI_DEV_PM_CALLBACK(dev, suspend);
 }
 
 static int acpi_pm_resume(struct device *dev)
 {
-	return ACPI_DEV_PM_CALLBACK(dev, resume, resume);
+	return ACPI_DEV_PM_CALLBACK(dev, resume);
 }
 
 static int acpi_pm_freeze(struct device *dev)
 {
-	return ACPI_DEV_PM_CALLBACK(dev, freeze, suspend);
+	return ACPI_DEV_PM_CALLBACK(dev, freeze);
 }
 
 static int acpi_pm_thaw(struct device *dev)
 {
-	return ACPI_DEV_PM_CALLBACK(dev, thaw, resume);
+	return ACPI_DEV_PM_CALLBACK(dev, thaw);
 }
 
 static int acpi_pm_poweroff(struct device *dev)
 {
-	return ACPI_DEV_PM_CALLBACK(dev, poweroff, suspend);
+	return ACPI_DEV_PM_CALLBACK(dev, poweroff);
 }
 
 static int acpi_pm_restore(struct device *dev)
 {
-	return ACPI_DEV_PM_CALLBACK(dev, restore, resume);
+	return ACPI_DEV_PM_CALLBACK(dev, restore);
 }
 
 static const struct dev_pm_ops acpi_bus_pm = {

commit 67699c5f0c68f5dc49e92b172d372c99cdd2bf09
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jun 27 23:25:59 2012 +0200

    ACPI / PM: Make acpi_bus_type use driver struct dev_pm_ops callbacks
    
    Modify acpi_bus_type so that it executes PM callbacks provided
    by drivers through their struct dev_pm_ops objects, if present,
    while still allowing the legacy ACPI PM callbacks to take precedence.
    This will make it possible to convert ACPI drivers one by one to
    handling PM through struct dev_pm_ops instead of the legacy way.
    
    The code added by this change is temporary and will be removed
    when all of the drivers in question have been switched over to
    the PM handling based on struct dev_pm_ops.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 7c37be53334d..af924ba85148 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -290,27 +290,61 @@ static void acpi_device_release(struct device *dev)
 	kfree(acpi_dev);
 }
 
-static int acpi_device_suspend(struct device *dev)
+#define ACPI_DEV_PM_CALLBACK(dev, callback, legacy_cb)		\
+({								\
+	struct acpi_device *__acpi_dev = to_acpi_device(dev);	\
+	struct acpi_driver *__acpi_drv = __acpi_dev->driver;	\
+	struct device_driver *__drv = dev->driver;		\
+	int __ret;						\
+								\
+	if (__acpi_drv && __acpi_drv->ops.legacy_cb)		\
+		__ret = __acpi_drv->ops.legacy_cb(__acpi_dev);	\
+	else if (__drv && __drv->pm && __drv->pm->callback)	\
+		__ret = __drv->pm->callback(dev);		\
+	else							\
+		__ret = 0;					\
+								\
+	__ret;							\
+})
+
+static int acpi_pm_suspend(struct device *dev)
 {
-	struct acpi_device *acpi_dev = to_acpi_device(dev);
-	struct acpi_driver *acpi_drv = acpi_dev->driver;
+	return ACPI_DEV_PM_CALLBACK(dev, suspend, suspend);
+}
 
-	if (acpi_drv && acpi_drv->ops.suspend)
-		return acpi_drv->ops.suspend(acpi_dev);
-	return 0;
+static int acpi_pm_resume(struct device *dev)
+{
+	return ACPI_DEV_PM_CALLBACK(dev, resume, resume);
 }
 
-static int acpi_device_resume(struct device *dev)
+static int acpi_pm_freeze(struct device *dev)
 {
-	struct acpi_device *acpi_dev = to_acpi_device(dev);
-	struct acpi_driver *acpi_drv = acpi_dev->driver;
+	return ACPI_DEV_PM_CALLBACK(dev, freeze, suspend);
+}
 
-	if (acpi_drv && acpi_drv->ops.resume)
-		return acpi_drv->ops.resume(acpi_dev);
-	return 0;
+static int acpi_pm_thaw(struct device *dev)
+{
+	return ACPI_DEV_PM_CALLBACK(dev, thaw, resume);
+}
+
+static int acpi_pm_poweroff(struct device *dev)
+{
+	return ACPI_DEV_PM_CALLBACK(dev, poweroff, suspend);
 }
 
-static SIMPLE_DEV_PM_OPS(acpi_bus_pm, acpi_device_suspend, acpi_device_resume);
+static int acpi_pm_restore(struct device *dev)
+{
+	return ACPI_DEV_PM_CALLBACK(dev, restore, resume);
+}
+
+static const struct dev_pm_ops acpi_bus_pm = {
+	.suspend = acpi_pm_suspend,
+	.resume = acpi_pm_resume,
+	.freeze = acpi_pm_freeze,
+	.thaw = acpi_pm_thaw,
+	.poweroff = acpi_pm_poweroff,
+	.restore = acpi_pm_restore,
+};
 
 static int acpi_bus_match(struct device *dev, struct device_driver *drv)
 {

commit 707156e600dbfd89e129239ee1d1d934cbe2119c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jun 27 23:25:49 2012 +0200

    ACPI / PM: Make acpi_bus_type use struct dev_pm_ops for PM handling
    
    Make the acpi_bus_type bus type define its PM callbacks through
    a struct dev_pm_ops object rather than by using legacy PM hooks
    in struct bus_type.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ec65ec9c529f..7c37be53334d 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -290,7 +290,7 @@ static void acpi_device_release(struct device *dev)
 	kfree(acpi_dev);
 }
 
-static int acpi_device_suspend(struct device *dev, pm_message_t state)
+static int acpi_device_suspend(struct device *dev)
 {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 	struct acpi_driver *acpi_drv = acpi_dev->driver;
@@ -310,6 +310,8 @@ static int acpi_device_resume(struct device *dev)
 	return 0;
 }
 
+static SIMPLE_DEV_PM_OPS(acpi_bus_pm, acpi_device_suspend, acpi_device_resume);
+
 static int acpi_bus_match(struct device *dev, struct device_driver *drv)
 {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
@@ -441,12 +443,11 @@ static int acpi_device_remove(struct device * dev)
 
 struct bus_type acpi_bus_type = {
 	.name		= "acpi",
-	.suspend	= acpi_device_suspend,
-	.resume		= acpi_device_resume,
 	.match		= acpi_bus_match,
 	.probe		= acpi_device_probe,
 	.remove		= acpi_device_remove,
 	.uevent		= acpi_device_uevent,
+	.pm		= &acpi_bus_pm,
 };
 
 static int acpi_device_register(struct acpi_device *device)

commit 17621e11fda095459e2f986c019f52686c7a4ffb
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jun 27 23:25:38 2012 +0200

    ACPI / PM: Drop pm_message_t argument from device suspend callback
    
    None of the drivers implementing the ACPI device suspend callback
    uses the pm_message_t argument of it, so this argument may be dropped
    entirely from that callback.  This will simplify switching the ACPI
    bus type to PM handling based on struct dev_pm_ops.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c8a1f3b68110..ec65ec9c529f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -296,7 +296,7 @@ static int acpi_device_suspend(struct device *dev, pm_message_t state)
 	struct acpi_driver *acpi_drv = acpi_dev->driver;
 
 	if (acpi_drv && acpi_drv->ops.suspend)
-		return acpi_drv->ops.suspend(acpi_dev, state);
+		return acpi_drv->ops.suspend(acpi_dev);
 	return 0;
 }
 

commit c4753e57b78b213f2384fa0dbafa348b087114fa
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Wed May 23 20:25:20 2012 -0600

    ACPI: Add _OST support for sysfs eject
    
    Changed acpi_bus_hot_remove_device() to support _OST. This function is
    also changed to global so that it can be called from hotplug notify
    handlers to perform hot-remove operation.
    
    Changed acpi_eject_store(), which is the sysfs eject handler. It checks
    eject_pending to see if the request was originated from ACPI eject
    notification. If not, it calls _OST(0x103,84,) per Figure 6-37 in ACPI
    5.0 spec.
    
    Added eject_pending bit to acpi_device_flags. This bit is set when the
    kernel has received an ACPI eject notification, but does not initiate
    its hot-remove operation by itself.
    
    Added struct acpi_eject_event. This structure is used to pass extended
    information to acpi_bus_hot_remove_device(), which has a single argument
    to support asynchronous call
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 85cbfdccc97c..bea3ab6b524f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -83,19 +83,29 @@ acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, cha
 }
 static DEVICE_ATTR(modalias, 0444, acpi_device_modalias_show, NULL);
 
-static void acpi_bus_hot_remove_device(void *context)
+/**
+ * acpi_bus_hot_remove_device: hot-remove a device and its children
+ * @context: struct acpi_eject_event pointer (freed in this func)
+ *
+ * Hot-remove a device and its children. This function frees up the
+ * memory space passed by arg context, so that the caller may call
+ * this function asynchronously through acpi_os_hotplug_execute().
+ */
+void acpi_bus_hot_remove_device(void *context)
 {
+	struct acpi_eject_event *ej_event = (struct acpi_eject_event *) context;
 	struct acpi_device *device;
-	acpi_handle handle = context;
+	acpi_handle handle = ej_event->handle;
 	struct acpi_object_list arg_list;
 	union acpi_object arg;
 	acpi_status status = AE_OK;
+	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE; /* default */
 
 	if (acpi_bus_get_device(handle, &device))
-		return;
+		goto err_out;
 
 	if (!device)
-		return;
+		goto err_out;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 		"Hot-removing device %s...\n", dev_name(&device->dev)));
@@ -103,7 +113,7 @@ static void acpi_bus_hot_remove_device(void *context)
 	if (acpi_bus_trim(device, 1)) {
 		printk(KERN_ERR PREFIX
 				"Removing device failed\n");
-		return;
+		goto err_out;
 	}
 
 	/* power off device */
@@ -129,10 +139,21 @@ static void acpi_bus_hot_remove_device(void *context)
 	 * TBD: _EJD support.
 	 */
 	status = acpi_evaluate_object(handle, "_EJ0", &arg_list, NULL);
-	if (ACPI_FAILURE(status))
-		printk(KERN_WARNING PREFIX
-				"Eject device failed\n");
+	if (ACPI_FAILURE(status)) {
+		if (status != AE_NOT_FOUND)
+			printk(KERN_WARNING PREFIX
+					"Eject device failed\n");
+		goto err_out;
+	}
+
+	kfree(context);
+	return;
 
+err_out:
+	/* Inform firmware the hot-remove operation has completed w/ error */
+	(void) acpi_evaluate_hotplug_ost(handle,
+				ej_event->event, ost_code, NULL);
+	kfree(context);
 	return;
 }
 
@@ -144,6 +165,7 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 	acpi_status status;
 	acpi_object_type type = 0;
 	struct acpi_device *acpi_device = to_acpi_device(d);
+	struct acpi_eject_event *ej_event;
 
 	if ((!count) || (buf[0] != '1')) {
 		return -EINVAL;
@@ -160,7 +182,25 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 		goto err;
 	}
 
-	acpi_os_hotplug_execute(acpi_bus_hot_remove_device, acpi_device->handle);
+	ej_event = kmalloc(sizeof(*ej_event), GFP_KERNEL);
+	if (!ej_event) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	ej_event->handle = acpi_device->handle;
+	if (acpi_device->flags.eject_pending) {
+		/* event originated from ACPI eject notification */
+		ej_event->event = ACPI_NOTIFY_EJECT_REQUEST;
+		acpi_device->flags.eject_pending = 0;
+	} else {
+		/* event originated from user */
+		ej_event->event = ACPI_OST_EC_OSPM_EJECT;
+		(void) acpi_evaluate_hotplug_ost(ej_event->handle,
+			ej_event->event, ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
+	}
+
+	acpi_os_hotplug_execute(acpi_bus_hot_remove_device, (void *)ej_event);
 err:
 	return ret;
 }

commit c10d7a13846bffa5c77f1122500b687ab902e2d2
Author: Daniel Drake <dsd@laptop.org>
Date:   Thu May 10 00:08:43 2012 +0100

    ACPI / PM: Generate wakeup events on fixed power button
    
    When the system is woken up by the ACPI fixed power button, currently there
    is no way of userspace becoming aware that the power button was pressed.
    
    OLPC would like to know this, so that we can respond appropriately.
    For example, if the system was woken up by a network packet, we know
    we can go back to sleep very quickly. But if the user explicitly woke the
    system with the power button, we're going to want to stay awake for a
    while.
    
    The wakeup count mechanism seems like a good fit for communicating this.
    Mark the fixed power button as wakeup-enabled, and increment its wakeup
    counter when the system is woken with the power button. (The wakeup counter
    is also incremented when the power button is pressed during system
    operation; this is already handled by an existing acpi-button codepath).
    
    Signed-off-by: Daniel Drake <dsd@laptop.org>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 85cbfdccc97c..c8a1f3b68110 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1567,6 +1567,7 @@ static int acpi_bus_scan_fixed(void)
 						ACPI_BUS_TYPE_POWER_BUTTON,
 						ACPI_STA_DEFAULT,
 						&ops);
+		device_init_wakeup(&device->dev, true);
 	}
 
 	if ((acpi_gbl_FADT.flags & ACPI_FADT_SLEEP_BUTTON) == 0) {

commit 5c7dd710f691d1b44c39e32d2f05b4286ff51f99
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri May 18 00:39:35 2012 +0200

    ACPI / PCI / PM: Fix device PM regression related to D3hot/D3cold
    
    Commit 1cc0c998fdf2 ("ACPI: Fix D3hot v D3cold confusion") introduced a
    bug in __acpi_bus_set_power() and changed the behavior of
    acpi_pci_set_power_state() in such a way that it generally doesn't work
    as expected if PCI_D3hot is passed to it as the second argument.
    
    First off, if ACPI_STATE_D3 (equal to ACPI_STATE_D3_COLD) is passed to
    __acpi_bus_set_power() and the explicit_set flag is set for the D3cold
    state, the function will try to execute AML method called "_PS4", which
    doesn't exist.
    
    Fix this by adding a check to ensure that the name of the AML method
    to execute for transitions to ACPI_STATE_D3_COLD is correct in
    __acpi_bus_set_power().  Also make sure that the explicit_set flag
    for ACPI_STATE_D3_COLD will be set if _PS3 is present and modify
    acpi_power_transition() to avoid accessing power resources for
    ACPI_STATE_D3_COLD, because they don't exist.
    
    Second, if PCI_D3hot is passed to acpi_pci_set_power_state() as the
    target state, the function will request a transition to
    ACPI_STATE_D3_HOT instead of ACPI_STATE_D3.  However,
    ACPI_STATE_D3_HOT is now only marked as supported if the _PR3 AML
    method is defined for the given device, which is rare.  This causes
    problems to happen on systems where devices were successfully put
    into ACPI D3 by pci_set_power_state(PCI_D3hot) which doesn't work
    now.  In particular, some unused graphics adapters are not turned
    off as a result.
    
    To fix this issue restore the old behavior of
    acpi_pci_set_power_state(), which is to request a transition to
    ACPI_STATE_D3 (equal to ACPI_STATE_D3_COLD) if either PCI_D3hot or
    PCI_D3cold is passed to it as the argument.
    
    This approach is not ideal, because generally power should not
    be removed from devices if PCI_D3hot is the target power state,
    but since this behavior is relied on, we have no choice but to
    restore it at the moment and spend more time on designing a
    better solution in the future.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=43228
    Reported-by: rocko <rockorequin@hotmail.com>
    Reported-by: Cristian Rodríguez <crrodriguez@opensuse.org>
    Reported-and-tested-by: Peter <lekensteyn@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 7417267e88fa..85cbfdccc97c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -908,6 +908,10 @@ static int acpi_bus_get_power_flags(struct acpi_device *device)
 	device->power.states[ACPI_STATE_D3].flags.valid = 1;
 	device->power.states[ACPI_STATE_D3].power = 0;
 
+	/* Set D3cold's explicit_set flag if _PS3 exists. */
+	if (device->power.states[ACPI_STATE_D3_HOT].flags.explicit_set)
+		device->power.states[ACPI_STATE_D3_COLD].flags.explicit_set = 1;
+
 	acpi_bus_init_power(device);
 
 	return 0;

commit 1cc0c998fdf2cb665d625fb565a0d6db5c81c639
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Apr 23 09:03:49 2012 +0800

    ACPI: Fix D3hot v D3cold confusion
    
    Before this patch, ACPI_STATE_D3 incorrectly referenced D3hot
    in some places, but D3cold in other places.
    
    After this patch, ACPI_STATE_D3 always means ACPI_STATE_D3_COLD;
    and all references to D3hot use ACPI_STATE_D3_HOT.
    
    ACPI's _PR3 method is used to enter both D3hot and D3cold states.
    What distinguishes D3hot from D3cold is the presence _PR3
    (Power Resources for D3hot)  If these resources are all ON,
    then the state is D3hot.  If _PR3 is not present,
    or all _PR0 resources for the devices are OFF,
    then the state is D3cold.
    
    This patch applies after Linux-3.4-rc1.
    A future syntax cleanup may remove ACPI_STATE_D3
    to emphasize that it always means ACPI_STATE_D3_COLD.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Aaron Lu <aaron.lu@amd.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 767e2dcb9616..7417267e88fa 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -869,7 +869,7 @@ static int acpi_bus_get_power_flags(struct acpi_device *device)
 	/*
 	 * Enumerate supported power management states
 	 */
-	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3; i++) {
+	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3_HOT; i++) {
 		struct acpi_device_power_state *ps = &device->power.states[i];
 		char object_name[5] = { '_', 'P', 'R', '0' + i, '\0' };
 
@@ -884,21 +884,18 @@ static int acpi_bus_get_power_flags(struct acpi_device *device)
 				acpi_bus_add_power_resource(ps->resources.handles[j]);
 		}
 
-		/* The exist of _PR3 indicates D3Cold support */
-		if (i == ACPI_STATE_D3) {
-			status = acpi_get_handle(device->handle, object_name, &handle);
-			if (ACPI_SUCCESS(status))
-				device->power.states[ACPI_STATE_D3_COLD].flags.valid = 1;
-		}
-
 		/* Evaluate "_PSx" to see if we can do explicit sets */
 		object_name[2] = 'S';
 		status = acpi_get_handle(device->handle, object_name, &handle);
 		if (ACPI_SUCCESS(status))
 			ps->flags.explicit_set = 1;
 
-		/* State is valid if we have some power control */
-		if (ps->resources.count || ps->flags.explicit_set)
+		/*
+		 * State is valid if there are means to put the device into it.
+		 * D3hot is only valid if _PR3 present.
+		 */
+		if (ps->resources.count ||
+		    (ps->flags.explicit_set && i < ACPI_STATE_D3_HOT))
 			ps->flags.valid = 1;
 
 		ps->power = -1;	/* Unknown - driver assigned */

commit ec612fcf43e09f5e05d37baf4d3f138b3fcc2f3d
Merge: 73f05330497b b24e50988536
Author: Len Brown <len.brown@intel.com>
Date:   Fri Mar 30 16:21:26 2012 -0400

    Merge branch 'd3' into release
    
    Conflicts:
            drivers/acpi/sleep.c
    
    This was a text conflict between
    a2ef5c4fd44ce3922435139393b89f2cce47f576
    (ACPI: Move module parameter gts and bfs to sleep.c)
    
    which added #include <linux/module.h>
    
    and
    
    b24e5098853653554baf6ec975b9e855f3d6e5c0
    (ACPI, PCI: Move acpi_dev_run_wake() to ACPI core)
    
    which added #include <linux/pm_runtime.h>
    
    The resolution was to take them both.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 37239978778806ecba54da60676abb46870acebb
Author: Alex He <alex.he@amd.com>
Date:   Tue Feb 21 16:58:10 2012 +0800

    ACPI: Clean redundant codes in scan.c
    
    Clean the redundant codes of apci_bus_get_power_flags().
    
    Signed-off-by: Alex He <alex.he@amd.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8ab80bafe3f1..5d24a17aa854 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -880,7 +880,6 @@ static int acpi_bus_get_power_flags(struct acpi_device *device)
 			int j;
 
 			device->power.flags.power_resources = 1;
-			ps->flags.valid = 1;
 			for (j = 0; j < ps->resources.count; j++)
 				acpi_bus_add_power_resource(ps->resources.handles[j]);
 		}
@@ -888,10 +887,8 @@ static int acpi_bus_get_power_flags(struct acpi_device *device)
 		/* Evaluate "_PSx" to see if we can do explicit sets */
 		object_name[2] = 'S';
 		status = acpi_get_handle(device->handle, object_name, &handle);
-		if (ACPI_SUCCESS(status)) {
+		if (ACPI_SUCCESS(status))
 			ps->flags.explicit_set = 1;
-			ps->flags.valid = 1;
-		}
 
 		/* State is valid if we have some power control */
 		if (ps->resources.count || ps->flags.explicit_set)

commit 3ebc81b8937d2bc1d0d0064bed29434dfce490aa
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Mar 29 14:09:38 2012 +0800

    ACPI: Introduce ACPI D3_COLD state support
    
    If a device has _PR3, it means the device supports D3_COLD.
    Add the ability to validate and enter D3_COLD state in ACPI.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8ab80bafe3f1..571396cf6110 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -885,6 +885,13 @@ static int acpi_bus_get_power_flags(struct acpi_device *device)
 				acpi_bus_add_power_resource(ps->resources.handles[j]);
 		}
 
+		/* The exist of _PR3 indicates D3Cold support */
+		if (i == ACPI_STATE_D3) {
+			status = acpi_get_handle(device->handle, object_name, &handle);
+			if (ACPI_SUCCESS(status))
+				device->power.states[ACPI_STATE_D3_COLD].flags.valid = 1;
+		}
+
 		/* Evaluate "_PSx" to see if we can do explicit sets */
 		object_name[2] = 'S';
 		status = acpi_get_handle(device->handle, object_name, &handle);

commit 581de59e8dff8eaa52809e768a585e9ef336aa4a
Author: Thomas Meyer <thomas@m3y3r.de>
Date:   Sat Aug 6 11:32:56 2011 +0200

    ACPI: use kstrdup()
    
     Use kstrdup rather than duplicating its implementation
    
     The semantic patch that makes this output is available
     in scripts/coccinelle/api/kstrdup.cocci.
    
     More information about semantic patching is available at
     http://coccinelle.lip6.fr/
    
    Signed-off-by: Thomas Meyer <thomas@m3y3r.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 449c556274c0..8ab80bafe3f1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1062,13 +1062,12 @@ static void acpi_add_id(struct acpi_device *device, const char *dev_id)
 	if (!id)
 		return;
 
-	id->id = kmalloc(strlen(dev_id) + 1, GFP_KERNEL);
+	id->id = kstrdup(dev_id, GFP_KERNEL);
 	if (!id->id) {
 		kfree(id);
 		return;
 	}
 
-	strcpy(id->id, dev_id);
 	list_add_tail(&id->list, &device->pnp.ids);
 }
 

commit 7bed50c5edf5cba8dd515a31191cbfb6065ddc85
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Apr 26 11:33:18 2011 +0200

    ACPI / PM: Avoid infinite recurrence while registering power resources
    
    There is at least one BIOS with a DSDT containing a power resource
    object with a _PR0 entry pointing back to that power resource.  In
    consequence, while registering that power resource
    acpi_bus_get_power_flags() sees that it depends on itself and tries
    to register it again, which leads to an infinitely deep recurrence.
    This problem was introduced by commit bf325f9538d8c89312be305b9779e
    (ACPI / PM: Register power resource devices as soon as they are
    needed).
    
    To fix this problem use the observation that power resources cannot
    be power manageable and prevent acpi_bus_get_power_flags() from
    being called for power resource objects.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=31872
    Reported-and-tested-by: Pascal Dormeau <pdormeau@free.fr>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Len Brown <lenb@kernel.org>
    Cc: stable@kernel.org

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b136c9c1e531..449c556274c0 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -943,6 +943,10 @@ static int acpi_bus_get_flags(struct acpi_device *device)
 	if (ACPI_SUCCESS(status))
 		device->flags.lockable = 1;
 
+	/* Power resources cannot be power manageable. */
+	if (device->device_type == ACPI_BUS_TYPE_POWER)
+		return 0;
+
 	/* Presence of _PS0|_PR0 indicates 'power manageable' */
 	status = acpi_get_handle(device->handle, "_PS0", &temp);
 	if (ACPI_FAILURE(status))

commit 5190726765b40774c069e187a958e10ccd970e65
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:40:37 2011 +0100

    ACPI: Remove the wakeup.run_wake_count device field
    
    The wakeup.run_wake_count ACPI device field is only used by the PCI
    runtime PM code to "protect" devices from being prepared for
    generating wakeup signals more than once in a row.  However, it
    really doesn't provide any protection, because (1) all of the
    functions it is supposed to protect use their own reference counters
    effectively ensuring that the device will be set up for generating
    wakeup signals just once and (2) the PCI runtime PM code uses
    wakeup.run_wake_count in a racy way, since nothing prevents
    acpi_dev_run_wake() from being called concurrently from two different
    threads for the same device.
    
    Remove the wakeup.run_wake_count ACPI device field which is
    unnecessary, confusing and used in a wrong way.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b99e62494607..b136c9c1e531 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -797,7 +797,6 @@ static void acpi_bus_set_run_wake_flags(struct acpi_device *device)
 	acpi_status status;
 	acpi_event_status event_status;
 
-	device->wakeup.run_wake_count = 0;
 	device->wakeup.flags.notifier_present = 0;
 
 	/* Power button, Lid switch always enable wakeup */

commit d57d09a480e1db38eeee7629c81289b00f338a15
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jan 6 23:41:27 2011 +0100

    ACPI: Drop device flag wake_capable
    
    The wake_capable ACPI device flag is not necessary, because it is
    only used in scan.c for recording the information that _PRW is
    present for the given device.  That information is only used by
    acpi_add_single_object() to decide whether or not to call
    acpi_bus_get_wakeup_device_flags(), so the flag may be dropped
    if the _PRW check is moved to acpi_bus_get_wakeup_device_flags().
    Moreover, acpi_bus_get_wakeup_device_flags() always returns 0,
    so it really should be void.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b5e4dedb497d..b99e62494607 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -815,16 +815,22 @@ static void acpi_bus_set_run_wake_flags(struct acpi_device *device)
 				!!(event_status & ACPI_EVENT_FLAG_HANDLE);
 }
 
-static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
+static void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 {
+	acpi_handle temp;
 	acpi_status status = 0;
 	int psw_error;
 
+	/* Presence of _PRW indicates wake capable */
+	status = acpi_get_handle(device->handle, "_PRW", &temp);
+	if (ACPI_FAILURE(status))
+		return;
+
 	status = acpi_bus_extract_wakeup_device_power_package(device->handle,
 							      &device->wakeup);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Extracting _PRW package"));
-		goto end;
+		return;
 	}
 
 	device->wakeup.flags.valid = 1;
@@ -840,11 +846,6 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	if (psw_error)
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				"error in _DSW or _PSW evaluation\n"));
-
-end:
-	if (ACPI_FAILURE(status))
-		device->flags.wake_capable = 0;
-	return 0;
 }
 
 static void acpi_bus_add_power_resource(acpi_handle handle);
@@ -950,11 +951,6 @@ static int acpi_bus_get_flags(struct acpi_device *device)
 	if (ACPI_SUCCESS(status))
 		device->flags.power_manageable = 1;
 
-	/* Presence of _PRW indicates wake capable */
-	status = acpi_get_handle(device->handle, "_PRW", &temp);
-	if (ACPI_SUCCESS(status))
-		device->flags.wake_capable = 1;
-
 	/* TBD: Performance management */
 
 	return 0;
@@ -1281,11 +1277,7 @@ static int acpi_add_single_object(struct acpi_device **child,
 	 * Wakeup device management
 	 *-----------------------
 	 */
-	if (device->flags.wake_capable) {
-		result = acpi_bus_get_wakeup_device_flags(device);
-		if (result)
-			goto end;
-	}
+	acpi_bus_get_wakeup_device_flags(device);
 
 	/*
 	 * Performance Management

commit 86e4e20e8a5301ff7104a4f40f35fd5bee408186
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jan 6 23:40:00 2011 +0100

    ACPI: Always check if _PRW is present before trying to evaluate it
    
    Before evaluating _PRW for devices that are reported as inactive or
    not present by their _STA control methods we should check if those
    methods are actually present (otherwise the evaulation of _PRW will
    obviously fail and a scary message will be printed unnecessarily).
    
    Reported-by: Andreas Mohr <andi@lisas.de>
    Reported-by: Maciej Rutecki <maciej.rutecki@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 64d4da0d6d52..b5e4dedb497d 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1388,7 +1388,6 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 	struct acpi_bus_ops *ops = context;
 	int type;
 	unsigned long long sta;
-	struct acpi_device_wakeup wakeup;
 	struct acpi_device *device;
 	acpi_status status;
 	int result;
@@ -1399,7 +1398,13 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 
 	if (!(sta & ACPI_STA_DEVICE_PRESENT) &&
 	    !(sta & ACPI_STA_DEVICE_FUNCTIONING)) {
-		acpi_bus_extract_wakeup_device_power_package(handle, &wakeup);
+		struct acpi_device_wakeup wakeup;
+		acpi_handle temp;
+
+		status = acpi_get_handle(handle, "_PRW", &temp);
+		if (ACPI_SUCCESS(status))
+			acpi_bus_extract_wakeup_device_power_package(handle,
+								     &wakeup);
 		return AE_CTRL_DEPTH;
 	}
 

commit fb4af417cce9ff87abf33a6bb9a0cf613e285364
Merge: 07bf280521bb 7b330707ddda
Author: Len Brown <len.brown@intel.com>
Date:   Wed Jan 12 04:55:46 2011 -0500

    Merge branch 'wakeup-etc-rafael' into release

commit 07bf280521bb06bc8e64f0b998fc391253fcb959
Merge: 1ae5ec903f71 53eac700b0df
Author: Len Brown <len.brown@intel.com>
Date:   Wed Jan 12 04:55:28 2011 -0500

    Merge branch 'power-resource' into release

commit bf325f9538d8c89312be305b9779edbcb436af00
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 25 00:10:44 2010 +0100

    ACPI / PM: Register power resource devices as soon as they are needed
    
    Depending on the organization of the ACPI namespace, power resource
    device objects may generally be scanned after the "regular" device
    objects that they are referred from through _PRn.  This, in turn, may
    cause acpi_bus_get_power_flags() to attempt to access them through
    acpi_bus_init_power() before they are registered (and initialized by
    acpi_power_driver).  [This is not a theoretical issue, it actually
    happens for one PnP device on my testbed HP nx6325.]
    
    To fix this problem, make acpi_bus_get_power_flags() attempt to
    register power resource devices as soon as they have been found in
    the _PRn output for any other devices.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 2951a27303cb..cb7956c23ca4 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -847,6 +847,8 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	return 0;
 }
 
+static void acpi_bus_add_power_resource(acpi_handle handle);
+
 static int acpi_bus_get_power_flags(struct acpi_device *device)
 {
 	acpi_status status = 0;
@@ -875,8 +877,12 @@ static int acpi_bus_get_power_flags(struct acpi_device *device)
 		acpi_evaluate_reference(device->handle, object_name, NULL,
 					&ps->resources);
 		if (ps->resources.count) {
+			int j;
+
 			device->power.flags.power_resources = 1;
 			ps->flags.valid = 1;
+			for (j = 0; j < ps->resources.count; j++)
+				acpi_bus_add_power_resource(ps->resources.handles[j]);
 		}
 
 		/* Evaluate "_PSx" to see if we can do explicit sets */
@@ -1323,6 +1329,20 @@ static int acpi_add_single_object(struct acpi_device **child,
 #define ACPI_STA_DEFAULT (ACPI_STA_DEVICE_PRESENT | ACPI_STA_DEVICE_ENABLED | \
 			  ACPI_STA_DEVICE_UI      | ACPI_STA_DEVICE_FUNCTIONING)
 
+static void acpi_bus_add_power_resource(acpi_handle handle)
+{
+	struct acpi_bus_ops ops = {
+		.acpi_op_add = 1,
+		.acpi_op_start = 1,
+	};
+	struct acpi_device *device = NULL;
+
+	acpi_bus_get_device(handle, &device);
+	if (!device)
+		acpi_add_single_object(&device, handle, ACPI_BUS_TYPE_POWER,
+					ACPI_STA_DEFAULT, &ops);
+}
+
 static int acpi_bus_type_and_status(acpi_handle handle, int *type,
 				    unsigned long long *sta)
 {

commit 97d9a9e9f5ee68f20005ca5aa77c6b684e7cace8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 25 00:10:02 2010 +0100

    ACPI / PM: Register acpi_power_driver early
    
    The ACPI device driver used for handling power resources,
    acpi_power_driver, creates a struct acpi_power_resource object for
    each ACPI device representing a power resource.  These objects are
    then used when setting and reading the power states of devices using
    the corresponding power resources.  Unfortunately, acpi_power_driver
    is registered after acpi_scan_init() that may add devices using the
    power resources before acpi_power_driver has a chance to create
    struct acpi_power_resource objects for them (specifically, the power
    resources may be referred to during the scanning process through
    acpi_bus_get_power() before they have been initialized).
    
    As the first step towards fixing this issue, move the registration
    of acpi_power_driver into acpi_scan_init() so that power resource
    devices can be initialized by it as soon as they have been found in
    the namespace.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ef8e659771e1..2951a27303cb 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1570,6 +1570,8 @@ int __init acpi_scan_init(void)
 		printk(KERN_ERR PREFIX "Could not register bus type\n");
 	}
 
+	acpi_power_init();
+
 	/*
 	 * Enumerate devices in the ACPI namespace.
 	 */

commit ade3e7fef794781c0798d0cf0f046123842ba550
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 25 00:08:36 2010 +0100

    ACPI / PM: Add function for device power state initialization
    
    Add function acpi_bus_init_power() for getting the initial power
    state of an ACPI device and reference counting its power resources
    as appropriate.
    
    Make acpi_bus_get_power_flags() use the new function instead of
    acpi_bus_get_power() that updates device->power.state without
    reference counting the device's power resources.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 29ef505c487b..ef8e659771e1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -901,10 +901,7 @@ static int acpi_bus_get_power_flags(struct acpi_device *device)
 	device->power.states[ACPI_STATE_D3].flags.valid = 1;
 	device->power.states[ACPI_STATE_D3].power = 0;
 
-	/* TBD: System wake support and resource requirements. */
-
-	device->power.state = ACPI_STATE_UNKNOWN;
-	acpi_bus_get_power(device->handle, &(device->power.state));
+	acpi_bus_init_power(device);
 
 	return 0;
 }

commit bba63a296ffab20e08d9e8252d2f0d99050ac859
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Dec 13 13:39:17 2010 +0800

    ACPICA: Implicit notify support
    
    This feature provides an automatic device notification for wake devices
    when a wakeup GPE occurs and there is no corresponding GPE method or
    handler. Rather than ignoring such a GPE, an implicit AML Notify
    operation is performed on the parent device object.
    This feature is not part of the ACPI specification and is provided for
    Windows compatibility only.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 70249b3d2934..ce6741ee1965 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -778,7 +778,7 @@ acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 		wakeup->resources.handles[i] = element->reference.handle;
 	}
 
-	acpi_setup_gpe_for_wake(wakeup->gpe_device, wakeup->gpe_number);
+	acpi_setup_gpe_for_wake(handle, wakeup->gpe_device, wakeup->gpe_number);
 
  out:
 	kfree(buffer.pointer);

commit 3a37898d507794cfc68a092303e02651d3f01308
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Dec 13 13:36:15 2010 +0800

    ACPICA: Rename some function and variable names
    
    Some function and variable names are renamed to be consistent with
    ACPICA code base.
    
    acpi_raw_enable_gpe -> acpi_ev_add_gpe_reference
    acpi_raw_disable_gpe -> acpi_ev_remove_gpe_reference
    acpi_gpe_can_wake -> acpi_setup_gpe_for_wake
    acpi_gpe_wakeup -> acpi_set_gpe_wake_mask
    acpi_update_gpes -> acpi_update_all_gpes
    acpi_all_gpes_initialized -> acpi_gbl_all_gpes_initialized
    acpi_handler_info -> acpi_gpe_handler_info
    ...
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 29ef505c487b..70249b3d2934 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -778,7 +778,7 @@ acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
 		wakeup->resources.handles[i] = element->reference.handle;
 	}
 
-	acpi_gpe_can_wake(wakeup->gpe_device, wakeup->gpe_number);
+	acpi_setup_gpe_for_wake(wakeup->gpe_device, wakeup->gpe_number);
 
  out:
 	kfree(buffer.pointer);
@@ -1467,7 +1467,7 @@ int acpi_bus_start(struct acpi_device *device)
 
 	result = acpi_bus_scan(device->handle, &ops, NULL);
 
-	acpi_update_gpes();
+	acpi_update_all_gpes();
 
 	return result;
 }
@@ -1584,7 +1584,7 @@ int __init acpi_scan_init(void)
 	if (result)
 		acpi_device_unregister(acpi_root, ACPI_BUS_REMOVAL_NORMAL);
 	else
-		acpi_update_gpes();
+		acpi_update_all_gpes();
 
 	return result;
 }

commit f2b56bc808addb908a5bf435d9b942c02af9a7c4
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jan 6 23:34:22 2011 +0100

    ACPI / PM: Use device wakeup flags for handling ACPI wakeup devices
    
    There are ACPI devices (buttons and the laptop lid) that can wake up
    the system from sleep states and have no "physical" companion
    devices.  The ACPI subsystem uses two flags, wakeup.state.enabled and
    wakeup.flags.always_enabled, for handling those devices, but they
    are not accessible through the standard device wakeup infrastructure.
    User space can only control them via the /proc/acpi/wakeup interface
    that is not really convenient (e.g. the way in which devices are
    enabled to wake up the system is not portable between different
    systems, because it requires one to know the devices' "names" used in
    the system's ACPI tables).
    
    To address this problem, use standard device wakeup flags instead of
    the special ACPI flags for handling those devices.  In particular,
    use device_set_wakeup_capable() to mark the ACPI wakeup devices
    during initialization and use device_set_wakeup_enable() to allow
    or disallow them to wake up the system from sleep states.  Rework
    the /proc/acpi/wakeup interface to take these changes into account.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 29ef505c487b..bf7acbff1f5f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -803,7 +803,7 @@ static void acpi_bus_set_run_wake_flags(struct acpi_device *device)
 	/* Power button, Lid switch always enable wakeup */
 	if (!acpi_match_device_ids(device, button_device_ids)) {
 		device->wakeup.flags.run_wake = 1;
-		device->wakeup.flags.always_enabled = 1;
+		device_set_wakeup_capable(&device->dev, true);
 		return;
 	}
 

commit b581a7f9c3abc6c7afacd021747543d32ff17adb
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Dec 17 22:34:01 2010 +0100

    ACPI: Execute _PRW for devices reported as inactive or not present
    
    If a device is reported as inactive or not present by its _STA
    control method, acpi_bus_check_add() skips it without evaluating its
    _PRW method.  This leads to a problem when the device's _PRW method
    points to a GPE, because in that case the GPE may be enabled by
    ACPICA during the subsequent acpi_update_gpes() call which, in
    turn, may cause a GPE storm to appear.
    
    To avoid this issue, make acpi_bus_check_add() evaluate _PRW for
    inactive or not present devices and register the wakeup GPE
    information returned by them, so that acpi_update_gpes() does not
    enable their GPEs unnecessarily.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 2b6c21d86b98..29ef505c487b 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -705,54 +705,85 @@ static int acpi_bus_get_perf_flags(struct acpi_device *device)
 }
 
 static acpi_status
-acpi_bus_extract_wakeup_device_power_package(struct acpi_device *device,
-					     union acpi_object *package)
+acpi_bus_extract_wakeup_device_power_package(acpi_handle handle,
+					     struct acpi_device_wakeup *wakeup)
 {
-	int i = 0;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *package = NULL;
 	union acpi_object *element = NULL;
+	acpi_status status;
+	int i = 0;
 
-	if (!device || !package || (package->package.count < 2))
+	if (!wakeup)
 		return AE_BAD_PARAMETER;
 
+	/* _PRW */
+	status = acpi_evaluate_object(handle, "_PRW", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRW"));
+		return status;
+	}
+
+	package = (union acpi_object *)buffer.pointer;
+
+	if (!package || (package->package.count < 2)) {
+		status = AE_BAD_DATA;
+		goto out;
+	}
+
 	element = &(package->package.elements[0]);
-	if (!element)
-		return AE_BAD_PARAMETER;
+	if (!element) {
+		status = AE_BAD_DATA;
+		goto out;
+	}
 	if (element->type == ACPI_TYPE_PACKAGE) {
 		if ((element->package.count < 2) ||
 		    (element->package.elements[0].type !=
 		     ACPI_TYPE_LOCAL_REFERENCE)
-		    || (element->package.elements[1].type != ACPI_TYPE_INTEGER))
-			return AE_BAD_DATA;
-		device->wakeup.gpe_device =
+		    || (element->package.elements[1].type != ACPI_TYPE_INTEGER)) {
+			status = AE_BAD_DATA;
+			goto out;
+		}
+		wakeup->gpe_device =
 		    element->package.elements[0].reference.handle;
-		device->wakeup.gpe_number =
+		wakeup->gpe_number =
 		    (u32) element->package.elements[1].integer.value;
 	} else if (element->type == ACPI_TYPE_INTEGER) {
-		device->wakeup.gpe_number = element->integer.value;
-	} else
-		return AE_BAD_DATA;
+		wakeup->gpe_device = NULL;
+		wakeup->gpe_number = element->integer.value;
+	} else {
+		status = AE_BAD_DATA;
+		goto out;
+	}
 
 	element = &(package->package.elements[1]);
 	if (element->type != ACPI_TYPE_INTEGER) {
-		return AE_BAD_DATA;
+		status = AE_BAD_DATA;
+		goto out;
 	}
-	device->wakeup.sleep_state = element->integer.value;
+	wakeup->sleep_state = element->integer.value;
 
 	if ((package->package.count - 2) > ACPI_MAX_HANDLES) {
-		return AE_NO_MEMORY;
+		status = AE_NO_MEMORY;
+		goto out;
 	}
-	device->wakeup.resources.count = package->package.count - 2;
-	for (i = 0; i < device->wakeup.resources.count; i++) {
+	wakeup->resources.count = package->package.count - 2;
+	for (i = 0; i < wakeup->resources.count; i++) {
 		element = &(package->package.elements[i + 2]);
-		if (element->type != ACPI_TYPE_LOCAL_REFERENCE)
-			return AE_BAD_DATA;
+		if (element->type != ACPI_TYPE_LOCAL_REFERENCE) {
+			status = AE_BAD_DATA;
+			goto out;
+		}
 
-		device->wakeup.resources.handles[i] = element->reference.handle;
+		wakeup->resources.handles[i] = element->reference.handle;
 	}
 
-	acpi_gpe_can_wake(device->wakeup.gpe_device, device->wakeup.gpe_number);
+	acpi_gpe_can_wake(wakeup->gpe_device, wakeup->gpe_number);
 
-	return AE_OK;
+ out:
+	kfree(buffer.pointer);
+
+	return status;
 }
 
 static void acpi_bus_set_run_wake_flags(struct acpi_device *device)
@@ -787,26 +818,15 @@ static void acpi_bus_set_run_wake_flags(struct acpi_device *device)
 static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 {
 	acpi_status status = 0;
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
-	union acpi_object *package = NULL;
 	int psw_error;
 
-	/* _PRW */
-	status = acpi_evaluate_object(device->handle, "_PRW", NULL, &buffer);
-	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRW"));
-		goto end;
-	}
-
-	package = (union acpi_object *)buffer.pointer;
-	status = acpi_bus_extract_wakeup_device_power_package(device, package);
+	status = acpi_bus_extract_wakeup_device_power_package(device->handle,
+							      &device->wakeup);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Extracting _PRW package"));
 		goto end;
 	}
 
-	kfree(buffer.pointer);
-
 	device->wakeup.flags.valid = 1;
 	device->wakeup.prepare_count = 0;
 	acpi_bus_set_run_wake_flags(device);
@@ -1351,6 +1371,7 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 	struct acpi_bus_ops *ops = context;
 	int type;
 	unsigned long long sta;
+	struct acpi_device_wakeup wakeup;
 	struct acpi_device *device;
 	acpi_status status;
 	int result;
@@ -1360,8 +1381,10 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 		return AE_OK;
 
 	if (!(sta & ACPI_STA_DEVICE_PRESENT) &&
-	    !(sta & ACPI_STA_DEVICE_FUNCTIONING))
+	    !(sta & ACPI_STA_DEVICE_FUNCTIONING)) {
+		acpi_bus_extract_wakeup_device_power_package(handle, &wakeup);
 		return AE_CTRL_DEPTH;
+	}
 
 	/*
 	 * We may already have an acpi_device from a previous enumeration.  If

commit 6e04c417aed5b0a5bd6ae80928bbd759fa1faabc
Merge: 880308089d0a a210080195c9
Author: Len Brown <len.brown@intel.com>
Date:   Mon Oct 25 02:13:09 2010 -0400

    Merge branch 'gpe-defer' into release

commit 620e112cfe1c9281c176de8ad1a7691c4eb4950d
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Oct 1 10:54:00 2010 +0200

    ACPI/PNP: A HID value of an object never changes -> make it const
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 81aec8d66fd0..6155eeb2e89a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -26,8 +26,7 @@ extern struct acpi_device *acpi_root;
 
 #define ACPI_IS_ROOT_DEVICE(device)    (!(device)->parent)
 
-/* Should be const */
-static char* dummy_hid = "device";
+static const char *dummy_hid = "device";
 
 static LIST_HEAD(acpi_device_list);
 static LIST_HEAD(acpi_bus_id_list);
@@ -1021,7 +1020,7 @@ static int acpi_dock_match(struct acpi_device *device)
 	return acpi_get_handle(device->handle, "_DCK", &tmp);
 }
 
-char *acpi_device_hid(struct acpi_device *device)
+const char *acpi_device_hid(struct acpi_device *device)
 {
 	struct acpi_hardware_id *hid;
 

commit 2b2ae7c7f8e25043793042eb9df88aa875b4cff8
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Oct 1 10:53:59 2010 +0200

    ACPI: Do not export hid/modalias sysfs file for ACPI objects without a HID
    
    Boot and compile tested.
    The fact that pnp.ids can now be empty needs testing on some
    further machines, though.
    
    This should handle a "modprobe is wrongly called by udev" issue:
    https://bugzilla.kernel.org/show_bug.cgi?id=19162
    
    Modaliase files in
    /sys/devices/LNXSYSTM:00/
    went down from 113 to 71 on my tested system.
    
    This is a sysfs change, but userspace must already be able to handle it.
    
    Also do not fill up pnp.ids list with a "struct hid"
    entry. This comment:
         * This generic ID isn't useful for driver binding, but it provides
         * the useful property that "every acpi_device has an ID."
    is still half way true:
    Best you never touch pnp.ids list directly or make sure it can be empty,
    instead use:
    char *acpi_device_hid()
    which always returns a value ("device" as a dummy if the object
    has no hid).
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    CC: Zhang Rui <rui.zhang@intel.com>
    CC: kay.sievers@vrfy.org
    CC: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b23825ecfa37..81aec8d66fd0 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -26,6 +26,9 @@ extern struct acpi_device *acpi_root;
 
 #define ACPI_IS_ROOT_DEVICE(device)    (!(device)->parent)
 
+/* Should be const */
+static char* dummy_hid = "device";
+
 static LIST_HEAD(acpi_device_list);
 static LIST_HEAD(acpi_bus_id_list);
 DEFINE_MUTEX(acpi_device_lock);
@@ -49,6 +52,9 @@ static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
 	int count;
 	struct acpi_hardware_id *id;
 
+	if (list_empty(&acpi_dev->pnp.ids))
+		return 0;
+
 	len = snprintf(modalias, size, "acpi:");
 	size -= len;
 
@@ -202,13 +208,15 @@ static int acpi_device_setup_files(struct acpi_device *dev)
 			goto end;
 	}
 
-	result = device_create_file(&dev->dev, &dev_attr_hid);
-	if (result)
-		goto end;
+	if (!list_empty(&dev->pnp.ids)) {
+		result = device_create_file(&dev->dev, &dev_attr_hid);
+		if (result)
+			goto end;
 
-	result = device_create_file(&dev->dev, &dev_attr_modalias);
-	if (result)
-		goto end;
+		result = device_create_file(&dev->dev, &dev_attr_modalias);
+		if (result)
+			goto end;
+	}
 
         /*
          * If device has _EJ0, 'eject' file is created that is used to trigger
@@ -316,6 +324,9 @@ static int acpi_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 	int len;
 
+	if (list_empty(&acpi_dev->pnp.ids))
+		return 0;
+
 	if (add_uevent_var(env, "MODALIAS="))
 		return -ENOMEM;
 	len = create_modalias(acpi_dev, &env->buf[env->buflen - 1],
@@ -1014,6 +1025,9 @@ char *acpi_device_hid(struct acpi_device *device)
 {
 	struct acpi_hardware_id *hid;
 
+	if (list_empty(&device->pnp.ids))
+		return dummy_hid;
+
 	hid = list_first_entry(&device->pnp.ids, struct acpi_hardware_id, list);
 	return hid->id;
 }
@@ -1142,16 +1156,6 @@ static void acpi_device_set_id(struct acpi_device *device)
 		acpi_add_id(device, ACPI_BUTTON_HID_SLEEPF);
 		break;
 	}
-
-	/*
-	 * We build acpi_devices for some objects that don't have _HID or _CID,
-	 * e.g., PCI bridges and slots.  Drivers can't bind to these objects,
-	 * but we do use them indirectly by traversing the acpi_device tree.
-	 * This generic ID isn't useful for driver binding, but it provides
-	 * the useful property that "every acpi_device has an ID."
-	 */
-	if (list_empty(&device->pnp.ids))
-		acpi_add_id(device, "device");
 }
 
 static int acpi_device_set_context(struct acpi_device *device)

commit a210080195c95ebca2a517ee3057d71607aa65e0
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Sep 16 00:30:43 2010 +0200

    ACPI / ACPICA: Defer enabling of runtime GPEs (v3)
    
    The current ACPI GPEs initialization code has a problem that it
    enables some GPEs pointed to by device _PRW methods, generally
    intended for signaling wakeup events (system or device wakeup).
    These GPEs are then almost immediately disabled by the ACPI namespace
    scanning code with the help of acpi_gpe_can_wake(), but it would be
    better not to enable them at all until really necessary.
    
    Modify the initialization of GPEs so that the ones that have
    associated _Lxx or _Exx methods and are not pointed to by any _PRW
    methods will be enabled after the namespace scan is complete.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b23825ecfa37..f87f04603b68 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1431,6 +1431,7 @@ EXPORT_SYMBOL(acpi_bus_add);
 int acpi_bus_start(struct acpi_device *device)
 {
 	struct acpi_bus_ops ops;
+	int result;
 
 	if (!device)
 		return -EINVAL;
@@ -1438,7 +1439,11 @@ int acpi_bus_start(struct acpi_device *device)
 	memset(&ops, 0, sizeof(ops));
 	ops.acpi_op_start = 1;
 
-	return acpi_bus_scan(device->handle, &ops, NULL);
+	result = acpi_bus_scan(device->handle, &ops, NULL);
+
+	acpi_update_gpes();
+
+	return result;
 }
 EXPORT_SYMBOL(acpi_bus_start);
 
@@ -1552,6 +1557,8 @@ int __init acpi_scan_init(void)
 
 	if (result)
 		acpi_device_unregister(acpi_root, ACPI_BUS_REMOVAL_NORMAL);
+	else
+		acpi_update_gpes();
 
 	return result;
 }

commit 9874647ba1bdf3e1af25e079070a00676f60f2f0
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 8 00:43:36 2010 +0200

    ACPI / ACPICA: Do not execute _PRW methods during initialization
    
    Currently, during initialization ACPICA walks the entire ACPI
    namespace in search of any device objects with assciated _PRW
    methods.  All of the _PRW methods found are executed in the process
    to extract the GPE information returned by them, so that the GPEs in
    question can be marked as "able to wakeup" (more precisely, the
    ACPI_GPE_CAN_WAKE flag is set for them).  The only purpose of this
    exercise is to avoid enabling the CAN_WAKE GPEs automatically, even
    if there are _Lxx/_Exx methods associated with them.  However, it is
    both costly and unnecessary, because the host OS has to execute the
    _PRW methods anyway to check which devices can wake up the system
    from sleep states.  Moreover, it then uses full information
    returned by _PRW, including the GPE information, so it can take care
    of disabling the GPEs if necessary.
    
    Remove the code that walks the namespace and executes _PRW from
    ACPICA and modify comments to reflect that change.  Make
    acpi_bus_set_run_wake_flags() disable GPEs for wakeup devices
    so that they don't cause spurious wakeup events to be signaled.
    This not only reduces the complexity of the ACPICA initialization
    code, but in some cases it should reduce the kernel boot time as
    well.
    
    Unfortunately, for this purpose we need a new ACPICA function,
    acpi_gpe_can_wake(), to be called by the host OS in order to disable
    the GPEs that can wake up the system and were previously enabled by
    acpi_ev_initialize_gpe_block() or acpi_ev_update_gpes() (such a GPE
    should be disabled only once, because the initialization code enables
    it only once, but it may be pointed to by _PRW for multiple devices
    and that's why the additional function is necessary).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 449ada016d81..b23825ecfa37 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -740,6 +740,8 @@ acpi_bus_extract_wakeup_device_power_package(struct acpi_device *device,
 		device->wakeup.resources.handles[i] = element->reference.handle;
 	}
 
+	acpi_gpe_can_wake(device->wakeup.gpe_device, device->wakeup.gpe_number);
+
 	return AE_OK;
 }
 

commit e8e18c956152ec9c26c94c6401c174691a8f04e7
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 8 00:42:51 2010 +0200

    ACPI: Fix bogus GPE test in acpi_bus_set_run_wake_flags()
    
    When we check if a GPE can be used for runtime signaling, we only
    search the FADT GPE blocks, which is incorrect, becuase the GPE
    may be located elsewhere.  We really should be using the GPE device
    information previously returned by _PRW here, so make that happen.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 7f2e051ed4f1..449ada016d81 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -764,8 +764,9 @@ static void acpi_bus_set_run_wake_flags(struct acpi_device *device)
 		return;
 	}
 
-	status = acpi_get_gpe_status(NULL, device->wakeup.gpe_number,
-					&event_status);
+	status = acpi_get_gpe_status(device->wakeup.gpe_device,
+					device->wakeup.gpe_number,
+						&event_status);
 	if (status == AE_OK)
 		device->wakeup.flags.run_wake =
 				!!(event_status & ACPI_EVENT_FLAG_HANDLE);

commit 0f849d2cc6863c7874889ea60a871fb71399dd3f
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Tue Apr 6 14:52:37 2010 +0800

    ACPICA: Minimize the differences between linux GPE code and ACPICA code base
    
    We have ported Rafael's major GPE changes
    (ACPI: Use GPE reference counting to support shared GPEs) into ACPICA code base.
    But the port and Rafael's original patch have some differences, so we made
    below patch to make linux GPE code consistent with ACPICA code base.
    
    Most changes are about comments and coding styles.
    Other noticeable changes are based on:
    
    Rafael: Reduce code duplication related to GPE lookup
    https://patchwork.kernel.org/patch/86237/
    
    Rafael: Always use the same lock for GPE locking
    https://patchwork.kernel.org/patch/90471/
    
    A new field gpe_count in struct acpi_gpe_block_info to record the number
    of individual GPEs in block.
    
    Rename acpi_ev_save_method_info to acpi_ev_match_gpe_method.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Robert Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 0338f513a010..7f2e051ed4f1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -765,7 +765,7 @@ static void acpi_bus_set_run_wake_flags(struct acpi_device *device)
 	}
 
 	status = acpi_get_gpe_status(NULL, device->wakeup.gpe_number,
-					ACPI_NOT_ISR, &event_status);
+					&event_status);
 	if (status == AE_OK)
 		device->wakeup.flags.run_wake =
 				!!(event_status & ACPI_EVENT_FLAG_HANDLE);

commit c25f7cf2032aaac9bd50d6eee982719878538082
Merge: f79e1cec8c8a dadf28a10c3e ac7729da880e 3162b6f0c5e1 bc73675b99fd b7b30de53aef bf02bd2590eb 1638bca898e5 0f9b75ef3722 17c452f99cf5
Author: Len Brown <len.brown@intel.com>
Date:   Tue Apr 6 17:06:22 2010 -0400

    Merge branches 'battery', 'bugzilla-14667', 'bugzilla-15096', 'bugzilla-15480', 'bugzilla-15521', 'bugzilla-15605', 'gpe-reference-counters', 'misc', 'pxm-fix' and 'video-random-key' into release

commit b7b30de53aef6ce773d34837ba7d8422bd3baeec
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Mar 24 10:44:33 2010 -0600

    ACPI: use _HID when supplied by root-level devices
    
    Previously, we assumed the only Device object immediately below the root
    was the \_SB Scope (which the ACPI CA treats as a Device), so we forced
    the HID of all such objects to ACPI_BUS_HID ("LNXSYBUS").
    
    However, there are DSDTs that supply root-level Device objects with _HIDs.
    This patch makes us pay attention to those _HIDs and only add the synthetic
    ACPI_BUS_HID for root-level objects that do not supply their own _HID.
    
    For example, this DSDT: https://bugzilla.kernel.org/show_bug.cgi?id=15605
    contains:
    
        Scope (_SB) {
            ...
        }
        Device (AMW0) {
            Name (_HID, EisaId ("PNP0C14"))
            ...
        }
    
    and we should use "PNP0C14" for the AMW0 device, not "LNXSYBUS".
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Tested-by: Yong Wang <yong.y.wang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 189cbc2585fa..95c90ff5b9a3 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1080,12 +1080,6 @@ static void acpi_device_set_id(struct acpi_device *device)
 		if (ACPI_IS_ROOT_DEVICE(device)) {
 			acpi_add_id(device, ACPI_SYSTEM_HID);
 			break;
-		} else if (ACPI_IS_ROOT_DEVICE(device->parent)) {
-			/* \_SB_, the only root-level namespace device */
-			acpi_add_id(device, ACPI_BUS_HID);
-			strcpy(device->pnp.device_name, ACPI_BUS_DEVICE_NAME);
-			strcpy(device->pnp.device_class, ACPI_BUS_CLASS);
-			break;
 		}
 
 		status = acpi_get_object_info(device->handle, &info);
@@ -1120,6 +1114,12 @@ static void acpi_device_set_id(struct acpi_device *device)
 			acpi_add_id(device, ACPI_DOCK_HID);
 		else if (!acpi_ibm_smbus_match(device))
 			acpi_add_id(device, ACPI_SMBUS_IBM_HID);
+		else if (!acpi_device_hid(device) &&
+			 ACPI_IS_ROOT_DEVICE(device->parent)) {
+			acpi_add_id(device, ACPI_BUS_HID); /* \_SB, LNXSYBUS */
+			strcpy(device->pnp.device_name, ACPI_BUS_DEVICE_NAME);
+			strcpy(device->pnp.device_class, ACPI_BUS_CLASS);
+		}
 
 		break;
 	case ACPI_BUS_TYPE_POWER:

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 189cbc2585fa..0261b116d051 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -4,6 +4,7 @@
 
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/slab.h>
 #include <linux/kernel.h>
 #include <linux/acpi.h>
 #include <linux/signal.h>

commit 222e82ac9ffbd3b80ab1b0b1d2c8c60ddb47d69d
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Wed Mar 24 14:38:37 2010 +0100

    acpi: Support IBM SMBus CMI devices
    
    On some old IBM workstations and desktop computers, the BIOS presents in the
    DSDT an SMBus object that is missing the HID identifier that the i2c-scmi
    driver looks for.  Modify the ACPI device scan code to insert the missing HID
    if it finds an IBM system with such an object.
    
    Affected machines: IntelliStation Z20/Z30.  Note that the i2c-i801 driver no
    longer works on these machines because of ACPI resource conflicts.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index fb7fc24fe727..189cbc2585fa 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -8,6 +8,7 @@
 #include <linux/acpi.h>
 #include <linux/signal.h>
 #include <linux/kthread.h>
+#include <linux/dmi.h>
 
 #include <acpi/acpi_drivers.h>
 
@@ -1032,6 +1033,41 @@ static void acpi_add_id(struct acpi_device *device, const char *dev_id)
 	list_add_tail(&id->list, &device->pnp.ids);
 }
 
+/*
+ * Old IBM workstations have a DSDT bug wherein the SMBus object
+ * lacks the SMBUS01 HID and the methods do not have the necessary "_"
+ * prefix.  Work around this.
+ */
+static int acpi_ibm_smbus_match(struct acpi_device *device)
+{
+	acpi_handle h_dummy;
+	struct acpi_buffer path = {ACPI_ALLOCATE_BUFFER, NULL};
+	int result;
+
+	if (!dmi_name_in_vendors("IBM"))
+		return -ENODEV;
+
+	/* Look for SMBS object */
+	result = acpi_get_name(device->handle, ACPI_SINGLE_NAME, &path);
+	if (result)
+		return result;
+
+	if (strcmp("SMBS", path.pointer)) {
+		result = -ENODEV;
+		goto out;
+	}
+
+	/* Does it have the necessary (but misnamed) methods? */
+	result = -ENODEV;
+	if (ACPI_SUCCESS(acpi_get_handle(device->handle, "SBI", &h_dummy)) &&
+	    ACPI_SUCCESS(acpi_get_handle(device->handle, "SBR", &h_dummy)) &&
+	    ACPI_SUCCESS(acpi_get_handle(device->handle, "SBW", &h_dummy)))
+		result = 0;
+out:
+	kfree(path.pointer);
+	return result;
+}
+
 static void acpi_device_set_id(struct acpi_device *device)
 {
 	acpi_status status;
@@ -1082,6 +1118,8 @@ static void acpi_device_set_id(struct acpi_device *device)
 			acpi_add_id(device, ACPI_BAY_HID);
 		else if (ACPI_SUCCESS(acpi_dock_match(device)))
 			acpi_add_id(device, ACPI_DOCK_HID);
+		else if (!acpi_ibm_smbus_match(device))
+			acpi_add_id(device, ACPI_SMBUS_IBM_HID);
 
 		break;
 	case ACPI_BUS_TYPE_POWER:

commit b67ea76172d4b1922c4b3c46c8ea8e9fec1ff38c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 17 23:44:09 2010 +0100

    PCI / ACPI / PM: Platform support for PCI PME wake-up
    
    Although the majority of PCI devices can generate PMEs that in
    principle may be used to wake up devices suspended at run time,
    platform support is generally necessary to convert PMEs into wake-up
    events that can be delivered to the kernel.  If ACPI is used for this
    purpose, PME signals generated by a PCI device will trigger the ACPI
    GPE associated with the device to generate an ACPI wake-up event that
    we can set up a handler for, provided that everything is configured
    correctly.
    
    Unfortunately, the subset of PCI devices that have GPEs associated
    with them is quite limited.  The devices without dedicated GPEs have
    to rely on the GPEs associated with other devices (in the majority of
    cases their upstream bridges and, possibly, the root bridge) to
    generate ACPI wake-up events in response to PME signals from them.
    
    Add ACPI platform support for PCI PME wake-up:
    o Add a framework making is possible to use ACPI system notify
      handlers for run-time PM.
    o Add new PCI platform callback ->run_wake() to struct
      pci_platform_pm_ops allowing us to enable/disable the platform to
      generate wake-up events for given device.  Implemet this callback
      for the ACPI platform.
    o Define ACPI wake-up handlers for PCI devices and PCI root buses and
      make the PCI-ACPI binding code register wake-up notifiers for all
      PCI devices present in the ACPI tables.
    o Add function pci_dev_run_wake() which can be used by PCI drivers to
      check if given device is capable of generating wake-up events at
      run time.
    
    Developed in cooperation with Matthew Garrett <mjg@redhat.com>.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 7491a52ad97a..fb7fc24fe727 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -753,6 +753,7 @@ static void acpi_bus_set_run_wake_flags(struct acpi_device *device)
 	acpi_event_status event_status;
 
 	device->wakeup.run_wake_count = 0;
+	device->wakeup.flags.notifier_present = 0;
 
 	/* Power button, Lid switch always enable wakeup */
 	if (!acpi_match_device_ids(device, button_device_ids)) {

commit f517709d65beed95f52f021b43e3035b52ef791a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 17 23:41:49 2010 +0100

    ACPI / PM: Add more run-time wake-up fields
    
    Use the run_wake flag to mark all devices for which run-time wake-up
    events may be generated by the platform.  Introduce a new wake-up
    flag, always_enabled, for marking devices that should be permanently
    enabled to generate run-time events.  Also, introduce a reference
    counter for run-wake devices and a function that will initialize all
    of the run-time wake-up fields for given device.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 3e009674f333..7491a52ad97a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -741,19 +741,39 @@ acpi_bus_extract_wakeup_device_power_package(struct acpi_device *device,
 	return AE_OK;
 }
 
-static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
+static void acpi_bus_set_run_wake_flags(struct acpi_device *device)
 {
-	acpi_status status = 0;
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
-	union acpi_object *package = NULL;
-	int psw_error;
-
 	struct acpi_device_id button_device_ids[] = {
 		{"PNP0C0D", 0},
 		{"PNP0C0C", 0},
 		{"PNP0C0E", 0},
 		{"", 0},
 	};
+	acpi_status status;
+	acpi_event_status event_status;
+
+	device->wakeup.run_wake_count = 0;
+
+	/* Power button, Lid switch always enable wakeup */
+	if (!acpi_match_device_ids(device, button_device_ids)) {
+		device->wakeup.flags.run_wake = 1;
+		device->wakeup.flags.always_enabled = 1;
+		return;
+	}
+
+	status = acpi_get_gpe_status(NULL, device->wakeup.gpe_number,
+					ACPI_NOT_ISR, &event_status);
+	if (status == AE_OK)
+		device->wakeup.flags.run_wake =
+				!!(event_status & ACPI_EVENT_FLAG_HANDLE);
+}
+
+static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
+{
+	acpi_status status = 0;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *package = NULL;
+	int psw_error;
 
 	/* _PRW */
 	status = acpi_evaluate_object(device->handle, "_PRW", NULL, &buffer);
@@ -773,6 +793,7 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 
 	device->wakeup.flags.valid = 1;
 	device->wakeup.prepare_count = 0;
+	acpi_bus_set_run_wake_flags(device);
 	/* Call _PSW/_DSW object to disable its ability to wake the sleeping
 	 * system for the ACPI device with the _PRW object.
 	 * The _PSW object is depreciated in ACPI 3.0 and is replaced by _DSW.
@@ -784,10 +805,6 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				"error in _DSW or _PSW evaluation\n"));
 
-	/* Power button, Lid switch always enable wakeup */
-	if (!acpi_match_device_ids(device, button_device_ids))
-		device->wakeup.flags.run_wake = 1;
-
 end:
 	if (ACPI_FAILURE(status))
 		device->flags.wake_capable = 0;

commit 7779688fc3d1ceddad84846a7b0affbe8e78ec6e
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Jan 29 17:48:52 2010 +0100

    ACPI: acpi_bus_{scan,bus,add}: return -ENODEV if no device was found
    
    Callers (acpi_memhotplug.c, dock.c and others) check for the return
    value of acpi_bus_add() and assume a valid device was returned in
    case zero was returned.
    
    Thus return -ENODEV if no device was found in acpi_bus_scan and
    propagate this through acpi_bus_add and acpi_bus_start.
    
    Also remove a confusing comment in acpiphp_glue.c, acpi_bus_scan
    will and cannot invoke if acpi_bus_add returns no valid device.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8044583f3034..3e009674f333 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1336,9 +1336,25 @@ static int acpi_bus_scan(acpi_handle handle, struct acpi_bus_ops *ops,
 
 	if (child)
 		*child = device;
-	return 0;
+
+	if (device)
+		return 0;
+	else
+		return -ENODEV;
 }
 
+/*
+ * acpi_bus_add and acpi_bus_start
+ *
+ * scan a given ACPI tree and (probably recently hot-plugged)
+ * create and add or starts found devices.
+ *
+ * If no devices were found -ENODEV is returned which does not
+ * mean that this is a real error, there just have been no suitable
+ * ACPI objects in the table trunk from which the kernel could create
+ * a device and add/start an appropriate driver.
+ */
+
 int
 acpi_bus_add(struct acpi_device **child,
 	     struct acpi_device *parent, acpi_handle handle, int type)
@@ -1348,8 +1364,7 @@ acpi_bus_add(struct acpi_device **child,
 	memset(&ops, 0, sizeof(ops));
 	ops.acpi_op_add = 1;
 
-	acpi_bus_scan(handle, &ops, child);
-	return 0;
+	return acpi_bus_scan(handle, &ops, child);
 }
 EXPORT_SYMBOL(acpi_bus_add);
 
@@ -1363,8 +1378,7 @@ int acpi_bus_start(struct acpi_device *device)
 	memset(&ops, 0, sizeof(ops));
 	ops.acpi_op_start = 1;
 
-	acpi_bus_scan(device->handle, &ops, NULL);
-	return 0;
+	return acpi_bus_scan(device->handle, &ops, NULL);
 }
 EXPORT_SYMBOL(acpi_bus_start);
 

commit d2f6650a950dadd20667a04a9dc785f240d43695
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Jan 29 17:48:51 2010 +0100

    ACPI: Add NULL pointer check in acpi_bus_start
    
    If acpi_bus_add does not return a device and it's passed
    to acpi_bus_start, bad things will happen:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000008
    IP: [<ffffffff8128402d>] acpi_bus_start+0x14/0x24
    ...
    [<ffffffffa008977a>] acpiphp_bus_add+0xba/0x130 [acpiphp]
    [<ffffffffa008aa72>] enable_device+0x132/0x2ff [acpiphp]
    [<ffffffffa0089b68>] acpiphp_enable_slot+0xb8/0x130 [acpiphp]
    [<ffffffffa0089df7>] handle_hotplug_event_func+0x87/0x190 [acpiphp]
    
    Next patch would make this NULL pointer check obsolete, but
    better having one more than one missing...
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    CC: stable@kernel.org
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ff9f6226085d..8044583f3034 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1357,6 +1357,9 @@ int acpi_bus_start(struct acpi_device *device)
 {
 	struct acpi_bus_ops ops;
 
+	if (!device)
+		return -EINVAL;
+
 	memset(&ops, 0, sizeof(ops));
 	ops.acpi_op_start = 1;
 

commit 2263576cfc6e8f6ab038126c3254404b9fcb1c33
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Fri Nov 13 10:06:08 2009 +0800

    ACPICA: Add post-order callback to acpi_walk_namespace
    
    The existing interface only has a pre-order callback. This change
    adds an additional parameter for a post-order callback which will
    be more useful for bus scans. ACPICA BZ 779.
    
    Also update the external calls to acpi_walk_namespace.
    
    http://www.acpica.org/bugzilla/show_bug.cgi?id=779
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 14a7481c97d7..ff9f6226085d 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1332,7 +1332,7 @@ static int acpi_bus_scan(acpi_handle handle, struct acpi_bus_ops *ops,
 	status = acpi_bus_check_add(handle, 0, ops, &device);
 	if (ACPI_SUCCESS(status))
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
-				    acpi_bus_check_add, ops, &device);
+				    acpi_bus_check_add, NULL, ops, &device);
 
 	if (child)
 		*child = device;

commit a83893ae903ba908b1139fd8455ac93c4e5a2dff
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Oct 2 11:03:12 2009 -0400

    ACPI: fix bus scanning memory leaks
    
    Free an acpi_get_object_info() buffer when we're finished.  Skip the
    acpi_get_name() altogether -- it was only used for a printk that was
    really just for debug anyway.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=14271
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Reported-and-tested-by: Zdenek Kabelac <zdenek.kabelac@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 468921bed22f..14a7481c97d7 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1052,6 +1052,8 @@ static void acpi_device_set_id(struct acpi_device *device)
 			device->flags.bus_address = 1;
 		}
 
+		kfree(info);
+
 		/*
 		 * Some devices don't reliably have _HIDs & _CIDs, so add
 		 * synthetic HIDs to make sure drivers can find them.
@@ -1325,13 +1327,8 @@ static int acpi_bus_scan(acpi_handle handle, struct acpi_bus_ops *ops,
 			 struct acpi_device **child)
 {
 	acpi_status status;
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	void *device = NULL;
 
-	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
-	printk(KERN_INFO PREFIX "Enumerating devices from [%s]\n",
-	       (char *) buffer.pointer);
-
 	status = acpi_bus_check_add(handle, 0, ops, &device);
 	if (ACPI_SUCCESS(status))
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,

commit 57f3674f5e9c7b1102ae62fc2920d2fa09fce1ea
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 13:35:40 2009 -0600

    ACPI: simplify building device HID/CID list
    
    Minor code cleanup, no functional change.  Instead of remembering
    what HIDs & CIDs to add later, just add them immediately.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index da11b5379dc8..468921bed22f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1016,21 +1016,19 @@ static void acpi_add_id(struct acpi_device *device, const char *dev_id)
 
 static void acpi_device_set_id(struct acpi_device *device)
 {
-	struct acpi_device_info *info = NULL;
-	char *hid = NULL;
-	struct acpica_device_id_list *cid_list = NULL;
-	char *cid_add = NULL;
 	acpi_status status;
+	struct acpi_device_info *info;
+	struct acpica_device_id_list *cid_list;
 	int i;
 
 	switch (device->device_type) {
 	case ACPI_BUS_TYPE_DEVICE:
 		if (ACPI_IS_ROOT_DEVICE(device)) {
-			hid = ACPI_SYSTEM_HID;
+			acpi_add_id(device, ACPI_SYSTEM_HID);
 			break;
 		} else if (ACPI_IS_ROOT_DEVICE(device->parent)) {
 			/* \_SB_, the only root-level namespace device */
-			hid = ACPI_BUS_HID;
+			acpi_add_id(device, ACPI_BUS_HID);
 			strcpy(device->pnp.device_name, ACPI_BUS_DEVICE_NAME);
 			strcpy(device->pnp.device_class, ACPI_BUS_CLASS);
 			break;
@@ -1043,41 +1041,43 @@ static void acpi_device_set_id(struct acpi_device *device)
 		}
 
 		if (info->valid & ACPI_VALID_HID)
-			hid = info->hardware_id.string;
-		if (info->valid & ACPI_VALID_CID)
+			acpi_add_id(device, info->hardware_id.string);
+		if (info->valid & ACPI_VALID_CID) {
 			cid_list = &info->compatible_id_list;
+			for (i = 0; i < cid_list->count; i++)
+				acpi_add_id(device, cid_list->ids[i].string);
+		}
 		if (info->valid & ACPI_VALID_ADR) {
 			device->pnp.bus_address = info->address;
 			device->flags.bus_address = 1;
 		}
 
-		/* If we have a video/bay/dock device, add our selfdefined
-		   HID to the CID list. Like that the video/bay/dock drivers
-		   will get autoloaded and the device might still match
-		   against another driver.
-		*/
+		/*
+		 * Some devices don't reliably have _HIDs & _CIDs, so add
+		 * synthetic HIDs to make sure drivers can find them.
+		 */
 		if (acpi_is_video_device(device))
-			cid_add = ACPI_VIDEO_HID;
+			acpi_add_id(device, ACPI_VIDEO_HID);
 		else if (ACPI_SUCCESS(acpi_bay_match(device)))
-			cid_add = ACPI_BAY_HID;
+			acpi_add_id(device, ACPI_BAY_HID);
 		else if (ACPI_SUCCESS(acpi_dock_match(device)))
-			cid_add = ACPI_DOCK_HID;
+			acpi_add_id(device, ACPI_DOCK_HID);
 
 		break;
 	case ACPI_BUS_TYPE_POWER:
-		hid = ACPI_POWER_HID;
+		acpi_add_id(device, ACPI_POWER_HID);
 		break;
 	case ACPI_BUS_TYPE_PROCESSOR:
-		hid = ACPI_PROCESSOR_OBJECT_HID;
+		acpi_add_id(device, ACPI_PROCESSOR_OBJECT_HID);
 		break;
 	case ACPI_BUS_TYPE_THERMAL:
-		hid = ACPI_THERMAL_HID;
+		acpi_add_id(device, ACPI_THERMAL_HID);
 		break;
 	case ACPI_BUS_TYPE_POWER_BUTTON:
-		hid = ACPI_BUTTON_HID_POWERF;
+		acpi_add_id(device, ACPI_BUTTON_HID_POWERF);
 		break;
 	case ACPI_BUS_TYPE_SLEEP_BUTTON:
-		hid = ACPI_BUTTON_HID_SLEEPF;
+		acpi_add_id(device, ACPI_BUTTON_HID_SLEEPF);
 		break;
 	}
 
@@ -1088,18 +1088,8 @@ static void acpi_device_set_id(struct acpi_device *device)
 	 * This generic ID isn't useful for driver binding, but it provides
 	 * the useful property that "every acpi_device has an ID."
 	 */
-	if (!hid && !cid_list && !cid_add)
-		hid = "device";
-
-	if (hid)
-		acpi_add_id(device, hid);
-	if (cid_list)
-		for (i = 0; i < cid_list->count; i++)
-			acpi_add_id(device, cid_list->ids[i].string);
-	if (cid_add)
-		acpi_add_id(device, cid_add);
-
-	kfree(info);
+	if (list_empty(&device->pnp.ids))
+		acpi_add_id(device, "device");
 }
 
 static int acpi_device_set_context(struct acpi_device *device)

commit 6622d8cee73a26bce958484065c8f0e704911a62
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 13:35:35 2009 -0600

    ACPI: remove acpi_device_uid() and related stuff
    
    Nobody uses acpi_device_uid(), so this patch removes it.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 7e031b90c09c..da11b5379dc8 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1018,7 +1018,6 @@ static void acpi_device_set_id(struct acpi_device *device)
 {
 	struct acpi_device_info *info = NULL;
 	char *hid = NULL;
-	char *uid = NULL;
 	struct acpica_device_id_list *cid_list = NULL;
 	char *cid_add = NULL;
 	acpi_status status;
@@ -1045,8 +1044,6 @@ static void acpi_device_set_id(struct acpi_device *device)
 
 		if (info->valid & ACPI_VALID_HID)
 			hid = info->hardware_id.string;
-		if (info->valid & ACPI_VALID_UID)
-			uid = info->unique_id.string;
 		if (info->valid & ACPI_VALID_CID)
 			cid_list = &info->compatible_id_list;
 		if (info->valid & ACPI_VALID_ADR) {
@@ -1096,16 +1093,6 @@ static void acpi_device_set_id(struct acpi_device *device)
 
 	if (hid)
 		acpi_add_id(device, hid);
-	if (uid) {
-		device->pnp.unique_id = ACPI_ALLOCATE_ZEROED(strlen (uid) + 1);
-		if (device->pnp.unique_id) {
-			strcpy(device->pnp.unique_id, uid);
-			device->flags.unique_id = 1;
-		}
-	}
-	if (!device->flags.unique_id)
-		device->pnp.unique_id = "";
-
 	if (cid_list)
 		for (i = 0; i < cid_list->count; i++)
 			acpi_add_id(device, cid_list->ids[i].string);
@@ -1200,11 +1187,6 @@ static int acpi_add_single_object(struct acpi_device **child,
 	 * -----------------
 	 * TBD: Synch with Core's enumeration/initialization process.
 	 */
-
-	/*
-	 * Hardware ID, Unique ID, & Bus Address
-	 * -------------------------------------
-	 */
 	acpi_device_set_id(device);
 
 	/*

commit 1131b938f0757350f569f8ad5bee737cd02b8e58
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 13:35:29 2009 -0600

    ACPI: remove acpi_device.flags.hardware_id
    
    Every acpi_device has at least one ID (if there's no _HID or _CID, we
    give it a synthetic or default ID).  So there's no longer a need to
    check whether an ID exists; we can just use it.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 395ae129aae0..7e031b90c09c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -47,9 +47,6 @@ static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
 	int count;
 	struct acpi_hardware_id *id;
 
-	if (!acpi_dev->flags.hardware_id)
-		return -ENODEV;
-
 	len = snprintf(modalias, size, "acpi:");
 	size -= len;
 
@@ -203,17 +200,13 @@ static int acpi_device_setup_files(struct acpi_device *dev)
 			goto end;
 	}
 
-	if (dev->flags.hardware_id) {
-		result = device_create_file(&dev->dev, &dev_attr_hid);
-		if (result)
-			goto end;
-	}
+	result = device_create_file(&dev->dev, &dev_attr_hid);
+	if (result)
+		goto end;
 
-	if (dev->flags.hardware_id) {
-		result = device_create_file(&dev->dev, &dev_attr_modalias);
-		if (result)
-			goto end;
-	}
+	result = device_create_file(&dev->dev, &dev_attr_modalias);
+	if (result)
+		goto end;
 
         /*
          * If device has _EJ0, 'eject' file is created that is used to trigger
@@ -239,11 +232,8 @@ static void acpi_device_remove_files(struct acpi_device *dev)
 	if (ACPI_SUCCESS(status))
 		device_remove_file(&dev->dev, &dev_attr_eject);
 
-	if (dev->flags.hardware_id)
-		device_remove_file(&dev->dev, &dev_attr_modalias);
-
-	if (dev->flags.hardware_id)
-		device_remove_file(&dev->dev, &dev_attr_hid);
+	device_remove_file(&dev->dev, &dev_attr_modalias);
+	device_remove_file(&dev->dev, &dev_attr_hid);
 	if (dev->handle)
 		device_remove_file(&dev->dev, &dev_attr_path);
 }
@@ -474,8 +464,9 @@ static int acpi_device_register(struct acpi_device *device)
 	 * If failed, create one and link it into acpi_bus_id_list
 	 */
 	list_for_each_entry(acpi_device_bus_id, &acpi_bus_id_list, node) {
-		if (!strcmp(acpi_device_bus_id->bus_id, device->flags.hardware_id ? acpi_device_hid(device) : "device")) {
-			acpi_device_bus_id->instance_no ++;
+		if (!strcmp(acpi_device_bus_id->bus_id,
+			    acpi_device_hid(device))) {
+			acpi_device_bus_id->instance_no++;
 			found = 1;
 			kfree(new_bus_id);
 			break;
@@ -483,7 +474,7 @@ static int acpi_device_register(struct acpi_device *device)
 	}
 	if (!found) {
 		acpi_device_bus_id = new_bus_id;
-		strcpy(acpi_device_bus_id->bus_id, device->flags.hardware_id ? acpi_device_hid(device) : "device");
+		strcpy(acpi_device_bus_id->bus_id, acpi_device_hid(device));
 		acpi_device_bus_id->instance_no = 0;
 		list_add_tail(&acpi_device_bus_id->node, &acpi_bus_id_list);
 	}
@@ -1103,10 +1094,8 @@ static void acpi_device_set_id(struct acpi_device *device)
 	if (!hid && !cid_list && !cid_add)
 		hid = "device";
 
-	if (hid) {
+	if (hid)
 		acpi_add_id(device, hid);
-		device->flags.hardware_id = 1;
-	}
 	if (uid) {
 		device->pnp.unique_id = ACPI_ALLOCATE_ZEROED(strlen (uid) + 1);
 		if (device->pnp.unique_id) {

commit b2972f87508a21db7584d11fdb5c97cb7101a788
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 13:35:24 2009 -0600

    ACPI: remove acpi_device.flags.compatible_ids
    
    We now keep a single list of IDs that includes both the _HID and any
    _CIDs.  We no longer need to keep track of whether the device has a _CID.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 2e8889f62666..395ae129aae0 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -47,7 +47,7 @@ static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
 	int count;
 	struct acpi_hardware_id *id;
 
-	if (!acpi_dev->flags.hardware_id && !acpi_dev->flags.compatible_ids)
+	if (!acpi_dev->flags.hardware_id)
 		return -ENODEV;
 
 	len = snprintf(modalias, size, "acpi:");
@@ -209,7 +209,7 @@ static int acpi_device_setup_files(struct acpi_device *dev)
 			goto end;
 	}
 
-	if (dev->flags.hardware_id || dev->flags.compatible_ids) {
+	if (dev->flags.hardware_id) {
 		result = device_create_file(&dev->dev, &dev_attr_modalias);
 		if (result)
 			goto end;
@@ -239,7 +239,7 @@ static void acpi_device_remove_files(struct acpi_device *dev)
 	if (ACPI_SUCCESS(status))
 		device_remove_file(&dev->dev, &dev_attr_eject);
 
-	if (dev->flags.hardware_id || dev->flags.compatible_ids)
+	if (dev->flags.hardware_id)
 		device_remove_file(&dev->dev, &dev_attr_modalias);
 
 	if (dev->flags.hardware_id)
@@ -876,11 +876,6 @@ static int acpi_bus_get_flags(struct acpi_device *device)
 	if (ACPI_SUCCESS(status))
 		device->flags.dynamic_status = 1;
 
-	/* Presence of _CID indicates 'compatible_ids' */
-	status = acpi_get_handle(device->handle, "_CID", &temp);
-	if (ACPI_SUCCESS(status))
-		device->flags.compatible_ids = 1;
-
 	/* Presence of _RMV indicates 'removable' */
 	status = acpi_get_handle(device->handle, "_RMV", &temp);
 	if (ACPI_SUCCESS(status))
@@ -1125,10 +1120,8 @@ static void acpi_device_set_id(struct acpi_device *device)
 	if (cid_list)
 		for (i = 0; i < cid_list->count; i++)
 			acpi_add_id(device, cid_list->ids[i].string);
-	if (cid_add) {
+	if (cid_add)
 		acpi_add_id(device, cid_add);
-		device->flags.compatible_ids = 1;
-	}
 
 	kfree(info);
 }

commit 7f47fa6c2ff15f5e59cdbb350f86faef6829294a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 13:35:19 2009 -0600

    ACPI: maintain a single list of _HID and _CID IDs
    
    There's no need to treat _HID and _CID differently.  Keeping them in
    a single list makes code that uses the IDs a little simpler because it
    can just traverse the list rather than checking "do we have a HID?",
    "do we have any CIDs?"
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Reviewed-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 53b96e7a64ab..2e8889f62666 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -45,6 +45,7 @@ static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
 {
 	int len;
 	int count;
+	struct acpi_hardware_id *id;
 
 	if (!acpi_dev->flags.hardware_id && !acpi_dev->flags.compatible_ids)
 		return -ENODEV;
@@ -52,33 +53,14 @@ static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
 	len = snprintf(modalias, size, "acpi:");
 	size -= len;
 
-	if (acpi_dev->flags.hardware_id) {
-		count = snprintf(&modalias[len], size, "%s:",
-				 acpi_dev->pnp.hardware_id);
+	list_for_each_entry(id, &acpi_dev->pnp.ids, list) {
+		count = snprintf(&modalias[len], size, "%s:", id->id);
 		if (count < 0 || count >= size)
 			return -EINVAL;
 		len += count;
 		size -= count;
 	}
 
-	if (acpi_dev->flags.compatible_ids) {
-		struct acpica_device_id_list *cid_list;
-		int i;
-
-		cid_list = acpi_dev->pnp.cid_list;
-		for (i = 0; i < cid_list->count; i++) {
-			count = snprintf(&modalias[len], size, "%s:",
-					 cid_list->ids[i].string);
-			if (count < 0 || count >= size) {
-				printk(KERN_ERR PREFIX "%s cid[%i] exceeds event buffer size",
-				       acpi_dev->pnp.device_name, i);
-				break;
-			}
-			len += count;
-			size -= count;
-		}
-	}
-
 	modalias[len] = '\0';
 	return len;
 }
@@ -273,6 +255,7 @@ int acpi_match_device_ids(struct acpi_device *device,
 			  const struct acpi_device_id *ids)
 {
 	const struct acpi_device_id *id;
+	struct acpi_hardware_id *hwid;
 
 	/*
 	 * If the device is not present, it is unnecessary to load device
@@ -281,40 +264,30 @@ int acpi_match_device_ids(struct acpi_device *device,
 	if (!device->status.present)
 		return -ENODEV;
 
-	if (device->flags.hardware_id) {
-		for (id = ids; id->id[0]; id++) {
-			if (!strcmp((char*)id->id, device->pnp.hardware_id))
+	for (id = ids; id->id[0]; id++)
+		list_for_each_entry(hwid, &device->pnp.ids, list)
+			if (!strcmp((char *) id->id, hwid->id))
 				return 0;
-		}
-	}
-
-	if (device->flags.compatible_ids) {
-		struct acpica_device_id_list *cid_list = device->pnp.cid_list;
-		int i;
-
-		for (id = ids; id->id[0]; id++) {
-			/* compare multiple _CID entries against driver ids */
-			for (i = 0; i < cid_list->count; i++) {
-				if (!strcmp((char*)id->id,
-					    cid_list->ids[i].string))
-					return 0;
-			}
-		}
-	}
 
 	return -ENOENT;
 }
 EXPORT_SYMBOL(acpi_match_device_ids);
 
+static void acpi_free_ids(struct acpi_device *device)
+{
+	struct acpi_hardware_id *id, *tmp;
+
+	list_for_each_entry_safe(id, tmp, &device->pnp.ids, list) {
+		kfree(id->id);
+		kfree(id);
+	}
+}
+
 static void acpi_device_release(struct device *dev)
 {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 
-	kfree(acpi_dev->pnp.cid_list);
-	if (acpi_dev->flags.hardware_id)
-		kfree(acpi_dev->pnp.hardware_id);
-	if (acpi_dev->flags.unique_id)
-		kfree(acpi_dev->pnp.unique_id);
+	acpi_free_ids(acpi_dev);
 	kfree(acpi_dev);
 }
 
@@ -1028,62 +1001,31 @@ static int acpi_dock_match(struct acpi_device *device)
 	return acpi_get_handle(device->handle, "_DCK", &tmp);
 }
 
-static struct acpica_device_id_list*
-acpi_add_cid(
-	struct acpi_device_info         *info,
-	struct acpica_device_id         *new_cid)
+char *acpi_device_hid(struct acpi_device *device)
 {
-	struct acpica_device_id_list    *cid;
-	char                            *next_id_string;
-	acpi_size                       cid_length;
-	acpi_size                       new_cid_length;
-	u32                             i;
-
-
-	/* Allocate new CID list with room for the new CID */
-
-	if (!new_cid)
-		new_cid_length = info->compatible_id_list.list_size;
-	else if (info->compatible_id_list.list_size)
-		new_cid_length = info->compatible_id_list.list_size +
-			new_cid->length + sizeof(struct acpica_device_id);
-	else
-		new_cid_length = sizeof(struct acpica_device_id_list) + new_cid->length;
-
-	cid = ACPI_ALLOCATE_ZEROED(new_cid_length);
-	if (!cid) {
-		return NULL;
-	}
-
-	cid->list_size = new_cid_length;
-	cid->count = info->compatible_id_list.count;
-	if (new_cid)
-		cid->count++;
-	next_id_string = (char *) cid->ids + (cid->count * sizeof(struct acpica_device_id));
-
-	/* Copy all existing CIDs */
+	struct acpi_hardware_id *hid;
 
-	for (i = 0; i < info->compatible_id_list.count; i++) {
-		cid_length = info->compatible_id_list.ids[i].length;
-		cid->ids[i].string = next_id_string;
-		cid->ids[i].length = cid_length;
-
-		ACPI_MEMCPY(next_id_string, info->compatible_id_list.ids[i].string,
-			cid_length);
-
-		next_id_string += cid_length;
-	}
+	hid = list_first_entry(&device->pnp.ids, struct acpi_hardware_id, list);
+	return hid->id;
+}
+EXPORT_SYMBOL(acpi_device_hid);
 
-	/* Append the new CID */
+static void acpi_add_id(struct acpi_device *device, const char *dev_id)
+{
+	struct acpi_hardware_id *id;
 
-	if (new_cid) {
-		cid->ids[i].string = next_id_string;
-		cid->ids[i].length = new_cid->length;
+	id = kmalloc(sizeof(*id), GFP_KERNEL);
+	if (!id)
+		return;
 
-		ACPI_MEMCPY(next_id_string, new_cid->string, new_cid->length);
+	id->id = kmalloc(strlen(dev_id) + 1, GFP_KERNEL);
+	if (!id->id) {
+		kfree(id);
+		return;
 	}
 
-	return cid;
+	strcpy(id->id, dev_id);
+	list_add_tail(&id->list, &device->pnp.ids);
 }
 
 static void acpi_device_set_id(struct acpi_device *device)
@@ -1094,6 +1036,7 @@ static void acpi_device_set_id(struct acpi_device *device)
 	struct acpica_device_id_list *cid_list = NULL;
 	char *cid_add = NULL;
 	acpi_status status;
+	int i;
 
 	switch (device->device_type) {
 	case ACPI_BUS_TYPE_DEVICE:
@@ -1166,15 +1109,9 @@ static void acpi_device_set_id(struct acpi_device *device)
 		hid = "device";
 
 	if (hid) {
-		device->pnp.hardware_id = ACPI_ALLOCATE_ZEROED(strlen (hid) + 1);
-		if (device->pnp.hardware_id) {
-			strcpy(device->pnp.hardware_id, hid);
-			device->flags.hardware_id = 1;
-		}
+		acpi_add_id(device, hid);
+		device->flags.hardware_id = 1;
 	}
-	if (!device->flags.hardware_id)
-		device->pnp.hardware_id = "";
-
 	if (uid) {
 		device->pnp.unique_id = ACPI_ALLOCATE_ZEROED(strlen (uid) + 1);
 		if (device->pnp.unique_id) {
@@ -1185,24 +1122,12 @@ static void acpi_device_set_id(struct acpi_device *device)
 	if (!device->flags.unique_id)
 		device->pnp.unique_id = "";
 
-	if (cid_list || cid_add) {
-		struct acpica_device_id_list *list;
-
-		if (cid_add) {
-			struct acpica_device_id cid;
-			cid.length = strlen (cid_add) + 1;
-			cid.string = cid_add;
-
-			list = acpi_add_cid(info, &cid);
-		} else {
-			list = acpi_add_cid(info, NULL);
-		}
-
-		if (list) {
-			device->pnp.cid_list = list;
-			if (cid_add)
-				device->flags.compatible_ids = 1;
-		}
+	if (cid_list)
+		for (i = 0; i < cid_list->count; i++)
+			acpi_add_id(device, cid_list->ids[i].string);
+	if (cid_add) {
+		acpi_add_id(device, cid_add);
+		device->flags.compatible_ids = 1;
 	}
 
 	kfree(info);
@@ -1269,6 +1194,7 @@ static int acpi_add_single_object(struct acpi_device **child,
 		return -ENOMEM;
 	}
 
+	INIT_LIST_HEAD(&device->pnp.ids);
 	device->device_type = type;
 	device->handle = handle;
 	device->parent = acpi_bus_get_parent(handle);

commit b1fbfb2ae8f2f0e04219218da6f52f7313466899
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 13:35:14 2009 -0600

    ACPI: make sure every acpi_device has an ID
    
    This makes sure every acpi_device has at least one ID.  If we build an
    acpi_device for a namespace node with no _HID or _CID, we sometimes
    synthesize an ID like "LNXCPU" or "LNXVIDEO".  If we don't even have
    that, give it a default "device" ID.
    
    Note that this means things like:
        /sys/devices/LNXSYSTM:00/LNXSYBUS:00/HWP0001:00/HWP0002:04/device:00
    (a PCI slot SxFy device) will have "hid" and "modprobe" entries, where
    they didn't before.  These aren't very useful (a HID of "device" doesn't
    tell you what *kind* of device it is, so it doesn't help find a driver),
    but I don't think they're harmful.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 269c0aae4bed..53b96e7a64ab 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1155,6 +1155,16 @@ static void acpi_device_set_id(struct acpi_device *device)
 		break;
 	}
 
+	/*
+	 * We build acpi_devices for some objects that don't have _HID or _CID,
+	 * e.g., PCI bridges and slots.  Drivers can't bind to these objects,
+	 * but we do use them indirectly by traversing the acpi_device tree.
+	 * This generic ID isn't useful for driver binding, but it provides
+	 * the useful property that "every acpi_device has an ID."
+	 */
+	if (!hid && !cid_list && !cid_add)
+		hid = "device";
+
 	if (hid) {
 		device->pnp.hardware_id = ACPI_ALLOCATE_ZEROED(strlen (hid) + 1);
 		if (device->pnp.hardware_id) {

commit ea8d82fd316208bd0ffe6f64823d04bcb8c57158
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 13:35:09 2009 -0600

    ACPI: use acpi_device_hid() when possible
    
    Use acpi_device_hid() rather than accessing acpi_device.pnp.hardware_id
    directly.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e9227ea2cb2f..269c0aae4bed 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -185,7 +185,7 @@ static ssize_t
 acpi_device_hid_show(struct device *dev, struct device_attribute *attr, char *buf) {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 
-	return sprintf(buf, "%s\n", acpi_dev->pnp.hardware_id);
+	return sprintf(buf, "%s\n", acpi_device_hid(acpi_dev));
 }
 static DEVICE_ATTR(hid, 0444, acpi_device_hid_show, NULL);
 
@@ -501,7 +501,7 @@ static int acpi_device_register(struct acpi_device *device)
 	 * If failed, create one and link it into acpi_bus_id_list
 	 */
 	list_for_each_entry(acpi_device_bus_id, &acpi_bus_id_list, node) {
-		if(!strcmp(acpi_device_bus_id->bus_id, device->flags.hardware_id? device->pnp.hardware_id : "device")) {
+		if (!strcmp(acpi_device_bus_id->bus_id, device->flags.hardware_id ? acpi_device_hid(device) : "device")) {
 			acpi_device_bus_id->instance_no ++;
 			found = 1;
 			kfree(new_bus_id);
@@ -510,7 +510,7 @@ static int acpi_device_register(struct acpi_device *device)
 	}
 	if (!found) {
 		acpi_device_bus_id = new_bus_id;
-		strcpy(acpi_device_bus_id->bus_id, device->flags.hardware_id ? device->pnp.hardware_id : "device");
+		strcpy(acpi_device_bus_id->bus_id, device->flags.hardware_id ? acpi_device_hid(device) : "device");
 		acpi_device_bus_id->instance_no = 0;
 		list_add_tail(&acpi_device_bus_id->node, &acpi_bus_id_list);
 	}

commit 78b8e141f8458ba0b8ac53c45bc327112c53887e
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 13:35:04 2009 -0600

    ACPI: fix synthetic HID for \_SB_
    
    This makes \_SB_ show up as /sys/devices/LNXSYSTM:00/LNXSYBUS:00
    rather than "device:00".  This has been broken for a loooong time
    (at least since 2.6.13) because device->parent is an acpi_device
    pointer, not a handle.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 2c4cac576a7e..e9227ea2cb2f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1100,6 +1100,12 @@ static void acpi_device_set_id(struct acpi_device *device)
 		if (ACPI_IS_ROOT_DEVICE(device)) {
 			hid = ACPI_SYSTEM_HID;
 			break;
+		} else if (ACPI_IS_ROOT_DEVICE(device->parent)) {
+			/* \_SB_, the only root-level namespace device */
+			hid = ACPI_BUS_HID;
+			strcpy(device->pnp.device_name, ACPI_BUS_DEVICE_NAME);
+			strcpy(device->pnp.device_class, ACPI_BUS_CLASS);
+			break;
 		}
 
 		status = acpi_get_object_info(device->handle, &info);
@@ -1149,18 +1155,6 @@ static void acpi_device_set_id(struct acpi_device *device)
 		break;
 	}
 
-	/*
-	 * \_SB
-	 * ----
-	 * Fix for the system root bus device -- the only root-level device.
-	 */
-	if (((acpi_handle)device->parent == ACPI_ROOT_OBJECT) &&
-	     (device->device_type == ACPI_BUS_TYPE_DEVICE)) {
-		hid = ACPI_BUS_HID;
-		strcpy(device->pnp.device_name, ACPI_BUS_DEVICE_NAME);
-		strcpy(device->pnp.device_class, ACPI_BUS_CLASS);
-	}
-
 	if (hid) {
 		device->pnp.hardware_id = ACPI_ALLOCATE_ZEROED(strlen (hid) + 1);
 		if (device->pnp.hardware_id) {

commit e3b87f8a9d5a61f6367c66d1bb0a4e19d251194d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 19:30:11 2009 +0000

    ACPI: handle re-enumeration, when acpi_devices might already exist
    
    acpi_bus_scan() traverses the namespace to enumerate devices and uses
    acpi_add_single_object() to create acpi_devices.  When the platform
    notifies us of a hot-plug event, we need to traverse part of the namespace
    again to figure out what appeared or disappeared.  (We don't yet call
    acpi_bus_scan() during hot-plug, but I plan to do that in the future.)
    
    This patch makes acpi_add_single_object() notice when we already have
    an acpi_device, so we don't need to make a new one.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 954bd01f295a..2c4cac576a7e 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1400,10 +1400,10 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 				      void *context, void **return_value)
 {
 	struct acpi_bus_ops *ops = context;
-	struct acpi_device *device = NULL;
-	acpi_status status;
 	int type;
 	unsigned long long sta;
+	struct acpi_device *device;
+	acpi_status status;
 	int result;
 
 	result = acpi_bus_type_and_status(handle, &type, &sta);
@@ -1414,13 +1414,16 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 	    !(sta & ACPI_STA_DEVICE_FUNCTIONING))
 		return AE_CTRL_DEPTH;
 
-	if (ops->acpi_op_add)
-		status = acpi_add_single_object(&device, handle, type, sta,
-						ops);
-	else
-		status = acpi_bus_get_device(handle, &device);
+	/*
+	 * We may already have an acpi_device from a previous enumeration.  If
+	 * so, we needn't add it again, but we may still have to start it.
+	 */
+	device = NULL;
+	acpi_bus_get_device(handle, &device);
+	if (ops->acpi_op_add && !device)
+		acpi_add_single_object(&device, handle, type, sta, ops);
 
-	if (ACPI_FAILURE(status))
+	if (!device)
 		return AE_CTRL_DEPTH;
 
 	if (ops->acpi_op_start && !(ops->acpi_op_add)) {

commit 778cbc1d3abd434b6d882714630235e3711bb15b
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 19:30:06 2009 +0000

    ACPI: factor out device type and status checking
    
    This patch adds acpi_bus_type_and_status(), which determines the type
    of the object and whether we want to build an acpi_device for it.  If
    it is acpi_device-worthy, it returns the type and the device's current
    status.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ed2b5f9a9815..954bd01f295a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1252,6 +1252,7 @@ static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 
 static int acpi_add_single_object(struct acpi_device **child,
 				  acpi_handle handle, int type,
+				  unsigned long long sta,
 				  struct acpi_bus_ops *ops)
 {
 	int result;
@@ -1268,60 +1269,20 @@ static int acpi_add_single_object(struct acpi_device **child,
 	device->handle = handle;
 	device->parent = acpi_bus_get_parent(handle);
 	device->bus_ops = *ops; /* workround for not call .start */
+	STRUCT_TO_INT(device->status) = sta;
 
 	acpi_device_get_busid(device);
 
 	/*
 	 * Flags
 	 * -----
-	 * Get prior to calling acpi_bus_get_status() so we know whether
-	 * or not _STA is present.  Note that we only look for object
-	 * handles -- cannot evaluate objects until we know the device is
-	 * present and properly initialized.
+	 * Note that we only look for object handles -- cannot evaluate objects
+	 * until we know the device is present and properly initialized.
 	 */
 	result = acpi_bus_get_flags(device);
 	if (result)
 		goto end;
 
-	/*
-	 * Status
-	 * ------
-	 * See if the device is present.  We always assume that non-Device
-	 * and non-Processor objects (e.g. thermal zones, power resources,
-	 * etc.) are present, functioning, etc. (at least when parent object
-	 * is present).  Note that _STA has a different meaning for some
-	 * objects (e.g. power resources) so we need to be careful how we use
-	 * it.
-	 */
-	switch (type) {
-	case ACPI_BUS_TYPE_PROCESSOR:
-	case ACPI_BUS_TYPE_DEVICE:
-		result = acpi_bus_get_status(device);
-		if (ACPI_FAILURE(result)) {
-			result = -ENODEV;
-			goto end;
-		}
-		/*
-		 * When the device is neither present nor functional, the
-		 * device should not be added to Linux ACPI device tree.
-		 * When the status of the device is not present but functinal,
-		 * it should be added to Linux ACPI tree. For example : bay
-		 * device , dock device.
-		 * In such conditions it is unncessary to check whether it is
-		 * bay device or dock device.
-		 */
-		if (!device->status.present && !device->status.functional) {
-			result = -ENODEV;
-			goto end;
-		}
-		break;
-	default:
-		STRUCT_TO_INT(device->status) =
-		    ACPI_STA_DEVICE_PRESENT | ACPI_STA_DEVICE_ENABLED |
-		    ACPI_STA_DEVICE_UI      | ACPI_STA_DEVICE_FUNCTIONING;
-		break;
-	}
-
 	/*
 	 * Initialize Device
 	 * -----------------
@@ -1393,41 +1354,69 @@ static int acpi_add_single_object(struct acpi_device **child,
 	return result;
 }
 
-static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
-				      void *context, void **return_value)
+#define ACPI_STA_DEFAULT (ACPI_STA_DEVICE_PRESENT | ACPI_STA_DEVICE_ENABLED | \
+			  ACPI_STA_DEVICE_UI      | ACPI_STA_DEVICE_FUNCTIONING)
+
+static int acpi_bus_type_and_status(acpi_handle handle, int *type,
+				    unsigned long long *sta)
 {
-	acpi_status status = AE_OK;
-	struct acpi_device *device = NULL;
-	acpi_object_type type = 0;
-	struct acpi_bus_ops *ops = context;
+	acpi_status status;
+	acpi_object_type acpi_type;
 
-	status = acpi_get_type(handle, &type);
+	status = acpi_get_type(handle, &acpi_type);
 	if (ACPI_FAILURE(status))
-		return AE_OK;
+		return -ENODEV;
 
-	/*
-	 * We're only interested in objects that we consider 'devices'.
-	 */
-	switch (type) {
+	switch (acpi_type) {
 	case ACPI_TYPE_ANY:		/* for ACPI_ROOT_OBJECT */
 	case ACPI_TYPE_DEVICE:
-		type = ACPI_BUS_TYPE_DEVICE;
+		*type = ACPI_BUS_TYPE_DEVICE;
+		status = acpi_bus_get_status_handle(handle, sta);
+		if (ACPI_FAILURE(status))
+			return -ENODEV;
 		break;
 	case ACPI_TYPE_PROCESSOR:
-		type = ACPI_BUS_TYPE_PROCESSOR;
+		*type = ACPI_BUS_TYPE_PROCESSOR;
+		status = acpi_bus_get_status_handle(handle, sta);
+		if (ACPI_FAILURE(status))
+			return -ENODEV;
 		break;
 	case ACPI_TYPE_THERMAL:
-		type = ACPI_BUS_TYPE_THERMAL;
+		*type = ACPI_BUS_TYPE_THERMAL;
+		*sta = ACPI_STA_DEFAULT;
 		break;
 	case ACPI_TYPE_POWER:
-		type = ACPI_BUS_TYPE_POWER;
+		*type = ACPI_BUS_TYPE_POWER;
+		*sta = ACPI_STA_DEFAULT;
 		break;
 	default:
-		return AE_OK;
+		return -ENODEV;
 	}
 
+	return 0;
+}
+
+static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
+				      void *context, void **return_value)
+{
+	struct acpi_bus_ops *ops = context;
+	struct acpi_device *device = NULL;
+	acpi_status status;
+	int type;
+	unsigned long long sta;
+	int result;
+
+	result = acpi_bus_type_and_status(handle, &type, &sta);
+	if (result)
+		return AE_OK;
+
+	if (!(sta & ACPI_STA_DEVICE_PRESENT) &&
+	    !(sta & ACPI_STA_DEVICE_FUNCTIONING))
+		return AE_CTRL_DEPTH;
+
 	if (ops->acpi_op_add)
-		status = acpi_add_single_object(&device, handle, type, ops);
+		status = acpi_add_single_object(&device, handle, type, sta,
+						ops);
 	else
 		status = acpi_bus_get_device(handle, &device);
 
@@ -1440,22 +1429,6 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
 			return AE_CTRL_DEPTH;
 	}
 
-	/*
-	 * If the device is present, enabled, and functioning then
-	 * parse its scope (depth-first).  Note that we need to
-	 * represent absent devices to facilitate PnP notifications
-	 * -- but only the subtree head (not all of its children,
-	 * which will be enumerated when the parent is inserted).
-	 *
-	 * TBD: Need notifications and other detection mechanisms
-	 *      in place before we can fully implement this.
-	 *
-	 * When the device is not present but functional, it is also
-	 * necessary to scan the children of this device.
-	 */
-	if (!device->status.present && !device->status.functional)
-		return AE_CTRL_DEPTH;
-
 	if (!*return_value)
 		*return_value = device;
 	return AE_OK;
@@ -1579,12 +1552,14 @@ static int acpi_bus_scan_fixed(void)
 	if ((acpi_gbl_FADT.flags & ACPI_FADT_POWER_BUTTON) == 0) {
 		result = acpi_add_single_object(&device, NULL,
 						ACPI_BUS_TYPE_POWER_BUTTON,
+						ACPI_STA_DEFAULT,
 						&ops);
 	}
 
 	if ((acpi_gbl_FADT.flags & ACPI_FADT_SLEEP_BUTTON) == 0) {
 		result = acpi_add_single_object(&device, NULL,
 						ACPI_BUS_TYPE_SLEEP_BUTTON,
+						ACPI_STA_DEFAULT,
 						&ops);
 	}
 

commit 51a85faf2d4ffecd8384b3f501f9f7ee2b05ee53
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 19:29:56 2009 +0000

    ACPI: use acpi_walk_namespace() to enumerate devices
    
    acpi_bus_scan() currently walks the namespace manually.  This patch changes
    it to use acpi_walk_namespace() instead.
    
    Besides removing some complicated code, this means we take advantage of the
    namespace locking done by acpi_walk_namespace().  The locking isn't so
    important at boot-time, but I hope to eventually use this same path to
    handle hot-addition of devices, when it will be important.
    
    Note that acpi_walk_namespace() does not actually visit the starting node
    first, so we need to do that by hand first.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 0b5aaf059c9b..ed2b5f9a9815 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1393,123 +1393,92 @@ static int acpi_add_single_object(struct acpi_device **child,
 	return result;
 }
 
-static int acpi_bus_scan(acpi_handle handle, struct acpi_bus_ops *ops)
+static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl,
+				      void *context, void **return_value)
 {
 	acpi_status status = AE_OK;
-	struct acpi_device *parent = NULL;
-	struct acpi_device *child = NULL;
-	acpi_handle phandle = NULL;
-	acpi_handle chandle = NULL;
+	struct acpi_device *device = NULL;
 	acpi_object_type type = 0;
-	u32 level = 1;
-	int ret;
+	struct acpi_bus_ops *ops = context;
 
-	/*
-	 * We must have an acpi_device for the starting node already, and
-	 * we scan its children.
-	 */
-	phandle = handle;
-	ret = acpi_bus_get_device(phandle, &parent);
-	if (ret)
-		return ret;
+	status = acpi_get_type(handle, &type);
+	if (ACPI_FAILURE(status))
+		return AE_OK;
 
 	/*
-	 * Parse through the ACPI namespace, identify all 'devices', and
-	 * create a new 'struct acpi_device' for each.
+	 * We're only interested in objects that we consider 'devices'.
 	 */
-	while ((level > 0) && parent) {
+	switch (type) {
+	case ACPI_TYPE_ANY:		/* for ACPI_ROOT_OBJECT */
+	case ACPI_TYPE_DEVICE:
+		type = ACPI_BUS_TYPE_DEVICE;
+		break;
+	case ACPI_TYPE_PROCESSOR:
+		type = ACPI_BUS_TYPE_PROCESSOR;
+		break;
+	case ACPI_TYPE_THERMAL:
+		type = ACPI_BUS_TYPE_THERMAL;
+		break;
+	case ACPI_TYPE_POWER:
+		type = ACPI_BUS_TYPE_POWER;
+		break;
+	default:
+		return AE_OK;
+	}
 
-		status = acpi_get_next_object(ACPI_TYPE_ANY, phandle,
-					      chandle, &chandle);
+	if (ops->acpi_op_add)
+		status = acpi_add_single_object(&device, handle, type, ops);
+	else
+		status = acpi_bus_get_device(handle, &device);
 
-		/*
-		 * If this scope is exhausted then move our way back up.
-		 */
-		if (ACPI_FAILURE(status)) {
-			level--;
-			chandle = phandle;
-			acpi_get_parent(phandle, &phandle);
-			if (parent->parent)
-				parent = parent->parent;
-			continue;
-		}
+	if (ACPI_FAILURE(status))
+		return AE_CTRL_DEPTH;
 
-		status = acpi_get_type(chandle, &type);
+	if (ops->acpi_op_start && !(ops->acpi_op_add)) {
+		status = acpi_start_single_object(device);
 		if (ACPI_FAILURE(status))
-			continue;
-
-		/*
-		 * If this is a scope object then parse it (depth-first).
-		 */
-		if (type == ACPI_TYPE_LOCAL_SCOPE) {
-			level++;
-			phandle = chandle;
-			chandle = NULL;
-			continue;
-		}
+			return AE_CTRL_DEPTH;
+	}
 
-		/*
-		 * We're only interested in objects that we consider 'devices'.
-		 */
-		switch (type) {
-		case ACPI_TYPE_DEVICE:
-			type = ACPI_BUS_TYPE_DEVICE;
-			break;
-		case ACPI_TYPE_PROCESSOR:
-			type = ACPI_BUS_TYPE_PROCESSOR;
-			break;
-		case ACPI_TYPE_THERMAL:
-			type = ACPI_BUS_TYPE_THERMAL;
-			break;
-		case ACPI_TYPE_POWER:
-			type = ACPI_BUS_TYPE_POWER;
-			break;
-		default:
-			continue;
-		}
+	/*
+	 * If the device is present, enabled, and functioning then
+	 * parse its scope (depth-first).  Note that we need to
+	 * represent absent devices to facilitate PnP notifications
+	 * -- but only the subtree head (not all of its children,
+	 * which will be enumerated when the parent is inserted).
+	 *
+	 * TBD: Need notifications and other detection mechanisms
+	 *      in place before we can fully implement this.
+	 *
+	 * When the device is not present but functional, it is also
+	 * necessary to scan the children of this device.
+	 */
+	if (!device->status.present && !device->status.functional)
+		return AE_CTRL_DEPTH;
 
-		if (ops->acpi_op_add)
-			status = acpi_add_single_object(&child, chandle, type,
-							ops);
-		else
-			status = acpi_bus_get_device(chandle, &child);
+	if (!*return_value)
+		*return_value = device;
+	return AE_OK;
+}
 
-		if (ACPI_FAILURE(status))
-			continue;
+static int acpi_bus_scan(acpi_handle handle, struct acpi_bus_ops *ops,
+			 struct acpi_device **child)
+{
+	acpi_status status;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	void *device = NULL;
 
-		if (ops->acpi_op_start && !(ops->acpi_op_add)) {
-			status = acpi_start_single_object(child);
-			if (ACPI_FAILURE(status))
-				continue;
-		}
+	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+	printk(KERN_INFO PREFIX "Enumerating devices from [%s]\n",
+	       (char *) buffer.pointer);
 
-		/*
-		 * If the device is present, enabled, and functioning then
-		 * parse its scope (depth-first).  Note that we need to
-		 * represent absent devices to facilitate PnP notifications
-		 * -- but only the subtree head (not all of its children,
-		 * which will be enumerated when the parent is inserted).
-		 *
-		 * TBD: Need notifications and other detection mechanisms
-		 *      in place before we can fully implement this.
-		 */
-		 /*
-		 * When the device is not present but functional, it is also
-		 * necessary to scan the children of this device.
-		 */
-		if (child->status.present || (!child->status.present &&
-					child->status.functional)) {
-			status = acpi_get_next_object(ACPI_TYPE_ANY, chandle,
-						      NULL, NULL);
-			if (ACPI_SUCCESS(status)) {
-				level++;
-				phandle = chandle;
-				chandle = NULL;
-				parent = child;
-			}
-		}
-	}
+	status = acpi_bus_check_add(handle, 0, ops, &device);
+	if (ACPI_SUCCESS(status))
+		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
+				    acpi_bus_check_add, ops, &device);
 
+	if (child)
+		*child = device;
 	return 0;
 }
 
@@ -1517,33 +1486,25 @@ int
 acpi_bus_add(struct acpi_device **child,
 	     struct acpi_device *parent, acpi_handle handle, int type)
 {
-	int result;
 	struct acpi_bus_ops ops;
 
 	memset(&ops, 0, sizeof(ops));
 	ops.acpi_op_add = 1;
 
-	result = acpi_add_single_object(child, handle, type, &ops);
-	if (!result)
-		result = acpi_bus_scan((*child)->handle, &ops);
-
-	return result;
+	acpi_bus_scan(handle, &ops, child);
+	return 0;
 }
 EXPORT_SYMBOL(acpi_bus_add);
 
 int acpi_bus_start(struct acpi_device *device)
 {
-	int result;
 	struct acpi_bus_ops ops;
 
 	memset(&ops, 0, sizeof(ops));
 	ops.acpi_op_start = 1;
 
-	result = acpi_start_single_object(device);
-	if (!result)
-		result = acpi_bus_scan(device->handle, &ops);
-
-	return result;
+	acpi_bus_scan(device->handle, &ops, NULL);
+	return 0;
 }
 EXPORT_SYMBOL(acpi_bus_start);
 
@@ -1645,18 +1606,10 @@ int __init acpi_scan_init(void)
 		printk(KERN_ERR PREFIX "Could not register bus type\n");
 	}
 
-	/*
-	 * Create the root device in the bus's device tree
-	 */
-	result = acpi_add_single_object(&acpi_root, ACPI_ROOT_OBJECT,
-					ACPI_BUS_TYPE_DEVICE, &ops);
-	if (result)
-		goto Done;
-
 	/*
 	 * Enumerate devices in the ACPI namespace.
 	 */
-	result = acpi_bus_scan(acpi_root->handle, &ops);
+	result = acpi_bus_scan(ACPI_ROOT_OBJECT, &ops, &acpi_root);
 
 	if (!result)
 		result = acpi_bus_scan_fixed();
@@ -1664,6 +1617,5 @@ int __init acpi_scan_init(void)
 	if (result)
 		acpi_device_unregister(acpi_root, ACPI_BUS_REMOVAL_NORMAL);
 
-Done:
 	return result;
 }

commit 859ac9a4be0c753cece0e30a2e4a65fd2cdcaeee
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 19:29:50 2009 +0000

    ACPI: identify device tree root by null parent pointer, not ACPI_BUS_TYPE
    
    We can identify the root of the ACPI device tree by the fact that it
    has no parent.  This is simpler than passing around ACPI_BUS_TYPE_SYSTEM
    and will help remove special treatment of the device tree root.
    
    Currently, we add the root by hand with ACPI_BUS_TYPE_SYSTEM.  If we
    traverse the tree treating the root as just another device and use
    acpi_get_type(), the root shows up as ACPI_TYPE_DEVICE.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 27d2dec55c6c..0b5aaf059c9b 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -22,6 +22,8 @@ extern struct acpi_device *acpi_root;
 #define ACPI_BUS_HID			"LNXSYBUS"
 #define ACPI_BUS_DEVICE_NAME		"System Bus"
 
+#define ACPI_IS_ROOT_DEVICE(device)    (!(device)->parent)
+
 static LIST_HEAD(acpi_device_list);
 static LIST_HEAD(acpi_bus_id_list);
 DEFINE_MUTEX(acpi_device_lock);
@@ -955,10 +957,12 @@ static void acpi_device_get_busid(struct acpi_device *device)
 	 * The device's Bus ID is simply the object name.
 	 * TBD: Shouldn't this value be unique (within the ACPI namespace)?
 	 */
-	switch (device->device_type) {
-	case ACPI_BUS_TYPE_SYSTEM:
+	if (ACPI_IS_ROOT_DEVICE(device)) {
 		strcpy(device->pnp.bus_id, "ACPI");
-		break;
+		return;
+	}
+
+	switch (device->device_type) {
 	case ACPI_BUS_TYPE_POWER_BUTTON:
 		strcpy(device->pnp.bus_id, "PWRF");
 		break;
@@ -1093,6 +1097,11 @@ static void acpi_device_set_id(struct acpi_device *device)
 
 	switch (device->device_type) {
 	case ACPI_BUS_TYPE_DEVICE:
+		if (ACPI_IS_ROOT_DEVICE(device)) {
+			hid = ACPI_SYSTEM_HID;
+			break;
+		}
+
 		status = acpi_get_object_info(device->handle, &info);
 		if (ACPI_FAILURE(status)) {
 			printk(KERN_ERR PREFIX "%s: Error reading device info\n", __func__);
@@ -1129,9 +1138,6 @@ static void acpi_device_set_id(struct acpi_device *device)
 	case ACPI_BUS_TYPE_PROCESSOR:
 		hid = ACPI_PROCESSOR_OBJECT_HID;
 		break;
-	case ACPI_BUS_TYPE_SYSTEM:
-		hid = ACPI_SYSTEM_HID;
-		break;
 	case ACPI_BUS_TYPE_THERMAL:
 		hid = ACPI_THERMAL_HID;
 		break;
@@ -1643,7 +1649,7 @@ int __init acpi_scan_init(void)
 	 * Create the root device in the bus's device tree
 	 */
 	result = acpi_add_single_object(&acpi_root, ACPI_ROOT_OBJECT,
-					ACPI_BUS_TYPE_SYSTEM, &ops);
+					ACPI_BUS_TYPE_DEVICE, &ops);
 	if (result)
 		goto Done;
 

commit adc08e2035f1859d4b129f42b2c2305ef090d226
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 19:29:45 2009 +0000

    ACPI: enumerate namespace before adding functional fixed hardware devices
    
    This patch changes the order so we enumerate in the "root, namespace,
    functional fixed" order instead of the "root, functional fixed, namespace"
    order.  When I change acpi_bus_scan() to use acpi_walk_namespace(), it
    will use the former order, so this patch isolates the order change for
    bisectability.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 4fe73596c5d3..27d2dec55c6c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1650,10 +1650,10 @@ int __init acpi_scan_init(void)
 	/*
 	 * Enumerate devices in the ACPI namespace.
 	 */
-	result = acpi_bus_scan_fixed();
+	result = acpi_bus_scan(acpi_root->handle, &ops);
 
 	if (!result)
-		result = acpi_bus_scan(acpi_root->handle, &ops);
+		result = acpi_bus_scan_fixed();
 
 	if (result)
 		acpi_device_unregister(acpi_root, ACPI_BUS_REMOVAL_NORMAL);

commit 8e029bf0a611ea3995bd1fae0285cbaf6eed7f16
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 19:29:40 2009 +0000

    ACPI: convert acpi_bus_scan() to operate on an acpi_handle
    
    This patch changes acpi_bus_scan() to take an acpi_handle rather than an
    acpi_device pointer.  I plan to use acpi_bus_scan() in the hotplug path,
    and I'd rather not assume that notifications only go to nodes that already
    have acpi_devices.
    
    This will also help remove the special case for adding the root node.  We
    currently add the root by hand before acpi_bus_scan(), but using a handle
    here means we can start the acpi_bus_scan() directly with the root even
    though it doesn't have an acpi_device yet.
    
    Note that acpi_bus_scan() currently adds and/or starts the *children* of
    its device argument.  It doesn't do anything with the device itself.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f205b368894b..4fe73596c5d3 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1387,7 +1387,7 @@ static int acpi_add_single_object(struct acpi_device **child,
 	return result;
 }
 
-static int acpi_bus_scan(struct acpi_device *start, struct acpi_bus_ops *ops)
+static int acpi_bus_scan(acpi_handle handle, struct acpi_bus_ops *ops)
 {
 	acpi_status status = AE_OK;
 	struct acpi_device *parent = NULL;
@@ -1396,13 +1396,16 @@ static int acpi_bus_scan(struct acpi_device *start, struct acpi_bus_ops *ops)
 	acpi_handle chandle = NULL;
 	acpi_object_type type = 0;
 	u32 level = 1;
+	int ret;
 
-
-	if (!start)
-		return -EINVAL;
-
-	parent = start;
-	phandle = start->handle;
+	/*
+	 * We must have an acpi_device for the starting node already, and
+	 * we scan its children.
+	 */
+	phandle = handle;
+	ret = acpi_bus_get_device(phandle, &parent);
+	if (ret)
+		return ret;
 
 	/*
 	 * Parse through the ACPI namespace, identify all 'devices', and
@@ -1516,7 +1519,7 @@ acpi_bus_add(struct acpi_device **child,
 
 	result = acpi_add_single_object(child, handle, type, &ops);
 	if (!result)
-		result = acpi_bus_scan(*child, &ops);
+		result = acpi_bus_scan((*child)->handle, &ops);
 
 	return result;
 }
@@ -1527,16 +1530,13 @@ int acpi_bus_start(struct acpi_device *device)
 	int result;
 	struct acpi_bus_ops ops;
 
-
-	if (!device)
-		return -EINVAL;
+	memset(&ops, 0, sizeof(ops));
+	ops.acpi_op_start = 1;
 
 	result = acpi_start_single_object(device);
-	if (!result) {
-		memset(&ops, 0, sizeof(ops));
-		ops.acpi_op_start = 1;
-		result = acpi_bus_scan(device, &ops);
-	}
+	if (!result)
+		result = acpi_bus_scan(device->handle, &ops);
+
 	return result;
 }
 EXPORT_SYMBOL(acpi_bus_start);
@@ -1653,7 +1653,7 @@ int __init acpi_scan_init(void)
 	result = acpi_bus_scan_fixed();
 
 	if (!result)
-		result = acpi_bus_scan(acpi_root, &ops);
+		result = acpi_bus_scan(acpi_root->handle, &ops);
 
 	if (result)
 		acpi_device_unregister(acpi_root, ACPI_BUS_REMOVAL_NORMAL);

commit 5c478f499c9e6a3ac542c940f7b434686f4967a5
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 19:29:35 2009 +0000

    ACPI: add acpi_bus_get_parent() and remove "parent" arguments
    
    This patch adds acpi_bus_get_parent(), which ascends the namespace until
    it finds a parent with an acpi_device.
    
    Then we use acpi_bus_get_parent() in acpi_add_single_object(), so callers
    don't have to figure out or keep track of the parent acpi_device.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f2e283426be9..f205b368894b 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -662,6 +662,33 @@ EXPORT_SYMBOL(acpi_bus_unregister_driver);
 /* --------------------------------------------------------------------------
                                  Device Enumeration
    -------------------------------------------------------------------------- */
+static struct acpi_device *acpi_bus_get_parent(acpi_handle handle)
+{
+	acpi_status status;
+	int ret;
+	struct acpi_device *device;
+
+	/*
+	 * Fixed hardware devices do not appear in the namespace and do not
+	 * have handles, but we fabricate acpi_devices for them, so we have
+	 * to deal with them specially.
+	 */
+	if (handle == NULL)
+		return acpi_root;
+
+	do {
+		status = acpi_get_parent(handle, &handle);
+		if (status == AE_NULL_ENTRY)
+			return NULL;
+		if (ACPI_FAILURE(status))
+			return acpi_root;
+
+		ret = acpi_bus_get_device(handle, &device);
+		if (ret == 0)
+			return device;
+	} while (1);
+}
+
 acpi_status
 acpi_bus_get_ejd(acpi_handle handle, acpi_handle *ejd)
 {
@@ -1217,10 +1244,9 @@ static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 	return 0;
 }
 
-static int
-acpi_add_single_object(struct acpi_device **child,
-		       struct acpi_device *parent, acpi_handle handle, int type,
-			struct acpi_bus_ops *ops)
+static int acpi_add_single_object(struct acpi_device **child,
+				  acpi_handle handle, int type,
+				  struct acpi_bus_ops *ops)
 {
 	int result;
 	struct acpi_device *device;
@@ -1234,7 +1260,7 @@ acpi_add_single_object(struct acpi_device **child,
 
 	device->device_type = type;
 	device->handle = handle;
-	device->parent = parent;
+	device->parent = acpi_bus_get_parent(handle);
 	device->bus_ops = *ops; /* workround for not call .start */
 
 	acpi_device_get_busid(device);
@@ -1434,8 +1460,8 @@ static int acpi_bus_scan(struct acpi_device *start, struct acpi_bus_ops *ops)
 		}
 
 		if (ops->acpi_op_add)
-			status = acpi_add_single_object(&child, parent,
-				chandle, type, ops);
+			status = acpi_add_single_object(&child, chandle, type,
+							ops);
 		else
 			status = acpi_bus_get_device(chandle, &child);
 
@@ -1488,7 +1514,7 @@ acpi_bus_add(struct acpi_device **child,
 	memset(&ops, 0, sizeof(ops));
 	ops.acpi_op_add = 1;
 
-	result = acpi_add_single_object(child, parent, handle, type, &ops);
+	result = acpi_add_single_object(child, handle, type, &ops);
 	if (!result)
 		result = acpi_bus_scan(*child, &ops);
 
@@ -1584,15 +1610,13 @@ static int acpi_bus_scan_fixed(void)
 	 * Enumerate all fixed-feature devices.
 	 */
 	if ((acpi_gbl_FADT.flags & ACPI_FADT_POWER_BUTTON) == 0) {
-		result = acpi_add_single_object(&device, acpi_root,
-						NULL,
+		result = acpi_add_single_object(&device, NULL,
 						ACPI_BUS_TYPE_POWER_BUTTON,
 						&ops);
 	}
 
 	if ((acpi_gbl_FADT.flags & ACPI_FADT_SLEEP_BUTTON) == 0) {
-		result = acpi_add_single_object(&device, acpi_root,
-						NULL,
+		result = acpi_add_single_object(&device, NULL,
 						ACPI_BUS_TYPE_SLEEP_BUTTON,
 						&ops);
 	}
@@ -1618,7 +1642,7 @@ int __init acpi_scan_init(void)
 	/*
 	 * Create the root device in the bus's device tree
 	 */
-	result = acpi_add_single_object(&acpi_root, NULL, ACPI_ROOT_OBJECT,
+	result = acpi_add_single_object(&acpi_root, ACPI_ROOT_OBJECT,
 					ACPI_BUS_TYPE_SYSTEM, &ops);
 	if (result)
 		goto Done;

commit 77c24888b7693eecee904308e0ee51f7f1f564df
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 19:29:30 2009 +0000

    ACPI: remove unnecessary argument checking
    
    acpi_add_single_object() is static, and all callers supply a valid "child"
    argument, so we don't need to check it.  This patch also remove some
    unnecessary initializations.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 6c83342d13d5..f2e283426be9 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1222,14 +1222,10 @@ acpi_add_single_object(struct acpi_device **child,
 		       struct acpi_device *parent, acpi_handle handle, int type,
 			struct acpi_bus_ops *ops)
 {
-	int result = 0;
-	struct acpi_device *device = NULL;
+	int result;
+	struct acpi_device *device;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 
-
-	if (!child)
-		return -EINVAL;
-
 	device = kzalloc(sizeof(struct acpi_device), GFP_KERNEL);
 	if (!device) {
 		printk(KERN_ERR PREFIX "Memory allocation error\n");

commit c7bcb4e98aca348f6f8ab432496ff35ba7a49a1d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 19:29:25 2009 +0000

    ACPI: remove redundant "type" arguments
    
    We now save the ACPI bus "device_type" in the acpi_device structure, so
    we don't need to pass it around explicitly anymore.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 44383fe35082..6c83342d13d5 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -916,7 +916,7 @@ static int acpi_bus_get_flags(struct acpi_device *device)
 	return 0;
 }
 
-static void acpi_device_get_busid(struct acpi_device *device, int type)
+static void acpi_device_get_busid(struct acpi_device *device)
 {
 	char bus_id[5] = { '?', 0 };
 	struct acpi_buffer buffer = { sizeof(bus_id), bus_id };
@@ -928,7 +928,7 @@ static void acpi_device_get_busid(struct acpi_device *device, int type)
 	 * The device's Bus ID is simply the object name.
 	 * TBD: Shouldn't this value be unique (within the ACPI namespace)?
 	 */
-	switch (type) {
+	switch (device->device_type) {
 	case ACPI_BUS_TYPE_SYSTEM:
 		strcpy(device->pnp.bus_id, "ACPI");
 		break;
@@ -1055,7 +1055,7 @@ acpi_add_cid(
 	return cid;
 }
 
-static void acpi_device_set_id(struct acpi_device *device, int type)
+static void acpi_device_set_id(struct acpi_device *device)
 {
 	struct acpi_device_info *info = NULL;
 	char *hid = NULL;
@@ -1064,7 +1064,7 @@ static void acpi_device_set_id(struct acpi_device *device, int type)
 	char *cid_add = NULL;
 	acpi_status status;
 
-	switch (type) {
+	switch (device->device_type) {
 	case ACPI_BUS_TYPE_DEVICE:
 		status = acpi_get_object_info(device->handle, &info);
 		if (ACPI_FAILURE(status)) {
@@ -1122,7 +1122,7 @@ static void acpi_device_set_id(struct acpi_device *device, int type)
 	 * Fix for the system root bus device -- the only root-level device.
 	 */
 	if (((acpi_handle)device->parent == ACPI_ROOT_OBJECT) &&
-	     (type == ACPI_BUS_TYPE_DEVICE)) {
+	     (device->device_type == ACPI_BUS_TYPE_DEVICE)) {
 		hid = ACPI_BUS_HID;
 		strcpy(device->pnp.device_name, ACPI_BUS_DEVICE_NAME);
 		strcpy(device->pnp.device_class, ACPI_BUS_CLASS);
@@ -1241,7 +1241,7 @@ acpi_add_single_object(struct acpi_device **child,
 	device->parent = parent;
 	device->bus_ops = *ops; /* workround for not call .start */
 
-	acpi_device_get_busid(device, type);
+	acpi_device_get_busid(device);
 
 	/*
 	 * Flags
@@ -1304,7 +1304,7 @@ acpi_add_single_object(struct acpi_device **child,
 	 * Hardware ID, Unique ID, & Bus Address
 	 * -------------------------------------
 	 */
-	acpi_device_set_id(device, type);
+	acpi_device_set_id(device);
 
 	/*
 	 * Power Management

commit bc3b07726aa288e2a5e60d9a1dd8188b3faa7385
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 19:29:20 2009 +0000

    ACPI: remove acpi_device_set_context() "type" argument
    
    We only pass the "type" to acpi_device_set_context() so we know whether
    the device has a handle to which we can attach the acpi_device pointer.
    But it's safer to just check for the handle directly, since it's in the
    acpi_device already.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c8e867b4a842..44383fe35082 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1171,29 +1171,27 @@ static void acpi_device_set_id(struct acpi_device *device, int type)
 	kfree(info);
 }
 
-static int acpi_device_set_context(struct acpi_device *device, int type)
+static int acpi_device_set_context(struct acpi_device *device)
 {
-	acpi_status status = AE_OK;
-	int result = 0;
+	acpi_status status;
+
 	/*
 	 * Context
 	 * -------
 	 * Attach this 'struct acpi_device' to the ACPI object.  This makes
-	 * resolutions from handle->device very efficient.  Note that we need
-	 * to be careful with fixed-feature devices as they all attach to the
-	 * root object.
+	 * resolutions from handle->device very efficient.  Fixed hardware
+	 * devices have no handles, so we skip them.
 	 */
-	if (type != ACPI_BUS_TYPE_POWER_BUTTON &&
-	    type != ACPI_BUS_TYPE_SLEEP_BUTTON) {
-		status = acpi_attach_data(device->handle,
-					  acpi_bus_data_handler, device);
+	if (!device->handle)
+		return 0;
 
-		if (ACPI_FAILURE(status)) {
-			printk(KERN_ERR PREFIX "Error attaching device data\n");
-			result = -ENODEV;
-		}
-	}
-	return result;
+	status = acpi_attach_data(device->handle,
+				  acpi_bus_data_handler, device);
+	if (ACPI_SUCCESS(status))
+		return 0;
+
+	printk(KERN_ERR PREFIX "Error attaching device data\n");
+	return -ENODEV;
 }
 
 static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
@@ -1338,7 +1336,7 @@ acpi_add_single_object(struct acpi_device **child,
 			goto end;
 	}
 
-	if ((result = acpi_device_set_context(device, type)))
+	if ((result = acpi_device_set_context(device)))
 		goto end;
 
 	result = acpi_device_register(device);

commit ccba2a36d74a9da815e597ac727cfd096fa8e750
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 19:29:15 2009 +0000

    ACPI: use device_type rather than comparing HID
    
    Check the acpi_device device_type rather than the HID.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c73681b7e69e..c8e867b4a842 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -378,15 +378,13 @@ static acpi_status acpi_device_notify_fixed(void *data)
 static int acpi_device_install_notify_handler(struct acpi_device *device)
 {
 	acpi_status status;
-	char *hid;
 
-	hid = acpi_device_hid(device);
-	if (!strcmp(hid, ACPI_BUTTON_HID_POWERF))
+	if (device->device_type == ACPI_BUS_TYPE_POWER_BUTTON)
 		status =
 		    acpi_install_fixed_event_handler(ACPI_EVENT_POWER_BUTTON,
 						     acpi_device_notify_fixed,
 						     device);
-	else if (!strcmp(hid, ACPI_BUTTON_HID_SLEEPF))
+	else if (device->device_type == ACPI_BUS_TYPE_SLEEP_BUTTON)
 		status =
 		    acpi_install_fixed_event_handler(ACPI_EVENT_SLEEP_BUTTON,
 						     acpi_device_notify_fixed,
@@ -404,10 +402,10 @@ static int acpi_device_install_notify_handler(struct acpi_device *device)
 
 static void acpi_device_remove_notify_handler(struct acpi_device *device)
 {
-	if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_POWERF))
+	if (device->device_type == ACPI_BUS_TYPE_POWER_BUTTON)
 		acpi_remove_fixed_event_handler(ACPI_EVENT_POWER_BUTTON,
 						acpi_device_notify_fixed);
-	else if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_SLEEPF))
+	else if (device->device_type == ACPI_BUS_TYPE_SLEEP_BUTTON)
 		acpi_remove_fixed_event_handler(ACPI_EVENT_SLEEP_BUTTON,
 						acpi_device_notify_fixed);
 	else

commit caaa6efb3d82d0102db9e7094ca5773c46e6780c
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 19:29:10 2009 +0000

    ACPI: save device_type in acpi_device
    
    Most uses of the ACPI bus device_type (ACPI_BUS_TYPE_DEVICE,
    ACPI_BUS_TYPE_POWER, etc) are during device initialization, but
    we do need it later for notify handler installation, since that
    is different for fixed hardware devices vs. namespace devices.
    
    This patch saves the device_type in the acpi_device structure,
    so we can check that rather than comparing against the _HID string.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ab5a26469707..c73681b7e69e 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1240,6 +1240,7 @@ acpi_add_single_object(struct acpi_device **child,
 		return -ENOMEM;
 	}
 
+	device->device_type = type;
 	device->handle = handle;
 	device->parent = parent;
 	device->bus_ops = *ops; /* workround for not call .start */

commit 66b7ed40aaf153d634aabff409a0dda675f37f45
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 19:29:05 2009 +0000

    ACPI: remove redundant "handle" and "parent" arguments
    
    In several cases, functions take handle and parent device pointers in
    addition to acpi_device pointers.  But the acpi_device structure contains
    both the handle and the parent pointer, so it's pointless and error-prone
    to pass them all.  This patch removes the unnecessary "handle" and "parent"
    arguments.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 0302dd454e17..ab5a26469707 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -474,12 +474,12 @@ struct bus_type acpi_bus_type = {
 	.uevent		= acpi_device_uevent,
 };
 
-static int acpi_device_register(struct acpi_device *device,
-				 struct acpi_device *parent)
+static int acpi_device_register(struct acpi_device *device)
 {
 	int result;
 	struct acpi_device_bus_id *acpi_device_bus_id, *new_bus_id;
 	int found = 0;
+
 	/*
 	 * Linkage
 	 * -------
@@ -524,7 +524,7 @@ static int acpi_device_register(struct acpi_device *device,
 	mutex_unlock(&acpi_device_lock);
 
 	if (device->parent)
-		device->dev.parent = &parent->dev;
+		device->dev.parent = &device->parent->dev;
 	device->dev.bus = &acpi_bus_type;
 	device->dev.release = &acpi_device_release;
 	result = device_register(&device->dev);
@@ -918,8 +918,7 @@ static int acpi_bus_get_flags(struct acpi_device *device)
 	return 0;
 }
 
-static void acpi_device_get_busid(struct acpi_device *device,
-				  acpi_handle handle, int type)
+static void acpi_device_get_busid(struct acpi_device *device, int type)
 {
 	char bus_id[5] = { '?', 0 };
 	struct acpi_buffer buffer = { sizeof(bus_id), bus_id };
@@ -942,7 +941,7 @@ static void acpi_device_get_busid(struct acpi_device *device,
 		strcpy(device->pnp.bus_id, "SLPF");
 		break;
 	default:
-		acpi_get_name(handle, ACPI_SINGLE_NAME, &buffer);
+		acpi_get_name(device->handle, ACPI_SINGLE_NAME, &buffer);
 		/* Clean up trailing underscores (if any) */
 		for (i = 3; i > 1; i--) {
 			if (bus_id[i] == '_')
@@ -1058,9 +1057,7 @@ acpi_add_cid(
 	return cid;
 }
 
-static void acpi_device_set_id(struct acpi_device *device,
-			       struct acpi_device *parent, acpi_handle handle,
-			       int type)
+static void acpi_device_set_id(struct acpi_device *device, int type)
 {
 	struct acpi_device_info *info = NULL;
 	char *hid = NULL;
@@ -1071,7 +1068,7 @@ static void acpi_device_set_id(struct acpi_device *device,
 
 	switch (type) {
 	case ACPI_BUS_TYPE_DEVICE:
-		status = acpi_get_object_info(handle, &info);
+		status = acpi_get_object_info(device->handle, &info);
 		if (ACPI_FAILURE(status)) {
 			printk(KERN_ERR PREFIX "%s: Error reading device info\n", __func__);
 			return;
@@ -1126,7 +1123,8 @@ static void acpi_device_set_id(struct acpi_device *device,
 	 * ----
 	 * Fix for the system root bus device -- the only root-level device.
 	 */
-	if (((acpi_handle)parent == ACPI_ROOT_OBJECT) && (type == ACPI_BUS_TYPE_DEVICE)) {
+	if (((acpi_handle)device->parent == ACPI_ROOT_OBJECT) &&
+	     (type == ACPI_BUS_TYPE_DEVICE)) {
 		hid = ACPI_BUS_HID;
 		strcpy(device->pnp.device_name, ACPI_BUS_DEVICE_NAME);
 		strcpy(device->pnp.device_class, ACPI_BUS_CLASS);
@@ -1246,8 +1244,7 @@ acpi_add_single_object(struct acpi_device **child,
 	device->parent = parent;
 	device->bus_ops = *ops; /* workround for not call .start */
 
-
-	acpi_device_get_busid(device, handle, type);
+	acpi_device_get_busid(device, type);
 
 	/*
 	 * Flags
@@ -1310,7 +1307,7 @@ acpi_add_single_object(struct acpi_device **child,
 	 * Hardware ID, Unique ID, & Bus Address
 	 * -------------------------------------
 	 */
-	acpi_device_set_id(device, parent, handle, type);
+	acpi_device_set_id(device, type);
 
 	/*
 	 * Power Management
@@ -1345,7 +1342,7 @@ acpi_add_single_object(struct acpi_device **child,
 	if ((result = acpi_device_set_context(device, type)))
 		goto end;
 
-	result = acpi_device_register(device, parent);
+	result = acpi_device_register(device);
 
 	/*
 	 * Bind _ADR-Based Devices when hot add

commit e8b945c9c155d06e1d1ea594f8e18e01aa36f612
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 19:28:59 2009 +0000

    ACPI: remove unused acpi_bus_scan_fixed() argument
    
    We never use the "root" argument, so just remove it.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 75b7c572ef45..0302dd454e17 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1580,15 +1580,12 @@ int acpi_bus_trim(struct acpi_device *start, int rmdevice)
 }
 EXPORT_SYMBOL_GPL(acpi_bus_trim);
 
-static int acpi_bus_scan_fixed(struct acpi_device *root)
+static int acpi_bus_scan_fixed(void)
 {
 	int result = 0;
 	struct acpi_device *device = NULL;
 	struct acpi_bus_ops ops;
 
-	if (!root)
-		return -ENODEV;
-
 	memset(&ops, 0, sizeof(ops));
 	ops.acpi_op_add = 1;
 	ops.acpi_op_start = 1;
@@ -1639,7 +1636,7 @@ int __init acpi_scan_init(void)
 	/*
 	 * Enumerate devices in the ACPI namespace.
 	 */
-	result = acpi_bus_scan_fixed(acpi_root);
+	result = acpi_bus_scan_fixed();
 
 	if (!result)
 		result = acpi_bus_scan(acpi_root, &ops);

commit 29aaefa68f933110e577fbf3ca360c88331e5ff5
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 21 19:28:54 2009 +0000

    ACPI: add debug for device addition
    
    Add debug output for adding an ACPI device.  Enable this with
    "acpi.debug_layer=0x00010000" (ACPI_BUS_COMPONENT).
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 408ebde18986..75b7c572ef45 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1230,6 +1230,7 @@ acpi_add_single_object(struct acpi_device **child,
 {
 	int result = 0;
 	struct acpi_device *device = NULL;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 
 
 	if (!child)
@@ -1355,9 +1356,16 @@ acpi_add_single_object(struct acpi_device **child,
 	}
 
 end:
-	if (!result)
+	if (!result) {
+		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Adding %s [%s] parent %s\n", dev_name(&device->dev),
+			 (char *) buffer.pointer,
+			 device->parent ? dev_name(&device->parent->dev) :
+					  "(null)"));
+		kfree(buffer.pointer);
 		*child = device;
-	else
+	} else
 		acpi_device_release(&device->dev);
 
 	return result;

commit 53de5356be3ac62c22ae1da266943059b169d9b1
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Aug 31 22:32:20 2009 +0000

    ACPI: don't pass handle for fixed hardware notifications
    
    Fixed hardware devices have no handles, so just pass an explicit
    NULL rather than something that looks like it might be meaningful.
    acpi_device_notify() doesn't need the handle anyway; the only
    reason it takes it as an argument is because the acpi_notify_handler
    typedef requires it.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 7b90900b2118..408ebde18986 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -370,7 +370,8 @@ static acpi_status acpi_device_notify_fixed(void *data)
 {
 	struct acpi_device *device = data;
 
-	acpi_device_notify(device->handle, ACPI_FIXED_HARDWARE_EVENT, device);
+	/* Fixed hardware devices have no handles */
+	acpi_device_notify(NULL, ACPI_FIXED_HARDWARE_EVENT, device);
 	return AE_OK;
 }
 

commit 3b87bb640e77023c97cf209e3dd85887a1113ad0
Merge: 7a92d803227a dcf52fb71d98
Author: Len Brown <len.brown@intel.com>
Date:   Sat Sep 19 01:56:39 2009 -0400

    Merge branch 'bjorn-start-stop-2.6.32' into release

commit 985f38781d19101aba121df423f92c87b208c6df
Merge: d093d70a81b0 c9766237afa9
Author: Len Brown <len.brown@intel.com>
Date:   Sat Sep 19 01:45:22 2009 -0400

    Merge branch 'acpica' into release

commit 71fd68e7d234f6b7d8407c8f486764d24f8411f4
Merge: 8ff0e082f083 78f28b7c5553
Author: Len Brown <len.brown@intel.com>
Date:   Sat Sep 19 00:06:59 2009 -0400

    Merge branch 'linus' into release

commit 9b83ccd2f14f647936dcfbf4a9a20c501007dd69
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Sep 8 23:15:31 2009 +0200

    ACPI PM: Replace wakeup.prepared with reference counter
    
    The wakeup.prepared flag is used for marking devices that have the
    wake-up power already enabled, so that the wake-up power is not
    enabled twice in a row for the same device.  This assumes, however,
    that device wake-up power will only be enabled once, while the device
    is being prepared for a system-wide sleep transition, and the second
    attempt is made by acpi_enable_wakeup_device_prep().
    
    With the upcoming PCI wake-up rework this assumption will not hold
    any more for PCI bridges and the root bridge whose wake-up power
    may be enabled as a result of wake-up enable propagation from other
    devices (eg. add-on devices that are not associated with any GPEs).
    Thus, there may be many attempts to enable wake-up power on a PCI
    bridge or the root bridge during a system power state transition
    and it's better to replace wakeup.prepared with a reference counter.
    
    Reviewed-by: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 781435d7e369..318b1ea7a5bf 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -781,6 +781,7 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	kfree(buffer.pointer);
 
 	device->wakeup.flags.valid = 1;
+	device->wakeup.prepare_count = 0;
 	/* Call _PSW/_DSW object to disable its ability to wake the sleeping
 	 * system for the ACPI device with the _PRW object.
 	 * The _PSW object is depreciated in ACPI 3.0 and is replaced by _DSW.

commit f61f925859c57f6175082aeeee17743c68558a6e
Author: Len Brown <len.brown@intel.com>
Date:   Sat Sep 5 13:33:23 2009 -0400

    Revert "ACPI: Attach the ACPI device to the ACPI handle as early as possible"
    
    This reverts commit eab4b645769fa2f8703f5a3cb0cc4ac090d347af.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=13002
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 781435d7e369..5dd702c9c1fa 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1263,16 +1263,6 @@ acpi_add_single_object(struct acpi_device **child,
 	 */
 	acpi_device_set_id(device, parent, handle, type);
 
-	/*
-	 * The ACPI device is attached to acpi handle before getting
-	 * the power/wakeup/peformance flags. Otherwise OS can't get
-	 * the corresponding ACPI device by the acpi handle in the course
-	 * of getting the power/wakeup/performance flags.
-	 */
-	result = acpi_device_set_context(device, type);
-	if (result)
-		goto end;
-
 	/*
 	 * Power Management
 	 * ----------------
@@ -1303,6 +1293,8 @@ acpi_add_single_object(struct acpi_device **child,
 			goto end;
 	}
 
+	if ((result = acpi_device_set_context(device, type)))
+		goto end;
 
 	result = acpi_device_register(device, parent);
 

commit 718fb0de8ff88f71b3b91a8ee8e42e60c88e5128
Author: Hugh Dickins <hugh.dickins@tiscali.co.uk>
Date:   Thu Aug 6 23:18:12 2009 +0000

    ACPI: fix NULL bug for HID/UID string
    
    acpi_device->pnp.hardware_id and unique_id are now allocated pointers,
    replacing the previous arrays.  acpi_device_install_notify_handler()
    oopsed on the NULL hid when probing the video device, and perhaps other
    uses are vulnerable too.  So initialize those pointers to empty strings
    when there is no hid or uid.  Also, free hardware_id and unique_id when
    when acpi_device is going to be freed.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=14096
    
    Signed-off-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 9606af13d3b8..dc14421b93f1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -309,6 +309,10 @@ static void acpi_device_release(struct device *dev)
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 
 	kfree(acpi_dev->pnp.cid_list);
+	if (acpi_dev->flags.hardware_id)
+		kfree(acpi_dev->pnp.hardware_id);
+	if (acpi_dev->flags.unique_id)
+		kfree(acpi_dev->pnp.unique_id);
 	kfree(acpi_dev);
 }
 
@@ -1137,8 +1141,9 @@ static void acpi_device_set_id(struct acpi_device *device,
 			strcpy(device->pnp.hardware_id, hid);
 			device->flags.hardware_id = 1;
 		}
-	} else
-		device->pnp.hardware_id = NULL;
+	}
+	if (!device->flags.hardware_id)
+		device->pnp.hardware_id = "";
 
 	if (uid) {
 		device->pnp.unique_id = ACPI_ALLOCATE_ZEROED(strlen (uid) + 1);
@@ -1146,8 +1151,9 @@ static void acpi_device_set_id(struct acpi_device *device,
 			strcpy(device->pnp.unique_id, uid);
 			device->flags.unique_id = 1;
 		}
-	} else
-		device->pnp.unique_id = NULL;
+	}
+	if (!device->flags.unique_id)
+		device->pnp.unique_id = "";
 
 	if (cid_list || cid_add) {
 		struct acpica_device_id_list *list;
@@ -1362,10 +1368,8 @@ acpi_add_single_object(struct acpi_device **child,
 end:
 	if (!result)
 		*child = device;
-	else {
-		kfree(device->pnp.cid_list);
-		kfree(device);
-	}
+	else
+		acpi_device_release(&device->dev);
 
 	return result;
 }

commit 8e4319c425077c4cc540696a5bb6c4d12f017dcd
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jun 29 13:43:27 2009 +0800

    ACPICA: Fix several acpi_attach_data problems
    
    Handler was never invoked. Now invoked if/when host node is deleted.
    Data object was not automatically deleted when host node was deleted.
    Interface to handler had an unused parameter, removed it.
    ACPICA BZ 778.
    
    http://acpica.org/bugzilla/show_bug.cgi?id=778
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 0ab526de7c55..9606af13d3b8 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -687,7 +687,7 @@ acpi_bus_get_ejd(acpi_handle handle, acpi_handle *ejd)
 }
 EXPORT_SYMBOL_GPL(acpi_bus_get_ejd);
 
-void acpi_bus_data_handler(acpi_handle handle, u32 function, void *context)
+void acpi_bus_data_handler(acpi_handle handle, void *context)
 {
 
 	/* TBD */

commit 15b8dd53f5ffaf8e2d9095c423f713423f576c0f
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jun 29 13:39:29 2009 +0800

    ACPICA: Major update for acpi_get_object_info external interface
    
    Completed a major update for the acpi_get_object_info external interface.
    Changes include:
     - Support for variable, unlimited length HID, UID, and CID strings
     - Support Processor objects the same as Devices (HID,UID,CID,ADR,STA, etc.)
     - Call the _SxW power methods on behalf of a device object
     - Determine if a device is a PCI root bridge
     - Change the ACPI_BUFFER parameter to ACPI_DEVICE_INFO.
    These changes will require an update to all callers of this interface.
    See the ACPICA Programmer Reference for details.
    
    Also, update all invocations of acpi_get_object_info interface
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 781435d7e369..0ab526de7c55 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -60,13 +60,13 @@ static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
 	}
 
 	if (acpi_dev->flags.compatible_ids) {
-		struct acpi_compatible_id_list *cid_list;
+		struct acpica_device_id_list *cid_list;
 		int i;
 
 		cid_list = acpi_dev->pnp.cid_list;
 		for (i = 0; i < cid_list->count; i++) {
 			count = snprintf(&modalias[len], size, "%s:",
-					 cid_list->id[i].value);
+					 cid_list->ids[i].string);
 			if (count < 0 || count >= size) {
 				printk(KERN_ERR PREFIX "%s cid[%i] exceeds event buffer size",
 				       acpi_dev->pnp.device_name, i);
@@ -287,14 +287,14 @@ int acpi_match_device_ids(struct acpi_device *device,
 	}
 
 	if (device->flags.compatible_ids) {
-		struct acpi_compatible_id_list *cid_list = device->pnp.cid_list;
+		struct acpica_device_id_list *cid_list = device->pnp.cid_list;
 		int i;
 
 		for (id = ids; id->id[0]; id++) {
 			/* compare multiple _CID entries against driver ids */
 			for (i = 0; i < cid_list->count; i++) {
 				if (!strcmp((char*)id->id,
-					    cid_list->id[i].value))
+					    cid_list->ids[i].string))
 					return 0;
 			}
 		}
@@ -999,33 +999,89 @@ static int acpi_dock_match(struct acpi_device *device)
 	return acpi_get_handle(device->handle, "_DCK", &tmp);
 }
 
+static struct acpica_device_id_list*
+acpi_add_cid(
+	struct acpi_device_info         *info,
+	struct acpica_device_id         *new_cid)
+{
+	struct acpica_device_id_list    *cid;
+	char                            *next_id_string;
+	acpi_size                       cid_length;
+	acpi_size                       new_cid_length;
+	u32                             i;
+
+
+	/* Allocate new CID list with room for the new CID */
+
+	if (!new_cid)
+		new_cid_length = info->compatible_id_list.list_size;
+	else if (info->compatible_id_list.list_size)
+		new_cid_length = info->compatible_id_list.list_size +
+			new_cid->length + sizeof(struct acpica_device_id);
+	else
+		new_cid_length = sizeof(struct acpica_device_id_list) + new_cid->length;
+
+	cid = ACPI_ALLOCATE_ZEROED(new_cid_length);
+	if (!cid) {
+		return NULL;
+	}
+
+	cid->list_size = new_cid_length;
+	cid->count = info->compatible_id_list.count;
+	if (new_cid)
+		cid->count++;
+	next_id_string = (char *) cid->ids + (cid->count * sizeof(struct acpica_device_id));
+
+	/* Copy all existing CIDs */
+
+	for (i = 0; i < info->compatible_id_list.count; i++) {
+		cid_length = info->compatible_id_list.ids[i].length;
+		cid->ids[i].string = next_id_string;
+		cid->ids[i].length = cid_length;
+
+		ACPI_MEMCPY(next_id_string, info->compatible_id_list.ids[i].string,
+			cid_length);
+
+		next_id_string += cid_length;
+	}
+
+	/* Append the new CID */
+
+	if (new_cid) {
+		cid->ids[i].string = next_id_string;
+		cid->ids[i].length = new_cid->length;
+
+		ACPI_MEMCPY(next_id_string, new_cid->string, new_cid->length);
+	}
+
+	return cid;
+}
+
 static void acpi_device_set_id(struct acpi_device *device,
 			       struct acpi_device *parent, acpi_handle handle,
 			       int type)
 {
-	struct acpi_device_info *info;
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_device_info *info = NULL;
 	char *hid = NULL;
 	char *uid = NULL;
-	struct acpi_compatible_id_list *cid_list = NULL;
-	const char *cid_add = NULL;
+	struct acpica_device_id_list *cid_list = NULL;
+	char *cid_add = NULL;
 	acpi_status status;
 
 	switch (type) {
 	case ACPI_BUS_TYPE_DEVICE:
-		status = acpi_get_object_info(handle, &buffer);
+		status = acpi_get_object_info(handle, &info);
 		if (ACPI_FAILURE(status)) {
 			printk(KERN_ERR PREFIX "%s: Error reading device info\n", __func__);
 			return;
 		}
 
-		info = buffer.pointer;
 		if (info->valid & ACPI_VALID_HID)
-			hid = info->hardware_id.value;
+			hid = info->hardware_id.string;
 		if (info->valid & ACPI_VALID_UID)
-			uid = info->unique_id.value;
+			uid = info->unique_id.string;
 		if (info->valid & ACPI_VALID_CID)
-			cid_list = &info->compatibility_id;
+			cid_list = &info->compatible_id_list;
 		if (info->valid & ACPI_VALID_ADR) {
 			device->pnp.bus_address = info->address;
 			device->flags.bus_address = 1;
@@ -1076,55 +1132,44 @@ static void acpi_device_set_id(struct acpi_device *device,
 	}
 
 	if (hid) {
-		strcpy(device->pnp.hardware_id, hid);
-		device->flags.hardware_id = 1;
-	}
+		device->pnp.hardware_id = ACPI_ALLOCATE_ZEROED(strlen (hid) + 1);
+		if (device->pnp.hardware_id) {
+			strcpy(device->pnp.hardware_id, hid);
+			device->flags.hardware_id = 1;
+		}
+	} else
+		device->pnp.hardware_id = NULL;
+
 	if (uid) {
-		strcpy(device->pnp.unique_id, uid);
-		device->flags.unique_id = 1;
-	}
+		device->pnp.unique_id = ACPI_ALLOCATE_ZEROED(strlen (uid) + 1);
+		if (device->pnp.unique_id) {
+			strcpy(device->pnp.unique_id, uid);
+			device->flags.unique_id = 1;
+		}
+	} else
+		device->pnp.unique_id = NULL;
+
 	if (cid_list || cid_add) {
-		struct  acpi_compatible_id_list *list;
-		int size = 0;
-		int count = 0;
-
-		if (cid_list) {
-			size = cid_list->size;
-		} else if (cid_add) {
-			size = sizeof(struct acpi_compatible_id_list);
-			cid_list = ACPI_ALLOCATE_ZEROED((acpi_size) size);
-			if (!cid_list) {
-				printk(KERN_ERR "Memory allocation error\n");
-				kfree(buffer.pointer);
-				return;
-			} else {
-				cid_list->count = 0;
-				cid_list->size = size;
-			}
+		struct acpica_device_id_list *list;
+
+		if (cid_add) {
+			struct acpica_device_id cid;
+			cid.length = strlen (cid_add) + 1;
+			cid.string = cid_add;
+
+			list = acpi_add_cid(info, &cid);
+		} else {
+			list = acpi_add_cid(info, NULL);
 		}
-		if (cid_add)
-			size += sizeof(struct acpi_compatible_id);
-		list = kmalloc(size, GFP_KERNEL);
 
 		if (list) {
-			if (cid_list) {
-				memcpy(list, cid_list, cid_list->size);
-				count = cid_list->count;
-			}
-			if (cid_add) {
-				strncpy(list->id[count].value, cid_add,
-					ACPI_MAX_CID_LENGTH);
-				count++;
-				device->flags.compatible_ids = 1;
-			}
-			list->size = size;
-			list->count = count;
 			device->pnp.cid_list = list;
-		} else
-			printk(KERN_ERR PREFIX "Memory allocation error\n");
+			if (cid_add)
+				device->flags.compatible_ids = 1;
+		}
 	}
 
-	kfree(buffer.pointer);
+	kfree(info);
 }
 
 static int acpi_device_set_context(struct acpi_device *device, int type)

commit dcf52fb71d988ba945054308f661bddf9b2455fb
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Jun 22 20:41:45 2009 +0000

    ACPI: remove unused acpi_device_ops .stop method
    
    No drivers use the .stop method, so remove it.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Reviewed-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 781435d7e369..4a89f081160f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -426,9 +426,6 @@ static int acpi_device_probe(struct device * dev)
 		if (acpi_drv->ops.notify) {
 			ret = acpi_device_install_notify_handler(acpi_dev);
 			if (ret) {
-				if (acpi_drv->ops.stop)
-					acpi_drv->ops.stop(acpi_dev,
-						   acpi_dev->removal_type);
 				if (acpi_drv->ops.remove)
 					acpi_drv->ops.remove(acpi_dev,
 						     acpi_dev->removal_type);
@@ -452,8 +449,6 @@ static int acpi_device_remove(struct device * dev)
 	if (acpi_drv) {
 		if (acpi_drv->ops.notify)
 			acpi_device_remove_notify_handler(acpi_dev);
-		if (acpi_drv->ops.stop)
-			acpi_drv->ops.stop(acpi_dev, acpi_dev->removal_type);
 		if (acpi_drv->ops.remove)
 			acpi_drv->ops.remove(acpi_dev, acpi_dev->removal_type);
 	}

commit fbe8cddd2d85979d273d7937a2b8a47498694d91
Merge: 4e8a2372f925 e86435eb91b2 7fe2a6c275a5 0705495d9010 35a7c64fbc77 152a4e630f7f 86e437f077c6 c8d72a5e7698 7a04b8491a07 ee1ca48fae7e 9eccbc2f67ef 7e275cc4e8e2 7b768f07dce4 8cb24c8fd70e 113b3a2b9015 d73772474f6e 056c308d3e48 871043bc463e
Author: Len Brown <len.brown@intel.com>
Date:   Wed Jun 24 01:19:50 2009 -0400

    Merge branches 'acerhdf', 'acpi-pci-bind', 'bjorn-pci-root', 'bugzilla-12904', 'bugzilla-13121', 'bugzilla-13396', 'bugzilla-13533', 'bugzilla-13612', 'c3_lock', 'hid-cleanups', 'misc-2.6.31', 'pdc-leak-fix', 'pnpacpi', 'power_nocheck', 'thinkpad_acpi', 'video' and 'wmi' into release

commit c8d72a5e76988140bfdfd8722f2228d94e7fa10f
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Mon Jun 22 11:31:16 2009 +0800

    ACPI: run ACPI device hot removal in kacpi_hotplug_wq
    
    Now that new interface is available,
    convert to using it rather than creating a new kernel thread.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8ff510b91d88..9c6e42e7cd13 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -95,7 +95,7 @@ acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, cha
 }
 static DEVICE_ATTR(modalias, 0444, acpi_device_modalias_show, NULL);
 
-static int acpi_bus_hot_remove_device(void *context)
+static void acpi_bus_hot_remove_device(void *context)
 {
 	struct acpi_device *device;
 	acpi_handle handle = context;
@@ -104,10 +104,10 @@ static int acpi_bus_hot_remove_device(void *context)
 	acpi_status status = AE_OK;
 
 	if (acpi_bus_get_device(handle, &device))
-		return 0;
+		return;
 
 	if (!device)
-		return 0;
+		return;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 		"Hot-removing device %s...\n", dev_name(&device->dev)));
@@ -115,7 +115,7 @@ static int acpi_bus_hot_remove_device(void *context)
 	if (acpi_bus_trim(device, 1)) {
 		printk(KERN_ERR PREFIX
 				"Removing device failed\n");
-		return -1;
+		return;
 	}
 
 	/* power off device */
@@ -142,9 +142,10 @@ static int acpi_bus_hot_remove_device(void *context)
 	 */
 	status = acpi_evaluate_object(handle, "_EJ0", &arg_list, NULL);
 	if (ACPI_FAILURE(status))
-		return -ENODEV;
+		printk(KERN_WARNING PREFIX
+				"Eject device failed\n");
 
-	return 0;
+	return;
 }
 
 static ssize_t
@@ -155,7 +156,6 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 	acpi_status status;
 	acpi_object_type type = 0;
 	struct acpi_device *acpi_device = to_acpi_device(d);
-	struct task_struct *task;
 
 	if ((!count) || (buf[0] != '1')) {
 		return -EINVAL;
@@ -172,11 +172,7 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 		goto err;
 	}
 
-	/* remove the device in another thread to fix the deadlock issue */
-	task = kthread_run(acpi_bus_hot_remove_device,
-				acpi_device->handle, "acpi_hot_remove_device");
-	if (IS_ERR(task))
-		ret = PTR_ERR(task);
+	acpi_os_hotplug_execute(acpi_bus_hot_remove_device, acpi_device->handle);
 err:
 	return ret;
 }

commit 0c526d96a5bd86c70507b7d9372e6a26a1e3ea43
Author: Alex Chiang <achiang@hp.com>
Date:   Thu May 14 08:31:37 2009 -0600

    ACPI: clean up whitespace in drivers/acpi/scan.c
    
    Align labels in column 0, adjust spacing in 'if' statements, eliminate
    trailing and superfluous whitespaces.
    
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b8f5c005fbb5..c40515e86187 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -198,12 +198,12 @@ acpi_device_path_show(struct device *dev, struct device_attribute *attr, char *b
 	int result;
 
 	result = acpi_get_name(acpi_dev->handle, ACPI_FULL_PATHNAME, &path);
-	if(result)
+	if (result)
 		goto end;
 
 	result = sprintf(buf, "%s\n", (char*)path.pointer);
 	kfree(path.pointer);
-  end:
+end:
 	return result;
 }
 static DEVICE_ATTR(path, 0444, acpi_device_path_show, NULL);
@@ -217,21 +217,21 @@ static int acpi_device_setup_files(struct acpi_device *dev)
 	/*
 	 * Devices gotten from FADT don't have a "path" attribute
 	 */
-	if(dev->handle) {
+	if (dev->handle) {
 		result = device_create_file(&dev->dev, &dev_attr_path);
-		if(result)
+		if (result)
 			goto end;
 	}
 
-	if(dev->flags.hardware_id) {
+	if (dev->flags.hardware_id) {
 		result = device_create_file(&dev->dev, &dev_attr_hid);
-		if(result)
+		if (result)
 			goto end;
 	}
 
-	if (dev->flags.hardware_id || dev->flags.compatible_ids){
+	if (dev->flags.hardware_id || dev->flags.compatible_ids) {
 		result = device_create_file(&dev->dev, &dev_attr_modalias);
-		if(result)
+		if (result)
 			goto end;
 	}
 
@@ -242,7 +242,7 @@ static int acpi_device_setup_files(struct acpi_device *dev)
 	status = acpi_get_handle(dev->handle, "_EJ0", &temp);
 	if (ACPI_SUCCESS(status))
 		result = device_create_file(&dev->dev, &dev_attr_eject);
-  end:
+end:
 	return result;
 }
 
@@ -262,9 +262,9 @@ static void acpi_device_remove_files(struct acpi_device *dev)
 	if (dev->flags.hardware_id || dev->flags.compatible_ids)
 		device_remove_file(&dev->dev, &dev_attr_modalias);
 
-	if(dev->flags.hardware_id)
+	if (dev->flags.hardware_id)
 		device_remove_file(&dev->dev, &dev_attr_hid);
-	if(dev->handle)
+	if (dev->handle)
 		device_remove_file(&dev->dev, &dev_attr_path);
 }
 /* --------------------------------------------------------------------------
@@ -512,7 +512,7 @@ static int acpi_device_register(struct acpi_device *device,
 			break;
 		}
 	}
-	if(!found) {
+	if (!found) {
 		acpi_device_bus_id = new_bus_id;
 		strcpy(acpi_device_bus_id->bus_id, device->flags.hardware_id ? device->pnp.hardware_id : "device");
 		acpi_device_bus_id->instance_no = 0;
@@ -532,19 +532,19 @@ static int acpi_device_register(struct acpi_device *device,
 	device->dev.bus = &acpi_bus_type;
 	device->dev.release = &acpi_device_release;
 	result = device_register(&device->dev);
-	if(result) {
+	if (result) {
 		dev_err(&device->dev, "Error registering device\n");
 		goto end;
 	}
 
 	result = acpi_device_setup_files(device);
-	if(result)
+	if (result)
 		printk(KERN_ERR PREFIX "Error creating sysfs interface for device %s\n",
 		       dev_name(&device->dev));
 
 	device->removal_type = ACPI_BUS_REMOVAL_NORMAL;
 	return 0;
-  end:
+end:
 	mutex_lock(&acpi_device_lock);
 	if (device->parent)
 		list_del(&device->node);
@@ -576,7 +576,7 @@ static void acpi_device_unregister(struct acpi_device *device, int type)
  * @device: the device to add and initialize
  * @driver: driver for the device
  *
- * Used to initialize a device via its device driver.  Called whenever a 
+ * Used to initialize a device via its device driver.  Called whenever a
  * driver is bound to a device.  Invokes the driver's add() ops.
  */
 static int
@@ -584,7 +584,6 @@ acpi_bus_driver_init(struct acpi_device *device, struct acpi_driver *driver)
 {
 	int result = 0;
 
-
 	if (!device || !driver)
 		return -EINVAL;
 
@@ -801,7 +800,7 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	if (!acpi_match_device_ids(device, button_device_ids))
 		device->wakeup.flags.run_wake = 1;
 
-      end:
+end:
 	if (ACPI_FAILURE(status))
 		device->flags.wake_capable = 0;
 	return 0;
@@ -1069,7 +1068,7 @@ static void acpi_device_set_id(struct acpi_device *device,
 		break;
 	}
 
-	/* 
+	/*
 	 * \_SB
 	 * ----
 	 * Fix for the system root bus device -- the only root-level device.
@@ -1319,7 +1318,7 @@ acpi_add_single_object(struct acpi_device **child,
 			device->parent->ops.bind(device);
 	}
 
-      end:
+end:
 	if (!result)
 		*child = device;
 	else {
@@ -1463,7 +1462,6 @@ acpi_bus_add(struct acpi_device **child,
 
 	return result;
 }
-
 EXPORT_SYMBOL(acpi_bus_add);
 
 int acpi_bus_start(struct acpi_device *device)
@@ -1483,7 +1481,6 @@ int acpi_bus_start(struct acpi_device *device)
 	}
 	return result;
 }
-
 EXPORT_SYMBOL(acpi_bus_start);
 
 int acpi_bus_trim(struct acpi_device *start, int rmdevice)
@@ -1541,7 +1538,6 @@ int acpi_bus_trim(struct acpi_device *start, int rmdevice)
 }
 EXPORT_SYMBOL_GPL(acpi_bus_trim);
 
-
 static int acpi_bus_scan_fixed(struct acpi_device *root)
 {
 	int result = 0;
@@ -1609,6 +1605,6 @@ int __init acpi_scan_init(void)
 	if (result)
 		acpi_device_unregister(acpi_root, ACPI_BUS_REMOVAL_NORMAL);
 
-      Done:
+Done:
 	return result;
 }

commit 8b12b922ed5b9b6bfc345d3d6c6de56b2982af7f
Author: Alex Chiang <achiang@hp.com>
Date:   Thu May 14 08:31:32 2009 -0600

    ACPI: acpi_device_register() should call device_register()
    
    There is no apparent reason for acpi_device_register() to manually
    register a new device in two steps (initialize then add).
    
    Just call device_register() directly.
    
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8ff510b91d88..b8f5c005fbb5 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -530,11 +530,10 @@ static int acpi_device_register(struct acpi_device *device,
 	if (device->parent)
 		device->dev.parent = &parent->dev;
 	device->dev.bus = &acpi_bus_type;
-	device_initialize(&device->dev);
 	device->dev.release = &acpi_device_release;
-	result = device_add(&device->dev);
+	result = device_register(&device->dev);
 	if(result) {
-		dev_err(&device->dev, "Error adding device\n");
+		dev_err(&device->dev, "Error registering device\n");
 		goto end;
 	}
 

commit 33b571501553ceb008c0aef8b89e932d4efda2a2
Author: Len Brown <len.brown@intel.com>
Date:   Mon Dec 15 22:09:26 2008 -0500

    ACPI: delete acpi_device.g_list
    
    unused
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e63f2febad84..8ff510b91d88 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -491,7 +491,6 @@ static int acpi_device_register(struct acpi_device *device,
 	 */
 	INIT_LIST_HEAD(&device->children);
 	INIT_LIST_HEAD(&device->node);
-	INIT_LIST_HEAD(&device->g_list);
 	INIT_LIST_HEAD(&device->wakeup_list);
 
 	new_bus_id = kzalloc(sizeof(struct acpi_device_bus_id), GFP_KERNEL);
@@ -521,11 +520,9 @@ static int acpi_device_register(struct acpi_device *device,
 	}
 	dev_set_name(&device->dev, "%s:%02x", acpi_device_bus_id->bus_id, acpi_device_bus_id->instance_no);
 
-	if (device->parent) {
+	if (device->parent)
 		list_add_tail(&device->node, &device->parent->children);
-		list_add_tail(&device->g_list, &device->parent->g_list);
-	} else
-		list_add_tail(&device->g_list, &acpi_device_list);
+
 	if (device->wakeup.flags.valid)
 		list_add_tail(&device->wakeup_list, &acpi_wakeup_device_list);
 	mutex_unlock(&acpi_device_lock);
@@ -550,11 +547,8 @@ static int acpi_device_register(struct acpi_device *device,
 	return 0;
   end:
 	mutex_lock(&acpi_device_lock);
-	if (device->parent) {
+	if (device->parent)
 		list_del(&device->node);
-		list_del(&device->g_list);
-	} else
-		list_del(&device->g_list);
 	list_del(&device->wakeup_list);
 	mutex_unlock(&acpi_device_lock);
 	return result;
@@ -563,11 +557,8 @@ static int acpi_device_register(struct acpi_device *device,
 static void acpi_device_unregister(struct acpi_device *device, int type)
 {
 	mutex_lock(&acpi_device_lock);
-	if (device->parent) {
+	if (device->parent)
 		list_del(&device->node);
-		list_del(&device->g_list);
-	} else
-		list_del(&device->g_list);
 
 	list_del(&device->wakeup_list);
 	mutex_unlock(&acpi_device_lock);

commit 9090589d87506c578ea1523ffd7ae7fd9424fb28
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Tue Apr 7 10:24:29 2009 +0800

    ACPI: convert acpi_device_lock spinlock to mutex
    
    Convert acpi_device_lock to a mutex to avoid
    a potential race upon access to /proc/acpi/wakeup
    
    Delete the lock entirely in wakeup.c
    since it is not necessary (and can not sleep)
    
    Found-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 20c23c049207..e63f2febad84 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -24,7 +24,7 @@ extern struct acpi_device *acpi_root;
 
 static LIST_HEAD(acpi_device_list);
 static LIST_HEAD(acpi_bus_id_list);
-DEFINE_SPINLOCK(acpi_device_lock);
+DEFINE_MUTEX(acpi_device_lock);
 LIST_HEAD(acpi_wakeup_device_list);
 
 struct acpi_device_bus_id{
@@ -500,7 +500,7 @@ static int acpi_device_register(struct acpi_device *device,
 		return -ENOMEM;
 	}
 
-	spin_lock(&acpi_device_lock);
+	mutex_lock(&acpi_device_lock);
 	/*
 	 * Find suitable bus_id and instance number in acpi_bus_id_list
 	 * If failed, create one and link it into acpi_bus_id_list
@@ -528,7 +528,7 @@ static int acpi_device_register(struct acpi_device *device,
 		list_add_tail(&device->g_list, &acpi_device_list);
 	if (device->wakeup.flags.valid)
 		list_add_tail(&device->wakeup_list, &acpi_wakeup_device_list);
-	spin_unlock(&acpi_device_lock);
+	mutex_unlock(&acpi_device_lock);
 
 	if (device->parent)
 		device->dev.parent = &parent->dev;
@@ -549,20 +549,20 @@ static int acpi_device_register(struct acpi_device *device,
 	device->removal_type = ACPI_BUS_REMOVAL_NORMAL;
 	return 0;
   end:
-	spin_lock(&acpi_device_lock);
+	mutex_lock(&acpi_device_lock);
 	if (device->parent) {
 		list_del(&device->node);
 		list_del(&device->g_list);
 	} else
 		list_del(&device->g_list);
 	list_del(&device->wakeup_list);
-	spin_unlock(&acpi_device_lock);
+	mutex_unlock(&acpi_device_lock);
 	return result;
 }
 
 static void acpi_device_unregister(struct acpi_device *device, int type)
 {
-	spin_lock(&acpi_device_lock);
+	mutex_lock(&acpi_device_lock);
 	if (device->parent) {
 		list_del(&device->node);
 		list_del(&device->g_list);
@@ -570,7 +570,7 @@ static void acpi_device_unregister(struct acpi_device *device, int type)
 		list_del(&device->g_list);
 
 	list_del(&device->wakeup_list);
-	spin_unlock(&acpi_device_lock);
+	mutex_unlock(&acpi_device_lock);
 
 	acpi_detach_data(device->handle, acpi_bus_data_handler);
 

commit 46ec8598fde74ba59703575c22a6fb0b6b151bb6
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Mar 30 17:48:13 2009 +0000

    ACPI: support acpi_device_ops .notify methods
    
    This patch adds support for ACPI device driver .notify() methods.  If
    such a method is present, Linux/ACPI installs a handler for device
    notifications (but not for system notifications such as Bus Check,
    Device Check, etc).  When a device notification occurs, Linux/ACPI
    passes it on to the driver's .notify() method.
    
    In most cases, this removes the need for drivers to install their own
    handlers for device-specific notifications.
    
    For fixed hardware devices like some power and sleep buttons, there's
    no notification value because there's no control method to execute a
    Notify opcode.  When a fixed hardware device generates an event, we
    handle it the same as a regular device notification, except we send
    a ACPI_FIXED_HARDWARE_EVENT value.  This is outside the normal 0x0-0xff
    range used by Notify opcodes.
    
    Several drivers install their own handlers for system Bus Check and
    Device Check notifications so they can support hot-plug.  This patch
    doesn't affect that usage.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Reviewed-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b7308efce458..20c23c049207 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -359,6 +359,61 @@ static int acpi_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return 0;
 }
 
+static void acpi_device_notify(acpi_handle handle, u32 event, void *data)
+{
+	struct acpi_device *device = data;
+
+	device->driver->ops.notify(device, event);
+}
+
+static acpi_status acpi_device_notify_fixed(void *data)
+{
+	struct acpi_device *device = data;
+
+	acpi_device_notify(device->handle, ACPI_FIXED_HARDWARE_EVENT, device);
+	return AE_OK;
+}
+
+static int acpi_device_install_notify_handler(struct acpi_device *device)
+{
+	acpi_status status;
+	char *hid;
+
+	hid = acpi_device_hid(device);
+	if (!strcmp(hid, ACPI_BUTTON_HID_POWERF))
+		status =
+		    acpi_install_fixed_event_handler(ACPI_EVENT_POWER_BUTTON,
+						     acpi_device_notify_fixed,
+						     device);
+	else if (!strcmp(hid, ACPI_BUTTON_HID_SLEEPF))
+		status =
+		    acpi_install_fixed_event_handler(ACPI_EVENT_SLEEP_BUTTON,
+						     acpi_device_notify_fixed,
+						     device);
+	else
+		status = acpi_install_notify_handler(device->handle,
+						     ACPI_DEVICE_NOTIFY,
+						     acpi_device_notify,
+						     device);
+
+	if (ACPI_FAILURE(status))
+		return -EINVAL;
+	return 0;
+}
+
+static void acpi_device_remove_notify_handler(struct acpi_device *device)
+{
+	if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_POWERF))
+		acpi_remove_fixed_event_handler(ACPI_EVENT_POWER_BUTTON,
+						acpi_device_notify_fixed);
+	else if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_SLEEPF))
+		acpi_remove_fixed_event_handler(ACPI_EVENT_SLEEP_BUTTON,
+						acpi_device_notify_fixed);
+	else
+		acpi_remove_notify_handler(device->handle, ACPI_DEVICE_NOTIFY,
+					   acpi_device_notify);
+}
+
 static int acpi_bus_driver_init(struct acpi_device *, struct acpi_driver *);
 static int acpi_start_single_object(struct acpi_device *);
 static int acpi_device_probe(struct device * dev)
@@ -371,6 +426,20 @@ static int acpi_device_probe(struct device * dev)
 	if (!ret) {
 		if (acpi_dev->bus_ops.acpi_op_start)
 			acpi_start_single_object(acpi_dev);
+
+		if (acpi_drv->ops.notify) {
+			ret = acpi_device_install_notify_handler(acpi_dev);
+			if (ret) {
+				if (acpi_drv->ops.stop)
+					acpi_drv->ops.stop(acpi_dev,
+						   acpi_dev->removal_type);
+				if (acpi_drv->ops.remove)
+					acpi_drv->ops.remove(acpi_dev,
+						     acpi_dev->removal_type);
+				return ret;
+			}
+		}
+
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			"Found driver [%s] for device [%s]\n",
 			acpi_drv->name, acpi_dev->pnp.bus_id));
@@ -385,6 +454,8 @@ static int acpi_device_remove(struct device * dev)
 	struct acpi_driver *acpi_drv = acpi_dev->driver;
 
 	if (acpi_drv) {
+		if (acpi_drv->ops.notify)
+			acpi_device_remove_notify_handler(acpi_dev);
 		if (acpi_drv->ops.stop)
 			acpi_drv->ops.stop(acpi_dev, acpi_dev->removal_type);
 		if (acpi_drv->ops.remove)

commit 493837009665a5ea1d91ed5fe4bab0ed546cae86
Merge: e857b33d1879 8308e8ab70fd
Author: Len Brown <len.brown@intel.com>
Date:   Sun Apr 5 01:38:51 2009 -0400

    Merge branch 'driver-ops-cleanup' into release

commit c0ce093f5b8bc3262c51bd0b5900424a67909831
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 24 10:55:27 2009 -0600

    ACPI: remove unused acpi_device_ops .shutdown method
    
    No drivers use the .shutdown method, so remove it.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c54d7b6c4066..4a6c7ee834ff 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -395,22 +395,10 @@ static int acpi_device_remove(struct device * dev)
 	return 0;
 }
 
-static void acpi_device_shutdown(struct device *dev)
-{
-	struct acpi_device *acpi_dev = to_acpi_device(dev);
-	struct acpi_driver *acpi_drv = acpi_dev->driver;
-
-	if (acpi_drv && acpi_drv->ops.shutdown)
-		acpi_drv->ops.shutdown(acpi_dev);
-
-	return ;
-}
-
 struct bus_type acpi_bus_type = {
 	.name		= "acpi",
 	.suspend	= acpi_device_suspend,
 	.resume		= acpi_device_resume,
-	.shutdown	= acpi_device_shutdown,
 	.match		= acpi_bus_match,
 	.probe		= acpi_device_probe,
 	.remove		= acpi_device_remove,

commit e747f274951507b5a0850155c3d709e26d20de5b
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 24 16:49:43 2009 -0600

    ACPI: call acpi_scan_init() explicitly rather than as initcall
    
    This patch makes acpi_init() call acpi_scan_init() directly.
    
    Previously, both acpi_init() and acpi_scan_init() were subsys_initcalls,
    and acpi_init() was called first based on the link order from the
    makefile (bus.o before scan.o).
    
    acpi_scan_init() registers the ACPI bus type, creates the root device,
    and enumerates fixed-feature and namespace devices.  All of this must
    be done after acpi_init(), and it's better to call acpi_scan_init()
    explicitly rather than rely on the link ordering.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 2f04cd1147e9..c548231965ef 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1526,16 +1526,11 @@ static int acpi_bus_scan_fixed(struct acpi_device *root)
 	return result;
 }
 
-
-static int __init acpi_scan_init(void)
+int __init acpi_scan_init(void)
 {
 	int result;
 	struct acpi_bus_ops ops;
 
-
-	if (acpi_disabled)
-		return 0;
-
 	memset(&ops, 0, sizeof(ops));
 	ops.acpi_op_add = 1;
 	ops.acpi_op_start = 1;
@@ -1568,5 +1563,3 @@ static int __init acpi_scan_init(void)
       Done:
 	return result;
 }
-
-subsys_initcall(acpi_scan_init);

commit e60cc7a6f02598fc23c68a656fe9c263d6531ca0
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Mar 13 12:08:26 2009 -0600

    ACPI: move private declarations to internal.h
    
    A number of things that shouldn't be exposed outside the ACPI core
    were declared in include/acpi/acpi_drivers.h, where anybody can
    see them.  This patch moves those declarations to a new "internal.h"
    inside drivers/acpi.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c54d7b6c4066..2f04cd1147e9 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -11,6 +11,8 @@
 
 #include <acpi/acpi_drivers.h>
 
+#include "internal.h"
+
 #define _COMPONENT		ACPI_BUS_COMPONENT
 ACPI_MODULE_NAME("scan");
 #define STRUCT_TO_INT(s)	(*((int*)&s))

commit ea7e96e0f2277107d9ea14c3f16c86ba82b2e560
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Tue Dec 16 16:28:17 2008 +0800

    ACPI: remove private acpica headers from driver files
    
    External driver files should not include any private acpica headers.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 39b7233c3485..c54d7b6c4066 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -10,7 +10,6 @@
 #include <linux/kthread.h>
 
 #include <acpi/acpi_drivers.h>
-#include <acpi/acinterp.h>	/* for acpi_ex_eisa_id_to_string() */
 
 #define _COMPONENT		ACPI_BUS_COMPONENT
 ACPI_MODULE_NAME("scan");

commit 3bdca1b863c1ebcb2244fc0cb683876d7330e62b
Author: Len Brown <len.brown@intel.com>
Date:   Wed Nov 26 17:55:15 2008 -0500

    Revert "ACPI: don't enable control method power button as wakeup device when Fixed Power button is used"
    
    This reverts commit faee816b1502385dc9bc5abf2960d1cc645844d1.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=12091
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index bd5253ee5c85..39b7233c3485 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -751,16 +751,6 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	if (!acpi_match_device_ids(device, button_device_ids))
 		device->wakeup.flags.run_wake = 1;
 
-	/*
-	 * Don't set Power button GPE as run_wake
-	 * if Fixed Power button is used
-	 */
-	if (!strcmp(device->pnp.hardware_id, "PNP0C0C") &&
-		!(acpi_gbl_FADT.flags & ACPI_FADT_POWER_BUTTON)) {
-		device->wakeup.flags.run_wake = 0;
-		device->wakeup.flags.valid = 0;
-	}
-
       end:
 	if (ACPI_FAILURE(status))
 		device->flags.wake_capable = 0;

commit 547f7847472c097a54adf38e6576f95ab512e27c
Merge: f398778aa336 5b53ed69158e
Author: Len Brown <len.brown@intel.com>
Date:   Tue Nov 11 21:17:03 2008 -0500

    Merge branch 'processor-256' into release

commit f398778aa336a2919ee04ba45d915007230c6957
Merge: 9b5a56ddfd61 2dba1b5d87e0
Author: Len Brown <len.brown@intel.com>
Date:   Tue Nov 11 21:15:50 2008 -0500

    Merge branch 'video' into release
    
    Conflicts:
            Documentation/kernel-parameters.txt
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit c3d6de698c84efdbdd3781b7058bcc339ab43da8
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Aug 1 17:37:55 2008 +0200

    ACPI video: if no ACPI backlight support, use vendor drivers
    
    If an ACPI graphics device supports backlight brightness functions (cmp. with
    latest ACPI spec Appendix B), let the ACPI video driver control backlight and
    switch backlight control off in vendor specific ACPI drivers (asus_acpi,
    thinkpad_acpi, eeepc, fujitsu_laptop, msi_laptop, sony_laptop, acer-wmi).
    
    Currently it is possible to load above drivers and let both poke on the
    brightness HW registers, the video and vendor specific ACPI drivers -> bad.
    
    This patch provides the basic support to check for BIOS capabilities before
    driver loading time. Driver specific modifications are in separate follow up
    patches.
    
    "acpi_backlight=vendor"
            Prever vendor driver over ACPI driver for backlight.
    "acpi_backlight=video" (default)
            Prever ACPI driver over vendor driver for backlight.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a9dda8e0f9f9..556b182001ca 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -919,36 +919,6 @@ static void acpi_device_get_busid(struct acpi_device *device,
 	}
 }
 
-static int
-acpi_video_bus_match(struct acpi_device *device)
-{
-	acpi_handle h_dummy;
-
-	if (!device)
-		return -EINVAL;
-
-	/* Since there is no HID, CID for ACPI Video drivers, we have
-	 * to check well known required nodes for each feature we support.
-	 */
-
-	/* Does this device able to support video switching ? */
-	if (ACPI_SUCCESS(acpi_get_handle(device->handle, "_DOD", &h_dummy)) &&
-	    ACPI_SUCCESS(acpi_get_handle(device->handle, "_DOS", &h_dummy)))
-		return 0;
-
-	/* Does this device able to retrieve a video ROM ? */
-	if (ACPI_SUCCESS(acpi_get_handle(device->handle, "_ROM", &h_dummy)))
-		return 0;
-
-	/* Does this device able to configure which video head to be POSTed ? */
-	if (ACPI_SUCCESS(acpi_get_handle(device->handle, "_VPO", &h_dummy)) &&
-	    ACPI_SUCCESS(acpi_get_handle(device->handle, "_GPD", &h_dummy)) &&
-	    ACPI_SUCCESS(acpi_get_handle(device->handle, "_SPD", &h_dummy)))
-		return 0;
-
-	return -ENODEV;
-}
-
 /*
  * acpi_bay_match - see if a device is an ejectable driver bay
  *
@@ -1031,7 +1001,7 @@ static void acpi_device_set_id(struct acpi_device *device,
 		   will get autoloaded and the device might still match
 		   against another driver.
 		*/
-		if (ACPI_SUCCESS(acpi_video_bus_match(device)))
+		if (acpi_is_video_device(device))
 			cid_add = ACPI_VIDEO_HID;
 		else if (ACPI_SUCCESS(acpi_bay_match(device)))
 			cid_add = ACPI_BAY_HID;

commit 0794469da3f7b2093575cbdfc1108308dd3641ce
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Oct 30 01:18:59 2008 +0100

    ACPI: struct device - replace bus_id with dev_name(), dev_set_name()
    
    This patch is part of a larger patch series which will remove
    the "char bus_id[20]" name string from struct device. The device
    name is managed in the kobject anyway, and without any size
    limitation, and just needlessly copied into "struct device".
    
    To set and read the device name dev_name(dev) and dev_set_name(dev)
    must be used. If your code uses static kobjects, which it shouldn't
    do, "const char *init_name" can be used to statically provide the
    name the registered device should have. At registration time, the
    init_name field is cleared, to enforce the use of dev_name(dev) to
    access the device name at a later time.
    
    We need to get rid of all occurrences of bus_id in the entire tree
    to be able to enable the new interface. Please apply this patch,
    and possibly convert any remaining remaining occurrences of bus_id.
    
    We want to submit a patch to -next, which will remove bus_id from
    "struct device", to find the remaining pieces to convert, and finally
    switch over to the new api, which will remove the 20 bytes array
    and does no longer have a size limitation.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-Off-By: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a9dda8e0f9f9..4dd1f31930b8 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -109,8 +109,7 @@ static int acpi_bus_hot_remove_device(void *context)
 		return 0;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-		"Hot-removing device %s...\n", device->dev.bus_id));
-
+		"Hot-removing device %s...\n", dev_name(&device->dev)));
 
 	if (acpi_bus_trim(device, 1)) {
 		printk(KERN_ERR PREFIX
@@ -460,7 +459,7 @@ static int acpi_device_register(struct acpi_device *device,
 		acpi_device_bus_id->instance_no = 0;
 		list_add_tail(&acpi_device_bus_id->node, &acpi_bus_id_list);
 	}
-	sprintf(device->dev.bus_id, "%s:%02x", acpi_device_bus_id->bus_id, acpi_device_bus_id->instance_no);
+	dev_set_name(&device->dev, "%s:%02x", acpi_device_bus_id->bus_id, acpi_device_bus_id->instance_no);
 
 	if (device->parent) {
 		list_add_tail(&device->node, &device->parent->children);
@@ -484,7 +483,8 @@ static int acpi_device_register(struct acpi_device *device,
 
 	result = acpi_device_setup_files(device);
 	if(result)
-		printk(KERN_ERR PREFIX "Error creating sysfs interface for device %s\n", device->dev.bus_id);
+		printk(KERN_ERR PREFIX "Error creating sysfs interface for device %s\n",
+		       dev_name(&device->dev));
 
 	device->removal_type = ACPI_BUS_REMOVAL_NORMAL;
 	return 0;

commit ad93a765c1834db031b5bf1c2baf2a50d0462ca4
Author: Myron Stowe <myron.stowe@hp.com>
Date:   Tue Nov 4 14:52:55 2008 -0700

    ACPI: Disambiguate processor declaration type
    
    Declaring processors in ACPI namespace can be done using either a
    "Processor" definition or a "Device" definition (see section 8.4 -
    Declaring Processors; "Advanced Configuration and Power Interface
    Specification", Revision 3.0b).  Currently the two processor
    declaration types are conflated.
    
    This patch disambiguates the processor declaration's definition type
    enabling subsequent code to behave uniquely based explicitly on the
    declaration's type.
    
    Signed-off-by: Myron Stowe <myron.stowe@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a9dda8e0f9f9..3fb6e2db585a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1043,7 +1043,7 @@ static void acpi_device_set_id(struct acpi_device *device,
 		hid = ACPI_POWER_HID;
 		break;
 	case ACPI_BUS_TYPE_PROCESSOR:
-		hid = ACPI_PROCESSOR_HID;
+		hid = ACPI_PROCESSOR_OBJECT_HID;
 		break;
 	case ACPI_BUS_TYPE_SYSTEM:
 		hid = ACPI_SYSTEM_HID;

commit 5f50ef453dcb05115fc98f244b8f10bfacd4b8b7
Merge: 530bc23bfeaa e3deda9c87ac
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:28:38 2008 -0400

    Merge branch 'misc' into test

commit 0fbb3726f246aadd1bebc01114100b6e69afa5b9
Merge: 47bf31adc541 c0ff17720ec5
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:27:59 2008 -0400

    Merge branch 'ec' into test

commit 462af435b3d8c682eb86e79d6a42ed62d183c317
Merge: 63e065e5d35b faee816b1502
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:20:01 2008 -0400

    Merge branch 'bugzilla-10503' into test

commit bcb631f31839cb7c7dd56ab534b6eb4867e9161b
Merge: 955ba395616a ed37a71eac8b
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:19:51 2008 -0400

    Merge branch 'acpica' into test

commit 55ac9a018f83e4f42f3c6ce98a8dbda73b985935
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Sun Sep 28 14:51:56 2008 +0800

    ACPI: replace ACPI_DEBUG_PRINT((ACPI_DB_ERROR, ...) with printk
    
    ACPI_DB_ERROR and ACPI_DB_WARN were removed from ACPICA core.
    So replace ACPI_DEBUG_PRINT((ACPI_DB_ERROR, ...) with printk(KERN_ERR PREFIX ...)
    and ACPI_DEBUG_PRINT((ACPI_DB_WARN, ...) with printk(KERN_WARNING PREFIX ...)
    
    We do not use ACPI_ERROR/ACPI_WARNING since they're not exported, see
    -------------------------------------------------------------
    commit 6468463abd7051fcc29f3ee7c931f9bbbb26f5a4
    Author: Len Brown <len.brown@intel.com>
    Date:   Mon Jun 26 23:41:38 2006 -0400
    
        ACPI: un-export ACPI_ERROR() -- use printk(KERN_ERR...)
    
        Signed-off-by: Len Brown <len.brown@intel.com>
    -------------------------------------------------------------
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f6f52c1a2aba..81d6095468f9 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -113,16 +113,16 @@ static int acpi_bus_hot_remove_device(void *context)
 
 
 	if (acpi_bus_trim(device, 1)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				"Removing device failed\n"));
+		printk(KERN_ERR PREFIX
+				"Removing device failed\n");
 		return -1;
 	}
 
 	/* power off device */
 	status = acpi_evaluate_object(handle, "_PS3", NULL, NULL);
 	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND)
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-				"Power-off device failed\n"));
+		printk(KERN_WARNING PREFIX
+				"Power-off device failed\n");
 
 	if (device->flags.lockable) {
 		arg_list.count = 1;
@@ -477,7 +477,7 @@ static int acpi_device_register(struct acpi_device *device,
 
 	result = acpi_device_setup_files(device);
 	if(result)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error creating sysfs interface for device %s\n", device->dev.bus_id));
+		printk(KERN_ERR PREFIX "Error creating sysfs interface for device %s\n", device->dev.bus_id);
 
 	device->removal_type = ACPI_BUS_REMOVAL_NORMAL;
 	return 0;

commit ea5c8af9b1241a10dc4ba6cd2d2362c179884b74
Author: Len Brown <len.brown@intel.com>
Date:   Sat Oct 11 01:13:12 2008 -0400

    ACPI: remove unused acpi_is_child_device()
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 89c112ef9e14..91fed422bae8 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1160,20 +1160,6 @@ static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 	return 0;
 }
 
-static int
-acpi_is_child_device(struct acpi_device *device,
-			int (*matcher)(struct acpi_device *))
-{
-	int result = -ENODEV;
-
-	do {
-		if (ACPI_SUCCESS(matcher(device)))
-			return AE_OK;
-	} while ((device = device->parent));
-
-	return result;
-}
-
 static int
 acpi_add_single_object(struct acpi_device **child,
 		       struct acpi_device *parent, acpi_handle handle, int type,

commit 39a0ad871000d2a016a4fa113a6e53d22aabf25d
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Mon Aug 11 13:40:22 2008 +0800

    ACPI : Load device driver according to the status of acpi device
    
    According to ACPI spec when the status of some device is not present
    but functional, the device is valid and the children of this device
    should be enumerated. It means that the device should be added to
    linux acpi device tree. But the device driver for this device should not
    be loaded.
        The detailed info can be found in the section 6.3.7 of ACPI 3.0b spec.
        _STA may return bit 0 clear (not present) with bit 3 set (device is
    functional). This case is used to indicate a valid device for which no
    device driver should be loaded (for example, a bridge device.).
    Children of this device may be present and valid. OS should continue
    enumeration below a device whose _STA returns this bit combination
    
    http://bugzilla.kernel.org/show_bug.cgi?id=3358
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index ad0679843bd5..89c112ef9e14 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -276,6 +276,13 @@ int acpi_match_device_ids(struct acpi_device *device,
 {
 	const struct acpi_device_id *id;
 
+	/*
+	 * If the device is not present, it is unnecessary to load device
+	 * driver for it.
+	 */
+	if (!device->status.present)
+		return -ENODEV;
+
 	if (device->flags.hardware_id) {
 		for (id = ids; id->id[0]; id++) {
 			if (!strcmp((char*)id->id, device->pnp.hardware_id))
@@ -1222,15 +1229,18 @@ acpi_add_single_object(struct acpi_device **child,
 			result = -ENODEV;
 			goto end;
 		}
-		if (!device->status.present) {
-			/* Bay and dock should be handled even if absent */
-			if (!ACPI_SUCCESS(
-			     acpi_is_child_device(device, acpi_bay_match)) &&
-			    !ACPI_SUCCESS(
-			     acpi_is_child_device(device, acpi_dock_match))) {
-					result = -ENODEV;
-					goto end;
-			}
+		/*
+		 * When the device is neither present nor functional, the
+		 * device should not be added to Linux ACPI device tree.
+		 * When the status of the device is not present but functinal,
+		 * it should be added to Linux ACPI tree. For example : bay
+		 * device , dock device.
+		 * In such conditions it is unncessary to check whether it is
+		 * bay device or dock device.
+		 */
+		if (!device->status.present && !device->status.functional) {
+			result = -ENODEV;
+			goto end;
 		}
 		break;
 	default:
@@ -1411,7 +1421,12 @@ static int acpi_bus_scan(struct acpi_device *start, struct acpi_bus_ops *ops)
 		 * TBD: Need notifications and other detection mechanisms
 		 *      in place before we can fully implement this.
 		 */
-		if (child->status.present) {
+		 /*
+		 * When the device is not present but functional, it is also
+		 * necessary to scan the children of this device.
+		 */
+		if (child->status.present || (!child->status.present &&
+					child->status.functional)) {
 			status = acpi_get_next_object(ACPI_TYPE_ANY, chandle,
 						      NULL, NULL);
 			if (ACPI_SUCCESS(status)) {

commit eab4b645769fa2f8703f5a3cb0cc4ac090d347af
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Mon Aug 11 14:54:16 2008 +0800

    ACPI: Attach the ACPI device to the ACPI handle as early as possible
    
    Attach the ACPI device to the ACPI handle as early as possible so that OS
    can get the corresponding ACPI device by the acpi handle in the course
    of getting the power/wakeup/performance flags.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=8049
    http://bugzilla.kernel.org/show_bug.cgi?id=11000
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 308ddb1c207c..ad0679843bd5 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1252,6 +1252,16 @@ acpi_add_single_object(struct acpi_device **child,
 	 */
 	acpi_device_set_id(device, parent, handle, type);
 
+	/*
+	 * The ACPI device is attached to acpi handle before getting
+	 * the power/wakeup/peformance flags. Otherwise OS can't get
+	 * the corresponding ACPI device by the acpi handle in the course
+	 * of getting the power/wakeup/performance flags.
+	 */
+	result = acpi_device_set_context(device, type);
+	if (result)
+		goto end;
+
 	/*
 	 * Power Management
 	 * ----------------
@@ -1282,8 +1292,6 @@ acpi_add_single_object(struct acpi_device **child,
 			goto end;
 	}
 
-	if ((result = acpi_device_set_context(device, type)))
-		goto end;
 
 	result = acpi_device_register(device, parent);
 

commit a51e145f379ae48003129610922595893e8efde0
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Mon Aug 11 14:55:05 2008 +0800

    ACPI: Get the device power state in the course of scanning device
    
    Get the device power state in the course of scanning device if the device
    power flag is power_managable. i.e. The device has the _PSx/_PRx object.
    
    At the same time before the drivers/acpi/power module is loaded, there is no
    relation between acpi_power_resource and acpi device. So the first parameter
    of acpi_power_get_state is changed to acpi_handle.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=8049
    http://bugzilla.kernel.org/show_bug.cgi?id=11000
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f6f52c1a2aba..308ddb1c207c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -807,6 +807,7 @@ static int acpi_bus_get_power_flags(struct acpi_device *device)
 	/* TBD: System wake support and resource requirements. */
 
 	device->power.state = ACPI_STATE_UNKNOWN;
+	acpi_bus_get_power(device->handle, &(device->power.state));
 
 	return 0;
 }

commit 455c8793d2c49eaecad038c8de83dade9fc3759f
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Mon Oct 6 10:31:36 2008 +0800

    ACPI: Enable EC device immediately after ACPI full initialization
    
    when there is no ECDT table and no _INI object for EC device, it will be
    enabled before scanning ACPI device. But it is too late after the following
    the commit is merged.
        >commit 7752d5cfe3d11ca0bb9c673ec38bd78ba6578f8e
        > Author: Robert Hancock <hancockr@shaw.ca>
        > Date:   Fri Feb 15 01:27:20 2008 -0800
           >x86: validate against acpi motherboard resources
    
       After the above commit is merged, OS will check whether MCFG area is
    reserved in ACPI motherboard resources by calling the function of
    acpi_get_devices when there exists MCFG table. In the acpi_get_devices the _STA
    object will be evaluated to check the status of the ACPI device. On some broken
    BIOS the MYEC object of EC device is initialized as one, which indicates that
    EC operation region is already accessible before enabling EC device.So on these
    broken BIOS the EC operation region will be accessed in course of evaluating
    the _STA object before enabling EC device, which causes that OS will print the
    following warning messages:
        >ACPI Error (evregion-0315): No handler for Region [EC__] (ffff88007f8145e8)
    [EmbeddedControl] [20080609]
        >ACPI Error (exfldio-0290): Region EmbeddedControl(3) has no handler [20080321]
        >ACPI Error (psparse-0530): Method parse/execution failed [\_SB_.PCI0.SBRG.
             EC__.BAT1._STA] (Node ffff81013fc17a00), AE_NOT_EXIST
        >ACPI Error (uteval-0233): Method execution failed [\_SB_.PCI0.SBRG.EC__.BAT1.
             _STA] (Node ffff81013fc17a00), AE_NOT_EXIST
    
    Although the above warning message is harmless, it looks confusing.
    So it is necessary to enable EC device as early as possible.Maybe it is
    appropriate to enable it immediately after ACPI full initialization.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=11255
    http://bugzilla.kernel.org/show_bug.cgi?id=11374
    http://bugzilla.kernel.org/show_bug.cgi?id=11660
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f6f52c1a2aba..2ae218f5ea59 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1545,7 +1545,6 @@ static int acpi_bus_scan_fixed(struct acpi_device *root)
 	return result;
 }
 
-int __init acpi_boot_ec_enable(void);
 
 static int __init acpi_scan_init(void)
 {
@@ -1579,9 +1578,6 @@ static int __init acpi_scan_init(void)
 	 */
 	result = acpi_bus_scan_fixed(acpi_root);
 
-	/* EC region might be needed at bus_scan, so enable it now */
-	acpi_boot_ec_enable();
-
 	if (!result)
 		result = acpi_bus_scan(acpi_root, &ops);
 

commit db89b4f0dbab837d0f3de2c3e9427a8d5393afa3
Author: Pavel Machek <pavel@suse.cz>
Date:   Mon Sep 22 14:37:34 2008 -0700

    ACPI: catch calls of acpi_driver_data on pointer of wrong type
    
    Catch attempts to use of acpi_driver_data on pointers of wrong type.
    
    akpm: rewritten to use proper C typechecking and remove the
    "function"-used-as-lvalue thing.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e7b8853c310b..b88536ab040a 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -384,7 +384,7 @@ static int acpi_device_remove(struct device * dev)
 			acpi_drv->ops.remove(acpi_dev, acpi_dev->removal_type);
 	}
 	acpi_dev->driver = NULL;
-	acpi_driver_data(acpi_dev) = NULL;
+	acpi_dev->driver_data = NULL;
 
 	put_device(dev);
 	return 0;
@@ -537,7 +537,7 @@ acpi_bus_driver_init(struct acpi_device *device, struct acpi_driver *driver)
 	result = driver->ops.add(device);
 	if (result) {
 		device->driver = NULL;
-		acpi_driver_data(device) = NULL;
+		device->driver_data = NULL;
 		return result;
 	}
 

commit 4b5fcb353ba46adfa2f98546e3d34e7dc65221cb
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Wed Sep 10 14:33:43 2008 +0400

    ACPI: acpi_driver_data could only be applied to acpi_device
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    CC: Hannes Reinecke <hare@suse.de>
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f6f52c1a2aba..e7b8853c310b 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -384,7 +384,7 @@ static int acpi_device_remove(struct device * dev)
 			acpi_drv->ops.remove(acpi_dev, acpi_dev->removal_type);
 	}
 	acpi_dev->driver = NULL;
-	acpi_driver_data(dev) = NULL;
+	acpi_driver_data(acpi_dev) = NULL;
 
 	put_device(dev);
 	return 0;

commit faee816b1502385dc9bc5abf2960d1cc645844d1
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri Sep 12 11:12:25 2008 +0800

    ACPI: don't enable control method power button as wakeup device when Fixed Power button is used
    
    don't enable control method power button as wakeup device
    when Fixed Power button is used.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=10503
    
    Tested-by: walken@zoy.org <walken@zoy.org>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f6f52c1a2aba..5ce14aee5e3f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -744,6 +744,16 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	if (!acpi_match_device_ids(device, button_device_ids))
 		device->wakeup.flags.run_wake = 1;
 
+	/*
+	 * Don't set Power button GPE as run_wake
+	 * if Fixed Power button is used
+	 */
+	if (!strcmp(device->pnp.hardware_id, "PNP0C0C") &&
+		!(acpi_gbl_FADT.flags & ACPI_FADT_POWER_BUTTON)) {
+		device->wakeup.flags.run_wake = 0;
+		device->wakeup.flags.valid = 0;
+	}
+
       end:
 	if (ACPI_FAILURE(status))
 		device->flags.wake_capable = 0;

commit fc3a8828b139c24aade3f9d608775e36c248f8f5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri May 2 06:02:41 2008 +0200

    driver core: fix a lot of printk usages of bus_id
    
    We have the dev_printk() variants for this kind of thing, use them
    instead of directly trying to access the bus_id field of struct device.
    
    This is done in order to remove bus_id entirely.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f3132aa47a69..f6f52c1a2aba 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -471,7 +471,7 @@ static int acpi_device_register(struct acpi_device *device,
 	device->dev.release = &acpi_device_release;
 	result = device_add(&device->dev);
 	if(result) {
-		printk(KERN_ERR PREFIX "Error adding device %s", device->dev.bus_id);
+		dev_err(&device->dev, "Error adding device\n");
 		goto end;
 	}
 

commit dc7c65db2845a8d17432d89252c4227a9a7cb15f
Merge: 8a0ca91e1db5 58b6e5538460
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 16 17:25:46 2008 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (72 commits)
      Revert "x86/PCI: ACPI based PCI gap calculation"
      PCI: remove unnecessary volatile in PCIe hotplug struct controller
      x86/PCI: ACPI based PCI gap calculation
      PCI: include linux/pm_wakeup.h for device_set_wakeup_capable
      PCI PM: Fix pci_prepare_to_sleep
      x86/PCI: Fix PCI config space for domains > 0
      Fix acpi_pm_device_sleep_wake() by providing a stub for CONFIG_PM_SLEEP=n
      PCI: Simplify PCI device PM code
      PCI PM: Introduce pci_prepare_to_sleep and pci_back_from_sleep
      PCI ACPI: Rework PCI handling of wake-up
      ACPI: Introduce new device wakeup flag 'prepared'
      ACPI: Introduce acpi_device_sleep_wake function
      PCI: rework pci_set_power_state function to call platform first
      PCI: Introduce platform_pci_power_manageable function
      ACPI: Introduce acpi_bus_power_manageable function
      PCI: make pci_name use dev_name
      PCI: handle pci_name() being const
      PCI: add stub for pci_set_consistent_dma_mask()
      PCI: remove unused arch pcibios_update_resource() functions
      PCI: fix pci_setup_device()'s sprinting into a const buffer
      ...
    
    Fixed up conflicts in various files (arch/x86/kernel/setup_64.c,
    arch/x86/pci/irq.c, arch/x86/pci/pci.h, drivers/acpi/sleep/main.c,
    drivers/pci/pci.c, drivers/pci/pci.h, include/acpi/acpi_bus.h) from x86
    and ACPI updates manually.

commit 74523c901342a773ddd9f14c14539ec3d4197ecf
Author: Alok N Kataria <akataria@vmware.com>
Date:   Fri Jun 13 12:54:24 2008 -0400

    ACPI: fix checkpatch.pl complaints in scan.c
    
    http://bugzilla.kernel.org/show_bug.cgi?id=9772
    
    Signed-off-by: Alok N Kataria <akataria@vmware.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 9a84ed250d9f..5b049cd79553 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -6,7 +6,8 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/acpi.h>
-#include <asm/signal.h>
+#include <linux/signal.h>
+#include <linux/kthread.h>
 
 #include <acpi/acpi_drivers.h>
 #include <acpi/acinterp.h>	/* for acpi_ex_eisa_id_to_string() */
@@ -154,6 +155,7 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 	acpi_status status;
 	acpi_object_type type = 0;
 	struct acpi_device *acpi_device = to_acpi_device(d);
+	struct task_struct *task;
 
 	if ((!count) || (buf[0] != '1')) {
 		return -EINVAL;
@@ -171,9 +173,11 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 	}
 
 	/* remove the device in another thread to fix the deadlock issue */
-	ret = kernel_thread(acpi_bus_hot_remove_device,
-				acpi_device->handle, SIGCHLD);
-      err:
+	task = kthread_run(acpi_bus_hot_remove_device,
+				acpi_device->handle, "acpi_hot_remove_device");
+	if (IS_ERR(task))
+		ret = PTR_ERR(task);
+err:
 	return ret;
 }
 

commit 26d46867b7d27f68a446b073dac7817721ae4c8f
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Apr 29 02:35:48 2008 -0400

    fix a deadlock issue when poking "eject" file
    
    "/sys/devices/LNXSYSTM:00/.../eject" is used to evaluate _EJx method
    and eject a device in user space.
    But system hangs when poking the "eject" file because that
    the device hot-removal code invoke the driver .remove method which will
    try to remove the "eject" file as a result.
    
    Queues the hot-removal function for deferred execution in this patch.
    http://bugzilla.kernel.org/show_bug.cgi?id=9772
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 6d85289f1c12..9a84ed250d9f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -6,6 +6,7 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/acpi.h>
+#include <asm/signal.h>
 
 #include <acpi/acpi_drivers.h>
 #include <acpi/acinterp.h>	/* for acpi_ex_eisa_id_to_string() */
@@ -92,17 +93,37 @@ acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, cha
 }
 static DEVICE_ATTR(modalias, 0444, acpi_device_modalias_show, NULL);
 
-static int acpi_eject_operation(acpi_handle handle, int lockable)
+static int acpi_bus_hot_remove_device(void *context)
 {
+	struct acpi_device *device;
+	acpi_handle handle = context;
 	struct acpi_object_list arg_list;
 	union acpi_object arg;
 	acpi_status status = AE_OK;
 
-	/*
-	 * TBD: evaluate _PS3?
-	 */
+	if (acpi_bus_get_device(handle, &device))
+		return 0;
 
-	if (lockable) {
+	if (!device)
+		return 0;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+		"Hot-removing device %s...\n", device->dev.bus_id));
+
+
+	if (acpi_bus_trim(device, 1)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				"Removing device failed\n"));
+		return -1;
+	}
+
+	/* power off device */
+	status = acpi_evaluate_object(handle, "_PS3", NULL, NULL);
+	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND)
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+				"Power-off device failed\n"));
+
+	if (device->flags.lockable) {
 		arg_list.count = 1;
 		arg_list.pointer = &arg;
 		arg.type = ACPI_TYPE_INTEGER;
@@ -118,24 +139,19 @@ static int acpi_eject_operation(acpi_handle handle, int lockable)
 	/*
 	 * TBD: _EJD support.
 	 */
-
 	status = acpi_evaluate_object(handle, "_EJ0", &arg_list, NULL);
-	if (ACPI_FAILURE(status)) {
-		return (-ENODEV);
-	}
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
 
-	return (0);
+	return 0;
 }
 
 static ssize_t
 acpi_eject_store(struct device *d, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
-	int result;
 	int ret = count;
-	int islockable;
 	acpi_status status;
-	acpi_handle handle;
 	acpi_object_type type = 0;
 	struct acpi_device *acpi_device = to_acpi_device(d);
 
@@ -154,17 +170,9 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 		goto err;
 	}
 
-	islockable = acpi_device->flags.lockable;
-	handle = acpi_device->handle;
-
-	result = acpi_bus_trim(acpi_device, 1);
-
-	if (!result)
-		result = acpi_eject_operation(handle, islockable);
-
-	if (result) {
-		ret = -EBUSY;
-	}
+	/* remove the device in another thread to fix the deadlock issue */
+	ret = kernel_thread(acpi_bus_hot_remove_device,
+				acpi_device->handle, SIGCHLD);
       err:
 	return ret;
 }

commit 77e766099efc29d8b01db4b8244ff64fa3d3d0ca
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 7 03:33:34 2008 +0200

    ACPI: Introduce acpi_device_sleep_wake function
    
    The currect ACPI code attempts to execute _PSW at three different
    places and in one of them only it tries to execute _DSW before _PSW,
    which is inconsistent with the other two cases.
    
    Move the execution of _DSW and _PSW into a separate function called
    acpi_device_sleep_wake() and call it wherever appropriate instead of
    executing _DSW and/or _PSW directly.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 6d85289f1c12..f276890cfde7 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -691,9 +691,7 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	acpi_status status = 0;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *package = NULL;
-	union acpi_object in_arg[3];
-	struct acpi_object_list arg_list = { 3, in_arg };
-	acpi_status psw_status = AE_OK;
+	int psw_error;
 
 	struct acpi_device_id button_device_ids[] = {
 		{"PNP0C0D", 0},
@@ -725,39 +723,11 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	 * So it is necessary to call _DSW object first. Only when it is not
 	 * present will the _PSW object used.
 	 */
-	/*
-	 * Three agruments are needed for the _DSW object.
-	 * Argument 0: enable/disable the wake capabilities
-	 * When _DSW object is called to disable the wake capabilities, maybe
-	 * the first argument is filled. The value of the other two agruments
-	 * is meaningless.
-	 */
-	in_arg[0].type = ACPI_TYPE_INTEGER;
-	in_arg[0].integer.value = 0;
-	in_arg[1].type = ACPI_TYPE_INTEGER;
-	in_arg[1].integer.value = 0;
-	in_arg[2].type = ACPI_TYPE_INTEGER;
-	in_arg[2].integer.value = 0;
-	psw_status = acpi_evaluate_object(device->handle, "_DSW",
-						&arg_list, NULL);
-	if (ACPI_FAILURE(psw_status) && (psw_status != AE_NOT_FOUND))
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "error in evaluate _DSW\n"));
-	/*
-	 * When the _DSW object is not present, OSPM will call _PSW object.
-	 */
-	if (psw_status == AE_NOT_FOUND) {
-		/*
-		 * Only one agruments is required for the _PSW object.
-		 * agrument 0: enable/disable the wake capabilities
-		 */
-		arg_list.count = 1;
-		in_arg[0].integer.value = 0;
-		psw_status = acpi_evaluate_object(device->handle, "_PSW",
-						&arg_list, NULL);
-		if (ACPI_FAILURE(psw_status) && (psw_status != AE_NOT_FOUND))
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "error in "
-						"evaluate _PSW\n"));
-	}
+	psw_error = acpi_device_sleep_wake(device, 0, 0, 0);
+	if (psw_error)
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				"error in _DSW or _PSW evaluation\n"));
+
 	/* Power button, Lid switch always enable wakeup */
 	if (!acpi_match_device_ids(device, button_device_ids))
 		device->wakeup.flags.run_wake = 1;

commit 96916090f488986a4ebb8e9ffa6a3b50881d5ccd
Merge: 75a44ce00b31 729b2bdbfa19 2f67a0695dc3 51ae796f7fa1 ce52ddf58cbc e1faa9da284d 36a913586597 9448b0d43e55 99bda83e8b31 1071695f17da 7aa0f1a8b1f7 68f12ae5d778 66fb9d120e91
Author: Len Brown <len.brown@intel.com>
Date:   Wed Apr 30 13:58:00 2008 -0400

    Merge branches 'release', 'acpica', 'bugzilla-10224', 'bugzilla-9772', 'bugzilla-9916', 'ec', 'eeepc', 'idle', 'misc', 'pm-legacy', 'sysfs-links-2.6.26', 'thermal', 'thinkpad' and 'video' into release

commit 66fb9d120e91050093b8ce4c1daa2e440660152b
Author: Thomas Renninger <trenn@suse.de>
Date:   Wed Apr 16 20:52:02 2008 +0200

    ACPI: Cleanup: Remove unneeded, multiple local dummy variables
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e6ce262b5d44..6b1999b1cd34 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -882,10 +882,7 @@ static void acpi_device_get_busid(struct acpi_device *device,
 static int
 acpi_video_bus_match(struct acpi_device *device)
 {
-	acpi_handle h_dummy1;
-	acpi_handle h_dummy2;
-	acpi_handle h_dummy3;
-
+	acpi_handle h_dummy;
 
 	if (!device)
 		return -EINVAL;
@@ -895,18 +892,18 @@ acpi_video_bus_match(struct acpi_device *device)
 	 */
 
 	/* Does this device able to support video switching ? */
-	if (ACPI_SUCCESS(acpi_get_handle(device->handle, "_DOD", &h_dummy1)) &&
-	    ACPI_SUCCESS(acpi_get_handle(device->handle, "_DOS", &h_dummy2)))
+	if (ACPI_SUCCESS(acpi_get_handle(device->handle, "_DOD", &h_dummy)) &&
+	    ACPI_SUCCESS(acpi_get_handle(device->handle, "_DOS", &h_dummy)))
 		return 0;
 
 	/* Does this device able to retrieve a video ROM ? */
-	if (ACPI_SUCCESS(acpi_get_handle(device->handle, "_ROM", &h_dummy1)))
+	if (ACPI_SUCCESS(acpi_get_handle(device->handle, "_ROM", &h_dummy)))
 		return 0;
 
 	/* Does this device able to configure which video head to be POSTed ? */
-	if (ACPI_SUCCESS(acpi_get_handle(device->handle, "_VPO", &h_dummy1)) &&
-	    ACPI_SUCCESS(acpi_get_handle(device->handle, "_GPD", &h_dummy2)) &&
-	    ACPI_SUCCESS(acpi_get_handle(device->handle, "_SPD", &h_dummy3)))
+	if (ACPI_SUCCESS(acpi_get_handle(device->handle, "_VPO", &h_dummy)) &&
+	    ACPI_SUCCESS(acpi_get_handle(device->handle, "_GPD", &h_dummy)) &&
+	    ACPI_SUCCESS(acpi_get_handle(device->handle, "_SPD", &h_dummy)))
 		return 0;
 
 	return -ENODEV;

commit cd0b2248241f4146152fb04a6bf4bccb6ce0478a
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Apr 10 19:06:43 2008 +0400

    ACPICA: Fixes for external Reference Objects
    
    All Reference Objects returned via the AcpiEvaluteObject interface
    are now marked as type "REFERENCE" instead of "ANY". The type ANY
    is now reservered for NULL objects - either NULL package elements
    or unresolved named references.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e6ce262b5d44..464ee6ea8c61 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -677,9 +677,8 @@ acpi_bus_extract_wakeup_device_power_package(struct acpi_device *device,
 	device->wakeup.resources.count = package->package.count - 2;
 	for (i = 0; i < device->wakeup.resources.count; i++) {
 		element = &(package->package.elements[i + 2]);
-		if (element->type != ACPI_TYPE_ANY) {
+		if (element->type != ACPI_TYPE_LOCAL_REFERENCE)
 			return AE_BAD_DATA;
-		}
 
 		device->wakeup.resources.handles[i] = element->reference.handle;
 	}

commit 729b2bdbfa19dd9be98dbd49caf2773b3271cc24
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Wed Mar 19 13:26:54 2008 +0800

    ACPI : Disable the device's ability to wake the sleeping system in the boot phase
    
    In some machines some GPE is shared by several ACPI devices, for example:
    sleep button, keyboard, mouse. At the same time one of them is
    non-wake(runtime) device and the other are wake devices. In such case OSPM
    should call the _PSW object to disable the device's ability to
    wake the sleeping system in the boot phase.
    Otherwise there will be ACPI interrupt flood triggered by the GPE input.
    
    The _PSW object is depreciated in ACPI 3.0 and is replaced by _DSW.
    So it is necessary to call _DSW object first. Only when it is not
    present will the _PSW object used.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=10224
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Zhang Rui  <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e6ce262b5d44..bd32351854ac 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -692,6 +692,9 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	acpi_status status = 0;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *package = NULL;
+	union acpi_object in_arg[3];
+	struct acpi_object_list arg_list = { 3, in_arg };
+	acpi_status psw_status = AE_OK;
 
 	struct acpi_device_id button_device_ids[] = {
 		{"PNP0C0D", 0},
@@ -700,7 +703,6 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 		{"", 0},
 	};
 
-
 	/* _PRW */
 	status = acpi_evaluate_object(device->handle, "_PRW", NULL, &buffer);
 	if (ACPI_FAILURE(status)) {
@@ -718,6 +720,45 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	kfree(buffer.pointer);
 
 	device->wakeup.flags.valid = 1;
+	/* Call _PSW/_DSW object to disable its ability to wake the sleeping
+	 * system for the ACPI device with the _PRW object.
+	 * The _PSW object is depreciated in ACPI 3.0 and is replaced by _DSW.
+	 * So it is necessary to call _DSW object first. Only when it is not
+	 * present will the _PSW object used.
+	 */
+	/*
+	 * Three agruments are needed for the _DSW object.
+	 * Argument 0: enable/disable the wake capabilities
+	 * When _DSW object is called to disable the wake capabilities, maybe
+	 * the first argument is filled. The value of the other two agruments
+	 * is meaningless.
+	 */
+	in_arg[0].type = ACPI_TYPE_INTEGER;
+	in_arg[0].integer.value = 0;
+	in_arg[1].type = ACPI_TYPE_INTEGER;
+	in_arg[1].integer.value = 0;
+	in_arg[2].type = ACPI_TYPE_INTEGER;
+	in_arg[2].integer.value = 0;
+	psw_status = acpi_evaluate_object(device->handle, "_DSW",
+						&arg_list, NULL);
+	if (ACPI_FAILURE(psw_status) && (psw_status != AE_NOT_FOUND))
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "error in evaluate _DSW\n"));
+	/*
+	 * When the _DSW object is not present, OSPM will call _PSW object.
+	 */
+	if (psw_status == AE_NOT_FOUND) {
+		/*
+		 * Only one agruments is required for the _PSW object.
+		 * agrument 0: enable/disable the wake capabilities
+		 */
+		arg_list.count = 1;
+		in_arg[0].integer.value = 0;
+		psw_status = acpi_evaluate_object(device->handle, "_PSW",
+						&arg_list, NULL);
+		if (ACPI_FAILURE(psw_status) && (psw_status != AE_NOT_FOUND))
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "error in "
+						"evaluate _PSW\n"));
+	}
 	/* Power button, Lid switch always enable wakeup */
 	if (!acpi_match_device_ids(device, button_device_ids))
 		device->wakeup.flags.run_wake = 1;

commit 5c9fcb5deef4d3a49798d76c48b726d2e3c7df72
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Mar 20 16:40:32 2008 +0800

    ACPI: fix a regression of ACPI device driver autoloading
    
    commit 3620f2f2f39e7870cf1a4fb2e34063a142f28716 sets the cid of
    ACPI video/dock/bay device and leaves the hid empty.
    As a result, "modalias" should export the cid for
    devices which don't have a hid.
    
    ACPI Video driver is not autoloaded with
    commit 3620f2f2f39e7870cf1a4fb2e34063a142f28716 applied.
    "cat /sys/.../device:03(acpi video bus)/modalias" shows nothing.
    
    ACPI Video driver is autoloaded after revert that commit.
    "cat /sys/.../LNXVIDEO:0x/modalias" shows "acpi:LNXVIDEO:"
    
    ACPI Video driver is autoloaded with commit
    3620f2f2f39e7870cf1a4fb2e34063a142f28716 and this patch applied.
    "cat /sys/.../device:03(acpi video bus)/modalias"
    shows "acpi:LNXVIDEO:"
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 57570ac47803..e6ce262b5d44 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -39,20 +39,26 @@ static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
 			   int size)
 {
 	int len;
+	int count;
 
-	if (!acpi_dev->flags.hardware_id)
+	if (!acpi_dev->flags.hardware_id && !acpi_dev->flags.compatible_ids)
 		return -ENODEV;
 
-	len = snprintf(modalias, size, "acpi:%s:",
-		       acpi_dev->pnp.hardware_id);
-	if (len < 0 || len >= size)
-		return -EINVAL;
+	len = snprintf(modalias, size, "acpi:");
 	size -= len;
 
+	if (acpi_dev->flags.hardware_id) {
+		count = snprintf(&modalias[len], size, "%s:",
+				 acpi_dev->pnp.hardware_id);
+		if (count < 0 || count >= size)
+			return -EINVAL;
+		len += count;
+		size -= count;
+	}
+
 	if (acpi_dev->flags.compatible_ids) {
 		struct acpi_compatible_id_list *cid_list;
 		int i;
-		int count;
 
 		cid_list = acpi_dev->pnp.cid_list;
 		for (i = 0; i < cid_list->count; i++) {

commit b4de123a0bc4a3f0c90899864d51299628729952
Merge: c523aef0f728 3b5fee5952ff d399d130c82a 07d31ee5597d
Author: Len Brown <len.brown@intel.com>
Date:   Thu Mar 13 01:59:52 2008 -0400

    Merge branches 'release', 'ejd', 'sony' and 'wmi' into release

commit 96b2dd1f1fdb9a131b7f2e79e5c7b2e4282cfcbf
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed Mar 5 18:24:51 2008 -0800

    ACPI: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 3fac011f9cf9..b26e3019e1cc 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -966,7 +966,7 @@ static void acpi_device_set_id(struct acpi_device *device,
 	case ACPI_BUS_TYPE_DEVICE:
 		status = acpi_get_object_info(handle, &buffer);
 		if (ACPI_FAILURE(status)) {
-			printk(KERN_ERR PREFIX "%s: Error reading device info\n", __FUNCTION__);
+			printk(KERN_ERR PREFIX "%s: Error reading device info\n", __func__);
 			return;
 		}
 

commit 3b5fee5952ff7eb6ff7a64247a01040b8b331b74
Author: Holger Macht <hmacht@suse.de>
Date:   Thu Feb 14 13:40:34 2008 +0100

    ACPI: Do not pass NULL to acpi_get_handle() when looking for _EJD
    
    When trying to get the acpi_handle from an acpi_buffer, pass
    ACPI_ROOT_OBJECT instead of NULL to acpi_get_handle(). This fixes the
    detection of dock dependent bays.
    
    Signed-off-by: Holger Macht <hmacht@suse.de>
    Tested-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 3fac011f9cf9..d9b914303b9c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -609,7 +609,8 @@ acpi_bus_get_ejd(acpi_handle handle, acpi_handle *ejd)
 	status = acpi_evaluate_object(handle, "_EJD", NULL, &buffer);
 	if (ACPI_SUCCESS(status)) {
 		obj = buffer.pointer;
-		status = acpi_get_handle(NULL, obj->string.pointer, ejd);
+		status = acpi_get_handle(ACPI_ROOT_OBJECT, obj->string.pointer,
+					 ejd);
 		kfree(buffer.pointer);
 	}
 	return status;

commit a733a5da97b238e3e3167d3d0aee8fe1e8d04e97
Merge: 299cfe38081b 299cfe38081b 9e52797131e8
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 7 03:38:22 2008 -0500

    Merge branches 'release' and 'fluff' into release
    
    Conflicts:
    
            drivers/acpi/scan.c
            include/linux/acpi.h
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 87ecd5cddaa37f057d8d8c2813e1b748b1804423
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jan 1 14:00:00 2008 -0500

    ACPI: add missing prink prefix strings
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d9d531cce27f..78a82b3c7b60 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -59,7 +59,7 @@ static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
 			count = snprintf(&modalias[len], size, "%s:",
 					 cid_list->id[i].value);
 			if (count < 0 || count >= size) {
-				printk(KERN_ERR "acpi: %s cid[%i] exceeds event buffer size",
+				printk(KERN_ERR PREFIX "%s cid[%i] exceeds event buffer size",
 				       acpi_dev->pnp.device_name, i);
 				break;
 			}
@@ -453,7 +453,7 @@ static int acpi_device_register(struct acpi_device *device,
 	device->dev.release = &acpi_device_release;
 	result = device_add(&device->dev);
 	if(result) {
-		printk("Error adding device %s", device->dev.bus_id);
+		printk(KERN_ERR PREFIX "Error adding device %s", device->dev.bus_id);
 		goto end;
 	}
 
@@ -956,7 +956,7 @@ static void acpi_device_set_id(struct acpi_device *device,
 	case ACPI_BUS_TYPE_DEVICE:
 		status = acpi_get_object_info(handle, &buffer);
 		if (ACPI_FAILURE(status)) {
-			printk("%s: Error reading device info\n", __FUNCTION__);
+			printk(KERN_ERR PREFIX "%s: Error reading device info\n", __FUNCTION__);
 			return;
 		}
 
@@ -1026,7 +1026,7 @@ static void acpi_device_set_id(struct acpi_device *device,
 		if (device->pnp.cid_list)
 			memcpy(device->pnp.cid_list, cid_list, cid_list->size);
 		else
-			printk(KERN_ERR "Memory allocation error\n");
+			printk(KERN_ERR PREFIX "Memory allocation error\n");
 	}
 
 	kfree(buffer.pointer);
@@ -1050,7 +1050,7 @@ static int acpi_device_set_context(struct acpi_device *device, int type)
 					  acpi_bus_data_handler, device);
 
 		if (ACPI_FAILURE(status)) {
-			printk("Error attaching device data\n");
+			printk(KERN_ERR PREFIX "Error attaching device data\n");
 			result = -ENODEV;
 		}
 	}

commit 8f859016ea49cd8d7c743533bd1ab3db9a813ffa
Merge: dd07a8db7283 17196d6e533a
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 7 03:07:55 2008 -0500

    Merge branches 'release' and 'autoload' into release

commit 3c5f9be461cd86394a143e73f2325da5938bce0b
Author: Joe Perches <joe@perches.com>
Date:   Sun Feb 3 17:06:17 2008 +0200

    drivers/acpi/: Spelling fixes
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index cbfe9ae7a9e5..d9d531cce27f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -830,7 +830,7 @@ static int acpi_bus_get_flags(struct acpi_device *device)
 	if (ACPI_SUCCESS(status))
 		device->flags.wake_capable = 1;
 
-	/* TBD: Peformance management */
+	/* TBD: Performance management */
 
 	return 0;
 }

commit c04209a7948b95e8c52084e8595e74e9428653d3
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Tue Jan 1 14:12:55 2008 -0500

    ACPI: EC: Enable boot EC before bus_scan
    
    Some _STA methods called during bus_scan() might require EC region handler,
    which might be enabled later in the scan.
    Enable it explicitly before scan to avoid errors.
    
    Reference: http://bugzilla.kernel.org/show_bug.cgi?id=9627
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5b4d462117cf..cbfe9ae7a9e5 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1449,6 +1449,8 @@ static int acpi_bus_scan_fixed(struct acpi_device *root)
 	return result;
 }
 
+int __init acpi_boot_ec_enable(void);
+
 static int __init acpi_scan_init(void)
 {
 	int result;
@@ -1480,6 +1482,10 @@ static int __init acpi_scan_init(void)
 	 * Enumerate devices in the ACPI namespace.
 	 */
 	result = acpi_bus_scan_fixed(acpi_root);
+
+	/* EC region might be needed at bus_scan, so enable it now */
+	acpi_boot_ec_enable();
+
 	if (!result)
 		result = acpi_bus_scan(acpi_root, &ops);
 

commit 3620f2f2f39e7870cf1a4fb2e34063a142f28716
Author: Frank Seidel <fseidel@suse.de>
Date:   Fri Dec 7 13:20:34 2007 +0100

    ACPI: Fix autloading of dock, video, bay and all linux specific HID drivers
    
    References: https://bugzilla.novell.com/show_bug.cgi?id=302482
    
    Due to the new autloading of acpi drivers, the dock driver
    wasn't loaded anymore as there is no HID to identify it with
    (dock is needed if ACPI has a  _DCK method).
    This patch is a workaround for this, original by Thomas Renninger,
    revised first by Kay Sievers and last by Frank Seidel.
    V2 of this patch fixed problems on systems without a defined _CID for
    the docking devices.
    
    Signed-off-by: Thomas Renninger <trenn@novell.com>
    Signed-off-by: Kay Sievers <kasievers@novell.com>
    Signed-off-by: Frank Seidel <fseidel@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5b4d462117cf..bf079265ce7e 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -941,6 +941,15 @@ static int acpi_bay_match(struct acpi_device *device){
 	return -ENODEV;
 }
 
+/*
+ * acpi_dock_match - see if a device has a _DCK method
+ */
+static int acpi_dock_match(struct acpi_device *device)
+{
+	acpi_handle tmp;
+	return acpi_get_handle(device->handle, "_DCK", &tmp);
+}
+
 static void acpi_device_set_id(struct acpi_device *device,
 			       struct acpi_device *parent, acpi_handle handle,
 			       int type)
@@ -950,6 +959,7 @@ static void acpi_device_set_id(struct acpi_device *device,
 	char *hid = NULL;
 	char *uid = NULL;
 	struct acpi_compatible_id_list *cid_list = NULL;
+	const char *cid_add = NULL;
 	acpi_status status;
 
 	switch (type) {
@@ -972,15 +982,18 @@ static void acpi_device_set_id(struct acpi_device *device,
 			device->flags.bus_address = 1;
 		}
 
-		if(!(info->valid & (ACPI_VALID_HID | ACPI_VALID_CID))){
-			status = acpi_video_bus_match(device);
-			if(ACPI_SUCCESS(status))
-				hid = ACPI_VIDEO_HID;
+		/* If we have a video/bay/dock device, add our selfdefined
+		   HID to the CID list. Like that the video/bay/dock drivers
+		   will get autoloaded and the device might still match
+		   against another driver.
+		*/
+		if (ACPI_SUCCESS(acpi_video_bus_match(device)))
+			cid_add = ACPI_VIDEO_HID;
+		else if (ACPI_SUCCESS(acpi_bay_match(device)))
+			cid_add = ACPI_BAY_HID;
+		else if (ACPI_SUCCESS(acpi_dock_match(device)))
+			cid_add = ACPI_DOCK_HID;
 
-			status = acpi_bay_match(device);
-			if (ACPI_SUCCESS(status))
-				hid = ACPI_BAY_HID;
-		}
 		break;
 	case ACPI_BUS_TYPE_POWER:
 		hid = ACPI_POWER_HID;
@@ -1021,11 +1034,44 @@ static void acpi_device_set_id(struct acpi_device *device,
 		strcpy(device->pnp.unique_id, uid);
 		device->flags.unique_id = 1;
 	}
-	if (cid_list) {
-		device->pnp.cid_list = kmalloc(cid_list->size, GFP_KERNEL);
-		if (device->pnp.cid_list)
-			memcpy(device->pnp.cid_list, cid_list, cid_list->size);
-		else
+	if (cid_list || cid_add) {
+		struct  acpi_compatible_id_list *list;
+		int size = 0;
+		int count = 0;
+
+		if (cid_list) {
+			size = cid_list->size;
+		} else if (cid_add) {
+			size = sizeof(struct acpi_compatible_id_list);
+			cid_list = ACPI_ALLOCATE_ZEROED((acpi_size) size);
+			if (!cid_list) {
+				printk(KERN_ERR "Memory allocation error\n");
+				kfree(buffer.pointer);
+				return;
+			} else {
+				cid_list->count = 0;
+				cid_list->size = size;
+			}
+		}
+		if (cid_add)
+			size += sizeof(struct acpi_compatible_id);
+		list = kmalloc(size, GFP_KERNEL);
+
+		if (list) {
+			if (cid_list) {
+				memcpy(list, cid_list, cid_list->size);
+				count = cid_list->count;
+			}
+			if (cid_add) {
+				strncpy(list->id[count].value, cid_add,
+					ACPI_MAX_CID_LENGTH);
+				count++;
+				device->flags.compatible_ids = 1;
+			}
+			list->size = size;
+			list->count = count;
+			device->pnp.cid_list = list;
+		} else
 			printk(KERN_ERR "Memory allocation error\n");
 	}
 
@@ -1080,6 +1126,20 @@ static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 	return 0;
 }
 
+static int
+acpi_is_child_device(struct acpi_device *device,
+			int (*matcher)(struct acpi_device *))
+{
+	int result = -ENODEV;
+
+	do {
+		if (ACPI_SUCCESS(matcher(device)))
+			return AE_OK;
+	} while ((device = device->parent));
+
+	return result;
+}
+
 static int
 acpi_add_single_object(struct acpi_device **child,
 		       struct acpi_device *parent, acpi_handle handle, int type,
@@ -1131,10 +1191,20 @@ acpi_add_single_object(struct acpi_device **child,
 	case ACPI_BUS_TYPE_PROCESSOR:
 	case ACPI_BUS_TYPE_DEVICE:
 		result = acpi_bus_get_status(device);
-		if (ACPI_FAILURE(result) || !device->status.present) {
-			result = -ENOENT;
+		if (ACPI_FAILURE(result)) {
+			result = -ENODEV;
 			goto end;
 		}
+		if (!device->status.present) {
+			/* Bay and dock should be handled even if absent */
+			if (!ACPI_SUCCESS(
+			     acpi_is_child_device(device, acpi_bay_match)) &&
+			    !ACPI_SUCCESS(
+			     acpi_is_child_device(device, acpi_dock_match))) {
+					result = -ENODEV;
+					goto end;
+			}
+		}
 		break;
 	default:
 		STRUCT_TO_INT(device->status) =

commit 7eff2e7a8b65c25920207324e56611150eb1cd9a
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Aug 14 15:15:12 2007 +0200

    Driver core: change add_uevent_var to use a struct
    
    This changes the uevent buffer functions to use a struct instead of a
    long list of parameters. It does no longer require the caller to do the
    proper buffer termination and size accounting, which is currently wrong
    in some places. It fixes a known bug where parts of the uevent
    environment are overwritten because of wrong index calculations.
    
    Many thanks to Mathieu Desnoyers for finding bugs and improving the
    error handling.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 64620d668742..5b4d462117cf 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -319,16 +319,18 @@ static int acpi_bus_match(struct device *dev, struct device_driver *drv)
 	return !acpi_match_device_ids(acpi_dev, acpi_drv->ids);
 }
 
-static int acpi_device_uevent(struct device *dev, char **envp, int num_envp,
-			      char *buffer, int buffer_size)
+static int acpi_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
+	int len;
 
-	strcpy(buffer, "MODALIAS=");
-	if (create_modalias(acpi_dev, buffer + 9, buffer_size - 9) > 0) {
-		envp[0] = buffer;
-		envp[1] = NULL;
-	}
+	if (add_uevent_var(env, "MODALIAS="))
+		return -ENOMEM;
+	len = create_modalias(acpi_dev, &env->buf[env->buflen - 1],
+			      sizeof(env->buf) - env->buflen);
+	if (len >= (sizeof(env->buf) - env->buflen))
+		return -ENOMEM;
+	env->buflen += len;
 	return 0;
 }
 

commit b3e572d2eb7cdbda6f212ad177acd0c9381903b9
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Aug 14 23:22:35 2007 +0200

    make drivers/acpi/scan.c:create_modalias() static
    
    This patch makes the needlessly global create_modalias() static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index be74347d1354..64620d668742 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -35,8 +35,9 @@ struct acpi_device_bus_id{
  * e.g. on a device with hid:IBM0001 and cid:ACPI0001 you get:
  * char *modalias: "acpi:IBM0001:ACPI0001"
 */
-int create_modalias(struct acpi_device *acpi_dev, char *modalias, int size){
-
+static int create_modalias(struct acpi_device *acpi_dev, char *modalias,
+			   int size)
+{
 	int len;
 
 	if (!acpi_dev->flags.hardware_id)

commit 29b71a1ca74491fab9fed09e9d835d840d042690
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jul 23 14:43:51 2007 +0200

    ACPI: autoload modules - Create ACPI alias interface
    
    Modify modpost (file2alias.c) to add acpi*:XYZ0001: alias in modules.alias
    like:
    grep acpi /lib/modules/2.6.22-rc4-default/modules.alias
    alias acpi*:SNY5001:* sony_laptop
    alias acpi*:SNY6001:* sony_laptop
    for e.g. the sony_laptop module.
    This module matches against all ACPI devices with a HID or CID of SNY5001
    or SNY6001
    
    Export an uevent and modalias sysfs file containing the string:
    [MODALIAS=]acpi:PNP0C0C:
    additional CIDs are concatenated at the end.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 6b3b8a522476..be74347d1354 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -16,7 +16,7 @@ ACPI_MODULE_NAME("scan");
 extern struct acpi_device *acpi_root;
 
 #define ACPI_BUS_CLASS			"system_bus"
-#define ACPI_BUS_HID			"ACPI_BUS"
+#define ACPI_BUS_HID			"LNXSYBUS"
 #define ACPI_BUS_DEVICE_NAME		"System Bus"
 
 static LIST_HEAD(acpi_device_list);
@@ -29,6 +29,62 @@ struct acpi_device_bus_id{
 	unsigned int instance_no;
 	struct list_head node;
 };
+
+/*
+ * Creates hid/cid(s) string needed for modalias and uevent
+ * e.g. on a device with hid:IBM0001 and cid:ACPI0001 you get:
+ * char *modalias: "acpi:IBM0001:ACPI0001"
+*/
+int create_modalias(struct acpi_device *acpi_dev, char *modalias, int size){
+
+	int len;
+
+	if (!acpi_dev->flags.hardware_id)
+		return -ENODEV;
+
+	len = snprintf(modalias, size, "acpi:%s:",
+		       acpi_dev->pnp.hardware_id);
+	if (len < 0 || len >= size)
+		return -EINVAL;
+	size -= len;
+
+	if (acpi_dev->flags.compatible_ids) {
+		struct acpi_compatible_id_list *cid_list;
+		int i;
+		int count;
+
+		cid_list = acpi_dev->pnp.cid_list;
+		for (i = 0; i < cid_list->count; i++) {
+			count = snprintf(&modalias[len], size, "%s:",
+					 cid_list->id[i].value);
+			if (count < 0 || count >= size) {
+				printk(KERN_ERR "acpi: %s cid[%i] exceeds event buffer size",
+				       acpi_dev->pnp.device_name, i);
+				break;
+			}
+			len += count;
+			size -= count;
+		}
+	}
+
+	modalias[len] = '\0';
+	return len;
+}
+
+static ssize_t
+acpi_device_modalias_show(struct device *dev, struct device_attribute *attr, char *buf) {
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+	int len;
+
+	/* Device has no HID and no CID or string is >1024 */
+	len = create_modalias(acpi_dev, buf, 1024);
+	if (len <= 0)
+		return 0;
+	buf[len++] = '\n';
+	return len;
+}
+static DEVICE_ATTR(modalias, 0444, acpi_device_modalias_show, NULL);
+
 static int acpi_eject_operation(acpi_handle handle, int lockable)
 {
 	struct acpi_object_list arg_list;
@@ -154,6 +210,12 @@ static int acpi_device_setup_files(struct acpi_device *dev)
 			goto end;
 	}
 
+	if (dev->flags.hardware_id || dev->flags.compatible_ids){
+		result = device_create_file(&dev->dev, &dev_attr_modalias);
+		if(result)
+			goto end;
+	}
+
         /*
          * If device has _EJ0, 'eject' file is created that is used to trigger
          * hot-removal function from userland.
@@ -178,6 +240,9 @@ static void acpi_device_remove_files(struct acpi_device *dev)
 	if (ACPI_SUCCESS(status))
 		device_remove_file(&dev->dev, &dev_attr_eject);
 
+	if (dev->flags.hardware_id || dev->flags.compatible_ids)
+		device_remove_file(&dev->dev, &dev_attr_modalias);
+
 	if(dev->flags.hardware_id)
 		device_remove_file(&dev->dev, &dev_attr_hid);
 	if(dev->handle)
@@ -186,6 +251,37 @@ static void acpi_device_remove_files(struct acpi_device *dev)
 /* --------------------------------------------------------------------------
 			ACPI Bus operations
    -------------------------------------------------------------------------- */
+
+int acpi_match_device_ids(struct acpi_device *device,
+			  const struct acpi_device_id *ids)
+{
+	const struct acpi_device_id *id;
+
+	if (device->flags.hardware_id) {
+		for (id = ids; id->id[0]; id++) {
+			if (!strcmp((char*)id->id, device->pnp.hardware_id))
+				return 0;
+		}
+	}
+
+	if (device->flags.compatible_ids) {
+		struct acpi_compatible_id_list *cid_list = device->pnp.cid_list;
+		int i;
+
+		for (id = ids; id->id[0]; id++) {
+			/* compare multiple _CID entries against driver ids */
+			for (i = 0; i < cid_list->count; i++) {
+				if (!strcmp((char*)id->id,
+					    cid_list->id[i].value))
+					return 0;
+			}
+		}
+	}
+
+	return -ENOENT;
+}
+EXPORT_SYMBOL(acpi_match_device_ids);
+
 static void acpi_device_release(struct device *dev)
 {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
@@ -219,37 +315,19 @@ static int acpi_bus_match(struct device *dev, struct device_driver *drv)
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 	struct acpi_driver *acpi_drv = to_acpi_driver(drv);
 
-	return !acpi_match_ids(acpi_dev, acpi_drv->ids);
+	return !acpi_match_device_ids(acpi_dev, acpi_drv->ids);
 }
 
 static int acpi_device_uevent(struct device *dev, char **envp, int num_envp,
-	char *buffer, int buffer_size)
+			      char *buffer, int buffer_size)
 {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
-	int i = 0, length = 0, ret = 0;
-
-	if (acpi_dev->flags.hardware_id)
-		ret = add_uevent_var(envp, num_envp, &i,
-			buffer, buffer_size, &length,
-			"HWID=%s", acpi_dev->pnp.hardware_id);
-	if (ret)
-		return -ENOMEM;
-	if (acpi_dev->flags.compatible_ids) {
-		int j;
-		struct acpi_compatible_id_list *cid_list;
 
-		cid_list = acpi_dev->pnp.cid_list;
-
-		for (j = 0; j < cid_list->count; j++) {
-			ret = add_uevent_var(envp, num_envp, &i, buffer,
-				buffer_size, &length, "COMPTID=%s",
-				cid_list->id[j].value);
-			if (ret)
-				return -ENOMEM;
-		}
+	strcpy(buffer, "MODALIAS=");
+	if (create_modalias(acpi_dev, buffer + 9, buffer_size - 9) > 0) {
+		envp[0] = buffer;
+		envp[1] = NULL;
 	}
-
-	envp[i] = NULL;
 	return 0;
 }
 
@@ -543,25 +621,6 @@ void acpi_bus_data_handler(acpi_handle handle, u32 function, void *context)
 	return;
 }
 
-int acpi_match_ids(struct acpi_device *device, char *ids)
-{
-	if (device->flags.hardware_id)
-		if (strstr(ids, device->pnp.hardware_id))
-			return 0;
-
-	if (device->flags.compatible_ids) {
-		struct acpi_compatible_id_list *cid_list = device->pnp.cid_list;
-		int i;
-
-		/* compare multiple _CID entries against driver ids */
-		for (i = 0; i < cid_list->count; i++) {
-			if (strstr(ids, cid_list->id[i].value))
-				return 0;
-		}
-	}
-	return -ENOENT;
-}
-
 static int acpi_bus_get_perf_flags(struct acpi_device *device)
 {
 	device->performance.state = ACPI_STATE_UNKNOWN;
@@ -624,6 +683,13 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *package = NULL;
 
+	struct acpi_device_id button_device_ids[] = {
+		{"PNP0C0D", 0},
+		{"PNP0C0C", 0},
+		{"PNP0C0E", 0},
+		{"", 0},
+	};
+
 
 	/* _PRW */
 	status = acpi_evaluate_object(device->handle, "_PRW", NULL, &buffer);
@@ -643,7 +709,7 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 
 	device->wakeup.flags.valid = 1;
 	/* Power button, Lid switch always enable wakeup */
-	if (!acpi_match_ids(device, "PNP0C0D,PNP0C0C,PNP0C0E"))
+	if (!acpi_match_device_ids(device, button_device_ids))
 		device->wakeup.flags.run_wake = 1;
 
       end:

commit 55955aad7c09e4d93029d0cf2d360b41891f2fe4
Author: David Brownell <david-b@pacbell.net>
Date:   Tue May 8 00:28:35 2007 -0700

    PNPACPI sets pnpdev->dev.archdata
    
    Teach PNPACPI how to hook up its devices to their ACPI nodes, so that
    pnpdev->dev.archdata points to the parallel acpi device node.  Previously
    this only worked for PCI, leaving a notable hole.
    
    Export "acpi_bus_type" so this can work.
    
    Remove some extraneous whitespace.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index d80dd84e5bfd..6b3b8a522476 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -302,7 +302,7 @@ static void acpi_device_shutdown(struct device *dev)
 	return ;
 }
 
-static struct bus_type acpi_bus_type = {
+struct bus_type acpi_bus_type = {
 	.name		= "acpi",
 	.suspend	= acpi_device_suspend,
 	.resume		= acpi_device_resume,

commit 0c0e8921018dbb4fe189a1034f80ac32553bc7bc
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Apr 25 14:20:58 2007 -0400

    ACPI: use _STA bit names rather than 0x0F
    
    Be explicit about what "device->status = 0x0F" really means.
    
    syntax only.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index bb0e0da39fb1..d80dd84e5bfd 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1068,7 +1068,9 @@ acpi_add_single_object(struct acpi_device **child,
 		}
 		break;
 	default:
-		STRUCT_TO_INT(device->status) = 0x0F;
+		STRUCT_TO_INT(device->status) =
+		    ACPI_STA_DEVICE_PRESENT | ACPI_STA_DEVICE_ENABLED |
+		    ACPI_STA_DEVICE_UI      | ACPI_STA_DEVICE_FUNCTIONING;
 		break;
 	}
 

commit 7cda93e008e1a477970adbf82dba81a5d4f0ae40
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 23:50:02 2007 -0500

    ACPI: delete extra #defines in /drivers/acpi/ drivers
    
    Cosmetic only.
    
    Except in a single case, #define ACPI_*_DRIVER_NAME
    were invoked 0 or 1 times.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index cff1b590d94d..bb0e0da39fb1 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -17,7 +17,6 @@ extern struct acpi_device *acpi_root;
 
 #define ACPI_BUS_CLASS			"system_bus"
 #define ACPI_BUS_HID			"ACPI_BUS"
-#define ACPI_BUS_DRIVER_NAME		"ACPI Bus Driver"
 #define ACPI_BUS_DEVICE_NAME		"System Bus"
 
 static LIST_HEAD(acpi_device_list);

commit f52fd66d2ea794010c2d7536cf8e6abed0ac4947
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 22:42:12 2007 -0500

    ACPI: clean up ACPI_MODULE_NAME() use
    
    cosmetic only
    
    Make "module name" actually match the file name.
    Invoke with ';' as leaving it off confuses Lindent and gcc doesn't care.
    Fix indentation where Lindent did get confused.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 64f26db10c8e..cff1b590d94d 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -11,7 +11,7 @@
 #include <acpi/acinterp.h>	/* for acpi_ex_eisa_id_to_string() */
 
 #define _COMPONENT		ACPI_BUS_COMPONENT
-ACPI_MODULE_NAME("scan")
+ACPI_MODULE_NAME("scan");
 #define STRUCT_TO_INT(s)	(*((int*)&s))
 extern struct acpi_device *acpi_root;
 

commit 6b259707d53f0f25f0b24318a0774f1ae7e7e92c
Merge: a4144e451ce1 db50342205de
Author: Len Brown <len.brown@intel.com>
Date:   Sat Feb 3 01:39:07 2007 -0500

    Pull trivial into test branch
    
    Conflicts:
    
            drivers/acpi/scan.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 547352660506ab99d6b0bad58dea495bf3718cee
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Jan 11 02:09:09 2007 -0500

    ACPI: bay: Convert ACPI Bay driver to be compatible with sysfs update.
    
            Set fake hid for ejectable drive bay.
            Match bay devices by checking the hid.
            Remove .match method of Bay driver.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5049230ccf49..0a13d954daed 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -837,6 +837,42 @@ acpi_video_bus_match(struct acpi_device *device)
 	return -ENODEV;
 }
 
+/*
+ * acpi_bay_match - see if a device is an ejectable driver bay
+ *
+ * If an acpi object is ejectable and has one of the ACPI ATA methods defined,
+ * then we can safely call it an ejectable drive bay
+ */
+static int acpi_bay_match(struct acpi_device *device){
+	acpi_status status;
+	acpi_handle handle;
+	acpi_handle tmp;
+	acpi_handle phandle;
+
+	handle = device->handle;
+
+	status = acpi_get_handle(handle, "_EJ0", &tmp);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	if ((ACPI_SUCCESS(acpi_get_handle(handle, "_GTF", &tmp))) ||
+		(ACPI_SUCCESS(acpi_get_handle(handle, "_GTM", &tmp))) ||
+		(ACPI_SUCCESS(acpi_get_handle(handle, "_STM", &tmp))) ||
+		(ACPI_SUCCESS(acpi_get_handle(handle, "_SDD", &tmp))))
+		return 0;
+
+	if (acpi_get_parent(handle, &phandle))
+		return -ENODEV;
+
+        if ((ACPI_SUCCESS(acpi_get_handle(phandle, "_GTF", &tmp))) ||
+                (ACPI_SUCCESS(acpi_get_handle(phandle, "_GTM", &tmp))) ||
+                (ACPI_SUCCESS(acpi_get_handle(phandle, "_STM", &tmp))) ||
+                (ACPI_SUCCESS(acpi_get_handle(phandle, "_SDD", &tmp))))
+                return 0;
+
+	return -ENODEV;
+}
+
 static void acpi_device_set_id(struct acpi_device *device,
 			       struct acpi_device *parent, acpi_handle handle,
 			       int type)
@@ -872,6 +908,10 @@ static void acpi_device_set_id(struct acpi_device *device,
 			status = acpi_video_bus_match(device);
 			if(ACPI_SUCCESS(status))
 				hid = ACPI_VIDEO_HID;
+
+			status = acpi_bay_match(device);
+			if (ACPI_SUCCESS(status))
+				hid = ACPI_BAY_HID;
 		}
 		break;
 	case ACPI_BUS_TYPE_POWER:

commit 975a8e3ed2b9eab9f062a1e0ba7fe180e15204e1
Merge: 1fcb71b84b05 bfd80223d73f
Author: Len Brown <len.brown@intel.com>
Date:   Sat Feb 3 01:14:35 2007 -0500

    Pull sysfs into test branch
    
    Conflicts:
    
            Documentation/feature-removal-schedule.txt
            include/acpi/acpi_drivers.h
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit cee324b145a1e5488b34191de670e5ed1d346ebb
Author: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Fri Feb 2 19:48:22 2007 +0300

    ACPICA: use new ACPI headers.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b1692b18c9d7..0de458664642 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1333,7 +1333,7 @@ static int acpi_bus_scan_fixed(struct acpi_device *root)
 	/*
 	 * Enumerate all fixed-feature devices.
 	 */
-	if ((acpi_fadt.flags & ACPI_FADT_POWER_BUTTON) == 0) {
+	if ((acpi_gbl_FADT.flags & ACPI_FADT_POWER_BUTTON) == 0) {
 		result = acpi_add_single_object(&device, acpi_root,
 						NULL,
 						ACPI_BUS_TYPE_POWER_BUTTON);
@@ -1341,7 +1341,7 @@ static int acpi_bus_scan_fixed(struct acpi_device *root)
 			result = acpi_start_single_object(device);
 	}
 
-	if ((acpi_fadt.flags & ACPI_FADT_SLEEP_BUTTON) == 0) {
+	if ((acpi_gbl_FADT.flags & ACPI_FADT_SLEEP_BUTTON) == 0) {
 		result = acpi_add_single_object(&device, acpi_root,
 						NULL,
 						ACPI_BUS_TYPE_SLEEP_BUTTON);

commit ad71860a17ba33eb0e673e9e2cf5ba0d8e3e3fdd
Author: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Fri Feb 2 19:48:19 2007 +0300

    ACPICA: minimal patch to integrate new tables into Linux
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 283d87522c5d..b1692b18c9d7 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1333,7 +1333,7 @@ static int acpi_bus_scan_fixed(struct acpi_device *root)
 	/*
 	 * Enumerate all fixed-feature devices.
 	 */
-	if (acpi_fadt.pwr_button == 0) {
+	if ((acpi_fadt.flags & ACPI_FADT_POWER_BUTTON) == 0) {
 		result = acpi_add_single_object(&device, acpi_root,
 						NULL,
 						ACPI_BUS_TYPE_POWER_BUTTON);
@@ -1341,7 +1341,7 @@ static int acpi_bus_scan_fixed(struct acpi_device *root)
 			result = acpi_start_single_object(device);
 	}
 
-	if (acpi_fadt.sleep_button == 0) {
+	if ((acpi_fadt.flags & ACPI_FADT_SLEEP_BUTTON) == 0) {
 		result = acpi_add_single_object(&device, acpi_root,
 						NULL,
 						ACPI_BUS_TYPE_SLEEP_BUTTON);

commit 7ac2735462349ca35d8807d93d66cf4d9ea7b729
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jan 30 02:13:44 2007 -0500

    ACPI: delete unused acpi_device_get_debug_info()
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 0bd788a64eb3..2e0fc8c3b58b 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -888,49 +888,6 @@ static int acpi_device_set_context(struct acpi_device *device, int type)
 	return result;
 }
 
-static void acpi_device_get_debug_info(struct acpi_device *device,
-				       acpi_handle handle, int type)
-{
-#ifdef ACPI_DEBUG_OUTPUT
-	char *type_string = NULL;
-	char name[80] = { '?', '\0' };
-	struct acpi_buffer buffer = { sizeof(name), name };
-
-	switch (type) {
-	case ACPI_BUS_TYPE_DEVICE:
-		type_string = "Device";
-		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
-		break;
-	case ACPI_BUS_TYPE_POWER:
-		type_string = "Power Resource";
-		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
-		break;
-	case ACPI_BUS_TYPE_PROCESSOR:
-		type_string = "Processor";
-		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
-		break;
-	case ACPI_BUS_TYPE_SYSTEM:
-		type_string = "System";
-		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
-		break;
-	case ACPI_BUS_TYPE_THERMAL:
-		type_string = "Thermal Zone";
-		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
-		break;
-	case ACPI_BUS_TYPE_POWER_BUTTON:
-		type_string = "Power Button";
-		sprintf(name, "PWRB");
-		break;
-	case ACPI_BUS_TYPE_SLEEP_BUTTON:
-		type_string = "Sleep Button";
-		sprintf(name, "SLPB");
-		break;
-	}
-
-	printk(KERN_DEBUG "Found %s %s [%p]\n", type_string, name, handle);
-#endif				/* ACPI_DEBUG_OUTPUT */
-}
-
 static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 {
 	int result = 0;
@@ -1076,8 +1033,6 @@ acpi_add_single_object(struct acpi_device **child,
 	if ((result = acpi_device_set_context(device, type)))
 		goto end;
 
-	acpi_device_get_debug_info(device, handle, type);
-
 	acpi_device_register(device, parent);
 
 	/*

commit 37cabc81640ddba28a2aa7f0d1286a1012eae248
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Sat Jan 27 01:55:18 2007 -0500

    ACPI: Correct ACPI_DEBUG_OUTPUT typo
    
    -#ifdef CONFIG_ACPI_DEBUG_OUTPUT
    +#ifdef ACPI_DEBUG_OUTPUT
    
    As the former doesn't exist.
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 283d87522c5d..0bd788a64eb3 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -891,7 +891,7 @@ static int acpi_device_set_context(struct acpi_device *device, int type)
 static void acpi_device_get_debug_info(struct acpi_device *device,
 				       acpi_handle handle, int type)
 {
-#ifdef CONFIG_ACPI_DEBUG_OUTPUT
+#ifdef ACPI_DEBUG_OUTPUT
 	char *type_string = NULL;
 	char name[80] = { '?', '\0' };
 	struct acpi_buffer buffer = { sizeof(name), name };
@@ -928,7 +928,7 @@ static void acpi_device_get_debug_info(struct acpi_device *device,
 	}
 
 	printk(KERN_DEBUG "Found %s %s [%p]\n", type_string, name, handle);
-#endif				/*CONFIG_ACPI_DEBUG_OUTPUT */
+#endif				/* ACPI_DEBUG_OUTPUT */
 }
 
 static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)

commit bb0958544f3c7c016b2a3025ab3694363e403aa1
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Jan 4 15:03:18 2007 +0800

    ACPI: use more understandable bus_id for ACPI devices
    
    Some of the ACPI devices use the internal fake hids
    which are exposed to userspace as devces' bus_id after sysfs conversion.
    To make it more friendly, we convert them to more understandable strings.
    
    For those devices w/o PNPids, we use "device:instance_no" as the bus_id
    instead of "PNPIDNON:instance_no".
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 30a39baeac51..4139e65d0ff5 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -26,7 +26,7 @@ DEFINE_SPINLOCK(acpi_device_lock);
 LIST_HEAD(acpi_wakeup_device_list);
 
 struct acpi_device_bus_id{
-	char bus_id[9];
+	char bus_id[15];
 	unsigned int instance_no;
 	struct list_head node;
 };
@@ -342,7 +342,7 @@ static int acpi_device_register(struct acpi_device *device,
 	 * If failed, create one and link it into acpi_bus_id_list
 	 */
 	list_for_each_entry(acpi_device_bus_id, &acpi_bus_id_list, node) {
-		if(!strcmp(acpi_device_bus_id->bus_id, device->flags.hardware_id? device->pnp.hardware_id : "PNPIDNON")) {
+		if(!strcmp(acpi_device_bus_id->bus_id, device->flags.hardware_id? device->pnp.hardware_id : "device")) {
 			acpi_device_bus_id->instance_no ++;
 			found = 1;
 			kfree(new_bus_id);
@@ -351,7 +351,7 @@ static int acpi_device_register(struct acpi_device *device,
 	}
 	if(!found) {
 		acpi_device_bus_id = new_bus_id;
-		strcpy(acpi_device_bus_id->bus_id, device->flags.hardware_id ? device->pnp.hardware_id : "PNPIDNON");
+		strcpy(acpi_device_bus_id->bus_id, device->flags.hardware_id ? device->pnp.hardware_id : "device");
 		acpi_device_bus_id->instance_no = 0;
 		list_add_tail(&acpi_device_bus_id->node, &acpi_bus_id_list);
 	}

commit 2786f6e388e9dfe9e7b1c3c6bd7fcfba9cfb9831
Author: Rui Zhang <rui.zhang@intel.com>
Date:   Thu Dec 21 02:21:13 2006 -0500

    ACPI: fix Supermicro X7DB8+ Boot regression
    
    http://bugzilla.kernel.org/show_bug.cgi?id=7695
    
    Originally we converted bind/unbind to use a new pci bridge driver.
    The driver will add/remove _PRT, so we can eventually remove
    .bind/.unbind methods.
    
    But we found that some of the _ADR-Based devices don't have _PRT,
    i.e. they are not managed by the new ACPI PCI bridge driver.
    So that .bind method is not called for some _ADR-Based devices,
    which leads to a failure.
    
    Now we make ACPI PCI Root Bridge Driver scan and binds all _ADR-Based devices
    once the driver is loaded, in the .add method of ACPI PCI Root Bridge driver.
    
    Extra code path for calling .bind/.unbind when _ADR-Based devices
    are hot added/removed is also added.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 769e54bc9226..30a39baeac51 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -837,20 +837,6 @@ acpi_video_bus_match(struct acpi_device *device)
 	return -ENODEV;
 }
 
-static int acpi_pci_bridge_match(struct acpi_device *device)
-{
-       acpi_status status;
-       acpi_handle handle;
-
-       /* pci bridge has _PRT but isn't PNP0A03 */
-       status = acpi_get_handle(device->handle, METHOD_NAME__PRT, &handle);
-       if (ACPI_FAILURE(status))
-               return -ENODEV;
-       if (!acpi_match_ids(device, "PNP0A03"))
-               return -ENODEV;
-       return 0;
-}
-
 static void acpi_device_set_id(struct acpi_device *device,
 			       struct acpi_device *parent, acpi_handle handle,
 			       int type)
@@ -886,10 +872,6 @@ static void acpi_device_set_id(struct acpi_device *device,
 			status = acpi_video_bus_match(device);
 			if(ACPI_SUCCESS(status))
 				hid = ACPI_VIDEO_HID;
-
-			status = acpi_pci_bridge_match(device);
-			if(ACPI_SUCCESS(status))
-				hid = ACPI_PCI_BRIDGE_HID;
 		}
 		break;
 	case ACPI_BUS_TYPE_POWER:
@@ -1021,6 +1003,13 @@ static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 	if (!rmdevice)
 		return 0;
 
+	/*
+	 * unbind _ADR-Based Devices when hot removal
+	 */
+	if (dev->flags.bus_address) {
+		if ((dev->parent) && (dev->parent->ops.unbind))
+			dev->parent->ops.unbind(dev);
+	}
 	acpi_device_unregister(dev, ACPI_BUS_REMOVAL_EJECT);
 
 	return 0;
@@ -1137,6 +1126,14 @@ acpi_add_single_object(struct acpi_device **child,
 
 	result = acpi_device_register(device, parent);
 
+	/*
+	 * Bind _ADR-Based Devices when hot add
+	 */
+	if (device->flags.bus_address) {
+		if (device->parent && device->parent->ops.bind)
+			device->parent->ops.bind(device);
+	}
+
       end:
 	if (!result)
 		*child = device;

commit e49bd2dd5a503bb94fe2f2af45422b610940b75d
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri Dec 8 17:23:43 2006 +0800

    ACPI: use PNPID:instance_no as bus_id of ACPI device
    
    Previously we used the device name in the DSDT, but would
    crash upon encountering a duplicate. Also, exposing the
    DSDT device name to the user in a patch isn't a good idea,
    because it is arbitrary.
    
    After some discussion, we finally decided to use
    "PNPID:instance_no" as the bus_id of ACPI devices.
    
    Two attributes for each device are added at the same time,
    the full pathname in ACPI namespace and hardware_id if it has.
    
    NOTE:   acpi_bus_id_list is used to keep the information of PNPID
            and instance number of the given PNPID. Loop the
            acpi_bus_id_list to find the instance_no of the same PNPID
            when register a device. If failed, i.e. we don't have a
            node with this PNPID, allocate one and link it to this list.
    
    NOTE:   Now I don't take the memory free work in charge.
            If necessary, I can add a reference count in
            struct acpi_device_bus_id, and check the reference and
            when unregister a device, i.e. memory is freed when
            the reference count of a given PNPID is 0.
    
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 9efe3e9dbf21..769e54bc9226 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -21,9 +21,15 @@ extern struct acpi_device *acpi_root;
 #define ACPI_BUS_DEVICE_NAME		"System Bus"
 
 static LIST_HEAD(acpi_device_list);
+static LIST_HEAD(acpi_bus_id_list);
 DEFINE_SPINLOCK(acpi_device_lock);
 LIST_HEAD(acpi_wakeup_device_list);
 
+struct acpi_device_bus_id{
+	char bus_id[9];
+	unsigned int instance_no;
+	struct list_head node;
+};
 static int acpi_eject_operation(acpi_handle handle, int lockable)
 {
 	struct acpi_object_list arg_list;
@@ -103,18 +109,61 @@ acpi_eject_store(struct device *d, struct device_attribute *attr,
 
 static DEVICE_ATTR(eject, 0200, NULL, acpi_eject_store);
 
-static void acpi_device_setup_files(struct acpi_device *dev)
+static ssize_t
+acpi_device_hid_show(struct device *dev, struct device_attribute *attr, char *buf) {
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+
+	return sprintf(buf, "%s\n", acpi_dev->pnp.hardware_id);
+}
+static DEVICE_ATTR(hid, 0444, acpi_device_hid_show, NULL);
+
+static ssize_t
+acpi_device_path_show(struct device *dev, struct device_attribute *attr, char *buf) {
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+	struct acpi_buffer path = {ACPI_ALLOCATE_BUFFER, NULL};
+	int result;
+
+	result = acpi_get_name(acpi_dev->handle, ACPI_FULL_PATHNAME, &path);
+	if(result)
+		goto end;
+
+	result = sprintf(buf, "%s\n", (char*)path.pointer);
+	kfree(path.pointer);
+  end:
+	return result;
+}
+static DEVICE_ATTR(path, 0444, acpi_device_path_show, NULL);
+
+static int acpi_device_setup_files(struct acpi_device *dev)
 {
 	acpi_status status;
 	acpi_handle temp;
+	int result = 0;
 
 	/*
-	 * If device has _EJ0, 'eject' file is created that is used to trigger
-	 * hot-removal function from userland.
+	 * Devices gotten from FADT don't have a "path" attribute
 	 */
+	if(dev->handle) {
+		result = device_create_file(&dev->dev, &dev_attr_path);
+		if(result)
+			goto end;
+	}
+
+	if(dev->flags.hardware_id) {
+		result = device_create_file(&dev->dev, &dev_attr_hid);
+		if(result)
+			goto end;
+	}
+
+        /*
+         * If device has _EJ0, 'eject' file is created that is used to trigger
+         * hot-removal function from userland.
+         */
 	status = acpi_get_handle(dev->handle, "_EJ0", &temp);
 	if (ACPI_SUCCESS(status))
-		device_create_file(&dev->dev, &dev_attr_eject);
+		result = device_create_file(&dev->dev, &dev_attr_eject);
+  end:
+	return result;
 }
 
 static void acpi_device_remove_files(struct acpi_device *dev)
@@ -129,6 +178,11 @@ static void acpi_device_remove_files(struct acpi_device *dev)
 	status = acpi_get_handle(dev->handle, "_EJ0", &temp);
 	if (ACPI_SUCCESS(status))
 		device_remove_file(&dev->dev, &dev_attr_eject);
+
+	if(dev->flags.hardware_id)
+		device_remove_file(&dev->dev, &dev_attr_hid);
+	if(dev->handle)
+		device_remove_file(&dev->dev, &dev_attr_path);
 }
 /* --------------------------------------------------------------------------
 			ACPI Bus operations
@@ -260,9 +314,12 @@ static struct bus_type acpi_bus_type = {
 	.uevent		= acpi_device_uevent,
 };
 
-static void acpi_device_register(struct acpi_device *device,
+static int acpi_device_register(struct acpi_device *device,
 				 struct acpi_device *parent)
 {
+	int result;
+	struct acpi_device_bus_id *acpi_device_bus_id, *new_bus_id;
+	int found = 0;
 	/*
 	 * Linkage
 	 * -------
@@ -273,7 +330,33 @@ static void acpi_device_register(struct acpi_device *device,
 	INIT_LIST_HEAD(&device->g_list);
 	INIT_LIST_HEAD(&device->wakeup_list);
 
+	new_bus_id = kzalloc(sizeof(struct acpi_device_bus_id), GFP_KERNEL);
+	if (!new_bus_id) {
+		printk(KERN_ERR PREFIX "Memory allocation error\n");
+		return -ENOMEM;
+	}
+
 	spin_lock(&acpi_device_lock);
+	/*
+	 * Find suitable bus_id and instance number in acpi_bus_id_list
+	 * If failed, create one and link it into acpi_bus_id_list
+	 */
+	list_for_each_entry(acpi_device_bus_id, &acpi_bus_id_list, node) {
+		if(!strcmp(acpi_device_bus_id->bus_id, device->flags.hardware_id? device->pnp.hardware_id : "PNPIDNON")) {
+			acpi_device_bus_id->instance_no ++;
+			found = 1;
+			kfree(new_bus_id);
+			break;
+		}
+	}
+	if(!found) {
+		acpi_device_bus_id = new_bus_id;
+		strcpy(acpi_device_bus_id->bus_id, device->flags.hardware_id ? device->pnp.hardware_id : "PNPIDNON");
+		acpi_device_bus_id->instance_no = 0;
+		list_add_tail(&acpi_device_bus_id->node, &acpi_bus_id_list);
+	}
+	sprintf(device->dev.bus_id, "%s:%02x", acpi_device_bus_id->bus_id, acpi_device_bus_id->instance_no);
+
 	if (device->parent) {
 		list_add_tail(&device->node, &device->parent->children);
 		list_add_tail(&device->g_list, &device->parent->g_list);
@@ -287,12 +370,29 @@ static void acpi_device_register(struct acpi_device *device,
 		device->dev.parent = &parent->dev;
 	device->dev.bus = &acpi_bus_type;
 	device_initialize(&device->dev);
-	sprintf(device->dev.bus_id, "%s", device->pnp.bus_id);
 	device->dev.release = &acpi_device_release;
-	device_add(&device->dev);
+	result = device_add(&device->dev);
+	if(result) {
+		printk("Error adding device %s", device->dev.bus_id);
+		goto end;
+	}
+
+	result = acpi_device_setup_files(device);
+	if(result)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error creating sysfs interface for device %s\n", device->dev.bus_id));
 
-	acpi_device_setup_files(device);
 	device->removal_type = ACPI_BUS_REMOVAL_NORMAL;
+	return 0;
+  end:
+	spin_lock(&acpi_device_lock);
+	if (device->parent) {
+		list_del(&device->node);
+		list_del(&device->g_list);
+	} else
+		list_del(&device->g_list);
+	list_del(&device->wakeup_list);
+	spin_unlock(&acpi_device_lock);
+	return result;
 }
 
 static void acpi_device_unregister(struct acpi_device *device, int type)
@@ -1035,7 +1135,7 @@ acpi_add_single_object(struct acpi_device **child,
 
 	acpi_device_get_debug_info(device, handle, type);
 
-	acpi_device_register(device, parent);
+	result = acpi_device_register(device, parent);
 
       end:
 	if (!result)

commit 36bcbec7ce21e2e8b3143b11a05747330abeca70
Author: Burman Yan <yan_952@hotmail.com>
Date:   Tue Dec 19 12:56:11 2006 -0800

    ACPI: replace kmalloc+memset with kzalloc
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 698a1540e303..283d87522c5d 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -984,12 +984,11 @@ acpi_add_single_object(struct acpi_device **child,
 	if (!child)
 		return -EINVAL;
 
-	device = kmalloc(sizeof(struct acpi_device), GFP_KERNEL);
+	device = kzalloc(sizeof(struct acpi_device), GFP_KERNEL);
 	if (!device) {
 		printk(KERN_ERR PREFIX "Memory allocation error\n");
 		return -ENOMEM;
 	}
-	memset(device, 0, sizeof(struct acpi_device));
 
 	device->handle = handle;
 	device->parent = parent;

commit ae8433324be16673c75951986dcf85f29c090557
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Dec 7 20:57:10 2006 +0800

    ACPI: Set fake hid for non-PNPID ACPI devices
    
    We do this mainly because:
    1.      hid is used to match ACPI devices and drivers.
            .match method which is incompatible to driver model
            can be deleted from acpi_driver.ops then.
    2.      As the .uevent method mark ACPI drivers by PNPID,
            fake hid is set to non-PNPID devices so that udev script
            can load the right ACPI driver by looking for
            "HWID = " or "COMPTID = ".
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c566c74e8a31..9efe3e9dbf21 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -166,8 +166,6 @@ static int acpi_bus_match(struct device *dev, struct device_driver *drv)
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
 	struct acpi_driver *acpi_drv = to_acpi_driver(drv);
 
-	if (acpi_drv->ops.match)
-		return !acpi_drv->ops.match(acpi_dev, acpi_drv);
 	return !acpi_match_ids(acpi_dev, acpi_drv->ids);
 }
 
@@ -706,6 +704,53 @@ static void acpi_device_get_busid(struct acpi_device *device,
 	}
 }
 
+static int
+acpi_video_bus_match(struct acpi_device *device)
+{
+	acpi_handle h_dummy1;
+	acpi_handle h_dummy2;
+	acpi_handle h_dummy3;
+
+
+	if (!device)
+		return -EINVAL;
+
+	/* Since there is no HID, CID for ACPI Video drivers, we have
+	 * to check well known required nodes for each feature we support.
+	 */
+
+	/* Does this device able to support video switching ? */
+	if (ACPI_SUCCESS(acpi_get_handle(device->handle, "_DOD", &h_dummy1)) &&
+	    ACPI_SUCCESS(acpi_get_handle(device->handle, "_DOS", &h_dummy2)))
+		return 0;
+
+	/* Does this device able to retrieve a video ROM ? */
+	if (ACPI_SUCCESS(acpi_get_handle(device->handle, "_ROM", &h_dummy1)))
+		return 0;
+
+	/* Does this device able to configure which video head to be POSTed ? */
+	if (ACPI_SUCCESS(acpi_get_handle(device->handle, "_VPO", &h_dummy1)) &&
+	    ACPI_SUCCESS(acpi_get_handle(device->handle, "_GPD", &h_dummy2)) &&
+	    ACPI_SUCCESS(acpi_get_handle(device->handle, "_SPD", &h_dummy3)))
+		return 0;
+
+	return -ENODEV;
+}
+
+static int acpi_pci_bridge_match(struct acpi_device *device)
+{
+       acpi_status status;
+       acpi_handle handle;
+
+       /* pci bridge has _PRT but isn't PNP0A03 */
+       status = acpi_get_handle(device->handle, METHOD_NAME__PRT, &handle);
+       if (ACPI_FAILURE(status))
+               return -ENODEV;
+       if (!acpi_match_ids(device, "PNP0A03"))
+               return -ENODEV;
+       return 0;
+}
+
 static void acpi_device_set_id(struct acpi_device *device,
 			       struct acpi_device *parent, acpi_handle handle,
 			       int type)
@@ -736,6 +781,16 @@ static void acpi_device_set_id(struct acpi_device *device,
 			device->pnp.bus_address = info->address;
 			device->flags.bus_address = 1;
 		}
+
+		if(!(info->valid & (ACPI_VALID_HID | ACPI_VALID_CID))){
+			status = acpi_video_bus_match(device);
+			if(ACPI_SUCCESS(status))
+				hid = ACPI_VIDEO_HID;
+
+			status = acpi_pci_bridge_match(device);
+			if(ACPI_SUCCESS(status))
+				hid = ACPI_PCI_BRIDGE_HID;
+		}
 		break;
 	case ACPI_BUS_TYPE_POWER:
 		hid = ACPI_POWER_HID;

commit db3e1cc3257758d8a694d0a6ab29f109fb019853
Author: Li Shaohua <shaohua.li@intel.com>
Date:   Thu Dec 7 20:57:05 2006 +0800

    ACPI: Convert ACPI PCI .bind/.unbind to use PCI bridge driver
    
    acpi_device had a .bind/.unbind methods, but Linux driver model does not.
    Cut ACPI PCI code over to use the Linux driver model methods.
    
    Convert bind/unbind to use a new pci bridge driver.
    The driver will add/remove _PRT, so we can eventually
    remove .bind/.unbind methods.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 06b86faf037f..c566c74e8a31 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -866,11 +866,6 @@ static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 	if (!rmdevice)
 		return 0;
 
-	if (dev->flags.bus_address) {
-		if ((dev->parent) && (dev->parent->ops.unbind))
-			dev->parent->ops.unbind(dev);
-	}
-
 	acpi_device_unregister(dev, ACPI_BUS_REMOVAL_EJECT);
 
 	return 0;
@@ -987,18 +982,6 @@ acpi_add_single_object(struct acpi_device **child,
 
 	acpi_device_register(device, parent);
 
-	/*
-	 * Bind _ADR-Based Devices
-	 * -----------------------
-	 * If there's a a bus address (_ADR) then we utilize the parent's 
-	 * 'bind' function (if exists) to bind the ACPI- and natively-
-	 * enumerated device representations.
-	 */
-	if (device->flags.bus_address) {
-		if (device->parent && device->parent->ops.bind)
-			device->parent->ops.bind(device);
-	}
-
       end:
 	if (!result)
 		*child = device;

commit 96333578b023957537c3e98b50af7f3b7e08e411
Author: Li Shaohua <shaohua.li@intel.com>
Date:   Thu Dec 7 20:56:46 2006 +0800

    ACPI: add acpi_bus_removal_type in acpi_device
    
    Add removal_type in structure acpi_device for hot removal.
    
    ACPI_BUS_REMOVAL_EJECT is used for ACPI device hot removal.
    Only one parameter is allowed in .remove method due to driver model.
    So removal_type is added to indicate different removal type.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 2a82645c9dfe..06b86faf037f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -229,9 +229,9 @@ static int acpi_device_remove(struct device * dev)
 
 	if (acpi_drv) {
 		if (acpi_drv->ops.stop)
-			acpi_drv->ops.stop(acpi_dev, ACPI_BUS_REMOVAL_NORMAL);
+			acpi_drv->ops.stop(acpi_dev, acpi_dev->removal_type);
 		if (acpi_drv->ops.remove)
-			acpi_drv->ops.remove(acpi_dev, ACPI_BUS_REMOVAL_NORMAL);
+			acpi_drv->ops.remove(acpi_dev, acpi_dev->removal_type);
 	}
 	acpi_dev->driver = NULL;
 	acpi_driver_data(dev) = NULL;
@@ -294,6 +294,7 @@ static void acpi_device_register(struct acpi_device *device,
 	device_add(&device->dev);
 
 	acpi_device_setup_files(device);
+	device->removal_type = ACPI_BUS_REMOVAL_NORMAL;
 }
 
 static void acpi_device_unregister(struct acpi_device *device, int type)
@@ -859,6 +860,7 @@ static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 	if (!dev)
 		return -EINVAL;
 
+	dev->removal_type = ACPI_BUS_REMOVAL_EJECT;
 	device_release_driver(&dev->dev);
 
 	if (!rmdevice)

commit c4168bff32e218b8400cb48b48adb9b7f7bb31b8
Author: Li Shaohua <shaohua.li@intel.com>
Date:   Thu Dec 7 20:56:41 2006 +0800

    ACPI: add acpi_bus_ops in acpi_device
    
    Add acpi_bus_ops in acpi_device to support acpi hot plug.
    
    NOTE:   Two methods .add and .start in acpi_driver.ops are
            called separately to probe ACPI devices, while only
            .probe method is called in driver model.
            As executing .add and .start separately is critical
            for ACPI device hot plug, we use acpi_bus_ops to
            distinguish different code path.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 97f6bbd6ef3c..2a82645c9dfe 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -212,7 +212,8 @@ static int acpi_device_probe(struct device * dev)
 
 	ret = acpi_bus_driver_init(acpi_dev, acpi_drv);
 	if (!ret) {
-		acpi_start_single_object(acpi_dev);
+		if (acpi_dev->bus_ops.acpi_op_start)
+			acpi_start_single_object(acpi_dev);
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			"Found driver [%s] for device [%s]\n",
 			acpi_drv->name, acpi_dev->pnp.bus_id));
@@ -305,7 +306,6 @@ static void acpi_device_unregister(struct acpi_device *device, int type)
 		list_del(&device->g_list);
 
 	list_del(&device->wakeup_list);
-
 	spin_unlock(&acpi_device_lock);
 
 	acpi_detach_data(device->handle, acpi_bus_data_handler);
@@ -876,7 +876,8 @@ static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 
 static int
 acpi_add_single_object(struct acpi_device **child,
-		       struct acpi_device *parent, acpi_handle handle, int type)
+		       struct acpi_device *parent, acpi_handle handle, int type,
+			struct acpi_bus_ops *ops)
 {
 	int result = 0;
 	struct acpi_device *device = NULL;
@@ -894,6 +895,8 @@ acpi_add_single_object(struct acpi_device **child,
 
 	device->handle = handle;
 	device->parent = parent;
+	device->bus_ops = *ops; /* workround for not call .start */
+
 
 	acpi_device_get_busid(device, handle, type);
 
@@ -1079,14 +1082,14 @@ static int acpi_bus_scan(struct acpi_device *start, struct acpi_bus_ops *ops)
 
 		if (ops->acpi_op_add)
 			status = acpi_add_single_object(&child, parent,
-							chandle, type);
+				chandle, type, ops);
 		else
 			status = acpi_bus_get_device(chandle, &child);
 
 		if (ACPI_FAILURE(status))
 			continue;
 
-		if (ops->acpi_op_start) {
+		if (ops->acpi_op_start && !(ops->acpi_op_add)) {
 			status = acpi_start_single_object(child);
 			if (ACPI_FAILURE(status))
 				continue;
@@ -1124,13 +1127,13 @@ acpi_bus_add(struct acpi_device **child,
 	int result;
 	struct acpi_bus_ops ops;
 
+	memset(&ops, 0, sizeof(ops));
+	ops.acpi_op_add = 1;
 
-	result = acpi_add_single_object(child, parent, handle, type);
-	if (!result) {
-		memset(&ops, 0, sizeof(ops));
-		ops.acpi_op_add = 1;
+	result = acpi_add_single_object(child, parent, handle, type, &ops);
+	if (!result)
 		result = acpi_bus_scan(*child, &ops);
-	}
+
 	return result;
 }
 
@@ -1216,28 +1219,30 @@ static int acpi_bus_scan_fixed(struct acpi_device *root)
 {
 	int result = 0;
 	struct acpi_device *device = NULL;
-
+	struct acpi_bus_ops ops;
 
 	if (!root)
 		return -ENODEV;
 
+	memset(&ops, 0, sizeof(ops));
+	ops.acpi_op_add = 1;
+	ops.acpi_op_start = 1;
+
 	/*
 	 * Enumerate all fixed-feature devices.
 	 */
 	if (acpi_fadt.pwr_button == 0) {
 		result = acpi_add_single_object(&device, acpi_root,
 						NULL,
-						ACPI_BUS_TYPE_POWER_BUTTON);
-		if (!result)
-			result = acpi_start_single_object(device);
+						ACPI_BUS_TYPE_POWER_BUTTON,
+						&ops);
 	}
 
 	if (acpi_fadt.sleep_button == 0) {
 		result = acpi_add_single_object(&device, acpi_root,
 						NULL,
-						ACPI_BUS_TYPE_SLEEP_BUTTON);
-		if (!result)
-			result = acpi_start_single_object(device);
+						ACPI_BUS_TYPE_SLEEP_BUTTON,
+						&ops);
 	}
 
 	return result;
@@ -1252,6 +1257,10 @@ static int __init acpi_scan_init(void)
 	if (acpi_disabled)
 		return 0;
 
+	memset(&ops, 0, sizeof(ops));
+	ops.acpi_op_add = 1;
+	ops.acpi_op_start = 1;
+
 	result = bus_register(&acpi_bus_type);
 	if (result) {
 		/* We don't want to quit even if we failed to add suspend/resume */
@@ -1262,11 +1271,7 @@ static int __init acpi_scan_init(void)
 	 * Create the root device in the bus's device tree
 	 */
 	result = acpi_add_single_object(&acpi_root, NULL, ACPI_ROOT_OBJECT,
-					ACPI_BUS_TYPE_SYSTEM);
-	if (result)
-		goto Done;
-
-	result = acpi_start_single_object(acpi_root);
+					ACPI_BUS_TYPE_SYSTEM, &ops);
 	if (result)
 		goto Done;
 
@@ -1274,12 +1279,8 @@ static int __init acpi_scan_init(void)
 	 * Enumerate devices in the ACPI namespace.
 	 */
 	result = acpi_bus_scan_fixed(acpi_root);
-	if (!result) {
-		memset(&ops, 0, sizeof(ops));
-		ops.acpi_op_add = 1;
-		ops.acpi_op_start = 1;
+	if (!result)
 		result = acpi_bus_scan(acpi_root, &ops);
-	}
 
 	if (result)
 		acpi_device_unregister(acpi_root, ACPI_BUS_REMOVAL_NORMAL);

commit f883d9db008deb20d4969c26475100cec2b7f6f8
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Thu Dec 7 20:56:38 2006 +0800

    ACPI: convert to sysfs framework
    
    Setup new sysfs framework
    
    1.      Remove /sys/firmware/acpi
    2.      Add ACPI device in device tree.
    
    File "eject" for every device that has _EJ0 method is moved from
    /sys/firmware to /sys/devices.
    Operation on this file is exactly the same as before.
    i.e. echo 1 to "eject" will cause hot removal of this device.
    Corresponding changes should be made in userspace for hot removal.
    
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Zhang Rui<rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b616e17de522..97f6bbd6ef3c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -24,126 +24,6 @@ static LIST_HEAD(acpi_device_list);
 DEFINE_SPINLOCK(acpi_device_lock);
 LIST_HEAD(acpi_wakeup_device_list);
 
-
-static void acpi_device_release_legacy(struct kobject *kobj)
-{
-	struct acpi_device *dev = container_of(kobj, struct acpi_device, kobj);
-	kfree(dev->pnp.cid_list);
-	kfree(dev);
-}
-
-struct acpi_device_attribute {
-	struct attribute attr;
-	 ssize_t(*show) (struct acpi_device *, char *);
-	 ssize_t(*store) (struct acpi_device *, const char *, size_t);
-};
-
-typedef void acpi_device_sysfs_files(struct kobject *,
-				     const struct attribute *);
-
-static void setup_sys_fs_device_files(struct acpi_device *dev,
-				      acpi_device_sysfs_files * func);
-
-#define create_sysfs_device_files(dev)	\
-	setup_sys_fs_device_files(dev, (acpi_device_sysfs_files *)&sysfs_create_file)
-#define remove_sysfs_device_files(dev)	\
-	setup_sys_fs_device_files(dev, (acpi_device_sysfs_files *)&sysfs_remove_file)
-
-#define to_acpi_dev(n) container_of(n, struct acpi_device, kobj)
-#define to_handle_attr(n) container_of(n, struct acpi_device_attribute, attr);
-
-static ssize_t acpi_device_attr_show(struct kobject *kobj,
-				     struct attribute *attr, char *buf)
-{
-	struct acpi_device *device = to_acpi_dev(kobj);
-	struct acpi_device_attribute *attribute = to_handle_attr(attr);
-	return attribute->show ? attribute->show(device, buf) : -EIO;
-}
-static ssize_t acpi_device_attr_store(struct kobject *kobj,
-				      struct attribute *attr, const char *buf,
-				      size_t len)
-{
-	struct acpi_device *device = to_acpi_dev(kobj);
-	struct acpi_device_attribute *attribute = to_handle_attr(attr);
-	return attribute->store ? attribute->store(device, buf, len) : -EIO;
-}
-
-static struct sysfs_ops acpi_device_sysfs_ops = {
-	.show = acpi_device_attr_show,
-	.store = acpi_device_attr_store,
-};
-
-static struct kobj_type ktype_acpi_ns = {
-	.sysfs_ops = &acpi_device_sysfs_ops,
-	.release = acpi_device_release_legacy,
-};
-
-static int namespace_uevent(struct kset *kset, struct kobject *kobj,
-			     char **envp, int num_envp, char *buffer,
-			     int buffer_size)
-{
-	struct acpi_device *dev = to_acpi_dev(kobj);
-	int i = 0;
-	int len = 0;
-
-	if (!dev->driver)
-		return 0;
-
-	if (add_uevent_var(envp, num_envp, &i, buffer, buffer_size, &len,
-			   "PHYSDEVDRIVER=%s", dev->driver->name))
-		return -ENOMEM;
-
-	envp[i] = NULL;
-
-	return 0;
-}
-
-static struct kset_uevent_ops namespace_uevent_ops = {
-	.uevent = &namespace_uevent,
-};
-
-static struct kset acpi_namespace_kset = {
-	.kobj = {
-		 .name = "namespace",
-		 },
-	.subsys = &acpi_subsys,
-	.ktype = &ktype_acpi_ns,
-	.uevent_ops = &namespace_uevent_ops,
-};
-
-/* --------------------------------------------------------------------------
-		ACPI sysfs device file support
-   -------------------------------------------------------------------------- */
-static ssize_t acpi_eject_store(struct acpi_device *device,
-				const char *buf, size_t count);
-
-#define ACPI_DEVICE_ATTR(_name,_mode,_show,_store) \
-static struct acpi_device_attribute acpi_device_attr_##_name = \
-		__ATTR(_name, _mode, _show, _store)
-
-ACPI_DEVICE_ATTR(eject, 0200, NULL, acpi_eject_store);
-
-/**
- * setup_sys_fs_device_files - sets up the device files under device namespace
- * @dev:	acpi_device object
- * @func:	function pointer to create or destroy the device file
- */
-static void
-setup_sys_fs_device_files(struct acpi_device *dev,
-			  acpi_device_sysfs_files * func)
-{
-	acpi_status status;
-	acpi_handle temp = NULL;
-
-	/*
-	 * If device has _EJ0, 'eject' file is created that is used to trigger
-	 * hot-removal function from userland.
-	 */
-	status = acpi_get_handle(dev->handle, "_EJ0", &temp);
-	if (ACPI_SUCCESS(status))
-		(*(func)) (&dev->kobj, &acpi_device_attr_eject.attr);
-}
-
 static int acpi_eject_operation(acpi_handle handle, int lockable)
 {
 	struct acpi_object_list arg_list;
@@ -180,7 +60,8 @@ static int acpi_eject_operation(acpi_handle handle, int lockable)
 }
 
 static ssize_t
-acpi_eject_store(struct acpi_device *device, const char *buf, size_t count)
+acpi_eject_store(struct device *d, struct device_attribute *attr,
+		const char *buf, size_t count)
 {
 	int result;
 	int ret = count;
@@ -188,26 +69,27 @@ acpi_eject_store(struct acpi_device *device, const char *buf, size_t count)
 	acpi_status status;
 	acpi_handle handle;
 	acpi_object_type type = 0;
+	struct acpi_device *acpi_device = to_acpi_device(d);
 
 	if ((!count) || (buf[0] != '1')) {
 		return -EINVAL;
 	}
 #ifndef FORCE_EJECT
-	if (device->driver == NULL) {
+	if (acpi_device->driver == NULL) {
 		ret = -ENODEV;
 		goto err;
 	}
 #endif
-	status = acpi_get_type(device->handle, &type);
-	if (ACPI_FAILURE(status) || (!device->flags.ejectable)) {
+	status = acpi_get_type(acpi_device->handle, &type);
+	if (ACPI_FAILURE(status) || (!acpi_device->flags.ejectable)) {
 		ret = -ENODEV;
 		goto err;
 	}
 
-	islockable = device->flags.lockable;
-	handle = device->handle;
+	islockable = acpi_device->flags.lockable;
+	handle = acpi_device->handle;
 
-	result = acpi_bus_trim(device, 1);
+	result = acpi_bus_trim(acpi_device, 1);
 
 	if (!result)
 		result = acpi_eject_operation(handle, islockable);
@@ -219,6 +101,35 @@ acpi_eject_store(struct acpi_device *device, const char *buf, size_t count)
 	return ret;
 }
 
+static DEVICE_ATTR(eject, 0200, NULL, acpi_eject_store);
+
+static void acpi_device_setup_files(struct acpi_device *dev)
+{
+	acpi_status status;
+	acpi_handle temp;
+
+	/*
+	 * If device has _EJ0, 'eject' file is created that is used to trigger
+	 * hot-removal function from userland.
+	 */
+	status = acpi_get_handle(dev->handle, "_EJ0", &temp);
+	if (ACPI_SUCCESS(status))
+		device_create_file(&dev->dev, &dev_attr_eject);
+}
+
+static void acpi_device_remove_files(struct acpi_device *dev)
+{
+	acpi_status status;
+	acpi_handle temp;
+
+	/*
+	 * If device has _EJ0, 'eject' file is created that is used to trigger
+	 * hot-removal function from userland.
+	 */
+	status = acpi_get_handle(dev->handle, "_EJ0", &temp);
+	if (ACPI_SUCCESS(status))
+		device_remove_file(&dev->dev, &dev_attr_eject);
+}
 /* --------------------------------------------------------------------------
 			ACPI Bus operations
    -------------------------------------------------------------------------- */
@@ -353,8 +264,6 @@ static struct bus_type acpi_bus_type = {
 static void acpi_device_register(struct acpi_device *device,
 				 struct acpi_device *parent)
 {
-	int err;
-
 	/*
 	 * Linkage
 	 * -------
@@ -375,17 +284,6 @@ static void acpi_device_register(struct acpi_device *device,
 		list_add_tail(&device->wakeup_list, &acpi_wakeup_device_list);
 	spin_unlock(&acpi_device_lock);
 
-	strlcpy(device->kobj.name, device->pnp.bus_id, KOBJ_NAME_LEN);
-	if (parent)
-		device->kobj.parent = &parent->kobj;
-	device->kobj.ktype = &ktype_acpi_ns;
-	device->kobj.kset = &acpi_namespace_kset;
-	err = kobject_register(&device->kobj);
-	if (err < 0)
-		printk(KERN_WARNING "%s: kobject_register error: %d\n",
-			__FUNCTION__, err);
-	create_sysfs_device_files(device);
-
 	if (device->parent)
 		device->dev.parent = &parent->dev;
 	device->dev.bus = &acpi_bus_type;
@@ -393,6 +291,8 @@ static void acpi_device_register(struct acpi_device *device,
 	sprintf(device->dev.bus_id, "%s", device->pnp.bus_id);
 	device->dev.release = &acpi_device_release;
 	device_add(&device->dev);
+
+	acpi_device_setup_files(device);
 }
 
 static void acpi_device_unregister(struct acpi_device *device, int type)
@@ -409,9 +309,8 @@ static void acpi_device_unregister(struct acpi_device *device, int type)
 	spin_unlock(&acpi_device_lock);
 
 	acpi_detach_data(device->handle, acpi_bus_data_handler);
-	remove_sysfs_device_files(device);
-	kobject_unregister(&device->kobj);
 
+	acpi_device_remove_files(device);
 	device_unregister(&device->dev);
 }
 
@@ -1353,10 +1252,6 @@ static int __init acpi_scan_init(void)
 	if (acpi_disabled)
 		return 0;
 
-	result = kset_register(&acpi_namespace_kset);
-	if (result < 0)
-		printk(KERN_ERR PREFIX "kset_register error: %d\n", result);
-
 	result = bus_register(&acpi_bus_type);
 	if (result) {
 		/* We don't want to quit even if we failed to add suspend/resume */

commit 1890a97ab3f66d1e99768439f8067608b9b97fe3
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Thu Dec 7 20:56:31 2006 +0800

    ACPI: change registration interface to follow driver model
    
    ACPI device/driver registration Interfaces are modified
    to follow Linux driver model.
    
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 464746257d8e..b616e17de522 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -25,7 +25,7 @@ DEFINE_SPINLOCK(acpi_device_lock);
 LIST_HEAD(acpi_wakeup_device_list);
 
 
-static void acpi_device_release(struct kobject *kobj)
+static void acpi_device_release_legacy(struct kobject *kobj)
 {
 	struct acpi_device *dev = container_of(kobj, struct acpi_device, kobj);
 	kfree(dev->pnp.cid_list);
@@ -75,7 +75,7 @@ static struct sysfs_ops acpi_device_sysfs_ops = {
 
 static struct kobj_type ktype_acpi_ns = {
 	.sysfs_ops = &acpi_device_sysfs_ops,
-	.release = acpi_device_release,
+	.release = acpi_device_release_legacy,
 };
 
 static int namespace_uevent(struct kset *kset, struct kobject *kobj,
@@ -222,6 +222,14 @@ acpi_eject_store(struct acpi_device *device, const char *buf, size_t count)
 /* --------------------------------------------------------------------------
 			ACPI Bus operations
    -------------------------------------------------------------------------- */
+static void acpi_device_release(struct device *dev)
+{
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+
+	kfree(acpi_dev->pnp.cid_list);
+	kfree(acpi_dev);
+}
+
 static int acpi_device_suspend(struct device *dev, pm_message_t state)
 {
 	struct acpi_device *acpi_dev = to_acpi_device(dev);
@@ -377,6 +385,14 @@ static void acpi_device_register(struct acpi_device *device,
 		printk(KERN_WARNING "%s: kobject_register error: %d\n",
 			__FUNCTION__, err);
 	create_sysfs_device_files(device);
+
+	if (device->parent)
+		device->dev.parent = &parent->dev;
+	device->dev.bus = &acpi_bus_type;
+	device_initialize(&device->dev);
+	sprintf(device->dev.bus_id, "%s", device->pnp.bus_id);
+	device->dev.release = &acpi_device_release;
+	device_add(&device->dev);
 }
 
 static void acpi_device_unregister(struct acpi_device *device, int type)
@@ -395,20 +411,20 @@ static void acpi_device_unregister(struct acpi_device *device, int type)
 	acpi_detach_data(device->handle, acpi_bus_data_handler);
 	remove_sysfs_device_files(device);
 	kobject_unregister(&device->kobj);
+
+	device_unregister(&device->dev);
 }
 
 /* --------------------------------------------------------------------------
                                  Driver Management
    -------------------------------------------------------------------------- */
-static LIST_HEAD(acpi_bus_drivers);
-
 /**
  * acpi_bus_driver_init - add a device to a driver
  * @device: the device to add and initialize
  * @driver: driver for the device
  *
  * Used to initialize a device via its device driver.  Called whenever a 
- * driver is bound to a device.  Invokes the driver's add() and start() ops.
+ * driver is bound to a device.  Invokes the driver's add() ops.
  */
 static int
 acpi_bus_driver_init(struct acpi_device *device, struct acpi_driver *driver)
@@ -459,57 +475,6 @@ static int acpi_start_single_object(struct acpi_device *device)
 	return result;
 }
 
-static void acpi_driver_attach(struct acpi_driver *drv)
-{
-	struct list_head *node, *next;
-
-
-	spin_lock(&acpi_device_lock);
-	list_for_each_safe(node, next, &acpi_device_list) {
-		struct acpi_device *dev =
-		    container_of(node, struct acpi_device, g_list);
-
-		if (dev->driver || !dev->status.present)
-			continue;
-		spin_unlock(&acpi_device_lock);
-
-		if (!acpi_bus_match(&(dev->dev), &(drv->drv))) {
-			if (!acpi_bus_driver_init(dev, drv)) {
-				acpi_start_single_object(dev);
-				atomic_inc(&drv->references);
-				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-						  "Found driver [%s] for device [%s]\n",
-						  drv->name, dev->pnp.bus_id));
-			}
-		}
-		spin_lock(&acpi_device_lock);
-	}
-	spin_unlock(&acpi_device_lock);
-}
-
-static void acpi_driver_detach(struct acpi_driver *drv)
-{
-	struct list_head *node, *next;
-
-
-	spin_lock(&acpi_device_lock);
-	list_for_each_safe(node, next, &acpi_device_list) {
-		struct acpi_device *dev =
-		    container_of(node, struct acpi_device, g_list);
-
-		if (dev->driver == drv) {
-			spin_unlock(&acpi_device_lock);
-			if (drv->ops.remove)
-				drv->ops.remove(dev, ACPI_BUS_REMOVAL_NORMAL);
-			spin_lock(&acpi_device_lock);
-			dev->driver = NULL;
-			dev->driver_data = NULL;
-			atomic_dec(&drv->references);
-		}
-	}
-	spin_unlock(&acpi_device_lock);
-}
-
 /**
  * acpi_bus_register_driver - register a driver with the ACPI bus
  * @driver: driver being registered
@@ -520,16 +485,16 @@ static void acpi_driver_detach(struct acpi_driver *drv)
  */
 int acpi_bus_register_driver(struct acpi_driver *driver)
 {
+	int ret;
 
 	if (acpi_disabled)
 		return -ENODEV;
+	driver->drv.name = driver->name;
+	driver->drv.bus = &acpi_bus_type;
+	driver->drv.owner = driver->owner;
 
-	spin_lock(&acpi_device_lock);
-	list_add_tail(&driver->node, &acpi_bus_drivers);
-	spin_unlock(&acpi_device_lock);
-	acpi_driver_attach(driver);
-
-	return 0;
+	ret = driver_register(&driver->drv);
+	return ret;
 }
 
 EXPORT_SYMBOL(acpi_bus_register_driver);
@@ -543,52 +508,11 @@ EXPORT_SYMBOL(acpi_bus_register_driver);
  */
 void acpi_bus_unregister_driver(struct acpi_driver *driver)
 {
-	acpi_driver_detach(driver);
-
-	if (!atomic_read(&driver->references)) {
-		spin_lock(&acpi_device_lock);
-		list_del_init(&driver->node);
-		spin_unlock(&acpi_device_lock);
-	}
-	return;
+	driver_unregister(&driver->drv);
 }
 
 EXPORT_SYMBOL(acpi_bus_unregister_driver);
 
-/**
- * acpi_bus_find_driver - check if there is a driver installed for the device
- * @device: device that we are trying to find a supporting driver for
- *
- * Parses the list of registered drivers looking for a driver applicable for
- * the specified device.
- */
-static int acpi_bus_find_driver(struct acpi_device *device)
-{
-	int result = 0;
-	struct list_head *node, *next;
-
-
-	spin_lock(&acpi_device_lock);
-	list_for_each_safe(node, next, &acpi_bus_drivers) {
-		struct acpi_driver *driver =
-		    container_of(node, struct acpi_driver, node);
-
-		atomic_inc(&driver->references);
-		spin_unlock(&acpi_device_lock);
-		if (!acpi_bus_match(&(device->dev), &(driver->drv))) {
-			result = acpi_bus_driver_init(device, driver);
-			if (!result)
-				goto Done;
-		}
-		atomic_dec(&driver->references);
-		spin_lock(&acpi_device_lock);
-	}
-	spin_unlock(&acpi_device_lock);
-
-      Done:
-	return result;
-}
-
 /* --------------------------------------------------------------------------
                                  Device Enumeration
    -------------------------------------------------------------------------- */
@@ -1033,32 +957,10 @@ static void acpi_device_get_debug_info(struct acpi_device *device,
 
 static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 {
-	int result = 0;
-	struct acpi_driver *driver;
-
-
 	if (!dev)
 		return -EINVAL;
 
-	driver = dev->driver;
-
-	if ((driver) && (driver->ops.remove)) {
-
-		if (driver->ops.stop) {
-			result = driver->ops.stop(dev, ACPI_BUS_REMOVAL_EJECT);
-			if (result)
-				return result;
-		}
-
-		result = dev->driver->ops.remove(dev, ACPI_BUS_REMOVAL_EJECT);
-		if (result) {
-			return result;
-		}
-
-		atomic_dec(&dev->driver->references);
-		dev->driver = NULL;
-		acpi_driver_data(dev) = NULL;
-	}
+	device_release_driver(&dev->dev);
 
 	if (!rmdevice)
 		return 0;
@@ -1193,17 +1095,6 @@ acpi_add_single_object(struct acpi_device **child,
 			device->parent->ops.bind(device);
 	}
 
-	/*
-	 * Locate & Attach Driver
-	 * ----------------------
-	 * If there's a hardware id (_HID) or compatible ids (_CID) we check
-	 * to see if there's a driver installed for this kind of device.  Note
-	 * that drivers can install before or after a device is enumerated.
-	 *
-	 * TBD: Assumes LDM provides driver hot-plug capability.
-	 */
-	acpi_bus_find_driver(device);
-
       end:
 	if (!result)
 		*child = device;
@@ -1484,14 +1375,6 @@ static int __init acpi_scan_init(void)
 	if (result)
 		goto Done;
 
-	acpi_root->dev.bus = &acpi_bus_type;
-	snprintf(acpi_root->dev.bus_id, BUS_ID_SIZE, "%s", acpi_bus_type.name);
-	result = device_register(&acpi_root->dev);
-	if (result) {
-		/* We don't want to quit even if we failed to add suspend/resume */
-		printk(KERN_ERR PREFIX "Could not register device\n");
-	}
-
 	/*
 	 * Enumerate devices in the ACPI namespace.
 	 */

commit 5d9464a46918ced087c351a10f38cee95725f85b
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Thu Dec 7 20:56:27 2006 +0800

    ACPI: add ACPI bus_type for driver model
    
    Add ACPI bus_type for Linux driver model.
    
    1.      .shutdown method is added into acpi_driver.ops
            needed by bus_type operations.
    2.      remove useless parameter 'int state' in .resume method.
    3.      change parameter 'int state'
            to 'pm_message_t state' in .suspend method.
    
    Note:   The new .uevent method mark ACPI drivers by PNPID instead of by name.
            Udev script needs to look for "HWID=" or "COMPTID=" to load
            ACPI drivers as a result.
    
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5b42948ea97f..464746257d8e 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -222,100 +222,124 @@ acpi_eject_store(struct acpi_device *device, const char *buf, size_t count)
 /* --------------------------------------------------------------------------
 			ACPI Bus operations
    -------------------------------------------------------------------------- */
-static int root_suspend(struct acpi_device * acpi_dev, pm_message_t state)
+static int acpi_device_suspend(struct device *dev, pm_message_t state)
 {
-	struct acpi_device * dev, * next;
-	int result;
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+	struct acpi_driver *acpi_drv = acpi_dev->driver;
 
-	spin_lock(&acpi_device_lock);
-	list_for_each_entry_safe_reverse(dev, next, &acpi_device_list, g_list) {
-		if (dev->driver && dev->driver->ops.suspend) {
-			spin_unlock(&acpi_device_lock);
-			result = dev->driver->ops.suspend(dev, 0);
-			if (result) {
-				printk(KERN_ERR PREFIX "[%s - %s] Suspend failed: %d\n",
-				       acpi_device_name(dev),
-				       acpi_device_bid(dev), result);
-			}
-			spin_lock(&acpi_device_lock);
-		}
-	}
-	spin_unlock(&acpi_device_lock);
+	if (acpi_drv && acpi_drv->ops.suspend)
+		return acpi_drv->ops.suspend(acpi_dev, state);
 	return 0;
 }
 
-static int acpi_device_suspend(struct device * dev, pm_message_t state)
+static int acpi_device_resume(struct device *dev)
 {
-	struct acpi_device * acpi_dev = to_acpi_device(dev);
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+	struct acpi_driver *acpi_drv = acpi_dev->driver;
 
-	/*
-	 * For now, we should only register 1 generic device -
-	 * the ACPI root device - and from there, we walk the
-	 * tree of ACPI devices to suspend each one using the
-	 * ACPI driver methods.
-	 */
-	if (acpi_dev->handle == ACPI_ROOT_OBJECT)
-		root_suspend(acpi_dev, state);
+	if (acpi_drv && acpi_drv->ops.resume)
+		return acpi_drv->ops.resume(acpi_dev);
 	return 0;
 }
 
-static int root_resume(struct acpi_device * acpi_dev)
+static int acpi_bus_match(struct device *dev, struct device_driver *drv)
 {
-	struct acpi_device * dev, * next;
-	int result;
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+	struct acpi_driver *acpi_drv = to_acpi_driver(drv);
 
-	spin_lock(&acpi_device_lock);
-	list_for_each_entry_safe(dev, next, &acpi_device_list, g_list) {
-		if (dev->driver && dev->driver->ops.resume) {
-			spin_unlock(&acpi_device_lock);
-			result = dev->driver->ops.resume(dev, 0);
-			if (result) {
-				printk(KERN_ERR PREFIX "[%s - %s] resume failed: %d\n",
-				       acpi_device_name(dev),
-				       acpi_device_bid(dev), result);
-			}
-			spin_lock(&acpi_device_lock);
+	if (acpi_drv->ops.match)
+		return !acpi_drv->ops.match(acpi_dev, acpi_drv);
+	return !acpi_match_ids(acpi_dev, acpi_drv->ids);
+}
+
+static int acpi_device_uevent(struct device *dev, char **envp, int num_envp,
+	char *buffer, int buffer_size)
+{
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+	int i = 0, length = 0, ret = 0;
+
+	if (acpi_dev->flags.hardware_id)
+		ret = add_uevent_var(envp, num_envp, &i,
+			buffer, buffer_size, &length,
+			"HWID=%s", acpi_dev->pnp.hardware_id);
+	if (ret)
+		return -ENOMEM;
+	if (acpi_dev->flags.compatible_ids) {
+		int j;
+		struct acpi_compatible_id_list *cid_list;
+
+		cid_list = acpi_dev->pnp.cid_list;
+
+		for (j = 0; j < cid_list->count; j++) {
+			ret = add_uevent_var(envp, num_envp, &i, buffer,
+				buffer_size, &length, "COMPTID=%s",
+				cid_list->id[j].value);
+			if (ret)
+				return -ENOMEM;
 		}
 	}
-	spin_unlock(&acpi_device_lock);
+
+	envp[i] = NULL;
 	return 0;
 }
 
-static int acpi_device_resume(struct device * dev)
+static int acpi_bus_driver_init(struct acpi_device *, struct acpi_driver *);
+static int acpi_start_single_object(struct acpi_device *);
+static int acpi_device_probe(struct device * dev)
 {
-	struct acpi_device * acpi_dev = to_acpi_device(dev);
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+	struct acpi_driver *acpi_drv = to_acpi_driver(dev->driver);
+	int ret;
+
+	ret = acpi_bus_driver_init(acpi_dev, acpi_drv);
+	if (!ret) {
+		acpi_start_single_object(acpi_dev);
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Found driver [%s] for device [%s]\n",
+			acpi_drv->name, acpi_dev->pnp.bus_id));
+		get_device(dev);
+	}
+	return ret;
+}
 
-	/*
-	 * For now, we should only register 1 generic device -
-	 * the ACPI root device - and from there, we walk the
-	 * tree of ACPI devices to resume each one using the
-	 * ACPI driver methods.
-	 */
-	if (acpi_dev->handle == ACPI_ROOT_OBJECT)
-		root_resume(acpi_dev);
+static int acpi_device_remove(struct device * dev)
+{
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+	struct acpi_driver *acpi_drv = acpi_dev->driver;
+
+	if (acpi_drv) {
+		if (acpi_drv->ops.stop)
+			acpi_drv->ops.stop(acpi_dev, ACPI_BUS_REMOVAL_NORMAL);
+		if (acpi_drv->ops.remove)
+			acpi_drv->ops.remove(acpi_dev, ACPI_BUS_REMOVAL_NORMAL);
+	}
+	acpi_dev->driver = NULL;
+	acpi_driver_data(dev) = NULL;
+
+	put_device(dev);
 	return 0;
 }
 
-/**
- * acpi_bus_match - match device IDs to driver's supported IDs
- * @device: the device that we are trying to match to a driver
- * @driver: driver whose device id table is being checked
- *
- * Checks the device's hardware (_HID) or compatible (_CID) ids to see if it
- * matches the specified driver's criteria.
- */
-static int
-acpi_bus_match(struct acpi_device *device, struct acpi_driver *driver)
+static void acpi_device_shutdown(struct device *dev)
 {
-	if (driver && driver->ops.match)
-		return driver->ops.match(device, driver);
-	return acpi_match_ids(device, driver->ids);
+	struct acpi_device *acpi_dev = to_acpi_device(dev);
+	struct acpi_driver *acpi_drv = acpi_dev->driver;
+
+	if (acpi_drv && acpi_drv->ops.shutdown)
+		acpi_drv->ops.shutdown(acpi_dev);
+
+	return ;
 }
 
 static struct bus_type acpi_bus_type = {
 	.name		= "acpi",
 	.suspend	= acpi_device_suspend,
 	.resume		= acpi_device_resume,
+	.shutdown	= acpi_device_shutdown,
+	.match		= acpi_bus_match,
+	.probe		= acpi_device_probe,
+	.remove		= acpi_device_remove,
+	.uevent		= acpi_device_uevent,
 };
 
 static void acpi_device_register(struct acpi_device *device,
@@ -449,7 +473,7 @@ static void acpi_driver_attach(struct acpi_driver *drv)
 			continue;
 		spin_unlock(&acpi_device_lock);
 
-		if (!acpi_bus_match(dev, drv)) {
+		if (!acpi_bus_match(&(dev->dev), &(drv->drv))) {
 			if (!acpi_bus_driver_init(dev, drv)) {
 				acpi_start_single_object(dev);
 				atomic_inc(&drv->references);
@@ -551,7 +575,7 @@ static int acpi_bus_find_driver(struct acpi_device *device)
 
 		atomic_inc(&driver->references);
 		spin_unlock(&acpi_device_lock);
-		if (!acpi_bus_match(device, driver)) {
+		if (!acpi_bus_match(&(device->dev), &(driver->drv))) {
 			result = acpi_bus_driver_init(device, driver);
 			if (!result)
 				goto Done;

commit d43ec68e9837dfa6618ab473622683fdbf6e68a9
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Thu Dec 7 20:56:23 2006 +0800

    ACPI: add device_driver and hepler functions
    
    Add device_driver into acpi_driver for driver model.
    Add helper functions 'to_acpi_device' and 'to_acpi_driver'
    to get structure acpi_device/acpi_driver by device/device_driver.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 1f75ba6afae6..5b42948ea97f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -222,11 +222,6 @@ acpi_eject_store(struct acpi_device *device, const char *buf, size_t count)
 /* --------------------------------------------------------------------------
 			ACPI Bus operations
    -------------------------------------------------------------------------- */
-static inline struct acpi_device * to_acpi_device(struct device * dev)
-{
-	return container_of(dev, struct acpi_device, dev);
-}
-
 static int root_suspend(struct acpi_device * acpi_dev, pm_message_t state)
 {
 	struct acpi_device * dev, * next;

commit 1d268b0a0f5407138caf0dec9559d68e657a3a74
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Dec 7 20:56:19 2006 +0800

    ACPI: rename some functions
    
    We want the name 'to_acpi_device'.
    And the current macro 'to_acpi_device' will be removed
    after device model is setup.
    So just simply rename them.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e0255cbd5e19..1f75ba6afae6 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -49,13 +49,13 @@ static void setup_sys_fs_device_files(struct acpi_device *dev,
 #define remove_sysfs_device_files(dev)	\
 	setup_sys_fs_device_files(dev, (acpi_device_sysfs_files *)&sysfs_remove_file)
 
-#define to_acpi_device(n) container_of(n, struct acpi_device, kobj)
+#define to_acpi_dev(n) container_of(n, struct acpi_device, kobj)
 #define to_handle_attr(n) container_of(n, struct acpi_device_attribute, attr);
 
 static ssize_t acpi_device_attr_show(struct kobject *kobj,
 				     struct attribute *attr, char *buf)
 {
-	struct acpi_device *device = to_acpi_device(kobj);
+	struct acpi_device *device = to_acpi_dev(kobj);
 	struct acpi_device_attribute *attribute = to_handle_attr(attr);
 	return attribute->show ? attribute->show(device, buf) : -EIO;
 }
@@ -63,7 +63,7 @@ static ssize_t acpi_device_attr_store(struct kobject *kobj,
 				      struct attribute *attr, const char *buf,
 				      size_t len)
 {
-	struct acpi_device *device = to_acpi_device(kobj);
+	struct acpi_device *device = to_acpi_dev(kobj);
 	struct acpi_device_attribute *attribute = to_handle_attr(attr);
 	return attribute->store ? attribute->store(device, buf, len) : -EIO;
 }
@@ -82,7 +82,7 @@ static int namespace_uevent(struct kset *kset, struct kobject *kobj,
 			     char **envp, int num_envp, char *buffer,
 			     int buffer_size)
 {
-	struct acpi_device *dev = to_acpi_device(kobj);
+	struct acpi_device *dev = to_acpi_dev(kobj);
 	int i = 0;
 	int len = 0;
 
@@ -222,7 +222,7 @@ acpi_eject_store(struct acpi_device *device, const char *buf, size_t count)
 /* --------------------------------------------------------------------------
 			ACPI Bus operations
    -------------------------------------------------------------------------- */
-static inline struct acpi_device * to_acpi_dev(struct device * dev)
+static inline struct acpi_device * to_acpi_device(struct device * dev)
 {
 	return container_of(dev, struct acpi_device, dev);
 }
@@ -251,7 +251,7 @@ static int root_suspend(struct acpi_device * acpi_dev, pm_message_t state)
 
 static int acpi_device_suspend(struct device * dev, pm_message_t state)
 {
-	struct acpi_device * acpi_dev = to_acpi_dev(dev);
+	struct acpi_device * acpi_dev = to_acpi_device(dev);
 
 	/*
 	 * For now, we should only register 1 generic device -
@@ -288,7 +288,7 @@ static int root_resume(struct acpi_device * acpi_dev)
 
 static int acpi_device_resume(struct device * dev)
 {
-	struct acpi_device * acpi_dev = to_acpi_dev(dev);
+	struct acpi_device * acpi_dev = to_acpi_device(dev);
 
 	/*
 	 * For now, we should only register 1 generic device -

commit 9e89dde2b063ca73fcdc9244fe68e2dea32c5088
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Dec 7 20:56:16 2006 +0800

    ACPI: clean up scan.c
    
    Adjust the code and make code doing similar things together.
    No logic changes.
    
    Signed-off-by : Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 698a1540e303..e0255cbd5e19 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -111,233 +111,6 @@ static struct kset acpi_namespace_kset = {
 	.uevent_ops = &namespace_uevent_ops,
 };
 
-static void acpi_device_register(struct acpi_device *device,
-				 struct acpi_device *parent)
-{
-	int err;
-
-	/*
-	 * Linkage
-	 * -------
-	 * Link this device to its parent and siblings.
-	 */
-	INIT_LIST_HEAD(&device->children);
-	INIT_LIST_HEAD(&device->node);
-	INIT_LIST_HEAD(&device->g_list);
-	INIT_LIST_HEAD(&device->wakeup_list);
-
-	spin_lock(&acpi_device_lock);
-	if (device->parent) {
-		list_add_tail(&device->node, &device->parent->children);
-		list_add_tail(&device->g_list, &device->parent->g_list);
-	} else
-		list_add_tail(&device->g_list, &acpi_device_list);
-	if (device->wakeup.flags.valid)
-		list_add_tail(&device->wakeup_list, &acpi_wakeup_device_list);
-	spin_unlock(&acpi_device_lock);
-
-	strlcpy(device->kobj.name, device->pnp.bus_id, KOBJ_NAME_LEN);
-	if (parent)
-		device->kobj.parent = &parent->kobj;
-	device->kobj.ktype = &ktype_acpi_ns;
-	device->kobj.kset = &acpi_namespace_kset;
-	err = kobject_register(&device->kobj);
-	if (err < 0)
-		printk(KERN_WARNING "%s: kobject_register error: %d\n",
-			__FUNCTION__, err);
-	create_sysfs_device_files(device);
-}
-
-static void acpi_device_unregister(struct acpi_device *device, int type)
-{
-	spin_lock(&acpi_device_lock);
-	if (device->parent) {
-		list_del(&device->node);
-		list_del(&device->g_list);
-	} else
-		list_del(&device->g_list);
-
-	list_del(&device->wakeup_list);
-
-	spin_unlock(&acpi_device_lock);
-
-	acpi_detach_data(device->handle, acpi_bus_data_handler);
-	remove_sysfs_device_files(device);
-	kobject_unregister(&device->kobj);
-}
-
-void acpi_bus_data_handler(acpi_handle handle, u32 function, void *context)
-{
-
-	/* TBD */
-
-	return;
-}
-
-static int acpi_bus_get_power_flags(struct acpi_device *device)
-{
-	acpi_status status = 0;
-	acpi_handle handle = NULL;
-	u32 i = 0;
-
-
-	/*
-	 * Power Management Flags
-	 */
-	status = acpi_get_handle(device->handle, "_PSC", &handle);
-	if (ACPI_SUCCESS(status))
-		device->power.flags.explicit_get = 1;
-	status = acpi_get_handle(device->handle, "_IRC", &handle);
-	if (ACPI_SUCCESS(status))
-		device->power.flags.inrush_current = 1;
-
-	/*
-	 * Enumerate supported power management states
-	 */
-	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3; i++) {
-		struct acpi_device_power_state *ps = &device->power.states[i];
-		char object_name[5] = { '_', 'P', 'R', '0' + i, '\0' };
-
-		/* Evaluate "_PRx" to se if power resources are referenced */
-		acpi_evaluate_reference(device->handle, object_name, NULL,
-					&ps->resources);
-		if (ps->resources.count) {
-			device->power.flags.power_resources = 1;
-			ps->flags.valid = 1;
-		}
-
-		/* Evaluate "_PSx" to see if we can do explicit sets */
-		object_name[2] = 'S';
-		status = acpi_get_handle(device->handle, object_name, &handle);
-		if (ACPI_SUCCESS(status)) {
-			ps->flags.explicit_set = 1;
-			ps->flags.valid = 1;
-		}
-
-		/* State is valid if we have some power control */
-		if (ps->resources.count || ps->flags.explicit_set)
-			ps->flags.valid = 1;
-
-		ps->power = -1;	/* Unknown - driver assigned */
-		ps->latency = -1;	/* Unknown - driver assigned */
-	}
-
-	/* Set defaults for D0 and D3 states (always valid) */
-	device->power.states[ACPI_STATE_D0].flags.valid = 1;
-	device->power.states[ACPI_STATE_D0].power = 100;
-	device->power.states[ACPI_STATE_D3].flags.valid = 1;
-	device->power.states[ACPI_STATE_D3].power = 0;
-
-	/* TBD: System wake support and resource requirements. */
-
-	device->power.state = ACPI_STATE_UNKNOWN;
-
-	return 0;
-}
-
-int acpi_match_ids(struct acpi_device *device, char *ids)
-{
-	if (device->flags.hardware_id)
-		if (strstr(ids, device->pnp.hardware_id))
-			return 0;
-
-	if (device->flags.compatible_ids) {
-		struct acpi_compatible_id_list *cid_list = device->pnp.cid_list;
-		int i;
-
-		/* compare multiple _CID entries against driver ids */
-		for (i = 0; i < cid_list->count; i++) {
-			if (strstr(ids, cid_list->id[i].value))
-				return 0;
-		}
-	}
-	return -ENOENT;
-}
-
-static acpi_status
-acpi_bus_extract_wakeup_device_power_package(struct acpi_device *device,
-					     union acpi_object *package)
-{
-	int i = 0;
-	union acpi_object *element = NULL;
-
-	if (!device || !package || (package->package.count < 2))
-		return AE_BAD_PARAMETER;
-
-	element = &(package->package.elements[0]);
-	if (!element)
-		return AE_BAD_PARAMETER;
-	if (element->type == ACPI_TYPE_PACKAGE) {
-		if ((element->package.count < 2) ||
-		    (element->package.elements[0].type !=
-		     ACPI_TYPE_LOCAL_REFERENCE)
-		    || (element->package.elements[1].type != ACPI_TYPE_INTEGER))
-			return AE_BAD_DATA;
-		device->wakeup.gpe_device =
-		    element->package.elements[0].reference.handle;
-		device->wakeup.gpe_number =
-		    (u32) element->package.elements[1].integer.value;
-	} else if (element->type == ACPI_TYPE_INTEGER) {
-		device->wakeup.gpe_number = element->integer.value;
-	} else
-		return AE_BAD_DATA;
-
-	element = &(package->package.elements[1]);
-	if (element->type != ACPI_TYPE_INTEGER) {
-		return AE_BAD_DATA;
-	}
-	device->wakeup.sleep_state = element->integer.value;
-
-	if ((package->package.count - 2) > ACPI_MAX_HANDLES) {
-		return AE_NO_MEMORY;
-	}
-	device->wakeup.resources.count = package->package.count - 2;
-	for (i = 0; i < device->wakeup.resources.count; i++) {
-		element = &(package->package.elements[i + 2]);
-		if (element->type != ACPI_TYPE_ANY) {
-			return AE_BAD_DATA;
-		}
-
-		device->wakeup.resources.handles[i] = element->reference.handle;
-	}
-
-	return AE_OK;
-}
-
-static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
-{
-	acpi_status status = 0;
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
-	union acpi_object *package = NULL;
-
-
-	/* _PRW */
-	status = acpi_evaluate_object(device->handle, "_PRW", NULL, &buffer);
-	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRW"));
-		goto end;
-	}
-
-	package = (union acpi_object *)buffer.pointer;
-	status = acpi_bus_extract_wakeup_device_power_package(device, package);
-	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, status, "Extracting _PRW package"));
-		goto end;
-	}
-
-	kfree(buffer.pointer);
-
-	device->wakeup.flags.valid = 1;
-	/* Power button, Lid switch always enable wakeup */
-	if (!acpi_match_ids(device, "PNP0C0D,PNP0C0C,PNP0C0E"))
-		device->wakeup.flags.run_wake = 1;
-
-      end:
-	if (ACPI_FAILURE(status))
-		device->flags.wake_capable = 0;
-	return 0;
-}
-
 /* --------------------------------------------------------------------------
 		ACPI sysfs device file support
    -------------------------------------------------------------------------- */
@@ -447,20 +220,86 @@ acpi_eject_store(struct acpi_device *device, const char *buf, size_t count)
 }
 
 /* --------------------------------------------------------------------------
-                              Performance Management
+			ACPI Bus operations
    -------------------------------------------------------------------------- */
+static inline struct acpi_device * to_acpi_dev(struct device * dev)
+{
+	return container_of(dev, struct acpi_device, dev);
+}
 
-static int acpi_bus_get_perf_flags(struct acpi_device *device)
+static int root_suspend(struct acpi_device * acpi_dev, pm_message_t state)
 {
-	device->performance.state = ACPI_STATE_UNKNOWN;
+	struct acpi_device * dev, * next;
+	int result;
+
+	spin_lock(&acpi_device_lock);
+	list_for_each_entry_safe_reverse(dev, next, &acpi_device_list, g_list) {
+		if (dev->driver && dev->driver->ops.suspend) {
+			spin_unlock(&acpi_device_lock);
+			result = dev->driver->ops.suspend(dev, 0);
+			if (result) {
+				printk(KERN_ERR PREFIX "[%s - %s] Suspend failed: %d\n",
+				       acpi_device_name(dev),
+				       acpi_device_bid(dev), result);
+			}
+			spin_lock(&acpi_device_lock);
+		}
+	}
+	spin_unlock(&acpi_device_lock);
 	return 0;
 }
 
-/* --------------------------------------------------------------------------
-                                 Driver Management
-   -------------------------------------------------------------------------- */
+static int acpi_device_suspend(struct device * dev, pm_message_t state)
+{
+	struct acpi_device * acpi_dev = to_acpi_dev(dev);
 
-static LIST_HEAD(acpi_bus_drivers);
+	/*
+	 * For now, we should only register 1 generic device -
+	 * the ACPI root device - and from there, we walk the
+	 * tree of ACPI devices to suspend each one using the
+	 * ACPI driver methods.
+	 */
+	if (acpi_dev->handle == ACPI_ROOT_OBJECT)
+		root_suspend(acpi_dev, state);
+	return 0;
+}
+
+static int root_resume(struct acpi_device * acpi_dev)
+{
+	struct acpi_device * dev, * next;
+	int result;
+
+	spin_lock(&acpi_device_lock);
+	list_for_each_entry_safe(dev, next, &acpi_device_list, g_list) {
+		if (dev->driver && dev->driver->ops.resume) {
+			spin_unlock(&acpi_device_lock);
+			result = dev->driver->ops.resume(dev, 0);
+			if (result) {
+				printk(KERN_ERR PREFIX "[%s - %s] resume failed: %d\n",
+				       acpi_device_name(dev),
+				       acpi_device_bid(dev), result);
+			}
+			spin_lock(&acpi_device_lock);
+		}
+	}
+	spin_unlock(&acpi_device_lock);
+	return 0;
+}
+
+static int acpi_device_resume(struct device * dev)
+{
+	struct acpi_device * acpi_dev = to_acpi_dev(dev);
+
+	/*
+	 * For now, we should only register 1 generic device -
+	 * the ACPI root device - and from there, we walk the
+	 * tree of ACPI devices to resume each one using the
+	 * ACPI driver methods.
+	 */
+	if (acpi_dev->handle == ACPI_ROOT_OBJECT)
+		root_resume(acpi_dev);
+	return 0;
+}
 
 /**
  * acpi_bus_match - match device IDs to driver's supported IDs
@@ -478,6 +317,72 @@ acpi_bus_match(struct acpi_device *device, struct acpi_driver *driver)
 	return acpi_match_ids(device, driver->ids);
 }
 
+static struct bus_type acpi_bus_type = {
+	.name		= "acpi",
+	.suspend	= acpi_device_suspend,
+	.resume		= acpi_device_resume,
+};
+
+static void acpi_device_register(struct acpi_device *device,
+				 struct acpi_device *parent)
+{
+	int err;
+
+	/*
+	 * Linkage
+	 * -------
+	 * Link this device to its parent and siblings.
+	 */
+	INIT_LIST_HEAD(&device->children);
+	INIT_LIST_HEAD(&device->node);
+	INIT_LIST_HEAD(&device->g_list);
+	INIT_LIST_HEAD(&device->wakeup_list);
+
+	spin_lock(&acpi_device_lock);
+	if (device->parent) {
+		list_add_tail(&device->node, &device->parent->children);
+		list_add_tail(&device->g_list, &device->parent->g_list);
+	} else
+		list_add_tail(&device->g_list, &acpi_device_list);
+	if (device->wakeup.flags.valid)
+		list_add_tail(&device->wakeup_list, &acpi_wakeup_device_list);
+	spin_unlock(&acpi_device_lock);
+
+	strlcpy(device->kobj.name, device->pnp.bus_id, KOBJ_NAME_LEN);
+	if (parent)
+		device->kobj.parent = &parent->kobj;
+	device->kobj.ktype = &ktype_acpi_ns;
+	device->kobj.kset = &acpi_namespace_kset;
+	err = kobject_register(&device->kobj);
+	if (err < 0)
+		printk(KERN_WARNING "%s: kobject_register error: %d\n",
+			__FUNCTION__, err);
+	create_sysfs_device_files(device);
+}
+
+static void acpi_device_unregister(struct acpi_device *device, int type)
+{
+	spin_lock(&acpi_device_lock);
+	if (device->parent) {
+		list_del(&device->node);
+		list_del(&device->g_list);
+	} else
+		list_del(&device->g_list);
+
+	list_del(&device->wakeup_list);
+
+	spin_unlock(&acpi_device_lock);
+
+	acpi_detach_data(device->handle, acpi_bus_data_handler);
+	remove_sysfs_device_files(device);
+	kobject_unregister(&device->kobj);
+}
+
+/* --------------------------------------------------------------------------
+                                 Driver Management
+   -------------------------------------------------------------------------- */
+static LIST_HEAD(acpi_bus_drivers);
+
 /**
  * acpi_bus_driver_init - add a device to a driver
  * @device: the device to add and initialize
@@ -583,114 +488,290 @@ static void acpi_driver_detach(struct acpi_driver *drv)
 			atomic_dec(&drv->references);
 		}
 	}
-	spin_unlock(&acpi_device_lock);
+	spin_unlock(&acpi_device_lock);
+}
+
+/**
+ * acpi_bus_register_driver - register a driver with the ACPI bus
+ * @driver: driver being registered
+ *
+ * Registers a driver with the ACPI bus.  Searches the namespace for all
+ * devices that match the driver's criteria and binds.  Returns zero for
+ * success or a negative error status for failure.
+ */
+int acpi_bus_register_driver(struct acpi_driver *driver)
+{
+
+	if (acpi_disabled)
+		return -ENODEV;
+
+	spin_lock(&acpi_device_lock);
+	list_add_tail(&driver->node, &acpi_bus_drivers);
+	spin_unlock(&acpi_device_lock);
+	acpi_driver_attach(driver);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(acpi_bus_register_driver);
+
+/**
+ * acpi_bus_unregister_driver - unregisters a driver with the APIC bus
+ * @driver: driver to unregister
+ *
+ * Unregisters a driver with the ACPI bus.  Searches the namespace for all
+ * devices that match the driver's criteria and unbinds.
+ */
+void acpi_bus_unregister_driver(struct acpi_driver *driver)
+{
+	acpi_driver_detach(driver);
+
+	if (!atomic_read(&driver->references)) {
+		spin_lock(&acpi_device_lock);
+		list_del_init(&driver->node);
+		spin_unlock(&acpi_device_lock);
+	}
+	return;
+}
+
+EXPORT_SYMBOL(acpi_bus_unregister_driver);
+
+/**
+ * acpi_bus_find_driver - check if there is a driver installed for the device
+ * @device: device that we are trying to find a supporting driver for
+ *
+ * Parses the list of registered drivers looking for a driver applicable for
+ * the specified device.
+ */
+static int acpi_bus_find_driver(struct acpi_device *device)
+{
+	int result = 0;
+	struct list_head *node, *next;
+
+
+	spin_lock(&acpi_device_lock);
+	list_for_each_safe(node, next, &acpi_bus_drivers) {
+		struct acpi_driver *driver =
+		    container_of(node, struct acpi_driver, node);
+
+		atomic_inc(&driver->references);
+		spin_unlock(&acpi_device_lock);
+		if (!acpi_bus_match(device, driver)) {
+			result = acpi_bus_driver_init(device, driver);
+			if (!result)
+				goto Done;
+		}
+		atomic_dec(&driver->references);
+		spin_lock(&acpi_device_lock);
+	}
+	spin_unlock(&acpi_device_lock);
+
+      Done:
+	return result;
+}
+
+/* --------------------------------------------------------------------------
+                                 Device Enumeration
+   -------------------------------------------------------------------------- */
+acpi_status
+acpi_bus_get_ejd(acpi_handle handle, acpi_handle *ejd)
+{
+	acpi_status status;
+	acpi_handle tmp;
+	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object *obj;
+
+	status = acpi_get_handle(handle, "_EJD", &tmp);
+	if (ACPI_FAILURE(status))
+		return status;
+
+	status = acpi_evaluate_object(handle, "_EJD", NULL, &buffer);
+	if (ACPI_SUCCESS(status)) {
+		obj = buffer.pointer;
+		status = acpi_get_handle(NULL, obj->string.pointer, ejd);
+		kfree(buffer.pointer);
+	}
+	return status;
+}
+EXPORT_SYMBOL_GPL(acpi_bus_get_ejd);
+
+void acpi_bus_data_handler(acpi_handle handle, u32 function, void *context)
+{
+
+	/* TBD */
+
+	return;
+}
+
+int acpi_match_ids(struct acpi_device *device, char *ids)
+{
+	if (device->flags.hardware_id)
+		if (strstr(ids, device->pnp.hardware_id))
+			return 0;
+
+	if (device->flags.compatible_ids) {
+		struct acpi_compatible_id_list *cid_list = device->pnp.cid_list;
+		int i;
+
+		/* compare multiple _CID entries against driver ids */
+		for (i = 0; i < cid_list->count; i++) {
+			if (strstr(ids, cid_list->id[i].value))
+				return 0;
+		}
+	}
+	return -ENOENT;
+}
+
+static int acpi_bus_get_perf_flags(struct acpi_device *device)
+{
+	device->performance.state = ACPI_STATE_UNKNOWN;
+	return 0;
+}
+
+static acpi_status
+acpi_bus_extract_wakeup_device_power_package(struct acpi_device *device,
+					     union acpi_object *package)
+{
+	int i = 0;
+	union acpi_object *element = NULL;
+
+	if (!device || !package || (package->package.count < 2))
+		return AE_BAD_PARAMETER;
+
+	element = &(package->package.elements[0]);
+	if (!element)
+		return AE_BAD_PARAMETER;
+	if (element->type == ACPI_TYPE_PACKAGE) {
+		if ((element->package.count < 2) ||
+		    (element->package.elements[0].type !=
+		     ACPI_TYPE_LOCAL_REFERENCE)
+		    || (element->package.elements[1].type != ACPI_TYPE_INTEGER))
+			return AE_BAD_DATA;
+		device->wakeup.gpe_device =
+		    element->package.elements[0].reference.handle;
+		device->wakeup.gpe_number =
+		    (u32) element->package.elements[1].integer.value;
+	} else if (element->type == ACPI_TYPE_INTEGER) {
+		device->wakeup.gpe_number = element->integer.value;
+	} else
+		return AE_BAD_DATA;
+
+	element = &(package->package.elements[1]);
+	if (element->type != ACPI_TYPE_INTEGER) {
+		return AE_BAD_DATA;
+	}
+	device->wakeup.sleep_state = element->integer.value;
+
+	if ((package->package.count - 2) > ACPI_MAX_HANDLES) {
+		return AE_NO_MEMORY;
+	}
+	device->wakeup.resources.count = package->package.count - 2;
+	for (i = 0; i < device->wakeup.resources.count; i++) {
+		element = &(package->package.elements[i + 2]);
+		if (element->type != ACPI_TYPE_ANY) {
+			return AE_BAD_DATA;
+		}
+
+		device->wakeup.resources.handles[i] = element->reference.handle;
+	}
+
+	return AE_OK;
 }
 
-/**
- * acpi_bus_register_driver - register a driver with the ACPI bus
- * @driver: driver being registered
- *
- * Registers a driver with the ACPI bus.  Searches the namespace for all
- * devices that match the driver's criteria and binds.  Returns zero for
- * success or a negative error status for failure.
- */
-int acpi_bus_register_driver(struct acpi_driver *driver)
+static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 {
+	acpi_status status = 0;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *package = NULL;
 
-	if (acpi_disabled)
-		return -ENODEV;
 
-	spin_lock(&acpi_device_lock);
-	list_add_tail(&driver->node, &acpi_bus_drivers);
-	spin_unlock(&acpi_device_lock);
-	acpi_driver_attach(driver);
+	/* _PRW */
+	status = acpi_evaluate_object(device->handle, "_PRW", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRW"));
+		goto end;
+	}
 
-	return 0;
-}
+	package = (union acpi_object *)buffer.pointer;
+	status = acpi_bus_extract_wakeup_device_power_package(device, package);
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status, "Extracting _PRW package"));
+		goto end;
+	}
 
-EXPORT_SYMBOL(acpi_bus_register_driver);
+	kfree(buffer.pointer);
 
-/**
- * acpi_bus_unregister_driver - unregisters a driver with the APIC bus
- * @driver: driver to unregister
- *
- * Unregisters a driver with the ACPI bus.  Searches the namespace for all
- * devices that match the driver's criteria and unbinds.
- */
-void acpi_bus_unregister_driver(struct acpi_driver *driver)
-{
-	acpi_driver_detach(driver);
+	device->wakeup.flags.valid = 1;
+	/* Power button, Lid switch always enable wakeup */
+	if (!acpi_match_ids(device, "PNP0C0D,PNP0C0C,PNP0C0E"))
+		device->wakeup.flags.run_wake = 1;
 
-	if (!atomic_read(&driver->references)) {
-		spin_lock(&acpi_device_lock);
-		list_del_init(&driver->node);
-		spin_unlock(&acpi_device_lock);
-	}
-	return;
+      end:
+	if (ACPI_FAILURE(status))
+		device->flags.wake_capable = 0;
+	return 0;
 }
 
-EXPORT_SYMBOL(acpi_bus_unregister_driver);
-
-/**
- * acpi_bus_find_driver - check if there is a driver installed for the device
- * @device: device that we are trying to find a supporting driver for
- *
- * Parses the list of registered drivers looking for a driver applicable for
- * the specified device.
- */
-static int acpi_bus_find_driver(struct acpi_device *device)
+static int acpi_bus_get_power_flags(struct acpi_device *device)
 {
-	int result = 0;
-	struct list_head *node, *next;
+	acpi_status status = 0;
+	acpi_handle handle = NULL;
+	u32 i = 0;
 
 
-	spin_lock(&acpi_device_lock);
-	list_for_each_safe(node, next, &acpi_bus_drivers) {
-		struct acpi_driver *driver =
-		    container_of(node, struct acpi_driver, node);
+	/*
+	 * Power Management Flags
+	 */
+	status = acpi_get_handle(device->handle, "_PSC", &handle);
+	if (ACPI_SUCCESS(status))
+		device->power.flags.explicit_get = 1;
+	status = acpi_get_handle(device->handle, "_IRC", &handle);
+	if (ACPI_SUCCESS(status))
+		device->power.flags.inrush_current = 1;
 
-		atomic_inc(&driver->references);
-		spin_unlock(&acpi_device_lock);
-		if (!acpi_bus_match(device, driver)) {
-			result = acpi_bus_driver_init(device, driver);
-			if (!result)
-				goto Done;
+	/*
+	 * Enumerate supported power management states
+	 */
+	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3; i++) {
+		struct acpi_device_power_state *ps = &device->power.states[i];
+		char object_name[5] = { '_', 'P', 'R', '0' + i, '\0' };
+
+		/* Evaluate "_PRx" to se if power resources are referenced */
+		acpi_evaluate_reference(device->handle, object_name, NULL,
+					&ps->resources);
+		if (ps->resources.count) {
+			device->power.flags.power_resources = 1;
+			ps->flags.valid = 1;
 		}
-		atomic_dec(&driver->references);
-		spin_lock(&acpi_device_lock);
-	}
-	spin_unlock(&acpi_device_lock);
 
-      Done:
-	return result;
-}
+		/* Evaluate "_PSx" to see if we can do explicit sets */
+		object_name[2] = 'S';
+		status = acpi_get_handle(device->handle, object_name, &handle);
+		if (ACPI_SUCCESS(status)) {
+			ps->flags.explicit_set = 1;
+			ps->flags.valid = 1;
+		}
 
-/* --------------------------------------------------------------------------
-                                 Device Enumeration
-   -------------------------------------------------------------------------- */
+		/* State is valid if we have some power control */
+		if (ps->resources.count || ps->flags.explicit_set)
+			ps->flags.valid = 1;
 
-acpi_status
-acpi_bus_get_ejd(acpi_handle handle, acpi_handle *ejd)
-{
-	acpi_status status;
-	acpi_handle tmp;
-	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	union acpi_object *obj;
+		ps->power = -1;	/* Unknown - driver assigned */
+		ps->latency = -1;	/* Unknown - driver assigned */
+	}
 
-	status = acpi_get_handle(handle, "_EJD", &tmp);
-	if (ACPI_FAILURE(status))
-		return status;
+	/* Set defaults for D0 and D3 states (always valid) */
+	device->power.states[ACPI_STATE_D0].flags.valid = 1;
+	device->power.states[ACPI_STATE_D0].power = 100;
+	device->power.states[ACPI_STATE_D3].flags.valid = 1;
+	device->power.states[ACPI_STATE_D3].power = 0;
 
-	status = acpi_evaluate_object(handle, "_EJD", NULL, &buffer);
-	if (ACPI_SUCCESS(status)) {
-		obj = buffer.pointer;
-		status = acpi_get_handle(NULL, obj->string.pointer, ejd);
-		kfree(buffer.pointer);
-	}
-	return status;
-}
-EXPORT_SYMBOL_GPL(acpi_bus_get_ejd);
+	/* TBD: System wake support and resource requirements. */
+
+	device->power.state = ACPI_STATE_UNKNOWN;
 
+	return 0;
+}
 
 static int acpi_bus_get_flags(struct acpi_device *device)
 {
@@ -1353,100 +1434,6 @@ static int acpi_bus_scan_fixed(struct acpi_device *root)
 	return result;
 }
 
-
-static inline struct acpi_device * to_acpi_dev(struct device * dev)
-{
-	return container_of(dev, struct acpi_device, dev);
-}
-
-
-static int root_suspend(struct acpi_device * acpi_dev, pm_message_t state)
-{
-	struct acpi_device * dev, * next;
-	int result;
-
-	spin_lock(&acpi_device_lock);
-	list_for_each_entry_safe_reverse(dev, next, &acpi_device_list, g_list) {
-		if (dev->driver && dev->driver->ops.suspend) {
-			spin_unlock(&acpi_device_lock);
-			result = dev->driver->ops.suspend(dev, 0);
-			if (result) {
-				printk(KERN_ERR PREFIX "[%s - %s] Suspend failed: %d\n",
-				       acpi_device_name(dev),
-				       acpi_device_bid(dev), result);
-			}
-			spin_lock(&acpi_device_lock);
-		}
-	}
-	spin_unlock(&acpi_device_lock);
-	return 0;
-}
-
-
-static int acpi_device_suspend(struct device * dev, pm_message_t state)
-{
-	struct acpi_device * acpi_dev = to_acpi_dev(dev);
-
-	/*
-	 * For now, we should only register 1 generic device -
-	 * the ACPI root device - and from there, we walk the
-	 * tree of ACPI devices to suspend each one using the
-	 * ACPI driver methods.
-	 */
-	if (acpi_dev->handle == ACPI_ROOT_OBJECT)
-		root_suspend(acpi_dev, state);
-	return 0;
-}
-
-
-
-static int root_resume(struct acpi_device * acpi_dev)
-{
-	struct acpi_device * dev, * next;
-	int result;
-
-	spin_lock(&acpi_device_lock);
-	list_for_each_entry_safe(dev, next, &acpi_device_list, g_list) {
-		if (dev->driver && dev->driver->ops.resume) {
-			spin_unlock(&acpi_device_lock);
-			result = dev->driver->ops.resume(dev, 0);
-			if (result) {
-				printk(KERN_ERR PREFIX "[%s - %s] resume failed: %d\n",
-				       acpi_device_name(dev),
-				       acpi_device_bid(dev), result);
-			}
-			spin_lock(&acpi_device_lock);
-		}
-	}
-	spin_unlock(&acpi_device_lock);
-	return 0;
-}
-
-
-static int acpi_device_resume(struct device * dev)
-{
-	struct acpi_device * acpi_dev = to_acpi_dev(dev);
-
-	/*
-	 * For now, we should only register 1 generic device -
-	 * the ACPI root device - and from there, we walk the
-	 * tree of ACPI devices to resume each one using the
-	 * ACPI driver methods.
-	 */
-	if (acpi_dev->handle == ACPI_ROOT_OBJECT)
-		root_resume(acpi_dev);
-	return 0;
-}
-
-
-static struct bus_type acpi_bus_type = {
-	.name		= "acpi",
-	.suspend	= acpi_device_suspend,
-	.resume		= acpi_device_resume,
-};
-
-
-
 static int __init acpi_scan_init(void)
 {
 	int result;

commit 9b6d97b64eff08b368375efcf9c1d01eba582ea2
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Wed Jul 12 02:08:00 2006 -0400

    ACPI: scan: handle kset/kobject errors
    
    Check and handle kset_register() and kobject_register() init errors.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5fcb50c7b778..698a1540e303 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -4,6 +4,7 @@
 
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/kernel.h>
 #include <linux/acpi.h>
 
 #include <acpi/acpi_drivers.h>
@@ -113,6 +114,8 @@ static struct kset acpi_namespace_kset = {
 static void acpi_device_register(struct acpi_device *device,
 				 struct acpi_device *parent)
 {
+	int err;
+
 	/*
 	 * Linkage
 	 * -------
@@ -138,7 +141,10 @@ static void acpi_device_register(struct acpi_device *device,
 		device->kobj.parent = &parent->kobj;
 	device->kobj.ktype = &ktype_acpi_ns;
 	device->kobj.kset = &acpi_namespace_kset;
-	kobject_register(&device->kobj);
+	err = kobject_register(&device->kobj);
+	if (err < 0)
+		printk(KERN_WARNING "%s: kobject_register error: %d\n",
+			__FUNCTION__, err);
 	create_sysfs_device_files(device);
 }
 
@@ -1450,7 +1456,9 @@ static int __init acpi_scan_init(void)
 	if (acpi_disabled)
 		return 0;
 
-	kset_register(&acpi_namespace_kset);
+	result = kset_register(&acpi_namespace_kset);
+	if (result < 0)
+		printk(KERN_ERR PREFIX "kset_register error: %d\n", result);
 
 	result = bus_register(&acpi_bus_type);
 	if (result) {

commit c8f7a62cdde461914c6457d5f4362538ed810bf4
Author: Len Brown <len.brown@intel.com>
Date:   Sun Jul 9 17:22:28 2006 -0400

    Revert "Revert "ACPI: dock driver""
    
    This reverts 953969ddf5b049361ed1e8471cc43dc4134d2a6f commit.

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index cac4fcdcfc8d..5fcb50c7b778 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -663,6 +663,29 @@ static int acpi_bus_find_driver(struct acpi_device *device)
                                  Device Enumeration
    -------------------------------------------------------------------------- */
 
+acpi_status
+acpi_bus_get_ejd(acpi_handle handle, acpi_handle *ejd)
+{
+	acpi_status status;
+	acpi_handle tmp;
+	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object *obj;
+
+	status = acpi_get_handle(handle, "_EJD", &tmp);
+	if (ACPI_FAILURE(status))
+		return status;
+
+	status = acpi_evaluate_object(handle, "_EJD", NULL, &buffer);
+	if (ACPI_SUCCESS(status)) {
+		obj = buffer.pointer;
+		status = acpi_get_handle(NULL, obj->string.pointer, ejd);
+		kfree(buffer.pointer);
+	}
+	return status;
+}
+EXPORT_SYMBOL_GPL(acpi_bus_get_ejd);
+
+
 static int acpi_bus_get_flags(struct acpi_device *device)
 {
 	acpi_status status = AE_OK;

commit 953969ddf5b049361ed1e8471cc43dc4134d2a6f
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Sun Jul 9 08:47:46 2006 -0700

    Revert "ACPI: dock driver"
    
    This reverts commit a5e1b94008f2a96abf4a0c0371a55a56b320c13e.
    
    Adrian Bunk points out that it has build errors, and apparently no
    maintenance. Throw it out.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5fcb50c7b778..cac4fcdcfc8d 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -663,29 +663,6 @@ static int acpi_bus_find_driver(struct acpi_device *device)
                                  Device Enumeration
    -------------------------------------------------------------------------- */
 
-acpi_status
-acpi_bus_get_ejd(acpi_handle handle, acpi_handle *ejd)
-{
-	acpi_status status;
-	acpi_handle tmp;
-	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	union acpi_object *obj;
-
-	status = acpi_get_handle(handle, "_EJD", &tmp);
-	if (ACPI_FAILURE(status))
-		return status;
-
-	status = acpi_evaluate_object(handle, "_EJD", NULL, &buffer);
-	if (ACPI_SUCCESS(status)) {
-		obj = buffer.pointer;
-		status = acpi_get_handle(NULL, obj->string.pointer, ejd);
-		kfree(buffer.pointer);
-	}
-	return status;
-}
-EXPORT_SYMBOL_GPL(acpi_bus_get_ejd);
-
-
 static int acpi_bus_get_flags(struct acpi_device *device)
 {
 	acpi_status status = AE_OK;

commit b197ba3c70638a3a2ae39296781912f26ac0f991
Merge: fc25465f0941 02438d8771ae
Author: Len Brown <len.brown@intel.com>
Date:   Sat Jul 1 17:19:08 2006 -0400

    Pull acpi_os_free into release branch

commit 9e5289f4dd2326fb8c0a3af23a954158ca99c354
Author: Adrian Bunk <bunk@stusta.de>
Date:   Fri Jun 30 05:15:00 2006 -0400

    ACPI: drivers/acpi/scan.c: make acpi_bus_type static
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 401e723e6c66..861ac378ce42 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1433,7 +1433,7 @@ static int acpi_device_resume(struct device * dev)
 }
 
 
-struct bus_type acpi_bus_type = {
+static struct bus_type acpi_bus_type = {
 	.name		= "acpi",
 	.suspend	= acpi_device_suspend,
 	.resume		= acpi_device_resume,

commit 02438d8771ae6a4b215938959827692026380bf9
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jun 30 03:19:10 2006 -0400

    ACPI: delete acpi_os_free(), use kfree() directly
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 401e723e6c66..a05b3dfb5cc5 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -319,7 +319,7 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 		goto end;
 	}
 
-	acpi_os_free(buffer.pointer);
+	kfree(buffer.pointer);
 
 	device->wakeup.flags.valid = 1;
 	/* Power button, Lid switch always enable wakeup */
@@ -854,7 +854,7 @@ static void acpi_device_set_id(struct acpi_device *device,
 			printk(KERN_ERR "Memory allocation error\n");
 	}
 
-	acpi_os_free(buffer.pointer);
+	kfree(buffer.pointer);
 }
 
 static int acpi_device_set_context(struct acpi_device *device, int type)

commit a5e1b94008f2a96abf4a0c0371a55a56b320c13e
Author: Kristen Accardi <kristen.c.accardi@intel.com>
Date:   Wed Jun 28 03:07:16 2006 -0400

    ACPI: dock driver
    
    Create a driver which lives in the acpi subsystem to handle dock events.
    This driver is not an "ACPI" driver, because acpi drivers require that the
    object be present when the driver is loaded.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Cc: Dave Hansen <haveblue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a7b1fda572cf..401e723e6c66 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -663,6 +663,29 @@ static int acpi_bus_find_driver(struct acpi_device *device)
                                  Device Enumeration
    -------------------------------------------------------------------------- */
 
+acpi_status
+acpi_bus_get_ejd(acpi_handle handle, acpi_handle *ejd)
+{
+	acpi_status status;
+	acpi_handle tmp;
+	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object *obj;
+
+	status = acpi_get_handle(handle, "_EJD", &tmp);
+	if (ACPI_FAILURE(status))
+		return status;
+
+	status = acpi_evaluate_object(handle, "_EJD", NULL, &buffer);
+	if (ACPI_SUCCESS(status)) {
+		obj = buffer.pointer;
+		status = acpi_get_handle(NULL, obj->string.pointer, ejd);
+		kfree(buffer.pointer);
+	}
+	return status;
+}
+EXPORT_SYMBOL_GPL(acpi_bus_get_ejd);
+
+
 static int acpi_bus_get_flags(struct acpi_device *device)
 {
 	acpi_status status = AE_OK;

commit d550d98d3317378d93a4869db204725d270ec812
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Tue Jun 27 00:41:40 2006 -0400

    ACPI: delete tracing macros from drivers/acpi/*.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 18c8e3e2fbad..a7b1fda572cf 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -162,11 +162,10 @@ static void acpi_device_unregister(struct acpi_device *device, int type)
 
 void acpi_bus_data_handler(acpi_handle handle, u32 function, void *context)
 {
-	ACPI_FUNCTION_TRACE("acpi_bus_data_handler");
 
 	/* TBD */
 
-	return_VOID;
+	return;
 }
 
 static int acpi_bus_get_power_flags(struct acpi_device *device)
@@ -175,7 +174,6 @@ static int acpi_bus_get_power_flags(struct acpi_device *device)
 	acpi_handle handle = NULL;
 	u32 i = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_get_power_flags");
 
 	/*
 	 * Power Management Flags
@@ -228,7 +226,7 @@ static int acpi_bus_get_power_flags(struct acpi_device *device)
 
 	device->power.state = ACPI_STATE_UNKNOWN;
 
-	return_VALUE(0);
+	return 0;
 }
 
 int acpi_match_ids(struct acpi_device *device, char *ids)
@@ -306,7 +304,6 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *package = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_get_wakeup_flags");
 
 	/* _PRW */
 	status = acpi_evaluate_object(device->handle, "_PRW", NULL, &buffer);
@@ -332,7 +329,7 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
       end:
 	if (ACPI_FAILURE(status))
 		device->flags.wake_capable = 0;
-	return_VALUE(0);
+	return 0;
 }
 
 /* --------------------------------------------------------------------------
@@ -488,19 +485,18 @@ acpi_bus_driver_init(struct acpi_device *device, struct acpi_driver *driver)
 {
 	int result = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_driver_init");
 
 	if (!device || !driver)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	if (!driver->ops.add)
-		return_VALUE(-ENOSYS);
+		return -ENOSYS;
 
 	result = driver->ops.add(device);
 	if (result) {
 		device->driver = NULL;
 		acpi_driver_data(device) = NULL;
-		return_VALUE(result);
+		return result;
 	}
 
 	device->driver = driver;
@@ -512,7 +508,7 @@ acpi_bus_driver_init(struct acpi_device *device, struct acpi_driver *driver)
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  "Driver successfully bound to device\n"));
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_start_single_object(struct acpi_device *device)
@@ -520,10 +516,9 @@ static int acpi_start_single_object(struct acpi_device *device)
 	int result = 0;
 	struct acpi_driver *driver;
 
-	ACPI_FUNCTION_TRACE("acpi_start_single_object");
 
 	if (!(driver = device->driver))
-		return_VALUE(0);
+		return 0;
 
 	if (driver->ops.start) {
 		result = driver->ops.start(device);
@@ -531,14 +526,13 @@ static int acpi_start_single_object(struct acpi_device *device)
 			driver->ops.remove(device, ACPI_BUS_REMOVAL_NORMAL);
 	}
 
-	return_VALUE(result);
+	return result;
 }
 
 static void acpi_driver_attach(struct acpi_driver *drv)
 {
 	struct list_head *node, *next;
 
-	ACPI_FUNCTION_TRACE("acpi_driver_attach");
 
 	spin_lock(&acpi_device_lock);
 	list_for_each_safe(node, next, &acpi_device_list) {
@@ -567,7 +561,6 @@ static void acpi_driver_detach(struct acpi_driver *drv)
 {
 	struct list_head *node, *next;
 
-	ACPI_FUNCTION_TRACE("acpi_driver_detach");
 
 	spin_lock(&acpi_device_lock);
 	list_for_each_safe(node, next, &acpi_device_list) {
@@ -597,17 +590,16 @@ static void acpi_driver_detach(struct acpi_driver *drv)
  */
 int acpi_bus_register_driver(struct acpi_driver *driver)
 {
-	ACPI_FUNCTION_TRACE("acpi_bus_register_driver");
 
 	if (acpi_disabled)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	spin_lock(&acpi_device_lock);
 	list_add_tail(&driver->node, &acpi_bus_drivers);
 	spin_unlock(&acpi_device_lock);
 	acpi_driver_attach(driver);
 
-	return_VALUE(0);
+	return 0;
 }
 
 EXPORT_SYMBOL(acpi_bus_register_driver);
@@ -645,7 +637,6 @@ static int acpi_bus_find_driver(struct acpi_device *device)
 	int result = 0;
 	struct list_head *node, *next;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_find_driver");
 
 	spin_lock(&acpi_device_lock);
 	list_for_each_safe(node, next, &acpi_bus_drivers) {
@@ -665,7 +656,7 @@ static int acpi_bus_find_driver(struct acpi_device *device)
 	spin_unlock(&acpi_device_lock);
 
       Done:
-	return_VALUE(result);
+	return result;
 }
 
 /* --------------------------------------------------------------------------
@@ -677,7 +668,6 @@ static int acpi_bus_get_flags(struct acpi_device *device)
 	acpi_status status = AE_OK;
 	acpi_handle temp = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_get_flags");
 
 	/* Presence of _STA indicates 'dynamic_status' */
 	status = acpi_get_handle(device->handle, "_STA", &temp);
@@ -723,7 +713,7 @@ static int acpi_bus_get_flags(struct acpi_device *device)
 
 	/* TBD: Peformance management */
 
-	return_VALUE(0);
+	return 0;
 }
 
 static void acpi_device_get_busid(struct acpi_device *device,
@@ -917,10 +907,9 @@ static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 	int result = 0;
 	struct acpi_driver *driver;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_remove");
 
 	if (!dev)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	driver = dev->driver;
 
@@ -929,12 +918,12 @@ static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 		if (driver->ops.stop) {
 			result = driver->ops.stop(dev, ACPI_BUS_REMOVAL_EJECT);
 			if (result)
-				return_VALUE(result);
+				return result;
 		}
 
 		result = dev->driver->ops.remove(dev, ACPI_BUS_REMOVAL_EJECT);
 		if (result) {
-			return_VALUE(result);
+			return result;
 		}
 
 		atomic_dec(&dev->driver->references);
@@ -943,7 +932,7 @@ static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 	}
 
 	if (!rmdevice)
-		return_VALUE(0);
+		return 0;
 
 	if (dev->flags.bus_address) {
 		if ((dev->parent) && (dev->parent->ops.unbind))
@@ -952,7 +941,7 @@ static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 
 	acpi_device_unregister(dev, ACPI_BUS_REMOVAL_EJECT);
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int
@@ -962,15 +951,14 @@ acpi_add_single_object(struct acpi_device **child,
 	int result = 0;
 	struct acpi_device *device = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_add_single_object");
 
 	if (!child)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	device = kmalloc(sizeof(struct acpi_device), GFP_KERNEL);
 	if (!device) {
 		printk(KERN_ERR PREFIX "Memory allocation error\n");
-		return_VALUE(-ENOMEM);
+		return -ENOMEM;
 	}
 	memset(device, 0, sizeof(struct acpi_device));
 
@@ -1095,7 +1083,7 @@ acpi_add_single_object(struct acpi_device **child,
 		kfree(device);
 	}
 
-	return_VALUE(result);
+	return result;
 }
 
 static int acpi_bus_scan(struct acpi_device *start, struct acpi_bus_ops *ops)
@@ -1108,10 +1096,9 @@ static int acpi_bus_scan(struct acpi_device *start, struct acpi_bus_ops *ops)
 	acpi_object_type type = 0;
 	u32 level = 1;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_scan");
 
 	if (!start)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	parent = start;
 	phandle = start->handle;
@@ -1208,7 +1195,7 @@ static int acpi_bus_scan(struct acpi_device *start, struct acpi_bus_ops *ops)
 		}
 	}
 
-	return_VALUE(0);
+	return 0;
 }
 
 int
@@ -1218,7 +1205,6 @@ acpi_bus_add(struct acpi_device **child,
 	int result;
 	struct acpi_bus_ops ops;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_add");
 
 	result = acpi_add_single_object(child, parent, handle, type);
 	if (!result) {
@@ -1226,7 +1212,7 @@ acpi_bus_add(struct acpi_device **child,
 		ops.acpi_op_add = 1;
 		result = acpi_bus_scan(*child, &ops);
 	}
-	return_VALUE(result);
+	return result;
 }
 
 EXPORT_SYMBOL(acpi_bus_add);
@@ -1236,10 +1222,9 @@ int acpi_bus_start(struct acpi_device *device)
 	int result;
 	struct acpi_bus_ops ops;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_start");
 
 	if (!device)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	result = acpi_start_single_object(device);
 	if (!result) {
@@ -1247,7 +1232,7 @@ int acpi_bus_start(struct acpi_device *device)
 		ops.acpi_op_start = 1;
 		result = acpi_bus_scan(device, &ops);
 	}
-	return_VALUE(result);
+	return result;
 }
 
 EXPORT_SYMBOL(acpi_bus_start);
@@ -1313,10 +1298,9 @@ static int acpi_bus_scan_fixed(struct acpi_device *root)
 	int result = 0;
 	struct acpi_device *device = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_scan_fixed");
 
 	if (!root)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	/*
 	 * Enumerate all fixed-feature devices.
@@ -1337,7 +1321,7 @@ static int acpi_bus_scan_fixed(struct acpi_device *root)
 			result = acpi_start_single_object(device);
 	}
 
-	return_VALUE(result);
+	return result;
 }
 
 
@@ -1439,10 +1423,9 @@ static int __init acpi_scan_init(void)
 	int result;
 	struct acpi_bus_ops ops;
 
-	ACPI_FUNCTION_TRACE("acpi_scan_init");
 
 	if (acpi_disabled)
-		return_VALUE(0);
+		return 0;
 
 	kset_register(&acpi_namespace_kset);
 
@@ -1487,7 +1470,7 @@ static int __init acpi_scan_init(void)
 		acpi_device_unregister(acpi_root, ACPI_BUS_REMOVAL_NORMAL);
 
       Done:
-	return_VALUE(result);
+	return result;
 }
 
 subsys_initcall(acpi_scan_init);

commit 6468463abd7051fcc29f3ee7c931f9bbbb26f5a4
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jun 26 23:41:38 2006 -0400

    ACPI: un-export ACPI_ERROR() -- use printk(KERN_ERR...)
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 964ee5c8ea16..18c8e3e2fbad 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -969,7 +969,7 @@ acpi_add_single_object(struct acpi_device **child,
 
 	device = kmalloc(sizeof(struct acpi_device), GFP_KERNEL);
 	if (!device) {
-		ACPI_ERROR((AE_INFO, "Memory allocation error"));
+		printk(KERN_ERR PREFIX "Memory allocation error\n");
 		return_VALUE(-ENOMEM);
 	}
 	memset(device, 0, sizeof(struct acpi_device));

commit a6fc67202e0224e6c9d1d285cc0b444bce887ed5
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jun 26 23:58:43 2006 -0400

    ACPI: Enable ACPI error messages w/o CONFIG_ACPI_DEBUG
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f8316a05ede7..964ee5c8ea16 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -311,15 +311,14 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 	/* _PRW */
 	status = acpi_evaluate_object(device->handle, "_PRW", NULL, &buffer);
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRW\n"));
+		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRW"));
 		goto end;
 	}
 
 	package = (union acpi_object *)buffer.pointer;
 	status = acpi_bus_extract_wakeup_device_power_package(device, package);
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Error extracting _PRW package\n"));
+		ACPI_EXCEPTION((AE_INFO, status, "Extracting _PRW package"));
 		goto end;
 	}
 
@@ -970,7 +969,7 @@ acpi_add_single_object(struct acpi_device **child,
 
 	device = kmalloc(sizeof(struct acpi_device), GFP_KERNEL);
 	if (!device) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Memory allocation error\n"));
+		ACPI_ERROR((AE_INFO, "Memory allocation error"));
 		return_VALUE(-ENOMEM);
 	}
 	memset(device, 0, sizeof(struct acpi_device));

commit 8f2ddb37e564a9616c05fa0d5652e0049072a730
Merge: 5b542e442276 74ce1468128e
Author: Len Brown <len.brown@intel.com>
Date:   Thu Jun 15 21:36:11 2006 -0400

    Pull bugzilla-5000 into release branch

commit c080a3e69dfb58ae9b8c7e70a1e33f4f4e493ea7
Merge: bf891bd65de6 36e430951af0
Author: Len Brown <len.brown@intel.com>
Date:   Thu Jun 15 21:31:47 2006 -0400

    Pull sem2mutex into release branch

commit 69cd291c6bbc6647fe3783257c5a2e076e808f71
Merge: 35a5d9ed9fed 06ea8e08ae7e
Author: Len Brown <len.brown@intel.com>
Date:   Thu Jun 15 21:28:57 2006 -0400

    Pull acpi_bus_register_driver into release branch
    
    Conflicts:
    
            drivers/acpi/asus_acpi.c
            drivers/acpi/scan.c

commit 63518472c05a351d779f35803e6ccfb361ae630a
Merge: e44e20ff1273 e6f1f3c54974
Author: Len Brown <len.brown@intel.com>
Date:   Thu Jun 15 15:37:09 2006 -0400

    Pull trivial1 into release branch

commit 531881d665ca011326bb466b97b07c95dee8d0a1
Author: Len Brown <len.brown@intel.com>
Date:   Mon May 15 03:06:41 2006 -0400

    ACPI: pass pm_message_t from acpi_device_suspend() to root_suspend()
    in case we want to decode it for future use in acpi_op_suspend(..., state)
    
    also, inline new 1-liner static function
    
    http://bugzilla.kernel.org/show_bug.cgi?id=5000
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 19ae9ff10210..eee58393eb46 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1372,13 +1372,13 @@ static int acpi_bus_scan_fixed(struct acpi_device *root)
 }
 
 
-static struct acpi_device * to_acpi_dev(struct device * dev)
+static inline struct acpi_device * to_acpi_dev(struct device * dev)
 {
 	return container_of(dev, struct acpi_device, dev);
 }
 
 
-static int root_suspend(struct acpi_device * acpi_dev)
+static int root_suspend(struct acpi_device * acpi_dev, pm_message_t state)
 {
 	struct acpi_device * dev, * next;
 	int result;
@@ -1387,10 +1387,6 @@ static int root_suspend(struct acpi_device * acpi_dev)
 	list_for_each_entry_safe_reverse(dev, next, &acpi_device_list, g_list) {
 		if (dev->driver && dev->driver->ops.suspend) {
 			spin_unlock(&acpi_device_lock);
-
-			/* TBD: What suspend state should be passed
-			 * to device?
-			 */
 			result = dev->driver->ops.suspend(dev, 0);
 			if (result) {
 				printk(KERN_ERR PREFIX "[%s - %s] Suspend failed: %d\n",
@@ -1416,7 +1412,7 @@ static int acpi_device_suspend(struct device * dev, pm_message_t state)
 	 * ACPI driver methods.
 	 */
 	if (acpi_dev->handle == ACPI_ROOT_OBJECT)
-		root_suspend(acpi_dev);
+		root_suspend(acpi_dev, state);
 	return 0;
 }
 
@@ -1431,10 +1427,6 @@ static int root_resume(struct acpi_device * acpi_dev)
 	list_for_each_entry_safe(dev, next, &acpi_device_list, g_list) {
 		if (dev->driver && dev->driver->ops.resume) {
 			spin_unlock(&acpi_device_lock);
-
-			/* TBD: What suspend state should be passed
-			 * to device?
-			 */
 			result = dev->driver->ops.resume(dev, 0);
 			if (result) {
 				printk(KERN_ERR PREFIX "[%s - %s] resume failed: %d\n",

commit 5b3272655a8e8a9a6e2503bc5a88fc9d9c8292a4
Author: Patrick Mochel <patrick.mochel@intel.com>
Date:   Wed May 10 10:33:00 2006 -0400

    ACPI: create acpi_device_suspend()/acpi_device_resume()
    
    updated and tested by Konstantin Karasyov
    
    http://bugzilla.kernel.org/show_bug.cgi?id=5000
    
    Signed-off-by: Patrick Mochel <patrick.mochel@intel.com>
    Signed-off-by: Konstantin Karasyov <konstantin.karasyov @intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a0ab828b2cc5..19ae9ff10210 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1371,6 +1371,108 @@ static int acpi_bus_scan_fixed(struct acpi_device *root)
 	return_VALUE(result);
 }
 
+
+static struct acpi_device * to_acpi_dev(struct device * dev)
+{
+	return container_of(dev, struct acpi_device, dev);
+}
+
+
+static int root_suspend(struct acpi_device * acpi_dev)
+{
+	struct acpi_device * dev, * next;
+	int result;
+
+	spin_lock(&acpi_device_lock);
+	list_for_each_entry_safe_reverse(dev, next, &acpi_device_list, g_list) {
+		if (dev->driver && dev->driver->ops.suspend) {
+			spin_unlock(&acpi_device_lock);
+
+			/* TBD: What suspend state should be passed
+			 * to device?
+			 */
+			result = dev->driver->ops.suspend(dev, 0);
+			if (result) {
+				printk(KERN_ERR PREFIX "[%s - %s] Suspend failed: %d\n",
+				       acpi_device_name(dev),
+				       acpi_device_bid(dev), result);
+			}
+			spin_lock(&acpi_device_lock);
+		}
+	}
+	spin_unlock(&acpi_device_lock);
+	return 0;
+}
+
+
+static int acpi_device_suspend(struct device * dev, pm_message_t state)
+{
+	struct acpi_device * acpi_dev = to_acpi_dev(dev);
+
+	/*
+	 * For now, we should only register 1 generic device -
+	 * the ACPI root device - and from there, we walk the
+	 * tree of ACPI devices to suspend each one using the
+	 * ACPI driver methods.
+	 */
+	if (acpi_dev->handle == ACPI_ROOT_OBJECT)
+		root_suspend(acpi_dev);
+	return 0;
+}
+
+
+
+static int root_resume(struct acpi_device * acpi_dev)
+{
+	struct acpi_device * dev, * next;
+	int result;
+
+	spin_lock(&acpi_device_lock);
+	list_for_each_entry_safe(dev, next, &acpi_device_list, g_list) {
+		if (dev->driver && dev->driver->ops.resume) {
+			spin_unlock(&acpi_device_lock);
+
+			/* TBD: What suspend state should be passed
+			 * to device?
+			 */
+			result = dev->driver->ops.resume(dev, 0);
+			if (result) {
+				printk(KERN_ERR PREFIX "[%s - %s] resume failed: %d\n",
+				       acpi_device_name(dev),
+				       acpi_device_bid(dev), result);
+			}
+			spin_lock(&acpi_device_lock);
+		}
+	}
+	spin_unlock(&acpi_device_lock);
+	return 0;
+}
+
+
+static int acpi_device_resume(struct device * dev)
+{
+	struct acpi_device * acpi_dev = to_acpi_dev(dev);
+
+	/*
+	 * For now, we should only register 1 generic device -
+	 * the ACPI root device - and from there, we walk the
+	 * tree of ACPI devices to resume each one using the
+	 * ACPI driver methods.
+	 */
+	if (acpi_dev->handle == ACPI_ROOT_OBJECT)
+		root_resume(acpi_dev);
+	return 0;
+}
+
+
+struct bus_type acpi_bus_type = {
+	.name		= "acpi",
+	.suspend	= acpi_device_suspend,
+	.resume		= acpi_device_resume,
+};
+
+
+
 static int __init acpi_scan_init(void)
 {
 	int result;
@@ -1383,6 +1485,12 @@ static int __init acpi_scan_init(void)
 
 	kset_register(&acpi_namespace_kset);
 
+	result = bus_register(&acpi_bus_type);
+	if (result) {
+		/* We don't want to quit even if we failed to add suspend/resume */
+		printk(KERN_ERR PREFIX "Could not register bus type\n");
+	}
+
 	/*
 	 * Create the root device in the bus's device tree
 	 */
@@ -1392,6 +1500,16 @@ static int __init acpi_scan_init(void)
 		goto Done;
 
 	result = acpi_start_single_object(acpi_root);
+	if (result)
+		goto Done;
+
+	acpi_root->dev.bus = &acpi_bus_type;
+	snprintf(acpi_root->dev.bus_id, BUS_ID_SIZE, "%s", acpi_bus_type.name);
+	result = device_register(&acpi_root->dev);
+	if (result) {
+		/* We don't want to quit even if we failed to add suspend/resume */
+		printk(KERN_ERR PREFIX "Could not register device\n");
+	}
 
 	/*
 	 * Enumerate devices in the ACPI namespace.

commit 06ea8e08ae7e7e450b6a78e7ce5e10b3c5f954ea
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Apr 27 05:25:00 2006 -0400

    ACPI: acpi_bus_unregister_driver() returns void
    
    Nobody looks at the return value, and this brings it into line with
    pci_unregister_driver(), etc.  Also removed validation of the driver
    pointer passed in to register and unregister.  More consistent, and we'll
    find bugs faster if we fault rather than returning an error that's ignored.
    
    Also makes internal functions acpi_device_unregister() and
    acpi_driver_detach() void, since nobody uses their returns either.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 669553553fbb..e8efaac71e74 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -142,7 +142,7 @@ static void acpi_device_register(struct acpi_device *device,
 	create_sysfs_device_files(device);
 }
 
-static int acpi_device_unregister(struct acpi_device *device, int type)
+static void acpi_device_unregister(struct acpi_device *device, int type)
 {
 	spin_lock(&acpi_device_lock);
 	if (device->parent) {
@@ -158,7 +158,6 @@ static int acpi_device_unregister(struct acpi_device *device, int type)
 	acpi_detach_data(device->handle, acpi_bus_data_handler);
 	remove_sysfs_device_files(device);
 	kobject_unregister(&device->kobj);
-	return 0;
 }
 
 void acpi_bus_data_handler(acpi_handle handle, u32 function, void *context)
@@ -577,7 +576,7 @@ static void acpi_driver_attach(struct acpi_driver *drv)
 	spin_unlock(&acpi_device_lock);
 }
 
-static int acpi_driver_detach(struct acpi_driver *drv)
+static void acpi_driver_detach(struct acpi_driver *drv)
 {
 	struct list_head *node, *next;
 
@@ -599,7 +598,6 @@ static int acpi_driver_detach(struct acpi_driver *drv)
 		}
 	}
 	spin_unlock(&acpi_device_lock);
-	return_VALUE(0);
 }
 
 /**
@@ -617,9 +615,6 @@ int acpi_bus_register_driver(struct acpi_driver *driver)
 	if (acpi_disabled)
 		return_VALUE(-ENODEV);
 
-	if (!driver)
-		return_VALUE(-EINVAL);
-
 	spin_lock(&acpi_device_lock);
 	list_add_tail(&driver->node, &acpi_bus_drivers);
 	spin_unlock(&acpi_device_lock);
@@ -637,23 +632,16 @@ EXPORT_SYMBOL(acpi_bus_register_driver);
  * Unregisters a driver with the ACPI bus.  Searches the namespace for all
  * devices that match the driver's criteria and unbinds.
  */
-int acpi_bus_unregister_driver(struct acpi_driver *driver)
+void acpi_bus_unregister_driver(struct acpi_driver *driver)
 {
-	int error = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_unregister_driver");
-
-	if (driver) {
-		acpi_driver_detach(driver);
+	acpi_driver_detach(driver);
 
-		if (!atomic_read(&driver->references)) {
-			spin_lock(&acpi_device_lock);
-			list_del_init(&driver->node);
-			spin_unlock(&acpi_device_lock);
-		}
-	} else
-		error = -EINVAL;
-	return_VALUE(error);
+	if (!atomic_read(&driver->references)) {
+		spin_lock(&acpi_device_lock);
+		list_del_init(&driver->node);
+		spin_unlock(&acpi_device_lock);
+	}
+	return;
 }
 
 EXPORT_SYMBOL(acpi_bus_unregister_driver);

commit 415d320a2384bb80d2be98b1dfa41594e085012d
Author: Len Brown <len.brown@intel.com>
Date:   Sat May 13 21:35:56 2006 -0400

    ACPI: delete unused acpi_bus_drivers_lock
    
    acpi_bus_drivers is protected by acpi_device_lock
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a0ab828b2cc5..2cb3b0916eba 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -471,7 +471,6 @@ static int acpi_bus_get_perf_flags(struct acpi_device *device)
    -------------------------------------------------------------------------- */
 
 static LIST_HEAD(acpi_bus_drivers);
-static DECLARE_MUTEX(acpi_bus_drivers_lock);
 
 /**
  * acpi_bus_match - match device IDs to driver's supported IDs

commit eefa27a93a0490902f33837ac86dbcf344b3aa29
Author: Ashok Raj <ashok.raj@intel.com>
Date:   Tue Mar 28 17:04:00 2006 -0500

    ACPI: Allow hot-add of ejected processor
    
    acpi_eject_store() didn't trim processors, causing subsequent
    hot-add to fail.
    
    Signed-off-by: Ashok Raj <ashok.raj@intel.com>
    Cc: Andi Kleen <ak@muc.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a0ab828b2cc5..95d5bc2acadd 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -441,10 +441,7 @@ acpi_eject_store(struct acpi_device *device, const char *buf, size_t count)
 	islockable = device->flags.lockable;
 	handle = device->handle;
 
-	if (type == ACPI_TYPE_PROCESSOR)
-		result = acpi_bus_trim(device, 0);
-	else
-		result = acpi_bus_trim(device, 1);
+	result = acpi_bus_trim(device, 1);
 
 	if (!result)
 		result = acpi_eject_operation(handle, islockable);

commit 1a36561607abf1405b56a41aac2fd163429cd1f8
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 28 17:04:00 2006 -0500

    ACPI: simplify scan.c coding
    
    No functional changes; just remove leftover, unused "buffer" and simplify
    control flow (no need to remember error values and goto the end, when we can
    simply return the value directly).
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a0ab828b2cc5..08ba85cab2dd 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -234,12 +234,9 @@ static int acpi_bus_get_power_flags(struct acpi_device *device)
 
 int acpi_match_ids(struct acpi_device *device, char *ids)
 {
-	int error = 0;
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
-
 	if (device->flags.hardware_id)
 		if (strstr(ids, device->pnp.hardware_id))
-			goto Done;
+			return 0;
 
 	if (device->flags.compatible_ids) {
 		struct acpi_compatible_id_list *cid_list = device->pnp.cid_list;
@@ -248,15 +245,10 @@ int acpi_match_ids(struct acpi_device *device, char *ids)
 		/* compare multiple _CID entries against driver ids */
 		for (i = 0; i < cid_list->count; i++) {
 			if (strstr(ids, cid_list->id[i].value))
-				goto Done;
+				return 0;
 		}
 	}
-	error = -ENOENT;
-
-      Done:
-	if (buffer.pointer)
-		acpi_os_free(buffer.pointer);
-	return error;
+	return -ENOENT;
 }
 
 static acpi_status
@@ -645,21 +637,19 @@ EXPORT_SYMBOL(acpi_bus_register_driver);
  */
 int acpi_bus_unregister_driver(struct acpi_driver *driver)
 {
-	int error = 0;
-
 	ACPI_FUNCTION_TRACE("acpi_bus_unregister_driver");
 
-	if (driver) {
-		acpi_driver_detach(driver);
+	if (!driver)
+		return_VALUE(-EINVAL);
 
-		if (!atomic_read(&driver->references)) {
-			spin_lock(&acpi_device_lock);
-			list_del_init(&driver->node);
-			spin_unlock(&acpi_device_lock);
-		}
-	} else
-		error = -EINVAL;
-	return_VALUE(error);
+	acpi_driver_detach(driver);
+
+	if (!atomic_read(&driver->references)) {
+		spin_lock(&acpi_device_lock);
+		list_del_init(&driver->node);
+		spin_unlock(&acpi_device_lock);
+	}
+	return_VALUE(0);
 }
 
 EXPORT_SYMBOL(acpi_bus_unregister_driver);

commit 9d9f749b316ac21cb59ad3e595cbce469b409e1a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 28 17:04:00 2006 -0500

    ACPI: make acpi_bus_register_driver() return success/failure, not device count
    
    acpi_bus_register_driver() should not return the number of devices claimed.
    We're not asking to find devices, we're making a driver available to devices,
    including hot-pluggable devices that may appear in the future.
    
    I audited all callers of acpi_bus_register_driver(), and except asus_acpi.c
    and sonypi.c (fixed in previous patches), all either ignore the return value
    or test only for failure (<0).
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index a0ab828b2cc5..669553553fbb 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -548,10 +548,9 @@ static int acpi_start_single_object(struct acpi_device *device)
 	return_VALUE(result);
 }
 
-static int acpi_driver_attach(struct acpi_driver *drv)
+static void acpi_driver_attach(struct acpi_driver *drv)
 {
 	struct list_head *node, *next;
-	int count = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_driver_attach");
 
@@ -568,7 +567,6 @@ static int acpi_driver_attach(struct acpi_driver *drv)
 			if (!acpi_bus_driver_init(dev, drv)) {
 				acpi_start_single_object(dev);
 				atomic_inc(&drv->references);
-				count++;
 				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 						  "Found driver [%s] for device [%s]\n",
 						  drv->name, dev->pnp.bus_id));
@@ -577,7 +575,6 @@ static int acpi_driver_attach(struct acpi_driver *drv)
 		spin_lock(&acpi_device_lock);
 	}
 	spin_unlock(&acpi_device_lock);
-	return_VALUE(count);
 }
 
 static int acpi_driver_detach(struct acpi_driver *drv)
@@ -610,14 +607,11 @@ static int acpi_driver_detach(struct acpi_driver *drv)
  * @driver: driver being registered
  *
  * Registers a driver with the ACPI bus.  Searches the namespace for all
- * devices that match the driver's criteria and binds.  Returns the
- * number of devices that were claimed by the driver, or a negative
- * error status for failure.
+ * devices that match the driver's criteria and binds.  Returns zero for
+ * success or a negative error status for failure.
  */
 int acpi_bus_register_driver(struct acpi_driver *driver)
 {
-	int count;
-
 	ACPI_FUNCTION_TRACE("acpi_bus_register_driver");
 
 	if (acpi_disabled)
@@ -629,9 +623,9 @@ int acpi_bus_register_driver(struct acpi_driver *driver)
 	spin_lock(&acpi_device_lock);
 	list_add_tail(&driver->node, &acpi_bus_drivers);
 	spin_unlock(&acpi_device_lock);
-	count = acpi_driver_attach(driver);
+	acpi_driver_attach(driver);
 
-	return_VALUE(count);
+	return_VALUE(0);
 }
 
 EXPORT_SYMBOL(acpi_bus_register_driver);

commit ceaba663055e38226a070a9668eac5881d65a2cc
Author: Kristen Accardi <kristen.c.accardi@intel.com>
Date:   Thu Feb 23 17:56:01 2006 -0800

    [PATCH] acpi: export acpi_bus_trim
    
    Export the acpi_bus_trim function so that the pci hotplug driver can
    use it.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 9271e5209ac1..a0ab828b2cc5 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -23,7 +23,6 @@ static LIST_HEAD(acpi_device_list);
 DEFINE_SPINLOCK(acpi_device_lock);
 LIST_HEAD(acpi_wakeup_device_list);
 
-static int acpi_bus_trim(struct acpi_device *start, int rmdevice);
 
 static void acpi_device_release(struct kobject *kobj)
 {
@@ -1284,7 +1283,7 @@ int acpi_bus_start(struct acpi_device *device)
 
 EXPORT_SYMBOL(acpi_bus_start);
 
-static int acpi_bus_trim(struct acpi_device *start, int rmdevice)
+int acpi_bus_trim(struct acpi_device *start, int rmdevice)
 {
 	acpi_status status;
 	struct acpi_device *parent, *child;
@@ -1337,6 +1336,8 @@ static int acpi_bus_trim(struct acpi_device *start, int rmdevice)
 	}
 	return err;
 }
+EXPORT_SYMBOL_GPL(acpi_bus_trim);
+
 
 static int acpi_bus_scan_fixed(struct acpi_device *root)
 {

commit 9fdb62af92c741addbea15545f214a6e89460865
Merge: 3ee68c4af3fd 876c184b31dc 729b4d4ce198 cf8247884018 dacd9b803555 63c94b68ec30 35f652b5ef4e 1a38416cea8a 4a90c7e86202 aea19aa0780d 757b18661ea0 c4bb6f5ad968
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jan 24 17:52:48 2006 -0500

    [ACPI] merge 3549 4320 4485 4588 4980 5483 5651 acpica asus fops pnpacpi branches into release
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit d758a8fa8ce0566947677f7e70bf70c57ad9445c
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Fri Jan 6 01:31:00 2006 -0500

    [ACPI] fix kernel-doc warnings in acpi/scan.c
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 0745d20afb8c..3b26a7104363 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -475,8 +475,10 @@ static LIST_HEAD(acpi_bus_drivers);
 static DECLARE_MUTEX(acpi_bus_drivers_lock);
 
 /**
- * acpi_bus_match 
- * --------------
+ * acpi_bus_match - match device IDs to driver's supported IDs
+ * @device: the device that we are trying to match to a driver
+ * @driver: driver whose device id table is being checked
+ *
  * Checks the device's hardware (_HID) or compatible (_CID) ids to see if it
  * matches the specified driver's criteria.
  */
@@ -489,8 +491,10 @@ acpi_bus_match(struct acpi_device *device, struct acpi_driver *driver)
 }
 
 /**
- * acpi_bus_driver_init 
- * --------------------
+ * acpi_bus_driver_init - add a device to a driver
+ * @device: the device to add and initialize
+ * @driver: driver for the device
+ *
  * Used to initialize a device via its device driver.  Called whenever a 
  * driver is bound to a device.  Invokes the driver's add() and start() ops.
  */
@@ -603,8 +607,9 @@ static int acpi_driver_detach(struct acpi_driver *drv)
 }
 
 /**
- * acpi_bus_register_driver 
- * ------------------------ 
+ * acpi_bus_register_driver - register a driver with the ACPI bus
+ * @driver: driver being registered
+ *
  * Registers a driver with the ACPI bus.  Searches the namespace for all
  * devices that match the driver's criteria and binds.  Returns the
  * number of devices that were claimed by the driver, or a negative
@@ -633,8 +638,9 @@ int acpi_bus_register_driver(struct acpi_driver *driver)
 EXPORT_SYMBOL(acpi_bus_register_driver);
 
 /**
- * acpi_bus_unregister_driver 
- * --------------------------
+ * acpi_bus_unregister_driver - unregisters a driver with the APIC bus
+ * @driver: driver to unregister
+ *
  * Unregisters a driver with the ACPI bus.  Searches the namespace for all
  * devices that match the driver's criteria and unbinds.
  */
@@ -660,8 +666,9 @@ int acpi_bus_unregister_driver(struct acpi_driver *driver)
 EXPORT_SYMBOL(acpi_bus_unregister_driver);
 
 /**
- * acpi_bus_find_driver 
- * --------------------
+ * acpi_bus_find_driver - check if there is a driver installed for the device
+ * @device: device that we are trying to find a supporting driver for
+ *
  * Parses the list of registered drivers looking for a driver applicable for
  * the specified device.
  */

commit ed03f430cdc8c802652467e9097606fedc2c7abc
Merge: ed349a8a0a78 6f957eaf7935
Author: Len Brown <len.brown@intel.com>
Date:   Sat Jan 7 03:50:18 2006 -0500

    Pull pnpacpi into acpica branch

commit 312c004d36ce6c739512bac83b452f4c20ab1f62
Author: Kay Sievers <kay.sievers@suse.de>
Date:   Wed Nov 16 09:00:00 2005 +0100

    [PATCH] driver core: replace "hotplug" by "uevent"
    
    Leave the overloaded "hotplug" word to susbsystems which are handling
    real devices. The driver core does not "plug" anything, it just exports
    the state to userspace and generates events.
    
    Signed-off-by: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 31218e1d2a18..0745d20afb8c 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -78,7 +78,7 @@ static struct kobj_type ktype_acpi_ns = {
 	.release = acpi_device_release,
 };
 
-static int namespace_hotplug(struct kset *kset, struct kobject *kobj,
+static int namespace_uevent(struct kset *kset, struct kobject *kobj,
 			     char **envp, int num_envp, char *buffer,
 			     int buffer_size)
 {
@@ -89,8 +89,8 @@ static int namespace_hotplug(struct kset *kset, struct kobject *kobj,
 	if (!dev->driver)
 		return 0;
 
-	if (add_hotplug_env_var(envp, num_envp, &i, buffer, buffer_size, &len,
-				"PHYSDEVDRIVER=%s", dev->driver->name))
+	if (add_uevent_var(envp, num_envp, &i, buffer, buffer_size, &len,
+			   "PHYSDEVDRIVER=%s", dev->driver->name))
 		return -ENOMEM;
 
 	envp[i] = NULL;
@@ -98,8 +98,8 @@ static int namespace_hotplug(struct kset *kset, struct kobject *kobj,
 	return 0;
 }
 
-static struct kset_hotplug_ops namespace_hotplug_ops = {
-	.hotplug = &namespace_hotplug,
+static struct kset_uevent_ops namespace_uevent_ops = {
+	.uevent = &namespace_uevent,
 };
 
 static struct kset acpi_namespace_kset = {
@@ -108,7 +108,7 @@ static struct kset acpi_namespace_kset = {
 		 },
 	.subsys = &acpi_subsys,
 	.ktype = &ktype_acpi_ns,
-	.hotplug_ops = &namespace_hotplug_ops,
+	.uevent_ops = &namespace_uevent_ops,
 };
 
 static void acpi_device_register(struct acpi_device *device,
@@ -347,7 +347,7 @@ static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 }
 
 /* --------------------------------------------------------------------------
-		ACPI hotplug sysfs device file support
+		ACPI sysfs device file support
    -------------------------------------------------------------------------- */
 static ssize_t acpi_eject_store(struct acpi_device *device,
 				const char *buf, size_t count);

commit c51a4de85de720670f2fbc592a6f8040af72ad87
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Nov 17 13:07:00 2005 -0500

    [ACPI] ACPICA 20051117
    
    Fixed a problem in the AML parser where the method thread
    count could be decremented below zero if any errors
    occurred during the method parse phase. This should
    eliminate AE_AML_METHOD_LIMIT exceptions seen on some
    machines. This also fixed a related regression with the
    mechanism that detects and corrects methods that cannot
    properly handle reentrancy (related to the deployment of
    the new OwnerId mechanism.)
    
    Eliminated the pre-parsing of control methods (to detect
    errors) during table load. Related to the problem above,
    this was causing unwind issues if any errors occurred
    during the parse, and it seemed to be overkill. A table
    load should not be aborted if there are problems with
    any single control method, thus rendering this feature
    rather pointless.
    
    Fixed a problem with the new table-driven resource manager
    where an internal buffer overflow could occur for small
    resource templates.
    
    Implemented a new external interface, acpi_get_vendor_resource()
    This interface will find and return a vendor-defined
    resource descriptor within a _CRS or _PRS
    method via an ACPI 3.0 UUID match. (from Bjorn Helgaas)
    
    Removed the length limit (200) on string objects as
    per the upcoming ACPI 3.0A specification. This affects
    the following areas of the interpreter: 1) any implicit
    conversion of a Buffer to a String, 2) a String object
    result of the ASL Concatentate operator, 3) the String
    object result of the ASL ToString operator.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 31218e1d2a18..e332306ae2b9 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -844,7 +844,7 @@ static void acpi_device_set_id(struct acpi_device *device,
 	 * ----
 	 * Fix for the system root bus device -- the only root-level device.
 	 */
-	if ((parent == ACPI_ROOT_OBJECT) && (type == ACPI_BUS_TYPE_DEVICE)) {
+	if (((acpi_handle)parent == ACPI_ROOT_OBJECT) && (type == ACPI_BUS_TYPE_DEVICE)) {
 		hid = ACPI_BUS_HID;
 		strcpy(device->pnp.device_name, ACPI_BUS_DEVICE_NAME);
 		strcpy(device->pnp.device_class, ACPI_BUS_CLASS);

commit bd7ce5b5ff930c29b1c0405051e9c9388660b785
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Oct 3 10:39:00 2005 -0700

    [ACPI] fix HP nx8220 boot hang regression
    
    This patch reverts the acpi_bus_find_driver() return value check
    that came in via the PCI tree via 3fb02738b0fd36f47710a2bf207129efd2f5daa2
    
            [PATCH] acpi bridge hotadd: Allow ACPI .add and .start
            operations to be done independently
    
    This particular change broke booting of some HP/Compaq laptops unless
    acpi=noirq is used.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=5221
    https://bugzilla.novell.com/show_bug.cgi?id=116763
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Cc: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 23e2c6968a11..31218e1d2a18 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1110,7 +1110,7 @@ acpi_add_single_object(struct acpi_device **child,
 	 *
 	 * TBD: Assumes LDM provides driver hot-plug capability.
 	 */
-	result = acpi_bus_find_driver(device);
+	acpi_bus_find_driver(device);
 
       end:
 	if (!result)

commit 6044ec8882c726e325017bd948aa0cd94ad33abc
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Mon Nov 7 01:01:32 2005 -0800

    [PATCH] kfree cleanup: misc remaining drivers
    
    This is the remaining misc drivers/ part of the big kfree cleanup patch.
    
    Remove pointless checks for NULL prior to calling kfree() in misc files in
    drivers/.
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Acked-by: Aristeu Sergio Rozanski Filho <aris@cathedrallabs.org>
    Acked-by: Roland Dreier <rolandd@cisco.com>
    Acked-by: Pierre Ossman <drzeus@drzeus.cx>
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Len Brown <len.brown@intel.com>
    Acked-by: "Antonino A. Daplas" <adaplas@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index c6db591479de..23e2c6968a11 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -28,8 +28,7 @@ static int acpi_bus_trim(struct acpi_device *start, int rmdevice);
 static void acpi_device_release(struct kobject *kobj)
 {
 	struct acpi_device *dev = container_of(kobj, struct acpi_device, kobj);
-	if (dev->pnp.cid_list)
-		kfree(dev->pnp.cid_list);
+	kfree(dev->pnp.cid_list);
 	kfree(dev);
 }
 
@@ -1117,8 +1116,7 @@ acpi_add_single_object(struct acpi_device **child,
 	if (!result)
 		*child = device;
 	else {
-		if (device->pnp.cid_list)
-			kfree(device->pnp.cid_list);
+		kfree(device->pnp.cid_list);
 		kfree(device);
 	}
 

commit 8713cbefafbb5a101ade541a4b0ffa108bf697cc
Author: Adrian Bunk <bunk@stusta.de>
Date:   Fri Sep 2 17:16:48 2005 -0400

    [ACPI] add static to function definitions
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 8a3ea41063ec..c6db591479de 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -527,7 +527,7 @@ acpi_bus_driver_init(struct acpi_device *device, struct acpi_driver *driver)
 	return_VALUE(0);
 }
 
-int acpi_start_single_object(struct acpi_device *device)
+static int acpi_start_single_object(struct acpi_device *device)
 {
 	int result = 0;
 	struct acpi_driver *driver;

commit 4be44fcd3bf648b782f4460fd06dfae6c42ded4b
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 5 00:44:28 2005 -0400

    [ACPI] Lindent all ACPI files
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index cbcda30c172d..8a3ea41063ec 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -9,14 +9,10 @@
 #include <acpi/acpi_drivers.h>
 #include <acpi/acinterp.h>	/* for acpi_ex_eisa_id_to_string() */
 
-
 #define _COMPONENT		ACPI_BUS_COMPONENT
-ACPI_MODULE_NAME		("scan")
-
+ACPI_MODULE_NAME("scan")
 #define STRUCT_TO_INT(s)	(*((int*)&s))
-
-extern struct acpi_device		*acpi_root;
-
+extern struct acpi_device *acpi_root;
 
 #define ACPI_BUS_CLASS			"system_bus"
 #define ACPI_BUS_HID			"ACPI_BUS"
@@ -27,13 +23,11 @@ static LIST_HEAD(acpi_device_list);
 DEFINE_SPINLOCK(acpi_device_lock);
 LIST_HEAD(acpi_wakeup_device_list);
 
-static int
-acpi_bus_trim(struct acpi_device	*start,
-		int rmdevice);
+static int acpi_bus_trim(struct acpi_device *start, int rmdevice);
 
-static void acpi_device_release(struct kobject * kobj)
+static void acpi_device_release(struct kobject *kobj)
 {
-	struct acpi_device * dev = container_of(kobj,struct acpi_device,kobj);
+	struct acpi_device *dev = container_of(kobj, struct acpi_device, kobj);
 	if (dev->pnp.cid_list)
 		kfree(dev->pnp.cid_list);
 	kfree(dev);
@@ -41,34 +35,34 @@ static void acpi_device_release(struct kobject * kobj)
 
 struct acpi_device_attribute {
 	struct attribute attr;
-	ssize_t (*show)(struct acpi_device *, char *);
-	ssize_t (*store)(struct acpi_device *, const char *, size_t);
+	 ssize_t(*show) (struct acpi_device *, char *);
+	 ssize_t(*store) (struct acpi_device *, const char *, size_t);
 };
 
 typedef void acpi_device_sysfs_files(struct kobject *,
-				const struct attribute *);
+				     const struct attribute *);
 
 static void setup_sys_fs_device_files(struct acpi_device *dev,
-		acpi_device_sysfs_files *func);
+				      acpi_device_sysfs_files * func);
 
 #define create_sysfs_device_files(dev)	\
 	setup_sys_fs_device_files(dev, (acpi_device_sysfs_files *)&sysfs_create_file)
 #define remove_sysfs_device_files(dev)	\
 	setup_sys_fs_device_files(dev, (acpi_device_sysfs_files *)&sysfs_remove_file)
 
-
 #define to_acpi_device(n) container_of(n, struct acpi_device, kobj)
 #define to_handle_attr(n) container_of(n, struct acpi_device_attribute, attr);
 
 static ssize_t acpi_device_attr_show(struct kobject *kobj,
-		struct attribute *attr, char *buf)
+				     struct attribute *attr, char *buf)
 {
 	struct acpi_device *device = to_acpi_device(kobj);
 	struct acpi_device_attribute *attribute = to_handle_attr(attr);
 	return attribute->show ? attribute->show(device, buf) : -EIO;
 }
 static ssize_t acpi_device_attr_store(struct kobject *kobj,
-		struct attribute *attr, const char *buf, size_t len)
+				      struct attribute *attr, const char *buf,
+				      size_t len)
 {
 	struct acpi_device *device = to_acpi_device(kobj);
 	struct acpi_device_attribute *attribute = to_handle_attr(attr);
@@ -76,13 +70,13 @@ static ssize_t acpi_device_attr_store(struct kobject *kobj,
 }
 
 static struct sysfs_ops acpi_device_sysfs_ops = {
-	.show	= acpi_device_attr_show,
-	.store	= acpi_device_attr_store,
+	.show = acpi_device_attr_show,
+	.store = acpi_device_attr_store,
 };
 
 static struct kobj_type ktype_acpi_ns = {
-	.sysfs_ops	= &acpi_device_sysfs_ops,
-	.release	= acpi_device_release,
+	.sysfs_ops = &acpi_device_sysfs_ops,
+	.release = acpi_device_release,
 };
 
 static int namespace_hotplug(struct kset *kset, struct kobject *kobj,
@@ -110,16 +104,16 @@ static struct kset_hotplug_ops namespace_hotplug_ops = {
 };
 
 static struct kset acpi_namespace_kset = {
-	.kobj		= { 
-		.name = "namespace",
-	},
+	.kobj = {
+		 .name = "namespace",
+		 },
 	.subsys = &acpi_subsys,
-	.ktype	= &ktype_acpi_ns,
+	.ktype = &ktype_acpi_ns,
 	.hotplug_ops = &namespace_hotplug_ops,
 };
 
-
-static void acpi_device_register(struct acpi_device * device, struct acpi_device * parent)
+static void acpi_device_register(struct acpi_device *device,
+				 struct acpi_device *parent)
 {
 	/*
 	 * Linkage
@@ -134,14 +128,14 @@ static void acpi_device_register(struct acpi_device * device, struct acpi_device
 	spin_lock(&acpi_device_lock);
 	if (device->parent) {
 		list_add_tail(&device->node, &device->parent->children);
-		list_add_tail(&device->g_list,&device->parent->g_list);
+		list_add_tail(&device->g_list, &device->parent->g_list);
 	} else
-		list_add_tail(&device->g_list,&acpi_device_list);
+		list_add_tail(&device->g_list, &acpi_device_list);
 	if (device->wakeup.flags.valid)
-		list_add_tail(&device->wakeup_list,&acpi_wakeup_device_list);
+		list_add_tail(&device->wakeup_list, &acpi_wakeup_device_list);
 	spin_unlock(&acpi_device_lock);
 
-	strlcpy(device->kobj.name,device->pnp.bus_id,KOBJ_NAME_LEN);
+	strlcpy(device->kobj.name, device->pnp.bus_id, KOBJ_NAME_LEN);
 	if (parent)
 		device->kobj.parent = &parent->kobj;
 	device->kobj.ktype = &ktype_acpi_ns;
@@ -150,10 +144,7 @@ static void acpi_device_register(struct acpi_device * device, struct acpi_device
 	create_sysfs_device_files(device);
 }
 
-static int
-acpi_device_unregister (
-	struct acpi_device	*device, 
-	int			type)
+static int acpi_device_unregister(struct acpi_device *device, int type)
 {
 	spin_lock(&acpi_device_lock);
 	if (device->parent) {
@@ -172,11 +163,7 @@ acpi_device_unregister (
 	return 0;
 }
 
-void
-acpi_bus_data_handler (
-	acpi_handle		handle,
-	u32			function,
-	void			*context)
+void acpi_bus_data_handler(acpi_handle handle, u32 function, void *context)
 {
 	ACPI_FUNCTION_TRACE("acpi_bus_data_handler");
 
@@ -185,13 +172,11 @@ acpi_bus_data_handler (
 	return_VOID;
 }
 
-static int
-acpi_bus_get_power_flags (
-	struct acpi_device	*device)
+static int acpi_bus_get_power_flags(struct acpi_device *device)
 {
-	acpi_status             status = 0;
-	acpi_handle		handle = NULL;
-	u32                     i = 0;
+	acpi_status status = 0;
+	acpi_handle handle = NULL;
+	u32 i = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_bus_get_power_flags");
 
@@ -210,11 +195,11 @@ acpi_bus_get_power_flags (
 	 */
 	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3; i++) {
 		struct acpi_device_power_state *ps = &device->power.states[i];
-		char		object_name[5] = {'_','P','R','0'+i,'\0'};
+		char object_name[5] = { '_', 'P', 'R', '0' + i, '\0' };
 
 		/* Evaluate "_PRx" to se if power resources are referenced */
 		acpi_evaluate_reference(device->handle, object_name, NULL,
-			&ps->resources);
+					&ps->resources);
 		if (ps->resources.count) {
 			device->power.flags.power_resources = 1;
 			ps->flags.valid = 1;
@@ -232,7 +217,7 @@ acpi_bus_get_power_flags (
 		if (ps->resources.count || ps->flags.explicit_set)
 			ps->flags.valid = 1;
 
-		ps->power = -1;		/* Unknown - driver assigned */
+		ps->power = -1;	/* Unknown - driver assigned */
 		ps->latency = -1;	/* Unknown - driver assigned */
 	}
 
@@ -249,13 +234,10 @@ acpi_bus_get_power_flags (
 	return_VALUE(0);
 }
 
-int
-acpi_match_ids (
-	struct acpi_device	*device,
-	char			*ids)
+int acpi_match_ids(struct acpi_device *device, char *ids)
 {
 	int error = 0;
-	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 
 	if (device->flags.hardware_id)
 		if (strstr(ids, device->pnp.hardware_id))
@@ -266,27 +248,25 @@ acpi_match_ids (
 		int i;
 
 		/* compare multiple _CID entries against driver ids */
-		for (i = 0; i < cid_list->count; i++)
-		{
+		for (i = 0; i < cid_list->count; i++) {
 			if (strstr(ids, cid_list->id[i].value))
 				goto Done;
 		}
 	}
 	error = -ENOENT;
 
- Done:
+      Done:
 	if (buffer.pointer)
 		acpi_os_free(buffer.pointer);
 	return error;
 }
 
 static acpi_status
-acpi_bus_extract_wakeup_device_power_package (
-	struct acpi_device	*device,
-	union acpi_object	*package)
+acpi_bus_extract_wakeup_device_power_package(struct acpi_device *device,
+					     union acpi_object *package)
 {
-	int 	 i = 0;
-	union acpi_object	*element = NULL;
+	int i = 0;
+	union acpi_object *element = NULL;
 
 	if (!device || !package || (package->package.count < 2))
 		return AE_BAD_PARAMETER;
@@ -296,14 +276,17 @@ acpi_bus_extract_wakeup_device_power_package (
 		return AE_BAD_PARAMETER;
 	if (element->type == ACPI_TYPE_PACKAGE) {
 		if ((element->package.count < 2) ||
-			(element->package.elements[0].type != ACPI_TYPE_LOCAL_REFERENCE) ||
-			(element->package.elements[1].type != ACPI_TYPE_INTEGER))
+		    (element->package.elements[0].type !=
+		     ACPI_TYPE_LOCAL_REFERENCE)
+		    || (element->package.elements[1].type != ACPI_TYPE_INTEGER))
 			return AE_BAD_DATA;
-		device->wakeup.gpe_device = element->package.elements[0].reference.handle;
-		device->wakeup.gpe_number = (u32)element->package.elements[1].integer.value;
-	}else if (element->type == ACPI_TYPE_INTEGER) {
+		device->wakeup.gpe_device =
+		    element->package.elements[0].reference.handle;
+		device->wakeup.gpe_number =
+		    (u32) element->package.elements[1].integer.value;
+	} else if (element->type == ACPI_TYPE_INTEGER) {
 		device->wakeup.gpe_number = element->integer.value;
-	}else
+	} else
 		return AE_BAD_DATA;
 
 	element = &(package->package.elements[1]);
@@ -316,9 +299,9 @@ acpi_bus_extract_wakeup_device_power_package (
 		return AE_NO_MEMORY;
 	}
 	device->wakeup.resources.count = package->package.count - 2;
-	for (i=0; i < device->wakeup.resources.count; i++) {
+	for (i = 0; i < device->wakeup.resources.count; i++) {
 		element = &(package->package.elements[i + 2]);
-		if (element->type != ACPI_TYPE_ANY ) {
+		if (element->type != ACPI_TYPE_ANY) {
 			return AE_BAD_DATA;
 		}
 
@@ -328,13 +311,11 @@ acpi_bus_extract_wakeup_device_power_package (
 	return AE_OK;
 }
 
-static int
-acpi_bus_get_wakeup_device_flags (
-	struct acpi_device	*device)
+static int acpi_bus_get_wakeup_device_flags(struct acpi_device *device)
 {
-	acpi_status	status = 0;
-	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	union acpi_object	*package = NULL;
+	acpi_status status = 0;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *package = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_bus_get_wakeup_flags");
 
@@ -345,21 +326,22 @@ acpi_bus_get_wakeup_device_flags (
 		goto end;
 	}
 
-	package = (union acpi_object *) buffer.pointer;
+	package = (union acpi_object *)buffer.pointer;
 	status = acpi_bus_extract_wakeup_device_power_package(device, package);
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _PRW package\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Error extracting _PRW package\n"));
 		goto end;
 	}
 
 	acpi_os_free(buffer.pointer);
 
 	device->wakeup.flags.valid = 1;
-	/* Power button, Lid switch always enable wakeup*/
+	/* Power button, Lid switch always enable wakeup */
 	if (!acpi_match_ids(device, "PNP0C0D,PNP0C0C,PNP0C0E"))
 		device->wakeup.flags.run_wake = 1;
 
-end:
+      end:
 	if (ACPI_FAILURE(status))
 		device->flags.wake_capable = 0;
 	return_VALUE(0);
@@ -368,8 +350,8 @@ acpi_bus_get_wakeup_device_flags (
 /* --------------------------------------------------------------------------
 		ACPI hotplug sysfs device file support
    -------------------------------------------------------------------------- */
-static ssize_t acpi_eject_store(struct acpi_device *device, 
-		const char *buf, size_t count);
+static ssize_t acpi_eject_store(struct acpi_device *device,
+				const char *buf, size_t count);
 
 #define ACPI_DEVICE_ATTR(_name,_mode,_show,_store) \
 static struct acpi_device_attribute acpi_device_attr_##_name = \
@@ -383,12 +365,11 @@ ACPI_DEVICE_ATTR(eject, 0200, NULL, acpi_eject_store);
  * @func:	function pointer to create or destroy the device file
  */
 static void
-setup_sys_fs_device_files (
-	struct acpi_device *dev,
-	acpi_device_sysfs_files *func)
+setup_sys_fs_device_files(struct acpi_device *dev,
+			  acpi_device_sysfs_files * func)
 {
-	acpi_status		status;
-	acpi_handle		temp = NULL;
+	acpi_status status;
+	acpi_handle temp = NULL;
 
 	/*
 	 * If device has _EJ0, 'eject' file is created that is used to trigger
@@ -396,11 +377,10 @@ setup_sys_fs_device_files (
 	 */
 	status = acpi_get_handle(dev->handle, "_EJ0", &temp);
 	if (ACPI_SUCCESS(status))
-		(*(func))(&dev->kobj,&acpi_device_attr_eject.attr);
+		(*(func)) (&dev->kobj, &acpi_device_attr_eject.attr);
 }
 
-static int
-acpi_eject_operation(acpi_handle handle, int lockable)
+static int acpi_eject_operation(acpi_handle handle, int lockable)
 {
 	struct acpi_object_list arg_list;
 	union acpi_object arg;
@@ -429,27 +409,25 @@ acpi_eject_operation(acpi_handle handle, int lockable)
 
 	status = acpi_evaluate_object(handle, "_EJ0", &arg_list, NULL);
 	if (ACPI_FAILURE(status)) {
-		return(-ENODEV);
+		return (-ENODEV);
 	}
 
-	return(0);
+	return (0);
 }
 
-
 static ssize_t
 acpi_eject_store(struct acpi_device *device, const char *buf, size_t count)
 {
-	int	result;
-	int	ret = count;
-	int	islockable;
-	acpi_status	status;
-	acpi_handle	handle;
-	acpi_object_type	type = 0;
+	int result;
+	int ret = count;
+	int islockable;
+	acpi_status status;
+	acpi_handle handle;
+	acpi_object_type type = 0;
 
 	if ((!count) || (buf[0] != '1')) {
 		return -EINVAL;
 	}
-
 #ifndef FORCE_EJECT
 	if (device->driver == NULL) {
 		ret = -ENODEV;
@@ -457,7 +435,7 @@ acpi_eject_store(struct acpi_device *device, const char *buf, size_t count)
 	}
 #endif
 	status = acpi_get_type(device->handle, &type);
-	if (ACPI_FAILURE(status) || (!device->flags.ejectable) ) {
+	if (ACPI_FAILURE(status) || (!device->flags.ejectable)) {
 		ret = -ENODEV;
 		goto err;
 	}
@@ -476,18 +454,15 @@ acpi_eject_store(struct acpi_device *device, const char *buf, size_t count)
 	if (result) {
 		ret = -EBUSY;
 	}
-err:
+      err:
 	return ret;
 }
 
-
 /* --------------------------------------------------------------------------
                               Performance Management
    -------------------------------------------------------------------------- */
 
-static int
-acpi_bus_get_perf_flags (
-	struct acpi_device	*device)
+static int acpi_bus_get_perf_flags(struct acpi_device *device)
 {
 	device->performance.state = ACPI_STATE_UNKNOWN;
 	return 0;
@@ -500,7 +475,6 @@ acpi_bus_get_perf_flags (
 static LIST_HEAD(acpi_bus_drivers);
 static DECLARE_MUTEX(acpi_bus_drivers_lock);
 
-
 /**
  * acpi_bus_match 
  * --------------
@@ -508,16 +482,13 @@ static DECLARE_MUTEX(acpi_bus_drivers_lock);
  * matches the specified driver's criteria.
  */
 static int
-acpi_bus_match (
-	struct acpi_device	*device,
-	struct acpi_driver	*driver)
+acpi_bus_match(struct acpi_device *device, struct acpi_driver *driver)
 {
 	if (driver && driver->ops.match)
 		return driver->ops.match(device, driver);
 	return acpi_match_ids(device, driver->ids);
 }
 
-
 /**
  * acpi_bus_driver_init 
  * --------------------
@@ -525,11 +496,9 @@ acpi_bus_match (
  * driver is bound to a device.  Invokes the driver's add() and start() ops.
  */
 static int
-acpi_bus_driver_init (
-	struct acpi_device	*device, 
-	struct acpi_driver	*driver)
+acpi_bus_driver_init(struct acpi_device *device, struct acpi_driver *driver)
 {
-	int			result = 0;
+	int result = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_bus_driver_init");
 
@@ -553,13 +522,12 @@ acpi_bus_driver_init (
 	 * upon possible configuration and currently allocated resources.
 	 */
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Driver successfully bound to device\n"));
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "Driver successfully bound to device\n"));
 	return_VALUE(0);
 }
 
-int
-acpi_start_single_object (
-		struct acpi_device *device)
+int acpi_start_single_object(struct acpi_device *device)
 {
 	int result = 0;
 	struct acpi_driver *driver;
@@ -578,16 +546,17 @@ acpi_start_single_object (
 	return_VALUE(result);
 }
 
-static int acpi_driver_attach(struct acpi_driver * drv)
+static int acpi_driver_attach(struct acpi_driver *drv)
 {
-	struct list_head * node, * next;
+	struct list_head *node, *next;
 	int count = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_driver_attach");
 
 	spin_lock(&acpi_device_lock);
 	list_for_each_safe(node, next, &acpi_device_list) {
-		struct acpi_device * dev = container_of(node, struct acpi_device, g_list);
+		struct acpi_device *dev =
+		    container_of(node, struct acpi_device, g_list);
 
 		if (dev->driver || !dev->status.present)
 			continue;
@@ -598,7 +567,8 @@ static int acpi_driver_attach(struct acpi_driver * drv)
 				acpi_start_single_object(dev);
 				atomic_inc(&drv->references);
 				count++;
-				ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found driver [%s] for device [%s]\n",
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+						  "Found driver [%s] for device [%s]\n",
 						  drv->name, dev->pnp.bus_id));
 			}
 		}
@@ -608,20 +578,21 @@ static int acpi_driver_attach(struct acpi_driver * drv)
 	return_VALUE(count);
 }
 
-static int acpi_driver_detach(struct acpi_driver * drv)
+static int acpi_driver_detach(struct acpi_driver *drv)
 {
-	struct list_head * node, * next;
+	struct list_head *node, *next;
 
 	ACPI_FUNCTION_TRACE("acpi_driver_detach");
 
 	spin_lock(&acpi_device_lock);
-	list_for_each_safe(node,next,&acpi_device_list) {
-		struct acpi_device * dev = container_of(node,struct acpi_device,g_list);
+	list_for_each_safe(node, next, &acpi_device_list) {
+		struct acpi_device *dev =
+		    container_of(node, struct acpi_device, g_list);
 
 		if (dev->driver == drv) {
 			spin_unlock(&acpi_device_lock);
 			if (drv->ops.remove)
-				drv->ops.remove(dev,ACPI_BUS_REMOVAL_NORMAL);
+				drv->ops.remove(dev, ACPI_BUS_REMOVAL_NORMAL);
 			spin_lock(&acpi_device_lock);
 			dev->driver = NULL;
 			dev->driver_data = NULL;
@@ -640,9 +611,7 @@ static int acpi_driver_detach(struct acpi_driver * drv)
  * number of devices that were claimed by the driver, or a negative
  * error status for failure.
  */
-int
-acpi_bus_register_driver (
-	struct acpi_driver	*driver)
+int acpi_bus_register_driver(struct acpi_driver *driver)
 {
 	int count;
 
@@ -661,8 +630,8 @@ acpi_bus_register_driver (
 
 	return_VALUE(count);
 }
-EXPORT_SYMBOL(acpi_bus_register_driver);
 
+EXPORT_SYMBOL(acpi_bus_register_driver);
 
 /**
  * acpi_bus_unregister_driver 
@@ -670,9 +639,7 @@ EXPORT_SYMBOL(acpi_bus_register_driver);
  * Unregisters a driver with the ACPI bus.  Searches the namespace for all
  * devices that match the driver's criteria and unbinds.
  */
-int
-acpi_bus_unregister_driver (
-	struct acpi_driver	*driver)
+int acpi_bus_unregister_driver(struct acpi_driver *driver)
 {
 	int error = 0;
 
@@ -685,11 +652,12 @@ acpi_bus_unregister_driver (
 			spin_lock(&acpi_device_lock);
 			list_del_init(&driver->node);
 			spin_unlock(&acpi_device_lock);
-		} 
-	} else 
+		}
+	} else
 		error = -EINVAL;
 	return_VALUE(error);
 }
+
 EXPORT_SYMBOL(acpi_bus_unregister_driver);
 
 /**
@@ -698,18 +666,17 @@ EXPORT_SYMBOL(acpi_bus_unregister_driver);
  * Parses the list of registered drivers looking for a driver applicable for
  * the specified device.
  */
-static int
-acpi_bus_find_driver (
-	struct acpi_device	*device)
+static int acpi_bus_find_driver(struct acpi_device *device)
 {
-	int			result = 0;
-	struct list_head	* node, *next;
+	int result = 0;
+	struct list_head *node, *next;
 
 	ACPI_FUNCTION_TRACE("acpi_bus_find_driver");
 
 	spin_lock(&acpi_device_lock);
-	list_for_each_safe(node,next,&acpi_bus_drivers) {
-		struct acpi_driver * driver = container_of(node,struct acpi_driver,node);
+	list_for_each_safe(node, next, &acpi_bus_drivers) {
+		struct acpi_driver *driver =
+		    container_of(node, struct acpi_driver, node);
 
 		atomic_inc(&driver->references);
 		spin_unlock(&acpi_device_lock);
@@ -723,21 +690,18 @@ acpi_bus_find_driver (
 	}
 	spin_unlock(&acpi_device_lock);
 
- Done:
+      Done:
 	return_VALUE(result);
 }
 
-
 /* --------------------------------------------------------------------------
                                  Device Enumeration
    -------------------------------------------------------------------------- */
 
-static int 
-acpi_bus_get_flags (
-	struct acpi_device	*device)
+static int acpi_bus_get_flags(struct acpi_device *device)
 {
-	acpi_status		status = AE_OK;
-	acpi_handle		temp = NULL;
+	acpi_status status = AE_OK;
+	acpi_handle temp = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_bus_get_flags");
 
@@ -788,11 +752,12 @@ acpi_bus_get_flags (
 	return_VALUE(0);
 }
 
-static void acpi_device_get_busid(struct acpi_device * device, acpi_handle handle, int type)
+static void acpi_device_get_busid(struct acpi_device *device,
+				  acpi_handle handle, int type)
 {
-	char			bus_id[5] = {'?',0};
-	struct acpi_buffer	buffer = {sizeof(bus_id), bus_id};
-	int			i = 0;
+	char bus_id[5] = { '?', 0 };
+	struct acpi_buffer buffer = { sizeof(bus_id), bus_id };
+	int i = 0;
 
 	/*
 	 * Bus ID
@@ -824,21 +789,22 @@ static void acpi_device_get_busid(struct acpi_device * device, acpi_handle handl
 	}
 }
 
-static void acpi_device_set_id(struct acpi_device * device, struct acpi_device * parent,
-			       acpi_handle handle, int type)
+static void acpi_device_set_id(struct acpi_device *device,
+			       struct acpi_device *parent, acpi_handle handle,
+			       int type)
 {
-	struct acpi_device_info	*info;
-	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	char			*hid = NULL;
-	char			*uid = NULL;
+	struct acpi_device_info *info;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	char *hid = NULL;
+	char *uid = NULL;
 	struct acpi_compatible_id_list *cid_list = NULL;
-	acpi_status		status;
+	acpi_status status;
 
 	switch (type) {
 	case ACPI_BUS_TYPE_DEVICE:
 		status = acpi_get_object_info(handle, &buffer);
 		if (ACPI_FAILURE(status)) {
-			printk("%s: Error reading device info\n",__FUNCTION__);
+			printk("%s: Error reading device info\n", __FUNCTION__);
 			return;
 		}
 
@@ -904,7 +870,7 @@ static void acpi_device_set_id(struct acpi_device * device, struct acpi_device *
 	acpi_os_free(buffer.pointer);
 }
 
-static int acpi_device_set_context(struct acpi_device * device, int type)
+static int acpi_device_set_context(struct acpi_device *device, int type)
 {
 	acpi_status status = AE_OK;
 	int result = 0;
@@ -916,10 +882,10 @@ static int acpi_device_set_context(struct acpi_device * device, int type)
 	 * to be careful with fixed-feature devices as they all attach to the
 	 * root object.
 	 */
-	if (type != ACPI_BUS_TYPE_POWER_BUTTON && 
+	if (type != ACPI_BUS_TYPE_POWER_BUTTON &&
 	    type != ACPI_BUS_TYPE_SLEEP_BUTTON) {
 		status = acpi_attach_data(device->handle,
-			acpi_bus_data_handler, device);
+					  acpi_bus_data_handler, device);
 
 		if (ACPI_FAILURE(status)) {
 			printk("Error attaching device data\n");
@@ -929,12 +895,13 @@ static int acpi_device_set_context(struct acpi_device * device, int type)
 	return result;
 }
 
-static void acpi_device_get_debug_info(struct acpi_device * device, acpi_handle handle, int type)
+static void acpi_device_get_debug_info(struct acpi_device *device,
+				       acpi_handle handle, int type)
 {
 #ifdef CONFIG_ACPI_DEBUG_OUTPUT
-	char		*type_string = NULL;
-	char		name[80] = {'?','\0'};
-	struct acpi_buffer	buffer = {sizeof(name), name};
+	char *type_string = NULL;
+	char name[80] = { '?', '\0' };
+	struct acpi_buffer buffer = { sizeof(name), name };
 
 	switch (type) {
 	case ACPI_BUS_TYPE_DEVICE:
@@ -968,18 +935,14 @@ static void acpi_device_get_debug_info(struct acpi_device * device, acpi_handle
 	}
 
 	printk(KERN_DEBUG "Found %s %s [%p]\n", type_string, name, handle);
-#endif /*CONFIG_ACPI_DEBUG_OUTPUT*/
+#endif				/*CONFIG_ACPI_DEBUG_OUTPUT */
 }
 
-
-static int
-acpi_bus_remove (
-	struct acpi_device *dev,
-	int rmdevice)
+static int acpi_bus_remove(struct acpi_device *dev, int rmdevice)
 {
-	int 			result = 0;
-	struct acpi_driver	*driver;
-	
+	int result = 0;
+	struct acpi_driver *driver;
+
 	ACPI_FUNCTION_TRACE("acpi_bus_remove");
 
 	if (!dev)
@@ -1012,22 +975,18 @@ acpi_bus_remove (
 		if ((dev->parent) && (dev->parent->ops.unbind))
 			dev->parent->ops.unbind(dev);
 	}
-	
+
 	acpi_device_unregister(dev, ACPI_BUS_REMOVAL_EJECT);
 
 	return_VALUE(0);
 }
 
-
 static int
-acpi_add_single_object (
-	struct acpi_device	**child,
-	struct acpi_device	*parent,
-	acpi_handle		handle,
-	int			type)
+acpi_add_single_object(struct acpi_device **child,
+		       struct acpi_device *parent, acpi_handle handle, int type)
 {
-	int			result = 0;
-	struct acpi_device	*device = NULL;
+	int result = 0;
+	struct acpi_device *device = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_add_single_object");
 
@@ -1044,7 +1003,7 @@ acpi_add_single_object (
 	device->handle = handle;
 	device->parent = parent;
 
-	acpi_device_get_busid(device,handle,type);
+	acpi_device_get_busid(device, handle, type);
 
 	/*
 	 * Flags
@@ -1092,7 +1051,7 @@ acpi_add_single_object (
 	 * Hardware ID, Unique ID, & Bus Address
 	 * -------------------------------------
 	 */
-	acpi_device_set_id(device,parent,handle,type);
+	acpi_device_set_id(device, parent, handle, type);
 
 	/*
 	 * Power Management
@@ -1104,7 +1063,7 @@ acpi_add_single_object (
 			goto end;
 	}
 
- 	/*
+	/*
 	 * Wakeup device management
 	 *-----------------------
 	 */
@@ -1124,12 +1083,12 @@ acpi_add_single_object (
 			goto end;
 	}
 
-	if ((result = acpi_device_set_context(device,type)))
+	if ((result = acpi_device_set_context(device, type)))
 		goto end;
 
-	acpi_device_get_debug_info(device,handle,type);
+	acpi_device_get_debug_info(device, handle, type);
 
-	acpi_device_register(device,parent);
+	acpi_device_register(device, parent);
 
 	/*
 	 * Bind _ADR-Based Devices
@@ -1154,7 +1113,7 @@ acpi_add_single_object (
 	 */
 	result = acpi_bus_find_driver(device);
 
-end:
+      end:
 	if (!result)
 		*child = device;
 	else {
@@ -1166,17 +1125,15 @@ acpi_add_single_object (
 	return_VALUE(result);
 }
 
-
-static int acpi_bus_scan (struct acpi_device	*start,
-		struct acpi_bus_ops *ops)
+static int acpi_bus_scan(struct acpi_device *start, struct acpi_bus_ops *ops)
 {
-	acpi_status		status = AE_OK;
-	struct acpi_device	*parent = NULL;
-	struct acpi_device	*child = NULL;
-	acpi_handle		phandle = NULL;
-	acpi_handle		chandle = NULL;
-	acpi_object_type	type = 0;
-	u32			level = 1;
+	acpi_status status = AE_OK;
+	struct acpi_device *parent = NULL;
+	struct acpi_device *child = NULL;
+	acpi_handle phandle = NULL;
+	acpi_handle chandle = NULL;
+	acpi_object_type type = 0;
+	u32 level = 1;
 
 	ACPI_FUNCTION_TRACE("acpi_bus_scan");
 
@@ -1185,7 +1142,7 @@ static int acpi_bus_scan (struct acpi_device	*start,
 
 	parent = start;
 	phandle = start->handle;
-	
+
 	/*
 	 * Parse through the ACPI namespace, identify all 'devices', and
 	 * create a new 'struct acpi_device' for each.
@@ -1193,7 +1150,7 @@ static int acpi_bus_scan (struct acpi_device	*start,
 	while ((level > 0) && parent) {
 
 		status = acpi_get_next_object(ACPI_TYPE_ANY, phandle,
-			chandle, &chandle);
+					      chandle, &chandle);
 
 		/*
 		 * If this scope is exhausted then move our way back up.
@@ -1243,12 +1200,12 @@ static int acpi_bus_scan (struct acpi_device	*start,
 
 		if (ops->acpi_op_add)
 			status = acpi_add_single_object(&child, parent,
-					chandle, type);
-		 else
+							chandle, type);
+		else
 			status = acpi_bus_get_device(chandle, &child);
 
-		 if (ACPI_FAILURE(status))
-			 continue;
+		if (ACPI_FAILURE(status))
+			continue;
 
 		if (ops->acpi_op_start) {
 			status = acpi_start_single_object(child);
@@ -1264,7 +1221,7 @@ static int acpi_bus_scan (struct acpi_device	*start,
 		 * which will be enumerated when the parent is inserted).
 		 *
 		 * TBD: Need notifications and other detection mechanisms
-		 *	in place before we can fully implement this.
+		 *      in place before we can fully implement this.
 		 */
 		if (child->status.present) {
 			status = acpi_get_next_object(ACPI_TYPE_ANY, chandle,
@@ -1282,11 +1239,8 @@ static int acpi_bus_scan (struct acpi_device	*start,
 }
 
 int
-acpi_bus_add (
-	struct acpi_device	**child,
-	struct acpi_device	*parent,
-	acpi_handle		handle,
-	int			type)
+acpi_bus_add(struct acpi_device **child,
+	     struct acpi_device *parent, acpi_handle handle, int type)
 {
 	int result;
 	struct acpi_bus_ops ops;
@@ -1301,11 +1255,10 @@ acpi_bus_add (
 	}
 	return_VALUE(result);
 }
+
 EXPORT_SYMBOL(acpi_bus_add);
 
-int
-acpi_bus_start (
-	struct acpi_device *device)
+int acpi_bus_start(struct acpi_device *device)
 {
 	int result;
 	struct acpi_bus_ops ops;
@@ -1323,26 +1276,25 @@ acpi_bus_start (
 	}
 	return_VALUE(result);
 }
+
 EXPORT_SYMBOL(acpi_bus_start);
 
-static int
-acpi_bus_trim(struct acpi_device	*start,
-		int rmdevice)
+static int acpi_bus_trim(struct acpi_device *start, int rmdevice)
 {
-	acpi_status		status;
-	struct acpi_device	*parent, *child;
-	acpi_handle		phandle, chandle;
-	acpi_object_type	type;
-	u32			level = 1;
-	int			err = 0;
-
-	parent  = start;
+	acpi_status status;
+	struct acpi_device *parent, *child;
+	acpi_handle phandle, chandle;
+	acpi_object_type type;
+	u32 level = 1;
+	int err = 0;
+
+	parent = start;
 	phandle = start->handle;
 	child = chandle = NULL;
 
 	while ((level > 0) && parent && (!err)) {
 		status = acpi_get_next_object(ACPI_TYPE_ANY, phandle,
-			chandle, &chandle);
+					      chandle, &chandle);
 
 		/*
 		 * If this scope is exhausted then move our way back up.
@@ -1381,12 +1333,10 @@ acpi_bus_trim(struct acpi_device	*start,
 	return err;
 }
 
-static int
-acpi_bus_scan_fixed (
-	struct acpi_device	*root)
+static int acpi_bus_scan_fixed(struct acpi_device *root)
 {
-	int			result = 0;
-	struct acpi_device	*device = NULL;
+	int result = 0;
+	struct acpi_device *device = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_bus_scan_fixed");
 
@@ -1398,14 +1348,16 @@ acpi_bus_scan_fixed (
 	 */
 	if (acpi_fadt.pwr_button == 0) {
 		result = acpi_add_single_object(&device, acpi_root,
-			NULL, ACPI_BUS_TYPE_POWER_BUTTON);
+						NULL,
+						ACPI_BUS_TYPE_POWER_BUTTON);
 		if (!result)
 			result = acpi_start_single_object(device);
 	}
 
 	if (acpi_fadt.sleep_button == 0) {
 		result = acpi_add_single_object(&device, acpi_root,
-			NULL, ACPI_BUS_TYPE_SLEEP_BUTTON);
+						NULL,
+						ACPI_BUS_TYPE_SLEEP_BUTTON);
 		if (!result)
 			result = acpi_start_single_object(device);
 	}
@@ -1413,7 +1365,6 @@ acpi_bus_scan_fixed (
 	return_VALUE(result);
 }
 
-
 static int __init acpi_scan_init(void)
 {
 	int result;
@@ -1430,7 +1381,7 @@ static int __init acpi_scan_init(void)
 	 * Create the root device in the bus's device tree
 	 */
 	result = acpi_add_single_object(&acpi_root, NULL, ACPI_ROOT_OBJECT,
-		ACPI_BUS_TYPE_SYSTEM);
+					ACPI_BUS_TYPE_SYSTEM);
 	if (result)
 		goto Done;
 
@@ -1450,7 +1401,7 @@ static int __init acpi_scan_init(void)
 	if (result)
 		acpi_device_unregister(acpi_root, ACPI_BUS_REMOVAL_NORMAL);
 
- Done:
+      Done:
 	return_VALUE(result);
 }
 

commit 5028770a42e7bc4d15791a44c28f0ad539323807
Merge: 9f02d6b7b43d d8683a0cb5d0
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jul 12 17:21:56 2005 -0400

    [ACPI] merge acpi-2.6.12 branch into latest Linux 2.6.13-rc...
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 6940fabaa35b893163b7043d0d1dc5d715f9e1ca
Author: Keiichiro Tokunaga <tokunaga.keiich@jp.fujitsu.com>
Date:   Wed Mar 30 23:15:47 2005 -0500

    [ACPI] hotplug Processor consideration in acpi_bus_add()
    
    Signed-off-by: Keiichiro Tokunaga <tokunaga.keiich@jp.fujitsu.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 119c94093a13..7c26fed0bdf0 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1051,13 +1051,15 @@ acpi_bus_add (
 	/*
 	 * Status
 	 * ------
-	 * See if the device is present.  We always assume that non-Device()
-	 * objects (e.g. thermal zones, power resources, processors, etc.) are
-	 * present, functioning, etc. (at least when parent object is present).
-	 * Note that _STA has a different meaning for some objects (e.g.
-	 * power resources) so we need to be careful how we use it.
+	 * See if the device is present.  We always assume that non-Device
+	 * and non-Processor objects (e.g. thermal zones, power resources,
+	 * etc.) are present, functioning, etc. (at least when parent object
+	 * is present).  Note that _STA has a different meaning for some
+	 * objects (e.g. power resources) so we need to be careful how we use
+	 * it.
 	 */
 	switch (type) {
+	case ACPI_BUS_TYPE_PROCESSOR:
 	case ACPI_BUS_TYPE_DEVICE:
 		result = acpi_bus_get_status(device);
 		if (ACPI_FAILURE(result) || !device->status.present) {

commit 3fb02738b0fd36f47710a2bf207129efd2f5daa2
Author: Rajesh Shah <rajesh.shah@intel.com>
Date:   Thu Apr 28 00:25:52 2005 -0700

    [PATCH] acpi bridge hotadd: Allow ACPI .add and .start operations to be done independently
    
    Create new interfaces to recursively add an acpi namespace object to the acpi
    device list, and recursively start the namespace object.  This is needed for
    ACPI based hotplug of a root bridge hierarchy where the add operation must be
    performed first and the start operation must be performed separately after the
    hot-plugged devices have been properly configured.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e85885593280..337d49b5564b 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -553,20 +553,29 @@ acpi_bus_driver_init (
 	 * upon possible configuration and currently allocated resources.
 	 */
 
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Driver successfully bound to device\n"));
+	return_VALUE(0);
+}
+
+int
+acpi_start_single_object (
+		struct acpi_device *device)
+{
+	int result = 0;
+	struct acpi_driver *driver;
+
+	ACPI_FUNCTION_TRACE("acpi_start_single_object");
+
+	if (!(driver = device->driver))
+		return_VALUE(0);
+
 	if (driver->ops.start) {
 		result = driver->ops.start(device);
 		if (result && driver->ops.remove)
 			driver->ops.remove(device, ACPI_BUS_REMOVAL_NORMAL);
-		return_VALUE(result);
 	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Driver successfully bound to device\n"));
-
-	if (driver->ops.scan) {
-		driver->ops.scan(device);
-	}
-
-	return_VALUE(0);
+	return_VALUE(result);
 }
 
 static int acpi_driver_attach(struct acpi_driver * drv)
@@ -586,6 +595,7 @@ static int acpi_driver_attach(struct acpi_driver * drv)
 
 		if (!acpi_bus_match(dev, drv)) {
 			if (!acpi_bus_driver_init(dev, drv)) {
+				acpi_start_single_object(dev);
 				atomic_inc(&drv->references);
 				count++;
 				ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found driver [%s] for device [%s]\n",
@@ -1009,8 +1019,8 @@ acpi_bus_remove (
 }
 
 
-int
-acpi_bus_add (
+static int
+acpi_add_single_object (
 	struct acpi_device	**child,
 	struct acpi_device	*parent,
 	acpi_handle		handle,
@@ -1019,7 +1029,7 @@ acpi_bus_add (
 	int			result = 0;
 	struct acpi_device	*device = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_bus_add");
+	ACPI_FUNCTION_TRACE("acpi_add_single_object");
 
 	if (!child)
 		return_VALUE(-EINVAL);
@@ -1140,7 +1150,7 @@ acpi_bus_add (
 	 *
 	 * TBD: Assumes LDM provides driver hot-plug capability.
 	 */
-	acpi_bus_find_driver(device);
+	result = acpi_bus_find_driver(device);
 
 end:
 	if (!result)
@@ -1153,10 +1163,10 @@ acpi_bus_add (
 
 	return_VALUE(result);
 }
-EXPORT_SYMBOL(acpi_bus_add);
 
 
-int acpi_bus_scan (struct acpi_device	*start)
+static int acpi_bus_scan (struct acpi_device	*start,
+		struct acpi_bus_ops *ops)
 {
 	acpi_status		status = AE_OK;
 	struct acpi_device	*parent = NULL;
@@ -1229,9 +1239,20 @@ int acpi_bus_scan (struct acpi_device	*start)
 			continue;
 		}
 
-		status = acpi_bus_add(&child, parent, chandle, type);
-		if (ACPI_FAILURE(status))
-			continue;
+		if (ops->acpi_op_add)
+			status = acpi_add_single_object(&child, parent,
+					chandle, type);
+		 else
+			status = acpi_bus_get_device(chandle, &child);
+
+		 if (ACPI_FAILURE(status))
+			 continue;
+
+		if (ops->acpi_op_start) {
+			status = acpi_start_single_object(child);
+			if (ACPI_FAILURE(status))
+				continue;
+		}
 
 		/*
 		 * If the device is present, enabled, and functioning then
@@ -1257,8 +1278,50 @@ int acpi_bus_scan (struct acpi_device	*start)
 
 	return_VALUE(0);
 }
-EXPORT_SYMBOL(acpi_bus_scan);
 
+int
+acpi_bus_add (
+	struct acpi_device	**child,
+	struct acpi_device	*parent,
+	acpi_handle		handle,
+	int			type)
+{
+	int result;
+	struct acpi_bus_ops ops;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_add");
+
+	result = acpi_add_single_object(child, parent, handle, type);
+	if (!result) {
+		memset(&ops, 0, sizeof(ops));
+		ops.acpi_op_add = 1;
+		result = acpi_bus_scan(*child, &ops);
+	}
+	return_VALUE(result);
+}
+EXPORT_SYMBOL(acpi_bus_add);
+
+int
+acpi_bus_start (
+	struct acpi_device *device)
+{
+	int result;
+	struct acpi_bus_ops ops;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_start");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	result = acpi_start_single_object(device);
+	if (!result) {
+		memset(&ops, 0, sizeof(ops));
+		ops.acpi_op_start = 1;
+		result = acpi_bus_scan(device, &ops);
+	}
+	return_VALUE(result);
+}
+EXPORT_SYMBOL(acpi_bus_start);
 
 static int
 acpi_bus_trim(struct acpi_device	*start,
@@ -1331,13 +1394,19 @@ acpi_bus_scan_fixed (
 	/*
 	 * Enumerate all fixed-feature devices.
 	 */
-	if (acpi_fadt.pwr_button == 0)
-		result = acpi_bus_add(&device, acpi_root, 
+	if (acpi_fadt.pwr_button == 0) {
+		result = acpi_add_single_object(&device, acpi_root,
 			NULL, ACPI_BUS_TYPE_POWER_BUTTON);
+		if (!result)
+			result = acpi_start_single_object(device);
+	}
 
-	if (acpi_fadt.sleep_button == 0)
-		result = acpi_bus_add(&device, acpi_root, 
+	if (acpi_fadt.sleep_button == 0) {
+		result = acpi_add_single_object(&device, acpi_root,
 			NULL, ACPI_BUS_TYPE_SLEEP_BUTTON);
+		if (!result)
+			result = acpi_start_single_object(device);
+	}
 
 	return_VALUE(result);
 }
@@ -1346,6 +1415,7 @@ acpi_bus_scan_fixed (
 static int __init acpi_scan_init(void)
 {
 	int result;
+	struct acpi_bus_ops ops;
 
 	ACPI_FUNCTION_TRACE("acpi_scan_init");
 
@@ -1357,17 +1427,23 @@ static int __init acpi_scan_init(void)
 	/*
 	 * Create the root device in the bus's device tree
 	 */
-	result = acpi_bus_add(&acpi_root, NULL, ACPI_ROOT_OBJECT, 
+	result = acpi_add_single_object(&acpi_root, NULL, ACPI_ROOT_OBJECT,
 		ACPI_BUS_TYPE_SYSTEM);
 	if (result)
 		goto Done;
 
+	result = acpi_start_single_object(acpi_root);
+
 	/*
 	 * Enumerate devices in the ACPI namespace.
 	 */
 	result = acpi_bus_scan_fixed(acpi_root);
-	if (!result) 
-		result = acpi_bus_scan(acpi_root);
+	if (!result) {
+		memset(&ops, 0, sizeof(ops));
+		ops.acpi_op_add = 1;
+		ops.acpi_op_start = 1;
+		result = acpi_bus_scan(acpi_root, &ops);
+	}
 
 	if (result)
 		acpi_device_unregister(acpi_root, ACPI_BUS_REMOVAL_NORMAL);

commit 70f2817a43c89b784dc2ec3d06ba5bf3064f8235
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Fri Apr 29 01:27:34 2005 -0500

    [PATCH] sysfs: (rest) if show/store is missing return -EIO
    
    sysfs: fix the rest of the kernel so if an attribute doesn't
           implement show or store method read/write will return
           -EIO instead of 0 or -EINVAL or -EPERM.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 119c94093a13..e85885593280 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -65,14 +65,14 @@ static ssize_t acpi_device_attr_show(struct kobject *kobj,
 {
 	struct acpi_device *device = to_acpi_device(kobj);
 	struct acpi_device_attribute *attribute = to_handle_attr(attr);
-	return attribute->show ? attribute->show(device, buf) : 0;
+	return attribute->show ? attribute->show(device, buf) : -EIO;
 }
 static ssize_t acpi_device_attr_store(struct kobject *kobj,
 		struct attribute *attr, const char *buf, size_t len)
 {
 	struct acpi_device *device = to_acpi_device(kobj);
 	struct acpi_device_attribute *attribute = to_handle_attr(attr);
-	return attribute->store ? attribute->store(device, buf, len) : len;
+	return attribute->store ? attribute->store(device, buf, len) : -EIO;
 }
 
 static struct sysfs_ops acpi_device_sysfs_ops = {

commit 67be2dd1bace0ec7ce2dbc1bba3f8df3d7be597e
Author: Martin Waitz <tali@admingilde.org>
Date:   Sun May 1 08:59:26 2005 -0700

    [PATCH] DocBook: fix some descriptions
    
    Some KernelDoc descriptions are updated to match the current code.
    No code changes.
    
    Signed-off-by: Martin Waitz <tali@admingilde.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e7ca06626566..119c94093a13 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -379,8 +379,8 @@ ACPI_DEVICE_ATTR(eject, 0200, NULL, acpi_eject_store);
 
 /**
  * setup_sys_fs_device_files - sets up the device files under device namespace
- * @@dev:	acpi_device object
- * @@func:	function pointer to create or destroy the device file
+ * @dev:	acpi_device object
+ * @func:	function pointer to create or destroy the device file
  */
 static void
 setup_sys_fs_device_files (

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
new file mode 100644
index 000000000000..e7ca06626566
--- /dev/null
+++ b/drivers/acpi/scan.c
@@ -0,0 +1,1379 @@
+/*
+ * scan.c - support for transforming the ACPI namespace into individual objects
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/acpi.h>
+
+#include <acpi/acpi_drivers.h>
+#include <acpi/acinterp.h>	/* for acpi_ex_eisa_id_to_string() */
+
+
+#define _COMPONENT		ACPI_BUS_COMPONENT
+ACPI_MODULE_NAME		("scan")
+
+#define STRUCT_TO_INT(s)	(*((int*)&s))
+
+extern struct acpi_device		*acpi_root;
+
+
+#define ACPI_BUS_CLASS			"system_bus"
+#define ACPI_BUS_HID			"ACPI_BUS"
+#define ACPI_BUS_DRIVER_NAME		"ACPI Bus Driver"
+#define ACPI_BUS_DEVICE_NAME		"System Bus"
+
+static LIST_HEAD(acpi_device_list);
+DEFINE_SPINLOCK(acpi_device_lock);
+LIST_HEAD(acpi_wakeup_device_list);
+
+static int
+acpi_bus_trim(struct acpi_device	*start,
+		int rmdevice);
+
+static void acpi_device_release(struct kobject * kobj)
+{
+	struct acpi_device * dev = container_of(kobj,struct acpi_device,kobj);
+	if (dev->pnp.cid_list)
+		kfree(dev->pnp.cid_list);
+	kfree(dev);
+}
+
+struct acpi_device_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct acpi_device *, char *);
+	ssize_t (*store)(struct acpi_device *, const char *, size_t);
+};
+
+typedef void acpi_device_sysfs_files(struct kobject *,
+				const struct attribute *);
+
+static void setup_sys_fs_device_files(struct acpi_device *dev,
+		acpi_device_sysfs_files *func);
+
+#define create_sysfs_device_files(dev)	\
+	setup_sys_fs_device_files(dev, (acpi_device_sysfs_files *)&sysfs_create_file)
+#define remove_sysfs_device_files(dev)	\
+	setup_sys_fs_device_files(dev, (acpi_device_sysfs_files *)&sysfs_remove_file)
+
+
+#define to_acpi_device(n) container_of(n, struct acpi_device, kobj)
+#define to_handle_attr(n) container_of(n, struct acpi_device_attribute, attr);
+
+static ssize_t acpi_device_attr_show(struct kobject *kobj,
+		struct attribute *attr, char *buf)
+{
+	struct acpi_device *device = to_acpi_device(kobj);
+	struct acpi_device_attribute *attribute = to_handle_attr(attr);
+	return attribute->show ? attribute->show(device, buf) : 0;
+}
+static ssize_t acpi_device_attr_store(struct kobject *kobj,
+		struct attribute *attr, const char *buf, size_t len)
+{
+	struct acpi_device *device = to_acpi_device(kobj);
+	struct acpi_device_attribute *attribute = to_handle_attr(attr);
+	return attribute->store ? attribute->store(device, buf, len) : len;
+}
+
+static struct sysfs_ops acpi_device_sysfs_ops = {
+	.show	= acpi_device_attr_show,
+	.store	= acpi_device_attr_store,
+};
+
+static struct kobj_type ktype_acpi_ns = {
+	.sysfs_ops	= &acpi_device_sysfs_ops,
+	.release	= acpi_device_release,
+};
+
+static int namespace_hotplug(struct kset *kset, struct kobject *kobj,
+			     char **envp, int num_envp, char *buffer,
+			     int buffer_size)
+{
+	struct acpi_device *dev = to_acpi_device(kobj);
+	int i = 0;
+	int len = 0;
+
+	if (!dev->driver)
+		return 0;
+
+	if (add_hotplug_env_var(envp, num_envp, &i, buffer, buffer_size, &len,
+				"PHYSDEVDRIVER=%s", dev->driver->name))
+		return -ENOMEM;
+
+	envp[i] = NULL;
+
+	return 0;
+}
+
+static struct kset_hotplug_ops namespace_hotplug_ops = {
+	.hotplug = &namespace_hotplug,
+};
+
+static struct kset acpi_namespace_kset = {
+	.kobj		= { 
+		.name = "namespace",
+	},
+	.subsys = &acpi_subsys,
+	.ktype	= &ktype_acpi_ns,
+	.hotplug_ops = &namespace_hotplug_ops,
+};
+
+
+static void acpi_device_register(struct acpi_device * device, struct acpi_device * parent)
+{
+	/*
+	 * Linkage
+	 * -------
+	 * Link this device to its parent and siblings.
+	 */
+	INIT_LIST_HEAD(&device->children);
+	INIT_LIST_HEAD(&device->node);
+	INIT_LIST_HEAD(&device->g_list);
+	INIT_LIST_HEAD(&device->wakeup_list);
+
+	spin_lock(&acpi_device_lock);
+	if (device->parent) {
+		list_add_tail(&device->node, &device->parent->children);
+		list_add_tail(&device->g_list,&device->parent->g_list);
+	} else
+		list_add_tail(&device->g_list,&acpi_device_list);
+	if (device->wakeup.flags.valid)
+		list_add_tail(&device->wakeup_list,&acpi_wakeup_device_list);
+	spin_unlock(&acpi_device_lock);
+
+	strlcpy(device->kobj.name,device->pnp.bus_id,KOBJ_NAME_LEN);
+	if (parent)
+		device->kobj.parent = &parent->kobj;
+	device->kobj.ktype = &ktype_acpi_ns;
+	device->kobj.kset = &acpi_namespace_kset;
+	kobject_register(&device->kobj);
+	create_sysfs_device_files(device);
+}
+
+static int
+acpi_device_unregister (
+	struct acpi_device	*device, 
+	int			type)
+{
+	spin_lock(&acpi_device_lock);
+	if (device->parent) {
+		list_del(&device->node);
+		list_del(&device->g_list);
+	} else
+		list_del(&device->g_list);
+
+	list_del(&device->wakeup_list);
+
+	spin_unlock(&acpi_device_lock);
+
+	acpi_detach_data(device->handle, acpi_bus_data_handler);
+	remove_sysfs_device_files(device);
+	kobject_unregister(&device->kobj);
+	return 0;
+}
+
+void
+acpi_bus_data_handler (
+	acpi_handle		handle,
+	u32			function,
+	void			*context)
+{
+	ACPI_FUNCTION_TRACE("acpi_bus_data_handler");
+
+	/* TBD */
+
+	return_VOID;
+}
+
+static int
+acpi_bus_get_power_flags (
+	struct acpi_device	*device)
+{
+	acpi_status             status = 0;
+	acpi_handle		handle = NULL;
+	u32                     i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_get_power_flags");
+
+	/*
+	 * Power Management Flags
+	 */
+	status = acpi_get_handle(device->handle, "_PSC", &handle);
+	if (ACPI_SUCCESS(status))
+		device->power.flags.explicit_get = 1;
+	status = acpi_get_handle(device->handle, "_IRC", &handle);
+	if (ACPI_SUCCESS(status))
+		device->power.flags.inrush_current = 1;
+
+	/*
+	 * Enumerate supported power management states
+	 */
+	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3; i++) {
+		struct acpi_device_power_state *ps = &device->power.states[i];
+		char		object_name[5] = {'_','P','R','0'+i,'\0'};
+
+		/* Evaluate "_PRx" to se if power resources are referenced */
+		acpi_evaluate_reference(device->handle, object_name, NULL,
+			&ps->resources);
+		if (ps->resources.count) {
+			device->power.flags.power_resources = 1;
+			ps->flags.valid = 1;
+		}
+
+		/* Evaluate "_PSx" to see if we can do explicit sets */
+		object_name[2] = 'S';
+		status = acpi_get_handle(device->handle, object_name, &handle);
+		if (ACPI_SUCCESS(status)) {
+			ps->flags.explicit_set = 1;
+			ps->flags.valid = 1;
+		}
+
+		/* State is valid if we have some power control */
+		if (ps->resources.count || ps->flags.explicit_set)
+			ps->flags.valid = 1;
+
+		ps->power = -1;		/* Unknown - driver assigned */
+		ps->latency = -1;	/* Unknown - driver assigned */
+	}
+
+	/* Set defaults for D0 and D3 states (always valid) */
+	device->power.states[ACPI_STATE_D0].flags.valid = 1;
+	device->power.states[ACPI_STATE_D0].power = 100;
+	device->power.states[ACPI_STATE_D3].flags.valid = 1;
+	device->power.states[ACPI_STATE_D3].power = 0;
+
+	/* TBD: System wake support and resource requirements. */
+
+	device->power.state = ACPI_STATE_UNKNOWN;
+
+	return_VALUE(0);
+}
+
+int
+acpi_match_ids (
+	struct acpi_device	*device,
+	char			*ids)
+{
+	int error = 0;
+	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+
+	if (device->flags.hardware_id)
+		if (strstr(ids, device->pnp.hardware_id))
+			goto Done;
+
+	if (device->flags.compatible_ids) {
+		struct acpi_compatible_id_list *cid_list = device->pnp.cid_list;
+		int i;
+
+		/* compare multiple _CID entries against driver ids */
+		for (i = 0; i < cid_list->count; i++)
+		{
+			if (strstr(ids, cid_list->id[i].value))
+				goto Done;
+		}
+	}
+	error = -ENOENT;
+
+ Done:
+	if (buffer.pointer)
+		acpi_os_free(buffer.pointer);
+	return error;
+}
+
+static acpi_status
+acpi_bus_extract_wakeup_device_power_package (
+	struct acpi_device	*device,
+	union acpi_object	*package)
+{
+	int 	 i = 0;
+	union acpi_object	*element = NULL;
+
+	if (!device || !package || (package->package.count < 2))
+		return AE_BAD_PARAMETER;
+
+	element = &(package->package.elements[0]);
+	if (!element)
+		return AE_BAD_PARAMETER;
+	if (element->type == ACPI_TYPE_PACKAGE) {
+		if ((element->package.count < 2) ||
+			(element->package.elements[0].type != ACPI_TYPE_LOCAL_REFERENCE) ||
+			(element->package.elements[1].type != ACPI_TYPE_INTEGER))
+			return AE_BAD_DATA;
+		device->wakeup.gpe_device = element->package.elements[0].reference.handle;
+		device->wakeup.gpe_number = (u32)element->package.elements[1].integer.value;
+	}else if (element->type == ACPI_TYPE_INTEGER) {
+		device->wakeup.gpe_number = element->integer.value;
+	}else
+		return AE_BAD_DATA;
+
+	element = &(package->package.elements[1]);
+	if (element->type != ACPI_TYPE_INTEGER) {
+		return AE_BAD_DATA;
+	}
+	device->wakeup.sleep_state = element->integer.value;
+
+	if ((package->package.count - 2) > ACPI_MAX_HANDLES) {
+		return AE_NO_MEMORY;
+	}
+	device->wakeup.resources.count = package->package.count - 2;
+	for (i=0; i < device->wakeup.resources.count; i++) {
+		element = &(package->package.elements[i + 2]);
+		if (element->type != ACPI_TYPE_ANY ) {
+			return AE_BAD_DATA;
+		}
+
+		device->wakeup.resources.handles[i] = element->reference.handle;
+	}
+
+	return AE_OK;
+}
+
+static int
+acpi_bus_get_wakeup_device_flags (
+	struct acpi_device	*device)
+{
+	acpi_status	status = 0;
+	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object	*package = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_get_wakeup_flags");
+
+	/* _PRW */
+	status = acpi_evaluate_object(device->handle, "_PRW", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRW\n"));
+		goto end;
+	}
+
+	package = (union acpi_object *) buffer.pointer;
+	status = acpi_bus_extract_wakeup_device_power_package(device, package);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _PRW package\n"));
+		goto end;
+	}
+
+	acpi_os_free(buffer.pointer);
+
+	device->wakeup.flags.valid = 1;
+	/* Power button, Lid switch always enable wakeup*/
+	if (!acpi_match_ids(device, "PNP0C0D,PNP0C0C,PNP0C0E"))
+		device->wakeup.flags.run_wake = 1;
+
+end:
+	if (ACPI_FAILURE(status))
+		device->flags.wake_capable = 0;
+	return_VALUE(0);
+}
+
+/* --------------------------------------------------------------------------
+		ACPI hotplug sysfs device file support
+   -------------------------------------------------------------------------- */
+static ssize_t acpi_eject_store(struct acpi_device *device, 
+		const char *buf, size_t count);
+
+#define ACPI_DEVICE_ATTR(_name,_mode,_show,_store) \
+static struct acpi_device_attribute acpi_device_attr_##_name = \
+		__ATTR(_name, _mode, _show, _store)
+
+ACPI_DEVICE_ATTR(eject, 0200, NULL, acpi_eject_store);
+
+/**
+ * setup_sys_fs_device_files - sets up the device files under device namespace
+ * @@dev:	acpi_device object
+ * @@func:	function pointer to create or destroy the device file
+ */
+static void
+setup_sys_fs_device_files (
+	struct acpi_device *dev,
+	acpi_device_sysfs_files *func)
+{
+	acpi_status		status;
+	acpi_handle		temp = NULL;
+
+	/*
+	 * If device has _EJ0, 'eject' file is created that is used to trigger
+	 * hot-removal function from userland.
+	 */
+	status = acpi_get_handle(dev->handle, "_EJ0", &temp);
+	if (ACPI_SUCCESS(status))
+		(*(func))(&dev->kobj,&acpi_device_attr_eject.attr);
+}
+
+static int
+acpi_eject_operation(acpi_handle handle, int lockable)
+{
+	struct acpi_object_list arg_list;
+	union acpi_object arg;
+	acpi_status status = AE_OK;
+
+	/*
+	 * TBD: evaluate _PS3?
+	 */
+
+	if (lockable) {
+		arg_list.count = 1;
+		arg_list.pointer = &arg;
+		arg.type = ACPI_TYPE_INTEGER;
+		arg.integer.value = 0;
+		acpi_evaluate_object(handle, "_LCK", &arg_list, NULL);
+	}
+
+	arg_list.count = 1;
+	arg_list.pointer = &arg;
+	arg.type = ACPI_TYPE_INTEGER;
+	arg.integer.value = 1;
+
+	/*
+	 * TBD: _EJD support.
+	 */
+
+	status = acpi_evaluate_object(handle, "_EJ0", &arg_list, NULL);
+	if (ACPI_FAILURE(status)) {
+		return(-ENODEV);
+	}
+
+	return(0);
+}
+
+
+static ssize_t
+acpi_eject_store(struct acpi_device *device, const char *buf, size_t count)
+{
+	int	result;
+	int	ret = count;
+	int	islockable;
+	acpi_status	status;
+	acpi_handle	handle;
+	acpi_object_type	type = 0;
+
+	if ((!count) || (buf[0] != '1')) {
+		return -EINVAL;
+	}
+
+#ifndef FORCE_EJECT
+	if (device->driver == NULL) {
+		ret = -ENODEV;
+		goto err;
+	}
+#endif
+	status = acpi_get_type(device->handle, &type);
+	if (ACPI_FAILURE(status) || (!device->flags.ejectable) ) {
+		ret = -ENODEV;
+		goto err;
+	}
+
+	islockable = device->flags.lockable;
+	handle = device->handle;
+
+	if (type == ACPI_TYPE_PROCESSOR)
+		result = acpi_bus_trim(device, 0);
+	else
+		result = acpi_bus_trim(device, 1);
+
+	if (!result)
+		result = acpi_eject_operation(handle, islockable);
+
+	if (result) {
+		ret = -EBUSY;
+	}
+err:
+	return ret;
+}
+
+
+/* --------------------------------------------------------------------------
+                              Performance Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_bus_get_perf_flags (
+	struct acpi_device	*device)
+{
+	device->performance.state = ACPI_STATE_UNKNOWN;
+	return 0;
+}
+
+/* --------------------------------------------------------------------------
+                                 Driver Management
+   -------------------------------------------------------------------------- */
+
+static LIST_HEAD(acpi_bus_drivers);
+static DECLARE_MUTEX(acpi_bus_drivers_lock);
+
+
+/**
+ * acpi_bus_match 
+ * --------------
+ * Checks the device's hardware (_HID) or compatible (_CID) ids to see if it
+ * matches the specified driver's criteria.
+ */
+static int
+acpi_bus_match (
+	struct acpi_device	*device,
+	struct acpi_driver	*driver)
+{
+	if (driver && driver->ops.match)
+		return driver->ops.match(device, driver);
+	return acpi_match_ids(device, driver->ids);
+}
+
+
+/**
+ * acpi_bus_driver_init 
+ * --------------------
+ * Used to initialize a device via its device driver.  Called whenever a 
+ * driver is bound to a device.  Invokes the driver's add() and start() ops.
+ */
+static int
+acpi_bus_driver_init (
+	struct acpi_device	*device, 
+	struct acpi_driver	*driver)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_driver_init");
+
+	if (!device || !driver)
+		return_VALUE(-EINVAL);
+
+	if (!driver->ops.add)
+		return_VALUE(-ENOSYS);
+
+	result = driver->ops.add(device);
+	if (result) {
+		device->driver = NULL;
+		acpi_driver_data(device) = NULL;
+		return_VALUE(result);
+	}
+
+	device->driver = driver;
+
+	/*
+	 * TBD - Configuration Management: Assign resources to device based
+	 * upon possible configuration and currently allocated resources.
+	 */
+
+	if (driver->ops.start) {
+		result = driver->ops.start(device);
+		if (result && driver->ops.remove)
+			driver->ops.remove(device, ACPI_BUS_REMOVAL_NORMAL);
+		return_VALUE(result);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Driver successfully bound to device\n"));
+
+	if (driver->ops.scan) {
+		driver->ops.scan(device);
+	}
+
+	return_VALUE(0);
+}
+
+static int acpi_driver_attach(struct acpi_driver * drv)
+{
+	struct list_head * node, * next;
+	int count = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_driver_attach");
+
+	spin_lock(&acpi_device_lock);
+	list_for_each_safe(node, next, &acpi_device_list) {
+		struct acpi_device * dev = container_of(node, struct acpi_device, g_list);
+
+		if (dev->driver || !dev->status.present)
+			continue;
+		spin_unlock(&acpi_device_lock);
+
+		if (!acpi_bus_match(dev, drv)) {
+			if (!acpi_bus_driver_init(dev, drv)) {
+				atomic_inc(&drv->references);
+				count++;
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found driver [%s] for device [%s]\n",
+						  drv->name, dev->pnp.bus_id));
+			}
+		}
+		spin_lock(&acpi_device_lock);
+	}
+	spin_unlock(&acpi_device_lock);
+	return_VALUE(count);
+}
+
+static int acpi_driver_detach(struct acpi_driver * drv)
+{
+	struct list_head * node, * next;
+
+	ACPI_FUNCTION_TRACE("acpi_driver_detach");
+
+	spin_lock(&acpi_device_lock);
+	list_for_each_safe(node,next,&acpi_device_list) {
+		struct acpi_device * dev = container_of(node,struct acpi_device,g_list);
+
+		if (dev->driver == drv) {
+			spin_unlock(&acpi_device_lock);
+			if (drv->ops.remove)
+				drv->ops.remove(dev,ACPI_BUS_REMOVAL_NORMAL);
+			spin_lock(&acpi_device_lock);
+			dev->driver = NULL;
+			dev->driver_data = NULL;
+			atomic_dec(&drv->references);
+		}
+	}
+	spin_unlock(&acpi_device_lock);
+	return_VALUE(0);
+}
+
+/**
+ * acpi_bus_register_driver 
+ * ------------------------ 
+ * Registers a driver with the ACPI bus.  Searches the namespace for all
+ * devices that match the driver's criteria and binds.  Returns the
+ * number of devices that were claimed by the driver, or a negative
+ * error status for failure.
+ */
+int
+acpi_bus_register_driver (
+	struct acpi_driver	*driver)
+{
+	int count;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_register_driver");
+
+	if (acpi_disabled)
+		return_VALUE(-ENODEV);
+
+	if (!driver)
+		return_VALUE(-EINVAL);
+
+	spin_lock(&acpi_device_lock);
+	list_add_tail(&driver->node, &acpi_bus_drivers);
+	spin_unlock(&acpi_device_lock);
+	count = acpi_driver_attach(driver);
+
+	return_VALUE(count);
+}
+EXPORT_SYMBOL(acpi_bus_register_driver);
+
+
+/**
+ * acpi_bus_unregister_driver 
+ * --------------------------
+ * Unregisters a driver with the ACPI bus.  Searches the namespace for all
+ * devices that match the driver's criteria and unbinds.
+ */
+int
+acpi_bus_unregister_driver (
+	struct acpi_driver	*driver)
+{
+	int error = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_unregister_driver");
+
+	if (driver) {
+		acpi_driver_detach(driver);
+
+		if (!atomic_read(&driver->references)) {
+			spin_lock(&acpi_device_lock);
+			list_del_init(&driver->node);
+			spin_unlock(&acpi_device_lock);
+		} 
+	} else 
+		error = -EINVAL;
+	return_VALUE(error);
+}
+EXPORT_SYMBOL(acpi_bus_unregister_driver);
+
+/**
+ * acpi_bus_find_driver 
+ * --------------------
+ * Parses the list of registered drivers looking for a driver applicable for
+ * the specified device.
+ */
+static int
+acpi_bus_find_driver (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	struct list_head	* node, *next;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_find_driver");
+
+	spin_lock(&acpi_device_lock);
+	list_for_each_safe(node,next,&acpi_bus_drivers) {
+		struct acpi_driver * driver = container_of(node,struct acpi_driver,node);
+
+		atomic_inc(&driver->references);
+		spin_unlock(&acpi_device_lock);
+		if (!acpi_bus_match(device, driver)) {
+			result = acpi_bus_driver_init(device, driver);
+			if (!result)
+				goto Done;
+		}
+		atomic_dec(&driver->references);
+		spin_lock(&acpi_device_lock);
+	}
+	spin_unlock(&acpi_device_lock);
+
+ Done:
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Device Enumeration
+   -------------------------------------------------------------------------- */
+
+static int 
+acpi_bus_get_flags (
+	struct acpi_device	*device)
+{
+	acpi_status		status = AE_OK;
+	acpi_handle		temp = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_get_flags");
+
+	/* Presence of _STA indicates 'dynamic_status' */
+	status = acpi_get_handle(device->handle, "_STA", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.dynamic_status = 1;
+
+	/* Presence of _CID indicates 'compatible_ids' */
+	status = acpi_get_handle(device->handle, "_CID", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.compatible_ids = 1;
+
+	/* Presence of _RMV indicates 'removable' */
+	status = acpi_get_handle(device->handle, "_RMV", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.removable = 1;
+
+	/* Presence of _EJD|_EJ0 indicates 'ejectable' */
+	status = acpi_get_handle(device->handle, "_EJD", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.ejectable = 1;
+	else {
+		status = acpi_get_handle(device->handle, "_EJ0", &temp);
+		if (ACPI_SUCCESS(status))
+			device->flags.ejectable = 1;
+	}
+
+	/* Presence of _LCK indicates 'lockable' */
+	status = acpi_get_handle(device->handle, "_LCK", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.lockable = 1;
+
+	/* Presence of _PS0|_PR0 indicates 'power manageable' */
+	status = acpi_get_handle(device->handle, "_PS0", &temp);
+	if (ACPI_FAILURE(status))
+		status = acpi_get_handle(device->handle, "_PR0", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.power_manageable = 1;
+
+	/* Presence of _PRW indicates wake capable */
+	status = acpi_get_handle(device->handle, "_PRW", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.wake_capable = 1;
+
+	/* TBD: Peformance management */
+
+	return_VALUE(0);
+}
+
+static void acpi_device_get_busid(struct acpi_device * device, acpi_handle handle, int type)
+{
+	char			bus_id[5] = {'?',0};
+	struct acpi_buffer	buffer = {sizeof(bus_id), bus_id};
+	int			i = 0;
+
+	/*
+	 * Bus ID
+	 * ------
+	 * The device's Bus ID is simply the object name.
+	 * TBD: Shouldn't this value be unique (within the ACPI namespace)?
+	 */
+	switch (type) {
+	case ACPI_BUS_TYPE_SYSTEM:
+		strcpy(device->pnp.bus_id, "ACPI");
+		break;
+	case ACPI_BUS_TYPE_POWER_BUTTON:
+		strcpy(device->pnp.bus_id, "PWRF");
+		break;
+	case ACPI_BUS_TYPE_SLEEP_BUTTON:
+		strcpy(device->pnp.bus_id, "SLPF");
+		break;
+	default:
+		acpi_get_name(handle, ACPI_SINGLE_NAME, &buffer);
+		/* Clean up trailing underscores (if any) */
+		for (i = 3; i > 1; i--) {
+			if (bus_id[i] == '_')
+				bus_id[i] = '\0';
+			else
+				break;
+		}
+		strcpy(device->pnp.bus_id, bus_id);
+		break;
+	}
+}
+
+static void acpi_device_set_id(struct acpi_device * device, struct acpi_device * parent,
+			       acpi_handle handle, int type)
+{
+	struct acpi_device_info	*info;
+	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	char			*hid = NULL;
+	char			*uid = NULL;
+	struct acpi_compatible_id_list *cid_list = NULL;
+	acpi_status		status;
+
+	switch (type) {
+	case ACPI_BUS_TYPE_DEVICE:
+		status = acpi_get_object_info(handle, &buffer);
+		if (ACPI_FAILURE(status)) {
+			printk("%s: Error reading device info\n",__FUNCTION__);
+			return;
+		}
+
+		info = buffer.pointer;
+		if (info->valid & ACPI_VALID_HID)
+			hid = info->hardware_id.value;
+		if (info->valid & ACPI_VALID_UID)
+			uid = info->unique_id.value;
+		if (info->valid & ACPI_VALID_CID)
+			cid_list = &info->compatibility_id;
+		if (info->valid & ACPI_VALID_ADR) {
+			device->pnp.bus_address = info->address;
+			device->flags.bus_address = 1;
+		}
+		break;
+	case ACPI_BUS_TYPE_POWER:
+		hid = ACPI_POWER_HID;
+		break;
+	case ACPI_BUS_TYPE_PROCESSOR:
+		hid = ACPI_PROCESSOR_HID;
+		break;
+	case ACPI_BUS_TYPE_SYSTEM:
+		hid = ACPI_SYSTEM_HID;
+		break;
+	case ACPI_BUS_TYPE_THERMAL:
+		hid = ACPI_THERMAL_HID;
+		break;
+	case ACPI_BUS_TYPE_POWER_BUTTON:
+		hid = ACPI_BUTTON_HID_POWERF;
+		break;
+	case ACPI_BUS_TYPE_SLEEP_BUTTON:
+		hid = ACPI_BUTTON_HID_SLEEPF;
+		break;
+	}
+
+	/* 
+	 * \_SB
+	 * ----
+	 * Fix for the system root bus device -- the only root-level device.
+	 */
+	if ((parent == ACPI_ROOT_OBJECT) && (type == ACPI_BUS_TYPE_DEVICE)) {
+		hid = ACPI_BUS_HID;
+		strcpy(device->pnp.device_name, ACPI_BUS_DEVICE_NAME);
+		strcpy(device->pnp.device_class, ACPI_BUS_CLASS);
+	}
+
+	if (hid) {
+		strcpy(device->pnp.hardware_id, hid);
+		device->flags.hardware_id = 1;
+	}
+	if (uid) {
+		strcpy(device->pnp.unique_id, uid);
+		device->flags.unique_id = 1;
+	}
+	if (cid_list) {
+		device->pnp.cid_list = kmalloc(cid_list->size, GFP_KERNEL);
+		if (device->pnp.cid_list)
+			memcpy(device->pnp.cid_list, cid_list, cid_list->size);
+		else
+			printk(KERN_ERR "Memory allocation error\n");
+	}
+
+	acpi_os_free(buffer.pointer);
+}
+
+static int acpi_device_set_context(struct acpi_device * device, int type)
+{
+	acpi_status status = AE_OK;
+	int result = 0;
+	/*
+	 * Context
+	 * -------
+	 * Attach this 'struct acpi_device' to the ACPI object.  This makes
+	 * resolutions from handle->device very efficient.  Note that we need
+	 * to be careful with fixed-feature devices as they all attach to the
+	 * root object.
+	 */
+	if (type != ACPI_BUS_TYPE_POWER_BUTTON && 
+	    type != ACPI_BUS_TYPE_SLEEP_BUTTON) {
+		status = acpi_attach_data(device->handle,
+			acpi_bus_data_handler, device);
+
+		if (ACPI_FAILURE(status)) {
+			printk("Error attaching device data\n");
+			result = -ENODEV;
+		}
+	}
+	return result;
+}
+
+static void acpi_device_get_debug_info(struct acpi_device * device, acpi_handle handle, int type)
+{
+#ifdef CONFIG_ACPI_DEBUG_OUTPUT
+	char		*type_string = NULL;
+	char		name[80] = {'?','\0'};
+	struct acpi_buffer	buffer = {sizeof(name), name};
+
+	switch (type) {
+	case ACPI_BUS_TYPE_DEVICE:
+		type_string = "Device";
+		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+		break;
+	case ACPI_BUS_TYPE_POWER:
+		type_string = "Power Resource";
+		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+		break;
+	case ACPI_BUS_TYPE_PROCESSOR:
+		type_string = "Processor";
+		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+		break;
+	case ACPI_BUS_TYPE_SYSTEM:
+		type_string = "System";
+		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+		break;
+	case ACPI_BUS_TYPE_THERMAL:
+		type_string = "Thermal Zone";
+		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+		break;
+	case ACPI_BUS_TYPE_POWER_BUTTON:
+		type_string = "Power Button";
+		sprintf(name, "PWRB");
+		break;
+	case ACPI_BUS_TYPE_SLEEP_BUTTON:
+		type_string = "Sleep Button";
+		sprintf(name, "SLPB");
+		break;
+	}
+
+	printk(KERN_DEBUG "Found %s %s [%p]\n", type_string, name, handle);
+#endif /*CONFIG_ACPI_DEBUG_OUTPUT*/
+}
+
+
+static int
+acpi_bus_remove (
+	struct acpi_device *dev,
+	int rmdevice)
+{
+	int 			result = 0;
+	struct acpi_driver	*driver;
+	
+	ACPI_FUNCTION_TRACE("acpi_bus_remove");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+
+	driver = dev->driver;
+
+	if ((driver) && (driver->ops.remove)) {
+
+		if (driver->ops.stop) {
+			result = driver->ops.stop(dev, ACPI_BUS_REMOVAL_EJECT);
+			if (result)
+				return_VALUE(result);
+		}
+
+		result = dev->driver->ops.remove(dev, ACPI_BUS_REMOVAL_EJECT);
+		if (result) {
+			return_VALUE(result);
+		}
+
+		atomic_dec(&dev->driver->references);
+		dev->driver = NULL;
+		acpi_driver_data(dev) = NULL;
+	}
+
+	if (!rmdevice)
+		return_VALUE(0);
+
+	if (dev->flags.bus_address) {
+		if ((dev->parent) && (dev->parent->ops.unbind))
+			dev->parent->ops.unbind(dev);
+	}
+	
+	acpi_device_unregister(dev, ACPI_BUS_REMOVAL_EJECT);
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_bus_add (
+	struct acpi_device	**child,
+	struct acpi_device	*parent,
+	acpi_handle		handle,
+	int			type)
+{
+	int			result = 0;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_add");
+
+	if (!child)
+		return_VALUE(-EINVAL);
+
+	device = kmalloc(sizeof(struct acpi_device), GFP_KERNEL);
+	if (!device) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Memory allocation error\n"));
+		return_VALUE(-ENOMEM);
+	}
+	memset(device, 0, sizeof(struct acpi_device));
+
+	device->handle = handle;
+	device->parent = parent;
+
+	acpi_device_get_busid(device,handle,type);
+
+	/*
+	 * Flags
+	 * -----
+	 * Get prior to calling acpi_bus_get_status() so we know whether
+	 * or not _STA is present.  Note that we only look for object
+	 * handles -- cannot evaluate objects until we know the device is
+	 * present and properly initialized.
+	 */
+	result = acpi_bus_get_flags(device);
+	if (result)
+		goto end;
+
+	/*
+	 * Status
+	 * ------
+	 * See if the device is present.  We always assume that non-Device()
+	 * objects (e.g. thermal zones, power resources, processors, etc.) are
+	 * present, functioning, etc. (at least when parent object is present).
+	 * Note that _STA has a different meaning for some objects (e.g.
+	 * power resources) so we need to be careful how we use it.
+	 */
+	switch (type) {
+	case ACPI_BUS_TYPE_DEVICE:
+		result = acpi_bus_get_status(device);
+		if (ACPI_FAILURE(result) || !device->status.present) {
+			result = -ENOENT;
+			goto end;
+		}
+		break;
+	default:
+		STRUCT_TO_INT(device->status) = 0x0F;
+		break;
+	}
+
+	/*
+	 * Initialize Device
+	 * -----------------
+	 * TBD: Synch with Core's enumeration/initialization process.
+	 */
+
+	/*
+	 * Hardware ID, Unique ID, & Bus Address
+	 * -------------------------------------
+	 */
+	acpi_device_set_id(device,parent,handle,type);
+
+	/*
+	 * Power Management
+	 * ----------------
+	 */
+	if (device->flags.power_manageable) {
+		result = acpi_bus_get_power_flags(device);
+		if (result)
+			goto end;
+	}
+
+ 	/*
+	 * Wakeup device management
+	 *-----------------------
+	 */
+	if (device->flags.wake_capable) {
+		result = acpi_bus_get_wakeup_device_flags(device);
+		if (result)
+			goto end;
+	}
+
+	/*
+	 * Performance Management
+	 * ----------------------
+	 */
+	if (device->flags.performance_manageable) {
+		result = acpi_bus_get_perf_flags(device);
+		if (result)
+			goto end;
+	}
+
+	if ((result = acpi_device_set_context(device,type)))
+		goto end;
+
+	acpi_device_get_debug_info(device,handle,type);
+
+	acpi_device_register(device,parent);
+
+	/*
+	 * Bind _ADR-Based Devices
+	 * -----------------------
+	 * If there's a a bus address (_ADR) then we utilize the parent's 
+	 * 'bind' function (if exists) to bind the ACPI- and natively-
+	 * enumerated device representations.
+	 */
+	if (device->flags.bus_address) {
+		if (device->parent && device->parent->ops.bind)
+			device->parent->ops.bind(device);
+	}
+
+	/*
+	 * Locate & Attach Driver
+	 * ----------------------
+	 * If there's a hardware id (_HID) or compatible ids (_CID) we check
+	 * to see if there's a driver installed for this kind of device.  Note
+	 * that drivers can install before or after a device is enumerated.
+	 *
+	 * TBD: Assumes LDM provides driver hot-plug capability.
+	 */
+	acpi_bus_find_driver(device);
+
+end:
+	if (!result)
+		*child = device;
+	else {
+		if (device->pnp.cid_list)
+			kfree(device->pnp.cid_list);
+		kfree(device);
+	}
+
+	return_VALUE(result);
+}
+EXPORT_SYMBOL(acpi_bus_add);
+
+
+int acpi_bus_scan (struct acpi_device	*start)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_device	*parent = NULL;
+	struct acpi_device	*child = NULL;
+	acpi_handle		phandle = NULL;
+	acpi_handle		chandle = NULL;
+	acpi_object_type	type = 0;
+	u32			level = 1;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_scan");
+
+	if (!start)
+		return_VALUE(-EINVAL);
+
+	parent = start;
+	phandle = start->handle;
+	
+	/*
+	 * Parse through the ACPI namespace, identify all 'devices', and
+	 * create a new 'struct acpi_device' for each.
+	 */
+	while ((level > 0) && parent) {
+
+		status = acpi_get_next_object(ACPI_TYPE_ANY, phandle,
+			chandle, &chandle);
+
+		/*
+		 * If this scope is exhausted then move our way back up.
+		 */
+		if (ACPI_FAILURE(status)) {
+			level--;
+			chandle = phandle;
+			acpi_get_parent(phandle, &phandle);
+			if (parent->parent)
+				parent = parent->parent;
+			continue;
+		}
+
+		status = acpi_get_type(chandle, &type);
+		if (ACPI_FAILURE(status))
+			continue;
+
+		/*
+		 * If this is a scope object then parse it (depth-first).
+		 */
+		if (type == ACPI_TYPE_LOCAL_SCOPE) {
+			level++;
+			phandle = chandle;
+			chandle = NULL;
+			continue;
+		}
+
+		/*
+		 * We're only interested in objects that we consider 'devices'.
+		 */
+		switch (type) {
+		case ACPI_TYPE_DEVICE:
+			type = ACPI_BUS_TYPE_DEVICE;
+			break;
+		case ACPI_TYPE_PROCESSOR:
+			type = ACPI_BUS_TYPE_PROCESSOR;
+			break;
+		case ACPI_TYPE_THERMAL:
+			type = ACPI_BUS_TYPE_THERMAL;
+			break;
+		case ACPI_TYPE_POWER:
+			type = ACPI_BUS_TYPE_POWER;
+			break;
+		default:
+			continue;
+		}
+
+		status = acpi_bus_add(&child, parent, chandle, type);
+		if (ACPI_FAILURE(status))
+			continue;
+
+		/*
+		 * If the device is present, enabled, and functioning then
+		 * parse its scope (depth-first).  Note that we need to
+		 * represent absent devices to facilitate PnP notifications
+		 * -- but only the subtree head (not all of its children,
+		 * which will be enumerated when the parent is inserted).
+		 *
+		 * TBD: Need notifications and other detection mechanisms
+		 *	in place before we can fully implement this.
+		 */
+		if (child->status.present) {
+			status = acpi_get_next_object(ACPI_TYPE_ANY, chandle,
+						      NULL, NULL);
+			if (ACPI_SUCCESS(status)) {
+				level++;
+				phandle = chandle;
+				chandle = NULL;
+				parent = child;
+			}
+		}
+	}
+
+	return_VALUE(0);
+}
+EXPORT_SYMBOL(acpi_bus_scan);
+
+
+static int
+acpi_bus_trim(struct acpi_device	*start,
+		int rmdevice)
+{
+	acpi_status		status;
+	struct acpi_device	*parent, *child;
+	acpi_handle		phandle, chandle;
+	acpi_object_type	type;
+	u32			level = 1;
+	int			err = 0;
+
+	parent  = start;
+	phandle = start->handle;
+	child = chandle = NULL;
+
+	while ((level > 0) && parent && (!err)) {
+		status = acpi_get_next_object(ACPI_TYPE_ANY, phandle,
+			chandle, &chandle);
+
+		/*
+		 * If this scope is exhausted then move our way back up.
+		 */
+		if (ACPI_FAILURE(status)) {
+			level--;
+			chandle = phandle;
+			acpi_get_parent(phandle, &phandle);
+			child = parent;
+			parent = parent->parent;
+
+			if (level == 0)
+				err = acpi_bus_remove(child, rmdevice);
+			else
+				err = acpi_bus_remove(child, 1);
+
+			continue;
+		}
+
+		status = acpi_get_type(chandle, &type);
+		if (ACPI_FAILURE(status)) {
+			continue;
+		}
+		/*
+		 * If there is a device corresponding to chandle then
+		 * parse it (depth-first).
+		 */
+		if (acpi_bus_get_device(chandle, &child) == 0) {
+			level++;
+			phandle = chandle;
+			chandle = NULL;
+			parent = child;
+		}
+		continue;
+	}
+	return err;
+}
+
+static int
+acpi_bus_scan_fixed (
+	struct acpi_device	*root)
+{
+	int			result = 0;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_scan_fixed");
+
+	if (!root)
+		return_VALUE(-ENODEV);
+
+	/*
+	 * Enumerate all fixed-feature devices.
+	 */
+	if (acpi_fadt.pwr_button == 0)
+		result = acpi_bus_add(&device, acpi_root, 
+			NULL, ACPI_BUS_TYPE_POWER_BUTTON);
+
+	if (acpi_fadt.sleep_button == 0)
+		result = acpi_bus_add(&device, acpi_root, 
+			NULL, ACPI_BUS_TYPE_SLEEP_BUTTON);
+
+	return_VALUE(result);
+}
+
+
+static int __init acpi_scan_init(void)
+{
+	int result;
+
+	ACPI_FUNCTION_TRACE("acpi_scan_init");
+
+	if (acpi_disabled)
+		return_VALUE(0);
+
+	kset_register(&acpi_namespace_kset);
+
+	/*
+	 * Create the root device in the bus's device tree
+	 */
+	result = acpi_bus_add(&acpi_root, NULL, ACPI_ROOT_OBJECT, 
+		ACPI_BUS_TYPE_SYSTEM);
+	if (result)
+		goto Done;
+
+	/*
+	 * Enumerate devices in the ACPI namespace.
+	 */
+	result = acpi_bus_scan_fixed(acpi_root);
+	if (!result) 
+		result = acpi_bus_scan(acpi_root);
+
+	if (result)
+		acpi_device_unregister(acpi_root, ACPI_BUS_REMOVAL_NORMAL);
+
+ Done:
+	return_VALUE(result);
+}
+
+subsys_initcall(acpi_scan_init);
