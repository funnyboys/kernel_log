commit c7d5f21e8d184f255785e02760139037a97fd796
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Apr 22 11:39:34 2019 -0500

    ACPI: event: replace strcpy() by strscpy()
    
    The strcpy() function is being deprecated. Replace it by the safer
    strscpy() and fix the following Coverity warnings:
    
    "You might overrun the 15-character fixed-size string event->bus_id
    by copying bus_id without checking the length."
    
    "You might overrun the 20-character fixed-size string event->device_class
    by copying device_class without checking the length."
    
    Addresses-Coverity-ID: 139001 ("Copy into fixed size buffer")
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 5a127f3f2d5c..47f21599f2ab 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -131,8 +131,8 @@ int acpi_bus_generate_netlink_event(const char *device_class,
 	event = nla_data(attr);
 	memset(event, 0, sizeof(struct acpi_genl_event));
 
-	strcpy(event->device_class, device_class);
-	strcpy(event->bus_id, bus_id);
+	strscpy(event->device_class, device_class, sizeof(event->device_class));
+	strscpy(event->bus_id, bus_id, sizeof(event->bus_id));
 	event->type = type;
 	event->data = data;
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 7fceb3b4691b..5a127f3f2d5c 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * event.c - exporting ACPI events via procfs
  *

commit 56989f6d8568c21257dcec0f5e644d5570ba3281
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Oct 24 14:40:05 2016 +0200

    genetlink: mark families as __ro_after_init
    
    Now genl_register_family() is the only thing (other than the
    users themselves, perhaps, but I didn't find any doing that)
    writing to the family struct.
    
    In all families that I found, genl_register_family() is only
    called from __init functions (some indirectly, in which case
    I've add __init annotations to clarifly things), so all can
    actually be marked __ro_after_init.
    
    This protects the data structure from accidental corruption.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 1ab12ad7d5ba..7fceb3b4691b 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -82,7 +82,7 @@ static const struct genl_multicast_group acpi_event_mcgrps[] = {
 	{ .name = ACPI_GENL_MCAST_GROUP_NAME, },
 };
 
-static struct genl_family acpi_event_genl_family = {
+static struct genl_family acpi_event_genl_family __ro_after_init = {
 	.module = THIS_MODULE,
 	.name = ACPI_GENL_FAMILY_NAME,
 	.version = ACPI_GENL_VERSION,
@@ -144,7 +144,7 @@ int acpi_bus_generate_netlink_event(const char *device_class,
 
 EXPORT_SYMBOL(acpi_bus_generate_netlink_event);
 
-static int acpi_event_genetlink_init(void)
+static int __init acpi_event_genetlink_init(void)
 {
 	return genl_register_family(&acpi_event_genl_family);
 }

commit 489111e5c25b93be80340c3113d71903d7c82136
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Oct 24 14:40:03 2016 +0200

    genetlink: statically initialize families
    
    Instead of providing macros/inline functions to initialize
    the families, make all users initialize them statically and
    get rid of the macros.
    
    This reduces the kernel code size by about 1.6k on x86-64
    (with allyesconfig).
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 8dfca3d53131..1ab12ad7d5ba 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -83,6 +83,7 @@ static const struct genl_multicast_group acpi_event_mcgrps[] = {
 };
 
 static struct genl_family acpi_event_genl_family = {
+	.module = THIS_MODULE,
 	.name = ACPI_GENL_FAMILY_NAME,
 	.version = ACPI_GENL_VERSION,
 	.maxattr = ACPI_GENL_ATTR_MAX,

commit a07ea4d9941af5a0c6f0be2a71b51ac9c083c5e5
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Oct 24 14:40:02 2016 +0200

    genetlink: no longer support using static family IDs
    
    Static family IDs have never really been used, the only
    use case was the workaround I introduced for those users
    that assumed their family ID was also their multicast
    group ID.
    
    Additionally, because static family IDs would never be
    reserved by the generic netlink code, using a relatively
    low ID would only work for built-in families that can be
    registered immediately after generic netlink is started,
    which is basically only the control family (apart from
    the workaround code, which I also had to add code for so
    it would reserve those IDs)
    
    Thus, anything other than GENL_ID_GENERATE is flawed and
    luckily not used except in the cases I mentioned. Move
    those workarounds into a few lines of code, and then get
    rid of GENL_ID_GENERATE entirely, making it more robust.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index e24ea4e796e4..8dfca3d53131 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -83,7 +83,6 @@ static const struct genl_multicast_group acpi_event_mcgrps[] = {
 };
 
 static struct genl_family acpi_event_genl_family = {
-	.id = GENL_ID_GENERATE,
 	.name = ACPI_GENL_FAMILY_NAME,
 	.version = ACPI_GENL_VERSION,
 	.maxattr = ACPI_GENL_ATTR_MAX,

commit 053c095a82cf773075e83d7233b5cc19a1f73ece
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jan 16 22:09:00 2015 +0100

    netlink: make nlmsg_end() and genlmsg_end() void
    
    Contrary to common expectations for an "int" return, these functions
    return only a positive value -- if used correctly they cannot even
    return 0 because the message header will necessarily be in the skb.
    
    This makes the very common pattern of
    
      if (genlmsg_end(...) < 0) { ... }
    
    be a whole bunch of dead code. Many places also simply do
    
      return nlmsg_end(...);
    
    and the caller is expected to deal with it.
    
    This also commonly (at least for me) causes errors, because it is very
    common to write
    
      if (my_function(...))
        /* error condition */
    
    and if my_function() does "return nlmsg_end()" this is of course wrong.
    
    Additionally, there's not a single place in the kernel that actually
    needs the message length returned, and if anyone needs it later then
    it'll be very easy to just use skb->len there.
    
    Remove this, and make the functions void. This removes a bunch of dead
    code as described above. The patch adds lines because I did
    
    -       return nlmsg_end(...);
    +       nlmsg_end(...);
    +       return 0;
    
    I could have preserved all the function's return values by returning
    skb->len, but instead I've audited all the places calling the affected
    functions and found that none cared. A few places actually compared
    the return value with <= 0 in dump functionality, but that could just
    be changed to < 0 with no change in behaviour, so I opted for the more
    efficient version.
    
    One instance of the error I've made numerous times now is also present
    in net/phonet/pn_netlink.c in the route_dumpit() function - it didn't
    check for <0 or <=0 and thus broke out of the loop every single time.
    I've preserved this since it will (I think) have caused the messages to
    userspace to be formatted differently with just a single message for
    every SKB returned to userspace. It's possible that this isn't needed
    for the tools that actually use this, but I don't even know what they
    are so couldn't test that changing this behaviour would be acceptable.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index ef2d730734dc..e24ea4e796e4 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -100,7 +100,6 @@ int acpi_bus_generate_netlink_event(const char *device_class,
 	struct acpi_genl_event *event;
 	void *msg_header;
 	int size;
-	int result;
 
 	/* allocate memory */
 	size = nla_total_size(sizeof(struct acpi_genl_event)) +
@@ -137,11 +136,7 @@ int acpi_bus_generate_netlink_event(const char *device_class,
 	event->data = data;
 
 	/* send multicast genetlink message */
-	result = genlmsg_end(skb, msg_header);
-	if (result < 0) {
-		nlmsg_free(skb);
-		return result;
-	}
+	genlmsg_end(skb, msg_header);
 
 	genlmsg_multicast(&acpi_event_genl_family, skb, 0, 0, GFP_ATOMIC);
 	return 0;

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index cae3b387b867..ef2d730734dc 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -12,7 +12,7 @@
 #include <linux/init.h>
 #include <linux/poll.h>
 #include <linux/gfp.h>
-#include <acpi/acpi_drivers.h>
+#include <linux/acpi.h>
 #include <net/netlink.h>
 #include <net/genetlink.h>
 

commit 1ee2dcc2245340cf4ac94b99c4d00efbeba61824
Merge: 4457e6f6c9f6 091e0662ee2c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 19 15:50:47 2013 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Pull networking fixes from David Miller:
     "Mostly these are fixes for fallout due to merge window changes, as
      well as cures for problems that have been with us for a much longer
      period of time"
    
     1) Johannes Berg noticed two major deficiencies in our genetlink
        registration.  Some genetlink protocols we passing in constant
        counts for their ops array rather than something like
        ARRAY_SIZE(ops) or similar.  Also, some genetlink protocols were
        using fixed IDs for their multicast groups.
    
        We have to retain these fixed IDs to keep existing userland tools
        working, but reserve them so that other multicast groups used by
        other protocols can not possibly conflict.
    
        In dealing with these two problems, we actually now use less state
        management for genetlink operations and multicast groups.
    
     2) When configuring interface hardware timestamping, fix several
        drivers that simply do not validate that the hwtstamp_config value
        is one the driver actually supports.  From Ben Hutchings.
    
     3) Invalid memory references in mwifiex driver, from Amitkumar Karwar.
    
     4) In dev_forward_skb(), set the skb->protocol in the right order
        relative to skb_scrub_packet().  From Alexei Starovoitov.
    
     5) Bridge erroneously fails to use the proper wrapper functions to make
        calls to netdev_ops->ndo_vlan_rx_{add,kill}_vid.  Fix from Toshiaki
        Makita.
    
     6) When detaching a bridge port, make sure to flush all VLAN IDs to
        prevent them from leaking, also from Toshiaki Makita.
    
     7) Put in a compromise for TCP Small Queues so that deep queued devices
        that delay TX reclaim non-trivially don't have such a performance
        decrease.  One particularly problematic area is 802.11 AMPDU in
        wireless.  From Eric Dumazet.
    
     8) Fix crashes in tcp_fastopen_cache_get(), we can see NULL socket dsts
        here.  Fix from Eric Dumzaet, reported by Dave Jones.
    
     9) Fix use after free in ipv6 SIT driver, from Willem de Bruijn.
    
    10) When computing mergeable buffer sizes, virtio-net fails to take the
        virtio-net header into account.  From Michael Dalton.
    
    11) Fix seqlock deadlock in ip4_datagram_connect() wrt.  statistic
        bumping, this one has been with us for a while.  From Eric Dumazet.
    
    12) Fix NULL deref in the new TIPC fragmentation handling, from Erik
        Hugne.
    
    13) 6lowpan bit used for traffic classification was wrong, from Jukka
        Rissanen.
    
    14) macvlan has the same issue as normal vlans did wrt.  propagating LRO
        disabling down to the real device, fix it the same way.  From Michal
        Kubecek.
    
    15) CPSW driver needs to soft reset all slaves during suspend, from
        Daniel Mack.
    
    16) Fix small frame pacing in FQ packet scheduler, from Eric Dumazet.
    
    17) The xen-netfront RX buffer refill timer isn't properly scheduled on
        partial RX allocation success, from Ma JieYue.
    
    18) When ipv6 ping protocol support was added, the AF_INET6 protocol
        initialization cleanup path on failure was borked a little.  Fix
        from Vlad Yasevich.
    
    19) If a socket disconnects during a read/recvmsg/recvfrom/etc that
        blocks we can do the wrong thing with the msg_name we write back to
        userspace.  From Hannes Frederic Sowa.  There is another fix in the
        works from Hannes which will prevent future problems of this nature.
    
    20) Fix route leak in VTI tunnel transmit, from Fan Du.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net: (106 commits)
      genetlink: make multicast groups const, prevent abuse
      genetlink: pass family to functions using groups
      genetlink: add and use genl_set_err()
      genetlink: remove family pointer from genl_multicast_group
      genetlink: remove genl_unregister_mc_group()
      hsr: don't call genl_unregister_mc_group()
      quota/genetlink: use proper genetlink multicast APIs
      drop_monitor/genetlink: use proper genetlink multicast APIs
      genetlink: only pass array to genl_register_family_with_ops()
      tcp: don't update snd_nxt, when a socket is switched from repair mode
      atm: idt77252: fix dev refcnt leak
      xfrm: Release dst if this dst is improper for vti tunnel
      netlink: fix documentation typo in netlink_set_err()
      be2net: Delete secondary unicast MAC addresses during be_close
      be2net: Fix unconditional enabling of Rx interface options
      net, virtio_net: replace the magic value
      ping: prevent NULL pointer dereference on write to msg_name
      bnx2x: Prevent "timeout waiting for state X"
      bnx2x: prevent CFC attention
      bnx2x: Prevent panic during DMAE timeout
      ...

commit 2a94fe48f32ccf7321450a2cc07f2b724a444e5b
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Nov 19 15:19:39 2013 +0100

    genetlink: make multicast groups const, prevent abuse
    
    Register generic netlink multicast groups as an array with
    the family and give them contiguous group IDs. Then instead
    of passing the global group ID to the various functions that
    send messages, pass the ID relative to the family - for most
    families that's just 0 because the only have one group.
    
    This avoids the list_head and ID in each group, adding a new
    field for the mcast group ID offset to the family.
    
    At the same time, this allows us to prevent abusing groups
    again like the quota and dropmon code did, since we can now
    check that a family only uses a group it owns.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 68a8755202ec..aeb5aa6ce068 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -78,15 +78,17 @@ enum {
 #define ACPI_GENL_VERSION		0x01
 #define ACPI_GENL_MCAST_GROUP_NAME 	"acpi_mc_group"
 
+static const struct genl_multicast_group acpi_event_mcgrps[] = {
+	{ .name = ACPI_GENL_MCAST_GROUP_NAME, },
+};
+
 static struct genl_family acpi_event_genl_family = {
 	.id = GENL_ID_GENERATE,
 	.name = ACPI_GENL_FAMILY_NAME,
 	.version = ACPI_GENL_VERSION,
 	.maxattr = ACPI_GENL_ATTR_MAX,
-};
-
-static struct genl_multicast_group acpi_event_mcgrp = {
-	.name = ACPI_GENL_MCAST_GROUP_NAME,
+	.mcgrps = acpi_event_mcgrps,
+	.n_mcgrps = ARRAY_SIZE(acpi_event_mcgrps),
 };
 
 int acpi_bus_generate_netlink_event(const char *device_class,
@@ -146,8 +148,7 @@ int acpi_bus_generate_netlink_event(const char *device_class,
 		return result;
 	}
 
-	genlmsg_multicast(&acpi_event_genl_family,
-			  skb, 0, acpi_event_mcgrp.id, GFP_ATOMIC);
+	genlmsg_multicast(&acpi_event_genl_family, skb, 0, 0, GFP_ATOMIC);
 	return 0;
 }
 
@@ -155,18 +156,7 @@ EXPORT_SYMBOL(acpi_bus_generate_netlink_event);
 
 static int acpi_event_genetlink_init(void)
 {
-	int result;
-
-	result = genl_register_family(&acpi_event_genl_family);
-	if (result)
-		return result;
-
-	result = genl_register_mc_group(&acpi_event_genl_family,
-					&acpi_event_mcgrp);
-	if (result)
-		genl_unregister_family(&acpi_event_genl_family);
-
-	return result;
+	return genl_register_family(&acpi_event_genl_family);
 }
 
 #else

commit 68eb55031da7c967d954e5f9415cd05f4abdb692
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Nov 19 15:19:38 2013 +0100

    genetlink: pass family to functions using groups
    
    This doesn't really change anything, but prepares for the
    next patch that will change the APIs to pass the group ID
    within the family, rather than the global group ID.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 8247fcdde079..68a8755202ec 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -146,7 +146,8 @@ int acpi_bus_generate_netlink_event(const char *device_class,
 		return result;
 	}
 
-	genlmsg_multicast(skb, 0, acpi_event_mcgrp.id, GFP_ATOMIC);
+	genlmsg_multicast(&acpi_event_genl_family,
+			  skb, 0, acpi_event_mcgrp.id, GFP_ATOMIC);
 	return 0;
 }
 

commit 9968e459f1378a1c00301472cfe672497fe001d5
Author: Mathias Krause <minipli@googlemail.com>
Date:   Tue Nov 5 21:25:32 2013 +0100

    ACPI / event: remove unneeded NULL pointer check
    
    nla_data() cannot return NULL as it simply adds NLA_HDRLEN to the
    passed pointer. The NULL pointer check is therefore superfluous.
    Remove it.
    
    Found by smatch:
      drivers/acpi/event.c:130 acpi_bus_generate_netlink_event() warn: can
      'event' even be NULL?
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 8247fcdde079..fdef416c0ff6 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -127,11 +127,6 @@ int acpi_bus_generate_netlink_event(const char *device_class,
 	}
 
 	event = nla_data(attr);
-	if (!event) {
-		nlmsg_free(skb);
-		return -EINVAL;
-	}
-
 	memset(event, 0, sizeof(struct acpi_genl_event));
 
 	strcpy(event->device_class, device_class);

commit 1696d9dc57e062ce5200f6a42a6aaada15b434bb
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jul 15 10:15:09 2013 +0200

    ACPI: Remove the old /proc/acpi/event interface
    
    It is quite some time that this one has been deprecated.
    Get rid of it.
    
    Should some really important user be overseen, it may be reverted and
    the userspace program worked on first, but it is time to do something
    to get rid of this old stuff...
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Acked-by: Matthew Garrett <matthew.garrett@nebula.com>
    Acked-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 1442737cedec..8247fcdde079 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -21,100 +21,6 @@
 #define _COMPONENT		ACPI_SYSTEM_COMPONENT
 ACPI_MODULE_NAME("event");
 
-#ifdef CONFIG_ACPI_PROC_EVENT
-/* Global vars for handling event proc entry */
-static DEFINE_SPINLOCK(acpi_system_event_lock);
-int event_is_open = 0;
-extern struct list_head acpi_bus_event_list;
-extern wait_queue_head_t acpi_bus_event_queue;
-
-static int acpi_system_open_event(struct inode *inode, struct file *file)
-{
-	spin_lock_irq(&acpi_system_event_lock);
-
-	if (event_is_open)
-		goto out_busy;
-
-	event_is_open = 1;
-
-	spin_unlock_irq(&acpi_system_event_lock);
-	return 0;
-
-      out_busy:
-	spin_unlock_irq(&acpi_system_event_lock);
-	return -EBUSY;
-}
-
-static ssize_t
-acpi_system_read_event(struct file *file, char __user * buffer, size_t count,
-		       loff_t * ppos)
-{
-	int result = 0;
-	struct acpi_bus_event event;
-	static char str[ACPI_MAX_STRING];
-	static int chars_remaining = 0;
-	static char *ptr;
-
-	if (!chars_remaining) {
-		memset(&event, 0, sizeof(struct acpi_bus_event));
-
-		if ((file->f_flags & O_NONBLOCK)
-		    && (list_empty(&acpi_bus_event_list)))
-			return -EAGAIN;
-
-		result = acpi_bus_receive_event(&event);
-		if (result)
-			return result;
-
-		chars_remaining = sprintf(str, "%s %s %08x %08x\n",
-					  event.device_class ? event.
-					  device_class : "<unknown>",
-					  event.bus_id ? event.
-					  bus_id : "<unknown>", event.type,
-					  event.data);
-		ptr = str;
-	}
-
-	if (chars_remaining < count) {
-		count = chars_remaining;
-	}
-
-	if (copy_to_user(buffer, ptr, count))
-		return -EFAULT;
-
-	*ppos += count;
-	chars_remaining -= count;
-	ptr += count;
-
-	return count;
-}
-
-static int acpi_system_close_event(struct inode *inode, struct file *file)
-{
-	spin_lock_irq(&acpi_system_event_lock);
-	event_is_open = 0;
-	spin_unlock_irq(&acpi_system_event_lock);
-	return 0;
-}
-
-static unsigned int acpi_system_poll_event(struct file *file, poll_table * wait)
-{
-	poll_wait(file, &acpi_bus_event_queue, wait);
-	if (!list_empty(&acpi_bus_event_list))
-		return POLLIN | POLLRDNORM;
-	return 0;
-}
-
-static const struct file_operations acpi_system_event_ops = {
-	.owner = THIS_MODULE,
-	.open = acpi_system_open_event,
-	.read = acpi_system_read_event,
-	.release = acpi_system_close_event,
-	.poll = acpi_system_poll_event,
-	.llseek = default_llseek,
-};
-#endif	/* CONFIG_ACPI_PROC_EVENT */
-
 /* ACPI notifier chain */
 static BLOCKING_NOTIFIER_HEAD(acpi_chain_head);
 
@@ -280,9 +186,6 @@ static int acpi_event_genetlink_init(void)
 
 static int __init acpi_event_init(void)
 {
-#ifdef CONFIG_ACPI_PROC_EVENT
-	struct proc_dir_entry *entry;
-#endif
 	int error = 0;
 
 	if (acpi_disabled)
@@ -293,15 +196,6 @@ static int __init acpi_event_init(void)
 	if (error)
 		printk(KERN_WARNING PREFIX
 		       "Failed to create genetlink family for ACPI event\n");
-
-#ifdef CONFIG_ACPI_PROC_EVENT
-	/* 'event' [R] */
-	entry = proc_create("event", S_IRUSR, acpi_root_dir,
-			    &acpi_system_event_ops);
-	if (!entry)
-		return -ENODEV;
-#endif
-
 	return 0;
 }
 

commit 214f2c90b970e098e75cf719c0c5b0f1fe69b716
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Oct 26 16:22:14 2011 -0400

    acpi: add export.h to files using THIS_MODULE/EXPORT_SYMBOL
    
    These files were relying on module.h to come in via the path
    in an include/acpi header file, but we don't want to have
    instances of module.h being included from include/* files
    if it can be avoided.  Have the files include export.h instead.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 85d908993809..1442737cedec 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -7,6 +7,7 @@
  */
 
 #include <linux/spinlock.h>
+#include <linux/export.h>
 #include <linux/proc_fs.h>
 #include <linux/init.h>
 #include <linux/poll.h>

commit 6038f373a3dc1f1c26496e60b6c40b164716f07e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 18:52:59 2010 +0200

    llseek: automatically add .llseek fop
    
    All file_operations should get a .llseek operation so we can make
    nonseekable_open the default for future file operations without a
    .llseek pointer.
    
    The three cases that we can automatically detect are no_llseek, seq_lseek
    and default_llseek. For cases where we can we can automatically prove that
    the file offset is always ignored, we use noop_llseek, which maintains
    the current behavior of not returning an error from a seek.
    
    New drivers should normally not use noop_llseek but instead use no_llseek
    and call nonseekable_open at open time.  Existing drivers can be converted
    to do the same when the maintainer knows for certain that no user code
    relies on calling seek on the device file.
    
    The generated code is often incorrectly indented and right now contains
    comments that clarify for each added line why a specific variant was
    chosen. In the version that gets submitted upstream, the comments will
    be gone and I will manually fix the indentation, because there does not
    seem to be a way to do that using coccinelle.
    
    Some amount of new code is currently sitting in linux-next that should get
    the same modifications, which I will do at the end of the merge window.
    
    Many thanks to Julia Lawall for helping me learn to write a semantic
    patch that does all this.
    
    ===== begin semantic patch =====
    // This adds an llseek= method to all file operations,
    // as a preparation for making no_llseek the default.
    //
    // The rules are
    // - use no_llseek explicitly if we do nonseekable_open
    // - use seq_lseek for sequential files
    // - use default_llseek if we know we access f_pos
    // - use noop_llseek if we know we don't access f_pos,
    //   but we still want to allow users to call lseek
    //
    @ open1 exists @
    identifier nested_open;
    @@
    nested_open(...)
    {
    <+...
    nonseekable_open(...)
    ...+>
    }
    
    @ open exists@
    identifier open_f;
    identifier i, f;
    identifier open1.nested_open;
    @@
    int open_f(struct inode *i, struct file *f)
    {
    <+...
    (
    nonseekable_open(...)
    |
    nested_open(...)
    )
    ...+>
    }
    
    @ read disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    <+...
    (
       *off = E
    |
       *off += E
    |
       func(..., off, ...)
    |
       E = *off
    )
    ...+>
    }
    
    @ read_no_fpos disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ write @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    <+...
    (
      *off = E
    |
      *off += E
    |
      func(..., off, ...)
    |
      E = *off
    )
    ...+>
    }
    
    @ write_no_fpos @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ fops0 @
    identifier fops;
    @@
    struct file_operations fops = {
     ...
    };
    
    @ has_llseek depends on fops0 @
    identifier fops0.fops;
    identifier llseek_f;
    @@
    struct file_operations fops = {
    ...
     .llseek = llseek_f,
    ...
    };
    
    @ has_read depends on fops0 @
    identifier fops0.fops;
    identifier read_f;
    @@
    struct file_operations fops = {
    ...
     .read = read_f,
    ...
    };
    
    @ has_write depends on fops0 @
    identifier fops0.fops;
    identifier write_f;
    @@
    struct file_operations fops = {
    ...
     .write = write_f,
    ...
    };
    
    @ has_open depends on fops0 @
    identifier fops0.fops;
    identifier open_f;
    @@
    struct file_operations fops = {
    ...
     .open = open_f,
    ...
    };
    
    // use no_llseek if we call nonseekable_open
    ////////////////////////////////////////////
    @ nonseekable1 depends on !has_llseek && has_open @
    identifier fops0.fops;
    identifier nso ~= "nonseekable_open";
    @@
    struct file_operations fops = {
    ...  .open = nso, ...
    +.llseek = no_llseek, /* nonseekable */
    };
    
    @ nonseekable2 depends on !has_llseek @
    identifier fops0.fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...  .open = open_f, ...
    +.llseek = no_llseek, /* open uses nonseekable */
    };
    
    // use seq_lseek for sequential files
    /////////////////////////////////////
    @ seq depends on !has_llseek @
    identifier fops0.fops;
    identifier sr ~= "seq_read";
    @@
    struct file_operations fops = {
    ...  .read = sr, ...
    +.llseek = seq_lseek, /* we have seq_read */
    };
    
    // use default_llseek if there is a readdir
    ///////////////////////////////////////////
    @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier readdir_e;
    @@
    // any other fop is used that changes pos
    struct file_operations fops = {
    ... .readdir = readdir_e, ...
    +.llseek = default_llseek, /* readdir is present */
    };
    
    // use default_llseek if at least one of read/write touches f_pos
    /////////////////////////////////////////////////////////////////
    @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read.read_f;
    @@
    // read fops use offset
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = default_llseek, /* read accesses f_pos */
    };
    
    @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ... .write = write_f, ...
    +       .llseek = default_llseek, /* write accesses f_pos */
    };
    
    // Use noop_llseek if neither read nor write accesses f_pos
    ///////////////////////////////////////////////////////////
    
    @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    identifier write_no_fpos.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ...
     .write = write_f,
     .read = read_f,
    ...
    +.llseek = noop_llseek, /* read and write both use no f_pos */
    };
    
    @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write_no_fpos.write_f;
    @@
    struct file_operations fops = {
    ... .write = write_f, ...
    +.llseek = noop_llseek, /* write uses no f_pos */
    };
    
    @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    @@
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = noop_llseek, /* read uses no f_pos */
    };
    
    @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    @@
    struct file_operations fops = {
    ...
    +.llseek = noop_llseek, /* no read or write fn */
    };
    ===== End semantic patch =====
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index d439314a75d8..85d908993809 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -110,6 +110,7 @@ static const struct file_operations acpi_system_event_ops = {
 	.read = acpi_system_read_event,
 	.release = acpi_system_close_event,
 	.poll = acpi_system_poll_event,
+	.llseek = default_llseek,
 };
 #endif	/* CONFIG_ACPI_PROC_EVENT */
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index c511071bfd79..d439314a75d8 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -10,6 +10,7 @@
 #include <linux/proc_fs.h>
 #include <linux/init.h>
 #include <linux/poll.h>
+#include <linux/gfp.h>
 #include <acpi/acpi_drivers.h>
 #include <net/netlink.h>
 #include <net/genetlink.h>

commit a192a9580bcc41692be1f36b77c3b681827f566a
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jul 28 16:45:54 2009 -0400

    ACPI: Move definition of PREFIX from acpi_bus.h to internal..h
    
    Linux/ACPI core files using internal.h all PREFIX "ACPI: ",
    however, not all ACPI drivers use/want it -- and they
    should not have to #undef PREFIX to define their own.
    
    Add GPL commment to internal.h while we are there.
    
    This does not change any actual console output,
    asside from a whitespace fix.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index aeb7e5fb4a04..c511071bfd79 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -14,6 +14,8 @@
 #include <net/netlink.h>
 #include <net/genetlink.h>
 
+#include "internal.h"
+
 #define _COMPONENT		ACPI_SYSTEM_COMPONENT
 ACPI_MODULE_NAME("event");
 

commit ff491a7334acfd74e515c896632e37e401f52676
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Thu Feb 5 23:56:36 2009 -0800

    netlink: change return-value logic of netlink_broadcast()
    
    Currently, netlink_broadcast() reports errors to the caller if no
    messages at all were delivered:
    
    1) If, at least, one message has been delivered correctly, returns 0.
    2) Otherwise, if no messages at all were delivered due to skb_clone()
       failure, return -ENOBUFS.
    3) Otherwise, if there are no listeners, return -ESRCH.
    
    With this patch, the caller knows if the delivery of any of the
    messages to the listeners have failed:
    
    1) If it fails to deliver any message (for whatever reason), return
       -ENOBUFS.
    2) Otherwise, if all messages were delivered OK, returns 0.
    3) Otherwise, if no listeners, return -ESRCH.
    
    In the current ctnetlink code and in Netfilter in general, we can add
    reliable logging and connection tracking event delivery by dropping the
    packets whose events were not successfully delivered over Netlink. Of
    course, this option would be settable via /proc as this approach reduces
    performance (in terms of filtered connections per seconds by a stateful
    firewall) but providing reliable logging and event delivery (for
    conntrackd) in return.
    
    This patch also changes some clients of netlink_broadcast() that
    may report ENOBUFS errors via printk. This error handling is not
    of any help. Instead, the userspace daemons that are listening to
    those netlink messages should resync themselves with the kernel-side
    if they hit ENOBUFS.
    
    BTW, netlink_broadcast() clients include those that call
    cn_netlink_send(), nlmsg_multicast() and genlmsg_multicast() since they
    internally call netlink_broadcast() and return its error value.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 0c24bd4d6562..aeb7e5fb4a04 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -235,11 +235,7 @@ int acpi_bus_generate_netlink_event(const char *device_class,
 		return result;
 	}
 
-	result =
-	    genlmsg_multicast(skb, 0, acpi_event_mcgrp.id, GFP_ATOMIC);
-	if (result)
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Failed to send a Genetlink message!\n"));
+	genlmsg_multicast(skb, 0, acpi_event_mcgrp.id, GFP_ATOMIC);
 	return 0;
 }
 

commit cf7acfab032ff262f42954328cdfd20a5d9aaaac
Author: Denis V. Lunev <den@openvz.org>
Date:   Tue Apr 29 01:02:27 2008 -0700

    acpi: use non-racy method for proc entries creation
    
    Use proc_create()/proc_create_data() to make sure that ->proc_fops and ->data
    be setup before gluing PDE to main tree.
    
    Add correct ->owner to proc_fops to fix reading/module unloading race.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index abec1ca94cf4..0c24bd4d6562 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -102,6 +102,7 @@ static unsigned int acpi_system_poll_event(struct file *file, poll_table * wait)
 }
 
 static const struct file_operations acpi_system_event_ops = {
+	.owner = THIS_MODULE,
 	.open = acpi_system_open_event,
 	.read = acpi_system_read_event,
 	.release = acpi_system_close_event,
@@ -294,10 +295,9 @@ static int __init acpi_event_init(void)
 
 #ifdef CONFIG_ACPI_PROC_EVENT
 	/* 'event' [R] */
-	entry = create_proc_entry("event", S_IRUSR, acpi_root_dir);
-	if (entry)
-		entry->proc_fops = &acpi_system_event_ops;
-	else
+	entry = proc_create("event", S_IRUSR, acpi_root_dir,
+			    &acpi_system_event_ops);
+	if (!entry)
 		return -ENODEV;
 #endif
 

commit c8e773fa4f6a999a80d9fa3836f412e259ab6fa1
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Feb 13 23:29:57 2008 +0200

    ACPI: static acpi_chain_head
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 5479dc0eeeec..abec1ca94cf4 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -110,7 +110,7 @@ static const struct file_operations acpi_system_event_ops = {
 #endif	/* CONFIG_ACPI_PROC_EVENT */
 
 /* ACPI notifier chain */
-BLOCKING_NOTIFIER_HEAD(acpi_chain_head);
+static BLOCKING_NOTIFIER_HEAD(acpi_chain_head);
 
 int acpi_notifier_call_chain(struct acpi_device *dev, u32 type, u32 data)
 {

commit 9ee85241fdaab358dff1d8647f20a478cfa512a1
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri Jan 25 14:48:06 2008 +0800

    ACPI: create notifier chain to get hotkey events to graphics driver
    
    Kernel mode graphics drivers need this ACPI notifier chaine
    so that they can get notified upon hotkey events.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 5c95863f8fa9..5479dc0eeeec 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -109,6 +109,34 @@ static const struct file_operations acpi_system_event_ops = {
 };
 #endif	/* CONFIG_ACPI_PROC_EVENT */
 
+/* ACPI notifier chain */
+BLOCKING_NOTIFIER_HEAD(acpi_chain_head);
+
+int acpi_notifier_call_chain(struct acpi_device *dev, u32 type, u32 data)
+{
+	struct acpi_bus_event event;
+
+	strcpy(event.device_class, dev->pnp.device_class);
+	strcpy(event.bus_id, dev->pnp.bus_id);
+	event.type = type;
+	event.data = data;
+	return (blocking_notifier_call_chain(&acpi_chain_head, 0, (void *)&event)
+                        == NOTIFY_BAD) ? -EINVAL : 0;
+}
+EXPORT_SYMBOL(acpi_notifier_call_chain);
+
+int register_acpi_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&acpi_chain_head, nb);
+}
+EXPORT_SYMBOL(register_acpi_notifier);
+
+int unregister_acpi_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&acpi_chain_head, nb);
+}
+EXPORT_SYMBOL(unregister_acpi_notifier);
+
 #ifdef CONFIG_NET
 static unsigned int acpi_event_seqnum;
 struct acpi_genl_event {

commit 66baf327ae5d4c17e75d1f501145e79eaeeaf649
Author: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
Date:   Mon Sep 3 00:03:35 2007 -0300

    ACPI: fix CONFIG_NET=n acpi_bus_generate_netlink_event build failure
    
    drivers/acpi/event.c:243: error: 'acpi_generate_netlink_event' undeclared
    here (not in a function)
    
    Signed-off-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index a2b9304596ce..5c95863f8fa9 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -240,7 +240,7 @@ int acpi_bus_generate_netlink_event(const char *device_class,
 	return 0;
 }
 
-EXPORT_SYMBOL(acpi_generate_netlink_event);
+EXPORT_SYMBOL(acpi_bus_generate_netlink_event);
 
 static int acpi_event_genetlink_init(void)
 {

commit 3e069ee0c30d6f28b79e409ef2df1ffa427897ae
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 24 03:06:33 2007 -0400

    ACPI: fix ia64 allnoconfig build
    
    drivers/acpi/event.c:238: error: conflicting types for ‘acpi_bus_generate_netlink_event’
    include/acpi/acpi_bus.h:324: error: previous declaration of ‘acpi_bus_generate_netlink_event’ was here
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index cf6d5161cf31..a2b9304596ce 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -233,8 +233,9 @@ static int acpi_event_genetlink_init(void)
 }
 
 #else
-int acpi_bus_generate_netlink_event(struct acpi_device *device, u8 type,
-				      int data)
+int acpi_bus_generate_netlink_event(const char *device_class,
+				      const char *bus_id,
+				      u8 type, int data)
 {
 	return 0;
 }

commit 14e04fb34ffa82ee61ae69f98d8fca12d2e8e31c
Author: Len Brown <len.brown@intel.com>
Date:   Thu Aug 23 15:20:26 2007 -0400

    ACPI: Schedule /proc/acpi/event for removal
    
    Schedule /proc/acpi/event for removal in 6 months.
    
    Re-name acpi_bus_generate_event() to acpi_bus_generate_proc_event()
    to make sure there is no confusion that it is for /proc/acpi/event only.
    
    Add CONFIG_ACPI_PROC_EVENT to allow removal of /proc/acpi/event.
    There is no functional change if CONFIG_ACPI_PROC_EVENT=y
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index b7b143288c22..cf6d5161cf31 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -17,6 +17,7 @@
 #define _COMPONENT		ACPI_SYSTEM_COMPONENT
 ACPI_MODULE_NAME("event");
 
+#ifdef CONFIG_ACPI_PROC_EVENT
 /* Global vars for handling event proc entry */
 static DEFINE_SPINLOCK(acpi_system_event_lock);
 int event_is_open = 0;
@@ -106,6 +107,7 @@ static const struct file_operations acpi_system_event_ops = {
 	.release = acpi_system_close_event,
 	.poll = acpi_system_poll_event,
 };
+#endif	/* CONFIG_ACPI_PROC_EVENT */
 
 #ifdef CONFIG_NET
 static unsigned int acpi_event_seqnum;
@@ -247,7 +249,9 @@ static int acpi_event_genetlink_init(void)
 
 static int __init acpi_event_init(void)
 {
+#ifdef CONFIG_ACPI_PROC_EVENT
 	struct proc_dir_entry *entry;
+#endif
 	int error = 0;
 
 	if (acpi_disabled)
@@ -259,12 +263,14 @@ static int __init acpi_event_init(void)
 		printk(KERN_WARNING PREFIX
 		       "Failed to create genetlink family for ACPI event\n");
 
+#ifdef CONFIG_ACPI_PROC_EVENT
 	/* 'event' [R] */
 	entry = create_proc_entry("event", S_IRUSR, acpi_root_dir);
 	if (entry)
 		entry->proc_fops = &acpi_system_event_ops;
 	else
 		return -ENODEV;
+#endif
 
 	return 0;
 }

commit 962ce8ca0604af0c3c5609f7613d4ec5fcfac623
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Aug 23 01:24:31 2007 +0800

    ACPI: don't duplicate input events on netlink
    
    The previous events patch added a netlink event for every
    user of the legacy /proc/acpi/event interface.
    
    However, some users of /proc/acpi/event are really input events,
    and they already report their events via the input layer.
    
    Introduce a new interface, acpi_bus_generate_netlink_event(),
    which is explicitly called by devices that want to repoprt
    events via netlink.  This allows the input-like events
    to opt-out of generating netlink events.  In summary:
    
    events that are sent via netlink:
            ac/battery/sbs
            thermal
            processor
            thinkpad_acpi dock/bay
    
    events that are sent via input layer:
            button
            video hotkey
            thinkpad_acpi hotkey
            asus_acpi/asus-laptop hotkey
            sonypi/sonylaptop
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 95637a4ff782..b7b143288c22 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -147,7 +147,8 @@ static struct genl_multicast_group acpi_event_mcgrp = {
 	.name = ACPI_GENL_MCAST_GROUP_NAME,
 };
 
-int acpi_bus_generate_genetlink_event(struct acpi_device *device,
+int acpi_bus_generate_netlink_event(const char *device_class,
+				      const char *bus_id,
 				      u8 type, int data)
 {
 	struct sk_buff *skb;
@@ -191,8 +192,8 @@ int acpi_bus_generate_genetlink_event(struct acpi_device *device,
 
 	memset(event, 0, sizeof(struct acpi_genl_event));
 
-	strcpy(event->device_class, device->pnp.device_class);
-	strcpy(event->bus_id, device->dev.bus_id);
+	strcpy(event->device_class, device_class);
+	strcpy(event->bus_id, bus_id);
 	event->type = type;
 	event->data = data;
 
@@ -211,6 +212,8 @@ int acpi_bus_generate_genetlink_event(struct acpi_device *device,
 	return 0;
 }
 
+EXPORT_SYMBOL(acpi_bus_generate_netlink_event);
+
 static int acpi_event_genetlink_init(void)
 {
 	int result;
@@ -228,12 +231,14 @@ static int acpi_event_genetlink_init(void)
 }
 
 #else
-int acpi_bus_generate_genetlink_event(struct acpi_device *device, u8 type,
+int acpi_bus_generate_netlink_event(struct acpi_device *device, u8 type,
 				      int data)
 {
 	return 0;
 }
 
+EXPORT_SYMBOL(acpi_generate_netlink_event);
+
 static int acpi_event_genetlink_init(void)
 {
 	return -ENODEV;

commit e13d87473284131a7ead8121d5d29345101f68a4
Author: Adrian Bunk <bunk@stusta.de>
Date:   Fri Aug 10 13:45:18 2007 -0700

    ACPI: static
    
    Make the needlessly global "acpi_event_seqnum" static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index dfa5853b17f0..95637a4ff782 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -108,7 +108,7 @@ static const struct file_operations acpi_system_event_ops = {
 };
 
 #ifdef CONFIG_NET
-unsigned int acpi_event_seqnum;
+static unsigned int acpi_event_seqnum;
 struct acpi_genl_event {
 	acpi_device_class device_class;
 	char bus_id[15];

commit 9c977a453ed62396d067b75f3f272b3fb1ea3acc
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri Jul 20 16:41:14 2007 +0800

    ACPI: export ACPI events via acpi_mc_group multicast group
    
    This is an incremental patch for the recent genetlink
    multicast changes.
    
    Now ACPI events are exported via generic netlink multicast group.
    
    Thanks for Johannes' help on developing this patch
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index de4def9b5515..dfa5853b17f0 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -132,30 +132,19 @@ enum {
 };
 #define ACPI_GENL_CMD_MAX (__ACPI_GENL_CMD_MAX - 1)
 
-#define ACPI_GENL_NAME		"acpi_event"
-#define ACPI_GENL_VERSION	0x01
+#define ACPI_GENL_FAMILY_NAME		"acpi_event"
+#define ACPI_GENL_VERSION		0x01
+#define ACPI_GENL_MCAST_GROUP_NAME 	"acpi_mc_group"
 
 static struct genl_family acpi_event_genl_family = {
 	.id = GENL_ID_GENERATE,
-	.name = ACPI_GENL_NAME,
+	.name = ACPI_GENL_FAMILY_NAME,
 	.version = ACPI_GENL_VERSION,
 	.maxattr = ACPI_GENL_ATTR_MAX,
 };
 
-/* .doit: standard command callback */
-static int acpi_genl_cmd_event(struct sk_buff *skb, struct genl_info *info)
-{
-	struct acpi_genl_event *event = info->userhdr;
-
-	if (!event)
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "ACPI event: NULL\n"));
-
-	return 0;
-}
-
-static struct genl_ops acpi_event_genl_ops = {
-	.cmd = ACPI_GENL_CMD_EVENT,
-	.doit = acpi_genl_cmd_event,
+static struct genl_multicast_group acpi_event_mcgrp = {
+	.name = ACPI_GENL_MCAST_GROUP_NAME,
 };
 
 int acpi_bus_generate_genetlink_event(struct acpi_device *device,
@@ -215,7 +204,7 @@ int acpi_bus_generate_genetlink_event(struct acpi_device *device,
 	}
 
 	result =
-	    genlmsg_multicast(skb, 0, acpi_event_genl_family.id, GFP_ATOMIC);
+	    genlmsg_multicast(skb, 0, acpi_event_mcgrp.id, GFP_ATOMIC);
 	if (result)
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Failed to send a Genetlink message!\n"));
@@ -230,8 +219,8 @@ static int acpi_event_genetlink_init(void)
 	if (result)
 		return result;
 
-	result =
-	    genl_register_ops(&acpi_event_genl_family, &acpi_event_genl_ops);
+	result = genl_register_mc_group(&acpi_event_genl_family,
+					&acpi_event_mcgrp);
 	if (result)
 		genl_unregister_family(&acpi_event_genl_family);
 

commit b563d6f30d937510e02541930b1558d0f5759413
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jul 3 15:32:23 2007 -0400

    ACPI: netlink: remove unnecessary EXPORT_SYMBOL
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 98627b02f547..de4def9b5515 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -221,7 +221,6 @@ int acpi_bus_generate_genetlink_event(struct acpi_device *device,
 				  "Failed to send a Genetlink message!\n"));
 	return 0;
 }
-EXPORT_SYMBOL(acpi_bus_generate_genetlink_event);
 
 static int acpi_event_genetlink_init(void)
 {
@@ -245,7 +244,6 @@ int acpi_bus_generate_genetlink_event(struct acpi_device *device, u8 type,
 {
 	return 0;
 }
-EXPORT_SYMBOL(acpi_bus_generate_genetlink_event);
 
 static int acpi_event_genetlink_init(void)
 {

commit 864bdfb912e372670b5b2541dac9d273a4a7722a
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Jun 19 11:40:03 2007 +0800

    ACPI: Export events via generic netlink
    
    Upon ACPI events, send an "acpi_event" via Generic Netlink.
    This is in addition to /proc/acpi/event, which remains intact for now.
    
    Thanks to Jamal for his great help.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 3b23562e6f92..98627b02f547 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -11,6 +11,8 @@
 #include <linux/init.h>
 #include <linux/poll.h>
 #include <acpi/acpi_drivers.h>
+#include <net/netlink.h>
+#include <net/genetlink.h>
 
 #define _COMPONENT		ACPI_SYSTEM_COMPONENT
 ACPI_MODULE_NAME("event");
@@ -48,7 +50,6 @@ acpi_system_read_event(struct file *file, char __user * buffer, size_t count,
 	static int chars_remaining = 0;
 	static char *ptr;
 
-
 	if (!chars_remaining) {
 		memset(&event, 0, sizeof(struct acpi_bus_event));
 
@@ -106,23 +107,174 @@ static const struct file_operations acpi_system_event_ops = {
 	.poll = acpi_system_poll_event,
 };
 
+#ifdef CONFIG_NET
+unsigned int acpi_event_seqnum;
+struct acpi_genl_event {
+	acpi_device_class device_class;
+	char bus_id[15];
+	u32 type;
+	u32 data;
+};
+
+/* attributes of acpi_genl_family */
+enum {
+	ACPI_GENL_ATTR_UNSPEC,
+	ACPI_GENL_ATTR_EVENT,	/* ACPI event info needed by user space */
+	__ACPI_GENL_ATTR_MAX,
+};
+#define ACPI_GENL_ATTR_MAX (__ACPI_GENL_ATTR_MAX - 1)
+
+/* commands supported by the acpi_genl_family */
+enum {
+	ACPI_GENL_CMD_UNSPEC,
+	ACPI_GENL_CMD_EVENT,	/* kernel->user notifications for ACPI events */
+	__ACPI_GENL_CMD_MAX,
+};
+#define ACPI_GENL_CMD_MAX (__ACPI_GENL_CMD_MAX - 1)
+
+#define ACPI_GENL_NAME		"acpi_event"
+#define ACPI_GENL_VERSION	0x01
+
+static struct genl_family acpi_event_genl_family = {
+	.id = GENL_ID_GENERATE,
+	.name = ACPI_GENL_NAME,
+	.version = ACPI_GENL_VERSION,
+	.maxattr = ACPI_GENL_ATTR_MAX,
+};
+
+/* .doit: standard command callback */
+static int acpi_genl_cmd_event(struct sk_buff *skb, struct genl_info *info)
+{
+	struct acpi_genl_event *event = info->userhdr;
+
+	if (!event)
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "ACPI event: NULL\n"));
+
+	return 0;
+}
+
+static struct genl_ops acpi_event_genl_ops = {
+	.cmd = ACPI_GENL_CMD_EVENT,
+	.doit = acpi_genl_cmd_event,
+};
+
+int acpi_bus_generate_genetlink_event(struct acpi_device *device,
+				      u8 type, int data)
+{
+	struct sk_buff *skb;
+	struct nlattr *attr;
+	struct acpi_genl_event *event;
+	void *msg_header;
+	int size;
+	int result;
+
+	/* allocate memory */
+	size = nla_total_size(sizeof(struct acpi_genl_event)) +
+	    nla_total_size(0);
+
+	skb = genlmsg_new(size, GFP_ATOMIC);
+	if (!skb)
+		return -ENOMEM;
+
+	/* add the genetlink message header */
+	msg_header = genlmsg_put(skb, 0, acpi_event_seqnum++,
+				 &acpi_event_genl_family, 0,
+				 ACPI_GENL_CMD_EVENT);
+	if (!msg_header) {
+		nlmsg_free(skb);
+		return -ENOMEM;
+	}
+
+	/* fill the data */
+	attr =
+	    nla_reserve(skb, ACPI_GENL_ATTR_EVENT,
+			sizeof(struct acpi_genl_event));
+	if (!attr) {
+		nlmsg_free(skb);
+		return -EINVAL;
+	}
+
+	event = nla_data(attr);
+	if (!event) {
+		nlmsg_free(skb);
+		return -EINVAL;
+	}
+
+	memset(event, 0, sizeof(struct acpi_genl_event));
+
+	strcpy(event->device_class, device->pnp.device_class);
+	strcpy(event->bus_id, device->dev.bus_id);
+	event->type = type;
+	event->data = data;
+
+	/* send multicast genetlink message */
+	result = genlmsg_end(skb, msg_header);
+	if (result < 0) {
+		nlmsg_free(skb);
+		return result;
+	}
+
+	result =
+	    genlmsg_multicast(skb, 0, acpi_event_genl_family.id, GFP_ATOMIC);
+	if (result)
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Failed to send a Genetlink message!\n"));
+	return 0;
+}
+EXPORT_SYMBOL(acpi_bus_generate_genetlink_event);
+
+static int acpi_event_genetlink_init(void)
+{
+	int result;
+
+	result = genl_register_family(&acpi_event_genl_family);
+	if (result)
+		return result;
+
+	result =
+	    genl_register_ops(&acpi_event_genl_family, &acpi_event_genl_ops);
+	if (result)
+		genl_unregister_family(&acpi_event_genl_family);
+
+	return result;
+}
+
+#else
+int acpi_bus_generate_genetlink_event(struct acpi_device *device, u8 type,
+				      int data)
+{
+	return 0;
+}
+EXPORT_SYMBOL(acpi_bus_generate_genetlink_event);
+
+static int acpi_event_genetlink_init(void)
+{
+	return -ENODEV;
+}
+#endif
+
 static int __init acpi_event_init(void)
 {
 	struct proc_dir_entry *entry;
 	int error = 0;
 
-
 	if (acpi_disabled)
 		return 0;
 
+	/* create genetlink for acpi event */
+	error = acpi_event_genetlink_init();
+	if (error)
+		printk(KERN_WARNING PREFIX
+		       "Failed to create genetlink family for ACPI event\n");
+
 	/* 'event' [R] */
 	entry = create_proc_entry("event", S_IRUSR, acpi_root_dir);
 	if (entry)
 		entry->proc_fops = &acpi_system_event_ops;
-	else {
-		error = -ENODEV;
-	}
-	return error;
+	else
+		return -ENODEV;
+
+	return 0;
 }
 
-subsys_initcall(acpi_event_init);
+fs_initcall(acpi_event_init);

commit f52fd66d2ea794010c2d7536cf8e6abed0ac4947
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 22:42:12 2007 -0500

    ACPI: clean up ACPI_MODULE_NAME() use
    
    cosmetic only
    
    Make "module name" actually match the file name.
    Invoke with ';' as leaving it off confuses Lindent and gcc doesn't care.
    Fix indentation where Lindent did get confused.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 959a893c8d1f..3b23562e6f92 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -13,7 +13,7 @@
 #include <acpi/acpi_drivers.h>
 
 #define _COMPONENT		ACPI_SYSTEM_COMPONENT
-ACPI_MODULE_NAME("event")
+ACPI_MODULE_NAME("event");
 
 /* Global vars for handling event proc entry */
 static DEFINE_SPINLOCK(acpi_system_event_lock);

commit d75080328affb4b268da430b7074cc8139cc662a
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Tue Jul 4 13:06:00 2006 -0400

    ACPI: add 'const' to several ACPI file_operations
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index a901b23e95e7..959a893c8d1f 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -99,7 +99,7 @@ static unsigned int acpi_system_poll_event(struct file *file, poll_table * wait)
 	return 0;
 }
 
-static struct file_operations acpi_system_event_ops = {
+static const struct file_operations acpi_system_event_ops = {
 	.open = acpi_system_open_event,
 	.read = acpi_system_read_event,
 	.release = acpi_system_close_event,

commit d550d98d3317378d93a4869db204725d270ec812
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Tue Jun 27 00:41:40 2006 -0400

    ACPI: delete tracing macros from drivers/acpi/*.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index dab09d3f6307..a901b23e95e7 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -48,18 +48,17 @@ acpi_system_read_event(struct file *file, char __user * buffer, size_t count,
 	static int chars_remaining = 0;
 	static char *ptr;
 
-	ACPI_FUNCTION_TRACE("acpi_system_read_event");
 
 	if (!chars_remaining) {
 		memset(&event, 0, sizeof(struct acpi_bus_event));
 
 		if ((file->f_flags & O_NONBLOCK)
 		    && (list_empty(&acpi_bus_event_list)))
-			return_VALUE(-EAGAIN);
+			return -EAGAIN;
 
 		result = acpi_bus_receive_event(&event);
 		if (result)
-			return_VALUE(result);
+			return result;
 
 		chars_remaining = sprintf(str, "%s %s %08x %08x\n",
 					  event.device_class ? event.
@@ -75,13 +74,13 @@ acpi_system_read_event(struct file *file, char __user * buffer, size_t count,
 	}
 
 	if (copy_to_user(buffer, ptr, count))
-		return_VALUE(-EFAULT);
+		return -EFAULT;
 
 	*ppos += count;
 	chars_remaining -= count;
 	ptr += count;
 
-	return_VALUE(count);
+	return count;
 }
 
 static int acpi_system_close_event(struct inode *inode, struct file *file)
@@ -112,10 +111,9 @@ static int __init acpi_event_init(void)
 	struct proc_dir_entry *entry;
 	int error = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_event_init");
 
 	if (acpi_disabled)
-		return_VALUE(0);
+		return 0;
 
 	/* 'event' [R] */
 	entry = create_proc_entry("event", S_IRUSR, acpi_root_dir);
@@ -124,7 +122,7 @@ static int __init acpi_event_init(void)
 	else {
 		error = -ENODEV;
 	}
-	return_VALUE(error);
+	return error;
 }
 
 subsys_initcall(acpi_event_init);

commit a6fc67202e0224e6c9d1d285cc0b444bce887ed5
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jun 26 23:58:43 2006 -0400

    ACPI: Enable ACPI error messages w/o CONFIG_ACPI_DEBUG
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 2dbb1b0f11d5..dab09d3f6307 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -122,10 +122,7 @@ static int __init acpi_event_init(void)
 	if (entry)
 		entry->proc_fops = &acpi_system_event_ops;
 	else {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Unable to create '%s' proc fs entry\n",
-				  "event"));
-		error = -EFAULT;
+		error = -ENODEV;
 	}
 	return_VALUE(error);
 }

commit 5cc9eeef9a9567acdfc2f6943f24381bf460f008
Author: Pavel Machek <pavel@ucw.cz>
Date:   Mon Oct 17 16:43:31 2005 -0700

    [PATCH] Fix /proc/acpi/events around suspend
    
    Fix -EIO on /proc/acpi/events after suspends.  This actually breaks
    suspending by power button in many setups.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index bfa8b76de403..2dbb1b0f11d5 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -58,9 +58,8 @@ acpi_system_read_event(struct file *file, char __user * buffer, size_t count,
 			return_VALUE(-EAGAIN);
 
 		result = acpi_bus_receive_event(&event);
-		if (result) {
-			return_VALUE(-EIO);
-		}
+		if (result)
+			return_VALUE(result);
 
 		chars_remaining = sprintf(str, "%s %s %08x %08x\n",
 					  event.device_class ? event.

commit 4be44fcd3bf648b782f4460fd06dfae6c42ded4b
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 5 00:44:28 2005 -0400

    [ACPI] Lindent all ACPI files
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index ce8d3eec3911..bfa8b76de403 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -13,16 +13,15 @@
 #include <acpi/acpi_drivers.h>
 
 #define _COMPONENT		ACPI_SYSTEM_COMPONENT
-ACPI_MODULE_NAME		("event")
+ACPI_MODULE_NAME("event")
 
 /* Global vars for handling event proc entry */
 static DEFINE_SPINLOCK(acpi_system_event_lock);
-int				event_is_open = 0;
-extern struct list_head		acpi_bus_event_list;
-extern wait_queue_head_t	acpi_bus_event_queue;
+int event_is_open = 0;
+extern struct list_head acpi_bus_event_list;
+extern wait_queue_head_t acpi_bus_event_queue;
 
-static int
-acpi_system_open_event(struct inode *inode, struct file *file)
+static int acpi_system_open_event(struct inode *inode, struct file *file)
 {
 	spin_lock_irq(&acpi_system_event_lock);
 
@@ -34,20 +33,20 @@ acpi_system_open_event(struct inode *inode, struct file *file)
 	spin_unlock_irq(&acpi_system_event_lock);
 	return 0;
 
-out_busy:
+      out_busy:
 	spin_unlock_irq(&acpi_system_event_lock);
 	return -EBUSY;
 }
 
 static ssize_t
-acpi_system_read_event(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
+acpi_system_read_event(struct file *file, char __user * buffer, size_t count,
+		       loff_t * ppos)
 {
-	int			result = 0;
-	struct acpi_bus_event	event;
-	static char		str[ACPI_MAX_STRING];
-	static int		chars_remaining = 0;
-	static char		*ptr;
-
+	int result = 0;
+	struct acpi_bus_event event;
+	static char str[ACPI_MAX_STRING];
+	static int chars_remaining = 0;
+	static char *ptr;
 
 	ACPI_FUNCTION_TRACE("acpi_system_read_event");
 
@@ -63,10 +62,12 @@ acpi_system_read_event(struct file *file, char __user *buffer, size_t count, lof
 			return_VALUE(-EIO);
 		}
 
-		chars_remaining = sprintf(str, "%s %s %08x %08x\n", 
-			event.device_class?event.device_class:"<unknown>",
-			event.bus_id?event.bus_id:"<unknown>", 
-			event.type, event.data);
+		chars_remaining = sprintf(str, "%s %s %08x %08x\n",
+					  event.device_class ? event.
+					  device_class : "<unknown>",
+					  event.bus_id ? event.
+					  bus_id : "<unknown>", event.type,
+					  event.data);
 		ptr = str;
 	}
 
@@ -84,17 +85,15 @@ acpi_system_read_event(struct file *file, char __user *buffer, size_t count, lof
 	return_VALUE(count);
 }
 
-static int
-acpi_system_close_event(struct inode *inode, struct file *file)
+static int acpi_system_close_event(struct inode *inode, struct file *file)
 {
-	spin_lock_irq (&acpi_system_event_lock);
+	spin_lock_irq(&acpi_system_event_lock);
 	event_is_open = 0;
-	spin_unlock_irq (&acpi_system_event_lock);
+	spin_unlock_irq(&acpi_system_event_lock);
 	return 0;
 }
 
-static unsigned int
-acpi_system_poll_event(struct file *file, poll_table *wait)
+static unsigned int acpi_system_poll_event(struct file *file, poll_table * wait)
 {
 	poll_wait(file, &acpi_bus_event_queue, wait);
 	if (!list_empty(&acpi_bus_event_list))
@@ -103,15 +102,15 @@ acpi_system_poll_event(struct file *file, poll_table *wait)
 }
 
 static struct file_operations acpi_system_event_ops = {
-	.open =		acpi_system_open_event,
-	.read =		acpi_system_read_event,
-	.release =	acpi_system_close_event,
-	.poll =		acpi_system_poll_event,
+	.open = acpi_system_open_event,
+	.read = acpi_system_read_event,
+	.release = acpi_system_close_event,
+	.poll = acpi_system_poll_event,
 };
 
 static int __init acpi_event_init(void)
 {
-	struct proc_dir_entry	*entry;
+	struct proc_dir_entry *entry;
 	int error = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_event_init");
@@ -124,8 +123,9 @@ static int __init acpi_event_init(void)
 	if (entry)
 		entry->proc_fops = &acpi_system_event_ops;
 	else {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-				  "Unable to create '%s' proc fs entry\n","event" ));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Unable to create '%s' proc fs entry\n",
+				  "event"));
 		error = -EFAULT;
 	}
 	return_VALUE(error);

commit c65ade4dc8b486e8c8b9b0a6399789a5428e2039
Author: Pavel Machek <pavel@suze.cz>
Date:   Fri Aug 5 00:37:45 2005 -0400

    [ACPI] whitespace
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 43c49f66a328..ce8d3eec3911 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -24,27 +24,23 @@ extern wait_queue_head_t	acpi_bus_event_queue;
 static int
 acpi_system_open_event(struct inode *inode, struct file *file)
 {
-	spin_lock_irq (&acpi_system_event_lock);
+	spin_lock_irq(&acpi_system_event_lock);
 
-	if(event_is_open)
+	if (event_is_open)
 		goto out_busy;
 
 	event_is_open = 1;
 
-	spin_unlock_irq (&acpi_system_event_lock);
+	spin_unlock_irq(&acpi_system_event_lock);
 	return 0;
 
 out_busy:
-	spin_unlock_irq (&acpi_system_event_lock);
+	spin_unlock_irq(&acpi_system_event_lock);
 	return -EBUSY;
 }
 
 static ssize_t
-acpi_system_read_event (
-	struct file		*file,
-	char			__user *buffer,
-	size_t			count,
-	loff_t			*ppos)
+acpi_system_read_event(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
 {
 	int			result = 0;
 	struct acpi_bus_event	event;
@@ -98,9 +94,7 @@ acpi_system_close_event(struct inode *inode, struct file *file)
 }
 
 static unsigned int
-acpi_system_poll_event(
-	struct file		*file,
-	poll_table		*wait)
+acpi_system_poll_event(struct file *file, poll_table *wait)
 {
 	poll_wait(file, &acpi_bus_event_queue, wait);
 	if (!list_empty(&acpi_bus_event_list))

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
new file mode 100644
index 000000000000..43c49f66a328
--- /dev/null
+++ b/drivers/acpi/event.c
@@ -0,0 +1,140 @@
+/*
+ * event.c - exporting ACPI events via procfs
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ */
+
+#include <linux/spinlock.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <acpi/acpi_drivers.h>
+
+#define _COMPONENT		ACPI_SYSTEM_COMPONENT
+ACPI_MODULE_NAME		("event")
+
+/* Global vars for handling event proc entry */
+static DEFINE_SPINLOCK(acpi_system_event_lock);
+int				event_is_open = 0;
+extern struct list_head		acpi_bus_event_list;
+extern wait_queue_head_t	acpi_bus_event_queue;
+
+static int
+acpi_system_open_event(struct inode *inode, struct file *file)
+{
+	spin_lock_irq (&acpi_system_event_lock);
+
+	if(event_is_open)
+		goto out_busy;
+
+	event_is_open = 1;
+
+	spin_unlock_irq (&acpi_system_event_lock);
+	return 0;
+
+out_busy:
+	spin_unlock_irq (&acpi_system_event_lock);
+	return -EBUSY;
+}
+
+static ssize_t
+acpi_system_read_event (
+	struct file		*file,
+	char			__user *buffer,
+	size_t			count,
+	loff_t			*ppos)
+{
+	int			result = 0;
+	struct acpi_bus_event	event;
+	static char		str[ACPI_MAX_STRING];
+	static int		chars_remaining = 0;
+	static char		*ptr;
+
+
+	ACPI_FUNCTION_TRACE("acpi_system_read_event");
+
+	if (!chars_remaining) {
+		memset(&event, 0, sizeof(struct acpi_bus_event));
+
+		if ((file->f_flags & O_NONBLOCK)
+		    && (list_empty(&acpi_bus_event_list)))
+			return_VALUE(-EAGAIN);
+
+		result = acpi_bus_receive_event(&event);
+		if (result) {
+			return_VALUE(-EIO);
+		}
+
+		chars_remaining = sprintf(str, "%s %s %08x %08x\n", 
+			event.device_class?event.device_class:"<unknown>",
+			event.bus_id?event.bus_id:"<unknown>", 
+			event.type, event.data);
+		ptr = str;
+	}
+
+	if (chars_remaining < count) {
+		count = chars_remaining;
+	}
+
+	if (copy_to_user(buffer, ptr, count))
+		return_VALUE(-EFAULT);
+
+	*ppos += count;
+	chars_remaining -= count;
+	ptr += count;
+
+	return_VALUE(count);
+}
+
+static int
+acpi_system_close_event(struct inode *inode, struct file *file)
+{
+	spin_lock_irq (&acpi_system_event_lock);
+	event_is_open = 0;
+	spin_unlock_irq (&acpi_system_event_lock);
+	return 0;
+}
+
+static unsigned int
+acpi_system_poll_event(
+	struct file		*file,
+	poll_table		*wait)
+{
+	poll_wait(file, &acpi_bus_event_queue, wait);
+	if (!list_empty(&acpi_bus_event_list))
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+static struct file_operations acpi_system_event_ops = {
+	.open =		acpi_system_open_event,
+	.read =		acpi_system_read_event,
+	.release =	acpi_system_close_event,
+	.poll =		acpi_system_poll_event,
+};
+
+static int __init acpi_event_init(void)
+{
+	struct proc_dir_entry	*entry;
+	int error = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_event_init");
+
+	if (acpi_disabled)
+		return_VALUE(0);
+
+	/* 'event' [R] */
+	entry = create_proc_entry("event", S_IRUSR, acpi_root_dir);
+	if (entry)
+		entry->proc_fops = &acpi_system_event_ops;
+	else {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+				  "Unable to create '%s' proc fs entry\n","event" ));
+		error = -EFAULT;
+	}
+	return_VALUE(error);
+}
+
+subsys_initcall(acpi_event_init);
