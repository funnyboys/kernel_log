commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/acpi_pnp.c b/drivers/acpi/acpi_pnp.c
index 67d97c0090a2..f3039b93ff61 100644
--- a/drivers/acpi/acpi_pnp.c
+++ b/drivers/acpi/acpi_pnp.c
@@ -1,13 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * ACPI support for PNP bus type
  *
  * Copyright (C) 2014, Intel Corporation
  * Authors: Zhang Rui <rui.zhang@intel.com>
  *          Rafael J. Wysocki <rafael.j.wysocki@intel.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/acpi.h>

commit 38a234b9f08883bbcb475b798e0a3d6b44bd37d7
Author: Mathias Krause <minipli@googlemail.com>
Date:   Sat Jan 2 11:30:09 2016 +0100

    ACPI / PNP: constify device IDs
    
    Instead of re-creating the array on the stack each time
    is_cmos_rtc_device() gets called, make the array 'static const'.
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_pnp.c b/drivers/acpi/acpi_pnp.c
index 48fc3ad13a4b..67d97c0090a2 100644
--- a/drivers/acpi/acpi_pnp.c
+++ b/drivers/acpi/acpi_pnp.c
@@ -367,7 +367,7 @@ static struct acpi_scan_handler acpi_pnp_handler = {
  */
 static int is_cmos_rtc_device(struct acpi_device *adev)
 {
-	struct acpi_device_id ids[] = {
+	static const struct acpi_device_id ids[] = {
 		{ "PNP0B00" },
 		{ "PNP0B01" },
 		{ "PNP0B02" },

commit 636c19d38920caee61d694ef306d110d33935038
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Sep 9 23:59:41 2015 +0200

    ACPI / scan: constify first argument of struct acpi_scan_handler::match
    
    One wouldn't expect a "match" function modify the string it searches
    for, and indeed the only instance of the struct
    acpi_scan_handler::match callback, acpi_pnp_match, can easily be
    changed. While there, update its helper matching_id().
    
    This is also preparation for constifying struct acpi_hardware_id::id.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_pnp.c b/drivers/acpi/acpi_pnp.c
index c58940b231d6..48fc3ad13a4b 100644
--- a/drivers/acpi/acpi_pnp.c
+++ b/drivers/acpi/acpi_pnp.c
@@ -316,7 +316,7 @@ static const struct acpi_device_id acpi_pnp_device_ids[] = {
 	{""},
 };
 
-static bool matching_id(char *idstr, char *list_id)
+static bool matching_id(const char *idstr, const char *list_id)
 {
 	int i;
 
@@ -333,7 +333,7 @@ static bool matching_id(char *idstr, char *list_id)
 	return true;
 }
 
-static bool acpi_pnp_match(char *idstr, const struct acpi_device_id **matchid)
+static bool acpi_pnp_match(const char *idstr, const struct acpi_device_id **matchid)
 {
 	const struct acpi_device_id *devid;
 

commit 0fbcf4af7c8362d4691f9388efa57d0b14b34225
Author: Corey Minyard <cminyard@mvista.com>
Date:   Tue Jun 9 16:51:46 2015 -0500

    ipmi: Convert the IPMI SI ACPI handling to a platform device
    
    The IPMI SI driver was using direct PNP, but that was not really
    ideal because the IPMI device is a platform device.  There was
    some special handling in the acpi_pnp.c code for making this work,
    but that was breaking ACPI handling for the IPMI SSIF driver.
    
    So without this patch there were significant issues getting the
    SSIF driver to work with ACPI.
    
    So use a platform device for ACPI detection and remove the
    entry from acpi_pnp.c.
    
    Signed-off-by: Corey Minyard <cminyard@mvista.com>

diff --git a/drivers/acpi/acpi_pnp.c b/drivers/acpi/acpi_pnp.c
index fb765524cc3d..c58940b231d6 100644
--- a/drivers/acpi/acpi_pnp.c
+++ b/drivers/acpi/acpi_pnp.c
@@ -19,8 +19,6 @@ static const struct acpi_device_id acpi_pnp_device_ids[] = {
 	{"PNP0600"},		/* Generic ESDI/IDE/ATA compatible hard disk controller */
 	/* floppy */
 	{"PNP0700"},
-	/* ipmi_si */
-	{"IPI0001"},
 	/* tpm_inf_pnp */
 	{"IFX0101"},		/* Infineon TPMs */
 	{"IFX0102"},		/* Infineon TPMs */

commit 1d7002777a8fe8188caaa98d4a8eb4ed298fcdae
Author: Maciej S. Szmigiero <mail@maciej.szmigiero.name>
Date:   Sun Aug 2 23:15:05 2015 +0200

    serial: 8250: bind to ALi Fast Infrared Controller (ALI5123)
    
    This way this device can be used with irtty-sir -
    at least on Toshiba Satellite A20-S103 it is not configured by default
    and needs PNP activation before it starts to respond on I/O ports.
    
    This device has actually its own driver (ali-ircc),
    but this driver seems to be non-functional for a very long time
    (see http://permalink.gmane.org/gmane.linux.irda.general/484
    http://permalink.gmane.org/gmane.network.protocols.obex.openobex.user/943
    https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=535070 ).
    
    Signed-off-by: Maciej Szmigiero <mail@maciej.szmigiero.name>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/acpi_pnp.c b/drivers/acpi/acpi_pnp.c
index ff6d8adc9cda..fb765524cc3d 100644
--- a/drivers/acpi/acpi_pnp.c
+++ b/drivers/acpi/acpi_pnp.c
@@ -153,6 +153,7 @@ static const struct acpi_device_id acpi_pnp_device_ids[] = {
 	{"AEI0250"},		/* PROLiNK 1456VH ISA PnP K56flex Fax Modem */
 	{"AEI1240"},		/* Actiontec ISA PNP 56K X2 Fax Modem */
 	{"AKY1021"},		/* Rockwell 56K ACF II Fax+Data+Voice Modem */
+	{"ALI5123"},		/* ALi Fast Infrared Controller */
 	{"AZT4001"},		/* AZT3005 PnP SOUND DEVICE */
 	{"BDP3336"},		/* Best Data Products Inc. Smart One 336F PnP Modem */
 	{"BRI0A49"},		/* Boca Complete Ofc Communicator 14.4 Data-FAX */

commit 622532bb2fad8fe342fb685727ae0be566f6be5d
Author: Witold Szczeponik <Witold.Szczeponik@gmx.net>
Date:   Fri May 1 19:05:20 2015 +0200

    ACPI / PNP: add two IDs to list for PNPACPI device enumeration
    
    Commit eec15edbb0e1 (ACPI / PNP: use device ID list for PNPACPI device
    enumeration) changed the way how ACPI devices are enumerated and when
    they are added to the PNP bus.
    
    However, it broke the sound card support on (at least) a vintage
    IBM ThinkPad 600E: with said commit applied, two of the necessary
    "CSC01xx" devices are not added to the PNP bus and hence can not be
    found during the initialization of the "snd-cs4236" module.  As a
    consequence, loading "snd-cs4236" causes null pointer exceptions.
    The attached patch fixes the problem end re-enables sound on the
    IBM ThinkPad 600E.
    
    Fixes: eec15edbb0e1 (ACPI / PNP: use device ID list for PNPACPI device enumeration)
    Signed-off-by: Witold Szczeponik <Witold.Szczeponik@gmx.net>
    Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_pnp.c b/drivers/acpi/acpi_pnp.c
index b193f8425999..ff6d8adc9cda 100644
--- a/drivers/acpi/acpi_pnp.c
+++ b/drivers/acpi/acpi_pnp.c
@@ -304,6 +304,8 @@ static const struct acpi_device_id acpi_pnp_device_ids[] = {
 	{"PNPb006"},
 	/* cs423x-pnpbios */
 	{"CSC0100"},
+	{"CSC0103"},
+	{"CSC0110"},
 	{"CSC0000"},
 	{"GIM0100"},		/* Guillemot Turtlebeach something appears to be cs4232 compatible */
 	/* es18xx-pnpbios */

commit b528392669415dc1e53a047215e5ad6c2de879fc
Merge: 80213c03c415 9f1a05329695
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 9 16:07:43 2014 -0400

    Merge tag 'pm+acpi-3.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "Features-wise, to me the most important this time is a rework of
      wakeup interrupts handling in the core that makes them work
      consistently across all of the available sleep states, including
      suspend-to-idle.  Many thanks to Thomas Gleixner for his help with
      this work.
    
      Second is an update of the generic PM domains code that has been in
      need of some care for quite a while.  Unused code is being removed, DT
      support is being added and domains are now going to be attached to
      devices in bus type code in analogy with the ACPI PM domain.  The
      majority of work here was done by Ulf Hansson who also has been the
      most active developer this time.
    
      Apart from this we have a traditional ACPICA update, this time to
      upstream version 20140828 and a few ACPI wakeup interrupts handling
      patches on top of the general rework mentioned above.  There also are
      several cpufreq commits including renaming the cpufreq-cpu0 driver to
      cpufreq-dt, as this is what implements generic DT-based cpufreq
      support, and a new DT-based idle states infrastructure for cpuidle.
    
      In addition to that, the ACPI LPSS driver is updated, ACPI support for
      Apple machines is improved, a few bugs are fixed and a few cleanups
      are made all over.
    
      Finally, the Adaptive Voltage Scaling (AVS) subsystem now has a tree
      maintained by Kevin Hilman that will be merged through the PM tree.
    
      Numbers-wise, the generic PM domains update takes the lead this time
      with 32 non-merge commits, second is cpufreq (15 commits) and the 3rd
      place goes to the wakeup interrupts handling rework (13 commits).
    
      Specifics:
    
       - Rework the handling of wakeup IRQs by the IRQ core such that all of
         them will be switched over to "wakeup" mode in suspend_device_irqs()
         and in that mode the first interrupt will abort system suspend in
         progress or wake up the system if already in suspend-to-idle (or
         equivalent) without executing any interrupt handlers.  Among other
         things that eliminates the wakeup-related motivation to use the
         IRQF_NO_SUSPEND interrupt flag with interrupts which don't really
         need it and should not use it (Thomas Gleixner and Rafael Wysocki)
    
       - Switch over ACPI to handling wakeup interrupts with the help of the
         new mechanism introduced by the above IRQ core rework (Rafael Wysocki)
    
       - Rework the core generic PM domains code to eliminate code that's
         not used, add DT support and add a generic mechanism by which
         devices can be added to PM domains automatically during enumeration
         (Ulf Hansson, Geert Uytterhoeven and Tomasz Figa).
    
       - Add debugfs-based mechanics for debugging generic PM domains
         (Maciej Matraszek).
    
       - ACPICA update to upstream version 20140828.  Included are updates
         related to the SRAT and GTDT tables and the _PSx methods are in the
         METHOD_NAME list now (Bob Moore and Hanjun Guo).
    
       - Add _OSI("Darwin") support to the ACPI core (unfortunately, that
         can't really be done in a straightforward way) to prevent
         Thunderbolt from being turned off on Apple systems after boot (or
         after resume from system suspend) and rework the ACPI Smart Battery
         Subsystem (SBS) driver to work correctly with Apple platforms
         (Matthew Garrett and Andreas Noever).
    
       - ACPI LPSS (Low-Power Subsystem) driver update cleaning up the code,
         adding support for 133MHz I2C source clock on Intel Baytrail to it
         and making it avoid using UART RTS override with Auto Flow Control
         (Heikki Krogerus).
    
       - ACPI backlight updates removing the video_set_use_native_backlight
         quirk which is not necessary any more, making the code check the
         list of output devices returned by the _DOD method to avoid
         creating acpi_video interfaces that won't work and adding a quirk
         for Lenovo Ideapad Z570 (Hans de Goede, Aaron Lu and Stepan Bujnak)
    
       - New Win8 ACPI OSI quirks for some Dell laptops (Edward Lin)
    
       - Assorted ACPI code cleanups (Fabian Frederick, Rasmus Villemoes,
         Sudip Mukherjee, Yijing Wang, and Zhang Rui)
    
       - cpufreq core updates and cleanups (Viresh Kumar, Preeti U Murthy,
         Rasmus Villemoes)
    
       - cpufreq driver updates: cpufreq-cpu0/cpufreq-dt (driver name change
         among other things), ppc-corenet, powernv (Viresh Kumar, Preeti U
         Murthy, Shilpasri G Bhat, Lucas Stach)
    
       - cpuidle support for DT-based idle states infrastructure, new ARM64
         cpuidle driver, cpuidle core cleanups (Lorenzo Pieralisi, Rasmus
         Villemoes)
    
       - ARM big.LITTLE cpuidle driver updates: support for DT-based
         initialization and Exynos5800 compatible string (Lorenzo Pieralisi,
         Kevin Hilman)
    
       - Rework of the test_suspend kernel command line argument and a new
         trace event for console resume (Srinivas Pandruvada, Todd E Brandt)
    
       - Second attempt to optimize swsusp_free() (hibernation core) to make
         it avoid going through all PFNs which may be way too slow on some
         systems (Joerg Roedel)
    
       - devfreq updates (Paul Bolle, Punit Agrawal, Ãrjan Eide).
    
       - rockchip-io Adaptive Voltage Scaling (AVS) driver and AVS entry
         update in MAINTAINERS (Heiko Stübner, Kevin Hilman)
    
       - PM core fix related to clock management (Geert Uytterhoeven)
    
       - PM core's sysfs code cleanup (Johannes Berg)"
    
    * tag 'pm+acpi-3.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (105 commits)
      ACPI / fan: printk replacement
      PM / clk: Fix crash in clocks management code if !CONFIG_PM_RUNTIME
      PM / Domains: Rename cpu_data to cpuidle_data
      cpufreq: cpufreq-dt: fix potential double put of cpu OF node
      cpufreq: cpu0: rename driver and internals to 'cpufreq_dt'
      PM / hibernate: Iterate over set bits instead of PFNs in swsusp_free()
      cpufreq: ppc-corenet: remove duplicate update of cpu_data
      ACPI / sleep: Rework the handling of ACPI GPE wakeup from suspend-to-idle
      PM / sleep: Rename platform suspend/resume functions in suspend.c
      PM / sleep: Export dpm_suspend_late/noirq() and dpm_resume_early/noirq()
      ACPICA: Introduce acpi_enable_all_wakeup_gpes()
      ACPICA: Clear all non-wakeup GPEs in acpi_hw_enable_wakeup_gpe_block()
      ACPI / video: check _DOD list when creating backlight devices
      PM / Domains: Move dev_pm_domain_attach|detach() to pm_domain.h
      cpufreq: Replace strnicmp with strncasecmp
      cpufreq: powernv: Set the cpus to nominal frequency during reboot/kexec
      cpufreq: powernv: Set the pstate of the last hotplugged out cpu in policy->cpus to minimum
      cpufreq: Allow stop CPU callback to be used by all cpufreq drivers
      PM / devfreq: exynos: Enable building exynos PPMU as module
      PM / devfreq: Export helper functions for drivers
      ...

commit 042e1c79166b9250edd8262bea84e1703f27ad2e
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Mon Sep 22 10:31:14 2014 -0700

    Input: soc_button_array - convert to platform bus
    
    ACPI device enumeration mechanism changed a lot since 3.16-rc1.
    ACPI device objects with _HID will be enumerated to platform bus by default.
    For the existing PNP drivers that probe the PNPACPI devices, the device ids
    are listed explicitly in drivers/acpi/acpi_pnp.c.
    But ACPI folks will continue their effort on shrinking this id list by
    converting the PNP drivers to platform drivers, for the devices that don't
    belong to PNP bus in nature.
    
    Signed-off-by: Jin Yao <yao.jin@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/acpi/acpi_pnp.c b/drivers/acpi/acpi_pnp.c
index 996fa1959eea..1f8b20496f32 100644
--- a/drivers/acpi/acpi_pnp.c
+++ b/drivers/acpi/acpi_pnp.c
@@ -15,8 +15,6 @@
 #include <linux/ctype.h>
 
 static const struct acpi_device_id acpi_pnp_device_ids[] = {
-	/* soc_button_array */
-	{"PNP0C40"},
 	/* pata_isapnp */
 	{"PNP0600"},		/* Generic ESDI/IDE/ATA compatible hard disk controller */
 	/* floppy */

commit 4990141496b82f91cb96b37100ac882ea5cee8b7
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Sep 9 00:21:59 2014 +0200

    ACPI / PNP: remove Fujitsu device IDs from ACPI PNP ID list
    
    Fujitsu backlight and hotkey devices have ACPI drivers.
    
    The PNP MODULE_DEVICE_TABLE in fujitsu-laptop driver is just used as an
    indicator for module autoloading, but this is wrong because what we
    need is ACPI module device table instead, because the driver is probing
    ACPI devices.
    
    Thus remove those IDs from ACPI PNP scan handler list as we don't
    have a PNP driver for them, and convert the fujitsu-laptop PNP
    MODULE_DEVICE_TABLE to ACPI MODULE_DEVICE_TABLE.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=81971
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Tested-by: Dirk Griesbach <spamthis@freenet.de>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_pnp.c b/drivers/acpi/acpi_pnp.c
index 996fa1959eea..f30c40796856 100644
--- a/drivers/acpi/acpi_pnp.c
+++ b/drivers/acpi/acpi_pnp.c
@@ -132,10 +132,6 @@ static const struct acpi_device_id acpi_pnp_device_ids[] = {
 	{"PNP0401"},		/* ECP Printer Port */
 	/* apple-gmux */
 	{"APP000B"},
-	/* fujitsu-laptop.c */
-	{"FUJ02bf"},
-	{"FUJ02B1"},
-	{"FUJ02E3"},
 	/* system */
 	{"PNP0c02"},		/* General ID for reserving resources */
 	{"PNP0c01"},		/* memory controller */

commit a5f95da9fb2a0b228b3bab19d35850af3e9a74b2
Author: Arjun Sreedharan <arjun024@gmail.com>
Date:   Thu Jul 31 14:34:49 2014 +0530

    ACPI / PNP: Replace faulty is_hex_digit() by isxdigit()
    
    0 is ascii for NULL. Hex digit matching should be from '0'.
    Faulty version returns true for #,$,%,& etc.
    
    Signed-off-by: Arjun Sreedharan <arjun024@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_pnp.c b/drivers/acpi/acpi_pnp.c
index 4ddb0dca56f6..996fa1959eea 100644
--- a/drivers/acpi/acpi_pnp.c
+++ b/drivers/acpi/acpi_pnp.c
@@ -12,6 +12,7 @@
 
 #include <linux/acpi.h>
 #include <linux/module.h>
+#include <linux/ctype.h>
 
 static const struct acpi_device_id acpi_pnp_device_ids[] = {
 	/* soc_button_array */
@@ -320,11 +321,6 @@ static const struct acpi_device_id acpi_pnp_device_ids[] = {
 	{""},
 };
 
-static bool is_hex_digit(char c)
-{
-	return (c >= 0 && c <= '9') || (c >= 'A' && c <= 'F');
-}
-
 static bool matching_id(char *idstr, char *list_id)
 {
 	int i;
@@ -335,7 +331,7 @@ static bool matching_id(char *idstr, char *list_id)
 	for (i = 3; i < 7; i++) {
 		char c = toupper(idstr[i]);
 
-		if (!is_hex_digit(c)
+		if (!isxdigit(c)
 		    || (list_id[i] != 'X' && c != toupper(list_id[i])))
 			return false;
 	}

commit c128c776e0f45d3edaf44ab3fecfa5d1f7067c07
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Wed Jul 9 14:31:04 2014 +0200

    ACPI / PNP: add soc_button_array device ID to PNP IDs list
    
    The soc_button_array PNP driver was introduced in 3.15.
    But in commit eec15edbb0e1 (ACPI / PNP: use device ID list for
    PNPACPI device enumeration), when reworking the PNPACPI device
    enumeration, we missed the soc_button_array device ID.
    
    This results in a regression in 3.16-rc1 that soc_button_array
    pnp device fails to be enumerated.
    
    Fix the problem by adding soc_button_array device ID into the
    acpi_pnp scan handler's ID list.
    
    Fixes: eec15edbb0e1 (ACPI / PNP: use device ID list for PNPACPI device enumeration)
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_pnp.c b/drivers/acpi/acpi_pnp.c
index 6703c1fd993a..4ddb0dca56f6 100644
--- a/drivers/acpi/acpi_pnp.c
+++ b/drivers/acpi/acpi_pnp.c
@@ -14,6 +14,8 @@
 #include <linux/module.h>
 
 static const struct acpi_device_id acpi_pnp_device_ids[] = {
+	/* soc_button_array */
+	{"PNP0C40"},
 	/* pata_isapnp */
 	{"PNP0600"},		/* Generic ESDI/IDE/ATA compatible hard disk controller */
 	/* floppy */

commit 01cd4bac8ce433f125b772e3964886fc12e108c7
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri May 30 04:25:15 2014 +0200

    ACPI / scan: drop unsupported serial IDs from PNP ACPI scan handler ID list
    
    The "serial" PNP driver supports some "unknown" PNP modems
    (PNPCXXX/PNPDXXX) by matching magic strings in the PNP device name
    or the PNP device card name.
    
    ACPI enumerated PNP devices neither are PNP cards, nor have those
    magic strings in device names, so this mechamism never actually works
    for ACPI enumerated PNPCXXX/PNPDXXX devices.
    
    Consequently, it is safe to remove those two IDs from the PNP ACPI scan
    handler's device ID list.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    [rjw: Subject and changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/acpi_pnp.c b/drivers/acpi/acpi_pnp.c
index 895c45d8d25a..6703c1fd993a 100644
--- a/drivers/acpi/acpi_pnp.c
+++ b/drivers/acpi/acpi_pnp.c
@@ -301,8 +301,6 @@ static const struct acpi_device_id acpi_pnp_device_ids[] = {
 	{"LTS0001"},		/* LG C1 EXPRESS DUAL (C1-PB11A3) touch screen (actually a FUJ02E6 in disguise) */
 	{"WCI0003"},		/* Rockwell's (PORALiNK) 33600 INT PNP */
 	{"WEC1022"},		/* Winbond CIR port, should not be probed. We should keep track of it to prevent the legacy serial driver from probing it */
-	{"PNPCXXX"},		/* Unknown PnP modems */
-	{"PNPDXXX"},		/* More unknown PnP modems */
 	/* scl200wdt */
 	{"NSC0800"},		/* National Semiconductor PC87307/PC97307 watchdog component */
 	/* mpu401 */

commit e1d2c4cf0bfa6a9b484ebcb2ce99c5f38d05c680
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri May 30 04:24:04 2014 +0200

    ACPI / scan: drop IDs that do not comply with the ACPI PNP ID rule
    
    The PNP ACPI scan handler device ID list includes all the IDs from
    all of the struct pnp_device_id instances in the tree, but some of
    them do not follow the ACPI PNP ID rule (3 letters + 4 hex digits).
    
    For those IDs, the coressponding devices will never be enumerated
    via ACPI, so it is safe to remove them from the PNP ACPI ID list.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    [rjw: Subject and changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/acpi_pnp.c b/drivers/acpi/acpi_pnp.c
index 567e7fc6330c..895c45d8d25a 100644
--- a/drivers/acpi/acpi_pnp.c
+++ b/drivers/acpi/acpi_pnp.c
@@ -34,10 +34,6 @@ static const struct acpi_device_id acpi_pnp_device_ids[] = {
 	/* ide   */
 	{"PNP0600"},		/* Generic ESDI/IDE/ATA compatible hard disk controller */
 	/* ns558 */
-	{"@P@0001"},		/* ALS 100 */
-	{"@P@0020"},		/* ALS 200 */
-	{"@P@1001"},		/* ALS 100+ */
-	{"@P@2001"},		/* ALS 120 */
 	{"ASB16fd"},		/* AdLib NSC16 */
 	{"AZT3001"},		/* AZT1008 */
 	{"CDC0001"},		/* Opl3-SAx */

commit eec15edbb0e14485998635ea7c62e30911b465f0
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri May 30 04:23:01 2014 +0200

    ACPI / PNP: use device ID list for PNPACPI device enumeration
    
    ACPI can be used to enumerate PNP devices, but the code does not
    handle this in the right way currently.  Namely, if an ACPI device
    object
     1. Has a _CRS method,
     2. Has an identification of
        "three capital characters followed by four hex digits",
     3. Is not in the excluded IDs list,
    it will be enumerated to PNP bus (that is, a PNP device object will
    be create for it).  This means that, actually, the PNP bus type is
    used as the default bus type for enumerating _HID devices in ACPI.
    
    However, more and more _HID devices need to be enumerated to the
    platform bus instead (that is, platform device objects need to be
    created for them).  As a result, the device ID list in acpi_platform.c
    is used to enforce creating platform device objects rather than PNP
    device objects for matching devices.  That list has been continuously
    growing recently, unfortunately, and it is pretty much guaranteed to
    grow even more in the future.
    
    To address that problem it is better to enumerate _HID devices
    as platform devices by default.  To this end, change the way of
    enumerating PNP devices by adding a PNP ACPI scan handler that
    will use a device ID list to create PNP devices for the ACPI
    device objects whose device IDs are present in that list.
    
    The initial device ID list in the PNP ACPI scan handler contains
    all of the pnp_device_id strings from all the existing PNP drivers,
    so this change should be transparent to the PNP core and all of the
    PNP drivers.  Still, in the future it should be possible to reduce
    its size by converting PNP drivers that need not be PNP for any
    technical reasons into platform drivers.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    [rjw: Rewrote the changelog, modified the PNP ACPI scan handler code]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/acpi_pnp.c b/drivers/acpi/acpi_pnp.c
new file mode 100644
index 000000000000..567e7fc6330c
--- /dev/null
+++ b/drivers/acpi/acpi_pnp.c
@@ -0,0 +1,401 @@
+/*
+ * ACPI support for PNP bus type
+ *
+ * Copyright (C) 2014, Intel Corporation
+ * Authors: Zhang Rui <rui.zhang@intel.com>
+ *          Rafael J. Wysocki <rafael.j.wysocki@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/acpi.h>
+#include <linux/module.h>
+
+static const struct acpi_device_id acpi_pnp_device_ids[] = {
+	/* pata_isapnp */
+	{"PNP0600"},		/* Generic ESDI/IDE/ATA compatible hard disk controller */
+	/* floppy */
+	{"PNP0700"},
+	/* ipmi_si */
+	{"IPI0001"},
+	/* tpm_inf_pnp */
+	{"IFX0101"},		/* Infineon TPMs */
+	{"IFX0102"},		/* Infineon TPMs */
+	/*tpm_tis */
+	{"PNP0C31"},		/* TPM */
+	{"ATM1200"},		/* Atmel */
+	{"IFX0102"},		/* Infineon */
+	{"BCM0101"},		/* Broadcom */
+	{"BCM0102"},		/* Broadcom */
+	{"NSC1200"},		/* National */
+	{"ICO0102"},		/* Intel */
+	/* ide   */
+	{"PNP0600"},		/* Generic ESDI/IDE/ATA compatible hard disk controller */
+	/* ns558 */
+	{"@P@0001"},		/* ALS 100 */
+	{"@P@0020"},		/* ALS 200 */
+	{"@P@1001"},		/* ALS 100+ */
+	{"@P@2001"},		/* ALS 120 */
+	{"ASB16fd"},		/* AdLib NSC16 */
+	{"AZT3001"},		/* AZT1008 */
+	{"CDC0001"},		/* Opl3-SAx */
+	{"CSC0001"},		/* CS4232 */
+	{"CSC000f"},		/* CS4236 */
+	{"CSC0101"},		/* CS4327 */
+	{"CTL7001"},		/* SB16 */
+	{"CTL7002"},		/* AWE64 */
+	{"CTL7005"},		/* Vibra16 */
+	{"ENS2020"},		/* SoundscapeVIVO */
+	{"ESS0001"},		/* ES1869 */
+	{"ESS0005"},		/* ES1878 */
+	{"ESS6880"},		/* ES688 */
+	{"IBM0012"},		/* CS4232 */
+	{"OPT0001"},		/* OPTi Audio16 */
+	{"YMH0006"},		/* Opl3-SA */
+	{"YMH0022"},		/* Opl3-SAx */
+	{"PNPb02f"},		/* Generic */
+	/* i8042 kbd */
+	{"PNP0300"},
+	{"PNP0301"},
+	{"PNP0302"},
+	{"PNP0303"},
+	{"PNP0304"},
+	{"PNP0305"},
+	{"PNP0306"},
+	{"PNP0309"},
+	{"PNP030a"},
+	{"PNP030b"},
+	{"PNP0320"},
+	{"PNP0343"},
+	{"PNP0344"},
+	{"PNP0345"},
+	{"CPQA0D7"},
+	/* i8042 aux */
+	{"AUI0200"},
+	{"FJC6000"},
+	{"FJC6001"},
+	{"PNP0f03"},
+	{"PNP0f0b"},
+	{"PNP0f0e"},
+	{"PNP0f12"},
+	{"PNP0f13"},
+	{"PNP0f19"},
+	{"PNP0f1c"},
+	{"SYN0801"},
+	/* fcpnp */
+	{"AVM0900"},
+	/* radio-cadet */
+	{"MSM0c24"},		/* ADS Cadet AM/FM Radio Card */
+	/* radio-gemtek */
+	{"ADS7183"},		/* AOpen FX-3D/Pro Radio */
+	/* radio-sf16fmr2 */
+	{"MFRad13"},		/* tuner subdevice of SF16-FMD2 */
+	/* ene_ir */
+	{"ENE0100"},
+	{"ENE0200"},
+	{"ENE0201"},
+	{"ENE0202"},
+	/* fintek-cir */
+	{"FIT0002"},		/* CIR */
+	/* ite-cir */
+	{"ITE8704"},		/* Default model */
+	{"ITE8713"},		/* CIR found in EEEBox 1501U */
+	{"ITE8708"},		/* Bridged IT8512 */
+	{"ITE8709"},		/* SRAM-Bridged IT8512 */
+	/* nuvoton-cir */
+	{"WEC0530"},		/* CIR */
+	{"NTN0530"},		/* CIR for new chip's pnp id */
+	/* Winbond CIR */
+	{"WEC1022"},
+	/* wbsd */
+	{"WEC0517"},
+	{"WEC0518"},
+	/* Winbond CIR */
+	{"TCM5090"},		/* 3Com Etherlink III (TP) */
+	{"TCM5091"},		/* 3Com Etherlink III */
+	{"TCM5094"},		/* 3Com Etherlink III (combo) */
+	{"TCM5095"},		/* 3Com Etherlink III (TPO) */
+	{"TCM5098"},		/* 3Com Etherlink III (TPC) */
+	{"PNP80f7"},		/* 3Com Etherlink III compatible */
+	{"PNP80f8"},		/* 3Com Etherlink III compatible */
+	/* nsc-ircc */
+	{"NSC6001"},
+	{"HWPC224"},
+	{"IBM0071"},
+	/* smsc-ircc2 */
+	{"SMCf010"},
+	/* sb1000 */
+	{"GIC1000"},
+	/* parport_pc */
+	{"PNP0400"},		/* Standard LPT Printer Port */
+	{"PNP0401"},		/* ECP Printer Port */
+	/* apple-gmux */
+	{"APP000B"},
+	/* fujitsu-laptop.c */
+	{"FUJ02bf"},
+	{"FUJ02B1"},
+	{"FUJ02E3"},
+	/* system */
+	{"PNP0c02"},		/* General ID for reserving resources */
+	{"PNP0c01"},		/* memory controller */
+	/* rtc_cmos */
+	{"PNP0b00"},
+	{"PNP0b01"},
+	{"PNP0b02"},
+	/* c6xdigio */
+	{"PNP0400"},		/* Standard LPT Printer Port */
+	{"PNP0401"},		/* ECP Printer Port */
+	/* ni_atmio.c */
+	{"NIC1900"},
+	{"NIC2400"},
+	{"NIC2500"},
+	{"NIC2600"},
+	{"NIC2700"},
+	/* serial */
+	{"AAC000F"},		/* Archtek America Corp. Archtek SmartLink Modem 3334BT Plug & Play */
+	{"ADC0001"},		/* Anchor Datacomm BV. SXPro 144 External Data Fax Modem Plug & Play */
+	{"ADC0002"},		/* SXPro 288 External Data Fax Modem Plug & Play */
+	{"AEI0250"},		/* PROLiNK 1456VH ISA PnP K56flex Fax Modem */
+	{"AEI1240"},		/* Actiontec ISA PNP 56K X2 Fax Modem */
+	{"AKY1021"},		/* Rockwell 56K ACF II Fax+Data+Voice Modem */
+	{"AZT4001"},		/* AZT3005 PnP SOUND DEVICE */
+	{"BDP3336"},		/* Best Data Products Inc. Smart One 336F PnP Modem */
+	{"BRI0A49"},		/* Boca Complete Ofc Communicator 14.4 Data-FAX */
+	{"BRI1400"},		/* Boca Research 33,600 ACF Modem */
+	{"BRI3400"},		/* Boca 33.6 Kbps Internal FD34FSVD */
+	{"BRI0A49"},		/* Boca 33.6 Kbps Internal FD34FSVD */
+	{"BDP3336"},		/* Best Data Products Inc. Smart One 336F PnP Modem */
+	{"CPI4050"},		/* Computer Peripherals Inc. EuroViVa CommCenter-33.6 SP PnP */
+	{"CTL3001"},		/* Creative Labs Phone Blaster 28.8 DSVD PnP Voice */
+	{"CTL3011"},		/* Creative Labs Modem Blaster 28.8 DSVD PnP Voice */
+	{"DAV0336"},		/* Davicom ISA 33.6K Modem */
+	{"DMB1032"},		/* Creative Modem Blaster Flash56 DI5601-1 */
+	{"DMB2001"},		/* Creative Modem Blaster V.90 DI5660 */
+	{"ETT0002"},		/* E-Tech CyberBULLET PC56RVP */
+	{"FUJ0202"},		/* Fujitsu 33600 PnP-I2 R Plug & Play */
+	{"FUJ0205"},		/* Fujitsu FMV-FX431 Plug & Play */
+	{"FUJ0206"},		/* Fujitsu 33600 PnP-I4 R Plug & Play */
+	{"FUJ0209"},		/* Fujitsu Fax Voice 33600 PNP-I5 R Plug & Play */
+	{"GVC000F"},		/* Archtek SmartLink Modem 3334BT Plug & Play */
+	{"GVC0303"},		/* Archtek SmartLink Modem 3334BRV 33.6K Data Fax Voice */
+	{"HAY0001"},		/* Hayes Optima 288 V.34-V.FC + FAX + Voice Plug & Play */
+	{"HAY000C"},		/* Hayes Optima 336 V.34 + FAX + Voice PnP */
+	{"HAY000D"},		/* Hayes Optima 336B V.34 + FAX + Voice PnP */
+	{"HAY5670"},		/* Hayes Accura 56K Ext Fax Modem PnP */
+	{"HAY5674"},		/* Hayes Accura 56K Ext Fax Modem PnP */
+	{"HAY5675"},		/* Hayes Accura 56K Fax Modem PnP */
+	{"HAYF000"},		/* Hayes 288, V.34 + FAX */
+	{"HAYF001"},		/* Hayes Optima 288 V.34 + FAX + Voice, Plug & Play */
+	{"IBM0033"},		/* IBM Thinkpad 701 Internal Modem Voice */
+	{"PNP4972"},		/* Intermec CV60 touchscreen port */
+	{"IXDC801"},		/* Intertex 28k8 33k6 Voice EXT PnP */
+	{"IXDC901"},		/* Intertex 33k6 56k Voice EXT PnP */
+	{"IXDD801"},		/* Intertex 28k8 33k6 Voice SP EXT PnP */
+	{"IXDD901"},		/* Intertex 33k6 56k Voice SP EXT PnP */
+	{"IXDF401"},		/* Intertex 28k8 33k6 Voice SP INT PnP */
+	{"IXDF801"},		/* Intertex 28k8 33k6 Voice SP EXT PnP */
+	{"IXDF901"},		/* Intertex 33k6 56k Voice SP EXT PnP */
+	{"KOR4522"},		/* KORTEX 28800 Externe PnP */
+	{"KORF661"},		/* KXPro 33.6 Vocal ASVD PnP */
+	{"LAS4040"},		/* LASAT Internet 33600 PnP */
+	{"LAS4540"},		/* Lasat Safire 560 PnP */
+	{"LAS5440"},		/* Lasat Safire 336  PnP */
+	{"MNP0281"},		/* Microcom TravelPorte FAST V.34 Plug & Play */
+	{"MNP0336"},		/* Microcom DeskPorte V.34 FAST or FAST+ Plug & Play */
+	{"MNP0339"},		/* Microcom DeskPorte FAST EP 28.8 Plug & Play */
+	{"MNP0342"},		/* Microcom DeskPorte 28.8P Plug & Play */
+	{"MNP0500"},		/* Microcom DeskPorte FAST ES 28.8 Plug & Play */
+	{"MNP0501"},		/* Microcom DeskPorte FAST ES 28.8 Plug & Play */
+	{"MNP0502"},		/* Microcom DeskPorte 28.8S Internal Plug & Play */
+	{"MOT1105"},		/* Motorola BitSURFR Plug & Play */
+	{"MOT1111"},		/* Motorola TA210 Plug & Play */
+	{"MOT1114"},		/* Motorola HMTA 200 (ISDN) Plug & Play */
+	{"MOT1115"},		/* Motorola BitSURFR Plug & Play */
+	{"MOT1190"},		/* Motorola Lifestyle 28.8 Internal */
+	{"MOT1501"},		/* Motorola V.3400 Plug & Play */
+	{"MOT1502"},		/* Motorola Lifestyle 28.8 V.34 Plug & Play */
+	{"MOT1505"},		/* Motorola Power 28.8 V.34 Plug & Play */
+	{"MOT1509"},		/* Motorola ModemSURFR External 28.8 Plug & Play */
+	{"MOT150A"},		/* Motorola Premier 33.6 Desktop Plug & Play */
+	{"MOT150F"},		/* Motorola VoiceSURFR 56K External PnP */
+	{"MOT1510"},		/* Motorola ModemSURFR 56K External PnP */
+	{"MOT1550"},		/* Motorola ModemSURFR 56K Internal PnP */
+	{"MOT1560"},		/* Motorola ModemSURFR Internal 28.8 Plug & Play */
+	{"MOT1580"},		/* Motorola Premier 33.6 Internal Plug & Play */
+	{"MOT15B0"},		/* Motorola OnlineSURFR 28.8 Internal Plug & Play */
+	{"MOT15F0"},		/* Motorola VoiceSURFR 56K Internal PnP */
+	{"MVX00A1"},		/*  Deskline K56 Phone System PnP */
+	{"MVX00F2"},		/* PC Rider K56 Phone System PnP */
+	{"nEC8241"},		/* NEC 98NOTE SPEAKER PHONE FAX MODEM(33600bps) */
+	{"PMC2430"},		/* Pace 56 Voice Internal Plug & Play Modem */
+	{"PNP0500"},		/* Generic standard PC COM port     */
+	{"PNP0501"},		/* Generic 16550A-compatible COM port */
+	{"PNPC000"},		/* Compaq 14400 Modem */
+	{"PNPC001"},		/* Compaq 2400/9600 Modem */
+	{"PNPC031"},		/* Dial-Up Networking Serial Cable between 2 PCs */
+	{"PNPC032"},		/* Dial-Up Networking Parallel Cable between 2 PCs */
+	{"PNPC100"},		/* Standard 9600 bps Modem */
+	{"PNPC101"},		/* Standard 14400 bps Modem */
+	{"PNPC102"},		/*  Standard 28800 bps Modem */
+	{"PNPC103"},		/*  Standard Modem */
+	{"PNPC104"},		/*  Standard 9600 bps Modem */
+	{"PNPC105"},		/*  Standard 14400 bps Modem */
+	{"PNPC106"},		/*  Standard 28800 bps Modem */
+	{"PNPC107"},		/*  Standard Modem */
+	{"PNPC108"},		/* Standard 9600 bps Modem */
+	{"PNPC109"},		/* Standard 14400 bps Modem */
+	{"PNPC10A"},		/* Standard 28800 bps Modem */
+	{"PNPC10B"},		/* Standard Modem */
+	{"PNPC10C"},		/* Standard 9600 bps Modem */
+	{"PNPC10D"},		/* Standard 14400 bps Modem */
+	{"PNPC10E"},		/* Standard 28800 bps Modem */
+	{"PNPC10F"},		/* Standard Modem */
+	{"PNP2000"},		/* Standard PCMCIA Card Modem */
+	{"ROK0030"},		/* Rockwell 33.6 DPF Internal PnP, Modular Technology 33.6 Internal PnP */
+	{"ROK0100"},		/* KORTEX 14400 Externe PnP */
+	{"ROK4120"},		/* Rockwell 28.8 */
+	{"ROK4920"},		/* Viking 28.8 INTERNAL Fax+Data+Voice PnP */
+	{"RSS00A0"},		/* Rockwell 33.6 DPF External PnP, BT Prologue 33.6 External PnP, Modular Technology 33.6 External PnP */
+	{"RSS0262"},		/* Viking 56K FAX INT */
+	{"RSS0250"},		/* K56 par,VV,Voice,Speakphone,AudioSpan,PnP */
+	{"SUP1310"},		/* SupraExpress 28.8 Data/Fax PnP modem */
+	{"SUP1381"},		/* SupraExpress 336i PnP Voice Modem */
+	{"SUP1421"},		/* SupraExpress 33.6 Data/Fax PnP modem */
+	{"SUP1590"},		/* SupraExpress 33.6 Data/Fax PnP modem */
+	{"SUP1620"},		/* SupraExpress 336i Sp ASVD */
+	{"SUP1760"},		/* SupraExpress 33.6 Data/Fax PnP modem */
+	{"SUP2171"},		/* SupraExpress 56i Sp Intl */
+	{"TEX0011"},		/* Phoebe Micro 33.6 Data Fax 1433VQH Plug & Play */
+	{"UAC000F"},		/* Archtek SmartLink Modem 3334BT Plug & Play */
+	{"USR0000"},		/* 3Com Corp. Gateway Telepath IIvi 33.6 */
+	{"USR0002"},		/* U.S. Robotics Sporster 33.6K Fax INT PnP */
+	{"USR0004"},		/*  Sportster Vi 14.4 PnP FAX Voicemail */
+	{"USR0006"},		/* U.S. Robotics 33.6K Voice INT PnP */
+	{"USR0007"},		/* U.S. Robotics 33.6K Voice EXT PnP */
+	{"USR0009"},		/* U.S. Robotics Courier V.Everything INT PnP */
+	{"USR2002"},		/* U.S. Robotics 33.6K Voice INT PnP */
+	{"USR2070"},		/* U.S. Robotics 56K Voice INT PnP */
+	{"USR2080"},		/* U.S. Robotics 56K Voice EXT PnP */
+	{"USR3031"},		/* U.S. Robotics 56K FAX INT */
+	{"USR3050"},		/* U.S. Robotics 56K FAX INT */
+	{"USR3070"},		/* U.S. Robotics 56K Voice INT PnP */
+	{"USR3080"},		/* U.S. Robotics 56K Voice EXT PnP */
+	{"USR3090"},		/* U.S. Robotics 56K Voice INT PnP */
+	{"USR9100"},		/* U.S. Robotics 56K Message  */
+	{"USR9160"},		/* U.S. Robotics 56K FAX EXT PnP */
+	{"USR9170"},		/* U.S. Robotics 56K FAX INT PnP */
+	{"USR9180"},		/* U.S. Robotics 56K Voice EXT PnP */
+	{"USR9190"},		/* U.S. Robotics 56K Voice INT PnP */
+	{"WACFXXX"},		/* Wacom tablets */
+	{"FPI2002"},		/* Compaq touchscreen */
+	{"FUJ02B2"},		/* Fujitsu Stylistic touchscreens */
+	{"FUJ02B3"},
+	{"FUJ02B4"},		/* Fujitsu Stylistic LT touchscreens */
+	{"FUJ02B6"},		/* Passive Fujitsu Stylistic touchscreens */
+	{"FUJ02B7"},
+	{"FUJ02B8"},
+	{"FUJ02B9"},
+	{"FUJ02BC"},
+	{"FUJ02E5"},		/* Fujitsu Wacom Tablet PC device */
+	{"FUJ02E6"},		/* Fujitsu P-series tablet PC device */
+	{"FUJ02E7"},		/* Fujitsu Wacom 2FGT Tablet PC device */
+	{"FUJ02E9"},		/* Fujitsu Wacom 1FGT Tablet PC device */
+	{"LTS0001"},		/* LG C1 EXPRESS DUAL (C1-PB11A3) touch screen (actually a FUJ02E6 in disguise) */
+	{"WCI0003"},		/* Rockwell's (PORALiNK) 33600 INT PNP */
+	{"WEC1022"},		/* Winbond CIR port, should not be probed. We should keep track of it to prevent the legacy serial driver from probing it */
+	{"PNPCXXX"},		/* Unknown PnP modems */
+	{"PNPDXXX"},		/* More unknown PnP modems */
+	/* scl200wdt */
+	{"NSC0800"},		/* National Semiconductor PC87307/PC97307 watchdog component */
+	/* mpu401 */
+	{"PNPb006"},
+	/* cs423x-pnpbios */
+	{"CSC0100"},
+	{"CSC0000"},
+	{"GIM0100"},		/* Guillemot Turtlebeach something appears to be cs4232 compatible */
+	/* es18xx-pnpbios */
+	{"ESS1869"},
+	{"ESS1879"},
+	/* snd-opl3sa2-pnpbios */
+	{"YMH0021"},
+	{"NMX2210"},		/* Gateway Solo 2500 */
+	{""},
+};
+
+static bool is_hex_digit(char c)
+{
+	return (c >= 0 && c <= '9') || (c >= 'A' && c <= 'F');
+}
+
+static bool matching_id(char *idstr, char *list_id)
+{
+	int i;
+
+	if (memcmp(idstr, list_id, 3))
+		return false;
+
+	for (i = 3; i < 7; i++) {
+		char c = toupper(idstr[i]);
+
+		if (!is_hex_digit(c)
+		    || (list_id[i] != 'X' && c != toupper(list_id[i])))
+			return false;
+	}
+	return true;
+}
+
+static bool acpi_pnp_match(char *idstr, const struct acpi_device_id **matchid)
+{
+	const struct acpi_device_id *devid;
+
+	for (devid = acpi_pnp_device_ids; devid->id[0]; devid++)
+		if (matching_id(idstr, (char *)devid->id)) {
+			if (matchid)
+				*matchid = devid;
+
+			return true;
+		}
+
+	return false;
+}
+
+static int acpi_pnp_attach(struct acpi_device *adev,
+			   const struct acpi_device_id *id)
+{
+	return 1;
+}
+
+static struct acpi_scan_handler acpi_pnp_handler = {
+	.ids = acpi_pnp_device_ids,
+	.match = acpi_pnp_match,
+	.attach = acpi_pnp_attach,
+};
+
+/*
+ * For CMOS RTC devices, the PNP ACPI scan handler does not work, because
+ * there is a CMOS RTC ACPI scan handler installed already, so we need to
+ * check those devices and enumerate them to the PNP bus directly.
+ */
+static int is_cmos_rtc_device(struct acpi_device *adev)
+{
+	struct acpi_device_id ids[] = {
+		{ "PNP0B00" },
+		{ "PNP0B01" },
+		{ "PNP0B02" },
+		{""},
+	};
+	return !acpi_match_device_ids(adev, ids);
+}
+
+bool acpi_is_pnp_device(struct acpi_device *adev)
+{
+	return adev->handler == &acpi_pnp_handler || is_cmos_rtc_device(adev);
+}
+EXPORT_SYMBOL_GPL(acpi_is_pnp_device);
+
+void __init acpi_pnp_init(void)
+{
+	acpi_scan_add_handler(&acpi_pnp_handler);
+}
