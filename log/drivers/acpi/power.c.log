commit a10660f7788bcb1229534cd1aa57a8f4b36cfe74
Author: Pascal Terjan <pterjan@google.com>
Date:   Sun May 10 20:30:16 2020 +0100

    ACPI: Delete unused proc filename macros
    
    Those were used to create files in /proc/acpi long ago
    and were missed when that code was deleted.
    
    Signed-off-by: Pascal Terjan <pterjan@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index fe1e7bc91a5e..837b875d075e 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -36,8 +36,6 @@
 ACPI_MODULE_NAME("power");
 #define ACPI_POWER_CLASS		"power_resource"
 #define ACPI_POWER_DEVICE_NAME		"Power Resource"
-#define ACPI_POWER_FILE_INFO		"info"
-#define ACPI_POWER_FILE_STATUS		"state"
 #define ACPI_POWER_RESOURCE_STATE_OFF	0x00
 #define ACPI_POWER_RESOURCE_STATE_ON	0x01
 #define ACPI_POWER_RESOURCE_STATE_UNKNOWN 0xFF

commit 4533771c1e53b921f66e580135ee64a76986a491
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Jun 25 13:29:41 2019 +0300

    ACPI / PM: Introduce concept of a _PR0 dependent device
    
    If there are shared power resources between otherwise unrelated devices
    turning them on causes the other devices sharing them to be powered up
    as well. In case of PCI devices go into D0uninitialized state meaning
    that if they were configured to trigger wake that configuration is lost
    at this point.
    
    For this reason introduce a concept of "_PR0 dependent device" that can
    be added to any ACPI device that has power resources. The dependent
    device will be included in a list of dependent devices for all power
    resources returned by the ACPI device's _PR0 (assuming it has one).
    Whenever a power resource having dependent devices is turned physically
    on (its _ON method is called) we runtime resume all of them to allow
    their driver or in case of PCI the PCI core to re-initialize the device
    and its wake configuration.
    
    This adds two functions that can be used to add and remove these
    dependent devices. Note the dependent device does not necessary need
    share power resources so this functionality can be used to add "software
    dependencies" as well if needed.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index a916417b9e70..fe1e7bc91a5e 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -42,6 +42,11 @@ ACPI_MODULE_NAME("power");
 #define ACPI_POWER_RESOURCE_STATE_ON	0x01
 #define ACPI_POWER_RESOURCE_STATE_UNKNOWN 0xFF
 
+struct acpi_power_dependent_device {
+	struct device *dev;
+	struct list_head node;
+};
+
 struct acpi_power_resource {
 	struct acpi_device device;
 	struct list_head list_node;
@@ -51,6 +56,7 @@ struct acpi_power_resource {
 	unsigned int ref_count;
 	bool wakeup_enabled;
 	struct mutex resource_lock;
+	struct list_head dependents;
 };
 
 struct acpi_power_resource_entry {
@@ -232,8 +238,121 @@ static int acpi_power_get_list_state(struct list_head *list, int *state)
 	return 0;
 }
 
+static int
+acpi_power_resource_add_dependent(struct acpi_power_resource *resource,
+				  struct device *dev)
+{
+	struct acpi_power_dependent_device *dep;
+	int ret = 0;
+
+	mutex_lock(&resource->resource_lock);
+	list_for_each_entry(dep, &resource->dependents, node) {
+		/* Only add it once */
+		if (dep->dev == dev)
+			goto unlock;
+	}
+
+	dep = kzalloc(sizeof(*dep), GFP_KERNEL);
+	if (!dep) {
+		ret = -ENOMEM;
+		goto unlock;
+	}
+
+	dep->dev = dev;
+	list_add_tail(&dep->node, &resource->dependents);
+	dev_dbg(dev, "added power dependency to [%s]\n", resource->name);
+
+unlock:
+	mutex_unlock(&resource->resource_lock);
+	return ret;
+}
+
+static void
+acpi_power_resource_remove_dependent(struct acpi_power_resource *resource,
+				     struct device *dev)
+{
+	struct acpi_power_dependent_device *dep;
+
+	mutex_lock(&resource->resource_lock);
+	list_for_each_entry(dep, &resource->dependents, node) {
+		if (dep->dev == dev) {
+			list_del(&dep->node);
+			kfree(dep);
+			dev_dbg(dev, "removed power dependency to [%s]\n",
+				resource->name);
+			break;
+		}
+	}
+	mutex_unlock(&resource->resource_lock);
+}
+
+/**
+ * acpi_device_power_add_dependent - Add dependent device of this ACPI device
+ * @adev: ACPI device pointer
+ * @dev: Dependent device
+ *
+ * If @adev has non-empty _PR0 the @dev is added as dependent device to all
+ * power resources returned by it. This means that whenever these power
+ * resources are turned _ON the dependent devices get runtime resumed. This
+ * is needed for devices such as PCI to allow its driver to re-initialize
+ * it after it went to D0uninitialized.
+ *
+ * If @adev does not have _PR0 this does nothing.
+ *
+ * Returns %0 in case of success and negative errno otherwise.
+ */
+int acpi_device_power_add_dependent(struct acpi_device *adev,
+				    struct device *dev)
+{
+	struct acpi_power_resource_entry *entry;
+	struct list_head *resources;
+	int ret;
+
+	if (!adev->flags.power_manageable)
+		return 0;
+
+	resources = &adev->power.states[ACPI_STATE_D0].resources;
+	list_for_each_entry(entry, resources, node) {
+		ret = acpi_power_resource_add_dependent(entry->resource, dev);
+		if (ret)
+			goto err;
+	}
+
+	return 0;
+
+err:
+	list_for_each_entry(entry, resources, node)
+		acpi_power_resource_remove_dependent(entry->resource, dev);
+
+	return ret;
+}
+
+/**
+ * acpi_device_power_remove_dependent - Remove dependent device
+ * @adev: ACPI device pointer
+ * @dev: Dependent device
+ *
+ * Does the opposite of acpi_device_power_add_dependent() and removes the
+ * dependent device if it is found. Can be called to @adev that does not
+ * have _PR0 as well.
+ */
+void acpi_device_power_remove_dependent(struct acpi_device *adev,
+					struct device *dev)
+{
+	struct acpi_power_resource_entry *entry;
+	struct list_head *resources;
+
+	if (!adev->flags.power_manageable)
+		return;
+
+	resources = &adev->power.states[ACPI_STATE_D0].resources;
+	list_for_each_entry_reverse(entry, resources, node)
+		acpi_power_resource_remove_dependent(entry->resource, dev);
+}
+
 static int __acpi_power_on(struct acpi_power_resource *resource)
 {
+	struct acpi_power_dependent_device *dep;
 	acpi_status status = AE_OK;
 
 	status = acpi_evaluate_object(resource->device.handle, "_ON", NULL, NULL);
@@ -243,6 +362,21 @@ static int __acpi_power_on(struct acpi_power_resource *resource)
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Power resource [%s] turned on\n",
 			  resource->name));
 
+	/*
+	 * If there are other dependents on this power resource we need to
+	 * resume them now so that their drivers can re-initialize the
+	 * hardware properly after it went back to D0.
+	 */
+	if (list_empty(&resource->dependents) ||
+	    list_is_singular(&resource->dependents))
+		return 0;
+
+	list_for_each_entry(dep, &resource->dependents, node) {
+		dev_dbg(dep->dev, "runtime resuming because [%s] turned on\n",
+			resource->name);
+		pm_request_resume(dep->dev);
+	}
+
 	return 0;
 }
 
@@ -810,6 +944,7 @@ int acpi_add_power_resource(acpi_handle handle)
 				ACPI_STA_DEFAULT);
 	mutex_init(&resource->resource_lock);
 	INIT_LIST_HEAD(&resource->list_node);
+	INIT_LIST_HEAD(&resource->dependents);
 	resource->name = device->pnp.bus_id;
 	strcpy(acpi_device_name(device), ACPI_POWER_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_POWER_CLASS);

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 87db3e124725..a916417b9e70 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * drivers/acpi/power.c - ACPI Power Resources management.
  *
@@ -5,20 +6,6 @@
  * Author: Andy Grover <andrew.grover@intel.com>
  * Author: Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
  * Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 
 /*

commit 603fadf33604a2e170eb833f99f569d3597f1f09
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Mar 25 13:34:00 2019 -0500

    ACPI: Fix comment typos
    
    Fix some misspellings in comments.  No functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 665e93ca0b40..87db3e124725 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -535,12 +535,12 @@ int acpi_device_sleep_wake(struct acpi_device *dev,
 	/*
 	 * Try to execute _DSW first.
 	 *
-	 * Three agruments are needed for the _DSW object:
+	 * Three arguments are needed for the _DSW object:
 	 * Argument 0: enable/disable the wake capabilities
 	 * Argument 1: target system state
 	 * Argument 2: target device state
 	 * When _DSW object is called to disable the wake capabilities, maybe
-	 * the first argument is filled. The values of the other two agruments
+	 * the first argument is filled. The values of the other two arguments
 	 * are meaningless.
 	 */
 	in_arg[0].type = ACPI_TYPE_INTEGER;

commit 7d7b467cb95bf29597b417d4990160d4ea6d69b9
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Dec 30 18:25:00 2018 +0100

    ACPI: power: Skip duplicate power resource references in _PRx
    
    Some ACPI tables contain duplicate power resource references like this:
    
            Name (_PR0, Package (0x04)  // _PR0: Power Resources for D0
            {
                P28P,
                P18P,
                P18P,
                CLK4
            })
    
    This causes a WARN_ON in sysfs_add_link_to_group() because we end up
    adding a link to the same acpi_device twice:
    
    sysfs: cannot create duplicate filename '/devices/LNXSYSTM:00/LNXSYBUS:00/PNP0A08:00/808622C1:00/OVTI2680:00/power_resources_D0/LNXPOWER:0a'
    CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.19.12-301.fc29.x86_64 #1
    Hardware name: Insyde CherryTrail/Type2 - Board Product Name, BIOS jumperx.T87.KFBNEEA02 04/13/2016
    Call Trace:
     dump_stack+0x5c/0x80
     sysfs_warn_dup.cold.3+0x17/0x2a
     sysfs_do_create_link_sd.isra.2+0xa9/0xb0
     sysfs_add_link_to_group+0x30/0x50
     acpi_power_expose_list+0x74/0xa0
     acpi_power_add_remove_device+0x50/0xa0
     acpi_add_single_object+0x26b/0x5f0
     acpi_bus_check_add+0xc4/0x250
     ...
    
    To address this issue, make acpi_extract_power_resources() check for
    duplicates and simply skip them when found.
    
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    [ rjw: Subject & changelog, comments ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 1b475bc1ae16..665e93ca0b40 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -131,6 +131,23 @@ void acpi_power_resources_list_free(struct list_head *list)
 	}
 }
 
+static bool acpi_power_resource_is_dup(union acpi_object *package,
+				       unsigned int start, unsigned int i)
+{
+	acpi_handle rhandle, dup;
+	unsigned int j;
+
+	/* The caller is expected to check the package element types */
+	rhandle = package->package.elements[i].reference.handle;
+	for (j = start; j < i; j++) {
+		dup = package->package.elements[j].reference.handle;
+		if (dup == rhandle)
+			return true;
+	}
+
+	return false;
+}
+
 int acpi_extract_power_resources(union acpi_object *package, unsigned int start,
 				 struct list_head *list)
 {
@@ -150,6 +167,11 @@ int acpi_extract_power_resources(union acpi_object *package, unsigned int start,
 			err = -ENODEV;
 			break;
 		}
+
+		/* Some ACPI tables contain duplicate power resource references */
+		if (acpi_power_resource_is_dup(package, start, i))
+			continue;
+
 		err = acpi_add_power_resource(rhandle);
 		if (err)
 			break;

commit 26408b24345b1afbc08727e7a899d59db0d6f21d
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Jun 30 17:39:05 2017 +0530

    ACPI / power: constify attribute_group structures
    
    attribute_groups are not supposed to change at runtime. All functions
    working with attribute_groups provided by <linux/sysfs.h> work with const
    attribute_group. So mark the non-const structs as const.
    
    File size before:
       text    data     bss     dec     hex filename
       4622     304       8    4934    1346 drivers/acpi/power.o
    
    File size After adding 'const':
       text    data     bss     dec     hex filename
       4846      80       8    4934    1346 drivers/acpi/power.o
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 3a6c9b741b23..1b475bc1ae16 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -352,7 +352,7 @@ static struct attribute *attrs[] = {
 	NULL,
 };
 
-static struct attribute_group attr_groups[] = {
+static const struct attribute_group attr_groups[] = {
 	[ACPI_STATE_D0] = {
 		.name = "power_resources_D0",
 		.attrs = attrs,
@@ -371,14 +371,14 @@ static struct attribute_group attr_groups[] = {
 	},
 };
 
-static struct attribute_group wakeup_attr_group = {
+static const struct attribute_group wakeup_attr_group = {
 	.name = "power_resources_wakeup",
 	.attrs = attrs,
 };
 
 static void acpi_power_hide_list(struct acpi_device *adev,
 				 struct list_head *resources,
-				 struct attribute_group *attr_group)
+				 const struct attribute_group *attr_group)
 {
 	struct acpi_power_resource_entry *entry;
 
@@ -397,7 +397,7 @@ static void acpi_power_hide_list(struct acpi_device *adev,
 
 static void acpi_power_expose_list(struct acpi_device *adev,
 				   struct list_head *resources,
-				   struct attribute_group *attr_group)
+				   const struct attribute_group *attr_group)
 {
 	struct acpi_power_resource_entry *entry;
 	int ret;
@@ -425,7 +425,7 @@ static void acpi_power_expose_list(struct acpi_device *adev,
 
 static void acpi_power_expose_hide(struct acpi_device *adev,
 				   struct list_head *resources,
-				   struct attribute_group *attr_group,
+				   const struct attribute_group *attr_group,
 				   bool expose)
 {
 	if (expose)

commit 8ece1d83346bcc431090d59a2184276192189cdd
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Apr 30 22:54:16 2017 +0200

    ACPI / power: Delay turning off unused power resources after suspend
    
    Commit 660b1113e0f3 (ACPI / PM: Fix consistency check for power resources
    during resume) introduced a check for ACPI power resources which have
    been turned on by the BIOS during suspend and turns these back off again.
    
    This is causing problems on a Dell Venue Pro 11 7130 (i5-4300Y) it causes
    the following messages to show up in dmesg:
    
    [  131.014605] ACPI: Waking up from system sleep state S3
    [  131.150271] acpi LNXPOWER:07: Turning OFF
    [  131.150323] acpi LNXPOWER:06: Turning OFF
    [  131.150911] acpi LNXPOWER:00: Turning OFF
    [  131.169014] ACPI : EC: interrupt unblocked
    [  131.181811] xhci_hcd 0000:00:14.0: System wakeup disabled by ACPI
    [  133.535728] pci_raw_set_power_state: 76 callbacks suppressed
    [  133.535735] iwlwifi 0000:01:00.0: Refused to change power state,
                   currently in D3
    [  133.597672] PM: noirq resume of devices complete after 2428.891 msecs
    
    Followed by a bunch of iwlwifi errors later on and the pcie device
    dropping from the bus (acpiphp thinks it has been unplugged).
    
    Disabling the turning off of unused power resources fixes this. Instead
    of adding a quirk for this system, this commit fixes this by moving the
    disabling of unused power resources to later in the resume sequence
    when the iwlwifi card has been moved out of D3 so the ref_count for
    its power resource no longer is 0.
    
    This new behavior seems to match the intend of the original commit which
    commit-msg says: "(... which means that no devices are going to need them
    any time soon) and we should turn them off".
    
    This also avoids power resources which we need when bringing devices out
    of D3 from getting bounced off and then back on again.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 1c2b846c5776..3a6c9b741b23 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -864,6 +864,16 @@ void acpi_resume_power_resources(void)
 
 		mutex_unlock(&resource->resource_lock);
 	}
+
+	mutex_unlock(&power_resource_list_lock);
+}
+
+void acpi_turn_off_unused_power_resources(void)
+{
+	struct acpi_power_resource *resource;
+
+	mutex_lock(&power_resource_list_lock);
+
 	list_for_each_entry_reverse(resource, &acpi_power_resource_list, list_node) {
 		int result, state;
 

commit fe8c470ab87d90e4b5115902dd94eced7e3305c3
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Apr 19 19:47:04 2017 +0200

    ACPI / power: Avoid maybe-uninitialized warning
    
    gcc -O2 cannot always prove that the loop in acpi_power_get_inferred_state()
    is enterered at least once, so it assumes that cur_state might not get
    initialized:
    
    drivers/acpi/power.c: In function 'acpi_power_get_inferred_state':
    drivers/acpi/power.c:222:9: error: 'cur_state' may be used uninitialized in this function [-Werror=maybe-uninitialized]
    
    This sets the variable to zero at the start of the loop, to ensure that
    there is well-defined behavior even for an empty list. This gets rid of
    the warning.
    
    The warning first showed up when the -Os flag got removed in a bug fix
    patch in linux-4.11-rc5.
    
    I would suggest merging this addon patch on top of that bug fix to avoid
    introducing a new warning in the stable kernels.
    
    Fixes: 61b79e16c68d (ACPI: Fix incompatibility with mcount-based function graph tracing)
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index fcd4ce6f78d5..1c2b846c5776 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -200,6 +200,7 @@ static int acpi_power_get_list_state(struct list_head *list, int *state)
 		return -EINVAL;
 
 	/* The state of the list is 'on' IFF all resources are 'on'. */
+	cur_state = 0;
 	list_for_each_entry(entry, list, node) {
 		struct acpi_power_resource *resource = entry->resource;
 		acpi_handle handle = resource->device.handle;

commit ef5f5de069bd9081a7ddf6998269b58fc65e27ef
Merge: 73990fc810bf e91a398c31ce
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 1 03:38:43 2015 +0200

    Merge branch 'acpi-pm'
    
    * acpi-pm:
      ACPI / bus: Move duplicate code to a separate new function
      mfd: Add support for Intel Sunrisepoint LPSS devices
      dmaengine: add a driver for Intel integrated DMA 64-bit
      mfd: make mfd_remove_devices() iterate in reverse order
      driver core: implement device_for_each_child_reverse()
      klist: implement klist_prev()
      Driver core: wakeup the parent device before trying probe
      ACPI / PM: Attach ACPI power domain only once
      PM / QoS: Make it possible to expose device latency tolerance to userspace
      ACPI / PM: Update the copyright notice and description of power.c

commit aa57aca8e15a4e11749640e16ac9814f14be24d2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jul 16 02:01:28 2015 +0200

    ACPI / PM: Update the copyright notice and description of power.c
    
    The description and copyright notice of drivers/acpi/power.c is out
    of date, so update it as appropriate.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 93eac53b5110..ce68ae68840d 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -1,8 +1,10 @@
 /*
- *  acpi_power.c - ACPI Bus Power Management ($Revision: 39 $)
+ * drivers/acpi/power.c - ACPI Power Resources management.
  *
- *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ * Copyright (C) 2001 - 2015 Intel Corp.
+ * Author: Andy Grover <andrew.grover@intel.com>
+ * Author: Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ * Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
  *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
@@ -27,10 +29,11 @@
  * ACPI power-managed devices may be controlled in two ways:
  * 1. via "Device Specific (D-State) Control"
  * 2. via "Power Resource Control".
- * This module is used to manage devices relying on Power Resource Control.
+ * The code below deals with ACPI Power Resources control.
  * 
- * An ACPI "power resource object" describes a software controllable power
- * plane, clock plane, or other resource used by a power managed device.
+ * An ACPI "power resource object" represents a software controllable power
+ * plane, clock plane, or other resource depended on by a device.
+ *
  * A device may rely on multiple power resources, and a power resource
  * may be shared by multiple devices.
  */

commit 4c62dbbce902cf2afa88cac89ec67c828160f431
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Jun 26 11:27:41 2015 +0300

    ACPI: Remove FSF mailing addresses
    
    There is no need to carry potentially outdated Free Software Foundation
    mailing address in file headers since the COPYING file includes it.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 93eac53b5110..45b47f2c9f03 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -16,10 +16,6 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  *  General Public License for more details.
  *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 

commit d5eefa8280a8bb1e8aef059154bc1d63e1ac3336
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 21 04:19:49 2015 +0200

    ACPI / PM: Turn power resources on and off in the right order during resume
    
    According to Section 7.2 of ACPI 6.0, power resources should
    always be enabled and disabled in order given by the "resourceorder"
    field of the corresponding Power Resource objects: "Power Resource
    levels are enabled from low values to high values and are disabled
    from high values to low values."
    
    However, this is not what happens during system resume, because
    in that case the enabling/disabling is carried out in the power
    resource registration order which may not reflect the ordering
    required by the platform.
    
    For this reason, make the ordering of the global list of all
    power resources in the system (used by the system resume code)
    reflect the one given by the "resourceorder" attributes of the
    Power Resource objects in the ACPI namespace and modify
    acpi_resume_power_resources() to walk the list in the reverse
    order when turning off the power resources that had been off
    before the system was suspended.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 1f8138f24d72..93eac53b5110 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -760,6 +760,25 @@ static void acpi_power_sysfs_remove(struct acpi_device *device)
 	device_remove_file(&device->dev, &dev_attr_resource_in_use);
 }
 
+static void acpi_power_add_resource_to_list(struct acpi_power_resource *resource)
+{
+	mutex_lock(&power_resource_list_lock);
+
+	if (!list_empty(&acpi_power_resource_list)) {
+		struct acpi_power_resource *r;
+
+		list_for_each_entry(r, &acpi_power_resource_list, list_node)
+			if (r->order > resource->order) {
+				list_add_tail(&resource->list_node, &r->list_node);
+				goto out;
+			}
+	}
+	list_add_tail(&resource->list_node, &acpi_power_resource_list);
+
+ out:
+	mutex_unlock(&power_resource_list_lock);
+}
+
 int acpi_add_power_resource(acpi_handle handle)
 {
 	struct acpi_power_resource *resource;
@@ -810,9 +829,7 @@ int acpi_add_power_resource(acpi_handle handle)
 	if (!device_create_file(&device->dev, &dev_attr_resource_in_use))
 		device->remove = acpi_power_sysfs_remove;
 
-	mutex_lock(&power_resource_list_lock);
-	list_add(&resource->list_node, &acpi_power_resource_list);
-	mutex_unlock(&power_resource_list_lock);
+	acpi_power_add_resource_to_list(resource);
 	acpi_device_add_finalize(device);
 	return 0;
 
@@ -843,7 +860,22 @@ void acpi_resume_power_resources(void)
 		    && resource->ref_count) {
 			dev_info(&resource->device.dev, "Turning ON\n");
 			__acpi_power_on(resource);
-		} else if (state == ACPI_POWER_RESOURCE_STATE_ON
+		}
+
+		mutex_unlock(&resource->resource_lock);
+	}
+	list_for_each_entry_reverse(resource, &acpi_power_resource_list, list_node) {
+		int result, state;
+
+		mutex_lock(&resource->resource_lock);
+
+		result = acpi_power_get_state(resource->device.handle, &state);
+		if (result) {
+			mutex_unlock(&resource->resource_lock);
+			continue;
+		}
+
+		if (state == ACPI_POWER_RESOURCE_STATE_ON
 		    && !resource->ref_count) {
 			dev_info(&resource->device.dev, "Turning OFF\n");
 			__acpi_power_off(resource);

commit 20dacb71ad283b9506ee7e01286a424999fb8309
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat May 16 01:55:35 2015 +0200

    ACPI / PM: Rework device power management to follow ACPI 6
    
    The ACPI 6 specification has made some changes in the device power
    management area.  In particular:
    
     * The D3hot power state is now supposed to be always available
       (instead of D3cold) and D3cold is only regarded as valid if the
       _PR3 object is present for the given device.
    
     * The required ordering of transitions into power states deeper than
       D0 is now such that for a transition into state Dx the _PSx method
       is supposed to be executed first, if present, and the states of
       the power resources the device depends on are supposed to be
       changed after that.
    
     * It is now explicitly forbidden to transition devices from
       lower-power (deeper) into higher-power (shallower) power states
       other than D0.
    
    Those changes have been made so the specification reflects the
    Windows' device power management code that the vast majority of
    systems using ACPI is validated against.
    
    To avoid artificial differences in ACPI device power management
    between Windows and Linux, modify the ACPI device power management
    code to follow the new specification.  Add comments explaining the
    code flow in some unclear places.
    
    This only may affect some real corner cases in which the OS behavior
    expected by the firmware is different from the Windows one, but that's
    quite unlikely.  The transition ordering change affects transitions
    to D1 and D2 which are rarely used (if at all) and into D3hot and
    D3cold for devices actually having _PR3, but those are likely to
    be validated against Windows anyway.  The other changes may affect
    code calling acpi_device_get_power() or acpi_device_update_power()
    where ACPI_STATE_D3_HOT may be returned instead of ACPI_STATE_D3_COLD
    (that's why the ACPI fan driver needs to be updated too) and since
    transitions into ACPI_STATE_D3_HOT may remove power now, it is better
    to avoid this one in acpi_pm_device_sleep_state() if the "no power
    off" PM QoS flag is set.
    
    The only existing user of acpi_device_can_poweroff() really cares
    about the case when _PR3 is present, so the change in that function
    should not cause any problems to happen too.
    
    A plus is that PCI_D3hot can be mapped to ACPI_STATE_D3_HOT
    now and the compatibility with older systems should be covered
    automatically.
    
    In any case, if any real problems result from this, it still will
    be better to follow the Windows' behavior (which now is reflected
    by the specification too) in general and handle the cases when it
    doesn't work via quirks.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 59a6bf707f91..1f8138f24d72 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -684,7 +684,8 @@ int acpi_power_get_inferred_state(struct acpi_device *device, int *state)
 		}
 	}
 
-	*state = ACPI_STATE_D3_COLD;
+	*state = device->power.states[ACPI_STATE_D3_COLD].flags.valid ?
+		ACPI_STATE_D3_COLD : ACPI_STATE_D3_HOT;
 	return 0;
 }
 

commit 6656bde5ec868d89cc803539f9edf85a89497b6a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 8 22:41:05 2015 +0200

    ACPI / PM: Drop stale comment from acpi_power_transition()
    
    An old comment in acpi_power_transition() indicates that support
    for ordering power resources needs to be added, but the current
    code handles that already.
    
    Drop the comment to avoid confusion.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index e0bcfb642b52..59a6bf707f91 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -710,8 +710,6 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	    || (device->power.state > ACPI_STATE_D3_COLD))
 		return -ENODEV;
 
-	/* TBD: Resources must be ordered. */
-
 	/*
 	 * First we reference all power resources required in the target list
 	 * (e.g. so the device doesn't lose power while transitioning).  Then,

commit 07070e12cf5cab46a783a4753f07bb99e557473b
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Thu Mar 13 12:47:39 2014 +0800

    ACPI: Remove duplicate definitions of PREFIX
    
    We already have a macro for PREFIX of "ACPI: " in
    drivers/acpi/internal.h, so remove the duplicate ones
    in ACPI drivers when internal.h is included.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index ad7da686e6e6..e0bcfb642b52 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -46,8 +46,6 @@
 #include "sleep.h"
 #include "internal.h"
 
-#define PREFIX "ACPI: "
-
 #define _COMPONENT			ACPI_POWER_COMPONENT
 ACPI_MODULE_NAME("power");
 #define ACPI_POWER_CLASS		"power_resource"

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index c2ad391d8041..ad7da686e6e6 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -42,8 +42,7 @@
 #include <linux/slab.h>
 #include <linux/pm_runtime.h>
 #include <linux/sysfs.h>
-#include <acpi/acpi_bus.h>
-#include <acpi/acpi_drivers.h>
+#include <linux/acpi.h>
 #include "sleep.h"
 #include "internal.h"
 

commit 41863fcee3039ec3de15003b78e7284c4393e862
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 16 23:05:42 2013 +0200

    ACPI / power: Drop automaitc resume of power resource dependent devices
    
    The mechanism causing devices depending on a given power resource
    (that is, devices that can be in D0 only if that power resource is
    on) to be resumed automatically when the power resource is turned
    on (and their "inferred" power state becomes D0 as a result) is
    inherently racy and in fact unnecessary.
    
    It is racy, because if the power resource is turned on and then
    immediately off, the device resume triggered by the first transition
    to "on" may still happen, causing the power resource to be turned
    on again.  That again will trigger the "resume of dependent devices"
    mechanism, but if the devices in question are not in use, they will
    be suspended in the meantime causing the power resource to be turned
    off.  However, the "resume of dependent devices" will next resume
    them again and so on.  In some cases (USB port PM in particular) that
    leads to an endless busy loop of flipping the resource on and off
    continuously.
    
    It is needless, because whoever turns a power resource on will most
    likely turn it off at some point and the devices that go into "D0"
    as a result of turning it on will then go back into D3cold
    (generally, the state they were in before).
    
    Moreover, turning on all power resources a device needs to go into
    D0 is not sufficient for a full transition into D0 in general.
    Namely, _PS0 may need to be executed in addition to that in some
    cases.  This means that the whole rationale of the "resume of
    dependent devices" mechanism was incorrect to begin with and it's
    best to remove it entirely.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 0c1c3ec784fb..c2ad391d8041 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -59,16 +59,9 @@ ACPI_MODULE_NAME("power");
 #define ACPI_POWER_RESOURCE_STATE_ON	0x01
 #define ACPI_POWER_RESOURCE_STATE_UNKNOWN 0xFF
 
-struct acpi_power_dependent_device {
-	struct list_head node;
-	struct acpi_device *adev;
-	struct work_struct work;
-};
-
 struct acpi_power_resource {
 	struct acpi_device device;
 	struct list_head list_node;
-	struct list_head dependent;
 	char *name;
 	u32 system_level;
 	u32 order;
@@ -233,32 +226,6 @@ static int acpi_power_get_list_state(struct list_head *list, int *state)
 	return 0;
 }
 
-static void acpi_power_resume_dependent(struct work_struct *work)
-{
-	struct acpi_power_dependent_device *dep;
-	struct acpi_device_physical_node *pn;
-	struct acpi_device *adev;
-	int state;
-
-	dep = container_of(work, struct acpi_power_dependent_device, work);
-	adev = dep->adev;
-	if (acpi_power_get_inferred_state(adev, &state))
-		return;
-
-	if (state > ACPI_STATE_D0)
-		return;
-
-	mutex_lock(&adev->physical_node_lock);
-
-	list_for_each_entry(pn, &adev->physical_node_list, node)
-		pm_request_resume(pn->dev);
-
-	list_for_each_entry(pn, &adev->power_dependent, node)
-		pm_request_resume(pn->dev);
-
-	mutex_unlock(&adev->physical_node_lock);
-}
-
 static int __acpi_power_on(struct acpi_power_resource *resource)
 {
 	acpi_status status = AE_OK;
@@ -283,14 +250,8 @@ static int acpi_power_on_unlocked(struct acpi_power_resource *resource)
 				  resource->name));
 	} else {
 		result = __acpi_power_on(resource);
-		if (result) {
+		if (result)
 			resource->ref_count--;
-		} else {
-			struct acpi_power_dependent_device *dep;
-
-			list_for_each_entry(dep, &resource->dependent, node)
-				schedule_work(&dep->work);
-		}
 	}
 	return result;
 }
@@ -390,52 +351,6 @@ static int acpi_power_on_list(struct list_head *list)
 	return result;
 }
 
-static void acpi_power_add_dependent(struct acpi_power_resource *resource,
-				     struct acpi_device *adev)
-{
-	struct acpi_power_dependent_device *dep;
-
-	mutex_lock(&resource->resource_lock);
-
-	list_for_each_entry(dep, &resource->dependent, node)
-		if (dep->adev == adev)
-			goto out;
-
-	dep = kzalloc(sizeof(*dep), GFP_KERNEL);
-	if (!dep)
-		goto out;
-
-	dep->adev = adev;
-	INIT_WORK(&dep->work, acpi_power_resume_dependent);
-	list_add_tail(&dep->node, &resource->dependent);
-
- out:
-	mutex_unlock(&resource->resource_lock);
-}
-
-static void acpi_power_remove_dependent(struct acpi_power_resource *resource,
-					struct acpi_device *adev)
-{
-	struct acpi_power_dependent_device *dep;
-	struct work_struct *work = NULL;
-
-	mutex_lock(&resource->resource_lock);
-
-	list_for_each_entry(dep, &resource->dependent, node)
-		if (dep->adev == adev) {
-			list_del(&dep->node);
-			work = &dep->work;
-			break;
-		}
-
-	mutex_unlock(&resource->resource_lock);
-
-	if (work) {
-		cancel_work_sync(work);
-		kfree(dep);
-	}
-}
-
 static struct attribute *attrs[] = {
 	NULL,
 };
@@ -524,8 +439,6 @@ static void acpi_power_expose_hide(struct acpi_device *adev,
 
 void acpi_power_add_remove_device(struct acpi_device *adev, bool add)
 {
-	struct acpi_device_power_state *ps;
-	struct acpi_power_resource_entry *entry;
 	int state;
 
 	if (adev->wakeup.flags.valid)
@@ -535,16 +448,6 @@ void acpi_power_add_remove_device(struct acpi_device *adev, bool add)
 	if (!adev->power.flags.power_resources)
 		return;
 
-	ps = &adev->power.states[ACPI_STATE_D0];
-	list_for_each_entry(entry, &ps->resources, node) {
-		struct acpi_power_resource *resource = entry->resource;
-
-		if (add)
-			acpi_power_add_dependent(resource, adev);
-		else
-			acpi_power_remove_dependent(resource, adev);
-	}
-
 	for (state = ACPI_STATE_D0; state <= ACPI_STATE_D3_HOT; state++)
 		acpi_power_expose_hide(adev,
 				       &adev->power.states[state].resources,
@@ -882,7 +785,6 @@ int acpi_add_power_resource(acpi_handle handle)
 	acpi_init_device_object(device, handle, ACPI_BUS_TYPE_POWER,
 				ACPI_STA_DEFAULT);
 	mutex_init(&resource->resource_lock);
-	INIT_LIST_HEAD(&resource->dependent);
 	INIT_LIST_HEAD(&resource->list_node);
 	resource->name = device->pnp.bus_id;
 	strcpy(acpi_device_name(device), ACPI_POWER_DEVICE_NAME);

commit d7d49012b917647794b6df33f4e7a61a2c818ccf
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Tue Oct 15 19:48:11 2013 +0800

    ACPI / power: Release resource_lock after acpi_power_get_state() return error
    
    In acpi_resume_power_resources() resource_lock should be released
    when acpi_power_get_state() fails and before passing to next power
    resource on the list.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 0dbe5cdf3396..0c1c3ec784fb 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -936,8 +936,10 @@ void acpi_resume_power_resources(void)
 		mutex_lock(&resource->resource_lock);
 
 		result = acpi_power_get_state(resource->device.handle, &state);
-		if (result)
+		if (result) {
+			mutex_unlock(&resource->resource_lock);
 			continue;
+		}
 
 		if (state == ACPI_POWER_RESOURCE_STATE_OFF
 		    && resource->ref_count) {

commit 0ad4c9a9848fdd46dc422160efd947489a98bbc1
Merge: abe5430e9d53 593298e68a3a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 27 01:28:17 2013 +0200

    Merge branch 'acpi-pm'
    
    * acpi-pm:
      ACPI / PM: Add state information to error message in acpi_device_set_power()
      ACPI / PM: Remove redundant power manageable check from acpi_bus_set_power()
      ACPI / PM: Use ACPI_STATE_D3_COLD instead of ACPI_STATE_D3 everywhere
      ACPI / PM: Make messages in acpi_device_set_power() print device names
      ACPI / PM: Only set power states of devices that are power manageable

commit 8ad928d52e63a9b7d69f0873d7318c4561e2f8cd
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 30 14:36:20 2013 +0200

    ACPI / PM: Use ACPI_STATE_D3_COLD instead of ACPI_STATE_D3 everywhere
    
    There are several places in the tree where ACPI_STATE_D3 is used
    instead of ACPI_STATE_D3_COLD which should be used instead for
    clarity.  Modify them all to use ACPI_STATE_D3_COLD as appropriate.
    
    [The definition of ACPI_STATE_D3 itself cannot go away at this point
     as it is part of ACPICA.]
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 5c28c894c0fc..4cdcc0cf0c56 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -786,7 +786,7 @@ int acpi_power_get_inferred_state(struct acpi_device *device, int *state)
 		}
 	}
 
-	*state = ACPI_STATE_D3;
+	*state = ACPI_STATE_D3_COLD;
 	return 0;
 }
 

commit 0db98202605c3d32e023d43c30b5bd878f520976
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Sat Jun 29 00:24:39 2013 +0800

    ACPI: introduce helper function acpi_execute_simple_method()
    
    Introduce helper function acpi_execute_simple_method() and use it in
    a number of places to simplify code.
    
    [rjw: Changelog]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 5c28c894c0fc..1460c88a7c0e 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -637,9 +637,7 @@ int acpi_device_sleep_wake(struct acpi_device *dev,
 	}
 
 	/* Execute _PSW */
-	arg_list.count = 1;
-	in_arg[0].integer.value = enable;
-	status = acpi_evaluate_object(dev->handle, "_PSW", &arg_list, NULL);
+	status = acpi_execute_simple_method(dev->handle, "_PSW", enable);
 	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
 		printk(KERN_ERR PREFIX "_PSW execution failed\n");
 		dev->wakeup.flags.valid = 0;

commit 10a0b6176b9f8b026ce07acd8f755297653c443c
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Jul 5 12:15:56 2013 +0300

    ACPI / power: add missing newline to debug messages
    
    There are few places in power.c where debug messages have no newline
    at the end.  Reading such debug messages from dmesg is not fun, so
    fix this by adding the missing newlines.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: All <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 288bb270f8ed..5c28c894c0fc 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -279,7 +279,7 @@ static int acpi_power_on_unlocked(struct acpi_power_resource *resource)
 
 	if (resource->ref_count++) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Power resource [%s] already on",
+				  "Power resource [%s] already on\n",
 				  resource->name));
 	} else {
 		result = __acpi_power_on(resource);
@@ -325,7 +325,7 @@ static int acpi_power_off_unlocked(struct acpi_power_resource *resource)
 
 	if (!resource->ref_count) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Power resource [%s] already off",
+				  "Power resource [%s] already off\n",
 				  resource->name));
 		return 0;
 	}

commit 6ee22e9d59151550a55d370b14109bdae8b58bda
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 19 00:44:45 2013 +0200

    ACPI / PM: Fix error code path for power resources initialization
    
    Commit 781d737 (ACPI: Drop power resources driver) introduced a
    bug in the power resources initialization error code path causing
    a NULL pointer to be referenced in acpi_release_power_resource()
    if there's an error triggering a jump to the 'err' label in
    acpi_add_power_resource().  This happens because the list_node
    field of struct acpi_power_resource has not been initialized yet
    at this point and doing a list_del() on it is a bad idea.
    
    To prevent this problem from occuring, initialize the list_node
    field of struct acpi_power_resource upfront.
    
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: 3.9+ <stable@vger.kernel.org>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index f962047c6c85..288bb270f8ed 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -885,6 +885,7 @@ int acpi_add_power_resource(acpi_handle handle)
 				ACPI_STA_DEFAULT);
 	mutex_init(&resource->resource_lock);
 	INIT_LIST_HEAD(&resource->dependent);
+	INIT_LIST_HEAD(&resource->list_node);
 	resource->name = device->pnp.bus_id;
 	strcpy(acpi_device_name(device), ACPI_POWER_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_POWER_CLASS);

commit 34bdb1a458baaf3e56843c36deb04283c26a8099
Merge: 0ad4991cae47 41a2a4665d40
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Apr 28 01:54:00 2013 +0200

    Merge branch 'acpi-pm'
    
    * acpi-pm:
      ACPI / PM: Expose lists of device wakeup power resources to user space
      ACPI / PM: Fix potential problem in acpi_device_get_power()

commit 41a2a4665d401f79912a3da83ff9ef3e502bc12e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Apr 11 22:41:48 2013 +0200

    ACPI / PM: Expose lists of device wakeup power resources to user space
    
    Commit 18a3870 (ACPI / PM: Expose lists of device power resources
    to user space) exposed the lists of ACPI power resources associated
    with power states of ACPI devices, but it didn't expose the lists
    of ACPI wakeup power resources, which also is necessary to get the
    full picture of dependencies between ACPI devices and power
    resources.
    
    For this reason, for every ACPI device node having a list of ACPI
    wakeup power resources associated with it, expose that list to user
    space in analogy with commit 18a3870.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 34f5ef11d427..0e3f57674fd1 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -459,57 +459,79 @@ static struct attribute_group attr_groups[] = {
 	},
 };
 
-static void acpi_power_hide_list(struct acpi_device *adev, int state)
+static struct attribute_group wakeup_attr_group = {
+	.name = "power_resources_wakeup",
+	.attrs = attrs,
+};
+
+static void acpi_power_hide_list(struct acpi_device *adev,
+				 struct list_head *resources,
+				 struct attribute_group *attr_group)
 {
-	struct acpi_device_power_state *ps = &adev->power.states[state];
 	struct acpi_power_resource_entry *entry;
 
-	if (list_empty(&ps->resources))
+	if (list_empty(resources))
 		return;
 
-	list_for_each_entry_reverse(entry, &ps->resources, node) {
+	list_for_each_entry_reverse(entry, resources, node) {
 		struct acpi_device *res_dev = &entry->resource->device;
 
 		sysfs_remove_link_from_group(&adev->dev.kobj,
-					     attr_groups[state].name,
+					     attr_group->name,
 					     dev_name(&res_dev->dev));
 	}
-	sysfs_remove_group(&adev->dev.kobj, &attr_groups[state]);
+	sysfs_remove_group(&adev->dev.kobj, attr_group);
 }
 
-static void acpi_power_expose_list(struct acpi_device *adev, int state)
+static void acpi_power_expose_list(struct acpi_device *adev,
+				   struct list_head *resources,
+				   struct attribute_group *attr_group)
 {
-	struct acpi_device_power_state *ps = &adev->power.states[state];
 	struct acpi_power_resource_entry *entry;
 	int ret;
 
-	if (list_empty(&ps->resources))
+	if (list_empty(resources))
 		return;
 
-	ret = sysfs_create_group(&adev->dev.kobj, &attr_groups[state]);
+	ret = sysfs_create_group(&adev->dev.kobj, attr_group);
 	if (ret)
 		return;
 
-	list_for_each_entry(entry, &ps->resources, node) {
+	list_for_each_entry(entry, resources, node) {
 		struct acpi_device *res_dev = &entry->resource->device;
 
 		ret = sysfs_add_link_to_group(&adev->dev.kobj,
-					      attr_groups[state].name,
+					      attr_group->name,
 					      &res_dev->dev.kobj,
 					      dev_name(&res_dev->dev));
 		if (ret) {
-			acpi_power_hide_list(adev, state);
+			acpi_power_hide_list(adev, resources, attr_group);
 			break;
 		}
 	}
 }
 
+static void acpi_power_expose_hide(struct acpi_device *adev,
+				   struct list_head *resources,
+				   struct attribute_group *attr_group,
+				   bool expose)
+{
+	if (expose)
+		acpi_power_expose_list(adev, resources, attr_group);
+	else
+		acpi_power_hide_list(adev, resources, attr_group);
+}
+
 void acpi_power_add_remove_device(struct acpi_device *adev, bool add)
 {
 	struct acpi_device_power_state *ps;
 	struct acpi_power_resource_entry *entry;
 	int state;
 
+	if (adev->wakeup.flags.valid)
+		acpi_power_expose_hide(adev, &adev->wakeup.resources,
+				       &wakeup_attr_group, add);
+
 	if (!adev->power.flags.power_resources)
 		return;
 
@@ -523,12 +545,10 @@ void acpi_power_add_remove_device(struct acpi_device *adev, bool add)
 			acpi_power_remove_dependent(resource, adev);
 	}
 
-	for (state = ACPI_STATE_D0; state <= ACPI_STATE_D3_HOT; state++) {
-		if (add)
-			acpi_power_expose_list(adev, state);
-		else
-			acpi_power_hide_list(adev, state);
-	}
+	for (state = ACPI_STATE_D0; state <= ACPI_STATE_D3_HOT; state++)
+		acpi_power_expose_hide(adev,
+				       &adev->power.states[state].resources,
+				       &attr_groups[state], add);
 }
 
 int acpi_power_wakeup_list_init(struct list_head *list, int *system_level_p)

commit c0af41757f406651cdd32de3e915753746c2948a
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Mon Mar 4 21:30:42 2013 +0000

    ACPI: Update PNPID set/free interfaces
    
    This patch introduces acpi_set_pnp_ids() and acpi_free_pnp_ids(),
    which are updated from acpi_device_set_id() and acpi_free_ids(),
    to setup and free acpi_device_pnp for a given acpi_handle.  They
    can be called without acpi_device.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 34f5ef11d427..0481b1b1d2aa 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -824,7 +824,7 @@ static void acpi_release_power_resource(struct device *dev)
 	list_del(&resource->list_node);
 	mutex_unlock(&power_resource_list_lock);
 
-	acpi_free_ids(device);
+	acpi_free_pnp_ids(&device->pnp);
 	kfree(resource);
 }
 

commit b5d667eb392ed901fc7ae76869c7a130559e193c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Feb 23 23:15:21 2013 +0100

    ACPI / PM: Take unusual configurations of power resources into account
    
    Commit d2e5f0c (ACPI / PCI: Rework the setup and cleanup of device
    wakeup) moved the initial disabling of system wakeup for PCI devices
    into a place where it can actually work and that exposed a hidden old
    issue with crap^Wunusual system designs where the same power
    resources are used for both wakeup power and device power control at
    run time.
    
    Namely, say there is one power resource such that the ACPI power
    state D0 of a PCI device depends on that power resource (i.e. the
    device is in D0 when that power resource is "on") and it is used
    as a wakeup power resource for the same device.  Then, calling
    acpi_pci_sleep_wake(pci_dev, false) for the device in question will
    cause the reference counter of that power resource to drop to 0,
    which in turn will cause it to be turned off.  As a result, the
    device will go into D3cold at that point, although it should have
    stayed in D0.
    
    As it turns out, that happens to USB controllers on some laptops
    and USB becomes unusable on those machines as a result, which is
    a major regression from v3.8.
    
    To fix this problem, (1) increment the reference counters of wakup
    power resources during their initialization if they are "on"
    initially, (2) prevent acpi_disable_wakeup_device_power() from
    decrementing the reference counters of wakeup power resources that
    were not enabled for wakeup power previously, and (3) prevent
    acpi_enable_wakeup_device_power() from incrementing the reference
    counters of wakeup power resources that already are enabled for
    wakeup power.
    
    In addition to that, if it is impossible to determine the initial
    states of wakeup power resources, avoid enabling wakeup for devices
    whose wakeup power depends on those power resources.
    
    Reported-by: Dave Jones <davej@redhat.com>
    Reported-by: Fabio Baltieri <fabio.baltieri@linaro.org>
    Tested-by: Fabio Baltieri <fabio.baltieri@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index b820528a5fa3..34f5ef11d427 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -73,6 +73,7 @@ struct acpi_power_resource {
 	u32 system_level;
 	u32 order;
 	unsigned int ref_count;
+	bool wakeup_enabled;
 	struct mutex resource_lock;
 };
 
@@ -272,11 +273,9 @@ static int __acpi_power_on(struct acpi_power_resource *resource)
 	return 0;
 }
 
-static int acpi_power_on(struct acpi_power_resource *resource)
+static int acpi_power_on_unlocked(struct acpi_power_resource *resource)
 {
-	int result = 0;;
-
-	mutex_lock(&resource->resource_lock);
+	int result = 0;
 
 	if (resource->ref_count++) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
@@ -293,9 +292,16 @@ static int acpi_power_on(struct acpi_power_resource *resource)
 				schedule_work(&dep->work);
 		}
 	}
+	return result;
+}
 
-	mutex_unlock(&resource->resource_lock);
+static int acpi_power_on(struct acpi_power_resource *resource)
+{
+	int result;
 
+	mutex_lock(&resource->resource_lock);
+	result = acpi_power_on_unlocked(resource);
+	mutex_unlock(&resource->resource_lock);
 	return result;
 }
 
@@ -313,17 +319,15 @@ static int __acpi_power_off(struct acpi_power_resource *resource)
 	return 0;
 }
 
-static int acpi_power_off(struct acpi_power_resource *resource)
+static int acpi_power_off_unlocked(struct acpi_power_resource *resource)
 {
 	int result = 0;
 
-	mutex_lock(&resource->resource_lock);
-
 	if (!resource->ref_count) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Power resource [%s] already off",
 				  resource->name));
-		goto unlock;
+		return 0;
 	}
 
 	if (--resource->ref_count) {
@@ -335,10 +339,16 @@ static int acpi_power_off(struct acpi_power_resource *resource)
 		if (result)
 			resource->ref_count++;
 	}
+	return result;
+}
 
- unlock:
-	mutex_unlock(&resource->resource_lock);
+static int acpi_power_off(struct acpi_power_resource *resource)
+{
+	int result;
 
+	mutex_lock(&resource->resource_lock);
+	result = acpi_power_off_unlocked(resource);
+	mutex_unlock(&resource->resource_lock);
 	return result;
 }
 
@@ -521,18 +531,35 @@ void acpi_power_add_remove_device(struct acpi_device *adev, bool add)
 	}
 }
 
-int acpi_power_min_system_level(struct list_head *list)
+int acpi_power_wakeup_list_init(struct list_head *list, int *system_level_p)
 {
 	struct acpi_power_resource_entry *entry;
 	int system_level = 5;
 
 	list_for_each_entry(entry, list, node) {
 		struct acpi_power_resource *resource = entry->resource;
+		acpi_handle handle = resource->device.handle;
+		int result;
+		int state;
 
+		mutex_lock(&resource->resource_lock);
+
+		result = acpi_power_get_state(handle, &state);
+		if (result) {
+			mutex_unlock(&resource->resource_lock);
+			return result;
+		}
+		if (state == ACPI_POWER_RESOURCE_STATE_ON) {
+			resource->ref_count++;
+			resource->wakeup_enabled = true;
+		}
 		if (system_level > resource->system_level)
 			system_level = resource->system_level;
+
+		mutex_unlock(&resource->resource_lock);
 	}
-	return system_level;
+	*system_level_p = system_level;
+	return 0;
 }
 
 /* --------------------------------------------------------------------------
@@ -610,6 +637,7 @@ int acpi_device_sleep_wake(struct acpi_device *dev,
  */
 int acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state)
 {
+	struct acpi_power_resource_entry *entry;
 	int err = 0;
 
 	if (!dev || !dev->wakeup.flags.valid)
@@ -620,17 +648,31 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state)
 	if (dev->wakeup.prepare_count++)
 		goto out;
 
-	err = acpi_power_on_list(&dev->wakeup.resources);
-	if (err) {
-		dev_err(&dev->dev, "Cannot turn wakeup power resources on\n");
-		dev->wakeup.flags.valid = 0;
-	} else {
-		/*
-		 * Passing 3 as the third argument below means the device may be
-		 * put into arbitrary power state afterward.
-		 */
-		err = acpi_device_sleep_wake(dev, 1, sleep_state, 3);
+	list_for_each_entry(entry, &dev->wakeup.resources, node) {
+		struct acpi_power_resource *resource = entry->resource;
+
+		mutex_lock(&resource->resource_lock);
+
+		if (!resource->wakeup_enabled) {
+			err = acpi_power_on_unlocked(resource);
+			if (!err)
+				resource->wakeup_enabled = true;
+		}
+
+		mutex_unlock(&resource->resource_lock);
+
+		if (err) {
+			dev_err(&dev->dev,
+				"Cannot turn wakeup power resources on\n");
+			dev->wakeup.flags.valid = 0;
+			goto out;
+		}
 	}
+	/*
+	 * Passing 3 as the third argument below means the device may be
+	 * put into arbitrary power state afterward.
+	 */
+	err = acpi_device_sleep_wake(dev, 1, sleep_state, 3);
 	if (err)
 		dev->wakeup.prepare_count = 0;
 
@@ -647,6 +689,7 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state)
  */
 int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 {
+	struct acpi_power_resource_entry *entry;
 	int err = 0;
 
 	if (!dev || !dev->wakeup.flags.valid)
@@ -668,10 +711,25 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 	if (err)
 		goto out;
 
-	err = acpi_power_off_list(&dev->wakeup.resources);
-	if (err) {
-		dev_err(&dev->dev, "Cannot turn wakeup power resources off\n");
-		dev->wakeup.flags.valid = 0;
+	list_for_each_entry(entry, &dev->wakeup.resources, node) {
+		struct acpi_power_resource *resource = entry->resource;
+
+		mutex_lock(&resource->resource_lock);
+
+		if (resource->wakeup_enabled) {
+			err = acpi_power_off_unlocked(resource);
+			if (!err)
+				resource->wakeup_enabled = false;
+		}
+
+		mutex_unlock(&resource->resource_lock);
+
+		if (err) {
+			dev_err(&dev->dev,
+				"Cannot turn wakeup power resources off\n");
+			dev->wakeup.flags.valid = 0;
+			break;
+		}
 	}
 
  out:

commit 660b1113e0f33a476952cb2cbcb5c9831e7ff4cd
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 25 21:51:57 2013 +0100

    ACPI / PM: Fix consistency check for power resources during resume
    
    During system resume we check if there are power resources that have
    been turned off by the BIOS, but our reference counters for them
    are nonzero (they need to be turned on then).  It turns out, however,
    that we also need to check the opposite, i.e. if there are power
    resources that have been turned on by the BIOS, but our reference
    counters for them are zero (which means that no devices are going
    to need them any time soon) and we should turn them off.
    
    Make the power resources resume code do the additional check and
    turn off the unused power resources as appropriate.
    
    This change has been tested on HP nx6325.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 9466f56b938f..b820528a5fa3 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -299,9 +299,22 @@ static int acpi_power_on(struct acpi_power_resource *resource)
 	return result;
 }
 
+static int __acpi_power_off(struct acpi_power_resource *resource)
+{
+	acpi_status status;
+
+	status = acpi_evaluate_object(resource->device.handle, "_OFF",
+				      NULL, NULL);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Power resource [%s] turned off\n",
+			  resource->name));
+	return 0;
+}
+
 static int acpi_power_off(struct acpi_power_resource *resource)
 {
-	acpi_status status = AE_OK;
 	int result = 0;
 
 	mutex_lock(&resource->resource_lock);
@@ -317,17 +330,12 @@ static int acpi_power_off(struct acpi_power_resource *resource)
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Power resource [%s] still in use\n",
 				  resource->name));
-		goto unlock;
+	} else {
+		result = __acpi_power_off(resource);
+		if (result)
+			resource->ref_count++;
 	}
 
-	status = acpi_evaluate_object(resource->device.handle, "_OFF", NULL, NULL);
-	if (ACPI_FAILURE(status))
-		result = -ENODEV;
-	else
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Power resource [%s] turned off\n",
-				  resource->name));
-
  unlock:
 	mutex_unlock(&resource->resource_lock);
 
@@ -851,10 +859,17 @@ void acpi_resume_power_resources(void)
 		mutex_lock(&resource->resource_lock);
 
 		result = acpi_power_get_state(resource->device.handle, &state);
-		if (!result && state == ACPI_POWER_RESOURCE_STATE_OFF
+		if (result)
+			continue;
+
+		if (state == ACPI_POWER_RESOURCE_STATE_OFF
 		    && resource->ref_count) {
 			dev_info(&resource->device.dev, "Turning ON\n");
 			__acpi_power_on(resource);
+		} else if (state == ACPI_POWER_RESOURCE_STATE_ON
+		    && !resource->ref_count) {
+			dev_info(&resource->device.dev, "Turning OFF\n");
+			__acpi_power_off(resource);
 		}
 
 		mutex_unlock(&resource->resource_lock);

commit 18a387099b3e3fd901cc706f708b163aa45347b6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 25 21:51:32 2013 +0100

    ACPI / PM: Expose lists of device power resources to user space
    
    Since ACPI power resources are going to be used more extensively on
    new hardware platforms, it is necessary to allow user space (powertop
    in particular) to look at the lists of power resources corresponding
    to different power states of devices for diagnostics and control
    purposes.
    
    For this reason, for each power state of an ACPI device node using
    power resources create a special attribute group under the device
    node's directory in sysfs containing links to sysfs directories
    representing the power resources in that list.  The names of the
    new attribute groups are "power_resources_<state>", where <state>
    is the state name i.e. "D0", "D1", "D2", or "D3hot".
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 946720a4db57..9466f56b938f 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -41,6 +41,7 @@
 #include <linux/types.h>
 #include <linux/slab.h>
 #include <linux/pm_runtime.h>
+#include <linux/sysfs.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 #include "sleep.h"
@@ -417,24 +418,101 @@ static void acpi_power_remove_dependent(struct acpi_power_resource *resource,
 	}
 }
 
-void acpi_power_add_remove_device(struct acpi_device *adev, bool add)
+static struct attribute *attrs[] = {
+	NULL,
+};
+
+static struct attribute_group attr_groups[] = {
+	[ACPI_STATE_D0] = {
+		.name = "power_resources_D0",
+		.attrs = attrs,
+	},
+	[ACPI_STATE_D1] = {
+		.name = "power_resources_D1",
+		.attrs = attrs,
+	},
+	[ACPI_STATE_D2] = {
+		.name = "power_resources_D2",
+		.attrs = attrs,
+	},
+	[ACPI_STATE_D3_HOT] = {
+		.name = "power_resources_D3hot",
+		.attrs = attrs,
+	},
+};
+
+static void acpi_power_hide_list(struct acpi_device *adev, int state)
+{
+	struct acpi_device_power_state *ps = &adev->power.states[state];
+	struct acpi_power_resource_entry *entry;
+
+	if (list_empty(&ps->resources))
+		return;
+
+	list_for_each_entry_reverse(entry, &ps->resources, node) {
+		struct acpi_device *res_dev = &entry->resource->device;
+
+		sysfs_remove_link_from_group(&adev->dev.kobj,
+					     attr_groups[state].name,
+					     dev_name(&res_dev->dev));
+	}
+	sysfs_remove_group(&adev->dev.kobj, &attr_groups[state]);
+}
+
+static void acpi_power_expose_list(struct acpi_device *adev, int state)
 {
-	if (adev->power.flags.power_resources) {
-		struct acpi_device_power_state *ps;
-		struct acpi_power_resource_entry *entry;
-
-		ps = &adev->power.states[ACPI_STATE_D0];
-		list_for_each_entry(entry, &ps->resources, node) {
-			struct acpi_power_resource *resource = entry->resource;
-
-			if (add)
-				acpi_power_add_dependent(resource, adev);
-			else
-				acpi_power_remove_dependent(resource, adev);
+	struct acpi_device_power_state *ps = &adev->power.states[state];
+	struct acpi_power_resource_entry *entry;
+	int ret;
+
+	if (list_empty(&ps->resources))
+		return;
+
+	ret = sysfs_create_group(&adev->dev.kobj, &attr_groups[state]);
+	if (ret)
+		return;
+
+	list_for_each_entry(entry, &ps->resources, node) {
+		struct acpi_device *res_dev = &entry->resource->device;
+
+		ret = sysfs_add_link_to_group(&adev->dev.kobj,
+					      attr_groups[state].name,
+					      &res_dev->dev.kobj,
+					      dev_name(&res_dev->dev));
+		if (ret) {
+			acpi_power_hide_list(adev, state);
+			break;
 		}
 	}
 }
 
+void acpi_power_add_remove_device(struct acpi_device *adev, bool add)
+{
+	struct acpi_device_power_state *ps;
+	struct acpi_power_resource_entry *entry;
+	int state;
+
+	if (!adev->power.flags.power_resources)
+		return;
+
+	ps = &adev->power.states[ACPI_STATE_D0];
+	list_for_each_entry(entry, &ps->resources, node) {
+		struct acpi_power_resource *resource = entry->resource;
+
+		if (add)
+			acpi_power_add_dependent(resource, adev);
+		else
+			acpi_power_remove_dependent(resource, adev);
+	}
+
+	for (state = ACPI_STATE_D0; state <= ACPI_STATE_D3_HOT; state++) {
+		if (add)
+			acpi_power_expose_list(adev, state);
+		else
+			acpi_power_hide_list(adev, state);
+	}
+}
+
 int acpi_power_min_system_level(struct list_head *list)
 {
 	struct acpi_power_resource_entry *entry;

commit b1c0f99bfb89cd9b42e3119ab822a8102fa87909
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 24 12:50:09 2013 +0100

    ACPI / PM: Expose current status of ACPI power resources
    
    Since ACPI power resources are going to be used more extensively on
    new hardware platforms, it becomes necessary for user space (powertop
    in particular) to observe some properties of those resources for
    diagnostics purposes.
    
    For this reason, expose the current status of each ACPI power
    resource to user space via sysfs by adding a new resource_in_use
    attribute to the sysfs directory representing the given power
    resource.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 3f16dd4db23e..946720a4db57 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -87,6 +87,12 @@ static DEFINE_MUTEX(power_resource_list_lock);
                              Power Resource Management
    -------------------------------------------------------------------------- */
 
+static inline
+struct acpi_power_resource *to_power_resource(struct acpi_device *device)
+{
+	return container_of(device, struct acpi_power_resource, device);
+}
+
 static struct acpi_power_resource *acpi_power_get_context(acpi_handle handle)
 {
 	struct acpi_device *device;
@@ -94,7 +100,7 @@ static struct acpi_power_resource *acpi_power_get_context(acpi_handle handle)
 	if (acpi_bus_get_device(handle, &device))
 		return NULL;
 
-	return container_of(device, struct acpi_power_resource, device);
+	return to_power_resource(device);
 }
 
 static int acpi_power_resources_list_add(acpi_handle handle,
@@ -678,6 +684,21 @@ static void acpi_release_power_resource(struct device *dev)
 	kfree(resource);
 }
 
+static ssize_t acpi_power_in_use_show(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf) {
+	struct acpi_power_resource *resource;
+
+	resource = to_power_resource(to_acpi_device(dev));
+	return sprintf(buf, "%u\n", !!resource->ref_count);
+}
+static DEVICE_ATTR(resource_in_use, 0444, acpi_power_in_use_show, NULL);
+
+static void acpi_power_sysfs_remove(struct acpi_device *device)
+{
+	device_remove_file(&device->dev, &dev_attr_resource_in_use);
+}
+
 int acpi_add_power_resource(acpi_handle handle)
 {
 	struct acpi_power_resource *resource;
@@ -725,6 +746,9 @@ int acpi_add_power_resource(acpi_handle handle)
 	if (result)
 		goto err;
 
+	if (!device_create_file(&device->dev, &dev_attr_resource_in_use))
+		device->remove = acpi_power_sysfs_remove;
+
 	mutex_lock(&power_resource_list_lock);
 	list_add(&resource->list_node, &acpi_power_resource_list);
 	mutex_unlock(&power_resource_list_lock);

commit cf860be639d86ed77af179c925085ae0721ae602
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 24 12:49:49 2013 +0100

    ACPI / scan: Prevent device add uevents from racing with user space
    
    ACPI core adds sysfs device files after the given devices have been
    registered with device_register(), which is not appropriate, because
    it may lead to race conditions with user space tools using those
    files.
    
    Fix the problem by delaying the KOBJ_ADD uevent for ACPI devices
    until after all of the devices' sysfs files have been created.
    
    This also fixes a use-after-free in acpi_device_unregister().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 6db261c237d4..3f16dd4db23e 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -721,13 +721,14 @@ int acpi_add_power_resource(acpi_handle handle)
 	       acpi_device_bid(device), state ? "on" : "off");
 
 	device->flags.match_driver = true;
-	result = acpi_device_register(device, acpi_release_power_resource);
+	result = acpi_device_add(device, acpi_release_power_resource);
 	if (result)
 		goto err;
 
 	mutex_lock(&power_resource_list_lock);
 	list_add(&resource->list_node, &acpi_power_resource_list);
 	mutex_unlock(&power_resource_list_lock);
+	acpi_device_add_finalize(device);
 	return 0;
 
  err:

commit 87e753b0065f94314ebdacf6593a172cdd7839c8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 22 12:56:16 2013 +0100

    ACPI / PM: Sanitize checks in acpi_power_on_resources()
    
    After the only user of acpi_power_on_resources(),
    acpi_bus_init_power(), has been changed to avoid calling it
    for state equal to ACPI_STATE_D3_COLD, it doesn't have to special
    case that state any more.
    
    For this reason, modify the checks in acpi_power_on_resources()
    so that it returns -EINVAL for ACPI_STATE_D3_COLD as it should.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 089a7c39348f..6db261c237d4 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -622,12 +622,9 @@ int acpi_power_get_inferred_state(struct acpi_device *device, int *state)
 
 int acpi_power_on_resources(struct acpi_device *device, int state)
 {
-	if (!device || state < ACPI_STATE_D0 || state > ACPI_STATE_D3_COLD)
+	if (!device || state < ACPI_STATE_D0 || state > ACPI_STATE_D3_HOT)
 		return -EINVAL;
 
-	if (state == ACPI_STATE_D3_COLD)
-		return 0;
-
 	return acpi_power_on_list(&device->power.states[state].resources);
 }
 

commit 0596a52b8357b25185e06af32973225baeb7196a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:07 2013 +0100

    ACPI: Use system level attribute of wakeup power resources
    
    The system level attribute of ACPI power resources is the lowest
    system sleep level (S0, S2 etc.) in which the given resource can be
    "on" (ACPI 5.0, Section 7.1).  On the other hand, wakeup power
    resources have to be "on" for devices depending on them to be able to
    signal wakeup.  Therefore devices cannot wake up the system from
    sleep states higher than the minimum of the system level attributes
    of their wakeup power resources.
    
    Use the wakeup power resources' system level values to get the
    deepest system sleep state (highest system sleep level) the given
    device can wake up the system from.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 1600f753fafe..089a7c39348f 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -429,6 +429,20 @@ void acpi_power_add_remove_device(struct acpi_device *adev, bool add)
 	}
 }
 
+int acpi_power_min_system_level(struct list_head *list)
+{
+	struct acpi_power_resource_entry *entry;
+	int system_level = 5;
+
+	list_for_each_entry(entry, list, node) {
+		struct acpi_power_resource *resource = entry->resource;
+
+		if (system_level > resource->system_level)
+			system_level = resource->system_level;
+	}
+	return system_level;
+}
+
 /* --------------------------------------------------------------------------
                              Device Power Management
    -------------------------------------------------------------------------- */

commit e88c9c603b2ad0cd0fbe90afedba3f1becbbeb79
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:07 2013 +0100

    ACPI: Take power resource initialization errors into account
    
    Some ACPI power resource initialization errors, like memory
    allocation errors, are not taken into account appropriately in some
    cases, which may lead to a device having an incomplete list of power
    resources that one of its power states depends on, for one example.
    
    Rework the power resource initialization and namespace scanning code
    so that power resource initialization errors are treated more
    seriously.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 4b93c97aff9f..1600f753fafe 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -97,18 +97,18 @@ static struct acpi_power_resource *acpi_power_get_context(acpi_handle handle)
 	return container_of(device, struct acpi_power_resource, device);
 }
 
-static void acpi_power_resources_list_add(acpi_handle handle,
-					  struct list_head *list)
+static int acpi_power_resources_list_add(acpi_handle handle,
+					 struct list_head *list)
 {
 	struct acpi_power_resource *resource = acpi_power_get_context(handle);
 	struct acpi_power_resource_entry *entry;
 
 	if (!resource || !list)
-		return;
+		return -EINVAL;
 
 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry)
-		return;
+		return -ENOMEM;
 
 	entry->resource = resource;
 	if (!list_empty(list)) {
@@ -117,10 +117,11 @@ static void acpi_power_resources_list_add(acpi_handle handle,
 		list_for_each_entry(e, list, node)
 			if (e->resource->order > resource->order) {
 				list_add_tail(&entry->node, &e->node);
-				return;
+				return 0;
 			}
 	}
 	list_add_tail(&entry->node, list);
+	return 0;
 }
 
 void acpi_power_resources_list_free(struct list_head *list)
@@ -133,33 +134,37 @@ void acpi_power_resources_list_free(struct list_head *list)
 	}
 }
 
-acpi_status acpi_extract_power_resources(union acpi_object *package,
-					 unsigned int start,
-					 struct list_head *list)
+int acpi_extract_power_resources(union acpi_object *package, unsigned int start,
+				 struct list_head *list)
 {
-	acpi_status status = AE_OK;
 	unsigned int i;
+	int err = 0;
 
 	for (i = start; i < package->package.count; i++) {
 		union acpi_object *element = &package->package.elements[i];
 		acpi_handle rhandle;
 
 		if (element->type != ACPI_TYPE_LOCAL_REFERENCE) {
-			status = AE_BAD_DATA;
+			err = -ENODATA;
 			break;
 		}
 		rhandle = element->reference.handle;
 		if (!rhandle) {
-			status = AE_NULL_ENTRY;
+			err = -ENODEV;
 			break;
 		}
-		acpi_add_power_resource(rhandle);
-		acpi_power_resources_list_add(rhandle, list);
+		err = acpi_add_power_resource(rhandle);
+		if (err)
+			break;
+
+		err = acpi_power_resources_list_add(rhandle, list);
+		if (err)
+			break;
 	}
-	if (ACPI_FAILURE(status))
+	if (err)
 		acpi_power_resources_list_free(list);
 
-	return status;
+	return err;
 }
 
 static int acpi_power_get_state(acpi_handle handle, int *state)
@@ -662,7 +667,7 @@ static void acpi_release_power_resource(struct device *dev)
 	kfree(resource);
 }
 
-void acpi_add_power_resource(acpi_handle handle)
+int acpi_add_power_resource(acpi_handle handle)
 {
 	struct acpi_power_resource *resource;
 	struct acpi_device *device = NULL;
@@ -673,11 +678,11 @@ void acpi_add_power_resource(acpi_handle handle)
 
 	acpi_bus_get_device(handle, &device);
 	if (device)
-		return;
+		return 0;
 
 	resource = kzalloc(sizeof(*resource), GFP_KERNEL);
 	if (!resource)
-		return;
+		return -ENOMEM;
 
 	device = &resource->device;
 	acpi_init_device_object(device, handle, ACPI_BUS_TYPE_POWER,
@@ -712,10 +717,11 @@ void acpi_add_power_resource(acpi_handle handle)
 	mutex_lock(&power_resource_list_lock);
 	list_add(&resource->list_node, &acpi_power_resource_list);
 	mutex_unlock(&power_resource_list_lock);
-	return;
+	return 0;
 
  err:
 	acpi_release_power_resource(&device->dev);
+	return result;
 }
 
 #ifdef CONFIG_ACPI_SLEEP

commit ef85bdbec444b42775a18580c6bfe1307a63ef0f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:07 2013 +0100

    ACPI / scan: Consolidate extraction of power resources lists
    
    The lists of ACPI power resources are currently extracted in two
    different ways, one for wakeup power resources and one for power
    resources that device power states depend on.  There is no reason
    why it should be done differently in those two cases, so introduce
    a common routine for extracting power resources lists from data
    returned by AML, acpi_extract_power_resources(), and make the
    namespace scanning code use it for both wakeup and device power
    states power resources.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 242feca231eb..4b93c97aff9f 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -97,7 +97,8 @@ static struct acpi_power_resource *acpi_power_get_context(acpi_handle handle)
 	return container_of(device, struct acpi_power_resource, device);
 }
 
-void acpi_power_resources_list_add(acpi_handle handle, struct list_head *list)
+static void acpi_power_resources_list_add(acpi_handle handle,
+					  struct list_head *list)
 {
 	struct acpi_power_resource *resource = acpi_power_get_context(handle);
 	struct acpi_power_resource_entry *entry;
@@ -132,6 +133,35 @@ void acpi_power_resources_list_free(struct list_head *list)
 	}
 }
 
+acpi_status acpi_extract_power_resources(union acpi_object *package,
+					 unsigned int start,
+					 struct list_head *list)
+{
+	acpi_status status = AE_OK;
+	unsigned int i;
+
+	for (i = start; i < package->package.count; i++) {
+		union acpi_object *element = &package->package.elements[i];
+		acpi_handle rhandle;
+
+		if (element->type != ACPI_TYPE_LOCAL_REFERENCE) {
+			status = AE_BAD_DATA;
+			break;
+		}
+		rhandle = element->reference.handle;
+		if (!rhandle) {
+			status = AE_NULL_ENTRY;
+			break;
+		}
+		acpi_add_power_resource(rhandle);
+		acpi_power_resources_list_add(rhandle, list);
+	}
+	if (ACPI_FAILURE(status))
+		acpi_power_resources_list_free(list);
+
+	return status;
+}
+
 static int acpi_power_get_state(acpi_handle handle, int *state)
 {
 	acpi_status status = AE_OK;

commit 993cbe595dda731471a07f4f65575fadedc570dc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:06 2013 +0100

    ACPI / PM: Take order attribute of wakeup power resources into account
    
    ACPI power resources have an order attribute that should be taken
    into account when turning them on and off, but it is not used now.
    
    Modify the power resources management code to preserve the
    spec-compliant ordering of wakeup power resources.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 22a3d00d0359..242feca231eb 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -469,7 +469,7 @@ int acpi_device_sleep_wake(struct acpi_device *dev,
  */
 int acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state)
 {
-	int i, err = 0;
+	int err = 0;
 
 	if (!dev || !dev->wakeup.flags.valid)
 		return -EINVAL;
@@ -479,24 +479,17 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state)
 	if (dev->wakeup.prepare_count++)
 		goto out;
 
-	/* Open power resource */
-	for (i = 0; i < dev->wakeup.resources.count; i++) {
-		int ret = acpi_power_on(dev->wakeup.resources.handles[i]);
-		if (ret) {
-			printk(KERN_ERR PREFIX "Transition power state\n");
-			dev->wakeup.flags.valid = 0;
-			err = -ENODEV;
-			goto err_out;
-		}
+	err = acpi_power_on_list(&dev->wakeup.resources);
+	if (err) {
+		dev_err(&dev->dev, "Cannot turn wakeup power resources on\n");
+		dev->wakeup.flags.valid = 0;
+	} else {
+		/*
+		 * Passing 3 as the third argument below means the device may be
+		 * put into arbitrary power state afterward.
+		 */
+		err = acpi_device_sleep_wake(dev, 1, sleep_state, 3);
 	}
-
-	/*
-	 * Passing 3 as the third argument below means the device may be placed
-	 * in arbitrary power state afterwards.
-	 */
-	err = acpi_device_sleep_wake(dev, 1, sleep_state, 3);
-
- err_out:
 	if (err)
 		dev->wakeup.prepare_count = 0;
 
@@ -513,7 +506,7 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state)
  */
 int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 {
-	int i, err = 0;
+	int err = 0;
 
 	if (!dev || !dev->wakeup.flags.valid)
 		return -EINVAL;
@@ -534,15 +527,10 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 	if (err)
 		goto out;
 
-	/* Close power resource */
-	for (i = 0; i < dev->wakeup.resources.count; i++) {
-		int ret = acpi_power_off(dev->wakeup.resources.handles[i]);
-		if (ret) {
-			printk(KERN_ERR PREFIX "Transition power state\n");
-			dev->wakeup.flags.valid = 0;
-			err = -ENODEV;
-			goto out;
-		}
+	err = acpi_power_off_list(&dev->wakeup.resources);
+	if (err) {
+		dev_err(&dev->dev, "Cannot turn wakeup power resources off\n");
+		dev->wakeup.flags.valid = 0;
 	}
 
  out:

commit 0b224527323669c66e0a37ae05b04034bfcdce14
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:06 2013 +0100

    ACPI / PM: Take order attribute of power resources into account
    
    ACPI power resources have an order attribute that should be taken
    into account when turning them on and off, but it is not used now.
    
    Modify the power resources management code to preserve the
    spec-compliant ordering of power resources that power states of
    devices depend on (analogous changes will be done separately for
    power resources used for wakeup).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 06ad05288af8..22a3d00d0359 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -75,6 +75,11 @@ struct acpi_power_resource {
 	struct mutex resource_lock;
 };
 
+struct acpi_power_resource_entry {
+	struct list_head node;
+	struct acpi_power_resource *resource;
+};
+
 static LIST_HEAD(acpi_power_resource_list);
 static DEFINE_MUTEX(power_resource_list_lock);
 
@@ -92,6 +97,41 @@ static struct acpi_power_resource *acpi_power_get_context(acpi_handle handle)
 	return container_of(device, struct acpi_power_resource, device);
 }
 
+void acpi_power_resources_list_add(acpi_handle handle, struct list_head *list)
+{
+	struct acpi_power_resource *resource = acpi_power_get_context(handle);
+	struct acpi_power_resource_entry *entry;
+
+	if (!resource || !list)
+		return;
+
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		return;
+
+	entry->resource = resource;
+	if (!list_empty(list)) {
+		struct acpi_power_resource_entry *e;
+
+		list_for_each_entry(e, list, node)
+			if (e->resource->order > resource->order) {
+				list_add_tail(&entry->node, &e->node);
+				return;
+			}
+	}
+	list_add_tail(&entry->node, list);
+}
+
+void acpi_power_resources_list_free(struct list_head *list)
+{
+	struct acpi_power_resource_entry *entry, *e;
+
+	list_for_each_entry_safe(entry, e, list, node) {
+		list_del(&entry->node);
+		kfree(entry);
+	}
+}
+
 static int acpi_power_get_state(acpi_handle handle, int *state)
 {
 	acpi_status status = AE_OK;
@@ -119,31 +159,23 @@ static int acpi_power_get_state(acpi_handle handle, int *state)
 	return 0;
 }
 
-static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
+static int acpi_power_get_list_state(struct list_head *list, int *state)
 {
+	struct acpi_power_resource_entry *entry;
 	int cur_state;
-	int i = 0;
 
 	if (!list || !state)
 		return -EINVAL;
 
 	/* The state of the list is 'on' IFF all resources are 'on'. */
-
-	for (i = 0; i < list->count; i++) {
-		struct acpi_power_resource *resource;
-		acpi_handle handle = list->handles[i];
+	list_for_each_entry(entry, list, node) {
+		struct acpi_power_resource *resource = entry->resource;
+		acpi_handle handle = resource->device.handle;
 		int result;
 
-		resource = acpi_power_get_context(handle);
-		if (!resource)
-			return -ENODEV;
-
 		mutex_lock(&resource->resource_lock);
-
 		result = acpi_power_get_state(handle, &cur_state);
-
 		mutex_unlock(&resource->resource_lock);
-
 		if (result)
 			return result;
 
@@ -155,7 +187,6 @@ static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 			  cur_state ? "on" : "off"));
 
 	*state = cur_state;
-
 	return 0;
 }
 
@@ -199,14 +230,9 @@ static int __acpi_power_on(struct acpi_power_resource *resource)
 	return 0;
 }
 
-static int acpi_power_on(acpi_handle handle)
+static int acpi_power_on(struct acpi_power_resource *resource)
 {
-	int result = 0;
-	struct acpi_power_resource *resource;
-
-	resource = acpi_power_get_context(handle);
-	if (!resource)
-		return -ENODEV;
+	int result = 0;;
 
 	mutex_lock(&resource->resource_lock);
 
@@ -231,15 +257,10 @@ static int acpi_power_on(acpi_handle handle)
 	return result;
 }
 
-static int acpi_power_off(acpi_handle handle)
+static int acpi_power_off(struct acpi_power_resource *resource)
 {
-	int result = 0;
 	acpi_status status = AE_OK;
-	struct acpi_power_resource *resource;
-
-	resource = acpi_power_get_context(handle);
-	if (!resource)
-		return -ENODEV;
+	int result = 0;
 
 	mutex_lock(&resource->resource_lock);
 
@@ -271,47 +292,48 @@ static int acpi_power_off(acpi_handle handle)
 	return result;
 }
 
-static void __acpi_power_off_list(struct acpi_handle_list *list, int num_res)
+static int acpi_power_off_list(struct list_head *list)
 {
-	int i;
+	struct acpi_power_resource_entry *entry;
+	int result = 0;
 
-	for (i = num_res - 1; i >= 0 ; i--)
-		acpi_power_off(list->handles[i]);
-}
+	list_for_each_entry_reverse(entry, list, node) {
+		result = acpi_power_off(entry->resource);
+		if (result)
+			goto err;
+	}
+	return 0;
 
-static void acpi_power_off_list(struct acpi_handle_list *list)
-{
-	__acpi_power_off_list(list, list->count);
+ err:
+	list_for_each_entry_continue(entry, list, node)
+		acpi_power_on(entry->resource);
+
+	return result;
 }
 
-static int acpi_power_on_list(struct acpi_handle_list *list)
+static int acpi_power_on_list(struct list_head *list)
 {
+	struct acpi_power_resource_entry *entry;
 	int result = 0;
-	int i;
 
-	for (i = 0; i < list->count; i++) {
-		result = acpi_power_on(list->handles[i]);
-		if (result) {
-			__acpi_power_off_list(list, i);
-			break;
-		}
+	list_for_each_entry(entry, list, node) {
+		result = acpi_power_on(entry->resource);
+		if (result)
+			goto err;
 	}
+	return 0;
+
+ err:
+	list_for_each_entry_continue_reverse(entry, list, node)
+		acpi_power_off(entry->resource);
 
 	return result;
 }
 
-static void acpi_power_add_dependent(acpi_handle rhandle,
+static void acpi_power_add_dependent(struct acpi_power_resource *resource,
 				     struct acpi_device *adev)
 {
 	struct acpi_power_dependent_device *dep;
-	struct acpi_power_resource *resource;
-
-	if (!rhandle || !adev)
-		return;
-
-	resource = acpi_power_get_context(rhandle);
-	if (!resource)
-		return;
 
 	mutex_lock(&resource->resource_lock);
 
@@ -331,20 +353,12 @@ static void acpi_power_add_dependent(acpi_handle rhandle,
 	mutex_unlock(&resource->resource_lock);
 }
 
-static void acpi_power_remove_dependent(acpi_handle rhandle,
+static void acpi_power_remove_dependent(struct acpi_power_resource *resource,
 					struct acpi_device *adev)
 {
 	struct acpi_power_dependent_device *dep;
-	struct acpi_power_resource *resource;
 	struct work_struct *work = NULL;
 
-	if (!rhandle || !adev)
-		return;
-
-	resource = acpi_power_get_context(rhandle);
-	if (!resource)
-		return;
-
 	mutex_lock(&resource->resource_lock);
 
 	list_for_each_entry(dep, &resource->dependent, node)
@@ -366,16 +380,16 @@ void acpi_power_add_remove_device(struct acpi_device *adev, bool add)
 {
 	if (adev->power.flags.power_resources) {
 		struct acpi_device_power_state *ps;
-		int j;
+		struct acpi_power_resource_entry *entry;
 
 		ps = &adev->power.states[ACPI_STATE_D0];
-		for (j = 0; j < ps->resources.count; j++) {
-			acpi_handle rhandle = ps->resources.handles[j];
+		list_for_each_entry(entry, &ps->resources, node) {
+			struct acpi_power_resource *resource = entry->resource;
 
 			if (add)
-				acpi_power_add_dependent(rhandle, adev);
+				acpi_power_add_dependent(resource, adev);
 			else
-				acpi_power_remove_dependent(rhandle, adev);
+				acpi_power_remove_dependent(resource, adev);
 		}
 	}
 }
@@ -539,7 +553,6 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 int acpi_power_get_inferred_state(struct acpi_device *device, int *state)
 {
 	int result = 0;
-	struct acpi_handle_list *list = NULL;
 	int list_state = 0;
 	int i = 0;
 
@@ -551,8 +564,9 @@ int acpi_power_get_inferred_state(struct acpi_device *device, int *state)
 	 * required for a given D-state are 'on'.
 	 */
 	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3_HOT; i++) {
-		list = &device->power.states[i].resources;
-		if (list->count < 1)
+		struct list_head *list = &device->power.states[i].resources;
+
+		if (list_empty(list))
 			continue;
 
 		result = acpi_power_get_list_state(list, &list_state);
@@ -571,9 +585,12 @@ int acpi_power_get_inferred_state(struct acpi_device *device, int *state)
 
 int acpi_power_on_resources(struct acpi_device *device, int state)
 {
-	if (!device || state < ACPI_STATE_D0 || state > ACPI_STATE_D3)
+	if (!device || state < ACPI_STATE_D0 || state > ACPI_STATE_D3_COLD)
 		return -EINVAL;
 
+	if (state == ACPI_STATE_D3_COLD)
+		return 0;
+
 	return acpi_power_on_list(&device->power.states[state].resources);
 }
 
@@ -584,7 +601,7 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3_COLD))
 		return -EINVAL;
 
-	if (device->power.state == state)
+	if (device->power.state == state || !device->flags.power_manageable)
 		return 0;
 
 	if ((device->power.state < ACPI_STATE_D0)

commit 722c929f32616943d2b67332068f09c08e81eec8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:06 2013 +0100

    ACPI: Do not use device power states of power resources
    
    ACPI power resource objects have struct acpi_device components, but
    they are only used for registering those resources in the device
    hierarchy.  In particular, power state information stored in them is
    completely useless (amnong other things, because the power resources
    "devices" are not power manageable), so there is no reason for the
    power resources management code to keep it up to date.
    
    Remove the code updating device power states of power resources from
    drivers/acpi/power.c.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 29803857a2ef..06ad05288af8 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -193,9 +193,6 @@ static int __acpi_power_on(struct acpi_power_resource *resource)
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
-	/* Update the power resource's _device_ power state */
-	resource->device.power.state = ACPI_STATE_D0;
-
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Power resource [%s] turned on\n",
 			  resource->name));
 
@@ -261,16 +258,12 @@ static int acpi_power_off(acpi_handle handle)
 	}
 
 	status = acpi_evaluate_object(resource->device.handle, "_OFF", NULL, NULL);
-	if (ACPI_FAILURE(status)) {
+	if (ACPI_FAILURE(status))
 		result = -ENODEV;
-	} else {
-		/* Update the power resource's _device_ power state */
-		resource->device.power.state = ACPI_STATE_D3;
-
+	else
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Power resource [%s] turned off\n",
 				  resource->name));
-	}
 
  unlock:
 	mutex_unlock(&resource->resource_lock);
@@ -659,6 +652,7 @@ void acpi_add_power_resource(acpi_handle handle)
 	resource->name = device->pnp.bus_id;
 	strcpy(acpi_device_name(device), ACPI_POWER_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_POWER_CLASS);
+	device->power.state = ACPI_STATE_UNKNOWN;
 
 	/* Evalute the object to get the system level and resource order. */
 	status = acpi_evaluate_object(handle, NULL, NULL, &buffer);
@@ -672,17 +666,6 @@ void acpi_add_power_resource(acpi_handle handle)
 	if (result)
 		goto err;
 
-	switch (state) {
-	case ACPI_POWER_RESOURCE_STATE_ON:
-		device->power.state = ACPI_STATE_D0;
-		break;
-	case ACPI_POWER_RESOURCE_STATE_OFF:
-		device->power.state = ACPI_STATE_D3;
-		break;
-	default:
-		device->power.state = ACPI_STATE_UNKNOWN;
-	}
-
 	printk(KERN_INFO PREFIX "%s [%s] (%s)\n", acpi_device_name(device),
 	       acpi_device_bid(device), state ? "on" : "off");
 

commit 781d737c7466845035e5ce02885c7436b5278b90
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:06 2013 +0100

    ACPI: Drop power resources driver
    
    The ACPI power resources driver is not very useful, because the only
    thing it really does is to restore the state of the power resources
    that were "on" before system suspend or hibernation, but that may be
    achieved in a different way.
    
    Drop the ACPI power resources driver entirely and add
    acpi_resume_power_resources() that will walk the list of all
    registered power resources during system resume and turn on the ones
    that were "on" before the preceding system suspend or hibernation.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index b12933fd2e56..29803857a2ef 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -58,27 +58,6 @@ ACPI_MODULE_NAME("power");
 #define ACPI_POWER_RESOURCE_STATE_ON	0x01
 #define ACPI_POWER_RESOURCE_STATE_UNKNOWN 0xFF
 
-static inline int acpi_power_add(struct acpi_device *device) { return 0; }
-
-static const struct acpi_device_id power_device_ids[] = {
-	{ACPI_POWER_HID, 0},
-	{"", 0},
-};
-MODULE_DEVICE_TABLE(acpi, power_device_ids);
-
-#ifdef CONFIG_PM_SLEEP
-static int acpi_power_resume(struct device *dev);
-#endif
-static SIMPLE_DEV_PM_OPS(acpi_power_pm, NULL, acpi_power_resume);
-
-static struct acpi_driver acpi_power_driver = {
-	.name = "power",
-	.class = ACPI_POWER_CLASS,
-	.ids = power_device_ids,
-	.ops.add = acpi_power_add,
-	.drv.pm = &acpi_power_pm,
-};
-
 struct acpi_power_dependent_device {
 	struct list_head node;
 	struct acpi_device *adev;
@@ -87,6 +66,7 @@ struct acpi_power_dependent_device {
 
 struct acpi_power_resource {
 	struct acpi_device device;
+	struct list_head list_node;
 	struct list_head dependent;
 	char *name;
 	u32 system_level;
@@ -95,7 +75,8 @@ struct acpi_power_resource {
 	struct mutex resource_lock;
 };
 
-static struct list_head acpi_power_resource_list;
+static LIST_HEAD(acpi_power_resource_list);
+static DEFINE_MUTEX(power_resource_list_lock);
 
 /* --------------------------------------------------------------------------
                              Power Resource Management
@@ -643,8 +624,13 @@ static void acpi_release_power_resource(struct device *dev)
 	struct acpi_device *device = to_acpi_device(dev);
 	struct acpi_power_resource *resource;
 
-	acpi_free_ids(device);
 	resource = container_of(device, struct acpi_power_resource, device);
+
+	mutex_lock(&power_resource_list_lock);
+	list_del(&resource->list_node);
+	mutex_unlock(&power_resource_list_lock);
+
+	acpi_free_ids(device);
 	kfree(resource);
 }
 
@@ -677,14 +663,14 @@ void acpi_add_power_resource(acpi_handle handle)
 	/* Evalute the object to get the system level and resource order. */
 	status = acpi_evaluate_object(handle, NULL, NULL, &buffer);
 	if (ACPI_FAILURE(status))
-		goto out;
+		goto err;
 
 	resource->system_level = acpi_object.power_resource.system_level;
 	resource->order = acpi_object.power_resource.resource_order;
 
 	result = acpi_power_get_state(handle, &state);
 	if (result)
-		goto out;
+		goto err;
 
 	switch (state) {
 	case ACPI_POWER_RESOURCE_STATE_ON:
@@ -702,51 +688,40 @@ void acpi_add_power_resource(acpi_handle handle)
 
 	device->flags.match_driver = true;
 	result = acpi_device_register(device, acpi_release_power_resource);
-
- out:
 	if (result)
-		acpi_release_power_resource(&device->dev);
+		goto err;
 
+	mutex_lock(&power_resource_list_lock);
+	list_add(&resource->list_node, &acpi_power_resource_list);
+	mutex_unlock(&power_resource_list_lock);
 	return;
-}
 
-/* --------------------------------------------------------------------------
-                                Driver Interface
-   -------------------------------------------------------------------------- */
+ err:
+	acpi_release_power_resource(&device->dev);
+}
 
-#ifdef CONFIG_PM_SLEEP
-static int acpi_power_resume(struct device *dev)
+#ifdef CONFIG_ACPI_SLEEP
+void acpi_resume_power_resources(void)
 {
-	int result = 0, state;
-	struct acpi_device *device;
 	struct acpi_power_resource *resource;
 
-	if (!dev)
-		return -EINVAL;
+	mutex_lock(&power_resource_list_lock);
 
-	device = to_acpi_device(dev);
-	resource = acpi_driver_data(device);
-	if (!resource)
-		return -EINVAL;
-
-	mutex_lock(&resource->resource_lock);
+	list_for_each_entry(resource, &acpi_power_resource_list, list_node) {
+		int result, state;
 
-	result = acpi_power_get_state(device->handle, &state);
-	if (result)
-		goto unlock;
+		mutex_lock(&resource->resource_lock);
 
-	if (state == ACPI_POWER_RESOURCE_STATE_OFF && resource->ref_count)
-		result = __acpi_power_on(resource);
+		result = acpi_power_get_state(resource->device.handle, &state);
+		if (!result && state == ACPI_POWER_RESOURCE_STATE_OFF
+		    && resource->ref_count) {
+			dev_info(&resource->device.dev, "Turning ON\n");
+			__acpi_power_on(resource);
+		}
 
- unlock:
-	mutex_unlock(&resource->resource_lock);
+		mutex_unlock(&resource->resource_lock);
+	}
 
-	return result;
+	mutex_unlock(&power_resource_list_lock);
 }
 #endif
-
-int __init acpi_power_init(void)
-{
-	INIT_LIST_HEAD(&acpi_power_resource_list);
-	return acpi_bus_register_driver(&acpi_power_driver);
-}

commit 82c7d5efaadf99fb4a26500cd5b59b6fd7659772
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:05 2013 +0100

    ACPI / scan: Treat power resources in a special way
    
    ACPI power resources need to be treated in a special way by the
    namespace scanning code, because they need to be ready to use as
    soon as they have been discovered (even before registering ACPI
    device nodes using them for power management).
    
    For this reason, it doesn't make sense to separate the preparation
    of struct acpi_device objects representing them in the device
    hierarchy from the creation of struct acpi_power_resource objects
    actually used for power resource manipulation.  Accordingly, it
    doesn't make sense to define non-empty .add() and .remove() callbacks
    in the power resources "driver" (in fact, it is questionable whether
    or not it is useful to register such a "driver" at all).
    
    Rearrange the code in scan.c and power.c so that power resources are
    initialized entirely by one routine, acpi_add_power_resource(), that
    also prepares their struct acpi_device objects and registers them
    with the driver core, telling it to use a special release routine,
    acpi_release_power_resource(), for removing objects that represent
    power resources from memory.  Make the ACPI namespace scanning code
    in scan.c always use acpi_add_power_resource() for preparing and
    registering objects that represent power resources.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 659386c4f0cb..b12933fd2e56 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -58,8 +58,7 @@ ACPI_MODULE_NAME("power");
 #define ACPI_POWER_RESOURCE_STATE_ON	0x01
 #define ACPI_POWER_RESOURCE_STATE_UNKNOWN 0xFF
 
-static int acpi_power_add(struct acpi_device *device);
-static int acpi_power_remove(struct acpi_device *device, int type);
+static inline int acpi_power_add(struct acpi_device *device) { return 0; }
 
 static const struct acpi_device_id power_device_ids[] = {
 	{ACPI_POWER_HID, 0},
@@ -76,10 +75,7 @@ static struct acpi_driver acpi_power_driver = {
 	.name = "power",
 	.class = ACPI_POWER_CLASS,
 	.ids = power_device_ids,
-	.ops = {
-		.add = acpi_power_add,
-		.remove = acpi_power_remove,
-		},
+	.ops.add = acpi_power_add,
 	.drv.pm = &acpi_power_pm,
 };
 
@@ -90,9 +86,9 @@ struct acpi_power_dependent_device {
 };
 
 struct acpi_power_resource {
-	struct acpi_device *device;
+	struct acpi_device device;
 	struct list_head dependent;
-	acpi_bus_id name;
+	char *name;
 	u32 system_level;
 	u32 order;
 	unsigned int ref_count;
@@ -105,28 +101,14 @@ static struct list_head acpi_power_resource_list;
                              Power Resource Management
    -------------------------------------------------------------------------- */
 
-static int
-acpi_power_get_context(acpi_handle handle,
-		       struct acpi_power_resource **resource)
+static struct acpi_power_resource *acpi_power_get_context(acpi_handle handle)
 {
-	int result = 0;
-	struct acpi_device *device = NULL;
-
-
-	if (!resource)
-		return -ENODEV;
-
-	result = acpi_bus_get_device(handle, &device);
-	if (result) {
-		printk(KERN_WARNING PREFIX "Getting context [%p]\n", handle);
-		return result;
-	}
+	struct acpi_device *device;
 
-	*resource = acpi_driver_data(device);
-	if (!*resource)
-		return -ENODEV;
+	if (acpi_bus_get_device(handle, &device))
+		return NULL;
 
-	return 0;
+	return container_of(device, struct acpi_power_resource, device);
 }
 
 static int acpi_power_get_state(acpi_handle handle, int *state)
@@ -171,9 +153,9 @@ static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 		acpi_handle handle = list->handles[i];
 		int result;
 
-		result = acpi_power_get_context(handle, &resource);
-		if (result)
-			return result;
+		resource = acpi_power_get_context(handle);
+		if (!resource)
+			return -ENODEV;
 
 		mutex_lock(&resource->resource_lock);
 
@@ -226,12 +208,12 @@ static int __acpi_power_on(struct acpi_power_resource *resource)
 {
 	acpi_status status = AE_OK;
 
-	status = acpi_evaluate_object(resource->device->handle, "_ON", NULL, NULL);
+	status = acpi_evaluate_object(resource->device.handle, "_ON", NULL, NULL);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
 	/* Update the power resource's _device_ power state */
-	resource->device->power.state = ACPI_STATE_D0;
+	resource->device.power.state = ACPI_STATE_D0;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Power resource [%s] turned on\n",
 			  resource->name));
@@ -242,11 +224,11 @@ static int __acpi_power_on(struct acpi_power_resource *resource)
 static int acpi_power_on(acpi_handle handle)
 {
 	int result = 0;
-	struct acpi_power_resource *resource = NULL;
+	struct acpi_power_resource *resource;
 
-	result = acpi_power_get_context(handle, &resource);
-	if (result)
-		return result;
+	resource = acpi_power_get_context(handle);
+	if (!resource)
+		return -ENODEV;
 
 	mutex_lock(&resource->resource_lock);
 
@@ -275,11 +257,11 @@ static int acpi_power_off(acpi_handle handle)
 {
 	int result = 0;
 	acpi_status status = AE_OK;
-	struct acpi_power_resource *resource = NULL;
+	struct acpi_power_resource *resource;
 
-	result = acpi_power_get_context(handle, &resource);
-	if (result)
-		return result;
+	resource = acpi_power_get_context(handle);
+	if (!resource)
+		return -ENODEV;
 
 	mutex_lock(&resource->resource_lock);
 
@@ -297,12 +279,12 @@ static int acpi_power_off(acpi_handle handle)
 		goto unlock;
 	}
 
-	status = acpi_evaluate_object(resource->device->handle, "_OFF", NULL, NULL);
+	status = acpi_evaluate_object(resource->device.handle, "_OFF", NULL, NULL);
 	if (ACPI_FAILURE(status)) {
 		result = -ENODEV;
 	} else {
 		/* Update the power resource's _device_ power state */
-		resource->device->power.state = ACPI_STATE_D3;
+		resource->device.power.state = ACPI_STATE_D3;
 
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Power resource [%s] turned off\n",
@@ -350,7 +332,11 @@ static void acpi_power_add_dependent(acpi_handle rhandle,
 	struct acpi_power_dependent_device *dep;
 	struct acpi_power_resource *resource;
 
-	if (!rhandle || !adev || acpi_power_get_context(rhandle, &resource))
+	if (!rhandle || !adev)
+		return;
+
+	resource = acpi_power_get_context(rhandle);
+	if (!resource)
 		return;
 
 	mutex_lock(&resource->resource_lock);
@@ -378,7 +364,11 @@ static void acpi_power_remove_dependent(acpi_handle rhandle,
 	struct acpi_power_resource *resource;
 	struct work_struct *work = NULL;
 
-	if (!rhandle || !adev || acpi_power_get_context(rhandle, &resource))
+	if (!rhandle || !adev)
+		return;
+
+	resource = acpi_power_get_context(rhandle);
+	if (!resource)
 		return;
 
 	mutex_lock(&resource->resource_lock);
@@ -648,46 +638,53 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	return result;
 }
 
-/* --------------------------------------------------------------------------
-                                Driver Interface
-   -------------------------------------------------------------------------- */
+static void acpi_release_power_resource(struct device *dev)
+{
+	struct acpi_device *device = to_acpi_device(dev);
+	struct acpi_power_resource *resource;
+
+	acpi_free_ids(device);
+	resource = container_of(device, struct acpi_power_resource, device);
+	kfree(resource);
+}
 
-static int acpi_power_add(struct acpi_device *device)
+void acpi_add_power_resource(acpi_handle handle)
 {
-	int result = 0, state;
-	acpi_status status = AE_OK;
-	struct acpi_power_resource *resource = NULL;
+	struct acpi_power_resource *resource;
+	struct acpi_device *device = NULL;
 	union acpi_object acpi_object;
 	struct acpi_buffer buffer = { sizeof(acpi_object), &acpi_object };
+	acpi_status status;
+	int state, result = -ENODEV;
 
+	acpi_bus_get_device(handle, &device);
+	if (device)
+		return;
 
-	if (!device)
-		return -EINVAL;
-
-	resource = kzalloc(sizeof(struct acpi_power_resource), GFP_KERNEL);
+	resource = kzalloc(sizeof(*resource), GFP_KERNEL);
 	if (!resource)
-		return -ENOMEM;
+		return;
 
-	resource->device = device;
+	device = &resource->device;
+	acpi_init_device_object(device, handle, ACPI_BUS_TYPE_POWER,
+				ACPI_STA_DEFAULT);
 	mutex_init(&resource->resource_lock);
 	INIT_LIST_HEAD(&resource->dependent);
-	strcpy(resource->name, device->pnp.bus_id);
+	resource->name = device->pnp.bus_id;
 	strcpy(acpi_device_name(device), ACPI_POWER_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_POWER_CLASS);
-	device->driver_data = resource;
 
 	/* Evalute the object to get the system level and resource order. */
-	status = acpi_evaluate_object(device->handle, NULL, NULL, &buffer);
-	if (ACPI_FAILURE(status)) {
-		result = -ENODEV;
-		goto end;
-	}
+	status = acpi_evaluate_object(handle, NULL, NULL, &buffer);
+	if (ACPI_FAILURE(status))
+		goto out;
+
 	resource->system_level = acpi_object.power_resource.system_level;
 	resource->order = acpi_object.power_resource.resource_order;
 
-	result = acpi_power_get_state(device->handle, &state);
+	result = acpi_power_get_state(handle, &state);
 	if (result)
-		goto end;
+		goto out;
 
 	switch (state) {
 	case ACPI_POWER_RESOURCE_STATE_ON:
@@ -698,34 +695,24 @@ static int acpi_power_add(struct acpi_device *device)
 		break;
 	default:
 		device->power.state = ACPI_STATE_UNKNOWN;
-		break;
 	}
 
 	printk(KERN_INFO PREFIX "%s [%s] (%s)\n", acpi_device_name(device),
 	       acpi_device_bid(device), state ? "on" : "off");
 
-      end:
+	device->flags.match_driver = true;
+	result = acpi_device_register(device, acpi_release_power_resource);
+
+ out:
 	if (result)
-		kfree(resource);
+		acpi_release_power_resource(&device->dev);
 
-	return result;
+	return;
 }
 
-static int acpi_power_remove(struct acpi_device *device, int type)
-{
-	struct acpi_power_resource *resource;
-
-	if (!device)
-		return -EINVAL;
-
-	resource = acpi_driver_data(device);
-	if (!resource)
-		return -EINVAL;
-
-	kfree(resource);
-
-	return 0;
-}
+/* --------------------------------------------------------------------------
+                                Driver Interface
+   -------------------------------------------------------------------------- */
 
 #ifdef CONFIG_PM_SLEEP
 static int acpi_power_resume(struct device *dev)

commit bc9b6407bd6df3ab7189e5622816bbc11ae9d2d8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:05 2013 +0100

    ACPI / PM: Rework the handling of devices depending on power resources
    
    Commit 0090def6 (ACPI: Add interface to register/unregister device
    to/from power resources) made it possible to indicate to the ACPI
    core that if the given device depends on any power resources, then
    it should be resumed as soon as all of the power resources required
    by it to transition to the D0 power state have been turned on.
    
    Unfortunately, however, this was a mistake, because all devices
    depending on power resources should be treated this way (i.e. they
    should be resumed when all power resources required by their D0
    state have been turned on) and for the majority of those devices
    the ACPI core can figure out by itself which (physical) devices
    depend on what power resources.
    
    For this reason, replace the code added by commit 0090def6 with a
    new, much more straightforward, mechanism that will be used
    internally by the ACPI core and remove all references to that code
    from kernel subsystems using ACPI.
    
    For the cases when there are (physical) devices that should be
    resumed whenever a not directly related ACPI device node goes into
    D0 as a result of power resources configuration changes, like in
    the SATA case, add two new routines, acpi_dev_pm_add_dependent()
    and acpi_dev_pm_remove_dependent(), allowing subsystems to manage
    such dependencies.  Convert the SATA subsystem to use the new
    functions accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 6e7b9d523812..659386c4f0cb 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -83,31 +83,20 @@ static struct acpi_driver acpi_power_driver = {
 	.drv.pm = &acpi_power_pm,
 };
 
-/*
- * A power managed device
- * A device may rely on multiple power resources.
- * */
-struct acpi_power_managed_device {
-	struct device *dev; /* The physical device */
-	acpi_handle *handle;
-};
-
-struct acpi_power_resource_device {
-	struct acpi_power_managed_device *device;
-	struct acpi_power_resource_device *next;
+struct acpi_power_dependent_device {
+	struct list_head node;
+	struct acpi_device *adev;
+	struct work_struct work;
 };
 
 struct acpi_power_resource {
-	struct acpi_device * device;
+	struct acpi_device *device;
+	struct list_head dependent;
 	acpi_bus_id name;
 	u32 system_level;
 	u32 order;
 	unsigned int ref_count;
 	struct mutex resource_lock;
-
-	/* List of devices relying on this power resource */
-	struct acpi_power_resource_device *devices;
-	struct mutex devices_lock;
 };
 
 static struct list_head acpi_power_resource_list;
@@ -207,21 +196,30 @@ static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 	return 0;
 }
 
-/* Resume the device when all power resources in _PR0 are on */
-static void acpi_power_on_device(struct acpi_power_managed_device *device)
+static void acpi_power_resume_dependent(struct work_struct *work)
 {
-	struct acpi_device *acpi_dev;
-	acpi_handle handle = device->handle;
+	struct acpi_power_dependent_device *dep;
+	struct acpi_device_physical_node *pn;
+	struct acpi_device *adev;
 	int state;
 
-	if (acpi_bus_get_device(handle, &acpi_dev))
+	dep = container_of(work, struct acpi_power_dependent_device, work);
+	adev = dep->adev;
+	if (acpi_power_get_inferred_state(adev, &state))
 		return;
 
-	if(acpi_power_get_inferred_state(acpi_dev, &state))
+	if (state > ACPI_STATE_D0)
 		return;
 
-	if (state == ACPI_STATE_D0 && pm_runtime_suspended(device->dev))
-		pm_request_resume(device->dev);
+	mutex_lock(&adev->physical_node_lock);
+
+	list_for_each_entry(pn, &adev->physical_node_list, node)
+		pm_request_resume(pn->dev);
+
+	list_for_each_entry(pn, &adev->power_dependent, node)
+		pm_request_resume(pn->dev);
+
+	mutex_unlock(&adev->physical_node_lock);
 }
 
 static int __acpi_power_on(struct acpi_power_resource *resource)
@@ -244,9 +242,7 @@ static int __acpi_power_on(struct acpi_power_resource *resource)
 static int acpi_power_on(acpi_handle handle)
 {
 	int result = 0;
-	bool resume_device = false;
 	struct acpi_power_resource *resource = NULL;
-	struct acpi_power_resource_device *device_list;
 
 	result = acpi_power_get_context(handle, &resource);
 	if (result)
@@ -260,26 +256,17 @@ static int acpi_power_on(acpi_handle handle)
 				  resource->name));
 	} else {
 		result = __acpi_power_on(resource);
-		if (result)
+		if (result) {
 			resource->ref_count--;
-		else
-			resume_device = true;
-	}
+		} else {
+			struct acpi_power_dependent_device *dep;
 
-	mutex_unlock(&resource->resource_lock);
-
-	if (!resume_device)
-		return result;
-
-	mutex_lock(&resource->devices_lock);
-
-	device_list = resource->devices;
-	while (device_list) {
-		acpi_power_on_device(device_list->device);
-		device_list = device_list->next;
+			list_for_each_entry(dep, &resource->dependent, node)
+				schedule_work(&dep->work);
+		}
 	}
 
-	mutex_unlock(&resource->devices_lock);
+	mutex_unlock(&resource->resource_lock);
 
 	return result;
 }
@@ -357,119 +344,81 @@ static int acpi_power_on_list(struct acpi_handle_list *list)
 	return result;
 }
 
-static void __acpi_power_resource_unregister_device(struct device *dev,
-		acpi_handle res_handle)
+static void acpi_power_add_dependent(acpi_handle rhandle,
+				     struct acpi_device *adev)
 {
-	struct acpi_power_resource *resource = NULL;
-	struct acpi_power_resource_device *prev, *curr;
+	struct acpi_power_dependent_device *dep;
+	struct acpi_power_resource *resource;
 
-	if (acpi_power_get_context(res_handle, &resource))
+	if (!rhandle || !adev || acpi_power_get_context(rhandle, &resource))
 		return;
 
-	mutex_lock(&resource->devices_lock);
-	prev = NULL;
-	curr = resource->devices;
-	while (curr) {
-		if (curr->device->dev == dev) {
-			if (!prev)
-				resource->devices = curr->next;
-			else
-				prev->next = curr->next;
-
-			kfree(curr);
-			break;
-		}
-
-		prev = curr;
-		curr = curr->next;
-	}
-	mutex_unlock(&resource->devices_lock);
-}
-
-/* Unlink dev from all power resources in _PR0 */
-void acpi_power_resource_unregister_device(struct device *dev, acpi_handle handle)
-{
-	struct acpi_device *acpi_dev;
-	struct acpi_handle_list *list;
-	int i;
+	mutex_lock(&resource->resource_lock);
 
-	if (!dev || !handle)
-		return;
+	list_for_each_entry(dep, &resource->dependent, node)
+		if (dep->adev == adev)
+			goto out;
 
-	if (acpi_bus_get_device(handle, &acpi_dev))
-		return;
+	dep = kzalloc(sizeof(*dep), GFP_KERNEL);
+	if (!dep)
+		goto out;
 
-	list = &acpi_dev->power.states[ACPI_STATE_D0].resources;
+	dep->adev = adev;
+	INIT_WORK(&dep->work, acpi_power_resume_dependent);
+	list_add_tail(&dep->node, &resource->dependent);
 
-	for (i = 0; i < list->count; i++)
-		__acpi_power_resource_unregister_device(dev,
-			list->handles[i]);
+ out:
+	mutex_unlock(&resource->resource_lock);
 }
-EXPORT_SYMBOL_GPL(acpi_power_resource_unregister_device);
 
-static int __acpi_power_resource_register_device(
-	struct acpi_power_managed_device *powered_device, acpi_handle handle)
+static void acpi_power_remove_dependent(acpi_handle rhandle,
+					struct acpi_device *adev)
 {
-	struct acpi_power_resource *resource = NULL;
-	struct acpi_power_resource_device *power_resource_device;
-	int result;
+	struct acpi_power_dependent_device *dep;
+	struct acpi_power_resource *resource;
+	struct work_struct *work = NULL;
 
-	result = acpi_power_get_context(handle, &resource);
-	if (result)
-		return result;
+	if (!rhandle || !adev || acpi_power_get_context(rhandle, &resource))
+		return;
 
-	power_resource_device = kzalloc(
-		sizeof(*power_resource_device), GFP_KERNEL);
-	if (!power_resource_device)
-		return -ENOMEM;
+	mutex_lock(&resource->resource_lock);
 
-	power_resource_device->device = powered_device;
+	list_for_each_entry(dep, &resource->dependent, node)
+		if (dep->adev == adev) {
+			list_del(&dep->node);
+			work = &dep->work;
+			break;
+		}
 
-	mutex_lock(&resource->devices_lock);
-	power_resource_device->next = resource->devices;
-	resource->devices = power_resource_device;
-	mutex_unlock(&resource->devices_lock);
+	mutex_unlock(&resource->resource_lock);
 
-	return 0;
+	if (work) {
+		cancel_work_sync(work);
+		kfree(dep);
+	}
 }
 
-/* Link dev to all power resources in _PR0 */
-int acpi_power_resource_register_device(struct device *dev, acpi_handle handle)
+void acpi_power_add_remove_device(struct acpi_device *adev, bool add)
 {
-	struct acpi_device *acpi_dev;
-	struct acpi_handle_list *list;
-	struct acpi_power_managed_device *powered_device;
-	int i, ret;
+	if (adev->power.flags.power_resources) {
+		struct acpi_device_power_state *ps;
+		int j;
 
-	if (!dev || !handle)
-		return -ENODEV;
-
-	ret = acpi_bus_get_device(handle, &acpi_dev);
-	if (ret || !acpi_dev->power.flags.power_resources)
-		return -ENODEV;
+		ps = &adev->power.states[ACPI_STATE_D0];
+		for (j = 0; j < ps->resources.count; j++) {
+			acpi_handle rhandle = ps->resources.handles[j];
 
-	powered_device = kzalloc(sizeof(*powered_device), GFP_KERNEL);
-	if (!powered_device)
-		return -ENOMEM;
-
-	powered_device->dev = dev;
-	powered_device->handle = handle;
-
-	list = &acpi_dev->power.states[ACPI_STATE_D0].resources;
-
-	for (i = 0; i < list->count; i++) {
-		ret = __acpi_power_resource_register_device(powered_device,
-			list->handles[i]);
-
-		if (ret) {
-			acpi_power_resource_unregister_device(dev, handle);
-			break;
+			if (add)
+				acpi_power_add_dependent(rhandle, adev);
+			else
+				acpi_power_remove_dependent(rhandle, adev);
 		}
 	}
-
-	return ret;
 }
-EXPORT_SYMBOL_GPL(acpi_power_resource_register_device);
+
+/* --------------------------------------------------------------------------
+                             Device Power Management
+   -------------------------------------------------------------------------- */
 
 /**
  * acpi_device_sleep_wake - execute _DSW (Device Sleep Wake) or (deprecated in
@@ -623,10 +572,6 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 	return err;
 }
 
-/* --------------------------------------------------------------------------
-                             Device Power Management
-   -------------------------------------------------------------------------- */
-
 int acpi_power_get_inferred_state(struct acpi_device *device, int *state)
 {
 	int result = 0;
@@ -725,7 +670,7 @@ static int acpi_power_add(struct acpi_device *device)
 
 	resource->device = device;
 	mutex_init(&resource->resource_lock);
-	mutex_init(&resource->devices_lock);
+	INIT_LIST_HEAD(&resource->dependent);
 	strcpy(resource->name, device->pnp.bus_id);
 	strcpy(acpi_device_name(device), ACPI_POWER_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_POWER_CLASS);

commit 0271f4f1176d7205b2b73ef956b169db8f417932
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Dec 26 13:26:46 2012 +0100

    ACPI / power: Remove useless message from device registering routine
    
    After commit 71fbad6 (PCI/ACPI: Notify PCI devices when their power
    resource is turned on) made acpi_pci_bind() call
    acpi_power_resource_register_device(), the debug message at the end
    of the latter appears in the kernel log for every PCI device that
    doesn't happen to have power resources assigned (which is the vast
    majority of them).  However, this message is totally useless, because
    it doesn't even say which device it is about.  Moreover, it is
    misleading, because it only means that the given device has no power
    resources, which isn't exceptional at all.
    
    Remove that useless message altogether and simplify
    acpi_power_resource_register_device() slightly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 7db61b8fa11f..6e7b9d523812 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -445,11 +445,8 @@ int acpi_power_resource_register_device(struct device *dev, acpi_handle handle)
 		return -ENODEV;
 
 	ret = acpi_bus_get_device(handle, &acpi_dev);
-	if (ret)
-		goto no_power_resource;
-
-	if (!acpi_dev->power.flags.power_resources)
-		goto no_power_resource;
+	if (ret || !acpi_dev->power.flags.power_resources)
+		return -ENODEV;
 
 	powered_device = kzalloc(sizeof(*powered_device), GFP_KERNEL);
 	if (!powered_device)
@@ -471,10 +468,6 @@ int acpi_power_resource_register_device(struct device *dev, acpi_handle handle)
 	}
 
 	return ret;
-
-no_power_resource:
-	printk(KERN_DEBUG PREFIX "Invalid Power Resource to register!\n");
-	return -ENODEV;
 }
 EXPORT_SYMBOL_GPL(acpi_power_resource_register_device);
 

commit acacb5f211e99fa2c98cf4ef4c632ab43724adb6
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Mon Oct 29 17:25:19 2012 +0000

    ACPI: add newline in power.c message
    
    Add newline to printk so that the message is on a line
    by itself and not merged with something unrelated to it.
    
    Reported-by: Toralf Frster <toralf.foerster@gmx.de>
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 40e38a06ba85..7db61b8fa11f 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -473,7 +473,7 @@ int acpi_power_resource_register_device(struct device *dev, acpi_handle handle)
 	return ret;
 
 no_power_resource:
-	printk(KERN_DEBUG PREFIX "Invalid Power Resource to register!");
+	printk(KERN_DEBUG PREFIX "Invalid Power Resource to register!\n");
 	return -ENODEV;
 }
 EXPORT_SYMBOL_GPL(acpi_power_resource_register_device);

commit f25b70613c048ceb1df052576fda03321ebf41cf
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Fri Sep 14 20:54:44 2012 +0200

    ACPI / PM: Use KERN_DEBUG when no power resources are found
    
    commit a606dac368eed5696fb38e16b1394f1d049c09e9 adds support to link
    devices which have _PRx, if a device does not have _PRx, a warning
    message will be printed.
    
    This commit is for ZPODD on Intel ZPODD capable platforms, on other
    platforms, it has no problem if there is no power resource for this
    device, so a warning here is not appropriate, change it to debug.
    
    Reported-by: Borislav Petkov <bp@amd64.org>
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index cc2a2dcff336..40e38a06ba85 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -473,7 +473,7 @@ int acpi_power_resource_register_device(struct device *dev, acpi_handle handle)
 	return ret;
 
 no_power_resource:
-	printk(KERN_WARNING PREFIX "Invalid Power Resource to register!");
+	printk(KERN_DEBUG PREFIX "Invalid Power Resource to register!");
 	return -ENODEV;
 }
 EXPORT_SYMBOL_GPL(acpi_power_resource_register_device);

commit 40bf66ec9791f1452b90b82aadc3b6e6aee201f5
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Fri Sep 14 00:26:33 2012 +0200

    ACPI / PM: Fix resource_lock dead lock in acpi_power_on_device
    
    Commit 0090def("ACPI: Add interface to register/unregister device
    to/from power resources") used resource_lock to protect the devices list
    that relies on power resource. It caused a mutex dead lock, as below
    
        acpi_power_on ---> lock resource_lock
          __acpi_power_on
            acpi_power_on_device
              acpi_power_get_inferred_state
                acpi_power_get_list_state ---> lock resource_lock
    
    This patch adds a new mutex "devices_lock" to protect the devices list
    and calls acpi_power_on_device in acpi_power_on, instead of
    __acpi_power_on, after the resource_lock is released.
    
    [rjw: Changed data type of a boolean variable to bool.]
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index fc1803414629..cc2a2dcff336 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -107,6 +107,7 @@ struct acpi_power_resource {
 
 	/* List of devices relying on this power resource */
 	struct acpi_power_resource_device *devices;
+	struct mutex devices_lock;
 };
 
 static struct list_head acpi_power_resource_list;
@@ -225,7 +226,6 @@ static void acpi_power_on_device(struct acpi_power_managed_device *device)
 
 static int __acpi_power_on(struct acpi_power_resource *resource)
 {
-	struct acpi_power_resource_device *device_list = resource->devices;
 	acpi_status status = AE_OK;
 
 	status = acpi_evaluate_object(resource->device->handle, "_ON", NULL, NULL);
@@ -238,19 +238,15 @@ static int __acpi_power_on(struct acpi_power_resource *resource)
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Power resource [%s] turned on\n",
 			  resource->name));
 
-	while (device_list) {
-		acpi_power_on_device(device_list->device);
-
-		device_list = device_list->next;
-	}
-
 	return 0;
 }
 
 static int acpi_power_on(acpi_handle handle)
 {
 	int result = 0;
+	bool resume_device = false;
 	struct acpi_power_resource *resource = NULL;
+	struct acpi_power_resource_device *device_list;
 
 	result = acpi_power_get_context(handle, &resource);
 	if (result)
@@ -266,10 +262,25 @@ static int acpi_power_on(acpi_handle handle)
 		result = __acpi_power_on(resource);
 		if (result)
 			resource->ref_count--;
+		else
+			resume_device = true;
 	}
 
 	mutex_unlock(&resource->resource_lock);
 
+	if (!resume_device)
+		return result;
+
+	mutex_lock(&resource->devices_lock);
+
+	device_list = resource->devices;
+	while (device_list) {
+		acpi_power_on_device(device_list->device);
+		device_list = device_list->next;
+	}
+
+	mutex_unlock(&resource->devices_lock);
+
 	return result;
 }
 
@@ -355,7 +366,7 @@ static void __acpi_power_resource_unregister_device(struct device *dev,
 	if (acpi_power_get_context(res_handle, &resource))
 		return;
 
-	mutex_lock(&resource->resource_lock);
+	mutex_lock(&resource->devices_lock);
 	prev = NULL;
 	curr = resource->devices;
 	while (curr) {
@@ -372,7 +383,7 @@ static void __acpi_power_resource_unregister_device(struct device *dev,
 		prev = curr;
 		curr = curr->next;
 	}
-	mutex_unlock(&resource->resource_lock);
+	mutex_unlock(&resource->devices_lock);
 }
 
 /* Unlink dev from all power resources in _PR0 */
@@ -414,10 +425,10 @@ static int __acpi_power_resource_register_device(
 
 	power_resource_device->device = powered_device;
 
-	mutex_lock(&resource->resource_lock);
+	mutex_lock(&resource->devices_lock);
 	power_resource_device->next = resource->devices;
 	resource->devices = power_resource_device;
-	mutex_unlock(&resource->resource_lock);
+	mutex_unlock(&resource->devices_lock);
 
 	return 0;
 }
@@ -721,6 +732,7 @@ static int acpi_power_add(struct acpi_device *device)
 
 	resource->device = device;
 	mutex_init(&resource->resource_lock);
+	mutex_init(&resource->devices_lock);
 	strcpy(resource->name, device->pnp.bus_id);
 	strcpy(acpi_device_name(device), ACPI_POWER_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_POWER_CLASS);

commit 9069240480e24a2d6ce23404c9ad6cabf59b7258
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Aug 9 23:00:02 2012 +0200

    ACPI / PM: Fix unused function warnings for CONFIG_PM_SLEEP
    
    According to compiler warnings, several suspend/resume functions
    in ACPI drivers are not used for CONFIG_PM_SLEEP unset, so add
    #ifdefs to prevent them from being built in that case.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 215ecd097408..fc1803414629 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -67,7 +67,9 @@ static const struct acpi_device_id power_device_ids[] = {
 };
 MODULE_DEVICE_TABLE(acpi, power_device_ids);
 
+#ifdef CONFIG_PM_SLEEP
 static int acpi_power_resume(struct device *dev);
+#endif
 static SIMPLE_DEV_PM_OPS(acpi_power_pm, NULL, acpi_power_resume);
 
 static struct acpi_driver acpi_power_driver = {
@@ -775,6 +777,7 @@ static int acpi_power_remove(struct acpi_device *device, int type)
 	return 0;
 }
 
+#ifdef CONFIG_PM_SLEEP
 static int acpi_power_resume(struct device *dev)
 {
 	int result = 0, state;
@@ -803,6 +806,7 @@ static int acpi_power_resume(struct device *dev)
 
 	return result;
 }
+#endif
 
 int __init acpi_power_init(void)
 {

commit 8407884dd9164ec18ed2afc00f56b87e36c51fcf
Merge: dc7f71f486f4 bdc0077af574
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Jul 25 15:58:48 2012 -0400

    Merge branch 'master' [vanilla Linus master] into libata-dev.git/upstream
    
    Two bits were appended to the end of the bitfield
    list in struct scsi_device.  Resolve that conflict
    by including both bits.
    
    Conflicts:
            include/scsi/scsi_device.h

commit e579e2dd8f056cfeaf4d2b313a35ddafb3c4e531
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jun 27 23:26:59 2012 +0200

    ACPI: Use struct dev_pm_ops for power management in the power driver
    
    Make the ACPI power resource driver define its PM callbacks through
    a struct dev_pm_ops object rather than by using legacy PM hooks
    in struct acpi_device_ops.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index dd6d6a3c6780..894d45c6bc67 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -60,7 +60,6 @@ ACPI_MODULE_NAME("power");
 
 static int acpi_power_add(struct acpi_device *device);
 static int acpi_power_remove(struct acpi_device *device, int type);
-static int acpi_power_resume(struct acpi_device *device);
 
 static const struct acpi_device_id power_device_ids[] = {
 	{ACPI_POWER_HID, 0},
@@ -68,6 +67,9 @@ static const struct acpi_device_id power_device_ids[] = {
 };
 MODULE_DEVICE_TABLE(acpi, power_device_ids);
 
+static int acpi_power_resume(struct device *dev);
+static SIMPLE_DEV_PM_OPS(acpi_power_pm, NULL, acpi_power_resume);
+
 static struct acpi_driver acpi_power_driver = {
 	.name = "power",
 	.class = ACPI_POWER_CLASS,
@@ -75,8 +77,8 @@ static struct acpi_driver acpi_power_driver = {
 	.ops = {
 		.add = acpi_power_add,
 		.remove = acpi_power_remove,
-		.resume = acpi_power_resume,
 		},
+	.drv.pm = &acpi_power_pm,
 };
 
 /*
@@ -771,14 +773,16 @@ static int acpi_power_remove(struct acpi_device *device, int type)
 	return 0;
 }
 
-static int acpi_power_resume(struct acpi_device *device)
+static int acpi_power_resume(struct device *dev)
 {
 	int result = 0, state;
+	struct acpi_device *device;
 	struct acpi_power_resource *resource;
 
-	if (!device)
+	if (!dev)
 		return -EINVAL;
 
+	device = to_acpi_device(dev);
 	resource = acpi_driver_data(device);
 	if (!resource)
 		return -EINVAL;

commit a606dac368eed5696fb38e16b1394f1d049c09e9
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Jun 25 16:13:07 2012 +0800

    libata-acpi: register/unregister device to/from power resource
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index dd6d6a3c6780..eb6408741a8f 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -390,6 +390,7 @@ void acpi_power_resource_unregister_device(struct device *dev, acpi_handle handl
 		__acpi_power_resource_unregister_device(dev,
 			list->handles[i]);
 }
+EXPORT_SYMBOL_GPL(acpi_power_resource_unregister_device);
 
 static int __acpi_power_resource_register_device(
 	struct acpi_power_managed_device *powered_device, acpi_handle handle)
@@ -460,6 +461,7 @@ int acpi_power_resource_register_device(struct device *dev, acpi_handle handle)
 	printk(KERN_WARNING PREFIX "Invalid Power Resource to register!");
 	return -ENODEV;
 }
+EXPORT_SYMBOL_GPL(acpi_power_resource_register_device);
 
 /**
  * acpi_device_sleep_wake - execute _DSW (Device Sleep Wake) or (deprecated in

commit 38c92fff988d518fe80dc23d0d44d66bd7e47ddd
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 20 13:58:00 2012 +0200

    ACPI / PM: Make __acpi_bus_get_power() cover D3cold correctly
    
    After recent changes of the ACPI device power states definitions, if
    power resources are not used for the device's power management, the
    state returned by __acpi_bus_get_power() cannot exceed D3hot, because
    the return values of _PSC are 0 through 3.  However, if the _PR3
    method is not present for the device and _PS3 returns 3, we have to
    assume that the device is in D3cold, so the value returned by
    __acpi_bus_get_power() in that case should be 4.
    
    Similarly, acpi_power_get_inferred_state() should take the power
    resources for the D3hot state into account in general, so that it
    can return 3 if those resources are "on" or 4 (D3cold) otherwise.
    
    Fix the the above two issues and make sure that if both _PSC and
    _PR3 are present for the device, the power resources listed by _PR3
    will be used to determine if the number 3 returned by _PSC is meant
    to represent D3cold or D3hot.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 0500f719f63e..dd6d6a3c6780 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -631,7 +631,7 @@ int acpi_power_get_inferred_state(struct acpi_device *device, int *state)
 	 * We know a device's inferred power state when all the resources
 	 * required for a given D-state are 'on'.
 	 */
-	for (i = ACPI_STATE_D0; i < ACPI_STATE_D3_HOT; i++) {
+	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3_HOT; i++) {
 		list = &device->power.states[i].resources;
 		if (list->count < 1)
 			continue;

commit 5c7dd710f691d1b44c39e32d2f05b4286ff51f99
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri May 18 00:39:35 2012 +0200

    ACPI / PCI / PM: Fix device PM regression related to D3hot/D3cold
    
    Commit 1cc0c998fdf2 ("ACPI: Fix D3hot v D3cold confusion") introduced a
    bug in __acpi_bus_set_power() and changed the behavior of
    acpi_pci_set_power_state() in such a way that it generally doesn't work
    as expected if PCI_D3hot is passed to it as the second argument.
    
    First off, if ACPI_STATE_D3 (equal to ACPI_STATE_D3_COLD) is passed to
    __acpi_bus_set_power() and the explicit_set flag is set for the D3cold
    state, the function will try to execute AML method called "_PS4", which
    doesn't exist.
    
    Fix this by adding a check to ensure that the name of the AML method
    to execute for transitions to ACPI_STATE_D3_COLD is correct in
    __acpi_bus_set_power().  Also make sure that the explicit_set flag
    for ACPI_STATE_D3_COLD will be set if _PS3 is present and modify
    acpi_power_transition() to avoid accessing power resources for
    ACPI_STATE_D3_COLD, because they don't exist.
    
    Second, if PCI_D3hot is passed to acpi_pci_set_power_state() as the
    target state, the function will request a transition to
    ACPI_STATE_D3_HOT instead of ACPI_STATE_D3.  However,
    ACPI_STATE_D3_HOT is now only marked as supported if the _PR3 AML
    method is defined for the given device, which is rare.  This causes
    problems to happen on systems where devices were successfully put
    into ACPI D3 by pci_set_power_state(PCI_D3hot) which doesn't work
    now.  In particular, some unused graphics adapters are not turned
    off as a result.
    
    To fix this issue restore the old behavior of
    acpi_pci_set_power_state(), which is to request a transition to
    ACPI_STATE_D3 (equal to ACPI_STATE_D3_COLD) if either PCI_D3hot or
    PCI_D3cold is passed to it as the argument.
    
    This approach is not ideal, because generally power should not
    be removed from devices if PCI_D3hot is the target power state,
    but since this behavior is relied on, we have no choice but to
    restore it at the moment and spend more time on designing a
    better solution in the future.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=43228
    Reported-by: rocko <rockorequin@hotmail.com>
    Reported-by: Cristian Rodrguez <crrodriguez@opensuse.org>
    Reported-and-tested-by: Peter <lekensteyn@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 330bb4d75852..0500f719f63e 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -660,7 +660,7 @@ int acpi_power_on_resources(struct acpi_device *device, int state)
 
 int acpi_power_transition(struct acpi_device *device, int state)
 {
-	int result;
+	int result = 0;
 
 	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3_COLD))
 		return -EINVAL;
@@ -679,8 +679,11 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	 * (e.g. so the device doesn't lose power while transitioning).  Then,
 	 * we dereference all power resources used in the current list.
 	 */
-	result = acpi_power_on_list(&device->power.states[state].resources);
-	if (!result)
+	if (state < ACPI_STATE_D3_COLD)
+		result = acpi_power_on_list(
+			&device->power.states[state].resources);
+
+	if (!result && device->power.state < ACPI_STATE_D3_COLD)
 		acpi_power_off_list(
 			&device->power.states[device->power.state].resources);
 

commit 1cc0c998fdf2cb665d625fb565a0d6db5c81c639
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Apr 23 09:03:49 2012 +0800

    ACPI: Fix D3hot v D3cold confusion
    
    Before this patch, ACPI_STATE_D3 incorrectly referenced D3hot
    in some places, but D3cold in other places.
    
    After this patch, ACPI_STATE_D3 always means ACPI_STATE_D3_COLD;
    and all references to D3hot use ACPI_STATE_D3_HOT.
    
    ACPI's _PR3 method is used to enter both D3hot and D3cold states.
    What distinguishes D3hot from D3cold is the presence _PR3
    (Power Resources for D3hot)  If these resources are all ON,
    then the state is D3hot.  If _PR3 is not present,
    or all _PR0 resources for the devices are OFF,
    then the state is D3cold.
    
    This patch applies after Linux-3.4-rc1.
    A future syntax cleanup may remove ACPI_STATE_D3
    to emphasize that it always means ACPI_STATE_D3_COLD.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Aaron Lu <aaron.lu@amd.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 7049a7d27c4f..330bb4d75852 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -631,7 +631,7 @@ int acpi_power_get_inferred_state(struct acpi_device *device, int *state)
 	 * We know a device's inferred power state when all the resources
 	 * required for a given D-state are 'on'.
 	 */
-	for (i = ACPI_STATE_D0; i < ACPI_STATE_D3; i++) {
+	for (i = ACPI_STATE_D0; i < ACPI_STATE_D3_HOT; i++) {
 		list = &device->power.states[i].resources;
 		if (list->count < 1)
 			continue;

commit 0090def6c37c8ea29508a435e581f2ef26fea10f
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Thu Mar 29 14:09:39 2012 +0800

    ACPI: Add interface to register/unregister device to/from power resources
    
    Devices may share same list of power resources in _PR0, for example
    
    Device(Dev0)
    {
            Name (_PR0, Package (0x01)
            {
                    P0PR,
                    P1PR
            })
    }
    
    Device(Dev1)
    {
            Name (_PR0, Package (0x01)
            {
                    P0PR,
                    P1PR
            }
    }
    
    Assume Dev0 and Dev1 were runtime suspended.
    Then Dev0 is resumed first and it goes into D0 state.
    But Dev1 is left in D0_Uninitialised state.
    
    This is wrong. In this case, Dev1 must be resumed too.
    
    In order to hand this case, each power resource maintains a list of
    devices which relies on it.
    
    When power resource is ON, it will check if the devices on its list
    can be resumed. The device can only be resumed when all the power
    resouces of its _PR0 are ON.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 0d681fb7428b..7049a7d27c4f 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -40,9 +40,11 @@
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/slab.h>
+#include <linux/pm_runtime.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 #include "sleep.h"
+#include "internal.h"
 
 #define PREFIX "ACPI: "
 
@@ -77,6 +79,20 @@ static struct acpi_driver acpi_power_driver = {
 		},
 };
 
+/*
+ * A power managed device
+ * A device may rely on multiple power resources.
+ * */
+struct acpi_power_managed_device {
+	struct device *dev; /* The physical device */
+	acpi_handle *handle;
+};
+
+struct acpi_power_resource_device {
+	struct acpi_power_managed_device *device;
+	struct acpi_power_resource_device *next;
+};
+
 struct acpi_power_resource {
 	struct acpi_device * device;
 	acpi_bus_id name;
@@ -84,6 +100,9 @@ struct acpi_power_resource {
 	u32 order;
 	unsigned int ref_count;
 	struct mutex resource_lock;
+
+	/* List of devices relying on this power resource */
+	struct acpi_power_resource_device *devices;
 };
 
 static struct list_head acpi_power_resource_list;
@@ -183,8 +202,26 @@ static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 	return 0;
 }
 
+/* Resume the device when all power resources in _PR0 are on */
+static void acpi_power_on_device(struct acpi_power_managed_device *device)
+{
+	struct acpi_device *acpi_dev;
+	acpi_handle handle = device->handle;
+	int state;
+
+	if (acpi_bus_get_device(handle, &acpi_dev))
+		return;
+
+	if(acpi_power_get_inferred_state(acpi_dev, &state))
+		return;
+
+	if (state == ACPI_STATE_D0 && pm_runtime_suspended(device->dev))
+		pm_request_resume(device->dev);
+}
+
 static int __acpi_power_on(struct acpi_power_resource *resource)
 {
+	struct acpi_power_resource_device *device_list = resource->devices;
 	acpi_status status = AE_OK;
 
 	status = acpi_evaluate_object(resource->device->handle, "_ON", NULL, NULL);
@@ -197,6 +234,12 @@ static int __acpi_power_on(struct acpi_power_resource *resource)
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Power resource [%s] turned on\n",
 			  resource->name));
 
+	while (device_list) {
+		acpi_power_on_device(device_list->device);
+
+		device_list = device_list->next;
+	}
+
 	return 0;
 }
 
@@ -299,6 +342,125 @@ static int acpi_power_on_list(struct acpi_handle_list *list)
 	return result;
 }
 
+static void __acpi_power_resource_unregister_device(struct device *dev,
+		acpi_handle res_handle)
+{
+	struct acpi_power_resource *resource = NULL;
+	struct acpi_power_resource_device *prev, *curr;
+
+	if (acpi_power_get_context(res_handle, &resource))
+		return;
+
+	mutex_lock(&resource->resource_lock);
+	prev = NULL;
+	curr = resource->devices;
+	while (curr) {
+		if (curr->device->dev == dev) {
+			if (!prev)
+				resource->devices = curr->next;
+			else
+				prev->next = curr->next;
+
+			kfree(curr);
+			break;
+		}
+
+		prev = curr;
+		curr = curr->next;
+	}
+	mutex_unlock(&resource->resource_lock);
+}
+
+/* Unlink dev from all power resources in _PR0 */
+void acpi_power_resource_unregister_device(struct device *dev, acpi_handle handle)
+{
+	struct acpi_device *acpi_dev;
+	struct acpi_handle_list *list;
+	int i;
+
+	if (!dev || !handle)
+		return;
+
+	if (acpi_bus_get_device(handle, &acpi_dev))
+		return;
+
+	list = &acpi_dev->power.states[ACPI_STATE_D0].resources;
+
+	for (i = 0; i < list->count; i++)
+		__acpi_power_resource_unregister_device(dev,
+			list->handles[i]);
+}
+
+static int __acpi_power_resource_register_device(
+	struct acpi_power_managed_device *powered_device, acpi_handle handle)
+{
+	struct acpi_power_resource *resource = NULL;
+	struct acpi_power_resource_device *power_resource_device;
+	int result;
+
+	result = acpi_power_get_context(handle, &resource);
+	if (result)
+		return result;
+
+	power_resource_device = kzalloc(
+		sizeof(*power_resource_device), GFP_KERNEL);
+	if (!power_resource_device)
+		return -ENOMEM;
+
+	power_resource_device->device = powered_device;
+
+	mutex_lock(&resource->resource_lock);
+	power_resource_device->next = resource->devices;
+	resource->devices = power_resource_device;
+	mutex_unlock(&resource->resource_lock);
+
+	return 0;
+}
+
+/* Link dev to all power resources in _PR0 */
+int acpi_power_resource_register_device(struct device *dev, acpi_handle handle)
+{
+	struct acpi_device *acpi_dev;
+	struct acpi_handle_list *list;
+	struct acpi_power_managed_device *powered_device;
+	int i, ret;
+
+	if (!dev || !handle)
+		return -ENODEV;
+
+	ret = acpi_bus_get_device(handle, &acpi_dev);
+	if (ret)
+		goto no_power_resource;
+
+	if (!acpi_dev->power.flags.power_resources)
+		goto no_power_resource;
+
+	powered_device = kzalloc(sizeof(*powered_device), GFP_KERNEL);
+	if (!powered_device)
+		return -ENOMEM;
+
+	powered_device->dev = dev;
+	powered_device->handle = handle;
+
+	list = &acpi_dev->power.states[ACPI_STATE_D0].resources;
+
+	for (i = 0; i < list->count; i++) {
+		ret = __acpi_power_resource_register_device(powered_device,
+			list->handles[i]);
+
+		if (ret) {
+			acpi_power_resource_unregister_device(dev, handle);
+			break;
+		}
+	}
+
+	return ret;
+
+no_power_resource:
+	printk(KERN_WARNING PREFIX "Invalid Power Resource to register!");
+	return -ENODEV;
+}
+
 /**
  * acpi_device_sleep_wake - execute _DSW (Device Sleep Wake) or (deprecated in
  *                          ACPI 3.0) _PSW (Power State Wake)

commit 3ebc81b8937d2bc1d0d0064bed29434dfce490aa
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Mar 29 14:09:38 2012 +0800

    ACPI: Introduce ACPI D3_COLD state support
    
    If a device has _PR3, it means the device supports D3_COLD.
    Add the ability to validate and enter D3_COLD state in ACPI.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 9ac2a9fa90ff..0d681fb7428b 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -500,14 +500,14 @@ int acpi_power_transition(struct acpi_device *device, int state)
 {
 	int result;
 
-	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
+	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3_COLD))
 		return -EINVAL;
 
 	if (device->power.state == state)
 		return 0;
 
 	if ((device->power.state < ACPI_STATE_D0)
-	    || (device->power.state > ACPI_STATE_D3))
+	    || (device->power.state > ACPI_STATE_D3_COLD))
 		return -ENODEV;
 
 	/* TBD: Resources must be ordered. */

commit d0515d9fec68bace144fda57a69f4268fb875209
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jan 6 23:38:57 2011 +0100

    ACPI / PM: Check status of power resources under mutexes
    
    It certainly is not a good idea to execute _ON or _OFF and _STA
    for the same power resource at the same time which may happen in
    some circumstances in theory.  To prevent that from happening,
    read the power state of each power resource under its mutex, as
    that will prevent the state from being changed at the same time.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index ac02af419b32..9ac2a9fa90ff 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -145,9 +145,8 @@ static int acpi_power_get_state(acpi_handle handle, int *state)
 
 static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 {
-	int result = 0, state1;
-	u32 i = 0;
-
+	int cur_state;
+	int i = 0;
 
 	if (!list || !state)
 		return -EINVAL;
@@ -155,25 +154,33 @@ static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 	/* The state of the list is 'on' IFF all resources are 'on'. */
 
 	for (i = 0; i < list->count; i++) {
-		/*
-		 * The state of the power resource can be obtained by
-		 * using the ACPI handle. In such case it is unnecessary to
-		 * get the Power resource first and then get its state again.
-		 */
-		result = acpi_power_get_state(list->handles[i], &state1);
+		struct acpi_power_resource *resource;
+		acpi_handle handle = list->handles[i];
+		int result;
+
+		result = acpi_power_get_context(handle, &resource);
 		if (result)
 			return result;
 
-		*state = state1;
+		mutex_lock(&resource->resource_lock);
 
-		if (*state != ACPI_POWER_RESOURCE_STATE_ON)
+		result = acpi_power_get_state(handle, &cur_state);
+
+		mutex_unlock(&resource->resource_lock);
+
+		if (result)
+			return result;
+
+		if (cur_state != ACPI_POWER_RESOURCE_STATE_ON)
 			break;
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource list is %s\n",
-			  *state ? "on" : "off"));
+			  cur_state ? "on" : "off"));
 
-	return result;
+	*state = cur_state;
+
+	return 0;
 }
 
 static int __acpi_power_on(struct acpi_power_resource *resource)

commit 36237fa0a711c309a38d7a7a9aed727e0eb76449
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jan 6 23:38:04 2011 +0100

    ACPI / PM: Rename acpi_power_off_device()
    
    Rename acpi_power_off_device() to acpi_power_off() in analogy with
    acpi_power_on().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 0003f1009885..ac02af419b32 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -219,7 +219,7 @@ static int acpi_power_on(acpi_handle handle)
 	return result;
 }
 
-static int acpi_power_off_device(acpi_handle handle)
+static int acpi_power_off(acpi_handle handle)
 {
 	int result = 0;
 	acpi_status status = AE_OK;
@@ -268,7 +268,7 @@ static void __acpi_power_off_list(struct acpi_handle_list *list, int num_res)
 	int i;
 
 	for (i = num_res - 1; i >= 0 ; i--)
-		acpi_power_off_device(list->handles[i]);
+		acpi_power_off(list->handles[i]);
 }
 
 static void acpi_power_off_list(struct acpi_handle_list *list)
@@ -430,8 +430,7 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 
 	/* Close power resource */
 	for (i = 0; i < dev->wakeup.resources.count; i++) {
-		int ret = acpi_power_off_device(
-				dev->wakeup.resources.handles[i]);
+		int ret = acpi_power_off(dev->wakeup.resources.handles[i]);
 		if (ret) {
 			printk(KERN_ERR PREFIX "Transition power state\n");
 			dev->wakeup.flags.valid = 0;

commit 53eac700b0df1fef8c957b9eedfd7f48120425e3
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Dec 11 23:45:30 2010 +0100

    ACPI / PM: Drop acpi_power_nocheck
    
    Since acpi_bus_set_power() should not use __acpi_bus_get_power() to
    update the device's device->power.state field before changing its
    power state (this may cause device->power.state to be inconsistent
    with the device power resources' reference counters), remove this
    call from it.  In consequence, the acpi_power_nocheck variable is not
    necessary any more, so it can be dropped along with the DMI table
    used for setting that variable for HP Pavilion 05.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 0cb4eab50d73..0003f1009885 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -56,9 +56,6 @@ ACPI_MODULE_NAME("power");
 #define ACPI_POWER_RESOURCE_STATE_ON	0x01
 #define ACPI_POWER_RESOURCE_STATE_UNKNOWN 0xFF
 
-int acpi_power_nocheck;
-module_param_named(power_nocheck, acpi_power_nocheck, bool, 000);
-
 static int acpi_power_add(struct acpi_device *device);
 static int acpi_power_remove(struct acpi_device *device, int type);
 static int acpi_power_resume(struct acpi_device *device);

commit 30d3df41b32b1ea63d3ebc52ef5644cbe41520f4
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 25 00:06:55 2010 +0100

    ACPI / PM: Introduce function for refcounting device power resources
    
    Introduce function acpi_power_on_resources() that reference counts
    and possibly turns on ACPI power resources for a given device and
    a given power state of it.
    
    This function will be used for reference counting device power
    resources during initialization.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 95fedbdf4fb8..0cb4eab50d73 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -485,6 +485,14 @@ int acpi_power_get_inferred_state(struct acpi_device *device, int *state)
 	return 0;
 }
 
+int acpi_power_on_resources(struct acpi_device *device, int state)
+{
+	if (!device || state < ACPI_STATE_D0 || state > ACPI_STATE_D3)
+		return -EINVAL;
+
+	return acpi_power_on_list(&device->power.states[state].resources);
+}
+
 int acpi_power_transition(struct acpi_device *device, int state)
 {
 	int result;

commit d2ef555b57292cd818934636ac8e3414cc2a6762
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 25 00:06:09 2010 +0100

    ACPI / PM: Add functions for manipulating lists of power resources
    
    ACPI device power resources should be reference counted during
    device initialization, so that their reference counters are always
    up to date.  It is convenient to do that with the help of a function
    that will reference count and possibly turn on power resources in
    a given list, so introduce that function, acpi_power_on_list().
    For symmetry, introduce acpi_power_off_list() for performing the
    reverse operation and use the both of them to simplify
    acpi_power_transition().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 9bd1b6044b55..95fedbdf4fb8 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -266,6 +266,35 @@ static int acpi_power_off_device(acpi_handle handle)
 	return result;
 }
 
+static void __acpi_power_off_list(struct acpi_handle_list *list, int num_res)
+{
+	int i;
+
+	for (i = num_res - 1; i >= 0 ; i--)
+		acpi_power_off_device(list->handles[i]);
+}
+
+static void acpi_power_off_list(struct acpi_handle_list *list)
+{
+	__acpi_power_off_list(list, list->count);
+}
+
+static int acpi_power_on_list(struct acpi_handle_list *list)
+{
+	int result = 0;
+	int i;
+
+	for (i = 0; i < list->count; i++) {
+		result = acpi_power_on(list->handles[i]);
+		if (result) {
+			__acpi_power_off_list(list, i);
+			break;
+		}
+	}
+
+	return result;
+}
+
 /**
  * acpi_device_sleep_wake - execute _DSW (Device Sleep Wake) or (deprecated in
  *                          ACPI 3.0) _PSW (Power State Wake)
@@ -458,10 +487,7 @@ int acpi_power_get_inferred_state(struct acpi_device *device, int *state)
 
 int acpi_power_transition(struct acpi_device *device, int state)
 {
-	int result = 0;
-	struct acpi_handle_list *cl = NULL;	/* Current Resources */
-	struct acpi_handle_list *tl = NULL;	/* Target Resources */
-	int i = 0;
+	int result;
 
 	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
 		return -EINVAL;
@@ -473,37 +499,20 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	    || (device->power.state > ACPI_STATE_D3))
 		return -ENODEV;
 
-	cl = &device->power.states[device->power.state].resources;
-	tl = &device->power.states[state].resources;
-
 	/* TBD: Resources must be ordered. */
 
 	/*
 	 * First we reference all power resources required in the target list
-	 * (e.g. so the device doesn't lose power while transitioning).
+	 * (e.g. so the device doesn't lose power while transitioning).  Then,
+	 * we dereference all power resources used in the current list.
 	 */
-	for (i = 0; i < tl->count; i++) {
-		result = acpi_power_on(tl->handles[i]);
-		if (result)
-			goto end;
-	}
+	result = acpi_power_on_list(&device->power.states[state].resources);
+	if (!result)
+		acpi_power_off_list(
+			&device->power.states[device->power.state].resources);
 
-	/*
-	 * Then we dereference all power resources used in the current list.
-	 */
-	for (i = 0; i < cl->count; i++) {
-		result = acpi_power_off_device(cl->handles[i]);
-		if (result)
-			goto end;
-	}
-
-     end:
-	if (result)
-		device->power.state = ACPI_STATE_UNKNOWN;
-	else {
-	/* We shouldn't change the state till all above operations succeed */
-		device->power.state = state;
-	}
+	/* We shouldn't change the state unless the above operations succeed. */
+	device->power.state = result ? ACPI_STATE_UNKNOWN : state;
 
 	return result;
 }

commit 32a00d274e877eab3ea7ab196b75c9be5170d25e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 25 00:05:17 2010 +0100

    ACPI / PM: Prevent acpi_power_get_inferred_state() from making changes
    
    acpi_power_get_inferred_state() should not update
    device->power.state behind the back of its caller, so make it return
    the state via a pointer instead.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 4c9c2fb5d98f..9bd1b6044b55 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -423,19 +423,16 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
                              Device Power Management
    -------------------------------------------------------------------------- */
 
-int acpi_power_get_inferred_state(struct acpi_device *device)
+int acpi_power_get_inferred_state(struct acpi_device *device, int *state)
 {
 	int result = 0;
 	struct acpi_handle_list *list = NULL;
 	int list_state = 0;
 	int i = 0;
 
-
-	if (!device)
+	if (!device || !state)
 		return -EINVAL;
 
-	device->power.state = ACPI_STATE_UNKNOWN;
-
 	/*
 	 * We know a device's inferred power state when all the resources
 	 * required for a given D-state are 'on'.
@@ -450,13 +447,12 @@ int acpi_power_get_inferred_state(struct acpi_device *device)
 			return result;
 
 		if (list_state == ACPI_POWER_RESOURCE_STATE_ON) {
-			device->power.state = i;
+			*state = i;
 			return 0;
 		}
 	}
 
-	device->power.state = ACPI_STATE_D3;
-
+	*state = ACPI_STATE_D3;
 	return 0;
 }
 

commit 12b3b5afed67e08aa641d30e57df20dab2e33432
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 25 00:03:32 2010 +0100

    ACPI / PM: Do not refcount power resources that can't be turned on
    
    If turning on a power resource fails, do not reference count it,
    since it cannot be in use in that case.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 792a8309d074..4c9c2fb5d98f 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -213,11 +213,13 @@ static int acpi_power_on(acpi_handle handle)
 				  resource->name));
 	} else {
 		result = __acpi_power_on(resource);
+		if (result)
+			resource->ref_count--;
 	}
 
 	mutex_unlock(&resource->resource_lock);
 
-	return 0;
+	return result;
 }
 
 static int acpi_power_off_device(acpi_handle handle)

commit 212967c69afd348342548272aedbe4d46a9325d6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 25 00:02:36 2010 +0100

    ACPI / PM: Check device state before refcounting power resources
    
    Commit 3e384ee6c687cb397581ee8f9440fc8220cfac80 (ACPI / PM: Fix
    reference counting of power resources) introduced a regression by
    causing fan power resources to be turned on and reference counted
    unnecessarily during resume, so on some boxes fans are always on
    after resume.
    
    Fix the problem by checking if the current device state is different
    from the new state before reference counting and turning on power
    resources in acpi_power_transition().
    
    Addresses https://bugzilla.kernel.org/show_bug.cgi?id=22932 .
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-and-tested-by: Maciej Rutecki <maciej.rutecki@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 67dedeed144c..792a8309d074 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -465,10 +465,12 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	struct acpi_handle_list *tl = NULL;	/* Target Resources */
 	int i = 0;
 
-
 	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
 		return -EINVAL;
 
+	if (device->power.state == state)
+		return 0;
+
 	if ((device->power.state < ACPI_STATE_D0)
 	    || (device->power.state > ACPI_STATE_D3))
 		return -ENODEV;
@@ -488,10 +490,6 @@ int acpi_power_transition(struct acpi_device *device, int state)
 			goto end;
 	}
 
-	if (device->power.state == state) {
-		goto end;
-	}
-
 	/*
 	 * Then we dereference all power resources used in the current list.
 	 */

commit 3e384ee6c687cb397581ee8f9440fc8220cfac80
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Oct 22 02:35:54 2010 +0200

    ACPI / PM: Fix reference counting of power resources
    
    The reference counting of ACPI power resources is currently broken
    for a few reasons.  First, instead of using a simple reference
    counter per power resource it uses a list of objects representing
    refereces to the given power resource from devices.  This leads to
    the second breakage, because it prevents power resources from
    being referenced more than once by one device, which is necessary
    if the device is configured to signal wakeup.  Namely, when putting
    the device into a low power state we first call
    acpi_enable_wakeup_device_power() that should reference count power
    resources needed for signaling wakeup and then we call
    acpi_power_transition() to power off the device.  The latter call
    drops references to the device's power resources, possibly including
    the ones added by acpi_enable_wakeup_device_power(), so the device
    can't signal wakeup as a result.  Apart from this, the locking
    in acpi_power_on() and acpi_power_off_device() doesn't prevent
    all possible races from happening, which may be problematic for
    runtime PM and asynchronous suspend and resume.
    
    Fix the problem by using a counter for power resources reference
    counting and putting the evaluation of ACPI _ON and _OFF methods
    under the power resource mutex.
    
    Reported-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 844c155aeb0f..67dedeed144c 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -80,18 +80,13 @@ static struct acpi_driver acpi_power_driver = {
 		},
 };
 
-struct acpi_power_reference {
-	struct list_head node;
-	struct acpi_device *device;
-};
-
 struct acpi_power_resource {
 	struct acpi_device * device;
 	acpi_bus_id name;
 	u32 system_level;
 	u32 order;
+	unsigned int ref_count;
 	struct mutex resource_lock;
-	struct list_head reference;
 };
 
 static struct list_head acpi_power_resource_list;
@@ -184,101 +179,89 @@ static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 	return result;
 }
 
-static int acpi_power_on(acpi_handle handle, struct acpi_device *dev)
+static int __acpi_power_on(struct acpi_power_resource *resource)
 {
-	int result = 0;
-	int found = 0;
 	acpi_status status = AE_OK;
-	struct acpi_power_resource *resource = NULL;
-	struct list_head *node, *next;
-	struct acpi_power_reference *ref;
 
+	status = acpi_evaluate_object(resource->device->handle, "_ON", NULL, NULL);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	/* Update the power resource's _device_ power state */
+	resource->device->power.state = ACPI_STATE_D0;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Power resource [%s] turned on\n",
+			  resource->name));
+
+	return 0;
+}
+
+static int acpi_power_on(acpi_handle handle)
+{
+	int result = 0;
+	struct acpi_power_resource *resource = NULL;
 
 	result = acpi_power_get_context(handle, &resource);
 	if (result)
 		return result;
 
 	mutex_lock(&resource->resource_lock);
-	list_for_each_safe(node, next, &resource->reference) {
-		ref = container_of(node, struct acpi_power_reference, node);
-		if (dev->handle == ref->device->handle) {
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] already referenced by resource [%s]\n",
-				  dev->pnp.bus_id, resource->name));
-			found = 1;
-			break;
-		}
-	}
 
-	if (!found) {
-		ref = kmalloc(sizeof (struct acpi_power_reference),
-		    irqs_disabled() ? GFP_ATOMIC : GFP_KERNEL);
-		if (!ref) {
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "kmalloc() failed\n"));
-			mutex_unlock(&resource->resource_lock);
-			return -ENOMEM;
-		}
-		list_add_tail(&ref->node, &resource->reference);
-		ref->device = dev;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] added to resource [%s] references\n",
-			  dev->pnp.bus_id, resource->name));
+	if (resource->ref_count++) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Power resource [%s] already on",
+				  resource->name));
+	} else {
+		result = __acpi_power_on(resource);
 	}
-	mutex_unlock(&resource->resource_lock);
 
-	status = acpi_evaluate_object(resource->device->handle, "_ON", NULL, NULL);
-	if (ACPI_FAILURE(status))
-		return -ENODEV;
-
-	/* Update the power resource's _device_ power state */
-	resource->device->power.state = ACPI_STATE_D0;
+	mutex_unlock(&resource->resource_lock);
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned on\n",
-			  resource->name));
 	return 0;
 }
 
-static int acpi_power_off_device(acpi_handle handle, struct acpi_device *dev)
+static int acpi_power_off_device(acpi_handle handle)
 {
 	int result = 0;
 	acpi_status status = AE_OK;
 	struct acpi_power_resource *resource = NULL;
-	struct list_head *node, *next;
-	struct acpi_power_reference *ref;
 
 	result = acpi_power_get_context(handle, &resource);
 	if (result)
 		return result;
 
 	mutex_lock(&resource->resource_lock);
-	list_for_each_safe(node, next, &resource->reference) {
-		ref = container_of(node, struct acpi_power_reference, node);
-		if (dev->handle == ref->device->handle) {
-			list_del(&ref->node);
-			kfree(ref);
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] removed from resource [%s] references\n",
-			    dev->pnp.bus_id, resource->name));
-			break;
-		}
+
+	if (!resource->ref_count) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Power resource [%s] already off",
+				  resource->name));
+		goto unlock;
 	}
 
-	if (!list_empty(&resource->reference)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cannot turn resource [%s] off - resource is in use\n",
-		    resource->name));
-		mutex_unlock(&resource->resource_lock);
-		return 0;
+	if (--resource->ref_count) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Power resource [%s] still in use\n",
+				  resource->name));
+		goto unlock;
 	}
-	mutex_unlock(&resource->resource_lock);
 
 	status = acpi_evaluate_object(resource->device->handle, "_OFF", NULL, NULL);
-	if (ACPI_FAILURE(status))
-		return -ENODEV;
+	if (ACPI_FAILURE(status)) {
+		result = -ENODEV;
+	} else {
+		/* Update the power resource's _device_ power state */
+		resource->device->power.state = ACPI_STATE_D3;
 
-	/* Update the power resource's _device_ power state */
-	resource->device->power.state = ACPI_STATE_D3;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Power resource [%s] turned off\n",
+				  resource->name));
+	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned off\n",
-			  resource->name));
+ unlock:
+	mutex_unlock(&resource->resource_lock);
 
-	return 0;
+	return result;
 }
 
 /**
@@ -364,7 +347,7 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state)
 
 	/* Open power resource */
 	for (i = 0; i < dev->wakeup.resources.count; i++) {
-		int ret = acpi_power_on(dev->wakeup.resources.handles[i], dev);
+		int ret = acpi_power_on(dev->wakeup.resources.handles[i]);
 		if (ret) {
 			printk(KERN_ERR PREFIX "Transition power state\n");
 			dev->wakeup.flags.valid = 0;
@@ -420,7 +403,7 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 	/* Close power resource */
 	for (i = 0; i < dev->wakeup.resources.count; i++) {
 		int ret = acpi_power_off_device(
-				dev->wakeup.resources.handles[i], dev);
+				dev->wakeup.resources.handles[i]);
 		if (ret) {
 			printk(KERN_ERR PREFIX "Transition power state\n");
 			dev->wakeup.flags.valid = 0;
@@ -500,7 +483,7 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	 * (e.g. so the device doesn't lose power while transitioning).
 	 */
 	for (i = 0; i < tl->count; i++) {
-		result = acpi_power_on(tl->handles[i], device);
+		result = acpi_power_on(tl->handles[i]);
 		if (result)
 			goto end;
 	}
@@ -513,7 +496,7 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	 * Then we dereference all power resources used in the current list.
 	 */
 	for (i = 0; i < cl->count; i++) {
-		result = acpi_power_off_device(cl->handles[i], device);
+		result = acpi_power_off_device(cl->handles[i]);
 		if (result)
 			goto end;
 	}
@@ -551,7 +534,6 @@ static int acpi_power_add(struct acpi_device *device)
 
 	resource->device = device;
 	mutex_init(&resource->resource_lock);
-	INIT_LIST_HEAD(&resource->reference);
 	strcpy(resource->name, device->pnp.bus_id);
 	strcpy(acpi_device_name(device), ACPI_POWER_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_POWER_CLASS);
@@ -594,22 +576,14 @@ static int acpi_power_add(struct acpi_device *device)
 
 static int acpi_power_remove(struct acpi_device *device, int type)
 {
-	struct acpi_power_resource *resource = NULL;
-	struct list_head *node, *next;
+	struct acpi_power_resource *resource;
 
-
-	if (!device || !acpi_driver_data(device))
+	if (!device)
 		return -EINVAL;
 
 	resource = acpi_driver_data(device);
-
-	mutex_lock(&resource->resource_lock);
-	list_for_each_safe(node, next, &resource->reference) {
-		struct acpi_power_reference *ref = container_of(node, struct acpi_power_reference, node);
-		list_del(&ref->node);
-		kfree(ref);
-	}
-	mutex_unlock(&resource->resource_lock);
+	if (!resource)
+		return -EINVAL;
 
 	kfree(resource);
 
@@ -619,29 +593,28 @@ static int acpi_power_remove(struct acpi_device *device, int type)
 static int acpi_power_resume(struct acpi_device *device)
 {
 	int result = 0, state;
-	struct acpi_power_resource *resource = NULL;
-	struct acpi_power_reference *ref;
+	struct acpi_power_resource *resource;
 
-	if (!device || !acpi_driver_data(device))
+	if (!device)
 		return -EINVAL;
 
 	resource = acpi_driver_data(device);
+	if (!resource)
+		return -EINVAL;
+
+	mutex_lock(&resource->resource_lock);
 
 	result = acpi_power_get_state(device->handle, &state);
 	if (result)
-		return result;
+		goto unlock;
 
-	mutex_lock(&resource->resource_lock);
-	if (state == ACPI_POWER_RESOURCE_STATE_OFF &&
-	    !list_empty(&resource->reference)) {
-		ref = container_of(resource->reference.next, struct acpi_power_reference, node);
-		mutex_unlock(&resource->resource_lock);
-		result = acpi_power_on(device->handle, ref->device);
-		return result;
-	}
+	if (state == ACPI_POWER_RESOURCE_STATE_OFF && resource->ref_count)
+		result = __acpi_power_on(resource);
 
+ unlock:
 	mutex_unlock(&resource->resource_lock);
-	return 0;
+
+	return result;
 }
 
 int __init acpi_power_init(void)

commit 2245ba2a3a975656bb303dfaa115accaa4667083
Merge: e2e96c663639 95ee46aa8698
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Aug 15 17:37:07 2010 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6:
      gcc-4.6: ACPI: fix unused but set variables in ACPI
      ACPI thermal: make procfs I/F depend on CONFIG_ACPI_PROCFS
      ACPI video: make procfs I/F depend on CONFIG_ACPI_PROCFS
      ACPI processor: remove deprecated ACPI procfs I/F
      ACPI power_resource: remove unused procfs I/F
      ACPI: remove deprecated ACPI procfs I/F
      ACPI: introduce drivers/acpi/sysfs.c
      ACPI: introduce module parameter acpi.aml_debug_output
      ACPI: introduce drivers/acpi/debugfs.c
      ACPI, APEI, ERST debug support
      ACPI, APEI, Manage GHES as platform devices
      ACPI, APEI, Rename CPER and GHES severity constants
      ACPI, APEI, Fix a typo of error path of apei_resources_request
      ACPI / ACPICA: Fix reference counting problems with GPE handlers
      ACPI: Add the check of ADR flag in course of finding ACPI handle for PCI device
      ACPI / Sleep: Drop acpi_suspend_finish()
      ACPI / Sleep: Consolidate suspend and hibernation routines
      ACPI / Wakeup: Simplify enabling of wakeup devices
      ACPI / Sleep: Rework enabling wakeup devices
      ACPI / Sleep: Free NVS copy if suspending of devices fails
    
    Fixed up totally buggered "ACPI: fix unused but set variables in ACPI"
    patch that doesn't even compile in the merge.
    
    Thanks to Sedat Dilek <sedat.dilek@googlemail.com> for noticing the
    breakage before I even pulled.  And a big "Grrr.." at Len for not even
    bothering to compile the tree before asking me to pull.

commit cfa806f059801dbe7e435745eb2e187c8bfe1e7f
Author: Andi Kleen <andi@firstfloor.org>
Date:   Tue Jul 20 15:18:36 2010 -0700

    gcc-4.6: ACPI: fix unused but set variables in ACPI
    
    Some minor improvements in error handling, but overall it was mostly dead
    code.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 4fe5018fd6ab..cf073aa0709b 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -242,8 +242,6 @@ static int acpi_power_off_device(acpi_handle handle, struct acpi_device *dev)
 	acpi_status status = AE_OK;
 	struct acpi_power_resource *resource = NULL;
 	struct list_head *node, *next;
-	struct acpi_power_reference *ref;
-
 
 	result = acpi_power_get_context(handle, &resource);
 	if (result)

commit 06af7eb043c02822072cea862fce1b7c74115e8f
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Jul 15 10:46:38 2010 +0800

    ACPI power_resource: remove unused procfs I/F
    
    Remove unused ACPI power procfs I/F.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index f74d3b31e5c9..4fe5018fd6ab 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -40,8 +40,6 @@
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/slab.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 #include "sleep.h"
@@ -64,7 +62,6 @@ module_param_named(power_nocheck, acpi_power_nocheck, bool, 000);
 static int acpi_power_add(struct acpi_device *device);
 static int acpi_power_remove(struct acpi_device *device, int type);
 static int acpi_power_resume(struct acpi_device *device);
-static int acpi_power_open_fs(struct inode *inode, struct file *file);
 
 static const struct acpi_device_id power_device_ids[] = {
 	{ACPI_POWER_HID, 0},
@@ -99,14 +96,6 @@ struct acpi_power_resource {
 
 static struct list_head acpi_power_resource_list;
 
-static const struct file_operations acpi_power_fops = {
-	.owner = THIS_MODULE,
-	.open = acpi_power_open_fs,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
 /* --------------------------------------------------------------------------
                              Power Resource Management
    -------------------------------------------------------------------------- */
@@ -541,102 +530,6 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	return result;
 }
 
-/* --------------------------------------------------------------------------
-                              FS Interface (/proc)
-   -------------------------------------------------------------------------- */
-
-static struct proc_dir_entry *acpi_power_dir;
-
-static int acpi_power_seq_show(struct seq_file *seq, void *offset)
-{
-	int count = 0;
-	int result = 0, state;
-	struct acpi_power_resource *resource = NULL;
-	struct list_head *node, *next;
-	struct acpi_power_reference *ref;
-
-
-	resource = seq->private;
-
-	if (!resource)
-		goto end;
-
-	result = acpi_power_get_state(resource->device->handle, &state);
-	if (result)
-		goto end;
-
-	seq_puts(seq, "state:                   ");
-	switch (state) {
-	case ACPI_POWER_RESOURCE_STATE_ON:
-		seq_puts(seq, "on\n");
-		break;
-	case ACPI_POWER_RESOURCE_STATE_OFF:
-		seq_puts(seq, "off\n");
-		break;
-	default:
-		seq_puts(seq, "unknown\n");
-		break;
-	}
-
-	mutex_lock(&resource->resource_lock);
-	list_for_each_safe(node, next, &resource->reference) {
-		ref = container_of(node, struct acpi_power_reference, node);
-		count++;
-	}
-	mutex_unlock(&resource->resource_lock);
-
-	seq_printf(seq, "system level:            S%d\n"
-		   "order:                   %d\n"
-		   "reference count:         %d\n",
-		   resource->system_level,
-		   resource->order, count);
-
-      end:
-	return 0;
-}
-
-static int acpi_power_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_power_seq_show, PDE(inode)->data);
-}
-
-static int acpi_power_add_fs(struct acpi_device *device)
-{
-	struct proc_dir_entry *entry = NULL;
-
-
-	if (!device)
-		return -EINVAL;
-
-	if (!acpi_device_dir(device)) {
-		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
-						     acpi_power_dir);
-		if (!acpi_device_dir(device))
-			return -ENODEV;
-	}
-
-	/* 'status' [R] */
-	entry = proc_create_data(ACPI_POWER_FILE_STATUS,
-				 S_IRUGO, acpi_device_dir(device),
-				 &acpi_power_fops, acpi_driver_data(device));
-	if (!entry)
-		return -EIO;
-	return 0;
-}
-
-static int acpi_power_remove_fs(struct acpi_device *device)
-{
-
-	if (acpi_device_dir(device)) {
-		remove_proc_entry(ACPI_POWER_FILE_STATUS,
-				  acpi_device_dir(device));
-		remove_proc_entry(acpi_device_bid(device), acpi_power_dir);
-		acpi_device_dir(device) = NULL;
-	}
-
-	return 0;
-}
-
 /* --------------------------------------------------------------------------
                                 Driver Interface
    -------------------------------------------------------------------------- */
@@ -690,10 +583,6 @@ static int acpi_power_add(struct acpi_device *device)
 		break;
 	}
 
-	result = acpi_power_add_fs(device);
-	if (result)
-		goto end;
-
 	printk(KERN_INFO PREFIX "%s [%s] (%s)\n", acpi_device_name(device),
 	       acpi_device_bid(device), state ? "on" : "off");
 
@@ -715,8 +604,6 @@ static int acpi_power_remove(struct acpi_device *device, int type)
 
 	resource = acpi_driver_data(device);
 
-	acpi_power_remove_fs(device);
-
 	mutex_lock(&resource->resource_lock);
 	list_for_each_safe(node, next, &resource->reference) {
 		struct acpi_power_reference *ref = container_of(node, struct acpi_power_reference, node);
@@ -760,19 +647,6 @@ static int acpi_power_resume(struct acpi_device *device)
 
 int __init acpi_power_init(void)
 {
-	int result = 0;
-
 	INIT_LIST_HEAD(&acpi_power_resource_list);
-
-	acpi_power_dir = proc_mkdir(ACPI_POWER_CLASS, acpi_root_dir);
-	if (!acpi_power_dir)
-		return -ENODEV;
-
-	result = acpi_bus_register_driver(&acpi_power_driver);
-	if (result < 0) {
-		remove_proc_entry(ACPI_POWER_CLASS, acpi_root_dir);
-		return -ENODEV;
-	}
-
-	return 0;
+	return acpi_bus_register_driver(&acpi_power_driver);
 }

commit 6c9468e9eb1252eaefd94ce7f06e1be9b0b641b1
Merge: 4cb3ca7cd7e2 c81eddb0e372
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Apr 23 02:08:44 2010 +0200

    Merge branch 'master' into for-next

commit 00bc42a11b0be6ce34c403ccc1990a6846a90d37
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Wed Mar 31 16:22:54 2010 -0700

    Remove empty comment in acpi/power.c
    
    Remove an empty comment.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 0f30c3c1eea4..8ed24c2fa185 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -171,7 +171,6 @@ static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 		return -EINVAL;
 
 	/* The state of the list is 'on' IFF all resources are 'on'. */
-	/* */
 
 	for (i = 0; i < list->count; i++) {
 		/*

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 0f30c3c1eea4..ddc76787b842 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -39,6 +39,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/types.h>
+#include <linux/slab.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <acpi/acpi_bus.h>

commit c97adf9e7bebf17a86b95e2131bf9ba76c4857c7
Author: Mrton Nmeth <nm127@freemail.hu>
Date:   Sun Jan 10 17:15:36 2010 +0100

    acpi: make ACPI device id constant
    
    The ids field of the struct acpi_driver is constant in <linux/acpi/acpi_bus.h>
    so it is worth to make the initialization data also constant.
    
    The semantic match that finds this kind of pattern is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    disable decl_init,const_decl_init;
    identifier I1, I2, x;
    @@
            struct I1 {
              ...
              const struct I2 *x;
              ...
            };
    @s@
    identifier r.I1, y;
    identifier r.x, E;
    @@
            struct I1 y = {
              .x = E,
            };
    @c@
    identifier r.I2;
    identifier s.E;
    @@
            const struct I2 E[] = ... ;
    @depends on !c@
    identifier r.I2;
    identifier s.E;
    @@
    +       const
            struct I2 E[] = ...;
    // </smpl>
    
    Signed-off-by: Mrton Nmeth <nm127@freemail.hu>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: cocci@diku.dk
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 22b297916519..0f30c3c1eea4 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -65,7 +65,7 @@ static int acpi_power_remove(struct acpi_device *device, int type);
 static int acpi_power_resume(struct acpi_device *device);
 static int acpi_power_open_fs(struct inode *inode, struct file *file);
 
-static struct acpi_device_id power_device_ids[] = {
+static const struct acpi_device_id power_device_ids[] = {
 	{ACPI_POWER_HID, 0},
 	{"", 0},
 };

commit 003d6a38ce1a59e0053a02fd9e9a65b588bc8e33
Merge: 71fd68e7d234 e55a5999ffcf
Author: Len Brown <len.brown@intel.com>
Date:   Sat Sep 19 00:37:13 2009 -0400

    Merge branch 'sfi-base' into release
    
    Conflicts:
            drivers/acpi/power.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 9b83ccd2f14f647936dcfbf4a9a20c501007dd69
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Sep 8 23:15:31 2009 +0200

    ACPI PM: Replace wakeup.prepared with reference counter
    
    The wakeup.prepared flag is used for marking devices that have the
    wake-up power already enabled, so that the wake-up power is not
    enabled twice in a row for the same device.  This assumes, however,
    that device wake-up power will only be enabled once, while the device
    is being prepared for a system-wide sleep transition, and the second
    attempt is made by acpi_enable_wakeup_device_prep().
    
    With the upcoming PCI wake-up rework this assumption will not hold
    any more for PCI bridges and the root bridge whose wake-up power
    may be enabled as a result of wake-up enable propagation from other
    devices (eg. add-on devices that are not associated with any GPEs).
    Thus, there may be many attempts to enable wake-up power on a PCI
    bridge or the root bridge during a system power state transition
    and it's better to replace wakeup.prepared with a reference counter.
    
    Reviewed-by: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index d74365d4a6e7..5a09bf392ec1 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -44,6 +44,8 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
+#include "sleep.h"
+
 #define _COMPONENT			ACPI_POWER_COMPONENT
 ACPI_MODULE_NAME("power");
 #define ACPI_POWER_CLASS		"power_resource"
@@ -361,17 +363,15 @@ int acpi_device_sleep_wake(struct acpi_device *dev,
  */
 int acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state)
 {
-	int i, err;
+	int i, err = 0;
 
 	if (!dev || !dev->wakeup.flags.valid)
 		return -EINVAL;
 
-	/*
-	 * Do not execute the code below twice in a row without calling
-	 * acpi_disable_wakeup_device_power() in between for the same device
-	 */
-	if (dev->wakeup.flags.prepared)
-		return 0;
+	mutex_lock(&acpi_device_lock);
+
+	if (dev->wakeup.prepare_count++)
+		goto out;
 
 	/* Open power resource */
 	for (i = 0; i < dev->wakeup.resources.count; i++) {
@@ -379,7 +379,8 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state)
 		if (ret) {
 			printk(KERN_ERR PREFIX "Transition power state\n");
 			dev->wakeup.flags.valid = 0;
-			return -ENODEV;
+			err = -ENODEV;
+			goto err_out;
 		}
 	}
 
@@ -388,9 +389,13 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state)
 	 * in arbitrary power state afterwards.
 	 */
 	err = acpi_device_sleep_wake(dev, 1, sleep_state, 3);
-	if (!err)
-		dev->wakeup.flags.prepared = 1;
 
+ err_out:
+	if (err)
+		dev->wakeup.prepare_count = 0;
+
+ out:
+	mutex_unlock(&acpi_device_lock);
 	return err;
 }
 
@@ -402,35 +407,42 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state)
  */
 int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 {
-	int i, ret;
+	int i, err = 0;
 
 	if (!dev || !dev->wakeup.flags.valid)
 		return -EINVAL;
 
+	mutex_lock(&acpi_device_lock);
+
+	if (--dev->wakeup.prepare_count > 0)
+		goto out;
+
 	/*
-	 * Do not execute the code below twice in a row without calling
-	 * acpi_enable_wakeup_device_power() in between for the same device
+	 * Executing the code below even if prepare_count is already zero when
+	 * the function is called may be useful, for example for initialisation.
 	 */
-	if (!dev->wakeup.flags.prepared)
-		return 0;
+	if (dev->wakeup.prepare_count < 0)
+		dev->wakeup.prepare_count = 0;
 
-	dev->wakeup.flags.prepared = 0;
-
-	ret = acpi_device_sleep_wake(dev, 0, 0, 0);
-	if (ret)
-		return ret;
+	err = acpi_device_sleep_wake(dev, 0, 0, 0);
+	if (err)
+		goto out;
 
 	/* Close power resource */
 	for (i = 0; i < dev->wakeup.resources.count; i++) {
-		ret = acpi_power_off_device(dev->wakeup.resources.handles[i], dev);
+		int ret = acpi_power_off_device(
+				dev->wakeup.resources.handles[i], dev);
 		if (ret) {
 			printk(KERN_ERR PREFIX "Transition power state\n");
 			dev->wakeup.flags.valid = 0;
-			return -ENODEV;
+			err = -ENODEV;
+			goto out;
 		}
 	}
 
-	return ret;
+ out:
+	mutex_unlock(&acpi_device_lock);
+	return err;
 }
 
 /* --------------------------------------------------------------------------

commit a192a9580bcc41692be1f36b77c3b681827f566a
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jul 28 16:45:54 2009 -0400

    ACPI: Move definition of PREFIX from acpi_bus.h to internal..h
    
    Linux/ACPI core files using internal.h all PREFIX "ACPI: ",
    however, not all ACPI drivers use/want it -- and they
    should not have to #undef PREFIX to define their own.
    
    Add GPL commment to internal.h while we are there.
    
    This does not change any actual console output,
    asside from a whitespace fix.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index d74365d4a6e7..e86603f37dee 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -44,6 +44,8 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
+#define PREFIX "ACPI: "
+
 #define _COMPONENT			ACPI_POWER_COMPONENT
 ACPI_MODULE_NAME("power");
 #define ACPI_POWER_CLASS		"power_resource"

commit bdf43bbf2e19952d82995a50e00cb4b66afa4f0c
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu May 21 17:28:53 2009 -0600

    ACPI: don't check power state after _ON/_OFF
    
    We used to evaluate _STA to check the power state of a device after
    running _ON or _OFF.  But as far as I can tell, there's no benefit
    to evaluating _STA, and sometimes we trip over bugs when BIOSes don't
    implement _STA correctly.
    
    Yakui says Windows XP doesn't evaluate _STA during power transition.
    So let's skip it in Linux, too.  It's conceivable that we'll need to
    check _STA in the future for some reason, but until we do, I don't
    see a reason to clutter this code path.
    
    References:
        http://bugzilla.kernel.org/show_bug.cgi?id=13243
        http://marc.info/?l=linux-acpi&m=124166053803753&w=2
        http://marc.info/?l=linux-acpi&m=124175761408256&w=2
        http://marc.info/?l=linux-acpi&m=124210593114061&w=2
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-by: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 56665a63bf19..d74365d4a6e7 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -194,7 +194,7 @@ static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 
 static int acpi_power_on(acpi_handle handle, struct acpi_device *dev)
 {
-	int result = 0, state;
+	int result = 0;
 	int found = 0;
 	acpi_status status = AE_OK;
 	struct acpi_power_resource *resource = NULL;
@@ -236,18 +236,6 @@ static int acpi_power_on(acpi_handle handle, struct acpi_device *dev)
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
-	if (!acpi_power_nocheck) {
-		/*
-		 * If acpi_power_nocheck is set, it is unnecessary to check
-		 * the power state after power transition.
-		 */
-		result = acpi_power_get_state(resource->device->handle,
-				&state);
-		if (result)
-			return result;
-		if (state != ACPI_POWER_RESOURCE_STATE_ON)
-			return -ENOEXEC;
-	}
 	/* Update the power resource's _device_ power state */
 	resource->device->power.state = ACPI_STATE_D0;
 
@@ -258,7 +246,7 @@ static int acpi_power_on(acpi_handle handle, struct acpi_device *dev)
 
 static int acpi_power_off_device(acpi_handle handle, struct acpi_device *dev)
 {
-	int result = 0, state;
+	int result = 0;
 	acpi_status status = AE_OK;
 	struct acpi_power_resource *resource = NULL;
 	struct list_head *node, *next;
@@ -293,18 +281,6 @@ static int acpi_power_off_device(acpi_handle handle, struct acpi_device *dev)
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
-	if (!acpi_power_nocheck) {
-		/*
-		 * If acpi_power_nocheck is set, it is unnecessary to check
-		 * the power state after power transition.
-		 */
-		result = acpi_power_get_state(handle, &state);
-		if (result)
-			return result;
-		if (state != ACPI_POWER_RESOURCE_STATE_OFF)
-			return -ENOEXEC;
-	}
-
 	/* Update the power resource's _device_ power state */
 	resource->device->power.state = ACPI_STATE_D3;
 

commit edd84690d15e4cb144cc60b754d4eaf8fac0a711
Merge: 7c27fd19b6d9 ae7d51517bc3
Author: Len Brown <len.brown@intel.com>
Date:   Sun Apr 5 01:45:50 2009 -0400

    Merge branch 'acpi-modparam' into release
    
    Conflicts:
            drivers/acpi/Makefile
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 5b5d9117407e790ade594687010343c5d559a1f4
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Mar 12 09:07:19 2009 +1030

    ACPI: simplify module_param namespace
    
    Impact: cleanup
    
    Rather than overriding MODULE_PARAM_PREFIX, build via acpi.o so
    KBUILD_MODNAME is set to "acpi".
    
    This is the logical way to do it, even though acpi cannot be a module
    due to these config options being bool.  Those parts of ACPI which can
    be modular are not built into the acpi "module".
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index c926e7d4a0d6..87361c1592d3 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -54,10 +54,6 @@ ACPI_MODULE_NAME("power");
 #define ACPI_POWER_RESOURCE_STATE_ON	0x01
 #define ACPI_POWER_RESOURCE_STATE_UNKNOWN 0xFF
 
-#ifdef MODULE_PARAM_PREFIX
-#undef MODULE_PARAM_PREFIX
-#endif
-#define MODULE_PARAM_PREFIX "acpi."
 int acpi_power_nocheck;
 module_param_named(power_nocheck, acpi_power_nocheck, bool, 000);
 

commit 44515374cba9e46d5622256b43eb06b9c349cee1
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 24 16:49:53 2009 -0600

    ACPI: call acpi_power_init() explicitly rather than as initcall
    
    This patch makes acpi_init() call acpi_power_init() directly.
    Previously, both were subsys_initcalls.  acpi_power_init()
    must happen after acpi_init(), and it's better to call it
    explicitly rather than rely on link ordering.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    CC: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index c926e7d4a0d6..11968ba28feb 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -773,14 +773,10 @@ static int acpi_power_resume(struct acpi_device *device)
 	return 0;
 }
 
-static int __init acpi_power_init(void)
+int __init acpi_power_init(void)
 {
 	int result = 0;
 
-
-	if (acpi_disabled)
-		return 0;
-
 	INIT_LIST_HEAD(&acpi_power_resource_list);
 
 	acpi_power_dir = proc_mkdir(ACPI_POWER_CLASS, acpi_root_dir);
@@ -795,5 +791,3 @@ static int __init acpi_power_init(void)
 
 	return 0;
 }
-
-subsys_initcall(acpi_power_init);

commit 60a4ce7f4148155d3f28eea4a213f7ee47cd57b7
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Tue Dec 16 17:02:22 2008 +0800

    ACPI: power.c: call acpi_get_name to get node name
    
    acpi_ut_get_node_name is an internal acpica function.
    use acpi_get_name to get node ascii name
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index bb7d50dd2818..c926e7d4a0d6 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -139,6 +139,8 @@ static int acpi_power_get_state(acpi_handle handle, int *state)
 {
 	acpi_status status = AE_OK;
 	unsigned long long sta = 0;
+	char node_name[5];
+	struct acpi_buffer buffer = { sizeof(node_name), node_name };
 
 
 	if (!handle || !state)
@@ -151,8 +153,10 @@ static int acpi_power_get_state(acpi_handle handle, int *state)
 	*state = (sta & 0x01)?ACPI_POWER_RESOURCE_STATE_ON:
 			      ACPI_POWER_RESOURCE_STATE_OFF;
 
+	acpi_get_name(handle, ACPI_SINGLE_NAME, &buffer);
+
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] is %s\n",
-			  acpi_ut_get_node_name(handle),
+			  node_name,
 				*state ? "on" : "off"));
 
 	return 0;

commit f613984902b64cfb05599f9ba52c0af39cb4db6b
Merge: 3e0fe364835c 676962dac6e2
Author: Len Brown <len.brown@intel.com>
Date:   Tue Nov 11 21:14:15 2008 -0500

    Merge branch 'power' into release

commit 89595b8f2850a080d290bf778ec933ea1d99f78e
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Nov 7 16:57:45 2008 -0700

    ACPI: consolidate ACPI_*_COMPONENT definitions in acpi_drivers.h
    
    Move all the component definitions for drivers to a single shared place,
    include/acpi/acpi_drivers.h.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index a1718e56103b..81f583f8098b 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -44,9 +44,8 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
-#define _COMPONENT		ACPI_POWER_COMPONENT
+#define _COMPONENT			ACPI_POWER_COMPONENT
 ACPI_MODULE_NAME("power");
-#define ACPI_POWER_COMPONENT		0x00800000
 #define ACPI_POWER_CLASS		"power_resource"
 #define ACPI_POWER_DEVICE_NAME		"Power Resource"
 #define ACPI_POWER_FILE_INFO		"info"

commit 676962dac6e267ce7c13f73962208f9124a084bb
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Mon Oct 27 16:05:39 2008 +0800

    ACPI: fan: Delete the strict check in power transition
    
    On some laptops the Fan device is turned on/off by controlling the
    corresponding power resource. For example: If the power resource
    defined in _PR0 object is turned off, it indicates that the FAN device
    is in off state(the ACPI state is in D3 state).
    
    Maybe the device is already in D3 state and expected to be transited to
    D3 state. As there is no _PR3 object, the power transition can't be
    finished and it will be switched to the Unknown state.
    
    Maybe it is more reasonable that the strick check in power transistion
    is deleted.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=9485
    
    Signed-off-by: yakui.zhao@intel.com
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 30d4a5282a2d..89111cd28ed8 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -517,11 +517,6 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	cl = &device->power.states[device->power.state].resources;
 	tl = &device->power.states[state].resources;
 
-	if (!cl->count && !tl->count) {
-		result = -ENODEV;
-		goto end;
-	}
-
 	/* TBD: Resources must be ordered. */
 
 	/*

commit b1b57fbe9bb10d94682a975456de7a727d1dbc84
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Mon Oct 27 16:04:53 2008 +0800

    ACPI: fix de-reference bug in power resource driver
    
    change state to *state in the function of acpi_power_get_state()
    
    Signed-off-by: yakui.zhao@intel.com
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index a1718e56103b..30d4a5282a2d 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -153,7 +153,8 @@ static int acpi_power_get_state(acpi_handle handle, int *state)
 			      ACPI_POWER_RESOURCE_STATE_OFF;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] is %s\n",
-			  acpi_ut_get_node_name(handle), state ? "on" : "off"));
+			  acpi_ut_get_node_name(handle),
+				*state ? "on" : "off"));
 
 	return 0;
 }

commit 7674416db4ee3d43813dddb650364ca994755256
Merge: 0ca9413c234a 27663c5855b1
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:33:29 2008 -0400

    Merge branch 'ull' into test
    
    Conflicts:
            drivers/acpi/bay.c
            drivers/acpi/dock.c
            drivers/ata/libata-acpi.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 5f50ef453dcb05115fc98f244b8f10bfacd4b8b7
Merge: 530bc23bfeaa e3deda9c87ac
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:28:38 2008 -0400

    Merge branch 'misc' into test

commit f5adfaa372c76423b6e8e4727a9701330374f364
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Mon Aug 11 14:57:50 2008 +0800

    ACPI: Add "acpi.power_nocheck=1" to disable power state check in power transition
    
       Maybe the incorrect power state is returned on the bogus bios, which
    is different with the real power state. For example: the bios returns D0
    state and the real power state is D3. OS expects to set the device to D0
    state. In  such case if OS uses the power state returned by the BIOS and
    checks the device power state very strictly in power transition, the device
    can't be transited to the correct power state.
    
       So the boot option of "acpi.power_nocheck=1" is added to avoid checking
    the device power in the course of device power transition.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=8049
    http://bugzilla.kernel.org/show_bug.cgi?id=11000
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index e7bab75075a9..7ff7349c0c52 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -54,6 +54,14 @@ ACPI_MODULE_NAME("power");
 #define ACPI_POWER_RESOURCE_STATE_OFF	0x00
 #define ACPI_POWER_RESOURCE_STATE_ON	0x01
 #define ACPI_POWER_RESOURCE_STATE_UNKNOWN 0xFF
+
+#ifdef MODULE_PARAM_PREFIX
+#undef MODULE_PARAM_PREFIX
+#endif
+#define MODULE_PARAM_PREFIX "acpi."
+int acpi_power_nocheck;
+module_param_named(power_nocheck, acpi_power_nocheck, bool, 000);
+
 static int acpi_power_add(struct acpi_device *device);
 static int acpi_power_remove(struct acpi_device *device, int type);
 static int acpi_power_resume(struct acpi_device *device);
@@ -228,12 +236,18 @@ static int acpi_power_on(acpi_handle handle, struct acpi_device *dev)
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
-	result = acpi_power_get_state(resource->device->handle, &state);
-	if (result)
-		return result;
-	if (state != ACPI_POWER_RESOURCE_STATE_ON)
-		return -ENOEXEC;
-
+	if (!acpi_power_nocheck) {
+		/*
+		 * If acpi_power_nocheck is set, it is unnecessary to check
+		 * the power state after power transition.
+		 */
+		result = acpi_power_get_state(resource->device->handle,
+				&state);
+		if (result)
+			return result;
+		if (state != ACPI_POWER_RESOURCE_STATE_ON)
+			return -ENOEXEC;
+	}
 	/* Update the power resource's _device_ power state */
 	resource->device->power.state = ACPI_STATE_D0;
 
@@ -279,11 +293,17 @@ static int acpi_power_off_device(acpi_handle handle, struct acpi_device *dev)
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
-	result = acpi_power_get_state(handle, &state);
-	if (result)
-		return result;
-	if (state != ACPI_POWER_RESOURCE_STATE_OFF)
-		return -ENOEXEC;
+	if (!acpi_power_nocheck) {
+		/*
+		 * If acpi_power_nocheck is set, it is unnecessary to check
+		 * the power state after power transition.
+		 */
+		result = acpi_power_get_state(handle, &state);
+		if (result)
+			return result;
+		if (state != ACPI_POWER_RESOURCE_STATE_OFF)
+			return -ENOEXEC;
+	}
 
 	/* Update the power resource's _device_ power state */
 	resource->device->power.state = ACPI_STATE_D3;

commit a51e145f379ae48003129610922595893e8efde0
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Mon Aug 11 14:55:05 2008 +0800

    ACPI: Get the device power state in the course of scanning device
    
    Get the device power state in the course of scanning device if the device
    power flag is power_managable. i.e. The device has the _PSx/_PRx object.
    
    At the same time before the drivers/acpi/power module is loaded, there is no
    relation between acpi_power_resource and acpi device. So the first parameter
    of acpi_power_get_state is changed to acpi_handle.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=8049
    http://bugzilla.kernel.org/show_bug.cgi?id=11000
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 4ab21cb1c8c7..e7bab75075a9 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -128,16 +128,16 @@ acpi_power_get_context(acpi_handle handle,
 	return 0;
 }
 
-static int acpi_power_get_state(struct acpi_power_resource *resource, int *state)
+static int acpi_power_get_state(acpi_handle handle, int *state)
 {
 	acpi_status status = AE_OK;
 	unsigned long sta = 0;
 
 
-	if (!resource || !state)
+	if (!handle || !state)
 		return -EINVAL;
 
-	status = acpi_evaluate_integer(resource->device->handle, "_STA", NULL, &sta);
+	status = acpi_evaluate_integer(handle, "_STA", NULL, &sta);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
@@ -145,7 +145,7 @@ static int acpi_power_get_state(struct acpi_power_resource *resource, int *state
 			      ACPI_POWER_RESOURCE_STATE_OFF;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] is %s\n",
-			  resource->name, state ? "on" : "off"));
+			  acpi_ut_get_node_name(handle), state ? "on" : "off"));
 
 	return 0;
 }
@@ -153,7 +153,6 @@ static int acpi_power_get_state(struct acpi_power_resource *resource, int *state
 static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 {
 	int result = 0, state1;
-	struct acpi_power_resource *resource = NULL;
 	u32 i = 0;
 
 
@@ -161,12 +160,15 @@ static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 		return -EINVAL;
 
 	/* The state of the list is 'on' IFF all resources are 'on'. */
+	/* */
 
 	for (i = 0; i < list->count; i++) {
-		result = acpi_power_get_context(list->handles[i], &resource);
-		if (result)
-			return result;
-		result = acpi_power_get_state(resource, &state1);
+		/*
+		 * The state of the power resource can be obtained by
+		 * using the ACPI handle. In such case it is unnecessary to
+		 * get the Power resource first and then get its state again.
+		 */
+		result = acpi_power_get_state(list->handles[i], &state1);
 		if (result)
 			return result;
 
@@ -226,7 +228,7 @@ static int acpi_power_on(acpi_handle handle, struct acpi_device *dev)
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
-	result = acpi_power_get_state(resource, &state);
+	result = acpi_power_get_state(resource->device->handle, &state);
 	if (result)
 		return result;
 	if (state != ACPI_POWER_RESOURCE_STATE_ON)
@@ -277,7 +279,7 @@ static int acpi_power_off_device(acpi_handle handle, struct acpi_device *dev)
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
-	result = acpi_power_get_state(resource, &state);
+	result = acpi_power_get_state(handle, &state);
 	if (result)
 		return result;
 	if (state != ACPI_POWER_RESOURCE_STATE_OFF)
@@ -555,7 +557,7 @@ static int acpi_power_seq_show(struct seq_file *seq, void *offset)
 	if (!resource)
 		goto end;
 
-	result = acpi_power_get_state(resource, &state);
+	result = acpi_power_get_state(resource->device->handle, &state);
 	if (result)
 		goto end;
 
@@ -668,7 +670,7 @@ static int acpi_power_add(struct acpi_device *device)
 	resource->system_level = acpi_object.power_resource.system_level;
 	resource->order = acpi_object.power_resource.resource_order;
 
-	result = acpi_power_get_state(resource, &state);
+	result = acpi_power_get_state(device->handle, &state);
 	if (result)
 		goto end;
 
@@ -735,7 +737,7 @@ static int acpi_power_resume(struct acpi_device *device)
 
 	resource = (struct acpi_power_resource *)acpi_driver_data(device);
 
-	result = acpi_power_get_state(resource, &state);
+	result = acpi_power_get_state(device->handle, &state);
 	if (result)
 		return result;
 

commit 27663c5855b10af9ec67bc7dfba001426ba21222
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Fri Oct 10 02:22:59 2008 -0400

    ACPI: Change acpi_evaluate_integer to support 64-bit on 32-bit kernels
    
    As of version 2.0, ACPI can return 64-bit integers.  The current
    acpi_evaluate_integer only supports 64-bit integers on 64-bit platforms.
    Change the argument to take a pointer to an acpi_integer so we support
    64-bit integers on all platforms.
    
    lenb: replaced use of "acpi_integer" with "unsigned long long"
    lenb: fixed bug in acpi_thermal_trips_update()
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 4ab21cb1c8c7..89e5d2a8c33a 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -131,7 +131,7 @@ acpi_power_get_context(acpi_handle handle,
 static int acpi_power_get_state(struct acpi_power_resource *resource, int *state)
 {
 	acpi_status status = AE_OK;
-	unsigned long sta = 0;
+	unsigned long long sta = 0;
 
 
 	if (!resource || !state)

commit db89b4f0dbab837d0f3de2c3e9427a8d5393afa3
Author: Pavel Machek <pavel@suse.cz>
Date:   Mon Sep 22 14:37:34 2008 -0700

    ACPI: catch calls of acpi_driver_data on pointer of wrong type
    
    Catch attempts to use of acpi_driver_data on pointers of wrong type.
    
    akpm: rewritten to use proper C typechecking and remove the
    "function"-used-as-lvalue thing.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 4ab21cb1c8c7..1bef9429189b 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -657,7 +657,7 @@ static int acpi_power_add(struct acpi_device *device)
 	strcpy(resource->name, device->pnp.bus_id);
 	strcpy(acpi_device_name(device), ACPI_POWER_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_POWER_CLASS);
-	acpi_driver_data(device) = resource;
+	device->driver_data = resource;
 
 	/* Evalute the object to get the system level and resource order. */
 	status = acpi_evaluate_object(device->handle, NULL, NULL, &buffer);
@@ -733,7 +733,7 @@ static int acpi_power_resume(struct acpi_device *device)
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
 
-	resource = (struct acpi_power_resource *)acpi_driver_data(device);
+	resource = acpi_driver_data(device);
 
 	result = acpi_power_get_state(resource, &state);
 	if (result)

commit 0af4b8c4fb31193dc666f4893107a18fef82baab
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 7 03:34:11 2008 +0200

    ACPI: Introduce new device wakeup flag 'prepared'
    
    Introduce additional flag 'prepared' in struct acpi_device_wakeup_flags
    and use it to prevent devices from being enable/disabled do wake up the
    system multiple times in a row (this does not happen currently, but will
    be possible after some of the following patches).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 2e959aa1ef0e..4ab21cb1c8c7 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -363,11 +363,18 @@ int acpi_device_sleep_wake(struct acpi_device *dev,
  */
 int acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state)
 {
-	int i;
+	int i, err;
 
 	if (!dev || !dev->wakeup.flags.valid)
 		return -EINVAL;
 
+	/*
+	 * Do not execute the code below twice in a row without calling
+	 * acpi_disable_wakeup_device_power() in between for the same device
+	 */
+	if (dev->wakeup.flags.prepared)
+		return 0;
+
 	/* Open power resource */
 	for (i = 0; i < dev->wakeup.resources.count; i++) {
 		int ret = acpi_power_on(dev->wakeup.resources.handles[i], dev);
@@ -382,7 +389,11 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state)
 	 * Passing 3 as the third argument below means the device may be placed
 	 * in arbitrary power state afterwards.
 	 */
-	return acpi_device_sleep_wake(dev, 1, sleep_state, 3);
+	err = acpi_device_sleep_wake(dev, 1, sleep_state, 3);
+	if (!err)
+		dev->wakeup.flags.prepared = 1;
+
+	return err;
 }
 
 /*
@@ -398,6 +409,15 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 	if (!dev || !dev->wakeup.flags.valid)
 		return -EINVAL;
 
+	/*
+	 * Do not execute the code below twice in a row without calling
+	 * acpi_enable_wakeup_device_power() in between for the same device
+	 */
+	if (!dev->wakeup.flags.prepared)
+		return 0;
+
+	dev->wakeup.flags.prepared = 0;
+
 	ret = acpi_device_sleep_wake(dev, 0, 0, 0);
 	if (ret)
 		return ret;

commit 77e766099efc29d8b01db4b8244ff64fa3d3d0ca
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 7 03:33:34 2008 +0200

    ACPI: Introduce acpi_device_sleep_wake function
    
    The currect ACPI code attempts to execute _PSW at three different
    places and in one of them only it tries to execute _DSW before _PSW,
    which is inconsistent with the other two cases.
    
    Move the execution of _DSW and _PSW into a separate function called
    acpi_device_sleep_wake() and call it wherever appropriate instead of
    executing _DSW and/or _PSW directly.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 81e4f081a4ae..2e959aa1ef0e 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -292,69 +292,115 @@ static int acpi_power_off_device(acpi_handle handle, struct acpi_device *dev)
 	return 0;
 }
 
+/**
+ * acpi_device_sleep_wake - execute _DSW (Device Sleep Wake) or (deprecated in
+ *                          ACPI 3.0) _PSW (Power State Wake)
+ * @dev: Device to handle.
+ * @enable: 0 - disable, 1 - enable the wake capabilities of the device.
+ * @sleep_state: Target sleep state of the system.
+ * @dev_state: Target power state of the device.
+ *
+ * Execute _DSW (Device Sleep Wake) or (deprecated in ACPI 3.0) _PSW (Power
+ * State Wake) for the device, if present.  On failure reset the device's
+ * wakeup.flags.valid flag.
+ *
+ * RETURN VALUE:
+ * 0 if either _DSW or _PSW has been successfully executed
+ * 0 if neither _DSW nor _PSW has been found
+ * -ENODEV if the execution of either _DSW or _PSW has failed
+ */
+int acpi_device_sleep_wake(struct acpi_device *dev,
+                           int enable, int sleep_state, int dev_state)
+{
+	union acpi_object in_arg[3];
+	struct acpi_object_list arg_list = { 3, in_arg };
+	acpi_status status = AE_OK;
+
+	/*
+	 * Try to execute _DSW first.
+	 *
+	 * Three agruments are needed for the _DSW object:
+	 * Argument 0: enable/disable the wake capabilities
+	 * Argument 1: target system state
+	 * Argument 2: target device state
+	 * When _DSW object is called to disable the wake capabilities, maybe
+	 * the first argument is filled. The values of the other two agruments
+	 * are meaningless.
+	 */
+	in_arg[0].type = ACPI_TYPE_INTEGER;
+	in_arg[0].integer.value = enable;
+	in_arg[1].type = ACPI_TYPE_INTEGER;
+	in_arg[1].integer.value = sleep_state;
+	in_arg[2].type = ACPI_TYPE_INTEGER;
+	in_arg[2].integer.value = dev_state;
+	status = acpi_evaluate_object(dev->handle, "_DSW", &arg_list, NULL);
+	if (ACPI_SUCCESS(status)) {
+		return 0;
+	} else if (status != AE_NOT_FOUND) {
+		printk(KERN_ERR PREFIX "_DSW execution failed\n");
+		dev->wakeup.flags.valid = 0;
+		return -ENODEV;
+	}
+
+	/* Execute _PSW */
+	arg_list.count = 1;
+	in_arg[0].integer.value = enable;
+	status = acpi_evaluate_object(dev->handle, "_PSW", &arg_list, NULL);
+	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
+		printk(KERN_ERR PREFIX "_PSW execution failed\n");
+		dev->wakeup.flags.valid = 0;
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
 /*
  * Prepare a wakeup device, two steps (Ref ACPI 2.0:P229):
  * 1. Power on the power resources required for the wakeup device 
- * 2. Enable _PSW (power state wake) for the device if present
+ * 2. Execute _DSW (Device Sleep Wake) or (deprecated in ACPI 3.0) _PSW (Power
+ *    State Wake) for the device, if present
  */
-int acpi_enable_wakeup_device_power(struct acpi_device *dev)
+int acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state)
 {
-	union acpi_object arg = { ACPI_TYPE_INTEGER };
-	struct acpi_object_list arg_list = { 1, &arg };
-	acpi_status status = AE_OK;
 	int i;
-	int ret = 0;
 
 	if (!dev || !dev->wakeup.flags.valid)
-		return -1;
+		return -EINVAL;
 
-	arg.integer.value = 1;
 	/* Open power resource */
 	for (i = 0; i < dev->wakeup.resources.count; i++) {
-		ret = acpi_power_on(dev->wakeup.resources.handles[i], dev);
+		int ret = acpi_power_on(dev->wakeup.resources.handles[i], dev);
 		if (ret) {
 			printk(KERN_ERR PREFIX "Transition power state\n");
 			dev->wakeup.flags.valid = 0;
-			return -1;
+			return -ENODEV;
 		}
 	}
 
-	/* Execute PSW */
-	status = acpi_evaluate_object(dev->handle, "_PSW", &arg_list, NULL);
-	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
-		printk(KERN_ERR PREFIX "Evaluate _PSW\n");
-		dev->wakeup.flags.valid = 0;
-		ret = -1;
-	}
-
-	return ret;
+	/*
+	 * Passing 3 as the third argument below means the device may be placed
+	 * in arbitrary power state afterwards.
+	 */
+	return acpi_device_sleep_wake(dev, 1, sleep_state, 3);
 }
 
 /*
  * Shutdown a wakeup device, counterpart of above method
- * 1. Disable _PSW (power state wake)
+ * 1. Execute _DSW (Device Sleep Wake) or (deprecated in ACPI 3.0) _PSW (Power
+ *    State Wake) for the device, if present
  * 2. Shutdown down the power resources
  */
 int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 {
-	union acpi_object arg = { ACPI_TYPE_INTEGER };
-	struct acpi_object_list arg_list = { 1, &arg };
-	acpi_status status = AE_OK;
-	int i;
-	int ret = 0;
-
+	int i, ret;
 
 	if (!dev || !dev->wakeup.flags.valid)
-		return -1;
+		return -EINVAL;
 
-	arg.integer.value = 0;
-	/* Execute PSW */
-	status = acpi_evaluate_object(dev->handle, "_PSW", &arg_list, NULL);
-	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
-		printk(KERN_ERR PREFIX "Evaluate _PSW\n");
-		dev->wakeup.flags.valid = 0;
-		return -1;
-	}
+	ret = acpi_device_sleep_wake(dev, 0, 0, 0);
+	if (ret)
+		return ret;
 
 	/* Close power resource */
 	for (i = 0; i < dev->wakeup.resources.count; i++) {
@@ -362,7 +408,7 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 		if (ret) {
 			printk(KERN_ERR PREFIX "Transition power state\n");
 			dev->wakeup.flags.valid = 0;
-			return -1;
+			return -ENODEV;
 		}
 	}
 

commit 08acd4f8af42affd8cbed81cc1b69fa12ddb213f
Merge: ccf2779544ee 008238b54ac2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 30 11:52:52 2008 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6: (179 commits)
      ACPI: Fix acpi_processor_idle and idle= boot parameters interaction
      acpi: fix section mismatch warning in pnpacpi
      intel_menlo: fix build warning
      ACPI: Cleanup: Remove unneeded, multiple local dummy variables
      ACPI: video - fix permissions on some proc entries
      ACPI: video - properly handle errors when registering proc elements
      ACPI: video - do not store invalid entries in attached_array list
      ACPI: re-name acpi_pm_ops to acpi_suspend_ops
      ACER_WMI/ASUS_LAPTOP: fix build bug
      thinkpad_acpi: fix possible NULL pointer dereference if kstrdup failed
      ACPI: check a return value correctly in acpi_power_get_context()
      #if 0 acpi/bay.c:eject_removable_drive()
      eeepc-laptop: add hwmon fan control
      eeepc-laptop: add backlight
      eeepc-laptop: add base driver
      ACPI: thinkpad-acpi: bump up version to 0.20
      ACPI: thinkpad-acpi: fix selects in Kconfig
      ACPI: thinkpad-acpi: use a private workqueue
      ACPI: thinkpad-acpi: fluff really minor fix
      ACPI: thinkpad-acpi: use uppercase for "LED" on user documentation
      ...
    
    Fixed conflicts in drivers/acpi/video.c and drivers/misc/intel_menlow.c
    manually.

commit cf7acfab032ff262f42954328cdfd20a5d9aaaac
Author: Denis V. Lunev <den@openvz.org>
Date:   Tue Apr 29 01:02:27 2008 -0700

    acpi: use non-racy method for proc entries creation
    
    Use proc_create()/proc_create_data() to make sure that ->proc_fops and ->data
    be setup before gluing PDE to main tree.
    
    Add correct ->owner to proc_fops to fix reading/module unloading race.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 76bf6d90c700..21fc8bf0d31f 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -93,6 +93,7 @@ struct acpi_power_resource {
 static struct list_head acpi_power_resource_list;
 
 static const struct file_operations acpi_power_fops = {
+	.owner = THIS_MODULE,
 	.open = acpi_power_open_fs,
 	.read = seq_read,
 	.llseek = seq_lseek,
@@ -543,15 +544,11 @@ static int acpi_power_add_fs(struct acpi_device *device)
 	}
 
 	/* 'status' [R] */
-	entry = create_proc_entry(ACPI_POWER_FILE_STATUS,
-				  S_IRUGO, acpi_device_dir(device));
+	entry = proc_create_data(ACPI_POWER_FILE_STATUS,
+				 S_IRUGO, acpi_device_dir(device),
+				 &acpi_power_fops, acpi_driver_data(device));
 	if (!entry)
 		return -EIO;
-	else {
-		entry->proc_fops = &acpi_power_fops;
-		entry->data = acpi_driver_data(device);
-	}
-
 	return 0;
 }
 

commit a815ab8b5891f3d2515316655729272f68269e3b
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Fri Apr 18 13:27:29 2008 -0700

    ACPI: check a return value correctly in acpi_power_get_context()
    
    We should check *resource != NULL rather than resource != NULL, which will be
    always true.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Acked-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 76bf6d90c700..f2a76acecfcd 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -121,7 +121,7 @@ acpi_power_get_context(acpi_handle handle,
 	}
 
 	*resource = acpi_driver_data(device);
-	if (!resource)
+	if (!*resource)
 		return -ENODEV;
 
 	return 0;

commit e76d5f7e831a3f33dd6fa8eb94533b0b4cb22b6f
Author: Miguel Botn <mboton@gmail.com>
Date:   Mon Feb 4 23:31:19 2008 -0800

    ACPI: remove duplicated warning message
    
    Remove duplicated warning message in acpi_power_transition()
    
    ACPI: Transitioning device [%s] to D%d\n
    
    This warning message is printed by acpi_bus_set_power() so we don't
    need to print it again.
    
    Signed-off-by: Miguel Botn <mboton@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index af1769a20c7a..76bf6d90c700 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -458,11 +458,9 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	}
 
      end:
-	if (result) {
+	if (result)
 		device->power.state = ACPI_STATE_UNKNOWN;
-		printk(KERN_WARNING PREFIX "Transitioning device [%s] to D%d\n",
-			      device->pnp.bus_id, state);
-	} else {
+	else {
 	/* We shouldn't change the state till all above operations succeed */
 		device->power.state = state;
 	}

commit c35923bc558074d4f5e6f9706e4cb9811ae55775
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Mon Oct 22 14:19:09 2007 +0400

    ACPI: power: don't cache power resource state
    
    ACPI may change power resource state behind our back, so don't
    keep our local copy, which may not be valid.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 57b9a2998fd0..af1769a20c7a 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -86,7 +86,6 @@ struct acpi_power_resource {
 	acpi_bus_id name;
 	u32 system_level;
 	u32 order;
-	int state;
 	struct mutex resource_lock;
 	struct list_head reference;
 };
@@ -128,33 +127,31 @@ acpi_power_get_context(acpi_handle handle,
 	return 0;
 }
 
-static int acpi_power_get_state(struct acpi_power_resource *resource)
+static int acpi_power_get_state(struct acpi_power_resource *resource, int *state)
 {
 	acpi_status status = AE_OK;
 	unsigned long sta = 0;
 
 
-	if (!resource)
+	if (!resource || !state)
 		return -EINVAL;
 
 	status = acpi_evaluate_integer(resource->device->handle, "_STA", NULL, &sta);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
-	if (sta & 0x01)
-		resource->state = ACPI_POWER_RESOURCE_STATE_ON;
-	else
-		resource->state = ACPI_POWER_RESOURCE_STATE_OFF;
+	*state = (sta & 0x01)?ACPI_POWER_RESOURCE_STATE_ON:
+			      ACPI_POWER_RESOURCE_STATE_OFF;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] is %s\n",
-			  resource->name, resource->state ? "on" : "off"));
+			  resource->name, state ? "on" : "off"));
 
 	return 0;
 }
 
 static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 {
-	int result = 0;
+	int result = 0, state1;
 	struct acpi_power_resource *resource = NULL;
 	u32 i = 0;
 
@@ -168,11 +165,11 @@ static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 		result = acpi_power_get_context(list->handles[i], &resource);
 		if (result)
 			return result;
-		result = acpi_power_get_state(resource);
+		result = acpi_power_get_state(resource, &state1);
 		if (result)
 			return result;
 
-		*state = resource->state;
+		*state = state1;
 
 		if (*state != ACPI_POWER_RESOURCE_STATE_ON)
 			break;
@@ -186,7 +183,7 @@ static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 
 static int acpi_power_on(acpi_handle handle, struct acpi_device *dev)
 {
-	int result = 0;
+	int result = 0, state;
 	int found = 0;
 	acpi_status status = AE_OK;
 	struct acpi_power_resource *resource = NULL;
@@ -224,20 +221,14 @@ static int acpi_power_on(acpi_handle handle, struct acpi_device *dev)
 	}
 	mutex_unlock(&resource->resource_lock);
 
-	if (resource->state == ACPI_POWER_RESOURCE_STATE_ON) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already on\n",
-				  resource->name));
-		return 0;
-	}
-
 	status = acpi_evaluate_object(resource->device->handle, "_ON", NULL, NULL);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
-	result = acpi_power_get_state(resource);
+	result = acpi_power_get_state(resource, &state);
 	if (result)
 		return result;
-	if (resource->state != ACPI_POWER_RESOURCE_STATE_ON)
+	if (state != ACPI_POWER_RESOURCE_STATE_ON)
 		return -ENOEXEC;
 
 	/* Update the power resource's _device_ power state */
@@ -250,7 +241,7 @@ static int acpi_power_on(acpi_handle handle, struct acpi_device *dev)
 
 static int acpi_power_off_device(acpi_handle handle, struct acpi_device *dev)
 {
-	int result = 0;
+	int result = 0, state;
 	acpi_status status = AE_OK;
 	struct acpi_power_resource *resource = NULL;
 	struct list_head *node, *next;
@@ -281,20 +272,14 @@ static int acpi_power_off_device(acpi_handle handle, struct acpi_device *dev)
 	}
 	mutex_unlock(&resource->resource_lock);
 
-	if (resource->state == ACPI_POWER_RESOURCE_STATE_OFF) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already off\n",
-				  resource->name));
-		return 0;
-	}
-
 	status = acpi_evaluate_object(resource->device->handle, "_OFF", NULL, NULL);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
-	result = acpi_power_get_state(resource);
+	result = acpi_power_get_state(resource, &state);
 	if (result)
 		return result;
-	if (resource->state != ACPI_POWER_RESOURCE_STATE_OFF)
+	if (state != ACPI_POWER_RESOURCE_STATE_OFF)
 		return -ENOEXEC;
 
 	/* Update the power resource's _device_ power state */
@@ -494,7 +479,7 @@ static struct proc_dir_entry *acpi_power_dir;
 static int acpi_power_seq_show(struct seq_file *seq, void *offset)
 {
 	int count = 0;
-	int result = 0;
+	int result = 0, state;
 	struct acpi_power_resource *resource = NULL;
 	struct list_head *node, *next;
 	struct acpi_power_reference *ref;
@@ -505,12 +490,12 @@ static int acpi_power_seq_show(struct seq_file *seq, void *offset)
 	if (!resource)
 		goto end;
 
-	result = acpi_power_get_state(resource);
+	result = acpi_power_get_state(resource, &state);
 	if (result)
 		goto end;
 
 	seq_puts(seq, "state:                   ");
-	switch (resource->state) {
+	switch (state) {
 	case ACPI_POWER_RESOURCE_STATE_ON:
 		seq_puts(seq, "on\n");
 		break;
@@ -591,7 +576,7 @@ static int acpi_power_remove_fs(struct acpi_device *device)
 
 static int acpi_power_add(struct acpi_device *device)
 {
-	int result = 0;
+	int result = 0, state;
 	acpi_status status = AE_OK;
 	struct acpi_power_resource *resource = NULL;
 	union acpi_object acpi_object;
@@ -622,11 +607,11 @@ static int acpi_power_add(struct acpi_device *device)
 	resource->system_level = acpi_object.power_resource.system_level;
 	resource->order = acpi_object.power_resource.resource_order;
 
-	result = acpi_power_get_state(resource);
+	result = acpi_power_get_state(resource, &state);
 	if (result)
 		goto end;
 
-	switch (resource->state) {
+	switch (state) {
 	case ACPI_POWER_RESOURCE_STATE_ON:
 		device->power.state = ACPI_STATE_D0;
 		break;
@@ -643,7 +628,7 @@ static int acpi_power_add(struct acpi_device *device)
 		goto end;
 
 	printk(KERN_INFO PREFIX "%s [%s] (%s)\n", acpi_device_name(device),
-	       acpi_device_bid(device), resource->state ? "on" : "off");
+	       acpi_device_bid(device), state ? "on" : "off");
 
       end:
 	if (result)
@@ -680,7 +665,7 @@ static int acpi_power_remove(struct acpi_device *device, int type)
 
 static int acpi_power_resume(struct acpi_device *device)
 {
-	int result = 0;
+	int result = 0, state;
 	struct acpi_power_resource *resource = NULL;
 	struct acpi_power_reference *ref;
 
@@ -689,12 +674,12 @@ static int acpi_power_resume(struct acpi_device *device)
 
 	resource = (struct acpi_power_resource *)acpi_driver_data(device);
 
-	result = acpi_power_get_state(resource);
+	result = acpi_power_get_state(resource, &state);
 	if (result)
 		return result;
 
 	mutex_lock(&resource->resource_lock);
-	if ((resource->state == ACPI_POWER_RESOURCE_STATE_OFF) &&
+	if (state == ACPI_POWER_RESOURCE_STATE_OFF &&
 	    !list_empty(&resource->reference)) {
 		ref = container_of(resource->reference.next, struct acpi_power_reference, node);
 		mutex_unlock(&resource->resource_lock);

commit 1ba90e3a87c46500623afdc3898573e4a5ebb21b
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jul 23 14:44:41 2007 +0200

    ACPI: autoload modules - Create __mod_acpi_device_table symbol for all ACPI drivers
    
    modpost is going to use these to create e.g. acpi:ACPI0001
    in modules.alias.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 4ffecd179702..57b9a2998fd0 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -59,10 +59,16 @@ static int acpi_power_remove(struct acpi_device *device, int type);
 static int acpi_power_resume(struct acpi_device *device);
 static int acpi_power_open_fs(struct inode *inode, struct file *file);
 
+static struct acpi_device_id power_device_ids[] = {
+	{ACPI_POWER_HID, 0},
+	{"", 0},
+};
+MODULE_DEVICE_TABLE(acpi, power_device_ids);
+
 static struct acpi_driver acpi_power_driver = {
 	.name = "power",
 	.class = ACPI_POWER_CLASS,
-	.ids = ACPI_POWER_HID,
+	.ids = power_device_ids,
 	.ops = {
 		.add = acpi_power_add,
 		.remove = acpi_power_remove,

commit 63e34ca93a62f472144db60fa3b81111c0d15721
Merge: 51e7fff1c2b7 9327f46ee281
Author: Len Brown <len.brown@intel.com>
Date:   Fri Mar 9 23:19:50 2007 -0500

    Pull misc-for-upstream into release branch

commit ff24ba74b6d3befbfbafa142582211b5a6095d45
Author: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
Date:   Wed Mar 7 03:50:11 2007 -0500

    ACPI: ThinkPad Z60m: usb mouse stops working after suspend to RAM
    
    (http://www.mail-archive.com/linux-acpi@vger.kernel.org/msg05270.html):
    
    References : http://lkml.org/lkml/2007/2/21/413
                 http://lkml.org/lkml/2007/2/28/172
    Submitter  : Arkadiusz Miskiewicz <arekm@maven.pl>
    Caused-By  : Konstantin Karasyov <konstantin.a.karasyov@intel.com>
                 commit 0a6139027f3986162233adc17285151e78b39cac
    
    Do not disable power resources on resume even if there are no devices referencing it.
    
    Signed-off-by: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 1ef338545dfe..ccecfe0d695c 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -687,13 +687,6 @@ static int acpi_power_resume(struct acpi_device *device)
 		return result;
 
 	mutex_lock(&resource->resource_lock);
-	if ((resource->state == ACPI_POWER_RESOURCE_STATE_ON) &&
-	    list_empty(&resource->reference)) {
-		mutex_unlock(&resource->resource_lock);
-		result = acpi_power_off_device(device->handle, NULL);
-		return result;
-	}
-
 	if ((resource->state == ACPI_POWER_RESOURCE_STATE_OFF) &&
 	    !list_empty(&resource->reference)) {
 		ref = container_of(resource->reference.next, struct acpi_power_reference, node);

commit 7292576043666ff39946dee14641fe719ba8c7e8
Author: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
Date:   Wed Feb 21 02:05:58 2007 -0500

    ACPI: fix S3 fan resume issue
    
    http://bugzilla.kernel.org/show_bug.cgi?id=7570#c14
    
    Signed-off-by: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 1ef338545dfe..547eee7537bc 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -436,8 +436,6 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	cl = &device->power.states[device->power.state].resources;
 	tl = &device->power.states[state].resources;
 
-	device->power.state = ACPI_STATE_UNKNOWN;
-
 	if (!cl->count && !tl->count) {
 		result = -ENODEV;
 		goto end;
@@ -468,12 +466,15 @@ int acpi_power_transition(struct acpi_device *device, int state)
 			goto end;
 	}
 
-	/* We shouldn't change the state till all above operations succeed */
-	device->power.state = state;
-      end:
-	if (result)
+     end:
+	if (result) {
+		device->power.state = ACPI_STATE_UNKNOWN;
 		printk(KERN_WARNING PREFIX "Transitioning device [%s] to D%d\n",
 			      device->pnp.bus_id, state);
+	} else {
+	/* We shouldn't change the state till all above operations succeed */
+		device->power.state = state;
+	}
 
 	return result;
 }

commit 08e4a10ec82faf5ba67c8d0115b7bc9e58071555
Merge: 4559b438225b b1028c545ced
Author: Len Brown <len.brown@intel.com>
Date:   Fri Feb 16 22:11:50 2007 -0500

    Pull bugzilla-7570 into release branch

commit 1004879f25c5719517b3d8a3180a517e190e2f5b
Merge: f0e5ed7f323d e8363f332757
Author: Len Brown <len.brown@intel.com>
Date:   Fri Feb 16 22:11:31 2007 -0500

    Pull bugzilla-7122 into release branch

commit b1028c545ced13590dd9a9a8086543aef26c7187
Author: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
Date:   Fri Feb 16 02:23:07 2007 -0500

    ACPI: fix fan after resume from S3
    
    http://bugzilla.kernel.org/show_bug.cgi?id=7570
    
    Signed-off-by: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 0ba7dfbbb2ee..01ce311ed6ee 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -412,6 +412,10 @@ int acpi_power_transition(struct acpi_device *device, int state)
 			goto end;
 	}
 
+	if (device->power.state == state) {
+		goto end;
+	}
+
 	/*
 	 * Then we dereference all power resources used in the current list.
 	 */

commit e8363f332757ac22395fb120cc33b3262f9ee26c
Author: Len Brown <len.brown@intel.com>
Date:   Fri Feb 16 02:05:39 2007 -0500

    ACPI: update acpi_power_resume() per new acpi_op_resume
    
    drivers/acpi/power.c:69: warning: initialization from incompatible pointer type
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 784cbdb1084b..e768eb362932 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -57,7 +57,7 @@ ACPI_MODULE_NAME("acpi_power")
 #define ACPI_POWER_RESOURCE_STATE_UNKNOWN 0xFF
 static int acpi_power_add(struct acpi_device *device);
 static int acpi_power_remove(struct acpi_device *device, int type);
-static int acpi_power_resume(struct acpi_device *device, int state);
+static int acpi_power_resume(struct acpi_device *device);
 static int acpi_power_open_fs(struct inode *inode, struct file *file);
 
 static struct acpi_driver acpi_power_driver = {
@@ -668,7 +668,7 @@ static int acpi_power_remove(struct acpi_device *device, int type)
 	return 0;
 }
 
-static int acpi_power_resume(struct acpi_device *device, int state)
+static int acpi_power_resume(struct acpi_device *device)
 {
 	int result = 0;
 	struct acpi_power_resource *resource = NULL;

commit 0a6139027f3986162233adc17285151e78b39cac
Author: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
Date:   Fri Feb 16 01:47:06 2007 -0500

    ACPI: Thermal issues on HP nx6325
    
    The previous reference counting scheme to enable power resources
    got confused when multiple devices were present that might
    repeatedly enable or disable the resource and throw off the count.
    
    The new code simply lists the referencing devices which
    are requesting the resource to be enabled.  When there are none,
    then it is off.
    
    Signed-off-by: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 0ba7dfbbb2ee..784cbdb1084b 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -57,6 +57,7 @@ ACPI_MODULE_NAME("acpi_power")
 #define ACPI_POWER_RESOURCE_STATE_UNKNOWN 0xFF
 static int acpi_power_add(struct acpi_device *device);
 static int acpi_power_remove(struct acpi_device *device, int type);
+static int acpi_power_resume(struct acpi_device *device, int state);
 static int acpi_power_open_fs(struct inode *inode, struct file *file);
 
 static struct acpi_driver acpi_power_driver = {
@@ -66,16 +67,23 @@ static struct acpi_driver acpi_power_driver = {
 	.ops = {
 		.add = acpi_power_add,
 		.remove = acpi_power_remove,
+		.resume = acpi_power_resume,
 		},
 };
 
+struct acpi_power_reference {
+	struct list_head node;
+	struct acpi_device *device;
+};
+
 struct acpi_power_resource {
 	struct acpi_device * device;
 	acpi_bus_id name;
 	u32 system_level;
 	u32 order;
 	int state;
-	int references;
+	struct mutex resource_lock;
+	struct list_head reference;
 };
 
 static struct list_head acpi_power_resource_list;
@@ -171,22 +179,47 @@ static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 	return result;
 }
 
-static int acpi_power_on(acpi_handle handle)
+static int acpi_power_on(acpi_handle handle, struct acpi_device *dev)
 {
 	int result = 0;
+	int found = 0;
 	acpi_status status = AE_OK;
-	struct acpi_device *device = NULL;
 	struct acpi_power_resource *resource = NULL;
+	struct list_head *node, *next;
+	struct acpi_power_reference *ref;
 
 
 	result = acpi_power_get_context(handle, &resource);
 	if (result)
 		return result;
 
-	resource->references++;
+	mutex_lock(&resource->resource_lock);
+	list_for_each_safe(node, next, &resource->reference) {
+		ref = container_of(node, struct acpi_power_reference, node);
+		if (dev->handle == ref->device->handle) {
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] already referenced by resource [%s]\n",
+				  dev->pnp.bus_id, resource->name));
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		ref = kmalloc(sizeof (struct acpi_power_reference),
+		    irqs_disabled() ? GFP_ATOMIC : GFP_KERNEL);
+		if (!ref) {
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "kmalloc() failed\n"));
+			mutex_unlock(&resource->resource_lock);
+			return -ENOMEM;
+		}
+		list_add_tail(&ref->node, &resource->reference);
+		ref->device = dev;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] added to resource [%s] references\n",
+			  dev->pnp.bus_id, resource->name));
+	}
+	mutex_unlock(&resource->resource_lock);
 
-	if ((resource->references > 1)
-	    || (resource->state == ACPI_POWER_RESOURCE_STATE_ON)) {
+	if (resource->state == ACPI_POWER_RESOURCE_STATE_ON) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already on\n",
 				  resource->name));
 		return 0;
@@ -203,38 +236,49 @@ static int acpi_power_on(acpi_handle handle)
 		return -ENOEXEC;
 
 	/* Update the power resource's _device_ power state */
-	device = resource->device;
 	resource->device->power.state = ACPI_STATE_D0;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned on\n",
 			  resource->name));
-
 	return 0;
 }
 
-static int acpi_power_off_device(acpi_handle handle)
+static int acpi_power_off_device(acpi_handle handle, struct acpi_device *dev)
 {
 	int result = 0;
 	acpi_status status = AE_OK;
 	struct acpi_power_resource *resource = NULL;
+	struct list_head *node, *next;
+	struct acpi_power_reference *ref;
+
 
 	result = acpi_power_get_context(handle, &resource);
 	if (result)
 		return result;
 
-	if (resource->references)
-		resource->references--;
+	mutex_lock(&resource->resource_lock);
+	list_for_each_safe(node, next, &resource->reference) {
+		ref = container_of(node, struct acpi_power_reference, node);
+		if (dev->handle == ref->device->handle) {
+			list_del(&ref->node);
+			kfree(ref);
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] removed from resource [%s] references\n",
+			    dev->pnp.bus_id, resource->name));
+			break;
+		}
+	}
 
-	if (resource->references) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Resource [%s] is still in use, dereferencing\n",
-				  resource->device->pnp.bus_id));
+	if (!list_empty(&resource->reference)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cannot turn resource [%s] off - resource is in use\n",
+		    resource->name));
+		mutex_unlock(&resource->resource_lock);
 		return 0;
 	}
+	mutex_unlock(&resource->resource_lock);
 
 	if (resource->state == ACPI_POWER_RESOURCE_STATE_OFF) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already off\n",
-				  resource->device->pnp.bus_id));
+				  resource->name));
 		return 0;
 	}
 
@@ -276,7 +320,7 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev)
 	arg.integer.value = 1;
 	/* Open power resource */
 	for (i = 0; i < dev->wakeup.resources.count; i++) {
-		ret = acpi_power_on(dev->wakeup.resources.handles[i]);
+		ret = acpi_power_on(dev->wakeup.resources.handles[i], dev);
 		if (ret) {
 			printk(KERN_ERR PREFIX "Transition power state\n");
 			dev->wakeup.flags.valid = 0;
@@ -323,7 +367,7 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 
 	/* Close power resource */
 	for (i = 0; i < dev->wakeup.resources.count; i++) {
-		ret = acpi_power_off_device(dev->wakeup.resources.handles[i]);
+		ret = acpi_power_off_device(dev->wakeup.resources.handles[i], dev);
 		if (ret) {
 			printk(KERN_ERR PREFIX "Transition power state\n");
 			dev->wakeup.flags.valid = 0;
@@ -407,7 +451,7 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	 * (e.g. so the device doesn't lose power while transitioning).
 	 */
 	for (i = 0; i < tl->count; i++) {
-		result = acpi_power_on(tl->handles[i]);
+		result = acpi_power_on(tl->handles[i], device);
 		if (result)
 			goto end;
 	}
@@ -416,7 +460,7 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	 * Then we dereference all power resources used in the current list.
 	 */
 	for (i = 0; i < cl->count; i++) {
-		result = acpi_power_off_device(cl->handles[i]);
+		result = acpi_power_off_device(cl->handles[i], device);
 		if (result)
 			goto end;
 	}
@@ -439,7 +483,11 @@ static struct proc_dir_entry *acpi_power_dir;
 
 static int acpi_power_seq_show(struct seq_file *seq, void *offset)
 {
+	int count = 0;
+	int result = 0;
 	struct acpi_power_resource *resource = NULL;
+	struct list_head *node, *next;
+	struct acpi_power_reference *ref;
 
 
 	resource = seq->private;
@@ -447,6 +495,10 @@ static int acpi_power_seq_show(struct seq_file *seq, void *offset)
 	if (!resource)
 		goto end;
 
+	result = acpi_power_get_state(resource);
+	if (result)
+		goto end;
+
 	seq_puts(seq, "state:                   ");
 	switch (resource->state) {
 	case ACPI_POWER_RESOURCE_STATE_ON:
@@ -460,11 +512,18 @@ static int acpi_power_seq_show(struct seq_file *seq, void *offset)
 		break;
 	}
 
+	mutex_lock(&resource->resource_lock);
+	list_for_each_safe(node, next, &resource->reference) {
+		ref = container_of(node, struct acpi_power_reference, node);
+		count++;
+	}
+	mutex_unlock(&resource->resource_lock);
+
 	seq_printf(seq, "system level:            S%d\n"
 		   "order:                   %d\n"
 		   "reference count:         %d\n",
 		   resource->system_level,
-		   resource->order, resource->references);
+		   resource->order, count);
 
       end:
 	return 0;
@@ -537,6 +596,8 @@ static int acpi_power_add(struct acpi_device *device)
 		return -ENOMEM;
 
 	resource->device = device;
+	mutex_init(&resource->resource_lock);
+	INIT_LIST_HEAD(&resource->reference);
 	strcpy(resource->name, device->pnp.bus_id);
 	strcpy(acpi_device_name(device), ACPI_POWER_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_POWER_CLASS);
@@ -584,6 +645,7 @@ static int acpi_power_add(struct acpi_device *device)
 static int acpi_power_remove(struct acpi_device *device, int type)
 {
 	struct acpi_power_resource *resource = NULL;
+	struct list_head *node, *next;
 
 
 	if (!device || !acpi_driver_data(device))
@@ -593,11 +655,54 @@ static int acpi_power_remove(struct acpi_device *device, int type)
 
 	acpi_power_remove_fs(device);
 
+	mutex_lock(&resource->resource_lock);
+	list_for_each_safe(node, next, &resource->reference) {
+		struct acpi_power_reference *ref = container_of(node, struct acpi_power_reference, node);
+		list_del(&ref->node);
+		kfree(ref);
+	}
+	mutex_unlock(&resource->resource_lock);
+
 	kfree(resource);
 
 	return 0;
 }
 
+static int acpi_power_resume(struct acpi_device *device, int state)
+{
+	int result = 0;
+	struct acpi_power_resource *resource = NULL;
+	struct acpi_power_reference *ref;
+
+	if (!device || !acpi_driver_data(device))
+		return -EINVAL;
+
+	resource = (struct acpi_power_resource *)acpi_driver_data(device);
+
+	result = acpi_power_get_state(resource);
+	if (result)
+		return result;
+
+	mutex_lock(&resource->resource_lock);
+	if ((resource->state == ACPI_POWER_RESOURCE_STATE_ON) &&
+	    list_empty(&resource->reference)) {
+		mutex_unlock(&resource->resource_lock);
+		result = acpi_power_off_device(device->handle, NULL);
+		return result;
+	}
+
+	if ((resource->state == ACPI_POWER_RESOURCE_STATE_OFF) &&
+	    !list_empty(&resource->reference)) {
+		ref = container_of(resource->reference.next, struct acpi_power_reference, node);
+		mutex_unlock(&resource->resource_lock);
+		result = acpi_power_on(device->handle, ref->device);
+		return result;
+	}
+
+	mutex_unlock(&resource->resource_lock);
+	return 0;
+}
+
 static int __init acpi_power_init(void)
 {
 	int result = 0;

commit 7cda93e008e1a477970adbf82dba81a5d4f0ae40
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 23:50:02 2007 -0500

    ACPI: delete extra #defines in /drivers/acpi/ drivers
    
    Cosmetic only.
    
    Except in a single case, #define ACPI_*_DRIVER_NAME
    were invoked 0 or 1 times.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 09b855d3a928..92f80ba491c5 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -48,7 +48,6 @@
 ACPI_MODULE_NAME("power");
 #define ACPI_POWER_COMPONENT		0x00800000
 #define ACPI_POWER_CLASS		"power_resource"
-#define ACPI_POWER_DRIVER_NAME		"ACPI Power Resource Driver"
 #define ACPI_POWER_DEVICE_NAME		"Power Resource"
 #define ACPI_POWER_FILE_INFO		"info"
 #define ACPI_POWER_FILE_STATUS		"state"

commit c2b6705b75d9c7aff98a4602a32230639e10891c
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 23:33:40 2007 -0500

    ACPI: fix acpi_driver.name usage
    
    It was erroneously used as a description rather than a name.
    
    ie. turn this:
    
    lenb@se7525gp2:/sys> ls bus/acpi/drivers
    ACPI AC Adapter Driver  ACPI Embedded Controller Driver  ACPI Power Resource Driver
    ACPI Battery Driver     ACPI Fan Driver                  ACPI Processor Driver
    ACPI Button Driver      ACPI PCI Interrupt Link Driver   ACPI Thermal Zone Driver
    ACPI container driver   ACPI PCI Root Bridge Driver      hpet
    
    into this:
    
    lenb@se7525gp2:~> ls /sys/bus/acpi/drivers
    ac  battery  button  container  ec  fan  hpet  pci_link  pci_root  power  processor  thermal
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 26e8edcf18e6..09b855d3a928 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -60,7 +60,7 @@ static int acpi_power_remove(struct acpi_device *device, int type);
 static int acpi_power_open_fs(struct inode *inode, struct file *file);
 
 static struct acpi_driver acpi_power_driver = {
-	.name = ACPI_POWER_DRIVER_NAME,
+	.name = "power",
 	.class = ACPI_POWER_CLASS,
 	.ids = ACPI_POWER_HID,
 	.ops = {

commit f52fd66d2ea794010c2d7536cf8e6abed0ac4947
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 22:42:12 2007 -0500

    ACPI: clean up ACPI_MODULE_NAME() use
    
    cosmetic only
    
    Make "module name" actually match the file name.
    Invoke with ';' as leaving it off confuses Lindent and gcc doesn't care.
    Fix indentation where Lindent did get confused.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 0ba7dfbbb2ee..26e8edcf18e6 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -45,7 +45,7 @@
 #include <acpi/acpi_drivers.h>
 
 #define _COMPONENT		ACPI_POWER_COMPONENT
-ACPI_MODULE_NAME("acpi_power")
+ACPI_MODULE_NAME("power");
 #define ACPI_POWER_COMPONENT		0x00800000
 #define ACPI_POWER_CLASS		"power_resource"
 #define ACPI_POWER_DRIVER_NAME		"ACPI Power Resource Driver"

commit 36bcbec7ce21e2e8b3143b11a05747330abeca70
Author: Burman Yan <yan_952@hotmail.com>
Date:   Tue Dec 19 12:56:11 2006 -0800

    ACPI: replace kmalloc+memset with kzalloc
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 23a8a9295578..0ba7dfbbb2ee 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -532,10 +532,9 @@ static int acpi_power_add(struct acpi_device *device)
 	if (!device)
 		return -EINVAL;
 
-	resource = kmalloc(sizeof(struct acpi_power_resource), GFP_KERNEL);
+	resource = kzalloc(sizeof(struct acpi_power_resource), GFP_KERNEL);
 	if (!resource)
 		return -ENOMEM;
-	memset(resource, 0, sizeof(struct acpi_power_resource));
 
 	resource->device = device;
 	strcpy(resource->name, device->pnp.bus_id);

commit cece901481bafbf14de8cbd3a89ae869ea881055
Merge: cfee47f99bc1 50dd096973f1
Author: Len Brown <len.brown@intel.com>
Date:   Sat Dec 16 01:04:27 2006 -0500

    Pull style into test branch
    
    Conflicts:
    
            drivers/acpi/button.c
            drivers/acpi/ec.c
            drivers/acpi/osl.c
            drivers/acpi/sbs.c

commit 786f18c666d7202a86a8aa42a98783b115fe8739
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Wed Aug 23 23:18:06 2006 -0400

    ACPI: fix potential OOPS in power driver with CONFIG_ACPI_DEBUG
    
    device was set to null and used before set in a debug printk
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index fec225d1b6b7..fe67a8af520e 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -216,10 +216,8 @@ static int acpi_power_off_device(acpi_handle handle)
 {
 	int result = 0;
 	acpi_status status = AE_OK;
-	struct acpi_device *device = NULL;
 	struct acpi_power_resource *resource = NULL;
 
-
 	result = acpi_power_get_context(handle, &resource);
 	if (result)
 		return result;
@@ -230,13 +228,13 @@ static int acpi_power_off_device(acpi_handle handle)
 	if (resource->references) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Resource [%s] is still in use, dereferencing\n",
-				  device->pnp.bus_id));
+				  resource->device->pnp.bus_id));
 		return 0;
 	}
 
 	if (resource->state == ACPI_POWER_RESOURCE_STATE_OFF) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already off\n",
-				  device->pnp.bus_id));
+				  resource->device->pnp.bus_id));
 		return 0;
 	}
 
@@ -251,8 +249,7 @@ static int acpi_power_off_device(acpi_handle handle)
 		return -ENOEXEC;
 
 	/* Update the power resource's _device_ power state */
-	device = resource->device;
-	device->power.state = ACPI_STATE_D3;
+	resource->device->power.state = ACPI_STATE_D3;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned off\n",
 			  resource->name));

commit 50dd096973f1d95aa03c6a6d9e148d706b62b68e
Author: Jan Engelhardt <jengelh@linux01.gwdg.de>
Date:   Sun Oct 1 00:28:50 2006 +0200

    ACPI: Remove unnecessary from/to-void* and to-void casts in drivers/acpi
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index fec225d1b6b7..e9dab54bd541 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -108,7 +108,7 @@ acpi_power_get_context(acpi_handle handle,
 		return result;
 	}
 
-	*resource = (struct acpi_power_resource *)acpi_driver_data(device);
+	*resource = acpi_driver_data(device);
 	if (!resource)
 		return -ENODEV;
 
@@ -445,7 +445,7 @@ static int acpi_power_seq_show(struct seq_file *seq, void *offset)
 	struct acpi_power_resource *resource = NULL;
 
 
-	resource = (struct acpi_power_resource *)seq->private;
+	resource = seq->private;
 
 	if (!resource)
 		goto end;
@@ -593,7 +593,7 @@ static int acpi_power_remove(struct acpi_device *device, int type)
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
 
-	resource = (struct acpi_power_resource *)acpi_driver_data(device);
+	resource = acpi_driver_data(device);
 
 	acpi_power_remove_fs(device);
 

commit d75080328affb4b268da430b7074cc8139cc662a
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Tue Jul 4 13:06:00 2006 -0400

    ACPI: add 'const' to several ACPI file_operations
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 5d3447f4582c..fec225d1b6b7 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -80,7 +80,7 @@ struct acpi_power_resource {
 
 static struct list_head acpi_power_resource_list;
 
-static struct file_operations acpi_power_fops = {
+static const struct file_operations acpi_power_fops = {
 	.open = acpi_power_open_fs,
 	.read = seq_read,
 	.llseek = seq_lseek,

commit 14747204055d4b8fb2f8517beca91985ac617c17
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Fri May 19 16:54:51 2006 -0400

    ACPI: power: Remove unneeded acpi_handle from driver.
    
    Signed-off-by: Patrick Mochel <mochel@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 214428948cc1..5d3447f4582c 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -70,7 +70,6 @@ static struct acpi_driver acpi_power_driver = {
 };
 
 struct acpi_power_resource {
-	acpi_handle handle;
 	struct acpi_device * device;
 	acpi_bus_id name;
 	u32 system_level;
@@ -541,7 +540,6 @@ static int acpi_power_add(struct acpi_device *device)
 		return -ENOMEM;
 	memset(resource, 0, sizeof(struct acpi_power_resource));
 
-	resource->handle = device->handle;
 	resource->device = device;
 	strcpy(resource->name, device->pnp.bus_id);
 	strcpy(acpi_device_name(device), ACPI_POWER_DEVICE_NAME);

commit 5fbc19efdbedf9c9125774f66f80d6a6ccce4566
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Fri May 19 16:54:43 2006 -0400

    ACPI: power: Use acpi_device's handle instead of driver's
    
    Signed-off-by: Patrick Mochel <mochel@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 2b61719d680b..214428948cc1 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -125,7 +125,7 @@ static int acpi_power_get_state(struct acpi_power_resource *resource)
 	if (!resource)
 		return -EINVAL;
 
-	status = acpi_evaluate_integer(resource->handle, "_STA", NULL, &sta);
+	status = acpi_evaluate_integer(resource->device->handle, "_STA", NULL, &sta);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
@@ -193,7 +193,7 @@ static int acpi_power_on(acpi_handle handle)
 		return 0;
 	}
 
-	status = acpi_evaluate_object(resource->handle, "_ON", NULL, NULL);
+	status = acpi_evaluate_object(resource->device->handle, "_ON", NULL, NULL);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
@@ -241,7 +241,7 @@ static int acpi_power_off_device(acpi_handle handle)
 		return 0;
 	}
 
-	status = acpi_evaluate_object(resource->handle, "_OFF", NULL, NULL);
+	status = acpi_evaluate_object(resource->device->handle, "_OFF", NULL, NULL);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
@@ -549,7 +549,7 @@ static int acpi_power_add(struct acpi_device *device)
 	acpi_driver_data(device) = resource;
 
 	/* Evalute the object to get the system level and resource order. */
-	status = acpi_evaluate_object(resource->handle, NULL, NULL, &buffer);
+	status = acpi_evaluate_object(device->handle, NULL, NULL, &buffer);
 	if (ACPI_FAILURE(status)) {
 		result = -ENODEV;
 		goto end;

commit 415985728895ba3127116bc4f999caf94420ed85
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Fri May 19 16:54:40 2006 -0400

    ACPI: power: add struct acpi_device to struct acpi_power_resource
    
    - Use it instead of acpi_bus_get_device() where we can..
    
    Signed-off-by: Patrick Mochel <mochel@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 224f729f700e..2b61719d680b 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -71,6 +71,7 @@ static struct acpi_driver acpi_power_driver = {
 
 struct acpi_power_resource {
 	acpi_handle handle;
+	struct acpi_device * device;
 	acpi_bus_id name;
 	u32 system_level;
 	u32 order;
@@ -203,10 +204,8 @@ static int acpi_power_on(acpi_handle handle)
 		return -ENOEXEC;
 
 	/* Update the power resource's _device_ power state */
-	result = acpi_bus_get_device(resource->handle, &device);
-	if (result)
-		return result;
-	device->power.state = ACPI_STATE_D0;
+	device = resource->device;
+	resource->device->power.state = ACPI_STATE_D0;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned on\n",
 			  resource->name));
@@ -253,9 +252,7 @@ static int acpi_power_off_device(acpi_handle handle)
 		return -ENOEXEC;
 
 	/* Update the power resource's _device_ power state */
-	result = acpi_bus_get_device(resource->handle, &device);
-	if (result)
-		return result;
+	device = resource->device;
 	device->power.state = ACPI_STATE_D3;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned off\n",
@@ -545,6 +542,7 @@ static int acpi_power_add(struct acpi_device *device)
 	memset(resource, 0, sizeof(struct acpi_power_resource));
 
 	resource->handle = device->handle;
+	resource->device = device;
 	strcpy(resource->name, device->pnp.bus_id);
 	strcpy(acpi_device_name(device), ACPI_POWER_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_POWER_CLASS);

commit d550d98d3317378d93a4869db204725d270ec812
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Tue Jun 27 00:41:40 2006 -0400

    ACPI: delete tracing macros from drivers/acpi/*.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index efc4bb751286..224f729f700e 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -98,22 +98,21 @@ acpi_power_get_context(acpi_handle handle,
 	int result = 0;
 	struct acpi_device *device = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_power_get_context");
 
 	if (!resource)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	result = acpi_bus_get_device(handle, &device);
 	if (result) {
 		printk(KERN_WARNING PREFIX "Getting context [%p]\n", handle);
-		return_VALUE(result);
+		return result;
 	}
 
 	*resource = (struct acpi_power_resource *)acpi_driver_data(device);
 	if (!resource)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_power_get_state(struct acpi_power_resource *resource)
@@ -121,14 +120,13 @@ static int acpi_power_get_state(struct acpi_power_resource *resource)
 	acpi_status status = AE_OK;
 	unsigned long sta = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_power_get_state");
 
 	if (!resource)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	status = acpi_evaluate_integer(resource->handle, "_STA", NULL, &sta);
 	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	if (sta & 0x01)
 		resource->state = ACPI_POWER_RESOURCE_STATE_ON;
@@ -138,7 +136,7 @@ static int acpi_power_get_state(struct acpi_power_resource *resource)
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] is %s\n",
 			  resource->name, resource->state ? "on" : "off"));
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
@@ -147,20 +145,19 @@ static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 	struct acpi_power_resource *resource = NULL;
 	u32 i = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_power_get_list_state");
 
 	if (!list || !state)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	/* The state of the list is 'on' IFF all resources are 'on'. */
 
 	for (i = 0; i < list->count; i++) {
 		result = acpi_power_get_context(list->handles[i], &resource);
 		if (result)
-			return_VALUE(result);
+			return result;
 		result = acpi_power_get_state(resource);
 		if (result)
-			return_VALUE(result);
+			return result;
 
 		*state = resource->state;
 
@@ -171,7 +168,7 @@ static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource list is %s\n",
 			  *state ? "on" : "off"));
 
-	return_VALUE(result);
+	return result;
 }
 
 static int acpi_power_on(acpi_handle handle)
@@ -181,11 +178,10 @@ static int acpi_power_on(acpi_handle handle)
 	struct acpi_device *device = NULL;
 	struct acpi_power_resource *resource = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_power_on");
 
 	result = acpi_power_get_context(handle, &resource);
 	if (result)
-		return_VALUE(result);
+		return result;
 
 	resource->references++;
 
@@ -193,29 +189,29 @@ static int acpi_power_on(acpi_handle handle)
 	    || (resource->state == ACPI_POWER_RESOURCE_STATE_ON)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already on\n",
 				  resource->name));
-		return_VALUE(0);
+		return 0;
 	}
 
 	status = acpi_evaluate_object(resource->handle, "_ON", NULL, NULL);
 	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	result = acpi_power_get_state(resource);
 	if (result)
-		return_VALUE(result);
+		return result;
 	if (resource->state != ACPI_POWER_RESOURCE_STATE_ON)
-		return_VALUE(-ENOEXEC);
+		return -ENOEXEC;
 
 	/* Update the power resource's _device_ power state */
 	result = acpi_bus_get_device(resource->handle, &device);
 	if (result)
-		return_VALUE(result);
+		return result;
 	device->power.state = ACPI_STATE_D0;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned on\n",
 			  resource->name));
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_power_off_device(acpi_handle handle)
@@ -225,11 +221,10 @@ static int acpi_power_off_device(acpi_handle handle)
 	struct acpi_device *device = NULL;
 	struct acpi_power_resource *resource = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_power_off_device");
 
 	result = acpi_power_get_context(handle, &resource);
 	if (result)
-		return_VALUE(result);
+		return result;
 
 	if (resource->references)
 		resource->references--;
@@ -238,35 +233,35 @@ static int acpi_power_off_device(acpi_handle handle)
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Resource [%s] is still in use, dereferencing\n",
 				  device->pnp.bus_id));
-		return_VALUE(0);
+		return 0;
 	}
 
 	if (resource->state == ACPI_POWER_RESOURCE_STATE_OFF) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already off\n",
 				  device->pnp.bus_id));
-		return_VALUE(0);
+		return 0;
 	}
 
 	status = acpi_evaluate_object(resource->handle, "_OFF", NULL, NULL);
 	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	result = acpi_power_get_state(resource);
 	if (result)
-		return_VALUE(result);
+		return result;
 	if (resource->state != ACPI_POWER_RESOURCE_STATE_OFF)
-		return_VALUE(-ENOEXEC);
+		return -ENOEXEC;
 
 	/* Update the power resource's _device_ power state */
 	result = acpi_bus_get_device(resource->handle, &device);
 	if (result)
-		return_VALUE(result);
+		return result;
 	device->power.state = ACPI_STATE_D3;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned off\n",
 			  resource->name));
 
-	return_VALUE(0);
+	return 0;
 }
 
 /*
@@ -282,9 +277,8 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev)
 	int i;
 	int ret = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_enable_wakeup_device_power");
 	if (!dev || !dev->wakeup.flags.valid)
-		return_VALUE(-1);
+		return -1;
 
 	arg.integer.value = 1;
 	/* Open power resource */
@@ -293,7 +287,7 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev)
 		if (ret) {
 			printk(KERN_ERR PREFIX "Transition power state\n");
 			dev->wakeup.flags.valid = 0;
-			return_VALUE(-1);
+			return -1;
 		}
 	}
 
@@ -305,7 +299,7 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev)
 		ret = -1;
 	}
 
-	return_VALUE(ret);
+	return ret;
 }
 
 /*
@@ -321,10 +315,9 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 	int i;
 	int ret = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_disable_wakeup_device_power");
 
 	if (!dev || !dev->wakeup.flags.valid)
-		return_VALUE(-1);
+		return -1;
 
 	arg.integer.value = 0;
 	/* Execute PSW */
@@ -332,7 +325,7 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
 		printk(KERN_ERR PREFIX "Evaluate _PSW\n");
 		dev->wakeup.flags.valid = 0;
-		return_VALUE(-1);
+		return -1;
 	}
 
 	/* Close power resource */
@@ -341,11 +334,11 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 		if (ret) {
 			printk(KERN_ERR PREFIX "Transition power state\n");
 			dev->wakeup.flags.valid = 0;
-			return_VALUE(-1);
+			return -1;
 		}
 	}
 
-	return_VALUE(ret);
+	return ret;
 }
 
 /* --------------------------------------------------------------------------
@@ -359,10 +352,9 @@ int acpi_power_get_inferred_state(struct acpi_device *device)
 	int list_state = 0;
 	int i = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_power_get_inferred_state");
 
 	if (!device)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	device->power.state = ACPI_STATE_UNKNOWN;
 
@@ -377,17 +369,17 @@ int acpi_power_get_inferred_state(struct acpi_device *device)
 
 		result = acpi_power_get_list_state(list, &list_state);
 		if (result)
-			return_VALUE(result);
+			return result;
 
 		if (list_state == ACPI_POWER_RESOURCE_STATE_ON) {
 			device->power.state = i;
-			return_VALUE(0);
+			return 0;
 		}
 	}
 
 	device->power.state = ACPI_STATE_D3;
 
-	return_VALUE(0);
+	return 0;
 }
 
 int acpi_power_transition(struct acpi_device *device, int state)
@@ -397,14 +389,13 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	struct acpi_handle_list *tl = NULL;	/* Target Resources */
 	int i = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_power_transition");
 
 	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	if ((device->power.state < ACPI_STATE_D0)
 	    || (device->power.state > ACPI_STATE_D3))
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	cl = &device->power.states[device->power.state].resources;
 	tl = &device->power.states[state].resources;
@@ -444,7 +435,7 @@ int acpi_power_transition(struct acpi_device *device, int state)
 		printk(KERN_WARNING PREFIX "Transitioning device [%s] to D%d\n",
 			      device->pnp.bus_id, state);
 
-	return_VALUE(result);
+	return result;
 }
 
 /* --------------------------------------------------------------------------
@@ -457,7 +448,6 @@ static int acpi_power_seq_show(struct seq_file *seq, void *offset)
 {
 	struct acpi_power_resource *resource = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_power_seq_show");
 
 	resource = (struct acpi_power_resource *)seq->private;
 
@@ -484,7 +474,7 @@ static int acpi_power_seq_show(struct seq_file *seq, void *offset)
 		   resource->order, resource->references);
 
       end:
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_power_open_fs(struct inode *inode, struct file *file)
@@ -496,34 +486,32 @@ static int acpi_power_add_fs(struct acpi_device *device)
 {
 	struct proc_dir_entry *entry = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_power_add_fs");
 
 	if (!device)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	if (!acpi_device_dir(device)) {
 		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
 						     acpi_power_dir);
 		if (!acpi_device_dir(device))
-			return_VALUE(-ENODEV);
+			return -ENODEV;
 	}
 
 	/* 'status' [R] */
 	entry = create_proc_entry(ACPI_POWER_FILE_STATUS,
 				  S_IRUGO, acpi_device_dir(device));
 	if (!entry)
-		return_VALUE(-EIO);
+		return -EIO;
 	else {
 		entry->proc_fops = &acpi_power_fops;
 		entry->data = acpi_driver_data(device);
 	}
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_power_remove_fs(struct acpi_device *device)
 {
-	ACPI_FUNCTION_TRACE("acpi_power_remove_fs");
 
 	if (acpi_device_dir(device)) {
 		remove_proc_entry(ACPI_POWER_FILE_STATUS,
@@ -532,7 +520,7 @@ static int acpi_power_remove_fs(struct acpi_device *device)
 		acpi_device_dir(device) = NULL;
 	}
 
-	return_VALUE(0);
+	return 0;
 }
 
 /* --------------------------------------------------------------------------
@@ -547,14 +535,13 @@ static int acpi_power_add(struct acpi_device *device)
 	union acpi_object acpi_object;
 	struct acpi_buffer buffer = { sizeof(acpi_object), &acpi_object };
 
-	ACPI_FUNCTION_TRACE("acpi_power_add");
 
 	if (!device)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	resource = kmalloc(sizeof(struct acpi_power_resource), GFP_KERNEL);
 	if (!resource)
-		return_VALUE(-ENOMEM);
+		return -ENOMEM;
 	memset(resource, 0, sizeof(struct acpi_power_resource));
 
 	resource->handle = device->handle;
@@ -599,17 +586,16 @@ static int acpi_power_add(struct acpi_device *device)
 	if (result)
 		kfree(resource);
 
-	return_VALUE(result);
+	return result;
 }
 
 static int acpi_power_remove(struct acpi_device *device, int type)
 {
 	struct acpi_power_resource *resource = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_power_remove");
 
 	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	resource = (struct acpi_power_resource *)acpi_driver_data(device);
 
@@ -617,31 +603,30 @@ static int acpi_power_remove(struct acpi_device *device, int type)
 
 	kfree(resource);
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int __init acpi_power_init(void)
 {
 	int result = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_power_init");
 
 	if (acpi_disabled)
-		return_VALUE(0);
+		return 0;
 
 	INIT_LIST_HEAD(&acpi_power_resource_list);
 
 	acpi_power_dir = proc_mkdir(ACPI_POWER_CLASS, acpi_root_dir);
 	if (!acpi_power_dir)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	result = acpi_bus_register_driver(&acpi_power_driver);
 	if (result < 0) {
 		remove_proc_entry(ACPI_POWER_CLASS, acpi_root_dir);
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
-	return_VALUE(0);
+	return 0;
 }
 
 subsys_initcall(acpi_power_init);

commit 6468463abd7051fcc29f3ee7c931f9bbbb26f5a4
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jun 26 23:41:38 2006 -0400

    ACPI: un-export ACPI_ERROR() -- use printk(KERN_ERR...)
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 43688c8280e5..efc4bb751286 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -291,7 +291,7 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev)
 	for (i = 0; i < dev->wakeup.resources.count; i++) {
 		ret = acpi_power_on(dev->wakeup.resources.handles[i]);
 		if (ret) {
-			ACPI_ERROR((AE_INFO, "Transition power state"));
+			printk(KERN_ERR PREFIX "Transition power state\n");
 			dev->wakeup.flags.valid = 0;
 			return_VALUE(-1);
 		}
@@ -300,7 +300,7 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev)
 	/* Execute PSW */
 	status = acpi_evaluate_object(dev->handle, "_PSW", &arg_list, NULL);
 	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
-		ACPI_ERROR((AE_INFO, "Evaluate _PSW"));
+		printk(KERN_ERR PREFIX "Evaluate _PSW\n");
 		dev->wakeup.flags.valid = 0;
 		ret = -1;
 	}
@@ -330,7 +330,7 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 	/* Execute PSW */
 	status = acpi_evaluate_object(dev->handle, "_PSW", &arg_list, NULL);
 	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
-		ACPI_ERROR((AE_INFO, "Evaluate _PSW"));
+		printk(KERN_ERR PREFIX "Evaluate _PSW\n");
 		dev->wakeup.flags.valid = 0;
 		return_VALUE(-1);
 	}
@@ -339,7 +339,7 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 	for (i = 0; i < dev->wakeup.resources.count; i++) {
 		ret = acpi_power_off_device(dev->wakeup.resources.handles[i]);
 		if (ret) {
-			ACPI_ERROR((AE_INFO, "Transition power state"));
+			printk(KERN_ERR PREFIX "Transition power state\n");
 			dev->wakeup.flags.valid = 0;
 			return_VALUE(-1);
 		}

commit cece92969762b8ed7930d4e23008b76b06411dee
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jun 26 23:04:31 2006 -0400

    ACPI: un-export ACPI_WARNING() -- use printk(KERN_WARNING...)
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 5712803ddc78..43688c8280e5 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -105,7 +105,7 @@ acpi_power_get_context(acpi_handle handle,
 
 	result = acpi_bus_get_device(handle, &device);
 	if (result) {
-		ACPI_WARNING((AE_INFO, "Getting context [%p]", handle));
+		printk(KERN_WARNING PREFIX "Getting context [%p]\n", handle);
 		return_VALUE(result);
 	}
 
@@ -441,8 +441,8 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	device->power.state = state;
       end:
 	if (result)
-		ACPI_WARNING((AE_INFO, "Transitioning device [%s] to D%d",
-			      device->pnp.bus_id, state));
+		printk(KERN_WARNING PREFIX "Transitioning device [%s] to D%d\n",
+			      device->pnp.bus_id, state);
 
 	return_VALUE(result);
 }

commit a6fc67202e0224e6c9d1d285cc0b444bce887ed5
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jun 26 23:58:43 2006 -0400

    ACPI: Enable ACPI error messages w/o CONFIG_ACPI_DEBUG
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 62a5595ed8bc..5712803ddc78 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -105,8 +105,7 @@ acpi_power_get_context(acpi_handle handle,
 
 	result = acpi_bus_get_device(handle, &device);
 	if (result) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Error getting context [%p]\n",
-				  handle));
+		ACPI_WARNING((AE_INFO, "Getting context [%p]", handle));
 		return_VALUE(result);
 	}
 
@@ -292,8 +291,7 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev)
 	for (i = 0; i < dev->wakeup.resources.count; i++) {
 		ret = acpi_power_on(dev->wakeup.resources.handles[i]);
 		if (ret) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-					  "Error transition power state\n"));
+			ACPI_ERROR((AE_INFO, "Transition power state"));
 			dev->wakeup.flags.valid = 0;
 			return_VALUE(-1);
 		}
@@ -302,7 +300,7 @@ int acpi_enable_wakeup_device_power(struct acpi_device *dev)
 	/* Execute PSW */
 	status = acpi_evaluate_object(dev->handle, "_PSW", &arg_list, NULL);
 	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluate _PSW\n"));
+		ACPI_ERROR((AE_INFO, "Evaluate _PSW"));
 		dev->wakeup.flags.valid = 0;
 		ret = -1;
 	}
@@ -332,7 +330,7 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 	/* Execute PSW */
 	status = acpi_evaluate_object(dev->handle, "_PSW", &arg_list, NULL);
 	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluate _PSW\n"));
+		ACPI_ERROR((AE_INFO, "Evaluate _PSW"));
 		dev->wakeup.flags.valid = 0;
 		return_VALUE(-1);
 	}
@@ -341,8 +339,7 @@ int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 	for (i = 0; i < dev->wakeup.resources.count; i++) {
 		ret = acpi_power_off_device(dev->wakeup.resources.handles[i]);
 		if (ret) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-					  "Error transition power state\n"));
+			ACPI_ERROR((AE_INFO, "Transition power state"));
 			dev->wakeup.flags.valid = 0;
 			return_VALUE(-1);
 		}
@@ -444,9 +441,8 @@ int acpi_power_transition(struct acpi_device *device, int state)
 	device->power.state = state;
       end:
 	if (result)
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-				  "Error transitioning device [%s] to D%d\n",
-				  device->pnp.bus_id, state));
+		ACPI_WARNING((AE_INFO, "Transitioning device [%s] to D%d",
+			      device->pnp.bus_id, state));
 
 	return_VALUE(result);
 }
@@ -516,9 +512,7 @@ static int acpi_power_add_fs(struct acpi_device *device)
 	entry = create_proc_entry(ACPI_POWER_FILE_STATUS,
 				  S_IRUGO, acpi_device_dir(device));
 	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Unable to create '%s' fs entry\n",
-				  ACPI_POWER_FILE_STATUS));
+		return_VALUE(-EIO);
 	else {
 		entry->proc_fops = &acpi_power_fops;
 		entry->data = acpi_driver_data(device);

commit 4be44fcd3bf648b782f4460fd06dfae6c42ded4b
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 5 00:44:28 2005 -0400

    [ACPI] Lindent all ACPI files
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index 373a3a95bb4e..62a5595ed8bc 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -44,10 +44,8 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
-
 #define _COMPONENT		ACPI_POWER_COMPONENT
-ACPI_MODULE_NAME		("acpi_power")
-
+ACPI_MODULE_NAME("acpi_power")
 #define ACPI_POWER_COMPONENT		0x00800000
 #define ACPI_POWER_CLASS		"power_resource"
 #define ACPI_POWER_DRIVER_NAME		"ACPI Power Resource Driver"
@@ -57,38 +55,36 @@ ACPI_MODULE_NAME		("acpi_power")
 #define ACPI_POWER_RESOURCE_STATE_OFF	0x00
 #define ACPI_POWER_RESOURCE_STATE_ON	0x01
 #define ACPI_POWER_RESOURCE_STATE_UNKNOWN 0xFF
-
-static int acpi_power_add (struct acpi_device *device);
-static int acpi_power_remove (struct acpi_device *device, int type);
+static int acpi_power_add(struct acpi_device *device);
+static int acpi_power_remove(struct acpi_device *device, int type);
 static int acpi_power_open_fs(struct inode *inode, struct file *file);
 
 static struct acpi_driver acpi_power_driver = {
-	.name =		ACPI_POWER_DRIVER_NAME,
-	.class =	ACPI_POWER_CLASS,
-	.ids =		ACPI_POWER_HID,
-	.ops =		{
-				.add =		acpi_power_add,
-				.remove =	acpi_power_remove,
-			},
+	.name = ACPI_POWER_DRIVER_NAME,
+	.class = ACPI_POWER_CLASS,
+	.ids = ACPI_POWER_HID,
+	.ops = {
+		.add = acpi_power_add,
+		.remove = acpi_power_remove,
+		},
 };
 
-struct acpi_power_resource
-{
-	acpi_handle		handle;
-	acpi_bus_id		name;
-	u32			system_level;
-	u32			order;
-	int			state;
-	int			references;
+struct acpi_power_resource {
+	acpi_handle handle;
+	acpi_bus_id name;
+	u32 system_level;
+	u32 order;
+	int state;
+	int references;
 };
 
-static struct list_head		acpi_power_resource_list;
+static struct list_head acpi_power_resource_list;
 
 static struct file_operations acpi_power_fops = {
-	.open		= acpi_power_open_fs,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
+	.open = acpi_power_open_fs,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
 };
 
 /* --------------------------------------------------------------------------
@@ -96,12 +92,11 @@ static struct file_operations acpi_power_fops = {
    -------------------------------------------------------------------------- */
 
 static int
-acpi_power_get_context (
-	acpi_handle		handle,
-	struct acpi_power_resource **resource)
+acpi_power_get_context(acpi_handle handle,
+		       struct acpi_power_resource **resource)
 {
-	int			result = 0;
-	struct acpi_device	*device = NULL;
+	int result = 0;
+	struct acpi_device *device = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_power_get_context");
 
@@ -111,24 +106,21 @@ acpi_power_get_context (
 	result = acpi_bus_get_device(handle, &device);
 	if (result) {
 		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Error getting context [%p]\n",
-			handle));
+				  handle));
 		return_VALUE(result);
 	}
 
-	*resource = (struct acpi_power_resource *) acpi_driver_data(device);
+	*resource = (struct acpi_power_resource *)acpi_driver_data(device);
 	if (!resource)
 		return_VALUE(-ENODEV);
 
 	return_VALUE(0);
 }
 
-
-static int
-acpi_power_get_state (
-	struct acpi_power_resource *resource)
+static int acpi_power_get_state(struct acpi_power_resource *resource)
 {
-	acpi_status		status = AE_OK;
-	unsigned long		sta = 0;
+	acpi_status status = AE_OK;
+	unsigned long sta = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_power_get_state");
 
@@ -145,20 +137,16 @@ acpi_power_get_state (
 		resource->state = ACPI_POWER_RESOURCE_STATE_OFF;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] is %s\n",
-		resource->name, resource->state?"on":"off"));
+			  resource->name, resource->state ? "on" : "off"));
 
 	return_VALUE(0);
 }
 
-
-static int
-acpi_power_get_list_state (
-	struct acpi_handle_list	*list,
-	int			*state)
+static int acpi_power_get_list_state(struct acpi_handle_list *list, int *state)
 {
-	int			result = 0;
+	int result = 0;
 	struct acpi_power_resource *resource = NULL;
-	u32			i = 0;
+	u32 i = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_power_get_list_state");
 
@@ -167,7 +155,7 @@ acpi_power_get_list_state (
 
 	/* The state of the list is 'on' IFF all resources are 'on'. */
 
-	for (i=0; i<list->count; i++) {
+	for (i = 0; i < list->count; i++) {
 		result = acpi_power_get_context(list->handles[i], &resource);
 		if (result)
 			return_VALUE(result);
@@ -182,19 +170,16 @@ acpi_power_get_list_state (
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource list is %s\n",
-		*state?"on":"off"));
+			  *state ? "on" : "off"));
 
 	return_VALUE(result);
 }
 
-
-static int
-acpi_power_on (
-	acpi_handle		handle)
+static int acpi_power_on(acpi_handle handle)
 {
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_device	*device = NULL;
+	int result = 0;
+	acpi_status status = AE_OK;
+	struct acpi_device *device = NULL;
 	struct acpi_power_resource *resource = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_power_on");
@@ -205,10 +190,10 @@ acpi_power_on (
 
 	resource->references++;
 
-	if ((resource->references > 1) 
-		|| (resource->state == ACPI_POWER_RESOURCE_STATE_ON)) {
+	if ((resource->references > 1)
+	    || (resource->state == ACPI_POWER_RESOURCE_STATE_ON)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already on\n",
-			resource->name));
+				  resource->name));
 		return_VALUE(0);
 	}
 
@@ -229,19 +214,16 @@ acpi_power_on (
 	device->power.state = ACPI_STATE_D0;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned on\n",
-		resource->name));
+			  resource->name));
 
 	return_VALUE(0);
 }
 
-
-static int
-acpi_power_off_device (
-	acpi_handle		handle)
+static int acpi_power_off_device(acpi_handle handle)
 {
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_device	*device = NULL;
+	int result = 0;
+	acpi_status status = AE_OK;
+	struct acpi_device *device = NULL;
 	struct acpi_power_resource *resource = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_power_off_device");
@@ -254,15 +236,15 @@ acpi_power_off_device (
 		resource->references--;
 
 	if (resource->references) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"Resource [%s] is still in use, dereferencing\n",
-			device->pnp.bus_id));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Resource [%s] is still in use, dereferencing\n",
+				  device->pnp.bus_id));
 		return_VALUE(0);
 	}
 
 	if (resource->state == ACPI_POWER_RESOURCE_STATE_OFF) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already off\n",
-			device->pnp.bus_id));
+				  device->pnp.bus_id));
 		return_VALUE(0);
 	}
 
@@ -283,7 +265,7 @@ acpi_power_off_device (
 	device->power.state = ACPI_STATE_D3;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned off\n",
-		resource->name));
+			  resource->name));
 
 	return_VALUE(0);
 }
@@ -293,13 +275,13 @@ acpi_power_off_device (
  * 1. Power on the power resources required for the wakeup device 
  * 2. Enable _PSW (power state wake) for the device if present
  */
-int acpi_enable_wakeup_device_power (struct acpi_device *dev)
+int acpi_enable_wakeup_device_power(struct acpi_device *dev)
 {
-	union acpi_object 		arg = {ACPI_TYPE_INTEGER};
-	struct acpi_object_list	arg_list = {1, &arg};
-	acpi_status			status = AE_OK;
-	int					i;
-	int 					ret = 0;
+	union acpi_object arg = { ACPI_TYPE_INTEGER };
+	struct acpi_object_list arg_list = { 1, &arg };
+	acpi_status status = AE_OK;
+	int i;
+	int ret = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_enable_wakeup_device_power");
 	if (!dev || !dev->wakeup.flags.valid)
@@ -310,8 +292,8 @@ int acpi_enable_wakeup_device_power (struct acpi_device *dev)
 	for (i = 0; i < dev->wakeup.resources.count; i++) {
 		ret = acpi_power_on(dev->wakeup.resources.handles[i]);
 		if (ret) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-				"Error transition power state\n"));
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+					  "Error transition power state\n"));
 			dev->wakeup.flags.valid = 0;
 			return_VALUE(-1);
 		}
@@ -333,20 +315,20 @@ int acpi_enable_wakeup_device_power (struct acpi_device *dev)
  * 1. Disable _PSW (power state wake)
  * 2. Shutdown down the power resources
  */
-int acpi_disable_wakeup_device_power (struct acpi_device *dev)
+int acpi_disable_wakeup_device_power(struct acpi_device *dev)
 {
-	union acpi_object 		arg = {ACPI_TYPE_INTEGER};
-	struct acpi_object_list	arg_list = {1, &arg};
-	acpi_status			status = AE_OK;
-	int					i;
-	int 					ret = 0;
+	union acpi_object arg = { ACPI_TYPE_INTEGER };
+	struct acpi_object_list arg_list = { 1, &arg };
+	acpi_status status = AE_OK;
+	int i;
+	int ret = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_disable_wakeup_device_power");
 
 	if (!dev || !dev->wakeup.flags.valid)
 		return_VALUE(-1);
 
-	arg.integer.value = 0;	
+	arg.integer.value = 0;
 	/* Execute PSW */
 	status = acpi_evaluate_object(dev->handle, "_PSW", &arg_list, NULL);
 	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
@@ -359,8 +341,8 @@ int acpi_disable_wakeup_device_power (struct acpi_device *dev)
 	for (i = 0; i < dev->wakeup.resources.count; i++) {
 		ret = acpi_power_off_device(dev->wakeup.resources.handles[i]);
 		if (ret) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-				"Error transition power state\n"));
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+					  "Error transition power state\n"));
 			dev->wakeup.flags.valid = 0;
 			return_VALUE(-1);
 		}
@@ -373,14 +355,12 @@ int acpi_disable_wakeup_device_power (struct acpi_device *dev)
                              Device Power Management
    -------------------------------------------------------------------------- */
 
-int
-acpi_power_get_inferred_state (
-	struct acpi_device	*device)
+int acpi_power_get_inferred_state(struct acpi_device *device)
 {
-	int			result = 0;
-	struct acpi_handle_list	*list = NULL;
-	int			list_state = 0;
-	int			i = 0;
+	int result = 0;
+	struct acpi_handle_list *list = NULL;
+	int list_state = 0;
+	int i = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_power_get_inferred_state");
 
@@ -393,7 +373,7 @@ acpi_power_get_inferred_state (
 	 * We know a device's inferred power state when all the resources
 	 * required for a given D-state are 'on'.
 	 */
-	for (i=ACPI_STATE_D0; i<ACPI_STATE_D3; i++) {
+	for (i = ACPI_STATE_D0; i < ACPI_STATE_D3; i++) {
 		list = &device->power.states[i].resources;
 		if (list->count < 1)
 			continue;
@@ -413,23 +393,20 @@ acpi_power_get_inferred_state (
 	return_VALUE(0);
 }
 
-
-int
-acpi_power_transition (
-	struct acpi_device	*device,
-	int			state)
+int acpi_power_transition(struct acpi_device *device, int state)
 {
-	int			result = 0;
-	struct acpi_handle_list	*cl = NULL;	/* Current Resources */
-	struct acpi_handle_list	*tl = NULL;	/* Target Resources */
-	int			i = 0;
+	int result = 0;
+	struct acpi_handle_list *cl = NULL;	/* Current Resources */
+	struct acpi_handle_list *tl = NULL;	/* Target Resources */
+	int i = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_power_transition");
 
 	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
 		return_VALUE(-EINVAL);
 
-	if ((device->power.state < ACPI_STATE_D0) || (device->power.state > ACPI_STATE_D3))
+	if ((device->power.state < ACPI_STATE_D0)
+	    || (device->power.state > ACPI_STATE_D3))
 		return_VALUE(-ENODEV);
 
 	cl = &device->power.states[device->power.state].resources;
@@ -448,7 +425,7 @@ acpi_power_transition (
 	 * First we reference all power resources required in the target list
 	 * (e.g. so the device doesn't lose power while transitioning).
 	 */
-	for (i=0; i<tl->count; i++) {
+	for (i = 0; i < tl->count; i++) {
 		result = acpi_power_on(tl->handles[i]);
 		if (result)
 			goto end;
@@ -457,7 +434,7 @@ acpi_power_transition (
 	/*
 	 * Then we dereference all power resources used in the current list.
 	 */
-	for (i=0; i<cl->count; i++) {
+	for (i = 0; i < cl->count; i++) {
 		result = acpi_power_off_device(cl->handles[i]);
 		if (result)
 			goto end;
@@ -465,21 +442,20 @@ acpi_power_transition (
 
 	/* We shouldn't change the state till all above operations succeed */
 	device->power.state = state;
-end:
+      end:
 	if (result)
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
-			"Error transitioning device [%s] to D%d\n",
-			device->pnp.bus_id, state));
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+				  "Error transitioning device [%s] to D%d\n",
+				  device->pnp.bus_id, state));
 
 	return_VALUE(result);
 }
 
-
 /* --------------------------------------------------------------------------
                               FS Interface (/proc)
    -------------------------------------------------------------------------- */
 
-static struct proc_dir_entry	*acpi_power_dir;
+static struct proc_dir_entry *acpi_power_dir;
 
 static int acpi_power_seq_show(struct seq_file *seq, void *offset)
 {
@@ -506,13 +482,12 @@ static int acpi_power_seq_show(struct seq_file *seq, void *offset)
 	}
 
 	seq_printf(seq, "system level:            S%d\n"
-			"order:                   %d\n"
-			"reference count:         %d\n",
-			resource->system_level,
-			resource->order,
-			resource->references);
+		   "order:                   %d\n"
+		   "reference count:         %d\n",
+		   resource->system_level,
+		   resource->order, resource->references);
 
-end:
+      end:
 	return_VALUE(0);
 }
 
@@ -521,11 +496,9 @@ static int acpi_power_open_fs(struct inode *inode, struct file *file)
 	return single_open(file, acpi_power_seq_show, PDE(inode)->data);
 }
 
-static int
-acpi_power_add_fs (
-	struct acpi_device	*device)
+static int acpi_power_add_fs(struct acpi_device *device)
 {
-	struct proc_dir_entry	*entry = NULL;
+	struct proc_dir_entry *entry = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_power_add_fs");
 
@@ -534,18 +507,18 @@ acpi_power_add_fs (
 
 	if (!acpi_device_dir(device)) {
 		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
-			acpi_power_dir);
+						     acpi_power_dir);
 		if (!acpi_device_dir(device))
 			return_VALUE(-ENODEV);
 	}
 
 	/* 'status' [R] */
 	entry = create_proc_entry(ACPI_POWER_FILE_STATUS,
-		S_IRUGO, acpi_device_dir(device));
+				  S_IRUGO, acpi_device_dir(device));
 	if (!entry)
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_POWER_FILE_STATUS));
+				  "Unable to create '%s' fs entry\n",
+				  ACPI_POWER_FILE_STATUS));
 	else {
 		entry->proc_fops = &acpi_power_fops;
 		entry->data = acpi_driver_data(device);
@@ -554,10 +527,7 @@ acpi_power_add_fs (
 	return_VALUE(0);
 }
 
-
-static int
-acpi_power_remove_fs (
-	struct acpi_device	*device)
+static int acpi_power_remove_fs(struct acpi_device *device)
 {
 	ACPI_FUNCTION_TRACE("acpi_power_remove_fs");
 
@@ -571,20 +541,17 @@ acpi_power_remove_fs (
 	return_VALUE(0);
 }
 
-
 /* --------------------------------------------------------------------------
                                 Driver Interface
    -------------------------------------------------------------------------- */
 
-static int
-acpi_power_add (
-	struct acpi_device	*device)
+static int acpi_power_add(struct acpi_device *device)
 {
-	int			result = 0;
-	acpi_status		status = AE_OK;
+	int result = 0;
+	acpi_status status = AE_OK;
 	struct acpi_power_resource *resource = NULL;
-	union acpi_object	acpi_object;
-	struct acpi_buffer	buffer = {sizeof(acpi_object), &acpi_object};
+	union acpi_object acpi_object;
+	struct acpi_buffer buffer = { sizeof(acpi_object), &acpi_object };
 
 	ACPI_FUNCTION_TRACE("acpi_power_add");
 
@@ -630,22 +597,18 @@ acpi_power_add (
 	result = acpi_power_add_fs(device);
 	if (result)
 		goto end;
-	
+
 	printk(KERN_INFO PREFIX "%s [%s] (%s)\n", acpi_device_name(device),
-		acpi_device_bid(device), resource->state?"on":"off");
+	       acpi_device_bid(device), resource->state ? "on" : "off");
 
-end:
+      end:
 	if (result)
 		kfree(resource);
-	
+
 	return_VALUE(result);
 }
 
-
-static int
-acpi_power_remove (
-	struct acpi_device	*device,
-	int			type)
+static int acpi_power_remove(struct acpi_device *device, int type)
 {
 	struct acpi_power_resource *resource = NULL;
 
@@ -654,7 +617,7 @@ acpi_power_remove (
 	if (!device || !acpi_driver_data(device))
 		return_VALUE(-EINVAL);
 
-	resource = (struct acpi_power_resource *) acpi_driver_data(device);
+	resource = (struct acpi_power_resource *)acpi_driver_data(device);
 
 	acpi_power_remove_fs(device);
 
@@ -663,10 +626,9 @@ acpi_power_remove (
 	return_VALUE(0);
 }
 
-
-static int __init acpi_power_init (void)
+static int __init acpi_power_init(void)
 {
-	int			result = 0;
+	int result = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_power_init");
 
@@ -689,4 +651,3 @@ static int __init acpi_power_init (void)
 }
 
 subsys_initcall(acpi_power_init);
-

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
new file mode 100644
index 000000000000..373a3a95bb4e
--- /dev/null
+++ b/drivers/acpi/power.c
@@ -0,0 +1,692 @@
+/*
+ *  acpi_power.c - ACPI Bus Power Management ($Revision: 39 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+/*
+ * ACPI power-managed devices may be controlled in two ways:
+ * 1. via "Device Specific (D-State) Control"
+ * 2. via "Power Resource Control".
+ * This module is used to manage devices relying on Power Resource Control.
+ * 
+ * An ACPI "power resource object" describes a software controllable power
+ * plane, clock plane, or other resource used by a power managed device.
+ * A device may rely on multiple power resources, and a power resource
+ * may be shared by multiple devices.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_POWER_COMPONENT
+ACPI_MODULE_NAME		("acpi_power")
+
+#define ACPI_POWER_COMPONENT		0x00800000
+#define ACPI_POWER_CLASS		"power_resource"
+#define ACPI_POWER_DRIVER_NAME		"ACPI Power Resource Driver"
+#define ACPI_POWER_DEVICE_NAME		"Power Resource"
+#define ACPI_POWER_FILE_INFO		"info"
+#define ACPI_POWER_FILE_STATUS		"state"
+#define ACPI_POWER_RESOURCE_STATE_OFF	0x00
+#define ACPI_POWER_RESOURCE_STATE_ON	0x01
+#define ACPI_POWER_RESOURCE_STATE_UNKNOWN 0xFF
+
+static int acpi_power_add (struct acpi_device *device);
+static int acpi_power_remove (struct acpi_device *device, int type);
+static int acpi_power_open_fs(struct inode *inode, struct file *file);
+
+static struct acpi_driver acpi_power_driver = {
+	.name =		ACPI_POWER_DRIVER_NAME,
+	.class =	ACPI_POWER_CLASS,
+	.ids =		ACPI_POWER_HID,
+	.ops =		{
+				.add =		acpi_power_add,
+				.remove =	acpi_power_remove,
+			},
+};
+
+struct acpi_power_resource
+{
+	acpi_handle		handle;
+	acpi_bus_id		name;
+	u32			system_level;
+	u32			order;
+	int			state;
+	int			references;
+};
+
+static struct list_head		acpi_power_resource_list;
+
+static struct file_operations acpi_power_fops = {
+	.open		= acpi_power_open_fs,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/* --------------------------------------------------------------------------
+                             Power Resource Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_power_get_context (
+	acpi_handle		handle,
+	struct acpi_power_resource **resource)
+{
+	int			result = 0;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_power_get_context");
+
+	if (!resource)
+		return_VALUE(-ENODEV);
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Error getting context [%p]\n",
+			handle));
+		return_VALUE(result);
+	}
+
+	*resource = (struct acpi_power_resource *) acpi_driver_data(device);
+	if (!resource)
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_power_get_state (
+	struct acpi_power_resource *resource)
+{
+	acpi_status		status = AE_OK;
+	unsigned long		sta = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_power_get_state");
+
+	if (!resource)
+		return_VALUE(-EINVAL);
+
+	status = acpi_evaluate_integer(resource->handle, "_STA", NULL, &sta);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	if (sta & 0x01)
+		resource->state = ACPI_POWER_RESOURCE_STATE_ON;
+	else
+		resource->state = ACPI_POWER_RESOURCE_STATE_OFF;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] is %s\n",
+		resource->name, resource->state?"on":"off"));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_power_get_list_state (
+	struct acpi_handle_list	*list,
+	int			*state)
+{
+	int			result = 0;
+	struct acpi_power_resource *resource = NULL;
+	u32			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_power_get_list_state");
+
+	if (!list || !state)
+		return_VALUE(-EINVAL);
+
+	/* The state of the list is 'on' IFF all resources are 'on'. */
+
+	for (i=0; i<list->count; i++) {
+		result = acpi_power_get_context(list->handles[i], &resource);
+		if (result)
+			return_VALUE(result);
+		result = acpi_power_get_state(resource);
+		if (result)
+			return_VALUE(result);
+
+		*state = resource->state;
+
+		if (*state != ACPI_POWER_RESOURCE_STATE_ON)
+			break;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource list is %s\n",
+		*state?"on":"off"));
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_power_on (
+	acpi_handle		handle)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_device	*device = NULL;
+	struct acpi_power_resource *resource = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_power_on");
+
+	result = acpi_power_get_context(handle, &resource);
+	if (result)
+		return_VALUE(result);
+
+	resource->references++;
+
+	if ((resource->references > 1) 
+		|| (resource->state == ACPI_POWER_RESOURCE_STATE_ON)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already on\n",
+			resource->name));
+		return_VALUE(0);
+	}
+
+	status = acpi_evaluate_object(resource->handle, "_ON", NULL, NULL);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	result = acpi_power_get_state(resource);
+	if (result)
+		return_VALUE(result);
+	if (resource->state != ACPI_POWER_RESOURCE_STATE_ON)
+		return_VALUE(-ENOEXEC);
+
+	/* Update the power resource's _device_ power state */
+	result = acpi_bus_get_device(resource->handle, &device);
+	if (result)
+		return_VALUE(result);
+	device->power.state = ACPI_STATE_D0;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned on\n",
+		resource->name));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_power_off_device (
+	acpi_handle		handle)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_device	*device = NULL;
+	struct acpi_power_resource *resource = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_power_off_device");
+
+	result = acpi_power_get_context(handle, &resource);
+	if (result)
+		return_VALUE(result);
+
+	if (resource->references)
+		resource->references--;
+
+	if (resource->references) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Resource [%s] is still in use, dereferencing\n",
+			device->pnp.bus_id));
+		return_VALUE(0);
+	}
+
+	if (resource->state == ACPI_POWER_RESOURCE_STATE_OFF) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already off\n",
+			device->pnp.bus_id));
+		return_VALUE(0);
+	}
+
+	status = acpi_evaluate_object(resource->handle, "_OFF", NULL, NULL);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	result = acpi_power_get_state(resource);
+	if (result)
+		return_VALUE(result);
+	if (resource->state != ACPI_POWER_RESOURCE_STATE_OFF)
+		return_VALUE(-ENOEXEC);
+
+	/* Update the power resource's _device_ power state */
+	result = acpi_bus_get_device(resource->handle, &device);
+	if (result)
+		return_VALUE(result);
+	device->power.state = ACPI_STATE_D3;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned off\n",
+		resource->name));
+
+	return_VALUE(0);
+}
+
+/*
+ * Prepare a wakeup device, two steps (Ref ACPI 2.0:P229):
+ * 1. Power on the power resources required for the wakeup device 
+ * 2. Enable _PSW (power state wake) for the device if present
+ */
+int acpi_enable_wakeup_device_power (struct acpi_device *dev)
+{
+	union acpi_object 		arg = {ACPI_TYPE_INTEGER};
+	struct acpi_object_list	arg_list = {1, &arg};
+	acpi_status			status = AE_OK;
+	int					i;
+	int 					ret = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_enable_wakeup_device_power");
+	if (!dev || !dev->wakeup.flags.valid)
+		return_VALUE(-1);
+
+	arg.integer.value = 1;
+	/* Open power resource */
+	for (i = 0; i < dev->wakeup.resources.count; i++) {
+		ret = acpi_power_on(dev->wakeup.resources.handles[i]);
+		if (ret) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+				"Error transition power state\n"));
+			dev->wakeup.flags.valid = 0;
+			return_VALUE(-1);
+		}
+	}
+
+	/* Execute PSW */
+	status = acpi_evaluate_object(dev->handle, "_PSW", &arg_list, NULL);
+	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluate _PSW\n"));
+		dev->wakeup.flags.valid = 0;
+		ret = -1;
+	}
+
+	return_VALUE(ret);
+}
+
+/*
+ * Shutdown a wakeup device, counterpart of above method
+ * 1. Disable _PSW (power state wake)
+ * 2. Shutdown down the power resources
+ */
+int acpi_disable_wakeup_device_power (struct acpi_device *dev)
+{
+	union acpi_object 		arg = {ACPI_TYPE_INTEGER};
+	struct acpi_object_list	arg_list = {1, &arg};
+	acpi_status			status = AE_OK;
+	int					i;
+	int 					ret = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_disable_wakeup_device_power");
+
+	if (!dev || !dev->wakeup.flags.valid)
+		return_VALUE(-1);
+
+	arg.integer.value = 0;	
+	/* Execute PSW */
+	status = acpi_evaluate_object(dev->handle, "_PSW", &arg_list, NULL);
+	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluate _PSW\n"));
+		dev->wakeup.flags.valid = 0;
+		return_VALUE(-1);
+	}
+
+	/* Close power resource */
+	for (i = 0; i < dev->wakeup.resources.count; i++) {
+		ret = acpi_power_off_device(dev->wakeup.resources.handles[i]);
+		if (ret) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+				"Error transition power state\n"));
+			dev->wakeup.flags.valid = 0;
+			return_VALUE(-1);
+		}
+	}
+
+	return_VALUE(ret);
+}
+
+/* --------------------------------------------------------------------------
+                             Device Power Management
+   -------------------------------------------------------------------------- */
+
+int
+acpi_power_get_inferred_state (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	struct acpi_handle_list	*list = NULL;
+	int			list_state = 0;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_power_get_inferred_state");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	device->power.state = ACPI_STATE_UNKNOWN;
+
+	/*
+	 * We know a device's inferred power state when all the resources
+	 * required for a given D-state are 'on'.
+	 */
+	for (i=ACPI_STATE_D0; i<ACPI_STATE_D3; i++) {
+		list = &device->power.states[i].resources;
+		if (list->count < 1)
+			continue;
+
+		result = acpi_power_get_list_state(list, &list_state);
+		if (result)
+			return_VALUE(result);
+
+		if (list_state == ACPI_POWER_RESOURCE_STATE_ON) {
+			device->power.state = i;
+			return_VALUE(0);
+		}
+	}
+
+	device->power.state = ACPI_STATE_D3;
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_power_transition (
+	struct acpi_device	*device,
+	int			state)
+{
+	int			result = 0;
+	struct acpi_handle_list	*cl = NULL;	/* Current Resources */
+	struct acpi_handle_list	*tl = NULL;	/* Target Resources */
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_power_transition");
+
+	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
+		return_VALUE(-EINVAL);
+
+	if ((device->power.state < ACPI_STATE_D0) || (device->power.state > ACPI_STATE_D3))
+		return_VALUE(-ENODEV);
+
+	cl = &device->power.states[device->power.state].resources;
+	tl = &device->power.states[state].resources;
+
+	device->power.state = ACPI_STATE_UNKNOWN;
+
+	if (!cl->count && !tl->count) {
+		result = -ENODEV;
+		goto end;
+	}
+
+	/* TBD: Resources must be ordered. */
+
+	/*
+	 * First we reference all power resources required in the target list
+	 * (e.g. so the device doesn't lose power while transitioning).
+	 */
+	for (i=0; i<tl->count; i++) {
+		result = acpi_power_on(tl->handles[i]);
+		if (result)
+			goto end;
+	}
+
+	/*
+	 * Then we dereference all power resources used in the current list.
+	 */
+	for (i=0; i<cl->count; i++) {
+		result = acpi_power_off_device(cl->handles[i]);
+		if (result)
+			goto end;
+	}
+
+	/* We shouldn't change the state till all above operations succeed */
+	device->power.state = state;
+end:
+	if (result)
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
+			"Error transitioning device [%s] to D%d\n",
+			device->pnp.bus_id, state));
+
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+static struct proc_dir_entry	*acpi_power_dir;
+
+static int acpi_power_seq_show(struct seq_file *seq, void *offset)
+{
+	struct acpi_power_resource *resource = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_power_seq_show");
+
+	resource = (struct acpi_power_resource *)seq->private;
+
+	if (!resource)
+		goto end;
+
+	seq_puts(seq, "state:                   ");
+	switch (resource->state) {
+	case ACPI_POWER_RESOURCE_STATE_ON:
+		seq_puts(seq, "on\n");
+		break;
+	case ACPI_POWER_RESOURCE_STATE_OFF:
+		seq_puts(seq, "off\n");
+		break;
+	default:
+		seq_puts(seq, "unknown\n");
+		break;
+	}
+
+	seq_printf(seq, "system level:            S%d\n"
+			"order:                   %d\n"
+			"reference count:         %d\n",
+			resource->system_level,
+			resource->order,
+			resource->references);
+
+end:
+	return_VALUE(0);
+}
+
+static int acpi_power_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, acpi_power_seq_show, PDE(inode)->data);
+}
+
+static int
+acpi_power_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_power_add_fs");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_power_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+	}
+
+	/* 'status' [R] */
+	entry = create_proc_entry(ACPI_POWER_FILE_STATUS,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_POWER_FILE_STATUS));
+	else {
+		entry->proc_fops = &acpi_power_fops;
+		entry->data = acpi_driver_data(device);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_power_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_power_remove_fs");
+
+	if (acpi_device_dir(device)) {
+		remove_proc_entry(ACPI_POWER_FILE_STATUS,
+				  acpi_device_dir(device));
+		remove_proc_entry(acpi_device_bid(device), acpi_power_dir);
+		acpi_device_dir(device) = NULL;
+	}
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                Driver Interface
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_power_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_power_resource *resource = NULL;
+	union acpi_object	acpi_object;
+	struct acpi_buffer	buffer = {sizeof(acpi_object), &acpi_object};
+
+	ACPI_FUNCTION_TRACE("acpi_power_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	resource = kmalloc(sizeof(struct acpi_power_resource), GFP_KERNEL);
+	if (!resource)
+		return_VALUE(-ENOMEM);
+	memset(resource, 0, sizeof(struct acpi_power_resource));
+
+	resource->handle = device->handle;
+	strcpy(resource->name, device->pnp.bus_id);
+	strcpy(acpi_device_name(device), ACPI_POWER_DEVICE_NAME);
+	strcpy(acpi_device_class(device), ACPI_POWER_CLASS);
+	acpi_driver_data(device) = resource;
+
+	/* Evalute the object to get the system level and resource order. */
+	status = acpi_evaluate_object(resource->handle, NULL, NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		result = -ENODEV;
+		goto end;
+	}
+	resource->system_level = acpi_object.power_resource.system_level;
+	resource->order = acpi_object.power_resource.resource_order;
+
+	result = acpi_power_get_state(resource);
+	if (result)
+		goto end;
+
+	switch (resource->state) {
+	case ACPI_POWER_RESOURCE_STATE_ON:
+		device->power.state = ACPI_STATE_D0;
+		break;
+	case ACPI_POWER_RESOURCE_STATE_OFF:
+		device->power.state = ACPI_STATE_D3;
+		break;
+	default:
+		device->power.state = ACPI_STATE_UNKNOWN;
+		break;
+	}
+
+	result = acpi_power_add_fs(device);
+	if (result)
+		goto end;
+	
+	printk(KERN_INFO PREFIX "%s [%s] (%s)\n", acpi_device_name(device),
+		acpi_device_bid(device), resource->state?"on":"off");
+
+end:
+	if (result)
+		kfree(resource);
+	
+	return_VALUE(result);
+}
+
+
+static int
+acpi_power_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	struct acpi_power_resource *resource = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_power_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	resource = (struct acpi_power_resource *) acpi_driver_data(device);
+
+	acpi_power_remove_fs(device);
+
+	kfree(resource);
+
+	return_VALUE(0);
+}
+
+
+static int __init acpi_power_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_power_init");
+
+	if (acpi_disabled)
+		return_VALUE(0);
+
+	INIT_LIST_HEAD(&acpi_power_resource_list);
+
+	acpi_power_dir = proc_mkdir(ACPI_POWER_CLASS, acpi_root_dir);
+	if (!acpi_power_dir)
+		return_VALUE(-ENODEV);
+
+	result = acpi_bus_register_driver(&acpi_power_driver);
+	if (result < 0) {
+		remove_proc_entry(ACPI_POWER_CLASS, acpi_root_dir);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+subsys_initcall(acpi_power_init);
+
