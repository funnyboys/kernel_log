commit 8c3f6993c221cc1a2588046e3ff32d64580396b7
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Feb 23 15:29:41 2020 +0100

    ACPI / battery: Cleanup Lenovo Ideapad Miix 320 DMI table entry
    
    The Lenovo Ideapad Miix 320 bat_dmi_table entry is using weird indentation
    and is the only entry which (unnecessarily) uses DMI_EXACT_MATCH instead
    of DMI_MATCH, fixup both to make the entry consistent with the others.
    
    While at it also update the comments for battery_do_not_check_pmic_quirk
    entries, adding a bit of text explaining why the quirk is necessary.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 111a407dcc77..366c389175d8 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1365,19 +1365,19 @@ static const struct dmi_system_id bat_dmi_table[] __initconst = {
 		},
 	},
 	{
-		/* ECS EF20EA */
+		/* ECS EF20EA, AXP288 PMIC but uses separate fuel-gauge */
 		.callback = battery_do_not_check_pmic_quirk,
 		.matches = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "EF20EA"),
 		},
 	},
 	{
-		/* Lenovo Ideapad Miix 320 */
+		/* Lenovo Ideapad Miix 320, AXP288 PMIC, separate fuel-gauge */
 		.callback = battery_do_not_check_pmic_quirk,
 		.matches = {
-		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "80XF"),
-		  DMI_EXACT_MATCH(DMI_PRODUCT_VERSION, "Lenovo MIIX 320-10ICR"),
+			DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "80XF"),
+			DMI_MATCH(DMI_PRODUCT_VERSION, "Lenovo MIIX 320-10ICR"),
 		},
 	},
 	{},

commit 97a32539b9568bb653683349e5a76d02ff3c3e2c
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Feb 3 17:37:17 2020 -0800

    proc: convert everything to "struct proc_ops"
    
    The most notable change is DEFINE_SHOW_ATTRIBUTE macro split in
    seq_file.h.
    
    Conversion rule is:
    
            llseek          => proc_lseek
            unlocked_ioctl  => proc_ioctl
    
            xxx             => proc_xxx
    
            delete ".owner = THIS_MODULE" line
    
    [akpm@linux-foundation.org: fix drivers/isdn/capi/kcapi_proc.c]
    [sfr@canb.auug.org.au: fix kernel/sched/psi.c]
      Link: http://lkml.kernel.org/r/20200122180545.36222f50@canb.auug.org.au
    Link: http://lkml.kernel.org/r/20191225172546.GB13378@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 15cc7d5a6185..111a407dcc77 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1202,13 +1202,12 @@ static int acpi_battery_alarm_proc_open(struct inode *inode, struct file *file)
 	return single_open(file, acpi_battery_alarm_proc_show, PDE_DATA(inode));
 }
 
-static const struct file_operations acpi_battery_alarm_fops = {
-	.owner		= THIS_MODULE,
-	.open		= acpi_battery_alarm_proc_open,
-	.read		= seq_read,
-	.write		= acpi_battery_write_alarm,
-	.llseek		= seq_lseek,
-	.release	= single_release,
+static const struct proc_ops acpi_battery_alarm_proc_ops = {
+	.proc_open	= acpi_battery_alarm_proc_open,
+	.proc_read	= seq_read,
+	.proc_write	= acpi_battery_write_alarm,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= single_release,
 };
 
 static int acpi_battery_add_fs(struct acpi_device *device)
@@ -1228,7 +1227,7 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 			acpi_battery_state_proc_show, acpi_driver_data(device)))
 		return -ENODEV;
 	if (!proc_create_data("alarm", S_IFREG | S_IRUGO | S_IWUSR,
-			acpi_device_dir(device), &acpi_battery_alarm_fops,
+			acpi_device_dir(device), &acpi_battery_alarm_proc_ops,
 			acpi_driver_data(device)))
 		return -ENODEV;
 	return 0;

commit ff3154d1d89a2343fd5f82e65bc0cf1d4e6659b3
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Dec 10 10:57:52 2019 +0100

    ACPI / battery: Deal better with neither design nor full capacity not being reported
    
    Commit b41901a2cf06 ("ACPI / battery: Do not export energy_full[_design] on
    devices without full_charge_capacity") added support for some (broken)
    devices which always report 0 for both design_capacity and
    full_charge_capacity.
    
    Since the device that commit was written as a fix for is not reporting any
    form of "full" capacity we cannot calculate the value for the
    POWER_SUPPLY_PROP_CAPACITY, this is worked around by using an alternative
    array of available properties which does not contain this property.
    
    This is necessary because userspace (upower) treats us returning -ENODEV
    as 0 and then typically will trigger an emergency shutdown because of that.
    Userspace does not do this if the capacity sysfs attribute is not present
    at all.
    
    There are two potential problems with that commit:
     1) It assumes that both full_charge- and design-capacity are broken at the
        same time and only checks if full_charge- is broken.
     2) It assumes that this only ever happens for devices which report energy
        units rather then charge units.
    
    This commit fixes both issues by only using the alternative
    array of available properties if both full_charge- and design-capacity are
    broken and by also adding an alternative array of available properties for
    devices using mA units.
    
    Fixes: b41901a2cf06 ("ACPI / battery: Do not export energy_full[_design] on devices without full_charge_capacity")
    Cc: 4.19+ <stable@vger.kernel.org> # 4.19+
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 85a6c3c3631c..15cc7d5a6185 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -342,6 +342,20 @@ static enum power_supply_property charge_battery_props[] = {
 	POWER_SUPPLY_PROP_SERIAL_NUMBER,
 };
 
+static enum power_supply_property charge_battery_full_cap_broken_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CYCLE_COUNT,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_MANUFACTURER,
+	POWER_SUPPLY_PROP_SERIAL_NUMBER,
+};
+
 static enum power_supply_property energy_battery_props[] = {
 	POWER_SUPPLY_PROP_STATUS,
 	POWER_SUPPLY_PROP_PRESENT,
@@ -803,21 +817,34 @@ static void __exit battery_hook_exit(void)
 static int sysfs_add_battery(struct acpi_battery *battery)
 {
 	struct power_supply_config psy_cfg = { .drv_data = battery, };
+	bool full_cap_broken = false;
+
+	if (!ACPI_BATTERY_CAPACITY_VALID(battery->full_charge_capacity) &&
+	    !ACPI_BATTERY_CAPACITY_VALID(battery->design_capacity))
+		full_cap_broken = true;
 
 	if (battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA) {
-		battery->bat_desc.properties = charge_battery_props;
-		battery->bat_desc.num_properties =
-			ARRAY_SIZE(charge_battery_props);
-	} else if (!ACPI_BATTERY_CAPACITY_VALID(
-					battery->full_charge_capacity)) {
-		battery->bat_desc.properties =
-			energy_battery_full_cap_broken_props;
-		battery->bat_desc.num_properties =
-			ARRAY_SIZE(energy_battery_full_cap_broken_props);
+		if (full_cap_broken) {
+			battery->bat_desc.properties =
+			    charge_battery_full_cap_broken_props;
+			battery->bat_desc.num_properties =
+			    ARRAY_SIZE(charge_battery_full_cap_broken_props);
+		} else {
+			battery->bat_desc.properties = charge_battery_props;
+			battery->bat_desc.num_properties =
+			    ARRAY_SIZE(charge_battery_props);
+		}
 	} else {
-		battery->bat_desc.properties = energy_battery_props;
-		battery->bat_desc.num_properties =
-			ARRAY_SIZE(energy_battery_props);
+		if (full_cap_broken) {
+			battery->bat_desc.properties =
+			    energy_battery_full_cap_broken_props;
+			battery->bat_desc.num_properties =
+			    ARRAY_SIZE(energy_battery_full_cap_broken_props);
+		} else {
+			battery->bat_desc.properties = energy_battery_props;
+			battery->bat_desc.num_properties =
+			    ARRAY_SIZE(energy_battery_props);
+		}
 	}
 
 	battery->bat_desc.name = acpi_device_bid(battery->device);

commit 5b74d1d16e2f5753fcbdecd6771b2d8370dda414
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Dec 10 10:57:51 2019 +0100

    ACPI / battery: Use design-cap for capacity calculations if full-cap is not available
    
    The ThunderSoft TS178 tablet's _BIX implementation reports design_capacity
    but not full_charge_capacity.
    
    Before this commit this would cause us to return -ENODEV for the capacity
    attribute, which userspace does not like. Specifically upower does this:
    
            if (sysfs_file_exists (native_path, "capacity")) {
                    percentage = sysfs_get_double (native_path, "capacity");
    
    Where the sysfs_get_double() helper returns 0 when we return -ENODEV,
    so the battery always reads 0% if we return -ENODEV.
    
    This commit fixes this by using the design-capacity instead of the
    full-charge-capacity when the full-charge-capacity is not available.
    
    Fixes: b41901a2cf06 ("ACPI / battery: Do not export energy_full[_design] on devices without full_charge_capacity")
    Cc: 4.19+ <stable@vger.kernel.org> # 4.19+
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 0862d38e51fa..85a6c3c3631c 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -217,7 +217,7 @@ static int acpi_battery_get_property(struct power_supply *psy,
 				     enum power_supply_property psp,
 				     union power_supply_propval *val)
 {
-	int ret = 0;
+	int full_capacity = ACPI_BATTERY_VALUE_UNKNOWN, ret = 0;
 	struct acpi_battery *battery = to_acpi_battery(psy);
 
 	if (acpi_battery_present(battery)) {
@@ -286,12 +286,17 @@ static int acpi_battery_get_property(struct power_supply *psy,
 			val->intval = battery->capacity_now * 1000;
 		break;
 	case POWER_SUPPLY_PROP_CAPACITY:
+		if (ACPI_BATTERY_CAPACITY_VALID(battery->full_charge_capacity))
+			full_capacity = battery->full_charge_capacity;
+		else if (ACPI_BATTERY_CAPACITY_VALID(battery->design_capacity))
+			full_capacity = battery->design_capacity;
+
 		if (battery->capacity_now == ACPI_BATTERY_VALUE_UNKNOWN ||
-		    !ACPI_BATTERY_CAPACITY_VALID(battery->full_charge_capacity))
+		    full_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
 			ret = -ENODEV;
 		else
 			val->intval = battery->capacity_now * 100/
-					battery->full_charge_capacity;
+					full_capacity;
 		break;
 	case POWER_SUPPLY_PROP_CAPACITY_LEVEL:
 		if (battery->state & ACPI_BATTERY_STATE_CRITICAL)

commit cc99f0ad52467028cb1251160f23ad4bb65baf20
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Dec 10 10:57:50 2019 +0100

    ACPI / battery: Deal with design or full capacity being reported as -1
    
    Commit b41901a2cf06 ("ACPI / battery: Do not export energy_full[_design]
    on devices without full_charge_capacity") added support for some (broken)
    devices which always report 0 for both design- and full_charge-capacity.
    
    This assumes that if the capacity is not being reported it is 0. The
    ThunderSoft TS178 tablet's _BIX implementation falsifies this assumption.
    It reports ACPI_BATTERY_VALUE_UNKNOWN (-1) as full_charge_capacity, which
    we treat as a valid value which causes several problems.
    
    This commit fixes this by adding a new ACPI_BATTERY_CAPACITY_VALID() helper
    which checks that the value is not 0 and not -1; and using this whenever we
    need to test if either design_capacity or full_charge_capacity is valid.
    
    Fixes: b41901a2cf06 ("ACPI / battery: Do not export energy_full[_design] on devices without full_charge_capacity")
    Cc: 4.19+ <stable@vger.kernel.org> # 4.19+
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 8f0e0c8d8c3d..0862d38e51fa 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -38,6 +38,8 @@
 #define PREFIX "ACPI: "
 
 #define ACPI_BATTERY_VALUE_UNKNOWN 0xFFFFFFFF
+#define ACPI_BATTERY_CAPACITY_VALID(capacity) \
+	((capacity) != 0 && (capacity) != ACPI_BATTERY_VALUE_UNKNOWN)
 
 #define ACPI_BATTERY_DEVICE_NAME	"Battery"
 
@@ -192,7 +194,8 @@ static int acpi_battery_is_charged(struct acpi_battery *battery)
 
 static bool acpi_battery_is_degraded(struct acpi_battery *battery)
 {
-	return battery->full_charge_capacity && battery->design_capacity &&
+	return ACPI_BATTERY_CAPACITY_VALID(battery->full_charge_capacity) &&
+		ACPI_BATTERY_CAPACITY_VALID(battery->design_capacity) &&
 		battery->full_charge_capacity < battery->design_capacity;
 }
 
@@ -263,14 +266,14 @@ static int acpi_battery_get_property(struct power_supply *psy,
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
 	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
-		if (battery->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+		if (!ACPI_BATTERY_CAPACITY_VALID(battery->design_capacity))
 			ret = -ENODEV;
 		else
 			val->intval = battery->design_capacity * 1000;
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_FULL:
 	case POWER_SUPPLY_PROP_ENERGY_FULL:
-		if (battery->full_charge_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+		if (!ACPI_BATTERY_CAPACITY_VALID(battery->full_charge_capacity))
 			ret = -ENODEV;
 		else
 			val->intval = battery->full_charge_capacity * 1000;
@@ -283,11 +286,12 @@ static int acpi_battery_get_property(struct power_supply *psy,
 			val->intval = battery->capacity_now * 1000;
 		break;
 	case POWER_SUPPLY_PROP_CAPACITY:
-		if (battery->capacity_now && battery->full_charge_capacity)
+		if (battery->capacity_now == ACPI_BATTERY_VALUE_UNKNOWN ||
+		    !ACPI_BATTERY_CAPACITY_VALID(battery->full_charge_capacity))
+			ret = -ENODEV;
+		else
 			val->intval = battery->capacity_now * 100/
 					battery->full_charge_capacity;
-		else
-			val->intval = 0;
 		break;
 	case POWER_SUPPLY_PROP_CAPACITY_LEVEL:
 		if (battery->state & ACPI_BATTERY_STATE_CRITICAL)
@@ -799,7 +803,8 @@ static int sysfs_add_battery(struct acpi_battery *battery)
 		battery->bat_desc.properties = charge_battery_props;
 		battery->bat_desc.num_properties =
 			ARRAY_SIZE(charge_battery_props);
-	} else if (battery->full_charge_capacity == 0) {
+	} else if (!ACPI_BATTERY_CAPACITY_VALID(
+					battery->full_charge_capacity)) {
 		battery->bat_desc.properties =
 			energy_battery_full_cap_broken_props;
 		battery->bat_desc.num_properties =

commit 933ca4e323de7775a436ae3f4a6b5a1414a4e98c
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Fri Oct 18 11:18:25 2019 +0800

    acpi: Use pr_warn instead of pr_warning
    
    As said in commit f2c2cbcc35d4 ("powerpc: Use pr_warn instead of
    pr_warning"), removing pr_warning so all logging messages use a
    consistent <prefix>_warn style. Let's do it.
    
    Link: http://lkml.kernel.org/r/20191018031850.48498-8-wangkefeng.wang@huawei.com
    To: linux-kernel@vger.kernel.org
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Len Brown <lenb@kernel.org>
    Cc: James Morse <james.morse@arm.com>
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    [pmladek@suse.com: two more indentation fixes]
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 558fedf8a7a1..8f0e0c8d8c3d 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1176,7 +1176,7 @@ static const struct file_operations acpi_battery_alarm_fops = {
 
 static int acpi_battery_add_fs(struct acpi_device *device)
 {
-	pr_warning(PREFIX "Deprecated procfs I/F for battery is loaded, please retry with CONFIG_ACPI_PROCFS_POWER cleared\n");
+	pr_warn(PREFIX "Deprecated procfs I/F for battery is loaded, please retry with CONFIG_ACPI_PROCFS_POWER cleared\n");
 	if (!acpi_device_dir(device)) {
 		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
 						     acpi_battery_dir);

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index cb97b6105f52..558fedf8a7a1 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  battery.c - ACPI Battery Driver (Revision: 2.0)
  *
@@ -5,20 +6,6 @@
  *  Copyright (C) 2004-2007 Vladimir Lebedev <vladimir.p.lebedev@intel.com>
  *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

commit b41901a2cf06f33c030be96c075872201089d47a
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Aug 7 09:36:30 2018 +0200

    ACPI / battery: Do not export energy_full[_design] on devices without full_charge_capacity
    
    On some devices (with a buggy _BIX implementation) full_charge_capacity
    always reports as 0. This means that our energy_full sysfs attribute will
    also always be 0, which is not useful to export.
    
    Worse we calculate our reported capacity on full_charge_capacity and if it
    is 0 we always report 0. This causes userspace to immediately shutdown or
    hibernate the laptop since it assumes that the battery is critically low.
    
    This commit makes us not report energy_full[_design] or capacity on such
    broken devices, avoiding the immediate shutdown / hibernate from userspace.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=83941
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index cb664e87cde8..cb97b6105f52 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -364,6 +364,20 @@ static enum power_supply_property energy_battery_props[] = {
 	POWER_SUPPLY_PROP_SERIAL_NUMBER,
 };
 
+static enum power_supply_property energy_battery_full_cap_broken_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CYCLE_COUNT,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_POWER_NOW,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_MANUFACTURER,
+	POWER_SUPPLY_PROP_SERIAL_NUMBER,
+};
+
 /* --------------------------------------------------------------------------
                                Battery Management
    -------------------------------------------------------------------------- */
@@ -798,6 +812,11 @@ static int sysfs_add_battery(struct acpi_battery *battery)
 		battery->bat_desc.properties = charge_battery_props;
 		battery->bat_desc.num_properties =
 			ARRAY_SIZE(charge_battery_props);
+	} else if (battery->full_charge_capacity == 0) {
+		battery->bat_desc.properties =
+			energy_battery_full_cap_broken_props;
+		battery->bat_desc.num_properties =
+			ARRAY_SIZE(energy_battery_full_cap_broken_props);
 	} else {
 		battery->bat_desc.properties = energy_battery_props;
 		battery->bat_desc.num_properties =

commit 2754435d4c820875412785da9bfa017a74fe51a7
Author: Dmitry Rozhkov <dmitry.rozhkov@linux.intel.com>
Date:   Tue Jul 24 14:27:34 2018 +0300

    ACPI / battery: get rid of negations in conditions
    
    Simple conditions without negations inflict less cognitive load
    on readers.
    
    Rework conditional branches not to use negations. Also add braces
    around single statement branches where their counterpart else-branches
    consist of more than one statement as suggested in the paragraph 3 of
    the coding style.
    
    Suggested-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Dmitry Rozhkov <dmitry.rozhkov@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 6d302bb2f51b..cb664e87cde8 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1020,7 +1020,7 @@ static int acpi_battery_info_proc_show(struct seq_file *seq, void *offset)
 			   acpi_battery_units(battery));
 
 	seq_printf(seq, "battery technology:      %srechargeable\n",
-		   (!battery->technology)?"non-":"");
+		   battery->technology ? "" : "non-");
 
 	if (battery->design_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "design voltage:          unknown\n");
@@ -1111,11 +1111,12 @@ static int acpi_battery_alarm_proc_show(struct seq_file *seq, void *offset)
 		goto end;
 	}
 	seq_printf(seq, "alarm:                   ");
-	if (!battery->alarm)
-		seq_printf(seq, "unsupported\n");
-	else
+	if (battery->alarm) {
 		seq_printf(seq, "%u %sh\n", battery->alarm,
 				acpi_battery_units(battery));
+	} else {
+		seq_printf(seq, "unsupported\n");
+	}
       end:
 	if (result)
 		seq_printf(seq, "ERROR: Unable to read battery alarm\n");
@@ -1148,9 +1149,9 @@ static ssize_t acpi_battery_write_alarm(struct file *file,
 	}
 	result = acpi_battery_set_alarm(battery);
       end:
-	if (!result)
-		return count;
-	return result;
+	if (result)
+		return result;
+	return count;
 }
 
 static int acpi_battery_alarm_proc_open(struct inode *inode, struct file *file)
@@ -1245,7 +1246,9 @@ static int battery_notify(struct notifier_block *nb,
 		if (!acpi_battery_present(battery))
 			return 0;
 
-		if (!battery->bat) {
+		if (battery->bat) {
+			acpi_battery_refresh(battery);
+		} else {
 			result = acpi_battery_get_info(battery);
 			if (result)
 				return result;
@@ -1253,8 +1256,7 @@ static int battery_notify(struct notifier_block *nb,
 			result = sysfs_add_battery(battery);
 			if (result)
 				return result;
-		} else
-			acpi_battery_refresh(battery);
+		}
 
 		acpi_battery_init_alarm(battery);
 		acpi_battery_get_state(battery);

commit dd1fca9e6cd4c5c179f4e854ceddbc22890109ce
Author: Dmitry Rozhkov <dmitry.rozhkov@linux.intel.com>
Date:   Tue Jul 24 14:27:33 2018 +0300

    ACPI / battery: use specialized print macros
    
    The kernel provides specialized macros for printing
    info and warning messages which make the code shorter.
    
    Use the specialized macros instead of bare printk()'s.
    
    Also format one user visible string literal into a searchable one
    line string.
    
    Suggested-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Dmitry Rozhkov <dmitry.rozhkov@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 321b5f98b63c..6d302bb2f51b 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -577,8 +577,7 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 		battery->rate_now != ACPI_BATTERY_VALUE_UNKNOWN &&
 		(s16)(battery->rate_now) < 0) {
 		battery->rate_now = abs((s16)battery->rate_now);
-		printk_once(KERN_WARNING FW_BUG
-			    "battery: (dis)charge rate invalid.\n");
+		pr_warn_once(FW_BUG "battery: (dis)charge rate invalid.\n");
 	}
 
 	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags)
@@ -1170,8 +1169,7 @@ static const struct file_operations acpi_battery_alarm_fops = {
 
 static int acpi_battery_add_fs(struct acpi_device *device)
 {
-	printk(KERN_WARNING PREFIX "Deprecated procfs I/F for battery is loaded,"
-			" please retry with CONFIG_ACPI_PROCFS_POWER cleared\n");
+	pr_warning(PREFIX "Deprecated procfs I/F for battery is loaded, please retry with CONFIG_ACPI_PROCFS_POWER cleared\n");
 	if (!acpi_device_dir(device)) {
 		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
 						     acpi_battery_dir);
@@ -1398,7 +1396,7 @@ static int acpi_battery_add(struct acpi_device *device)
 	}
 #endif
 
-	printk(KERN_INFO PREFIX "%s Slot [%s] (battery %s)\n",
+	pr_info(PREFIX "%s Slot [%s] (battery %s)\n",
 		ACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),
 		device->status.battery_present ? "present" : "absent");
 

commit 53dd200a2eed1413f2ef980dd5a193a3d45cc9a9
Author: Dmitry Rozhkov <dmitry.rozhkov@linux.intel.com>
Date:   Tue Jul 24 14:27:32 2018 +0300

    ACPI / battery: reorder headers alphabetically
    
    Headers ordered alphabetically as easier to maintain.
    
    Suggested-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Dmitry Rozhkov <dmitry.rozhkov@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 642e51f8f412..321b5f98b63c 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -23,17 +23,18 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#include <linux/async.h>
+#include <linux/delay.h>
+#include <linux/dmi.h>
+#include <linux/jiffies.h>
 #include <linux/kernel.h>
 #include <linux/list.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
-#include <linux/types.h>
-#include <linux/jiffies.h>
-#include <linux/async.h>
-#include <linux/dmi.h>
-#include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/suspend.h>
+#include <linux/types.h>
+
 #include <asm/unaligned.h>
 
 #ifdef CONFIG_ACPI_PROCFS_POWER

commit 3461dfbabcc40d48c7b4b3ebb26a4ec927303e16
Author: Dmitry Rozhkov <dmitry.rozhkov@linux.intel.com>
Date:   Tue Jul 24 14:27:31 2018 +0300

    ACPI / battery: drop inclusion of init.h
    
    The driver can be built as a module thus inclusion of init.h is
    redundant in battery.c since it's always included by module.h.
    
    Suggested-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Dmitry Rozhkov <dmitry.rozhkov@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 78e40a9f5e18..642e51f8f412 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -27,7 +27,6 @@
 #include <linux/list.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
-#include <linux/init.h>
 #include <linux/types.h>
 #include <linux/jiffies.h>
 #include <linux/async.h>

commit 82f2d30570b7ecdf1ce7e6376805f063ae86a7e5
Author: Lucas Rangit Magasweran <lucas.magasweran@ieee.org>
Date:   Sat Jul 14 15:40:18 2018 -0700

    ACPI: battery: remove redundant old_present check on insertion
    
    On removal battery_present changes from 1 to 0 after calling
    acpi_battery_get_status() and battery->update_time is set to 0
    before returning.
    
    On insertion battery_present changes from 0 to 1 after calling
    acpi_battery_get_status() and acpi_battery_get_info() is called
    because battery->update_time is 0.
    
    The old_present condition is therefore redundant.
    
    This was added in the commit below when there was a path without
    sysfs that would skip getting the newly inserted battery info.
    
    commit 50b178512b7d ("Newly inserted battery might differ from one
    just removed, so update of battery info fields is required.")
    
    Signed-off-by: Lucas Rangit Magasweran <lucas.magasweran@ieee.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index d79ad844c78f..78e40a9f5e18 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -918,10 +918,11 @@ static void acpi_battery_quirks(struct acpi_battery *battery)
 
 static int acpi_battery_update(struct acpi_battery *battery, bool resume)
 {
-	int result, old_present = acpi_battery_present(battery);
-	result = acpi_battery_get_status(battery);
+	int result = acpi_battery_get_status(battery);
+
 	if (result)
 		return result;
+
 	if (!acpi_battery_present(battery)) {
 		sysfs_remove_battery(battery);
 		battery->update_time = 0;
@@ -931,8 +932,7 @@ static int acpi_battery_update(struct acpi_battery *battery, bool resume)
 	if (resume)
 		return 0;
 
-	if (!battery->update_time ||
-	    old_present != acpi_battery_present(battery)) {
+	if (!battery->update_time) {
 		result = acpi_battery_get_info(battery);
 		if (result)
 			return result;

commit 673b4271665a12fa839a12abb50e6f6e9953c081
Author: Jouke Witteveen <j.witteveen@gmail.com>
Date:   Wed Jul 4 12:27:15 2018 +0200

    ACPI / battery: Safe unregistering of hooks
    
    A hooking API was implemented for 4.17 in fa93854f7a7ed63d followed
    by hooks for Thinkpad laptops in 2801b9683f740012. The Thinkpad
    drivers did not support the Thinkpad 13 and the hooking API crashes
    on unsupported batteries by altering a list of hooks during unsafe
    iteration. Thus, Thinkpad 13 laptops could no longer boot.
    
    Additionally, a lock was kept in place and debugging information was
    printed out of order.
    
    Fixes: fa93854f7a7e (battery: Add the battery hooking API)
    Cc: 4.17+ <stable@vger.kernel.org> # 4.17+
    Signed-off-by: Jouke Witteveen <j.witteveen@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index b0113a5802a3..d79ad844c78f 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -717,10 +717,11 @@ void battery_hook_register(struct acpi_battery_hook *hook)
 			 */
 			pr_err("extension failed to load: %s", hook->name);
 			__battery_hook_unregister(hook, 0);
-			return;
+			goto end;
 		}
 	}
 	pr_info("new extension: %s\n", hook->name);
+end:
 	mutex_unlock(&hook_mutex);
 }
 EXPORT_SYMBOL_GPL(battery_hook_register);
@@ -732,7 +733,7 @@ EXPORT_SYMBOL_GPL(battery_hook_register);
 */
 static void battery_hook_add_battery(struct acpi_battery *battery)
 {
-	struct acpi_battery_hook *hook_node;
+	struct acpi_battery_hook *hook_node, *tmp;
 
 	mutex_lock(&hook_mutex);
 	INIT_LIST_HEAD(&battery->list);
@@ -744,15 +745,15 @@ static void battery_hook_add_battery(struct acpi_battery *battery)
 	 * when a battery gets hotplugged or initialized
 	 * during the battery module initialization.
 	 */
-	list_for_each_entry(hook_node, &battery_hook_list, list) {
+	list_for_each_entry_safe(hook_node, tmp, &battery_hook_list, list) {
 		if (hook_node->add_battery(battery->bat)) {
 			/*
 			 * The notification of the extensions has failed, to
 			 * prevent further errors we will unload the extension.
 			 */
-			__battery_hook_unregister(hook_node, 0);
 			pr_err("error in extension, unloading: %s",
 					hook_node->name);
+			__battery_hook_unregister(hook_node, 0);
 		}
 	}
 	mutex_unlock(&hook_mutex);

commit f4fe74cc909bf811cd9cc7fd84f5a7514e06a7e1
Merge: 3c89adb0d111 2448d1399bac
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 5 10:08:27 2018 -0700

    Merge tag 'acpi-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI updates from Rafael Wysocki:
     "These update the ACPICA code in the kernel to the 20180508 upstream
      revision and make it support the RT patch, add CPPC v3 support to the
      ACPI CPPC library, add a WDAT-based watchdog quirk to prevent clashes
      with the RTC, add quirks to the ACPI AC and battery drivers, and
      update the ACPI SoC drivers.
    
      Specifics:
    
       - Update the ACPICA code in the kernel to the 20180508 upstream
         revision including:
           * iASL -tc option enhancement (Bob Moore).
           * Debugger improvements (Bob Moore).
           * Support for tables larger than 1 MB in acpidump/acpixtract (Bob
             Moore).
           * Minor fixes and cleanups (Colin Ian King, Toomas Soome).
    
       - Make the ACPICA code in the kernel support the RT patch (Sebastian
         Andrzej Siewior, Steven Rostedt).
    
       - Add a kmemleak annotation to the ACPICA code (Larry Finger).
    
       - Add CPPC v3 support to the ACPI CPPC library and fix two issues
         related to CPPC (Prashanth Prakash, Al Stone).
    
       - Add an ACPI WDAT-based watchdog quirk to prefer iTCO_wdt on systems
         where WDAT clashes with the RTC SRAM (Mika Westerberg).
    
       - Add some quirks to the ACPI AC and battery drivers (Carlo Caione,
         Hans de Goede).
    
       - Update the ACPI SoC drivers for Intel (LPSS) and AMD (APD)
         platforms (Akshu Agrawal, Hans de Goede).
    
       - Fix up some assorted minor issues (Al Stone, Laszlo Toth, Mathieu
         Malaterre)"
    
    * tag 'acpi-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (32 commits)
      ACPICA: Mark acpi_ut_create_internal_object_dbg() memory allocations as non-leaks
      ACPI / watchdog: Prefer iTCO_wdt always when WDAT table uses RTC SRAM
      mailbox: PCC: erroneous error message when parsing ACPI PCCT
      ACPICA: Update version to 20180508
      ACPICA: acpidump/acpixtract: Support for tables larger than 1MB
      ACPI: APD: Add AMD misc clock handler support
      clk: x86: Add ST oscout platform clock
      ACPICA: Update version to 20180427
      ACPICA: Debugger: Removed direct support for EC address space in "Test Objects"
      ACPICA: Debugger: Add Package support for "test objects" command
      ACPICA: Improve error messages for the namespace root node
      ACPICA: Fix potential infinite loop in acpi_rs_dump_byte_list
      ACPICA: vsnprintf: this statement may fall through
      ACPICA: Tables: Fix spelling mistake in comment
      ACPICA: iASL: Enhance the -tc option (create AML hex file in C)
      ACPI: Add missing prototype_for arch_post_acpi_subsys_init()
      ACPI / tables: improve comments regarding acpi_parse_entries_array()
      ACPICA: Convert acpi_gbl_hardware lock back to an acpi_raw_spinlock
      ACPICA: provide abstraction for raw_spinlock_t
      ACPI / CPPC: Fix invalid PCC channel status errors
      ...

commit e7b087fc6bb60234bb6d84d73b74c1e9cf03d5b7
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Apr 11 16:27:14 2018 +0200

    acpi/battery: simplify procfs code
    
    Use remove_proc_subtree to remove the whole subtree on cleanup, and
    unwind the registration loop into individual calls.  Switch to use
    proc_create_seq where applicable.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index bdb24d636d9a..76550689ce10 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -81,14 +81,6 @@ MODULE_PARM_DESC(cache_time, "cache time in milliseconds");
 #ifdef CONFIG_ACPI_PROCFS_POWER
 extern struct proc_dir_entry *acpi_lock_battery_dir(void);
 extern void *acpi_unlock_battery_dir(struct proc_dir_entry *acpi_battery_dir);
-
-enum acpi_battery_files {
-	info_tag = 0,
-	state_tag,
-	alarm_tag,
-	ACPI_BATTERY_NUMFILES,
-};
-
 #endif
 
 static const struct acpi_device_id battery_device_ids[] = {
@@ -985,9 +977,10 @@ static const char *acpi_battery_units(const struct acpi_battery *battery)
 		"mA" : "mW";
 }
 
-static int acpi_battery_print_info(struct seq_file *seq, int result)
+static int acpi_battery_info_proc_show(struct seq_file *seq, void *offset)
 {
 	struct acpi_battery *battery = seq->private;
+	int result = acpi_battery_update(battery, false);
 
 	if (result)
 		goto end;
@@ -1041,9 +1034,10 @@ static int acpi_battery_print_info(struct seq_file *seq, int result)
 	return result;
 }
 
-static int acpi_battery_print_state(struct seq_file *seq, int result)
+static int acpi_battery_state_proc_show(struct seq_file *seq, void *offset)
 {
 	struct acpi_battery *battery = seq->private;
+	int result = acpi_battery_update(battery, false);
 
 	if (result)
 		goto end;
@@ -1088,9 +1082,10 @@ static int acpi_battery_print_state(struct seq_file *seq, int result)
 	return result;
 }
 
-static int acpi_battery_print_alarm(struct seq_file *seq, int result)
+static int acpi_battery_alarm_proc_show(struct seq_file *seq, void *offset)
 {
 	struct acpi_battery *battery = seq->private;
+	int result = acpi_battery_update(battery, false);
 
 	if (result)
 		goto end;
@@ -1142,82 +1137,22 @@ static ssize_t acpi_battery_write_alarm(struct file *file,
 	return result;
 }
 
-typedef int(*print_func)(struct seq_file *seq, int result);
-
-static print_func acpi_print_funcs[ACPI_BATTERY_NUMFILES] = {
-	acpi_battery_print_info,
-	acpi_battery_print_state,
-	acpi_battery_print_alarm,
-};
-
-static int acpi_battery_read(int fid, struct seq_file *seq)
+static int acpi_battery_alarm_proc_open(struct inode *inode, struct file *file)
 {
-	struct acpi_battery *battery = seq->private;
-	int result = acpi_battery_update(battery, false);
-	return acpi_print_funcs[fid](seq, result);
+	return single_open(file, acpi_battery_alarm_proc_show, PDE_DATA(inode));
 }
 
-#define DECLARE_FILE_FUNCTIONS(_name) \
-static int acpi_battery_read_##_name(struct seq_file *seq, void *offset) \
-{ \
-	return acpi_battery_read(_name##_tag, seq); \
-} \
-static int acpi_battery_##_name##_open_fs(struct inode *inode, struct file *file) \
-{ \
-	return single_open(file, acpi_battery_read_##_name, PDE_DATA(inode)); \
-}
-
-DECLARE_FILE_FUNCTIONS(info);
-DECLARE_FILE_FUNCTIONS(state);
-DECLARE_FILE_FUNCTIONS(alarm);
-
-#undef DECLARE_FILE_FUNCTIONS
-
-#define FILE_DESCRIPTION_RO(_name) \
-	{ \
-	.name = __stringify(_name), \
-	.mode = S_IRUGO, \
-	.ops = { \
-		.open = acpi_battery_##_name##_open_fs, \
-		.read = seq_read, \
-		.llseek = seq_lseek, \
-		.release = single_release, \
-		.owner = THIS_MODULE, \
-		}, \
-	}
-
-#define FILE_DESCRIPTION_RW(_name) \
-	{ \
-	.name = __stringify(_name), \
-	.mode = S_IFREG | S_IRUGO | S_IWUSR, \
-	.ops = { \
-		.open = acpi_battery_##_name##_open_fs, \
-		.read = seq_read, \
-		.llseek = seq_lseek, \
-		.write = acpi_battery_write_##_name, \
-		.release = single_release, \
-		.owner = THIS_MODULE, \
-		}, \
-	}
-
-static const struct battery_file {
-	struct file_operations ops;
-	umode_t mode;
-	const char *name;
-} acpi_battery_file[] = {
-	FILE_DESCRIPTION_RO(info),
-	FILE_DESCRIPTION_RO(state),
-	FILE_DESCRIPTION_RW(alarm),
+static const struct file_operations acpi_battery_alarm_fops = {
+	.owner		= THIS_MODULE,
+	.open		= acpi_battery_alarm_proc_open,
+	.read		= seq_read,
+	.write		= acpi_battery_write_alarm,
+	.llseek		= seq_lseek,
+	.release	= single_release,
 };
 
-#undef FILE_DESCRIPTION_RO
-#undef FILE_DESCRIPTION_RW
-
 static int acpi_battery_add_fs(struct acpi_device *device)
 {
-	struct proc_dir_entry *entry = NULL;
-	int i;
-
 	printk(KERN_WARNING PREFIX "Deprecated procfs I/F for battery is loaded,"
 			" please retry with CONFIG_ACPI_PROCFS_POWER cleared\n");
 	if (!acpi_device_dir(device)) {
@@ -1227,28 +1162,24 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 			return -ENODEV;
 	}
 
-	for (i = 0; i < ACPI_BATTERY_NUMFILES; ++i) {
-		entry = proc_create_data(acpi_battery_file[i].name,
-					 acpi_battery_file[i].mode,
-					 acpi_device_dir(device),
-					 &acpi_battery_file[i].ops,
-					 acpi_driver_data(device));
-		if (!entry)
-			return -ENODEV;
-	}
+	if (!proc_create_single_data("info", S_IRUGO, acpi_device_dir(device),
+			acpi_battery_info_proc_show, acpi_driver_data(device)))
+		return -ENODEV;
+	if (!proc_create_single_data("state", S_IRUGO, acpi_device_dir(device),
+			acpi_battery_state_proc_show, acpi_driver_data(device)))
+		return -ENODEV;
+	if (!proc_create_data("alarm", S_IFREG | S_IRUGO | S_IWUSR,
+			acpi_device_dir(device), &acpi_battery_alarm_fops,
+			acpi_driver_data(device)))
+		return -ENODEV;
 	return 0;
 }
 
 static void acpi_battery_remove_fs(struct acpi_device *device)
 {
-	int i;
 	if (!acpi_device_dir(device))
 		return;
-	for (i = 0; i < ACPI_BATTERY_NUMFILES; ++i)
-		remove_proc_entry(acpi_battery_file[i].name,
-				  acpi_device_dir(device));
-
-	remove_proc_entry(acpi_device_bid(device), acpi_battery_dir);
+	remove_proc_subtree(acpi_device_bid(device), acpi_battery_dir);
 	acpi_device_dir(device) = NULL;
 }
 

commit ec625a37c10c64681c00459912ce7318e133bf7a
Author: Carlo Caione <carlo@endlessm.com>
Date:   Wed Apr 18 14:04:39 2018 +0200

    ACPI / battery: Add quirk to avoid checking for PMIC with native driver
    
    With commit dccfae6d4f4c (ACPI / battery: Add a blacklist with PMIC ACPI
    HIDs with a native battery driver) a blacklist was introduced to avoid
    using the ACPI drivers for the battery when a native PMIC driver was
    already present. While this is in general a good idea (because of broken
    DSDT or proprietary and undocumented ACPI opregions for the ACPI battery
    devices) there are some Cherry Trail devices which use a separate FG
    controller despite the AXP288 having a builtin FG.
    
    The net effect of blacklisting the ACPI drivers is that on these devices
    the battery reporting is broken since the AXP288 PMIC FG bits are not
    actually used on this hardware.
    
    This commit adds a battery_do_not_check_pmic quirk for this and sets
    this on the 2 devices currently known to use a separate FG controller,
    the ECS EF20EA and the Lenovo Ideapad Miix 320.
    
    [hdegoede@redhat.com: Merge the quirk handling and the adding of the DMI
     table entry into 1 commit, add a second DMI entry for the Miix 320.]
    
    Signed-off-by: Carlo Caione <carlo@endlessm.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index c63b6a14ad95..572845fafb00 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -75,6 +75,7 @@ static bool battery_driver_registered;
 static int battery_bix_broken_package;
 static int battery_notification_delay_ms;
 static int battery_ac_is_broken;
+static int battery_check_pmic = 1;
 static unsigned int cache_time = 1000;
 module_param(cache_time, uint, 0644);
 MODULE_PARM_DESC(cache_time, "cache time in milliseconds");
@@ -1354,6 +1355,13 @@ battery_ac_is_broken_quirk(const struct dmi_system_id *d)
 	return 0;
 }
 
+static int __init
+battery_do_not_check_pmic_quirk(const struct dmi_system_id *d)
+{
+	battery_check_pmic = 0;
+	return 0;
+}
+
 static const struct dmi_system_id bat_dmi_table[] __initconst = {
 	{
 		/* NEC LZ750/LS */
@@ -1382,6 +1390,22 @@ static const struct dmi_system_id bat_dmi_table[] __initconst = {
 			DMI_MATCH(DMI_BIOS_DATE, "08/22/2014"),
 		},
 	},
+	{
+		/* ECS EF20EA */
+		.callback = battery_do_not_check_pmic_quirk,
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "EF20EA"),
+		},
+	},
+	{
+		/* Lenovo Ideapad Miix 320 */
+		.callback = battery_do_not_check_pmic_quirk,
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "80XF"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_VERSION, "Lenovo MIIX 320-10ICR"),
+		},
+	},
 	{},
 };
 
@@ -1521,16 +1545,18 @@ static void __init acpi_battery_init_async(void *unused, async_cookie_t cookie)
 	unsigned int i;
 	int result;
 
-	for (i = 0; i < ARRAY_SIZE(acpi_battery_blacklist); i++)
-		if (acpi_dev_present(acpi_battery_blacklist[i], "1", -1)) {
-			pr_info(PREFIX ACPI_BATTERY_DEVICE_NAME
-				": found native %s PMIC, not loading\n",
-				acpi_battery_blacklist[i]);
-			return;
-		}
-
 	dmi_check_system(bat_dmi_table);
 
+	if (battery_check_pmic) {
+		for (i = 0; i < ARRAY_SIZE(acpi_battery_blacklist); i++)
+			if (acpi_dev_present(acpi_battery_blacklist[i], "1", -1)) {
+				pr_info(PREFIX ACPI_BATTERY_DEVICE_NAME
+					": found native %s PMIC, not loading\n",
+					acpi_battery_blacklist[i]);
+				return;
+			}
+	}
+
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	acpi_battery_dir = acpi_lock_battery_dir();
 	if (!acpi_battery_dir)

commit 1b799c5cf031c2b615f4b21150eafde3ff227788
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Apr 12 12:02:00 2018 +0200

    ACPI / battery: Ignore AC state in handle_discharging on systems where it is broken
    
    On some devices the "AC" interface ACPI AML code uses the exact same broken
    logic which is causing the battery code to wrongly report discharging to
    determine the "AC" state. Specifically the ACPI AML code is checking the
    charging status bits of the charger-IC rather then the vbus present or
    power-good status bits.
    
    This makes our workaround for devices which wrongly report discharging when
    plugged into AC while the charge is above the start charging threshold not
    work on these devices.
    
    This commit adds a battery_ac_is_broken flag and when that is set it skips
    the power_supply_is_system_supplied() check in the workaround fixing this.
    
    This flag gets set by a DMI quirk selected by systems where we know the AC
    AML code is broken in this way *and* the rate_now value can be trusted.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index bd36cb5c3fe1..c63b6a14ad95 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -74,6 +74,7 @@ static async_cookie_t async_cookie;
 static bool battery_driver_registered;
 static int battery_bix_broken_package;
 static int battery_notification_delay_ms;
+static int battery_ac_is_broken;
 static unsigned int cache_time = 1000;
 module_param(cache_time, uint, 0644);
 MODULE_PARM_DESC(cache_time, "cache time in milliseconds");
@@ -222,7 +223,8 @@ static int acpi_battery_handle_discharging(struct acpi_battery *battery)
 	 * was above the device's start charging threshold atm the AC adapter
 	 * was plugged in and the device thus did not start a new charge cycle.
 	 */
-	if (power_supply_is_system_supplied() && battery->rate_now == 0)
+	if ((battery_ac_is_broken || power_supply_is_system_supplied()) &&
+	    battery->rate_now == 0)
 		return POWER_SUPPLY_STATUS_NOT_CHARGING;
 
 	return POWER_SUPPLY_STATUS_DISCHARGING;
@@ -1345,6 +1347,13 @@ battery_notification_delay_quirk(const struct dmi_system_id *d)
 	return 0;
 }
 
+static int __init
+battery_ac_is_broken_quirk(const struct dmi_system_id *d)
+{
+	battery_ac_is_broken = 1;
+	return 0;
+}
+
 static const struct dmi_system_id bat_dmi_table[] __initconst = {
 	{
 		/* NEC LZ750/LS */
@@ -1362,6 +1371,17 @@ static const struct dmi_system_id bat_dmi_table[] __initconst = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire V5-573G"),
 		},
 	},
+	{
+		/* Point of View mobii wintab p800w */
+		.callback = battery_ac_is_broken_quirk,
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "AMI Corporation"),
+			DMI_MATCH(DMI_BOARD_NAME, "Aptio CRB"),
+			DMI_MATCH(DMI_BIOS_VERSION, "3BAIR1013"),
+			/* Above matches are too generic, add bios-date match */
+			DMI_MATCH(DMI_BIOS_DATE, "08/22/2014"),
+		},
+	},
 	{},
 };
 

commit 19fffc8450d4378580a8f019b195c4617083176f
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Apr 12 12:01:59 2018 +0200

    ACPI / battery: Add handling for devices which wrongly report discharging state
    
    On quite a few devices the battery code in the ACPI tables is buggy and
    first checks the charging status bits of the charger-IC, and if those
    report not charging it will report discharging, without looking at the
    presence of AC power or at the battery dis(charge) current from the
    fuel-gauge.
    
    This causes the wrong status to be reported for the battery in the
    following quite common scenario:
    
    1) Plug in charger while battery is say half full, battery starts
    charging, charging state bits indicate: pre-charge or fast-charge,
    ACPI reported battery status is ok
    
    2) When fully charged charging state bits indicate: end-of-charge,
    ACPI reported battery status is ok
    
    3) unplug the charger, wait 1 minute, replug. Now the battery voltage is
    still above the start-charging threshold, so the charger will not start
    charging to avoid wrecking the battery by repeatedly recharging the last 1%
    capacity. The charger IC charging state bits now are all 0 (not-charging)
    and the broken ACPI code wrongly translate this to "discharging" and ends
    up setting the ACPI_BATTERY_STATE_DISCHARGING bit in its state field.
    
    Reporting this "not charging" state as discharging is confusing for users,
    making the user think his adapter/power-brick is broken or not properly
    plugged in.
    
    This commit adds a helper for handling the ACPI_BATTERY_STATE_DISCHARGING
    state. This helper checks if we're an AC and the current going out of the
    battery is 0 and in that case reports a status of "not charging" to
    userspace rather then "discharging".
    
    This replaces commit c68f0676ef7d ("ACPI / battery: Add quirk for Asus
    GL502VSK and UX305LA"), a previous fix for this which was reverted.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Daniel Drake <drake@endlessm.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 338432cbef09..bd36cb5c3fe1 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -215,6 +215,19 @@ static bool acpi_battery_is_degraded(struct acpi_battery *battery)
 		battery->full_charge_capacity < battery->design_capacity;
 }
 
+static int acpi_battery_handle_discharging(struct acpi_battery *battery)
+{
+	/*
+	 * Some devices wrongly report discharging if the battery's charge level
+	 * was above the device's start charging threshold atm the AC adapter
+	 * was plugged in and the device thus did not start a new charge cycle.
+	 */
+	if (power_supply_is_system_supplied() && battery->rate_now == 0)
+		return POWER_SUPPLY_STATUS_NOT_CHARGING;
+
+	return POWER_SUPPLY_STATUS_DISCHARGING;
+}
+
 static int acpi_battery_get_property(struct power_supply *psy,
 				     enum power_supply_property psp,
 				     union power_supply_propval *val)
@@ -230,7 +243,7 @@ static int acpi_battery_get_property(struct power_supply *psy,
 	switch (psp) {
 	case POWER_SUPPLY_PROP_STATUS:
 		if (battery->state & ACPI_BATTERY_STATE_DISCHARGING)
-			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+			val->intval = acpi_battery_handle_discharging(battery);
 		else if (battery->state & ACPI_BATTERY_STATE_CHARGING)
 			val->intval = POWER_SUPPLY_STATUS_CHARGING;
 		else if (acpi_battery_is_charged(battery))

commit 91afa07664a8d26f51fb59b13fd5fa3592b728bc
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Apr 12 12:01:58 2018 +0200

    ACPI / battery: Remove initializer for unused ident dmi_system_id
    
    The battery code does not use the dmi_system_id ident member, so there is
    no need to initialize it. This saves us storing the unused strings as
    as const data.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index bdb24d636d9a..338432cbef09 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1334,16 +1334,16 @@ battery_notification_delay_quirk(const struct dmi_system_id *d)
 
 static const struct dmi_system_id bat_dmi_table[] __initconst = {
 	{
+		/* NEC LZ750/LS */
 		.callback = battery_bix_broken_package_quirk,
-		.ident = "NEC LZ750/LS",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "NEC"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "PC-LZ750LS"),
 		},
 	},
 	{
+		/* Acer Aspire V5-573G */
 		.callback = battery_notification_delay_quirk,
-		.ident = "Acer Aspire V5-573G",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire V5-573G"),

commit 0c9ed61bddd27cf95067e17c3d25634e25c4204b
Merge: ae02168d7877 7a4ea10c01cd 4f1c29d0dc7b 66444f460e68
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Apr 2 10:58:13 2018 +0200

    Merge branches 'acpi-battery', 'acpi-doc' and 'acpi-pmic'
    
    * acpi-battery:
      Revert "ACPI: battery: Add the ThinkPad "Not Charging" quirk"
      ACPI: battery: do not export degraded capacity values over 100
      ACPI: battery: make function __battery_hook_unregister() static
      ACPI: battery: Add the ThinkPad "Not Charging" quirk
      thinkpad_acpi: Add support for battery thresholds
      power: add to_power_supply macro to the API
      battery: Add the battery hooking API
    
    * acpi-doc:
      ACPI: sysfs: Update device object sysfs documentation
    
    * acpi-pmic:
      ACPI / PMIC: Replace license boilerplate with SPDX license identifier

commit 82bf43b291888599b4079244d12195d214086fa4
Author: Daniel Drake <drake@endlessm.com>
Date:   Wed Mar 14 16:42:17 2018 +0800

    Revert "ACPI / battery: Add quirk for Asus GL502VSK and UX305LA"
    
    Revert commit c68f0676ef7d ("ACPI / battery: Add quirk for Asus
    GL502VSK and UX305LA") and commit 4446823e2573 ("ACPI / battery: Add
    quirk for Asus UX360UA and UX410UAK").
    
    On many many Asus products, the battery is sometimes reported as
    charging or discharging even when it is full and you are on AC power.
    This change quirked the kernel to avoid advertising the discharging
    state when this happens on 4 laptop models, under the belief that
    this was incorrect information.  I presume it originates from user
    reports who are confused that their battery status icon says that it
    is discharging.
    
    However, the reported information is indeed correct, and the quirk
    approach taken is inadequate and more thought is needed first.
    Specifically:
    
     1. It only quirks discharging state, not charging
    
     2. There are so many different Asus products and DMI naming variants
        within those product families that behave this way; Linux could
        grow to quirk hundreds of products and still not even be close at
        "winning" this battle.
    
     3. Asus previously clarified that this behaviour is intentional. The
        platform will periodically do a partial discharge/charge cycle
        when the battery is full, because this is one way to extend the
        lifetime of the battery (leaving a battery at 100% charge and
        unused will decrease its usable capacity over time).
    
        My understanding is that any decent consumer product will have
        this behaviour, but it appears that Asus is different in that
        they expose this info through ACPI.
    
        However, the behaviour seems correct. The ACPI spec does not
        suggest in that the platform should hide the truth.  It lets you
        report that the battery is full of charge, and discharging, and
        with external power connected; and Asus does this.
    
     4. In terms of not confusing the user, this seems like something that
        could/should be handled by userspace, which can also detect these
        same (accurate) conditions in the general case.
    
    Revert this quirk before it gets included in a release, while we look
    for better approaches.
    
    Signed-off-by: Daniel Drake <drake@endlessm.com>
    Acked-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 7128488a3a72..f2eb6c37ea0a 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -70,7 +70,6 @@ static async_cookie_t async_cookie;
 static bool battery_driver_registered;
 static int battery_bix_broken_package;
 static int battery_notification_delay_ms;
-static int battery_full_discharging;
 static unsigned int cache_time = 1000;
 module_param(cache_time, uint, 0644);
 MODULE_PARM_DESC(cache_time, "cache time in milliseconds");
@@ -215,12 +214,9 @@ static int acpi_battery_get_property(struct power_supply *psy,
 		return -ENODEV;
 	switch (psp) {
 	case POWER_SUPPLY_PROP_STATUS:
-		if (battery->state & ACPI_BATTERY_STATE_DISCHARGING) {
-			if (battery_full_discharging && battery->rate_now == 0)
-				val->intval = POWER_SUPPLY_STATUS_FULL;
-			else
-				val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
-		} else if (battery->state & ACPI_BATTERY_STATE_CHARGING)
+		if (battery->state & ACPI_BATTERY_STATE_DISCHARGING)
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		else if (battery->state & ACPI_BATTERY_STATE_CHARGING)
 			val->intval = POWER_SUPPLY_STATUS_CHARGING;
 		else if (acpi_battery_is_charged(battery))
 			val->intval = POWER_SUPPLY_STATUS_FULL;
@@ -1170,12 +1166,6 @@ battery_notification_delay_quirk(const struct dmi_system_id *d)
 	return 0;
 }
 
-static int __init battery_full_discharging_quirk(const struct dmi_system_id *d)
-{
-	battery_full_discharging = 1;
-	return 0;
-}
-
 static const struct dmi_system_id bat_dmi_table[] __initconst = {
 	{
 		.callback = battery_bix_broken_package_quirk,
@@ -1193,38 +1183,6 @@ static const struct dmi_system_id bat_dmi_table[] __initconst = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire V5-573G"),
 		},
 	},
-	{
-		.callback = battery_full_discharging_quirk,
-		.ident = "ASUS GL502VSK",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "GL502VSK"),
-		},
-	},
-	{
-		.callback = battery_full_discharging_quirk,
-		.ident = "ASUS UX305LA",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "UX305LA"),
-		},
-	},
-	{
-		.callback = battery_full_discharging_quirk,
-		.ident = "ASUS UX360UA",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "UX360UA"),
-		},
-	},
-	{
-		.callback = battery_full_discharging_quirk,
-		.ident = "ASUS UX410UAK",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "UX410UAK"),
-		},
-	},
 	{},
 };
 

commit 7a4ea10c01cdda3d66aa98af258f150d863aee24
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Mar 13 10:07:49 2018 +0100

    Revert "ACPI: battery: Add the ThinkPad "Not Charging" quirk"
    
    Revert commit 91eea70e5e5c (ACPI: battery: Add the ThinkPad "Not
    Charging" quirk) as it is reported to cause user space to misbehave.
    
    That appears to be due to bugs in user space, so this commit will go
    in again after the bugs have been fixed and the fixes have been
    delivered to users.
    
    Link: https://marc.info/?l=linux-acpi&m=152089585129589&w=2
    Reported-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 96ed134bacf8..c88d41b04789 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -74,7 +74,6 @@ static async_cookie_t async_cookie;
 static bool battery_driver_registered;
 static int battery_bix_broken_package;
 static int battery_notification_delay_ms;
-static int battery_quirk_notcharging;
 static int battery_full_discharging;
 static unsigned int cache_time = 1000;
 module_param(cache_time, uint, 0644);
@@ -240,8 +239,6 @@ static int acpi_battery_get_property(struct power_supply *psy,
 			val->intval = POWER_SUPPLY_STATUS_CHARGING;
 		else if (acpi_battery_is_charged(battery))
 			val->intval = POWER_SUPPLY_STATUS_FULL;
-		else if (battery_quirk_notcharging)
-			val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
 		else
 			val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
 		break;
@@ -728,7 +725,7 @@ EXPORT_SYMBOL_GPL(battery_hook_register);
  * This function gets called right after the battery sysfs
  * attributes have been added, so that the drivers that
  * define custom sysfs attributes can add their own.
- */
+*/
 static void battery_hook_add_battery(struct acpi_battery *battery)
 {
 	struct acpi_battery_hook *hook_node;
@@ -1345,12 +1342,6 @@ static int __init battery_full_discharging_quirk(const struct dmi_system_id *d)
 	return 0;
 }
 
-static int __init battery_quirk_not_charging(const struct dmi_system_id *d)
-{
-	battery_quirk_notcharging = 1;
-	return 0;
-}
-
 static const struct dmi_system_id bat_dmi_table[] __initconst = {
 	{
 		.callback = battery_bix_broken_package_quirk,
@@ -1400,19 +1391,6 @@ static const struct dmi_system_id bat_dmi_table[] __initconst = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "UX410UAK"),
 		},
 	},
-	{
-		/*
-		 * On Lenovo ThinkPads the BIOS specification defines
-		 * a state when the bits for charging and discharging
-		 * are both set to 0. That state is "Not Charging".
-		 */
-		.callback = battery_quirk_not_charging,
-		.ident = "Lenovo ThinkPad",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-			DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad"),
-		},
-	},
 	{},
 };
 

commit a20136a67a995cd5b74e8c0fcb3b2f2e5b2848dd
Author: Laszlo Toth <laszlth@gmail.com>
Date:   Sat Feb 24 10:20:15 2018 +0100

    ACPI: battery: do not export degraded capacity values over 100
    
    With a degraded battery, full_charge_capacity can be less
    than design_capacity, however it's not sure that capacity_now's
    max will follow.
    
    Example from an affected machine:
    /sys/class/power_supply/BAT0/charge_full        -> 4290000
    /sys/class/power_supply/BAT0/charge_full_design -> 5900000
    /sys/class/power_supply/BAT0/charge_now         -> 5900000
    /sys/class/power_supply/BAT0/capacity           -> 137
    
    The battery is a degraded one with a full charge, and
    charge_now is the value of charge_full_design instead of
    charge_full.
    
    Added a new quirk to test and correct this, and
    a new function to check if the battery is a degraded one
    or not. This keeps the possibility to be over 100 if
    it's really the case.
    
    Signed-off-by: Laszlo Toth <laszlth@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index b4580b2e8706..96ed134bacf8 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -121,6 +121,10 @@ enum {
 	   post-1.29 BIOS), but as of Nov. 2012, no such update is
 	   available for the 2010 models.  */
 	ACPI_BATTERY_QUIRK_THINKPAD_MAH,
+	/* for batteries reporting current capacity with design capacity
+	 * on a full charge, but showing degradation in full charge cap.
+	 */
+	ACPI_BATTERY_QUIRK_DEGRADED_FULL_CHARGE,
 };
 
 struct acpi_battery {
@@ -207,6 +211,12 @@ static int acpi_battery_is_charged(struct acpi_battery *battery)
 	return 0;
 }
 
+static bool acpi_battery_is_degraded(struct acpi_battery *battery)
+{
+	return battery->full_charge_capacity && battery->design_capacity &&
+		battery->full_charge_capacity < battery->design_capacity;
+}
+
 static int acpi_battery_get_property(struct power_supply *psy,
 				     enum power_supply_property psp,
 				     union power_supply_propval *val)
@@ -483,6 +493,10 @@ static int extract_battery_info(const int use_bix,
 		   it's impossible to tell if they would need an adjustment
 		   or not if their values were higher.  */
 	}
+	if (test_bit(ACPI_BATTERY_QUIRK_DEGRADED_FULL_CHARGE, &battery->flags) &&
+	    battery->capacity_now > battery->full_charge_capacity)
+		battery->capacity_now = battery->full_charge_capacity;
+
 	return result;
 }
 
@@ -575,6 +589,10 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 		battery->capacity_now = battery->capacity_now *
 		    10000 / battery->design_voltage;
 	}
+	if (test_bit(ACPI_BATTERY_QUIRK_DEGRADED_FULL_CHARGE, &battery->flags) &&
+	    battery->capacity_now > battery->full_charge_capacity)
+		battery->capacity_now = battery->full_charge_capacity;
+
 	return result;
 }
 
@@ -885,6 +903,15 @@ static void acpi_battery_quirks(struct acpi_battery *battery)
 			}
 		}
 	}
+
+	if (test_bit(ACPI_BATTERY_QUIRK_DEGRADED_FULL_CHARGE, &battery->flags))
+		return;
+
+	if (acpi_battery_is_degraded(battery) &&
+	    battery->capacity_now > battery->full_charge_capacity) {
+		set_bit(ACPI_BATTERY_QUIRK_DEGRADED_FULL_CHARGE, &battery->flags);
+		battery->capacity_now = battery->full_charge_capacity;
+	}
 }
 
 static int acpi_battery_update(struct acpi_battery *battery, bool resume)

commit 514bcc5dfa69d64f7772cb6442721b9d1b83504d
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Feb 23 16:32:55 2018 +0000

    ACPI: battery: make function __battery_hook_unregister() static
    
    The function __battery_hook_unregister is local to the source and does
    not need to be in global scope, so make it static.
    
    Cleans up sparse warning:
    drivers/acpi/battery.c:654:6: warning: symbol '__battery_hook_unregister'
    was not declared. Should it be static?
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index cfdef4c1d097..b4580b2e8706 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -651,7 +651,7 @@ static LIST_HEAD(acpi_battery_list);
 static LIST_HEAD(battery_hook_list);
 static DEFINE_MUTEX(hook_mutex);
 
-void __battery_hook_unregister(struct acpi_battery_hook *hook, int lock)
+static void __battery_hook_unregister(struct acpi_battery_hook *hook, int lock)
 {
 	struct acpi_battery *battery;
 	/*

commit 91eea70e5e5ce12eb1c7cd922e561fab43e201bd
Author: Ognjen Galic <smclt30p@gmail.com>
Date:   Wed Feb 7 15:59:36 2018 +0100

    ACPI: battery: Add the ThinkPad "Not Charging" quirk
    
    The EC/ACPI firmware on Lenovo ThinkPads used to report a status
    of "Unknown" when the battery is between the charge start and
    charge stop thresholds. On Windows, it reports "Not Charging"
    so the quirk has been added to also report correctly.
    
    Now the "status" attribute returns "Not Charging" when the
    battery on ThinkPads is not physicaly charging.
    
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Ognjen Galic <smclt30p@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index f14a2bb1f7cd..cfdef4c1d097 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -74,6 +74,7 @@ static async_cookie_t async_cookie;
 static bool battery_driver_registered;
 static int battery_bix_broken_package;
 static int battery_notification_delay_ms;
+static int battery_quirk_notcharging;
 static int battery_full_discharging;
 static unsigned int cache_time = 1000;
 module_param(cache_time, uint, 0644);
@@ -229,6 +230,8 @@ static int acpi_battery_get_property(struct power_supply *psy,
 			val->intval = POWER_SUPPLY_STATUS_CHARGING;
 		else if (acpi_battery_is_charged(battery))
 			val->intval = POWER_SUPPLY_STATUS_FULL;
+		else if (battery_quirk_notcharging)
+			val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
 		else
 			val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
 		break;
@@ -707,7 +710,7 @@ EXPORT_SYMBOL_GPL(battery_hook_register);
  * This function gets called right after the battery sysfs
  * attributes have been added, so that the drivers that
  * define custom sysfs attributes can add their own.
-*/
+ */
 static void battery_hook_add_battery(struct acpi_battery *battery)
 {
 	struct acpi_battery_hook *hook_node;
@@ -1315,6 +1318,12 @@ static int __init battery_full_discharging_quirk(const struct dmi_system_id *d)
 	return 0;
 }
 
+static int __init battery_quirk_not_charging(const struct dmi_system_id *d)
+{
+	battery_quirk_notcharging = 1;
+	return 0;
+}
+
 static const struct dmi_system_id bat_dmi_table[] __initconst = {
 	{
 		.callback = battery_bix_broken_package_quirk,
@@ -1364,6 +1373,19 @@ static const struct dmi_system_id bat_dmi_table[] __initconst = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "UX410UAK"),
 		},
 	},
+	{
+		/*
+		 * On Lenovo ThinkPads the BIOS specification defines
+		 * a state when the bits for charging and discharging
+		 * are both set to 0. That state is "Not Charging".
+		 */
+		.callback = battery_quirk_not_charging,
+		.ident = "Lenovo ThinkPad",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+			DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad"),
+		},
+	},
 	{},
 };
 

commit fa93854f7a7ed63d054405bf3779247d5300edd3
Author: Ognjen Galic <smclt30p@gmail.com>
Date:   Wed Feb 7 15:58:13 2018 +0100

    battery: Add the battery hooking API
    
    This is a patch that implements a generic hooking API for the
    generic ACPI battery driver.
    
    With this new generic API, drivers can expose platform specific
    behaviour via sysfs attributes in /sys/class/power_supply/BATn/
    in a generic way.
    
    A perfect example of the need for this API are Lenovo ThinkPads.
    
    Lenovo ThinkPads have a ACPI extension that allows the setting of
    start and stop charge thresholds in the EC and battery firmware
    via ACPI. The thinkpad_acpi module can use this API to expose
    sysfs attributes that it controls inside the ACPI battery driver
    sysfs tree, under /sys/class/power_supply/BATN/.
    
    The file drivers/acpi/battery.h has been moved to
    include/acpi/battery.h and the includes inside ac.c, sbs.c, and
    battery.c have been adjusted to reflect that.
    
    When drivers hooks into the API, the API calls add_battery() for
    each battery in the system that passes it a acpi_battery
    struct. Then, the drivers can use device_create_file() to create
    new sysfs attributes with that struct and identify the batteries
    for per-battery attributes.
    
    Signed-off-by: Ognjen Galic <smclt30p@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 7128488a3a72..f14a2bb1f7cd 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -21,8 +21,12 @@
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/kernel.h>
+#include <linux/list.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/jiffies.h>
@@ -42,7 +46,7 @@
 #include <linux/acpi.h>
 #include <linux/power_supply.h>
 
-#include "battery.h"
+#include <acpi/battery.h>
 
 #define PREFIX "ACPI: "
 
@@ -125,6 +129,7 @@ struct acpi_battery {
 	struct power_supply_desc bat_desc;
 	struct acpi_device *device;
 	struct notifier_block pm_nb;
+	struct list_head list;
 	unsigned long update_time;
 	int revision;
 	int rate_now;
@@ -630,6 +635,139 @@ static const struct device_attribute alarm_attr = {
 	.store = acpi_battery_alarm_store,
 };
 
+/*
+ * The Battery Hooking API
+ *
+ * This API is used inside other drivers that need to expose
+ * platform-specific behaviour within the generic driver in a
+ * generic way.
+ *
+ */
+
+static LIST_HEAD(acpi_battery_list);
+static LIST_HEAD(battery_hook_list);
+static DEFINE_MUTEX(hook_mutex);
+
+void __battery_hook_unregister(struct acpi_battery_hook *hook, int lock)
+{
+	struct acpi_battery *battery;
+	/*
+	 * In order to remove a hook, we first need to
+	 * de-register all the batteries that are registered.
+	 */
+	if (lock)
+		mutex_lock(&hook_mutex);
+	list_for_each_entry(battery, &acpi_battery_list, list) {
+		hook->remove_battery(battery->bat);
+	}
+	list_del(&hook->list);
+	if (lock)
+		mutex_unlock(&hook_mutex);
+	pr_info("extension unregistered: %s\n", hook->name);
+}
+
+void battery_hook_unregister(struct acpi_battery_hook *hook)
+{
+	__battery_hook_unregister(hook, 1);
+}
+EXPORT_SYMBOL_GPL(battery_hook_unregister);
+
+void battery_hook_register(struct acpi_battery_hook *hook)
+{
+	struct acpi_battery *battery;
+
+	mutex_lock(&hook_mutex);
+	INIT_LIST_HEAD(&hook->list);
+	list_add(&hook->list, &battery_hook_list);
+	/*
+	 * Now that the driver is registered, we need
+	 * to notify the hook that a battery is available
+	 * for each battery, so that the driver may add
+	 * its attributes.
+	 */
+	list_for_each_entry(battery, &acpi_battery_list, list) {
+		if (hook->add_battery(battery->bat)) {
+			/*
+			 * If a add-battery returns non-zero,
+			 * the registration of the extension has failed,
+			 * and we will not add it to the list of loaded
+			 * hooks.
+			 */
+			pr_err("extension failed to load: %s", hook->name);
+			__battery_hook_unregister(hook, 0);
+			return;
+		}
+	}
+	pr_info("new extension: %s\n", hook->name);
+	mutex_unlock(&hook_mutex);
+}
+EXPORT_SYMBOL_GPL(battery_hook_register);
+
+/*
+ * This function gets called right after the battery sysfs
+ * attributes have been added, so that the drivers that
+ * define custom sysfs attributes can add their own.
+*/
+static void battery_hook_add_battery(struct acpi_battery *battery)
+{
+	struct acpi_battery_hook *hook_node;
+
+	mutex_lock(&hook_mutex);
+	INIT_LIST_HEAD(&battery->list);
+	list_add(&battery->list, &acpi_battery_list);
+	/*
+	 * Since we added a new battery to the list, we need to
+	 * iterate over the hooks and call add_battery for each
+	 * hook that was registered. This usually happens
+	 * when a battery gets hotplugged or initialized
+	 * during the battery module initialization.
+	 */
+	list_for_each_entry(hook_node, &battery_hook_list, list) {
+		if (hook_node->add_battery(battery->bat)) {
+			/*
+			 * The notification of the extensions has failed, to
+			 * prevent further errors we will unload the extension.
+			 */
+			__battery_hook_unregister(hook_node, 0);
+			pr_err("error in extension, unloading: %s",
+					hook_node->name);
+		}
+	}
+	mutex_unlock(&hook_mutex);
+}
+
+static void battery_hook_remove_battery(struct acpi_battery *battery)
+{
+	struct acpi_battery_hook *hook;
+
+	mutex_lock(&hook_mutex);
+	/*
+	 * Before removing the hook, we need to remove all
+	 * custom attributes from the battery.
+	 */
+	list_for_each_entry(hook, &battery_hook_list, list) {
+		hook->remove_battery(battery->bat);
+	}
+	/* Then, just remove the battery from the list */
+	list_del(&battery->list);
+	mutex_unlock(&hook_mutex);
+}
+
+static void __exit battery_hook_exit(void)
+{
+	struct acpi_battery_hook *hook;
+	struct acpi_battery_hook *ptr;
+	/*
+	 * At this point, the acpi_bus_unregister_driver()
+	 * has called remove for all batteries. We just
+	 * need to remove the hooks.
+	 */
+	list_for_each_entry_safe(hook, ptr, &battery_hook_list, list) {
+		__battery_hook_unregister(hook, 1);
+	}
+	mutex_destroy(&hook_mutex);
+}
+
 static int sysfs_add_battery(struct acpi_battery *battery)
 {
 	struct power_supply_config psy_cfg = { .drv_data = battery, };
@@ -657,6 +795,7 @@ static int sysfs_add_battery(struct acpi_battery *battery)
 		battery->bat = NULL;
 		return result;
 	}
+	battery_hook_add_battery(battery);
 	return device_create_file(&battery->bat->dev, &alarm_attr);
 }
 
@@ -667,7 +806,7 @@ static void sysfs_remove_battery(struct acpi_battery *battery)
 		mutex_unlock(&battery->sysfs_lock);
 		return;
 	}
-
+	battery_hook_remove_battery(battery);
 	device_remove_file(&battery->bat->dev, &alarm_attr);
 	power_supply_unregister(battery->bat);
 	battery->bat = NULL;
@@ -1399,8 +1538,10 @@ static int __init acpi_battery_init(void)
 static void __exit acpi_battery_exit(void)
 {
 	async_synchronize_cookie(async_cookie + 1);
-	if (battery_driver_registered)
+	if (battery_driver_registered) {
 		acpi_bus_unregister_driver(&acpi_battery_driver);
+		battery_hook_exit();
+	}
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	if (acpi_battery_dir)
 		acpi_unlock_battery_dir(acpi_battery_dir);

commit 4446823e2573e97b26f0534ff8db9e9c4cb65840
Author: Kai Heng Feng <kai.heng.feng@canonical.com>
Date:   Mon Jan 29 13:40:36 2018 +0800

    ACPI / battery: Add quirk for Asus UX360UA and UX410UAK
    
    Same issue as other Asus laptops, ACPI incorrectly reports discharging
    when battery is full and AC is plugged.
    
    Use the same battery quirk can workaround the issue.
    
    Link: https://bugs.launchpad.net/bugs/1661876
    Link: https://bugs.launchpad.net/bugs/1745032
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 19bc440820e6..7128488a3a72 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1209,6 +1209,22 @@ static const struct dmi_system_id bat_dmi_table[] __initconst = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "UX305LA"),
 		},
 	},
+	{
+		.callback = battery_full_discharging_quirk,
+		.ident = "ASUS UX360UA",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "UX360UA"),
+		},
+	},
+	{
+		.callback = battery_full_discharging_quirk,
+		.ident = "ASUS UX410UAK",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "UX410UAK"),
+		},
+	},
 	{},
 };
 

commit c68f0676ef7df08d52a65031db3e0ba017dbfd89
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Tue Nov 21 03:33:06 2017 -0500

    ACPI / battery: Add quirk for Asus GL502VSK and UX305LA
    
    On Asus GL502VSK and UX305LA, ACPI incorrectly reports discharging when
    battery is full and AC is plugged.
    
    However rate_now is correct under this circumstance, hence we can use
    "rate_now == 0" as a predicate to report battery full status correctly.
    
    Link: https://bugs.launchpad.net/bugs/1482390
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index f2eb6c37ea0a..19bc440820e6 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -70,6 +70,7 @@ static async_cookie_t async_cookie;
 static bool battery_driver_registered;
 static int battery_bix_broken_package;
 static int battery_notification_delay_ms;
+static int battery_full_discharging;
 static unsigned int cache_time = 1000;
 module_param(cache_time, uint, 0644);
 MODULE_PARM_DESC(cache_time, "cache time in milliseconds");
@@ -214,9 +215,12 @@ static int acpi_battery_get_property(struct power_supply *psy,
 		return -ENODEV;
 	switch (psp) {
 	case POWER_SUPPLY_PROP_STATUS:
-		if (battery->state & ACPI_BATTERY_STATE_DISCHARGING)
-			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
-		else if (battery->state & ACPI_BATTERY_STATE_CHARGING)
+		if (battery->state & ACPI_BATTERY_STATE_DISCHARGING) {
+			if (battery_full_discharging && battery->rate_now == 0)
+				val->intval = POWER_SUPPLY_STATUS_FULL;
+			else
+				val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		} else if (battery->state & ACPI_BATTERY_STATE_CHARGING)
 			val->intval = POWER_SUPPLY_STATUS_CHARGING;
 		else if (acpi_battery_is_charged(battery))
 			val->intval = POWER_SUPPLY_STATUS_FULL;
@@ -1166,6 +1170,12 @@ battery_notification_delay_quirk(const struct dmi_system_id *d)
 	return 0;
 }
 
+static int __init battery_full_discharging_quirk(const struct dmi_system_id *d)
+{
+	battery_full_discharging = 1;
+	return 0;
+}
+
 static const struct dmi_system_id bat_dmi_table[] __initconst = {
 	{
 		.callback = battery_bix_broken_package_quirk,
@@ -1183,6 +1193,22 @@ static const struct dmi_system_id bat_dmi_table[] __initconst = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire V5-573G"),
 		},
 	},
+	{
+		.callback = battery_full_discharging_quirk,
+		.ident = "ASUS GL502VSK",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "GL502VSK"),
+		},
+	},
+	{
+		.callback = battery_full_discharging_quirk,
+		.ident = "ASUS UX305LA",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "UX305LA"),
+		},
+	},
 	{},
 };
 

commit 6993ce46c910ec83b4a7f064bbf76f254217019c
Author: Bjrn Mork <bjorn@mork.no>
Date:   Tue Dec 5 18:46:39 2017 +0100

    ACPI: battery: Drop redundant test for failure
    
    Merging the two adjacent conditionally built blocks makes the code
    a lot more readable.  And as a bonus, we drop a duplicate test when
    CONFIG_ACPI_PROCFS_POWER is undefined.
    
    Signed-off-by: Bjrn Mork <bjorn@mork.no>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 13e7b56e33ae..f2eb6c37ea0a 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1237,13 +1237,11 @@ static int acpi_battery_add(struct acpi_device *device)
 
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	result = acpi_battery_add_fs(device);
-#endif
 	if (result) {
-#ifdef CONFIG_ACPI_PROCFS_POWER
 		acpi_battery_remove_fs(device);
-#endif
 		goto fail;
 	}
+#endif
 
 	printk(KERN_INFO PREFIX "%s Slot [%s] (battery %s)\n",
 		ACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),

commit 82d2b610586763f21f8f6e1f8c163c1f14b94e1c
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Mon Aug 21 17:13:07 2017 +0530

    ACPI: make device_attribute const
    
    Make these const as they are only passed as an argument to the function
    device_create_file and device_remove_file and the corresponding
    arguments are of type const.
    Done using Coccinelle
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 1cbb88d938e5..13e7b56e33ae 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -620,7 +620,7 @@ static ssize_t acpi_battery_alarm_store(struct device *dev,
 	return count;
 }
 
-static struct device_attribute alarm_attr = {
+static const struct device_attribute alarm_attr = {
 	.attr = {.name = "alarm", .mode = 0644},
 	.show = acpi_battery_alarm_show,
 	.store = acpi_battery_alarm_store,

commit 33e4f80ee69b5168badf37edbfed796eb48434b9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 12 22:56:34 2017 +0200

    ACPI / PM: Ignore spurious SCI wakeups from suspend-to-idle
    
    The ACPI SCI (System Control Interrupt) is set up as a wakeup IRQ
    during suspend-to-idle transitions and, consequently, any events
    signaled through it wake up the system from that state.  However,
    on some systems some of the events signaled via the ACPI SCI while
    suspended to idle should not cause the system to wake up.  In fact,
    quite often they should just be discarded.
    
    Arguably, systems should not resume entirely on such events, but in
    order to decide which events really should cause the system to resume
    and which are spurious, it is necessary to resume up to the point
    when ACPI SCIs are actually handled and processed, which is after
    executing dpm_resume_noirq() in the system resume path.
    
    For this reasons, add a loop around freeze_enter() in which the
    platforms can process events signaled via multiplexed IRQ lines
    like the ACPI SCI and add suspend-to-idle hooks that can be
    used for this purpose to struct platform_freeze_ops.
    
    In the ACPI case, the ->wake hook is used for checking if the SCI
    has triggered while suspended and deferring the interrupt-induced
    system wakeup until the events signaled through it are actually
    processed sufficiently to decide whether or not the system should
    resume.  In turn, the ->sync hook allows all of the relevant event
    queues to be flushed so as to prevent events from being missed due
    to race conditions.
    
    In addition to that, some ACPI code processing wakeup events needs
    to be modified to use the "hard" version of wakeup triggers, so that
    it will cause a system resume to happen on device-induced wakeup
    events even if the "soft" mechanism to prevent the system from
    suspending is not enabled.  However, to preserve the existing
    behavior with respect to suspend-to-RAM, this only is done in
    the suspend-to-idle case and only if an SCI has occurred while
    suspended.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index d42eeef9d928..1cbb88d938e5 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -782,7 +782,7 @@ static int acpi_battery_update(struct acpi_battery *battery, bool resume)
 	if ((battery->state & ACPI_BATTERY_STATE_CRITICAL) ||
 	    (test_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags) &&
             (battery->capacity_now <= battery->alarm)))
-		pm_wakeup_event(&battery->device->dev, 0);
+		acpi_pm_wakeup_event(&battery->device->dev);
 
 	return result;
 }

commit fbd78afe34d9cc3a86aff7cc214d9f06e815e63e
Merge: 3c2993b8c614 57caf4ec2b8b f3b7eaae1b35
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 9 01:25:16 2017 +0200

    Merge branches 'intel_pstate' and 'pm-sleep'
    
    * intel_pstate:
      cpufreq: intel_pstate: Avoid division by 0 in min_perf_pct_min()
    
    * pm-sleep:
      Revert "ACPI / sleep: Ignore spurious SCI wakeups from suspend-to-idle"

commit f3b7eaae1b35eb8077610eb7c7db042c9b0645e1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 7 00:57:37 2017 +0200

    Revert "ACPI / sleep: Ignore spurious SCI wakeups from suspend-to-idle"
    
    Revert commit eed4d47efe95 (ACPI / sleep: Ignore spurious SCI wakeups
    from suspend-to-idle) as it turned out to be premature and triggered
    a number of different issues on various systems.
    
    That includes, but is not limited to, premature suspend-to-RAM aborts
    on Dell XPS 13 (9343) reported by Dominik.
    
    The issue the commit in question attempted to address is real and
    will need to be taken care of going forward, but evidently more work
    is needed for this purpose.
    
    Reported-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 83ab17e4a795..4ef1e4624b2b 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -776,7 +776,7 @@ static int acpi_battery_update(struct acpi_battery *battery, bool resume)
 	if ((battery->state & ACPI_BATTERY_STATE_CRITICAL) ||
 	    (test_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags) &&
             (battery->capacity_now <= battery->alarm)))
-		pm_wakeup_hard_event(&battery->device->dev);
+		pm_wakeup_event(&battery->device->dev, 0);
 
 	return result;
 }

commit 80449d89d4d6d0af4d6d310597e0f4a3fe0c08a9
Merge: 08be881064da 5e68ebd0ac48 1b2e87687d3f eed4d47efe95 4486740da2e1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue May 9 23:21:46 2017 +0200

    Merge branches 'pm-domains', 'pm-cpuidle', 'pm-sleep' and 'powercap'
    
    * pm-domains:
      PM / Domains: Add DT file to MAINTAINERS
      PM / Domains: Fix DT example
    
    * pm-cpuidle:
      x86/intel_idle: add Gemini Lake support
      cpuidle: check dev before usage in cpuidle_use_deepest_state()
    
    * pm-sleep:
      ACPI / sleep: Ignore spurious SCI wakeups from suspend-to-idle
      PM / wakeup: Integrate mechanism to abort transitions in progress
    
    * powercap:
      powercap: intel_rapl: Add support for Gemini Lake

commit eed4d47efe9508b855b09754cf6de4325d8a2f0d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Apr 26 23:23:03 2017 +0200

    ACPI / sleep: Ignore spurious SCI wakeups from suspend-to-idle
    
    The ACPI SCI (System Control Interrupt) is set up as a wakeup IRQ
    during suspend-to-idle transitions and, consequently, any events
    signaled through it wake up the system from that state.  However,
    on some systems some of the events signaled via the ACPI SCI while
    suspended to idle should not cause the system to wake up.  In fact,
    quite often they should just be discarded.
    
    Arguably, systems should not resume entirely on such events, but in
    order to decide which events really should cause the system to resume
    and which are spurious, it is necessary to resume up to the point
    when ACPI SCIs are actually handled and processed, which is after
    executing dpm_resume_noirq() in the system resume path.
    
    For this reasons, add a loop around freeze_enter() in which the
    platforms can process events signaled via multiplexed IRQ lines
    like the ACPI SCI and add suspend-to-idle hooks that can be
    used for this purpose to struct platform_freeze_ops.
    
    In the ACPI case, the ->wake hook is used for checking if the SCI
    has triggered while suspended and deferring the interrupt-induced
    system wakeup until the events signaled through it are actually
    processed sufficiently to decide whether or not the system should
    resume.  In turn, the ->sync hook allows all of the relevant event
    queues to be flushed so as to prevent events from being missed due
    to race conditions.
    
    In addition to that, some ACPI code processing wakeup events needs
    to be modified to use the "hard" version of wakeup triggers, so that
    it will cause a system resume to happen on device-induced wakeup
    events even if the "soft" mechanism to prevent the system from
    suspending is not enabled (that also helps to catch device-induced
    wakeup events occurring during suspend transitions in progress).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 4ef1e4624b2b..83ab17e4a795 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -776,7 +776,7 @@ static int acpi_battery_update(struct acpi_battery *battery, bool resume)
 	if ((battery->state & ACPI_BATTERY_STATE_CRITICAL) ||
 	    (test_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags) &&
             (battery->capacity_now <= battery->alarm)))
-		pm_wakeup_event(&battery->device->dev, 0);
+		pm_wakeup_hard_event(&battery->device->dev);
 
 	return result;
 }

commit dccfae6d4f4c2cfa1fdc3bf55755fcad02184b99
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Apr 19 14:02:10 2017 +0200

    ACPI / battery: Add a blacklist with PMIC ACPI HIDs with a native battery driver
    
    On some systems we have a native PMIC driver which provides battery
    monitoring, while the ACPI battery driver is broken on these systems
    due to bad DSDTs or because we do not support the proprietary and
    undocumented ACPI opregions these ACPI battery devices rely on
    (e.g. BMOP opregion).
    
    This leads to there being 2 battery power_supply-s registed like this:
    
    ~$ acpi
    Battery 0: Charging, 84%, 00:49:39 until charged
    Battery 1: Unknown, 0%, rate information unavailable
    
    Even if the ACPI battery where to function fine (which on systems
    where we have a native PMIC driver it often doesn't) we still do not
    want to export the same battery to userspace twice.
    
    This commit adds a blacklist with PMIC ACPI HIDs for which we've a
    native battery driver and makes the ACPI battery driver not register
    itself when a PMIC on this list is present.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=194811
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index b35fca478097..d42eeef9d928 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -94,6 +94,11 @@ static const struct acpi_device_id battery_device_ids[] = {
 
 MODULE_DEVICE_TABLE(acpi, battery_device_ids);
 
+/* Lists of PMIC ACPI HIDs with an (often better) native battery driver */
+static const char * const acpi_battery_blacklist[] = {
+	"INT33F4", /* X-Powers AXP288 PMIC */
+};
+
 enum {
 	ACPI_BATTERY_ALARM_PRESENT,
 	ACPI_BATTERY_XINFO_PRESENT,
@@ -1316,8 +1321,17 @@ static struct acpi_driver acpi_battery_driver = {
 
 static void __init acpi_battery_init_async(void *unused, async_cookie_t cookie)
 {
+	unsigned int i;
 	int result;
 
+	for (i = 0; i < ARRAY_SIZE(acpi_battery_blacklist); i++)
+		if (acpi_dev_present(acpi_battery_blacklist[i], "1", -1)) {
+			pr_info(PREFIX ACPI_BATTERY_DEVICE_NAME
+				": found native %s PMIC, not loading\n",
+				acpi_battery_blacklist[i]);
+			return;
+		}
+
 	dmi_check_system(bat_dmi_table);
 
 #ifdef CONFIG_ACPI_PROCFS_POWER

commit bc39fbcf9c782970263bdc5b428e4a755db16efb
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Apr 19 14:02:09 2017 +0200

    ACPI / battery: Fix acpi_battery_exit on acpi_battery_init_async errors
    
    The acpi_lock_battery_dir() / acpi_bus_register_driver() calls in
    acpi_battery_init_async() may fail.
    
    Check that they succeeded before undoing them.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 4ef1e4624b2b..b35fca478097 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -67,6 +67,7 @@ MODULE_DESCRIPTION("ACPI Battery Driver");
 MODULE_LICENSE("GPL");
 
 static async_cookie_t async_cookie;
+static bool battery_driver_registered;
 static int battery_bix_broken_package;
 static int battery_notification_delay_ms;
 static unsigned int cache_time = 1000;
@@ -1329,6 +1330,7 @@ static void __init acpi_battery_init_async(void *unused, async_cookie_t cookie)
 	if (result < 0)
 		acpi_unlock_battery_dir(acpi_battery_dir);
 #endif
+	battery_driver_registered = (result == 0);
 }
 
 static int __init acpi_battery_init(void)
@@ -1343,9 +1345,11 @@ static int __init acpi_battery_init(void)
 static void __exit acpi_battery_exit(void)
 {
 	async_synchronize_cookie(async_cookie + 1);
-	acpi_bus_unregister_driver(&acpi_battery_driver);
+	if (battery_driver_registered)
+		acpi_bus_unregister_driver(&acpi_battery_driver);
 #ifdef CONFIG_ACPI_PROCFS_POWER
-	acpi_unlock_battery_dir(acpi_battery_dir);
+	if (acpi_battery_dir)
+		acpi_unlock_battery_dir(acpi_battery_dir);
 #endif
 }
 

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 05fe9ebfb9b5..4ef1e4624b2b 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -36,7 +36,7 @@
 #ifdef CONFIG_ACPI_PROCFS_POWER
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #endif
 
 #include <linux/acpi.h>

commit 2d09af4a88d99a8dd0429263451b7b88e6d92738
Author: Dave Lambley <linux@davel.me.uk>
Date:   Fri Nov 4 01:05:40 2016 +0000

    ACPI / battery: If _BIX fails, retry with _BIF
    
    The Lenovo Yoga 300 laptop's firmware advertises that it provides the _BIX
    the method to retrieve battery information. Unfortunately (some versions
    of?) the implementation return with an error.
    
    [   21.712228] ACPI Exception: AE_AML_PACKAGE_LIMIT, Index (0x000000010) is beyond end of object (length 0xD) (20160422/exoparg2-427)
    [   21.712244] ACPI Error: Method parse/execution failed [\_SB.PCI0.LPCB.H_EC.BAT1._BIX] (Node ffff95f8ff0b20f0), AE_AML_PACKAGE_LIMIT (20160422/psparse-542)
    
    The _BIF method does succeed and returns convincing data. We detect _BIX
    failing and automatically retry with _BIF.
    
    Signed-off-by: Dave Lambley <linux@davel.me.uk>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 93ecae55fe6a..05fe9ebfb9b5 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -430,39 +430,24 @@ static int acpi_battery_get_status(struct acpi_battery *battery)
 	return 0;
 }
 
-static int acpi_battery_get_info(struct acpi_battery *battery)
+
+static int extract_battery_info(const int use_bix,
+			 struct acpi_battery *battery,
+			 const struct acpi_buffer *buffer)
 {
 	int result = -EFAULT;
-	acpi_status status = 0;
-	char *name = test_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags) ?
-			"_BIX" : "_BIF";
-
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 
-	if (!acpi_battery_present(battery))
-		return 0;
-	mutex_lock(&battery->lock);
-	status = acpi_evaluate_object(battery->device->handle, name,
-						NULL, &buffer);
-	mutex_unlock(&battery->lock);
-
-	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, status, "Evaluating %s", name));
-		return -ENODEV;
-	}
-
-	if (battery_bix_broken_package)
-		result = extract_package(battery, buffer.pointer,
+	if (use_bix && battery_bix_broken_package)
+		result = extract_package(battery, buffer->pointer,
 				extended_info_offsets + 1,
 				ARRAY_SIZE(extended_info_offsets) - 1);
-	else if (test_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags))
-		result = extract_package(battery, buffer.pointer,
+	else if (use_bix)
+		result = extract_package(battery, buffer->pointer,
 				extended_info_offsets,
 				ARRAY_SIZE(extended_info_offsets));
 	else
-		result = extract_package(battery, buffer.pointer,
+		result = extract_package(battery, buffer->pointer,
 				info_offsets, ARRAY_SIZE(info_offsets));
-	kfree(buffer.pointer);
 	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags))
 		battery->full_charge_capacity = battery->design_capacity;
 	if (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH, &battery->flags) &&
@@ -483,6 +468,45 @@ static int acpi_battery_get_info(struct acpi_battery *battery)
 	return result;
 }
 
+static int acpi_battery_get_info(struct acpi_battery *battery)
+{
+	const int xinfo = test_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags);
+	int use_bix;
+	int result = -ENODEV;
+
+	if (!acpi_battery_present(battery))
+		return 0;
+
+
+	for (use_bix = xinfo ? 1 : 0; use_bix >= 0; use_bix--) {
+		struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+		acpi_status status = AE_ERROR;
+
+		mutex_lock(&battery->lock);
+		status = acpi_evaluate_object(battery->device->handle,
+					      use_bix ? "_BIX":"_BIF",
+					      NULL, &buffer);
+		mutex_unlock(&battery->lock);
+
+		if (ACPI_FAILURE(status)) {
+			ACPI_EXCEPTION((AE_INFO, status, "Evaluating %s",
+					use_bix ? "_BIX":"_BIF"));
+		} else {
+			result = extract_battery_info(use_bix,
+						      battery,
+						      &buffer);
+
+			kfree(buffer.pointer);
+			break;
+		}
+	}
+
+	if (!result && !use_bix && xinfo)
+		pr_warn(FW_BUG "The _BIX method is broken, using _BIF.\n");
+
+	return result;
+}
+
 static int acpi_battery_get_state(struct acpi_battery *battery)
 {
 	int result = 0;

commit 12c78ca2ab5e64b636ce085fb08f7685654a5f22
Author: Carlos Garnacho <carlosg@gnome.org>
Date:   Wed Aug 10 17:24:15 2016 +0200

    ACPI / battery: Add sysfs representation after checking _BST
    
    Thus move sysfs_add_battery() after acpi_battery_get_state(), which doesn't
    require the power_supply. Prevents possible hanged tasks if
    acpi_battery_get_state() fails consistently (and takes a long time in doing
    so) when called inside acpi_battery_add().
    
    In this situation the battery module first calls sysfs_add_battery(),
    which creates a power_supply, which spawns an async
    power_supply_deferred_register_work() task, which shall try to hold the
    parent battery device mutex (being already held) so this register work
    is set up after device initialization. If initialization takes long enough
    the thread will be eventually run and try to hold the mutex before
    acpi_battery_add() had the chance to finish.
    
    Eventually the 5 retries in acpi_battery_update_retry() fail, the error
    state is propagated, and results in sysfs_remove_battery() being called
    within the error handling paths of acpi_battery_add(), and the power_supply
    tear down too.
    
    This triggers a cancel_delayed_work_sync() of the deferred_register_work
    task, which ends up in schedule(). The end result is that the deferred
    task is blocked trying to acquire the parent device mutex, which is not
    released because the thread doing initialization (and failure handling)
    went to sleep awaiting for the deferred task to be cancelled.
    
    The hanged tasks look like this:
    
    INFO: task kworker/u8:0:6 blocked for more than 120 seconds.
     ...
    Call Trace:
     [<ffffffff815daec5>] schedule+0x35/0x80
     [<ffffffff815dda3c>] schedule_timeout+0x1ec/0x250
     [<ffffffff810a0572>] ? check_preempt_curr+0x52/0x90
     [<ffffffff810a05c9>] ? ttwu_do_wakeup+0x19/0xe0
     [<ffffffff815db915>] wait_for_common+0xc5/0x190
     [<ffffffff810a1500>] ? wake_up_q+0x70/0x70
     [<ffffffff815db9fd>] wait_for_completion+0x1d/0x20
     [<ffffffff8108ffb1>] flush_work+0x111/0x1c0
     [<ffffffff8108dfe0>] ? flush_workqueue_prep_pwqs+0x1a0/0x1a0
     [<ffffffff810909af>] __cancel_work_timer+0x9f/0x1d0
     [<ffffffff81090b13>] cancel_delayed_work_sync+0x13/0x20
     [<ffffffff8147ac67>] power_supply_unregister+0x37/0xc0
     [<ffffffffa058b03d>] sysfs_remove_battery+0x3d/0x52 [battery]
     [<ffffffffa058bf3a>] acpi_battery_add+0x112/0x181 [battery]
     [<ffffffff81366db6>] acpi_device_probe+0x54/0x19b
     [<ffffffff81427e9c>] driver_probe_device+0x22c/0x440
     [<ffffffff81428181>] __driver_attach+0xd1/0xf0
     [<ffffffff814280b0>] ? driver_probe_device+0x440/0x440
     [<ffffffff8142591c>] bus_for_each_dev+0x6c/0xc0
     [<ffffffff8142758e>] driver_attach+0x1e/0x20
     [<ffffffff81426fc3>] bus_add_driver+0x1c3/0x280
     [<ffffffff81428b00>] driver_register+0x60/0xe0
     [<ffffffff81366c80>] acpi_bus_register_driver+0x3b/0x43
     [<ffffffffa0591040>] acpi_battery_init_async+0x1c/0x1e [battery]
     [<ffffffff81099268>] async_run_entry_fn+0x48/0x150
     [<ffffffff81090d09>] process_one_work+0x1e9/0x440
     [<ffffffff81090fab>] worker_thread+0x4b/0x4f0
     [<ffffffff81090f60>] ? process_one_work+0x440/0x440
     [<ffffffff81096b58>] kthread+0xd8/0xf0
     [<ffffffff815de97f>] ret_from_fork+0x1f/0x40
     [<ffffffff81096a80>] ? kthread_worker_fn+0x180/0x180
    
    INFO: task kworker/u8:4:282 blocked for more than 120 seconds.
     ...
    Call Trace:
     [<ffffffff810ad745>] ? put_prev_entity+0x35/0x8b0
     [<ffffffff815daec5>] schedule+0x35/0x80
     [<ffffffff815db14e>] schedule_preempt_disabled+0xe/0x10
     [<ffffffff815dc533>] __mutex_lock_slowpath+0xb3/0x120
     [<ffffffff815dc5bf>] mutex_lock+0x1f/0x30
     [<ffffffff8147a59b>] power_supply_deferred_register_work+0x2b/0x50
     [<ffffffff81090d09>] process_one_work+0x1e9/0x440
     [<ffffffff81090fab>] worker_thread+0x4b/0x4f0
     [<ffffffff81090f60>] ? process_one_work+0x440/0x440
     [<ffffffff81090f60>] ? process_one_work+0x440/0x440
     [<ffffffff81096b58>] kthread+0xd8/0xf0
     [<ffffffff815de97f>] ret_from_fork+0x1f/0x40
     [<ffffffff81096a80>] ? kthread_worker_fn+0x180/0x180
    
    Making sysfs_add_battery() the last operation here means that the
    power_supply won't be created yet when the acpi_add_battery() failure
    handling happens, the deferred task won't even spawn, and
    sysfs_remove_battery will just skip over the NULL battery->bat.
    
    Signed-off-by: Carlos Garnacho <carlosg@gnome.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index ab234791a0ba..93ecae55fe6a 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -733,15 +733,17 @@ static int acpi_battery_update(struct acpi_battery *battery, bool resume)
 			return result;
 		acpi_battery_init_alarm(battery);
 	}
+
+	result = acpi_battery_get_state(battery);
+	if (result)
+		return result;
+	acpi_battery_quirks(battery);
+
 	if (!battery->bat) {
 		result = sysfs_add_battery(battery);
 		if (result)
 			return result;
 	}
-	result = acpi_battery_get_state(battery);
-	if (result)
-		return result;
-	acpi_battery_quirks(battery);
 
 	/*
 	 * Wakeup the system if battery is critical low

commit 5dfa0c73953360e07a47731e412d33dfc896bf4e
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu May 19 09:11:52 2016 +0100

    ACPI / battery: Correctly serialise with the pending async probe
    
    async_synchronize_cookie() only serialises all tasks up to the specified
    cookie, and importantly does not wait for the task corresponding with
    the cookie. [This is so that it can be trivially used from inside the
    async_func_t in order to serialise with all preceding tasks.] In order
    to serialise with acpi_battery_init_async() we need to compensate and
    pass in the next cookie instead.
    
    The impact today is zero since performing an async_schedule() from inside
    a module init function will trigger an async_synchronize_full() prior to
    the module loader's completion. However, if the probe was moved to its
    own unregistered async_domain, then the async_synchronize_cookie would
    be replaced with an async_synchronize_full_domain.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index b719ab3090bb..ab234791a0ba 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1316,7 +1316,7 @@ static int __init acpi_battery_init(void)
 
 static void __exit acpi_battery_exit(void)
 {
-	async_synchronize_cookie(async_cookie);
+	async_synchronize_cookie(async_cookie + 1);
 	acpi_bus_unregister_driver(&acpi_battery_driver);
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	acpi_unlock_battery_dir(acpi_battery_dir);

commit 4c62dbbce902cf2afa88cac89ec67c828160f431
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Jun 26 11:27:41 2015 +0300

    ACPI: Remove FSF mailing addresses
    
    There is no need to carry potentially outdated Free Software Foundation
    mailing address in file headers since the COPYING file includes it.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index b3628cc01a53..b719ab3090bb 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -18,10 +18,6 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  *  General Public License for more details.
  *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 

commit 048d16da75cc3ae1a75455c0e7b2bf107c4f0f84
Author: Mathias Krause <minipli@googlemail.com>
Date:   Sat Jun 13 14:26:55 2015 +0200

    ACPI / battery: mark DMI table as __initconst
    
    The bat_dmi_table[] DMI table is referenced from the __init function
    acpi_battery_init_async() only. It and its referenced functions can
    therefore be marked __initconst to free up ~1kB of runtime memory after
    initialization is done.
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index c918c01c5ae6..b3628cc01a53 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1124,19 +1124,21 @@ static int battery_notify(struct notifier_block *nb,
 	return 0;
 }
 
-static int battery_bix_broken_package_quirk(const struct dmi_system_id *d)
+static int __init
+battery_bix_broken_package_quirk(const struct dmi_system_id *d)
 {
 	battery_bix_broken_package = 1;
 	return 0;
 }
 
-static int battery_notification_delay_quirk(const struct dmi_system_id *d)
+static int __init
+battery_notification_delay_quirk(const struct dmi_system_id *d)
 {
 	battery_notification_delay_ms = 1000;
 	return 0;
 }
 
-static struct dmi_system_id bat_dmi_table[] = {
+static const struct dmi_system_id bat_dmi_table[] __initconst = {
 	{
 		.callback = battery_bix_broken_package_quirk,
 		.ident = "NEC LZ750/LS",

commit 27059b9132880f4211c41dfbf7665671cbf1ac91
Author: Mathias Krause <minipli@googlemail.com>
Date:   Sat Jun 13 14:26:54 2015 +0200

    ACPI / battery: minor tweaks to acpi_battery_units()
    
    Make the acpi_battery_units() function take a const argument and return
    a const char*, too. Also make it static. It probably doesn't matter, as
    gcc will be clever enough to optimize and inline the code even without
    these hints. However, we also get rid of a #ifdef block by moving the
    function closer to its usage location, so it's at least a small gain in
    code readability.
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 7a175e9c1523..c918c01c5ae6 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -339,14 +339,6 @@ static enum power_supply_property energy_battery_props[] = {
 	POWER_SUPPLY_PROP_SERIAL_NUMBER,
 };
 
-#ifdef CONFIG_ACPI_PROCFS_POWER
-inline char *acpi_battery_units(struct acpi_battery *battery)
-{
-	return (battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA) ?
-		"mA" : "mW";
-}
-#endif
-
 /* --------------------------------------------------------------------------
                                Battery Management
    -------------------------------------------------------------------------- */
@@ -793,6 +785,12 @@ static void acpi_battery_refresh(struct acpi_battery *battery)
 #ifdef CONFIG_ACPI_PROCFS_POWER
 static struct proc_dir_entry *acpi_battery_dir;
 
+static const char *acpi_battery_units(const struct acpi_battery *battery)
+{
+	return (battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA) ?
+		"mA" : "mW";
+}
+
 static int acpi_battery_print_info(struct seq_file *seq, int result)
 {
 	struct acpi_battery *battery = seq->private;

commit a465878455a06a8d52599be25459ba23cec3fd09
Author: Mathias Krause <minipli@googlemail.com>
Date:   Sat Jun 13 14:26:53 2015 +0200

    ACPI / battery: constify the offset tables
    
    The offset tables are only read, not modified. Make them const.
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 547e627611e0..7a175e9c1523 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -355,14 +355,14 @@ struct acpi_offsets {
 	u8 mode;		/* int or string? */
 };
 
-static struct acpi_offsets state_offsets[] = {
+static const struct acpi_offsets state_offsets[] = {
 	{offsetof(struct acpi_battery, state), 0},
 	{offsetof(struct acpi_battery, rate_now), 0},
 	{offsetof(struct acpi_battery, capacity_now), 0},
 	{offsetof(struct acpi_battery, voltage_now), 0},
 };
 
-static struct acpi_offsets info_offsets[] = {
+static const struct acpi_offsets info_offsets[] = {
 	{offsetof(struct acpi_battery, power_unit), 0},
 	{offsetof(struct acpi_battery, design_capacity), 0},
 	{offsetof(struct acpi_battery, full_charge_capacity), 0},
@@ -378,7 +378,7 @@ static struct acpi_offsets info_offsets[] = {
 	{offsetof(struct acpi_battery, oem_info), 1},
 };
 
-static struct acpi_offsets extended_info_offsets[] = {
+static const struct acpi_offsets extended_info_offsets[] = {
 	{offsetof(struct acpi_battery, revision), 0},
 	{offsetof(struct acpi_battery, power_unit), 0},
 	{offsetof(struct acpi_battery, design_capacity), 0},
@@ -403,7 +403,7 @@ static struct acpi_offsets extended_info_offsets[] = {
 
 static int extract_package(struct acpi_battery *battery,
 			   union acpi_object *package,
-			   struct acpi_offsets *offsets, int num)
+			   const struct acpi_offsets *offsets, int num)
 {
 	int i;
 	union acpi_object *element;

commit eca21d9167213bc9217450613a671553ab45c225
Author: Luis Henriques <luis.henriques@canonical.com>
Date:   Mon May 11 22:49:05 2015 +0100

    ACPI / battery: ensure acpi_battery_init() has finish
    
    Make sure that async function scheduled with async_schedule() has already
    been executed.
    
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 9c676a6f32ce..547e627611e0 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -70,6 +70,7 @@ MODULE_AUTHOR("Alexey Starikovskiy <astarikovskiy@suse.de>");
 MODULE_DESCRIPTION("ACPI Battery Driver");
 MODULE_LICENSE("GPL");
 
+static async_cookie_t async_cookie;
 static int battery_bix_broken_package;
 static int battery_notification_delay_ms;
 static unsigned int cache_time = 1000;
@@ -1313,12 +1314,13 @@ static int __init acpi_battery_init(void)
 	if (acpi_disabled)
 		return -ENODEV;
 
-	async_schedule(acpi_battery_init_async, NULL);
+	async_cookie = async_schedule(acpi_battery_init_async, NULL);
 	return 0;
 }
 
 static void __exit acpi_battery_exit(void)
 {
+	async_synchronize_cookie(async_cookie);
 	acpi_bus_unregister_driver(&acpi_battery_driver);
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	acpi_unlock_battery_dir(acpi_battery_dir);

commit 479faaf00fde35e80a5be1389938b38e422d799d
Author: Luis Henriques <luis.henriques@canonical.com>
Date:   Mon May 11 22:48:46 2015 +0100

    ACPI / battery: drop useless return statements
    
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 69b8e607ec35..9c676a6f32ce 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1292,20 +1292,20 @@ static struct acpi_driver acpi_battery_driver = {
 
 static void __init acpi_battery_init_async(void *unused, async_cookie_t cookie)
 {
+	int result;
+
 	dmi_check_system(bat_dmi_table);
-	
+
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	acpi_battery_dir = acpi_lock_battery_dir();
 	if (!acpi_battery_dir)
 		return;
 #endif
-	if (acpi_bus_register_driver(&acpi_battery_driver) < 0) {
+	result = acpi_bus_register_driver(&acpi_battery_driver);
 #ifdef CONFIG_ACPI_PROCFS_POWER
+	if (result < 0)
 		acpi_unlock_battery_dir(acpi_battery_dir);
 #endif
-		return;
-	}
-	return;
 }
 
 static int __init acpi_battery_init(void)

commit e234b074c8ebe736f74cc40a8953accb66b82d04
Author: Luis Henriques <luis.henriques@canonical.com>
Date:   Mon May 11 22:48:38 2015 +0100

    ACPI / battery: abort initialization earlier if acpi_disabled
    
    If ACPI is disabled there's no need to schedule an async function call,
    the driver initialization can be aborted earlier in acpi_battery_init().
    
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 63d43677f644..69b8e607ec35 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1292,9 +1292,6 @@ static struct acpi_driver acpi_battery_driver = {
 
 static void __init acpi_battery_init_async(void *unused, async_cookie_t cookie)
 {
-	if (acpi_disabled)
-		return;
-
 	dmi_check_system(bat_dmi_table);
 	
 #ifdef CONFIG_ACPI_PROCFS_POWER
@@ -1313,6 +1310,9 @@ static void __init acpi_battery_init_async(void *unused, async_cookie_t cookie)
 
 static int __init acpi_battery_init(void)
 {
+	if (acpi_disabled)
+		return -ENODEV;
+
 	async_schedule(acpi_battery_init_async, NULL);
 	return 0;
 }

commit 2481bc75283ea10e75d5fb1a8b42af363fc4b45c
Merge: 8691c130fae1 518b4e272d99
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 14 20:21:54 2015 -0700

    Merge tag 'pm+acpi-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "These are mostly fixes and cleanups all over, although there are a few
      items that sort of fall into the new feature category.
    
      First off, we have new callbacks for PM domains that should help us to
      handle some issues related to device initialization in a better way.
    
      There also is some consolidation in the unified device properties API
      area allowing us to use that inferface for accessing data coming from
      platform initialization code in addition to firmware-provided data.
    
      We have some new device/CPU IDs in a few drivers, support for new
      chips and a new cpufreq driver too.
    
      Specifics:
    
       - Generic PM domains support update including new PM domain callbacks
         to handle device initialization better (Russell King, Rafael J
         Wysocki, Kevin Hilman)
    
       - Unified device properties API update including a new mechanism for
         accessing data provided by platform initialization code (Rafael J
         Wysocki, Adrian Hunter)
    
       - ARM cpuidle update including ARM32/ARM64 handling consolidation
         (Daniel Lezcano)
    
       - intel_idle update including support for the Silvermont Core in the
         Baytrail SOC and for the Airmont Core in the Cherrytrail and
         Braswell SOCs (Len Brown, Mathias Krause)
    
       - New cpufreq driver for Hisilicon ACPU (Leo Yan)
    
       - intel_pstate update including support for the Knights Landing chip
         (Dasaratharaman Chandramouli, Kristen Carlson Accardi)
    
       - QorIQ cpufreq driver update (Tang Yuantian, Arnd Bergmann)
    
       - powernv cpufreq driver update (Shilpasri G Bhat)
    
       - devfreq update including Tegra support changes (Tomeu Vizoso,
         MyungJoo Ham, Chanwoo Choi)
    
       - powercap RAPL (Running-Average Power Limit) driver update including
         support for Intel Broadwell server chips (Jacob Pan, Mathias Krause)
    
       - ACPI device enumeration update related to the handling of the
         special PRP0001 device ID allowing DT-style 'compatible' property
         to be used for ACPI device identification (Rafael J Wysocki)
    
       - ACPI EC driver update including limited _DEP support (Lan Tianyu,
         Lv Zheng)
    
       - ACPI backlight driver update including a new mechanism to allow
         native backlight handling to be forced on non-Windows 8 systems and
         a new quirk for Lenovo Ideapad Z570 (Aaron Lu, Hans de Goede)
    
       - New Windows Vista compatibility quirk for Sony VGN-SR19XN (Chen Yu)
    
       - Assorted ACPI fixes and cleanups (Aaron Lu, Martin Kepplinger,
         Masanari Iida, Mika Westerberg, Nan Li, Rafael J Wysocki)
    
       - Fixes related to suspend-to-idle for the iTCO watchdog driver and
         the ACPI core system suspend/resume code (Rafael J Wysocki, Chen Yu)
    
       - PM tracing support for the suspend phase of system suspend/resume
         transitions (Zhonghui Fu)
    
       - Configurable delay for the system suspend/resume testing facility
         (Brian Norris)
    
       - PNP subsystem cleanups (Peter Huewe, Rafael J Wysocki)"
    
    * tag 'pm+acpi-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (74 commits)
      ACPI / scan: Fix NULL pointer dereference in acpi_companion_match()
      ACPI / scan: Rework modalias creation when "compatible" is present
      intel_idle: mark cpu id array as __initconst
      powercap / RAPL: mark rapl_ids array as __initconst
      powercap / RAPL: add ID for Broadwell server
      intel_pstate: Knights Landing support
      intel_pstate: remove MSR test
      cpufreq: fix qoriq uniprocessor build
      ACPI / scan: Take the PRP0001 position in the list of IDs into account
      ACPI / scan: Simplify acpi_match_device()
      ACPI / scan: Generalize of_compatible matching
      device property: Introduce firmware node type for platform data
      device property: Make it possible to use secondary firmware nodes
      PM / watchdog: iTCO: stop watchdog during system suspend
      cpufreq: hisilicon: add acpu driver
      ACPI / EC: Call acpi_walk_dep_device_list() after installing EC opregion handler
      cpufreq: powernv: Report cpu frequency throttling
      intel_idle: Add support for the Airmont Core in the Cherrytrail and Braswell SOCs
      intel_idle: Update support for Silvermont Core in Baytrail SOC
      PM / devfreq: tegra: Register governor on module init
      ...

commit 31f7dc796998d2967e999a0f9229d8a50c7b348d
Author: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
Date:   Tue Apr 14 22:24:13 2015 +0900

    ACPI / battery: Fix doubly added battery on system suspend
    
    Commit 297d716f6260 ("power_supply: Change ownership from driver to
    core") inverted the logic in battery_notify().  As an effect already
    present battery was re-added on each system suspend or hibernation.
    
        WARNING: CPU: 0 PID: 303 at ../fs/sysfs/dir.c:31 sysfs_warn_dup+0x68/0x80()
        sysfs: cannot create duplicate filename '/devices/LNXSYSTM:00/LNXSYBUS:00/PNP0A03:00/PNP0C0A:00/power_supply/BAT0'
        CPU: 0 PID: 303 Comm: rtcwake Not tainted 4.0.0-ARCH-02621-g07e6253af953 #48
        Call Trace:
          sysfs_create_dir_ns+0x8d/0xa0
          kobject_add_internal+0xb6/0x370
          kobject_add+0x6f/0xd0
          device_add+0x120/0x6c0
          __power_supply_register+0x145/0x290
          power_supply_register_no_ws+0x10/0x20
          sysfs_add_battery+0x84/0xc5 [battery]
          battery_notify+0x45/0x6b [battery]
          notifier_call_chain+0x4f/0x80
          __blocking_notifier_call_chain+0x4b/0x70
          blocking_notifier_call_chain+0x16/0x20
          pm_notifier_call_chain+0x1a/0x40
          pm_suspend+0x3ed/0x4e0
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-By: Sebastian Reichel <sre@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index fdc16ce9d272..672263a3832c 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1106,7 +1106,7 @@ static int battery_notify(struct notifier_block *nb,
 		if (!acpi_battery_present(battery))
 			return 0;
 
-		if (battery->bat) {
+		if (!battery->bat) {
 			result = acpi_battery_get_info(battery);
 			if (result)
 				return result;

commit 9237516c1b96553040e95588347e2f6d337531ae
Author: Martin Kepplinger <martink@posteo.de>
Date:   Fri Mar 13 00:48:17 2015 +0100

    ACPI / battery: make warning greppable
    
    Signed-off-by: Martin Kepplinger <martink@posteo.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index d98ba4355819..baebd1a9b811 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -530,8 +530,8 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 		battery->rate_now != ACPI_BATTERY_VALUE_UNKNOWN &&
 		(s16)(battery->rate_now) < 0) {
 		battery->rate_now = abs((s16)battery->rate_now);
-		printk_once(KERN_WARNING FW_BUG "battery: (dis)charge rate"
-			" invalid.\n");
+		printk_once(KERN_WARNING FW_BUG
+			    "battery: (dis)charge rate invalid.\n");
 	}
 
 	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags)

commit 297d716f6260cc9421d971b124ca196b957ee458
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Thu Mar 12 08:44:11 2015 +0100

    power_supply: Change ownership from driver to core
    
    Change the ownership of power_supply structure from each driver
    implementing the class to the power supply core.
    
    The patch changes power_supply_register() function thus all drivers
    implementing power supply class are adjusted.
    
    Each driver provides the implementation of power supply. However it
    should not be the owner of power supply class instance because it is
    exposed by core to other subsystems with power_supply_get_by_name().
    These other subsystems have no knowledge when the driver will unregister
    the power supply. This leads to several issues when driver is unbound -
    mostly because user of power supply accesses freed memory.
    
    Instead let the core own the instance of struct 'power_supply'.  Other
    users of this power supply will still access valid memory because it
    will be freed when device reference count reaches 0. Currently this
    means "it will leak" but power_supply_put() call in next patches will
    solve it.
    
    This solves invalid memory references in following race condition
    scenario:
    
    Thread 1: charger manager
    Thread 2: power supply driver, used by charger manager
    
    THREAD 1 (charger manager)         THREAD 2 (power supply driver)
    ==========================         ==============================
    psy = power_supply_get_by_name()
                                       Driver unbind, .remove
                                         power_supply_unregister()
                                         Device fully removed
    psy->get_property()
    
    The 'get_property' call is executed in invalid context because the driver was
    unbound and struct 'power_supply' memory was freed.
    
    This could be observed easily with charger manager driver (here compiled
    with max17040 fuel gauge):
    
    $ cat /sys/devices/virtual/power_supply/cm-battery/capacity &
    $ echo "1-0036" > /sys/bus/i2c/drivers/max17040/unbind
    [   55.725123] Unable to handle kernel NULL pointer dereference at virtual address 00000000
    [   55.732584] pgd = d98d4000
    [   55.734060] [00000000] *pgd=5afa2831, *pte=00000000, *ppte=00000000
    [   55.740318] Internal error: Oops: 80000007 [#1] PREEMPT SMP ARM
    [   55.746210] Modules linked in:
    [   55.749259] CPU: 1 PID: 2936 Comm: cat Tainted: G        W       3.19.0-rc1-next-20141226-00048-gf79f475f3c44-dirty #1496
    [   55.760190] Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    [   55.766270] task: d9b76f00 ti: daf54000 task.ti: daf54000
    [   55.771647] PC is at 0x0
    [   55.774182] LR is at charger_get_property+0x2f4/0x36c
    [   55.779201] pc : [<00000000>]    lr : [<c034b0b4>]    psr: 60000013
    [   55.779201] sp : daf55e90  ip : 00000003  fp : 00000000
    [   55.790657] r10: 00000000  r9 : c06e2878  r8 : d9b26c68
    [   55.795865] r7 : dad81610  r6 : daec7410  r5 : daf55ebc  r4 : 00000000
    [   55.802367] r3 : 00000000  r2 : daf55ebc  r1 : 0000002a  r0 : d9b26c68
    [   55.808879] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
    [   55.815994] Control: 10c5387d  Table: 598d406a  DAC: 00000015
    [   55.821723] Process cat (pid: 2936, stack limit = 0xdaf54210)
    [   55.827451] Stack: (0xdaf55e90 to 0xdaf56000)
    [   55.831795] 5e80:                                     60000013 c01459c4 0000002a c06f8ef8
    [   55.839956] 5ea0: db651000 c06f8ef8 daebac00 c04cb668 daebac08 c0346864 00000000 c01459c4
    [   55.848115] 5ec0: d99eaa80 c06f8ef8 00000fff 00001000 db651000 c027f25c c027f240 d99eaa80
    [   55.856274] 5ee0: d9a06c00 c0146218 daf55f18 00001000 d99eaa80 db4c18c0 00000001 00000001
    [   55.864468] 5f00: daf55f80 c0144c78 c0144c54 c0107f90 00015000 d99eaab0 00000000 00000000
    [   55.872603] 5f20: 000051c7 00000000 db4c18c0 c04a9370 00015000 00001000 daf55f80 00001000
    [   55.880763] 5f40: daf54000 00015000 00000000 c00e53dc db4c18c0 c00e548c 0000000d 00008124
    [   55.888937] 5f60: 00000001 00000000 00000000 db4c18c0 db4c18c0 00001000 00015000 c00e5550
    [   55.897099] 5f80: 00000000 00000000 00001000 00001000 00015000 00000003 00000003 c000f364
    [   55.905239] 5fa0: 00000000 c000f1a0 00001000 00015000 00000003 00015000 00001000 0001333c
    [   55.913399] 5fc0: 00001000 00015000 00000003 00000003 00000002 00000000 00000000 00000000
    [   55.921560] 5fe0: 7fffe000 be999850 0000a225 b6f3c19c 60000010 00000003 00000000 00000000
    [   55.929744] [<c034b0b4>] (charger_get_property) from [<c0346864>] (power_supply_show_property+0x48/0x20c)
    [   55.939286] [<c0346864>] (power_supply_show_property) from [<c027f25c>] (dev_attr_show+0x1c/0x48)
    [   55.948130] [<c027f25c>] (dev_attr_show) from [<c0146218>] (sysfs_kf_seq_show+0x84/0x104)
    [   55.956298] [<c0146218>] (sysfs_kf_seq_show) from [<c0144c78>] (kernfs_seq_show+0x24/0x28)
    [   55.964536] [<c0144c78>] (kernfs_seq_show) from [<c0107f90>] (seq_read+0x1b0/0x484)
    [   55.972172] [<c0107f90>] (seq_read) from [<c00e53dc>] (__vfs_read+0x18/0x4c)
    [   55.979188] [<c00e53dc>] (__vfs_read) from [<c00e548c>] (vfs_read+0x7c/0x100)
    [   55.986304] [<c00e548c>] (vfs_read) from [<c00e5550>] (SyS_read+0x40/0x8c)
    [   55.993164] [<c00e5550>] (SyS_read) from [<c000f1a0>] (ret_fast_syscall+0x0/0x48)
    [   56.000626] Code: bad PC value
    [   56.011652] ---[ end trace 7b64343fbdae8ef1 ]---
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    
    [for the nvec part]
    Reviewed-by: Marc Dietrich <marvin24@gmx.de>
    
    [for compal-laptop.c]
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    
    [for the mfd part]
    Acked-by: Lee Jones <lee.jones@linaro.org>
    
    [for the hid part]
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    
    [for the acpi part]
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index fd8c06f492a1..fdc16ce9d272 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -117,7 +117,8 @@ enum {
 struct acpi_battery {
 	struct mutex lock;
 	struct mutex sysfs_lock;
-	struct power_supply bat;
+	struct power_supply *bat;
+	struct power_supply_desc bat_desc;
 	struct acpi_device *device;
 	struct notifier_block pm_nb;
 	unsigned long update_time;
@@ -149,7 +150,7 @@ struct acpi_battery {
 	unsigned long flags;
 };
 
-#define to_acpi_battery(x) container_of(x, struct acpi_battery, bat)
+#define to_acpi_battery(x) power_supply_get_drvdata(x)
 
 static inline int acpi_battery_present(struct acpi_battery *battery)
 {
@@ -608,41 +609,45 @@ static struct device_attribute alarm_attr = {
 
 static int sysfs_add_battery(struct acpi_battery *battery)
 {
-	int result;
+	struct power_supply_config psy_cfg = { .drv_data = battery, };
 
 	if (battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA) {
-		battery->bat.properties = charge_battery_props;
-		battery->bat.num_properties =
+		battery->bat_desc.properties = charge_battery_props;
+		battery->bat_desc.num_properties =
 			ARRAY_SIZE(charge_battery_props);
 	} else {
-		battery->bat.properties = energy_battery_props;
-		battery->bat.num_properties =
+		battery->bat_desc.properties = energy_battery_props;
+		battery->bat_desc.num_properties =
 			ARRAY_SIZE(energy_battery_props);
 	}
 
-	battery->bat.name = acpi_device_bid(battery->device);
-	battery->bat.type = POWER_SUPPLY_TYPE_BATTERY;
-	battery->bat.get_property = acpi_battery_get_property;
+	battery->bat_desc.name = acpi_device_bid(battery->device);
+	battery->bat_desc.type = POWER_SUPPLY_TYPE_BATTERY;
+	battery->bat_desc.get_property = acpi_battery_get_property;
 
-	result = power_supply_register_no_ws(&battery->device->dev,
-			&battery->bat, NULL);
+	battery->bat = power_supply_register_no_ws(&battery->device->dev,
+				&battery->bat_desc, &psy_cfg);
 
-	if (result)
+	if (IS_ERR(battery->bat)) {
+		int result = PTR_ERR(battery->bat);
+
+		battery->bat = NULL;
 		return result;
-	return device_create_file(battery->bat.dev, &alarm_attr);
+	}
+	return device_create_file(&battery->bat->dev, &alarm_attr);
 }
 
 static void sysfs_remove_battery(struct acpi_battery *battery)
 {
 	mutex_lock(&battery->sysfs_lock);
-	if (!battery->bat.dev) {
+	if (!battery->bat) {
 		mutex_unlock(&battery->sysfs_lock);
 		return;
 	}
 
-	device_remove_file(battery->bat.dev, &alarm_attr);
-	power_supply_unregister(&battery->bat);
-	battery->bat.dev = NULL;
+	device_remove_file(&battery->bat->dev, &alarm_attr);
+	power_supply_unregister(battery->bat);
+	battery->bat = NULL;
 	mutex_unlock(&battery->sysfs_lock);
 }
 
@@ -739,7 +744,7 @@ static int acpi_battery_update(struct acpi_battery *battery, bool resume)
 			return result;
 		acpi_battery_init_alarm(battery);
 	}
-	if (!battery->bat.dev) {
+	if (!battery->bat) {
 		result = sysfs_add_battery(battery);
 		if (result)
 			return result;
@@ -765,7 +770,7 @@ static void acpi_battery_refresh(struct acpi_battery *battery)
 {
 	int power_unit;
 
-	if (!battery->bat.dev)
+	if (!battery->bat)
 		return;
 
 	power_unit = battery->power_unit;
@@ -1063,11 +1068,11 @@ static void acpi_battery_remove_fs(struct acpi_device *device)
 static void acpi_battery_notify(struct acpi_device *device, u32 event)
 {
 	struct acpi_battery *battery = acpi_driver_data(device);
-	struct device *old;
+	struct power_supply *old;
 
 	if (!battery)
 		return;
-	old = battery->bat.dev;
+	old = battery->bat;
 	/*
 	* On Acer Aspire V5-573G notifications are sometimes triggered too
 	* early. For example, when AC is unplugged and notification is
@@ -1084,8 +1089,8 @@ static void acpi_battery_notify(struct acpi_device *device, u32 event)
 					acpi_battery_present(battery));
 	acpi_notifier_call_chain(device, event, acpi_battery_present(battery));
 	/* acpi_battery_update could remove power_supply object */
-	if (old && battery->bat.dev)
-		power_supply_changed(&battery->bat);
+	if (old && battery->bat)
+		power_supply_changed(battery->bat);
 }
 
 static int battery_notify(struct notifier_block *nb,
@@ -1101,7 +1106,7 @@ static int battery_notify(struct notifier_block *nb,
 		if (!acpi_battery_present(battery))
 			return 0;
 
-		if (!battery->bat.dev) {
+		if (battery->bat) {
 			result = acpi_battery_get_info(battery);
 			if (result)
 				return result;

commit 2dc9215d7c94f7f9f34ccf8b1710ad73d82f6216
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Thu Mar 12 08:44:02 2015 +0100

    power_supply: Move run-time configuration to separate structure
    
    Add new structure 'power_supply_config' for holding run-time
    initialization data like of_node, supplies and private driver data.
    
    The power_supply_register() function is changed so all power supply
    drivers need updating.
    
    When registering the power supply this new 'power_supply_config' should be
    used instead of directly initializing 'struct power_supply'. This allows
    changing the ownership of power_supply structure from driver to the
    power supply core in next patches.
    
    When a driver does not use of_node or supplies then it should use NULL
    as config. If driver uses of_node or supplies then it should allocate
    config on stack and initialize it with proper values.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    
    [for the nvec part]
    Reviewed-by: Marc Dietrich <marvin24@gmx.de>
    
    [for drivers/platform/x86/compal-laptop.c]
    Reviewed-by: Darren Hart <dvhart@linux.intel.com>
    
    [for drivers/hid/*]
    Reviewed-by: Jiri Kosina <jkosina@suse.cz>
    
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index d98ba4355819..fd8c06f492a1 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -624,7 +624,8 @@ static int sysfs_add_battery(struct acpi_battery *battery)
 	battery->bat.type = POWER_SUPPLY_TYPE_BATTERY;
 	battery->bat.get_property = acpi_battery_get_property;
 
-	result = power_supply_register_no_ws(&battery->device->dev, &battery->bat);
+	result = power_supply_register_no_ws(&battery->device->dev,
+			&battery->bat, NULL);
 
 	if (result)
 		return result;

commit 40e7fcb19293cbdff02c74cb0668413480f82ea1
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Sun Nov 23 21:22:54 2014 +0800

    ACPI: Add _DEP support to fix battery issue on Asus T100TA
    
    ACPI 5.0 introduces _DEP (Operation Region Dependencies) to designate
    device objects that OSPM should assign a higher priority in start
    ordering due to future operation region accesses.
    
    On Asus T100TA, ACPI battery info are read from a I2C slave device via
    I2C operation region. Before I2C operation region handler is installed,
    battery _STA always returns 0. There is a _DEP method of designating
    start order under battery device node.
    
    This patch is to implement _DEP feature to fix battery issue on the
    Asus T100TA.  Introducing acpi_dep_list and adding dep_unmet count
    in struct acpi_device. During ACPI namespace scan, create struct
    acpi_dep_data for a valid pair of master (device pointed to by _DEP)/
    slave(device with _DEP), record master's and slave's ACPI handle in
    it and put it into acpi_dep_list. The dep_unmet count will increase
    by one if there is a device under its _DEP. Driver's probe() should
    return EPROBE_DEFER when find dep_unmet is larger than 0. When I2C
    operation region handler is installed, remove all struct acpi_dep_data
    on the acpi_dep_list whose master is pointed to I2C host controller
    and decrease slave's dep_unmet. When dep_unmet decreases to 0, all
    _DEP conditions are met and then do acpi_bus_attach() for the device
    in order to resolve battery _STA issue on the Asus T100TA.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=69011
    Tested-by: Jan-Michael Brummer <jan.brummer@tabos.org>
    Tested-by: Adam Williamson <adamw@happyassassin.net>
    Tested-by: Michael Shigorin <shigorin@gmail.com>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 8ec8a89a20ab..d98ba4355819 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1180,6 +1180,10 @@ static int acpi_battery_add(struct acpi_device *device)
 
 	if (!device)
 		return -EINVAL;
+
+	if (device->dep_unmet)
+		return -EPROBE_DEFER;
+
 	battery = kzalloc(sizeof(struct acpi_battery), GFP_KERNEL);
 	if (!battery)
 		return -ENOMEM;

commit ffd8a731d9bfd186b8bb8b88f558de7e04ae06e6
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Tue Sep 16 22:51:24 2014 +0200

    ACPI / battery: Replace strnicmp with strncasecmp
    
    The kernel used to contain two functions for length-delimited,
    case-insensitive string comparison, strnicmp with correct semantics
    and a slightly buggy strncasecmp. The latter is the POSIX name, so
    strnicmp was renamed to strncasecmp, and strnicmp made into a wrapper
    for the new strncasecmp to avoid breaking existing users.
    
    To allow the compat wrapper strnicmp to be removed at some point in
    the future, and to avoid the extra indirection cost, do
    s/strnicmp/strncasecmp/g.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 5fdfe65fe165..8ec8a89a20ab 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -695,7 +695,7 @@ static void acpi_battery_quirks(struct acpi_battery *battery)
 	if (battery->power_unit && dmi_name_in_vendors("LENOVO")) {
 		const char *s;
 		s = dmi_get_system_info(DMI_PRODUCT_VERSION);
-		if (s && !strnicmp(s, "ThinkPad", 8)) {
+		if (s && !strncasecmp(s, "ThinkPad", 8)) {
 			dmi_walk(find_battery, battery);
 			if (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH,
 				     &battery->flags) &&

commit 508b3c677601797f2d51df3df5caa436dd235cb9
Author: Bjrn Mork <bjorn@mork.no>
Date:   Tue Sep 9 10:45:18 2014 +0200

    Revert "ACPI / battery: fix wrong value of capacity_now reported when fully charged"
    
    This reverts commit 232de5143790 ("ACPI / battery: fix wrong value of
    capacity_now reported when fully charged")
    
    There is nothing wrong or unexpected about 'capacity_now' increasing above
    the last 'full_charge_capacity' value. Different charging cycles will cause
    'full_charge_capacity' to vary, both up and down.  Good battery firmwares
    will update 'full_charge_capacity' when the current charging cycle is
    complete, increasing it if necessary. It might even go above
    'design_capacity' on a fresh and healthy battery.
    
    Capping 'capacity_now' to 'full_charge_capacity' is plain wrong, and
    printing a warning if this doesn't happen to match the 'design_capacity'
    is both annoying and terribly wrong.
    
    This results in bogus warnings on perfectly working systems/firmwares:
    
     [Firmware Bug]: battery: reported current charge level (39800) is higher than reported maximum charge level (39800).
    
    and wrong values being reported for 'capacity_now' and
    'full_charge_capacity' after the warning has been triggered.
    
    Fixes: 232de5143790 ("ACPI / battery: fix wrong value of capacity_now reported when fully charged")
    Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
    Signed-off-by: Bjrn Mork <bjorn@mork.no>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 48bcf38a0ea8..5fdfe65fe165 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -534,20 +534,6 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 			" invalid.\n");
 	}
 
-	/*
-	 * When fully charged, some batteries wrongly report
-	 * capacity_now = design_capacity instead of = full_charge_capacity
-	 */
-	if (battery->capacity_now > battery->full_charge_capacity
-	    && battery->full_charge_capacity != ACPI_BATTERY_VALUE_UNKNOWN) {
-		battery->capacity_now = battery->full_charge_capacity;
-		if (battery->capacity_now != battery->design_capacity)
-			printk_once(KERN_WARNING FW_BUG
-				"battery: reported current charge level (%d) "
-				"is higher than reported maximum charge level (%d).\n",
-				battery->capacity_now, battery->full_charge_capacity);
-	}
-
 	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags)
 	    && battery->capacity_now >= 0 && battery->capacity_now <= 100)
 		battery->capacity_now = (battery->capacity_now *

commit 583ee394ac503ff9eac0f50673cd569643bdb3b4
Author: Bjrn Mork <bjorn@mork.no>
Date:   Tue Sep 9 10:45:17 2014 +0200

    Revert "ACPI / battery: Fix warning message in acpi_battery_get_state()"
    
    This reverts commit d719870b41e0 ("ACPI / battery: Fix warning message in
    acpi_battery_get_state()")
    
    Capping 'capacity_now' to 'full_charge_capacity' is plain wrong. If this
    is necessary to work around some buggy firmware, then the workaround needs
    protection against being applied to working firmwares.
    
    Good battery firmwares will allow 'capacity_now' to increase above
    'full_charge_capacity', and will update the latter when the battery
    is fully charged.  By capping 'capacity_now' we lose accurate capacity
    reporting until charging is complete whenever 'full_charge_capacity'
    needs to be increased.
    
    Fixes: d719870b41e0 ("ACPI / battery: Fix warning message in acpi_battery_get_state()")
    Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
    Signed-off-by: Bjrn Mork <bjorn@mork.no>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 1c162e7be045..48bcf38a0ea8 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -540,12 +540,12 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 	 */
 	if (battery->capacity_now > battery->full_charge_capacity
 	    && battery->full_charge_capacity != ACPI_BATTERY_VALUE_UNKNOWN) {
+		battery->capacity_now = battery->full_charge_capacity;
 		if (battery->capacity_now != battery->design_capacity)
 			printk_once(KERN_WARNING FW_BUG
 				"battery: reported current charge level (%d) "
 				"is higher than reported maximum charge level (%d).\n",
 				battery->capacity_now, battery->full_charge_capacity);
-		battery->capacity_now = battery->full_charge_capacity;
 	}
 
 	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags)

commit d719870b41e00baf64d028c2668ae1fc3eb50e79
Author: Mariusz Ceier <mceier+kernel@gmail.com>
Date:   Sat Aug 9 11:43:31 2014 +0200

    ACPI / battery: Fix warning message in acpi_battery_get_state()
    
    capacity_now should be assigned after comparing it to design_capacity.
    
    Otherwise warning is printed even when capacity_now before assignment is
    equal to design_capacity, making the check useless and "current charge level"
    wrong (it should be higher than, not equal to, "maximum charge level", which
    is full_charge_capacity):
    
    "battery: reported current charge level (56410) is higher than reported
    maximum charge level (56410)."
    
    Fixes: 232de5143790 (ACPI / battery: fix wrong value of capacity_now reported when fully charged)
    Signed-off-by: Mariusz Ceier <mceier+kernel@gmail.com>
    Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
    [rjw: Subject]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 48bcf38a0ea8..1c162e7be045 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -540,12 +540,12 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 	 */
 	if (battery->capacity_now > battery->full_charge_capacity
 	    && battery->full_charge_capacity != ACPI_BATTERY_VALUE_UNKNOWN) {
-		battery->capacity_now = battery->full_charge_capacity;
 		if (battery->capacity_now != battery->design_capacity)
 			printk_once(KERN_WARNING FW_BUG
 				"battery: reported current charge level (%d) "
 				"is higher than reported maximum charge level (%d).\n",
 				battery->capacity_now, battery->full_charge_capacity);
+		battery->capacity_now = battery->full_charge_capacity;
 	}
 
 	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags)

commit 3a54a57dceed78f7f3c35991d6d4a064a0c2e343
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Mon Jul 28 21:22:55 2014 +0800

    ACPI / battery: remove duplicated include from battery.c
    
    Remove duplicated include.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 130f513e08c9..48bcf38a0ea8 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -35,7 +35,6 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/suspend.h>
-#include <linux/delay.h>
 #include <asm/unaligned.h>
 
 #ifdef CONFIG_ACPI_PROCFS_POWER

commit 232de514379082e7ec431c66c9713a6ef23d5dcb
Author: Josef Gajdusek <atx@atx.name>
Date:   Tue Jun 17 23:15:49 2014 +0200

    ACPI / battery: fix wrong value of capacity_now reported when fully charged
    
    It seems that some batteries (noticed on DELL JYPJ136) assume
    capacity_now = design_capacity when fully charged. This causes
    reported capacity to suddenly jump to >full_charge_capacity (and that
    means capacity reported to userspace is >100% and incorrect)
    values after 99%. This patch detects capacity_now > full_charge_capacity,
    notifies userspace (unless it is the known bug where capacity_now ==
    design_capacity) and trims the value to full_charge_capacity.
    
    Signed-off-by: Josef Gajdusek <atx@atx.name>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index bc0b286ff2ba..130f513e08c9 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -535,6 +535,20 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 			" invalid.\n");
 	}
 
+	/*
+	 * When fully charged, some batteries wrongly report
+	 * capacity_now = design_capacity instead of = full_charge_capacity
+	 */
+	if (battery->capacity_now > battery->full_charge_capacity
+	    && battery->full_charge_capacity != ACPI_BATTERY_VALUE_UNKNOWN) {
+		battery->capacity_now = battery->full_charge_capacity;
+		if (battery->capacity_now != battery->design_capacity)
+			printk_once(KERN_WARNING FW_BUG
+				"battery: reported current charge level (%d) "
+				"is higher than reported maximum charge level (%d).\n",
+				battery->capacity_now, battery->full_charge_capacity);
+	}
+
 	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags)
 	    && battery->capacity_now >= 0 && battery->capacity_now <= 100)
 		battery->capacity_now = (battery->capacity_now *

commit 75646e758a0ecbed5024454507d5be5b9ea9dcbf
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Mon Jul 7 15:47:12 2014 +0800

    ACPI / battery: Retry to get battery information if failed during probing
    
    Some machines (eg. Lenovo Z480) ECs are not stable during boot up
    and causes battery driver fails to be loaded due to failure of getting
    battery information from EC sometimes. After several retries, the
    operation will work. This patch is to retry to get battery information 5
    times if the first try fails.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=75581
    Reported-and-tested-by: naszar <naszar@ya.ru>
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 0d7116f34b95..bc0b286ff2ba 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -35,6 +35,7 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/suspend.h>
+#include <linux/delay.h>
 #include <asm/unaligned.h>
 
 #ifdef CONFIG_ACPI_PROCFS_POWER
@@ -1151,6 +1152,28 @@ static struct dmi_system_id bat_dmi_table[] = {
 	{},
 };
 
+/*
+ * Some machines'(E,G Lenovo Z480) ECs are not stable
+ * during boot up and this causes battery driver fails to be
+ * probed due to failure of getting battery information
+ * from EC sometimes. After several retries, the operation
+ * may work. So add retry code here and 20ms sleep between
+ * every retries.
+ */
+static int acpi_battery_update_retry(struct acpi_battery *battery)
+{
+	int retry, ret;
+
+	for (retry = 5; retry; retry--) {
+		ret = acpi_battery_update(battery, false);
+		if (!ret)
+			break;
+
+		msleep(20);
+	}
+	return ret;
+}
+
 static int acpi_battery_add(struct acpi_device *device)
 {
 	int result = 0;
@@ -1169,9 +1192,11 @@ static int acpi_battery_add(struct acpi_device *device)
 	mutex_init(&battery->sysfs_lock);
 	if (acpi_has_method(battery->device->handle, "_BIX"))
 		set_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags);
-	result = acpi_battery_update(battery, false);
+
+	result = acpi_battery_update_retry(battery);
 	if (result)
 		goto fail;
+
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	result = acpi_battery_add_fs(device);
 #endif

commit cf8116c491e98b47a535348a50c94cc01770d9a3
Merge: 12e27b115472 3d915894f831 92c4d2ad3c85 765bdd4e5167 f43691c61d6e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jun 19 14:40:48 2014 +0200

    Merge branches 'acpi-general', 'acpi-processor', 'acpi-lpss' and 'acpi-battery'
    
    * acpi-general:
      ACPI: use kstrto*() instead of simple_strto*()
    
    * acpi-processor:
      ACPI / processor replace __attribute__((packed)) by __packed
    
    * acpi-lpss:
      ACPI / LPSS: Take I2C host controllers out of reset
    
    * acpi-battery:
      ACPI / battery: add quirk for Acer Aspire V5-573G
      ACPI / battery: use callback for setting up quirks

commit 3d915894f8317ac3e55b47da829aa65eb5f9ae97
Author: Christoph Jaeger <christophjaeger@linux.com>
Date:   Fri Jun 13 21:49:58 2014 +0200

    ACPI: use kstrto*() instead of simple_strto*()
    
    simple_strto*() are obsolete; use kstrto*() instead. Add proper error
    checking.
    
    Signed-off-by: Christoph Jaeger <christophjaeger@linux.com>
    Acked-by: David Rientjes <rientjes@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index e48fc98e71c4..5963e6f0a1ed 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -930,7 +930,10 @@ static ssize_t acpi_battery_write_alarm(struct file *file,
 		goto end;
 	}
 	alarm_string[count] = '\0';
-	battery->alarm = simple_strtol(alarm_string, NULL, 0);
+	if (kstrtoint(alarm_string, 0, &battery->alarm)) {
+		result = -EINVAL;
+		goto end;
+	}
 	result = acpi_battery_set_alarm(battery);
       end:
 	if (!result)

commit f43691c61d6e547809bff33394ac83cc263960e4
Author: Alexander Mezin <mezin.alexander@gmail.com>
Date:   Wed Jun 4 02:01:23 2014 +0700

    ACPI / battery: add quirk for Acer Aspire V5-573G
    
    On Acer Aspire V5-573G battery notifications are sometimes
    triggered too early. For example, when AC is unplugged and
    notification is triggered, battery state is still reported as
    "Full", and changes to "Discharging" only after short delay,
    without any notification.
    
    This patch solves the problem by adding 1 second sleep.
    Similar quirk is already implemented in AC driver for other laptop.
    
    Signed-off-by: Alexander Mezin <mezin.alexander@gmail.com>
    Acked-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 9530f4478ae2..1ce197f499f1 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -32,6 +32,7 @@
 #include <linux/jiffies.h>
 #include <linux/async.h>
 #include <linux/dmi.h>
+#include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/suspend.h>
 #include <asm/unaligned.h>
@@ -70,6 +71,7 @@ MODULE_DESCRIPTION("ACPI Battery Driver");
 MODULE_LICENSE("GPL");
 
 static int battery_bix_broken_package;
+static int battery_notification_delay_ms;
 static unsigned int cache_time = 1000;
 module_param(cache_time, uint, 0644);
 MODULE_PARM_DESC(cache_time, "cache time in milliseconds");
@@ -1062,6 +1064,14 @@ static void acpi_battery_notify(struct acpi_device *device, u32 event)
 	if (!battery)
 		return;
 	old = battery->bat.dev;
+	/*
+	* On Acer Aspire V5-573G notifications are sometimes triggered too
+	* early. For example, when AC is unplugged and notification is
+	* triggered, battery state is still reported as "Full", and changes to
+	* "Discharging" only after short delay, without any notification.
+	*/
+	if (battery_notification_delay_ms > 0)
+		msleep(battery_notification_delay_ms);
 	if (event == ACPI_BATTERY_NOTIFY_INFO)
 		acpi_battery_refresh(battery);
 	acpi_battery_update(battery, false);
@@ -1112,6 +1122,12 @@ static int battery_bix_broken_package_quirk(const struct dmi_system_id *d)
 	return 0;
 }
 
+static int battery_notification_delay_quirk(const struct dmi_system_id *d)
+{
+	battery_notification_delay_ms = 1000;
+	return 0;
+}
+
 static struct dmi_system_id bat_dmi_table[] = {
 	{
 		.callback = battery_bix_broken_package_quirk,
@@ -1121,6 +1137,14 @@ static struct dmi_system_id bat_dmi_table[] = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "PC-LZ750LS"),
 		},
 	},
+	{
+		.callback = battery_notification_delay_quirk,
+		.ident = "Acer Aspire V5-573G",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire V5-573G"),
+		},
+	},
 	{},
 };
 

commit 3f5dc08f5682bba2b9054ee8995e0d84fc14daad
Author: Alexander Mezin <mezin.alexander@gmail.com>
Date:   Wed Jun 4 02:01:22 2014 +0700

    ACPI / battery: use callback for setting up quirks
    
    Use callback for setting up quirk instead of checking return code
    of dmi_check_system(). This change will allow using bat_dmi_table
    for other quirks.
    
    Signed-off-by: Alexander Mezin <mezin.alexander@gmail.com>
    Acked-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index e48fc98e71c4..9530f4478ae2 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1106,8 +1106,15 @@ static int battery_notify(struct notifier_block *nb,
 	return 0;
 }
 
+static int battery_bix_broken_package_quirk(const struct dmi_system_id *d)
+{
+	battery_bix_broken_package = 1;
+	return 0;
+}
+
 static struct dmi_system_id bat_dmi_table[] = {
 	{
+		.callback = battery_bix_broken_package_quirk,
 		.ident = "NEC LZ750/LS",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "NEC"),
@@ -1227,8 +1234,7 @@ static void __init acpi_battery_init_async(void *unused, async_cookie_t cookie)
 	if (acpi_disabled)
 		return;
 
-	if (dmi_check_system(bat_dmi_table))
-		battery_bix_broken_package = 1;
+	dmi_check_system(bat_dmi_table);
 	
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	acpi_battery_dir = acpi_lock_battery_dir();

commit e0d1f09e311fafa33b4bfd942c852671ce25ae58
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Wed May 28 15:23:38 2014 +0800

    ACPI / battery: wakeup the system only when necessary
    
    ACPI Battery device receives notifications from firmware frequently,
    and most of these notifications are some general events, like battery
    remaining capacity change, etc, which should not wake the system up
    if the system is in suspend/hibernate state.
    
    This causes a problem that the system wakes up from suspend to freeze
    shortly, because there is an ACPI battery notification every 10 seconds.
    
    Fix the problem in this patch by registering ACPI battery device'
    own wakeup source, and waking up the system only when the battery remaining
    capacity is critical low, or lower than the alarm capacity set via _BTP.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=76221
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 11285e7df278..e48fc98e71c4 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -622,7 +622,8 @@ static int sysfs_add_battery(struct acpi_battery *battery)
 	battery->bat.type = POWER_SUPPLY_TYPE_BATTERY;
 	battery->bat.get_property = acpi_battery_get_property;
 
-	result = power_supply_register(&battery->device->dev, &battery->bat);
+	result = power_supply_register_no_ws(&battery->device->dev, &battery->bat);
+
 	if (result)
 		return result;
 	return device_create_file(battery->bat.dev, &alarm_attr);
@@ -741,7 +742,19 @@ static int acpi_battery_update(struct acpi_battery *battery, bool resume)
 			return result;
 	}
 	result = acpi_battery_get_state(battery);
+	if (result)
+		return result;
 	acpi_battery_quirks(battery);
+
+	/*
+	 * Wakeup the system if battery is critical low
+	 * or lower than the alarm level
+	 */
+	if ((battery->state & ACPI_BATTERY_STATE_CRITICAL) ||
+	    (test_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags) &&
+            (battery->capacity_now <= battery->alarm)))
+		pm_wakeup_event(&battery->device->dev, 0);
+
 	return result;
 }
 
@@ -1142,6 +1155,8 @@ static int acpi_battery_add(struct acpi_device *device)
 	battery->pm_nb.notifier_call = battery_notify;
 	register_pm_notifier(&battery->pm_nb);
 
+	device_init_wakeup(&device->dev, 1);
+
 	return result;
 
 fail:
@@ -1158,6 +1173,7 @@ static int acpi_battery_remove(struct acpi_device *device)
 
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
+	device_init_wakeup(&device->dev, 0);
 	battery = acpi_driver_data(device);
 	unregister_pm_notifier(&battery->pm_nb);
 #ifdef CONFIG_ACPI_PROCFS_POWER

commit 1ac5aaa67290b397712e4410de7f067d5cd85871
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Wed May 28 15:23:36 2014 +0800

    ACPI / battery: introduce support for POWER_SUPPLY_PROP_CAPACITY_LEVEL
    
    ACPI battery device receives notifications when
    1. the remaining battery capacity becomes critical low
    2. the trip point set by the _BTP (Design capacity of Warning by default)
       is reached or crossed.
    
    So it is able to support POWER_SUPPLY_PROP_CAPACITY_LEVEL to report
            POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL,
            POWER_SUPPLY_CAPACITY_LEVEL_LOW,
            POWER_SUPPLY_CAPACITY_LEVEL_NORMAL,
            POWER_SUPPLY_CAPACITY_LEVEL_FULL,
    capacity levels to power supply core and user space.
    
    Introduce support for POWER_SUPPLY_PROP_CAPACITY_LEVEL in this patch.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 3b4921e4dc4e..11285e7df278 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -56,6 +56,10 @@
 /* Battery power unit: 0 means mW, 1 means mA */
 #define ACPI_BATTERY_POWER_UNIT_MA	1
 
+#define ACPI_BATTERY_STATE_DISCHARGING	0x1
+#define ACPI_BATTERY_STATE_CHARGING	0x2
+#define ACPI_BATTERY_STATE_CRITICAL	0x4
+
 #define _COMPONENT		ACPI_BATTERY_COMPONENT
 
 ACPI_MODULE_NAME("battery");
@@ -169,7 +173,7 @@ static int acpi_battery_get_state(struct acpi_battery *battery);
 
 static int acpi_battery_is_charged(struct acpi_battery *battery)
 {
-	/* either charging or discharging */
+	/* charging, discharging or critical low */
 	if (battery->state != 0)
 		return 0;
 
@@ -204,9 +208,9 @@ static int acpi_battery_get_property(struct power_supply *psy,
 		return -ENODEV;
 	switch (psp) {
 	case POWER_SUPPLY_PROP_STATUS:
-		if (battery->state & 0x01)
+		if (battery->state & ACPI_BATTERY_STATE_DISCHARGING)
 			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
-		else if (battery->state & 0x02)
+		else if (battery->state & ACPI_BATTERY_STATE_CHARGING)
 			val->intval = POWER_SUPPLY_STATUS_CHARGING;
 		else if (acpi_battery_is_charged(battery))
 			val->intval = POWER_SUPPLY_STATUS_FULL;
@@ -269,6 +273,17 @@ static int acpi_battery_get_property(struct power_supply *psy,
 		else
 			val->intval = 0;
 		break;
+	case POWER_SUPPLY_PROP_CAPACITY_LEVEL:
+		if (battery->state & ACPI_BATTERY_STATE_CRITICAL)
+			val->intval = POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;
+		else if (test_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags) &&
+			(battery->capacity_now <= battery->alarm))
+			val->intval = POWER_SUPPLY_CAPACITY_LEVEL_LOW;
+		else if (acpi_battery_is_charged(battery))
+			val->intval = POWER_SUPPLY_CAPACITY_LEVEL_FULL;
+		else
+			val->intval = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;
+		break;
 	case POWER_SUPPLY_PROP_MODEL_NAME:
 		val->strval = battery->model_number;
 		break;
@@ -296,6 +311,7 @@ static enum power_supply_property charge_battery_props[] = {
 	POWER_SUPPLY_PROP_CHARGE_FULL,
 	POWER_SUPPLY_PROP_CHARGE_NOW,
 	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
 	POWER_SUPPLY_PROP_MODEL_NAME,
 	POWER_SUPPLY_PROP_MANUFACTURER,
 	POWER_SUPPLY_PROP_SERIAL_NUMBER,
@@ -313,6 +329,7 @@ static enum power_supply_property energy_battery_props[] = {
 	POWER_SUPPLY_PROP_ENERGY_FULL,
 	POWER_SUPPLY_PROP_ENERGY_NOW,
 	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
 	POWER_SUPPLY_PROP_MODEL_NAME,
 	POWER_SUPPLY_PROP_MANUFACTURER,
 	POWER_SUPPLY_PROP_SERIAL_NUMBER,

commit 9e50bc14a7f58b5d8a55973b2d69355852ae2dae
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Sun May 4 14:07:06 2014 +0800

    ACPI / battery: Accelerate battery resume callback
    
    Most time of battery resume callback is spent on executing AML code
    _BTP, _BIF and _BIF to get battery info, status and set alarm. These
    AML methods may access EC operation regions several times and consumes
    time.
    
    These operations are not necessary during devices resume and can run
    during POST_SUSPEND/HIBERNATION event when all processes are thawed.
    
    This also can avoid removing and adding battery sysfs nodes every system
    resume even if the battery unit is not actually changed. The original code
    updates sysfs nodes without check and this seems not reasonable.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 6e7b2a12860d..3b4921e4dc4e 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -696,7 +696,7 @@ static void acpi_battery_quirks(struct acpi_battery *battery)
 	}
 }
 
-static int acpi_battery_update(struct acpi_battery *battery)
+static int acpi_battery_update(struct acpi_battery *battery, bool resume)
 {
 	int result, old_present = acpi_battery_present(battery);
 	result = acpi_battery_get_status(battery);
@@ -707,6 +707,10 @@ static int acpi_battery_update(struct acpi_battery *battery)
 		battery->update_time = 0;
 		return 0;
 	}
+
+	if (resume)
+		return 0;
+
 	if (!battery->update_time ||
 	    old_present != acpi_battery_present(battery)) {
 		result = acpi_battery_get_info(battery);
@@ -915,7 +919,7 @@ static print_func acpi_print_funcs[ACPI_BATTERY_NUMFILES] = {
 static int acpi_battery_read(int fid, struct seq_file *seq)
 {
 	struct acpi_battery *battery = seq->private;
-	int result = acpi_battery_update(battery);
+	int result = acpi_battery_update(battery, false);
 	return acpi_print_funcs[fid](seq, result);
 }
 
@@ -1030,7 +1034,7 @@ static void acpi_battery_notify(struct acpi_device *device, u32 event)
 	old = battery->bat.dev;
 	if (event == ACPI_BATTERY_NOTIFY_INFO)
 		acpi_battery_refresh(battery);
-	acpi_battery_update(battery);
+	acpi_battery_update(battery, false);
 	acpi_bus_generate_netlink_event(device->pnp.device_class,
 					dev_name(&device->dev), event,
 					acpi_battery_present(battery));
@@ -1045,13 +1049,27 @@ static int battery_notify(struct notifier_block *nb,
 {
 	struct acpi_battery *battery = container_of(nb, struct acpi_battery,
 						    pm_nb);
+	int result;
+
 	switch (mode) {
 	case PM_POST_HIBERNATION:
 	case PM_POST_SUSPEND:
-		if (battery->bat.dev) {
-			sysfs_remove_battery(battery);
-			sysfs_add_battery(battery);
-		}
+		if (!acpi_battery_present(battery))
+			return 0;
+
+		if (!battery->bat.dev) {
+			result = acpi_battery_get_info(battery);
+			if (result)
+				return result;
+
+			result = sysfs_add_battery(battery);
+			if (result)
+				return result;
+		} else
+			acpi_battery_refresh(battery);
+
+		acpi_battery_init_alarm(battery);
+		acpi_battery_get_state(battery);
 		break;
 	}
 
@@ -1087,7 +1105,7 @@ static int acpi_battery_add(struct acpi_device *device)
 	mutex_init(&battery->sysfs_lock);
 	if (acpi_has_method(battery->device->handle, "_BIX"))
 		set_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags);
-	result = acpi_battery_update(battery);
+	result = acpi_battery_update(battery, false);
 	if (result)
 		goto fail;
 #ifdef CONFIG_ACPI_PROCFS_POWER
@@ -1149,7 +1167,7 @@ static int acpi_battery_resume(struct device *dev)
 		return -EINVAL;
 
 	battery->update_time = 0;
-	acpi_battery_update(battery);
+	acpi_battery_update(battery, true);
 	return 0;
 }
 #else

commit 3a670cc79342c36d308decd5f90351830ed1685c
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Sun May 4 11:07:25 2014 +0800

    ACPI: Revert "ACPI / Battery: Remove battery's proc directory"
    
    The commit 1e2d9cd and 7d7ee95 remove ACPI Proc Battery
    directory and breaks some old userspace tools. This patch
    is to revert commit 1e2d9cd.
    
    Fixes: 1e2d9cdfb449 (ACPI / Battery: Remove battery's proc directory)
    Cc: 3.13+ <stable@vger.kernel.org> # 3.13+
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 9a2c63b20050..6e7b2a12860d 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -36,6 +36,12 @@
 #include <linux/suspend.h>
 #include <asm/unaligned.h>
 
+#ifdef CONFIG_ACPI_PROCFS_POWER
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <asm/uaccess.h>
+#endif
+
 #include <linux/acpi.h>
 #include <linux/power_supply.h>
 
@@ -64,6 +70,19 @@ static unsigned int cache_time = 1000;
 module_param(cache_time, uint, 0644);
 MODULE_PARM_DESC(cache_time, "cache time in milliseconds");
 
+#ifdef CONFIG_ACPI_PROCFS_POWER
+extern struct proc_dir_entry *acpi_lock_battery_dir(void);
+extern void *acpi_unlock_battery_dir(struct proc_dir_entry *acpi_battery_dir);
+
+enum acpi_battery_files {
+	info_tag = 0,
+	state_tag,
+	alarm_tag,
+	ACPI_BATTERY_NUMFILES,
+};
+
+#endif
+
 static const struct acpi_device_id battery_device_ids[] = {
 	{"PNP0C0A", 0},
 	{"", 0},
@@ -299,6 +318,14 @@ static enum power_supply_property energy_battery_props[] = {
 	POWER_SUPPLY_PROP_SERIAL_NUMBER,
 };
 
+#ifdef CONFIG_ACPI_PROCFS_POWER
+inline char *acpi_battery_units(struct acpi_battery *battery)
+{
+	return (battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA) ?
+		"mA" : "mW";
+}
+#endif
+
 /* --------------------------------------------------------------------------
                                Battery Management
    -------------------------------------------------------------------------- */
@@ -716,6 +743,279 @@ static void acpi_battery_refresh(struct acpi_battery *battery)
 	sysfs_add_battery(battery);
 }
 
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+#ifdef CONFIG_ACPI_PROCFS_POWER
+static struct proc_dir_entry *acpi_battery_dir;
+
+static int acpi_battery_print_info(struct seq_file *seq, int result)
+{
+	struct acpi_battery *battery = seq->private;
+
+	if (result)
+		goto end;
+
+	seq_printf(seq, "present:                 %s\n",
+		   acpi_battery_present(battery) ? "yes" : "no");
+	if (!acpi_battery_present(battery))
+		goto end;
+	if (battery->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+		seq_printf(seq, "design capacity:         unknown\n");
+	else
+		seq_printf(seq, "design capacity:         %d %sh\n",
+			   battery->design_capacity,
+			   acpi_battery_units(battery));
+
+	if (battery->full_charge_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+		seq_printf(seq, "last full capacity:      unknown\n");
+	else
+		seq_printf(seq, "last full capacity:      %d %sh\n",
+			   battery->full_charge_capacity,
+			   acpi_battery_units(battery));
+
+	seq_printf(seq, "battery technology:      %srechargeable\n",
+		   (!battery->technology)?"non-":"");
+
+	if (battery->design_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
+		seq_printf(seq, "design voltage:          unknown\n");
+	else
+		seq_printf(seq, "design voltage:          %d mV\n",
+			   battery->design_voltage);
+	seq_printf(seq, "design capacity warning: %d %sh\n",
+		   battery->design_capacity_warning,
+		   acpi_battery_units(battery));
+	seq_printf(seq, "design capacity low:     %d %sh\n",
+		   battery->design_capacity_low,
+		   acpi_battery_units(battery));
+	seq_printf(seq, "cycle count:		  %i\n", battery->cycle_count);
+	seq_printf(seq, "capacity granularity 1:  %d %sh\n",
+		   battery->capacity_granularity_1,
+		   acpi_battery_units(battery));
+	seq_printf(seq, "capacity granularity 2:  %d %sh\n",
+		   battery->capacity_granularity_2,
+		   acpi_battery_units(battery));
+	seq_printf(seq, "model number:            %s\n", battery->model_number);
+	seq_printf(seq, "serial number:           %s\n", battery->serial_number);
+	seq_printf(seq, "battery type:            %s\n", battery->type);
+	seq_printf(seq, "OEM info:                %s\n", battery->oem_info);
+      end:
+	if (result)
+		seq_printf(seq, "ERROR: Unable to read battery info\n");
+	return result;
+}
+
+static int acpi_battery_print_state(struct seq_file *seq, int result)
+{
+	struct acpi_battery *battery = seq->private;
+
+	if (result)
+		goto end;
+
+	seq_printf(seq, "present:                 %s\n",
+		   acpi_battery_present(battery) ? "yes" : "no");
+	if (!acpi_battery_present(battery))
+		goto end;
+
+	seq_printf(seq, "capacity state:          %s\n",
+			(battery->state & 0x04) ? "critical" : "ok");
+	if ((battery->state & 0x01) && (battery->state & 0x02))
+		seq_printf(seq,
+			   "charging state:          charging/discharging\n");
+	else if (battery->state & 0x01)
+		seq_printf(seq, "charging state:          discharging\n");
+	else if (battery->state & 0x02)
+		seq_printf(seq, "charging state:          charging\n");
+	else
+		seq_printf(seq, "charging state:          charged\n");
+
+	if (battery->rate_now == ACPI_BATTERY_VALUE_UNKNOWN)
+		seq_printf(seq, "present rate:            unknown\n");
+	else
+		seq_printf(seq, "present rate:            %d %s\n",
+			   battery->rate_now, acpi_battery_units(battery));
+
+	if (battery->capacity_now == ACPI_BATTERY_VALUE_UNKNOWN)
+		seq_printf(seq, "remaining capacity:      unknown\n");
+	else
+		seq_printf(seq, "remaining capacity:      %d %sh\n",
+			   battery->capacity_now, acpi_battery_units(battery));
+	if (battery->voltage_now == ACPI_BATTERY_VALUE_UNKNOWN)
+		seq_printf(seq, "present voltage:         unknown\n");
+	else
+		seq_printf(seq, "present voltage:         %d mV\n",
+			   battery->voltage_now);
+      end:
+	if (result)
+		seq_printf(seq, "ERROR: Unable to read battery state\n");
+
+	return result;
+}
+
+static int acpi_battery_print_alarm(struct seq_file *seq, int result)
+{
+	struct acpi_battery *battery = seq->private;
+
+	if (result)
+		goto end;
+
+	if (!acpi_battery_present(battery)) {
+		seq_printf(seq, "present:                 no\n");
+		goto end;
+	}
+	seq_printf(seq, "alarm:                   ");
+	if (!battery->alarm)
+		seq_printf(seq, "unsupported\n");
+	else
+		seq_printf(seq, "%u %sh\n", battery->alarm,
+				acpi_battery_units(battery));
+      end:
+	if (result)
+		seq_printf(seq, "ERROR: Unable to read battery alarm\n");
+	return result;
+}
+
+static ssize_t acpi_battery_write_alarm(struct file *file,
+					const char __user * buffer,
+					size_t count, loff_t * ppos)
+{
+	int result = 0;
+	char alarm_string[12] = { '\0' };
+	struct seq_file *m = file->private_data;
+	struct acpi_battery *battery = m->private;
+
+	if (!battery || (count > sizeof(alarm_string) - 1))
+		return -EINVAL;
+	if (!acpi_battery_present(battery)) {
+		result = -ENODEV;
+		goto end;
+	}
+	if (copy_from_user(alarm_string, buffer, count)) {
+		result = -EFAULT;
+		goto end;
+	}
+	alarm_string[count] = '\0';
+	battery->alarm = simple_strtol(alarm_string, NULL, 0);
+	result = acpi_battery_set_alarm(battery);
+      end:
+	if (!result)
+		return count;
+	return result;
+}
+
+typedef int(*print_func)(struct seq_file *seq, int result);
+
+static print_func acpi_print_funcs[ACPI_BATTERY_NUMFILES] = {
+	acpi_battery_print_info,
+	acpi_battery_print_state,
+	acpi_battery_print_alarm,
+};
+
+static int acpi_battery_read(int fid, struct seq_file *seq)
+{
+	struct acpi_battery *battery = seq->private;
+	int result = acpi_battery_update(battery);
+	return acpi_print_funcs[fid](seq, result);
+}
+
+#define DECLARE_FILE_FUNCTIONS(_name) \
+static int acpi_battery_read_##_name(struct seq_file *seq, void *offset) \
+{ \
+	return acpi_battery_read(_name##_tag, seq); \
+} \
+static int acpi_battery_##_name##_open_fs(struct inode *inode, struct file *file) \
+{ \
+	return single_open(file, acpi_battery_read_##_name, PDE_DATA(inode)); \
+}
+
+DECLARE_FILE_FUNCTIONS(info);
+DECLARE_FILE_FUNCTIONS(state);
+DECLARE_FILE_FUNCTIONS(alarm);
+
+#undef DECLARE_FILE_FUNCTIONS
+
+#define FILE_DESCRIPTION_RO(_name) \
+	{ \
+	.name = __stringify(_name), \
+	.mode = S_IRUGO, \
+	.ops = { \
+		.open = acpi_battery_##_name##_open_fs, \
+		.read = seq_read, \
+		.llseek = seq_lseek, \
+		.release = single_release, \
+		.owner = THIS_MODULE, \
+		}, \
+	}
+
+#define FILE_DESCRIPTION_RW(_name) \
+	{ \
+	.name = __stringify(_name), \
+	.mode = S_IFREG | S_IRUGO | S_IWUSR, \
+	.ops = { \
+		.open = acpi_battery_##_name##_open_fs, \
+		.read = seq_read, \
+		.llseek = seq_lseek, \
+		.write = acpi_battery_write_##_name, \
+		.release = single_release, \
+		.owner = THIS_MODULE, \
+		}, \
+	}
+
+static const struct battery_file {
+	struct file_operations ops;
+	umode_t mode;
+	const char *name;
+} acpi_battery_file[] = {
+	FILE_DESCRIPTION_RO(info),
+	FILE_DESCRIPTION_RO(state),
+	FILE_DESCRIPTION_RW(alarm),
+};
+
+#undef FILE_DESCRIPTION_RO
+#undef FILE_DESCRIPTION_RW
+
+static int acpi_battery_add_fs(struct acpi_device *device)
+{
+	struct proc_dir_entry *entry = NULL;
+	int i;
+
+	printk(KERN_WARNING PREFIX "Deprecated procfs I/F for battery is loaded,"
+			" please retry with CONFIG_ACPI_PROCFS_POWER cleared\n");
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+						     acpi_battery_dir);
+		if (!acpi_device_dir(device))
+			return -ENODEV;
+	}
+
+	for (i = 0; i < ACPI_BATTERY_NUMFILES; ++i) {
+		entry = proc_create_data(acpi_battery_file[i].name,
+					 acpi_battery_file[i].mode,
+					 acpi_device_dir(device),
+					 &acpi_battery_file[i].ops,
+					 acpi_driver_data(device));
+		if (!entry)
+			return -ENODEV;
+	}
+	return 0;
+}
+
+static void acpi_battery_remove_fs(struct acpi_device *device)
+{
+	int i;
+	if (!acpi_device_dir(device))
+		return;
+	for (i = 0; i < ACPI_BATTERY_NUMFILES; ++i)
+		remove_proc_entry(acpi_battery_file[i].name,
+				  acpi_device_dir(device));
+
+	remove_proc_entry(acpi_device_bid(device), acpi_battery_dir);
+	acpi_device_dir(device) = NULL;
+}
+
+#endif
+
 /* --------------------------------------------------------------------------
                                  Driver Interface
    -------------------------------------------------------------------------- */
@@ -790,6 +1090,15 @@ static int acpi_battery_add(struct acpi_device *device)
 	result = acpi_battery_update(battery);
 	if (result)
 		goto fail;
+#ifdef CONFIG_ACPI_PROCFS_POWER
+	result = acpi_battery_add_fs(device);
+#endif
+	if (result) {
+#ifdef CONFIG_ACPI_PROCFS_POWER
+		acpi_battery_remove_fs(device);
+#endif
+		goto fail;
+	}
 
 	printk(KERN_INFO PREFIX "%s Slot [%s] (battery %s)\n",
 		ACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),
@@ -816,6 +1125,9 @@ static int acpi_battery_remove(struct acpi_device *device)
 		return -EINVAL;
 	battery = acpi_driver_data(device);
 	unregister_pm_notifier(&battery->pm_nb);
+#ifdef CONFIG_ACPI_PROCFS_POWER
+	acpi_battery_remove_fs(device);
+#endif
 	sysfs_remove_battery(battery);
 	mutex_destroy(&battery->lock);
 	mutex_destroy(&battery->sysfs_lock);
@@ -866,7 +1178,19 @@ static void __init acpi_battery_init_async(void *unused, async_cookie_t cookie)
 
 	if (dmi_check_system(bat_dmi_table))
 		battery_bix_broken_package = 1;
-	acpi_bus_register_driver(&acpi_battery_driver);
+	
+#ifdef CONFIG_ACPI_PROCFS_POWER
+	acpi_battery_dir = acpi_lock_battery_dir();
+	if (!acpi_battery_dir)
+		return;
+#endif
+	if (acpi_bus_register_driver(&acpi_battery_driver) < 0) {
+#ifdef CONFIG_ACPI_PROCFS_POWER
+		acpi_unlock_battery_dir(acpi_battery_dir);
+#endif
+		return;
+	}
+	return;
 }
 
 static int __init acpi_battery_init(void)
@@ -878,6 +1202,9 @@ static int __init acpi_battery_init(void)
 static void __exit acpi_battery_exit(void)
 {
 	acpi_bus_unregister_driver(&acpi_battery_driver);
+#ifdef CONFIG_ACPI_PROCFS_POWER
+	acpi_unlock_battery_dir(acpi_battery_dir);
+#endif
 }
 
 module_init(acpi_battery_init);

commit 411e0f77bdf79cdb80b61ab78acc6513c9ff8f97
Author: Alexander Mezin <mezin.alexander@gmail.com>
Date:   Wed Mar 12 00:58:47 2014 +0700

    ACPI / battery: call ACPI notifier chain in acpi_battery_notify
    
    Allow other drivers to subscribe to battery status notifications.
    Just like AC driver does.
    
    Signed-off-by: Alexander Mezin <mezin.alexander@gmail.com>
    Acked-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index bfec70f12faa..9a2c63b20050 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -734,6 +734,7 @@ static void acpi_battery_notify(struct acpi_device *device, u32 event)
 	acpi_bus_generate_netlink_event(device->pnp.device_class,
 					dev_name(&device->dev), event,
 					acpi_battery_present(battery));
+	acpi_notifier_call_chain(device, event, acpi_battery_present(battery));
 	/* acpi_battery_update could remove power_supply object */
 	if (old && battery->bat.dev)
 		power_supply_changed(&battery->bat);

commit f03be3525f1fac98b03a994522a7d78e9a70fe52
Author: Alexander Mezin <mezin.alexander@gmail.com>
Date:   Wed Mar 12 00:58:46 2014 +0700

    ACPI / battery: move some ACPI_BATTERY_* definitions to header
    
    ACPI_BATTERY_CLASS is used in multiple places.
    Also, I'll use ACPI_BATTERY_NOTIFY_STATUS inside AC driver in
    one of following patches.
    
    So, create a header file and move ACPI_BATTERY_CLASS and
    ACPI_BATTERY_NOTIFY_* definitions into it.
    Also, remove copy of ACPI_BATTERY_CLASS from sbs.c
    
    Signed-off-by: Alexander Mezin <mezin.alexander@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 797a6938d051..bfec70f12faa 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -39,15 +39,13 @@
 #include <linux/acpi.h>
 #include <linux/power_supply.h>
 
+#include "battery.h"
+
 #define PREFIX "ACPI: "
 
 #define ACPI_BATTERY_VALUE_UNKNOWN 0xFFFFFFFF
 
-#define ACPI_BATTERY_CLASS		"battery"
 #define ACPI_BATTERY_DEVICE_NAME	"Battery"
-#define ACPI_BATTERY_NOTIFY_STATUS	0x80
-#define ACPI_BATTERY_NOTIFY_INFO	0x81
-#define ACPI_BATTERY_NOTIFY_THRESHOLD   0x82
 
 /* Battery power unit: 0 means mW, 1 means mA */
 #define ACPI_BATTERY_POWER_UNIT_MA	1

commit 7f6895c60f40354b5adf0320ea5ef8e47cf475c9
Author: Shuah Khan <shuah.kh@samsung.com>
Date:   Wed Feb 12 20:19:06 2014 -0700

    ACPI / battery: fix battery driver compile error when CONFIG_PM_SLEEP is undefined
    
    The ACPI battery driver defines acpi_battery_resume() when
    CONFIG_PM_SLEEP is defined. This results in the following compile
    error when CONFIG_PM_SLEEP is undefined:
    
    drivers/acpi/battery.c:847:8: error: acpi_battery_resume undeclared here (not in a function)
    
    Signed-off-by: Shuah Khan <shuah.kh@samsung.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 018a42883706..797a6938d051 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -841,6 +841,8 @@ static int acpi_battery_resume(struct device *dev)
 	acpi_battery_update(battery);
 	return 0;
 }
+#else
+#define acpi_battery_resume NULL
 #endif
 
 static SIMPLE_DEV_PM_OPS(acpi_battery_pm, NULL, acpi_battery_resume);

commit 47a08c85f70ebdbaaf42b444af57dd6f83e04485
Author: Luis G.F <luisgf@luisgf.es>
Date:   Tue Jan 21 15:40:43 2014 +0100

    ACPI / battery: Fix incorrect sscanf() string in acpi_battery_init_alarm()
    
    Fix incorrect sscanf() string in acpi_battery_init_alarm().
    Change from %ld to %lu, because 'x' is unsigned long.
    
    Signed-off-by: Luis G.F <luisgf@luisgf.es>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 470e7542bf31..018a42883706 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -549,7 +549,7 @@ static ssize_t acpi_battery_alarm_store(struct device *dev,
 {
 	unsigned long x;
 	struct acpi_battery *battery = to_acpi_battery(dev_get_drvdata(dev));
-	if (sscanf(buf, "%ld\n", &x) == 1)
+	if (sscanf(buf, "%lu\n", &x) == 1)
 		battery->alarm = x/1000;
 	if (acpi_battery_present(battery))
 		acpi_battery_set_alarm(battery);

commit 98feb7cc61c50fe0fa36eeb994d5db527ca9e103
Merge: 7e22e91102c6 f8a571b2a128
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 12 23:44:09 2014 +0100

    Merge branch 'acpi-cleanup'
    
    * acpi-cleanup: (22 commits)
      ACPI / tables: Return proper error codes from acpi_table_parse() and fix comment.
      ACPI / tables: Check if id is NULL in acpi_table_parse()
      ACPI / proc: Include appropriate header file in proc.c
      ACPI / EC: Remove unused functions and add prototype declaration in internal.h
      ACPI / dock: Include appropriate header file in dock.c
      ACPI / PCI: Include appropriate header file in pci_link.c
      ACPI / PCI: Include appropriate header file in pci_slot.c
      ACPI / EC: Mark the function acpi_ec_add_debugfs() as static in ec_sys.c
      ACPI / NVS: Include appropriate header file in nvs.c
      ACPI / OSL: Mark the function acpi_table_checksum() as static
      ACPI / processor: initialize a variable to silence compiler warning
      ACPI / processor: use ACPI_COMPANION() to get ACPI device
      ACPI: correct minor typos
      ACPI / sleep: Drop redundant acpi_disabled check
      ACPI / dock: Drop redundant acpi_disabled check
      ACPI / table: Replace '1' with specific error return values
      ACPI: remove trailing whitespace
      ACPI / IBFT: Fix incorrect <acpi/acpi.h> inclusion in iSCSI boot firmware module
      ACPI / i915: Fix incorrect <acpi/acpi.h> inclusions via <linux/acpi_io.h>
      SFI / ACPI: Fix warnings reported during builds with W=1
      ...
    
    Conflicts:
            drivers/acpi/nvs.c
            drivers/hwmon/asus_atk0110.c

commit a90b40385735af0d3031f98e97b439e8944a31b3
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Mon Jan 6 22:50:37 2014 +0800

    ACPI / Battery: Add a _BIX quirk for NEC LZ750/LS
    
    The AML method _BIX of NEC LZ750/LS returns a broken package which
    skips the first member "Revision" (ACPI 5.0, Table 10-234).
    
    Add a quirk for this machine to skip member "Revision" during parsing
    the package returned by _BIX.
    
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=67351
    Reported-and-tested-by: Francisco Castro <fcr@adinet.com.uy>
    Cc: 3.8+ <stable@vger.kernel.org> " 3.8+
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index fbf1aceda8b8..5876a49dfd38 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -62,6 +62,7 @@ MODULE_AUTHOR("Alexey Starikovskiy <astarikovskiy@suse.de>");
 MODULE_DESCRIPTION("ACPI Battery Driver");
 MODULE_LICENSE("GPL");
 
+static int battery_bix_broken_package;
 static unsigned int cache_time = 1000;
 module_param(cache_time, uint, 0644);
 MODULE_PARM_DESC(cache_time, "cache time in milliseconds");
@@ -416,7 +417,12 @@ static int acpi_battery_get_info(struct acpi_battery *battery)
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating %s", name));
 		return -ENODEV;
 	}
-	if (test_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags))
+
+	if (battery_bix_broken_package)
+		result = extract_package(battery, buffer.pointer,
+				extended_info_offsets + 1,
+				ARRAY_SIZE(extended_info_offsets) - 1);
+	else if (test_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags))
 		result = extract_package(battery, buffer.pointer,
 				extended_info_offsets,
 				ARRAY_SIZE(extended_info_offsets));
@@ -754,6 +760,17 @@ static int battery_notify(struct notifier_block *nb,
 	return 0;
 }
 
+static struct dmi_system_id bat_dmi_table[] = {
+	{
+		.ident = "NEC LZ750/LS",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "NEC"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "PC-LZ750LS"),
+		},
+	},
+	{},
+};
+
 static int acpi_battery_add(struct acpi_device *device)
 {
 	int result = 0;
@@ -846,6 +863,9 @@ static void __init acpi_battery_init_async(void *unused, async_cookie_t cookie)
 {
 	if (acpi_disabled)
 		return;
+
+	if (dmi_check_system(bat_dmi_table))
+		battery_bix_broken_package = 1;
 	acpi_bus_register_driver(&acpi_battery_driver);
 }
 

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index fbf1aceda8b8..e90ef8b96f26 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -36,8 +36,7 @@
 #include <linux/suspend.h>
 #include <asm/unaligned.h>
 
-#include <acpi/acpi_bus.h>
-#include <acpi/acpi_drivers.h>
+#include <linux/acpi.h>
 #include <linux/power_supply.h>
 
 #define PREFIX "ACPI: "

commit 1e2d9cdfb4494fce682b4ae010d86a2766816d36
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Fri Oct 11 09:54:08 2013 +0800

    ACPI / Battery: Remove battery's proc directory
    
    The battery's proc directory isn't useded and remove it.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 2c9958cd7a43..fbf1aceda8b8 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -36,12 +36,6 @@
 #include <linux/suspend.h>
 #include <asm/unaligned.h>
 
-#ifdef CONFIG_ACPI_PROCFS_POWER
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#include <asm/uaccess.h>
-#endif
-
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 #include <linux/power_supply.h>
@@ -72,19 +66,6 @@ static unsigned int cache_time = 1000;
 module_param(cache_time, uint, 0644);
 MODULE_PARM_DESC(cache_time, "cache time in milliseconds");
 
-#ifdef CONFIG_ACPI_PROCFS_POWER
-extern struct proc_dir_entry *acpi_lock_battery_dir(void);
-extern void *acpi_unlock_battery_dir(struct proc_dir_entry *acpi_battery_dir);
-
-enum acpi_battery_files {
-	info_tag = 0,
-	state_tag,
-	alarm_tag,
-	ACPI_BATTERY_NUMFILES,
-};
-
-#endif
-
 static const struct acpi_device_id battery_device_ids[] = {
 	{"PNP0C0A", 0},
 	{"", 0},
@@ -320,14 +301,6 @@ static enum power_supply_property energy_battery_props[] = {
 	POWER_SUPPLY_PROP_SERIAL_NUMBER,
 };
 
-#ifdef CONFIG_ACPI_PROCFS_POWER
-inline char *acpi_battery_units(struct acpi_battery *battery)
-{
-	return (battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA) ?
-		"mA" : "mW";
-}
-#endif
-
 /* --------------------------------------------------------------------------
                                Battery Management
    -------------------------------------------------------------------------- */
@@ -740,279 +713,6 @@ static void acpi_battery_refresh(struct acpi_battery *battery)
 	sysfs_add_battery(battery);
 }
 
-/* --------------------------------------------------------------------------
-                              FS Interface (/proc)
-   -------------------------------------------------------------------------- */
-
-#ifdef CONFIG_ACPI_PROCFS_POWER
-static struct proc_dir_entry *acpi_battery_dir;
-
-static int acpi_battery_print_info(struct seq_file *seq, int result)
-{
-	struct acpi_battery *battery = seq->private;
-
-	if (result)
-		goto end;
-
-	seq_printf(seq, "present:                 %s\n",
-		   acpi_battery_present(battery) ? "yes" : "no");
-	if (!acpi_battery_present(battery))
-		goto end;
-	if (battery->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
-		seq_printf(seq, "design capacity:         unknown\n");
-	else
-		seq_printf(seq, "design capacity:         %d %sh\n",
-			   battery->design_capacity,
-			   acpi_battery_units(battery));
-
-	if (battery->full_charge_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
-		seq_printf(seq, "last full capacity:      unknown\n");
-	else
-		seq_printf(seq, "last full capacity:      %d %sh\n",
-			   battery->full_charge_capacity,
-			   acpi_battery_units(battery));
-
-	seq_printf(seq, "battery technology:      %srechargeable\n",
-		   (!battery->technology)?"non-":"");
-
-	if (battery->design_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
-		seq_printf(seq, "design voltage:          unknown\n");
-	else
-		seq_printf(seq, "design voltage:          %d mV\n",
-			   battery->design_voltage);
-	seq_printf(seq, "design capacity warning: %d %sh\n",
-		   battery->design_capacity_warning,
-		   acpi_battery_units(battery));
-	seq_printf(seq, "design capacity low:     %d %sh\n",
-		   battery->design_capacity_low,
-		   acpi_battery_units(battery));
-	seq_printf(seq, "cycle count:		  %i\n", battery->cycle_count);
-	seq_printf(seq, "capacity granularity 1:  %d %sh\n",
-		   battery->capacity_granularity_1,
-		   acpi_battery_units(battery));
-	seq_printf(seq, "capacity granularity 2:  %d %sh\n",
-		   battery->capacity_granularity_2,
-		   acpi_battery_units(battery));
-	seq_printf(seq, "model number:            %s\n", battery->model_number);
-	seq_printf(seq, "serial number:           %s\n", battery->serial_number);
-	seq_printf(seq, "battery type:            %s\n", battery->type);
-	seq_printf(seq, "OEM info:                %s\n", battery->oem_info);
-      end:
-	if (result)
-		seq_printf(seq, "ERROR: Unable to read battery info\n");
-	return result;
-}
-
-static int acpi_battery_print_state(struct seq_file *seq, int result)
-{
-	struct acpi_battery *battery = seq->private;
-
-	if (result)
-		goto end;
-
-	seq_printf(seq, "present:                 %s\n",
-		   acpi_battery_present(battery) ? "yes" : "no");
-	if (!acpi_battery_present(battery))
-		goto end;
-
-	seq_printf(seq, "capacity state:          %s\n",
-			(battery->state & 0x04) ? "critical" : "ok");
-	if ((battery->state & 0x01) && (battery->state & 0x02))
-		seq_printf(seq,
-			   "charging state:          charging/discharging\n");
-	else if (battery->state & 0x01)
-		seq_printf(seq, "charging state:          discharging\n");
-	else if (battery->state & 0x02)
-		seq_printf(seq, "charging state:          charging\n");
-	else
-		seq_printf(seq, "charging state:          charged\n");
-
-	if (battery->rate_now == ACPI_BATTERY_VALUE_UNKNOWN)
-		seq_printf(seq, "present rate:            unknown\n");
-	else
-		seq_printf(seq, "present rate:            %d %s\n",
-			   battery->rate_now, acpi_battery_units(battery));
-
-	if (battery->capacity_now == ACPI_BATTERY_VALUE_UNKNOWN)
-		seq_printf(seq, "remaining capacity:      unknown\n");
-	else
-		seq_printf(seq, "remaining capacity:      %d %sh\n",
-			   battery->capacity_now, acpi_battery_units(battery));
-	if (battery->voltage_now == ACPI_BATTERY_VALUE_UNKNOWN)
-		seq_printf(seq, "present voltage:         unknown\n");
-	else
-		seq_printf(seq, "present voltage:         %d mV\n",
-			   battery->voltage_now);
-      end:
-	if (result)
-		seq_printf(seq, "ERROR: Unable to read battery state\n");
-
-	return result;
-}
-
-static int acpi_battery_print_alarm(struct seq_file *seq, int result)
-{
-	struct acpi_battery *battery = seq->private;
-
-	if (result)
-		goto end;
-
-	if (!acpi_battery_present(battery)) {
-		seq_printf(seq, "present:                 no\n");
-		goto end;
-	}
-	seq_printf(seq, "alarm:                   ");
-	if (!battery->alarm)
-		seq_printf(seq, "unsupported\n");
-	else
-		seq_printf(seq, "%u %sh\n", battery->alarm,
-				acpi_battery_units(battery));
-      end:
-	if (result)
-		seq_printf(seq, "ERROR: Unable to read battery alarm\n");
-	return result;
-}
-
-static ssize_t acpi_battery_write_alarm(struct file *file,
-					const char __user * buffer,
-					size_t count, loff_t * ppos)
-{
-	int result = 0;
-	char alarm_string[12] = { '\0' };
-	struct seq_file *m = file->private_data;
-	struct acpi_battery *battery = m->private;
-
-	if (!battery || (count > sizeof(alarm_string) - 1))
-		return -EINVAL;
-	if (!acpi_battery_present(battery)) {
-		result = -ENODEV;
-		goto end;
-	}
-	if (copy_from_user(alarm_string, buffer, count)) {
-		result = -EFAULT;
-		goto end;
-	}
-	alarm_string[count] = '\0';
-	battery->alarm = simple_strtol(alarm_string, NULL, 0);
-	result = acpi_battery_set_alarm(battery);
-      end:
-	if (!result)
-		return count;
-	return result;
-}
-
-typedef int(*print_func)(struct seq_file *seq, int result);
-
-static print_func acpi_print_funcs[ACPI_BATTERY_NUMFILES] = {
-	acpi_battery_print_info,
-	acpi_battery_print_state,
-	acpi_battery_print_alarm,
-};
-
-static int acpi_battery_read(int fid, struct seq_file *seq)
-{
-	struct acpi_battery *battery = seq->private;
-	int result = acpi_battery_update(battery);
-	return acpi_print_funcs[fid](seq, result);
-}
-
-#define DECLARE_FILE_FUNCTIONS(_name) \
-static int acpi_battery_read_##_name(struct seq_file *seq, void *offset) \
-{ \
-	return acpi_battery_read(_name##_tag, seq); \
-} \
-static int acpi_battery_##_name##_open_fs(struct inode *inode, struct file *file) \
-{ \
-	return single_open(file, acpi_battery_read_##_name, PDE_DATA(inode)); \
-}
-
-DECLARE_FILE_FUNCTIONS(info);
-DECLARE_FILE_FUNCTIONS(state);
-DECLARE_FILE_FUNCTIONS(alarm);
-
-#undef DECLARE_FILE_FUNCTIONS
-
-#define FILE_DESCRIPTION_RO(_name) \
-	{ \
-	.name = __stringify(_name), \
-	.mode = S_IRUGO, \
-	.ops = { \
-		.open = acpi_battery_##_name##_open_fs, \
-		.read = seq_read, \
-		.llseek = seq_lseek, \
-		.release = single_release, \
-		.owner = THIS_MODULE, \
-		}, \
-	}
-
-#define FILE_DESCRIPTION_RW(_name) \
-	{ \
-	.name = __stringify(_name), \
-	.mode = S_IFREG | S_IRUGO | S_IWUSR, \
-	.ops = { \
-		.open = acpi_battery_##_name##_open_fs, \
-		.read = seq_read, \
-		.llseek = seq_lseek, \
-		.write = acpi_battery_write_##_name, \
-		.release = single_release, \
-		.owner = THIS_MODULE, \
-		}, \
-	}
-
-static const struct battery_file {
-	struct file_operations ops;
-	umode_t mode;
-	const char *name;
-} acpi_battery_file[] = {
-	FILE_DESCRIPTION_RO(info),
-	FILE_DESCRIPTION_RO(state),
-	FILE_DESCRIPTION_RW(alarm),
-};
-
-#undef FILE_DESCRIPTION_RO
-#undef FILE_DESCRIPTION_RW
-
-static int acpi_battery_add_fs(struct acpi_device *device)
-{
-	struct proc_dir_entry *entry = NULL;
-	int i;
-
-	printk(KERN_WARNING PREFIX "Deprecated procfs I/F for battery is loaded,"
-			" please retry with CONFIG_ACPI_PROCFS_POWER cleared\n");
-	if (!acpi_device_dir(device)) {
-		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
-						     acpi_battery_dir);
-		if (!acpi_device_dir(device))
-			return -ENODEV;
-	}
-
-	for (i = 0; i < ACPI_BATTERY_NUMFILES; ++i) {
-		entry = proc_create_data(acpi_battery_file[i].name,
-					 acpi_battery_file[i].mode,
-					 acpi_device_dir(device),
-					 &acpi_battery_file[i].ops,
-					 acpi_driver_data(device));
-		if (!entry)
-			return -ENODEV;
-	}
-	return 0;
-}
-
-static void acpi_battery_remove_fs(struct acpi_device *device)
-{
-	int i;
-	if (!acpi_device_dir(device))
-		return;
-	for (i = 0; i < ACPI_BATTERY_NUMFILES; ++i)
-		remove_proc_entry(acpi_battery_file[i].name,
-				  acpi_device_dir(device));
-
-	remove_proc_entry(acpi_device_bid(device), acpi_battery_dir);
-	acpi_device_dir(device) = NULL;
-}
-
-#endif
-
 /* --------------------------------------------------------------------------
                                  Driver Interface
    -------------------------------------------------------------------------- */
@@ -1075,15 +775,6 @@ static int acpi_battery_add(struct acpi_device *device)
 	result = acpi_battery_update(battery);
 	if (result)
 		goto fail;
-#ifdef CONFIG_ACPI_PROCFS_POWER
-	result = acpi_battery_add_fs(device);
-#endif
-	if (result) {
-#ifdef CONFIG_ACPI_PROCFS_POWER
-		acpi_battery_remove_fs(device);
-#endif
-		goto fail;
-	}
 
 	printk(KERN_INFO PREFIX "%s Slot [%s] (battery %s)\n",
 		ACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),
@@ -1110,9 +801,6 @@ static int acpi_battery_remove(struct acpi_device *device)
 		return -EINVAL;
 	battery = acpi_driver_data(device);
 	unregister_pm_notifier(&battery->pm_nb);
-#ifdef CONFIG_ACPI_PROCFS_POWER
-	acpi_battery_remove_fs(device);
-#endif
 	sysfs_remove_battery(battery);
 	mutex_destroy(&battery->lock);
 	mutex_destroy(&battery->sysfs_lock);
@@ -1158,18 +846,7 @@ static void __init acpi_battery_init_async(void *unused, async_cookie_t cookie)
 {
 	if (acpi_disabled)
 		return;
-#ifdef CONFIG_ACPI_PROCFS_POWER
-	acpi_battery_dir = acpi_lock_battery_dir();
-	if (!acpi_battery_dir)
-		return;
-#endif
-	if (acpi_bus_register_driver(&acpi_battery_driver) < 0) {
-#ifdef CONFIG_ACPI_PROCFS_POWER
-		acpi_unlock_battery_dir(acpi_battery_dir);
-#endif
-		return;
-	}
-	return;
+	acpi_bus_register_driver(&acpi_battery_driver);
 }
 
 static int __init acpi_battery_init(void)
@@ -1181,9 +858,6 @@ static int __init acpi_battery_init(void)
 static void __exit acpi_battery_exit(void)
 {
 	acpi_bus_unregister_driver(&acpi_battery_driver);
-#ifdef CONFIG_ACPI_PROCFS_POWER
-	acpi_unlock_battery_dir(acpi_battery_dir);
-#endif
 }
 
 module_init(acpi_battery_init);

commit 0c581415b522267138d807814e526aa7534b9a61
Merge: afdca01c9821 7702ae0dd9b4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 27 01:29:04 2013 +0200

    Merge branch 'acpi-assorted'
    
    * acpi-assorted:
      ACPI / osl: Kill macro INVALID_TABLE().
      earlycpio.c: Fix the confusing comment of find_cpio_data().
      ACPI / x86: Print Hot-Pluggable Field in SRAT.
      ACPI / thermal: Use THERMAL_TRIPS_NONE macro to replace number
      ACPI / thermal: Remove unused macros in the driver/acpi/thermal.c
      ACPI / thermal: Remove the unused lock of struct acpi_thermal
      ACPI / osl: Fix osi_setup_entries[] __initdata attribute location
      ACPI / numa: Fix __init attribute location in slit_valid()
      ACPI / dock: Fix __init attribute location in find_dock_and_bay()
      ACPI / Sleep: Fix incorrect placement of __initdata
      ACPI / processor: Fix incorrect placement of __initdata
      ACPI / EC: Fix incorrect placement of __initdata
      ACPI / scan: Drop unnecessary label from acpi_create_platform_device()
      ACPI: Move acpi_bus_get_device() from bus.c to scan.c
      ACPI / scan: Allow platform device creation without any IO resources
      ACPI: Cleanup sparse warning on acpi_os_initialize1()
      platform / thinkpad: Remove deprecated hotkey_report_mode parameter
      ACPI: Remove the old /proc/acpi/event interface

commit c92f56cbdfc08c8c207c9476c69c99fdbadbd77b
Merge: d8dfad3876e4 0177f29fea53
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 27 01:25:28 2013 +0200

    Merge branch 'acpi-cleanup'
    
    * acpi-cleanup: (21 commits)
      ACPI / dock: fix error return code in dock_add()
      ACPI / dock: Drop unnecessary local variable from dock_add()
      ACPI / dock / PCI: Drop ACPI dock notifier chain
      ACPI / dock: Do not check CONFIG_ACPI_DOCK_MODULE
      ACPI / dock: Do not leak memory on falilures to add a dock station
      ACPI: Drop ACPI bus notifier call chain
      ACPI / dock: Rework the handling of notifications
      ACPI / dock: Simplify dock_init_hotplug() and dock_release_hotplug()
      ACPI / dock: Walk list in reverse order during removal of devices
      ACPI / dock: Rework and simplify find_dock_devices()
      ACPI / dock: Drop the hp_lock mutex from struct dock_station
      ACPI: simplify acpiphp driver with new helper functions
      ACPI: simplify dock driver with new helper functions
      ACPI: Export acpi_(bay)|(dock)_match() from scan.c
      ACPI: introduce two helper functions for _EJ0 and _LCK
      ACPI: introduce helper function acpi_execute_simple_method()
      ACPI: introduce helper function acpi_has_method()
      ACPI / dock: simplify dock_create_acpi_device()
      ACPI / dock: mark initialization functions with __init
      ACPI / dock: drop redundant spin lock in dock station object
      ...

commit f3ce717e60572421f56d89c9a85ac42e634d16e7
Merge: d4e4ab86bcba e73d3136355f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 14 23:22:45 2013 +0200

    Merge back earlier 'acpi-assorted' material

commit 016d5baad04269e8559332df05f89bd95b52d6ad
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Tue Jul 30 14:00:42 2013 +0200

    ACPI / battery: Fix parsing _BIX return value
    
    The _BIX method returns extended battery info as a package.
    According the ACPI spec (ACPI 5, Section 10.2.2.2), the first member
    of that package should be "Revision".  However, the current ACPI
    battery driver treats the first member as "Power Unit" which should
    be the second member.  This causes the result of _BIX return data
    parsing to be incorrect.
    
    Fix this by adding a new member called 'revision' to struct
    acpi_battery and adding the offsetof() information on it to
    extended_info_offsets[] as the first row.
    
    [rjw: Changelog]
    Reported-and-tested-by: Jan Hoffmann <jan.christian.hoffmann@gmail.com>
    References: http://bugzilla.kernel.org/show_bug.cgi?id=60519
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Cc: 2.6.34+ <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 082b4dd252a8..d405fbad406a 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -117,6 +117,7 @@ struct acpi_battery {
 	struct acpi_device *device;
 	struct notifier_block pm_nb;
 	unsigned long update_time;
+	int revision;
 	int rate_now;
 	int capacity_now;
 	int voltage_now;
@@ -359,6 +360,7 @@ static struct acpi_offsets info_offsets[] = {
 };
 
 static struct acpi_offsets extended_info_offsets[] = {
+	{offsetof(struct acpi_battery, revision), 0},
 	{offsetof(struct acpi_battery, power_unit), 0},
 	{offsetof(struct acpi_battery, design_capacity), 0},
 	{offsetof(struct acpi_battery, full_charge_capacity), 0},

commit 1696d9dc57e062ce5200f6a42a6aaada15b434bb
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jul 15 10:15:09 2013 +0200

    ACPI: Remove the old /proc/acpi/event interface
    
    It is quite some time that this one has been deprecated.
    Get rid of it.
    
    Should some really important user be overseen, it may be reverted and
    the userspace program worked on first, but it is time to do something
    to get rid of this old stuff...
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Acked-by: Matthew Garrett <matthew.garrett@nebula.com>
    Acked-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 082b4dd252a8..33dfa851899d 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1034,8 +1034,6 @@ static void acpi_battery_notify(struct acpi_device *device, u32 event)
 	if (event == ACPI_BATTERY_NOTIFY_INFO)
 		acpi_battery_refresh(battery);
 	acpi_battery_update(battery);
-	acpi_bus_generate_proc_event(device, event,
-				     acpi_battery_present(battery));
 	acpi_bus_generate_netlink_event(device->pnp.device_class,
 					dev_name(&device->dev), event,
 					acpi_battery_present(battery));

commit 0db98202605c3d32e023d43c30b5bd878f520976
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Sat Jun 29 00:24:39 2013 +0800

    ACPI: introduce helper function acpi_execute_simple_method()
    
    Introduce helper function acpi_execute_simple_method() and use it in
    a number of places to simplify code.
    
    [rjw: Changelog]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index a7627166e18b..74669ac4c615 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -525,18 +525,14 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 static int acpi_battery_set_alarm(struct acpi_battery *battery)
 {
 	acpi_status status = 0;
-	union acpi_object arg0 = { .type = ACPI_TYPE_INTEGER };
-	struct acpi_object_list arg_list = { 1, &arg0 };
 
 	if (!acpi_battery_present(battery) ||
 	    !test_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags))
 		return -ENODEV;
 
-	arg0.integer.value = battery->alarm;
-
 	mutex_lock(&battery->lock);
-	status = acpi_evaluate_object(battery->device->handle, "_BTP",
-				 &arg_list, NULL);
+	status = acpi_execute_simple_method(battery->device->handle, "_BTP",
+					    battery->alarm);
 	mutex_unlock(&battery->lock);
 
 	if (ACPI_FAILURE(status))

commit 952c63e9512b63220886105cfc791507046fa39a
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Sat Jun 29 00:24:38 2013 +0800

    ACPI: introduce helper function acpi_has_method()
    
    Introduce helper function acpi_has_method() and use it in a number
    of places to simplify code.
    
    [rjw: Changelog]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 082b4dd252a8..a7627166e18b 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -548,12 +548,8 @@ static int acpi_battery_set_alarm(struct acpi_battery *battery)
 
 static int acpi_battery_init_alarm(struct acpi_battery *battery)
 {
-	acpi_status status = AE_OK;
-	acpi_handle handle = NULL;
-
 	/* See if alarms are supported, and if so, set default */
-	status = acpi_get_handle(battery->device->handle, "_BTP", &handle);
-	if (ACPI_FAILURE(status)) {
+	if (!acpi_has_method(battery->device->handle, "_BTP")) {
 		clear_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags);
 		return 0;
 	}
@@ -1066,7 +1062,7 @@ static int acpi_battery_add(struct acpi_device *device)
 {
 	int result = 0;
 	struct acpi_battery *battery = NULL;
-	acpi_handle handle;
+
 	if (!device)
 		return -EINVAL;
 	battery = kzalloc(sizeof(struct acpi_battery), GFP_KERNEL);
@@ -1078,8 +1074,7 @@ static int acpi_battery_add(struct acpi_device *device)
 	device->driver_data = battery;
 	mutex_init(&battery->lock);
 	mutex_init(&battery->sysfs_lock);
-	if (ACPI_SUCCESS(acpi_get_handle(battery->device->handle,
-			"_BIX", &handle)))
+	if (acpi_has_method(battery->device->handle, "_BIX"))
 		set_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags);
 	result = acpi_battery_update(battery);
 	if (result)

commit 0f4c65478d2ac03296415a5bdac1ead3e24cfc5b
Author: Nicholas Mazzuca <nicholas@mazzucastuff.com>
Date:   Wed May 8 23:11:15 2013 +0000

    ACPI / battery: Make sure all spaces are in correct places
    
    Add or remove spaces that give errors or warnings from checkpatch.pl.
    
    Signed-off-by: Nicholas Mazzuca <nicholas@mazzucastuff.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index e7100459ac4a..082b4dd252a8 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -425,7 +425,7 @@ static int acpi_battery_get_info(struct acpi_battery *battery)
 {
 	int result = -EFAULT;
 	acpi_status status = 0;
-	char *name = test_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags)?
+	char *name = test_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags) ?
 			"_BIX" : "_BIF";
 
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
@@ -661,11 +661,11 @@ static void find_battery(const struct dmi_header *dm, void *private)
 static void acpi_battery_quirks(struct acpi_battery *battery)
 {
 	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags))
-		return ;
+		return;
 
-        if (battery->full_charge_capacity == 100 &&
-            battery->rate_now == ACPI_BATTERY_VALUE_UNKNOWN &&
-            battery->capacity_now >=0 && battery->capacity_now <= 100) {
+	if (battery->full_charge_capacity == 100 &&
+		battery->rate_now == ACPI_BATTERY_VALUE_UNKNOWN &&
+		battery->capacity_now >= 0 && battery->capacity_now <= 100) {
 		set_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags);
 		battery->full_charge_capacity = battery->design_capacity;
 		battery->capacity_now = (battery->capacity_now *
@@ -673,7 +673,7 @@ static void acpi_battery_quirks(struct acpi_battery *battery)
 	}
 
 	if (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH, &battery->flags))
-		return ;
+		return;
 
 	if (battery->power_unit && dmi_name_in_vendors("LENOVO")) {
 		const char *s;
@@ -761,7 +761,7 @@ static int acpi_battery_print_info(struct seq_file *seq, int result)
 		goto end;
 
 	seq_printf(seq, "present:                 %s\n",
-		   acpi_battery_present(battery)?"yes":"no");
+		   acpi_battery_present(battery) ? "yes" : "no");
 	if (!acpi_battery_present(battery))
 		goto end;
 	if (battery->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
@@ -817,12 +817,12 @@ static int acpi_battery_print_state(struct seq_file *seq, int result)
 		goto end;
 
 	seq_printf(seq, "present:                 %s\n",
-		   acpi_battery_present(battery)?"yes":"no");
+		   acpi_battery_present(battery) ? "yes" : "no");
 	if (!acpi_battery_present(battery))
 		goto end;
 
 	seq_printf(seq, "capacity state:          %s\n",
-			(battery->state & 0x04)?"critical":"ok");
+			(battery->state & 0x04) ? "critical" : "ok");
 	if ((battery->state & 0x01) && (battery->state & 0x02))
 		seq_printf(seq,
 			   "charging state:          charging/discharging\n");

commit 20b4fb485227404329e41ad15588afad3df23050
Merge: b9394d8a657c ac3e3c5b1164
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 1 17:51:54 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull VFS updates from Al Viro,
    
    Misc cleanups all over the place, mainly wrt /proc interfaces (switch
    create_proc_entry to proc_create(), get rid of the deprecated
    create_proc_read_entry() in favor of using proc_create_data() and
    seq_file etc).
    
    7kloc removed.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (204 commits)
      don't bother with deferred freeing of fdtables
      proc: Move non-public stuff from linux/proc_fs.h to fs/proc/internal.h
      proc: Make the PROC_I() and PDE() macros internal to procfs
      proc: Supply a function to remove a proc entry by PDE
      take cgroup_open() and cpuset_open() to fs/proc/base.c
      ppc: Clean up scanlog
      ppc: Clean up rtas_flash driver somewhat
      hostap: proc: Use remove_proc_subtree()
      drm: proc: Use remove_proc_subtree()
      drm: proc: Use minor->index to label things, not PDE->name
      drm: Constify drm_proc_list[]
      zoran: Don't print proc_dir_entry data in debug
      reiserfs: Don't access the proc_dir_entry in r_open(), r_start() r_show()
      proc: Supply an accessor for getting the data from a PDE's parent
      airo: Use remove_proc_subtree()
      rtl8192u: Don't need to save device proc dir PDE
      rtl8187se: Use a dir under /proc/net/r8180/
      proc: Add proc_mkdir_data()
      proc: Move some bits from linux/proc_fs.h to linux/{of.h,signal.h,tty.h}
      proc: Move PDE_NET() to fs/proc/proc_net.c
      ...

commit d9dda78bad879595d8c4220a067fc029d6484a16
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 18:16:14 2013 -0400

    procfs: new helper - PDE_DATA(inode)
    
    The only part of proc_dir_entry the code outside of fs/proc
    really cares about is PDE(inode)->data.  Provide a helper
    for that; static inline for now, eventually will be moved
    to fs/proc, along with the knowledge of struct proc_dir_entry
    layout.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index c5cd5b5513e6..169ced7e540d 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -929,7 +929,7 @@ static int acpi_battery_read_##_name(struct seq_file *seq, void *offset) \
 } \
 static int acpi_battery_##_name##_open_fs(struct inode *inode, struct file *file) \
 { \
-	return single_open(file, acpi_battery_read_##_name, PDE(inode)->data); \
+	return single_open(file, acpi_battery_read_##_name, PDE_DATA(inode)); \
 }
 
 DECLARE_FILE_FUNCTIONS(info);

commit efd941f108569a9cfd1c14f20093a4ac745dec2d
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Mar 11 09:17:06 2013 +0000

    ACPI: suppress compiler warning in battery.c
    
    This patch fixes following compiler warning when build via make W=1:
    
    drivers/acpi/battery.c:149:52: warning: no previous prototype for acpi_battery_present [-Wmissing-prototypes]
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index c5cd5b5513e6..0cc384b72943 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -146,7 +146,7 @@ struct acpi_battery {
 
 #define to_acpi_battery(x) container_of(x, struct acpi_battery, bat)
 
-inline int acpi_battery_present(struct acpi_battery *battery)
+static inline int acpi_battery_present(struct acpi_battery *battery)
 {
 	return battery->device->status.battery_present;
 }

commit 51fac8388a0325a43f0ae67453ece2c373e2ec28
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 24 00:24:48 2013 +0100

    ACPI: Remove useless type argument of driver .remove() operation
    
    The second argument of ACPI driver .remove() operation is only used
    by the ACPI processor driver and the value passed to that driver
    through it is always available from the given struct acpi_device
    object's removal_type field.  For this reason, the second ACPI driver
    .remove() argument is in fact useless, so drop it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Jiang Liu <jiang.liu@huawei.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 7efaeaa53b88..c5cd5b5513e6 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1111,7 +1111,7 @@ static int acpi_battery_add(struct acpi_device *device)
 	return result;
 }
 
-static int acpi_battery_remove(struct acpi_device *device, int type)
+static int acpi_battery_remove(struct acpi_device *device)
 {
 	struct acpi_battery *battery = NULL;
 

commit 4000e626156935dfb626321ce09cae2c833eabbb
Author: Kamil Iskra <kamil@iskra.name>
Date:   Fri Nov 16 22:28:58 2012 +0100

    ACPI / battery: Correct battery capacity values on Thinkpads
    
    Add a quirk to correctly report battery capacity on 2010 and 2011
    Lenovo Thinkpad models.
    
    The affected models that I tested (x201, t410, t410s, and x220)
    exhibit a problem where, when battery capacity reporting unit is mAh,
    the values being reported are wrong.  Pre-2010 and 2012 models appear
    to always report in mWh and are thus unaffected.  Also, in mid-2012
    Lenovo issued a BIOS update for the 2011 models that fixes the issue
    (tested on x220 with a post-1.29 BIOS).  No such update is available
    for the 2010 models, so those still need this patch.
    
    Problem description: for some reason, the affected Thinkpads switch
    the reporting unit between mAh and mWh; generally, mAh is used when a
    laptop is plugged in and mWh when it's unplugged, although a
    suspend/resume or rmmod/modprobe is needed for the switch to take
    effect.  The values reported in mAh are *always* wrong.  This does
    not appear to be a kernel regression; I believe that the values were
    never reported correctly.  I tested back to kernel 2.6.34, with
    multiple machines and BIOS versions.
    
    Simply plugging a laptop into mains before turning it on is enough to
    reproduce the problem.  Here's a sample /proc/acpi/battery/BAT0/info
    from Thinkpad x220 (before a BIOS update) with a 4-cell battery:
    
    present:                 yes
    design capacity:         2886 mAh
    last full capacity:      2909 mAh
    battery technology:      rechargeable
    design voltage:          14800 mV
    design capacity warning: 145 mAh
    design capacity low:     13 mAh
    cycle count:              0
    capacity granularity 1:  1 mAh
    capacity granularity 2:  1 mAh
    model number:            42T4899
    serial number:           21064
    battery type:            LION
    OEM info:                SANYO
    
    Once the laptop switches the unit to mWh (unplug from mains, suspend,
    resume), the output changes to:
    
    present:                 yes
    design capacity:         28860 mWh
    last full capacity:      29090 mWh
    battery technology:      rechargeable
    design voltage:          14800 mV
    design capacity warning: 1454 mWh
    design capacity low:     200 mWh
    cycle count:              0
    capacity granularity 1:  1 mWh
    capacity granularity 2:  1 mWh
    model number:            42T4899
    serial number:           21064
    battery type:            LION
    OEM info:                SANYO
    
    Can you see how the values for "design capacity", etc., differ by a
    factor of 10 instead of 14.8 (the design voltage of this battery)?
    On the battery itself it says: 14.8V, 1.95Ah, 29Wh, so clearly the
    values reported in mWh are correct and the ones in mAh are not.
    
    My guess is that this problem has been around ever since those
    machines were released, but because the most common Thinkpad
    batteries are rated at 10.8V, the error (8%) is small enough that it
    simply hasn't been noticed or at least nobody could be bothered to
    look into it.
    
    My patch works around the problem by adjusting the incorrectly
    reported mAh values by "10000 / design_voltage".  The patch also has
    code to figure out if it should be activated or not.  It only
    activates on Lenovo Thinkpads, only when the unit is mAh, and, as an
    extra precaution, only when the battery capacity reported through
    ACPI does not match what is reported through DMI (I've never
    encountered a machine where the first two conditions would be true
    but the last would not, but better safe than sorry).
    
    I've been using this patch for close to a year on several systems
    without any problems.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=41062
    Acked-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 45e3e1759fb8..7efaeaa53b88 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -34,6 +34,7 @@
 #include <linux/dmi.h>
 #include <linux/slab.h>
 #include <linux/suspend.h>
+#include <asm/unaligned.h>
 
 #ifdef CONFIG_ACPI_PROCFS_POWER
 #include <linux/proc_fs.h>
@@ -95,6 +96,18 @@ enum {
 	ACPI_BATTERY_ALARM_PRESENT,
 	ACPI_BATTERY_XINFO_PRESENT,
 	ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY,
+	/* On Lenovo Thinkpad models from 2010 and 2011, the power unit
+	   switches between mWh and mAh depending on whether the system
+	   is running on battery or not.  When mAh is the unit, most
+	   reported values are incorrect and need to be adjusted by
+	   10000/design_voltage.  Verified on x201, t410, t410s, and x220.
+	   Pre-2010 and 2012 models appear to always report in mWh and
+	   are thus unaffected (tested with t42, t61, t500, x200, x300,
+	   and x230).  Also, in mid-2012 Lenovo issued a BIOS update for
+	   the 2011 models that fixes the issue (tested on x220 with a
+	   post-1.29 BIOS), but as of Nov. 2012, no such update is
+	   available for the 2010 models.  */
+	ACPI_BATTERY_QUIRK_THINKPAD_MAH,
 };
 
 struct acpi_battery {
@@ -438,6 +451,21 @@ static int acpi_battery_get_info(struct acpi_battery *battery)
 	kfree(buffer.pointer);
 	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags))
 		battery->full_charge_capacity = battery->design_capacity;
+	if (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH, &battery->flags) &&
+	    battery->power_unit && battery->design_voltage) {
+		battery->design_capacity = battery->design_capacity *
+		    10000 / battery->design_voltage;
+		battery->full_charge_capacity = battery->full_charge_capacity *
+		    10000 / battery->design_voltage;
+		battery->design_capacity_warning =
+		    battery->design_capacity_warning *
+		    10000 / battery->design_voltage;
+		/* Curiously, design_capacity_low, unlike the rest of them,
+		   is correct.  */
+		/* capacity_granularity_* equal 1 on the systems tested, so
+		   it's impossible to tell if they would need an adjustment
+		   or not if their values were higher.  */
+	}
 	return result;
 }
 
@@ -486,6 +514,11 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 	    && battery->capacity_now >= 0 && battery->capacity_now <= 100)
 		battery->capacity_now = (battery->capacity_now *
 				battery->full_charge_capacity) / 100;
+	if (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH, &battery->flags) &&
+	    battery->power_unit && battery->design_voltage) {
+		battery->capacity_now = battery->capacity_now *
+		    10000 / battery->design_voltage;
+	}
 	return result;
 }
 
@@ -595,6 +628,24 @@ static void sysfs_remove_battery(struct acpi_battery *battery)
 	mutex_unlock(&battery->sysfs_lock);
 }
 
+static void find_battery(const struct dmi_header *dm, void *private)
+{
+	struct acpi_battery *battery = (struct acpi_battery *)private;
+	/* Note: the hardcoded offsets below have been extracted from
+	   the source code of dmidecode.  */
+	if (dm->type == DMI_ENTRY_PORTABLE_BATTERY && dm->length >= 8) {
+		const u8 *dmi_data = (const u8 *)(dm + 1);
+		int dmi_capacity = get_unaligned((const u16 *)(dmi_data + 6));
+		if (dm->length >= 18)
+			dmi_capacity *= dmi_data[17];
+		if (battery->design_capacity * battery->design_voltage / 1000
+		    != dmi_capacity &&
+		    battery->design_capacity * 10 == dmi_capacity)
+			set_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH,
+				&battery->flags);
+	}
+}
+
 /*
  * According to the ACPI spec, some kinds of primary batteries can
  * report percentage battery remaining capacity directly to OS.
@@ -620,6 +671,32 @@ static void acpi_battery_quirks(struct acpi_battery *battery)
 		battery->capacity_now = (battery->capacity_now *
 				battery->full_charge_capacity) / 100;
 	}
+
+	if (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH, &battery->flags))
+		return ;
+
+	if (battery->power_unit && dmi_name_in_vendors("LENOVO")) {
+		const char *s;
+		s = dmi_get_system_info(DMI_PRODUCT_VERSION);
+		if (s && !strnicmp(s, "ThinkPad", 8)) {
+			dmi_walk(find_battery, battery);
+			if (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH,
+				     &battery->flags) &&
+			    battery->design_voltage) {
+				battery->design_capacity =
+				    battery->design_capacity *
+				    10000 / battery->design_voltage;
+				battery->full_charge_capacity =
+				    battery->full_charge_capacity *
+				    10000 / battery->design_voltage;
+				battery->design_capacity_warning =
+				    battery->design_capacity_warning *
+				    10000 / battery->design_voltage;
+				battery->capacity_now = battery->capacity_now *
+				    10000 / battery->design_voltage;
+			}
+		}
+	}
 }
 
 static int acpi_battery_update(struct acpi_battery *battery)

commit 9069240480e24a2d6ce23404c9ad6cabf59b7258
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Aug 9 23:00:02 2012 +0200

    ACPI / PM: Fix unused function warnings for CONFIG_PM_SLEEP
    
    According to compiler warnings, several suspend/resume functions
    in ACPI drivers are not used for CONFIG_PM_SLEEP unset, so add
    #ifdefs to prevent them from being built in that case.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index ff2c876ec412..45e3e1759fb8 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1052,6 +1052,7 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 	return 0;
 }
 
+#ifdef CONFIG_PM_SLEEP
 /* this is needed to learn about changes made in suspended state */
 static int acpi_battery_resume(struct device *dev)
 {
@@ -1068,6 +1069,7 @@ static int acpi_battery_resume(struct device *dev)
 	acpi_battery_update(battery);
 	return 0;
 }
+#endif
 
 static SIMPLE_DEV_PM_OPS(acpi_battery_pm, NULL, acpi_battery_resume);
 

commit 476525004ac7e2f990b6956efcd44d0780c2ab4c
Merge: bd22dc17e499 ec033d0a0290
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 26 14:28:55 2012 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux
    
    Pull ACPI & power management update from Len Brown:
     "Re-write of the turbostat tool.
         lower overhead was necessary for measuring very large system when
         they are very idle.
    
      IVB support in intel_idle
         It's what I run on my IVB, others should be able to also:-)
    
      ACPICA core update
         We have found some bugs due to divergence between Linux and the
         upstream ACPICA base.  Most of these patches are to reduce that
         divergence to reduce the risk of future bugs.
    
      Some cpuidle updates, mostly for non-Intel
         More will be coming, as they depend on this part.
    
      Some thermal management changes needed by non-ACPI systems.
    
      Some _OST (OS Status Indication) updates for hot ACPI hot-plug."
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux: (51 commits)
      Thermal: Documentation update
      Thermal: Add Hysteresis attributes
      Thermal: Make Thermal trip points writeable
      ACPI/AC: prevent OOPS on some boxes due to missing check power_supply_register() return value check
      tools/power: turbostat: fix large c1% issue
      tools/power: turbostat v2 - re-write for efficiency
      ACPICA: Update to version 20120711
      ACPICA: AcpiSrc: Fix some translation issues for Linux conversion
      ACPICA: Update header files copyrights to 2012
      ACPICA: Add new ACPI table load/unload external interfaces
      ACPICA: Split file: tbxface.c -> tbxfload.c
      ACPICA: Add PCC address space to space ID decode function
      ACPICA: Fix some comment fields
      ACPICA: Table manager: deploy new firmware error/warning interfaces
      ACPICA: Add new interfaces for BIOS(firmware) errors and warnings
      ACPICA: Split exception code utilities to a new file, utexcep.c
      ACPI: acpi_pad: tune round_robin_time
      ACPICA: Update to version 20120620
      ACPICA: Add support for implicit notify on multiple devices
      ACPICA: Update comments; no functional change
      ...

commit a6f50dc8ef26819c510cda84477dd60e3d1c90bb
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jun 27 23:26:43 2012 +0200

    ACPI: Use struct dev_pm_ops for power management in the battery driver
    
    Make the ACPI battery driver define its PM callbacks through
    a struct dev_pm_ops object rather than by using legacy PM hooks
    in struct acpi_device_ops.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 7dd3f9fb9f3f..023f9c8534d0 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1044,17 +1044,24 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 }
 
 /* this is needed to learn about changes made in suspended state */
-static int acpi_battery_resume(struct acpi_device *device)
+static int acpi_battery_resume(struct device *dev)
 {
 	struct acpi_battery *battery;
-	if (!device)
+
+	if (!dev)
 		return -EINVAL;
-	battery = acpi_driver_data(device);
+
+	battery = acpi_driver_data(to_acpi_device(dev));
+	if (!battery)
+		return -EINVAL;
+
 	battery->update_time = 0;
 	acpi_battery_update(battery);
 	return 0;
 }
 
+static SIMPLE_DEV_PM_OPS(acpi_battery_pm, NULL, acpi_battery_resume);
+
 static struct acpi_driver acpi_battery_driver = {
 	.name = "battery",
 	.class = ACPI_BATTERY_CLASS,
@@ -1062,10 +1069,10 @@ static struct acpi_driver acpi_battery_driver = {
 	.flags = ACPI_DRIVER_ALL_NOTIFY_EVENTS,
 	.ops = {
 		.add = acpi_battery_add,
-		.resume = acpi_battery_resume,
 		.remove = acpi_battery_remove,
 		.notify = acpi_battery_notify,
 		},
+	.drv.pm = &acpi_battery_pm,
 };
 
 static void __init acpi_battery_init_async(void *unused, async_cookie_t cookie)

commit a58e1150225cc9e554b76da5519b2bb5bb6e46ff
Author: srinivas pandruvada <srinivas.pandruvada@intel.com>
Date:   Thu Apr 5 17:38:54 2012 -0700

    ACPI Battery: Added capacity
    
    Added Capacity field, which is a pre-defined power_supply
    property. Calculating capacity using current charge/energy and
    full charge/energy.
    Some user mode implementations are relying on capacity field to
    show battery strength and power down decision.
    
    Signed-off-by: srinivas pandruvada <srinivas.pandruvada@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 7dd3f9fb9f3f..5662d64e6733 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -250,6 +250,13 @@ static int acpi_battery_get_property(struct power_supply *psy,
 		else
 			val->intval = battery->capacity_now * 1000;
 		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (battery->capacity_now && battery->full_charge_capacity)
+			val->intval = battery->capacity_now * 100/
+					battery->full_charge_capacity;
+		else
+			val->intval = 0;
+		break;
 	case POWER_SUPPLY_PROP_MODEL_NAME:
 		val->strval = battery->model_number;
 		break;
@@ -276,6 +283,7 @@ static enum power_supply_property charge_battery_props[] = {
 	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
 	POWER_SUPPLY_PROP_CHARGE_FULL,
 	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
 	POWER_SUPPLY_PROP_MODEL_NAME,
 	POWER_SUPPLY_PROP_MANUFACTURER,
 	POWER_SUPPLY_PROP_SERIAL_NUMBER,
@@ -292,6 +300,7 @@ static enum power_supply_property energy_battery_props[] = {
 	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
 	POWER_SUPPLY_PROP_ENERGY_FULL,
 	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
 	POWER_SUPPLY_PROP_MODEL_NAME,
 	POWER_SUPPLY_PROP_MANUFACTURER,
 	POWER_SUPPLY_PROP_SERIAL_NUMBER,

commit c5971456964290da7e98222892797b71ef793e62
Author: Andy Whitcroft <apw@canonical.com>
Date:   Thu May 3 14:48:26 2012 +0100

    ACPI battery: only refresh the sysfs files when pertinent information changes
    
    We only need to regenerate the sysfs files when the capacity units
    change, avoid the update otherwise.
    
    The origin of this issue is dates way back to 2.6.38:
    da8aeb92d4853f37e281f11fddf61f9c7d84c3cd
    (ACPI / Battery: Update information on info notification and resume)
    
    cc: <stable@vger.kernel.org>
    Signed-off-by: Andy Whitcroft <apw@canonical.com>
    Tested-by: Ralf Jung <post@ralfj.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 86933ca8b472..7dd3f9fb9f3f 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -643,11 +643,19 @@ static int acpi_battery_update(struct acpi_battery *battery)
 
 static void acpi_battery_refresh(struct acpi_battery *battery)
 {
+	int power_unit;
+
 	if (!battery->bat.dev)
 		return;
 
+	power_unit = battery->power_unit;
+
 	acpi_battery_get_info(battery);
-	/* The battery may have changed its reporting units. */
+
+	if (power_unit == battery->power_unit)
+		return;
+
+	/* The battery has changed its reporting units. */
 	sysfs_remove_battery(battery);
 	sysfs_add_battery(battery);
 }

commit d161a13f974c72fd7ff0069d39a3ae57cb5694ff
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 24 03:36:29 2011 -0400

    switch procfs to umode_t use
    
    both proc_dir_entry ->mode and populating functions
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 7711d94a0409..86933ca8b472 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -873,7 +873,7 @@ DECLARE_FILE_FUNCTIONS(alarm);
 
 static const struct battery_file {
 	struct file_operations ops;
-	mode_t mode;
+	umode_t mode;
 	const char *name;
 } acpi_battery_file[] = {
 	FILE_DESCRIPTION_RO(info),

commit 5389102e231d5f06da8b2897336293db18af9d76
Merge: de96355c1116 69d94ec6d83d
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 5 22:16:42 2011 -0400

    Merge branch 'battery' into release

commit 69d94ec6d83d84044252d9ba03f6a8970816e350
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Sat Aug 6 01:34:08 2011 +0300

    Battery: sysfs_remove_battery(): possible circular locking
    
    Commit 9c921c22a7f33397a6774d7fa076db9b6a0fd669
    Author: Lan Tianyu <tianyu.lan@intel.com>
    
        ACPI / Battery: Resolve the race condition in the sysfs_remove_battery()
    
    fixed BUG https://bugzilla.kernel.org/show_bug.cgi?id=35642 , but as a side
    effect made lockdep unhappy with sysfs_remove_battery():
    
    [14818.477168]
    [14818.477170] =======================================================
    [14818.477200] [ INFO: possible circular locking dependency detected ]
    [14818.477221] 3.1.0-dbg-07865-g1280ea8-dirty #668
    [14818.477236] -------------------------------------------------------
    [14818.477257] s2ram/1599 is trying to acquire lock:
    [14818.477276]  (s_active#8){++++.+}, at: [<ffffffff81169147>] sysfs_addrm_finish+0x31/0x5a
    [14818.477323]
    [14818.477325] but task is already holding lock:
    [14818.477350]  (&battery->lock){+.+.+.}, at: [<ffffffffa0047278>] sysfs_remove_battery+0x10/0x4b [battery]
    [14818.477395]
    [14818.477397] which lock already depends on the new lock.
    [14818.477399]
    [..]
    [14818.479121] stack backtrace:
    [14818.479148] Pid: 1599, comm: s2ram Not tainted 3.1.0-dbg-07865-g1280ea8-dirty #668
    [14818.479175] Call Trace:
    [14818.479198]  [<ffffffff814828c3>] print_circular_bug+0x293/0x2a4
    [14818.479228]  [<ffffffff81070cb5>] __lock_acquire+0xfe4/0x164b
    [14818.479260]  [<ffffffff81169147>] ? sysfs_addrm_finish+0x31/0x5a
    [14818.479288]  [<ffffffff810718d2>] lock_acquire+0x138/0x1ac
    [14818.479316]  [<ffffffff81169147>] ? sysfs_addrm_finish+0x31/0x5a
    [14818.479345]  [<ffffffff81168a79>] sysfs_deactivate+0x9b/0xec
    [14818.479373]  [<ffffffff81169147>] ? sysfs_addrm_finish+0x31/0x5a
    [14818.479405]  [<ffffffff81169147>] sysfs_addrm_finish+0x31/0x5a
    [14818.479433]  [<ffffffff81167bc5>] sysfs_hash_and_remove+0x54/0x77
    [14818.479461]  [<ffffffff811681b9>] sysfs_remove_file+0x12/0x14
    [14818.479488]  [<ffffffff81385bf8>] device_remove_file+0x12/0x14
    [14818.479516]  [<ffffffff81386504>] device_del+0x119/0x17c
    [14818.479542]  [<ffffffff81386575>] device_unregister+0xe/0x1a
    [14818.479570]  [<ffffffff813c6ef9>] power_supply_unregister+0x23/0x27
    [14818.479601]  [<ffffffffa004729c>] sysfs_remove_battery+0x34/0x4b [battery]
    [14818.479632]  [<ffffffffa004778f>] battery_notify+0x2c/0x3a [battery]
    [14818.479662]  [<ffffffff8148fe82>] notifier_call_chain+0x74/0xa1
    [14818.479692]  [<ffffffff810624b4>] __blocking_notifier_call_chain+0x6c/0x89
    [14818.479722]  [<ffffffff810624e0>] blocking_notifier_call_chain+0xf/0x11
    [14818.479751]  [<ffffffff8107e40e>] pm_notifier_call_chain+0x15/0x27
    [14818.479770]  [<ffffffff8107ee1a>] enter_state+0xa7/0xd5
    [14818.479782]  [<ffffffff8107e341>] state_store+0xaa/0xc0
    [14818.479795]  [<ffffffff8107e297>] ? pm_async_store+0x45/0x45
    [14818.479807]  [<ffffffff81248837>] kobj_attr_store+0x17/0x19
    [14818.479820]  [<ffffffff81167e27>] sysfs_write_file+0x103/0x13f
    [14818.479834]  [<ffffffff81109037>] vfs_write+0xad/0x13d
    [14818.479847]  [<ffffffff811092b2>] sys_write+0x45/0x6c
    [14818.479860]  [<ffffffff81492f92>] system_call_fastpath+0x16/0x1b
    
    This patch introduces separate lock to struct acpi_battery to
    grab in sysfs_remove_battery() instead of battery->lock.
    So fix by Lan Tianyu is still there, we just grab independent lock.
    
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Tested-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index ffce2f06dd8d..8953b7087091 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -99,6 +99,7 @@ enum {
 
 struct acpi_battery {
 	struct mutex lock;
+	struct mutex sysfs_lock;
 	struct power_supply bat;
 	struct acpi_device *device;
 	struct notifier_block pm_nb;
@@ -573,16 +574,16 @@ static int sysfs_add_battery(struct acpi_battery *battery)
 
 static void sysfs_remove_battery(struct acpi_battery *battery)
 {
-	mutex_lock(&battery->lock);
+	mutex_lock(&battery->sysfs_lock);
 	if (!battery->bat.dev) {
-		mutex_unlock(&battery->lock);
+		mutex_unlock(&battery->sysfs_lock);
 		return;
 	}
 
 	device_remove_file(battery->bat.dev, &alarm_attr);
 	power_supply_unregister(&battery->bat);
 	battery->bat.dev = NULL;
-	mutex_unlock(&battery->lock);
+	mutex_unlock(&battery->sysfs_lock);
 }
 
 /*
@@ -982,6 +983,7 @@ static int acpi_battery_add(struct acpi_device *device)
 	strcpy(acpi_device_class(device), ACPI_BATTERY_CLASS);
 	device->driver_data = battery;
 	mutex_init(&battery->lock);
+	mutex_init(&battery->sysfs_lock);
 	if (ACPI_SUCCESS(acpi_get_handle(battery->device->handle,
 			"_BIX", &handle)))
 		set_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags);
@@ -1010,6 +1012,7 @@ static int acpi_battery_add(struct acpi_device *device)
 fail:
 	sysfs_remove_battery(battery);
 	mutex_destroy(&battery->lock);
+	mutex_destroy(&battery->sysfs_lock);
 	kfree(battery);
 	return result;
 }
@@ -1027,6 +1030,7 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 #endif
 	sysfs_remove_battery(battery);
 	mutex_destroy(&battery->lock);
+	mutex_destroy(&battery->sysfs_lock);
 	kfree(battery);
 	return 0;
 }

commit c299eba3c5a801657f275d33be588b34831cd30e
Merge: 1850536b9388 4a8f5058bde1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 2 21:17:02 2011 -1000

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6: (28 commits)
      ACPI:  delete stale reference in kernel-parameters.txt
      ACPI: add missing _OSI strings
      ACPI: remove NID_INVAL
      thermal: make THERMAL_HWMON implementation fully internal
      thermal: split hwmon lookup to a separate function
      thermal: hide CONFIG_THERMAL_HWMON
      ACPI print OSI(Linux) warning only once
      ACPI: DMI workaround for Asus A8N-SLI Premium and Asus A8N-SLI DELUX
      ACPI / Battery: propagate sysfs error in acpi_battery_add()
      ACPI / Battery: avoid acpi_battery_add() use-after-free
      ACPI: introduce "acpi_rsdp=" parameter for kdump
      ACPI: constify ops structs
      ACPI: fix CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS
      ACPI: fix 80 char overflow
      ACPI / Battery: Resolve the race condition in the sysfs_remove_battery()
      ACPI / Battery: Add the check before refresh sysfs in the battery_notify()
      ACPI / Battery: Add the hibernation process in the battery_notify()
      ACPI / Battery: Rename acpi_battery_quirks2 with acpi_battery_quirks
      ACPI / Battery: Change 16-bit signed negative battery current into correct value
      ACPI / Battery: Add the power unit macro
      ...

commit 4a8f5058bde15d737abe39b5bed3f21dcb6599d2
Merge: 3eb208f0a36c eb03cb02b74d d7f6169a0d32 e4108292cc5b bb0c5ed6ec52 aa165971c292 4996c02306a2 6c8111e9a0e7
Author: Len Brown <len.brown@intel.com>
Date:   Tue Aug 2 17:22:09 2011 -0400

    Merge branches 'acpica', 'battery', 'boot-irqs', 'bz-24492', 'bz-9528', 'from-akpm', 'kexec-param' and 'misc' into release
    
    Conflicts:
            Documentation/kernel-parameters.txt
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 497888cf69bf607ac1fe061a6437e0a670b0022f
Author: Phil Carmody <ext-phil.2.carmody@nokia.com>
Date:   Thu Jul 14 15:07:13 2011 +0300

    treewide: fix potentially dangerous trailing ';' in #defined values/expressions
    
    All these are instances of
      #define NAME value;
    or
      #define NAME(params_opt) value;
    
    These of course fail to build when used in contexts like
      if(foo $OP NAME)
      while(bar $OP NAME)
    and may silently generate the wrong code in contexts such as
      foo = NAME + 1;    /* foo = value; + 1; */
      bar = NAME - 1;    /* bar = value; - 1; */
      baz = NAME & quux; /* baz = value; & quux; */
    
    Reported on comp.lang.c,
    Message-ID: <ab0d55fe-25e5-482b-811e-c475aa6065c3@c29g2000yqd.googlegroups.com>
    Initial analysis of the dangers provided by Keith Thompson in that thread.
    
    There are many more instances of more complicated macros having unnecessary
    trailing semicolons, but this pile seems to be all of the cases of simple
    values suffering from the problem. (Thus things that are likely to be found
    in one of the contexts above, more complicated ones aren't.)
    
    Signed-off-by: Phil Carmody <ext-phil.2.carmody@nokia.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index fcc13ac0aa18..2c661353e8f2 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -132,7 +132,7 @@ struct acpi_battery {
 	unsigned long flags;
 };
 
-#define to_acpi_battery(x) container_of(x, struct acpi_battery, bat);
+#define to_acpi_battery(x) container_of(x, struct acpi_battery, bat)
 
 inline int acpi_battery_present(struct acpi_battery *battery)
 {

commit eb03cb02b74df6dd0b653d5f6d976f16a434dfaf
Author: Stefan Hajnoczi <stefanha@linux.vnet.ibm.com>
Date:   Tue Jul 12 09:03:29 2011 +0100

    ACPI / Battery: propagate sysfs error in acpi_battery_add()
    
    Make sure the error return from sysfs_add_battery() is checked and
    propagated out from acpi_battery_add().
    
    Signed-off-by: Stefan Hajnoczi <stefanha@linux.vnet.ibm.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index c771768f57c8..ffce2f06dd8d 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -630,8 +630,11 @@ static int acpi_battery_update(struct acpi_battery *battery)
 			return result;
 		acpi_battery_init_alarm(battery);
 	}
-	if (!battery->bat.dev)
-		sysfs_add_battery(battery);
+	if (!battery->bat.dev) {
+		result = sysfs_add_battery(battery);
+		if (result)
+			return result;
+	}
 	result = acpi_battery_get_state(battery);
 	acpi_battery_quirks(battery);
 	return result;
@@ -982,7 +985,9 @@ static int acpi_battery_add(struct acpi_device *device)
 	if (ACPI_SUCCESS(acpi_get_handle(battery->device->handle,
 			"_BIX", &handle)))
 		set_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags);
-	acpi_battery_update(battery);
+	result = acpi_battery_update(battery);
+	if (result)
+		goto fail;
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	result = acpi_battery_add_fs(device);
 #endif

commit e80bba4b5108c6479379740201b0a5d9da5ffbac
Author: Stefan Hajnoczi <stefanha@linux.vnet.ibm.com>
Date:   Tue Jul 12 09:03:28 2011 +0100

    ACPI / Battery: avoid acpi_battery_add() use-after-free
    
    When acpi_battery_add_fs() fails the error handling code does not clean
    up completely.  Moreover, it does not return resulting in a
    use-after-free.
    
    Signed-off-by: Stefan Hajnoczi <stefanha@linux.vnet.ibm.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 40bf01d42cc3..c771768f57c8 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -986,21 +986,27 @@ static int acpi_battery_add(struct acpi_device *device)
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	result = acpi_battery_add_fs(device);
 #endif
-	if (!result) {
-		printk(KERN_INFO PREFIX "%s Slot [%s] (battery %s)\n",
-			ACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),
-			device->status.battery_present ? "present" : "absent");
-	} else {
+	if (result) {
 #ifdef CONFIG_ACPI_PROCFS_POWER
 		acpi_battery_remove_fs(device);
 #endif
-		kfree(battery);
+		goto fail;
 	}
 
+	printk(KERN_INFO PREFIX "%s Slot [%s] (battery %s)\n",
+		ACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),
+		device->status.battery_present ? "present" : "absent");
+
 	battery->pm_nb.notifier_call = battery_notify;
 	register_pm_notifier(&battery->pm_nb);
 
 	return result;
+
+fail:
+	sysfs_remove_battery(battery);
+	mutex_destroy(&battery->lock);
+	kfree(battery);
+	return result;
 }
 
 static int acpi_battery_remove(struct acpi_device *device, int type)

commit 9c8b04be443b33939f374a811c82abeebe0a61d1
Author: Vasiliy Kulikov <segoon@openwall.com>
Date:   Sat Jun 25 21:07:52 2011 +0400

    ACPI: constify ops structs
    
    Structs battery_file, acpi_dock_ops, file_operations,
    thermal_cooling_device_ops, thermal_zone_device_ops, kernel_param_ops
    are not changed in runtime.  It is safe to make them const.
    register_hotplug_dock_device() was altered to take const "ops" argument
    to respect acpi_dock_ops' const notion.
    
    Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index fcc13ac0aa18..746b47507e9f 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -863,7 +863,7 @@ DECLARE_FILE_FUNCTIONS(alarm);
 		}, \
 	}
 
-static struct battery_file {
+static const struct battery_file {
 	struct file_operations ops;
 	mode_t mode;
 	const char *name;

commit 9c921c22a7f33397a6774d7fa076db9b6a0fd669
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Thu Jun 30 11:34:12 2011 +0800

    ACPI / Battery: Resolve the race condition in the sysfs_remove_battery()
    
    Use battery->lock in sysfs_remove_battery() to make
    checking, removing, and clearing bat.dev atomic.
    This is necessary because sysfs_remove_battery() may
    be invoked concurrently from different paths.
    
        https://bugzilla.kernel.org/show_bug.cgi?id=35642
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 4ba339d0ea19..40bf01d42cc3 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -573,11 +573,16 @@ static int sysfs_add_battery(struct acpi_battery *battery)
 
 static void sysfs_remove_battery(struct acpi_battery *battery)
 {
-	if (!battery->bat.dev)
+	mutex_lock(&battery->lock);
+	if (!battery->bat.dev) {
+		mutex_unlock(&battery->lock);
 		return;
+	}
+
 	device_remove_file(battery->bat.dev, &alarm_attr);
 	power_supply_unregister(&battery->bat);
 	battery->bat.dev = NULL;
+	mutex_unlock(&battery->lock);
 }
 
 /*

commit 6e17fb6aa1a67afa1827ae317c3594040f055730
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Thu Jun 30 11:33:58 2011 +0800

    ACPI / Battery: Add the check before refresh sysfs in the battery_notify()
    
    In the commit 25be5821, add the refresh sysfs when system resumes
    from suspending. But it didn't check that the battery exists. This
    will cause battery sysfs files added when the battery doesn't exist.
    This patch add the check before refreshing.
    
            https://bugzilla.kernel.org/show_bug.cgi?id=35642
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 2fe7cfd95680..4ba339d0ea19 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -949,8 +949,10 @@ static int battery_notify(struct notifier_block *nb,
 	switch (mode) {
 	case PM_POST_HIBERNATION:
 	case PM_POST_SUSPEND:
-		sysfs_remove_battery(battery);
-		sysfs_add_battery(battery);
+		if (battery->bat.dev) {
+			sysfs_remove_battery(battery);
+			sysfs_add_battery(battery);
+		}
 		break;
 	}
 

commit d5a5911b3278bad6515a9958f7318f74d534ef64
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Thu Jun 30 11:33:40 2011 +0800

    ACPI / Battery: Add the hibernation process in the battery_notify()
    
    The Commit 25be58215 has added a PM notifier to refresh the sys in order
    to deal with the unit change of the Battery Present Rate. But it just
    consided the suspend situation. The problem also will happen during the
    hibernation according the bug 28192.
    
        https://bugzilla.kernel.org/show_bug.cgi?id=28192
    
    This patch adds the hibernation process and fix the bug.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index ba7926fce4fb..2fe7cfd95680 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -947,6 +947,7 @@ static int battery_notify(struct notifier_block *nb,
 	struct acpi_battery *battery = container_of(nb, struct acpi_battery,
 						    pm_nb);
 	switch (mode) {
+	case PM_POST_HIBERNATION:
 	case PM_POST_SUSPEND:
 		sysfs_remove_battery(battery);
 		sysfs_add_battery(battery);

commit 7b78622d0f9df9f274a319eea1494240119d3734
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Thu Jun 30 11:33:27 2011 +0800

    ACPI / Battery: Rename acpi_battery_quirks2 with acpi_battery_quirks
    
    This patch is cosmetic only, and makes no functional change.
    Since the acpi_battery_quirks has been deleted, rename
    acpi_battery_quirks2 with acpi_battery_quirks to clean the code.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index ff1ff70da384..ba7926fce4fb 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -592,7 +592,7 @@ static void sysfs_remove_battery(struct acpi_battery *battery)
  *
  * Handle this correctly so that they won't break userspace.
  */
-static void acpi_battery_quirks2(struct acpi_battery *battery)
+static void acpi_battery_quirks(struct acpi_battery *battery)
 {
 	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags))
 		return ;
@@ -628,7 +628,7 @@ static int acpi_battery_update(struct acpi_battery *battery)
 	if (!battery->bat.dev)
 		sysfs_add_battery(battery);
 	result = acpi_battery_get_state(battery);
-	acpi_battery_quirks2(battery);
+	acpi_battery_quirks(battery);
 	return result;
 }
 

commit 55003b2105a4578736f3e868fbaa889bb1ff3ce0
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Thu Jun 30 11:33:12 2011 +0800

    ACPI / Battery: Change 16-bit signed negative battery current into correct value
    
    This patch is for some machines which report the battery current
    as a 16-bit signed negative when it is charging. This is caused
    by DSDT bug. The commit bc76f90b8a5cf4aceedf210d08d5e8292f820cec
    has resolved the problem for Acer laptops. But some other machines
    also have such problem.
    
        https://bugzilla.kernel.org/show_bug.cgi?id=33722
    
    Since it is improper that the current is above 32A on laptops
    whether on AC or on battery, this patch is to check the current and
     take its absolute value as current and producing a message when it
    is negative in s16.
    
    Remove Acer quirk, as this workaround handles Acer too.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 611434f413db..ff1ff70da384 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -94,11 +94,6 @@ MODULE_DEVICE_TABLE(acpi, battery_device_ids);
 enum {
 	ACPI_BATTERY_ALARM_PRESENT,
 	ACPI_BATTERY_XINFO_PRESENT,
-	/* For buggy DSDTs that report negative 16-bit values for either
-	 * charging or discharging current and/or report 0 as 65536
-	 * due to bad math.
-	 */
-	ACPI_BATTERY_QUIRK_SIGNED16_CURRENT,
 	ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY,
 };
 
@@ -465,9 +460,17 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 	battery->update_time = jiffies;
 	kfree(buffer.pointer);
 
-	if (test_bit(ACPI_BATTERY_QUIRK_SIGNED16_CURRENT, &battery->flags) &&
-	    battery->rate_now != -1)
+	/* For buggy DSDTs that report negative 16-bit values for either
+	 * charging or discharging current and/or report 0 as 65536
+	 * due to bad math.
+	 */
+	if (battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA &&
+		battery->rate_now != ACPI_BATTERY_VALUE_UNKNOWN &&
+		(s16)(battery->rate_now) < 0) {
 		battery->rate_now = abs((s16)battery->rate_now);
+		printk_once(KERN_WARNING FW_BUG "battery: (dis)charge rate"
+			" invalid.\n");
+	}
 
 	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags)
 	    && battery->capacity_now >= 0 && battery->capacity_now <= 100)
@@ -577,14 +580,6 @@ static void sysfs_remove_battery(struct acpi_battery *battery)
 	battery->bat.dev = NULL;
 }
 
-static void acpi_battery_quirks(struct acpi_battery *battery)
-{
-	if (dmi_name_in_vendors("Acer") &&
-		battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA) {
-		set_bit(ACPI_BATTERY_QUIRK_SIGNED16_CURRENT, &battery->flags);
-	}
-}
-
 /*
  * According to the ACPI spec, some kinds of primary batteries can
  * report percentage battery remaining capacity directly to OS.
@@ -628,7 +623,6 @@ static int acpi_battery_update(struct acpi_battery *battery)
 		result = acpi_battery_get_info(battery);
 		if (result)
 			return result;
-		acpi_battery_quirks(battery);
 		acpi_battery_init_alarm(battery);
 	}
 	if (!battery->bat.dev)

commit ae6f61870490c10a0b0436e5afffa00c9dacffef
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Thu Jun 30 11:32:40 2011 +0800

    ACPI / Battery: Add the power unit macro
    
    This patch is cosmetic only, and makes no functional change.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index fcc13ac0aa18..611434f413db 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -55,6 +55,9 @@
 #define ACPI_BATTERY_NOTIFY_INFO	0x81
 #define ACPI_BATTERY_NOTIFY_THRESHOLD   0x82
 
+/* Battery power unit: 0 means mW, 1 means mA */
+#define ACPI_BATTERY_POWER_UNIT_MA	1
+
 #define _COMPONENT		ACPI_BATTERY_COMPONENT
 
 ACPI_MODULE_NAME("battery");
@@ -301,7 +304,8 @@ static enum power_supply_property energy_battery_props[] = {
 #ifdef CONFIG_ACPI_PROCFS_POWER
 inline char *acpi_battery_units(struct acpi_battery *battery)
 {
-	return (battery->power_unit)?"mA":"mW";
+	return (battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA) ?
+		"mA" : "mW";
 }
 #endif
 
@@ -544,7 +548,7 @@ static int sysfs_add_battery(struct acpi_battery *battery)
 {
 	int result;
 
-	if (battery->power_unit) {
+	if (battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA) {
 		battery->bat.properties = charge_battery_props;
 		battery->bat.num_properties =
 			ARRAY_SIZE(charge_battery_props);
@@ -575,7 +579,8 @@ static void sysfs_remove_battery(struct acpi_battery *battery)
 
 static void acpi_battery_quirks(struct acpi_battery *battery)
 {
-	if (dmi_name_in_vendors("Acer") && battery->power_unit) {
+	if (dmi_name_in_vendors("Acer") &&
+		battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA) {
 		set_bit(ACPI_BATTERY_QUIRK_SIGNED16_CURRENT, &battery->flags);
 	}
 }

commit 25be5821521640eb00b7eb219ffe59664510d073
Author: Kyle McMartin <kyle@redhat.com>
Date:   Tue Mar 22 16:19:50 2011 -0400

    ACPI battery: fribble sysfs files from a resume notifier
    
    Commit da8aeb92 re-poked the battery on resume, but Linus reports that
    it broke his eee and partially reverted it in b23fffd7. Unfortunately
    this also results in my x201s giving crack values until the sysfs files
    are poked again. In the revert message, it was suggested that we poke it
    from a PM notifier, so let's do that.
    
    With this in place, I haven't noticed the units going nutty on my
    gnome-power-manager across a dozen suspends or so...
    
    Signed-off-by: Kyle McMartin <kyle@redhat.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index ac1a599f5147..fcc13ac0aa18 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -33,6 +33,7 @@
 #include <linux/async.h>
 #include <linux/dmi.h>
 #include <linux/slab.h>
+#include <linux/suspend.h>
 
 #ifdef CONFIG_ACPI_PROCFS_POWER
 #include <linux/proc_fs.h>
@@ -102,6 +103,7 @@ struct acpi_battery {
 	struct mutex lock;
 	struct power_supply bat;
 	struct acpi_device *device;
+	struct notifier_block pm_nb;
 	unsigned long update_time;
 	int rate_now;
 	int capacity_now;
@@ -940,6 +942,21 @@ static void acpi_battery_notify(struct acpi_device *device, u32 event)
 		power_supply_changed(&battery->bat);
 }
 
+static int battery_notify(struct notifier_block *nb,
+			       unsigned long mode, void *_unused)
+{
+	struct acpi_battery *battery = container_of(nb, struct acpi_battery,
+						    pm_nb);
+	switch (mode) {
+	case PM_POST_SUSPEND:
+		sysfs_remove_battery(battery);
+		sysfs_add_battery(battery);
+		break;
+	}
+
+	return 0;
+}
+
 static int acpi_battery_add(struct acpi_device *device)
 {
 	int result = 0;
@@ -972,6 +989,10 @@ static int acpi_battery_add(struct acpi_device *device)
 #endif
 		kfree(battery);
 	}
+
+	battery->pm_nb.notifier_call = battery_notify;
+	register_pm_notifier(&battery->pm_nb);
+
 	return result;
 }
 
@@ -982,6 +1003,7 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
 	battery = acpi_driver_data(device);
+	unregister_pm_notifier(&battery->pm_nb);
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	acpi_battery_remove_fs(device);
 #endif

commit b23fffd778c312b8fb258d342051fcbdf6712128
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 20 13:14:10 2011 -0800

    ACPI / Battery: remove battery refresh on resume
    
    This partially reverts commit da8aeb92d4853f37e281f11fddf61f9c7d84c3cd
    ("ACPI / Battery: Update information on info notification and resume"),
    which causes a hang on resume on at least some machines.
    
    This bug was bisected on an ASUS EeePC 901, which hangs at resume time
    if we do that "acpi_battery_refresh(battery)" in the battery resume
    function.
    
    Rafael suspects we'll still need to refresh the sysfs files upon resume,
    but that that can be done from a PM notifier (that will run after
    thawing user space).
    
    Bisected-and-tested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matthew Garrett <mjg@redhat.com>
    Cc: Len Brown <len.brown@intel.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 68bc227e7c4c..ac1a599f5147 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -998,7 +998,6 @@ static int acpi_battery_resume(struct acpi_device *device)
 	if (!device)
 		return -EINVAL;
 	battery = acpi_driver_data(device);
-	acpi_battery_refresh(battery);
 	battery->update_time = 0;
 	acpi_battery_update(battery);
 	return 0;

commit da8aeb92d4853f37e281f11fddf61f9c7d84c3cd
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jan 6 23:42:27 2011 +0100

    ACPI / Battery: Update information on info notification and resume
    
    A notification event 0x81 from an ACPI battery device requires us to
    re-read the battery information structure.  Follow this requirement
    and remove and re-create the battery's attibutes in sysfs so that
    they reflect the reporting units used by the battery at the moment
    (those units may actually change sometimes at run time, which happens
    on some Thinkpads).
    
    The approach used in this patch was suggested by Matthew Garrett.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 2a31421e0d75..68bc227e7c4c 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -631,6 +631,17 @@ static int acpi_battery_update(struct acpi_battery *battery)
 	return result;
 }
 
+static void acpi_battery_refresh(struct acpi_battery *battery)
+{
+	if (!battery->bat.dev)
+		return;
+
+	acpi_battery_get_info(battery);
+	/* The battery may have changed its reporting units. */
+	sysfs_remove_battery(battery);
+	sysfs_add_battery(battery);
+}
+
 /* --------------------------------------------------------------------------
                               FS Interface (/proc)
    -------------------------------------------------------------------------- */
@@ -916,6 +927,8 @@ static void acpi_battery_notify(struct acpi_device *device, u32 event)
 	if (!battery)
 		return;
 	old = battery->bat.dev;
+	if (event == ACPI_BATTERY_NOTIFY_INFO)
+		acpi_battery_refresh(battery);
 	acpi_battery_update(battery);
 	acpi_bus_generate_proc_event(device, event,
 				     acpi_battery_present(battery));
@@ -985,6 +998,7 @@ static int acpi_battery_resume(struct acpi_device *device)
 	if (!device)
 		return -EINVAL;
 	battery = acpi_driver_data(device);
+	acpi_battery_refresh(battery);
 	battery->update_time = 0;
 	acpi_battery_update(battery);
 	return 0;

commit 6d855fcdd24d2491455527c4999b4d04363f1980
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Mon Jan 10 11:16:30 2011 +0800

    ACPI: delete CONFIG_ACPI_PROCFS_POWER and power procfs I/F in 2.6.39
    
    sysfs I/F for ACPI power devices, including AC and Battery,
    has been working in upstream kenrel since 2.6.24, Sep 2007.
    In 2.6.37, we made the sysfs I/F always built in and this option
    disabled by default.
    Now, we plan to remove this option and the ACPI power procfs
    interface in 2.6.39.
    
    First, update the feature-removal-schedule to announce this change.
    Second, add runtime warnings in ACPI AC/Battery/SBS driver, so that
    users will notice this change even if "make oldconfig" is used.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 95649d373071..2a31421e0d75 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -868,6 +868,8 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 	struct proc_dir_entry *entry = NULL;
 	int i;
 
+	printk(KERN_WARNING PREFIX "Deprecated procfs I/F for battery is loaded,"
+			" please retry with CONFIG_ACPI_PROCFS_POWER cleared\n");
 	if (!acpi_device_dir(device)) {
 		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
 						     acpi_battery_dir);

commit 880308089d0abebac365c3a1378b4e3238b100ac
Merge: e000f8f72908 a1b4bd694a80
Author: Len Brown <len.brown@intel.com>
Date:   Mon Oct 25 02:12:57 2010 -0400

    Merge branch 'battery' into release

commit a1b4bd694a803eba49d637de32bb249638ceadb4
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Oct 23 19:35:15 2010 +0200

    ACPI / Battery: Return -ENODEV for unknown values in get_property()
    
    The function acpi_battery_get_property() is called by the
    power supply framework's function power_supply_show_property()
    implementing the sysfs interface for power supply devices as the
    ACPI battery driver's ->get_property() callback.  Thus it is supposed
    to return error code if the value of the given property is unknown.
    Unfortunately, however, it returns 0 in those cases and puts a
    wrong (negative) value into the intval field of the
    union power_supply_propval object provided by
    power_supply_show_property().  In consequence, wrong negative
    values are read by user space from the battery's sysfs files.
    
    Fix this by making acpi_battery_get_property() return -ENODEV
    for properties with unknown values (-ENODEV is returned, because
    power_supply_uevent() returns with error for any other error code
    returned by power_supply_show_property()).
    
    Reported-and-tested-by: Sitsofe Wheeler <sitsofe@yahoo.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 98417201e9ce..ac74a7ddaaa4 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -186,6 +186,7 @@ static int acpi_battery_get_property(struct power_supply *psy,
 				     enum power_supply_property psp,
 				     union power_supply_propval *val)
 {
+	int ret = 0;
 	struct acpi_battery *battery = to_acpi_battery(psy);
 
 	if (acpi_battery_present(battery)) {
@@ -214,26 +215,44 @@ static int acpi_battery_get_property(struct power_supply *psy,
 		val->intval = battery->cycle_count;
 		break;
 	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
-		val->intval = battery->design_voltage * 1000;
+		if (battery->design_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
+			ret = -ENODEV;
+		else
+			val->intval = battery->design_voltage * 1000;
 		break;
 	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
-		val->intval = battery->voltage_now * 1000;
+		if (battery->voltage_now == ACPI_BATTERY_VALUE_UNKNOWN)
+			ret = -ENODEV;
+		else
+			val->intval = battery->voltage_now * 1000;
 		break;
 	case POWER_SUPPLY_PROP_CURRENT_NOW:
 	case POWER_SUPPLY_PROP_POWER_NOW:
-		val->intval = battery->rate_now * 1000;
+		if (battery->rate_now == ACPI_BATTERY_VALUE_UNKNOWN)
+			ret = -ENODEV;
+		else
+			val->intval = battery->rate_now * 1000;
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
 	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
-		val->intval = battery->design_capacity * 1000;
+		if (battery->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+			ret = -ENODEV;
+		else
+			val->intval = battery->design_capacity * 1000;
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_FULL:
 	case POWER_SUPPLY_PROP_ENERGY_FULL:
-		val->intval = battery->full_charge_capacity * 1000;
+		if (battery->full_charge_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+			ret = -ENODEV;
+		else
+			val->intval = battery->full_charge_capacity * 1000;
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_NOW:
 	case POWER_SUPPLY_PROP_ENERGY_NOW:
-		val->intval = battery->capacity_now * 1000;
+		if (battery->capacity_now == ACPI_BATTERY_VALUE_UNKNOWN)
+			ret = -ENODEV;
+		else
+			val->intval = battery->capacity_now * 1000;
 		break;
 	case POWER_SUPPLY_PROP_MODEL_NAME:
 		val->strval = battery->model_number;
@@ -245,9 +264,9 @@ static int acpi_battery_get_property(struct power_supply *psy,
 		val->strval = battery->serial_number;
 		break;
 	default:
-		return -EINVAL;
+		ret = -EINVAL;
 	}
-	return 0;
+	return ret;
 }
 
 static enum power_supply_property charge_battery_props[] = {

commit 557d58687dcdee6bc00c1a8f1fd4e0eac8fefce9
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri Oct 22 10:02:06 2010 +0800

    ACPI battery: support percentage battery remaining capacity
    
    According to the ACPI spec, some kinds of primary battery can
    report percentage battery remaining capacity directly to OS.
    
    In this case, it reports the LastFullChargedCapacity == 100,
    BatteryPresentRate = 0xFFFFFFFF, and BatteryRemaingCapacity a
    percentage value, which actually means RemainingBatteryPercentage.
    
    Now we found some battery follows this rule even if it's a rechargeable.
    https://bugzilla.kernel.org/show_bug.cgi?id=15979
    
    Handle these batteries correctly in ACPI battery driver
    so that they won't break userspace.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Tested-by: Sitsofe Wheeler <sitsofe@yahoo.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 7b8787b490f6..0b2707ee094b 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -95,6 +95,7 @@ enum {
 	 * due to bad math.
 	 */
 	ACPI_BATTERY_QUIRK_SIGNED16_CURRENT,
+	ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY,
 };
 
 struct acpi_battery {
@@ -405,6 +406,8 @@ static int acpi_battery_get_info(struct acpi_battery *battery)
 		result = extract_package(battery, buffer.pointer,
 				info_offsets, ARRAY_SIZE(info_offsets));
 	kfree(buffer.pointer);
+	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags))
+		battery->full_charge_capacity = battery->design_capacity;
 	return result;
 }
 
@@ -441,6 +444,10 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 	    battery->rate_now != -1)
 		battery->rate_now = abs((s16)battery->rate_now);
 
+	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags)
+	    && battery->capacity_now >= 0 && battery->capacity_now <= 100)
+		battery->capacity_now = (battery->capacity_now *
+				battery->full_charge_capacity) / 100;
 	return result;
 }
 
@@ -552,6 +559,33 @@ static void acpi_battery_quirks(struct acpi_battery *battery)
 	}
 }
 
+/*
+ * According to the ACPI spec, some kinds of primary batteries can
+ * report percentage battery remaining capacity directly to OS.
+ * In this case, it reports the Last Full Charged Capacity == 100
+ * and BatteryPresentRate == 0xFFFFFFFF.
+ *
+ * Now we found some battery reports percentage remaining capacity
+ * even if it's rechargeable.
+ * https://bugzilla.kernel.org/show_bug.cgi?id=15979
+ *
+ * Handle this correctly so that they won't break userspace.
+ */
+static void acpi_battery_quirks2(struct acpi_battery *battery)
+{
+	if (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags))
+		return ;
+
+        if (battery->full_charge_capacity == 100 &&
+            battery->rate_now == ACPI_BATTERY_VALUE_UNKNOWN &&
+            battery->capacity_now >=0 && battery->capacity_now <= 100) {
+		set_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags);
+		battery->full_charge_capacity = battery->design_capacity;
+		battery->capacity_now = (battery->capacity_now *
+				battery->full_charge_capacity) / 100;
+	}
+}
+
 static int acpi_battery_update(struct acpi_battery *battery)
 {
 	int result, old_present = acpi_battery_present(battery);
@@ -573,7 +607,9 @@ static int acpi_battery_update(struct acpi_battery *battery)
 	}
 	if (!battery->bat.dev)
 		sysfs_add_battery(battery);
-	return acpi_battery_get_state(battery);
+	result = acpi_battery_get_state(battery);
+	acpi_battery_quirks2(battery);
+	return result;
 }
 
 /* --------------------------------------------------------------------------

commit 1b3d4c3b9a597e216c08bff2c59a8de872ef2d09
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri Oct 8 13:54:57 2010 +0800

    ACPI ac/battery/sbs: sysfs I/F always built in, procfs I/F disabled by default
    
    ACPI AC/Battery/SBS driver has different kernel option for procfs and sysfs I/F.
    
    This patch,
    1. Change CONFIG_ACPI_PROCFS_POWER to 'n' by default so that we can remove it in the next release or two.
    2. Remove CONFIG_ACPI_SYSFS_POWER and always build in the sysfs I/F of these drivers.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 98417201e9ce..7b8787b490f6 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -42,10 +42,7 @@
 
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
-
-#ifdef CONFIG_ACPI_SYSFS_POWER
 #include <linux/power_supply.h>
-#endif
 
 #define PREFIX "ACPI: "
 
@@ -102,9 +99,7 @@ enum {
 
 struct acpi_battery {
 	struct mutex lock;
-#ifdef CONFIG_ACPI_SYSFS_POWER
 	struct power_supply bat;
-#endif
 	struct acpi_device *device;
 	unsigned long update_time;
 	int rate_now;
@@ -141,7 +136,6 @@ inline int acpi_battery_present(struct acpi_battery *battery)
 	return battery->device->status.battery_present;
 }
 
-#ifdef CONFIG_ACPI_SYSFS_POWER
 static int acpi_battery_technology(struct acpi_battery *battery)
 {
 	if (!strcasecmp("NiCd", battery->type))
@@ -281,7 +275,6 @@ static enum power_supply_property energy_battery_props[] = {
 	POWER_SUPPLY_PROP_MANUFACTURER,
 	POWER_SUPPLY_PROP_SERIAL_NUMBER,
 };
-#endif
 
 #ifdef CONFIG_ACPI_PROCFS_POWER
 inline char *acpi_battery_units(struct acpi_battery *battery)
@@ -492,7 +485,6 @@ static int acpi_battery_init_alarm(struct acpi_battery *battery)
 	return acpi_battery_set_alarm(battery);
 }
 
-#ifdef CONFIG_ACPI_SYSFS_POWER
 static ssize_t acpi_battery_alarm_show(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
@@ -552,7 +544,6 @@ static void sysfs_remove_battery(struct acpi_battery *battery)
 	power_supply_unregister(&battery->bat);
 	battery->bat.dev = NULL;
 }
-#endif
 
 static void acpi_battery_quirks(struct acpi_battery *battery)
 {
@@ -568,9 +559,7 @@ static int acpi_battery_update(struct acpi_battery *battery)
 	if (result)
 		return result;
 	if (!acpi_battery_present(battery)) {
-#ifdef CONFIG_ACPI_SYSFS_POWER
 		sysfs_remove_battery(battery);
-#endif
 		battery->update_time = 0;
 		return 0;
 	}
@@ -582,10 +571,8 @@ static int acpi_battery_update(struct acpi_battery *battery)
 		acpi_battery_quirks(battery);
 		acpi_battery_init_alarm(battery);
 	}
-#ifdef CONFIG_ACPI_SYSFS_POWER
 	if (!battery->bat.dev)
 		sysfs_add_battery(battery);
-#endif
 	return acpi_battery_get_state(battery);
 }
 
@@ -867,26 +854,20 @@ static void acpi_battery_remove_fs(struct acpi_device *device)
 static void acpi_battery_notify(struct acpi_device *device, u32 event)
 {
 	struct acpi_battery *battery = acpi_driver_data(device);
-#ifdef CONFIG_ACPI_SYSFS_POWER
 	struct device *old;
-#endif
 
 	if (!battery)
 		return;
-#ifdef CONFIG_ACPI_SYSFS_POWER
 	old = battery->bat.dev;
-#endif
 	acpi_battery_update(battery);
 	acpi_bus_generate_proc_event(device, event,
 				     acpi_battery_present(battery));
 	acpi_bus_generate_netlink_event(device->pnp.device_class,
 					dev_name(&device->dev), event,
 					acpi_battery_present(battery));
-#ifdef CONFIG_ACPI_SYSFS_POWER
 	/* acpi_battery_update could remove power_supply object */
 	if (old && battery->bat.dev)
 		power_supply_changed(&battery->bat);
-#endif
 }
 
 static int acpi_battery_add(struct acpi_device *device)
@@ -934,9 +915,7 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	acpi_battery_remove_fs(device);
 #endif
-#ifdef CONFIG_ACPI_SYSFS_POWER
 	sysfs_remove_battery(battery);
-#endif
 	mutex_destroy(&battery->lock);
 	kfree(battery);
 	return 0;

commit b137b9942a07843c64a934cfdb7d43155e507e13
Author: Matthew Garrett <mjg@redhat.com>
Date:   Mon Aug 23 20:25:32 2010 +0000

    ACPI: Don't report current_now if battery reports in mWh
    
    ACPI batteries can report in units of either current or energy. Right
    now we expose the current_now file even if the battery is reporting
    energy units, resulting in a file that should contain mA instead
    containing mW. Don't expose this value unless the battery is reporting
    current.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index dc58402b0a17..98417201e9ce 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -273,7 +273,6 @@ static enum power_supply_property energy_battery_props[] = {
 	POWER_SUPPLY_PROP_CYCLE_COUNT,
 	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
 	POWER_SUPPLY_PROP_VOLTAGE_NOW,
-	POWER_SUPPLY_PROP_CURRENT_NOW,
 	POWER_SUPPLY_PROP_POWER_NOW,
 	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
 	POWER_SUPPLY_PROP_ENERGY_FULL,

commit 153e500f516329f439856f52ccbf61d1fd1a946a
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Wed Jul 7 09:11:57 2010 +0800

    ACPI battery: don't invoke power_supply_changed twice when battery is hot-added
    
    When battery is hot-added, we should not invoke power_supply_changed
    in acpi_battery_notify, because it has been invoked in acpi_battery_update,
    and battery->bat.changed_work is queued in keventd already.
    https://bugzilla.kernel.org/show_bug.cgi?id=16244
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Alexey Starikovskiy <astarikovskiy@sude.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 3026e3fa83ef..dc58402b0a17 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -868,9 +868,15 @@ static void acpi_battery_remove_fs(struct acpi_device *device)
 static void acpi_battery_notify(struct acpi_device *device, u32 event)
 {
 	struct acpi_battery *battery = acpi_driver_data(device);
+#ifdef CONFIG_ACPI_SYSFS_POWER
+	struct device *old;
+#endif
 
 	if (!battery)
 		return;
+#ifdef CONFIG_ACPI_SYSFS_POWER
+	old = battery->bat.dev;
+#endif
 	acpi_battery_update(battery);
 	acpi_bus_generate_proc_event(device, event,
 				     acpi_battery_present(battery));
@@ -879,7 +885,7 @@ static void acpi_battery_notify(struct acpi_device *device, u32 event)
 					acpi_battery_present(battery));
 #ifdef CONFIG_ACPI_SYSFS_POWER
 	/* acpi_battery_update could remove power_supply object */
-	if (battery->bat.dev)
+	if (old && battery->bat.dev)
 		power_supply_changed(&battery->bat);
 #endif
 }

commit c25f7cf2032aaac9bd50d6eee982719878538082
Merge: f79e1cec8c8a dadf28a10c3e ac7729da880e 3162b6f0c5e1 bc73675b99fd b7b30de53aef bf02bd2590eb 1638bca898e5 0f9b75ef3722 17c452f99cf5
Author: Len Brown <len.brown@intel.com>
Date:   Tue Apr 6 17:06:22 2010 -0400

    Merge branches 'battery', 'bugzilla-14667', 'bugzilla-15096', 'bugzilla-15480', 'bugzilla-15521', 'bugzilla-15605', 'gpe-reference-counters', 'misc', 'pxm-fix' and 'video-random-key' into release

commit f79e1cec8c8aa64895fd7b595dc7b48157df0754
Author: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
Date:   Tue Jun 30 14:36:16 2009 +0000

    ACPI: battery drivers should call power_supply_changed()
    
    Calling kobject_uevent() directly is a layering violation.  In
    particular, it means we'll miss updating the generic LED trigger.
    
    Signed-off-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 52df9947dbb2..db78b6e0ea6a 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -879,7 +879,7 @@ static void acpi_battery_notify(struct acpi_device *device, u32 event)
 #ifdef CONFIG_ACPI_SYSFS_POWER
 	/* acpi_battery_update could remove power_supply object */
 	if (battery->bat.dev)
-		kobject_uevent(&battery->bat.dev->kobj, KOBJ_CHANGE);
+		power_supply_changed(&battery->bat);
 #endif
 }
 

commit e363a755e8033e18f733fc0d1687039df8efade0
Author: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
Date:   Tue Jun 30 14:35:05 2009 +0000

    ACPI: battery: Fix CONFIG_ACPI_SYSFS_POWER=n
    
    Disabling CONFIG_ACPI_SYSFS_POWER changes the behaviour of
    acpi_battery_update().  It will call acpi_battery_get_info()
    even if the battery is not present.  I haven't noticed this
    causing any problem, but it does look like a bad idea.
    
    Signed-off-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 75f39f2c166d..52df9947dbb2 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -567,13 +567,13 @@ static int acpi_battery_update(struct acpi_battery *battery)
 	result = acpi_battery_get_status(battery);
 	if (result)
 		return result;
-#ifdef CONFIG_ACPI_SYSFS_POWER
 	if (!acpi_battery_present(battery)) {
+#ifdef CONFIG_ACPI_SYSFS_POWER
 		sysfs_remove_battery(battery);
+#endif
 		battery->update_time = 0;
 		return 0;
 	}
-#endif
 	if (!battery->update_time ||
 	    old_present != acpi_battery_present(battery)) {
 		result = acpi_battery_get_info(battery);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 75f39f2c166d..5717bd300869 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -32,6 +32,7 @@
 #include <linux/jiffies.h>
 #include <linux/async.h>
 #include <linux/dmi.h>
+#include <linux/slab.h>
 
 #ifdef CONFIG_ACPI_PROCFS_POWER
 #include <linux/proc_fs.h>

commit ec28dcc6b4c00b78ad269ad5b85ebd5c2d504825
Merge: c67fcd670b55 d06070509147 f6bb13aa1ea3 0c99c5288eb9 4c81ba4900ab 7e0e9c042790 149fe9c293f7 cffdde993a01 fa80945269f3 8b7ef6d8f162 70287db87cfc 38bcb37a6f63
Author: Len Brown <len.brown@intel.com>
Date:   Sun Mar 14 21:30:17 2010 -0400

    Merge branches 'battery-2.6.34', 'bugzilla-10805', 'bugzilla-14668', 'bugzilla-531916-power-state', 'ht-warn-2.6.34', 'pnp', 'processor-rename', 'sony-2.6.34', 'suse-bugzilla-531547', 'tz-check', 'video' and 'misc-2.6.34' into release

commit 439913fffd39374c3737186b22d2d56c3a0ae526
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Thu Jan 28 10:53:19 2010 +0800

    ACPI: replace acpi_integer by u64
    
    acpi_integer is now obsolete and removed from the ACPICA code base,
    replaced by u64.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index cada73ffdfa7..58d2c91ba62b 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -324,8 +324,8 @@ static int extract_package(struct acpi_battery *battery,
 				strncpy(ptr, element->string.pointer, 32);
 			else if (element->type == ACPI_TYPE_INTEGER) {
 				strncpy(ptr, (u8 *)&element->integer.value,
-					sizeof(acpi_integer));
-				ptr[sizeof(acpi_integer)] = 0;
+					sizeof(u64));
+				ptr[sizeof(u64)] = 0;
 			} else
 				*ptr = 0; /* don't have value */
 		} else {

commit c67fcd670b55e89e0c129fbf7fae854bd1f8bfa6
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Thu Oct 15 14:31:44 2009 +0400

    ACPI: Battery: Add support for _BIX extended info method
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index b2b48f8545c7..1ca0ea77115b 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -54,6 +54,7 @@
 #define ACPI_BATTERY_DEVICE_NAME	"Battery"
 #define ACPI_BATTERY_NOTIFY_STATUS	0x80
 #define ACPI_BATTERY_NOTIFY_INFO	0x81
+#define ACPI_BATTERY_NOTIFY_THRESHOLD   0x82
 
 #define _COMPONENT		ACPI_BATTERY_COMPONENT
 
@@ -90,9 +91,11 @@ MODULE_DEVICE_TABLE(acpi, battery_device_ids);
 
 enum {
 	ACPI_BATTERY_ALARM_PRESENT,
-	/* For buggy DSDTs that report negative 16-bit values for either charging
-	* or discharging current and/or report 0 as 65536 due to bad math.
-	*/
+	ACPI_BATTERY_XINFO_PRESENT,
+	/* For buggy DSDTs that report negative 16-bit values for either
+	 * charging or discharging current and/or report 0 as 65536
+	 * due to bad math.
+	 */
 	ACPI_BATTERY_QUIRK_SIGNED16_CURRENT,
 };
 
@@ -112,6 +115,12 @@ struct acpi_battery {
 	int design_voltage;
 	int design_capacity_warning;
 	int design_capacity_low;
+	int cycle_count;
+	int measurement_accuracy;
+	int max_sampling_time;
+	int min_sampling_time;
+	int max_averaging_interval;
+	int min_averaging_interval;
 	int capacity_granularity_1;
 	int capacity_granularity_2;
 	int alarm;
@@ -200,6 +209,9 @@ static int acpi_battery_get_property(struct power_supply *psy,
 	case POWER_SUPPLY_PROP_TECHNOLOGY:
 		val->intval = acpi_battery_technology(battery);
 		break;
+	case POWER_SUPPLY_PROP_CYCLE_COUNT:
+		val->intval = battery->cycle_count;
+		break;
 	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
 		val->intval = battery->design_voltage * 1000;
 		break;
@@ -241,6 +253,7 @@ static enum power_supply_property charge_battery_props[] = {
 	POWER_SUPPLY_PROP_STATUS,
 	POWER_SUPPLY_PROP_PRESENT,
 	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CYCLE_COUNT,
 	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
 	POWER_SUPPLY_PROP_VOLTAGE_NOW,
 	POWER_SUPPLY_PROP_CURRENT_NOW,
@@ -256,6 +269,7 @@ static enum power_supply_property energy_battery_props[] = {
 	POWER_SUPPLY_PROP_STATUS,
 	POWER_SUPPLY_PROP_PRESENT,
 	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CYCLE_COUNT,
 	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
 	POWER_SUPPLY_PROP_VOLTAGE_NOW,
 	POWER_SUPPLY_PROP_CURRENT_NOW,
@@ -307,6 +321,28 @@ static struct acpi_offsets info_offsets[] = {
 	{offsetof(struct acpi_battery, oem_info), 1},
 };
 
+static struct acpi_offsets extended_info_offsets[] = {
+	{offsetof(struct acpi_battery, power_unit), 0},
+	{offsetof(struct acpi_battery, design_capacity), 0},
+	{offsetof(struct acpi_battery, full_charge_capacity), 0},
+	{offsetof(struct acpi_battery, technology), 0},
+	{offsetof(struct acpi_battery, design_voltage), 0},
+	{offsetof(struct acpi_battery, design_capacity_warning), 0},
+	{offsetof(struct acpi_battery, design_capacity_low), 0},
+	{offsetof(struct acpi_battery, cycle_count), 0},
+	{offsetof(struct acpi_battery, measurement_accuracy), 0},
+	{offsetof(struct acpi_battery, max_sampling_time), 0},
+	{offsetof(struct acpi_battery, min_sampling_time), 0},
+	{offsetof(struct acpi_battery, max_averaging_interval), 0},
+	{offsetof(struct acpi_battery, min_averaging_interval), 0},
+	{offsetof(struct acpi_battery, capacity_granularity_1), 0},
+	{offsetof(struct acpi_battery, capacity_granularity_2), 0},
+	{offsetof(struct acpi_battery, model_number), 1},
+	{offsetof(struct acpi_battery, serial_number), 1},
+	{offsetof(struct acpi_battery, type), 1},
+	{offsetof(struct acpi_battery, oem_info), 1},
+};
+
 static int extract_package(struct acpi_battery *battery,
 			   union acpi_object *package,
 			   struct acpi_offsets *offsets, int num)
@@ -352,22 +388,29 @@ static int acpi_battery_get_info(struct acpi_battery *battery)
 {
 	int result = -EFAULT;
 	acpi_status status = 0;
+	char *name = test_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags)?
+			"_BIX" : "_BIF";
+
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 
 	if (!acpi_battery_present(battery))
 		return 0;
 	mutex_lock(&battery->lock);
-	status = acpi_evaluate_object(battery->device->handle, "_BIF",
-				      NULL, &buffer);
+	status = acpi_evaluate_object(battery->device->handle, name,
+						NULL, &buffer);
 	mutex_unlock(&battery->lock);
 
 	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BIF"));
+		ACPI_EXCEPTION((AE_INFO, status, "Evaluating %s", name));
 		return -ENODEV;
 	}
-
-	result = extract_package(battery, buffer.pointer,
-				 info_offsets, ARRAY_SIZE(info_offsets));
+	if (test_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags))
+		result = extract_package(battery, buffer.pointer,
+				extended_info_offsets,
+				ARRAY_SIZE(extended_info_offsets));
+	else
+		result = extract_package(battery, buffer.pointer,
+				info_offsets, ARRAY_SIZE(info_offsets));
 	kfree(buffer.pointer);
 	return result;
 }
@@ -414,7 +457,7 @@ static int acpi_battery_set_alarm(struct acpi_battery *battery)
 	union acpi_object arg0 = { .type = ACPI_TYPE_INTEGER };
 	struct acpi_object_list arg_list = { 1, &arg0 };
 
-	if (!acpi_battery_present(battery)||
+	if (!acpi_battery_present(battery) ||
 	    !test_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags))
 		return -ENODEV;
 
@@ -592,6 +635,7 @@ static int acpi_battery_print_info(struct seq_file *seq, int result)
 	seq_printf(seq, "design capacity low:     %d %sh\n",
 		   battery->design_capacity_low,
 		   acpi_battery_units(battery));
+	seq_printf(seq, "cycle count:		  %i\n", battery->cycle_count);
 	seq_printf(seq, "capacity granularity 1:  %d %sh\n",
 		   battery->capacity_granularity_1,
 		   acpi_battery_units(battery));
@@ -843,6 +887,7 @@ static int acpi_battery_add(struct acpi_device *device)
 {
 	int result = 0;
 	struct acpi_battery *battery = NULL;
+	acpi_handle handle;
 	if (!device)
 		return -EINVAL;
 	battery = kzalloc(sizeof(struct acpi_battery), GFP_KERNEL);
@@ -853,6 +898,9 @@ static int acpi_battery_add(struct acpi_device *device)
 	strcpy(acpi_device_class(device), ACPI_BATTERY_CLASS);
 	device->driver_data = battery;
 	mutex_init(&battery->lock);
+	if (ACPI_SUCCESS(acpi_get_handle(battery->device->handle,
+			"_BIX", &handle)))
+		set_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags);
 	acpi_battery_update(battery);
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	result = acpi_battery_add_fs(device);

commit 7b3bcc4a1a7cd2d53b403ca29d06ceb5fa617eb7
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Thu Oct 15 14:31:24 2009 +0400

    ACPI: Battery: Add bit flags
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index cada73ffdfa7..b2b48f8545c7 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -88,10 +88,13 @@ static const struct acpi_device_id battery_device_ids[] = {
 
 MODULE_DEVICE_TABLE(acpi, battery_device_ids);
 
-/* For buggy DSDTs that report negative 16-bit values for either charging
- * or discharging current and/or report 0 as 65536 due to bad math.
- */
-#define QUIRK_SIGNED16_CURRENT 0x0001
+enum {
+	ACPI_BATTERY_ALARM_PRESENT,
+	/* For buggy DSDTs that report negative 16-bit values for either charging
+	* or discharging current and/or report 0 as 65536 due to bad math.
+	*/
+	ACPI_BATTERY_QUIRK_SIGNED16_CURRENT,
+};
 
 struct acpi_battery {
 	struct mutex lock;
@@ -118,8 +121,7 @@ struct acpi_battery {
 	char oem_info[32];
 	int state;
 	int power_unit;
-	u8 alarm_present;
-	long quirks;
+	unsigned long flags;
 };
 
 #define to_acpi_battery(x) container_of(x, struct acpi_battery, bat);
@@ -399,7 +401,7 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 	battery->update_time = jiffies;
 	kfree(buffer.pointer);
 
-	if ((battery->quirks & QUIRK_SIGNED16_CURRENT) &&
+	if (test_bit(ACPI_BATTERY_QUIRK_SIGNED16_CURRENT, &battery->flags) &&
 	    battery->rate_now != -1)
 		battery->rate_now = abs((s16)battery->rate_now);
 
@@ -412,7 +414,8 @@ static int acpi_battery_set_alarm(struct acpi_battery *battery)
 	union acpi_object arg0 = { .type = ACPI_TYPE_INTEGER };
 	struct acpi_object_list arg_list = { 1, &arg0 };
 
-	if (!acpi_battery_present(battery)|| !battery->alarm_present)
+	if (!acpi_battery_present(battery)||
+	    !test_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags))
 		return -ENODEV;
 
 	arg0.integer.value = battery->alarm;
@@ -437,10 +440,10 @@ static int acpi_battery_init_alarm(struct acpi_battery *battery)
 	/* See if alarms are supported, and if so, set default */
 	status = acpi_get_handle(battery->device->handle, "_BTP", &handle);
 	if (ACPI_FAILURE(status)) {
-		battery->alarm_present = 0;
+		clear_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags);
 		return 0;
 	}
-	battery->alarm_present = 1;
+	set_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags);
 	if (!battery->alarm)
 		battery->alarm = battery->design_capacity_warning;
 	return acpi_battery_set_alarm(battery);
@@ -510,9 +513,8 @@ static void sysfs_remove_battery(struct acpi_battery *battery)
 
 static void acpi_battery_quirks(struct acpi_battery *battery)
 {
-	battery->quirks = 0;
 	if (dmi_name_in_vendors("Acer") && battery->power_unit) {
-		battery->quirks |= QUIRK_SIGNED16_CURRENT;
+		set_bit(ACPI_BATTERY_QUIRK_SIGNED16_CURRENT, &battery->flags);
 	}
 }
 

commit 2345baf4a8a0ac2e7e83f932048bb2d8ec1287e7
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Sun Dec 13 14:42:36 2009 -0800

    battery: fix typo in comment
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 3f4602b8f287..cada73ffdfa7 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -831,7 +831,7 @@ static void acpi_battery_notify(struct acpi_device *device, u32 event)
 					dev_name(&device->dev), event,
 					acpi_battery_present(battery));
 #ifdef CONFIG_ACPI_SYSFS_POWER
-	/* acpi_batter_update could remove power_supply object */
+	/* acpi_battery_update could remove power_supply object */
 	if (battery->bat.dev)
 		kobject_uevent(&battery->bat.dev->kobj, KOBJ_CHANGE);
 #endif

commit 7a92d803227a523a9a5546e4e0dce1325a4b5926
Merge: b4549a24b619 bc76f90b8a5c
Author: Len Brown <len.brown@intel.com>
Date:   Sat Sep 19 01:56:17 2009 -0400

    Merge branch 'battery' into release

commit bc76f90b8a5cf4aceedf210d08d5e8292f820cec
Author: Hector Martin <hector@marcansoft.com>
Date:   Thu Aug 6 15:57:48 2009 -0700

    ACPI battery: work around negative s16 battery current on Acer
    
    Acer Aspire 8930G laptops (and possibly others) report the battery current
    as a 16-bit signed negative when it is charging.  It also reports it as
    0x10000 when the current is 0.  This patch adds a quirk for this which
    takes the absolute value of the reported current cast to an s16.  This is
    a DSDT bug present in the latest BIOS revision (the EC register is 16 bits
    signed and the DSDT attempts to take the 16-bit two's complement of this,
    which works for discharge but not charge.  It also breaks zero values
    because a 32-bit register is used and the high bits aren't thrown away).
    
    I've enabled this for all Acer systems which report in mA units.  This
    should be safe since it won't break compliant systems unless they report a
    current above 32A, which is insane.  The patch also detects the valid
    32-bit value -1, which indicates unknown status, and does not attempt the
    fix in that case (note that this does not conflict with 16-bit -1, which
    is 65535 as read normally and gets translated to 1mA).
    
    Signed-off-by: Hector Martin <hector@marcansoft.com>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 58b4517ce712..d7a786d5c4a5 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -31,6 +31,7 @@
 #include <linux/types.h>
 #include <linux/jiffies.h>
 #include <linux/async.h>
+#include <linux/dmi.h>
 
 #ifdef CONFIG_ACPI_PROCFS_POWER
 #include <linux/proc_fs.h>
@@ -85,6 +86,10 @@ static const struct acpi_device_id battery_device_ids[] = {
 
 MODULE_DEVICE_TABLE(acpi, battery_device_ids);
 
+/* For buggy DSDTs that report negative 16-bit values for either charging
+ * or discharging current and/or report 0 as 65536 due to bad math.
+ */
+#define QUIRK_SIGNED16_CURRENT 0x0001
 
 struct acpi_battery {
 	struct mutex lock;
@@ -112,6 +117,7 @@ struct acpi_battery {
 	int state;
 	int power_unit;
 	u8 alarm_present;
+	long quirks;
 };
 
 #define to_acpi_battery(x) container_of(x, struct acpi_battery, bat);
@@ -390,6 +396,11 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 				 state_offsets, ARRAY_SIZE(state_offsets));
 	battery->update_time = jiffies;
 	kfree(buffer.pointer);
+
+	if ((battery->quirks & QUIRK_SIGNED16_CURRENT) &&
+	    battery->rate_now != -1)
+		battery->rate_now = abs((s16)battery->rate_now);
+
 	return result;
 }
 
@@ -495,6 +506,14 @@ static void sysfs_remove_battery(struct acpi_battery *battery)
 }
 #endif
 
+static void acpi_battery_quirks(struct acpi_battery *battery)
+{
+	battery->quirks = 0;
+	if (dmi_name_in_vendors("Acer") && battery->power_unit) {
+		battery->quirks |= QUIRK_SIGNED16_CURRENT;
+	}
+}
+
 static int acpi_battery_update(struct acpi_battery *battery)
 {
 	int result, old_present = acpi_battery_present(battery);
@@ -513,6 +532,7 @@ static int acpi_battery_update(struct acpi_battery *battery)
 		result = acpi_battery_get_info(battery);
 		if (result)
 			return result;
+		acpi_battery_quirks(battery);
 		acpi_battery_init_alarm(battery);
 	}
 #ifdef CONFIG_ACPI_SYSFS_POWER

commit a192a9580bcc41692be1f36b77c3b681827f566a
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jul 28 16:45:54 2009 -0400

    ACPI: Move definition of PREFIX from acpi_bus.h to internal..h
    
    Linux/ACPI core files using internal.h all PREFIX "ACPI: ",
    however, not all ACPI drivers use/want it -- and they
    should not have to #undef PREFIX to define their own.
    
    Add GPL commment to internal.h while we are there.
    
    This does not change any actual console output,
    asside from a whitespace fix.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 58b4517ce712..f8c3d1bb6969 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -45,6 +45,8 @@
 #include <linux/power_supply.h>
 #endif
 
+#define PREFIX "ACPI: "
+
 #define ACPI_BATTERY_VALUE_UNKNOWN 0xFFFFFFFF
 
 #define ACPI_BATTERY_CLASS		"battery"

commit 586caae36cece718ff46b3a59b88af79e9f7a2e0
Author: Len Brown <len.brown@intel.com>
Date:   Thu Jun 18 00:38:27 2009 -0400

    ACPI: battery: fix CONFIG_ACPI_PROCFS_POWER=n build warning
    
    drivers/acpi/battery.c:841: warning: label end defined but not used
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index eb00c4e3747a..58b4517ce712 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -832,14 +832,12 @@ static int acpi_battery_add(struct acpi_device *device)
 	acpi_battery_update(battery);
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	result = acpi_battery_add_fs(device);
-	if (result)
-		goto end;
 #endif
-	printk(KERN_INFO PREFIX "%s Slot [%s] (battery %s)\n",
-	       ACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),
-	       device->status.battery_present ? "present" : "absent");
-      end:
-	if (result) {
+	if (!result) {
+		printk(KERN_INFO PREFIX "%s Slot [%s] (battery %s)\n",
+			ACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),
+			device->status.battery_present ? "present" : "absent");
+	} else {
 #ifdef CONFIG_ACPI_PROCFS_POWER
 		acpi_battery_remove_fs(device);
 #endif

commit d94066910943837558d2a461c6766da981260bf0
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Apr 30 09:35:47 2009 -0600

    ACPI: battery: use .notify method instead of installing handler directly
    
    This patch adds a .notify() method.  The presence of .notify() causes
    Linux/ACPI to manage event handlers and notify handlers on our behalf,
    so we don't have to install and remove them ourselves.
    
    This driver apparently relies on seeing ALL notify events, not just
    device-specific ones (because it used ACPI_ALL_NOTIFY).  We use the
    ACPI_DRIVER_ALL_NOTIFY_EVENTS driver flag to request all events.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    CC: Alexey Starikovskiy <alexey.y.starikovskiy@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index b0de6312919a..eb00c4e3747a 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -796,13 +796,12 @@ static void acpi_battery_remove_fs(struct acpi_device *device)
                                  Driver Interface
    -------------------------------------------------------------------------- */
 
-static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
+static void acpi_battery_notify(struct acpi_device *device, u32 event)
 {
-	struct acpi_battery *battery = data;
-	struct acpi_device *device;
+	struct acpi_battery *battery = acpi_driver_data(device);
+
 	if (!battery)
 		return;
-	device = battery->device;
 	acpi_battery_update(battery);
 	acpi_bus_generate_proc_event(device, event,
 				     acpi_battery_present(battery));
@@ -819,7 +818,6 @@ static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 static int acpi_battery_add(struct acpi_device *device)
 {
 	int result = 0;
-	acpi_status status = 0;
 	struct acpi_battery *battery = NULL;
 	if (!device)
 		return -EINVAL;
@@ -837,14 +835,6 @@ static int acpi_battery_add(struct acpi_device *device)
 	if (result)
 		goto end;
 #endif
-	status = acpi_install_notify_handler(device->handle,
-					     ACPI_ALL_NOTIFY,
-					     acpi_battery_notify, battery);
-	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, status, "Installing notify handler"));
-		result = -ENODEV;
-		goto end;
-	}
 	printk(KERN_INFO PREFIX "%s Slot [%s] (battery %s)\n",
 	       ACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),
 	       device->status.battery_present ? "present" : "absent");
@@ -860,15 +850,11 @@ static int acpi_battery_add(struct acpi_device *device)
 
 static int acpi_battery_remove(struct acpi_device *device, int type)
 {
-	acpi_status status = 0;
 	struct acpi_battery *battery = NULL;
 
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
 	battery = acpi_driver_data(device);
-	status = acpi_remove_notify_handler(device->handle,
-					    ACPI_ALL_NOTIFY,
-					    acpi_battery_notify);
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	acpi_battery_remove_fs(device);
 #endif
@@ -896,10 +882,12 @@ static struct acpi_driver acpi_battery_driver = {
 	.name = "battery",
 	.class = ACPI_BATTERY_CLASS,
 	.ids = battery_device_ids,
+	.flags = ACPI_DRIVER_ALL_NOTIFY_EVENTS,
 	.ops = {
 		.add = acpi_battery_add,
 		.resume = acpi_battery_resume,
 		.remove = acpi_battery_remove,
+		.notify = acpi_battery_notify,
 		},
 };
 

commit b0cbc861a3c05e634520b049b5cc27ad6febb51f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 11 12:45:20 2009 -0700

    Revert "ACPI battery: fix async boot oops"
    
    This reverts commit 5d38258ec026921a7b266f4047ebeaa75db358e5, since the
    underlying problem got fixed properly in the previous commit ("async:
    Fix module loading async-work regression").
    
    Cc: Arkadiusz Miskiewicz <a.miskiewicz@gmail.com>
    Cc: Vegard Nossum <vegard.nossum@gmail.com>
    Cc: Len Brown <len.brown@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 3c7d8942f23b..b0de6312919a 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -903,7 +903,7 @@ static struct acpi_driver acpi_battery_driver = {
 		},
 };
 
-static void acpi_battery_init_async(void *unused, async_cookie_t cookie)
+static void __init acpi_battery_init_async(void *unused, async_cookie_t cookie)
 {
 	if (acpi_disabled)
 		return;

commit 5d38258ec026921a7b266f4047ebeaa75db358e5
Author: Vegard Nossum <vegard.nossum@gmail.com>
Date:   Tue Apr 7 10:55:38 2009 +0200

    ACPI battery: fix async boot oops
    
    > BUG: unable to handle kernel NULL pointer dereference at (null)
    
    What happens is that the battery module's init sections are being freed
    before the async callback (which was marked __init) has run. This theory
    is supported by the fact that the bad RIP value is a vmalloc address.
    
    The immediate fix is to make this a non-init call.
    
    (A better long-term fix is of course to wait with init-section unloading
    until a module's async initcalls have been run, which would allow us to
    discard this function which is still only run once, after all. Perhaps a
    new async_initcall() function for the async/module API, if this is needed
    for other modules in the future?)
    
    Reported-by: Arkadiusz Miskiewicz <a.miskiewicz@gmail.com>
    Signed-off-by: Vegard Nossum <vegard.nossum@gmail.com>
    Tested-by: Alessandro Suardi <alessandro.suardi@gmail.com>
    Tested-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index b0de6312919a..3c7d8942f23b 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -903,7 +903,7 @@ static struct acpi_driver acpi_battery_driver = {
 		},
 };
 
-static void __init acpi_battery_init_async(void *unused, async_cookie_t cookie)
+static void acpi_battery_init_async(void *unused, async_cookie_t cookie)
 {
 	if (acpi_disabled)
 		return;

commit 478c6a43fcbc6c11609f8cee7c7b57223907754f
Merge: 8a3f257c704e 6bb597507f98
Author: Len Brown <len.brown@intel.com>
Date:   Sun Apr 5 02:14:15 2009 -0400

    Merge branch 'linus' into release
    
    Conflicts:
            arch/x86/kernel/cpu/cpufreq/longhaul.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit e2fae0abf6a9c7a2da1a481b7adb4e24f7778992
Merge: fff251f6b26b c07c9a78a95c
Author: Len Brown <len.brown@intel.com>
Date:   Sun Apr 5 01:51:16 2009 -0400

    Merge branch 'constify' into release

commit 59b17bf6ea06abed519dfc788fff1b6b9499d23f
Merge: edd84690d15e 0f66af530116
Author: Len Brown <len.brown@intel.com>
Date:   Sun Apr 5 01:48:46 2009 -0400

    Merge branch 'async-battery' into release
    
    Conflicts:
            drivers/acpi/Makefile
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 0f66af530116e9f4dd97f328d91718b56a6fc5a4
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Sat Jan 10 14:19:05 2009 -0500

    ACPI: battery: asynchronous init
    
    The battery driver tends to take quite some time to initialize
    (100ms-300ms is quite typical).
    This patch initializes the batter driver asynchronously, so that other
    things in the kernel can initialize in parallel to this 300 msec.
    
    As part of this, the battery driver had to move to the back
    of the ACPI init order (hence the Makefile change).
    Without this move, the next ACPI driver would just block
    on the ACPI/devicee layer semaphores until the battery driver was
    done anyway, not gaining any boot time.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 69cbc57c2d1c..0f1c8190c1d3 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -30,6 +30,7 @@
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/jiffies.h>
+#include <linux/async.h>
 
 #ifdef CONFIG_ACPI_PROCFS_POWER
 #include <linux/proc_fs.h>
@@ -901,21 +902,27 @@ static struct acpi_driver acpi_battery_driver = {
 		},
 };
 
-static int __init acpi_battery_init(void)
+static void __init acpi_battery_init_async(void *unused, async_cookie_t cookie)
 {
 	if (acpi_disabled)
-		return -ENODEV;
+		return;
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	acpi_battery_dir = acpi_lock_battery_dir();
 	if (!acpi_battery_dir)
-		return -ENODEV;
+		return;
 #endif
 	if (acpi_bus_register_driver(&acpi_battery_driver) < 0) {
 #ifdef CONFIG_ACPI_PROCFS_POWER
 		acpi_unlock_battery_dir(acpi_battery_dir);
 #endif
-		return -ENODEV;
+		return;
 	}
+	return;
+}
+
+static int __init acpi_battery_init(void)
+{
+	async_schedule(acpi_battery_init_async, NULL);
 	return 0;
 }
 

commit 070d8eb1f6b789206486ea6a4a1bb7745d86d314
Author: Jan Engelhardt <jengelh@medozas.de>
Date:   Mon Jan 12 00:07:55 2009 +0100

    ACPI: constify VFTs (1/2)
    
    Signed-off-by: Jan Engelhardt <jengelh@medozas.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 69cbc57c2d1c..4d11b0704d5f 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -740,7 +740,7 @@ DECLARE_FILE_FUNCTIONS(alarm);
 static struct battery_file {
 	struct file_operations ops;
 	mode_t mode;
-	char *name;
+	const char *name;
 } acpi_battery_file[] = {
 	FILE_DESCRIPTION_RO(info),
 	FILE_DESCRIPTION_RO(state),

commit 99b76233803beab302123d243eea9e41149804f3
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 25 22:48:06 2009 +0300

    proc 2/2: remove struct proc_dir_entry::owner
    
    Setting ->owner as done currently (pde->owner = THIS_MODULE) is racy
    as correctly noted at bug #12454. Someone can lookup entry with NULL
    ->owner, thus not pinning enything, and release it later resulting
    in module refcount underflow.
    
    We can keep ->owner and supply it at registration time like ->proc_fops
    and ->data.
    
    But this leaves ->owner as easy-manipulative field (just one C assignment)
    and somebody will forget to unpin previous/pin current module when
    switching ->owner. ->proc_fops is declared as "const" which should give
    some thoughts.
    
    ->read_proc/->write_proc were just fixed to not require ->owner for
    protection.
    
    rmmod'ed directories will be empty and return "." and ".." -- no harm.
    And directories with tricky enough readdir and lookup shouldn't be modular.
    We definitely don't want such modular code.
    
    Removing ->owner will also make PDE smaller.
    
    So, let's nuke it.
    
    Kudos to Jeff Layton for reminding about this, let's say, oversight.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=12454
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 69cbc57c2d1c..3bcb5bfc45d3 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -760,7 +760,6 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 						     acpi_battery_dir);
 		if (!acpi_device_dir(device))
 			return -ENODEV;
-		acpi_device_dir(device)->owner = THIS_MODULE;
 	}
 
 	for (i = 0; i < ACPI_BATTERY_NUMFILES; ++i) {

commit 7faa144a518c456e2057918f030f50100144ccc6
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Fri Mar 27 22:23:52 2009 -0400

    ACPI: battery: add power_{now,avg} properties to power_class
    
    ACPI has smart batteries, which work in units of energy and measure
    rate of (dis)charge as power, thus it is not appropriate to export it
    as a current_now. Current_now will still be exported to allow
    for userland applications to match.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 69cbc57c2d1c..09a2240d5605 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -92,7 +92,7 @@ struct acpi_battery {
 #endif
 	struct acpi_device *device;
 	unsigned long update_time;
-	int current_now;
+	int rate_now;
 	int capacity_now;
 	int voltage_now;
 	int design_capacity;
@@ -196,7 +196,8 @@ static int acpi_battery_get_property(struct power_supply *psy,
 		val->intval = battery->voltage_now * 1000;
 		break;
 	case POWER_SUPPLY_PROP_CURRENT_NOW:
-		val->intval = battery->current_now * 1000;
+	case POWER_SUPPLY_PROP_POWER_NOW:
+		val->intval = battery->rate_now * 1000;
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
 	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
@@ -247,6 +248,7 @@ static enum power_supply_property energy_battery_props[] = {
 	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
 	POWER_SUPPLY_PROP_VOLTAGE_NOW,
 	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_POWER_NOW,
 	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
 	POWER_SUPPLY_PROP_ENERGY_FULL,
 	POWER_SUPPLY_PROP_ENERGY_NOW,
@@ -273,7 +275,7 @@ struct acpi_offsets {
 
 static struct acpi_offsets state_offsets[] = {
 	{offsetof(struct acpi_battery, state), 0},
-	{offsetof(struct acpi_battery, current_now), 0},
+	{offsetof(struct acpi_battery, rate_now), 0},
 	{offsetof(struct acpi_battery, capacity_now), 0},
 	{offsetof(struct acpi_battery, voltage_now), 0},
 };
@@ -605,11 +607,11 @@ static int acpi_battery_print_state(struct seq_file *seq, int result)
 	else
 		seq_printf(seq, "charging state:          charged\n");
 
-	if (battery->current_now == ACPI_BATTERY_VALUE_UNKNOWN)
+	if (battery->rate_now == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "present rate:            unknown\n");
 	else
 		seq_printf(seq, "present rate:            %d %s\n",
-			   battery->current_now, acpi_battery_units(battery));
+			   battery->rate_now, acpi_battery_units(battery));
 
 	if (battery->capacity_now == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "remaining capacity:      unknown\n");

commit 56f382a08722186623400180adbb9d1be1721cee
Author: Richard Hughes <hughsient@gmail.com>
Date:   Sun Jan 25 15:05:50 2009 +0000

    battery: don't assume we are fully charged when not charging or discharging
    
    On hardware like the T61 it can take a couple of seconds for the battery
    to start charging after the power is connected, and we incorrectly tell
    userspace that we are fully charged, and then go back to charging.
    
    Only mark a battery as fully charged when the preset charge matches either
    the last full charge, or the design charge.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=12632
    
    Signed-off-by: Richard Hughes <hughsient@gmail.com>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Acked-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 65132f920459..69cbc57c2d1c 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -138,6 +138,29 @@ static int acpi_battery_technology(struct acpi_battery *battery)
 
 static int acpi_battery_get_state(struct acpi_battery *battery);
 
+static int acpi_battery_is_charged(struct acpi_battery *battery)
+{
+	/* either charging or discharging */
+	if (battery->state != 0)
+		return 0;
+
+	/* battery not reporting charge */
+	if (battery->capacity_now == ACPI_BATTERY_VALUE_UNKNOWN ||
+	    battery->capacity_now == 0)
+		return 0;
+
+	/* good batteries update full_charge as the batteries degrade */
+	if (battery->full_charge_capacity == battery->capacity_now)
+		return 1;
+
+	/* fallback to using design values for broken batteries */
+	if (battery->design_capacity == battery->capacity_now)
+		return 1;
+
+	/* we don't do any sort of metric based on percentages */
+	return 0;
+}
+
 static int acpi_battery_get_property(struct power_supply *psy,
 				     enum power_supply_property psp,
 				     union power_supply_propval *val)
@@ -155,7 +178,7 @@ static int acpi_battery_get_property(struct power_supply *psy,
 			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
 		else if (battery->state & 0x02)
 			val->intval = POWER_SUPPLY_STATUS_CHARGING;
-		else if (battery->state == 0)
+		else if (acpi_battery_is_charged(battery))
 			val->intval = POWER_SUPPLY_STATUS_FULL;
 		else
 			val->intval = POWER_SUPPLY_STATUS_UNKNOWN;

commit 50b178512b7d6e7724f87459f6bd06504c9c2da1
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Tue Dec 23 02:44:54 2008 +0300

    Newly inserted battery might differ from one just removed, so
    update of battery info fields is required.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Acked-by: Andy Neitzke <neitzke@ias.edu>
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy <at> suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 1423b0c0cd2e..65132f920459 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -471,7 +471,7 @@ static void sysfs_remove_battery(struct acpi_battery *battery)
 
 static int acpi_battery_update(struct acpi_battery *battery)
 {
-	int result;
+	int result, old_present = acpi_battery_present(battery);
 	result = acpi_battery_get_status(battery);
 	if (result)
 		return result;
@@ -482,7 +482,8 @@ static int acpi_battery_update(struct acpi_battery *battery)
 		return 0;
 	}
 #endif
-	if (!battery->update_time) {
+	if (!battery->update_time ||
+	    old_present != acpi_battery_present(battery)) {
 		result = acpi_battery_get_info(battery);
 		if (result)
 			return result;

commit f10a3a32ae2edbe94920ce6827f4c2550eb6ed48
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 5 13:30:03 2008 -0800

    Revert "ACPI: battery: Convert discharge energy rate to current properly"
    
    This reverts commit 558073dd56707864f09d563b64e7c37c021e89d2, along with
    the failed try to fix the regression it caused ("ACPI: Fix ACPI battery
    regression introduced by commit 558073"), which just made things worse.
    
    Commit aaad077638be1a25871bcae5e43952d6b63abfca (that failed "Fix ACPI
    battery regression") got the voltage conversion confused, and fixed the
    problem with Rafael's battery monitor apparently just by mistake.
    
    So revert them both, getting us back to the 2.6.27 state in this, and
    let's revisit it when people understand what's going on.
    
    Noted-by: Paul Martin <pm@debian.org>
    Requested-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 4fb3c12ac1d8..1423b0c0cd2e 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -173,19 +173,7 @@ static int acpi_battery_get_property(struct power_supply *psy,
 		val->intval = battery->voltage_now * 1000;
 		break;
 	case POWER_SUPPLY_PROP_CURRENT_NOW:
-		val->intval = battery->current_now;
-		if (battery->power_unit) {
-			val->intval *= 1000;
-		} else {
-			/*
-			 * If power units are mW, convert to mA by dividing by
-			 * current voltage.
-			 */
-			if (battery->voltage_now)
-				val->intval /= battery->voltage_now;
-			else
-				val->intval = -1;
-		}
+		val->intval = battery->current_now * 1000;
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
 	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:

commit aaad077638be1a25871bcae5e43952d6b63abfca
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Dec 5 01:07:51 2008 +0100

    ACPI: Fix ACPI battery regression introduced by commit 558073
    
    Commit 558073dd56707864f09d563b64e7c37c021e89d2 ("ACPI: battery: Convert
    discharge energy rate to current properly") caused the battery subsystem
    to report wrong values of the remaining time on battery power and the
    time until fully charged on Toshiba Portege R500 (and presumably on
    other boxes too).
    
    Fix the issue by correcting the conversion from mW to mA.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index a0a178dd189c..4fb3c12ac1d8 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -173,14 +173,17 @@ static int acpi_battery_get_property(struct power_supply *psy,
 		val->intval = battery->voltage_now * 1000;
 		break;
 	case POWER_SUPPLY_PROP_CURRENT_NOW:
-		val->intval = battery->current_now * 1000;
-		/* if power units are mW, convert to mA by
-		   dividing by current voltage (mV/1000) */
-		if (!battery->power_unit) {
-			if (battery->voltage_now) {
+		val->intval = battery->current_now;
+		if (battery->power_unit) {
+			val->intval *= 1000;
+		} else {
+			/*
+			 * If power units are mW, convert to mA by dividing by
+			 * current voltage.
+			 */
+			if (battery->voltage_now)
 				val->intval /= battery->voltage_now;
-				val->intval *= 1000;
-			} else
+			else
 				val->intval = -1;
 		}
 		break;

commit 558073dd56707864f09d563b64e7c37c021e89d2
Author: Alexey Starikovskiy <aystarik@gmail.com>
Date:   Fri Nov 21 22:41:01 2008 +0800

    ACPI: battery: Convert discharge energy rate to current properly
    
    ACPI battery interface reports its state either in mW or in mA, and
    discharge rate in your case is reported in mW. power_supply interface
    does not have such a parameter, so current_now parameter is used
    for all cases. But in case of mW, reported discharge should
    be converted into mA.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Tested-by: Ferenc Wagner <wferi@niif.hu>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 1423b0c0cd2e..a0a178dd189c 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -174,6 +174,15 @@ static int acpi_battery_get_property(struct power_supply *psy,
 		break;
 	case POWER_SUPPLY_PROP_CURRENT_NOW:
 		val->intval = battery->current_now * 1000;
+		/* if power units are mW, convert to mA by
+		   dividing by current voltage (mV/1000) */
+		if (!battery->power_unit) {
+			if (battery->voltage_now) {
+				val->intval /= battery->voltage_now;
+				val->intval *= 1000;
+			} else
+				val->intval = -1;
+		}
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
 	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:

commit 9b5a56ddfd615a27e3a0856ceae1592a24021e42
Merge: a0017f471054 0794469da3f7
Author: Len Brown <len.brown@intel.com>
Date:   Tue Nov 11 21:14:49 2008 -0500

    Merge branch 'sysfs' into release

commit 89595b8f2850a080d290bf778ec933ea1d99f78e
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Nov 7 16:57:45 2008 -0700

    ACPI: consolidate ACPI_*_COMPONENT definitions in acpi_drivers.h
    
    Move all the component definitions for drivers to a single shared place,
    include/acpi/acpi_drivers.h.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index b2133e89ad9a..47f6e38fa6c8 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -46,7 +46,6 @@
 
 #define ACPI_BATTERY_VALUE_UNKNOWN 0xFFFFFFFF
 
-#define ACPI_BATTERY_COMPONENT		0x00040000
 #define ACPI_BATTERY_CLASS		"battery"
 #define ACPI_BATTERY_DEVICE_NAME	"Battery"
 #define ACPI_BATTERY_NOTIFY_STATUS	0x80

commit 0794469da3f7b2093575cbdfc1108308dd3641ce
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Oct 30 01:18:59 2008 +0100

    ACPI: struct device - replace bus_id with dev_name(), dev_set_name()
    
    This patch is part of a larger patch series which will remove
    the "char bus_id[20]" name string from struct device. The device
    name is managed in the kobject anyway, and without any size
    limitation, and just needlessly copied into "struct device".
    
    To set and read the device name dev_name(dev) and dev_set_name(dev)
    must be used. If your code uses static kobjects, which it shouldn't
    do, "const char *init_name" can be used to statically provide the
    name the registered device should have. At registration time, the
    init_name field is cleared, to enforce the use of dev_name(dev) to
    access the device name at a later time.
    
    We need to get rid of all occurrences of bus_id in the entire tree
    to be able to enable the new interface. Please apply this patch,
    and possibly convert any remaining remaining occurrences of bus_id.
    
    We want to submit a patch to -next, which will remove bus_id from
    "struct device", to find the remaining pieces to convert, and finally
    switch over to the new api, which will remove the 20 bytes array
    and does no longer have a size limitation.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-Off-By: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index b2133e89ad9a..e68f2187ed64 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -782,7 +782,7 @@ static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 	acpi_bus_generate_proc_event(device, event,
 				     acpi_battery_present(battery));
 	acpi_bus_generate_netlink_event(device->pnp.device_class,
-					device->dev.bus_id, event,
+					dev_name(&device->dev), event,
 					acpi_battery_present(battery));
 #ifdef CONFIG_ACPI_SYSFS_POWER
 	/* acpi_batter_update could remove power_supply object */

commit 057316cc6a5b521b332a1d7ccc871cd60c904c74
Merge: 3e2dab9a1c2d 2515ddc6db8e
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:57:26 2008 -0400

    Merge branch 'linus' into test
    
    Conflicts:
            MAINTAINERS
            arch/x86/kernel/acpi/boot.c
            arch/x86/kernel/acpi/sleep.c
            drivers/acpi/Kconfig
            drivers/pnp/Makefile
            drivers/pnp/quirks.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 01e8ef11bc1a74e65678ed55795f59266d4add01
Author: Parag Warudkar <parag.lkml@gmail.com>
Date:   Sat Oct 18 20:28:50 2008 -0700

    x86: sysfs: kill owner field from attribute
    
    Tejun's commit 7b595756ec1f49e0049a9e01a1298d53a7faaa15 made sysfs
    attribute->owner unnecessary.  But the field was left in the structure to
    ease the merge.  It's been over a year since that change and it is now
    time to start killing attribute->owner along with its users - one arch at
    a time!
    
    This patch is attempt #1 to get rid of attribute->owner only for
    CONFIG_X86_64 or CONFIG_X86_32 .  We will deal with other arches later on
    as and when possible - avr32 will be the next since that is something I
    can test.  Compile (make allyesconfig / make allmodconfig / custom config)
    and boot tested.
    
    akpm: the idea is that we put the declaration of sttribute.owner inside
    `#ifndef CONFIG_X86'.  But that proved to be too ambitious for now because
    new usages kept on turning up in subsystem trees.
    
    [akpm: remove the ifdef for now]
    Signed-off-by: Parag Warudkar <parag.lkml@gmail.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Tejun Heo <htejun@gmail.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Roland Dreier <rolandd@cisco.com>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index b1c723f9f58d..70f7f60929ca 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -431,7 +431,7 @@ static ssize_t acpi_battery_alarm_store(struct device *dev,
 }
 
 static struct device_attribute alarm_attr = {
-	.attr = {.name = "alarm", .mode = 0644, .owner = THIS_MODULE},
+	.attr = {.name = "alarm", .mode = 0644},
 	.show = acpi_battery_alarm_show,
 	.store = acpi_battery_alarm_store,
 };

commit db89b4f0dbab837d0f3de2c3e9427a8d5393afa3
Author: Pavel Machek <pavel@suse.cz>
Date:   Mon Sep 22 14:37:34 2008 -0700

    ACPI: catch calls of acpi_driver_data on pointer of wrong type
    
    Catch attempts to use of acpi_driver_data on pointers of wrong type.
    
    akpm: rewritten to use proper C typechecking and remove the
    "function"-used-as-lvalue thing.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index b1c723f9f58d..de8046933bce 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -804,7 +804,7 @@ static int acpi_battery_add(struct acpi_device *device)
 	battery->device = device;
 	strcpy(acpi_device_name(device), ACPI_BATTERY_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_BATTERY_CLASS);
-	acpi_driver_data(device) = battery;
+	device->driver_data = battery;
 	mutex_init(&battery->lock);
 	acpi_battery_update(battery);
 #ifdef CONFIG_ACPI_PROCFS_POWER

commit cf7acfab032ff262f42954328cdfd20a5d9aaaac
Author: Denis V. Lunev <den@openvz.org>
Date:   Tue Apr 29 01:02:27 2008 -0700

    acpi: use non-racy method for proc entries creation
    
    Use proc_create()/proc_create_data() to make sure that ->proc_fops and ->data
    be setup before gluing PDE to main tree.
    
    Add correct ->owner to proc_fops to fix reading/module unloading race.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index d5729d5dc190..b1c723f9f58d 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -741,15 +741,13 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 	}
 
 	for (i = 0; i < ACPI_BATTERY_NUMFILES; ++i) {
-		entry = create_proc_entry(acpi_battery_file[i].name,
-				  acpi_battery_file[i].mode, acpi_device_dir(device));
+		entry = proc_create_data(acpi_battery_file[i].name,
+					 acpi_battery_file[i].mode,
+					 acpi_device_dir(device),
+					 &acpi_battery_file[i].ops,
+					 acpi_driver_data(device));
 		if (!entry)
 			return -ENODEV;
-		else {
-			entry->proc_fops = &acpi_battery_file[i].ops;
-			entry->data = acpi_driver_data(device);
-			entry->owner = THIS_MODULE;
-		}
 	}
 	return 0;
 }

commit b8a1bdb14940946fcf0438a6337b2a6c54294fb8
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Mon Mar 17 22:37:42 2008 -0400

    ACPI: battery: Don't return -EFAIL on broken packages.
    
    Acer BIOS has a bug which is exposed when a dead battery is present.
    
    The package template that is used to describe battery status is
    over-written with sane values when the battery is live.
    But when the batter is dead, a bogus reference in the template
    is used.  In this case, Linux returns a fault, when instead
    it should simply return that it doesn't know the missing value.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=8573
    http://bugzilla.kernel.org/show_bug.cgi?id=10202
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index f6215e809808..d5729d5dc190 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -293,13 +293,12 @@ static int extract_package(struct acpi_battery *battery,
 				strncpy(ptr, (u8 *)&element->integer.value,
 					sizeof(acpi_integer));
 				ptr[sizeof(acpi_integer)] = 0;
-			} else return -EFAULT;
+			} else
+				*ptr = 0; /* don't have value */
 		} else {
-			if (element->type == ACPI_TYPE_INTEGER) {
-				int *x = (int *)((u8 *)battery +
-						offsets[i].offset);
-				*x = element->integer.value;
-			} else return -EFAULT;
+			int *x = (int *)((u8 *)battery + offsets[i].offset);
+			*x = (element->type == ACPI_TYPE_INTEGER) ?
+				element->integer.value : -1;
 		}
 	}
 	return 0;

commit 7c2670bbb53820d0a4fab8d74593eeccd1eef225
Author: maximilian attems <max@stro.at>
Date:   Tue Jan 22 18:46:50 2008 +0100

    ACPI: battery: add sysfs serial number
    
    egrep serial /proc/acpi/battery/BAT0/info
    serial number:           32090
    
    serial number can tell you from the imminent danger
    of beeing set on fire.
    
    Signed-off-by: maximilian attems <max@stro.at>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index c4a769d1ba85..f6215e809808 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -194,6 +194,9 @@ static int acpi_battery_get_property(struct power_supply *psy,
 	case POWER_SUPPLY_PROP_MANUFACTURER:
 		val->strval = battery->oem_info;
 		break;
+	case POWER_SUPPLY_PROP_SERIAL_NUMBER:
+		val->strval = battery->serial_number;
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -212,6 +215,7 @@ static enum power_supply_property charge_battery_props[] = {
 	POWER_SUPPLY_PROP_CHARGE_NOW,
 	POWER_SUPPLY_PROP_MODEL_NAME,
 	POWER_SUPPLY_PROP_MANUFACTURER,
+	POWER_SUPPLY_PROP_SERIAL_NUMBER,
 };
 
 static enum power_supply_property energy_battery_props[] = {
@@ -226,6 +230,7 @@ static enum power_supply_property energy_battery_props[] = {
 	POWER_SUPPLY_PROP_ENERGY_NOW,
 	POWER_SUPPLY_PROP_MODEL_NAME,
 	POWER_SUPPLY_PROP_MANUFACTURER,
+	POWER_SUPPLY_PROP_SERIAL_NUMBER,
 };
 #endif
 

commit 97749cd9adbb2985e4b2aee1a59d6b970fe9c3a7
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Tue Jan 1 14:27:24 2008 -0500

    ACPI: Make sysfs interface in ACPI power optional.
    
    Reference: http://bugzilla.kernel.org/show_bug.cgi?id=9494
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 8f7505d304b5..c4a769d1ba85 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -40,7 +40,9 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
+#ifdef CONFIG_ACPI_SYSFS_POWER
 #include <linux/power_supply.h>
+#endif
 
 #define ACPI_BATTERY_VALUE_UNKNOWN 0xFFFFFFFF
 
@@ -86,7 +88,9 @@ MODULE_DEVICE_TABLE(acpi, battery_device_ids);
 
 struct acpi_battery {
 	struct mutex lock;
+#ifdef CONFIG_ACPI_SYSFS_POWER
 	struct power_supply bat;
+#endif
 	struct acpi_device *device;
 	unsigned long update_time;
 	int current_now;
@@ -117,6 +121,7 @@ inline int acpi_battery_present(struct acpi_battery *battery)
 	return battery->device->status.battery_present;
 }
 
+#ifdef CONFIG_ACPI_SYSFS_POWER
 static int acpi_battery_technology(struct acpi_battery *battery)
 {
 	if (!strcasecmp("NiCd", battery->type))
@@ -222,6 +227,7 @@ static enum power_supply_property energy_battery_props[] = {
 	POWER_SUPPLY_PROP_MODEL_NAME,
 	POWER_SUPPLY_PROP_MANUFACTURER,
 };
+#endif
 
 #ifdef CONFIG_ACPI_PROCFS_POWER
 inline char *acpi_battery_units(struct acpi_battery *battery)
@@ -398,6 +404,7 @@ static int acpi_battery_init_alarm(struct acpi_battery *battery)
 	return acpi_battery_set_alarm(battery);
 }
 
+#ifdef CONFIG_ACPI_SYSFS_POWER
 static ssize_t acpi_battery_alarm_show(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
@@ -429,11 +436,6 @@ static int sysfs_add_battery(struct acpi_battery *battery)
 {
 	int result;
 
-	battery->update_time = 0;
-	result = acpi_battery_get_info(battery);
-	acpi_battery_init_alarm(battery);
-	if (result)
-		return result;
 	if (battery->power_unit) {
 		battery->bat.properties = charge_battery_props;
 		battery->bat.num_properties =
@@ -462,18 +464,31 @@ static void sysfs_remove_battery(struct acpi_battery *battery)
 	power_supply_unregister(&battery->bat);
 	battery->bat.dev = NULL;
 }
+#endif
 
 static int acpi_battery_update(struct acpi_battery *battery)
 {
-	int result = acpi_battery_get_status(battery);
+	int result;
+	result = acpi_battery_get_status(battery);
 	if (result)
 		return result;
+#ifdef CONFIG_ACPI_SYSFS_POWER
 	if (!acpi_battery_present(battery)) {
 		sysfs_remove_battery(battery);
+		battery->update_time = 0;
 		return 0;
 	}
+#endif
+	if (!battery->update_time) {
+		result = acpi_battery_get_info(battery);
+		if (result)
+			return result;
+		acpi_battery_init_alarm(battery);
+	}
+#ifdef CONFIG_ACPI_SYSFS_POWER
 	if (!battery->bat.dev)
 		sysfs_add_battery(battery);
+#endif
 	return acpi_battery_get_state(battery);
 }
 
@@ -767,9 +782,11 @@ static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 	acpi_bus_generate_netlink_event(device->pnp.device_class,
 					device->dev.bus_id, event,
 					acpi_battery_present(battery));
+#ifdef CONFIG_ACPI_SYSFS_POWER
 	/* acpi_batter_update could remove power_supply object */
 	if (battery->bat.dev)
 		kobject_uevent(&battery->bat.dev->kobj, KOBJ_CHANGE);
+#endif
 }
 
 static int acpi_battery_add(struct acpi_device *device)
@@ -828,7 +845,9 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 #ifdef CONFIG_ACPI_PROCFS_POWER
 	acpi_battery_remove_fs(device);
 #endif
+#ifdef CONFIG_ACPI_SYSFS_POWER
 	sysfs_remove_battery(battery);
+#endif
 	mutex_destroy(&battery->lock);
 	kfree(battery);
 	return 0;

commit ad40e68bf5c54831cd6b2199fd24d616bac179f7
Author: Andrey Borzenkov <arvidjaar@mail.ru>
Date:   Sat Nov 10 20:02:49 2007 +0300

    ACPI: battery: fix ACPI battery technology reporting
    
    At least some systems report technology information with trailing spaces:
    
    {pts/1}% cat -E /var/tmp/bat/2.6.23 | grep type
    battery type:            Li-ION  $
    
    Use strncasecmp to compare model string to skip trailing part
    
    Signed-off-by: Andrey Borzenkov <arvidjaar@mail.ru>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 7d6be23eff89..8f7505d304b5 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -125,7 +125,7 @@ static int acpi_battery_technology(struct acpi_battery *battery)
 		return POWER_SUPPLY_TECHNOLOGY_NiMH;
 	if (!strcasecmp("LION", battery->type))
 		return POWER_SUPPLY_TECHNOLOGY_LION;
-	if (!strcasecmp("LI-ION", battery->type))
+	if (!strncasecmp("LI-ION", battery->type, 6))
 		return POWER_SUPPLY_TECHNOLOGY_LION;
 	if (!strcasecmp("LiP", battery->type))
 		return POWER_SUPPLY_TECHNOLOGY_LIPO;

commit c2e46d2e2a8e6ed17fac6154ac7e5fa7fe4efb28
Merge: 95b00786f3b8 65ea6520375c
Author: Len Brown <len.brown@intel.com>
Date:   Tue Nov 20 01:20:00 2007 -0500

    Pull procfs-default into release branch
    
    Conflicts:
    
            drivers/acpi/sbs.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 86533e80e0a20ed1a676f9eeb2dde0fa5ff23276
Merge: 2ffbb8377c7a 037cbc63fd83
Author: Len Brown <len.brown@intel.com>
Date:   Tue Nov 20 01:17:42 2007 -0500

    Pull battery into release branch

commit fdcedbba2f98c94bfbac9f6e712ab765f997b8dc
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Mon Nov 19 16:33:45 2007 +0300

    ACPI: Split out control for /proc/acpi entries from battery, ac, and sbs.
    
    Introduce new ACPI_PROCFS_POWER (default Yes) config option and move
    procfs code in battery, ac, and sbs drivers under it.
    This is done to allow ACPI_PROCFS to be default No.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 192c244f6190..b871f289dd30 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -31,7 +31,7 @@
 #include <linux/types.h>
 #include <linux/jiffies.h>
 
-#ifdef CONFIG_ACPI_PROCFS
+#ifdef CONFIG_ACPI_PROCFS_POWER
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <asm/uaccess.h>
@@ -63,7 +63,7 @@ static unsigned int cache_time = 1000;
 module_param(cache_time, uint, 0644);
 MODULE_PARM_DESC(cache_time, "cache time in milliseconds");
 
-#ifdef CONFIG_ACPI_PROCFS
+#ifdef CONFIG_ACPI_PROCFS_POWER
 extern struct proc_dir_entry *acpi_lock_battery_dir(void);
 extern void *acpi_unlock_battery_dir(struct proc_dir_entry *acpi_battery_dir);
 
@@ -221,7 +221,7 @@ static enum power_supply_property energy_battery_props[] = {
 	POWER_SUPPLY_PROP_MANUFACTURER,
 };
 
-#ifdef CONFIG_ACPI_PROCFS
+#ifdef CONFIG_ACPI_PROCFS_POWER
 inline char *acpi_battery_units(struct acpi_battery *battery)
 {
 	return (battery->power_unit)?"mA":"mW";
@@ -479,7 +479,7 @@ static int acpi_battery_update(struct acpi_battery *battery)
                               FS Interface (/proc)
    -------------------------------------------------------------------------- */
 
-#ifdef CONFIG_ACPI_PROCFS
+#ifdef CONFIG_ACPI_PROCFS_POWER
 static struct proc_dir_entry *acpi_battery_dir;
 
 static int acpi_battery_print_info(struct seq_file *seq, int result)
@@ -786,7 +786,7 @@ static int acpi_battery_add(struct acpi_device *device)
 	acpi_driver_data(device) = battery;
 	mutex_init(&battery->lock);
 	acpi_battery_update(battery);
-#ifdef CONFIG_ACPI_PROCFS
+#ifdef CONFIG_ACPI_PROCFS_POWER
 	result = acpi_battery_add_fs(device);
 	if (result)
 		goto end;
@@ -804,7 +804,7 @@ static int acpi_battery_add(struct acpi_device *device)
 	       device->status.battery_present ? "present" : "absent");
       end:
 	if (result) {
-#ifdef CONFIG_ACPI_PROCFS
+#ifdef CONFIG_ACPI_PROCFS_POWER
 		acpi_battery_remove_fs(device);
 #endif
 		kfree(battery);
@@ -823,7 +823,7 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 	status = acpi_remove_notify_handler(device->handle,
 					    ACPI_ALL_NOTIFY,
 					    acpi_battery_notify);
-#ifdef CONFIG_ACPI_PROCFS
+#ifdef CONFIG_ACPI_PROCFS_POWER
 	acpi_battery_remove_fs(device);
 #endif
 	sysfs_remove_battery(battery);
@@ -859,13 +859,13 @@ static int __init acpi_battery_init(void)
 {
 	if (acpi_disabled)
 		return -ENODEV;
-#ifdef CONFIG_ACPI_PROCFS
+#ifdef CONFIG_ACPI_PROCFS_POWER
 	acpi_battery_dir = acpi_lock_battery_dir();
 	if (!acpi_battery_dir)
 		return -ENODEV;
 #endif
 	if (acpi_bus_register_driver(&acpi_battery_driver) < 0) {
-#ifdef CONFIG_ACPI_PROCFS
+#ifdef CONFIG_ACPI_PROCFS_POWER
 		acpi_unlock_battery_dir(acpi_battery_dir);
 #endif
 		return -ENODEV;
@@ -876,7 +876,7 @@ static int __init acpi_battery_init(void)
 static void __exit acpi_battery_exit(void)
 {
 	acpi_bus_unregister_driver(&acpi_battery_driver);
-#ifdef CONFIG_ACPI_PROCFS
+#ifdef CONFIG_ACPI_PROCFS_POWER
 	acpi_unlock_battery_dir(acpi_battery_dir);
 #endif
 }

commit 9104476e4efbef8a8e32d48ced583603ff32a2db
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Tue Nov 13 12:23:06 2007 +0300

    ACPI: Battery: remove cycle from battery removal.
    
    get_property() should not call battery_update(), it also should call
    get_status() only if battery is present to avoid cycle and oops.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Tested-by: Rolf Eike Beer <eike-kernel@sf-tec.de>
    Acked-by: Johannes Weiner <hannes@saeurebad.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index c2ce0ad21693..192c244f6190 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -132,7 +132,7 @@ static int acpi_battery_technology(struct acpi_battery *battery)
 	return POWER_SUPPLY_TECHNOLOGY_UNKNOWN;
 }
 
-static int acpi_battery_update(struct acpi_battery *battery);
+static int acpi_battery_get_state(struct acpi_battery *battery);
 
 static int acpi_battery_get_property(struct power_supply *psy,
 				     enum power_supply_property psp,
@@ -140,10 +140,11 @@ static int acpi_battery_get_property(struct power_supply *psy,
 {
 	struct acpi_battery *battery = to_acpi_battery(psy);
 
-	if ((!acpi_battery_present(battery)) &&
-	     psp != POWER_SUPPLY_PROP_PRESENT)
+	if (acpi_battery_present(battery)) {
+		/* run battery update only if it is present */
+		acpi_battery_get_state(battery);
+	} else if (psp != POWER_SUPPLY_PROP_PRESENT)
 		return -ENODEV;
-	acpi_battery_update(battery);
 	switch (psp) {
 	case POWER_SUPPLY_PROP_STATUS:
 		if (battery->state & 0x01)
@@ -457,6 +458,7 @@ static void sysfs_remove_battery(struct acpi_battery *battery)
 		return;
 	device_remove_file(battery->bat.dev, &alarm_attr);
 	power_supply_unregister(&battery->bat);
+	battery->bat.dev = NULL;
 }
 
 static int acpi_battery_update(struct acpi_battery *battery)

commit 4c41d3ad6544f1c9aec37c441af04f5d0ad3a731
Author: Roland Dreier <roland@digitalvampire.org>
Date:   Wed Nov 7 15:09:09 2007 -0800

    ACPI: Always return valid 'status' from acpi_battery_get_property()
    
    If a battery is at a critical charge level and not being charged or
    discharged, then the ACPI _BST method will return a state of 4, and
    the current acpi_battery_get_property() code will not set any property
    value for POWER_SUPPLY_PROP_STATUS.  This will cause an oops in
    power_supply_show_property() when it reads off the end of the
    status_text array.  This actually was causing a 100% reproducible
    crash on boot on my laptop with two batteries, when one battery was
    completely drained and the laptop was not plugged in.
    
    Fix this by making sure acpi_battery_get_property() returns
    POWER_SUPPLY_STATUS_UNKNOWN for any battery state it doesn't already
    handle explicitly.  There doesn't seem to be any status enum value
    defined that makes more sense than 'unknown' for a battery at a
    critical charge level.
    
    Signed-off-by: Roland Dreier <roland@digitalvampire.org>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <lenb@t61.(none)>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index c2ce0ad21693..cbb27b4ddea4 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -152,6 +152,8 @@ static int acpi_battery_get_property(struct power_supply *psy,
 			val->intval = POWER_SUPPLY_STATUS_CHARGING;
 		else if (battery->state == 0)
 			val->intval = POWER_SUPPLY_STATUS_FULL;
+		else
+			val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
 		break;
 	case POWER_SUPPLY_PROP_PRESENT:
 		val->intval = acpi_battery_present(battery);

commit 106449e870b3069c049a3486ae7b47995351270c
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Mon Oct 29 23:29:40 2007 +0300

    ACPI: Battery: Allow extract string from integer
    
    Some machines return integer instead of expected string.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Tested-by: Andrey Borzenkov <arvidjaar@mail.ru>
    Tested-by: Frans Pop <elendil@planet.nl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 74caa07ad351..c2ce0ad21693 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -262,7 +262,7 @@ static int extract_package(struct acpi_battery *battery,
 			   union acpi_object *package,
 			   struct acpi_offsets *offsets, int num)
 {
-	int i, *x;
+	int i;
 	union acpi_object *element;
 	if (package->type != ACPI_TYPE_PACKAGE)
 		return -EFAULT;
@@ -271,16 +271,21 @@ static int extract_package(struct acpi_battery *battery,
 			return -EFAULT;
 		element = &package->package.elements[i];
 		if (offsets[i].mode) {
-			if (element->type != ACPI_TYPE_STRING &&
-			    element->type != ACPI_TYPE_BUFFER)
-				return -EFAULT;
-			strncpy((u8 *)battery + offsets[i].offset,
-				element->string.pointer, 32);
+			u8 *ptr = (u8 *)battery + offsets[i].offset;
+			if (element->type == ACPI_TYPE_STRING ||
+			    element->type == ACPI_TYPE_BUFFER)
+				strncpy(ptr, element->string.pointer, 32);
+			else if (element->type == ACPI_TYPE_INTEGER) {
+				strncpy(ptr, (u8 *)&element->integer.value,
+					sizeof(acpi_integer));
+				ptr[sizeof(acpi_integer)] = 0;
+			} else return -EFAULT;
 		} else {
-			if (element->type != ACPI_TYPE_INTEGER)
-				return -EFAULT;
-			x = (int *)((u8 *)battery + offsets[i].offset);
-			*x = element->integer.value;
+			if (element->type == ACPI_TYPE_INTEGER) {
+				int *x = (int *)((u8 *)battery +
+						offsets[i].offset);
+				*x = element->integer.value;
+			} else return -EFAULT;
 		}
 	}
 	return 0;

commit 0bde7eee9489cc7cce08cf6eba05b4f42a6b2334
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Sun Oct 28 15:33:10 2007 +0300

    ACPI: battery: Support for non-spec name for LiIon technology
    
    Support Li-Ion as possible name for technology.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 489d3385efe4..74caa07ad351 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -125,6 +125,8 @@ static int acpi_battery_technology(struct acpi_battery *battery)
 		return POWER_SUPPLY_TECHNOLOGY_NiMH;
 	if (!strcasecmp("LION", battery->type))
 		return POWER_SUPPLY_TECHNOLOGY_LION;
+	if (!strcasecmp("LI-ION", battery->type))
+		return POWER_SUPPLY_TECHNOLOGY_LION;
 	if (!strcasecmp("LiP", battery->type))
 		return POWER_SUPPLY_TECHNOLOGY_LIPO;
 	return POWER_SUPPLY_TECHNOLOGY_UNKNOWN;

commit 508df92d1f8d1921013cb4f45bb547d0eaff912a
Author: Andrey Borzenkov <arvidjaar@mail.ru>
Date:   Sun Oct 28 12:50:09 2007 +0300

    ACPI: battery: register power_supply subdevice only when battery is present
    
    Make sure no power_supply object is present unless we actualy detect
    presence of battery. This fixes ghost batteries detected by HAL
    
    Signed-off-by: Andrey Borzenkov <arvidjaar@mail.ru>
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 9da8cec80fd1..489d3385efe4 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -388,29 +388,81 @@ static int acpi_battery_init_alarm(struct acpi_battery *battery)
 	return acpi_battery_set_alarm(battery);
 }
 
+static ssize_t acpi_battery_alarm_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct acpi_battery *battery = to_acpi_battery(dev_get_drvdata(dev));
+	return sprintf(buf, "%d\n", battery->alarm * 1000);
+}
+
+static ssize_t acpi_battery_alarm_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	unsigned long x;
+	struct acpi_battery *battery = to_acpi_battery(dev_get_drvdata(dev));
+	if (sscanf(buf, "%ld\n", &x) == 1)
+		battery->alarm = x/1000;
+	if (acpi_battery_present(battery))
+		acpi_battery_set_alarm(battery);
+	return count;
+}
+
+static struct device_attribute alarm_attr = {
+	.attr = {.name = "alarm", .mode = 0644, .owner = THIS_MODULE},
+	.show = acpi_battery_alarm_show,
+	.store = acpi_battery_alarm_store,
+};
+
+static int sysfs_add_battery(struct acpi_battery *battery)
+{
+	int result;
+
+	battery->update_time = 0;
+	result = acpi_battery_get_info(battery);
+	acpi_battery_init_alarm(battery);
+	if (result)
+		return result;
+	if (battery->power_unit) {
+		battery->bat.properties = charge_battery_props;
+		battery->bat.num_properties =
+			ARRAY_SIZE(charge_battery_props);
+	} else {
+		battery->bat.properties = energy_battery_props;
+		battery->bat.num_properties =
+			ARRAY_SIZE(energy_battery_props);
+	}
+
+	battery->bat.name = acpi_device_bid(battery->device);
+	battery->bat.type = POWER_SUPPLY_TYPE_BATTERY;
+	battery->bat.get_property = acpi_battery_get_property;
+
+	result = power_supply_register(&battery->device->dev, &battery->bat);
+	if (result)
+		return result;
+	return device_create_file(battery->bat.dev, &alarm_attr);
+}
+
+static void sysfs_remove_battery(struct acpi_battery *battery)
+{
+	if (!battery->bat.dev)
+		return;
+	device_remove_file(battery->bat.dev, &alarm_attr);
+	power_supply_unregister(&battery->bat);
+}
+
 static int acpi_battery_update(struct acpi_battery *battery)
 {
-	int saved_present = acpi_battery_present(battery);
 	int result = acpi_battery_get_status(battery);
-	if (result || !acpi_battery_present(battery))
+	if (result)
 		return result;
-	if (saved_present != acpi_battery_present(battery) ||
-	    !battery->update_time) {
-		battery->update_time = 0;
-		result = acpi_battery_get_info(battery);
-		if (result)
-			return result;
-		if (battery->power_unit) {
-			battery->bat.properties = charge_battery_props;
-			battery->bat.num_properties =
-				ARRAY_SIZE(charge_battery_props);
-		} else {
-			battery->bat.properties = energy_battery_props;
-			battery->bat.num_properties =
-				ARRAY_SIZE(energy_battery_props);
-		}
-		acpi_battery_init_alarm(battery);
+	if (!acpi_battery_present(battery)) {
+		sysfs_remove_battery(battery);
+		return 0;
 	}
+	if (!battery->bat.dev)
+		sysfs_add_battery(battery);
 	return acpi_battery_get_state(battery);
 }
 
@@ -687,33 +739,6 @@ static void acpi_battery_remove_fs(struct acpi_device *device)
 
 #endif
 
-static ssize_t acpi_battery_alarm_show(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
-{
-	struct acpi_battery *battery = to_acpi_battery(dev_get_drvdata(dev));
-	return sprintf(buf, "%d\n", battery->alarm * 1000);
-}
-
-static ssize_t acpi_battery_alarm_store(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	unsigned long x;
-	struct acpi_battery *battery = to_acpi_battery(dev_get_drvdata(dev));
-	if (sscanf(buf, "%ld\n", &x) == 1)
-		battery->alarm = x/1000;
-	if (acpi_battery_present(battery))
-		acpi_battery_set_alarm(battery);
-	return count;
-}
-
-static struct device_attribute alarm_attr = {
-	.attr = {.name = "alarm", .mode = 0644, .owner = THIS_MODULE},
-	.show = acpi_battery_alarm_show,
-	.store = acpi_battery_alarm_store,
-};
-
 /* --------------------------------------------------------------------------
                                  Driver Interface
    -------------------------------------------------------------------------- */
@@ -731,7 +756,9 @@ static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 	acpi_bus_generate_netlink_event(device->pnp.device_class,
 					device->dev.bus_id, event,
 					acpi_battery_present(battery));
-	kobject_uevent(&battery->bat.dev->kobj, KOBJ_CHANGE);
+	/* acpi_batter_update could remove power_supply object */
+	if (battery->bat.dev)
+		kobject_uevent(&battery->bat.dev->kobj, KOBJ_CHANGE);
 }
 
 static int acpi_battery_add(struct acpi_device *device)
@@ -755,11 +782,6 @@ static int acpi_battery_add(struct acpi_device *device)
 	if (result)
 		goto end;
 #endif
-	battery->bat.name = acpi_device_bid(device);
-	battery->bat.type = POWER_SUPPLY_TYPE_BATTERY;
-	battery->bat.get_property = acpi_battery_get_property;
-	result = power_supply_register(&battery->device->dev, &battery->bat);
-	result = device_create_file(battery->bat.dev, &alarm_attr);
 	status = acpi_install_notify_handler(device->handle,
 					     ACPI_ALL_NOTIFY,
 					     acpi_battery_notify, battery);
@@ -795,10 +817,7 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 #ifdef CONFIG_ACPI_PROCFS
 	acpi_battery_remove_fs(device);
 #endif
-	if (battery->bat.dev) {
-		device_remove_file(battery->bat.dev, &alarm_attr);
-		power_supply_unregister(&battery->bat);
-	}
+	sysfs_remove_battery(battery);
 	mutex_destroy(&battery->lock);
 	kfree(battery);
 	return 0;
@@ -812,6 +831,7 @@ static int acpi_battery_resume(struct acpi_device *device)
 		return -EINVAL;
 	battery = acpi_driver_data(device);
 	battery->update_time = 0;
+	acpi_battery_update(battery);
 	return 0;
 }
 

commit b19073a0be5e317d626b3b404e0039b59383891c
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Thu Oct 25 17:10:47 2007 -0400

    ACPI: battery: Update battery information upon sysfs read.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index a291849f6c5d..9da8cec80fd1 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -130,6 +130,8 @@ static int acpi_battery_technology(struct acpi_battery *battery)
 	return POWER_SUPPLY_TECHNOLOGY_UNKNOWN;
 }
 
+static int acpi_battery_update(struct acpi_battery *battery);
+
 static int acpi_battery_get_property(struct power_supply *psy,
 				     enum power_supply_property psp,
 				     union power_supply_propval *val)
@@ -139,6 +141,7 @@ static int acpi_battery_get_property(struct power_supply *psy,
 	if ((!acpi_battery_present(battery)) &&
 	     psp != POWER_SUPPLY_PROP_PRESENT)
 		return -ENODEV;
+	acpi_battery_update(battery);
 	switch (psp) {
 	case POWER_SUPPLY_PROP_STATUS:
 		if (battery->state & 0x01)

commit c9e4172cde0f793dbf48c99bdfd0abe7d18e4b09
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Oct 24 18:25:37 2007 +0200

    ACPI: battery: remove dead code
    
    After commit f1d4661abe05d0a2c014166042d15ed8b69ae8f2 this was dead
    code.
    
    Spotted by the Coverity checker.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 681e26b56b11..a291849f6c5d 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -554,10 +554,6 @@ static ssize_t acpi_battery_write_alarm(struct file *file,
 
 	if (!battery || (count > sizeof(alarm_string) - 1))
 		return -EINVAL;
-	if (result) {
-		result = -ENODEV;
-		goto end;
-	}
 	if (!acpi_battery_present(battery)) {
 		result = -ENODEV;
 		goto end;

commit 3e58ea0d31659b22ba5753f7abf3d7db346eab81
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Wed Sep 26 19:43:11 2007 +0400

    ACPI: Battery: add sysfs alarm
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 057a5eb67ccc..681e26b56b11 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -687,6 +687,34 @@ static void acpi_battery_remove_fs(struct acpi_device *device)
 }
 
 #endif
+
+static ssize_t acpi_battery_alarm_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct acpi_battery *battery = to_acpi_battery(dev_get_drvdata(dev));
+	return sprintf(buf, "%d\n", battery->alarm * 1000);
+}
+
+static ssize_t acpi_battery_alarm_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	unsigned long x;
+	struct acpi_battery *battery = to_acpi_battery(dev_get_drvdata(dev));
+	if (sscanf(buf, "%ld\n", &x) == 1)
+		battery->alarm = x/1000;
+	if (acpi_battery_present(battery))
+		acpi_battery_set_alarm(battery);
+	return count;
+}
+
+static struct device_attribute alarm_attr = {
+	.attr = {.name = "alarm", .mode = 0644, .owner = THIS_MODULE},
+	.show = acpi_battery_alarm_show,
+	.store = acpi_battery_alarm_store,
+};
+
 /* --------------------------------------------------------------------------
                                  Driver Interface
    -------------------------------------------------------------------------- */
@@ -732,6 +760,7 @@ static int acpi_battery_add(struct acpi_device *device)
 	battery->bat.type = POWER_SUPPLY_TYPE_BATTERY;
 	battery->bat.get_property = acpi_battery_get_property;
 	result = power_supply_register(&battery->device->dev, &battery->bat);
+	result = device_create_file(battery->bat.dev, &alarm_attr);
 	status = acpi_install_notify_handler(device->handle,
 					     ACPI_ALL_NOTIFY,
 					     acpi_battery_notify, battery);
@@ -767,8 +796,10 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 #ifdef CONFIG_ACPI_PROCFS
 	acpi_battery_remove_fs(device);
 #endif
-	if (battery->bat.dev)
+	if (battery->bat.dev) {
+		device_remove_file(battery->bat.dev, &alarm_attr);
 		power_supply_unregister(&battery->bat);
+	}
 	mutex_destroy(&battery->lock);
 	kfree(battery);
 	return 0;

commit d7380965752505951668e85de59c128d1d6fd21f
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Wed Sep 26 19:43:04 2007 +0400

    ACPI: Battery: Add sysfs support
    
    Refer to Documentation/power_supply_class.txt for interface description.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index db725bfe5840..057a5eb67ccc 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -30,13 +30,18 @@
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/jiffies.h>
+
+#ifdef CONFIG_ACPI_PROCFS
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <asm/uaccess.h>
+#endif
 
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
+#include <linux/power_supply.h>
+
 #define ACPI_BATTERY_VALUE_UNKNOWN 0xFFFFFFFF
 
 #define ACPI_BATTERY_COMPONENT		0x00040000
@@ -58,9 +63,19 @@ static unsigned int cache_time = 1000;
 module_param(cache_time, uint, 0644);
 MODULE_PARM_DESC(cache_time, "cache time in milliseconds");
 
+#ifdef CONFIG_ACPI_PROCFS
 extern struct proc_dir_entry *acpi_lock_battery_dir(void);
 extern void *acpi_unlock_battery_dir(struct proc_dir_entry *acpi_battery_dir);
 
+enum acpi_battery_files {
+	info_tag = 0,
+	state_tag,
+	alarm_tag,
+	ACPI_BATTERY_NUMFILES,
+};
+
+#endif
+
 static const struct acpi_device_id battery_device_ids[] = {
 	{"PNP0C0A", 0},
 	{"", 0},
@@ -68,22 +83,17 @@ static const struct acpi_device_id battery_device_ids[] = {
 
 MODULE_DEVICE_TABLE(acpi, battery_device_ids);
 
-enum acpi_battery_files {
-	info_tag = 0,
-	state_tag,
-	alarm_tag,
-	ACPI_BATTERY_NUMFILES,
-};
 
 struct acpi_battery {
 	struct mutex lock;
+	struct power_supply bat;
 	struct acpi_device *device;
 	unsigned long update_time;
-	int present_rate;
-	int remaining_capacity;
-	int present_voltage;
+	int current_now;
+	int capacity_now;
+	int voltage_now;
 	int design_capacity;
-	int last_full_capacity;
+	int full_charge_capacity;
 	int technology;
 	int design_voltage;
 	int design_capacity_warning;
@@ -100,15 +110,117 @@ struct acpi_battery {
 	u8 alarm_present;
 };
 
+#define to_acpi_battery(x) container_of(x, struct acpi_battery, bat);
+
 inline int acpi_battery_present(struct acpi_battery *battery)
 {
 	return battery->device->status.battery_present;
 }
 
+static int acpi_battery_technology(struct acpi_battery *battery)
+{
+	if (!strcasecmp("NiCd", battery->type))
+		return POWER_SUPPLY_TECHNOLOGY_NiCd;
+	if (!strcasecmp("NiMH", battery->type))
+		return POWER_SUPPLY_TECHNOLOGY_NiMH;
+	if (!strcasecmp("LION", battery->type))
+		return POWER_SUPPLY_TECHNOLOGY_LION;
+	if (!strcasecmp("LiP", battery->type))
+		return POWER_SUPPLY_TECHNOLOGY_LIPO;
+	return POWER_SUPPLY_TECHNOLOGY_UNKNOWN;
+}
+
+static int acpi_battery_get_property(struct power_supply *psy,
+				     enum power_supply_property psp,
+				     union power_supply_propval *val)
+{
+	struct acpi_battery *battery = to_acpi_battery(psy);
+
+	if ((!acpi_battery_present(battery)) &&
+	     psp != POWER_SUPPLY_PROP_PRESENT)
+		return -ENODEV;
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if (battery->state & 0x01)
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		else if (battery->state & 0x02)
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else if (battery->state == 0)
+			val->intval = POWER_SUPPLY_STATUS_FULL;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = acpi_battery_present(battery);
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = acpi_battery_technology(battery);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+		val->intval = battery->design_voltage * 1000;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = battery->voltage_now * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = battery->current_now * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		val->intval = battery->design_capacity * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+	case POWER_SUPPLY_PROP_ENERGY_FULL:
+		val->intval = battery->full_charge_capacity * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		val->intval = battery->capacity_now * 1000;
+		break;
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = battery->model_number;
+		break;
+	case POWER_SUPPLY_PROP_MANUFACTURER:
+		val->strval = battery->oem_info;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static enum power_supply_property charge_battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_MANUFACTURER,
+};
+
+static enum power_supply_property energy_battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
+	POWER_SUPPLY_PROP_ENERGY_FULL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_MANUFACTURER,
+};
+
+#ifdef CONFIG_ACPI_PROCFS
 inline char *acpi_battery_units(struct acpi_battery *battery)
 {
 	return (battery->power_unit)?"mA":"mW";
 }
+#endif
 
 /* --------------------------------------------------------------------------
                                Battery Management
@@ -120,15 +232,15 @@ struct acpi_offsets {
 
 static struct acpi_offsets state_offsets[] = {
 	{offsetof(struct acpi_battery, state), 0},
-	{offsetof(struct acpi_battery, present_rate), 0},
-	{offsetof(struct acpi_battery, remaining_capacity), 0},
-	{offsetof(struct acpi_battery, present_voltage), 0},
+	{offsetof(struct acpi_battery, current_now), 0},
+	{offsetof(struct acpi_battery, capacity_now), 0},
+	{offsetof(struct acpi_battery, voltage_now), 0},
 };
 
 static struct acpi_offsets info_offsets[] = {
 	{offsetof(struct acpi_battery, power_unit), 0},
 	{offsetof(struct acpi_battery, design_capacity), 0},
-	{offsetof(struct acpi_battery, last_full_capacity), 0},
+	{offsetof(struct acpi_battery, full_charge_capacity), 0},
 	{offsetof(struct acpi_battery, technology), 0},
 	{offsetof(struct acpi_battery, design_voltage), 0},
 	{offsetof(struct acpi_battery, design_capacity_warning), 0},
@@ -285,6 +397,15 @@ static int acpi_battery_update(struct acpi_battery *battery)
 		result = acpi_battery_get_info(battery);
 		if (result)
 			return result;
+		if (battery->power_unit) {
+			battery->bat.properties = charge_battery_props;
+			battery->bat.num_properties =
+				ARRAY_SIZE(charge_battery_props);
+		} else {
+			battery->bat.properties = energy_battery_props;
+			battery->bat.num_properties =
+				ARRAY_SIZE(energy_battery_props);
+		}
 		acpi_battery_init_alarm(battery);
 	}
 	return acpi_battery_get_state(battery);
@@ -294,6 +415,7 @@ static int acpi_battery_update(struct acpi_battery *battery)
                               FS Interface (/proc)
    -------------------------------------------------------------------------- */
 
+#ifdef CONFIG_ACPI_PROCFS
 static struct proc_dir_entry *acpi_battery_dir;
 
 static int acpi_battery_print_info(struct seq_file *seq, int result)
@@ -314,11 +436,11 @@ static int acpi_battery_print_info(struct seq_file *seq, int result)
 			   battery->design_capacity,
 			   acpi_battery_units(battery));
 
-	if (battery->last_full_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+	if (battery->full_charge_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "last full capacity:      unknown\n");
 	else
 		seq_printf(seq, "last full capacity:      %d %sh\n",
-			   battery->last_full_capacity,
+			   battery->full_charge_capacity,
 			   acpi_battery_units(battery));
 
 	seq_printf(seq, "battery technology:      %srechargeable\n",
@@ -375,22 +497,22 @@ static int acpi_battery_print_state(struct seq_file *seq, int result)
 	else
 		seq_printf(seq, "charging state:          charged\n");
 
-	if (battery->present_rate == ACPI_BATTERY_VALUE_UNKNOWN)
+	if (battery->current_now == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "present rate:            unknown\n");
 	else
 		seq_printf(seq, "present rate:            %d %s\n",
-			   battery->present_rate, acpi_battery_units(battery));
+			   battery->current_now, acpi_battery_units(battery));
 
-	if (battery->remaining_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+	if (battery->capacity_now == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "remaining capacity:      unknown\n");
 	else
 		seq_printf(seq, "remaining capacity:      %d %sh\n",
-			   battery->remaining_capacity, acpi_battery_units(battery));
-	if (battery->present_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
+			   battery->capacity_now, acpi_battery_units(battery));
+	if (battery->voltage_now == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "present voltage:         unknown\n");
 	else
 		seq_printf(seq, "present voltage:         %d mV\n",
-			   battery->present_voltage);
+			   battery->voltage_now);
       end:
 	if (result)
 		seq_printf(seq, "ERROR: Unable to read battery state\n");
@@ -564,6 +686,7 @@ static void acpi_battery_remove_fs(struct acpi_device *device)
 	acpi_device_dir(device) = NULL;
 }
 
+#endif
 /* --------------------------------------------------------------------------
                                  Driver Interface
    -------------------------------------------------------------------------- */
@@ -581,6 +704,7 @@ static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 	acpi_bus_generate_netlink_event(device->pnp.device_class,
 					device->dev.bus_id, event,
 					acpi_battery_present(battery));
+	kobject_uevent(&battery->bat.dev->kobj, KOBJ_CHANGE);
 }
 
 static int acpi_battery_add(struct acpi_device *device)
@@ -599,9 +723,15 @@ static int acpi_battery_add(struct acpi_device *device)
 	acpi_driver_data(device) = battery;
 	mutex_init(&battery->lock);
 	acpi_battery_update(battery);
+#ifdef CONFIG_ACPI_PROCFS
 	result = acpi_battery_add_fs(device);
 	if (result)
 		goto end;
+#endif
+	battery->bat.name = acpi_device_bid(device);
+	battery->bat.type = POWER_SUPPLY_TYPE_BATTERY;
+	battery->bat.get_property = acpi_battery_get_property;
+	result = power_supply_register(&battery->device->dev, &battery->bat);
 	status = acpi_install_notify_handler(device->handle,
 					     ACPI_ALL_NOTIFY,
 					     acpi_battery_notify, battery);
@@ -615,7 +745,9 @@ static int acpi_battery_add(struct acpi_device *device)
 	       device->status.battery_present ? "present" : "absent");
       end:
 	if (result) {
+#ifdef CONFIG_ACPI_PROCFS
 		acpi_battery_remove_fs(device);
+#endif
 		kfree(battery);
 	}
 	return result;
@@ -632,7 +764,11 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 	status = acpi_remove_notify_handler(device->handle,
 					    ACPI_ALL_NOTIFY,
 					    acpi_battery_notify);
+#ifdef CONFIG_ACPI_PROCFS
 	acpi_battery_remove_fs(device);
+#endif
+	if (battery->bat.dev)
+		power_supply_unregister(&battery->bat);
 	mutex_destroy(&battery->lock);
 	kfree(battery);
 	return 0;
@@ -664,11 +800,15 @@ static int __init acpi_battery_init(void)
 {
 	if (acpi_disabled)
 		return -ENODEV;
+#ifdef CONFIG_ACPI_PROCFS
 	acpi_battery_dir = acpi_lock_battery_dir();
 	if (!acpi_battery_dir)
 		return -ENODEV;
+#endif
 	if (acpi_bus_register_driver(&acpi_battery_driver) < 0) {
+#ifdef CONFIG_ACPI_PROCFS
 		acpi_unlock_battery_dir(acpi_battery_dir);
+#endif
 		return -ENODEV;
 	}
 	return 0;
@@ -677,7 +817,9 @@ static int __init acpi_battery_init(void)
 static void __exit acpi_battery_exit(void)
 {
 	acpi_bus_unregister_driver(&acpi_battery_driver);
+#ifdef CONFIG_ACPI_PROCFS
 	acpi_unlock_battery_dir(acpi_battery_dir);
+#endif
 }
 
 module_init(acpi_battery_init);

commit aa650bbdcb94bde4292eabc44490970825c98669
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Wed Sep 26 19:42:58 2007 +0400

    ACPI: Battery: Misc clean-ups, no functional changes
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index faa70a50b807..db725bfe5840 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -1,6 +1,8 @@
 /*
- *  acpi_battery.c - ACPI Battery Driver ($Revision: 37 $)
+ *  battery.c - ACPI Battery Driver (Revision: 2.0)
  *
+ *  Copyright (C) 2007 Alexey Starikovskiy <astarikovskiy@suse.de>
+ *  Copyright (C) 2004-2007 Vladimir Lebedev <vladimir.p.lebedev@intel.com>
  *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
  *
@@ -48,6 +50,7 @@
 ACPI_MODULE_NAME("battery");
 
 MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_AUTHOR("Alexey Starikovskiy <astarikovskiy@suse.de>");
 MODULE_DESCRIPTION("ACPI Battery Driver");
 MODULE_LICENSE("GPL");
 
@@ -58,31 +61,17 @@ MODULE_PARM_DESC(cache_time, "cache time in milliseconds");
 extern struct proc_dir_entry *acpi_lock_battery_dir(void);
 extern void *acpi_unlock_battery_dir(struct proc_dir_entry *acpi_battery_dir);
 
-static int acpi_battery_add(struct acpi_device *device);
-static int acpi_battery_remove(struct acpi_device *device, int type);
-static int acpi_battery_resume(struct acpi_device *device);
-
 static const struct acpi_device_id battery_device_ids[] = {
 	{"PNP0C0A", 0},
 	{"", 0},
 };
-MODULE_DEVICE_TABLE(acpi, battery_device_ids);
 
-static struct acpi_driver acpi_battery_driver = {
-	.name = "battery",
-	.class = ACPI_BATTERY_CLASS,
-	.ids = battery_device_ids,
-	.ops = {
-		.add = acpi_battery_add,
-		.resume = acpi_battery_resume,
-		.remove = acpi_battery_remove,
-		},
-};
+MODULE_DEVICE_TABLE(acpi, battery_device_ids);
 
 enum acpi_battery_files {
-	ACPI_BATTERY_INFO = 0,
-	ACPI_BATTERY_STATE,
-	ACPI_BATTERY_ALARM,
+	info_tag = 0,
+	state_tag,
+	alarm_tag,
 	ACPI_BATTERY_NUMFILES,
 };
 
@@ -124,7 +113,6 @@ inline char *acpi_battery_units(struct acpi_battery *battery)
 /* --------------------------------------------------------------------------
                                Battery Management
    -------------------------------------------------------------------------- */
-
 struct acpi_offsets {
 	size_t offset;		/* offset inside struct acpi_sbs_battery */
 	u8 mode;		/* int or string? */
@@ -183,19 +171,16 @@ static int extract_package(struct acpi_battery *battery,
 
 static int acpi_battery_get_status(struct acpi_battery *battery)
 {
-	int result = 0;
-
-	result = acpi_bus_get_status(battery->device);
-	if (result) {
+	if (acpi_bus_get_status(battery->device)) {
 		ACPI_EXCEPTION((AE_INFO, AE_ERROR, "Evaluating _STA"));
 		return -ENODEV;
 	}
-	return result;
+	return 0;
 }
 
 static int acpi_battery_get_info(struct acpi_battery *battery)
 {
-	int result = 0;
+	int result = -EFAULT;
 	acpi_status status = 0;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 
@@ -205,10 +190,12 @@ static int acpi_battery_get_info(struct acpi_battery *battery)
 	status = acpi_evaluate_object(battery->device->handle, "_BIF",
 				      NULL, &buffer);
 	mutex_unlock(&battery->lock);
+
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BIF"));
 		return -ENODEV;
 	}
+
 	result = extract_package(battery, buffer.pointer,
 				 info_offsets, ARRAY_SIZE(info_offsets));
 	kfree(buffer.pointer);
@@ -238,6 +225,7 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BST"));
 		return -ENODEV;
 	}
+
 	result = extract_package(battery, buffer.pointer,
 				 state_offsets, ARRAY_SIZE(state_offsets));
 	battery->update_time = jiffies;
@@ -245,37 +233,26 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 	return result;
 }
 
-static int acpi_battery_get_alarm(struct acpi_battery *battery)
-{
-	return 0;
-}
-
-static int acpi_battery_set_alarm(struct acpi_battery *battery,
-				  unsigned long alarm)
+static int acpi_battery_set_alarm(struct acpi_battery *battery)
 {
 	acpi_status status = 0;
-	union acpi_object arg0 = { ACPI_TYPE_INTEGER };
+	union acpi_object arg0 = { .type = ACPI_TYPE_INTEGER };
 	struct acpi_object_list arg_list = { 1, &arg0 };
 
-	if (!acpi_battery_present(battery))
-		return -ENODEV;
-
-	if (!battery->alarm_present)
+	if (!acpi_battery_present(battery)|| !battery->alarm_present)
 		return -ENODEV;
 
-	arg0.integer.value = alarm;
+	arg0.integer.value = battery->alarm;
 
 	mutex_lock(&battery->lock);
 	status = acpi_evaluate_object(battery->device->handle, "_BTP",
 				 &arg_list, NULL);
 	mutex_unlock(&battery->lock);
+
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Alarm set to %d\n", (u32) alarm));
-
-	battery->alarm = alarm;
-
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Alarm set to %d\n", battery->alarm));
 	return 0;
 }
 
@@ -293,7 +270,7 @@ static int acpi_battery_init_alarm(struct acpi_battery *battery)
 	battery->alarm_present = 1;
 	if (!battery->alarm)
 		battery->alarm = battery->design_capacity_warning;
-	return acpi_battery_set_alarm(battery, battery->alarm);
+	return acpi_battery_set_alarm(battery);
 }
 
 static int acpi_battery_update(struct acpi_battery *battery)
@@ -322,130 +299,101 @@ static struct proc_dir_entry *acpi_battery_dir;
 static int acpi_battery_print_info(struct seq_file *seq, int result)
 {
 	struct acpi_battery *battery = seq->private;
-	char *units = "?";
 
 	if (result)
 		goto end;
 
-	if (acpi_battery_present(battery))
-		seq_printf(seq, "present:                 yes\n");
-	else {
-		seq_printf(seq, "present:                 no\n");
+	seq_printf(seq, "present:                 %s\n",
+		   acpi_battery_present(battery)?"yes":"no");
+	if (!acpi_battery_present(battery))
 		goto end;
-	}
-
-	/* Battery Units */
-
-	units = acpi_battery_units(battery);
-
 	if (battery->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "design capacity:         unknown\n");
 	else
 		seq_printf(seq, "design capacity:         %d %sh\n",
-			   (u32) battery->design_capacity, units);
+			   battery->design_capacity,
+			   acpi_battery_units(battery));
 
 	if (battery->last_full_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "last full capacity:      unknown\n");
 	else
 		seq_printf(seq, "last full capacity:      %d %sh\n",
-			   (u32) battery->last_full_capacity, units);
-
-	switch ((u32) battery->technology) {
-	case 0:
-		seq_printf(seq, "battery technology:      non-rechargeable\n");
-		break;
-	case 1:
-		seq_printf(seq, "battery technology:      rechargeable\n");
-		break;
-	default:
-		seq_printf(seq, "battery technology:      unknown\n");
-		break;
-	}
+			   battery->last_full_capacity,
+			   acpi_battery_units(battery));
+
+	seq_printf(seq, "battery technology:      %srechargeable\n",
+		   (!battery->technology)?"non-":"");
 
 	if (battery->design_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "design voltage:          unknown\n");
 	else
 		seq_printf(seq, "design voltage:          %d mV\n",
-			   (u32) battery->design_voltage);
+			   battery->design_voltage);
 	seq_printf(seq, "design capacity warning: %d %sh\n",
-		   (u32) battery->design_capacity_warning, units);
+		   battery->design_capacity_warning,
+		   acpi_battery_units(battery));
 	seq_printf(seq, "design capacity low:     %d %sh\n",
-		   (u32) battery->design_capacity_low, units);
+		   battery->design_capacity_low,
+		   acpi_battery_units(battery));
 	seq_printf(seq, "capacity granularity 1:  %d %sh\n",
-		   (u32) battery->capacity_granularity_1, units);
+		   battery->capacity_granularity_1,
+		   acpi_battery_units(battery));
 	seq_printf(seq, "capacity granularity 2:  %d %sh\n",
-		   (u32) battery->capacity_granularity_2, units);
+		   battery->capacity_granularity_2,
+		   acpi_battery_units(battery));
 	seq_printf(seq, "model number:            %s\n", battery->model_number);
 	seq_printf(seq, "serial number:           %s\n", battery->serial_number);
 	seq_printf(seq, "battery type:            %s\n", battery->type);
 	seq_printf(seq, "OEM info:                %s\n", battery->oem_info);
-
       end:
-
 	if (result)
 		seq_printf(seq, "ERROR: Unable to read battery info\n");
-
 	return result;
 }
 
 static int acpi_battery_print_state(struct seq_file *seq, int result)
 {
 	struct acpi_battery *battery = seq->private;
-	char *units = "?";
 
 	if (result)
 		goto end;
 
-	if (acpi_battery_present(battery))
-		seq_printf(seq, "present:                 yes\n");
-	else {
-		seq_printf(seq, "present:                 no\n");
+	seq_printf(seq, "present:                 %s\n",
+		   acpi_battery_present(battery)?"yes":"no");
+	if (!acpi_battery_present(battery))
 		goto end;
-	}
-
-	/* Battery Units */
-
-	units = acpi_battery_units(battery);
 
-	if (!(battery->state & 0x04))
-		seq_printf(seq, "capacity state:          ok\n");
-	else
-		seq_printf(seq, "capacity state:          critical\n");
-
-	if ((battery->state & 0x01) && (battery->state & 0x02)) {
+	seq_printf(seq, "capacity state:          %s\n",
+			(battery->state & 0x04)?"critical":"ok");
+	if ((battery->state & 0x01) && (battery->state & 0x02))
 		seq_printf(seq,
 			   "charging state:          charging/discharging\n");
-	} else if (battery->state & 0x01)
+	else if (battery->state & 0x01)
 		seq_printf(seq, "charging state:          discharging\n");
 	else if (battery->state & 0x02)
 		seq_printf(seq, "charging state:          charging\n");
-	else {
+	else
 		seq_printf(seq, "charging state:          charged\n");
-	}
 
 	if (battery->present_rate == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "present rate:            unknown\n");
 	else
 		seq_printf(seq, "present rate:            %d %s\n",
-			   (u32) battery->present_rate, units);
+			   battery->present_rate, acpi_battery_units(battery));
 
 	if (battery->remaining_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "remaining capacity:      unknown\n");
 	else
 		seq_printf(seq, "remaining capacity:      %d %sh\n",
-			   (u32) battery->remaining_capacity, units);
-
+			   battery->remaining_capacity, acpi_battery_units(battery));
 	if (battery->present_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "present voltage:         unknown\n");
 	else
 		seq_printf(seq, "present voltage:         %d mV\n",
-			   (u32) battery->present_voltage);
-
+			   battery->present_voltage);
       end:
-
-	if (result) {
+	if (result)
 		seq_printf(seq, "ERROR: Unable to read battery state\n");
-	}
 
 	return result;
 }
@@ -453,7 +401,6 @@ static int acpi_battery_print_state(struct seq_file *seq, int result)
 static int acpi_battery_print_alarm(struct seq_file *seq, int result)
 {
 	struct acpi_battery *battery = seq->private;
-	char *units = "?";
 
 	if (result)
 		goto end;
@@ -462,22 +409,15 @@ static int acpi_battery_print_alarm(struct seq_file *seq, int result)
 		seq_printf(seq, "present:                 no\n");
 		goto end;
 	}
-
-	/* Battery Units */
-
-	units = acpi_battery_units(battery);
-
 	seq_printf(seq, "alarm:                   ");
 	if (!battery->alarm)
 		seq_printf(seq, "unsupported\n");
 	else
-		seq_printf(seq, "%u %sh\n", battery->alarm, units);
-
+		seq_printf(seq, "%u %sh\n", battery->alarm,
+				acpi_battery_units(battery));
       end:
-
 	if (result)
 		seq_printf(seq, "ERROR: Unable to read battery alarm\n");
-
 	return result;
 }
 
@@ -506,7 +446,7 @@ static ssize_t acpi_battery_write_alarm(struct file *file,
 	}
 	alarm_string[count] = '\0';
 	battery->alarm = simple_strtol(alarm_string, NULL, 0);
-	result = acpi_battery_set_alarm(battery, battery->alarm);
+	result = acpi_battery_set_alarm(battery);
       end:
 	if (!result)
 		return count;
@@ -514,95 +454,76 @@ static ssize_t acpi_battery_write_alarm(struct file *file,
 }
 
 typedef int(*print_func)(struct seq_file *seq, int result);
-typedef int(*get_func)(struct acpi_battery *battery);
-
-static struct acpi_read_mux {
-	print_func print;
-	get_func get;
-} acpi_read_funcs[ACPI_BATTERY_NUMFILES] = {
-	{.get = acpi_battery_get_info, .print = acpi_battery_print_info},
-	{.get = acpi_battery_get_state, .print = acpi_battery_print_state},
-	{.get = acpi_battery_get_alarm, .print = acpi_battery_print_alarm},
+
+static print_func acpi_print_funcs[ACPI_BATTERY_NUMFILES] = {
+	acpi_battery_print_info,
+	acpi_battery_print_state,
+	acpi_battery_print_alarm,
 };
 
 static int acpi_battery_read(int fid, struct seq_file *seq)
 {
 	struct acpi_battery *battery = seq->private;
 	int result = acpi_battery_update(battery);
-	return acpi_read_funcs[fid].print(seq, result);
-}
-
-static int acpi_battery_read_info(struct seq_file *seq, void *offset)
-{
-	return acpi_battery_read(ACPI_BATTERY_INFO, seq);
-}
-
-static int acpi_battery_read_state(struct seq_file *seq, void *offset)
-{
-	return acpi_battery_read(ACPI_BATTERY_STATE, seq);
-}
-
-static int acpi_battery_read_alarm(struct seq_file *seq, void *offset)
-{
-	return acpi_battery_read(ACPI_BATTERY_ALARM, seq);
+	return acpi_print_funcs[fid](seq, result);
 }
 
-static int acpi_battery_info_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_battery_read_info, PDE(inode)->data);
+#define DECLARE_FILE_FUNCTIONS(_name) \
+static int acpi_battery_read_##_name(struct seq_file *seq, void *offset) \
+{ \
+	return acpi_battery_read(_name##_tag, seq); \
+} \
+static int acpi_battery_##_name##_open_fs(struct inode *inode, struct file *file) \
+{ \
+	return single_open(file, acpi_battery_read_##_name, PDE(inode)->data); \
 }
 
-static int acpi_battery_state_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_battery_read_state, PDE(inode)->data);
-}
+DECLARE_FILE_FUNCTIONS(info);
+DECLARE_FILE_FUNCTIONS(state);
+DECLARE_FILE_FUNCTIONS(alarm);
+
+#undef DECLARE_FILE_FUNCTIONS
+
+#define FILE_DESCRIPTION_RO(_name) \
+	{ \
+	.name = __stringify(_name), \
+	.mode = S_IRUGO, \
+	.ops = { \
+		.open = acpi_battery_##_name##_open_fs, \
+		.read = seq_read, \
+		.llseek = seq_lseek, \
+		.release = single_release, \
+		.owner = THIS_MODULE, \
+		}, \
+	}
 
-static int acpi_battery_alarm_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_battery_read_alarm, PDE(inode)->data);
-}
+#define FILE_DESCRIPTION_RW(_name) \
+	{ \
+	.name = __stringify(_name), \
+	.mode = S_IFREG | S_IRUGO | S_IWUSR, \
+	.ops = { \
+		.open = acpi_battery_##_name##_open_fs, \
+		.read = seq_read, \
+		.llseek = seq_lseek, \
+		.write = acpi_battery_write_##_name, \
+		.release = single_release, \
+		.owner = THIS_MODULE, \
+		}, \
+	}
 
 static struct battery_file {
 	struct file_operations ops;
 	mode_t mode;
 	char *name;
 } acpi_battery_file[] = {
-	{
-	.name = "info",
-	.mode = S_IRUGO,
-	.ops = {
-	.open = acpi_battery_info_open_fs,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-	.owner = THIS_MODULE,
-	},
-	},
-	{
-	.name = "state",
-	.mode = S_IRUGO,
-	.ops = {
-	.open = acpi_battery_state_open_fs,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-	.owner = THIS_MODULE,
-	},
-	},
-	{
-	.name = "alarm",
-	.mode = S_IFREG | S_IRUGO | S_IWUSR,
-	.ops = {
-	.open = acpi_battery_alarm_open_fs,
-	.read = seq_read,
-	.write = acpi_battery_write_alarm,
-	.llseek = seq_lseek,
-	.release = single_release,
-	.owner = THIS_MODULE,
-	},
-	},
+	FILE_DESCRIPTION_RO(info),
+	FILE_DESCRIPTION_RO(state),
+	FILE_DESCRIPTION_RW(alarm),
 };
 
+#undef FILE_DESCRIPTION_RO
+#undef FILE_DESCRIPTION_RW
+
 static int acpi_battery_add_fs(struct acpi_device *device)
 {
 	struct proc_dir_entry *entry = NULL;
@@ -627,23 +548,20 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 			entry->owner = THIS_MODULE;
 		}
 	}
-
 	return 0;
 }
 
-static int acpi_battery_remove_fs(struct acpi_device *device)
+static void acpi_battery_remove_fs(struct acpi_device *device)
 {
 	int i;
-	if (acpi_device_dir(device)) {
-		for (i = 0; i < ACPI_BATTERY_NUMFILES; ++i) {
-			remove_proc_entry(acpi_battery_file[i].name,
+	if (!acpi_device_dir(device))
+		return;
+	for (i = 0; i < ACPI_BATTERY_NUMFILES; ++i)
+		remove_proc_entry(acpi_battery_file[i].name,
 				  acpi_device_dir(device));
-		}
-		remove_proc_entry(acpi_device_bid(device), acpi_battery_dir);
-		acpi_device_dir(device) = NULL;
-	}
 
-	return 0;
+	remove_proc_entry(acpi_device_bid(device), acpi_battery_dir);
+	acpi_device_dir(device) = NULL;
 }
 
 /* --------------------------------------------------------------------------
@@ -670,14 +588,11 @@ static int acpi_battery_add(struct acpi_device *device)
 	int result = 0;
 	acpi_status status = 0;
 	struct acpi_battery *battery = NULL;
-
 	if (!device)
 		return -EINVAL;
-
 	battery = kzalloc(sizeof(struct acpi_battery), GFP_KERNEL);
 	if (!battery)
 		return -ENOMEM;
-
 	battery->device = device;
 	strcpy(acpi_device_name(device), ACPI_BATTERY_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_BATTERY_CLASS);
@@ -687,7 +602,6 @@ static int acpi_battery_add(struct acpi_device *device)
 	result = acpi_battery_add_fs(device);
 	if (result)
 		goto end;
-
 	status = acpi_install_notify_handler(device->handle,
 					     ACPI_ALL_NOTIFY,
 					     acpi_battery_notify, battery);
@@ -696,18 +610,14 @@ static int acpi_battery_add(struct acpi_device *device)
 		result = -ENODEV;
 		goto end;
 	}
-
 	printk(KERN_INFO PREFIX "%s Slot [%s] (battery %s)\n",
 	       ACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),
 	       device->status.battery_present ? "present" : "absent");
-
       end:
-
 	if (result) {
 		acpi_battery_remove_fs(device);
 		kfree(battery);
 	}
-
 	return result;
 }
 
@@ -718,17 +628,13 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
-
 	battery = acpi_driver_data(device);
-
 	status = acpi_remove_notify_handler(device->handle,
 					    ACPI_ALL_NOTIFY,
 					    acpi_battery_notify);
-
 	acpi_battery_remove_fs(device);
 	mutex_destroy(&battery->lock);
 	kfree(battery);
-
 	return 0;
 }
 
@@ -743,33 +649,35 @@ static int acpi_battery_resume(struct acpi_device *device)
 	return 0;
 }
 
+static struct acpi_driver acpi_battery_driver = {
+	.name = "battery",
+	.class = ACPI_BATTERY_CLASS,
+	.ids = battery_device_ids,
+	.ops = {
+		.add = acpi_battery_add,
+		.resume = acpi_battery_resume,
+		.remove = acpi_battery_remove,
+		},
+};
+
 static int __init acpi_battery_init(void)
 {
-	int result;
-
 	if (acpi_disabled)
 		return -ENODEV;
-
 	acpi_battery_dir = acpi_lock_battery_dir();
 	if (!acpi_battery_dir)
 		return -ENODEV;
-
-	result = acpi_bus_register_driver(&acpi_battery_driver);
-	if (result < 0) {
+	if (acpi_bus_register_driver(&acpi_battery_driver) < 0) {
 		acpi_unlock_battery_dir(acpi_battery_dir);
 		return -ENODEV;
 	}
-
 	return 0;
 }
 
 static void __exit acpi_battery_exit(void)
 {
 	acpi_bus_unregister_driver(&acpi_battery_driver);
-
 	acpi_unlock_battery_dir(acpi_battery_dir);
-
-	return;
 }
 
 module_init(acpi_battery_init);

commit f1d4661abe05d0a2c014166042d15ed8b69ae8f2
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Wed Sep 26 19:42:52 2007 +0400

    ACPI: Battery: simplify update scheme
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index de506f39d3bd..faa70a50b807 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -27,6 +27,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/types.h>
+#include <linux/jiffies.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <asm/uaccess.h>
@@ -41,27 +42,18 @@
 #define ACPI_BATTERY_DEVICE_NAME	"Battery"
 #define ACPI_BATTERY_NOTIFY_STATUS	0x80
 #define ACPI_BATTERY_NOTIFY_INFO	0x81
-#define ACPI_BATTERY_UNITS_WATTS	"mW"
-#define ACPI_BATTERY_UNITS_AMPS		"mA"
 
 #define _COMPONENT		ACPI_BATTERY_COMPONENT
 
-#define ACPI_BATTERY_UPDATE_TIME	0
-
-#define ACPI_BATTERY_NONE_UPDATE	0
-#define ACPI_BATTERY_EASY_UPDATE	1
-#define ACPI_BATTERY_INIT_UPDATE	2
-
 ACPI_MODULE_NAME("battery");
 
 MODULE_AUTHOR("Paul Diefenbaugh");
 MODULE_DESCRIPTION("ACPI Battery Driver");
 MODULE_LICENSE("GPL");
 
-static unsigned int update_time = ACPI_BATTERY_UPDATE_TIME;
-
-/* 0 - every time, > 0 - by update_time */
-module_param(update_time, uint, 0644);
+static unsigned int cache_time = 1000;
+module_param(cache_time, uint, 0644);
+MODULE_PARM_DESC(cache_time, "cache time in milliseconds");
 
 extern struct proc_dir_entry *acpi_lock_battery_dir(void);
 extern void *acpi_unlock_battery_dir(struct proc_dir_entry *acpi_battery_dir);
@@ -95,15 +87,12 @@ enum acpi_battery_files {
 };
 
 struct acpi_battery {
-	struct acpi_device *device;
 	struct mutex lock;
-	unsigned long alarm;
-	unsigned long update_time[ACPI_BATTERY_NUMFILES];
-	int state;
+	struct acpi_device *device;
+	unsigned long update_time;
 	int present_rate;
 	int remaining_capacity;
 	int present_voltage;
-	int power_unit;
 	int design_capacity;
 	int last_full_capacity;
 	int technology;
@@ -112,14 +101,14 @@ struct acpi_battery {
 	int design_capacity_low;
 	int capacity_granularity_1;
 	int capacity_granularity_2;
+	int alarm;
 	char model_number[32];
 	char serial_number[32];
 	char type[32];
 	char oem_info[32];
-	u8 present_prev;
+	int state;
+	int power_unit;
 	u8 alarm_present;
-	u8 init_update;
-	u8 update[ACPI_BATTERY_NUMFILES];
 };
 
 inline int acpi_battery_present(struct acpi_battery *battery)
@@ -127,33 +116,15 @@ inline int acpi_battery_present(struct acpi_battery *battery)
 	return battery->device->status.battery_present;
 }
 
-inline char *acpi_battery_power_units(struct acpi_battery *battery)
+inline char *acpi_battery_units(struct acpi_battery *battery)
 {
-	if (battery->power_unit)
-		return ACPI_BATTERY_UNITS_AMPS;
-	else
-		return ACPI_BATTERY_UNITS_WATTS;
-}
-
-inline acpi_handle acpi_battery_handle(struct acpi_battery *battery)
-{
-	return battery->device->handle;
+	return (battery->power_unit)?"mA":"mW";
 }
 
 /* --------------------------------------------------------------------------
                                Battery Management
    -------------------------------------------------------------------------- */
 
-static void acpi_battery_check_result(struct acpi_battery *battery, int result)
-{
-	if (!battery)
-		return;
-
-	if (result) {
-		battery->init_update = 1;
-	}
-}
-
 struct acpi_offsets {
 	size_t offset;		/* offset inside struct acpi_sbs_battery */
 	u8 mode;		/* int or string? */
@@ -228,11 +199,10 @@ static int acpi_battery_get_info(struct acpi_battery *battery)
 	acpi_status status = 0;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 
-	battery->update_time[ACPI_BATTERY_INFO] = get_seconds();
 	if (!acpi_battery_present(battery))
 		return 0;
 	mutex_lock(&battery->lock);
-	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BIF",
+	status = acpi_evaluate_object(battery->device->handle, "_BIF",
 				      NULL, &buffer);
 	mutex_unlock(&battery->lock);
 	if (ACPI_FAILURE(status)) {
@@ -251,13 +221,16 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 	acpi_status status = 0;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 
-	battery->update_time[ACPI_BATTERY_STATE] = get_seconds();
-
 	if (!acpi_battery_present(battery))
 		return 0;
 
+	if (battery->update_time &&
+	    time_before(jiffies, battery->update_time +
+			msecs_to_jiffies(cache_time)))
+		return 0;
+
 	mutex_lock(&battery->lock);
-	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BST",
+	status = acpi_evaluate_object(battery->device->handle, "_BST",
 				      NULL, &buffer);
 	mutex_unlock(&battery->lock);
 
@@ -267,14 +240,13 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 	}
 	result = extract_package(battery, buffer.pointer,
 				 state_offsets, ARRAY_SIZE(state_offsets));
+	battery->update_time = jiffies;
 	kfree(buffer.pointer);
 	return result;
 }
 
 static int acpi_battery_get_alarm(struct acpi_battery *battery)
 {
-	battery->update_time[ACPI_BATTERY_ALARM] = get_seconds();
-
 	return 0;
 }
 
@@ -285,8 +257,6 @@ static int acpi_battery_set_alarm(struct acpi_battery *battery,
 	union acpi_object arg0 = { ACPI_TYPE_INTEGER };
 	struct acpi_object_list arg_list = { 1, &arg0 };
 
-	battery->update_time[ACPI_BATTERY_ALARM] = get_seconds();
-
 	if (!acpi_battery_present(battery))
 		return -ENODEV;
 
@@ -296,8 +266,8 @@ static int acpi_battery_set_alarm(struct acpi_battery *battery,
 	arg0.integer.value = alarm;
 
 	mutex_lock(&battery->lock);
-	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BTP",
-				      &arg_list, NULL);
+	status = acpi_evaluate_object(battery->device->handle, "_BTP",
+				 &arg_list, NULL);
 	mutex_unlock(&battery->lock);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
@@ -311,112 +281,36 @@ static int acpi_battery_set_alarm(struct acpi_battery *battery,
 
 static int acpi_battery_init_alarm(struct acpi_battery *battery)
 {
-	int result = 0;
 	acpi_status status = AE_OK;
 	acpi_handle handle = NULL;
-	unsigned long alarm = battery->alarm;
 
 	/* See if alarms are supported, and if so, set default */
-
-	status = acpi_get_handle(acpi_battery_handle(battery), "_BTP", &handle);
-	if (ACPI_SUCCESS(status)) {
-		battery->alarm_present = 1;
-		if (!alarm) {
-			alarm = battery->design_capacity_warning;
-		}
-		result = acpi_battery_set_alarm(battery, alarm);
-		if (result)
-			goto end;
-	} else {
+	status = acpi_get_handle(battery->device->handle, "_BTP", &handle);
+	if (ACPI_FAILURE(status)) {
 		battery->alarm_present = 0;
+		return 0;
 	}
-
-      end:
-
-	return result;
+	battery->alarm_present = 1;
+	if (!battery->alarm)
+		battery->alarm = battery->design_capacity_warning;
+	return acpi_battery_set_alarm(battery, battery->alarm);
 }
 
-static int acpi_battery_init_update(struct acpi_battery *battery)
+static int acpi_battery_update(struct acpi_battery *battery)
 {
-	int result = 0;
-
-	result = acpi_battery_get_status(battery);
-	if (result)
+	int saved_present = acpi_battery_present(battery);
+	int result = acpi_battery_get_status(battery);
+	if (result || !acpi_battery_present(battery))
 		return result;
-
-	battery->present_prev = acpi_battery_present(battery);
-
-	if (acpi_battery_present(battery)) {
+	if (saved_present != acpi_battery_present(battery) ||
+	    !battery->update_time) {
+		battery->update_time = 0;
 		result = acpi_battery_get_info(battery);
 		if (result)
 			return result;
-		result = acpi_battery_get_state(battery);
-		if (result)
-			return result;
-
 		acpi_battery_init_alarm(battery);
 	}
-
-	return result;
-}
-
-static int acpi_battery_update(struct acpi_battery *battery,
-			       int update, int *update_result_ptr)
-{
-	int result = 0;
-	int update_result = ACPI_BATTERY_NONE_UPDATE;
-
-	if (!acpi_battery_present(battery)) {
-		update = 1;
-	}
-
-	if (battery->init_update) {
-		result = acpi_battery_init_update(battery);
-		if (result)
-			goto end;
-		update_result = ACPI_BATTERY_INIT_UPDATE;
-	} else if (update) {
-		result = acpi_battery_get_status(battery);
-		if (result)
-			goto end;
-		if ((!battery->present_prev & acpi_battery_present(battery))
-		    || (battery->present_prev & !acpi_battery_present(battery))) {
-			result = acpi_battery_init_update(battery);
-			if (result)
-				goto end;
-			update_result = ACPI_BATTERY_INIT_UPDATE;
-		} else {
-			update_result = ACPI_BATTERY_EASY_UPDATE;
-		}
-	}
-
-      end:
-
-	battery->init_update = (result != 0);
-
-	*update_result_ptr = update_result;
-
-	return result;
-}
-
-static void acpi_battery_notify_update(struct acpi_battery *battery)
-{
-	acpi_battery_get_status(battery);
-
-	if (battery->init_update) {
-		return;
-	}
-
-	if ((!battery->present_prev &
-	     acpi_battery_present(battery)) ||
-	    (battery->present_prev &
-	     !acpi_battery_present(battery))) {
-		battery->init_update = 1;
-	} else {
-		battery->update[ACPI_BATTERY_INFO] = 1;
-		battery->update[ACPI_BATTERY_STATE] = 1;
-		battery->update[ACPI_BATTERY_ALARM] = 1;
-	}
+	return acpi_battery_get_state(battery);
 }
 
 /* --------------------------------------------------------------------------
@@ -442,7 +336,7 @@ static int acpi_battery_print_info(struct seq_file *seq, int result)
 
 	/* Battery Units */
 
-	units = acpi_battery_power_units(battery);
+	units = acpi_battery_units(battery);
 
 	if (battery->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "design capacity:         unknown\n");
@@ -511,7 +405,7 @@ static int acpi_battery_print_state(struct seq_file *seq, int result)
 
 	/* Battery Units */
 
-	units = acpi_battery_power_units(battery);
+	units = acpi_battery_units(battery);
 
 	if (!(battery->state & 0x04))
 		seq_printf(seq, "capacity state:          ok\n");
@@ -571,13 +465,13 @@ static int acpi_battery_print_alarm(struct seq_file *seq, int result)
 
 	/* Battery Units */
 
-	units = acpi_battery_power_units(battery);
+	units = acpi_battery_units(battery);
 
 	seq_printf(seq, "alarm:                   ");
 	if (!battery->alarm)
 		seq_printf(seq, "unsupported\n");
 	else
-		seq_printf(seq, "%lu %sh\n", battery->alarm, units);
+		seq_printf(seq, "%u %sh\n", battery->alarm, units);
 
       end:
 
@@ -587,49 +481,35 @@ static int acpi_battery_print_alarm(struct seq_file *seq, int result)
 	return result;
 }
 
-static ssize_t
-acpi_battery_write_alarm(struct file *file,
-			 const char __user * buffer,
-			 size_t count, loff_t * ppos)
+static ssize_t acpi_battery_write_alarm(struct file *file,
+					const char __user * buffer,
+					size_t count, loff_t * ppos)
 {
 	int result = 0;
 	char alarm_string[12] = { '\0' };
 	struct seq_file *m = file->private_data;
 	struct acpi_battery *battery = m->private;
-	int update_result = ACPI_BATTERY_NONE_UPDATE;
 
 	if (!battery || (count > sizeof(alarm_string) - 1))
 		return -EINVAL;
-
-	result = acpi_battery_update(battery, 1, &update_result);
 	if (result) {
 		result = -ENODEV;
 		goto end;
 	}
-
 	if (!acpi_battery_present(battery)) {
 		result = -ENODEV;
 		goto end;
 	}
-
 	if (copy_from_user(alarm_string, buffer, count)) {
 		result = -EFAULT;
 		goto end;
 	}
-
 	alarm_string[count] = '\0';
-
-	result = acpi_battery_set_alarm(battery,
-					simple_strtoul(alarm_string, NULL, 0));
-	if (result)
-		goto end;
-
+	battery->alarm = simple_strtol(alarm_string, NULL, 0);
+	result = acpi_battery_set_alarm(battery, battery->alarm);
       end:
-
-	acpi_battery_check_result(battery, result);
-
 	if (!result)
-		result = count;
+		return count;
 	return result;
 }
 
@@ -648,28 +528,8 @@ static struct acpi_read_mux {
 static int acpi_battery_read(int fid, struct seq_file *seq)
 {
 	struct acpi_battery *battery = seq->private;
-	int result = 0;
-	int update_result = ACPI_BATTERY_NONE_UPDATE;
-	int update = 0;
-
-	update = (get_seconds() - battery->update_time[fid] >= update_time);
-	update = (update | battery->update[fid]);
-
-	result = acpi_battery_update(battery, update, &update_result);
-	if (result)
-		goto end;
-
-	if (update_result == ACPI_BATTERY_EASY_UPDATE) {
-		result = acpi_read_funcs[fid].get(battery);
-		if (result)
-			goto end;
-	}
-
-      end:
-	result = acpi_read_funcs[fid].print(seq, result);
-	acpi_battery_check_result(battery, result);
-	battery->update[fid] = result;
-	return result;
+	int result = acpi_battery_update(battery);
+	return acpi_read_funcs[fid].print(seq, result);
 }
 
 static int acpi_battery_read_info(struct seq_file *seq, void *offset)
@@ -793,33 +653,16 @@ static int acpi_battery_remove_fs(struct acpi_device *device)
 static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 {
 	struct acpi_battery *battery = data;
-	struct acpi_device *device = NULL;
-
+	struct acpi_device *device;
 	if (!battery)
 		return;
-
 	device = battery->device;
-
-	switch (event) {
-	case ACPI_BATTERY_NOTIFY_STATUS:
-	case ACPI_BATTERY_NOTIFY_INFO:
-	case ACPI_NOTIFY_BUS_CHECK:
-	case ACPI_NOTIFY_DEVICE_CHECK:
-		device = battery->device;
-		acpi_battery_notify_update(battery);
-		acpi_bus_generate_proc_event(device, event,
+	acpi_battery_update(battery);
+	acpi_bus_generate_proc_event(device, event,
+				     acpi_battery_present(battery));
+	acpi_bus_generate_netlink_event(device->pnp.device_class,
+					device->dev.bus_id, event,
 					acpi_battery_present(battery));
-		acpi_bus_generate_netlink_event(device->pnp.device_class,
-						  device->dev.bus_id, event,
-						  acpi_battery_present(battery));
-		break;
-	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Unsupported event [0x%x]\n", event));
-		break;
-	}
-
-	return;
 }
 
 static int acpi_battery_add(struct acpi_device *device)
@@ -840,12 +683,7 @@ static int acpi_battery_add(struct acpi_device *device)
 	strcpy(acpi_device_class(device), ACPI_BATTERY_CLASS);
 	acpi_driver_data(device) = battery;
 	mutex_init(&battery->lock);
-	result = acpi_battery_get_status(battery);
-	if (result)
-		goto end;
-
-	battery->init_update = 1;
-
+	acpi_battery_update(battery);
 	result = acpi_battery_add_fs(device);
 	if (result)
 		goto end;
@@ -898,14 +736,10 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 static int acpi_battery_resume(struct acpi_device *device)
 {
 	struct acpi_battery *battery;
-
 	if (!device)
 		return -EINVAL;
-
-	battery = device->driver_data;
-
-	battery->init_update = 1;
-
+	battery = acpi_driver_data(device);
+	battery->update_time = 0;
 	return 0;
 }
 

commit 038fdea2960be53f82353fd409526fb77a558c52
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Wed Sep 26 19:42:46 2007 +0400

    ACPI: Battery: don't use acpi_extract_package()
    
    acpi_extract_package() creates more problems with memory management than
    it solves as helper for package handling.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 9b2c0f74f869..de506f39d3bd 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -36,9 +36,6 @@
 
 #define ACPI_BATTERY_VALUE_UNKNOWN 0xFFFFFFFF
 
-#define ACPI_BATTERY_FORMAT_BIF	"NNNNNNNNNSSSS"
-#define ACPI_BATTERY_FORMAT_BST	"NNNN"
-
 #define ACPI_BATTERY_COMPONENT		0x00040000
 #define ACPI_BATTERY_CLASS		"battery"
 #define ACPI_BATTERY_DEVICE_NAME	"Battery"
@@ -90,61 +87,49 @@ static struct acpi_driver acpi_battery_driver = {
 		},
 };
 
-struct acpi_battery_state {
-	acpi_integer state;
-	acpi_integer present_rate;
-	acpi_integer remaining_capacity;
-	acpi_integer present_voltage;
-};
-
-struct acpi_battery_info {
-	acpi_integer power_unit;
-	acpi_integer design_capacity;
-	acpi_integer last_full_capacity;
-	acpi_integer battery_technology;
-	acpi_integer design_voltage;
-	acpi_integer design_capacity_warning;
-	acpi_integer design_capacity_low;
-	acpi_integer battery_capacity_granularity_1;
-	acpi_integer battery_capacity_granularity_2;
-	acpi_string model_number;
-	acpi_string serial_number;
-	acpi_string battery_type;
-	acpi_string oem_info;
-};
-
-enum acpi_battery_files{
+enum acpi_battery_files {
 	ACPI_BATTERY_INFO = 0,
 	ACPI_BATTERY_STATE,
 	ACPI_BATTERY_ALARM,
 	ACPI_BATTERY_NUMFILES,
 };
 
-struct acpi_battery_flags {
-	u8 battery_present_prev;
-	u8 alarm_present;
-	u8 init_update;
-	u8 update[ACPI_BATTERY_NUMFILES];
-	u8 power_unit;
-};
-
 struct acpi_battery {
-	struct mutex mutex;
 	struct acpi_device *device;
-	struct acpi_battery_flags flags;
-	struct acpi_buffer bif_data;
-	struct acpi_buffer bst_data;
+	struct mutex lock;
 	unsigned long alarm;
 	unsigned long update_time[ACPI_BATTERY_NUMFILES];
+	int state;
+	int present_rate;
+	int remaining_capacity;
+	int present_voltage;
+	int power_unit;
+	int design_capacity;
+	int last_full_capacity;
+	int technology;
+	int design_voltage;
+	int design_capacity_warning;
+	int design_capacity_low;
+	int capacity_granularity_1;
+	int capacity_granularity_2;
+	char model_number[32];
+	char serial_number[32];
+	char type[32];
+	char oem_info[32];
+	u8 present_prev;
+	u8 alarm_present;
+	u8 init_update;
+	u8 update[ACPI_BATTERY_NUMFILES];
 };
 
 inline int acpi_battery_present(struct acpi_battery *battery)
 {
 	return battery->device->status.battery_present;
 }
+
 inline char *acpi_battery_power_units(struct acpi_battery *battery)
 {
-	if (battery->flags.power_unit)
+	if (battery->power_unit)
 		return ACPI_BATTERY_UNITS_AMPS;
 	else
 		return ACPI_BATTERY_UNITS_WATTS;
@@ -165,43 +150,63 @@ static void acpi_battery_check_result(struct acpi_battery *battery, int result)
 		return;
 
 	if (result) {
-		battery->flags.init_update = 1;
+		battery->init_update = 1;
 	}
 }
 
-static int acpi_battery_extract_package(struct acpi_battery *battery,
-					union acpi_object *package,
-					struct acpi_buffer *format,
-					struct acpi_buffer *data,
-					char *package_name)
-{
-	acpi_status status = AE_OK;
-	struct acpi_buffer data_null = { 0, NULL };
+struct acpi_offsets {
+	size_t offset;		/* offset inside struct acpi_sbs_battery */
+	u8 mode;		/* int or string? */
+};
 
-	status = acpi_extract_package(package, format, &data_null);
-	if (status != AE_BUFFER_OVERFLOW) {
-		ACPI_EXCEPTION((AE_INFO, status, "Extracting size %s",
-				package_name));
-		return -ENODEV;
-	}
+static struct acpi_offsets state_offsets[] = {
+	{offsetof(struct acpi_battery, state), 0},
+	{offsetof(struct acpi_battery, present_rate), 0},
+	{offsetof(struct acpi_battery, remaining_capacity), 0},
+	{offsetof(struct acpi_battery, present_voltage), 0},
+};
 
-	if (data_null.length != data->length) {
-		kfree(data->pointer);
-		data->pointer = kzalloc(data_null.length, GFP_KERNEL);
-		if (!data->pointer) {
-			ACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY, "kzalloc()"));
-			return -ENOMEM;
-		}
-		data->length = data_null.length;
-	}
+static struct acpi_offsets info_offsets[] = {
+	{offsetof(struct acpi_battery, power_unit), 0},
+	{offsetof(struct acpi_battery, design_capacity), 0},
+	{offsetof(struct acpi_battery, last_full_capacity), 0},
+	{offsetof(struct acpi_battery, technology), 0},
+	{offsetof(struct acpi_battery, design_voltage), 0},
+	{offsetof(struct acpi_battery, design_capacity_warning), 0},
+	{offsetof(struct acpi_battery, design_capacity_low), 0},
+	{offsetof(struct acpi_battery, capacity_granularity_1), 0},
+	{offsetof(struct acpi_battery, capacity_granularity_2), 0},
+	{offsetof(struct acpi_battery, model_number), 1},
+	{offsetof(struct acpi_battery, serial_number), 1},
+	{offsetof(struct acpi_battery, type), 1},
+	{offsetof(struct acpi_battery, oem_info), 1},
+};
 
-	status = acpi_extract_package(package, format, data);
-	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, status, "Extracting %s",
-				package_name));
-		return -ENODEV;
+static int extract_package(struct acpi_battery *battery,
+			   union acpi_object *package,
+			   struct acpi_offsets *offsets, int num)
+{
+	int i, *x;
+	union acpi_object *element;
+	if (package->type != ACPI_TYPE_PACKAGE)
+		return -EFAULT;
+	for (i = 0; i < num; ++i) {
+		if (package->package.count <= i)
+			return -EFAULT;
+		element = &package->package.elements[i];
+		if (offsets[i].mode) {
+			if (element->type != ACPI_TYPE_STRING &&
+			    element->type != ACPI_TYPE_BUFFER)
+				return -EFAULT;
+			strncpy((u8 *)battery + offsets[i].offset,
+				element->string.pointer, 32);
+		} else {
+			if (element->type != ACPI_TYPE_INTEGER)
+				return -EFAULT;
+			x = (int *)((u8 *)battery + offsets[i].offset);
+			*x = element->integer.value;
+		}
 	}
-
 	return 0;
 }
 
@@ -222,49 +227,21 @@ static int acpi_battery_get_info(struct acpi_battery *battery)
 	int result = 0;
 	acpi_status status = 0;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
-	struct acpi_buffer format = { sizeof(ACPI_BATTERY_FORMAT_BIF),
-		ACPI_BATTERY_FORMAT_BIF
-	};
-	union acpi_object *package = NULL;
-	struct acpi_buffer *data = NULL;
-	struct acpi_battery_info *bif = NULL;
 
 	battery->update_time[ACPI_BATTERY_INFO] = get_seconds();
-
 	if (!acpi_battery_present(battery))
 		return 0;
-
-	/* Evaluate _BIF */
-
-	status =
-	    acpi_evaluate_object(acpi_battery_handle(battery), "_BIF", NULL,
-				 &buffer);
+	mutex_lock(&battery->lock);
+	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BIF",
+				      NULL, &buffer);
+	mutex_unlock(&battery->lock);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BIF"));
 		return -ENODEV;
 	}
-
-	package = buffer.pointer;
-
-	data = &battery->bif_data;
-
-	/* Extract Package Data */
-
-	result =
-	    acpi_battery_extract_package(battery, package, &format, data,
-					 "_BIF");
-	if (result)
-		goto end;
-
-      end:
-
+	result = extract_package(battery, buffer.pointer,
+				 info_offsets, ARRAY_SIZE(info_offsets));
 	kfree(buffer.pointer);
-
-	if (!result) {
-		bif = data->pointer;
-		battery->flags.power_unit = bif->power_unit;
-	}
-
 	return result;
 }
 
@@ -273,42 +250,24 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 	int result = 0;
 	acpi_status status = 0;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
-	struct acpi_buffer format = { sizeof(ACPI_BATTERY_FORMAT_BST),
-		ACPI_BATTERY_FORMAT_BST
-	};
-	union acpi_object *package = NULL;
-	struct acpi_buffer *data = NULL;
 
 	battery->update_time[ACPI_BATTERY_STATE] = get_seconds();
 
 	if (!acpi_battery_present(battery))
 		return 0;
 
-	/* Evaluate _BST */
+	mutex_lock(&battery->lock);
+	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BST",
+				      NULL, &buffer);
+	mutex_unlock(&battery->lock);
 
-	status =
-	    acpi_evaluate_object(acpi_battery_handle(battery), "_BST", NULL,
-				 &buffer);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BST"));
 		return -ENODEV;
 	}
-
-	package = buffer.pointer;
-
-	data = &battery->bst_data;
-
-	/* Extract Package Data */
-
-	result =
-	    acpi_battery_extract_package(battery, package, &format, data,
-					 "_BST");
-	if (result)
-		goto end;
-
-      end:
+	result = extract_package(battery, buffer.pointer,
+				 state_offsets, ARRAY_SIZE(state_offsets));
 	kfree(buffer.pointer);
-
 	return result;
 }
 
@@ -331,14 +290,15 @@ static int acpi_battery_set_alarm(struct acpi_battery *battery,
 	if (!acpi_battery_present(battery))
 		return -ENODEV;
 
-	if (!battery->flags.alarm_present)
+	if (!battery->alarm_present)
 		return -ENODEV;
 
 	arg0.integer.value = alarm;
 
-	status =
-	    acpi_evaluate_object(acpi_battery_handle(battery), "_BTP",
-				 &arg_list, NULL);
+	mutex_lock(&battery->lock);
+	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BTP",
+				      &arg_list, NULL);
+	mutex_unlock(&battery->lock);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
@@ -354,22 +314,21 @@ static int acpi_battery_init_alarm(struct acpi_battery *battery)
 	int result = 0;
 	acpi_status status = AE_OK;
 	acpi_handle handle = NULL;
-	struct acpi_battery_info *bif = battery->bif_data.pointer;
 	unsigned long alarm = battery->alarm;
 
 	/* See if alarms are supported, and if so, set default */
 
 	status = acpi_get_handle(acpi_battery_handle(battery), "_BTP", &handle);
 	if (ACPI_SUCCESS(status)) {
-		battery->flags.alarm_present = 1;
-		if (!alarm && bif) {
-			alarm = bif->design_capacity_warning;
+		battery->alarm_present = 1;
+		if (!alarm) {
+			alarm = battery->design_capacity_warning;
 		}
 		result = acpi_battery_set_alarm(battery, alarm);
 		if (result)
 			goto end;
 	} else {
-		battery->flags.alarm_present = 0;
+		battery->alarm_present = 0;
 	}
 
       end:
@@ -385,7 +344,7 @@ static int acpi_battery_init_update(struct acpi_battery *battery)
 	if (result)
 		return result;
 
-	battery->flags.battery_present_prev = acpi_battery_present(battery);
+	battery->present_prev = acpi_battery_present(battery);
 
 	if (acpi_battery_present(battery)) {
 		result = acpi_battery_get_info(battery);
@@ -411,7 +370,7 @@ static int acpi_battery_update(struct acpi_battery *battery,
 		update = 1;
 	}
 
-	if (battery->flags.init_update) {
+	if (battery->init_update) {
 		result = acpi_battery_init_update(battery);
 		if (result)
 			goto end;
@@ -420,8 +379,8 @@ static int acpi_battery_update(struct acpi_battery *battery,
 		result = acpi_battery_get_status(battery);
 		if (result)
 			goto end;
-		if ((!battery->flags.battery_present_prev & acpi_battery_present(battery))
-		    || (battery->flags.battery_present_prev & !acpi_battery_present(battery))) {
+		if ((!battery->present_prev & acpi_battery_present(battery))
+		    || (battery->present_prev & !acpi_battery_present(battery))) {
 			result = acpi_battery_init_update(battery);
 			if (result)
 				goto end;
@@ -433,7 +392,7 @@ static int acpi_battery_update(struct acpi_battery *battery,
 
       end:
 
-	battery->flags.init_update = (result != 0);
+	battery->init_update = (result != 0);
 
 	*update_result_ptr = update_result;
 
@@ -444,19 +403,19 @@ static void acpi_battery_notify_update(struct acpi_battery *battery)
 {
 	acpi_battery_get_status(battery);
 
-	if (battery->flags.init_update) {
+	if (battery->init_update) {
 		return;
 	}
 
-	if ((!battery->flags.battery_present_prev &
+	if ((!battery->present_prev &
 	     acpi_battery_present(battery)) ||
-	    (battery->flags.battery_present_prev &
+	    (battery->present_prev &
 	     !acpi_battery_present(battery))) {
-		battery->flags.init_update = 1;
+		battery->init_update = 1;
 	} else {
-		battery->flags.update[ACPI_BATTERY_INFO] = 1;
-		battery->flags.update[ACPI_BATTERY_STATE] = 1;
-		battery->flags.update[ACPI_BATTERY_ALARM] = 1;
+		battery->update[ACPI_BATTERY_INFO] = 1;
+		battery->update[ACPI_BATTERY_STATE] = 1;
+		battery->update[ACPI_BATTERY_ALARM] = 1;
 	}
 }
 
@@ -469,7 +428,6 @@ static struct proc_dir_entry *acpi_battery_dir;
 static int acpi_battery_print_info(struct seq_file *seq, int result)
 {
 	struct acpi_battery *battery = seq->private;
-	struct acpi_battery_info *bif = NULL;
 	char *units = "?";
 
 	if (result)
@@ -482,30 +440,23 @@ static int acpi_battery_print_info(struct seq_file *seq, int result)
 		goto end;
 	}
 
-	bif = battery->bif_data.pointer;
-	if (!bif) {
-		ACPI_EXCEPTION((AE_INFO, AE_ERROR, "BIF buffer is NULL"));
-		result = -ENODEV;
-		goto end;
-	}
-
 	/* Battery Units */
 
 	units = acpi_battery_power_units(battery);
 
-	if (bif->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+	if (battery->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "design capacity:         unknown\n");
 	else
 		seq_printf(seq, "design capacity:         %d %sh\n",
-			   (u32) bif->design_capacity, units);
+			   (u32) battery->design_capacity, units);
 
-	if (bif->last_full_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+	if (battery->last_full_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "last full capacity:      unknown\n");
 	else
 		seq_printf(seq, "last full capacity:      %d %sh\n",
-			   (u32) bif->last_full_capacity, units);
+			   (u32) battery->last_full_capacity, units);
 
-	switch ((u32) bif->battery_technology) {
+	switch ((u32) battery->technology) {
 	case 0:
 		seq_printf(seq, "battery technology:      non-rechargeable\n");
 		break;
@@ -517,23 +468,23 @@ static int acpi_battery_print_info(struct seq_file *seq, int result)
 		break;
 	}
 
-	if (bif->design_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
+	if (battery->design_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "design voltage:          unknown\n");
 	else
 		seq_printf(seq, "design voltage:          %d mV\n",
-			   (u32) bif->design_voltage);
+			   (u32) battery->design_voltage);
 	seq_printf(seq, "design capacity warning: %d %sh\n",
-		   (u32) bif->design_capacity_warning, units);
+		   (u32) battery->design_capacity_warning, units);
 	seq_printf(seq, "design capacity low:     %d %sh\n",
-		   (u32) bif->design_capacity_low, units);
+		   (u32) battery->design_capacity_low, units);
 	seq_printf(seq, "capacity granularity 1:  %d %sh\n",
-		   (u32) bif->battery_capacity_granularity_1, units);
+		   (u32) battery->capacity_granularity_1, units);
 	seq_printf(seq, "capacity granularity 2:  %d %sh\n",
-		   (u32) bif->battery_capacity_granularity_2, units);
-	seq_printf(seq, "model number:            %s\n", bif->model_number);
-	seq_printf(seq, "serial number:           %s\n", bif->serial_number);
-	seq_printf(seq, "battery type:            %s\n", bif->battery_type);
-	seq_printf(seq, "OEM info:                %s\n", bif->oem_info);
+		   (u32) battery->capacity_granularity_2, units);
+	seq_printf(seq, "model number:            %s\n", battery->model_number);
+	seq_printf(seq, "serial number:           %s\n", battery->serial_number);
+	seq_printf(seq, "battery type:            %s\n", battery->type);
+	seq_printf(seq, "OEM info:                %s\n", battery->oem_info);
 
       end:
 
@@ -546,7 +497,6 @@ static int acpi_battery_print_info(struct seq_file *seq, int result)
 static int acpi_battery_print_state(struct seq_file *seq, int result)
 {
 	struct acpi_battery *battery = seq->private;
-	struct acpi_battery_state *bst = NULL;
 	char *units = "?";
 
 	if (result)
@@ -559,50 +509,43 @@ static int acpi_battery_print_state(struct seq_file *seq, int result)
 		goto end;
 	}
 
-	bst = battery->bst_data.pointer;
-	if (!bst) {
-		ACPI_EXCEPTION((AE_INFO, AE_ERROR, "BST buffer is NULL"));
-		result = -ENODEV;
-		goto end;
-	}
-
 	/* Battery Units */
 
 	units = acpi_battery_power_units(battery);
 
-	if (!(bst->state & 0x04))
+	if (!(battery->state & 0x04))
 		seq_printf(seq, "capacity state:          ok\n");
 	else
 		seq_printf(seq, "capacity state:          critical\n");
 
-	if ((bst->state & 0x01) && (bst->state & 0x02)) {
+	if ((battery->state & 0x01) && (battery->state & 0x02)) {
 		seq_printf(seq,
 			   "charging state:          charging/discharging\n");
-	} else if (bst->state & 0x01)
+	} else if (battery->state & 0x01)
 		seq_printf(seq, "charging state:          discharging\n");
-	else if (bst->state & 0x02)
+	else if (battery->state & 0x02)
 		seq_printf(seq, "charging state:          charging\n");
 	else {
 		seq_printf(seq, "charging state:          charged\n");
 	}
 
-	if (bst->present_rate == ACPI_BATTERY_VALUE_UNKNOWN)
+	if (battery->present_rate == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "present rate:            unknown\n");
 	else
 		seq_printf(seq, "present rate:            %d %s\n",
-			   (u32) bst->present_rate, units);
+			   (u32) battery->present_rate, units);
 
-	if (bst->remaining_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+	if (battery->remaining_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "remaining capacity:      unknown\n");
 	else
 		seq_printf(seq, "remaining capacity:      %d %sh\n",
-			   (u32) bst->remaining_capacity, units);
+			   (u32) battery->remaining_capacity, units);
 
-	if (bst->present_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
+	if (battery->present_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "present voltage:         unknown\n");
 	else
 		seq_printf(seq, "present voltage:         %d mV\n",
-			   (u32) bst->present_voltage);
+			   (u32) battery->present_voltage);
 
       end:
 
@@ -658,8 +601,6 @@ acpi_battery_write_alarm(struct file *file,
 	if (!battery || (count > sizeof(alarm_string) - 1))
 		return -EINVAL;
 
-	mutex_lock(&battery->mutex);
-
 	result = acpi_battery_update(battery, 1, &update_result);
 	if (result) {
 		result = -ENODEV;
@@ -689,9 +630,6 @@ acpi_battery_write_alarm(struct file *file,
 
 	if (!result)
 		result = count;
-
-	mutex_unlock(&battery->mutex);
-
 	return result;
 }
 
@@ -714,10 +652,8 @@ static int acpi_battery_read(int fid, struct seq_file *seq)
 	int update_result = ACPI_BATTERY_NONE_UPDATE;
 	int update = 0;
 
-	mutex_lock(&battery->mutex);
-
 	update = (get_seconds() - battery->update_time[fid] >= update_time);
-	update = (update | battery->flags.update[fid]);
+	update = (update | battery->update[fid]);
 
 	result = acpi_battery_update(battery, update, &update_result);
 	if (result)
@@ -732,8 +668,7 @@ static int acpi_battery_read(int fid, struct seq_file *seq)
       end:
 	result = acpi_read_funcs[fid].print(seq, result);
 	acpi_battery_check_result(battery, result);
-	battery->flags.update[fid] = result;
-	mutex_unlock(&battery->mutex);
+	battery->update[fid] = result;
 	return result;
 }
 
@@ -900,20 +835,16 @@ static int acpi_battery_add(struct acpi_device *device)
 	if (!battery)
 		return -ENOMEM;
 
-	mutex_init(&battery->mutex);
-
-	mutex_lock(&battery->mutex);
-
 	battery->device = device;
 	strcpy(acpi_device_name(device), ACPI_BATTERY_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_BATTERY_CLASS);
 	acpi_driver_data(device) = battery;
-
+	mutex_init(&battery->lock);
 	result = acpi_battery_get_status(battery);
 	if (result)
 		goto end;
 
-	battery->flags.init_update = 1;
+	battery->init_update = 1;
 
 	result = acpi_battery_add_fs(device);
 	if (result)
@@ -939,8 +870,6 @@ static int acpi_battery_add(struct acpi_device *device)
 		kfree(battery);
 	}
 
-	mutex_unlock(&battery->mutex);
-
 	return result;
 }
 
@@ -954,22 +883,12 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 
 	battery = acpi_driver_data(device);
 
-	mutex_lock(&battery->mutex);
-
 	status = acpi_remove_notify_handler(device->handle,
 					    ACPI_ALL_NOTIFY,
 					    acpi_battery_notify);
 
 	acpi_battery_remove_fs(device);
-
-	kfree(battery->bif_data.pointer);
-
-	kfree(battery->bst_data.pointer);
-
-	mutex_unlock(&battery->mutex);
-
-	mutex_destroy(&battery->mutex);
-
+	mutex_destroy(&battery->lock);
 	kfree(battery);
 
 	return 0;
@@ -985,7 +904,7 @@ static int acpi_battery_resume(struct acpi_device *device)
 
 	battery = device->driver_data;
 
-	battery->flags.init_update = 1;
+	battery->init_update = 1;
 
 	return 0;
 }

commit 25c87f7f2a4fc3e50a7912b1c78405d454d1c4d9
Merge: a4fd4946214f 3e069ee0c30d
Author: Len Brown <len.brown@intel.com>
Date:   Sat Aug 25 01:44:01 2007 -0400

    Pull events into release branch
    
    Conflicts:
    
            drivers/acpi/video.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 14e04fb34ffa82ee61ae69f98d8fca12d2e8e31c
Author: Len Brown <len.brown@intel.com>
Date:   Thu Aug 23 15:20:26 2007 -0400

    ACPI: Schedule /proc/acpi/event for removal
    
    Schedule /proc/acpi/event for removal in 6 months.
    
    Re-name acpi_bus_generate_event() to acpi_bus_generate_proc_event()
    to make sure there is no confusion that it is for /proc/acpi/event only.
    
    Add CONFIG_ACPI_PROC_EVENT to allow removal of /proc/acpi/event.
    There is no functional change if CONFIG_ACPI_PROC_EVENT=y
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 9f0bf90afdab..91dc4b316a08 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -867,7 +867,7 @@ static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 	case ACPI_NOTIFY_DEVICE_CHECK:
 		device = battery->device;
 		acpi_battery_notify_update(battery);
-		acpi_bus_generate_event(device, event,
+		acpi_bus_generate_proc_event(device, event,
 					acpi_battery_present(battery));
 		acpi_bus_generate_netlink_event(device->pnp.device_class,
 						  device->dev.bus_id, event,

commit 962ce8ca0604af0c3c5609f7613d4ec5fcfac623
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Aug 23 01:24:31 2007 +0800

    ACPI: don't duplicate input events on netlink
    
    The previous events patch added a netlink event for every
    user of the legacy /proc/acpi/event interface.
    
    However, some users of /proc/acpi/event are really input events,
    and they already report their events via the input layer.
    
    Introduce a new interface, acpi_bus_generate_netlink_event(),
    which is explicitly called by devices that want to repoprt
    events via netlink.  This allows the input-like events
    to opt-out of generating netlink events.  In summary:
    
    events that are sent via netlink:
            ac/battery/sbs
            thermal
            processor
            thinkpad_acpi dock/bay
    
    events that are sent via input layer:
            button
            video hotkey
            thinkpad_acpi hotkey
            asus_acpi/asus-laptop hotkey
            sonypi/sonylaptop
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index d7b499fe0cd9..9f0bf90afdab 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -869,6 +869,9 @@ static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 		acpi_battery_notify_update(battery);
 		acpi_bus_generate_event(device, event,
 					acpi_battery_present(battery));
+		acpi_bus_generate_netlink_event(device->pnp.device_class,
+						  device->dev.bus_id, event,
+						  acpi_battery_present(battery));
 		break;
 	default:
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,

commit 5b31d895874f56174e4d885c065c9fc4b24b28bb
Author: Len Brown <len.brown@intel.com>
Date:   Wed Aug 15 00:19:26 2007 -0400

    Revert "ACPI: Battery: Synchronize battery operations."
    
    This reverts commit 3bd92ba19a89fe61ebf58804f9c8675372f50c1c.
    
    It is no longer necessary, and it opens up a race.
    
    Acked-by: Vladimir Lebedev <vladimir.p.lebedev@gmail.com>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index d7b499fe0cd9..81651032791b 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -113,7 +113,7 @@ struct acpi_battery_info {
 	acpi_string oem_info;
 };
 
-enum acpi_battery_files {
+enum acpi_battery_files{
 	ACPI_BATTERY_INFO = 0,
 	ACPI_BATTERY_STATE,
 	ACPI_BATTERY_ALARM,
@@ -129,14 +129,13 @@ struct acpi_battery_flags {
 };
 
 struct acpi_battery {
+	struct mutex mutex;
 	struct acpi_device *device;
 	struct acpi_battery_flags flags;
 	struct acpi_buffer bif_data;
 	struct acpi_buffer bst_data;
-	struct mutex lock;
 	unsigned long alarm;
 	unsigned long update_time[ACPI_BATTERY_NUMFILES];
-
 };
 
 inline int acpi_battery_present(struct acpi_battery *battery)
@@ -236,10 +235,10 @@ static int acpi_battery_get_info(struct acpi_battery *battery)
 		return 0;
 
 	/* Evaluate _BIF */
-	mutex_lock(&battery->lock);
-	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BIF",
-				      NULL, &buffer);
-	mutex_unlock(&battery->lock);
+
+	status =
+	    acpi_evaluate_object(acpi_battery_handle(battery), "_BIF", NULL,
+				 &buffer);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BIF"));
 		return -ENODEV;
@@ -286,10 +285,10 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 		return 0;
 
 	/* Evaluate _BST */
-	mutex_lock(&battery->lock);
-	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BST",
-				      NULL, &buffer);
-	mutex_unlock(&battery->lock);
+
+	status =
+	    acpi_evaluate_object(acpi_battery_handle(battery), "_BST", NULL,
+				 &buffer);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BST"));
 		return -ENODEV;
@@ -337,10 +336,9 @@ static int acpi_battery_set_alarm(struct acpi_battery *battery,
 
 	arg0.integer.value = alarm;
 
-	mutex_lock(&battery->lock);
-	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BTP",
+	status =
+	    acpi_evaluate_object(acpi_battery_handle(battery), "_BTP",
 				 &arg_list, NULL);
-	mutex_unlock(&battery->lock);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
@@ -660,6 +658,8 @@ acpi_battery_write_alarm(struct file *file,
 	if (!battery || (count > sizeof(alarm_string) - 1))
 		return -EINVAL;
 
+	mutex_lock(&battery->mutex);
+
 	result = acpi_battery_update(battery, 1, &update_result);
 	if (result) {
 		result = -ENODEV;
@@ -688,7 +688,9 @@ acpi_battery_write_alarm(struct file *file,
 	acpi_battery_check_result(battery, result);
 
 	if (!result)
-		return count;
+		result = count;
+
+	mutex_unlock(&battery->mutex);
 
 	return result;
 }
@@ -712,6 +714,8 @@ static int acpi_battery_read(int fid, struct seq_file *seq)
 	int update_result = ACPI_BATTERY_NONE_UPDATE;
 	int update = 0;
 
+	mutex_lock(&battery->mutex);
+
 	update = (get_seconds() - battery->update_time[fid] >= update_time);
 	update = (update | battery->flags.update[fid]);
 
@@ -729,6 +733,7 @@ static int acpi_battery_read(int fid, struct seq_file *seq)
 	result = acpi_read_funcs[fid].print(seq, result);
 	acpi_battery_check_result(battery, result);
 	battery->flags.update[fid] = result;
+	mutex_unlock(&battery->mutex);
 	return result;
 }
 
@@ -892,7 +897,10 @@ static int acpi_battery_add(struct acpi_device *device)
 	if (!battery)
 		return -ENOMEM;
 
-	mutex_init(&battery->lock);
+	mutex_init(&battery->mutex);
+
+	mutex_lock(&battery->mutex);
+
 	battery->device = device;
 	strcpy(acpi_device_name(device), ACPI_BATTERY_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_BATTERY_CLASS);
@@ -928,6 +936,7 @@ static int acpi_battery_add(struct acpi_device *device)
 		kfree(battery);
 	}
 
+	mutex_unlock(&battery->mutex);
 
 	return result;
 }
@@ -942,6 +951,8 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 
 	battery = acpi_driver_data(device);
 
+	mutex_lock(&battery->mutex);
+
 	status = acpi_remove_notify_handler(device->handle,
 					    ACPI_ALL_NOTIFY,
 					    acpi_battery_notify);
@@ -952,7 +963,9 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 
 	kfree(battery->bst_data.pointer);
 
-	mutex_destroy(&battery->lock);
+	mutex_unlock(&battery->mutex);
+
+	mutex_destroy(&battery->mutex);
 
 	kfree(battery);
 

commit 3bd92ba19a89fe61ebf58804f9c8675372f50c1c
Author: Alexey Starikovskiy <astarikivskiy@suse.de>
Date:   Fri Aug 3 17:38:20 2007 -0400

    ACPI: Battery: Synchronize battery operations.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=8768
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 81651032791b..d7b499fe0cd9 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -113,7 +113,7 @@ struct acpi_battery_info {
 	acpi_string oem_info;
 };
 
-enum acpi_battery_files{
+enum acpi_battery_files {
 	ACPI_BATTERY_INFO = 0,
 	ACPI_BATTERY_STATE,
 	ACPI_BATTERY_ALARM,
@@ -129,13 +129,14 @@ struct acpi_battery_flags {
 };
 
 struct acpi_battery {
-	struct mutex mutex;
 	struct acpi_device *device;
 	struct acpi_battery_flags flags;
 	struct acpi_buffer bif_data;
 	struct acpi_buffer bst_data;
+	struct mutex lock;
 	unsigned long alarm;
 	unsigned long update_time[ACPI_BATTERY_NUMFILES];
+
 };
 
 inline int acpi_battery_present(struct acpi_battery *battery)
@@ -235,10 +236,10 @@ static int acpi_battery_get_info(struct acpi_battery *battery)
 		return 0;
 
 	/* Evaluate _BIF */
-
-	status =
-	    acpi_evaluate_object(acpi_battery_handle(battery), "_BIF", NULL,
-				 &buffer);
+	mutex_lock(&battery->lock);
+	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BIF",
+				      NULL, &buffer);
+	mutex_unlock(&battery->lock);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BIF"));
 		return -ENODEV;
@@ -285,10 +286,10 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 		return 0;
 
 	/* Evaluate _BST */
-
-	status =
-	    acpi_evaluate_object(acpi_battery_handle(battery), "_BST", NULL,
-				 &buffer);
+	mutex_lock(&battery->lock);
+	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BST",
+				      NULL, &buffer);
+	mutex_unlock(&battery->lock);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BST"));
 		return -ENODEV;
@@ -336,9 +337,10 @@ static int acpi_battery_set_alarm(struct acpi_battery *battery,
 
 	arg0.integer.value = alarm;
 
-	status =
-	    acpi_evaluate_object(acpi_battery_handle(battery), "_BTP",
+	mutex_lock(&battery->lock);
+	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BTP",
 				 &arg_list, NULL);
+	mutex_unlock(&battery->lock);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
@@ -658,8 +660,6 @@ acpi_battery_write_alarm(struct file *file,
 	if (!battery || (count > sizeof(alarm_string) - 1))
 		return -EINVAL;
 
-	mutex_lock(&battery->mutex);
-
 	result = acpi_battery_update(battery, 1, &update_result);
 	if (result) {
 		result = -ENODEV;
@@ -688,9 +688,7 @@ acpi_battery_write_alarm(struct file *file,
 	acpi_battery_check_result(battery, result);
 
 	if (!result)
-		result = count;
-
-	mutex_unlock(&battery->mutex);
+		return count;
 
 	return result;
 }
@@ -714,8 +712,6 @@ static int acpi_battery_read(int fid, struct seq_file *seq)
 	int update_result = ACPI_BATTERY_NONE_UPDATE;
 	int update = 0;
 
-	mutex_lock(&battery->mutex);
-
 	update = (get_seconds() - battery->update_time[fid] >= update_time);
 	update = (update | battery->flags.update[fid]);
 
@@ -733,7 +729,6 @@ static int acpi_battery_read(int fid, struct seq_file *seq)
 	result = acpi_read_funcs[fid].print(seq, result);
 	acpi_battery_check_result(battery, result);
 	battery->flags.update[fid] = result;
-	mutex_unlock(&battery->mutex);
 	return result;
 }
 
@@ -897,10 +892,7 @@ static int acpi_battery_add(struct acpi_device *device)
 	if (!battery)
 		return -ENOMEM;
 
-	mutex_init(&battery->mutex);
-
-	mutex_lock(&battery->mutex);
-
+	mutex_init(&battery->lock);
 	battery->device = device;
 	strcpy(acpi_device_name(device), ACPI_BATTERY_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_BATTERY_CLASS);
@@ -936,7 +928,6 @@ static int acpi_battery_add(struct acpi_device *device)
 		kfree(battery);
 	}
 
-	mutex_unlock(&battery->mutex);
 
 	return result;
 }
@@ -951,8 +942,6 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 
 	battery = acpi_driver_data(device);
 
-	mutex_lock(&battery->mutex);
-
 	status = acpi_remove_notify_handler(device->handle,
 					    ACPI_ALL_NOTIFY,
 					    acpi_battery_notify);
@@ -963,9 +952,7 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 
 	kfree(battery->bst_data.pointer);
 
-	mutex_unlock(&battery->mutex);
-
-	mutex_destroy(&battery->mutex);
+	mutex_destroy(&battery->lock);
 
 	kfree(battery);
 

commit 1ba90e3a87c46500623afdc3898573e4a5ebb21b
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jul 23 14:44:41 2007 +0200

    ACPI: autoload modules - Create __mod_acpi_device_table symbol for all ACPI drivers
    
    modpost is going to use these to create e.g. acpi:ACPI0001
    in modules.alias.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index cad932de383d..81651032791b 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -41,7 +41,6 @@
 
 #define ACPI_BATTERY_COMPONENT		0x00040000
 #define ACPI_BATTERY_CLASS		"battery"
-#define ACPI_BATTERY_HID		"PNP0C0A"
 #define ACPI_BATTERY_DEVICE_NAME	"Battery"
 #define ACPI_BATTERY_NOTIFY_STATUS	0x80
 #define ACPI_BATTERY_NOTIFY_INFO	0x81
@@ -74,10 +73,16 @@ static int acpi_battery_add(struct acpi_device *device);
 static int acpi_battery_remove(struct acpi_device *device, int type);
 static int acpi_battery_resume(struct acpi_device *device);
 
+static const struct acpi_device_id battery_device_ids[] = {
+	{"PNP0C0A", 0},
+	{"", 0},
+};
+MODULE_DEVICE_TABLE(acpi, battery_device_ids);
+
 static struct acpi_driver acpi_battery_driver = {
 	.name = "battery",
 	.class = ACPI_BATTERY_CLASS,
-	.ids = ACPI_BATTERY_HID,
+	.ids = battery_device_ids,
 	.ops = {
 		.add = acpi_battery_add,
 		.resume = acpi_battery_resume,

commit 78490d82129f7331d1366737c8704c1c053221a3
Author: Alexey Starikovskiy <aystarik@gmail.com>
Date:   Fri May 11 13:18:55 2007 -0400

    ACPI: battery: syntax cleanup
    
    In response to review comments from Andrew Morton
    
    Signed-off-by: Alexey Starikovskiy <aystarik@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index b5df318978ed..cad932de383d 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -43,9 +43,6 @@
 #define ACPI_BATTERY_CLASS		"battery"
 #define ACPI_BATTERY_HID		"PNP0C0A"
 #define ACPI_BATTERY_DEVICE_NAME	"Battery"
-#define ACPI_BATTERY_FILE_INFO		"info"
-#define ACPI_BATTERY_FILE_STATE		"state"
-#define ACPI_BATTERY_FILE_ALARM		"alarm"
 #define ACPI_BATTERY_NOTIFY_STATUS	0x80
 #define ACPI_BATTERY_NOTIFY_INFO	0x81
 #define ACPI_BATTERY_UNITS_WATTS	"mW"
@@ -111,13 +108,18 @@ struct acpi_battery_info {
 	acpi_string oem_info;
 };
 
+enum acpi_battery_files{
+	ACPI_BATTERY_INFO = 0,
+	ACPI_BATTERY_STATE,
+	ACPI_BATTERY_ALARM,
+	ACPI_BATTERY_NUMFILES,
+};
+
 struct acpi_battery_flags {
 	u8 battery_present_prev;
 	u8 alarm_present;
 	u8 init_update;
-	u8 info_update;
-	u8 state_update;
-	u8 alarm_update;
+	u8 update[ACPI_BATTERY_NUMFILES];
 	u8 power_unit;
 };
 
@@ -128,47 +130,37 @@ struct acpi_battery {
 	struct acpi_buffer bif_data;
 	struct acpi_buffer bst_data;
 	unsigned long alarm;
-	unsigned long info_update_time;
-	unsigned long state_update_time;
-	unsigned long alarm_update_time;
+	unsigned long update_time[ACPI_BATTERY_NUMFILES];
 };
 
-#define acpi_battery_present(battery) battery->device->status.battery_present
-#define acpi_battery_present_prev(battery) battery->flags.battery_present_prev
-#define acpi_battery_alarm_present(battery) battery->flags.alarm_present
-#define acpi_battery_init_update_flag(battery) battery->flags.init_update
-#define acpi_battery_info_update_flag(battery) battery->flags.info_update
-#define acpi_battery_state_update_flag(battery) battery->flags.state_update
-#define acpi_battery_alarm_update_flag(battery) battery->flags.alarm_update
-#define acpi_battery_power_units(battery) battery->flags.power_unit ? \
-		ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS
-#define acpi_battery_handle(battery) battery->device->handle
-#define acpi_battery_inserted(battery) (!acpi_battery_present_prev(battery) & acpi_battery_present(battery))
-#define acpi_battery_removed(battery) (acpi_battery_present_prev(battery) & !acpi_battery_present(battery))
-#define acpi_battery_bid(battery) acpi_device_bid(battery->device)
-#define acpi_battery_status_str(battery) acpi_battery_present(battery) ? "present" : "absent"
-
-/* --------------------------------------------------------------------------
-                               Battery Management
-   -------------------------------------------------------------------------- */
-
-static void acpi_battery_mutex_lock(struct acpi_battery *battery)
+inline int acpi_battery_present(struct acpi_battery *battery)
 {
-	mutex_lock(&battery->mutex);
+	return battery->device->status.battery_present;
+}
+inline char *acpi_battery_power_units(struct acpi_battery *battery)
+{
+	if (battery->flags.power_unit)
+		return ACPI_BATTERY_UNITS_AMPS;
+	else
+		return ACPI_BATTERY_UNITS_WATTS;
 }
 
-static void acpi_battery_mutex_unlock(struct acpi_battery *battery)
+inline acpi_handle acpi_battery_handle(struct acpi_battery *battery)
 {
-	mutex_unlock(&battery->mutex);
+	return battery->device->handle;
 }
 
+/* --------------------------------------------------------------------------
+                               Battery Management
+   -------------------------------------------------------------------------- */
+
 static void acpi_battery_check_result(struct acpi_battery *battery, int result)
 {
 	if (!battery)
 		return;
 
 	if (result) {
-		acpi_battery_init_update_flag(battery) = 1;
+		battery->flags.init_update = 1;
 	}
 }
 
@@ -189,9 +181,7 @@ static int acpi_battery_extract_package(struct acpi_battery *battery,
 	}
 
 	if (data_null.length != data->length) {
-		if (data->pointer) {
-			kfree(data->pointer);
-		}
+		kfree(data->pointer);
 		data->pointer = kzalloc(data_null.length, GFP_KERNEL);
 		if (!data->pointer) {
 			ACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY, "kzalloc()"));
@@ -234,12 +224,12 @@ static int acpi_battery_get_info(struct acpi_battery *battery)
 	struct acpi_buffer *data = NULL;
 	struct acpi_battery_info *bif = NULL;
 
-	battery->info_update_time = get_seconds();
+	battery->update_time[ACPI_BATTERY_INFO] = get_seconds();
 
 	if (!acpi_battery_present(battery))
 		return 0;
 
-	/* Evalute _BIF */
+	/* Evaluate _BIF */
 
 	status =
 	    acpi_evaluate_object(acpi_battery_handle(battery), "_BIF", NULL,
@@ -263,9 +253,7 @@ static int acpi_battery_get_info(struct acpi_battery *battery)
 
       end:
 
-	if (buffer.pointer) {
-		kfree(buffer.pointer);
-	}
+	kfree(buffer.pointer);
 
 	if (!result) {
 		bif = data->pointer;
@@ -286,12 +274,12 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 	union acpi_object *package = NULL;
 	struct acpi_buffer *data = NULL;
 
-	battery->state_update_time = get_seconds();
+	battery->update_time[ACPI_BATTERY_STATE] = get_seconds();
 
 	if (!acpi_battery_present(battery))
 		return 0;
 
-	/* Evalute _BST */
+	/* Evaluate _BST */
 
 	status =
 	    acpi_evaluate_object(acpi_battery_handle(battery), "_BST", NULL,
@@ -314,16 +302,14 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 		goto end;
 
       end:
-	if (buffer.pointer) {
-		kfree(buffer.pointer);
-	}
+	kfree(buffer.pointer);
 
 	return result;
 }
 
 static int acpi_battery_get_alarm(struct acpi_battery *battery)
 {
-	battery->alarm_update_time = get_seconds();
+	battery->update_time[ACPI_BATTERY_ALARM] = get_seconds();
 
 	return 0;
 }
@@ -335,12 +321,12 @@ static int acpi_battery_set_alarm(struct acpi_battery *battery,
 	union acpi_object arg0 = { ACPI_TYPE_INTEGER };
 	struct acpi_object_list arg_list = { 1, &arg0 };
 
-	battery->alarm_update_time = get_seconds();
+	battery->update_time[ACPI_BATTERY_ALARM] = get_seconds();
 
 	if (!acpi_battery_present(battery))
 		return -ENODEV;
 
-	if (!acpi_battery_alarm_present(battery))
+	if (!battery->flags.alarm_present)
 		return -ENODEV;
 
 	arg0.integer.value = alarm;
@@ -370,7 +356,7 @@ static int acpi_battery_init_alarm(struct acpi_battery *battery)
 
 	status = acpi_get_handle(acpi_battery_handle(battery), "_BTP", &handle);
 	if (ACPI_SUCCESS(status)) {
-		acpi_battery_alarm_present(battery) = 1;
+		battery->flags.alarm_present = 1;
 		if (!alarm && bif) {
 			alarm = bif->design_capacity_warning;
 		}
@@ -378,7 +364,7 @@ static int acpi_battery_init_alarm(struct acpi_battery *battery)
 		if (result)
 			goto end;
 	} else {
-		acpi_battery_alarm_present(battery) = 0;
+		battery->flags.alarm_present = 0;
 	}
 
       end:
@@ -394,7 +380,7 @@ static int acpi_battery_init_update(struct acpi_battery *battery)
 	if (result)
 		return result;
 
-	acpi_battery_present_prev(battery) = acpi_battery_present(battery);
+	battery->flags.battery_present_prev = acpi_battery_present(battery);
 
 	if (acpi_battery_present(battery)) {
 		result = acpi_battery_get_info(battery);
@@ -420,20 +406,20 @@ static int acpi_battery_update(struct acpi_battery *battery,
 		update = 1;
 	}
 
-	if (acpi_battery_init_update_flag(battery)) {
+	if (battery->flags.init_update) {
 		result = acpi_battery_init_update(battery);
 		if (result)
-			goto end;;
+			goto end;
 		update_result = ACPI_BATTERY_INIT_UPDATE;
 	} else if (update) {
 		result = acpi_battery_get_status(battery);
 		if (result)
-			goto end;;
-		if (acpi_battery_inserted(battery)
-		    || acpi_battery_removed(battery)) {
+			goto end;
+		if ((!battery->flags.battery_present_prev & acpi_battery_present(battery))
+		    || (battery->flags.battery_present_prev & !acpi_battery_present(battery))) {
 			result = acpi_battery_init_update(battery);
 			if (result)
-				goto end;;
+				goto end;
 			update_result = ACPI_BATTERY_INIT_UPDATE;
 		} else {
 			update_result = ACPI_BATTERY_EASY_UPDATE;
@@ -442,7 +428,7 @@ static int acpi_battery_update(struct acpi_battery *battery,
 
       end:
 
-	acpi_battery_init_update_flag(battery) = (result != 0);
+	battery->flags.init_update = (result != 0);
 
 	*update_result_ptr = update_result;
 
@@ -453,16 +439,19 @@ static void acpi_battery_notify_update(struct acpi_battery *battery)
 {
 	acpi_battery_get_status(battery);
 
-	if (acpi_battery_init_update_flag(battery)) {
+	if (battery->flags.init_update) {
 		return;
 	}
 
-	if (acpi_battery_inserted(battery) || acpi_battery_removed(battery)) {
-		acpi_battery_init_update_flag(battery) = 1;
+	if ((!battery->flags.battery_present_prev &
+	     acpi_battery_present(battery)) ||
+	    (battery->flags.battery_present_prev &
+	     !acpi_battery_present(battery))) {
+		battery->flags.init_update = 1;
 	} else {
-		acpi_battery_info_update_flag(battery) = 1;
-		acpi_battery_state_update_flag(battery) = 1;
-		acpi_battery_alarm_update_flag(battery) = 1;
+		battery->flags.update[ACPI_BATTERY_INFO] = 1;
+		battery->flags.update[ACPI_BATTERY_STATE] = 1;
+		battery->flags.update[ACPI_BATTERY_ALARM] = 1;
 	}
 }
 
@@ -472,7 +461,7 @@ static void acpi_battery_notify_update(struct acpi_battery *battery)
 
 static struct proc_dir_entry *acpi_battery_dir;
 
-static int acpi_battery_read_info_print(struct seq_file *seq, int result)
+static int acpi_battery_print_info(struct seq_file *seq, int result)
 {
 	struct acpi_battery *battery = seq->private;
 	struct acpi_battery_info *bif = NULL;
@@ -549,49 +538,7 @@ static int acpi_battery_read_info_print(struct seq_file *seq, int result)
 	return result;
 }
 
-static int acpi_battery_read_info(struct seq_file *seq, void *offset)
-{
-	struct acpi_battery *battery = seq->private;
-	int result = 0;
-	int update_result = ACPI_BATTERY_NONE_UPDATE;
-	int update = 0;
-
-	acpi_battery_mutex_lock(battery);
-
-	update = (get_seconds() - battery->info_update_time >= update_time);
-	update = (update | acpi_battery_info_update_flag(battery));
-
-	result = acpi_battery_update(battery, update, &update_result);
-	if (result)
-		goto end;
-
-	/* Battery Info (_BIF) */
-
-	if (update_result == ACPI_BATTERY_EASY_UPDATE) {
-		result = acpi_battery_get_info(battery);
-		if (result)
-			goto end;
-	}
-
-      end:
-
-	result = acpi_battery_read_info_print(seq, result);
-
-	acpi_battery_check_result(battery, result);
-
-	acpi_battery_info_update_flag(battery) = result;
-
-	acpi_battery_mutex_unlock(battery);
-
-	return result;
-}
-
-static int acpi_battery_info_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_battery_read_info, PDE(inode)->data);
-}
-
-static int acpi_battery_read_state_print(struct seq_file *seq, int result)
+static int acpi_battery_print_state(struct seq_file *seq, int result)
 {
 	struct acpi_battery *battery = seq->private;
 	struct acpi_battery_state *bst = NULL;
@@ -661,49 +608,7 @@ static int acpi_battery_read_state_print(struct seq_file *seq, int result)
 	return result;
 }
 
-static int acpi_battery_read_state(struct seq_file *seq, void *offset)
-{
-	struct acpi_battery *battery = seq->private;
-	int result = 0;
-	int update_result = ACPI_BATTERY_NONE_UPDATE;
-	int update = 0;
-
-	acpi_battery_mutex_lock(battery);
-
-	update = (get_seconds() - battery->state_update_time >= update_time);
-	update = (update | acpi_battery_state_update_flag(battery));
-
-	result = acpi_battery_update(battery, update, &update_result);
-	if (result)
-		goto end;
-
-	/* Battery State (_BST) */
-
-	if (update_result == ACPI_BATTERY_EASY_UPDATE) {
-		result = acpi_battery_get_state(battery);
-		if (result)
-			goto end;
-	}
-
-      end:
-
-	result = acpi_battery_read_state_print(seq, result);
-
-	acpi_battery_check_result(battery, result);
-
-	acpi_battery_state_update_flag(battery) = result;
-
-	acpi_battery_mutex_unlock(battery);
-
-	return result;
-}
-
-static int acpi_battery_state_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_battery_read_state, PDE(inode)->data);
-}
-
-static int acpi_battery_read_alarm_print(struct seq_file *seq, int result)
+static int acpi_battery_print_alarm(struct seq_file *seq, int result)
 {
 	struct acpi_battery *battery = seq->private;
 	char *units = "?";
@@ -734,43 +639,6 @@ static int acpi_battery_read_alarm_print(struct seq_file *seq, int result)
 	return result;
 }
 
-static int acpi_battery_read_alarm(struct seq_file *seq, void *offset)
-{
-	struct acpi_battery *battery = seq->private;
-	int result = 0;
-	int update_result = ACPI_BATTERY_NONE_UPDATE;
-	int update = 0;
-
-	acpi_battery_mutex_lock(battery);
-
-	update = (get_seconds() - battery->alarm_update_time >= update_time);
-	update = (update | acpi_battery_alarm_update_flag(battery));
-
-	result = acpi_battery_update(battery, update, &update_result);
-	if (result)
-		goto end;
-
-	/* Battery Alarm */
-
-	if (update_result == ACPI_BATTERY_EASY_UPDATE) {
-		result = acpi_battery_get_alarm(battery);
-		if (result)
-			goto end;
-	}
-
-      end:
-
-	result = acpi_battery_read_alarm_print(seq, result);
-
-	acpi_battery_check_result(battery, result);
-
-	acpi_battery_alarm_update_flag(battery) = result;
-
-	acpi_battery_mutex_unlock(battery);
-
-	return result;
-}
-
 static ssize_t
 acpi_battery_write_alarm(struct file *file,
 			 const char __user * buffer,
@@ -785,7 +653,7 @@ acpi_battery_write_alarm(struct file *file,
 	if (!battery || (count > sizeof(alarm_string) - 1))
 		return -EINVAL;
 
-	acpi_battery_mutex_lock(battery);
+	mutex_lock(&battery->mutex);
 
 	result = acpi_battery_update(battery, 1, &update_result);
 	if (result) {
@@ -817,44 +685,128 @@ acpi_battery_write_alarm(struct file *file,
 	if (!result)
 		result = count;
 
-	acpi_battery_mutex_unlock(battery);
+	mutex_unlock(&battery->mutex);
+
+	return result;
+}
+
+typedef int(*print_func)(struct seq_file *seq, int result);
+typedef int(*get_func)(struct acpi_battery *battery);
+
+static struct acpi_read_mux {
+	print_func print;
+	get_func get;
+} acpi_read_funcs[ACPI_BATTERY_NUMFILES] = {
+	{.get = acpi_battery_get_info, .print = acpi_battery_print_info},
+	{.get = acpi_battery_get_state, .print = acpi_battery_print_state},
+	{.get = acpi_battery_get_alarm, .print = acpi_battery_print_alarm},
+};
 
+static int acpi_battery_read(int fid, struct seq_file *seq)
+{
+	struct acpi_battery *battery = seq->private;
+	int result = 0;
+	int update_result = ACPI_BATTERY_NONE_UPDATE;
+	int update = 0;
+
+	mutex_lock(&battery->mutex);
+
+	update = (get_seconds() - battery->update_time[fid] >= update_time);
+	update = (update | battery->flags.update[fid]);
+
+	result = acpi_battery_update(battery, update, &update_result);
+	if (result)
+		goto end;
+
+	if (update_result == ACPI_BATTERY_EASY_UPDATE) {
+		result = acpi_read_funcs[fid].get(battery);
+		if (result)
+			goto end;
+	}
+
+      end:
+	result = acpi_read_funcs[fid].print(seq, result);
+	acpi_battery_check_result(battery, result);
+	battery->flags.update[fid] = result;
+	mutex_unlock(&battery->mutex);
 	return result;
 }
 
+static int acpi_battery_read_info(struct seq_file *seq, void *offset)
+{
+	return acpi_battery_read(ACPI_BATTERY_INFO, seq);
+}
+
+static int acpi_battery_read_state(struct seq_file *seq, void *offset)
+{
+	return acpi_battery_read(ACPI_BATTERY_STATE, seq);
+}
+
+static int acpi_battery_read_alarm(struct seq_file *seq, void *offset)
+{
+	return acpi_battery_read(ACPI_BATTERY_ALARM, seq);
+}
+
+static int acpi_battery_info_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, acpi_battery_read_info, PDE(inode)->data);
+}
+
+static int acpi_battery_state_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, acpi_battery_read_state, PDE(inode)->data);
+}
+
 static int acpi_battery_alarm_open_fs(struct inode *inode, struct file *file)
 {
 	return single_open(file, acpi_battery_read_alarm, PDE(inode)->data);
 }
 
-static const struct file_operations acpi_battery_info_ops = {
+static struct battery_file {
+	struct file_operations ops;
+	mode_t mode;
+	char *name;
+} acpi_battery_file[] = {
+	{
+	.name = "info",
+	.mode = S_IRUGO,
+	.ops = {
 	.open = acpi_battery_info_open_fs,
 	.read = seq_read,
 	.llseek = seq_lseek,
 	.release = single_release,
 	.owner = THIS_MODULE,
-};
-
-static const struct file_operations acpi_battery_state_ops = {
+	},
+	},
+	{
+	.name = "state",
+	.mode = S_IRUGO,
+	.ops = {
 	.open = acpi_battery_state_open_fs,
 	.read = seq_read,
 	.llseek = seq_lseek,
 	.release = single_release,
 	.owner = THIS_MODULE,
-};
-
-static const struct file_operations acpi_battery_alarm_ops = {
+	},
+	},
+	{
+	.name = "alarm",
+	.mode = S_IFREG | S_IRUGO | S_IWUSR,
+	.ops = {
 	.open = acpi_battery_alarm_open_fs,
 	.read = seq_read,
 	.write = acpi_battery_write_alarm,
 	.llseek = seq_lseek,
 	.release = single_release,
 	.owner = THIS_MODULE,
+	},
+	},
 };
 
 static int acpi_battery_add_fs(struct acpi_device *device)
 {
 	struct proc_dir_entry *entry = NULL;
+	int i;
 
 	if (!acpi_device_dir(device)) {
 		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
@@ -864,38 +816,16 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 		acpi_device_dir(device)->owner = THIS_MODULE;
 	}
 
-	/* 'info' [R] */
-	entry = create_proc_entry(ACPI_BATTERY_FILE_INFO,
-				  S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		return -ENODEV;
-	else {
-		entry->proc_fops = &acpi_battery_info_ops;
-		entry->data = acpi_driver_data(device);
-		entry->owner = THIS_MODULE;
-	}
-
-	/* 'status' [R] */
-	entry = create_proc_entry(ACPI_BATTERY_FILE_STATE,
-				  S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		return -ENODEV;
-	else {
-		entry->proc_fops = &acpi_battery_state_ops;
-		entry->data = acpi_driver_data(device);
-		entry->owner = THIS_MODULE;
-	}
-
-	/* 'alarm' [R/W] */
-	entry = create_proc_entry(ACPI_BATTERY_FILE_ALARM,
-				  S_IFREG | S_IRUGO | S_IWUSR,
-				  acpi_device_dir(device));
-	if (!entry)
-		return -ENODEV;
-	else {
-		entry->proc_fops = &acpi_battery_alarm_ops;
-		entry->data = acpi_driver_data(device);
-		entry->owner = THIS_MODULE;
+	for (i = 0; i < ACPI_BATTERY_NUMFILES; ++i) {
+		entry = create_proc_entry(acpi_battery_file[i].name,
+				  acpi_battery_file[i].mode, acpi_device_dir(device));
+		if (!entry)
+			return -ENODEV;
+		else {
+			entry->proc_fops = &acpi_battery_file[i].ops;
+			entry->data = acpi_driver_data(device);
+			entry->owner = THIS_MODULE;
+		}
 	}
 
 	return 0;
@@ -903,14 +833,12 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 
 static int acpi_battery_remove_fs(struct acpi_device *device)
 {
+	int i;
 	if (acpi_device_dir(device)) {
-		remove_proc_entry(ACPI_BATTERY_FILE_ALARM,
-				  acpi_device_dir(device));
-		remove_proc_entry(ACPI_BATTERY_FILE_STATE,
-				  acpi_device_dir(device));
-		remove_proc_entry(ACPI_BATTERY_FILE_INFO,
+		for (i = 0; i < ACPI_BATTERY_NUMFILES; ++i) {
+			remove_proc_entry(acpi_battery_file[i].name,
 				  acpi_device_dir(device));
-
+		}
 		remove_proc_entry(acpi_device_bid(device), acpi_battery_dir);
 		acpi_device_dir(device) = NULL;
 	}
@@ -966,7 +894,7 @@ static int acpi_battery_add(struct acpi_device *device)
 
 	mutex_init(&battery->mutex);
 
-	acpi_battery_mutex_lock(battery);
+	mutex_lock(&battery->mutex);
 
 	battery->device = device;
 	strcpy(acpi_device_name(device), ACPI_BATTERY_DEVICE_NAME);
@@ -977,7 +905,7 @@ static int acpi_battery_add(struct acpi_device *device)
 	if (result)
 		goto end;
 
-	acpi_battery_init_update_flag(battery) = 1;
+	battery->flags.init_update = 1;
 
 	result = acpi_battery_add_fs(device);
 	if (result)
@@ -1003,7 +931,7 @@ static int acpi_battery_add(struct acpi_device *device)
 		kfree(battery);
 	}
 
-	acpi_battery_mutex_unlock(battery);
+	mutex_unlock(&battery->mutex);
 
 	return result;
 }
@@ -1018,7 +946,7 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 
 	battery = acpi_driver_data(device);
 
-	acpi_battery_mutex_lock(battery);
+	mutex_lock(&battery->mutex);
 
 	status = acpi_remove_notify_handler(device->handle,
 					    ACPI_ALL_NOTIFY,
@@ -1026,13 +954,11 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 
 	acpi_battery_remove_fs(device);
 
-	if (battery->bif_data.pointer)
-		kfree(battery->bif_data.pointer);
+	kfree(battery->bif_data.pointer);
 
-	if (battery->bst_data.pointer)
-		kfree(battery->bst_data.pointer);
+	kfree(battery->bst_data.pointer);
 
-	acpi_battery_mutex_unlock(battery);
+	mutex_unlock(&battery->mutex);
 
 	mutex_destroy(&battery->mutex);
 
@@ -1051,7 +977,7 @@ static int acpi_battery_resume(struct acpi_device *device)
 
 	battery = device->driver_data;
 
-	acpi_battery_init_update_flag(battery) = 1;
+	battery->flags.init_update = 1;
 
 	return 0;
 }

commit 6eedeef73e7fff32eb5fa25178c3c77b1db0ec0f
Author: Vladimir Lebedev <vladimir.p.lebedev@gmail.com>
Date:   Sat Apr 21 22:41:48 2007 -0400

    process reading battery status hangs
    
    http://bugzilla.kernel.org/show_bug.cgi?id=8351
    
    Signed-off-by: Vladimir Lebedev <vladimir.p.lebedev@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index fc9c50ab5219..b5df318978ed 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -937,10 +937,8 @@ static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 	case ACPI_BATTERY_NOTIFY_INFO:
 	case ACPI_NOTIFY_BUS_CHECK:
 	case ACPI_NOTIFY_DEVICE_CHECK:
-		acpi_battery_mutex_lock(battery);
 		device = battery->device;
 		acpi_battery_notify_update(battery);
-		acpi_battery_mutex_unlock(battery);
 		acpi_bus_generate_event(device, event,
 					acpi_battery_present(battery));
 		break;

commit 9ea7d57576f40c6af03c8c9fa7a069f2222b498b
Author: Vladimir Lebedev <vladimir.p.lebedev@intel.com>
Date:   Tue Feb 20 15:48:06 2007 +0300

    ACPI: battery: Lindent
    
    Signed-off-by: Vladimir Lebedev <vladimir.p.lebedev@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index f3b0024e5760..fc9c50ab5219 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -123,7 +123,7 @@ struct acpi_battery_flags {
 
 struct acpi_battery {
 	struct mutex mutex;
-	struct acpi_device * device;
+	struct acpi_device *device;
 	struct acpi_battery_flags flags;
 	struct acpi_buffer bif_data;
 	struct acpi_buffer bst_data;
@@ -241,7 +241,9 @@ static int acpi_battery_get_info(struct acpi_battery *battery)
 
 	/* Evalute _BIF */
 
-	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BIF", NULL, &buffer);
+	status =
+	    acpi_evaluate_object(acpi_battery_handle(battery), "_BIF", NULL,
+				 &buffer);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BIF"));
 		return -ENODEV;
@@ -253,7 +255,9 @@ static int acpi_battery_get_info(struct acpi_battery *battery)
 
 	/* Extract Package Data */
 
-	result = acpi_battery_extract_package(battery, package, &format, data, "_BIF");
+	result =
+	    acpi_battery_extract_package(battery, package, &format, data,
+					 "_BIF");
 	if (result)
 		goto end;
 
@@ -289,7 +293,9 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 
 	/* Evalute _BST */
 
-	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BST", NULL, &buffer);
+	status =
+	    acpi_evaluate_object(acpi_battery_handle(battery), "_BST", NULL,
+				 &buffer);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BST"));
 		return -ENODEV;
@@ -301,7 +307,9 @@ static int acpi_battery_get_state(struct acpi_battery *battery)
 
 	/* Extract Package Data */
 
-	result = acpi_battery_extract_package(battery, package, &format, data, "_BST");
+	result =
+	    acpi_battery_extract_package(battery, package, &format, data,
+					 "_BST");
 	if (result)
 		goto end;
 
@@ -320,7 +328,8 @@ static int acpi_battery_get_alarm(struct acpi_battery *battery)
 	return 0;
 }
 
-static int acpi_battery_set_alarm(struct acpi_battery *battery, unsigned long alarm)
+static int acpi_battery_set_alarm(struct acpi_battery *battery,
+				  unsigned long alarm)
 {
 	acpi_status status = 0;
 	union acpi_object arg0 = { ACPI_TYPE_INTEGER };
@@ -336,7 +345,9 @@ static int acpi_battery_set_alarm(struct acpi_battery *battery, unsigned long al
 
 	arg0.integer.value = alarm;
 
-	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BTP", &arg_list, NULL);
+	status =
+	    acpi_evaluate_object(acpi_battery_handle(battery), "_BTP",
+				 &arg_list, NULL);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
@@ -400,7 +411,7 @@ static int acpi_battery_init_update(struct acpi_battery *battery)
 }
 
 static int acpi_battery_update(struct acpi_battery *battery,
-			   int update, int *update_result_ptr)
+			       int update, int *update_result_ptr)
 {
 	int result = 0;
 	int update_result = ACPI_BATTERY_NONE_UPDATE;
@@ -418,7 +429,8 @@ static int acpi_battery_update(struct acpi_battery *battery,
 		result = acpi_battery_get_status(battery);
 		if (result)
 			goto end;;
-		if (acpi_battery_inserted(battery) || acpi_battery_removed(battery)) {
+		if (acpi_battery_inserted(battery)
+		    || acpi_battery_removed(battery)) {
 			result = acpi_battery_init_update(battery);
 			if (result)
 				goto end;;
@@ -770,7 +782,6 @@ acpi_battery_write_alarm(struct file *file,
 	struct acpi_battery *battery = m->private;
 	int update_result = ACPI_BATTERY_NONE_UPDATE;
 
-
 	if (!battery || (count > sizeof(alarm_string) - 1))
 		return -EINVAL;
 
@@ -845,7 +856,6 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 {
 	struct proc_dir_entry *entry = NULL;
 
-
 	if (!acpi_device_dir(device)) {
 		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
 						     acpi_battery_dir);
@@ -917,7 +927,6 @@ static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 	struct acpi_battery *battery = data;
 	struct acpi_device *device = NULL;
 
-
 	if (!battery)
 		return;
 
@@ -932,7 +941,8 @@ static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 		device = battery->device;
 		acpi_battery_notify_update(battery);
 		acpi_battery_mutex_unlock(battery);
-		acpi_bus_generate_event(device, event, acpi_battery_present(battery));
+		acpi_bus_generate_event(device, event,
+					acpi_battery_present(battery));
 		break;
 	default:
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,

commit b6ce4083ed8e2a01a3a59301eabe0fc1e68a8a84
Author: Vladimir Lebedev <vladimir.p.lebedev@intel.com>
Date:   Tue Feb 20 15:48:06 2007 +0300

    ACPI: Cache battery status instead of re-evaluating AML
    
    /proc exports _BST in a single file, and _BST is re-evaulated
    whenever that file is read.
    
    Sometimes user-space reads this file frequently, and on some
    systems _BST takes a long time to evaluate due to a slow EC.
    
    Further, when we move to sysfs, the values returned from _BST
    will be in multiple files, and evaluating _BST for each
    file read would make matters worse.
    
    Here code is added to support caching the results of _BST.
    A new module parameter "update_time" tells how many seconds the
    cached _BST should be used before it is re-evaluated.
    Currently, update_time defaults to 0, and so the
    existing behaviour of re-evaluating on each read retained.
    
    Signed-off-by: Vladimir Lebedev <vladimir.p.lebedev@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index df04f87dd491..f3b0024e5760 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -52,12 +52,24 @@
 #define ACPI_BATTERY_UNITS_AMPS		"mA"
 
 #define _COMPONENT		ACPI_BATTERY_COMPONENT
+
+#define ACPI_BATTERY_UPDATE_TIME	0
+
+#define ACPI_BATTERY_NONE_UPDATE	0
+#define ACPI_BATTERY_EASY_UPDATE	1
+#define ACPI_BATTERY_INIT_UPDATE	2
+
 ACPI_MODULE_NAME("battery");
 
 MODULE_AUTHOR("Paul Diefenbaugh");
 MODULE_DESCRIPTION("ACPI Battery Driver");
 MODULE_LICENSE("GPL");
 
+static unsigned int update_time = ACPI_BATTERY_UPDATE_TIME;
+
+/* 0 - every time, > 0 - by update_time */
+module_param(update_time, uint, 0644);
+
 extern struct proc_dir_entry *acpi_lock_battery_dir(void);
 extern void *acpi_unlock_battery_dir(struct proc_dir_entry *acpi_battery_dir);
 
@@ -100,32 +112,117 @@ struct acpi_battery_info {
 };
 
 struct acpi_battery_flags {
-	u8 present:1;		/* Bay occupied? */
-	u8 power_unit:1;	/* 0=watts, 1=apms */
-	u8 alarm:1;		/* _BTP present? */
-	u8 reserved:5;
-};
-
-struct acpi_battery_trips {
-	unsigned long warning;
-	unsigned long low;
+	u8 battery_present_prev;
+	u8 alarm_present;
+	u8 init_update;
+	u8 info_update;
+	u8 state_update;
+	u8 alarm_update;
+	u8 power_unit;
 };
 
 struct acpi_battery {
+	struct mutex mutex;
 	struct acpi_device * device;
 	struct acpi_battery_flags flags;
-	struct acpi_battery_trips trips;
+	struct acpi_buffer bif_data;
+	struct acpi_buffer bst_data;
 	unsigned long alarm;
-	struct acpi_battery_info *info;
+	unsigned long info_update_time;
+	unsigned long state_update_time;
+	unsigned long alarm_update_time;
 };
 
+#define acpi_battery_present(battery) battery->device->status.battery_present
+#define acpi_battery_present_prev(battery) battery->flags.battery_present_prev
+#define acpi_battery_alarm_present(battery) battery->flags.alarm_present
+#define acpi_battery_init_update_flag(battery) battery->flags.init_update
+#define acpi_battery_info_update_flag(battery) battery->flags.info_update
+#define acpi_battery_state_update_flag(battery) battery->flags.state_update
+#define acpi_battery_alarm_update_flag(battery) battery->flags.alarm_update
+#define acpi_battery_power_units(battery) battery->flags.power_unit ? \
+		ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS
+#define acpi_battery_handle(battery) battery->device->handle
+#define acpi_battery_inserted(battery) (!acpi_battery_present_prev(battery) & acpi_battery_present(battery))
+#define acpi_battery_removed(battery) (acpi_battery_present_prev(battery) & !acpi_battery_present(battery))
+#define acpi_battery_bid(battery) acpi_device_bid(battery->device)
+#define acpi_battery_status_str(battery) acpi_battery_present(battery) ? "present" : "absent"
+
 /* --------------------------------------------------------------------------
                                Battery Management
    -------------------------------------------------------------------------- */
 
-static int
-acpi_battery_get_info(struct acpi_battery *battery,
-		      struct acpi_battery_info **bif)
+static void acpi_battery_mutex_lock(struct acpi_battery *battery)
+{
+	mutex_lock(&battery->mutex);
+}
+
+static void acpi_battery_mutex_unlock(struct acpi_battery *battery)
+{
+	mutex_unlock(&battery->mutex);
+}
+
+static void acpi_battery_check_result(struct acpi_battery *battery, int result)
+{
+	if (!battery)
+		return;
+
+	if (result) {
+		acpi_battery_init_update_flag(battery) = 1;
+	}
+}
+
+static int acpi_battery_extract_package(struct acpi_battery *battery,
+					union acpi_object *package,
+					struct acpi_buffer *format,
+					struct acpi_buffer *data,
+					char *package_name)
+{
+	acpi_status status = AE_OK;
+	struct acpi_buffer data_null = { 0, NULL };
+
+	status = acpi_extract_package(package, format, &data_null);
+	if (status != AE_BUFFER_OVERFLOW) {
+		ACPI_EXCEPTION((AE_INFO, status, "Extracting size %s",
+				package_name));
+		return -ENODEV;
+	}
+
+	if (data_null.length != data->length) {
+		if (data->pointer) {
+			kfree(data->pointer);
+		}
+		data->pointer = kzalloc(data_null.length, GFP_KERNEL);
+		if (!data->pointer) {
+			ACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY, "kzalloc()"));
+			return -ENOMEM;
+		}
+		data->length = data_null.length;
+	}
+
+	status = acpi_extract_package(package, format, data);
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status, "Extracting %s",
+				package_name));
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int acpi_battery_get_status(struct acpi_battery *battery)
+{
+	int result = 0;
+
+	result = acpi_bus_get_status(battery->device);
+	if (result) {
+		ACPI_EXCEPTION((AE_INFO, AE_ERROR, "Evaluating _STA"));
+		return -ENODEV;
+	}
+	return result;
+}
+
+static int acpi_battery_get_info(struct acpi_battery *battery)
 {
 	int result = 0;
 	acpi_status status = 0;
@@ -133,16 +230,18 @@ acpi_battery_get_info(struct acpi_battery *battery,
 	struct acpi_buffer format = { sizeof(ACPI_BATTERY_FORMAT_BIF),
 		ACPI_BATTERY_FORMAT_BIF
 	};
-	struct acpi_buffer data = { 0, NULL };
 	union acpi_object *package = NULL;
+	struct acpi_buffer *data = NULL;
+	struct acpi_battery_info *bif = NULL;
 
+	battery->info_update_time = get_seconds();
 
-	if (!battery || !bif)
-		return -EINVAL;
+	if (!acpi_battery_present(battery))
+		return 0;
 
 	/* Evalute _BIF */
 
-	status = acpi_evaluate_object(battery->device->handle, "_BIF", NULL, &buffer);
+	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BIF", NULL, &buffer);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BIF"));
 		return -ENODEV;
@@ -150,41 +249,29 @@ acpi_battery_get_info(struct acpi_battery *battery,
 
 	package = buffer.pointer;
 
+	data = &battery->bif_data;
+
 	/* Extract Package Data */
 
-	status = acpi_extract_package(package, &format, &data);
-	if (status != AE_BUFFER_OVERFLOW) {
-		ACPI_EXCEPTION((AE_INFO, status, "Extracting _BIF"));
-		result = -ENODEV;
+	result = acpi_battery_extract_package(battery, package, &format, data, "_BIF");
+	if (result)
 		goto end;
-	}
 
-	data.pointer = kzalloc(data.length, GFP_KERNEL);
-	if (!data.pointer) {
-		result = -ENOMEM;
-		goto end;
-	}
+      end:
 
-	status = acpi_extract_package(package, &format, &data);
-	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, status, "Extracting _BIF"));
-		kfree(data.pointer);
-		result = -ENODEV;
-		goto end;
+	if (buffer.pointer) {
+		kfree(buffer.pointer);
 	}
 
-      end:
-	kfree(buffer.pointer);
-
-	if (!result)
-		(*bif) = data.pointer;
+	if (!result) {
+		bif = data->pointer;
+		battery->flags.power_unit = bif->power_unit;
+	}
 
 	return result;
 }
 
-static int
-acpi_battery_get_state(struct acpi_battery *battery,
-			struct acpi_battery_state **bst)
+static int acpi_battery_get_state(struct acpi_battery *battery)
 {
 	int result = 0;
 	acpi_status status = 0;
@@ -192,16 +279,17 @@ acpi_battery_get_state(struct acpi_battery *battery,
 	struct acpi_buffer format = { sizeof(ACPI_BATTERY_FORMAT_BST),
 		ACPI_BATTERY_FORMAT_BST
 	};
-	struct acpi_buffer data = { 0, NULL };
 	union acpi_object *package = NULL;
+	struct acpi_buffer *data = NULL;
 
+	battery->state_update_time = get_seconds();
 
-	if (!battery || !bst)
-		return -EINVAL;
+	if (!acpi_battery_present(battery))
+		return 0;
 
 	/* Evalute _BST */
 
-	status = acpi_evaluate_object(battery->device->handle, "_BST", NULL, &buffer);
+	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BST", NULL, &buffer);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BST"));
 		return -ENODEV;
@@ -209,55 +297,46 @@ acpi_battery_get_state(struct acpi_battery *battery,
 
 	package = buffer.pointer;
 
-	/* Extract Package Data */
+	data = &battery->bst_data;
 
-	status = acpi_extract_package(package, &format, &data);
-	if (status != AE_BUFFER_OVERFLOW) {
-		ACPI_EXCEPTION((AE_INFO, status, "Extracting _BST"));
-		result = -ENODEV;
-		goto end;
-	}
+	/* Extract Package Data */
 
-	data.pointer = kzalloc(data.length, GFP_KERNEL);
-	if (!data.pointer) {
-		result = -ENOMEM;
+	result = acpi_battery_extract_package(battery, package, &format, data, "_BST");
+	if (result)
 		goto end;
-	}
 
-	status = acpi_extract_package(package, &format, &data);
-	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, status, "Extracting _BST"));
-		kfree(data.pointer);
-		result = -ENODEV;
-		goto end;
+      end:
+	if (buffer.pointer) {
+		kfree(buffer.pointer);
 	}
 
-      end:
-	kfree(buffer.pointer);
+	return result;
+}
 
-	if (!result)
-		(*bst) = data.pointer;
+static int acpi_battery_get_alarm(struct acpi_battery *battery)
+{
+	battery->alarm_update_time = get_seconds();
 
-	return result;
+	return 0;
 }
 
-static int
-acpi_battery_set_alarm(struct acpi_battery *battery, unsigned long alarm)
+static int acpi_battery_set_alarm(struct acpi_battery *battery, unsigned long alarm)
 {
 	acpi_status status = 0;
 	union acpi_object arg0 = { ACPI_TYPE_INTEGER };
 	struct acpi_object_list arg_list = { 1, &arg0 };
 
+	battery->alarm_update_time = get_seconds();
 
-	if (!battery)
-		return -EINVAL;
+	if (!acpi_battery_present(battery))
+		return -ENODEV;
 
-	if (!battery->flags.alarm)
+	if (!acpi_battery_alarm_present(battery))
 		return -ENODEV;
 
 	arg0.integer.value = alarm;
 
-	status = acpi_evaluate_object(battery->device->handle, "_BTP", &arg_list, NULL);
+	status = acpi_evaluate_object(acpi_battery_handle(battery), "_BTP", &arg_list, NULL);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
@@ -268,65 +347,110 @@ acpi_battery_set_alarm(struct acpi_battery *battery, unsigned long alarm)
 	return 0;
 }
 
-static int acpi_battery_check(struct acpi_battery *battery)
+static int acpi_battery_init_alarm(struct acpi_battery *battery)
 {
 	int result = 0;
 	acpi_status status = AE_OK;
 	acpi_handle handle = NULL;
-	struct acpi_device *device = NULL;
-	struct acpi_battery_info *bif = NULL;
-
+	struct acpi_battery_info *bif = battery->bif_data.pointer;
+	unsigned long alarm = battery->alarm;
 
-	if (!battery)
-		return -EINVAL;
+	/* See if alarms are supported, and if so, set default */
 
-	device = battery->device;
+	status = acpi_get_handle(acpi_battery_handle(battery), "_BTP", &handle);
+	if (ACPI_SUCCESS(status)) {
+		acpi_battery_alarm_present(battery) = 1;
+		if (!alarm && bif) {
+			alarm = bif->design_capacity_warning;
+		}
+		result = acpi_battery_set_alarm(battery, alarm);
+		if (result)
+			goto end;
+	} else {
+		acpi_battery_alarm_present(battery) = 0;
+	}
 
-	result = acpi_bus_get_status(device);
-	if (result)
-		return result;
+      end:
 
-	/* Insertion? */
+	return result;
+}
 
-	if (!battery->flags.present && device->status.battery_present) {
+static int acpi_battery_init_update(struct acpi_battery *battery)
+{
+	int result = 0;
 
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Battery inserted\n"));
+	result = acpi_battery_get_status(battery);
+	if (result)
+		return result;
 
-		/* Evalute _BIF to get certain static information */
+	acpi_battery_present_prev(battery) = acpi_battery_present(battery);
 
-		result = acpi_battery_get_info(battery, &bif);
+	if (acpi_battery_present(battery)) {
+		result = acpi_battery_get_info(battery);
+		if (result)
+			return result;
+		result = acpi_battery_get_state(battery);
 		if (result)
 			return result;
 
-		battery->flags.power_unit = bif->power_unit;
-		battery->trips.warning = bif->design_capacity_warning;
-		battery->trips.low = bif->design_capacity_low;
-		kfree(bif);
+		acpi_battery_init_alarm(battery);
+	}
+
+	return result;
+}
+
+static int acpi_battery_update(struct acpi_battery *battery,
+			   int update, int *update_result_ptr)
+{
+	int result = 0;
+	int update_result = ACPI_BATTERY_NONE_UPDATE;
 
-		/* See if alarms are supported, and if so, set default */
+	if (!acpi_battery_present(battery)) {
+		update = 1;
+	}
 
-		status = acpi_get_handle(battery->device->handle, "_BTP", &handle);
-		if (ACPI_SUCCESS(status)) {
-			battery->flags.alarm = 1;
-			acpi_battery_set_alarm(battery, battery->trips.warning);
+	if (acpi_battery_init_update_flag(battery)) {
+		result = acpi_battery_init_update(battery);
+		if (result)
+			goto end;;
+		update_result = ACPI_BATTERY_INIT_UPDATE;
+	} else if (update) {
+		result = acpi_battery_get_status(battery);
+		if (result)
+			goto end;;
+		if (acpi_battery_inserted(battery) || acpi_battery_removed(battery)) {
+			result = acpi_battery_init_update(battery);
+			if (result)
+				goto end;;
+			update_result = ACPI_BATTERY_INIT_UPDATE;
+		} else {
+			update_result = ACPI_BATTERY_EASY_UPDATE;
 		}
 	}
 
-	/* Removal? */
+      end:
 
-	else if (battery->flags.present && !device->status.battery_present) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Battery removed\n"));
-	}
+	acpi_battery_init_update_flag(battery) = (result != 0);
 
-	battery->flags.present = device->status.battery_present;
+	*update_result_ptr = update_result;
 
 	return result;
 }
 
-static void acpi_battery_check_present(struct acpi_battery *battery)
+static void acpi_battery_notify_update(struct acpi_battery *battery)
 {
-	if (!battery->flags.present) {
-		acpi_battery_check(battery);
+	acpi_battery_get_status(battery);
+
+	if (acpi_battery_init_update_flag(battery)) {
+		return;
+	}
+
+	if (acpi_battery_inserted(battery) || acpi_battery_removed(battery)) {
+		acpi_battery_init_update_flag(battery) = 1;
+	} else {
+		acpi_battery_info_update_flag(battery) = 1;
+		acpi_battery_state_update_flag(battery) = 1;
+		acpi_battery_alarm_update_flag(battery) = 1;
 	}
 }
 
@@ -335,37 +459,33 @@ static void acpi_battery_check_present(struct acpi_battery *battery)
    -------------------------------------------------------------------------- */
 
 static struct proc_dir_entry *acpi_battery_dir;
-static int acpi_battery_read_info(struct seq_file *seq, void *offset)
+
+static int acpi_battery_read_info_print(struct seq_file *seq, int result)
 {
-	int result = 0;
 	struct acpi_battery *battery = seq->private;
 	struct acpi_battery_info *bif = NULL;
 	char *units = "?";
 
-
-	if (!battery)
+	if (result)
 		goto end;
 
-	acpi_battery_check_present(battery);
-
-	if (battery->flags.present)
+	if (acpi_battery_present(battery))
 		seq_printf(seq, "present:                 yes\n");
 	else {
 		seq_printf(seq, "present:                 no\n");
 		goto end;
 	}
 
-	/* Battery Info (_BIF) */
-
-	result = acpi_battery_get_info(battery, &bif);
-	if (result || !bif) {
-		seq_printf(seq, "ERROR: Unable to read battery information\n");
+	bif = battery->bif_data.pointer;
+	if (!bif) {
+		ACPI_EXCEPTION((AE_INFO, AE_ERROR, "BIF buffer is NULL"));
+		result = -ENODEV;
 		goto end;
 	}
 
-	units =
-	    bif->
-	    power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
+	/* Battery Units */
+
+	units = acpi_battery_power_units(battery);
 
 	if (bif->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "design capacity:         unknown\n");
@@ -396,7 +516,6 @@ static int acpi_battery_read_info(struct seq_file *seq, void *offset)
 	else
 		seq_printf(seq, "design voltage:          %d mV\n",
 			   (u32) bif->design_voltage);
-
 	seq_printf(seq, "design capacity warning: %d %sh\n",
 		   (u32) bif->design_capacity_warning, units);
 	seq_printf(seq, "design capacity low:     %d %sh\n",
@@ -411,9 +530,48 @@ static int acpi_battery_read_info(struct seq_file *seq, void *offset)
 	seq_printf(seq, "OEM info:                %s\n", bif->oem_info);
 
       end:
-	kfree(bif);
 
-	return 0;
+	if (result)
+		seq_printf(seq, "ERROR: Unable to read battery info\n");
+
+	return result;
+}
+
+static int acpi_battery_read_info(struct seq_file *seq, void *offset)
+{
+	struct acpi_battery *battery = seq->private;
+	int result = 0;
+	int update_result = ACPI_BATTERY_NONE_UPDATE;
+	int update = 0;
+
+	acpi_battery_mutex_lock(battery);
+
+	update = (get_seconds() - battery->info_update_time >= update_time);
+	update = (update | acpi_battery_info_update_flag(battery));
+
+	result = acpi_battery_update(battery, update, &update_result);
+	if (result)
+		goto end;
+
+	/* Battery Info (_BIF) */
+
+	if (update_result == ACPI_BATTERY_EASY_UPDATE) {
+		result = acpi_battery_get_info(battery);
+		if (result)
+			goto end;
+	}
+
+      end:
+
+	result = acpi_battery_read_info_print(seq, result);
+
+	acpi_battery_check_result(battery, result);
+
+	acpi_battery_info_update_flag(battery) = result;
+
+	acpi_battery_mutex_unlock(battery);
+
+	return result;
 }
 
 static int acpi_battery_info_open_fs(struct inode *inode, struct file *file)
@@ -421,40 +579,33 @@ static int acpi_battery_info_open_fs(struct inode *inode, struct file *file)
 	return single_open(file, acpi_battery_read_info, PDE(inode)->data);
 }
 
-static int acpi_battery_read_state(struct seq_file *seq, void *offset)
+static int acpi_battery_read_state_print(struct seq_file *seq, int result)
 {
-	int result = 0;
 	struct acpi_battery *battery = seq->private;
 	struct acpi_battery_state *bst = NULL;
 	char *units = "?";
 
-
-	if (!battery)
+	if (result)
 		goto end;
 
-	acpi_battery_check_present(battery);
-
-	if (battery->flags.present)
+	if (acpi_battery_present(battery))
 		seq_printf(seq, "present:                 yes\n");
 	else {
 		seq_printf(seq, "present:                 no\n");
 		goto end;
 	}
 
-	/* Battery Units */
-
-	units =
-	    battery->flags.
-	    power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
-
-	/* Battery Status (_BST) */
-
-	result = acpi_battery_get_state(battery, &bst);
-	if (result || !bst) {
-		seq_printf(seq, "ERROR: Unable to read battery state\n");
+	bst = battery->bst_data.pointer;
+	if (!bst) {
+		ACPI_EXCEPTION((AE_INFO, AE_ERROR, "BST buffer is NULL"));
+		result = -ENODEV;
 		goto end;
 	}
 
+	/* Battery Units */
+
+	units = acpi_battery_power_units(battery);
+
 	if (!(bst->state & 0x04))
 		seq_printf(seq, "capacity state:          ok\n");
 	else
@@ -490,9 +641,49 @@ static int acpi_battery_read_state(struct seq_file *seq, void *offset)
 			   (u32) bst->present_voltage);
 
       end:
-	kfree(bst);
 
-	return 0;
+	if (result) {
+		seq_printf(seq, "ERROR: Unable to read battery state\n");
+	}
+
+	return result;
+}
+
+static int acpi_battery_read_state(struct seq_file *seq, void *offset)
+{
+	struct acpi_battery *battery = seq->private;
+	int result = 0;
+	int update_result = ACPI_BATTERY_NONE_UPDATE;
+	int update = 0;
+
+	acpi_battery_mutex_lock(battery);
+
+	update = (get_seconds() - battery->state_update_time >= update_time);
+	update = (update | acpi_battery_state_update_flag(battery));
+
+	result = acpi_battery_update(battery, update, &update_result);
+	if (result)
+		goto end;
+
+	/* Battery State (_BST) */
+
+	if (update_result == ACPI_BATTERY_EASY_UPDATE) {
+		result = acpi_battery_get_state(battery);
+		if (result)
+			goto end;
+	}
+
+      end:
+
+	result = acpi_battery_read_state_print(seq, result);
+
+	acpi_battery_check_result(battery, result);
+
+	acpi_battery_state_update_flag(battery) = result;
+
+	acpi_battery_mutex_unlock(battery);
+
+	return result;
 }
 
 static int acpi_battery_state_open_fs(struct inode *inode, struct file *file)
@@ -500,38 +691,72 @@ static int acpi_battery_state_open_fs(struct inode *inode, struct file *file)
 	return single_open(file, acpi_battery_read_state, PDE(inode)->data);
 }
 
-static int acpi_battery_read_alarm(struct seq_file *seq, void *offset)
+static int acpi_battery_read_alarm_print(struct seq_file *seq, int result)
 {
 	struct acpi_battery *battery = seq->private;
 	char *units = "?";
 
-
-	if (!battery)
+	if (result)
 		goto end;
 
-	acpi_battery_check_present(battery);
-
-	if (!battery->flags.present) {
+	if (!acpi_battery_present(battery)) {
 		seq_printf(seq, "present:                 no\n");
 		goto end;
 	}
 
 	/* Battery Units */
 
-	units =
-	    battery->flags.
-	    power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
-
-	/* Battery Alarm */
+	units = acpi_battery_power_units(battery);
 
 	seq_printf(seq, "alarm:                   ");
 	if (!battery->alarm)
 		seq_printf(seq, "unsupported\n");
 	else
-		seq_printf(seq, "%d %sh\n", (u32) battery->alarm, units);
+		seq_printf(seq, "%lu %sh\n", battery->alarm, units);
 
       end:
-	return 0;
+
+	if (result)
+		seq_printf(seq, "ERROR: Unable to read battery alarm\n");
+
+	return result;
+}
+
+static int acpi_battery_read_alarm(struct seq_file *seq, void *offset)
+{
+	struct acpi_battery *battery = seq->private;
+	int result = 0;
+	int update_result = ACPI_BATTERY_NONE_UPDATE;
+	int update = 0;
+
+	acpi_battery_mutex_lock(battery);
+
+	update = (get_seconds() - battery->alarm_update_time >= update_time);
+	update = (update | acpi_battery_alarm_update_flag(battery));
+
+	result = acpi_battery_update(battery, update, &update_result);
+	if (result)
+		goto end;
+
+	/* Battery Alarm */
+
+	if (update_result == ACPI_BATTERY_EASY_UPDATE) {
+		result = acpi_battery_get_alarm(battery);
+		if (result)
+			goto end;
+	}
+
+      end:
+
+	result = acpi_battery_read_alarm_print(seq, result);
+
+	acpi_battery_check_result(battery, result);
+
+	acpi_battery_alarm_update_flag(battery) = result;
+
+	acpi_battery_mutex_unlock(battery);
+
+	return result;
 }
 
 static ssize_t
@@ -543,27 +768,47 @@ acpi_battery_write_alarm(struct file *file,
 	char alarm_string[12] = { '\0' };
 	struct seq_file *m = file->private_data;
 	struct acpi_battery *battery = m->private;
+	int update_result = ACPI_BATTERY_NONE_UPDATE;
 
 
 	if (!battery || (count > sizeof(alarm_string) - 1))
 		return -EINVAL;
 
-	acpi_battery_check_present(battery);
+	acpi_battery_mutex_lock(battery);
 
-	if (!battery->flags.present)
-		return -ENODEV;
+	result = acpi_battery_update(battery, 1, &update_result);
+	if (result) {
+		result = -ENODEV;
+		goto end;
+	}
 
-	if (copy_from_user(alarm_string, buffer, count))
-		return -EFAULT;
+	if (!acpi_battery_present(battery)) {
+		result = -ENODEV;
+		goto end;
+	}
+
+	if (copy_from_user(alarm_string, buffer, count)) {
+		result = -EFAULT;
+		goto end;
+	}
 
 	alarm_string[count] = '\0';
 
 	result = acpi_battery_set_alarm(battery,
 					simple_strtoul(alarm_string, NULL, 0));
 	if (result)
-		return result;
+		goto end;
+
+      end:
+
+	acpi_battery_check_result(battery, result);
 
-	return count;
+	if (!result)
+		result = count;
+
+	acpi_battery_mutex_unlock(battery);
+
+	return result;
 }
 
 static int acpi_battery_alarm_open_fs(struct inode *inode, struct file *file)
@@ -648,7 +893,6 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 
 static int acpi_battery_remove_fs(struct acpi_device *device)
 {
-
 	if (acpi_device_dir(device)) {
 		remove_proc_entry(ACPI_BATTERY_FILE_ALARM,
 				  acpi_device_dir(device));
@@ -684,8 +928,11 @@ static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 	case ACPI_BATTERY_NOTIFY_INFO:
 	case ACPI_NOTIFY_BUS_CHECK:
 	case ACPI_NOTIFY_DEVICE_CHECK:
-		acpi_battery_check(battery);
-		acpi_bus_generate_event(device, event, battery->flags.present);
+		acpi_battery_mutex_lock(battery);
+		device = battery->device;
+		acpi_battery_notify_update(battery);
+		acpi_battery_mutex_unlock(battery);
+		acpi_bus_generate_event(device, event, acpi_battery_present(battery));
 		break;
 	default:
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
@@ -702,7 +949,6 @@ static int acpi_battery_add(struct acpi_device *device)
 	acpi_status status = 0;
 	struct acpi_battery *battery = NULL;
 
-
 	if (!device)
 		return -EINVAL;
 
@@ -710,15 +956,21 @@ static int acpi_battery_add(struct acpi_device *device)
 	if (!battery)
 		return -ENOMEM;
 
+	mutex_init(&battery->mutex);
+
+	acpi_battery_mutex_lock(battery);
+
 	battery->device = device;
 	strcpy(acpi_device_name(device), ACPI_BATTERY_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_BATTERY_CLASS);
 	acpi_driver_data(device) = battery;
 
-	result = acpi_battery_check(battery);
+	result = acpi_battery_get_status(battery);
 	if (result)
 		goto end;
 
+	acpi_battery_init_update_flag(battery) = 1;
+
 	result = acpi_battery_add_fs(device);
 	if (result)
 		goto end;
@@ -727,6 +979,7 @@ static int acpi_battery_add(struct acpi_device *device)
 					     ACPI_ALL_NOTIFY,
 					     acpi_battery_notify, battery);
 	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status, "Installing notify handler"));
 		result = -ENODEV;
 		goto end;
 	}
@@ -736,11 +989,14 @@ static int acpi_battery_add(struct acpi_device *device)
 	       device->status.battery_present ? "present" : "absent");
 
       end:
+
 	if (result) {
 		acpi_battery_remove_fs(device);
 		kfree(battery);
 	}
 
+	acpi_battery_mutex_unlock(battery);
+
 	return result;
 }
 
@@ -749,18 +1005,29 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 	acpi_status status = 0;
 	struct acpi_battery *battery = NULL;
 
-
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
 
 	battery = acpi_driver_data(device);
 
+	acpi_battery_mutex_lock(battery);
+
 	status = acpi_remove_notify_handler(device->handle,
 					    ACPI_ALL_NOTIFY,
 					    acpi_battery_notify);
 
 	acpi_battery_remove_fs(device);
 
+	if (battery->bif_data.pointer)
+		kfree(battery->bif_data.pointer);
+
+	if (battery->bst_data.pointer)
+		kfree(battery->bst_data.pointer);
+
+	acpi_battery_mutex_unlock(battery);
+
+	mutex_destroy(&battery->mutex);
+
 	kfree(battery);
 
 	return 0;
@@ -775,7 +1042,10 @@ static int acpi_battery_resume(struct acpi_device *device)
 		return -EINVAL;
 
 	battery = device->driver_data;
-	return acpi_battery_check(battery);
+
+	acpi_battery_init_update_flag(battery) = 1;
+
+	return 0;
 }
 
 static int __init acpi_battery_init(void)
@@ -800,7 +1070,6 @@ static int __init acpi_battery_init(void)
 
 static void __exit acpi_battery_exit(void)
 {
-
 	acpi_bus_unregister_driver(&acpi_battery_driver);
 
 	acpi_unlock_battery_dir(acpi_battery_dir);

commit a1f0eff21edac1bd87e397f56c4258b9611b5a50
Author: Vladimir Lebedev <vladimir.p.lebedev@intel.com>
Date:   Tue Feb 20 15:48:06 2007 +0300

    ACPI: battery: make internal names consistent with battery "state"
    
    Cleanup -- No functional changes.
    
    Battery state is currently exported in a proc "state" file.
    Update associated #defines and routines to be consistent.
    
    Signed-off-by: Vladimir Lebedev <vladimir.p.lebedev@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index e64c76c8b726..df04f87dd491 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -44,7 +44,7 @@
 #define ACPI_BATTERY_HID		"PNP0C0A"
 #define ACPI_BATTERY_DEVICE_NAME	"Battery"
 #define ACPI_BATTERY_FILE_INFO		"info"
-#define ACPI_BATTERY_FILE_STATUS	"state"
+#define ACPI_BATTERY_FILE_STATE		"state"
 #define ACPI_BATTERY_FILE_ALARM		"alarm"
 #define ACPI_BATTERY_NOTIFY_STATUS	0x80
 #define ACPI_BATTERY_NOTIFY_INFO	0x81
@@ -76,7 +76,7 @@ static struct acpi_driver acpi_battery_driver = {
 		},
 };
 
-struct acpi_battery_status {
+struct acpi_battery_state {
 	acpi_integer state;
 	acpi_integer present_rate;
 	acpi_integer remaining_capacity;
@@ -183,8 +183,8 @@ acpi_battery_get_info(struct acpi_battery *battery,
 }
 
 static int
-acpi_battery_get_status(struct acpi_battery *battery,
-			struct acpi_battery_status **bst)
+acpi_battery_get_state(struct acpi_battery *battery,
+			struct acpi_battery_state **bst)
 {
 	int result = 0;
 	acpi_status status = 0;
@@ -425,7 +425,7 @@ static int acpi_battery_read_state(struct seq_file *seq, void *offset)
 {
 	int result = 0;
 	struct acpi_battery *battery = seq->private;
-	struct acpi_battery_status *bst = NULL;
+	struct acpi_battery_state *bst = NULL;
 	char *units = "?";
 
 
@@ -449,9 +449,9 @@ static int acpi_battery_read_state(struct seq_file *seq, void *offset)
 
 	/* Battery Status (_BST) */
 
-	result = acpi_battery_get_status(battery, &bst);
+	result = acpi_battery_get_state(battery, &bst);
 	if (result || !bst) {
-		seq_printf(seq, "ERROR: Unable to read battery status\n");
+		seq_printf(seq, "ERROR: Unable to read battery state\n");
 		goto end;
 	}
 
@@ -621,7 +621,7 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 	}
 
 	/* 'status' [R] */
-	entry = create_proc_entry(ACPI_BATTERY_FILE_STATUS,
+	entry = create_proc_entry(ACPI_BATTERY_FILE_STATE,
 				  S_IRUGO, acpi_device_dir(device));
 	if (!entry)
 		return -ENODEV;
@@ -652,7 +652,7 @@ static int acpi_battery_remove_fs(struct acpi_device *device)
 	if (acpi_device_dir(device)) {
 		remove_proc_entry(ACPI_BATTERY_FILE_ALARM,
 				  acpi_device_dir(device));
-		remove_proc_entry(ACPI_BATTERY_FILE_STATUS,
+		remove_proc_entry(ACPI_BATTERY_FILE_STATE,
 				  acpi_device_dir(device));
 		remove_proc_entry(ACPI_BATTERY_FILE_INFO,
 				  acpi_device_dir(device));

commit 4559b438225b01942e1661759db0df55883b1bc0
Merge: 1004879f25c5 4bd35cdb1e2d
Author: Len Brown <len.brown@intel.com>
Date:   Fri Feb 16 22:11:37 2007 -0500

    Pull bugzilla-7200 into release branch

commit 7cda93e008e1a477970adbf82dba81a5d4f0ae40
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 23:50:02 2007 -0500

    ACPI: delete extra #defines in /drivers/acpi/ drivers
    
    Cosmetic only.
    
    Except in a single case, #define ACPI_*_DRIVER_NAME
    were invoked 0 or 1 times.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index da29d9d61c34..02de49ef1bce 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -42,7 +42,6 @@
 #define ACPI_BATTERY_COMPONENT		0x00040000
 #define ACPI_BATTERY_CLASS		"battery"
 #define ACPI_BATTERY_HID		"PNP0C0A"
-#define ACPI_BATTERY_DRIVER_NAME	"ACPI Battery Driver"
 #define ACPI_BATTERY_DEVICE_NAME	"Battery"
 #define ACPI_BATTERY_FILE_INFO		"info"
 #define ACPI_BATTERY_FILE_STATUS	"state"
@@ -56,7 +55,7 @@
 ACPI_MODULE_NAME("battery");
 
 MODULE_AUTHOR("Paul Diefenbaugh");
-MODULE_DESCRIPTION(ACPI_BATTERY_DRIVER_NAME);
+MODULE_DESCRIPTION("ACPI Battery Driver");
 MODULE_LICENSE("GPL");
 
 extern struct proc_dir_entry *acpi_lock_battery_dir(void);

commit c2b6705b75d9c7aff98a4602a32230639e10891c
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 23:33:40 2007 -0500

    ACPI: fix acpi_driver.name usage
    
    It was erroneously used as a description rather than a name.
    
    ie. turn this:
    
    lenb@se7525gp2:/sys> ls bus/acpi/drivers
    ACPI AC Adapter Driver  ACPI Embedded Controller Driver  ACPI Power Resource Driver
    ACPI Battery Driver     ACPI Fan Driver                  ACPI Processor Driver
    ACPI Button Driver      ACPI PCI Interrupt Link Driver   ACPI Thermal Zone Driver
    ACPI container driver   ACPI PCI Root Bridge Driver      hpet
    
    into this:
    
    lenb@se7525gp2:~> ls /sys/bus/acpi/drivers
    ac  battery  button  container  ec  fan  hpet  pci_link  pci_root  power  processor  thermal
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 4b8db56721c3..da29d9d61c34 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -67,7 +67,7 @@ static int acpi_battery_remove(struct acpi_device *device, int type);
 static int acpi_battery_resume(struct acpi_device *device);
 
 static struct acpi_driver acpi_battery_driver = {
-	.name = ACPI_BATTERY_DRIVER_NAME,
+	.name = "battery",
 	.class = ACPI_BATTERY_CLASS,
 	.ids = ACPI_BATTERY_HID,
 	.ops = {

commit f52fd66d2ea794010c2d7536cf8e6abed0ac4947
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 22:42:12 2007 -0500

    ACPI: clean up ACPI_MODULE_NAME() use
    
    cosmetic only
    
    Make "module name" actually match the file name.
    Invoke with ';' as leaving it off confuses Lindent and gcc doesn't care.
    Fix indentation where Lindent did get confused.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 2f4521a48fe7..4b8db56721c3 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -53,9 +53,9 @@
 #define ACPI_BATTERY_UNITS_AMPS		"mA"
 
 #define _COMPONENT		ACPI_BATTERY_COMPONENT
-ACPI_MODULE_NAME("acpi_battery")
+ACPI_MODULE_NAME("battery");
 
-    MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_AUTHOR("Paul Diefenbaugh");
 MODULE_DESCRIPTION(ACPI_BATTERY_DRIVER_NAME);
 MODULE_LICENSE("GPL");
 

commit 4bd35cdb1e2d1a1bbbe4b75132718e79b80519ab
Author: Vladimir Lebedev <vladimir.p.lebedev@intel.com>
Date:   Sat Feb 10 01:43:48 2007 -0500

    ACPI: battery: check for battery present on /proc/battery access
    
    http://bugzilla.kernel.org/show_bug.cgi?id=7200
    
    Signed-off-by: Vladimir Lebedev <vladimir.p.lebedev@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 2f4521a48fe7..0d7a32e502d1 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -324,6 +324,13 @@ static int acpi_battery_check(struct acpi_battery *battery)
 	return result;
 }
 
+static void acpi_battery_check_present(struct acpi_battery *battery)
+{
+	if (!battery->flags.present) {
+		acpi_battery_check(battery);
+	}
+}
+
 /* --------------------------------------------------------------------------
                               FS Interface (/proc)
    -------------------------------------------------------------------------- */
@@ -340,6 +347,8 @@ static int acpi_battery_read_info(struct seq_file *seq, void *offset)
 	if (!battery)
 		goto end;
 
+	acpi_battery_check_present(battery);
+
 	if (battery->flags.present)
 		seq_printf(seq, "present:                 yes\n");
 	else {
@@ -424,6 +433,8 @@ static int acpi_battery_read_state(struct seq_file *seq, void *offset)
 	if (!battery)
 		goto end;
 
+	acpi_battery_check_present(battery);
+
 	if (battery->flags.present)
 		seq_printf(seq, "present:                 yes\n");
 	else {
@@ -499,6 +510,8 @@ static int acpi_battery_read_alarm(struct seq_file *seq, void *offset)
 	if (!battery)
 		goto end;
 
+	acpi_battery_check_present(battery);
+
 	if (!battery->flags.present) {
 		seq_printf(seq, "present:                 no\n");
 		goto end;
@@ -536,6 +549,8 @@ acpi_battery_write_alarm(struct file *file,
 	if (!battery || (count > sizeof(alarm_string) - 1))
 		return -EINVAL;
 
+	acpi_battery_check_present(battery);
+
 	if (!battery->flags.present)
 		return -ENODEV;
 

commit 975a8e3ed2b9eab9f062a1e0ba7fe180e15204e1
Merge: 1fcb71b84b05 bfd80223d73f
Author: Len Brown <len.brown@intel.com>
Date:   Sat Feb 3 01:14:35 2007 -0500

    Pull sysfs into test branch
    
    Conflicts:
    
            Documentation/feature-removal-schedule.txt
            include/acpi/acpi_drivers.h
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 36bcbec7ce21e2e8b3143b11a05747330abeca70
Author: Burman Yan <yan_952@hotmail.com>
Date:   Tue Dec 19 12:56:11 2006 -0800

    ACPI: replace kmalloc+memset with kzalloc
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index f47c78a10656..5f43e0d14899 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -160,12 +160,11 @@ acpi_battery_get_info(struct acpi_battery *battery,
 		goto end;
 	}
 
-	data.pointer = kmalloc(data.length, GFP_KERNEL);
+	data.pointer = kzalloc(data.length, GFP_KERNEL);
 	if (!data.pointer) {
 		result = -ENOMEM;
 		goto end;
 	}
-	memset(data.pointer, 0, data.length);
 
 	status = acpi_extract_package(package, &format, &data);
 	if (ACPI_FAILURE(status)) {
@@ -220,12 +219,11 @@ acpi_battery_get_status(struct acpi_battery *battery,
 		goto end;
 	}
 
-	data.pointer = kmalloc(data.length, GFP_KERNEL);
+	data.pointer = kzalloc(data.length, GFP_KERNEL);
 	if (!data.pointer) {
 		result = -ENOMEM;
 		goto end;
 	}
-	memset(data.pointer, 0, data.length);
 
 	status = acpi_extract_package(package, &format, &data);
 	if (ACPI_FAILURE(status)) {
@@ -694,10 +692,9 @@ static int acpi_battery_add(struct acpi_device *device)
 	if (!device)
 		return -EINVAL;
 
-	battery = kmalloc(sizeof(struct acpi_battery), GFP_KERNEL);
+	battery = kzalloc(sizeof(struct acpi_battery), GFP_KERNEL);
 	if (!battery)
 		return -ENOMEM;
-	memset(battery, 0, sizeof(struct acpi_battery));
 
 	battery->device = device;
 	strcpy(acpi_device_name(device), ACPI_BATTERY_DEVICE_NAME);

commit cece901481bafbf14de8cbd3a89ae869ea881055
Merge: cfee47f99bc1 50dd096973f1
Author: Len Brown <len.brown@intel.com>
Date:   Sat Dec 16 01:04:27 2006 -0500

    Pull style into test branch
    
    Conflicts:
    
            drivers/acpi/button.c
            drivers/acpi/ec.c
            drivers/acpi/osl.c
            drivers/acpi/sbs.c

commit 5d9464a46918ced087c351a10f38cee95725f85b
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Thu Dec 7 20:56:27 2006 +0800

    ACPI: add ACPI bus_type for driver model
    
    Add ACPI bus_type for Linux driver model.
    
    1.      .shutdown method is added into acpi_driver.ops
            needed by bus_type operations.
    2.      remove useless parameter 'int state' in .resume method.
    3.      change parameter 'int state'
            to 'pm_message_t state' in .suspend method.
    
    Note:   The new .uevent method mark ACPI drivers by PNPID instead of by name.
            Udev script needs to look for "HWID=" or "COMPTID=" to load
            ACPI drivers as a result.
    
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 026e40755cdd..07c3c276ad34 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -64,7 +64,7 @@ extern void *acpi_unlock_battery_dir(struct proc_dir_entry *acpi_battery_dir);
 
 static int acpi_battery_add(struct acpi_device *device);
 static int acpi_battery_remove(struct acpi_device *device, int type);
-static int acpi_battery_resume(struct acpi_device *device, int status);
+static int acpi_battery_resume(struct acpi_device *device);
 
 static struct acpi_driver acpi_battery_driver = {
 	.name = ACPI_BATTERY_DRIVER_NAME,
@@ -756,7 +756,7 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 }
 
 /* this is needed to learn about changes made in suspended state */
-static int acpi_battery_resume(struct acpi_device *device, int state)
+static int acpi_battery_resume(struct acpi_device *device)
 {
 	struct acpi_battery *battery;
 

commit 34c4415ab857dc6d51db08d62bcd45d4b8513bb6
Author: Jiri Kosina <jikos@jikos.cz>
Date:   Tue Oct 10 14:20:41 2006 -0700

    ACPI: check battery status on resume for un/plug events during sleep
    
    Add ->resume method to the ACPI battery handler to check
    if the battery state has changed during sleep.
    If yes, update the ACPI internal data structures
    for benefit of /proc/acpi/battery/.
    
    Signed-off-by: Jiri Kosina <jikos@jikos.cz>
    Cc: Stefan Seyfried <seife@suse.de>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 9810e2a55d0a..026e40755cdd 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -64,6 +64,7 @@ extern void *acpi_unlock_battery_dir(struct proc_dir_entry *acpi_battery_dir);
 
 static int acpi_battery_add(struct acpi_device *device);
 static int acpi_battery_remove(struct acpi_device *device, int type);
+static int acpi_battery_resume(struct acpi_device *device, int status);
 
 static struct acpi_driver acpi_battery_driver = {
 	.name = ACPI_BATTERY_DRIVER_NAME,
@@ -71,6 +72,7 @@ static struct acpi_driver acpi_battery_driver = {
 	.ids = ACPI_BATTERY_HID,
 	.ops = {
 		.add = acpi_battery_add,
+		.resume = acpi_battery_resume,
 		.remove = acpi_battery_remove,
 		},
 };
@@ -753,6 +755,18 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 	return 0;
 }
 
+/* this is needed to learn about changes made in suspended state */
+static int acpi_battery_resume(struct acpi_device *device, int state)
+{
+	struct acpi_battery *battery;
+
+	if (!device)
+		return -EINVAL;
+
+	battery = device->driver_data;
+	return acpi_battery_check(battery);
+}
+
 static int __init acpi_battery_init(void)
 {
 	int result;

commit 50dd096973f1d95aa03c6a6d9e148d706b62b68e
Author: Jan Engelhardt <jengelh@linux01.gwdg.de>
Date:   Sun Oct 1 00:28:50 2006 +0200

    ACPI: Remove unnecessary from/to-void* and to-void casts in drivers/acpi
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 9810e2a55d0a..adb0d2725731 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -147,7 +147,7 @@ acpi_battery_get_info(struct acpi_battery *battery,
 		return -ENODEV;
 	}
 
-	package = (union acpi_object *)buffer.pointer;
+	package = buffer.pointer;
 
 	/* Extract Package Data */
 
@@ -177,7 +177,7 @@ acpi_battery_get_info(struct acpi_battery *battery,
 	kfree(buffer.pointer);
 
 	if (!result)
-		(*bif) = (struct acpi_battery_info *)data.pointer;
+		(*bif) = data.pointer;
 
 	return result;
 }
@@ -207,7 +207,7 @@ acpi_battery_get_status(struct acpi_battery *battery,
 		return -ENODEV;
 	}
 
-	package = (union acpi_object *)buffer.pointer;
+	package = buffer.pointer;
 
 	/* Extract Package Data */
 
@@ -237,7 +237,7 @@ acpi_battery_get_status(struct acpi_battery *battery,
 	kfree(buffer.pointer);
 
 	if (!result)
-		(*bst) = (struct acpi_battery_status *)data.pointer;
+		(*bst) = data.pointer;
 
 	return result;
 }
@@ -332,7 +332,7 @@ static struct proc_dir_entry *acpi_battery_dir;
 static int acpi_battery_read_info(struct seq_file *seq, void *offset)
 {
 	int result = 0;
-	struct acpi_battery *battery = (struct acpi_battery *)seq->private;
+	struct acpi_battery *battery = seq->private;
 	struct acpi_battery_info *bif = NULL;
 	char *units = "?";
 
@@ -416,7 +416,7 @@ static int acpi_battery_info_open_fs(struct inode *inode, struct file *file)
 static int acpi_battery_read_state(struct seq_file *seq, void *offset)
 {
 	int result = 0;
-	struct acpi_battery *battery = (struct acpi_battery *)seq->private;
+	struct acpi_battery *battery = seq->private;
 	struct acpi_battery_status *bst = NULL;
 	char *units = "?";
 
@@ -492,7 +492,7 @@ static int acpi_battery_state_open_fs(struct inode *inode, struct file *file)
 
 static int acpi_battery_read_alarm(struct seq_file *seq, void *offset)
 {
-	struct acpi_battery *battery = (struct acpi_battery *)seq->private;
+	struct acpi_battery *battery = seq->private;
 	char *units = "?";
 
 
@@ -529,8 +529,8 @@ acpi_battery_write_alarm(struct file *file,
 {
 	int result = 0;
 	char alarm_string[12] = { '\0' };
-	struct seq_file *m = (struct seq_file *)file->private_data;
-	struct acpi_battery *battery = (struct acpi_battery *)m->private;
+	struct seq_file *m = file->private_data;
+	struct acpi_battery *battery = m->private;
 
 
 	if (!battery || (count > sizeof(alarm_string) - 1))
@@ -656,7 +656,7 @@ static int acpi_battery_remove_fs(struct acpi_device *device)
 
 static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 {
-	struct acpi_battery *battery = (struct acpi_battery *)data;
+	struct acpi_battery *battery = data;
 	struct acpi_device *device = NULL;
 
 
@@ -740,7 +740,7 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
 
-	battery = (struct acpi_battery *)acpi_driver_data(device);
+	battery = acpi_driver_data(device);
 
 	status = acpi_remove_notify_handler(device->handle,
 					    ACPI_ALL_NOTIFY,

commit 4d8316d5ea4dcf0bf15d8a06d539ed7c99e9cfbe
Author: Pavel Machek <pavel@ucw.cz>
Date:   Mon Aug 14 22:37:22 2006 -0700

    ACPI: fix boot with acpi=off
    
    Fix acpi_ac/battery boot with acpi=off
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 6e5221707d97..9810e2a55d0a 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -757,6 +757,9 @@ static int __init acpi_battery_init(void)
 {
 	int result;
 
+	if (acpi_disabled)
+		return -ENODEV;
+
 	acpi_battery_dir = acpi_lock_battery_dir();
 	if (!acpi_battery_dir)
 		return -ENODEV;

commit d75080328affb4b268da430b7074cc8139cc662a
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Tue Jul 4 13:06:00 2006 -0400

    ACPI: add 'const' to several ACPI file_operations
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 24bf4dca88cc..6e5221707d97 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -557,7 +557,7 @@ static int acpi_battery_alarm_open_fs(struct inode *inode, struct file *file)
 	return single_open(file, acpi_battery_read_alarm, PDE(inode)->data);
 }
 
-static struct file_operations acpi_battery_info_ops = {
+static const struct file_operations acpi_battery_info_ops = {
 	.open = acpi_battery_info_open_fs,
 	.read = seq_read,
 	.llseek = seq_lseek,
@@ -565,7 +565,7 @@ static struct file_operations acpi_battery_info_ops = {
 	.owner = THIS_MODULE,
 };
 
-static struct file_operations acpi_battery_state_ops = {
+static const struct file_operations acpi_battery_state_ops = {
 	.open = acpi_battery_state_open_fs,
 	.read = seq_read,
 	.llseek = seq_lseek,
@@ -573,7 +573,7 @@ static struct file_operations acpi_battery_state_ops = {
 	.owner = THIS_MODULE,
 };
 
-static struct file_operations acpi_battery_alarm_ops = {
+static const struct file_operations acpi_battery_alarm_ops = {
 	.open = acpi_battery_alarm_open_fs,
 	.read = seq_read,
 	.write = acpi_battery_write_alarm,

commit 309b0f125a22ee34c8f6962677255f7bf6af5e3d
Merge: d0e5f39f1ee2 635227ee8992
Author: Len Brown <len.brown@intel.com>
Date:   Sat Jul 1 17:21:39 2006 -0400

    Pull smart-battery into release branch

commit 3f86b83243d59bb50caf5938d284d22e10d082a4
Author: Rich Townsend <rhdt@bartol.udel.edu>
Date:   Sat Jul 1 11:36:54 2006 -0400

    ACPI: add support for Smart Battery
    
    Most batteries today are ACPI "Control Method" batteries,
    but some models ship with the older "Smart Battery"
    that requires this code.
    
    Rich Townsend and Bruno Ducrot were the original authors.
    Vladimir Lebedev updated to run on latest kernel.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=3734
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 2b8aab560b58..3ea79decfe24 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -59,6 +59,9 @@ ACPI_MODULE_NAME("acpi_battery")
 MODULE_DESCRIPTION(ACPI_BATTERY_DRIVER_NAME);
 MODULE_LICENSE("GPL");
 
+extern struct proc_dir_entry *acpi_lock_battery_dir(void);
+extern void *acpi_unlock_battery_dir(struct proc_dir_entry *acpi_battery_dir);
+
 static int acpi_battery_add(struct acpi_device *device);
 static int acpi_battery_remove(struct acpi_device *device, int type);
 
@@ -750,17 +753,15 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 
 static int __init acpi_battery_init(void)
 {
-	int result = 0;
-
+	int result;
 
-	acpi_battery_dir = proc_mkdir(ACPI_BATTERY_CLASS, acpi_root_dir);
+	acpi_battery_dir = acpi_lock_battery_dir();
 	if (!acpi_battery_dir)
 		return -ENODEV;
-	acpi_battery_dir->owner = THIS_MODULE;
 
 	result = acpi_bus_register_driver(&acpi_battery_driver);
 	if (result < 0) {
-		remove_proc_entry(ACPI_BATTERY_CLASS, acpi_root_dir);
+		acpi_unlock_battery_dir(acpi_battery_dir);
 		return -ENODEV;
 	}
 
@@ -772,7 +773,7 @@ static void __exit acpi_battery_exit(void)
 
 	acpi_bus_unregister_driver(&acpi_battery_driver);
 
-	remove_proc_entry(ACPI_BATTERY_CLASS, acpi_root_dir);
+	acpi_unlock_battery_dir(acpi_battery_dir);
 
 	return;
 }

commit 9fdae727645215d4dbb88912b9a176ef87911a05
Author: Vladimir Lebedev <vladimir.p.lebedev@intel.com>
Date:   Tue Jun 27 04:49:00 2006 -0400

    ACPI: handle battery notify event on broken BIOS
    
    http://bugzilla.kernel.org/show_bug.cgi?id=3241
    
    Signed-off-by: Vladimir Lebedev <vladimir.p.lebedev@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 2b8aab560b58..a192d2b47cc8 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -665,6 +665,8 @@ static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 	switch (event) {
 	case ACPI_BATTERY_NOTIFY_STATUS:
 	case ACPI_BATTERY_NOTIFY_INFO:
+	case ACPI_NOTIFY_BUS_CHECK:
+	case ACPI_NOTIFY_DEVICE_CHECK:
 		acpi_battery_check(battery);
 		acpi_bus_generate_event(device, event, battery->flags.present);
 		break;
@@ -706,7 +708,7 @@ static int acpi_battery_add(struct acpi_device *device)
 		goto end;
 
 	status = acpi_install_notify_handler(device->handle,
-					     ACPI_DEVICE_NOTIFY,
+					     ACPI_ALL_NOTIFY,
 					     acpi_battery_notify, battery);
 	if (ACPI_FAILURE(status)) {
 		result = -ENODEV;
@@ -738,7 +740,7 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 	battery = (struct acpi_battery *)acpi_driver_data(device);
 
 	status = acpi_remove_notify_handler(device->handle,
-					    ACPI_DEVICE_NOTIFY,
+					    ACPI_ALL_NOTIFY,
 					    acpi_battery_notify);
 
 	acpi_battery_remove_fs(device);

commit b2f71bade430d468398167d696731bf770de2db8
Merge: ba290ab7dace d07a8577f695
Author: Len Brown <len.brown@intel.com>
Date:   Sat Jul 1 11:05:19 2006 -0400

    Pull acpi_device_handle_cleanup into release branch

commit 02438d8771ae6a4b215938959827692026380bf9
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jun 30 03:19:10 2006 -0400

    ACPI: delete acpi_os_free(), use kfree() directly
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 00b0728efe82..7d92f73b265f 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -171,7 +171,7 @@ acpi_battery_get_info(struct acpi_battery *battery,
 	}
 
       end:
-	acpi_os_free(buffer.pointer);
+	kfree(buffer.pointer);
 
 	if (!result)
 		(*bif) = (struct acpi_battery_info *)data.pointer;
@@ -231,7 +231,7 @@ acpi_battery_get_status(struct acpi_battery *battery,
 	}
 
       end:
-	acpi_os_free(buffer.pointer);
+	kfree(buffer.pointer);
 
 	if (!result)
 		(*bst) = (struct acpi_battery_status *)data.pointer;

commit 39cb61e26771891f843cb433ee6febd9159bce73
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Fri May 19 16:54:49 2006 -0400

    ACPI: battery: Remove unneeded acpi_handle from driver.
    
    Signed-off-by: Patrick Mochel <mochel@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 5de735ffc3e6..6ce93306dd37 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -108,7 +108,6 @@ struct acpi_battery_trips {
 };
 
 struct acpi_battery {
-	acpi_handle handle;
 	struct acpi_device * device;
 	struct acpi_battery_flags flags;
 	struct acpi_battery_trips trips;
@@ -693,7 +692,6 @@ static int acpi_battery_add(struct acpi_device *device)
 		return -ENOMEM;
 	memset(battery, 0, sizeof(struct acpi_battery));
 
-	battery->handle = device->handle;
 	battery->device = device;
 	strcpy(acpi_device_name(device), ACPI_BATTERY_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_BATTERY_CLASS);

commit 3b073ec3667ee63e35b66752a30eeedef1e1e772
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Fri May 19 16:54:41 2006 -0400

    ACPI: battery: Use acpi_device's handle instead of driver's
    
    Signed-off-by: Patrick Mochel <mochel@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index ba34ca611d71..5de735ffc3e6 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -139,7 +139,7 @@ acpi_battery_get_info(struct acpi_battery *battery,
 
 	/* Evalute _BIF */
 
-	status = acpi_evaluate_object(battery->handle, "_BIF", NULL, &buffer);
+	status = acpi_evaluate_object(battery->device->handle, "_BIF", NULL, &buffer);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BIF"));
 		return -ENODEV;
@@ -199,7 +199,7 @@ acpi_battery_get_status(struct acpi_battery *battery,
 
 	/* Evalute _BST */
 
-	status = acpi_evaluate_object(battery->handle, "_BST", NULL, &buffer);
+	status = acpi_evaluate_object(battery->device->handle, "_BST", NULL, &buffer);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BST"));
 		return -ENODEV;
@@ -256,7 +256,7 @@ acpi_battery_set_alarm(struct acpi_battery *battery, unsigned long alarm)
 
 	arg0.integer.value = alarm;
 
-	status = acpi_evaluate_object(battery->handle, "_BTP", &arg_list, NULL);
+	status = acpi_evaluate_object(battery->device->handle, "_BTP", &arg_list, NULL);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
@@ -304,7 +304,7 @@ static int acpi_battery_check(struct acpi_battery *battery)
 
 		/* See if alarms are supported, and if so, set default */
 
-		status = acpi_get_handle(battery->handle, "_BTP", &handle);
+		status = acpi_get_handle(battery->device->handle, "_BTP", &handle);
 		if (ACPI_SUCCESS(status)) {
 			battery->flags.alarm = 1;
 			acpi_battery_set_alarm(battery, battery->trips.warning);
@@ -707,7 +707,7 @@ static int acpi_battery_add(struct acpi_device *device)
 	if (result)
 		goto end;
 
-	status = acpi_install_notify_handler(battery->handle,
+	status = acpi_install_notify_handler(device->handle,
 					     ACPI_DEVICE_NOTIFY,
 					     acpi_battery_notify, battery);
 	if (ACPI_FAILURE(status)) {
@@ -739,7 +739,7 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 
 	battery = (struct acpi_battery *)acpi_driver_data(device);
 
-	status = acpi_remove_notify_handler(battery->handle,
+	status = acpi_remove_notify_handler(device->handle,
 					    ACPI_DEVICE_NOTIFY,
 					    acpi_battery_notify);
 

commit 145def84a177c01cf3cc6cfbb67a029f39a8ac35
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Fri May 19 16:54:39 2006 -0400

    ACPI: battery: add struct acpi_device to struct acpi_battery.
    
    - Use it instead of acpi_bus_get_device()..
    
    Signed-off-by: Patrick Mochel <mochel@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 00b0728efe82..ba34ca611d71 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -109,6 +109,7 @@ struct acpi_battery_trips {
 
 struct acpi_battery {
 	acpi_handle handle;
+	struct acpi_device * device;
 	struct acpi_battery_flags flags;
 	struct acpi_battery_trips trips;
 	unsigned long alarm;
@@ -278,9 +279,7 @@ static int acpi_battery_check(struct acpi_battery *battery)
 	if (!battery)
 		return -EINVAL;
 
-	result = acpi_bus_get_device(battery->handle, &device);
-	if (result)
-		return result;
+	device = battery->device;
 
 	result = acpi_bus_get_status(device);
 	if (result)
@@ -662,8 +661,7 @@ static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 	if (!battery)
 		return;
 
-	if (acpi_bus_get_device(handle, &device))
-		return;
+	device = battery->device;
 
 	switch (event) {
 	case ACPI_BATTERY_NOTIFY_STATUS:
@@ -696,6 +694,7 @@ static int acpi_battery_add(struct acpi_device *device)
 	memset(battery, 0, sizeof(struct acpi_battery));
 
 	battery->handle = device->handle;
+	battery->device = device;
 	strcpy(acpi_device_name(device), ACPI_BATTERY_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_BATTERY_CLASS);
 	acpi_driver_data(device) = battery;

commit d550d98d3317378d93a4869db204725d270ec812
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Tue Jun 27 00:41:40 2006 -0400

    ACPI: delete tracing macros from drivers/acpi/*.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 3b92c94ebc60..00b0728efe82 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -132,17 +132,16 @@ acpi_battery_get_info(struct acpi_battery *battery,
 	struct acpi_buffer data = { 0, NULL };
 	union acpi_object *package = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_battery_get_info");
 
 	if (!battery || !bif)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	/* Evalute _BIF */
 
 	status = acpi_evaluate_object(battery->handle, "_BIF", NULL, &buffer);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BIF"));
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
 	package = (union acpi_object *)buffer.pointer;
@@ -177,7 +176,7 @@ acpi_battery_get_info(struct acpi_battery *battery,
 	if (!result)
 		(*bif) = (struct acpi_battery_info *)data.pointer;
 
-	return_VALUE(result);
+	return result;
 }
 
 static int
@@ -193,17 +192,16 @@ acpi_battery_get_status(struct acpi_battery *battery,
 	struct acpi_buffer data = { 0, NULL };
 	union acpi_object *package = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_battery_get_status");
 
 	if (!battery || !bst)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	/* Evalute _BST */
 
 	status = acpi_evaluate_object(battery->handle, "_BST", NULL, &buffer);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BST"));
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
 	package = (union acpi_object *)buffer.pointer;
@@ -238,7 +236,7 @@ acpi_battery_get_status(struct acpi_battery *battery,
 	if (!result)
 		(*bst) = (struct acpi_battery_status *)data.pointer;
 
-	return_VALUE(result);
+	return result;
 }
 
 static int
@@ -248,25 +246,24 @@ acpi_battery_set_alarm(struct acpi_battery *battery, unsigned long alarm)
 	union acpi_object arg0 = { ACPI_TYPE_INTEGER };
 	struct acpi_object_list arg_list = { 1, &arg0 };
 
-	ACPI_FUNCTION_TRACE("acpi_battery_set_alarm");
 
 	if (!battery)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	if (!battery->flags.alarm)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	arg0.integer.value = alarm;
 
 	status = acpi_evaluate_object(battery->handle, "_BTP", &arg_list, NULL);
 	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Alarm set to %d\n", (u32) alarm));
 
 	battery->alarm = alarm;
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_battery_check(struct acpi_battery *battery)
@@ -277,18 +274,17 @@ static int acpi_battery_check(struct acpi_battery *battery)
 	struct acpi_device *device = NULL;
 	struct acpi_battery_info *bif = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_battery_check");
 
 	if (!battery)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	result = acpi_bus_get_device(battery->handle, &device);
 	if (result)
-		return_VALUE(result);
+		return result;
 
 	result = acpi_bus_get_status(device);
 	if (result)
-		return_VALUE(result);
+		return result;
 
 	/* Insertion? */
 
@@ -300,7 +296,7 @@ static int acpi_battery_check(struct acpi_battery *battery)
 
 		result = acpi_battery_get_info(battery, &bif);
 		if (result)
-			return_VALUE(result);
+			return result;
 
 		battery->flags.power_unit = bif->power_unit;
 		battery->trips.warning = bif->design_capacity_warning;
@@ -324,7 +320,7 @@ static int acpi_battery_check(struct acpi_battery *battery)
 
 	battery->flags.present = device->status.battery_present;
 
-	return_VALUE(result);
+	return result;
 }
 
 /* --------------------------------------------------------------------------
@@ -339,7 +335,6 @@ static int acpi_battery_read_info(struct seq_file *seq, void *offset)
 	struct acpi_battery_info *bif = NULL;
 	char *units = "?";
 
-	ACPI_FUNCTION_TRACE("acpi_battery_read_info");
 
 	if (!battery)
 		goto end;
@@ -409,7 +404,7 @@ static int acpi_battery_read_info(struct seq_file *seq, void *offset)
       end:
 	kfree(bif);
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_battery_info_open_fs(struct inode *inode, struct file *file)
@@ -424,7 +419,6 @@ static int acpi_battery_read_state(struct seq_file *seq, void *offset)
 	struct acpi_battery_status *bst = NULL;
 	char *units = "?";
 
-	ACPI_FUNCTION_TRACE("acpi_battery_read_state");
 
 	if (!battery)
 		goto end;
@@ -487,7 +481,7 @@ static int acpi_battery_read_state(struct seq_file *seq, void *offset)
       end:
 	kfree(bst);
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_battery_state_open_fs(struct inode *inode, struct file *file)
@@ -500,7 +494,6 @@ static int acpi_battery_read_alarm(struct seq_file *seq, void *offset)
 	struct acpi_battery *battery = (struct acpi_battery *)seq->private;
 	char *units = "?";
 
-	ACPI_FUNCTION_TRACE("acpi_battery_read_alarm");
 
 	if (!battery)
 		goto end;
@@ -525,7 +518,7 @@ static int acpi_battery_read_alarm(struct seq_file *seq, void *offset)
 		seq_printf(seq, "%d %sh\n", (u32) battery->alarm, units);
 
       end:
-	return_VALUE(0);
+	return 0;
 }
 
 static ssize_t
@@ -538,25 +531,24 @@ acpi_battery_write_alarm(struct file *file,
 	struct seq_file *m = (struct seq_file *)file->private_data;
 	struct acpi_battery *battery = (struct acpi_battery *)m->private;
 
-	ACPI_FUNCTION_TRACE("acpi_battery_write_alarm");
 
 	if (!battery || (count > sizeof(alarm_string) - 1))
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	if (!battery->flags.present)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 
 	if (copy_from_user(alarm_string, buffer, count))
-		return_VALUE(-EFAULT);
+		return -EFAULT;
 
 	alarm_string[count] = '\0';
 
 	result = acpi_battery_set_alarm(battery,
 					simple_strtoul(alarm_string, NULL, 0));
 	if (result)
-		return_VALUE(result);
+		return result;
 
-	return_VALUE(count);
+	return count;
 }
 
 static int acpi_battery_alarm_open_fs(struct inode *inode, struct file *file)
@@ -593,13 +585,12 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 {
 	struct proc_dir_entry *entry = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_battery_add_fs");
 
 	if (!acpi_device_dir(device)) {
 		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
 						     acpi_battery_dir);
 		if (!acpi_device_dir(device))
-			return_VALUE(-ENODEV);
+			return -ENODEV;
 		acpi_device_dir(device)->owner = THIS_MODULE;
 	}
 
@@ -607,7 +598,7 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 	entry = create_proc_entry(ACPI_BATTERY_FILE_INFO,
 				  S_IRUGO, acpi_device_dir(device));
 	if (!entry)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	else {
 		entry->proc_fops = &acpi_battery_info_ops;
 		entry->data = acpi_driver_data(device);
@@ -618,7 +609,7 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 	entry = create_proc_entry(ACPI_BATTERY_FILE_STATUS,
 				  S_IRUGO, acpi_device_dir(device));
 	if (!entry)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	else {
 		entry->proc_fops = &acpi_battery_state_ops;
 		entry->data = acpi_driver_data(device);
@@ -630,19 +621,18 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 				  S_IFREG | S_IRUGO | S_IWUSR,
 				  acpi_device_dir(device));
 	if (!entry)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	else {
 		entry->proc_fops = &acpi_battery_alarm_ops;
 		entry->data = acpi_driver_data(device);
 		entry->owner = THIS_MODULE;
 	}
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int acpi_battery_remove_fs(struct acpi_device *device)
 {
-	ACPI_FUNCTION_TRACE("acpi_battery_remove_fs");
 
 	if (acpi_device_dir(device)) {
 		remove_proc_entry(ACPI_BATTERY_FILE_ALARM,
@@ -656,7 +646,7 @@ static int acpi_battery_remove_fs(struct acpi_device *device)
 		acpi_device_dir(device) = NULL;
 	}
 
-	return_VALUE(0);
+	return 0;
 }
 
 /* --------------------------------------------------------------------------
@@ -668,13 +658,12 @@ static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 	struct acpi_battery *battery = (struct acpi_battery *)data;
 	struct acpi_device *device = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_battery_notify");
 
 	if (!battery)
-		return_VOID;
+		return;
 
 	if (acpi_bus_get_device(handle, &device))
-		return_VOID;
+		return;
 
 	switch (event) {
 	case ACPI_BATTERY_NOTIFY_STATUS:
@@ -688,7 +677,7 @@ static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 		break;
 	}
 
-	return_VOID;
+	return;
 }
 
 static int acpi_battery_add(struct acpi_device *device)
@@ -697,14 +686,13 @@ static int acpi_battery_add(struct acpi_device *device)
 	acpi_status status = 0;
 	struct acpi_battery *battery = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_battery_add");
 
 	if (!device)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	battery = kmalloc(sizeof(struct acpi_battery), GFP_KERNEL);
 	if (!battery)
-		return_VALUE(-ENOMEM);
+		return -ENOMEM;
 	memset(battery, 0, sizeof(struct acpi_battery));
 
 	battery->handle = device->handle;
@@ -738,7 +726,7 @@ static int acpi_battery_add(struct acpi_device *device)
 		kfree(battery);
 	}
 
-	return_VALUE(result);
+	return result;
 }
 
 static int acpi_battery_remove(struct acpi_device *device, int type)
@@ -746,10 +734,9 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 	acpi_status status = 0;
 	struct acpi_battery *battery = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_battery_remove");
 
 	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	battery = (struct acpi_battery *)acpi_driver_data(device);
 
@@ -761,38 +748,36 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 
 	kfree(battery);
 
-	return_VALUE(0);
+	return 0;
 }
 
 static int __init acpi_battery_init(void)
 {
 	int result = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_battery_init");
 
 	acpi_battery_dir = proc_mkdir(ACPI_BATTERY_CLASS, acpi_root_dir);
 	if (!acpi_battery_dir)
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	acpi_battery_dir->owner = THIS_MODULE;
 
 	result = acpi_bus_register_driver(&acpi_battery_driver);
 	if (result < 0) {
 		remove_proc_entry(ACPI_BATTERY_CLASS, acpi_root_dir);
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
-	return_VALUE(0);
+	return 0;
 }
 
 static void __exit acpi_battery_exit(void)
 {
-	ACPI_FUNCTION_TRACE("acpi_battery_exit");
 
 	acpi_bus_unregister_driver(&acpi_battery_driver);
 
 	remove_proc_entry(ACPI_BATTERY_CLASS, acpi_root_dir);
 
-	return_VOID;
+	return;
 }
 
 module_init(acpi_battery_init);

commit a6fc67202e0224e6c9d1d285cc0b444bce887ed5
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jun 26 23:58:43 2006 -0400

    ACPI: Enable ACPI error messages w/o CONFIG_ACPI_DEBUG
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 702e857e98c5..3b92c94ebc60 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -141,7 +141,7 @@ acpi_battery_get_info(struct acpi_battery *battery,
 
 	status = acpi_evaluate_object(battery->handle, "_BIF", NULL, &buffer);
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _BIF\n"));
+		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BIF"));
 		return_VALUE(-ENODEV);
 	}
 
@@ -151,7 +151,7 @@ acpi_battery_get_info(struct acpi_battery *battery,
 
 	status = acpi_extract_package(package, &format, &data);
 	if (status != AE_BUFFER_OVERFLOW) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BIF\n"));
+		ACPI_EXCEPTION((AE_INFO, status, "Extracting _BIF"));
 		result = -ENODEV;
 		goto end;
 	}
@@ -165,7 +165,7 @@ acpi_battery_get_info(struct acpi_battery *battery,
 
 	status = acpi_extract_package(package, &format, &data);
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BIF\n"));
+		ACPI_EXCEPTION((AE_INFO, status, "Extracting _BIF"));
 		kfree(data.pointer);
 		result = -ENODEV;
 		goto end;
@@ -202,7 +202,7 @@ acpi_battery_get_status(struct acpi_battery *battery,
 
 	status = acpi_evaluate_object(battery->handle, "_BST", NULL, &buffer);
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _BST\n"));
+		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _BST"));
 		return_VALUE(-ENODEV);
 	}
 
@@ -212,7 +212,7 @@ acpi_battery_get_status(struct acpi_battery *battery,
 
 	status = acpi_extract_package(package, &format, &data);
 	if (status != AE_BUFFER_OVERFLOW) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BST\n"));
+		ACPI_EXCEPTION((AE_INFO, status, "Extracting _BST"));
 		result = -ENODEV;
 		goto end;
 	}
@@ -226,7 +226,7 @@ acpi_battery_get_status(struct acpi_battery *battery,
 
 	status = acpi_extract_package(package, &format, &data);
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BST\n"));
+		ACPI_EXCEPTION((AE_INFO, status, "Extracting _BST"));
 		kfree(data.pointer);
 		result = -ENODEV;
 		goto end;
@@ -458,8 +458,6 @@ static int acpi_battery_read_state(struct seq_file *seq, void *offset)
 	if ((bst->state & 0x01) && (bst->state & 0x02)) {
 		seq_printf(seq,
 			   "charging state:          charging/discharging\n");
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Battery Charging and Discharging?\n"));
 	} else if (bst->state & 0x01)
 		seq_printf(seq, "charging state:          discharging\n");
 	else if (bst->state & 0x02)
@@ -609,9 +607,7 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 	entry = create_proc_entry(ACPI_BATTERY_FILE_INFO,
 				  S_IRUGO, acpi_device_dir(device));
 	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Unable to create '%s' fs entry\n",
-				  ACPI_BATTERY_FILE_INFO));
+		return_VALUE(-ENODEV);
 	else {
 		entry->proc_fops = &acpi_battery_info_ops;
 		entry->data = acpi_driver_data(device);
@@ -622,9 +618,7 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 	entry = create_proc_entry(ACPI_BATTERY_FILE_STATUS,
 				  S_IRUGO, acpi_device_dir(device));
 	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Unable to create '%s' fs entry\n",
-				  ACPI_BATTERY_FILE_STATUS));
+		return_VALUE(-ENODEV);
 	else {
 		entry->proc_fops = &acpi_battery_state_ops;
 		entry->data = acpi_driver_data(device);
@@ -636,9 +630,7 @@ static int acpi_battery_add_fs(struct acpi_device *device)
 				  S_IFREG | S_IRUGO | S_IWUSR,
 				  acpi_device_dir(device));
 	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Unable to create '%s' fs entry\n",
-				  ACPI_BATTERY_FILE_ALARM));
+		return_VALUE(-ENODEV);
 	else {
 		entry->proc_fops = &acpi_battery_alarm_ops;
 		entry->data = acpi_driver_data(device);
@@ -732,8 +724,6 @@ static int acpi_battery_add(struct acpi_device *device)
 					     ACPI_DEVICE_NOTIFY,
 					     acpi_battery_notify, battery);
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Error installing notify handler\n"));
 		result = -ENODEV;
 		goto end;
 	}
@@ -766,9 +756,6 @@ static int acpi_battery_remove(struct acpi_device *device, int type)
 	status = acpi_remove_notify_handler(battery->handle,
 					    ACPI_DEVICE_NOTIFY,
 					    acpi_battery_notify);
-	if (ACPI_FAILURE(status))
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Error removing notify handler\n"));
 
 	acpi_battery_remove_fs(device);
 

commit 4be44fcd3bf648b782f4460fd06dfae6c42ded4b
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 5 00:44:28 2005 -0400

    [ACPI] Lindent all ACPI files
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index c55feca9b7d5..702e857e98c5 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -34,7 +34,6 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
-
 #define ACPI_BATTERY_VALUE_UNKNOWN 0xFFFFFFFF
 
 #define ACPI_BATTERY_FORMAT_BIF	"NNNNNNNNNSSSS"
@@ -53,87 +52,85 @@
 #define ACPI_BATTERY_UNITS_WATTS	"mW"
 #define ACPI_BATTERY_UNITS_AMPS		"mA"
 
-
 #define _COMPONENT		ACPI_BATTERY_COMPONENT
-ACPI_MODULE_NAME		("acpi_battery")
+ACPI_MODULE_NAME("acpi_battery")
 
-MODULE_AUTHOR("Paul Diefenbaugh");
+    MODULE_AUTHOR("Paul Diefenbaugh");
 MODULE_DESCRIPTION(ACPI_BATTERY_DRIVER_NAME);
 MODULE_LICENSE("GPL");
 
-static int acpi_battery_add (struct acpi_device *device);
-static int acpi_battery_remove (struct acpi_device *device, int type);
+static int acpi_battery_add(struct acpi_device *device);
+static int acpi_battery_remove(struct acpi_device *device, int type);
 
 static struct acpi_driver acpi_battery_driver = {
-	.name =		ACPI_BATTERY_DRIVER_NAME,
-	.class =	ACPI_BATTERY_CLASS,
-	.ids =		ACPI_BATTERY_HID,
-	.ops =		{
-				.add =		acpi_battery_add,
-				.remove =	acpi_battery_remove,
-			},
+	.name = ACPI_BATTERY_DRIVER_NAME,
+	.class = ACPI_BATTERY_CLASS,
+	.ids = ACPI_BATTERY_HID,
+	.ops = {
+		.add = acpi_battery_add,
+		.remove = acpi_battery_remove,
+		},
 };
 
 struct acpi_battery_status {
-	acpi_integer		state;
-	acpi_integer		present_rate;
-	acpi_integer		remaining_capacity;
-	acpi_integer		present_voltage;
+	acpi_integer state;
+	acpi_integer present_rate;
+	acpi_integer remaining_capacity;
+	acpi_integer present_voltage;
 };
 
 struct acpi_battery_info {
-	acpi_integer		power_unit;
-	acpi_integer		design_capacity;
-	acpi_integer		last_full_capacity;
-	acpi_integer		battery_technology;
-	acpi_integer		design_voltage;
-	acpi_integer		design_capacity_warning;
-	acpi_integer		design_capacity_low;
-	acpi_integer		battery_capacity_granularity_1;
-	acpi_integer		battery_capacity_granularity_2;
-	acpi_string		model_number;
-	acpi_string		serial_number;
-	acpi_string		battery_type;
-	acpi_string		oem_info;
+	acpi_integer power_unit;
+	acpi_integer design_capacity;
+	acpi_integer last_full_capacity;
+	acpi_integer battery_technology;
+	acpi_integer design_voltage;
+	acpi_integer design_capacity_warning;
+	acpi_integer design_capacity_low;
+	acpi_integer battery_capacity_granularity_1;
+	acpi_integer battery_capacity_granularity_2;
+	acpi_string model_number;
+	acpi_string serial_number;
+	acpi_string battery_type;
+	acpi_string oem_info;
 };
 
 struct acpi_battery_flags {
-	u8			present:1;	/* Bay occupied? */
-	u8			power_unit:1;	/* 0=watts, 1=apms */
-	u8			alarm:1;	/* _BTP present? */
-	u8			reserved:5;
+	u8 present:1;		/* Bay occupied? */
+	u8 power_unit:1;	/* 0=watts, 1=apms */
+	u8 alarm:1;		/* _BTP present? */
+	u8 reserved:5;
 };
 
 struct acpi_battery_trips {
-	unsigned long		warning;
-	unsigned long		low;
+	unsigned long warning;
+	unsigned long low;
 };
 
 struct acpi_battery {
-	acpi_handle		handle;
+	acpi_handle handle;
 	struct acpi_battery_flags flags;
 	struct acpi_battery_trips trips;
-	unsigned long		alarm;
+	unsigned long alarm;
 	struct acpi_battery_info *info;
 };
 
-
 /* --------------------------------------------------------------------------
                                Battery Management
    -------------------------------------------------------------------------- */
 
 static int
-acpi_battery_get_info (
-	struct acpi_battery	*battery,
-	struct acpi_battery_info **bif)
+acpi_battery_get_info(struct acpi_battery *battery,
+		      struct acpi_battery_info **bif)
 {
-	int			result = 0;
-	acpi_status 		status = 0;
-	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	struct acpi_buffer	format = {sizeof(ACPI_BATTERY_FORMAT_BIF),
-						ACPI_BATTERY_FORMAT_BIF};
-	struct acpi_buffer	data = {0, NULL};
-	union acpi_object	*package = NULL;
+	int result = 0;
+	acpi_status status = 0;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_buffer format = { sizeof(ACPI_BATTERY_FORMAT_BIF),
+		ACPI_BATTERY_FORMAT_BIF
+	};
+	struct acpi_buffer data = { 0, NULL };
+	union acpi_object *package = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_battery_get_info");
 
@@ -148,7 +145,7 @@ acpi_battery_get_info (
 		return_VALUE(-ENODEV);
 	}
 
-	package = (union acpi_object *) buffer.pointer;
+	package = (union acpi_object *)buffer.pointer;
 
 	/* Extract Package Data */
 
@@ -174,27 +171,27 @@ acpi_battery_get_info (
 		goto end;
 	}
 
-end:
+      end:
 	acpi_os_free(buffer.pointer);
 
 	if (!result)
-		(*bif) = (struct acpi_battery_info *) data.pointer;
+		(*bif) = (struct acpi_battery_info *)data.pointer;
 
 	return_VALUE(result);
 }
 
 static int
-acpi_battery_get_status (
-	struct acpi_battery	*battery,
-	struct acpi_battery_status **bst)
+acpi_battery_get_status(struct acpi_battery *battery,
+			struct acpi_battery_status **bst)
 {
-	int			result = 0;
-	acpi_status 		status = 0;
-	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	struct acpi_buffer	format = {sizeof(ACPI_BATTERY_FORMAT_BST),
-						ACPI_BATTERY_FORMAT_BST};
-	struct acpi_buffer	data = {0, NULL};
-	union acpi_object	*package = NULL;
+	int result = 0;
+	acpi_status status = 0;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_buffer format = { sizeof(ACPI_BATTERY_FORMAT_BST),
+		ACPI_BATTERY_FORMAT_BST
+	};
+	struct acpi_buffer data = { 0, NULL };
+	union acpi_object *package = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_battery_get_status");
 
@@ -209,7 +206,7 @@ acpi_battery_get_status (
 		return_VALUE(-ENODEV);
 	}
 
-	package = (union acpi_object *) buffer.pointer;
+	package = (union acpi_object *)buffer.pointer;
 
 	/* Extract Package Data */
 
@@ -235,24 +232,21 @@ acpi_battery_get_status (
 		goto end;
 	}
 
-end:
+      end:
 	acpi_os_free(buffer.pointer);
 
 	if (!result)
-		(*bst) = (struct acpi_battery_status *) data.pointer;
+		(*bst) = (struct acpi_battery_status *)data.pointer;
 
 	return_VALUE(result);
 }
 
-
 static int
-acpi_battery_set_alarm (
-	struct acpi_battery	*battery,
-	unsigned long		alarm)
+acpi_battery_set_alarm(struct acpi_battery *battery, unsigned long alarm)
 {
-	acpi_status		status = 0;
-	union acpi_object	arg0 = {ACPI_TYPE_INTEGER};
-	struct acpi_object_list	arg_list = {1, &arg0};
+	acpi_status status = 0;
+	union acpi_object arg0 = { ACPI_TYPE_INTEGER };
+	struct acpi_object_list arg_list = { 1, &arg0 };
 
 	ACPI_FUNCTION_TRACE("acpi_battery_set_alarm");
 
@@ -275,19 +269,16 @@ acpi_battery_set_alarm (
 	return_VALUE(0);
 }
 
-
-static int
-acpi_battery_check (
-	struct acpi_battery	*battery)
+static int acpi_battery_check(struct acpi_battery *battery)
 {
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	acpi_handle		handle = NULL;
-	struct acpi_device	*device = NULL;
+	int result = 0;
+	acpi_status status = AE_OK;
+	acpi_handle handle = NULL;
+	struct acpi_device *device = NULL;
 	struct acpi_battery_info *bif = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_battery_check");
-	
+
 	if (!battery)
 		return_VALUE(-EINVAL);
 
@@ -336,18 +327,17 @@ acpi_battery_check (
 	return_VALUE(result);
 }
 
-
 /* --------------------------------------------------------------------------
                               FS Interface (/proc)
    -------------------------------------------------------------------------- */
 
-static struct proc_dir_entry	*acpi_battery_dir;
+static struct proc_dir_entry *acpi_battery_dir;
 static int acpi_battery_read_info(struct seq_file *seq, void *offset)
 {
-	int			result = 0;
-	struct acpi_battery	*battery = (struct acpi_battery *) seq->private;
+	int result = 0;
+	struct acpi_battery *battery = (struct acpi_battery *)seq->private;
 	struct acpi_battery_info *bif = NULL;
-	char			*units = "?";
+	char *units = "?";
 
 	ACPI_FUNCTION_TRACE("acpi_battery_read_info");
 
@@ -369,19 +359,21 @@ static int acpi_battery_read_info(struct seq_file *seq, void *offset)
 		goto end;
 	}
 
-	units = bif->power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
-					
+	units =
+	    bif->
+	    power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
+
 	if (bif->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "design capacity:         unknown\n");
 	else
 		seq_printf(seq, "design capacity:         %d %sh\n",
-			(u32) bif->design_capacity, units);
+			   (u32) bif->design_capacity, units);
 
 	if (bif->last_full_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "last full capacity:      unknown\n");
 	else
 		seq_printf(seq, "last full capacity:      %d %sh\n",
-			(u32) bif->last_full_capacity, units);
+			   (u32) bif->last_full_capacity, units);
 
 	switch ((u32) bif->battery_technology) {
 	case 0:
@@ -399,26 +391,22 @@ static int acpi_battery_read_info(struct seq_file *seq, void *offset)
 		seq_printf(seq, "design voltage:          unknown\n");
 	else
 		seq_printf(seq, "design voltage:          %d mV\n",
-			(u32) bif->design_voltage);
-	
+			   (u32) bif->design_voltage);
+
 	seq_printf(seq, "design capacity warning: %d %sh\n",
-		(u32) bif->design_capacity_warning, units);
+		   (u32) bif->design_capacity_warning, units);
 	seq_printf(seq, "design capacity low:     %d %sh\n",
-		(u32) bif->design_capacity_low, units);
+		   (u32) bif->design_capacity_low, units);
 	seq_printf(seq, "capacity granularity 1:  %d %sh\n",
-		(u32) bif->battery_capacity_granularity_1, units);
+		   (u32) bif->battery_capacity_granularity_1, units);
 	seq_printf(seq, "capacity granularity 2:  %d %sh\n",
-		(u32) bif->battery_capacity_granularity_2, units);
-	seq_printf(seq, "model number:            %s\n",
-		bif->model_number);
-	seq_printf(seq, "serial number:           %s\n",
-		bif->serial_number);
-	seq_printf(seq, "battery type:            %s\n",
-		bif->battery_type);
-	seq_printf(seq, "OEM info:                %s\n",
-		bif->oem_info);
-
-end:
+		   (u32) bif->battery_capacity_granularity_2, units);
+	seq_printf(seq, "model number:            %s\n", bif->model_number);
+	seq_printf(seq, "serial number:           %s\n", bif->serial_number);
+	seq_printf(seq, "battery type:            %s\n", bif->battery_type);
+	seq_printf(seq, "OEM info:                %s\n", bif->oem_info);
+
+      end:
 	kfree(bif);
 
 	return_VALUE(0);
@@ -429,14 +417,12 @@ static int acpi_battery_info_open_fs(struct inode *inode, struct file *file)
 	return single_open(file, acpi_battery_read_info, PDE(inode)->data);
 }
 
-
-static int
-acpi_battery_read_state (struct seq_file *seq, void *offset)
+static int acpi_battery_read_state(struct seq_file *seq, void *offset)
 {
-	int			result = 0;
-	struct acpi_battery	*battery = (struct acpi_battery *) seq->private;
+	int result = 0;
+	struct acpi_battery *battery = (struct acpi_battery *)seq->private;
 	struct acpi_battery_status *bst = NULL;
-	char			*units = "?";
+	char *units = "?";
 
 	ACPI_FUNCTION_TRACE("acpi_battery_read_state");
 
@@ -452,7 +438,9 @@ acpi_battery_read_state (struct seq_file *seq, void *offset)
 
 	/* Battery Units */
 
-	units = battery->flags.power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
+	units =
+	    battery->flags.
+	    power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
 
 	/* Battery Status (_BST) */
 
@@ -467,12 +455,12 @@ acpi_battery_read_state (struct seq_file *seq, void *offset)
 	else
 		seq_printf(seq, "capacity state:          critical\n");
 
-	if ((bst->state & 0x01) && (bst->state & 0x02)){
-		seq_printf(seq, "charging state:          charging/discharging\n");
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-					"Battery Charging and Discharging?\n"));
-	}
-	else if (bst->state & 0x01)
+	if ((bst->state & 0x01) && (bst->state & 0x02)) {
+		seq_printf(seq,
+			   "charging state:          charging/discharging\n");
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Battery Charging and Discharging?\n"));
+	} else if (bst->state & 0x01)
 		seq_printf(seq, "charging state:          discharging\n");
 	else if (bst->state & 0x02)
 		seq_printf(seq, "charging state:          charging\n");
@@ -484,21 +472,21 @@ acpi_battery_read_state (struct seq_file *seq, void *offset)
 		seq_printf(seq, "present rate:            unknown\n");
 	else
 		seq_printf(seq, "present rate:            %d %s\n",
-			(u32) bst->present_rate, units);
+			   (u32) bst->present_rate, units);
 
 	if (bst->remaining_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "remaining capacity:      unknown\n");
 	else
 		seq_printf(seq, "remaining capacity:      %d %sh\n",
-			(u32) bst->remaining_capacity, units);
+			   (u32) bst->remaining_capacity, units);
 
 	if (bst->present_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
 		seq_printf(seq, "present voltage:         unknown\n");
 	else
 		seq_printf(seq, "present voltage:         %d mV\n",
-			(u32) bst->present_voltage);
+			   (u32) bst->present_voltage);
 
-end:
+      end:
 	kfree(bst);
 
 	return_VALUE(0);
@@ -509,12 +497,10 @@ static int acpi_battery_state_open_fs(struct inode *inode, struct file *file)
 	return single_open(file, acpi_battery_read_state, PDE(inode)->data);
 }
 
-
-static int
-acpi_battery_read_alarm (struct seq_file *seq, void *offset)
+static int acpi_battery_read_alarm(struct seq_file *seq, void *offset)
 {
-	struct acpi_battery	*battery = (struct acpi_battery *) seq->private;
-	char			*units = "?";
+	struct acpi_battery *battery = (struct acpi_battery *)seq->private;
+	char *units = "?";
 
 	ACPI_FUNCTION_TRACE("acpi_battery_read_alarm");
 
@@ -527,8 +513,10 @@ acpi_battery_read_alarm (struct seq_file *seq, void *offset)
 	}
 
 	/* Battery Units */
-	
-	units = battery->flags.power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
+
+	units =
+	    battery->flags.
+	    power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
 
 	/* Battery Alarm */
 
@@ -538,22 +526,19 @@ acpi_battery_read_alarm (struct seq_file *seq, void *offset)
 	else
 		seq_printf(seq, "%d %sh\n", (u32) battery->alarm, units);
 
-end:
+      end:
 	return_VALUE(0);
 }
 
-
 static ssize_t
-acpi_battery_write_alarm (
-	struct file	*file,
-	const char	__user *buffer,
-	size_t		count,
-	loff_t		*ppos)
+acpi_battery_write_alarm(struct file *file,
+			 const char __user * buffer,
+			 size_t count, loff_t * ppos)
 {
-	int			result = 0;
-	char			alarm_string[12] = {'\0'};
-	struct seq_file		*m = (struct seq_file *)file->private_data;
-	struct acpi_battery	*battery = (struct acpi_battery *)m->private;
+	int result = 0;
+	char alarm_string[12] = { '\0' };
+	struct seq_file *m = (struct seq_file *)file->private_data;
+	struct acpi_battery *battery = (struct acpi_battery *)m->private;
 
 	ACPI_FUNCTION_TRACE("acpi_battery_write_alarm");
 
@@ -565,11 +550,11 @@ acpi_battery_write_alarm (
 
 	if (copy_from_user(alarm_string, buffer, count))
 		return_VALUE(-EFAULT);
-	
+
 	alarm_string[count] = '\0';
 
-	result = acpi_battery_set_alarm(battery, 
-		simple_strtoul(alarm_string, NULL, 0));
+	result = acpi_battery_set_alarm(battery,
+					simple_strtoul(alarm_string, NULL, 0));
 	if (result)
 		return_VALUE(result);
 
@@ -582,41 +567,39 @@ static int acpi_battery_alarm_open_fs(struct inode *inode, struct file *file)
 }
 
 static struct file_operations acpi_battery_info_ops = {
-	.open		= acpi_battery_info_open_fs,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
+	.open = acpi_battery_info_open_fs,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
 	.owner = THIS_MODULE,
 };
 
 static struct file_operations acpi_battery_state_ops = {
-	.open		= acpi_battery_state_open_fs,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
+	.open = acpi_battery_state_open_fs,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
 	.owner = THIS_MODULE,
 };
 
 static struct file_operations acpi_battery_alarm_ops = {
-	.open		= acpi_battery_alarm_open_fs,
-	.read		= seq_read,
-	.write		= acpi_battery_write_alarm,
-	.llseek		= seq_lseek,
-	.release	= single_release,
+	.open = acpi_battery_alarm_open_fs,
+	.read = seq_read,
+	.write = acpi_battery_write_alarm,
+	.llseek = seq_lseek,
+	.release = single_release,
 	.owner = THIS_MODULE,
 };
 
-static int
-acpi_battery_add_fs (
-	struct acpi_device	*device)
+static int acpi_battery_add_fs(struct acpi_device *device)
 {
-	struct proc_dir_entry	*entry = NULL;
+	struct proc_dir_entry *entry = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_battery_add_fs");
 
 	if (!acpi_device_dir(device)) {
 		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
-			acpi_battery_dir);
+						     acpi_battery_dir);
 		if (!acpi_device_dir(device))
 			return_VALUE(-ENODEV);
 		acpi_device_dir(device)->owner = THIS_MODULE;
@@ -624,24 +607,24 @@ acpi_battery_add_fs (
 
 	/* 'info' [R] */
 	entry = create_proc_entry(ACPI_BATTERY_FILE_INFO,
-		S_IRUGO, acpi_device_dir(device));
+				  S_IRUGO, acpi_device_dir(device));
 	if (!entry)
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_BATTERY_FILE_INFO));
+				  "Unable to create '%s' fs entry\n",
+				  ACPI_BATTERY_FILE_INFO));
 	else {
-		entry->proc_fops = &acpi_battery_info_ops; 
+		entry->proc_fops = &acpi_battery_info_ops;
 		entry->data = acpi_driver_data(device);
 		entry->owner = THIS_MODULE;
 	}
 
 	/* 'status' [R] */
 	entry = create_proc_entry(ACPI_BATTERY_FILE_STATUS,
-		S_IRUGO, acpi_device_dir(device));
+				  S_IRUGO, acpi_device_dir(device));
 	if (!entry)
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_BATTERY_FILE_STATUS));
+				  "Unable to create '%s' fs entry\n",
+				  ACPI_BATTERY_FILE_STATUS));
 	else {
 		entry->proc_fops = &acpi_battery_state_ops;
 		entry->data = acpi_driver_data(device);
@@ -650,11 +633,12 @@ acpi_battery_add_fs (
 
 	/* 'alarm' [R/W] */
 	entry = create_proc_entry(ACPI_BATTERY_FILE_ALARM,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+				  S_IFREG | S_IRUGO | S_IWUSR,
+				  acpi_device_dir(device));
 	if (!entry)
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_BATTERY_FILE_ALARM));
+				  "Unable to create '%s' fs entry\n",
+				  ACPI_BATTERY_FILE_ALARM));
 	else {
 		entry->proc_fops = &acpi_battery_alarm_ops;
 		entry->data = acpi_driver_data(device);
@@ -664,10 +648,7 @@ acpi_battery_add_fs (
 	return_VALUE(0);
 }
 
-
-static int
-acpi_battery_remove_fs (
-	struct acpi_device	*device)
+static int acpi_battery_remove_fs(struct acpi_device *device)
 {
 	ACPI_FUNCTION_TRACE("acpi_battery_remove_fs");
 
@@ -686,19 +667,14 @@ acpi_battery_remove_fs (
 	return_VALUE(0);
 }
 
-
 /* --------------------------------------------------------------------------
                                  Driver Interface
    -------------------------------------------------------------------------- */
 
-static void
-acpi_battery_notify (
-	acpi_handle		handle,
-	u32			event,
-	void			*data)
+static void acpi_battery_notify(acpi_handle handle, u32 event, void *data)
 {
-	struct acpi_battery	*battery = (struct acpi_battery *) data;
-	struct acpi_device	*device = NULL;
+	struct acpi_battery *battery = (struct acpi_battery *)data;
+	struct acpi_device *device = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_battery_notify");
 
@@ -716,24 +692,21 @@ acpi_battery_notify (
 		break;
 	default:
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			"Unsupported event [0x%x]\n", event));
+				  "Unsupported event [0x%x]\n", event));
 		break;
 	}
 
 	return_VOID;
 }
 
-
-static int
-acpi_battery_add (
-	struct acpi_device	*device)
+static int acpi_battery_add(struct acpi_device *device)
 {
-	int			result = 0;
-	acpi_status		status = 0;
-	struct acpi_battery	*battery = NULL;
+	int result = 0;
+	acpi_status status = 0;
+	struct acpi_battery *battery = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_battery_add");
-	
+
 	if (!device)
 		return_VALUE(-EINVAL);
 
@@ -756,19 +729,20 @@ acpi_battery_add (
 		goto end;
 
 	status = acpi_install_notify_handler(battery->handle,
-		ACPI_DEVICE_NOTIFY, acpi_battery_notify, battery);
+					     ACPI_DEVICE_NOTIFY,
+					     acpi_battery_notify, battery);
 	if (ACPI_FAILURE(status)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error installing notify handler\n"));
+				  "Error installing notify handler\n"));
 		result = -ENODEV;
 		goto end;
 	}
 
 	printk(KERN_INFO PREFIX "%s Slot [%s] (battery %s)\n",
-		ACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),
-		device->status.battery_present?"present":"absent");
-		
-end:
+	       ACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),
+	       device->status.battery_present ? "present" : "absent");
+
+      end:
 	if (result) {
 		acpi_battery_remove_fs(device);
 		kfree(battery);
@@ -777,27 +751,24 @@ acpi_battery_add (
 	return_VALUE(result);
 }
 
-
-static int
-acpi_battery_remove (
-	struct acpi_device	*device,
-	int			type)
+static int acpi_battery_remove(struct acpi_device *device, int type)
 {
-	acpi_status		status = 0;
-	struct acpi_battery	*battery = NULL;
+	acpi_status status = 0;
+	struct acpi_battery *battery = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_battery_remove");
 
 	if (!device || !acpi_driver_data(device))
 		return_VALUE(-EINVAL);
 
-	battery = (struct acpi_battery *) acpi_driver_data(device);
+	battery = (struct acpi_battery *)acpi_driver_data(device);
 
 	status = acpi_remove_notify_handler(battery->handle,
-		ACPI_DEVICE_NOTIFY, acpi_battery_notify);
+					    ACPI_DEVICE_NOTIFY,
+					    acpi_battery_notify);
 	if (ACPI_FAILURE(status))
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error removing notify handler\n"));
+				  "Error removing notify handler\n"));
 
 	acpi_battery_remove_fs(device);
 
@@ -806,11 +777,9 @@ acpi_battery_remove (
 	return_VALUE(0);
 }
 
-
-static int __init
-acpi_battery_init (void)
+static int __init acpi_battery_init(void)
 {
-	int			result = 0;
+	int result = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_battery_init");
 
@@ -828,9 +797,7 @@ acpi_battery_init (void)
 	return_VALUE(0);
 }
 
-
-static void __exit
-acpi_battery_exit (void)
+static void __exit acpi_battery_exit(void)
 {
 	ACPI_FUNCTION_TRACE("acpi_battery_exit");
 
@@ -841,6 +808,5 @@ acpi_battery_exit (void)
 	return_VOID;
 }
 
-
 module_init(acpi_battery_init);
 module_exit(acpi_battery_exit);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
new file mode 100644
index 000000000000..c55feca9b7d5
--- /dev/null
+++ b/drivers/acpi/battery.c
@@ -0,0 +1,846 @@
+/*
+ *  acpi_battery.c - ACPI Battery Driver ($Revision: 37 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <asm/uaccess.h>
+
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define ACPI_BATTERY_VALUE_UNKNOWN 0xFFFFFFFF
+
+#define ACPI_BATTERY_FORMAT_BIF	"NNNNNNNNNSSSS"
+#define ACPI_BATTERY_FORMAT_BST	"NNNN"
+
+#define ACPI_BATTERY_COMPONENT		0x00040000
+#define ACPI_BATTERY_CLASS		"battery"
+#define ACPI_BATTERY_HID		"PNP0C0A"
+#define ACPI_BATTERY_DRIVER_NAME	"ACPI Battery Driver"
+#define ACPI_BATTERY_DEVICE_NAME	"Battery"
+#define ACPI_BATTERY_FILE_INFO		"info"
+#define ACPI_BATTERY_FILE_STATUS	"state"
+#define ACPI_BATTERY_FILE_ALARM		"alarm"
+#define ACPI_BATTERY_NOTIFY_STATUS	0x80
+#define ACPI_BATTERY_NOTIFY_INFO	0x81
+#define ACPI_BATTERY_UNITS_WATTS	"mW"
+#define ACPI_BATTERY_UNITS_AMPS		"mA"
+
+
+#define _COMPONENT		ACPI_BATTERY_COMPONENT
+ACPI_MODULE_NAME		("acpi_battery")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_BATTERY_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+static int acpi_battery_add (struct acpi_device *device);
+static int acpi_battery_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_battery_driver = {
+	.name =		ACPI_BATTERY_DRIVER_NAME,
+	.class =	ACPI_BATTERY_CLASS,
+	.ids =		ACPI_BATTERY_HID,
+	.ops =		{
+				.add =		acpi_battery_add,
+				.remove =	acpi_battery_remove,
+			},
+};
+
+struct acpi_battery_status {
+	acpi_integer		state;
+	acpi_integer		present_rate;
+	acpi_integer		remaining_capacity;
+	acpi_integer		present_voltage;
+};
+
+struct acpi_battery_info {
+	acpi_integer		power_unit;
+	acpi_integer		design_capacity;
+	acpi_integer		last_full_capacity;
+	acpi_integer		battery_technology;
+	acpi_integer		design_voltage;
+	acpi_integer		design_capacity_warning;
+	acpi_integer		design_capacity_low;
+	acpi_integer		battery_capacity_granularity_1;
+	acpi_integer		battery_capacity_granularity_2;
+	acpi_string		model_number;
+	acpi_string		serial_number;
+	acpi_string		battery_type;
+	acpi_string		oem_info;
+};
+
+struct acpi_battery_flags {
+	u8			present:1;	/* Bay occupied? */
+	u8			power_unit:1;	/* 0=watts, 1=apms */
+	u8			alarm:1;	/* _BTP present? */
+	u8			reserved:5;
+};
+
+struct acpi_battery_trips {
+	unsigned long		warning;
+	unsigned long		low;
+};
+
+struct acpi_battery {
+	acpi_handle		handle;
+	struct acpi_battery_flags flags;
+	struct acpi_battery_trips trips;
+	unsigned long		alarm;
+	struct acpi_battery_info *info;
+};
+
+
+/* --------------------------------------------------------------------------
+                               Battery Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_battery_get_info (
+	struct acpi_battery	*battery,
+	struct acpi_battery_info **bif)
+{
+	int			result = 0;
+	acpi_status 		status = 0;
+	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	struct acpi_buffer	format = {sizeof(ACPI_BATTERY_FORMAT_BIF),
+						ACPI_BATTERY_FORMAT_BIF};
+	struct acpi_buffer	data = {0, NULL};
+	union acpi_object	*package = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_get_info");
+
+	if (!battery || !bif)
+		return_VALUE(-EINVAL);
+
+	/* Evalute _BIF */
+
+	status = acpi_evaluate_object(battery->handle, "_BIF", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _BIF\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	package = (union acpi_object *) buffer.pointer;
+
+	/* Extract Package Data */
+
+	status = acpi_extract_package(package, &format, &data);
+	if (status != AE_BUFFER_OVERFLOW) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BIF\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	data.pointer = kmalloc(data.length, GFP_KERNEL);
+	if (!data.pointer) {
+		result = -ENOMEM;
+		goto end;
+	}
+	memset(data.pointer, 0, data.length);
+
+	status = acpi_extract_package(package, &format, &data);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BIF\n"));
+		kfree(data.pointer);
+		result = -ENODEV;
+		goto end;
+	}
+
+end:
+	acpi_os_free(buffer.pointer);
+
+	if (!result)
+		(*bif) = (struct acpi_battery_info *) data.pointer;
+
+	return_VALUE(result);
+}
+
+static int
+acpi_battery_get_status (
+	struct acpi_battery	*battery,
+	struct acpi_battery_status **bst)
+{
+	int			result = 0;
+	acpi_status 		status = 0;
+	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	struct acpi_buffer	format = {sizeof(ACPI_BATTERY_FORMAT_BST),
+						ACPI_BATTERY_FORMAT_BST};
+	struct acpi_buffer	data = {0, NULL};
+	union acpi_object	*package = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_get_status");
+
+	if (!battery || !bst)
+		return_VALUE(-EINVAL);
+
+	/* Evalute _BST */
+
+	status = acpi_evaluate_object(battery->handle, "_BST", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _BST\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	package = (union acpi_object *) buffer.pointer;
+
+	/* Extract Package Data */
+
+	status = acpi_extract_package(package, &format, &data);
+	if (status != AE_BUFFER_OVERFLOW) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BST\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	data.pointer = kmalloc(data.length, GFP_KERNEL);
+	if (!data.pointer) {
+		result = -ENOMEM;
+		goto end;
+	}
+	memset(data.pointer, 0, data.length);
+
+	status = acpi_extract_package(package, &format, &data);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BST\n"));
+		kfree(data.pointer);
+		result = -ENODEV;
+		goto end;
+	}
+
+end:
+	acpi_os_free(buffer.pointer);
+
+	if (!result)
+		(*bst) = (struct acpi_battery_status *) data.pointer;
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_battery_set_alarm (
+	struct acpi_battery	*battery,
+	unsigned long		alarm)
+{
+	acpi_status		status = 0;
+	union acpi_object	arg0 = {ACPI_TYPE_INTEGER};
+	struct acpi_object_list	arg_list = {1, &arg0};
+
+	ACPI_FUNCTION_TRACE("acpi_battery_set_alarm");
+
+	if (!battery)
+		return_VALUE(-EINVAL);
+
+	if (!battery->flags.alarm)
+		return_VALUE(-ENODEV);
+
+	arg0.integer.value = alarm;
+
+	status = acpi_evaluate_object(battery->handle, "_BTP", &arg_list, NULL);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Alarm set to %d\n", (u32) alarm));
+
+	battery->alarm = alarm;
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_battery_check (
+	struct acpi_battery	*battery)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	acpi_handle		handle = NULL;
+	struct acpi_device	*device = NULL;
+	struct acpi_battery_info *bif = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_check");
+	
+	if (!battery)
+		return_VALUE(-EINVAL);
+
+	result = acpi_bus_get_device(battery->handle, &device);
+	if (result)
+		return_VALUE(result);
+
+	result = acpi_bus_get_status(device);
+	if (result)
+		return_VALUE(result);
+
+	/* Insertion? */
+
+	if (!battery->flags.present && device->status.battery_present) {
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Battery inserted\n"));
+
+		/* Evalute _BIF to get certain static information */
+
+		result = acpi_battery_get_info(battery, &bif);
+		if (result)
+			return_VALUE(result);
+
+		battery->flags.power_unit = bif->power_unit;
+		battery->trips.warning = bif->design_capacity_warning;
+		battery->trips.low = bif->design_capacity_low;
+		kfree(bif);
+
+		/* See if alarms are supported, and if so, set default */
+
+		status = acpi_get_handle(battery->handle, "_BTP", &handle);
+		if (ACPI_SUCCESS(status)) {
+			battery->flags.alarm = 1;
+			acpi_battery_set_alarm(battery, battery->trips.warning);
+		}
+	}
+
+	/* Removal? */
+
+	else if (battery->flags.present && !device->status.battery_present) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Battery removed\n"));
+	}
+
+	battery->flags.present = device->status.battery_present;
+
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+static struct proc_dir_entry	*acpi_battery_dir;
+static int acpi_battery_read_info(struct seq_file *seq, void *offset)
+{
+	int			result = 0;
+	struct acpi_battery	*battery = (struct acpi_battery *) seq->private;
+	struct acpi_battery_info *bif = NULL;
+	char			*units = "?";
+
+	ACPI_FUNCTION_TRACE("acpi_battery_read_info");
+
+	if (!battery)
+		goto end;
+
+	if (battery->flags.present)
+		seq_printf(seq, "present:                 yes\n");
+	else {
+		seq_printf(seq, "present:                 no\n");
+		goto end;
+	}
+
+	/* Battery Info (_BIF) */
+
+	result = acpi_battery_get_info(battery, &bif);
+	if (result || !bif) {
+		seq_printf(seq, "ERROR: Unable to read battery information\n");
+		goto end;
+	}
+
+	units = bif->power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
+					
+	if (bif->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+		seq_printf(seq, "design capacity:         unknown\n");
+	else
+		seq_printf(seq, "design capacity:         %d %sh\n",
+			(u32) bif->design_capacity, units);
+
+	if (bif->last_full_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+		seq_printf(seq, "last full capacity:      unknown\n");
+	else
+		seq_printf(seq, "last full capacity:      %d %sh\n",
+			(u32) bif->last_full_capacity, units);
+
+	switch ((u32) bif->battery_technology) {
+	case 0:
+		seq_printf(seq, "battery technology:      non-rechargeable\n");
+		break;
+	case 1:
+		seq_printf(seq, "battery technology:      rechargeable\n");
+		break;
+	default:
+		seq_printf(seq, "battery technology:      unknown\n");
+		break;
+	}
+
+	if (bif->design_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
+		seq_printf(seq, "design voltage:          unknown\n");
+	else
+		seq_printf(seq, "design voltage:          %d mV\n",
+			(u32) bif->design_voltage);
+	
+	seq_printf(seq, "design capacity warning: %d %sh\n",
+		(u32) bif->design_capacity_warning, units);
+	seq_printf(seq, "design capacity low:     %d %sh\n",
+		(u32) bif->design_capacity_low, units);
+	seq_printf(seq, "capacity granularity 1:  %d %sh\n",
+		(u32) bif->battery_capacity_granularity_1, units);
+	seq_printf(seq, "capacity granularity 2:  %d %sh\n",
+		(u32) bif->battery_capacity_granularity_2, units);
+	seq_printf(seq, "model number:            %s\n",
+		bif->model_number);
+	seq_printf(seq, "serial number:           %s\n",
+		bif->serial_number);
+	seq_printf(seq, "battery type:            %s\n",
+		bif->battery_type);
+	seq_printf(seq, "OEM info:                %s\n",
+		bif->oem_info);
+
+end:
+	kfree(bif);
+
+	return_VALUE(0);
+}
+
+static int acpi_battery_info_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, acpi_battery_read_info, PDE(inode)->data);
+}
+
+
+static int
+acpi_battery_read_state (struct seq_file *seq, void *offset)
+{
+	int			result = 0;
+	struct acpi_battery	*battery = (struct acpi_battery *) seq->private;
+	struct acpi_battery_status *bst = NULL;
+	char			*units = "?";
+
+	ACPI_FUNCTION_TRACE("acpi_battery_read_state");
+
+	if (!battery)
+		goto end;
+
+	if (battery->flags.present)
+		seq_printf(seq, "present:                 yes\n");
+	else {
+		seq_printf(seq, "present:                 no\n");
+		goto end;
+	}
+
+	/* Battery Units */
+
+	units = battery->flags.power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
+
+	/* Battery Status (_BST) */
+
+	result = acpi_battery_get_status(battery, &bst);
+	if (result || !bst) {
+		seq_printf(seq, "ERROR: Unable to read battery status\n");
+		goto end;
+	}
+
+	if (!(bst->state & 0x04))
+		seq_printf(seq, "capacity state:          ok\n");
+	else
+		seq_printf(seq, "capacity state:          critical\n");
+
+	if ((bst->state & 0x01) && (bst->state & 0x02)){
+		seq_printf(seq, "charging state:          charging/discharging\n");
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"Battery Charging and Discharging?\n"));
+	}
+	else if (bst->state & 0x01)
+		seq_printf(seq, "charging state:          discharging\n");
+	else if (bst->state & 0x02)
+		seq_printf(seq, "charging state:          charging\n");
+	else {
+		seq_printf(seq, "charging state:          charged\n");
+	}
+
+	if (bst->present_rate == ACPI_BATTERY_VALUE_UNKNOWN)
+		seq_printf(seq, "present rate:            unknown\n");
+	else
+		seq_printf(seq, "present rate:            %d %s\n",
+			(u32) bst->present_rate, units);
+
+	if (bst->remaining_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+		seq_printf(seq, "remaining capacity:      unknown\n");
+	else
+		seq_printf(seq, "remaining capacity:      %d %sh\n",
+			(u32) bst->remaining_capacity, units);
+
+	if (bst->present_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
+		seq_printf(seq, "present voltage:         unknown\n");
+	else
+		seq_printf(seq, "present voltage:         %d mV\n",
+			(u32) bst->present_voltage);
+
+end:
+	kfree(bst);
+
+	return_VALUE(0);
+}
+
+static int acpi_battery_state_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, acpi_battery_read_state, PDE(inode)->data);
+}
+
+
+static int
+acpi_battery_read_alarm (struct seq_file *seq, void *offset)
+{
+	struct acpi_battery	*battery = (struct acpi_battery *) seq->private;
+	char			*units = "?";
+
+	ACPI_FUNCTION_TRACE("acpi_battery_read_alarm");
+
+	if (!battery)
+		goto end;
+
+	if (!battery->flags.present) {
+		seq_printf(seq, "present:                 no\n");
+		goto end;
+	}
+
+	/* Battery Units */
+	
+	units = battery->flags.power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
+
+	/* Battery Alarm */
+
+	seq_printf(seq, "alarm:                   ");
+	if (!battery->alarm)
+		seq_printf(seq, "unsupported\n");
+	else
+		seq_printf(seq, "%d %sh\n", (u32) battery->alarm, units);
+
+end:
+	return_VALUE(0);
+}
+
+
+static ssize_t
+acpi_battery_write_alarm (
+	struct file	*file,
+	const char	__user *buffer,
+	size_t		count,
+	loff_t		*ppos)
+{
+	int			result = 0;
+	char			alarm_string[12] = {'\0'};
+	struct seq_file		*m = (struct seq_file *)file->private_data;
+	struct acpi_battery	*battery = (struct acpi_battery *)m->private;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_write_alarm");
+
+	if (!battery || (count > sizeof(alarm_string) - 1))
+		return_VALUE(-EINVAL);
+
+	if (!battery->flags.present)
+		return_VALUE(-ENODEV);
+
+	if (copy_from_user(alarm_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	alarm_string[count] = '\0';
+
+	result = acpi_battery_set_alarm(battery, 
+		simple_strtoul(alarm_string, NULL, 0));
+	if (result)
+		return_VALUE(result);
+
+	return_VALUE(count);
+}
+
+static int acpi_battery_alarm_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, acpi_battery_read_alarm, PDE(inode)->data);
+}
+
+static struct file_operations acpi_battery_info_ops = {
+	.open		= acpi_battery_info_open_fs,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.owner = THIS_MODULE,
+};
+
+static struct file_operations acpi_battery_state_ops = {
+	.open		= acpi_battery_state_open_fs,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.owner = THIS_MODULE,
+};
+
+static struct file_operations acpi_battery_alarm_ops = {
+	.open		= acpi_battery_alarm_open_fs,
+	.read		= seq_read,
+	.write		= acpi_battery_write_alarm,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.owner = THIS_MODULE,
+};
+
+static int
+acpi_battery_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_add_fs");
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_battery_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+		acpi_device_dir(device)->owner = THIS_MODULE;
+	}
+
+	/* 'info' [R] */
+	entry = create_proc_entry(ACPI_BATTERY_FILE_INFO,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_BATTERY_FILE_INFO));
+	else {
+		entry->proc_fops = &acpi_battery_info_ops; 
+		entry->data = acpi_driver_data(device);
+		entry->owner = THIS_MODULE;
+	}
+
+	/* 'status' [R] */
+	entry = create_proc_entry(ACPI_BATTERY_FILE_STATUS,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_BATTERY_FILE_STATUS));
+	else {
+		entry->proc_fops = &acpi_battery_state_ops;
+		entry->data = acpi_driver_data(device);
+		entry->owner = THIS_MODULE;
+	}
+
+	/* 'alarm' [R/W] */
+	entry = create_proc_entry(ACPI_BATTERY_FILE_ALARM,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_BATTERY_FILE_ALARM));
+	else {
+		entry->proc_fops = &acpi_battery_alarm_ops;
+		entry->data = acpi_driver_data(device);
+		entry->owner = THIS_MODULE;
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_battery_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_battery_remove_fs");
+
+	if (acpi_device_dir(device)) {
+		remove_proc_entry(ACPI_BATTERY_FILE_ALARM,
+				  acpi_device_dir(device));
+		remove_proc_entry(ACPI_BATTERY_FILE_STATUS,
+				  acpi_device_dir(device));
+		remove_proc_entry(ACPI_BATTERY_FILE_INFO,
+				  acpi_device_dir(device));
+
+		remove_proc_entry(acpi_device_bid(device), acpi_battery_dir);
+		acpi_device_dir(device) = NULL;
+	}
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Interface
+   -------------------------------------------------------------------------- */
+
+static void
+acpi_battery_notify (
+	acpi_handle		handle,
+	u32			event,
+	void			*data)
+{
+	struct acpi_battery	*battery = (struct acpi_battery *) data;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_notify");
+
+	if (!battery)
+		return_VOID;
+
+	if (acpi_bus_get_device(handle, &device))
+		return_VOID;
+
+	switch (event) {
+	case ACPI_BATTERY_NOTIFY_STATUS:
+	case ACPI_BATTERY_NOTIFY_INFO:
+		acpi_battery_check(battery);
+		acpi_bus_generate_event(device, event, battery->flags.present);
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Unsupported event [0x%x]\n", event));
+		break;
+	}
+
+	return_VOID;
+}
+
+
+static int
+acpi_battery_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = 0;
+	struct acpi_battery	*battery = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_add");
+	
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	battery = kmalloc(sizeof(struct acpi_battery), GFP_KERNEL);
+	if (!battery)
+		return_VALUE(-ENOMEM);
+	memset(battery, 0, sizeof(struct acpi_battery));
+
+	battery->handle = device->handle;
+	strcpy(acpi_device_name(device), ACPI_BATTERY_DEVICE_NAME);
+	strcpy(acpi_device_class(device), ACPI_BATTERY_CLASS);
+	acpi_driver_data(device) = battery;
+
+	result = acpi_battery_check(battery);
+	if (result)
+		goto end;
+
+	result = acpi_battery_add_fs(device);
+	if (result)
+		goto end;
+
+	status = acpi_install_notify_handler(battery->handle,
+		ACPI_DEVICE_NOTIFY, acpi_battery_notify, battery);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error installing notify handler\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	printk(KERN_INFO PREFIX "%s Slot [%s] (battery %s)\n",
+		ACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),
+		device->status.battery_present?"present":"absent");
+		
+end:
+	if (result) {
+		acpi_battery_remove_fs(device);
+		kfree(battery);
+	}
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_battery_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	acpi_status		status = 0;
+	struct acpi_battery	*battery = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	battery = (struct acpi_battery *) acpi_driver_data(device);
+
+	status = acpi_remove_notify_handler(battery->handle,
+		ACPI_DEVICE_NOTIFY, acpi_battery_notify);
+	if (ACPI_FAILURE(status))
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error removing notify handler\n"));
+
+	acpi_battery_remove_fs(device);
+
+	kfree(battery);
+
+	return_VALUE(0);
+}
+
+
+static int __init
+acpi_battery_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_init");
+
+	acpi_battery_dir = proc_mkdir(ACPI_BATTERY_CLASS, acpi_root_dir);
+	if (!acpi_battery_dir)
+		return_VALUE(-ENODEV);
+	acpi_battery_dir->owner = THIS_MODULE;
+
+	result = acpi_bus_register_driver(&acpi_battery_driver);
+	if (result < 0) {
+		remove_proc_entry(ACPI_BATTERY_CLASS, acpi_root_dir);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+static void __exit
+acpi_battery_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_battery_exit");
+
+	acpi_bus_unregister_driver(&acpi_battery_driver);
+
+	remove_proc_entry(ACPI_BATTERY_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
+
+
+module_init(acpi_battery_init);
+module_exit(acpi_battery_exit);
