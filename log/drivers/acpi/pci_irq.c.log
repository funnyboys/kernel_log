commit 29b49958cf73b439b17fa29e9a25210809a6c01c
Author: Wenwen Wang <wenwen@cs.uga.edu>
Date:   Tue Aug 20 22:44:19 2019 -0500

    ACPI / PCI: fix acpi_pci_irq_enable() memory leak
    
    In acpi_pci_irq_enable(), 'entry' is allocated by kzalloc() in
    acpi_pci_irq_check_entry() (invoked from acpi_pci_irq_lookup()). However,
    it is not deallocated if acpi_pci_irq_valid() returns false, leading to a
    memory leak. To fix this issue, free 'entry' before returning 0.
    
    Fixes: e237a5518425 ("x86/ACPI/PCI: Recognize that Interrupt Line 255 means "not connected"")
    Signed-off-by: Wenwen Wang <wenwen@cs.uga.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index d2549ae65e1b..dea8a60e18a4 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -449,8 +449,10 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 		 * No IRQ known to the ACPI subsystem - maybe the BIOS /
 		 * driver reported one, then use it. Exit in any case.
 		 */
-		if (!acpi_pci_irq_valid(dev, pin))
+		if (!acpi_pci_irq_valid(dev, pin)) {
+			kfree(entry);
 			return 0;
+		}
 
 		if (acpi_isa_register_gsi(dev))
 			dev_warn(&dev->dev, "PCI INT %c: no GSI\n",

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index c576a6fe4ebb..d2549ae65e1b 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  pci_irq.c - ACPI PCI Interrupt Routing ($Revision: 11 $)
  *
@@ -6,20 +7,6 @@
  *  Copyright (C) 2002       Dominik Brodowski <devel@brodo.de>
  *  (c) Copyright 2008 Hewlett-Packard Development Company, L.P.
  *	Bjorn Helgaas <bjorn.helgaas@hp.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 
 

commit 10b68700add43d0c38fedefb7a2b7df931f8e84e
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Sep 5 15:12:38 2016 +0100

    ACPI / PCI: fix GIC irq model default PCI IRQ polarity
    
    On ACPI ARM based systems the GIC interrupt controller
    and corresponding interrupt model permit only the high
    polarity for level interrupts.
    
    ACPI firmware describes PCI legacy IRQs through entries
    in the _PRT objects. Entries in the _PRT can be of two types:
    
    - Static: not configurable, trigger/polarity default to level-low,
      _PRT entry defines the global GSI interrupt number
    - Configurable: _PRT interrupt entry contains a reference to the
      corresponding PCI interrupt link device (that in turn provides the
      interrupt descriptor through its _CRS/_PRS methods)
    
    Configurable IRQ entries are not currently allowed by the ACPI
    specification on ARM since they can only be used for interrupt pins that
    are routable, as per ACPI specifications (version 6.1, 6.2.13):
    
    "[...] There are two ways that _PRT can be used. Typically, the
    interrupt input that a given PCI interrupt is on is configurable. For
    example, a given PCI interrupt might be configured for either IRQ 10 or
    11 on an 8259 interrupt controller. In this model, each interrupt is
    represented in the ACPI namespace as a PCI Interrupt Link Device. [...]"
    
    ARM platforms GIC configurations do not allow dynamic IRQ routing,
    since routing is statically laid out at synthesis time; therefore PCI
    interrupt links cannot be used for PCI legacy IRQ descriptions in the
    _PRT on ARM systems.
    
    On the other hand, current core ACPI code handling PCI legacy IRQs
    consider IRQ trigger/polarity for static _PRT entries as level-low.
    
    On ARM systems with a GIC interrupt controller and corresponding
    ACPI interrupt model this does not work in that GIC interrupt
    controller is only capable of handling level interrupts whose
    polarity is high (for PCI legacy IRQs - that are level-low by
    specification - this means that the legacy IRQs are inverted before
    reaching the interrupt controller pin), resulting in IRQ allocation
    failures such as:
    
    genirq: Setting trigger mode 8 for irq 18 failed (gic_set_type+0x0/0x48)
    
    Change the default polarity for PCI legacy IRQs to high on systems
    booting wth ACPI on platforms with a GIC interrupt controller model,
    fixing the discrepancy between specification and HW behaviour.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Duc Dang <dhdang@apm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 2c45dd3acc17..c576a6fe4ebb 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -411,7 +411,15 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	int gsi;
 	u8 pin;
 	int triggering = ACPI_LEVEL_SENSITIVE;
-	int polarity = ACPI_ACTIVE_LOW;
+	/*
+	 * On ARM systems with the GIC interrupt model, level interrupts
+	 * are always polarity high by specification; PCI legacy
+	 * IRQs lines are inverted before reaching the interrupt
+	 * controller and must therefore be considered active high
+	 * as default.
+	 */
+	int polarity = acpi_irq_model == ACPI_IRQ_MODEL_GIC ?
+				      ACPI_ACTIVE_HIGH : ACPI_ACTIVE_LOW;
 	char *link = NULL;
 	char link_desc[16];
 	int rc;

commit e237a5518425155faa508a087f28269f58074b92
Author: Chen Fan <chen.fan.fnst@cn.fujitsu.com>
Date:   Mon Feb 15 12:52:01 2016 +0800

    x86/ACPI/PCI: Recognize that Interrupt Line 255 means "not connected"
    
    Per the x86-specific footnote to PCI spec r3.0, sec 6.2.4, the value 255 in
    the Interrupt Line register means "unknown" or "no connection."
    Previously, when we couldn't derive an IRQ from the _PRT, we fell back to
    using the value from Interrupt Line as an IRQ.  It's questionable whether
    we should do that at all, but the spec clearly suggests we shouldn't do it
    for the value 255 on x86.
    
    Calling request_irq() with IRQ 255 may succeed, but the driver won't
    receive any interrupts.  Or, if IRQ 255 is shared with another device, it
    may succeed, and the driver's ISR will be called at random times when the
    *other* device interrupts.  Or it may fail if another device is using IRQ
    255 with incompatible flags.  What we *want* is for request_irq() to fail
    predictably so the driver can fall back to polling.
    
    On x86, assume 255 in the Interrupt Line means the INTx line is not
    connected.  In that case, set dev->irq to IRQ_NOTCONNECTED so request_irq()
    will fail gracefully with -ENOTCONN.
    
    We found this problem on a system where Secure Boot firmware assigned
    Interrupt Line 255 to an i801_smbus device and another device was already
    using MSI-X IRQ 255.  This was in v3.10, where i801_probe() fails if
    request_irq() fails:
    
      i801_smbus 0000:00:1f.3: enabling device (0140 -> 0143)
      i801_smbus 0000:00:1f.3: can't derive routing for PCI INT C
      i801_smbus 0000:00:1f.3: PCI INT C: no GSI
      genirq: Flags mismatch irq 255. 00000080 (i801_smbus) vs. 00000000 (megasa)
      CPU: 0 PID: 2487 Comm: kworker/0:1 Not tainted 3.10.0-229.el7.x86_64 #1
      Hardware name: FUJITSU PRIMEQUEST 2800E2/D3736, BIOS PRIMEQUEST 2000 Serie5
      Call Trace:
        dump_stack+0x19/0x1b
        __setup_irq+0x54a/0x570
        request_threaded_irq+0xcc/0x170
        i801_probe+0x32f/0x508 [i2c_i801]
        local_pci_probe+0x45/0xa0
      i801_smbus 0000:00:1f.3: Failed to allocate irq 255: -16
      i801_smbus: probe of 0000:00:1f.3 failed with error -16
    
    After aeb8a3d16ae0 ("i2c: i801: Check if interrupts are disabled"),
    i801_probe() will fall back to polling if request_irq() fails.  But we
    still need this patch because request_irq() may succeed or fail depending
    on other devices in the system.  If request_irq() fails, i801_smbus will
    work by falling back to polling, but if it succeeds, i801_smbus won't work
    because it expects interrupts that it may not receive.
    
    Signed-off-by: Chen Fan <chen.fan.fnst@cn.fujitsu.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index c8e169e46673..2c45dd3acc17 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -33,6 +33,7 @@
 #include <linux/pci.h>
 #include <linux/acpi.h>
 #include <linux/slab.h>
+#include <linux/interrupt.h>
 
 #define PREFIX "ACPI: "
 
@@ -387,6 +388,23 @@ static inline int acpi_isa_register_gsi(struct pci_dev *dev)
 }
 #endif
 
+static inline bool acpi_pci_irq_valid(struct pci_dev *dev, u8 pin)
+{
+#ifdef CONFIG_X86
+	/*
+	 * On x86 irq line 0xff means "unknown" or "no connection"
+	 * (PCI 3.0, Section 6.2.4, footnote on page 223).
+	 */
+	if (dev->irq == 0xff) {
+		dev->irq = IRQ_NOTCONNECTED;
+		dev_warn(&dev->dev, "PCI INT %c: not connected\n",
+			 pin_name(pin));
+		return false;
+	}
+#endif
+	return true;
+}
+
 int acpi_pci_irq_enable(struct pci_dev *dev)
 {
 	struct acpi_prt_entry *entry;
@@ -431,11 +449,14 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	} else
 		gsi = -1;
 
-	/*
-	 * No IRQ known to the ACPI subsystem - maybe the BIOS / 
-	 * driver reported one, then use it. Exit in any case.
-	 */
 	if (gsi < 0) {
+		/*
+		 * No IRQ known to the ACPI subsystem - maybe the BIOS /
+		 * driver reported one, then use it. Exit in any case.
+		 */
+		if (!acpi_pci_irq_valid(dev, pin))
+			return 0;
+
 		if (acpi_isa_register_gsi(dev))
 			dev_warn(&dev->dev, "PCI INT %c: no GSI\n",
 				 pin_name(pin));

commit 6c777e8799a93e3bdb67bec622429e1b48dc90fb
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Feb 17 12:26:42 2016 -0600

    Revert "PCI, x86: Implement pcibios_alloc_irq() and pcibios_free_irq()"
    
    991de2e59090 ("PCI, x86: Implement pcibios_alloc_irq() and
    pcibios_free_irq()") appeared in v4.3 and helps support IOAPIC hotplug.
    
    Олег reported that the Elcus-1553 TA1-PCI driver worked in v4.2 but not
    v4.3 and bisected it to 991de2e59090.  Sunjin reported that the RocketRAID
    272x driver worked in v4.2 but not v4.3.  In both cases booting with
    "pci=routirq" is a workaround.
    
    I think the problem is that after 991de2e59090, we no longer call
    pcibios_enable_irq() for upstream bridges.  Prior to 991de2e59090, when a
    driver called pci_enable_device(), we recursively called
    pcibios_enable_irq() for upstream bridges via pci_enable_bridge().
    
    After 991de2e59090, we call pcibios_enable_irq() from pci_device_probe()
    instead of the pci_enable_device() path, which does *not* call
    pcibios_enable_irq() for upstream bridges.
    
    Revert 991de2e59090 to fix these driver regressions.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=111211
    Fixes: 991de2e59090 ("PCI, x86: Implement pcibios_alloc_irq() and pcibios_free_irq()")
    Reported-and-tested-by: Олег Мороз <oleg.moroz@mcc.vniiem.ru>
    Reported-by: Sunjin Yang <fan4326@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael@kernel.org>
    CC: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 9032db7e4b3a..c8e169e46673 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -478,6 +478,14 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	if (!pin || !dev->irq_managed || dev->irq <= 0)
 		return;
 
+	/* Keep IOAPIC pin configuration when suspending */
+	if (dev->dev.power.is_prepared)
+		return;
+#ifdef	CONFIG_PM
+	if (dev->dev.power.runtime_status == RPM_SUSPENDING)
+		return;
+#endif
+
 	entry = acpi_pci_irq_lookup(dev, pin);
 	if (!entry)
 		return;
@@ -498,6 +506,5 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	if (gsi >= 0) {
 		acpi_unregister_gsi(gsi);
 		dev->irq_managed = 0;
-		dev->irq = 0;
 	}
 }

commit 67b4eab91caf2ad574cab1b17ae09180ea2e116e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Feb 17 12:26:38 2016 -0600

    Revert "PCI: Add helpers to manage pci_dev->irq and pci_dev->irq_managed"
    
    Revert 811a4e6fce09 ("PCI: Add helpers to manage pci_dev->irq and
    pci_dev->irq_managed").
    
    This is part of reverting 991de2e59090 ("PCI, x86: Implement
    pcibios_alloc_irq() and pcibios_free_irq()") to fix regressions it
    introduced.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=111211
    Fixes: 991de2e59090 ("PCI, x86: Implement pcibios_alloc_irq() and pcibios_free_irq()")
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael@kernel.org>
    CC: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index d30184c7f3bc..9032db7e4b3a 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -406,7 +406,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 		return 0;
 	}
 
-	if (pci_has_managed_irq(dev))
+	if (dev->irq_managed && dev->irq > 0)
 		return 0;
 
 	entry = acpi_pci_irq_lookup(dev, pin);
@@ -451,7 +451,8 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 		kfree(entry);
 		return rc;
 	}
-	pci_set_managed_irq(dev, rc);
+	dev->irq = rc;
+	dev->irq_managed = 1;
 
 	if (link)
 		snprintf(link_desc, sizeof(link_desc), " -> Link[%s]", link);
@@ -474,7 +475,7 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	u8 pin;
 
 	pin = dev->pin;
-	if (!pin || !pci_has_managed_irq(dev))
+	if (!pin || !dev->irq_managed || dev->irq <= 0)
 		return;
 
 	entry = acpi_pci_irq_lookup(dev, pin);
@@ -496,6 +497,7 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	dev_dbg(&dev->dev, "PCI INT %c disabled\n", pin_name(pin));
 	if (gsi >= 0) {
 		acpi_unregister_gsi(gsi);
-		pci_reset_managed_irq(dev);
+		dev->irq_managed = 0;
+		dev->irq = 0;
 	}
 }

commit 45288978859119c019eff93f0cb838a0de100bcc
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Jan 5 10:57:11 2016 +0000

    ACPI, PCI, irq: remove redundant check for null string pointer
    
    source is decleared as a 4 byte char array in struct acpi_pci_routing_table
    so !prt->source is a redundant null string pointer check. Detected with
    smatch:
    
    drivers/acpi/pci_irq.c:134 do_prt_fixups() warn: this array is probably
      non-NULL. 'prt->source'
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index c9336751e5e3..d30184c7f3bc 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -131,9 +131,6 @@ static void do_prt_fixups(struct acpi_prt_entry *entry,
 		quirk = &prt_quirks[i];
 
 		/* All current quirks involve link devices, not GSIs */
-		if (!prt->source)
-			continue;
-
 		if (dmi_check_system(quirk->system) &&
 		    entry->id.segment == quirk->segment &&
 		    entry->id.bus == quirk->bus &&

commit 5ebc76035303016ec41bb752bec156ea9fde7c34
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Sep 17 14:02:45 2015 +0800

    ACPI, PCI, irq: Do not share PCI IRQ with ISA IRQ
    
    Avoid IRQs occupied by ISA IRQs when allocating IRQs for PCI link devices,
    otherwise it may cause interrupt storm due to incompatible pin attributes.
    
    This issue was triggered on a KVM virtual machine, which
     1) uses IRQ9 for SCI in high level mode.
     2) defines an PCI interrupt link device (LNKS) with IRQ9 as the only
        possible irq.
     3) has an PCI device referring to link device LNKS.
    So it causes interrupt storm when enabling the PCI device because PCI IRQ
    works in low level mode.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 6da0f9beab19..c9336751e5e3 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -372,6 +372,7 @@ static int acpi_isa_register_gsi(struct pci_dev *dev)
 
 	/* Interrupt Line values above 0xF are forbidden */
 	if (dev->irq > 0 && (dev->irq <= 0xF) &&
+	    acpi_isa_irq_available(dev->irq) &&
 	    (acpi_isa_irq_to_gsi(dev->irq, &dev_gsi) == 0)) {
 		dev_warn(&dev->dev, "PCI INT %c: no GSI - using ISA IRQ %d\n",
 			 pin_name(dev->pin), dev->irq);

commit ae982073095a44f004d7ffb9f271077abef9dbcf
Merge: f1a3c0b933e7 e625ccec1fa6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 1 19:45:46 2015 -0700

    Merge tag 'pm+acpi-4.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "From the number of commits perspective, the biggest items are ACPICA
      and cpufreq changes with the latter taking the lead (over 50 commits).
    
      On the cpufreq front, there are many cleanups and minor fixes in the
      core and governors, driver updates etc.  We also have a new cpufreq
      driver for Mediatek MT8173 chips.
    
      ACPICA mostly updates its debug infrastructure and adds a number of
      fixes and cleanups for a good measure.
    
      The Operating Performance Points (OPP) framework is updated with new
      DT bindings and support for them among other things.
    
      We have a few updates of the generic power domains framework and a
      reorganization of the ACPI device enumeration code and bus type
      operations.
    
      And a lot of fixes and cleanups all over.
    
      Included is one branch from the MFD tree as it contains some
      PM-related driver core and ACPI PM changes a few other commits are
      based on.
    
      Specifics:
    
       - ACPICA update to upstream revision 20150818 including method
         tracing extensions to allow more in-depth AML debugging in the
         kernel and a number of assorted fixes and cleanups (Bob Moore, Lv
         Zheng, Markus Elfring).
    
       - ACPI sysfs code updates and a documentation update related to AML
         method tracing (Lv Zheng).
    
       - ACPI EC driver fix related to serialized evaluations of _Qxx
         methods and ACPI tools updates allowing the EC userspace tool to be
         built from the kernel source (Lv Zheng).
    
       - ACPI processor driver updates preparing it for future introduction
         of CPPC support and ACPI PCC mailbox driver updates (Ashwin
         Chaugule).
    
       - ACPI interrupts enumeration fix for a regression related to the
         handling of IRQ attribute conflicts between MADT and the ACPI
         namespace (Jiang Liu).
    
       - Fixes related to ACPI device PM (Mika Westerberg, Srinidhi
         Kasagar).
    
       - ACPI device registration code reorganization to separate the
         sysfs-related code and bus type operations from the rest (Rafael J
         Wysocki).
    
       - Assorted cleanups in the ACPI core (Jarkko Nikula, Mathias Krause,
         Andy Shevchenko, Rafael J Wysocki, Nicolas Iooss).
    
       - ACPI cpufreq driver and ia64 cpufreq driver fixes and cleanups (Pan
         Xinhui, Rafael J Wysocki).
    
       - cpufreq core cleanups on top of the previous changes allowing it to
         preseve its sysfs directories over system suspend/resume (Viresh
         Kumar, Rafael J Wysocki, Sebastian Andrzej Siewior).
    
       - cpufreq fixes and cleanups related to governors (Viresh Kumar).
    
       - cpufreq updates (core and the cpufreq-dt driver) related to the
         turbo/boost mode support (Viresh Kumar, Bartlomiej Zolnierkiewicz).
    
       - New DT bindings for Operating Performance Points (OPP), support for
         them in the OPP framework and in the cpufreq-dt driver plus related
         OPP framework fixes and cleanups (Viresh Kumar).
    
       - cpufreq powernv driver updates (Shilpasri G Bhat).
    
       - New cpufreq driver for Mediatek MT8173 (Pi-Cheng Chen).
    
       - Assorted cpufreq driver (speedstep-lib, sfi, integrator) cleanups
         and fixes (Abhilash Jindal, Andrzej Hajda, Cristian Ardelean).
    
       - intel_pstate driver updates including Skylake-S support, support
         for enabling HW P-states per CPU and an additional vendor bypass
         list entry (Kristen Carlson Accardi, Chen Yu, Ethan Zhao).
    
       - cpuidle core fixes related to the handling of coupled idle states
         (Xunlei Pang).
    
       - intel_idle driver updates including Skylake Client support and
         support for freeze-mode-specific idle states (Len Brown).
    
       - Driver core updates related to power management (Andy Shevchenko,
         Rafael J Wysocki).
    
       - Generic power domains framework fixes and cleanups (Jon Hunter,
         Geert Uytterhoeven, Rajendra Nayak, Ulf Hansson).
    
       - Device PM QoS framework update to allow the latency tolerance
         setting to be exposed to user space via sysfs (Mika Westerberg).
    
       - devfreq support for PPMUv2 in Exynos5433 and a fix for an incorrect
         exynos-ppmu DT binding (Chanwoo Choi, Javier Martinez Canillas).
    
       - System sleep support updates (Alan Stern, Len Brown, SungEun Kim).
    
       - rockchip-io AVS support updates (Heiko Stuebner).
    
       - PM core clocks support fixup (Colin Ian King).
    
       - Power capping RAPL driver update including support for Skylake H/S
         and Broadwell-H (Radivoje Jovanovic, Seiichi Ikarashi).
    
       - Generic device properties framework fixes related to the handling
         of static (driver-provided) property sets (Andy Shevchenko).
    
       - turbostat and cpupower updates (Len Brown, Shilpasri G Bhat,
         Shreyas B Prabhu)"
    
    * tag 'pm+acpi-4.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (180 commits)
      cpufreq: speedstep-lib: Use monotonic clock
      cpufreq: powernv: Increase the verbosity of OCC console messages
      cpufreq: sfi: use kmemdup rather than duplicating its implementation
      cpufreq: drop !cpufreq_driver check from cpufreq_parse_governor()
      cpufreq: rename cpufreq_real_policy as cpufreq_user_policy
      cpufreq: remove redundant 'policy' field from user_policy
      cpufreq: remove redundant 'governor' field from user_policy
      cpufreq: update user_policy.* on success
      cpufreq: use memcpy() to copy policy
      cpufreq: remove redundant CPUFREQ_INCOMPATIBLE notifier event
      cpufreq: mediatek: Add MT8173 cpufreq driver
      dt-bindings: mediatek: Add MT8173 CPU DVFS clock bindings
      PM / Domains: Fix typo in description of genpd_dev_pm_detach()
      PM / Domains: Remove unusable governor dummies
      PM / Domains: Make pm_genpd_init() available to modules
      PM / domains: Align column headers and data in pm_genpd_summary output
      powercap / RAPL: disable the 2nd power limit properly
      tools: cpupower: Fix error when running cpupower monitor
      PM / OPP: Drop unlikely before IS_ERR(_OR_NULL)
      PM / OPP: Fix static checker warning (broken 64bit big endian systems)
      ...

commit 811a4e6fce09bc9239c664c6a1a53645a678c303
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Jun 10 16:55:00 2015 +0800

    PCI: Add helpers to manage pci_dev->irq and pci_dev->irq_managed
    
    Add pci_has_managed_irq(), pci_set_managed_irq(), and
    pci_reset_managed_irq() to simplify code.  No functional change.
    
    [bhelgaas: changelog]
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index d1aad6900b4c..afa16c557c17 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -412,7 +412,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 		return 0;
 	}
 
-	if (dev->irq_managed && dev->irq > 0)
+	if (pci_has_managed_irq(dev))
 		return 0;
 
 	entry = acpi_pci_irq_lookup(dev, pin);
@@ -457,8 +457,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 		kfree(entry);
 		return rc;
 	}
-	dev->irq = rc;
-	dev->irq_managed = 1;
+	pci_set_managed_irq(dev, rc);
 
 	if (link)
 		snprintf(link_desc, sizeof(link_desc), " -> Link[%s]", link);
@@ -481,7 +480,7 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	u8 pin;
 
 	pin = dev->pin;
-	if (!pin || !dev->irq_managed || dev->irq <= 0)
+	if (!pin || !pci_has_managed_irq(dev))
 		return;
 
 	entry = acpi_pci_irq_lookup(dev, pin);
@@ -503,7 +502,6 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	dev_dbg(&dev->dev, "PCI INT %c disabled\n", pin_name(pin));
 	if (gsi >= 0) {
 		acpi_unregister_gsi(gsi);
-		dev->irq_managed = 0;
-		dev->irq = 0;
+		pci_reset_managed_irq(dev);
 	}
 }

commit 991de2e59090e55c65a7f59a049142e3c480f7bd
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Jun 10 16:54:59 2015 +0800

    PCI, x86: Implement pcibios_alloc_irq() and pcibios_free_irq()
    
    To support IOAPIC hotplug, we need to allocate PCI IRQ resources on demand
    and free them when not used anymore.
    
    Implement pcibios_alloc_irq() and pcibios_free_irq() to dynamically
    allocate and free PCI IRQs.
    
    Remove mp_should_keep_irq(), which is no longer used.
    
    [bhelgaas: changelog]
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 304eccb0ae5c..d1aad6900b4c 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -484,14 +484,6 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	if (!pin || !dev->irq_managed || dev->irq <= 0)
 		return;
 
-	/* Keep IOAPIC pin configuration when suspending */
-	if (dev->dev.power.is_prepared)
-		return;
-#ifdef	CONFIG_PM
-	if (dev->dev.power.runtime_status == RPM_SUSPENDING)
-		return;
-#endif
-
 	entry = acpi_pci_irq_lookup(dev, pin);
 	if (!entry)
 		return;
@@ -512,5 +504,6 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	if (gsi >= 0) {
 		acpi_unregister_gsi(gsi);
 		dev->irq_managed = 0;
+		dev->irq = 0;
 	}
 }

commit 4c62dbbce902cf2afa88cac89ec67c828160f431
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Jun 26 11:27:41 2015 +0300

    ACPI: Remove FSF mailing addresses
    
    There is no need to carry potentially outdated Free Software Foundation
    mailing address in file headers since the COPYING file includes it.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 304eccb0ae5c..25fff35df82c 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -19,10 +19,6 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  *  General Public License for more details.
  *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 

commit 43c9fad942b5afb9e03801c0721d83160fa5b0dd
Merge: cb8a4deaf9b2 d461003574eb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 23 14:18:07 2015 -0700

    Merge tag 'pm+acpi-4.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "The rework of backlight interface selection API from Hans de Goede
      stands out from the number of commits and the number of affected
      places perspective.  The cpufreq core fixes from Viresh Kumar are
      quite significant too as far as the number of commits goes and because
      they should reduce CPU online/offline overhead quite a bit in the
      majority of cases.
    
      From the new featues point of view, the ACPICA update (to upstream
      revision 20150515) adding support for new ACPI 6 material to ACPICA is
      the one that matters the most as some new significant features will be
      based on it going forward.  Also included is an update of the ACPI
      device power management core to follow ACPI 6 (which in turn reflects
      the Windows' device PM implementation), a PM core extension to support
      wakeup interrupts in a more generic way and support for the ACPI _CCA
      device configuration object.
    
      The rest is mostly fixes and cleanups all over and some documentation
      updates, including new DT bindings for Operating Performance Points.
    
      There is one fix for a regression introduced in the 4.1 cycle, but it
      adds quite a number of lines of code, it wasn't really ready before
      Thursday and you were on vacation, so I refrained from pushing it on
      the last minute for 4.1.
    
      Specifics:
    
       - ACPICA update to upstream revision 20150515 including basic support
         for ACPI 6 features: new ACPI tables introduced by ACPI 6 (STAO,
         XENV, WPBT, NFIT, IORT), changes related to the other tables (DTRM,
         FADT, LPIT, MADT), new predefined names (_BTH, _CR3, _DSD, _LPI,
         _MTL, _PRR, _RDI, _RST, _TFP, _TSN), fixes and cleanups (Bob Moore,
         Lv Zheng).
    
       - ACPI device power management core code update to follow ACPI 6
         which reflects the ACPI device power management implementation in
         Windows (Rafael J Wysocki).
    
       - rework of the backlight interface selection logic to reduce the
         number of kernel command line options and improve the handling of
         DMI quirks that may be involved in that and to make the code
         generally more straightforward (Hans de Goede).
    
       - fixes for the ACPI Embedded Controller (EC) driver related to the
         handling of EC transactions (Lv Zheng).
    
       - fix for a regression related to the ACPI resources management and
         resulting from a recent change of ACPI initialization code ordering
         (Rafael J Wysocki).
    
       - fix for a system initialization regression related to ACPI
         introduced during the 3.14 cycle and caused by running the code
         that switches the platform over to the ACPI mode too early in the
         initialization sequence (Rafael J Wysocki).
    
       - support for the ACPI _CCA device configuration object related to
         DMA cache coherence (Suravee Suthikulpanit).
    
       - ACPI/APEI fixes and cleanups (Jiri Kosina, Borislav Petkov).
    
       - ACPI battery driver cleanups (Luis Henriques, Mathias Krause).
    
       - ACPI processor driver cleanups (Hanjun Guo).
    
       - cleanups and documentation update related to the ACPI device
         properties interface based on _DSD (Rafael J Wysocki).
    
       - ACPI device power management fixes (Rafael J Wysocki).
    
       - assorted cleanups related to ACPI (Dominik Brodowski, Fabian
         Frederick, Lorenzo Pieralisi, Mathias Krause, Rafael J Wysocki).
    
       - fix for a long-standing issue causing General Protection Faults to
         be generated occasionally on return to user space after resume from
         ACPI-based suspend-to-RAM on 32-bit x86 (Ingo Molnar).
    
       - fix to make the suspend core code return -EBUSY consistently in all
         cases when system suspend is aborted due to wakeup detection (Ruchi
         Kandoi).
    
       - support for automated device wakeup IRQ handling allowing drivers
         to make their PM support more starightforward (Tony Lindgren).
    
       - new tracepoints for suspend-to-idle tracing and rework of the
         prepare/complete callbacks tracing in the PM core (Todd E Brandt,
         Rafael J Wysocki).
    
       - wakeup sources framework enhancements (Jin Qian).
    
       - new macro for noirq system PM callbacks (Grygorii Strashko).
    
       - assorted cleanups related to system suspend (Rafael J Wysocki).
    
       - cpuidle core cleanups to make the code more efficient (Rafael J
         Wysocki).
    
       - powernv/pseries cpuidle driver update (Shilpasri G Bhat).
    
       - cpufreq core fixes related to CPU online/offline that should reduce
         the overhead of these operations quite a bit, unless the CPU in
         question is physically going away (Viresh Kumar, Saravana Kannan).
    
       - serialization of cpufreq governor callbacks to avoid race
         conditions in some cases (Viresh Kumar).
    
       - intel_pstate driver fixes and cleanups (Doug Smythies, Prarit
         Bhargava, Joe Konno).
    
       - cpufreq driver (arm_big_little, cpufreq-dt, qoriq) updates (Sudeep
         Holla, Felipe Balbi, Tang Yuantian).
    
       - assorted cleanups in cpufreq drivers and core (Shailendra Verma,
         Fabian Frederick, Wang Long).
    
       - new Device Tree bindings for representing Operating Performance
         Points (Viresh Kumar).
    
       - updates for the common clock operations support code in the PM core
         (Rajendra Nayak, Geert Uytterhoeven).
    
       - PM domains core code update (Geert Uytterhoeven).
    
       - Intel Knights Landing support for the RAPL (Running Average Power
         Limit) power capping driver (Dasaratharaman Chandramouli).
    
       - fixes related to the floor frequency setting on Atom SoCs in the
         RAPL power capping driver (Ajay Thomas).
    
       - runtime PM framework documentation update (Ben Dooks).
    
       - cpupower tool fix (Herton R Krzesinski)"
    
    * tag 'pm+acpi-4.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (194 commits)
      cpuidle: powernv/pseries: Auto-promotion of snooze to deeper idle state
      x86: Load __USER_DS into DS/ES after resume
      PM / OPP: Add binding for 'opp-suspend'
      PM / OPP: Allow multiple OPP tables to be passed via DT
      PM / OPP: Add new bindings to address shortcomings of existing bindings
      ACPI: Constify ACPI device IDs in documentation
      ACPI / enumeration: Document the rules regarding the PRP0001 device ID
      ACPI / video: Make acpi_video_unregister_backlight() private
      acpi-video-detect: Remove old API
      toshiba-acpi: Port to new backlight interface selection API
      thinkpad-acpi: Port to new backlight interface selection API
      sony-laptop: Port to new backlight interface selection API
      samsung-laptop: Port to new backlight interface selection API
      msi-wmi: Port to new backlight interface selection API
      msi-laptop: Port to new backlight interface selection API
      intel-oaktrail: Port to new backlight interface selection API
      ideapad-laptop: Port to new backlight interface selection API
      fujitsu-laptop: Port to new backlight interface selection API
      eeepc-laptop: Port to new backlight interface selection API
      dell-wmi: Port to new backlight interface selection API
      ...

commit 917bfd93d3c9c644743940deaf8fe0cff77947eb
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue May 26 15:11:51 2015 -0600

    ACPI / PCI: Account for ARI in _PRT lookups
    
    The PCIe specification, rev 3.0, section 2.2.8.1, contains the following
    implementation note:
    
      Virtual Wire Mapping for INTx Interrupts From ARI Devices
    
      The implied Device Number for an ARI Device is 0.  When ARI-aware
      software (including BIOS and operating system) enables ARI Forwarding in
      the Downstream Port immediately above an ARI Device in order to access
      its Extended Functions, software must comprehend that the Downstream Port
      will use Device Number 0 for the virtual wire mappings of INTx interrupts
      coming from all Functions of the ARI Device.  If non-ARI-aware software
      attempts to determine the virtual wire mappings for Extended Functions,
      it can come up with incorrect mappings by examining the traditional
      Device Number field and finding it to be non-0.
    
    We account for this in pci_swizzle_interrupt_pin(), but it looks like we
    miss it here, looking for a _PRT entry with a slot matching the ARI device
    slot number.  This can cause errors like:
    
      pcieport 0000:80:03.0: can't derive routing for PCI INT B
      sfc 0000:82:01.1: PCI INT B: no GSI
    
    pci_dev.irq is then invalid, resulting in errors for drivers that attempt
    to enable INTx on the device.  Fix by using slot 0 for ARI enabled devices.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Don Dutile <ddutile@redhat.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index b1def411c0b8..4db10b189104 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -163,7 +163,7 @@ static int acpi_pci_irq_check_entry(acpi_handle handle, struct pci_dev *dev,
 {
 	int segment = pci_domain_nr(dev->bus);
 	int bus = dev->bus->number;
-	int device = PCI_SLOT(dev->devfn);
+	int device = pci_ari_enabled(dev->bus) ? 0 : PCI_SLOT(dev->devfn);
 	struct acpi_prt_entry *entry;
 
 	if (((prt->address >> 16) & 0xffff) != device ||

commit cae756fbaa02a24f868330e68631b3f5ea345cb8
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Thu May 21 23:29:26 2015 +0800

    ACPI / PCI: remove stale list_head in struct acpi_prt_entry
    
    list_head "list" in struct acpi_prt_entry was used to connect
    _PRT entries for PCI irq, but after commit 181380b702ee ("PCI/ACPI:
    Don't cache _PRT, and don't associate them with bus numbers"),
    the list head for _PRT entries was removed, but left "list" in
    struct acpi_prt_entry which is useless and stale, remove it now.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index b1def411c0b8..03e4b6c49c6d 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -44,7 +44,6 @@
 ACPI_MODULE_NAME("pci_irq");
 
 struct acpi_prt_entry {
-	struct list_head	list;
 	struct acpi_pci_id	id;
 	u8			pin;
 	acpi_handle		link;

commit 9e8ce4b96b781b003e3174fbbc62e1d4388c8b8f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 20 14:56:19 2015 +0100

    Revert "x86/PCI: Refine the way to release PCI IRQ resources"
    
    Commit b4b55cda5874 (Refine the way to release PCI IRQ resources)
    introduced a regression in the PCI IRQ resource management by causing
    the IRQ resource of a device, established when pci_enabled_device()
    is called on a fully disabled device, to be released when the driver
    is unbound from the device, regardless of the enable_cnt.
    
    This leads to the situation that an ill-behaved driver can now make a
    device unusable to subsequent drivers by an imbalance in their use of
    pci_enable/disable_device().  That is a serious problem for secondary
    drivers like vfio-pci, which are innocent of the transgressions of
    the previous driver.
    
    Since the solution of this problem is not immediate and requires
    further discussion, revert commit b4b55cda5874 and the issue it was
    supposed to address (a bug related to xen-pciback) will be taken
    care of in a different way going forward.
    
    Reported-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index e7f718d6918a..b1def411c0b8 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -485,6 +485,14 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	if (!pin || !dev->irq_managed || dev->irq <= 0)
 		return;
 
+	/* Keep IOAPIC pin configuration when suspending */
+	if (dev->dev.power.is_prepared)
+		return;
+#ifdef	CONFIG_PM
+	if (dev->dev.power.runtime_status == RPM_SUSPENDING)
+		return;
+#endif
+
 	entry = acpi_pci_irq_lookup(dev, pin);
 	if (!entry)
 		return;
@@ -505,6 +513,5 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	if (gsi >= 0) {
 		acpi_unregister_gsi(gsi);
 		dev->irq_managed = 0;
-		dev->irq = 0;
 	}
 }

commit b4b55cda587442477a3a9f0669e26bba4b7800c0
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Feb 5 13:44:47 2015 +0800

    x86/PCI: Refine the way to release PCI IRQ resources
    
    Some PCI device drivers assume that pci_dev->irq won't change after
    calling pci_disable_device() and pci_enable_device() during suspend and
    resume.
    
    Commit c03b3b0738a5 ("x86, irq, mpparse: Release IOAPIC pin when
    PCI device is disabled") frees PCI IRQ resources when pci_disable_device()
    is called and reallocate IRQ resources when pci_enable_device() is
    called again. This breaks above assumption. So commit 3eec595235c1
    ("x86, irq, PCI: Keep IRQ assignment for PCI devices during
    suspend/hibernation") and 9eabc99a635a ("x86, irq, PCI: Keep IRQ
    assignment for runtime power management") fix the issue by avoiding
    freeing/reallocating IRQ resources during PCI device suspend/resume.
    They achieve this by checking dev.power.is_prepared and
    dev.power.runtime_status.  PM maintainer, Rafael, then pointed out that
    it's really an ugly fix which leaking PM internal state information to
    IRQ subsystem.
    
    Recently David Vrabel <david.vrabel@citrix.com> also reports an
    regression in pciback driver caused by commit cffe0a2b5a34 ("x86, irq:
    Keep balance of IOAPIC pin reference count"). Please refer to:
    http://lkml.org/lkml/2015/1/14/546
    
    So this patch refine the way to release PCI IRQ resources. Instead of
    releasing PCI IRQ resources in pci_disable_device()/
    pcibios_disable_device(), we now release it at driver unbinding
    notification BUS_NOTIFY_UNBOUND_DRIVER. In other word, we only release
    PCI IRQ resources when there's no driver bound to the PCI device, and
    it keeps the assumption that pci_dev->irq won't through multiple
    invocation of pci_enable_device()/pci_disable_device().
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index b1def411c0b8..e7f718d6918a 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -485,14 +485,6 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	if (!pin || !dev->irq_managed || dev->irq <= 0)
 		return;
 
-	/* Keep IOAPIC pin configuration when suspending */
-	if (dev->dev.power.is_prepared)
-		return;
-#ifdef	CONFIG_PM
-	if (dev->dev.power.runtime_status == RPM_SUSPENDING)
-		return;
-#endif
-
 	entry = acpi_pci_irq_lookup(dev, pin);
 	if (!entry)
 		return;
@@ -513,5 +505,6 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	if (gsi >= 0) {
 		acpi_unregister_gsi(gsi);
 		dev->irq_managed = 0;
+		dev->irq = 0;
 	}
 }

commit 9889eaeb7c999cae64006bb98c47f40f412ec875
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue Jan 20 10:21:06 2015 +0800

    ACPI: pci: Do not clear pci_dev->irq in acpi_pci_irq_disable()
    
    Xen pciback driver assumes that pci_dev->irq won't change after calling
    pci_disable_device(). But commit cffe0a2b5a34c95a4dadc9ec7132690a5b0f6687
    ("x86, irq: Keep balance of IOAPIC pin reference count") frees irq
    resources and resets pci_dev->irq to zero when pci_disable_device() is
    called.
    
    So this is a hotfix for 3.19 to avoid resetting pci_dev->irq, and
    another proper fix will be prepared for next merging window.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Tested-by: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Len Brown <lenb@kernel.org>
    Link: http://lkml.kernel.org/r/1421720467-7709-3-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 5277a0ee5704..b1def411c0b8 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -512,7 +512,6 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	dev_dbg(&dev->dev, "PCI INT %c disabled\n", pin_name(pin));
 	if (gsi >= 0) {
 		acpi_unregister_gsi(gsi);
-		dev->irq = 0;
 		dev->irq_managed = 0;
 	}
 }

commit e589c9e13aeb0c5539bf1314b3a78442ea8fc0c2
Merge: 4bb9374e0bd4 719b530cdc70
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 19 14:02:02 2014 -0800

    Merge branch 'x86-apic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 apic updates from Thomas Gleixner:
     "After stopping the full x86/apic branch, I took some time to go
      through the first block of patches again, which are mostly cleanups
      and preparatory work for the irqdomain conversion and ioapic hotplug
      support.
    
      Unfortunaly one of the real problematic commits was right at the
      beginning, so I rebased this portion of the pending patches without
      the offenders.
    
      It would be great to get this into 3.19.  That makes reworking the
      problematic parts simpler.  The usual tip testing did not unearth any
      issues and it is fully bisectible now.
    
      I'm pretty confident that this wont affect the calmness of the xmas
      season.
    
      Changes:
       - Split the convoluted io_apic.c code into domain specific parts
         (vector, ioapic, msi, htirq)
       - Introduce proper helper functions to retrieve irq specific data
         instead of open coded dereferencing of pointers
       - Preparatory work for ioapic hotplug and irqdomain conversion
       - Removal of the non functional pci-ioapic driver
       - Removal of unused irq entry stubs
       - Make native_smp_prepare_cpus() preemtible to avoid GFP_ATOMIC
         allocations for everything which is called from there.
       - Small cleanups and fixes"
    
    * 'x86-apic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (36 commits)
      iommu/amd: Use helpers to access irq_cfg data structure associated with IRQ
      iommu/vt-d: Use helpers to access irq_cfg data structure associated with IRQ
      x86: irq_remapping: Use helpers to access irq_cfg data structure associated with IRQ
      x86, irq: Use helpers to access irq_cfg data structure associated with IRQ
      x86, irq: Make MSI and HT_IRQ indepenent of X86_IO_APIC
      x86, irq: Move IRQ initialization routines from io_apic.c into vector.c
      x86, irq: Move IOAPIC related declarations from hw_irq.h into io_apic.h
      x86, irq: Move HT IRQ related code from io_apic.c into htirq.c
      x86, irq: Move PCI MSI related code from io_apic.c into msi.c
      x86, irq: Replace printk(KERN_LVL) with pr_lvl() utilities
      x86, irq: Make UP version of irq_complete_move() an inline stub
      x86, irq: Move local APIC related code from io_apic.c into vector.c
      x86, irq: Introduce helpers to access struct irq_cfg
      x86, irq: Protect __clear_irq_vector() with vector_lock
      x86, irq: Rename local APIC related functions in io_apic.c as apic_xxx()
      x86, irq: Refine hw_irq.h to prepare for irqdomain support
      x86, irq: Convert irq_2_pin list to generic list
      x86, irq: Kill useless parameter 'irq_attr' of IO_APIC_get_PCI_irq_vector()
      x86, irq, acpi: Get rid of special handling of GSI for ACPI SCI
      x86, irq: Introduce helper to check whether an IOAPIC has been registered
      ...

commit cffe0a2b5a34c95a4dadc9ec7132690a5b0f6687
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Oct 27 13:21:42 2014 +0800

    x86, irq: Keep balance of IOAPIC pin reference count
    
    To keep balance of IOAPIC pin reference count, we need to protect
    pirq_enable_irq(), acpi_pci_irq_enable() and intel_mid_pci_irq_enable()
    from reentrance. There are two cases which will cause reentrance.
    
    The first case is caused by suspend/hibernation. If pcibios_disable_irq
    is called during suspending/hibernating, we don't release the assigned
    IRQ number, otherwise it may break the suspend/hibernation. So late when
    pcibios_enable_irq is called during resume, we shouldn't allocate IRQ
    number again.
    
    The second case is that function acpi_pci_irq_enable() may be called
    twice for PCI devices present at boot time as below:
    1) pci_acpi_init()
            --> acpi_pci_irq_enable() if pci_routeirq is true
    2) pci_enable_device()
            --> pcibios_enable_device()
                    --> acpi_pci_irq_enable()
    We can't kill kernel parameter pci_routeirq yet because it's still
    needed for debugging purpose.
    
    So flag irq_managed is introduced to track whether IRQ number is
    assigned by OS and to protect pirq_enable_irq(), acpi_pci_irq_enable()
    and intel_mid_pci_irq_enable() from reentrance.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Len Brown <lenb@kernel.org>
    Link: http://lkml.kernel.org/r/1414387308-27148-13-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 6e6b80eb0bba..5f1fdca65e5f 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -413,6 +413,9 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 		return 0;
 	}
 
+	if (dev->irq_managed && dev->irq > 0)
+		return 0;
+
 	entry = acpi_pci_irq_lookup(dev, pin);
 	if (!entry) {
 		/*
@@ -456,6 +459,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 		return rc;
 	}
 	dev->irq = rc;
+	dev->irq_managed = 1;
 
 	if (link)
 		snprintf(link_desc, sizeof(link_desc), " -> Link[%s]", link);
@@ -478,7 +482,7 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	u8 pin;
 
 	pin = dev->pin;
-	if (!pin)
+	if (!pin || !dev->irq_managed || dev->irq <= 0)
 		return;
 
 	/* Keep IOAPIC pin configuration when suspending */
@@ -506,6 +510,9 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	 */
 
 	dev_dbg(&dev->dev, "PCI INT %c disabled\n", pin_name(pin));
-	if (gsi >= 0 && dev->irq > 0)
+	if (gsi >= 0) {
 		acpi_unregister_gsi(gsi);
+		dev->irq = 0;
+		dev->irq_managed = 0;
+	}
 }

commit 5de21bb998b8e816e6a1df1f2c04d95fb6e27a5d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 27 22:38:23 2014 +0100

    ACPI / PM: Drop CONFIG_PM_RUNTIME from the ACPI core
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so quite a few
    depend on CONFIG_PM.
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM in the ACPI core code.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 6e6b80eb0bba..7cc4e33179f9 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -484,7 +484,7 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	/* Keep IOAPIC pin configuration when suspending */
 	if (dev->dev.power.is_prepared)
 		return;
-#ifdef	CONFIG_PM_RUNTIME
+#ifdef	CONFIG_PM
 	if (dev->dev.power.runtime_status == RPM_SUSPENDING)
 		return;
 #endif

commit 9eabc99a635a77cbf0948ce17d3cbc2b51680d4a
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Fri Aug 29 17:26:23 2014 +0800

    x86, irq, PCI: Keep IRQ assignment for runtime power management
    
    Now IOAPIC driver dynamically allocates IRQ numbers for IOAPIC pins.
    We need to keep IRQ assignment for PCI devices during runtime power
    management, otherwise it may cause failure of device wakeups.
    
    Commit 3eec595235c17a7 "x86, irq, PCI: Keep IRQ assignment for PCI
    devices during suspend/hibernation" has fixed the issue for suspend/
    hibernation, we also need the same fix for runtime device sleep too.
    
    Fix: https://bugzilla.kernel.org/show_bug.cgi?id=83271
    Reported-and-Tested-by: EmanueL Czirai <amanual@openmailbox.org>
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: EmanueL Czirai <amanual@openmailbox.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Grant Likely <grant.likely@linaro.org>
    Link: http://lkml.kernel.org/r/1409304383-18806-1-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index c96887d5289e..6e6b80eb0bba 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -484,6 +484,10 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	/* Keep IOAPIC pin configuration when suspending */
 	if (dev->dev.power.is_prepared)
 		return;
+#ifdef	CONFIG_PM_RUNTIME
+	if (dev->dev.power.runtime_status == RPM_SUSPENDING)
+		return;
+#endif
 
 	entry = acpi_pci_irq_lookup(dev, pin);
 	if (!entry)

commit 3eec595235c17a74094daa1e02d1b0af2e9a7125
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Fri Aug 8 14:07:51 2014 +0800

    x86, irq, PCI: Keep IRQ assignment for PCI devices during suspend/hibernation
    
    Now IOAPIC driver dynamically allocates IRQ numbers for IOAPIC pins.
    We need to keep IRQ assignment for PCI devices during suspend/hibernation,
    otherwise it may cause failure of suspend/hibernation due to:
    1) Device driver calls pci_enable_device() to allocate an IRQ number
       and register interrupt handler on the returned IRQ.
    2) Device driver's suspend callback calls pci_disable_device() and
       release assigned IRQ in turn.
    3) Device driver's resume callback calls pci_enable_device() to
       allocate IRQ number again. A different IRQ number may be assigned
       by IOAPIC driver this time.
    4) Now the hardware delivers interrupt to the new IRQ but interrupt
       handler is still registered against the old IRQ, so it breaks
       suspend/hibernation.
    
    To fix this issue, we keep IRQ assignment during suspend/hibernation.
    Flag pci_dev.dev.power.is_prepared is used to detect that
    pci_disable_device() is called during suspend/hibernation.
    
    Reported-and-Tested-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Len Brown <lenb@kernel.org>
    Link: http://lkml.kernel.org/r/1407478071-29399-1-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 6ba463ceccc6..c96887d5289e 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -481,6 +481,10 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	if (!pin)
 		return;
 
+	/* Keep IOAPIC pin configuration when suspending */
+	if (dev->dev.power.is_prepared)
+		return;
+
 	entry = acpi_pci_irq_lookup(dev, pin);
 	if (!entry)
 		return;

commit 6a38fa0e3c94dfd1394a71a2d47c9c4d47367374
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue Jun 10 14:16:27 2014 +0800

    x86, irq, ACPI: Release IOAPIC pin when PCI device is disabled
    
    Release IOAPIC pin associated with PCI device when the PCI device
    is disabled.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Link: http://lkml.kernel.org/r/1402380987-32577-1-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 9c62340c2360..6ba463ceccc6 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -498,5 +498,6 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	 */
 
 	dev_dbg(&dev->dev, "PCI INT %c disabled\n", pin_name(pin));
-	acpi_unregister_gsi(gsi);
+	if (gsi >= 0 && dev->irq > 0)
+		acpi_unregister_gsi(gsi);
 }

commit c1aaae673f68448253905bd9af6c6f9d31a7769a
Author: Tomasz Nowicki <tomasz.nowicki@linaro.org>
Date:   Thu Feb 20 14:27:46 2014 +0100

    ACPI / PCI: Do not call ISA-specific code if ISA is not supported
    
    This commit moves ISA-specific code to separate function and makes that
    function depend on CONFIG_{E}ISA so that we do not have to maintain
    acpi_isa_irq_to_gsi() function for architectures which do not support ISA.
    
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 361b40c10c3f..9c62340c2360 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -370,6 +370,30 @@ static struct acpi_prt_entry *acpi_pci_irq_lookup(struct pci_dev *dev, int pin)
 	return NULL;
 }
 
+#if IS_ENABLED(CONFIG_ISA) || IS_ENABLED(CONFIG_EISA)
+static int acpi_isa_register_gsi(struct pci_dev *dev)
+{
+	u32 dev_gsi;
+
+	/* Interrupt Line values above 0xF are forbidden */
+	if (dev->irq > 0 && (dev->irq <= 0xF) &&
+	    (acpi_isa_irq_to_gsi(dev->irq, &dev_gsi) == 0)) {
+		dev_warn(&dev->dev, "PCI INT %c: no GSI - using ISA IRQ %d\n",
+			 pin_name(dev->pin), dev->irq);
+		acpi_register_gsi(&dev->dev, dev_gsi,
+				  ACPI_LEVEL_SENSITIVE,
+				  ACPI_ACTIVE_LOW);
+		return 0;
+	}
+	return -EINVAL;
+}
+#else
+static inline int acpi_isa_register_gsi(struct pci_dev *dev)
+{
+	return -ENODEV;
+}
+#endif
+
 int acpi_pci_irq_enable(struct pci_dev *dev)
 {
 	struct acpi_prt_entry *entry;
@@ -416,19 +440,9 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	 * driver reported one, then use it. Exit in any case.
 	 */
 	if (gsi < 0) {
-		u32 dev_gsi;
-		/* Interrupt Line values above 0xF are forbidden */
-		if (dev->irq > 0 && (dev->irq <= 0xF) &&
-		    (acpi_isa_irq_to_gsi(dev->irq, &dev_gsi) == 0)) {
-			dev_warn(&dev->dev, "PCI INT %c: no GSI - using ISA IRQ %d\n",
-				 pin_name(pin), dev->irq);
-			acpi_register_gsi(&dev->dev, dev_gsi,
-					  ACPI_LEVEL_SENSITIVE,
-					  ACPI_ACTIVE_LOW);
-		} else {
+		if (acpi_isa_register_gsi(dev))
 			dev_warn(&dev->dev, "PCI INT %c: no GSI\n",
 				 pin_name(pin));
-		}
 
 		kfree(entry);
 		return 0;

commit b685f3b1744061aa9ad822548ba9c674de5be7c6
Author: Tomasz Nowicki <tomasz.nowicki@linaro.org>
Date:   Mon Feb 10 14:00:11 2014 +0100

    ACPI / PCI: Fix memory leak in acpi_pci_irq_enable()
    
    acpi_pci_link_allocate_irq() can return negative gsi even if
    entry != NULL.  For that case we have a memory leak, so free
    entry before returning from acpi_pci_irq_enable() for gsi < 0.
    
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: All applicable <stable@vger.kernel.org>
    [rjw: Subject and changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 52d45ea2bc4f..361b40c10c3f 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -430,6 +430,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 				 pin_name(pin));
 		}
 
+		kfree(entry);
 		return 0;
 	}
 

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 41c5e1b799ef..52d45ea2bc4f 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -37,8 +37,6 @@
 #include <linux/pci.h>
 #include <linux/acpi.h>
 #include <linux/slab.h>
-#include <acpi/acpi_bus.h>
-#include <acpi/acpi_drivers.h>
 
 #define PREFIX "ACPI: "
 

commit 181380b702eee1a9aca51354d7b87c7b08541fcf
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Feb 16 11:58:34 2013 -0700

    PCI/ACPI: Don't cache _PRT, and don't associate them with bus numbers
    
    Previously, we cached _PRT (PCI routing table, ACPI 5.0 sec 6.2.12)
    contents and associated each _PRT entry with a PCI bus number.  The bus
    number association means dependencies on PCI device enumeration and bus
    number assignment, as well as on the PCI/ACPI binding process.
    
    After 4f535093cf ("PCI: Put pci_dev in device tree as early as possible"),
    these dependencies caused the IRQ issues reported by Peter:
    
        pci 0000:00:1e.0: PCI bridge to [bus 09] (subtractive decode)
        pci 0000:00:1e.0: can't derive routing for PCI INT A
        snd_ctxfi 0000:09:02.0: PCI INT A: no GSI - using ISA IRQ 5
        irq 18: nobody cared (try booting with the "irqpoll" option)
    
    This patch removes _PRT caching.  Instead, we evaluate _PRT as needed
    in the pci_enable_device() path.  This also removes the dependency on
    PCI bus numbers: we can simply look at the _PRT associated with each
    bridge as we walk upstream toward the root.
    
    [bhelgaas: changelog]
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=53561
    Reported-and-tested-by: Peter Hurley <peter@hurleysoftware.com>
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 68a921d03247..41c5e1b799ef 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -53,9 +53,6 @@ struct acpi_prt_entry {
 	u32			index;		/* GSI, or link _CRS index */
 };
 
-static LIST_HEAD(acpi_prt_list);
-static DEFINE_SPINLOCK(acpi_prt_lock);
-
 static inline char pin_name(int pin)
 {
 	return 'A' + pin - 1;
@@ -65,28 +62,6 @@ static inline char pin_name(int pin)
                          PCI IRQ Routing Table (PRT) Support
    -------------------------------------------------------------------------- */
 
-static struct acpi_prt_entry *acpi_pci_irq_find_prt_entry(struct pci_dev *dev,
-							  int pin)
-{
-	struct acpi_prt_entry *entry;
-	int segment = pci_domain_nr(dev->bus);
-	int bus = dev->bus->number;
-	int device = PCI_SLOT(dev->devfn);
-
-	spin_lock(&acpi_prt_lock);
-	list_for_each_entry(entry, &acpi_prt_list, list) {
-		if ((segment == entry->id.segment)
-		    && (bus == entry->id.bus)
-		    && (device == entry->id.device)
-		    && (pin == entry->pin)) {
-			spin_unlock(&acpi_prt_lock);
-			return entry;
-		}
-	}
-	spin_unlock(&acpi_prt_lock);
-	return NULL;
-}
-
 /* http://bugzilla.kernel.org/show_bug.cgi?id=4773 */
 static const struct dmi_system_id medion_md9580[] = {
 	{
@@ -184,11 +159,19 @@ static void do_prt_fixups(struct acpi_prt_entry *entry,
 	}
 }
 
-static int acpi_pci_irq_add_entry(acpi_handle handle, int segment, int bus,
-				  struct acpi_pci_routing_table *prt)
+static int acpi_pci_irq_check_entry(acpi_handle handle, struct pci_dev *dev,
+				  int pin, struct acpi_pci_routing_table *prt,
+				  struct acpi_prt_entry **entry_ptr)
 {
+	int segment = pci_domain_nr(dev->bus);
+	int bus = dev->bus->number;
+	int device = PCI_SLOT(dev->devfn);
 	struct acpi_prt_entry *entry;
 
+	if (((prt->address >> 16) & 0xffff) != device ||
+	    prt->pin + 1 != pin)
+		return -ENODEV;
+
 	entry = kzalloc(sizeof(struct acpi_prt_entry), GFP_KERNEL);
 	if (!entry)
 		return -ENOMEM;
@@ -237,43 +220,37 @@ static int acpi_pci_irq_add_entry(acpi_handle handle, int segment, int bus,
 			      entry->id.device, pin_name(entry->pin),
 			      prt->source, entry->index));
 
-	spin_lock(&acpi_prt_lock);
-	list_add_tail(&entry->list, &acpi_prt_list);
-	spin_unlock(&acpi_prt_lock);
+	*entry_ptr = entry;
 
 	return 0;
 }
 
-int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
+static int acpi_pci_irq_find_prt_entry(struct pci_dev *dev,
+			  int pin, struct acpi_prt_entry **entry_ptr)
 {
 	acpi_status status;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	struct acpi_pci_routing_table *entry;
+	acpi_handle handle = NULL;
 
-	/* 'handle' is the _PRT's parent (root bridge or PCI-PCI bridge) */
-	status = acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
-	if (ACPI_FAILURE(status))
-		return -ENODEV;
-
-	printk(KERN_DEBUG "ACPI: PCI Interrupt Routing Table [%s._PRT]\n",
-	       (char *) buffer.pointer);
-
-	kfree(buffer.pointer);
+	if (dev->bus->bridge)
+		handle = ACPI_HANDLE(dev->bus->bridge);
 
-	buffer.length = ACPI_ALLOCATE_BUFFER;
-	buffer.pointer = NULL;
+	if (!handle)
+		return -ENODEV;
 
+	/* 'handle' is the _PRT's parent (root bridge or PCI-PCI bridge) */
 	status = acpi_get_irq_routing_table(handle, &buffer);
 	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRT [%s]",
-				acpi_format_exception(status)));
 		kfree(buffer.pointer);
 		return -ENODEV;
 	}
 
 	entry = buffer.pointer;
 	while (entry && (entry->length > 0)) {
-		acpi_pci_irq_add_entry(handle, segment, bus, entry);
+		if (!acpi_pci_irq_check_entry(handle, dev, pin,
+						 entry, entry_ptr))
+			break;
 		entry = (struct acpi_pci_routing_table *)
 		    ((unsigned long)entry + entry->length);
 	}
@@ -282,23 +259,6 @@ int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 	return 0;
 }
 
-void acpi_pci_irq_del_prt(int segment, int bus)
-{
-	struct acpi_prt_entry *entry, *tmp;
-
-	printk(KERN_DEBUG
-	       "ACPI: Delete PCI Interrupt Routing Table for %04x:%02x\n",
-	       segment, bus);
-	spin_lock(&acpi_prt_lock);
-	list_for_each_entry_safe(entry, tmp, &acpi_prt_list, list) {
-		if (segment == entry->id.segment && bus == entry->id.bus) {
-			list_del(&entry->list);
-			kfree(entry);
-		}
-	}
-	spin_unlock(&acpi_prt_lock);
-}
-
 /* --------------------------------------------------------------------------
                           PCI Interrupt Routing Support
    -------------------------------------------------------------------------- */
@@ -359,12 +319,13 @@ static int acpi_reroute_boot_interrupt(struct pci_dev *dev,
 
 static struct acpi_prt_entry *acpi_pci_irq_lookup(struct pci_dev *dev, int pin)
 {
-	struct acpi_prt_entry *entry;
+	struct acpi_prt_entry *entry = NULL;
 	struct pci_dev *bridge;
 	u8 bridge_pin, orig_pin = pin;
+	int ret;
 
-	entry = acpi_pci_irq_find_prt_entry(dev, pin);
-	if (entry) {
+	ret = acpi_pci_irq_find_prt_entry(dev, pin, &entry);
+	if (!ret && entry) {
 #ifdef CONFIG_X86_IO_APIC
 		acpi_reroute_boot_interrupt(dev, entry);
 #endif /* CONFIG_X86_IO_APIC */
@@ -373,7 +334,7 @@ static struct acpi_prt_entry *acpi_pci_irq_lookup(struct pci_dev *dev, int pin)
 		return entry;
 	}
 
-	/* 
+	/*
 	 * Attempt to derive an IRQ for this device from a parent bridge's
 	 * PCI interrupt routing entry (eg. yenta bridge and add-in card bridge).
 	 */
@@ -393,8 +354,8 @@ static struct acpi_prt_entry *acpi_pci_irq_lookup(struct pci_dev *dev, int pin)
 			pin = bridge_pin;
 		}
 
-		entry = acpi_pci_irq_find_prt_entry(bridge, pin);
-		if (entry) {
+		ret = acpi_pci_irq_find_prt_entry(bridge, pin, &entry);
+		if (!ret && entry) {
 			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 					 "Derived GSI for %s INT %c from %s\n",
 					 pci_name(dev), pin_name(orig_pin),
@@ -470,6 +431,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 			dev_warn(&dev->dev, "PCI INT %c: no GSI\n",
 				 pin_name(pin));
 		}
+
 		return 0;
 	}
 
@@ -477,6 +439,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	if (rc < 0) {
 		dev_warn(&dev->dev, "PCI INT %c: failed to register GSI\n",
 			 pin_name(pin));
+		kfree(entry);
 		return rc;
 	}
 	dev->irq = rc;
@@ -491,6 +454,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 		(triggering == ACPI_LEVEL_SENSITIVE) ? "level" : "edge",
 		(polarity == ACPI_ACTIVE_LOW) ? "low" : "high", dev->irq);
 
+	kfree(entry);
 	return 0;
 }
 
@@ -513,6 +477,8 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	else
 		gsi = entry->index;
 
+	kfree(entry);
+
 	/*
 	 * TBD: It might be worth clearing dev->irq by magic constant
 	 * (e.g. PCI_UNDEFINED_IRQ).

commit 193c0d682525987db59ac3a24531a77e4947aa95
Merge: 8b0cab14951f 1cb73f8c479e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 13 12:14:47 2012 -0800

    Merge tag 'for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI update from Bjorn Helgaas:
     "Host bridge hotplug:
       - Untangle _PRT from struct pci_bus (Bjorn Helgaas)
       - Request _OSC control before scanning root bus (Taku Izumi)
       - Assign resources when adding host bridge (Yinghai Lu)
       - Remove root bus when removing host bridge (Yinghai Lu)
       - Remove _PRT during hot remove (Yinghai Lu)
    
      SRIOV
        - Add sysfs knobs to control numVFs (Don Dutile)
    
      Power management
       - Notify devices when power resource turned on (Huang Ying)
    
      Bug fixes
       - Work around broken _SEG on HP xw9300 (Bjorn Helgaas)
       - Keep runtime PM enabled for unbound PCI devices (Huang Ying)
       - Fix Optimus dual-GPU runtime D3 suspend issue (Dave Airlie)
       - Fix xen frontend shutdown issue (David Vrabel)
       - Work around PLX PCI 9050 BAR alignment erratum (Ian Abbott)
    
      Miscellaneous
       - Add GPL license for drivers/pci/ioapic (Andrew Cooks)
       - Add standard PCI-X, PCIe ASPM register #defines (Bjorn Helgaas)
       - NumaChip remote PCI support (Daniel Blueman)
       - Fix PCIe Link Capabilities Supported Link Speed definition (Jingoo
         Han)
       - Convert dev_printk() to dev_info(), etc (Joe Perches)
       - Add support for non PCI BAR ROM data (Matthew Garrett)
       - Add x86 support for host bridge translation offset (Mike Yoknis)
       - Report success only when every driver supports AER (Vijay
         Pandarathil)"
    
    Fix up trivial conflicts.
    
    * tag 'for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (48 commits)
      PCI: Use phys_addr_t for physical ROM address
      x86/PCI: Add NumaChip remote PCI support
      ath9k: Use standard #defines for PCIe Capability ASPM fields
      iwlwifi: Use standard #defines for PCIe Capability ASPM fields
      iwlwifi: collapse wrapper for pcie_capability_read_word()
      iwlegacy: Use standard #defines for PCIe Capability ASPM fields
      iwlegacy: collapse wrapper for pcie_capability_read_word()
      cxgb3: Use standard #defines for PCIe Capability ASPM fields
      PCI: Add standard PCIe Capability Link ASPM field names
      PCI/portdrv: Use PCI Express Capability accessors
      PCI: Use standard PCIe Capability Link register field names
      x86: Use PCI setup data
      PCI: Add support for non-BAR ROMs
      PCI: Add pcibios_add_device
      EFI: Stash ROMs if they're not in the PCI BAR
      PCI: Add and use standard PCI-X Capability register names
      PCI/PM: Keep runtime PM enabled for unbound PCI devices
      xen-pcifront: Handle backend CLOSED without CLOSING
      PCI: SRIOV control and status via sysfs (documentation)
      PCI/AER: Report success only when every device has AER-aware driver
      ...

commit d4c091f13dc4d30e4af43c0ccf8c82b3277574ca
Merge: 08ab72980a77 261cba2deb7d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 29 21:43:06 2012 +0100

    Merge branch 'acpi-general'
    
    * acpi-general: (38 commits)
      ACPI / thermal: _TMP and _CRT/_HOT/_PSV/_ACx dependency fix
      ACPI: drop unnecessary local variable from acpi_system_write_wakeup_device()
      ACPI: Fix logging when no pci_irq is allocated
      ACPI: Update Dock hotplug error messages
      ACPI: Update Container hotplug error messages
      ACPI: Update Memory hotplug error messages
      ACPI: Update CPU hotplug error messages
      ACPI: Add acpi_handle_<level>() interfaces
      ACPI: remove use of __devexit
      ACPI / PM: Add Sony Vaio VPCEB1S1E to nonvs blacklist.
      ACPI / battery: Correct battery capacity values on Thinkpads
      Revert "ACPI / x86: Add quirk for "CheckPoint P-20-00" to not use bridge _CRS_ info"
      ACPI: create _SUN sysfs file
      ACPI / memhotplug: bind the memory device when the driver is being loaded
      ACPI / memhotplug: don't allow to eject the memory device if it is being used
      ACPI / memhotplug: free memory device if acpi_memory_enable_device() failed
      ACPI / memhotplug: fix memory leak when memory device is unbound from acpi_memhotplug
      ACPI / memhotplug: deal with eject request in hotplug queue
      ACPI / memory-hotplug: add memory offline code to acpi_memory_device_remove()
      ACPI / memory-hotplug: call acpi_bus_trim() to remove memory device
      ...
    
    Conflicts:
            include/linux/acpi.h (two additions at the end of the same file)

commit 66fd3835ac9a3740a7bf953b439e54dbc326d272
Author: Joe Perches <joe@perches.com>
Date:   Wed Nov 21 13:46:04 2012 +0000

    ACPI: Fix logging when no pci_irq is allocated
    
    Work around a defect in the printk subsystem introduced by a
    logging change.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 0eefa12e648c..f2c3d74af23e 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -459,19 +459,19 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	 */
 	if (gsi < 0) {
 		u32 dev_gsi;
-		dev_warn(&dev->dev, "PCI INT %c: no GSI", pin_name(pin));
 		/* Interrupt Line values above 0xF are forbidden */
 		if (dev->irq > 0 && (dev->irq <= 0xF) &&
 		    (acpi_isa_irq_to_gsi(dev->irq, &dev_gsi) == 0)) {
-			printk(" - using ISA IRQ %d\n", dev->irq);
+			dev_warn(&dev->dev, "PCI INT %c: no GSI - using ISA IRQ %d\n",
+				 pin_name(pin), dev->irq);
 			acpi_register_gsi(&dev->dev, dev_gsi,
 					  ACPI_LEVEL_SENSITIVE,
 					  ACPI_ACTIVE_LOW);
-			return 0;
 		} else {
-			printk("\n");
-			return 0;
+			dev_warn(&dev->dev, "PCI INT %c: no GSI\n",
+				 pin_name(pin));
 		}
+		return 0;
 	}
 
 	rc = acpi_register_gsi(&dev->dev, gsi, triggering, polarity);

commit 35e92b78c1d327b1624e94d1c9c65ea7065d6b95
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Oct 31 22:44:48 2012 +0100

    ACPI / x86: Export acpi_[un]register_gsi()
    
    These functions might be called from modules as well so make sure
    they are exported.
    
    In addition, implement empty version of acpi_unregister_gsi() and
    remove the one from pci_irq.c.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 0eefa12e648c..1be25a590dce 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -495,11 +495,6 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	return 0;
 }
 
-/* FIXME: implement x86/x86_64 version */
-void __attribute__ ((weak)) acpi_unregister_gsi(u32 i)
-{
-}
-
 void acpi_pci_irq_disable(struct pci_dev *dev)
 {
 	struct acpi_prt_entry *entry;

commit 79c4412298771b8996302806abc8a11e760da9b3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Oct 30 15:24:06 2012 +0900

    ACPI: Pass segment/bus to _PRT add/del so they don't depend on pci_bus
    
    This effectively reverts 859a3f86ca8 ("ACPI: simplify
    acpi_pci_irq_add_prt() API") and d9efae3688a ("ACPI: simplify
    acpi_pci_irq_del_prt() API").
    
    The reason is to disentangle these routines from the struct pci_bus.
    We want to be able to add the _PRT before the struct pci_bus
    exists, and delete the _PRT after we've removed the pci_bus.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 0eefa12e648c..8835cc38aa30 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -184,7 +184,7 @@ static void do_prt_fixups(struct acpi_prt_entry *entry,
 	}
 }
 
-static int acpi_pci_irq_add_entry(acpi_handle handle, struct pci_bus *bus,
+static int acpi_pci_irq_add_entry(acpi_handle handle, int segment, int bus,
 				  struct acpi_pci_routing_table *prt)
 {
 	struct acpi_prt_entry *entry;
@@ -198,8 +198,8 @@ static int acpi_pci_irq_add_entry(acpi_handle handle, struct pci_bus *bus,
 	 * 1=INTA, 2=INTB.  We use the PCI encoding throughout, so convert
 	 * it here.
 	 */
-	entry->id.segment = pci_domain_nr(bus);
-	entry->id.bus = bus->number;
+	entry->id.segment = segment;
+	entry->id.bus = bus;
 	entry->id.device = (prt->address >> 16) & 0xFFFF;
 	entry->pin = prt->pin + 1;
 
@@ -244,7 +244,7 @@ static int acpi_pci_irq_add_entry(acpi_handle handle, struct pci_bus *bus,
 	return 0;
 }
 
-int acpi_pci_irq_add_prt(acpi_handle handle, struct pci_bus *bus)
+int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 {
 	acpi_status status;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
@@ -273,7 +273,7 @@ int acpi_pci_irq_add_prt(acpi_handle handle, struct pci_bus *bus)
 
 	entry = buffer.pointer;
 	while (entry && (entry->length > 0)) {
-		acpi_pci_irq_add_entry(handle, bus, entry);
+		acpi_pci_irq_add_entry(handle, segment, bus, entry);
 		entry = (struct acpi_pci_routing_table *)
 		    ((unsigned long)entry + entry->length);
 	}
@@ -282,17 +282,16 @@ int acpi_pci_irq_add_prt(acpi_handle handle, struct pci_bus *bus)
 	return 0;
 }
 
-void acpi_pci_irq_del_prt(struct pci_bus *bus)
+void acpi_pci_irq_del_prt(int segment, int bus)
 {
 	struct acpi_prt_entry *entry, *tmp;
 
 	printk(KERN_DEBUG
 	       "ACPI: Delete PCI Interrupt Routing Table for %04x:%02x\n",
-	       pci_domain_nr(bus), bus->number);
+	       segment, bus);
 	spin_lock(&acpi_prt_lock);
 	list_for_each_entry_safe(entry, tmp, &acpi_prt_list, list) {
-		if (pci_domain_nr(bus) == entry->id.segment
-			&& bus->number == entry->id.bus) {
+		if (segment == entry->id.segment && bus == entry->id.bus) {
 			list_del(&entry->list);
 			kfree(entry);
 		}

commit 85b8582d7ca516030efb84d94fa29a73c1d9a125
Author: Vincent Palatin <vpalatin@chromium.org>
Date:   Mon Dec 5 11:51:18 2011 -0800

    PCI/PM/Runtime: make PCI traces quieter
    
    When the runtime PM is activated on PCI, if a device switches state
    frequently (e.g. an EHCI controller with autosuspending USB devices
    connected) the PCI configuration traces might be very verbose in the
    kernel log.  Let's guard those traces with DEBUG condition.
    
    Acked-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Vincent Palatin <vpalatin@chromium.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 7f9eba9a0b02..0eefa12e648c 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -487,10 +487,10 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	else
 		link_desc[0] = '\0';
 
-	dev_info(&dev->dev, "PCI INT %c%s -> GSI %u (%s, %s) -> IRQ %d\n",
-		 pin_name(pin), link_desc, gsi,
-		 (triggering == ACPI_LEVEL_SENSITIVE) ? "level" : "edge",
-		 (polarity == ACPI_ACTIVE_LOW) ? "low" : "high", dev->irq);
+	dev_dbg(&dev->dev, "PCI INT %c%s -> GSI %u (%s, %s) -> IRQ %d\n",
+		pin_name(pin), link_desc, gsi,
+		(triggering == ACPI_LEVEL_SENSITIVE) ? "level" : "edge",
+		(polarity == ACPI_ACTIVE_LOW) ? "low" : "high", dev->irq);
 
 	return 0;
 }
@@ -524,6 +524,6 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	 * (e.g. PCI_UNDEFINED_IRQ).
 	 */
 
-	dev_info(&dev->dev, "PCI INT %c disabled\n", pin_name(pin));
+	dev_dbg(&dev->dev, "PCI INT %c disabled\n", pin_name(pin));
 	acpi_unregister_gsi(gsi);
 }

commit d7f6169a0d32002657886fee561c641acddb9a75
Author: Stefan Assmann <sassmann@kpanic.de>
Date:   Fri Jul 15 14:52:30 2011 +0200

    ACPI: fix CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS
    
    The following was observed by Steve Rostedt on 3.0.0-rc5
    Backtrace:
    irq 16: nobody cared (try booting with the "irqpoll" option)
    Pid: 65, comm: irq/16-uhci_hcd Not tainted 3.0.0-rc5-test+ #94
    Call Trace:
     [<ffffffff810aa643>] __report_bad_irq+0x37/0xc1
     [<ffffffff810aaa2d>] note_interrupt+0x14e/0x1c9
     [<ffffffff810a9a05>] ? irq_thread_fn+0x3c/0x3c
     [<ffffffff810a990e>] irq_thread+0xf6/0x1b1
     [<ffffffff810a9818>] ? irq_finalize_oneshot+0xb3/0xb3
     [<ffffffff8106b4d6>] kthread+0x9f/0xa7
     [<ffffffff814f1f04>] kernel_thread_helper+0x4/0x10
     [<ffffffff8103ca09>] ? finish_task_switch+0x7b/0xc0
     [<ffffffff814eac78>] ? retint_restore_args+0x13/0x13
     [<ffffffff8106b437>] ? __init_kthread_worker+0x5a/0x5a
     [<ffffffff814f1f00>] ? gs_change+0x13/0x13
    handlers:
    [<ffffffff810a912d>] irq_default_primary_handler threaded [<ffffffff8135eaa6>] usb_hcd_irq
    [<ffffffff810a912d>] irq_default_primary_handler threaded [<ffffffff8135eaa6>] usb_hcd_irq
    Disabling IRQ #16
    
    The problem being that a device triggers boot interrupts (due to threaded
    interrupt handling and masking of the IO-APIC), which are forwarded
    to the PIRQ line of the device. These interrupts are not handled on the PIRQ
    line because the interrupt handler is not present there.
    This should have already been fixed by CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS.
    However some parts of the quirk got lost in the ACPI merge. This is a resent of
    the patch proposed in 2009.
    See http://lkml.org/lkml/2009/9/7/192
    
    Signed-off-by: Stefan Assmann <sassmann@kpanic.de>
    Tested-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index f907cfbfa13c..7f9eba9a0b02 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -303,6 +303,61 @@ void acpi_pci_irq_del_prt(struct pci_bus *bus)
 /* --------------------------------------------------------------------------
                           PCI Interrupt Routing Support
    -------------------------------------------------------------------------- */
+#ifdef CONFIG_X86_IO_APIC
+extern int noioapicquirk;
+extern int noioapicreroute;
+
+static int bridge_has_boot_interrupt_variant(struct pci_bus *bus)
+{
+	struct pci_bus *bus_it;
+
+	for (bus_it = bus ; bus_it ; bus_it = bus_it->parent) {
+		if (!bus_it->self)
+			return 0;
+		if (bus_it->self->irq_reroute_variant)
+			return bus_it->self->irq_reroute_variant;
+	}
+	return 0;
+}
+
+/*
+ * Some chipsets (e.g. Intel 6700PXH) generate a legacy INTx when the IRQ
+ * entry in the chipset's IO-APIC is masked (as, e.g. the RT kernel does
+ * during interrupt handling). When this INTx generation cannot be disabled,
+ * we reroute these interrupts to their legacy equivalent to get rid of
+ * spurious interrupts.
+ */
+static int acpi_reroute_boot_interrupt(struct pci_dev *dev,
+				       struct acpi_prt_entry *entry)
+{
+	if (noioapicquirk || noioapicreroute) {
+		return 0;
+	} else {
+		switch (bridge_has_boot_interrupt_variant(dev->bus)) {
+		case 0:
+			/* no rerouting necessary */
+			return 0;
+		case INTEL_IRQ_REROUTE_VARIANT:
+			/*
+			 * Remap according to INTx routing table in 6700PXH
+			 * specs, intel order number 302628-002, section
+			 * 2.15.2. Other chipsets (80332, ...) have the same
+			 * mapping and are handled here as well.
+			 */
+			dev_info(&dev->dev, "PCI IRQ %d -> rerouted to legacy "
+				 "IRQ %d\n", entry->index,
+				 (entry->index % 4) + 16);
+			entry->index = (entry->index % 4) + 16;
+			return 1;
+		default:
+			dev_warn(&dev->dev, "Cannot reroute IRQ %d to legacy "
+				 "IRQ: unknown mapping\n", entry->index);
+			return -1;
+		}
+	}
+}
+#endif /* CONFIG_X86_IO_APIC */
+
 static struct acpi_prt_entry *acpi_pci_irq_lookup(struct pci_dev *dev, int pin)
 {
 	struct acpi_prt_entry *entry;
@@ -311,6 +366,9 @@ static struct acpi_prt_entry *acpi_pci_irq_lookup(struct pci_dev *dev, int pin)
 
 	entry = acpi_pci_irq_find_prt_entry(dev, pin);
 	if (entry) {
+#ifdef CONFIG_X86_IO_APIC
+		acpi_reroute_boot_interrupt(dev, entry);
+#endif /* CONFIG_X86_IO_APIC */
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %s[%c] _PRT entry\n",
 				  pci_name(dev), pin_name(pin)));
 		return entry;

commit 03e7c3432d40d067476eaf49ede29128b637998f
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri Oct 8 13:55:17 2010 +0800

    ACPI: remove unused declaration of proc_fs.h
    
    Remove unused declaration of proc_fs.h.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index e4804fb05e23..f907cfbfa13c 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -32,7 +32,6 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/types.h>
-#include <linux/proc_fs.h>
 #include <linux/spinlock.h>
 #include <linux/pm.h>
 #include <linux/pci.h>

commit 414d3448dbcb40807a1265ace64b2576ef919fbe
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Mar 30 01:07:04 2010 -0700

    x86, acpi/irq: pci device dev->irq is an isa irq not a gsi
    
    Strictly speaking on x86 (where acpi is used) dev->irq must be
    a dual i8259 irq input aka an isa irq.  Therefore we should translate
    that isa irq into a gsi before passing it to a function that
    takes a gsi.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    LKML-Reference: <1269936436-7039-3-git-send-email-ebiederm@xmission.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index b0a71ecee682..e4804fb05e23 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -401,11 +401,13 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	 * driver reported one, then use it. Exit in any case.
 	 */
 	if (gsi < 0) {
+		u32 dev_gsi;
 		dev_warn(&dev->dev, "PCI INT %c: no GSI", pin_name(pin));
 		/* Interrupt Line values above 0xF are forbidden */
-		if (dev->irq > 0 && (dev->irq <= 0xF)) {
-			printk(" - using IRQ %d\n", dev->irq);
-			acpi_register_gsi(&dev->dev, dev->irq,
+		if (dev->irq > 0 && (dev->irq <= 0xF) &&
+		    (acpi_isa_irq_to_gsi(dev->irq, &dev_gsi) == 0)) {
+			printk(" - using ISA IRQ %d\n", dev->irq);
+			acpi_register_gsi(&dev->dev, dev_gsi,
 					  ACPI_LEVEL_SENSITIVE,
 					  ACPI_ACTIVE_LOW);
 			return 0;

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 843699ed93f2..b0a71ecee682 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -37,6 +37,7 @@
 #include <linux/pm.h>
 #include <linux/pci.h>
 #include <linux/acpi.h>
+#include <linux/slab.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 

commit a192a9580bcc41692be1f36b77c3b681827f566a
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jul 28 16:45:54 2009 -0400

    ACPI: Move definition of PREFIX from acpi_bus.h to internal..h
    
    Linux/ACPI core files using internal.h all PREFIX "ACPI: ",
    however, not all ACPI drivers use/want it -- and they
    should not have to #undef PREFIX to define their own.
    
    Add GPL commment to internal.h while we are there.
    
    This does not change any actual console output,
    asside from a whitespace fix.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index b794eb88ab90..843699ed93f2 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -40,6 +40,8 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
+#define PREFIX "ACPI: "
+
 #define _COMPONENT		ACPI_PCI_COMPONENT
 ACPI_MODULE_NAME("pci_irq");
 

commit fbe8cddd2d85979d273d7937a2b8a47498694d91
Merge: 4e8a2372f925 e86435eb91b2 7fe2a6c275a5 0705495d9010 35a7c64fbc77 152a4e630f7f 86e437f077c6 c8d72a5e7698 7a04b8491a07 ee1ca48fae7e 9eccbc2f67ef 7e275cc4e8e2 7b768f07dce4 8cb24c8fd70e 113b3a2b9015 d73772474f6e 056c308d3e48 871043bc463e
Author: Len Brown <len.brown@intel.com>
Date:   Wed Jun 24 01:19:50 2009 -0400

    Merge branches 'acerhdf', 'acpi-pci-bind', 'bjorn-pci-root', 'bugzilla-12904', 'bugzilla-13121', 'bugzilla-13396', 'bugzilla-13533', 'bugzilla-13612', 'c3_lock', 'hid-cleanups', 'misc-2.6.31', 'pdc-leak-fix', 'pnpacpi', 'power_nocheck', 'thinkpad_acpi', 'video' and 'wmi' into release

commit d9efae3688addb15994c9ad9761dada6f988bc14
Author: Alexander Chiang <achiang@hp.com>
Date:   Wed Jun 10 19:55:40 2009 +0000

    ACPI: simplify acpi_pci_irq_del_prt() API
    
    There is no need to pass a segment/bus tuple to this API, as the callsite
    always has a struct pci_bus. We can derive segment/bus from the
    struct pci_bus, so let's take this opportunit to simplify the API and
    make life easier for the callers.
    
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 3ed944cefb36..ef9509e33191 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -280,16 +280,17 @@ int acpi_pci_irq_add_prt(acpi_handle handle, struct pci_bus *bus)
 	return 0;
 }
 
-void acpi_pci_irq_del_prt(int segment, int bus)
+void acpi_pci_irq_del_prt(struct pci_bus *bus)
 {
 	struct acpi_prt_entry *entry, *tmp;
 
 	printk(KERN_DEBUG
 	       "ACPI: Delete PCI Interrupt Routing Table for %04x:%02x\n",
-	       segment, bus);
+	       pci_domain_nr(bus), bus->number);
 	spin_lock(&acpi_prt_lock);
 	list_for_each_entry_safe(entry, tmp, &acpi_prt_list, list) {
-		if (segment == entry->id.segment && bus == entry->id.bus) {
+		if (pci_domain_nr(bus) == entry->id.segment
+			&& bus->number == entry->id.bus) {
 			list_del(&entry->list);
 			kfree(entry);
 		}

commit 859a3f86ca83346f4097e956d0b27d96aa7a1cff
Author: Alexander Chiang <achiang@hp.com>
Date:   Wed Jun 10 19:55:35 2009 +0000

    ACPI: simplify acpi_pci_irq_add_prt() API
    
    A PCI domain cannot change as you descend down subordinate buses, which
    makes the 'segment' argument to acpi_pci_irq_add_prt() useless.
    
    Change the interface to take a struct pci_bus *, from whence we can derive
    the bus number and segment. Reducing the number of arguments makes life
    simpler for callers.
    
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 51b9f8280f88..3ed944cefb36 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -182,7 +182,7 @@ static void do_prt_fixups(struct acpi_prt_entry *entry,
 	}
 }
 
-static int acpi_pci_irq_add_entry(acpi_handle handle, int segment, int bus,
+static int acpi_pci_irq_add_entry(acpi_handle handle, struct pci_bus *bus,
 				  struct acpi_pci_routing_table *prt)
 {
 	struct acpi_prt_entry *entry;
@@ -196,8 +196,8 @@ static int acpi_pci_irq_add_entry(acpi_handle handle, int segment, int bus,
 	 * 1=INTA, 2=INTB.  We use the PCI encoding throughout, so convert
 	 * it here.
 	 */
-	entry->id.segment = segment;
-	entry->id.bus = bus;
+	entry->id.segment = pci_domain_nr(bus);
+	entry->id.bus = bus->number;
 	entry->id.device = (prt->address >> 16) & 0xFFFF;
 	entry->pin = prt->pin + 1;
 
@@ -242,7 +242,7 @@ static int acpi_pci_irq_add_entry(acpi_handle handle, int segment, int bus,
 	return 0;
 }
 
-int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
+int acpi_pci_irq_add_prt(acpi_handle handle, struct pci_bus *bus)
 {
 	acpi_status status;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
@@ -271,7 +271,7 @@ int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 
 	entry = buffer.pointer;
 	while (entry && (entry->length > 0)) {
-		acpi_pci_irq_add_entry(handle, segment, bus, entry);
+		acpi_pci_irq_add_entry(handle, bus, entry);
 		entry = (struct acpi_pci_routing_table *)
 		    ((unsigned long)entry + entry->length);
 	}

commit a2f809b08ae4dddc1015c7dcd8659e5729e45b3e
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 27 18:01:20 2009 -0700

    irq: change ACPI GSI APIs to also take a device argument
    
    We want to use dev_to_node() later on, to be aware of the 'home node'
    of the GSI in question.
    
    [ Impact: cleanup, prepare the IRQ code to be more NUMA aware ]
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Len Brown <lenb@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-ia64@vger.kernel.org
    LKML-Reference: <49F65560.20904@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 51b9f8280f88..2faa9e2ac893 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -401,7 +401,8 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 		/* Interrupt Line values above 0xF are forbidden */
 		if (dev->irq > 0 && (dev->irq <= 0xF)) {
 			printk(" - using IRQ %d\n", dev->irq);
-			acpi_register_gsi(dev->irq, ACPI_LEVEL_SENSITIVE,
+			acpi_register_gsi(&dev->dev, dev->irq,
+					  ACPI_LEVEL_SENSITIVE,
 					  ACPI_ACTIVE_LOW);
 			return 0;
 		} else {
@@ -410,7 +411,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 		}
 	}
 
-	rc = acpi_register_gsi(gsi, triggering, polarity);
+	rc = acpi_register_gsi(&dev->dev, gsi, triggering, polarity);
 	if (rc < 0) {
 		dev_warn(&dev->dev, "PCI INT %c: failed to register GSI\n",
 			 pin_name(pin));

commit 8a3f257c704e02aee9869decd069a806b45be3f1
Merge: 33526a53600a 15065531c1c5
Author: Len Brown <len.brown@intel.com>
Date:   Sun Apr 5 01:52:07 2009 -0400

    Merge branch 'misc' into release

commit 609d4bc949a9175a6c8ba9dc1b6fdb4d9dab0427
Author: Jan Beulich <jbeulich@novell.com>
Date:   Thu Mar 12 11:58:25 2009 +0000

    ACPI: constify tables in pci_irq.c
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 891bdf6679f3..f93667ee43dc 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -86,7 +86,7 @@ static struct acpi_prt_entry *acpi_pci_irq_find_prt_entry(struct pci_dev *dev,
 }
 
 /* http://bugzilla.kernel.org/show_bug.cgi?id=4773 */
-static struct dmi_system_id medion_md9580[] = {
+static const struct dmi_system_id medion_md9580[] = {
 	{
 		.ident = "Medion MD9580-F laptop",
 		.matches = {
@@ -98,7 +98,7 @@ static struct dmi_system_id medion_md9580[] = {
 };
 
 /* http://bugzilla.kernel.org/show_bug.cgi?id=5044 */
-static struct dmi_system_id dell_optiplex[] = {
+static const struct dmi_system_id dell_optiplex[] = {
 	{
 		.ident = "Dell Optiplex GX1",
 		.matches = {
@@ -110,7 +110,7 @@ static struct dmi_system_id dell_optiplex[] = {
 };
 
 /* http://bugzilla.kernel.org/show_bug.cgi?id=10138 */
-static struct dmi_system_id hp_t5710[] = {
+static const struct dmi_system_id hp_t5710[] = {
 	{
 		.ident = "HP t5710",
 		.matches = {
@@ -123,13 +123,13 @@ static struct dmi_system_id hp_t5710[] = {
 };
 
 struct prt_quirk {
-	struct dmi_system_id	*system;
+	const struct dmi_system_id *system;
 	unsigned int		segment;
 	unsigned int		bus;
 	unsigned int		device;
 	unsigned char		pin;
-	char			*source;	/* according to BIOS */
-	char			*actual_source;
+	const char		*source;	/* according to BIOS */
+	const char		*actual_source;
 };
 
 #define PCI_INTX_PIN(c)		(c - 'A' + 1)
@@ -139,7 +139,7 @@ struct prt_quirk {
  * interrupt at the listed segment/bus/device/pin is connected to the first
  * link device, but it is actually connected to the second.
  */
-static struct prt_quirk prt_quirks[] = {
+static const struct prt_quirk prt_quirks[] = {
 	{ medion_md9580, 0, 0, 9, PCI_INTX_PIN('A'),
 		"\\_SB_.PCI0.ISA_.LNKA",
 		"\\_SB_.PCI0.ISA_.LNKB"},
@@ -155,7 +155,7 @@ static void do_prt_fixups(struct acpi_prt_entry *entry,
 			  struct acpi_pci_routing_table *prt)
 {
 	int i;
-	struct prt_quirk *quirk;
+	const struct prt_quirk *quirk;
 
 	for (i = 0; i < ARRAY_SIZE(prt_quirks); i++) {
 		quirk = &prt_quirks[i];

commit c686d141c7c668ac186015841a1ccd285a1f3362
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Feb 17 13:49:10 2009 -0700

    ACPI: PCI: use generic pci_swizzle_interrupt_pin()
    
    Use the generic pci_swizzle_interrupt_pin() instead of ACPI-specific code.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 891bdf6679f3..be6b9093f8df 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -319,7 +319,7 @@ static struct acpi_prt_entry *acpi_pci_irq_lookup(struct pci_dev *dev, int pin)
 	 */
 	bridge = dev->bus->self;
 	while (bridge) {
-		pin = (((pin - 1) + PCI_SLOT(dev->devfn)) % 4) + 1;
+		pin = pci_swizzle_interrupt_pin(dev, pin);
 
 		if ((bridge->class >> 8) == PCI_CLASS_BRIDGE_CARDBUS) {
 			/* PC card has the same IRQ as its cardbridge */

commit 39488b041e2fdc206b3de4517b8f220ae07b2a20
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:31:42 2008 -0700

    ACPI: PCI: add HP copyright
    
    Add HP copyright to pci_irq.c.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index cba8d4dc56ae..891bdf6679f3 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -4,6 +4,8 @@
  *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
  *  Copyright (C) 2002       Dominik Brodowski <devel@brodo.de>
+ *  (c) Copyright 2008 Hewlett-Packard Development Company, L.P.
+ *	Bjorn Helgaas <bjorn.helgaas@hp.com>
  *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *

commit 3f0f3c27be19d390f23af1075d9948d0310e2673
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:31:37 2008 -0700

    ACPI: PCI: whitespace and useless initialization cleanup
    
    This patch makes function declarations consistent throughout
    the file and removes some unnecessary initializations.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 03d528e02c29..cba8d4dc56ae 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -149,8 +149,8 @@ static struct prt_quirk prt_quirks[] = {
 		"\\_SB_.PCI0.LNK3"},
 };
 
-static void
-do_prt_fixups(struct acpi_prt_entry *entry, struct acpi_pci_routing_table *prt)
+static void do_prt_fixups(struct acpi_prt_entry *entry,
+			  struct acpi_pci_routing_table *prt)
 {
 	int i;
 	struct prt_quirk *quirk;
@@ -180,9 +180,8 @@ do_prt_fixups(struct acpi_prt_entry *entry, struct acpi_pci_routing_table *prt)
 	}
 }
 
-static int
-acpi_pci_irq_add_entry(acpi_handle handle,
-		       int segment, int bus, struct acpi_pci_routing_table *prt)
+static int acpi_pci_irq_add_entry(acpi_handle handle, int segment, int bus,
+				  struct acpi_pci_routing_table *prt)
 {
 	struct acpi_prt_entry *entry;
 
@@ -299,8 +298,7 @@ void acpi_pci_irq_del_prt(int segment, int bus)
 /* --------------------------------------------------------------------------
                           PCI Interrupt Routing Support
    -------------------------------------------------------------------------- */
-static struct acpi_prt_entry *
-acpi_pci_irq_lookup(struct pci_dev *dev, int pin)
+static struct acpi_prt_entry *acpi_pci_irq_lookup(struct pci_dev *dev, int pin)
 {
 	struct acpi_prt_entry *entry;
 	struct pci_dev *bridge;
@@ -351,24 +349,17 @@ acpi_pci_irq_lookup(struct pci_dev *dev, int pin)
 	return NULL;
 }
 
-/*
- * acpi_pci_irq_enable
- * success: return 0
- * failure: return < 0
- */
-
 int acpi_pci_irq_enable(struct pci_dev *dev)
 {
 	struct acpi_prt_entry *entry;
-	int gsi = 0;
-	u8 pin = 0;
+	int gsi;
+	u8 pin;
 	int triggering = ACPI_LEVEL_SENSITIVE;
 	int polarity = ACPI_ACTIVE_LOW;
 	char *link = NULL;
 	char link_desc[16];
 	int rc;
 
-
 	pin = dev->pin;
 	if (!pin) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
@@ -446,9 +437,8 @@ void __attribute__ ((weak)) acpi_unregister_gsi(u32 i)
 void acpi_pci_irq_disable(struct pci_dev *dev)
 {
 	struct acpi_prt_entry *entry;
-	int gsi = 0;
-	u8 pin = 0;
-
+	int gsi;
+	u8 pin;
 
 	pin = dev->pin;
 	if (!pin)

commit 74f82af1eda39c26c17f8030e4f60c00929ec9df
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:31:32 2008 -0700

    ACPI: PCI: expand acpi_pci_allocate_irq() and acpi_pci_free_irq() inline
    
    acpi_pci_allocate_irq() and acpi_pci_free_irq() are trivial and
    only used once, so just open-code them.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 643c4e864298..03d528e02c29 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -299,44 +299,6 @@ void acpi_pci_irq_del_prt(int segment, int bus)
 /* --------------------------------------------------------------------------
                           PCI Interrupt Routing Support
    -------------------------------------------------------------------------- */
-static int
-acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
-		      int *triggering, int *polarity, char **link)
-{
-	int irq;
-
-
-	if (entry->link) {
-		irq = acpi_pci_link_allocate_irq(entry->link, entry->index,
-						 triggering, polarity, link);
-		if (irq < 0) {
-			printk(KERN_WARNING PREFIX
-				      "Invalid IRQ link routing entry\n");
-			return -1;
-		}
-	} else {
-		irq = entry->index;
-		*triggering = ACPI_LEVEL_SENSITIVE;
-		*polarity = ACPI_ACTIVE_LOW;
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found GSI %d\n", irq));
-	return irq;
-}
-
-static int
-acpi_pci_free_irq(struct acpi_prt_entry *entry)
-{
-	int irq;
-
-	if (entry->link) {
-		irq = acpi_pci_link_free_irq(entry->link);
-	} else {
-		irq = entry->index;
-	}
-	return irq;
-}
-
 static struct acpi_prt_entry *
 acpi_pci_irq_lookup(struct pci_dev *dev, int pin)
 {
@@ -426,10 +388,15 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 			return 0;
 	}
 
-	if (entry)
-		gsi = acpi_pci_allocate_irq(entry, &triggering, &polarity,
-					    &link);
-	else
+	if (entry) {
+		if (entry->link)
+			gsi = acpi_pci_link_allocate_irq(entry->link,
+							 entry->index,
+							 &triggering, &polarity,
+							 &link);
+		else
+			gsi = entry->index;
+	} else
 		gsi = -1;
 
 	/*
@@ -491,7 +458,10 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	if (!entry)
 		return;
 
-	gsi = acpi_pci_free_irq(entry);
+	if (entry->link)
+		gsi = acpi_pci_link_free_irq(entry->link);
+	else
+		gsi = entry->index;
 
 	/*
 	 * TBD: It might be worth clearing dev->irq by magic constant

commit 4eaf6db3ea0edf7e011a613b5a15360444e58fec
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:31:27 2008 -0700

    ACPI: PCI: simplify struct acpi_prt_entry
    
    Remove unused "irq" field, remove unnecessary struct,
    rename "handle" to "link".
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 42b195ed7922..643c4e864298 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -45,11 +45,8 @@ struct acpi_prt_entry {
 	struct list_head	list;
 	struct acpi_pci_id	id;
 	u8			pin;
-	struct {
-		acpi_handle		handle;
-		u32			index;
-	}			link;
-	u32			irq;
+	acpi_handle		link;
+	u32			index;		/* GSI, or link _CRS index */
 };
 
 static LIST_HEAD(acpi_prt_list);
@@ -205,6 +202,8 @@ acpi_pci_irq_add_entry(acpi_handle handle,
 
 	do_prt_fixups(entry, prt);
 
+	entry->index = prt->source_index;
+
 	/*
 	 * Type 1: Dynamic
 	 * ---------------
@@ -218,10 +217,9 @@ acpi_pci_irq_add_entry(acpi_handle handle,
 	 *       (e.g. exists somewhere 'below' this _PRT entry in the ACPI
 	 *       namespace).
 	 */
-	if (prt->source[0]) {
-		acpi_get_handle(handle, prt->source, &entry->link.handle);
-		entry->link.index = prt->source_index;
-	}
+	if (prt->source[0])
+		acpi_get_handle(handle, prt->source, &entry->link);
+
 	/*
 	 * Type 2: Static
 	 * --------------
@@ -229,14 +227,12 @@ acpi_pci_irq_add_entry(acpi_handle handle,
 	 * the IRQ value, which is hardwired to specific interrupt inputs on
 	 * the interrupt controller.
 	 */
-	else
-		entry->link.index = prt->source_index;
 
 	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INFO,
 			      "      %04x:%02x:%02x[%c] -> %s[%d]\n",
 			      entry->id.segment, entry->id.bus,
 			      entry->id.device, pin_name(entry->pin),
-			      prt->source, entry->link.index));
+			      prt->source, entry->index));
 
 	spin_lock(&acpi_prt_lock);
 	list_add_tail(&entry->list, &acpi_prt_list);
@@ -310,17 +306,16 @@ acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
 	int irq;
 
 
-	if (entry->link.handle) {
-		irq = acpi_pci_link_allocate_irq(entry->link.handle,
-						 entry->link.index, triggering,
-						 polarity, link);
+	if (entry->link) {
+		irq = acpi_pci_link_allocate_irq(entry->link, entry->index,
+						 triggering, polarity, link);
 		if (irq < 0) {
 			printk(KERN_WARNING PREFIX
 				      "Invalid IRQ link routing entry\n");
 			return -1;
 		}
 	} else {
-		irq = entry->link.index;
+		irq = entry->index;
 		*triggering = ACPI_LEVEL_SENSITIVE;
 		*polarity = ACPI_ACTIVE_LOW;
 	}
@@ -334,10 +329,10 @@ acpi_pci_free_irq(struct acpi_prt_entry *entry)
 {
 	int irq;
 
-	if (entry->link.handle) {
-		irq = acpi_pci_link_free_irq(entry->link.handle);
+	if (entry->link) {
+		irq = acpi_pci_link_free_irq(entry->link);
 	} else {
-		irq = entry->link.index;
+		irq = entry->index;
 	}
 	return irq;
 }

commit 3604a9f445afde2801b8c24b63dd289c33e290a6
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:31:21 2008 -0700

    ACPI: PCI: simplify list of _PRT entries
    
    We don't need a struct containing a count and a list_head; a simple
    list_head is sufficient.  The list iterators handle empty lists
    fine.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index b03bb84266b2..42b195ed7922 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -42,7 +42,7 @@
 ACPI_MODULE_NAME("pci_irq");
 
 struct acpi_prt_entry {
-	struct list_head	node;
+	struct list_head	list;
 	struct acpi_pci_id	id;
 	u8			pin;
 	struct {
@@ -52,12 +52,7 @@ struct acpi_prt_entry {
 	u32			irq;
 };
 
-struct acpi_prt_list {
-	int			count;
-	struct list_head	entries;
-};
-
-static struct acpi_prt_list acpi_prt;
+static LIST_HEAD(acpi_prt_list);
 static DEFINE_SPINLOCK(acpi_prt_lock);
 
 static inline char pin_name(int pin)
@@ -72,21 +67,13 @@ static inline char pin_name(int pin)
 static struct acpi_prt_entry *acpi_pci_irq_find_prt_entry(struct pci_dev *dev,
 							  int pin)
 {
-	struct acpi_prt_entry *entry = NULL;
+	struct acpi_prt_entry *entry;
 	int segment = pci_domain_nr(dev->bus);
 	int bus = dev->bus->number;
 	int device = PCI_SLOT(dev->devfn);
 
-	if (!acpi_prt.count)
-		return NULL;
-
-	/*
-	 * Parse through all PRT entries looking for a match on the specified
-	 * PCI device's segment, bus, device, and pin (don't care about func).
-	 *
-	 */
 	spin_lock(&acpi_prt_lock);
-	list_for_each_entry(entry, &acpi_prt.entries, node) {
+	list_for_each_entry(entry, &acpi_prt_list, list) {
 		if ((segment == entry->id.segment)
 		    && (bus == entry->id.bus)
 		    && (device == entry->id.device)
@@ -95,7 +82,6 @@ static struct acpi_prt_entry *acpi_pci_irq_find_prt_entry(struct pci_dev *dev,
 			return entry;
 		}
 	}
-
 	spin_unlock(&acpi_prt_lock);
 	return NULL;
 }
@@ -201,7 +187,7 @@ static int
 acpi_pci_irq_add_entry(acpi_handle handle,
 		       int segment, int bus, struct acpi_pci_routing_table *prt)
 {
-	struct acpi_prt_entry *entry = NULL;
+	struct acpi_prt_entry *entry;
 
 	entry = kzalloc(sizeof(struct acpi_prt_entry), GFP_KERNEL);
 	if (!entry)
@@ -253,35 +239,17 @@ acpi_pci_irq_add_entry(acpi_handle handle,
 			      prt->source, entry->link.index));
 
 	spin_lock(&acpi_prt_lock);
-	list_add_tail(&entry->node, &acpi_prt.entries);
-	acpi_prt.count++;
+	list_add_tail(&entry->list, &acpi_prt_list);
 	spin_unlock(&acpi_prt_lock);
 
 	return 0;
 }
 
-static void
-acpi_pci_irq_del_entry(int segment, int bus, struct acpi_prt_entry *entry)
-{
-	if (segment == entry->id.segment && bus == entry->id.bus) {
-		acpi_prt.count--;
-		list_del(&entry->node);
-		kfree(entry);
-	}
-}
-
 int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 {
 	acpi_status status;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	struct acpi_pci_routing_table *entry;
-	static int first_time = 1;
-
-	if (first_time) {
-		acpi_prt.count = 0;
-		INIT_LIST_HEAD(&acpi_prt.entries);
-		first_time = 0;
-	}
 
 	/* 'handle' is the _PRT's parent (root bridge or PCI-PCI bridge) */
 	status = acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
@@ -317,21 +285,17 @@ int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 
 void acpi_pci_irq_del_prt(int segment, int bus)
 {
-	struct list_head *node = NULL, *n = NULL;
-	struct acpi_prt_entry *entry = NULL;
-
-	if (!acpi_prt.count) {
-		return;
-	}
+	struct acpi_prt_entry *entry, *tmp;
 
 	printk(KERN_DEBUG
 	       "ACPI: Delete PCI Interrupt Routing Table for %04x:%02x\n",
 	       segment, bus);
 	spin_lock(&acpi_prt_lock);
-	list_for_each_safe(node, n, &acpi_prt.entries) {
-		entry = list_entry(node, struct acpi_prt_entry, node);
-
-		acpi_pci_irq_del_entry(segment, bus, entry);
+	list_for_each_entry_safe(entry, tmp, &acpi_prt_list, list) {
+		if (segment == entry->id.segment && bus == entry->id.bus) {
+			list_del(&entry->list);
+			kfree(entry);
+		}
 	}
 	spin_unlock(&acpi_prt_lock);
 }

commit 5697b7ca406b4ee0afeef6d9a29b823767716cab
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:31:16 2008 -0700

    ACPI: PCI: combine lookup and derive
    
    This folds acpi_pci_irq_derive() into acpi_pci_irq_lookup() so it
    can be easily used by both acpi_pci_irq_enable() and acpi_pci_irq_disable().
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index b35e64d71409..b03bb84266b2 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -382,6 +382,8 @@ static struct acpi_prt_entry *
 acpi_pci_irq_lookup(struct pci_dev *dev, int pin)
 {
 	struct acpi_prt_entry *entry;
+	struct pci_dev *bridge;
+	u8 bridge_pin, orig_pin = pin;
 
 	entry = acpi_pci_irq_find_prt_entry(dev, pin);
 	if (entry) {
@@ -390,19 +392,6 @@ acpi_pci_irq_lookup(struct pci_dev *dev, int pin)
 		return entry;
 	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No %s[%c] _PRT entry\n",
-			  pci_name(dev), pin_name(pin)));
-	return NULL;
-}
-
-static struct acpi_prt_entry *
-acpi_pci_irq_derive(struct pci_dev *dev, int pin)
-{
-	struct acpi_prt_entry *entry = NULL;
-	struct pci_dev *bridge;
-	u8 bridge_pin = 0, orig_pin = pin;
-
-
 	/* 
 	 * Attempt to derive an IRQ for this device from a parent bridge's
 	 * PCI interrupt routing entry (eg. yenta bridge and add-in card bridge).
@@ -423,7 +412,7 @@ acpi_pci_irq_derive(struct pci_dev *dev, int pin)
 			pin = bridge_pin;
 		}
 
-		entry = acpi_pci_irq_lookup(bridge, pin);
+		entry = acpi_pci_irq_find_prt_entry(bridge, pin);
 		if (entry) {
 			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 					 "Derived GSI for %s INT %c from %s\n",
@@ -467,26 +456,8 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 		return 0;
 	}
 
-	/* 
-	 * First we check the PCI IRQ routing table (PRT) for an IRQ.  PRT
-	 * values override any BIOS-assigned IRQs set during boot.
-	 */
 	entry = acpi_pci_irq_lookup(dev, pin);
-
-	/*
-	 * If no PRT entry was found, we'll try to derive an IRQ from the
-	 * device's parent bridge.
-	 */
-	if (!entry)
-		entry = acpi_pci_irq_derive(dev, pin);
-
-	if (entry)
-		gsi = acpi_pci_allocate_irq(entry, &triggering, &polarity,
-					    &link);
-	else
-		gsi = -1;
-
-	if (gsi < 0) {
+	if (!entry) {
 		/*
 		 * IDE legacy mode controller IRQs are magic. Why do compat
 		 * extensions always make such a nasty mess.
@@ -495,6 +466,13 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 				(dev->class & 0x05) == 0)
 			return 0;
 	}
+
+	if (entry)
+		gsi = acpi_pci_allocate_irq(entry, &triggering, &polarity,
+					    &link);
+	else
+		gsi = -1;
+
 	/*
 	 * No IRQ known to the ACPI subsystem - maybe the BIOS / 
 	 * driver reported one, then use it. Exit in any case.
@@ -550,18 +528,7 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	if (!pin)
 		return;
 
-	/*
-	 * First we check the PCI IRQ routing table (PRT) for an IRQ.
-	 */
 	entry = acpi_pci_irq_lookup(dev, pin);
-
-	/*
-	 * If no PRT entry was found, we'll try to derive an IRQ from the
-	 * device's parent bridge.
-	 */
-	if (!entry)
-		entry = acpi_pci_irq_derive(dev, pin);
-
 	if (!entry)
 		return;
 

commit ee40136313323db1096b17df7b436d22a24ef2be
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:31:11 2008 -0700

    ACPI: PCI: follow typical PCI INTx swizzling pattern
    
    No functional change; this just uses the typical pattern of
    PCI INTx swizzling done on other architectures.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index e42481f64495..b35e64d71409 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -399,7 +399,7 @@ static struct acpi_prt_entry *
 acpi_pci_irq_derive(struct pci_dev *dev, int pin)
 {
 	struct acpi_prt_entry *entry = NULL;
-	struct pci_dev *bridge = dev;
+	struct pci_dev *bridge;
 	u8 bridge_pin = 0, orig_pin = pin;
 
 
@@ -407,9 +407,9 @@ acpi_pci_irq_derive(struct pci_dev *dev, int pin)
 	 * Attempt to derive an IRQ for this device from a parent bridge's
 	 * PCI interrupt routing entry (eg. yenta bridge and add-in card bridge).
 	 */
-	while (bridge->bus->self) {
-		pin = (((pin - 1) + PCI_SLOT(bridge->devfn)) % 4) + 1;
-		bridge = bridge->bus->self;
+	bridge = dev->bus->self;
+	while (bridge) {
+		pin = (((pin - 1) + PCI_SLOT(dev->devfn)) % 4) + 1;
 
 		if ((bridge->class >> 8) == PCI_CLASS_BRIDGE_CARDBUS) {
 			/* PC card has the same IRQ as its cardbridge */
@@ -431,6 +431,9 @@ acpi_pci_irq_derive(struct pci_dev *dev, int pin)
 					 pci_name(bridge)));
 			return entry;
 		}
+
+		dev = bridge;
+		bridge = dev->bus->self;
 	}
 
 	dev_warn(&dev->dev, "can't derive routing for PCI INT %c\n",

commit 3b1ea18d3b3542b55861d7f968ded705e3bc2aa6
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:31:06 2008 -0700

    ACPI: PCI: use positive logic to simplify code
    
    This doesn't change anything functionally; it just changes tests
    so we test for success instead of failure.  This makes the code
    read more easily and allows us to remove the "!entry" in the while
    loop condition.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 28338227dd5e..e42481f64495 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -384,16 +384,15 @@ acpi_pci_irq_lookup(struct pci_dev *dev, int pin)
 	struct acpi_prt_entry *entry;
 
 	entry = acpi_pci_irq_find_prt_entry(dev, pin);
-	if (!entry) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No %s[%c] _PRT entry\n",
+	if (entry) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %s[%c] _PRT entry\n",
 				  pci_name(dev), pin_name(pin)));
-		return NULL;
+		return entry;
 	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %s[%c] _PRT entry\n",
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No %s[%c] _PRT entry\n",
 			  pci_name(dev), pin_name(pin)));
-
-	return entry;
+	return NULL;
 }
 
 static struct acpi_prt_entry *
@@ -408,7 +407,7 @@ acpi_pci_irq_derive(struct pci_dev *dev, int pin)
 	 * Attempt to derive an IRQ for this device from a parent bridge's
 	 * PCI interrupt routing entry (eg. yenta bridge and add-in card bridge).
 	 */
-	while (!entry && bridge->bus->self) {
+	while (bridge->bus->self) {
 		pin = (((pin - 1) + PCI_SLOT(bridge->devfn)) % 4) + 1;
 		bridge = bridge->bus->self;
 
@@ -425,18 +424,18 @@ acpi_pci_irq_derive(struct pci_dev *dev, int pin)
 		}
 
 		entry = acpi_pci_irq_lookup(bridge, pin);
+		if (entry) {
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					 "Derived GSI for %s INT %c from %s\n",
+					 pci_name(dev), pin_name(orig_pin),
+					 pci_name(bridge)));
+			return entry;
+		}
 	}
 
-	if (!entry) {
-		dev_warn(&dev->dev, "can't derive routing for PCI INT %c\n",
-			 pin_name(orig_pin));
-		return NULL;
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Derived GSI for %s INT %c from %s\n",
-			  pci_name(dev), pin_name(orig_pin), pci_name(bridge)));
-
-	return entry;
+	dev_warn(&dev->dev, "can't derive routing for PCI INT %c\n",
+		 pin_name(orig_pin));
+	return NULL;
 }
 
 /*

commit beba8a643d7f774cf27c3c92a51b99cebf787415
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:31:01 2008 -0700

    ACPI: PCI: remove callback from acpi_pci_irq_lookup & acpi_pci_irq_derive
    
    We currently pass a callback function (either acpi_pci_allocate_irq() or
    acpi_pci_free_irq()) to acpi_pci_irq_lookup() and acpi_pci_irq_derive().
    
    I think it's simpler to remove the callback and just have the enable/
    disable functions make the calls directly.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 7978c97afb0a..28338227dd5e 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -339,8 +339,6 @@ void acpi_pci_irq_del_prt(int segment, int bus)
 /* --------------------------------------------------------------------------
                           PCI Interrupt Routing Support
    -------------------------------------------------------------------------- */
-typedef int (*irq_lookup_func) (struct acpi_prt_entry *, int *, int *, char **);
-
 static int
 acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
 		      int *triggering, int *polarity, char **link)
@@ -368,8 +366,7 @@ acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
 }
 
 static int
-acpi_pci_free_irq(struct acpi_prt_entry *entry,
-		  int *triggering, int *polarity, char **link)
+acpi_pci_free_irq(struct acpi_prt_entry *entry)
 {
 	int irq;
 
@@ -381,47 +378,29 @@ acpi_pci_free_irq(struct acpi_prt_entry *entry,
 	return irq;
 }
 
-/*
- * acpi_pci_irq_lookup
- * success: return IRQ >= 0
- * failure: return -1
- */
-static int
-acpi_pci_irq_lookup(struct pci_dev *dev, int pin,
-		    int *triggering,
-		    int *polarity, char **link, irq_lookup_func func)
+static struct acpi_prt_entry *
+acpi_pci_irq_lookup(struct pci_dev *dev, int pin)
 {
-	struct acpi_prt_entry *entry = NULL;
-	int ret;
-
+	struct acpi_prt_entry *entry;
 
 	entry = acpi_pci_irq_find_prt_entry(dev, pin);
 	if (!entry) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No %s[%c] _PRT entry\n",
 				  pci_name(dev), pin_name(pin)));
-		return -1;
+		return NULL;
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %s[%c] _PRT entry\n",
 			  pci_name(dev), pin_name(pin)));
 
-	ret = func(entry, triggering, polarity, link);
-	return ret;
+	return entry;
 }
 
-/*
- * acpi_pci_irq_derive
- * success: return IRQ >= 0
- * failure: return < 0
- */
-static int
-acpi_pci_irq_derive(struct pci_dev *dev,
-		    int pin,
-		    int *triggering,
-		    int *polarity, char **link, irq_lookup_func func)
+static struct acpi_prt_entry *
+acpi_pci_irq_derive(struct pci_dev *dev, int pin)
 {
+	struct acpi_prt_entry *entry = NULL;
 	struct pci_dev *bridge = dev;
-	int irq = -1;
 	u8 bridge_pin = 0, orig_pin = pin;
 
 
@@ -429,7 +408,7 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 	 * Attempt to derive an IRQ for this device from a parent bridge's
 	 * PCI interrupt routing entry (eg. yenta bridge and add-in card bridge).
 	 */
-	while (irq < 0 && bridge->bus->self) {
+	while (!entry && bridge->bus->self) {
 		pin = (((pin - 1) + PCI_SLOT(bridge->devfn)) % 4) + 1;
 		bridge = bridge->bus->self;
 
@@ -440,26 +419,24 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 						  "No interrupt pin configured for device %s\n",
 						  pci_name(bridge)));
-				return -1;
+				return NULL;
 			}
 			pin = bridge_pin;
 		}
 
-		irq = acpi_pci_irq_lookup(bridge,
-					  pin, triggering, polarity,
-					  link, func);
+		entry = acpi_pci_irq_lookup(bridge, pin);
 	}
 
-	if (irq < 0) {
+	if (!entry) {
 		dev_warn(&dev->dev, "can't derive routing for PCI INT %c\n",
 			 pin_name(orig_pin));
-		return -1;
+		return NULL;
 	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Derived GSI %d for %s INT %c from %s\n",
-			  irq, pci_name(dev), pin_name(orig_pin), pci_name(bridge)));
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Derived GSI for %s INT %c from %s\n",
+			  pci_name(dev), pin_name(orig_pin), pci_name(bridge)));
 
-	return irq;
+	return entry;
 }
 
 /*
@@ -470,6 +447,7 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 
 int acpi_pci_irq_enable(struct pci_dev *dev)
 {
+	struct acpi_prt_entry *entry;
 	int gsi = 0;
 	u8 pin = 0;
 	int triggering = ACPI_LEVEL_SENSITIVE;
@@ -491,18 +469,20 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	 * First we check the PCI IRQ routing table (PRT) for an IRQ.  PRT
 	 * values override any BIOS-assigned IRQs set during boot.
 	 */
-	gsi = acpi_pci_irq_lookup(dev, pin,
-				  &triggering, &polarity, &link,
-				  acpi_pci_allocate_irq);
+	entry = acpi_pci_irq_lookup(dev, pin);
 
 	/*
 	 * If no PRT entry was found, we'll try to derive an IRQ from the
 	 * device's parent bridge.
 	 */
-	if (gsi < 0)
-		gsi = acpi_pci_irq_derive(dev, pin, &triggering,
-					  &polarity, &link,
-					  acpi_pci_allocate_irq);
+	if (!entry)
+		entry = acpi_pci_irq_derive(dev, pin);
+
+	if (entry)
+		gsi = acpi_pci_allocate_irq(entry, &triggering, &polarity,
+					    &link);
+	else
+		gsi = -1;
 
 	if (gsi < 0) {
 		/*
@@ -559,10 +539,9 @@ void __attribute__ ((weak)) acpi_unregister_gsi(u32 i)
 
 void acpi_pci_irq_disable(struct pci_dev *dev)
 {
+	struct acpi_prt_entry *entry;
 	int gsi = 0;
 	u8 pin = 0;
-	int triggering = ACPI_LEVEL_SENSITIVE;
-	int polarity = ACPI_ACTIVE_LOW;
 
 
 	pin = dev->pin;
@@ -572,20 +551,20 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	/*
 	 * First we check the PCI IRQ routing table (PRT) for an IRQ.
 	 */
-	gsi = acpi_pci_irq_lookup(dev, pin,
-				  &triggering, &polarity, NULL,
-				  acpi_pci_free_irq);
+	entry = acpi_pci_irq_lookup(dev, pin);
+
 	/*
 	 * If no PRT entry was found, we'll try to derive an IRQ from the
 	 * device's parent bridge.
 	 */
-	if (gsi < 0)
-		gsi = acpi_pci_irq_derive(dev, pin,
-					  &triggering, &polarity, NULL,
-					  acpi_pci_free_irq);
-	if (gsi < 0)
+	if (!entry)
+		entry = acpi_pci_irq_derive(dev, pin);
+
+	if (!entry)
 		return;
 
+	gsi = acpi_pci_free_irq(entry);
+
 	/*
 	 * TBD: It might be worth clearing dev->irq by magic constant
 	 * (e.g. PCI_UNDEFINED_IRQ).

commit 1350487eeb616889f589e9b8c06bd5077452b7e3
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:30:56 2008 -0700

    ACPI: PCI: tweak _PRT lookup debug
    
    Print one message (either "found" or "not found") for every _PRT
    search.  And add pin information to the INTx swizzling debug.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index aabf8a965aff..7978c97afb0a 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -395,15 +395,16 @@ acpi_pci_irq_lookup(struct pci_dev *dev, int pin,
 	int ret;
 
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Searching for _PRT entry for %s[%c]\n",
-			  pci_name(dev), pin_name(pin)));
-
 	entry = acpi_pci_irq_find_prt_entry(dev, pin);
 	if (!entry) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "_PRT entry not found\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No %s[%c] _PRT entry\n",
+				  pci_name(dev), pin_name(pin)));
 		return -1;
 	}
 
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %s[%c] _PRT entry\n",
+			  pci_name(dev), pin_name(pin)));
+
 	ret = func(entry, triggering, polarity, link);
 	return ret;
 }
@@ -455,8 +456,8 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 		return -1;
 	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Derive GSI %d for device %s from %s\n",
-			  irq, pci_name(dev), pci_name(bridge)));
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Derived GSI %d for %s INT %c from %s\n",
+			  irq, pci_name(dev), pin_name(orig_pin), pci_name(bridge)));
 
 	return irq;
 }

commit 063563b4b8f87e2be0e127ccf3a8e6eef6309ff4
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:30:51 2008 -0700

    ACPI: PCI: lookup _PRT entry by PCI dev and pin, not segment/bus/dev/pin
    
    There's no reason to pass around segment, bus, and device independently
    when we can just pass the pci_dev pointer, which carries all those
    already.
    
    The pci_dev contains an interrupt pin, too, but we still have to pass both
    the pci_dev and the pin because when we use a bridge to derive an IRQ, we
    need the pin from the downstream device, not the bridge.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index c4a5c49809db..aabf8a965aff 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -69,11 +69,13 @@ static inline char pin_name(int pin)
                          PCI IRQ Routing Table (PRT) Support
    -------------------------------------------------------------------------- */
 
-static struct acpi_prt_entry *acpi_pci_irq_find_prt_entry(int segment,
-							  int bus,
-							  int device, int pin)
+static struct acpi_prt_entry *acpi_pci_irq_find_prt_entry(struct pci_dev *dev,
+							  int pin)
 {
 	struct acpi_prt_entry *entry = NULL;
+	int segment = pci_domain_nr(dev->bus);
+	int bus = dev->bus->number;
+	int device = PCI_SLOT(dev->devfn);
 
 	if (!acpi_prt.count)
 		return NULL;
@@ -385,23 +387,18 @@ acpi_pci_free_irq(struct acpi_prt_entry *entry,
  * failure: return -1
  */
 static int
-acpi_pci_irq_lookup(struct pci_bus *bus,
-		    int device,
-		    int pin,
+acpi_pci_irq_lookup(struct pci_dev *dev, int pin,
 		    int *triggering,
 		    int *polarity, char **link, irq_lookup_func func)
 {
 	struct acpi_prt_entry *entry = NULL;
-	int segment = pci_domain_nr(bus);
-	int bus_nr = bus->number;
 	int ret;
 
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			  "Searching for _PRT entry for %04x:%02x:%02x[%c]\n",
-			  segment, bus_nr, device, pin_name(pin)));
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Searching for _PRT entry for %s[%c]\n",
+			  pci_name(dev), pin_name(pin)));
 
-	entry = acpi_pci_irq_find_prt_entry(segment, bus_nr, device, pin);
+	entry = acpi_pci_irq_find_prt_entry(dev, pin);
 	if (!entry) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "_PRT entry not found\n"));
 		return -1;
@@ -447,7 +444,7 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 			pin = bridge_pin;
 		}
 
-		irq = acpi_pci_irq_lookup(bridge->bus, PCI_SLOT(bridge->devfn),
+		irq = acpi_pci_irq_lookup(bridge,
 					  pin, triggering, polarity,
 					  link, func);
 	}
@@ -493,7 +490,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	 * First we check the PCI IRQ routing table (PRT) for an IRQ.  PRT
 	 * values override any BIOS-assigned IRQs set during boot.
 	 */
-	gsi = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin,
+	gsi = acpi_pci_irq_lookup(dev, pin,
 				  &triggering, &polarity, &link,
 				  acpi_pci_allocate_irq);
 
@@ -574,7 +571,7 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	/*
 	 * First we check the PCI IRQ routing table (PRT) for an IRQ.
 	 */
-	gsi = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin,
+	gsi = acpi_pci_irq_lookup(dev, pin,
 				  &triggering, &polarity, NULL,
 				  acpi_pci_free_irq);
 	/*

commit c458033c9b72a81b890d97ec6339694bab252383
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:30:46 2008 -0700

    ACPI: PCI: use 1-based encoding for _PRT quirks
    
    Use the PCI INTx pin encoding (1=INTA, 2=INTB, etc) for _PRT quirks.
    Then we can simply compare "entry->pin == quirk->pin".
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 2c52cf0004ba..c4a5c49809db 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -145,19 +145,21 @@ struct prt_quirk {
 	char			*actual_source;
 };
 
+#define PCI_INTX_PIN(c)		(c - 'A' + 1)
+
 /*
  * These systems have incorrect _PRT entries.  The BIOS claims the PCI
  * interrupt at the listed segment/bus/device/pin is connected to the first
  * link device, but it is actually connected to the second.
  */
 static struct prt_quirk prt_quirks[] = {
-	{ medion_md9580, 0, 0, 9, 'A',
+	{ medion_md9580, 0, 0, 9, PCI_INTX_PIN('A'),
 		"\\_SB_.PCI0.ISA_.LNKA",
 		"\\_SB_.PCI0.ISA_.LNKB"},
-	{ dell_optiplex, 0, 0, 0xd, 'A',
+	{ dell_optiplex, 0, 0, 0xd, PCI_INTX_PIN('A'),
 		"\\_SB_.LNKB",
 		"\\_SB_.LNKA"},
-	{ hp_t5710, 0, 0, 1, 'A',
+	{ hp_t5710, 0, 0, 1, PCI_INTX_PIN('A'),
 		"\\_SB_.PCI0.LNK1",
 		"\\_SB_.PCI0.LNK3"},
 };
@@ -179,7 +181,7 @@ do_prt_fixups(struct acpi_prt_entry *entry, struct acpi_pci_routing_table *prt)
 		    entry->id.segment == quirk->segment &&
 		    entry->id.bus == quirk->bus &&
 		    entry->id.device == quirk->device &&
-		    pin_name(entry->pin) == quirk->pin &&
+		    entry->pin == quirk->pin &&
 		    !strcmp(prt->source, quirk->source) &&
 		    strlen(prt->source) >= strlen(quirk->actual_source)) {
 			printk(KERN_WARNING PREFIX "firmware reports "

commit e64e9db53ab78d20dff4cc1aec8a6b0e4e70ce8c
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:30:41 2008 -0700

    ACPI: PCI: always use the PCI INTx pin values, not the _PRT ones
    
    This patch changes pci_irq.c to always use PCI INTx pin encodings
    instead of a mix of PCI and _PRT encodings.
    
    The PCI INTx pin numbers from the PCI_INTERRUPT_PIN config register
    are 0=device doesn't use interrupts, 1=INTA, ..., 4=INTD.  But the
    _PRT table uses 0=INTA, ..., 3=INTD.
    
    This patch converts the _PRT encoding to the PCI encoding immediately
    when we add a _PRT entry to the global list.  All the rest of the
    code can then use the PCI encoding consistently.
    
    The point of this is to make the interrupt swizzling look the same
    as on other architectures, so someday we can unify them.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 5ce1fcf77455..2c52cf0004ba 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -62,7 +62,7 @@ static DEFINE_SPINLOCK(acpi_prt_lock);
 
 static inline char pin_name(int pin)
 {
-	return 'A' + pin;
+	return 'A' + pin - 1;
 }
 
 /* --------------------------------------------------------------------------
@@ -203,10 +203,15 @@ acpi_pci_irq_add_entry(acpi_handle handle,
 	if (!entry)
 		return -ENOMEM;
 
+	/*
+	 * Note that the _PRT uses 0=INTA, 1=INTB, etc, while PCI uses
+	 * 1=INTA, 2=INTB.  We use the PCI encoding throughout, so convert
+	 * it here.
+	 */
 	entry->id.segment = segment;
 	entry->id.bus = bus;
 	entry->id.device = (prt->address >> 16) & 0xFFFF;
-	entry->pin = prt->pin;
+	entry->pin = prt->pin + 1;
 
 	do_prt_fixups(entry, prt);
 
@@ -425,7 +430,7 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 	 * PCI interrupt routing entry (eg. yenta bridge and add-in card bridge).
 	 */
 	while (irq < 0 && bridge->bus->self) {
-		pin = (pin + PCI_SLOT(bridge->devfn)) % 4;
+		pin = (((pin - 1) + PCI_SLOT(bridge->devfn)) % 4) + 1;
 		bridge = bridge->bus->self;
 
 		if ((bridge->class >> 8) == PCI_CLASS_BRIDGE_CARDBUS) {
@@ -437,8 +442,6 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 						  pci_name(bridge)));
 				return -1;
 			}
-			/* Pin is from 0 to 3 */
-			bridge_pin--;
 			pin = bridge_pin;
 		}
 
@@ -483,7 +486,6 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 				  pci_name(dev)));
 		return 0;
 	}
-	pin--;
 
 	/* 
 	 * First we check the PCI IRQ routing table (PRT) for an IRQ.  PRT
@@ -566,7 +568,6 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	pin = dev->pin;
 	if (!pin)
 		return;
-	pin--;
 
 	/*
 	 * First we check the PCI IRQ routing table (PRT) for an IRQ.

commit cf68b80b0e0cbc6a0d7bbb36b07ce94779ef5f1f
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:30:36 2008 -0700

    ACPI: PCI: add a helper to convert _PRT INTx pin number to name
    
    This adds a helper function to convert INTx pin numbers from the _PRT
    (0, 1, 2, 3) to the pin name ('A', 'B', 'C', 'D').
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index ea003bab7ecd..5ce1fcf77455 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -60,6 +60,11 @@ struct acpi_prt_list {
 static struct acpi_prt_list acpi_prt;
 static DEFINE_SPINLOCK(acpi_prt_lock);
 
+static inline char pin_name(int pin)
+{
+	return 'A' + pin;
+}
+
 /* --------------------------------------------------------------------------
                          PCI IRQ Routing Table (PRT) Support
    -------------------------------------------------------------------------- */
@@ -174,14 +179,14 @@ do_prt_fixups(struct acpi_prt_entry *entry, struct acpi_pci_routing_table *prt)
 		    entry->id.segment == quirk->segment &&
 		    entry->id.bus == quirk->bus &&
 		    entry->id.device == quirk->device &&
-		    entry->pin + 'A' == quirk->pin &&
+		    pin_name(entry->pin) == quirk->pin &&
 		    !strcmp(prt->source, quirk->source) &&
 		    strlen(prt->source) >= strlen(quirk->actual_source)) {
 			printk(KERN_WARNING PREFIX "firmware reports "
 				"%04x:%02x:%02x PCI INT %c connected to %s; "
 				"changing to %s\n",
 				entry->id.segment, entry->id.bus,
-				entry->id.device, 'A' + entry->pin,
+				entry->id.device, pin_name(entry->pin),
 				prt->source, quirk->actual_source);
 			strcpy(prt->source, quirk->actual_source);
 		}
@@ -235,8 +240,8 @@ acpi_pci_irq_add_entry(acpi_handle handle,
 	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INFO,
 			      "      %04x:%02x:%02x[%c] -> %s[%d]\n",
 			      entry->id.segment, entry->id.bus,
-			      entry->id.device, ('A' + entry->pin), prt->source,
-			      entry->link.index));
+			      entry->id.device, pin_name(entry->pin),
+			      prt->source, entry->link.index));
 
 	spin_lock(&acpi_prt_lock);
 	list_add_tail(&entry->node, &acpi_prt.entries);
@@ -387,7 +392,7 @@ acpi_pci_irq_lookup(struct pci_bus *bus,
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  "Searching for _PRT entry for %04x:%02x:%02x[%c]\n",
-			  segment, bus_nr, device, ('A' + pin)));
+			  segment, bus_nr, device, pin_name(pin)));
 
 	entry = acpi_pci_irq_find_prt_entry(segment, bus_nr, device, pin);
 	if (!entry) {
@@ -444,7 +449,7 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 
 	if (irq < 0) {
 		dev_warn(&dev->dev, "can't derive routing for PCI INT %c\n",
-			 'A' + orig_pin);
+			 pin_name(orig_pin));
 		return -1;
 	}
 
@@ -511,7 +516,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	 * driver reported one, then use it. Exit in any case.
 	 */
 	if (gsi < 0) {
-		dev_warn(&dev->dev, "PCI INT %c: no GSI", 'A' + pin);
+		dev_warn(&dev->dev, "PCI INT %c: no GSI", pin_name(pin));
 		/* Interrupt Line values above 0xF are forbidden */
 		if (dev->irq > 0 && (dev->irq <= 0xF)) {
 			printk(" - using IRQ %d\n", dev->irq);
@@ -527,7 +532,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	rc = acpi_register_gsi(gsi, triggering, polarity);
 	if (rc < 0) {
 		dev_warn(&dev->dev, "PCI INT %c: failed to register GSI\n",
-			 'A' + pin);
+			 pin_name(pin));
 		return rc;
 	}
 	dev->irq = rc;
@@ -538,7 +543,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 		link_desc[0] = '\0';
 
 	dev_info(&dev->dev, "PCI INT %c%s -> GSI %u (%s, %s) -> IRQ %d\n",
-		 'A' + pin, link_desc, gsi,
+		 pin_name(pin), link_desc, gsi,
 		 (triggering == ACPI_LEVEL_SENSITIVE) ? "level" : "edge",
 		 (polarity == ACPI_ACTIVE_LOW) ? "low" : "high", dev->irq);
 
@@ -585,6 +590,6 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	 * (e.g. PCI_UNDEFINED_IRQ).
 	 */
 
-	dev_info(&dev->dev, "PCI INT %c disabled\n", 'A' + pin);
+	dev_info(&dev->dev, "PCI INT %c disabled\n", pin_name(pin));
 	acpi_unregister_gsi(gsi);
 }

commit f748bafa3ca1fb056e63afdeecacc1c68d8104df
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:30:31 2008 -0700

    ACPI: PCI: move struct acpi_prt_entry declaration out of public header file
    
    The struct acpi_prt_entry is used only in pci_irq.c, so there's no
    need for the declaration to be public.  This patch moves it into
    pci_irq.c.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 9302f4bb89e2..ea003bab7ecd 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -41,6 +41,22 @@
 #define _COMPONENT		ACPI_PCI_COMPONENT
 ACPI_MODULE_NAME("pci_irq");
 
+struct acpi_prt_entry {
+	struct list_head	node;
+	struct acpi_pci_id	id;
+	u8			pin;
+	struct {
+		acpi_handle		handle;
+		u32			index;
+	}			link;
+	u32			irq;
+};
+
+struct acpi_prt_list {
+	int			count;
+	struct list_head	entries;
+};
+
 static struct acpi_prt_list acpi_prt;
 static DEFINE_SPINLOCK(acpi_prt_lock);
 

commit c13f889a24e6ced50abb582dab3ee4b7c79b038e
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:30:26 2008 -0700

    ACPI: PCI: fix GSI/IRQ naming confusion
    
    The interrupt numbers from _PRT entries are GSIs, not Linux IRQs.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index c6a0364715ce..9302f4bb89e2 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -333,7 +333,7 @@ acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
 		*polarity = ACPI_ACTIVE_LOW;
 	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found IRQ %d\n", irq));
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found GSI %d\n", irq));
 	return irq;
 }
 
@@ -432,7 +432,7 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 		return -1;
 	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Derive IRQ %d for device %s from %s\n",
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Derive GSI %d for device %s from %s\n",
 			  irq, pci_name(dev), pci_name(bridge)));
 
 	return irq;
@@ -446,7 +446,7 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 
 int acpi_pci_irq_enable(struct pci_dev *dev)
 {
-	int irq = 0;
+	int gsi = 0;
 	u8 pin = 0;
 	int triggering = ACPI_LEVEL_SENSITIVE;
 	int polarity = ACPI_ACTIVE_LOW;
@@ -468,7 +468,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	 * First we check the PCI IRQ routing table (PRT) for an IRQ.  PRT
 	 * values override any BIOS-assigned IRQs set during boot.
 	 */
-	irq = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin,
+	gsi = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin,
 				  &triggering, &polarity, &link,
 				  acpi_pci_allocate_irq);
 
@@ -476,12 +476,12 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	 * If no PRT entry was found, we'll try to derive an IRQ from the
 	 * device's parent bridge.
 	 */
-	if (irq < 0)
-		irq = acpi_pci_irq_derive(dev, pin, &triggering,
+	if (gsi < 0)
+		gsi = acpi_pci_irq_derive(dev, pin, &triggering,
 					  &polarity, &link,
 					  acpi_pci_allocate_irq);
 
-	if (irq < 0) {
+	if (gsi < 0) {
 		/*
 		 * IDE legacy mode controller IRQs are magic. Why do compat
 		 * extensions always make such a nasty mess.
@@ -494,7 +494,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	 * No IRQ known to the ACPI subsystem - maybe the BIOS / 
 	 * driver reported one, then use it. Exit in any case.
 	 */
-	if (irq < 0) {
+	if (gsi < 0) {
 		dev_warn(&dev->dev, "PCI INT %c: no GSI", 'A' + pin);
 		/* Interrupt Line values above 0xF are forbidden */
 		if (dev->irq > 0 && (dev->irq <= 0xF)) {
@@ -508,7 +508,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 		}
 	}
 
-	rc = acpi_register_gsi(irq, triggering, polarity);
+	rc = acpi_register_gsi(gsi, triggering, polarity);
 	if (rc < 0) {
 		dev_warn(&dev->dev, "PCI INT %c: failed to register GSI\n",
 			 'A' + pin);
@@ -522,7 +522,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 		link_desc[0] = '\0';
 
 	dev_info(&dev->dev, "PCI INT %c%s -> GSI %u (%s, %s) -> IRQ %d\n",
-		 'A' + pin, link_desc, irq,
+		 'A' + pin, link_desc, gsi,
 		 (triggering == ACPI_LEVEL_SENSITIVE) ? "level" : "edge",
 		 (polarity == ACPI_ACTIVE_LOW) ? "low" : "high", dev->irq);
 

commit b52b3f4af83571e86f910b07a61b177e2b7d8409
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:30:20 2008 -0700

    ACPI: PCI: ignore _PRT function information
    
    _PRT entries don't contain any useful PCI function information (the
    function part of the PCI address is supposed to be 0xffff), and we
    don't ever look at it, so this patch just removes the reference to
    it.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 6a9f3ddb322e..c6a0364715ce 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -185,7 +185,6 @@ acpi_pci_irq_add_entry(acpi_handle handle,
 	entry->id.segment = segment;
 	entry->id.bus = bus;
 	entry->id.device = (prt->address >> 16) & 0xFFFF;
-	entry->id.function = prt->address & 0xFFFF;
 	entry->pin = prt->pin;
 
 	do_prt_fixups(entry, prt);

commit 2320ac6cb078eec77bf93742895dc35e64fae124
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:30:15 2008 -0700

    ACPI: PCI: simplify buffer management for evaluating _PRT
    
    Previously, acpi_pci_irq_add_prt() did all its own buffer management.
    But now that we have ACPI_ALLOCATE_BUFFER, we no longer need to do
    that management.  And we don't have to call acpi_get_irq_routing_table()
    twice (once to learn the size of the buffer needed, and again to
    actually get the table).
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 6c04060d063b..6a9f3ddb322e 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -243,55 +243,29 @@ acpi_pci_irq_del_entry(int segment, int bus, struct acpi_prt_entry *entry)
 
 int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 {
-	acpi_status status = AE_OK;
-	char *pathname = NULL;
-	struct acpi_buffer buffer = { 0, NULL };
-	struct acpi_pci_routing_table *prt = NULL;
-	struct acpi_pci_routing_table *entry = NULL;
+	acpi_status status;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_pci_routing_table *entry;
 	static int first_time = 1;
 
-
-	pathname = kzalloc(ACPI_PATHNAME_MAX, GFP_KERNEL);
-	if (!pathname)
-		return -ENOMEM;
-
 	if (first_time) {
 		acpi_prt.count = 0;
 		INIT_LIST_HEAD(&acpi_prt.entries);
 		first_time = 0;
 	}
 
-	/* 
-	 * NOTE: We're given a 'handle' to the _PRT object's parent device
-	 *       (either a PCI root bridge or PCI-PCI bridge).
-	 */
-
-	buffer.length = ACPI_PATHNAME_MAX;
-	buffer.pointer = pathname;
-	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+	/* 'handle' is the _PRT's parent (root bridge or PCI-PCI bridge) */
+	status = acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
 
 	printk(KERN_DEBUG "ACPI: PCI Interrupt Routing Table [%s._PRT]\n",
-	       pathname);
+	       (char *) buffer.pointer);
 
-	/* 
-	 * Evaluate this _PRT and add its entries to our global list (acpi_prt).
-	 */
+	kfree(buffer.pointer);
 
-	buffer.length = 0;
+	buffer.length = ACPI_ALLOCATE_BUFFER;
 	buffer.pointer = NULL;
-	kfree(pathname);
-	status = acpi_get_irq_routing_table(handle, &buffer);
-	if (status != AE_BUFFER_OVERFLOW) {
-		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRT [%s]",
-				acpi_format_exception(status)));
-		return -ENODEV;
-	}
-
-	prt = kzalloc(buffer.length, GFP_KERNEL);
-	if (!prt) {
-		return -ENOMEM;
-	}
-	buffer.pointer = prt;
 
 	status = acpi_get_irq_routing_table(handle, &buffer);
 	if (ACPI_FAILURE(status)) {
@@ -301,16 +275,14 @@ int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 		return -ENODEV;
 	}
 
-	entry = prt;
-
+	entry = buffer.pointer;
 	while (entry && (entry->length > 0)) {
 		acpi_pci_irq_add_entry(handle, segment, bus, entry);
 		entry = (struct acpi_pci_routing_table *)
 		    ((unsigned long)entry + entry->length);
 	}
 
-	kfree(prt);
-
+	kfree(buffer.pointer);
 	return 0;
 }
 

commit 3b8249de43ecf05407888c1ca6ca6e4945ff823c
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:30:10 2008 -0700

    ACPI: PCI: remove unnecessary null pointer checks
    
    Better to oops and learn about a bug than to silently cover it up.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 63a132609991..6c04060d063b 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -178,10 +178,6 @@ acpi_pci_irq_add_entry(acpi_handle handle,
 {
 	struct acpi_prt_entry *entry = NULL;
 
-
-	if (!prt)
-		return -EINVAL;
-
 	entry = kzalloc(sizeof(struct acpi_prt_entry), GFP_KERNEL);
 	if (!entry)
 		return -ENOMEM;
@@ -432,9 +428,6 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 	u8 bridge_pin = 0, orig_pin = pin;
 
 
-	if (!dev)
-		return -EINVAL;
-
 	/* 
 	 * Attempt to derive an IRQ for this device from a parent bridge's
 	 * PCI interrupt routing entry (eg. yenta bridge and add-in card bridge).
@@ -491,9 +484,6 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	int rc;
 
 
-	if (!dev)
-		return -EINVAL;
-
 	pin = dev->pin;
 	if (!pin) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
@@ -503,11 +493,6 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	}
 	pin--;
 
-	if (!dev->bus) {
-		dev_err(&dev->dev, "invalid (NULL) 'bus' field\n");
-		return -ENODEV;
-	}
-
 	/* 
 	 * First we check the PCI IRQ routing table (PRT) for an IRQ.  PRT
 	 * values override any BIOS-assigned IRQs set during boot.
@@ -586,9 +571,6 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	int polarity = ACPI_ACTIVE_LOW;
 
 
-	if (!dev || !dev->bus)
-		return;
-
 	pin = dev->pin;
 	if (!pin)
 		return;

commit 21a53283a012f21764f2aaaac9414849e1153d93
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Dec 8 21:30:05 2008 -0700

    ACPI: PCI: use conventional PCI address format
    
    Use the conventional format for PCI addresses (%04x:%02x:%02x.%d).
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 11acaee14d66..63a132609991 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -222,7 +222,7 @@ acpi_pci_irq_add_entry(acpi_handle handle,
 		entry->link.index = prt->source_index;
 
 	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INFO,
-			      "      %02X:%02X:%02X[%c] -> %s[%d]\n",
+			      "      %04x:%02x:%02x[%c] -> %s[%d]\n",
 			      entry->id.segment, entry->id.bus,
 			      entry->id.device, ('A' + entry->pin), prt->source,
 			      entry->link.index));
@@ -328,8 +328,8 @@ void acpi_pci_irq_del_prt(int segment, int bus)
 	}
 
 	printk(KERN_DEBUG
-	       "ACPI: Delete PCI Interrupt Routing Table for %x:%x\n", segment,
-	       bus);
+	       "ACPI: Delete PCI Interrupt Routing Table for %04x:%02x\n",
+	       segment, bus);
 	spin_lock(&acpi_prt_lock);
 	list_for_each_safe(node, n, &acpi_prt.entries) {
 		entry = list_entry(node, struct acpi_prt_entry, node);
@@ -403,12 +403,12 @@ acpi_pci_irq_lookup(struct pci_bus *bus,
 
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			  "Searching for PRT entry for %02x:%02x:%02x[%c]\n",
+			  "Searching for _PRT entry for %04x:%02x:%02x[%c]\n",
 			  segment, bus_nr, device, ('A' + pin)));
 
 	entry = acpi_pci_irq_find_prt_entry(segment, bus_nr, device, pin);
 	if (!entry) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "PRT entry not found\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "_PRT entry not found\n"));
 		return -1;
 	}
 

commit c83642d5123225a22cccd75adea6e97c245714cb
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 08:45:39 2008 -0600

    ACPI: use dev_printk when possible
    
    Convert printks to use dev_printk().  The most obvious change will
    be messages like this:
    
       -ACPI: PCI Interrupt 0000:00:04.0[A] -> GSI 31 (level, low) -> IRQ 31
       +cciss 0000:00:04.0: PCI INT A -> GSI 31 (level, low) -> IRQ 31
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 89022a74faee..11acaee14d66 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -162,7 +162,7 @@ do_prt_fixups(struct acpi_prt_entry *entry, struct acpi_pci_routing_table *prt)
 		    !strcmp(prt->source, quirk->source) &&
 		    strlen(prt->source) >= strlen(quirk->actual_source)) {
 			printk(KERN_WARNING PREFIX "firmware reports "
-				"%04x:%02x:%02x[%c] connected to %s; "
+				"%04x:%02x:%02x PCI INT %c connected to %s; "
 				"changing to %s\n",
 				entry->id.segment, entry->id.bus,
 				entry->id.device, 'A' + entry->pin,
@@ -429,7 +429,7 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 {
 	struct pci_dev *bridge = dev;
 	int irq = -1;
-	u8 bridge_pin = 0;
+	u8 bridge_pin = 0, orig_pin = pin;
 
 
 	if (!dev)
@@ -463,8 +463,8 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 	}
 
 	if (irq < 0) {
-		printk(KERN_WARNING PREFIX "Unable to derive IRQ for device %s\n",
-			      pci_name(dev));
+		dev_warn(&dev->dev, "can't derive routing for PCI INT %c\n",
+			 'A' + orig_pin);
 		return -1;
 	}
 
@@ -487,6 +487,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	int triggering = ACPI_LEVEL_SENSITIVE;
 	int polarity = ACPI_ACTIVE_LOW;
 	char *link = NULL;
+	char link_desc[16];
 	int rc;
 
 
@@ -503,7 +504,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	pin--;
 
 	if (!dev->bus) {
-		printk(KERN_ERR PREFIX "Invalid (NULL) 'bus' field\n");
+		dev_err(&dev->dev, "invalid (NULL) 'bus' field\n");
 		return -ENODEV;
 	}
 
@@ -538,8 +539,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	 * driver reported one, then use it. Exit in any case.
 	 */
 	if (irq < 0) {
-		printk(KERN_WARNING PREFIX "PCI Interrupt %s[%c]: no GSI",
-		       pci_name(dev), ('A' + pin));
+		dev_warn(&dev->dev, "PCI INT %c: no GSI", 'A' + pin);
 		/* Interrupt Line values above 0xF are forbidden */
 		if (dev->irq > 0 && (dev->irq <= 0xF)) {
 			printk(" - using IRQ %d\n", dev->irq);
@@ -554,21 +554,21 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 
 	rc = acpi_register_gsi(irq, triggering, polarity);
 	if (rc < 0) {
-		printk(KERN_WARNING PREFIX "PCI Interrupt %s[%c]: failed "
-		       "to register GSI\n", pci_name(dev), ('A' + pin));
+		dev_warn(&dev->dev, "PCI INT %c: failed to register GSI\n",
+			 'A' + pin);
 		return rc;
 	}
 	dev->irq = rc;
 
-	printk(KERN_INFO PREFIX "PCI Interrupt %s[%c] -> ",
-	       pci_name(dev), 'A' + pin);
-
 	if (link)
-		printk("Link [%s] -> ", link);
+		snprintf(link_desc, sizeof(link_desc), " -> Link[%s]", link);
+	else
+		link_desc[0] = '\0';
 
-	printk("GSI %u (%s, %s) -> IRQ %d\n", irq,
-	       (triggering == ACPI_LEVEL_SENSITIVE) ? "level" : "edge",
-	       (polarity == ACPI_ACTIVE_LOW) ? "low" : "high", dev->irq);
+	dev_info(&dev->dev, "PCI INT %c%s -> GSI %u (%s, %s) -> IRQ %d\n",
+		 'A' + pin, link_desc, irq,
+		 (triggering == ACPI_LEVEL_SENSITIVE) ? "level" : "edge",
+		 (polarity == ACPI_ACTIVE_LOW) ? "low" : "high", dev->irq);
 
 	return 0;
 }
@@ -616,10 +616,6 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	 * (e.g. PCI_UNDEFINED_IRQ).
 	 */
 
-	printk(KERN_INFO PREFIX "PCI interrupt for device %s disabled\n",
-	       pci_name(dev));
-
+	dev_info(&dev->dev, "PCI INT %c disabled\n", 'A' + pin);
 	acpi_unregister_gsi(gsi);
-
-	return;
 }

commit b97d4803400a4442b0e4ae14d0bd8e83994b9004
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 25 11:21:11 2008 -0600

    ACPI: fix Medion _PRT quirk (use "ISA_", not "ISA")
    
    This fixes the builtin RTL8139 NIC on the Medion MD9580-F laptop.  The
    BIOS reports the interrupt routing incorrectly.  I recently added a
    quirk to work around this, and this patch fixes a typo in the quirk.
    
    We pad every ACPI pathname component to four characters, so ".ISA." will
    never match anything.  We need ".ISA_." instead.
    
    Thank you Johann-Nikolaus Andreae <johann-nikolaus.andreae@nacs.de>
    for patiently testing this patch.
    
    See http://bugzilla.kernel.org/show_bug.cgi?id=4773
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 7af414a3c63e..89022a74faee 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -131,8 +131,8 @@ struct prt_quirk {
  */
 static struct prt_quirk prt_quirks[] = {
 	{ medion_md9580, 0, 0, 9, 'A',
-		"\\_SB_.PCI0.ISA.LNKA",
-		"\\_SB_.PCI0.ISA.LNKB"},
+		"\\_SB_.PCI0.ISA_.LNKA",
+		"\\_SB_.PCI0.ISA_.LNKB"},
 	{ dell_optiplex, 0, 0, 0xd, 'A',
 		"\\_SB_.LNKB",
 		"\\_SB_.LNKA"},

commit 391df5dce30a5aab477b9e55ea65a3e83bae96b1
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 11 13:45:15 2008 -0700

    ACPI: add _PRT quirks to work around broken firmware
    
    This patch works around incorrect _PRT (PCI interrupt routing)
    information from firmware.  This does not fix any regressions
    and can wait for the next kernel release.
    
    On the Medion MD9580-F laptop, the BIOS says the builtin RTL8139
    NIC interrupt at 00:09.0[A] is connected to \_SB.PCI0.ISA.LNKA, but
    it's really connected to \_SB.PCI0.ISA.LNKB.  Before this patch,
    the workaround was to use "pci=routeirq".  More details at
    http://bugzilla.kernel.org/show_bug.cgi?id=4773.
    
    On the Dell OptiPlex GX1, the BIOS says the PCI slot interrupt
    00:0d[A] is connected to LNKB, but it's really connected to LNKA.
    Before this patch, the workaround was to use "pci=routeirq".
    Pierre Ossman tested a previous version of this patch and confirmed
    that it fixed the problem.  More details at
    http://bugzilla.kernel.org/show_bug.cgi?id=5044.
    
    On the HP t5710 thin client, the BIOS says the builtin Radeon
    video interrupt at 01:00[A] is connected to LNK1, but it's really
    connected to LNK3.  The previous workaround was to use a custom
    DSDT.  I tested this patch and verified that it fixes the problem.
    More details at http://bugzilla.kernel.org/show_bug.cgi?id=10138.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 7f19859580c7..7af414a3c63e 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -25,6 +25,7 @@
  */
 
 
+#include <linux/dmi.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -76,6 +77,101 @@ static struct acpi_prt_entry *acpi_pci_irq_find_prt_entry(int segment,
 	return NULL;
 }
 
+/* http://bugzilla.kernel.org/show_bug.cgi?id=4773 */
+static struct dmi_system_id medion_md9580[] = {
+	{
+		.ident = "Medion MD9580-F laptop",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "MEDIONNB"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "A555"),
+		},
+	},
+	{ }
+};
+
+/* http://bugzilla.kernel.org/show_bug.cgi?id=5044 */
+static struct dmi_system_id dell_optiplex[] = {
+	{
+		.ident = "Dell Optiplex GX1",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex GX1 600S+"),
+		},
+	},
+	{ }
+};
+
+/* http://bugzilla.kernel.org/show_bug.cgi?id=10138 */
+static struct dmi_system_id hp_t5710[] = {
+	{
+		.ident = "HP t5710",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "hp t5000 series"),
+			DMI_MATCH(DMI_BOARD_NAME, "098Ch"),
+		},
+	},
+	{ }
+};
+
+struct prt_quirk {
+	struct dmi_system_id	*system;
+	unsigned int		segment;
+	unsigned int		bus;
+	unsigned int		device;
+	unsigned char		pin;
+	char			*source;	/* according to BIOS */
+	char			*actual_source;
+};
+
+/*
+ * These systems have incorrect _PRT entries.  The BIOS claims the PCI
+ * interrupt at the listed segment/bus/device/pin is connected to the first
+ * link device, but it is actually connected to the second.
+ */
+static struct prt_quirk prt_quirks[] = {
+	{ medion_md9580, 0, 0, 9, 'A',
+		"\\_SB_.PCI0.ISA.LNKA",
+		"\\_SB_.PCI0.ISA.LNKB"},
+	{ dell_optiplex, 0, 0, 0xd, 'A',
+		"\\_SB_.LNKB",
+		"\\_SB_.LNKA"},
+	{ hp_t5710, 0, 0, 1, 'A',
+		"\\_SB_.PCI0.LNK1",
+		"\\_SB_.PCI0.LNK3"},
+};
+
+static void
+do_prt_fixups(struct acpi_prt_entry *entry, struct acpi_pci_routing_table *prt)
+{
+	int i;
+	struct prt_quirk *quirk;
+
+	for (i = 0; i < ARRAY_SIZE(prt_quirks); i++) {
+		quirk = &prt_quirks[i];
+
+		/* All current quirks involve link devices, not GSIs */
+		if (!prt->source)
+			continue;
+
+		if (dmi_check_system(quirk->system) &&
+		    entry->id.segment == quirk->segment &&
+		    entry->id.bus == quirk->bus &&
+		    entry->id.device == quirk->device &&
+		    entry->pin + 'A' == quirk->pin &&
+		    !strcmp(prt->source, quirk->source) &&
+		    strlen(prt->source) >= strlen(quirk->actual_source)) {
+			printk(KERN_WARNING PREFIX "firmware reports "
+				"%04x:%02x:%02x[%c] connected to %s; "
+				"changing to %s\n",
+				entry->id.segment, entry->id.bus,
+				entry->id.device, 'A' + entry->pin,
+				prt->source, quirk->actual_source);
+			strcpy(prt->source, quirk->actual_source);
+		}
+	}
+}
+
 static int
 acpi_pci_irq_add_entry(acpi_handle handle,
 		       int segment, int bus, struct acpi_pci_routing_table *prt)
@@ -96,6 +192,8 @@ acpi_pci_irq_add_entry(acpi_handle handle,
 	entry->id.function = prt->address & 0xFFFF;
 	entry->pin = prt->pin;
 
+	do_prt_fixups(entry, prt);
+
 	/*
 	 * Type 1: Dynamic
 	 * ---------------

commit a733a5da97b238e3e3167d3d0aee8fe1e8d04e97
Merge: 299cfe38081b 299cfe38081b 9e52797131e8
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 7 03:38:22 2008 -0500

    Merge branches 'release' and 'fluff' into release
    
    Conflicts:
    
            drivers/acpi/scan.c
            include/linux/acpi.h
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit e5685b9d35c2cc0a98425b05df30cb837dd1e632
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Oct 24 18:24:42 2007 +0200

    ACPI: misc cleanups
    
        This patch contains the following possible cleanups:
        - make the following needlessly global code static:
          - drivers/acpi/bay.c:dev_attr_eject
          - drivers/acpi/bay.c:dev_attr_present
          - drivers/acpi/dock.c:dev_attr_docked
          - drivers/acpi/dock.c:dev_attr_flags
          - drivers/acpi/dock.c:dev_attr_uid
          - drivers/acpi/dock.c:dev_attr_undock
          - drivers/acpi/pci_bind.c:acpi_pci_unbind()
          - drivers/acpi/pci_link.c:acpi_link_lock
          - drivers/acpi/sbs.c:acpi_sbs_callback()
          - drivers/acpi/sbshc.c:acpi_smbus_transaction()
          - drivers/acpi/sleep/main.c:acpi_sleep_prepare()
        - #if 0 the following unused global functions:
          - drivers/acpi/numa.c:acpi_unmap_pxm_to_node()
        - remove the following unused EXPORT_SYMBOL's:
          - acpi_register_gsi
          - acpi_unregister_gsi
          - acpi_strict
          - acpi_bus_receive_event
          - register_acpi_bus_type
          - unregister_acpi_bus_type
          - acpi_os_printf
          - acpi_os_sleep
          - acpi_os_stall
          - acpi_os_read_pci_configuration
          - acpi_os_create_semaphore
          - acpi_os_delete_semaphore
          - acpi_os_wait_semaphore
          - acpi_os_signal_semaphore
          - acpi_os_signal
          - acpi_pci_irq_enable
          - acpi_get_pxm
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 62010c2481b3..822947339df1 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -478,8 +478,6 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	return 0;
 }
 
-EXPORT_SYMBOL(acpi_pci_irq_enable);
-
 /* FIXME: implement x86/x86_64 version */
 void __attribute__ ((weak)) acpi_unregister_gsi(u32 i)
 {

commit 1a3b77ae60f19fa85f4cdc34b6c09efb1a18372c
Author: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
Date:   Mon Feb 4 23:31:20 2008 -0800

    ACPI: acpi_pci_irq_find_prt_entry(): use list_for_each_entry() instead of list_for_each()
    
    Signed-off-by: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 62010c2481b3..76d9c669d2d8 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -51,10 +51,8 @@ static struct acpi_prt_entry *acpi_pci_irq_find_prt_entry(int segment,
 							  int bus,
 							  int device, int pin)
 {
-	struct list_head *node = NULL;
 	struct acpi_prt_entry *entry = NULL;
 
-
 	if (!acpi_prt.count)
 		return NULL;
 
@@ -64,8 +62,7 @@ static struct acpi_prt_entry *acpi_pci_irq_find_prt_entry(int segment,
 	 *
 	 */
 	spin_lock(&acpi_prt_lock);
-	list_for_each(node, &acpi_prt.entries) {
-		entry = list_entry(node, struct acpi_prt_entry, node);
+	list_for_each_entry(entry, &acpi_prt.entries, node) {
 		if ((segment == entry->id.segment)
 		    && (bus == entry->id.bus)
 		    && (device == entry->id.device)

commit 96c2a8766bf4fe91abac863749c11637fabcc64f
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Jan 10 22:49:58 2008 -0500

    ACPI : Not register gsi for PCI IDE controller in legacy mode
    
    When PCI IDE controller works in legacy mode and no PRT entry is found
    in ACPI PRT table, OSPM will neither read the irq number from the IDE
    PCI configuration space nor call the function of acpi_register_gsi to
    register gsi.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=5637
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index dd3186abe07a..62010c2481b3 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -429,6 +429,15 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 					  &polarity, &link,
 					  acpi_pci_allocate_irq);
 
+	if (irq < 0) {
+		/*
+		 * IDE legacy mode controller IRQs are magic. Why do compat
+		 * extensions always make such a nasty mess.
+		 */
+		if (dev->class >> 8 == PCI_CLASS_STORAGE_IDE &&
+				(dev->class & 0x05) == 0)
+			return 0;
+	}
 	/*
 	 * No IRQ known to the ACPI subsystem - maybe the BIOS / 
 	 * driver reported one, then use it. Exit in any case.

commit f52fd66d2ea794010c2d7536cf8e6abed0ac4947
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 22:42:12 2007 -0500

    ACPI: clean up ACPI_MODULE_NAME() use
    
    cosmetic only
    
    Make "module name" actually match the file name.
    Invoke with ';' as leaving it off confuses Lindent and gcc doesn't care.
    Fix indentation where Lindent did get confused.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index fe7d007833ad..dd3186abe07a 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -38,7 +38,7 @@
 #include <acpi/acpi_drivers.h>
 
 #define _COMPONENT		ACPI_PCI_COMPONENT
-ACPI_MODULE_NAME("pci_irq")
+ACPI_MODULE_NAME("pci_irq");
 
 static struct acpi_prt_list acpi_prt;
 static DEFINE_SPINLOCK(acpi_prt_lock);

commit 36bcbec7ce21e2e8b3143b11a05747330abeca70
Author: Burman Yan <yan_952@hotmail.com>
Date:   Tue Dec 19 12:56:11 2006 -0800

    ACPI: replace kmalloc+memset with kzalloc
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 226892eaf987..fe7d007833ad 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -89,10 +89,9 @@ acpi_pci_irq_add_entry(acpi_handle handle,
 	if (!prt)
 		return -EINVAL;
 
-	entry = kmalloc(sizeof(struct acpi_prt_entry), GFP_KERNEL);
+	entry = kzalloc(sizeof(struct acpi_prt_entry), GFP_KERNEL);
 	if (!entry)
 		return -ENOMEM;
-	memset(entry, 0, sizeof(struct acpi_prt_entry));
 
 	entry->id.segment = segment;
 	entry->id.bus = bus;
@@ -161,10 +160,9 @@ int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 	static int first_time = 1;
 
 
-	pathname = kmalloc(ACPI_PATHNAME_MAX, GFP_KERNEL);
+	pathname = kzalloc(ACPI_PATHNAME_MAX, GFP_KERNEL);
 	if (!pathname)
 		return -ENOMEM;
-	memset(pathname, 0, ACPI_PATHNAME_MAX);
 
 	if (first_time) {
 		acpi_prt.count = 0;
@@ -198,11 +196,10 @@ int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 		return -ENODEV;
 	}
 
-	prt = kmalloc(buffer.length, GFP_KERNEL);
+	prt = kzalloc(buffer.length, GFP_KERNEL);
 	if (!prt) {
 		return -ENOMEM;
 	}
-	memset(prt, 0, buffer.length);
 	buffer.pointer = prt;
 
 	status = acpi_get_irq_routing_table(handle, &buffer);

commit 50dd096973f1d95aa03c6a6d9e148d706b62b68e
Author: Jan Engelhardt <jengelh@linux01.gwdg.de>
Date:   Sun Oct 1 00:28:50 2006 +0200

    ACPI: Remove unnecessary from/to-void* and to-void casts in drivers/acpi
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index feda0341f5a7..226892eaf987 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -161,7 +161,7 @@ int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 	static int first_time = 1;
 
 
-	pathname = (char *)kmalloc(ACPI_PATHNAME_MAX, GFP_KERNEL);
+	pathname = kmalloc(ACPI_PATHNAME_MAX, GFP_KERNEL);
 	if (!pathname)
 		return -ENOMEM;
 	memset(pathname, 0, ACPI_PATHNAME_MAX);

commit 22a3e233ca08a2ddc949ba1ae8f6e16ec7ef1a13
Merge: 39302175c26d 6ab3d5624e17
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Fri Jun 30 15:39:30 2006 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/bunk/trivial
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/bunk/trivial:
      Remove obsolete #include <linux/config.h>
      remove obsolete swsusp_encrypt
      arch/arm26/Kconfig typos
      Documentation/IPMI typos
      Kconfig: Typos in net/sched/Kconfig
      v9fs: do not include linux/version.h
      Documentation/DocBook/mtdnand.tmpl: typo fixes
      typo fixes: specfic -> specific
      typo fixes in Documentation/networking/pktgen.txt
      typo fixes: occuring -> occurring
      typo fixes: infomation -> information
      typo fixes: disadvantadge -> disadvantage
      typo fixes: aquire -> acquire
      typo fixes: mecanism -> mechanism
      typo fixes: bandwith -> bandwidth
      fix a typo in the RTC_CLASS help text
      smb is no longer maintained
    
    Manually merged trivial conflict in arch/um/kernel/vmlinux.lds.S

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 65aee79b3971..ed3f226677aa 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -24,7 +24,6 @@
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 
-#include <linux/config.h>
 
 #include <linux/kernel.h>
 #include <linux/module.h>

commit d550d98d3317378d93a4869db204725d270ec812
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Tue Jun 27 00:41:40 2006 -0400

    ACPI: delete tracing macros from drivers/acpi/*.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index f24a610008a0..fb96e3bf969b 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -55,10 +55,9 @@ static struct acpi_prt_entry *acpi_pci_irq_find_prt_entry(int segment,
 	struct list_head *node = NULL;
 	struct acpi_prt_entry *entry = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_irq_find_prt_entry");
 
 	if (!acpi_prt.count)
-		return_PTR(NULL);
+		return NULL;
 
 	/*
 	 * Parse through all PRT entries looking for a match on the specified
@@ -73,12 +72,12 @@ static struct acpi_prt_entry *acpi_pci_irq_find_prt_entry(int segment,
 		    && (device == entry->id.device)
 		    && (pin == entry->pin)) {
 			spin_unlock(&acpi_prt_lock);
-			return_PTR(entry);
+			return entry;
 		}
 	}
 
 	spin_unlock(&acpi_prt_lock);
-	return_PTR(NULL);
+	return NULL;
 }
 
 static int
@@ -87,14 +86,13 @@ acpi_pci_irq_add_entry(acpi_handle handle,
 {
 	struct acpi_prt_entry *entry = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_irq_add_entry");
 
 	if (!prt)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	entry = kmalloc(sizeof(struct acpi_prt_entry), GFP_KERNEL);
 	if (!entry)
-		return_VALUE(-ENOMEM);
+		return -ENOMEM;
 	memset(entry, 0, sizeof(struct acpi_prt_entry));
 
 	entry->id.segment = segment;
@@ -141,7 +139,7 @@ acpi_pci_irq_add_entry(acpi_handle handle,
 	acpi_prt.count++;
 	spin_unlock(&acpi_prt_lock);
 
-	return_VALUE(0);
+	return 0;
 }
 
 static void
@@ -163,11 +161,10 @@ int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 	struct acpi_pci_routing_table *entry = NULL;
 	static int first_time = 1;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_irq_add_prt");
 
 	pathname = (char *)kmalloc(ACPI_PATHNAME_MAX, GFP_KERNEL);
 	if (!pathname)
-		return_VALUE(-ENOMEM);
+		return -ENOMEM;
 	memset(pathname, 0, ACPI_PATHNAME_MAX);
 
 	if (first_time) {
@@ -199,12 +196,12 @@ int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 	if (status != AE_BUFFER_OVERFLOW) {
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRT [%s]",
 				acpi_format_exception(status)));
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
 	prt = kmalloc(buffer.length, GFP_KERNEL);
 	if (!prt) {
-		return_VALUE(-ENOMEM);
+		return -ENOMEM;
 	}
 	memset(prt, 0, buffer.length);
 	buffer.pointer = prt;
@@ -214,7 +211,7 @@ int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRT [%s]",
 				acpi_format_exception(status)));
 		kfree(buffer.pointer);
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
 	entry = prt;
@@ -227,7 +224,7 @@ int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 
 	kfree(prt);
 
-	return_VALUE(0);
+	return 0;
 }
 
 void acpi_pci_irq_del_prt(int segment, int bus)
@@ -262,7 +259,6 @@ acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
 {
 	int irq;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_allocate_irq");
 
 	if (entry->link.handle) {
 		irq = acpi_pci_link_allocate_irq(entry->link.handle,
@@ -271,7 +267,7 @@ acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
 		if (irq < 0) {
 			printk(KERN_WARNING PREFIX
 				      "Invalid IRQ link routing entry\n");
-			return_VALUE(-1);
+			return -1;
 		}
 	} else {
 		irq = entry->link.index;
@@ -280,7 +276,7 @@ acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found IRQ %d\n", irq));
-	return_VALUE(irq);
+	return irq;
 }
 
 static int
@@ -289,13 +285,12 @@ acpi_pci_free_irq(struct acpi_prt_entry *entry,
 {
 	int irq;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_free_irq");
 	if (entry->link.handle) {
 		irq = acpi_pci_link_free_irq(entry->link.handle);
 	} else {
 		irq = entry->link.index;
 	}
-	return_VALUE(irq);
+	return irq;
 }
 
 /*
@@ -315,7 +310,6 @@ acpi_pci_irq_lookup(struct pci_bus *bus,
 	int bus_nr = bus->number;
 	int ret;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_irq_lookup");
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  "Searching for PRT entry for %02x:%02x:%02x[%c]\n",
@@ -324,11 +318,11 @@ acpi_pci_irq_lookup(struct pci_bus *bus,
 	entry = acpi_pci_irq_find_prt_entry(segment, bus_nr, device, pin);
 	if (!entry) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "PRT entry not found\n"));
-		return_VALUE(-1);
+		return -1;
 	}
 
 	ret = func(entry, triggering, polarity, link);
-	return_VALUE(ret);
+	return ret;
 }
 
 /*
@@ -346,10 +340,9 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 	int irq = -1;
 	u8 bridge_pin = 0;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_irq_derive");
 
 	if (!dev)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	/* 
 	 * Attempt to derive an IRQ for this device from a parent bridge's
@@ -366,7 +359,7 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 						  "No interrupt pin configured for device %s\n",
 						  pci_name(bridge)));
-				return_VALUE(-1);
+				return -1;
 			}
 			/* Pin is from 0 to 3 */
 			bridge_pin--;
@@ -381,13 +374,13 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 	if (irq < 0) {
 		printk(KERN_WARNING PREFIX "Unable to derive IRQ for device %s\n",
 			      pci_name(dev));
-		return_VALUE(-1);
+		return -1;
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Derive IRQ %d for device %s from %s\n",
 			  irq, pci_name(dev), pci_name(bridge)));
 
-	return_VALUE(irq);
+	return irq;
 }
 
 /*
@@ -405,23 +398,22 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	char *link = NULL;
 	int rc;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_irq_enable");
 
 	if (!dev)
-		return_VALUE(-EINVAL);
+		return -EINVAL;
 
 	pin = dev->pin;
 	if (!pin) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "No interrupt pin configured for device %s\n",
 				  pci_name(dev)));
-		return_VALUE(0);
+		return 0;
 	}
 	pin--;
 
 	if (!dev->bus) {
 		printk(KERN_ERR PREFIX "Invalid (NULL) 'bus' field\n");
-		return_VALUE(-ENODEV);
+		return -ENODEV;
 	}
 
 	/* 
@@ -453,10 +445,10 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 			printk(" - using IRQ %d\n", dev->irq);
 			acpi_register_gsi(dev->irq, ACPI_LEVEL_SENSITIVE,
 					  ACPI_ACTIVE_LOW);
-			return_VALUE(0);
+			return 0;
 		} else {
 			printk("\n");
-			return_VALUE(0);
+			return 0;
 		}
 	}
 
@@ -464,7 +456,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	if (rc < 0) {
 		printk(KERN_WARNING PREFIX "PCI Interrupt %s[%c]: failed "
 		       "to register GSI\n", pci_name(dev), ('A' + pin));
-		return_VALUE(rc);
+		return rc;
 	}
 	dev->irq = rc;
 
@@ -478,7 +470,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	       (triggering == ACPI_LEVEL_SENSITIVE) ? "level" : "edge",
 	       (polarity == ACPI_ACTIVE_LOW) ? "low" : "high", dev->irq);
 
-	return_VALUE(0);
+	return 0;
 }
 
 EXPORT_SYMBOL(acpi_pci_irq_enable);
@@ -495,14 +487,13 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	int triggering = ACPI_LEVEL_SENSITIVE;
 	int polarity = ACPI_ACTIVE_LOW;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_irq_disable");
 
 	if (!dev || !dev->bus)
-		return_VOID;
+		return;
 
 	pin = dev->pin;
 	if (!pin)
-		return_VOID;
+		return;
 	pin--;
 
 	/*
@@ -520,7 +511,7 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 					  &triggering, &polarity, NULL,
 					  acpi_pci_free_irq);
 	if (gsi < 0)
-		return_VOID;
+		return;
 
 	/*
 	 * TBD: It might be worth clearing dev->irq by magic constant
@@ -532,5 +523,5 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 
 	acpi_unregister_gsi(gsi);
 
-	return_VOID;
+	return;
 }

commit 6468463abd7051fcc29f3ee7c931f9bbbb26f5a4
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jun 26 23:41:38 2006 -0400

    ACPI: un-export ACPI_ERROR() -- use printk(KERN_ERR...)
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 9010653a3823..f24a610008a0 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -420,7 +420,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	pin--;
 
 	if (!dev->bus) {
-		ACPI_ERROR((AE_INFO, "Invalid (NULL) 'bus' field"));
+		printk(KERN_ERR PREFIX "Invalid (NULL) 'bus' field\n");
 		return_VALUE(-ENODEV);
 	}
 

commit cece92969762b8ed7930d4e23008b76b06411dee
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jun 26 23:04:31 2006 -0400

    ACPI: un-export ACPI_WARNING() -- use printk(KERN_WARNING...)
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 4cabc51246de..9010653a3823 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -269,8 +269,8 @@ acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
 						 entry->link.index, triggering,
 						 polarity, link);
 		if (irq < 0) {
-			ACPI_WARNING((AE_INFO,
-				      "Invalid IRQ link routing entry"));
+			printk(KERN_WARNING PREFIX
+				      "Invalid IRQ link routing entry\n");
 			return_VALUE(-1);
 		}
 	} else {
@@ -379,8 +379,8 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 	}
 
 	if (irq < 0) {
-		ACPI_WARNING((AE_INFO, "Unable to derive IRQ for device %s",
-			      pci_name(dev)));
+		printk(KERN_WARNING PREFIX "Unable to derive IRQ for device %s\n",
+			      pci_name(dev));
 		return_VALUE(-1);
 	}
 

commit a6fc67202e0224e6c9d1d285cc0b444bce887ed5
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jun 26 23:58:43 2006 -0400

    ACPI: Enable ACPI error messages w/o CONFIG_ACPI_DEBUG
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 65aee79b3971..4cabc51246de 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -197,8 +197,8 @@ int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 	kfree(pathname);
 	status = acpi_get_irq_routing_table(handle, &buffer);
 	if (status != AE_BUFFER_OVERFLOW) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRT [%s]\n",
-				  acpi_format_exception(status)));
+		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRT [%s]",
+				acpi_format_exception(status)));
 		return_VALUE(-ENODEV);
 	}
 
@@ -211,8 +211,8 @@ int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 
 	status = acpi_get_irq_routing_table(handle, &buffer);
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRT [%s]\n",
-				  acpi_format_exception(status)));
+		ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRT [%s]",
+				acpi_format_exception(status)));
 		kfree(buffer.pointer);
 		return_VALUE(-ENODEV);
 	}
@@ -269,8 +269,8 @@ acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
 						 entry->link.index, triggering,
 						 polarity, link);
 		if (irq < 0) {
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-					  "Invalid IRQ link routing entry\n"));
+			ACPI_WARNING((AE_INFO,
+				      "Invalid IRQ link routing entry"));
 			return_VALUE(-1);
 		}
 	} else {
@@ -379,9 +379,8 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 	}
 
 	if (irq < 0) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-				  "Unable to derive IRQ for device %s\n",
-				  pci_name(dev)));
+		ACPI_WARNING((AE_INFO, "Unable to derive IRQ for device %s",
+			      pci_name(dev)));
 		return_VALUE(-1);
 	}
 
@@ -421,8 +420,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	pin--;
 
 	if (!dev->bus) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Invalid (NULL) 'bus' field\n"));
+		ACPI_ERROR((AE_INFO, "Invalid (NULL) 'bus' field"));
 		return_VALUE(-ENODEV);
 	}
 

commit 9fdb62af92c741addbea15545f214a6e89460865
Merge: 3ee68c4af3fd 876c184b31dc 729b4d4ce198 cf8247884018 dacd9b803555 63c94b68ec30 35f652b5ef4e 1a38416cea8a 4a90c7e86202 aea19aa0780d 757b18661ea0 c4bb6f5ad968
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jan 24 17:52:48 2006 -0500

    [ACPI] merge 3549 4320 4485 4588 4980 5483 5651 acpica asus fops pnpacpi branches into release
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 8015a01486a0f789c9e98e8bf1f12a3ccb535b30
Author: Kristen Accardi <kristen.c.accardi@intel.com>
Date:   Wed Nov 2 16:24:35 2005 -0800

    [PATCH] apci: use pin stored in pci_dev
    
    Use the stored value of the Interrupt Pin, rather than try to read
    it again.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 09567c2edcfb..e567c03b238e 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -361,8 +361,7 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 
 		if ((bridge->class >> 8) == PCI_CLASS_BRIDGE_CARDBUS) {
 			/* PC card has the same IRQ as its cardbridge */
-			pci_read_config_byte(bridge, PCI_INTERRUPT_PIN,
-					     &bridge_pin);
+			bridge_pin = bridge->pin;
 			if (!bridge_pin) {
 				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 						  "No interrupt pin configured for device %s\n",
@@ -412,7 +411,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	if (!dev)
 		return_VALUE(-EINVAL);
 
-	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
+	pin = dev->pin;
 	if (!pin) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "No interrupt pin configured for device %s\n",
@@ -503,7 +502,7 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	if (!dev || !dev->bus)
 		return_VOID;
 
-	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
+	pin = dev->pin;
 	if (!pin)
 		return_VOID;
 	pin--;

commit 50eca3eb89d73d9f0aa070b126c7ee6a616016ab
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Sep 30 19:03:00 2005 -0400

    [ACPI] ACPICA 20050930
    
    Completed a major overhaul of the Resource Manager code -
    specifically, optimizations in the area of the AML/internal
    resource conversion code. The code has been optimized to
    simplify and eliminate duplicated code, CPU stack use has
    been decreased by optimizing function parameters and local
    variables, and naming conventions across the manager have
    been standardized for clarity and ease of maintenance (this
    includes function, parameter, variable, and struct/typedef
    names.)
    
    All Resource Manager dispatch and information tables have
    been moved to a single location for clarity and ease of
    maintenance. One new file was created, named "rsinfo.c".
    
    The ACPI return macros (return_ACPI_STATUS, etc.) have
    been modified to guarantee that the argument is
    not evaluated twice, making them less prone to macro
    side-effects. However, since there exists the possibility
    of additional stack use if a particular compiler cannot
    optimize them (such as in the debug generation case),
    the original macros are optionally available.  Note that
    some invocations of the return_VALUE macro may now cause
    size mismatch warnings; the return_UINT8 and return_UINT32
    macros are provided to eliminate these. (From Randy Dunlap)
    
    Implemented a new mechanism to enable debug tracing for
    individual control methods. A new external interface,
    acpi_debug_trace(), is provided to enable this mechanism. The
    intent is to allow the host OS to easily enable and disable
    tracing for problematic control methods. This interface
    can be easily exposed to a user or debugger interface if
    desired. See the file psxface.c for details.
    
    acpi_ut_callocate() will now return a valid pointer if a
    length of zero is specified - a length of one is used
    and a warning is issued. This matches the behavior of
    acpi_ut_allocate().
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 09567c2edcfb..726dda1fce1c 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -258,7 +258,7 @@ typedef int (*irq_lookup_func) (struct acpi_prt_entry *, int *, int *, char **);
 
 static int
 acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
-		      int *edge_level, int *active_high_low, char **link)
+		      int *triggering, int *polarity, char **link)
 {
 	int irq;
 
@@ -266,8 +266,8 @@ acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
 
 	if (entry->link.handle) {
 		irq = acpi_pci_link_allocate_irq(entry->link.handle,
-						 entry->link.index, edge_level,
-						 active_high_low, link);
+						 entry->link.index, triggering,
+						 polarity, link);
 		if (irq < 0) {
 			ACPI_DEBUG_PRINT((ACPI_DB_WARN,
 					  "Invalid IRQ link routing entry\n"));
@@ -275,8 +275,8 @@ acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
 		}
 	} else {
 		irq = entry->link.index;
-		*edge_level = ACPI_LEVEL_SENSITIVE;
-		*active_high_low = ACPI_ACTIVE_LOW;
+		*triggering = ACPI_LEVEL_SENSITIVE;
+		*polarity = ACPI_ACTIVE_LOW;
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found IRQ %d\n", irq));
@@ -285,7 +285,7 @@ acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
 
 static int
 acpi_pci_free_irq(struct acpi_prt_entry *entry,
-		  int *edge_level, int *active_high_low, char **link)
+		  int *triggering, int *polarity, char **link)
 {
 	int irq;
 
@@ -307,8 +307,8 @@ static int
 acpi_pci_irq_lookup(struct pci_bus *bus,
 		    int device,
 		    int pin,
-		    int *edge_level,
-		    int *active_high_low, char **link, irq_lookup_func func)
+		    int *triggering,
+		    int *polarity, char **link, irq_lookup_func func)
 {
 	struct acpi_prt_entry *entry = NULL;
 	int segment = pci_domain_nr(bus);
@@ -327,7 +327,7 @@ acpi_pci_irq_lookup(struct pci_bus *bus,
 		return_VALUE(-1);
 	}
 
-	ret = func(entry, edge_level, active_high_low, link);
+	ret = func(entry, triggering, polarity, link);
 	return_VALUE(ret);
 }
 
@@ -339,8 +339,8 @@ acpi_pci_irq_lookup(struct pci_bus *bus,
 static int
 acpi_pci_irq_derive(struct pci_dev *dev,
 		    int pin,
-		    int *edge_level,
-		    int *active_high_low, char **link, irq_lookup_func func)
+		    int *triggering,
+		    int *polarity, char **link, irq_lookup_func func)
 {
 	struct pci_dev *bridge = dev;
 	int irq = -1;
@@ -375,7 +375,7 @@ acpi_pci_irq_derive(struct pci_dev *dev,
 		}
 
 		irq = acpi_pci_irq_lookup(bridge->bus, PCI_SLOT(bridge->devfn),
-					  pin, edge_level, active_high_low,
+					  pin, triggering, polarity,
 					  link, func);
 	}
 
@@ -402,8 +402,8 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 {
 	int irq = 0;
 	u8 pin = 0;
-	int edge_level = ACPI_LEVEL_SENSITIVE;
-	int active_high_low = ACPI_ACTIVE_LOW;
+	int triggering = ACPI_LEVEL_SENSITIVE;
+	int polarity = ACPI_ACTIVE_LOW;
 	char *link = NULL;
 	int rc;
 
@@ -432,7 +432,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	 * values override any BIOS-assigned IRQs set during boot.
 	 */
 	irq = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin,
-				  &edge_level, &active_high_low, &link,
+				  &triggering, &polarity, &link,
 				  acpi_pci_allocate_irq);
 
 	/*
@@ -440,8 +440,8 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 	 * device's parent bridge.
 	 */
 	if (irq < 0)
-		irq = acpi_pci_irq_derive(dev, pin, &edge_level,
-					  &active_high_low, &link,
+		irq = acpi_pci_irq_derive(dev, pin, &triggering,
+					  &polarity, &link,
 					  acpi_pci_allocate_irq);
 
 	/*
@@ -463,7 +463,7 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 		}
 	}
 
-	rc = acpi_register_gsi(irq, edge_level, active_high_low);
+	rc = acpi_register_gsi(irq, triggering, polarity);
 	if (rc < 0) {
 		printk(KERN_WARNING PREFIX "PCI Interrupt %s[%c]: failed "
 		       "to register GSI\n", pci_name(dev), ('A' + pin));
@@ -478,8 +478,8 @@ int acpi_pci_irq_enable(struct pci_dev *dev)
 		printk("Link [%s] -> ", link);
 
 	printk("GSI %u (%s, %s) -> IRQ %d\n", irq,
-	       (edge_level == ACPI_LEVEL_SENSITIVE) ? "level" : "edge",
-	       (active_high_low == ACPI_ACTIVE_LOW) ? "low" : "high", dev->irq);
+	       (triggering == ACPI_LEVEL_SENSITIVE) ? "level" : "edge",
+	       (polarity == ACPI_ACTIVE_LOW) ? "low" : "high", dev->irq);
 
 	return_VALUE(0);
 }
@@ -495,8 +495,8 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 {
 	int gsi = 0;
 	u8 pin = 0;
-	int edge_level = ACPI_LEVEL_SENSITIVE;
-	int active_high_low = ACPI_ACTIVE_LOW;
+	int triggering = ACPI_LEVEL_SENSITIVE;
+	int polarity = ACPI_ACTIVE_LOW;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_irq_disable");
 
@@ -512,7 +512,7 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	 * First we check the PCI IRQ routing table (PRT) for an IRQ.
 	 */
 	gsi = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin,
-				  &edge_level, &active_high_low, NULL,
+				  &triggering, &polarity, NULL,
 				  acpi_pci_free_irq);
 	/*
 	 * If no PRT entry was found, we'll try to derive an IRQ from the
@@ -520,7 +520,7 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 	 */
 	if (gsi < 0)
 		gsi = acpi_pci_irq_derive(dev, pin,
-					  &edge_level, &active_high_low, NULL,
+					  &triggering, &polarity, NULL,
 					  acpi_pci_free_irq);
 	if (gsi < 0)
 		return_VOID;

commit 5f0110f2a716376f3b260703835f527ca8900946
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Sat Sep 3 00:34:32 2005 -0400

    [ACPI] fix run-time error checking in acpi_pci_irq_disable()
    
    The 'bus' field in pci_dev structure should be checked before calling
    pci_read_config_byte() because pci_bus_read_config_byte() called by
    pci_read_config_byte() refers to 'bus' field.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 2bbfba8e8c6d..09567c2edcfb 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -500,7 +500,7 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 
 	ACPI_FUNCTION_TRACE("acpi_pci_irq_disable");
 
-	if (!dev)
+	if (!dev || !dev->bus)
 		return_VOID;
 
 	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
@@ -508,9 +508,6 @@ void acpi_pci_irq_disable(struct pci_dev *dev)
 		return_VOID;
 	pin--;
 
-	if (!dev->bus)
-		return_VOID;
-
 	/*
 	 * First we check the PCI IRQ routing table (PRT) for an IRQ.
 	 */

commit 4be44fcd3bf648b782f4460fd06dfae6c42ded4b
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 5 00:44:28 2005 -0400

    [ACPI] Lindent all ACPI files
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index c885300579ec..2bbfba8e8c6d 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -38,26 +38,22 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
-
 #define _COMPONENT		ACPI_PCI_COMPONENT
-ACPI_MODULE_NAME		("pci_irq")
+ACPI_MODULE_NAME("pci_irq")
 
-static struct acpi_prt_list	acpi_prt;
+static struct acpi_prt_list acpi_prt;
 static DEFINE_SPINLOCK(acpi_prt_lock);
 
 /* --------------------------------------------------------------------------
                          PCI IRQ Routing Table (PRT) Support
    -------------------------------------------------------------------------- */
 
-static struct acpi_prt_entry *
-acpi_pci_irq_find_prt_entry (
-	int			segment,
-	int			bus,
-	int			device,
-	int			pin)
+static struct acpi_prt_entry *acpi_pci_irq_find_prt_entry(int segment,
+							  int bus,
+							  int device, int pin)
 {
-	struct list_head	*node = NULL;
-	struct acpi_prt_entry	*entry = NULL;
+	struct list_head *node = NULL;
+	struct acpi_prt_entry *entry = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_irq_find_prt_entry");
 
@@ -72,10 +68,10 @@ acpi_pci_irq_find_prt_entry (
 	spin_lock(&acpi_prt_lock);
 	list_for_each(node, &acpi_prt.entries) {
 		entry = list_entry(node, struct acpi_prt_entry, node);
-		if ((segment == entry->id.segment) 
-			&& (bus == entry->id.bus) 
-			&& (device == entry->id.device)
-			&& (pin == entry->pin)) {
+		if ((segment == entry->id.segment)
+		    && (bus == entry->id.bus)
+		    && (device == entry->id.device)
+		    && (pin == entry->pin)) {
 			spin_unlock(&acpi_prt_lock);
 			return_PTR(entry);
 		}
@@ -85,15 +81,11 @@ acpi_pci_irq_find_prt_entry (
 	return_PTR(NULL);
 }
 
-
 static int
-acpi_pci_irq_add_entry (
-	acpi_handle			handle,
-	int				segment,
-	int				bus,
-	struct acpi_pci_routing_table	*prt)
+acpi_pci_irq_add_entry(acpi_handle handle,
+		       int segment, int bus, struct acpi_pci_routing_table *prt)
 {
-	struct acpi_prt_entry	*entry = NULL;
+	struct acpi_prt_entry *entry = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_irq_add_entry");
 
@@ -139,9 +131,10 @@ acpi_pci_irq_add_entry (
 		entry->link.index = prt->source_index;
 
 	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INFO,
-		"      %02X:%02X:%02X[%c] -> %s[%d]\n", 
-		entry->id.segment, entry->id.bus, entry->id.device, 
-		('A' + entry->pin), prt->source, entry->link.index));
+			      "      %02X:%02X:%02X[%c] -> %s[%d]\n",
+			      entry->id.segment, entry->id.bus,
+			      entry->id.device, ('A' + entry->pin), prt->source,
+			      entry->link.index));
 
 	spin_lock(&acpi_prt_lock);
 	list_add_tail(&entry->node, &acpi_prt.entries);
@@ -151,38 +144,29 @@ acpi_pci_irq_add_entry (
 	return_VALUE(0);
 }
 
-
 static void
-acpi_pci_irq_del_entry (
-	int				segment,
-	int				bus,
-	struct acpi_prt_entry		*entry)
+acpi_pci_irq_del_entry(int segment, int bus, struct acpi_prt_entry *entry)
 {
-	if (segment == entry->id.segment && bus == entry->id.bus){
+	if (segment == entry->id.segment && bus == entry->id.bus) {
 		acpi_prt.count--;
 		list_del(&entry->node);
 		kfree(entry);
 	}
 }
 
-
-int
-acpi_pci_irq_add_prt (
-	acpi_handle		handle,
-	int			segment,
-	int			bus)
+int acpi_pci_irq_add_prt(acpi_handle handle, int segment, int bus)
 {
-	acpi_status			status = AE_OK;
-	char				*pathname = NULL;
-	struct acpi_buffer		buffer = {0, NULL};
-	struct acpi_pci_routing_table	*prt = NULL;
-	struct acpi_pci_routing_table	*entry = NULL;
-	static int			first_time = 1;
+	acpi_status status = AE_OK;
+	char *pathname = NULL;
+	struct acpi_buffer buffer = { 0, NULL };
+	struct acpi_pci_routing_table *prt = NULL;
+	struct acpi_pci_routing_table *entry = NULL;
+	static int first_time = 1;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_irq_add_prt");
 
-	pathname = (char *) kmalloc(ACPI_PATHNAME_MAX, GFP_KERNEL);
-	if(!pathname)
+	pathname = (char *)kmalloc(ACPI_PATHNAME_MAX, GFP_KERNEL);
+	if (!pathname)
 		return_VALUE(-ENOMEM);
 	memset(pathname, 0, ACPI_PATHNAME_MAX);
 
@@ -202,7 +186,7 @@ acpi_pci_irq_add_prt (
 	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
 
 	printk(KERN_DEBUG "ACPI: PCI Interrupt Routing Table [%s._PRT]\n",
-		pathname);
+	       pathname);
 
 	/* 
 	 * Evaluate this _PRT and add its entries to our global list (acpi_prt).
@@ -214,12 +198,12 @@ acpi_pci_irq_add_prt (
 	status = acpi_get_irq_routing_table(handle, &buffer);
 	if (status != AE_BUFFER_OVERFLOW) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRT [%s]\n",
-			acpi_format_exception(status)));
+				  acpi_format_exception(status)));
 		return_VALUE(-ENODEV);
 	}
 
 	prt = kmalloc(buffer.length, GFP_KERNEL);
-	if (!prt){
+	if (!prt) {
 		return_VALUE(-ENOMEM);
 	}
 	memset(prt, 0, buffer.length);
@@ -228,7 +212,7 @@ acpi_pci_irq_add_prt (
 	status = acpi_get_irq_routing_table(handle, &buffer);
 	if (ACPI_FAILURE(status)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRT [%s]\n",
-			acpi_format_exception(status)));
+				  acpi_format_exception(status)));
 		kfree(buffer.pointer);
 		return_VALUE(-ENODEV);
 	}
@@ -238,7 +222,7 @@ acpi_pci_irq_add_prt (
 	while (entry && (entry->length > 0)) {
 		acpi_pci_irq_add_entry(handle, segment, bus, entry);
 		entry = (struct acpi_pci_routing_table *)
-			((unsigned long) entry + entry->length);
+		    ((unsigned long)entry + entry->length);
 	}
 
 	kfree(prt);
@@ -246,18 +230,18 @@ acpi_pci_irq_add_prt (
 	return_VALUE(0);
 }
 
-void
-acpi_pci_irq_del_prt (int segment, int bus)
+void acpi_pci_irq_del_prt(int segment, int bus)
 {
-	struct list_head        *node = NULL, *n = NULL;
-	struct acpi_prt_entry   *entry = NULL;
+	struct list_head *node = NULL, *n = NULL;
+	struct acpi_prt_entry *entry = NULL;
 
-	if (!acpi_prt.count)    {
+	if (!acpi_prt.count) {
 		return;
 	}
 
-	printk(KERN_DEBUG "ACPI: Delete PCI Interrupt Routing Table for %x:%x\n",
-		segment, bus);
+	printk(KERN_DEBUG
+	       "ACPI: Delete PCI Interrupt Routing Table for %x:%x\n", segment,
+	       bus);
 	spin_lock(&acpi_prt_lock);
 	list_for_each_safe(node, n, &acpi_prt.entries) {
 		entry = list_entry(node, struct acpi_prt_entry, node);
@@ -266,26 +250,27 @@ acpi_pci_irq_del_prt (int segment, int bus)
 	}
 	spin_unlock(&acpi_prt_lock);
 }
+
 /* --------------------------------------------------------------------------
                           PCI Interrupt Routing Support
    -------------------------------------------------------------------------- */
-typedef int (*irq_lookup_func)(struct acpi_prt_entry *, int *, int *, char **);
+typedef int (*irq_lookup_func) (struct acpi_prt_entry *, int *, int *, char **);
 
 static int
 acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
-	int	*edge_level,
-	int	*active_high_low,
-	char	**link)
+		      int *edge_level, int *active_high_low, char **link)
 {
-	int	irq;
+	int irq;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_allocate_irq");
 
 	if (entry->link.handle) {
 		irq = acpi_pci_link_allocate_irq(entry->link.handle,
-			entry->link.index, edge_level, active_high_low, link);
+						 entry->link.index, edge_level,
+						 active_high_low, link);
 		if (irq < 0) {
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid IRQ link routing entry\n"));
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+					  "Invalid IRQ link routing entry\n"));
 			return_VALUE(-1);
 		}
 	} else {
@@ -300,11 +285,9 @@ acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
 
 static int
 acpi_pci_free_irq(struct acpi_prt_entry *entry,
-	int	*edge_level,
-	int	*active_high_low,
-	char	**link)
+		  int *edge_level, int *active_high_low, char **link)
 {
-	int	irq;
+	int irq;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_free_irq");
 	if (entry->link.handle) {
@@ -314,38 +297,36 @@ acpi_pci_free_irq(struct acpi_prt_entry *entry,
 	}
 	return_VALUE(irq);
 }
+
 /*
  * acpi_pci_irq_lookup
  * success: return IRQ >= 0
  * failure: return -1
  */
 static int
-acpi_pci_irq_lookup (
-	struct pci_bus		*bus,
-	int			device,
-	int			pin,
-	int			*edge_level,
-	int			*active_high_low,
-	char			**link,
-	irq_lookup_func		func)
+acpi_pci_irq_lookup(struct pci_bus *bus,
+		    int device,
+		    int pin,
+		    int *edge_level,
+		    int *active_high_low, char **link, irq_lookup_func func)
 {
-	struct acpi_prt_entry	*entry = NULL;
+	struct acpi_prt_entry *entry = NULL;
 	int segment = pci_domain_nr(bus);
 	int bus_nr = bus->number;
 	int ret;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_irq_lookup");
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"Searching for PRT entry for %02x:%02x:%02x[%c]\n", 
-		segment, bus_nr, device, ('A' + pin)));
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "Searching for PRT entry for %02x:%02x:%02x[%c]\n",
+			  segment, bus_nr, device, ('A' + pin)));
 
-	entry = acpi_pci_irq_find_prt_entry(segment, bus_nr, device, pin); 
+	entry = acpi_pci_irq_find_prt_entry(segment, bus_nr, device, pin);
 	if (!entry) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "PRT entry not found\n"));
 		return_VALUE(-1);
 	}
-	
+
 	ret = func(entry, edge_level, active_high_low, link);
 	return_VALUE(ret);
 }
@@ -356,17 +337,14 @@ acpi_pci_irq_lookup (
  * failure: return < 0
  */
 static int
-acpi_pci_irq_derive (
-	struct pci_dev		*dev,
-	int			pin,
-	int			*edge_level,
-	int			*active_high_low,
-	char			**link,
-	irq_lookup_func		func)
+acpi_pci_irq_derive(struct pci_dev *dev,
+		    int pin,
+		    int *edge_level,
+		    int *active_high_low, char **link, irq_lookup_func func)
 {
-	struct pci_dev		*bridge = dev;
-	int			irq = -1;
-	u8			bridge_pin = 0;
+	struct pci_dev *bridge = dev;
+	int irq = -1;
+	u8 bridge_pin = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_irq_derive");
 
@@ -383,28 +361,33 @@ acpi_pci_irq_derive (
 
 		if ((bridge->class >> 8) == PCI_CLASS_BRIDGE_CARDBUS) {
 			/* PC card has the same IRQ as its cardbridge */
-			pci_read_config_byte(bridge, PCI_INTERRUPT_PIN, &bridge_pin);
+			pci_read_config_byte(bridge, PCI_INTERRUPT_PIN,
+					     &bridge_pin);
 			if (!bridge_pin) {
-				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-					"No interrupt pin configured for device %s\n", pci_name(bridge)));
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+						  "No interrupt pin configured for device %s\n",
+						  pci_name(bridge)));
 				return_VALUE(-1);
 			}
 			/* Pin is from 0 to 3 */
-			bridge_pin --;
+			bridge_pin--;
 			pin = bridge_pin;
 		}
 
 		irq = acpi_pci_irq_lookup(bridge->bus, PCI_SLOT(bridge->devfn),
-			pin, edge_level, active_high_low, link, func);
+					  pin, edge_level, active_high_low,
+					  link, func);
 	}
 
 	if (irq < 0) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to derive IRQ for device %s\n", pci_name(dev)));
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+				  "Unable to derive IRQ for device %s\n",
+				  pci_name(dev)));
 		return_VALUE(-1);
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Derive IRQ %d for device %s from %s\n",
-		irq, pci_name(dev), pci_name(bridge)));
+			  irq, pci_name(dev), pci_name(bridge)));
 
 	return_VALUE(irq);
 }
@@ -415,31 +398,32 @@ acpi_pci_irq_derive (
  * failure: return < 0
  */
 
-int
-acpi_pci_irq_enable (
-	struct pci_dev		*dev)
+int acpi_pci_irq_enable(struct pci_dev *dev)
 {
-	int			irq = 0;
-	u8			pin = 0;
-	int			edge_level = ACPI_LEVEL_SENSITIVE;
-	int			active_high_low = ACPI_ACTIVE_LOW;
-	char			*link = NULL;
-	int			rc;
+	int irq = 0;
+	u8 pin = 0;
+	int edge_level = ACPI_LEVEL_SENSITIVE;
+	int active_high_low = ACPI_ACTIVE_LOW;
+	char *link = NULL;
+	int rc;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_irq_enable");
 
 	if (!dev)
 		return_VALUE(-EINVAL);
-	
+
 	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
 	if (!pin) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No interrupt pin configured for device %s\n", pci_name(dev)));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "No interrupt pin configured for device %s\n",
+				  pci_name(dev)));
 		return_VALUE(0);
 	}
 	pin--;
 
 	if (!dev->bus) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid (NULL) 'bus' field\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Invalid (NULL) 'bus' field\n"));
 		return_VALUE(-ENODEV);
 	}
 
@@ -447,35 +431,37 @@ acpi_pci_irq_enable (
 	 * First we check the PCI IRQ routing table (PRT) for an IRQ.  PRT
 	 * values override any BIOS-assigned IRQs set during boot.
 	 */
- 	irq = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin,
-		&edge_level, &active_high_low, &link, acpi_pci_allocate_irq);
+	irq = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin,
+				  &edge_level, &active_high_low, &link,
+				  acpi_pci_allocate_irq);
 
 	/*
 	 * If no PRT entry was found, we'll try to derive an IRQ from the
 	 * device's parent bridge.
 	 */
 	if (irq < 0)
- 		irq = acpi_pci_irq_derive(dev, pin, &edge_level,
-			&active_high_low, &link, acpi_pci_allocate_irq);
- 
+		irq = acpi_pci_irq_derive(dev, pin, &edge_level,
+					  &active_high_low, &link,
+					  acpi_pci_allocate_irq);
+
 	/*
 	 * No IRQ known to the ACPI subsystem - maybe the BIOS / 
 	 * driver reported one, then use it. Exit in any case.
 	 */
 	if (irq < 0) {
 		printk(KERN_WARNING PREFIX "PCI Interrupt %s[%c]: no GSI",
-			pci_name(dev), ('A' + pin));
+		       pci_name(dev), ('A' + pin));
 		/* Interrupt Line values above 0xF are forbidden */
 		if (dev->irq > 0 && (dev->irq <= 0xF)) {
 			printk(" - using IRQ %d\n", dev->irq);
-			acpi_register_gsi(dev->irq, ACPI_LEVEL_SENSITIVE, ACPI_ACTIVE_LOW);
+			acpi_register_gsi(dev->irq, ACPI_LEVEL_SENSITIVE,
+					  ACPI_ACTIVE_LOW);
 			return_VALUE(0);
-		}
-		else {
+		} else {
 			printk("\n");
 			return_VALUE(0);
 		}
- 	}
+	}
 
 	rc = acpi_register_gsi(irq, edge_level, active_high_low);
 	if (rc < 0) {
@@ -486,32 +472,31 @@ acpi_pci_irq_enable (
 	dev->irq = rc;
 
 	printk(KERN_INFO PREFIX "PCI Interrupt %s[%c] -> ",
-		pci_name(dev), 'A' + pin);
+	       pci_name(dev), 'A' + pin);
 
 	if (link)
 		printk("Link [%s] -> ", link);
 
 	printk("GSI %u (%s, %s) -> IRQ %d\n", irq,
-		(edge_level == ACPI_LEVEL_SENSITIVE) ? "level" : "edge",
-		(active_high_low == ACPI_ACTIVE_LOW) ? "low" : "high",
-		dev->irq);
+	       (edge_level == ACPI_LEVEL_SENSITIVE) ? "level" : "edge",
+	       (active_high_low == ACPI_ACTIVE_LOW) ? "low" : "high", dev->irq);
 
 	return_VALUE(0);
 }
-EXPORT_SYMBOL(acpi_pci_irq_enable);
 
+EXPORT_SYMBOL(acpi_pci_irq_enable);
 
 /* FIXME: implement x86/x86_64 version */
-void __attribute__((weak)) acpi_unregister_gsi(u32 i) {}
+void __attribute__ ((weak)) acpi_unregister_gsi(u32 i)
+{
+}
 
-void
-acpi_pci_irq_disable (
-	struct pci_dev		*dev)
+void acpi_pci_irq_disable(struct pci_dev *dev)
 {
-	int			gsi = 0;
-	u8			pin = 0;
-	int			edge_level = ACPI_LEVEL_SENSITIVE;
-	int			active_high_low = ACPI_ACTIVE_LOW;
+	int gsi = 0;
+	u8 pin = 0;
+	int edge_level = ACPI_LEVEL_SENSITIVE;
+	int active_high_low = ACPI_ACTIVE_LOW;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_irq_disable");
 
@@ -529,15 +514,17 @@ acpi_pci_irq_disable (
 	/*
 	 * First we check the PCI IRQ routing table (PRT) for an IRQ.
 	 */
- 	gsi = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin,
-			&edge_level, &active_high_low, NULL, acpi_pci_free_irq);
+	gsi = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin,
+				  &edge_level, &active_high_low, NULL,
+				  acpi_pci_free_irq);
 	/*
 	 * If no PRT entry was found, we'll try to derive an IRQ from the
 	 * device's parent bridge.
 	 */
 	if (gsi < 0)
- 		gsi = acpi_pci_irq_derive(dev, pin,
-			&edge_level, &active_high_low, NULL, acpi_pci_free_irq);
+		gsi = acpi_pci_irq_derive(dev, pin,
+					  &edge_level, &active_high_low, NULL,
+					  acpi_pci_free_irq);
 	if (gsi < 0)
 		return_VOID;
 

commit 1d492eb41371d9a5145651e8eb64bea1042a4057
Merge: 5d2a22079c82 cbfc1bae55bb
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 5 00:31:42 2005 -0400

    [ACPI] Merge acpi-2.6.12 branch into 2.6.13-rc3
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 349f0d5640c18db09a646f9da51a97f1da908660
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu Jul 28 14:42:00 2005 -0400

    [ACPI] acpi_pci_enable_irq() now checks for acpi_register_gsi() errors
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index c536ccfc5413..7ed4b2ef265f 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -424,6 +424,7 @@ acpi_pci_irq_enable (
 	int			edge_level = ACPI_LEVEL_SENSITIVE;
 	int			active_high_low = ACPI_ACTIVE_LOW;
 	char			*link = NULL;
+	int			rc;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_irq_enable");
 
@@ -475,7 +476,13 @@ acpi_pci_irq_enable (
 		}
  	}
 
-	dev->irq = acpi_register_gsi(irq, edge_level, active_high_low);
+	rc = acpi_register_gsi(irq, edge_level, active_high_low);
+	if (rc < 0) {
+		printk(KERN_WARNING PREFIX "PCI Interrupt %s[%c]: failed "
+		       "to register GSI\n", pci_name(dev), ('A' + pin));
+		return_VALUE(rc);
+	}
+	dev->irq = rc;
 
 	printk(KERN_INFO PREFIX "PCI Interrupt %s[%c] -> ",
 		pci_name(dev), 'A' + pin);

commit d6ac1a7910d22626bc77e73db091e00b810715f4
Merge: 577a4f8102d5 87bec66b9691
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jul 29 23:31:17 2005 -0400

    /home/lenb/src/to-linus branch 'acpi-2.6.12'

commit 87bec66b9691522414862dd8d41e430b063735ef
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Wed Jul 27 23:02:00 2005 -0400

    [ACPI] suspend/resume ACPI PCI Interrupt Links
    
    Add reference count and disable ACPI PCI Interrupt Link
    when no device still uses it.
    
    Warn when drivers have not released Link at suspend time.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=3469
    
    Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 8093f2e00321..c536ccfc5413 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -269,7 +269,51 @@ acpi_pci_irq_del_prt (int segment, int bus)
 /* --------------------------------------------------------------------------
                           PCI Interrupt Routing Support
    -------------------------------------------------------------------------- */
+typedef int (*irq_lookup_func)(struct acpi_prt_entry *, int *, int *, char **);
 
+static int
+acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
+	int	*edge_level,
+	int	*active_high_low,
+	char	**link)
+{
+	int	irq;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_allocate_irq");
+
+	if (entry->link.handle) {
+		irq = acpi_pci_link_allocate_irq(entry->link.handle,
+			entry->link.index, edge_level, active_high_low, link);
+		if (irq < 0) {
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid IRQ link routing entry\n"));
+			return_VALUE(-1);
+		}
+	} else {
+		irq = entry->link.index;
+		*edge_level = ACPI_LEVEL_SENSITIVE;
+		*active_high_low = ACPI_ACTIVE_LOW;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found IRQ %d\n", irq));
+	return_VALUE(irq);
+}
+
+static int
+acpi_pci_free_irq(struct acpi_prt_entry *entry,
+	int	*edge_level,
+	int	*active_high_low,
+	char	**link)
+{
+	int	irq;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_free_irq");
+	if (entry->link.handle) {
+		irq = acpi_pci_link_free_irq(entry->link.handle);
+	} else {
+		irq = entry->link.index;
+	}
+	return_VALUE(irq);
+}
 /*
  * acpi_pci_irq_lookup
  * success: return IRQ >= 0
@@ -282,12 +326,13 @@ acpi_pci_irq_lookup (
 	int			pin,
 	int			*edge_level,
 	int			*active_high_low,
-	char			**link)
+	char			**link,
+	irq_lookup_func		func)
 {
 	struct acpi_prt_entry	*entry = NULL;
 	int segment = pci_domain_nr(bus);
 	int bus_nr = bus->number;
-	int irq;
+	int ret;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_irq_lookup");
 
@@ -301,22 +346,8 @@ acpi_pci_irq_lookup (
 		return_VALUE(-1);
 	}
 	
-	if (entry->link.handle) {
-		irq = acpi_pci_link_get_irq(entry->link.handle,
-			entry->link.index, edge_level, active_high_low, link);
-		if (irq < 0) {
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid IRQ link routing entry\n"));
-			return_VALUE(-1);
-		}
-	} else {
-		irq = entry->link.index;
-		*edge_level = ACPI_LEVEL_SENSITIVE;
-		*active_high_low = ACPI_ACTIVE_LOW;
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found IRQ %d\n", irq));
-
-	return_VALUE(irq);
+	ret = func(entry, edge_level, active_high_low, link);
+	return_VALUE(ret);
 }
 
 /*
@@ -330,7 +361,8 @@ acpi_pci_irq_derive (
 	int			pin,
 	int			*edge_level,
 	int			*active_high_low,
-	char			**link)
+	char			**link,
+	irq_lookup_func		func)
 {
 	struct pci_dev		*bridge = dev;
 	int			irq = -1;
@@ -363,7 +395,7 @@ acpi_pci_irq_derive (
 		}
 
 		irq = acpi_pci_irq_lookup(bridge->bus, PCI_SLOT(bridge->devfn),
-			pin, edge_level, active_high_low, link);
+			pin, edge_level, active_high_low, link, func);
 	}
 
 	if (irq < 0) {
@@ -415,7 +447,7 @@ acpi_pci_irq_enable (
 	 * values override any BIOS-assigned IRQs set during boot.
 	 */
  	irq = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin,
-		&edge_level, &active_high_low, &link);
+		&edge_level, &active_high_low, &link, acpi_pci_allocate_irq);
 
 	/*
 	 * If no PRT entry was found, we'll try to derive an IRQ from the
@@ -423,7 +455,7 @@ acpi_pci_irq_enable (
 	 */
 	if (irq < 0)
  		irq = acpi_pci_irq_derive(dev, pin, &edge_level,
-			&active_high_low, &link);
+			&active_high_low, &link, acpi_pci_allocate_irq);
  
 	/*
 	 * No IRQ known to the ACPI subsystem - maybe the BIOS / 
@@ -461,7 +493,9 @@ acpi_pci_irq_enable (
 EXPORT_SYMBOL(acpi_pci_irq_enable);
 
 
-#ifdef CONFIG_ACPI_DEALLOCATE_IRQ
+/* FIXME: implement x86/x86_64 version */
+void __attribute__((weak)) acpi_unregister_gsi(u32 i) {}
+
 void
 acpi_pci_irq_disable (
 	struct pci_dev		*dev)
@@ -488,14 +522,14 @@ acpi_pci_irq_disable (
 	 * First we check the PCI IRQ routing table (PRT) for an IRQ.
 	 */
  	gsi = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin,
-				  &edge_level, &active_high_low, NULL);
+			&edge_level, &active_high_low, NULL, acpi_pci_free_irq);
 	/*
 	 * If no PRT entry was found, we'll try to derive an IRQ from the
 	 * device's parent bridge.
 	 */
 	if (gsi < 0)
  		gsi = acpi_pci_irq_derive(dev, pin,
-					  &edge_level, &active_high_low, NULL);
+			&edge_level, &active_high_low, NULL, acpi_pci_free_irq);
 	if (gsi < 0)
 		return_VOID;
 
@@ -511,4 +545,3 @@ acpi_pci_irq_disable (
 
 	return_VOID;
 }
-#endif /* CONFIG_ACPI_DEALLOCATE_IRQ */

commit 44f8e1a20cf3afe10a3744bd9317808a39a242bb
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Sat Jul 2 10:35:33 2005 -0700

    If ACPI doesn't find an irq listed, don't accept 0 as a valid PCI irq.
    
    That zero just means that nothing else found any irq information either.

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 8dbf802ee7f8..d1f42b972821 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -433,7 +433,7 @@ acpi_pci_irq_enable (
 		printk(KERN_WARNING PREFIX "PCI Interrupt %s[%c]: no GSI",
 			pci_name(dev), ('A' + pin));
 		/* Interrupt Line values above 0xF are forbidden */
-		if (dev->irq >= 0 && (dev->irq <= 0xF)) {
+		if (dev->irq > 0 && (dev->irq <= 0xF)) {
 			printk(" - using IRQ %d\n", dev->irq);
 			acpi_register_gsi(dev->irq, ACPI_LEVEL_SENSITIVE, ACPI_ACTIVE_LOW);
 			return_VALUE(0);

commit 7be426c6e3a8ad7dcc8791589cea8af7aaafdf6f
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Jun 25 10:01:36 2005 -0700

    ACPI: Make sure we call acpi_register_gsi() even for default PCI interrupt assignment
    
    That's the part that keeps track of the ELCR register, and we want to
    make sure that the PCI interrupts are properly marked level/low.

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 8093f2e00321..8dbf802ee7f8 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -435,6 +435,7 @@ acpi_pci_irq_enable (
 		/* Interrupt Line values above 0xF are forbidden */
 		if (dev->irq >= 0 && (dev->irq <= 0xF)) {
 			printk(" - using IRQ %d\n", dev->irq);
+			acpi_register_gsi(dev->irq, ACPI_LEVEL_SENSITIVE, ACPI_ACTIVE_LOW);
 			return_VALUE(0);
 		}
 		else {

commit 25be5e6ccc5c9cab77012fabbb72520f9b6e4618
Author: Len Brown <lenb@toshiba.hsd1.ma.comcast.net>
Date:   Fri May 27 04:21:50 2005 -0400

    [PATCH] VIA IRQ quirk
    
    Delete quirk_via_bridge(), restore quirk_via_irqpic() -- but now
    improved to be invoked upon device ENABLE, and now only for VIA devices
    -- not all devices behind VIA bridges.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
index 12b0eea63407..8093f2e00321 100644
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -391,7 +391,6 @@ acpi_pci_irq_enable (
 	u8			pin = 0;
 	int			edge_level = ACPI_LEVEL_SENSITIVE;
 	int			active_high_low = ACPI_ACTIVE_LOW;
-	extern int		via_interrupt_line_quirk;
 	char			*link = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_irq_enable");
@@ -444,9 +443,6 @@ acpi_pci_irq_enable (
 		}
  	}
 
-	if (via_interrupt_line_quirk)
-		pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq & 15);
-
 	dev->irq = acpi_register_gsi(irq, edge_level, active_high_low);
 
 	printk(KERN_INFO PREFIX "PCI Interrupt %s[%c] -> ",

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
new file mode 100644
index 000000000000..12b0eea63407
--- /dev/null
+++ b/drivers/acpi/pci_irq.c
@@ -0,0 +1,518 @@
+/*
+ *  pci_irq.c - ACPI PCI Interrupt Routing ($Revision: 11 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (C) 2002       Dominik Brodowski <devel@brodo.de>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/config.h>
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/pm.h>
+#include <linux/pci.h>
+#include <linux/acpi.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_PCI_COMPONENT
+ACPI_MODULE_NAME		("pci_irq")
+
+static struct acpi_prt_list	acpi_prt;
+static DEFINE_SPINLOCK(acpi_prt_lock);
+
+/* --------------------------------------------------------------------------
+                         PCI IRQ Routing Table (PRT) Support
+   -------------------------------------------------------------------------- */
+
+static struct acpi_prt_entry *
+acpi_pci_irq_find_prt_entry (
+	int			segment,
+	int			bus,
+	int			device,
+	int			pin)
+{
+	struct list_head	*node = NULL;
+	struct acpi_prt_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_find_prt_entry");
+
+	if (!acpi_prt.count)
+		return_PTR(NULL);
+
+	/*
+	 * Parse through all PRT entries looking for a match on the specified
+	 * PCI device's segment, bus, device, and pin (don't care about func).
+	 *
+	 */
+	spin_lock(&acpi_prt_lock);
+	list_for_each(node, &acpi_prt.entries) {
+		entry = list_entry(node, struct acpi_prt_entry, node);
+		if ((segment == entry->id.segment) 
+			&& (bus == entry->id.bus) 
+			&& (device == entry->id.device)
+			&& (pin == entry->pin)) {
+			spin_unlock(&acpi_prt_lock);
+			return_PTR(entry);
+		}
+	}
+
+	spin_unlock(&acpi_prt_lock);
+	return_PTR(NULL);
+}
+
+
+static int
+acpi_pci_irq_add_entry (
+	acpi_handle			handle,
+	int				segment,
+	int				bus,
+	struct acpi_pci_routing_table	*prt)
+{
+	struct acpi_prt_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_add_entry");
+
+	if (!prt)
+		return_VALUE(-EINVAL);
+
+	entry = kmalloc(sizeof(struct acpi_prt_entry), GFP_KERNEL);
+	if (!entry)
+		return_VALUE(-ENOMEM);
+	memset(entry, 0, sizeof(struct acpi_prt_entry));
+
+	entry->id.segment = segment;
+	entry->id.bus = bus;
+	entry->id.device = (prt->address >> 16) & 0xFFFF;
+	entry->id.function = prt->address & 0xFFFF;
+	entry->pin = prt->pin;
+
+	/*
+	 * Type 1: Dynamic
+	 * ---------------
+	 * The 'source' field specifies the PCI interrupt link device used to
+	 * configure the IRQ assigned to this slot|dev|pin.  The 'source_index'
+	 * indicates which resource descriptor in the resource template (of
+	 * the link device) this interrupt is allocated from.
+	 * 
+	 * NOTE: Don't query the Link Device for IRQ information at this time
+	 *       because Link Device enumeration may not have occurred yet
+	 *       (e.g. exists somewhere 'below' this _PRT entry in the ACPI
+	 *       namespace).
+	 */
+	if (prt->source[0]) {
+		acpi_get_handle(handle, prt->source, &entry->link.handle);
+		entry->link.index = prt->source_index;
+	}
+	/*
+	 * Type 2: Static
+	 * --------------
+	 * The 'source' field is NULL, and the 'source_index' field specifies
+	 * the IRQ value, which is hardwired to specific interrupt inputs on
+	 * the interrupt controller.
+	 */
+	else
+		entry->link.index = prt->source_index;
+
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INFO,
+		"      %02X:%02X:%02X[%c] -> %s[%d]\n", 
+		entry->id.segment, entry->id.bus, entry->id.device, 
+		('A' + entry->pin), prt->source, entry->link.index));
+
+	spin_lock(&acpi_prt_lock);
+	list_add_tail(&entry->node, &acpi_prt.entries);
+	acpi_prt.count++;
+	spin_unlock(&acpi_prt_lock);
+
+	return_VALUE(0);
+}
+
+
+static void
+acpi_pci_irq_del_entry (
+	int				segment,
+	int				bus,
+	struct acpi_prt_entry		*entry)
+{
+	if (segment == entry->id.segment && bus == entry->id.bus){
+		acpi_prt.count--;
+		list_del(&entry->node);
+		kfree(entry);
+	}
+}
+
+
+int
+acpi_pci_irq_add_prt (
+	acpi_handle		handle,
+	int			segment,
+	int			bus)
+{
+	acpi_status			status = AE_OK;
+	char				*pathname = NULL;
+	struct acpi_buffer		buffer = {0, NULL};
+	struct acpi_pci_routing_table	*prt = NULL;
+	struct acpi_pci_routing_table	*entry = NULL;
+	static int			first_time = 1;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_add_prt");
+
+	pathname = (char *) kmalloc(ACPI_PATHNAME_MAX, GFP_KERNEL);
+	if(!pathname)
+		return_VALUE(-ENOMEM);
+	memset(pathname, 0, ACPI_PATHNAME_MAX);
+
+	if (first_time) {
+		acpi_prt.count = 0;
+		INIT_LIST_HEAD(&acpi_prt.entries);
+		first_time = 0;
+	}
+
+	/* 
+	 * NOTE: We're given a 'handle' to the _PRT object's parent device
+	 *       (either a PCI root bridge or PCI-PCI bridge).
+	 */
+
+	buffer.length = ACPI_PATHNAME_MAX;
+	buffer.pointer = pathname;
+	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+
+	printk(KERN_DEBUG "ACPI: PCI Interrupt Routing Table [%s._PRT]\n",
+		pathname);
+
+	/* 
+	 * Evaluate this _PRT and add its entries to our global list (acpi_prt).
+	 */
+
+	buffer.length = 0;
+	buffer.pointer = NULL;
+	kfree(pathname);
+	status = acpi_get_irq_routing_table(handle, &buffer);
+	if (status != AE_BUFFER_OVERFLOW) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRT [%s]\n",
+			acpi_format_exception(status)));
+		return_VALUE(-ENODEV);
+	}
+
+	prt = kmalloc(buffer.length, GFP_KERNEL);
+	if (!prt){
+		return_VALUE(-ENOMEM);
+	}
+	memset(prt, 0, buffer.length);
+	buffer.pointer = prt;
+
+	status = acpi_get_irq_routing_table(handle, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRT [%s]\n",
+			acpi_format_exception(status)));
+		kfree(buffer.pointer);
+		return_VALUE(-ENODEV);
+	}
+
+	entry = prt;
+
+	while (entry && (entry->length > 0)) {
+		acpi_pci_irq_add_entry(handle, segment, bus, entry);
+		entry = (struct acpi_pci_routing_table *)
+			((unsigned long) entry + entry->length);
+	}
+
+	kfree(prt);
+
+	return_VALUE(0);
+}
+
+void
+acpi_pci_irq_del_prt (int segment, int bus)
+{
+	struct list_head        *node = NULL, *n = NULL;
+	struct acpi_prt_entry   *entry = NULL;
+
+	if (!acpi_prt.count)    {
+		return;
+	}
+
+	printk(KERN_DEBUG "ACPI: Delete PCI Interrupt Routing Table for %x:%x\n",
+		segment, bus);
+	spin_lock(&acpi_prt_lock);
+	list_for_each_safe(node, n, &acpi_prt.entries) {
+		entry = list_entry(node, struct acpi_prt_entry, node);
+
+		acpi_pci_irq_del_entry(segment, bus, entry);
+	}
+	spin_unlock(&acpi_prt_lock);
+}
+/* --------------------------------------------------------------------------
+                          PCI Interrupt Routing Support
+   -------------------------------------------------------------------------- */
+
+/*
+ * acpi_pci_irq_lookup
+ * success: return IRQ >= 0
+ * failure: return -1
+ */
+static int
+acpi_pci_irq_lookup (
+	struct pci_bus		*bus,
+	int			device,
+	int			pin,
+	int			*edge_level,
+	int			*active_high_low,
+	char			**link)
+{
+	struct acpi_prt_entry	*entry = NULL;
+	int segment = pci_domain_nr(bus);
+	int bus_nr = bus->number;
+	int irq;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_lookup");
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Searching for PRT entry for %02x:%02x:%02x[%c]\n", 
+		segment, bus_nr, device, ('A' + pin)));
+
+	entry = acpi_pci_irq_find_prt_entry(segment, bus_nr, device, pin); 
+	if (!entry) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "PRT entry not found\n"));
+		return_VALUE(-1);
+	}
+	
+	if (entry->link.handle) {
+		irq = acpi_pci_link_get_irq(entry->link.handle,
+			entry->link.index, edge_level, active_high_low, link);
+		if (irq < 0) {
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid IRQ link routing entry\n"));
+			return_VALUE(-1);
+		}
+	} else {
+		irq = entry->link.index;
+		*edge_level = ACPI_LEVEL_SENSITIVE;
+		*active_high_low = ACPI_ACTIVE_LOW;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found IRQ %d\n", irq));
+
+	return_VALUE(irq);
+}
+
+/*
+ * acpi_pci_irq_derive
+ * success: return IRQ >= 0
+ * failure: return < 0
+ */
+static int
+acpi_pci_irq_derive (
+	struct pci_dev		*dev,
+	int			pin,
+	int			*edge_level,
+	int			*active_high_low,
+	char			**link)
+{
+	struct pci_dev		*bridge = dev;
+	int			irq = -1;
+	u8			bridge_pin = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_derive");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+
+	/* 
+	 * Attempt to derive an IRQ for this device from a parent bridge's
+	 * PCI interrupt routing entry (eg. yenta bridge and add-in card bridge).
+	 */
+	while (irq < 0 && bridge->bus->self) {
+		pin = (pin + PCI_SLOT(bridge->devfn)) % 4;
+		bridge = bridge->bus->self;
+
+		if ((bridge->class >> 8) == PCI_CLASS_BRIDGE_CARDBUS) {
+			/* PC card has the same IRQ as its cardbridge */
+			pci_read_config_byte(bridge, PCI_INTERRUPT_PIN, &bridge_pin);
+			if (!bridge_pin) {
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+					"No interrupt pin configured for device %s\n", pci_name(bridge)));
+				return_VALUE(-1);
+			}
+			/* Pin is from 0 to 3 */
+			bridge_pin --;
+			pin = bridge_pin;
+		}
+
+		irq = acpi_pci_irq_lookup(bridge->bus, PCI_SLOT(bridge->devfn),
+			pin, edge_level, active_high_low, link);
+	}
+
+	if (irq < 0) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to derive IRQ for device %s\n", pci_name(dev)));
+		return_VALUE(-1);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Derive IRQ %d for device %s from %s\n",
+		irq, pci_name(dev), pci_name(bridge)));
+
+	return_VALUE(irq);
+}
+
+/*
+ * acpi_pci_irq_enable
+ * success: return 0
+ * failure: return < 0
+ */
+
+int
+acpi_pci_irq_enable (
+	struct pci_dev		*dev)
+{
+	int			irq = 0;
+	u8			pin = 0;
+	int			edge_level = ACPI_LEVEL_SENSITIVE;
+	int			active_high_low = ACPI_ACTIVE_LOW;
+	extern int		via_interrupt_line_quirk;
+	char			*link = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_enable");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+	
+	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
+	if (!pin) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No interrupt pin configured for device %s\n", pci_name(dev)));
+		return_VALUE(0);
+	}
+	pin--;
+
+	if (!dev->bus) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid (NULL) 'bus' field\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	/* 
+	 * First we check the PCI IRQ routing table (PRT) for an IRQ.  PRT
+	 * values override any BIOS-assigned IRQs set during boot.
+	 */
+ 	irq = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin,
+		&edge_level, &active_high_low, &link);
+
+	/*
+	 * If no PRT entry was found, we'll try to derive an IRQ from the
+	 * device's parent bridge.
+	 */
+	if (irq < 0)
+ 		irq = acpi_pci_irq_derive(dev, pin, &edge_level,
+			&active_high_low, &link);
+ 
+	/*
+	 * No IRQ known to the ACPI subsystem - maybe the BIOS / 
+	 * driver reported one, then use it. Exit in any case.
+	 */
+	if (irq < 0) {
+		printk(KERN_WARNING PREFIX "PCI Interrupt %s[%c]: no GSI",
+			pci_name(dev), ('A' + pin));
+		/* Interrupt Line values above 0xF are forbidden */
+		if (dev->irq >= 0 && (dev->irq <= 0xF)) {
+			printk(" - using IRQ %d\n", dev->irq);
+			return_VALUE(0);
+		}
+		else {
+			printk("\n");
+			return_VALUE(0);
+		}
+ 	}
+
+	if (via_interrupt_line_quirk)
+		pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq & 15);
+
+	dev->irq = acpi_register_gsi(irq, edge_level, active_high_low);
+
+	printk(KERN_INFO PREFIX "PCI Interrupt %s[%c] -> ",
+		pci_name(dev), 'A' + pin);
+
+	if (link)
+		printk("Link [%s] -> ", link);
+
+	printk("GSI %u (%s, %s) -> IRQ %d\n", irq,
+		(edge_level == ACPI_LEVEL_SENSITIVE) ? "level" : "edge",
+		(active_high_low == ACPI_ACTIVE_LOW) ? "low" : "high",
+		dev->irq);
+
+	return_VALUE(0);
+}
+EXPORT_SYMBOL(acpi_pci_irq_enable);
+
+
+#ifdef CONFIG_ACPI_DEALLOCATE_IRQ
+void
+acpi_pci_irq_disable (
+	struct pci_dev		*dev)
+{
+	int			gsi = 0;
+	u8			pin = 0;
+	int			edge_level = ACPI_LEVEL_SENSITIVE;
+	int			active_high_low = ACPI_ACTIVE_LOW;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_disable");
+
+	if (!dev)
+		return_VOID;
+
+	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
+	if (!pin)
+		return_VOID;
+	pin--;
+
+	if (!dev->bus)
+		return_VOID;
+
+	/*
+	 * First we check the PCI IRQ routing table (PRT) for an IRQ.
+	 */
+ 	gsi = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin,
+				  &edge_level, &active_high_low, NULL);
+	/*
+	 * If no PRT entry was found, we'll try to derive an IRQ from the
+	 * device's parent bridge.
+	 */
+	if (gsi < 0)
+ 		gsi = acpi_pci_irq_derive(dev, pin,
+					  &edge_level, &active_high_low, NULL);
+	if (gsi < 0)
+		return_VOID;
+
+	/*
+	 * TBD: It might be worth clearing dev->irq by magic constant
+	 * (e.g. PCI_UNDEFINED_IRQ).
+	 */
+
+	printk(KERN_INFO PREFIX "PCI interrupt for device %s disabled\n",
+	       pci_name(dev));
+
+	acpi_unregister_gsi(gsi);
+
+	return_VOID;
+}
+#endif /* CONFIG_ACPI_DEALLOCATE_IRQ */
