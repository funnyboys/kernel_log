commit 2288eba5ca746e4095ecb483463d8bc4e4d7b2fd
Author: Jules Irenge <jbi.octave@gmail.com>
Date:   Sun Feb 23 23:17:03 2020 +0000

    ACPI: OSL: Add missing __acquires/__releases annotations
    
    Sparse reports a warnings at acpi_os_acquire_lock() and
    acpi_os_release_lock():
    
    warning: context imbalance in acpi_os_acquire_lock() - unexpected unlock
    
    warning: context imbalance in acpi_os_release_lock() - unexpected unlock
    
    which result from missing __acquires/__releases annotations.
    
    Add the annotations as appropriate to get rid of the warnings.
    
    Signed-off-by: Jules Irenge <jbi.octave@gmail.com>
    [ rjw: Two patches merged into one, subject & changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 41168c027a5a..762c5d50b8fe 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1598,6 +1598,7 @@ void acpi_os_delete_lock(acpi_spinlock handle)
  */
 
 acpi_cpu_flags acpi_os_acquire_lock(acpi_spinlock lockp)
+	__acquires(lockp)
 {
 	acpi_cpu_flags flags;
 	spin_lock_irqsave(lockp, flags);
@@ -1609,6 +1610,7 @@ acpi_cpu_flags acpi_os_acquire_lock(acpi_spinlock lockp)
  */
 
 void acpi_os_release_lock(acpi_spinlock lockp, acpi_cpu_flags flags)
+	__releases(lockp)
 {
 	spin_unlock_irqrestore(lockp, flags);
 }

commit 833a426cc471b6088011b3d67f1dc4e147614647
Author: Francesco Ruggeri <fruggeri@arista.com>
Date:   Tue Nov 19 21:47:27 2019 -0800

    ACPI: OSL: only free map once in osl.c
    
    acpi_os_map_cleanup checks map->refcount outside of acpi_ioremap_lock
    before freeing the map. This creates a race condition the can result
    in the map being freed more than once.
    A panic can be caused by running
    
    for ((i=0; i<10; i++))
    do
            for ((j=0; j<100000; j++))
            do
                    cat /sys/firmware/acpi/tables/data/BERT >/dev/null
            done &
    done
    
    This patch makes sure that only the process that drops the reference
    to 0 does the freeing.
    
    Fixes: b7c1fadd6c2e ("ACPI: Do not use krefs under a mutex in osl.c")
    Signed-off-by: Francesco Ruggeri <fruggeri@arista.com>
    Reviewed-by: Dmitry Safonov <0x7f454c46@gmail.com>
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index a2e844a8e9ed..41168c027a5a 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -374,19 +374,21 @@ void *__ref acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 }
 EXPORT_SYMBOL_GPL(acpi_os_map_memory);
 
-static void acpi_os_drop_map_ref(struct acpi_ioremap *map)
+/* Must be called with mutex_lock(&acpi_ioremap_lock) */
+static unsigned long acpi_os_drop_map_ref(struct acpi_ioremap *map)
 {
-	if (!--map->refcount)
+	unsigned long refcount = --map->refcount;
+
+	if (!refcount)
 		list_del_rcu(&map->list);
+	return refcount;
 }
 
 static void acpi_os_map_cleanup(struct acpi_ioremap *map)
 {
-	if (!map->refcount) {
-		synchronize_rcu_expedited();
-		acpi_unmap(map->phys, map->virt);
-		kfree(map);
-	}
+	synchronize_rcu_expedited();
+	acpi_unmap(map->phys, map->virt);
+	kfree(map);
 }
 
 /**
@@ -406,6 +408,7 @@ static void acpi_os_map_cleanup(struct acpi_ioremap *map)
 void __ref acpi_os_unmap_iomem(void __iomem *virt, acpi_size size)
 {
 	struct acpi_ioremap *map;
+	unsigned long refcount;
 
 	if (!acpi_permanent_mmap) {
 		__acpi_unmap_table(virt, size);
@@ -419,10 +422,11 @@ void __ref acpi_os_unmap_iomem(void __iomem *virt, acpi_size size)
 		WARN(true, PREFIX "%s: bad address %p\n", __func__, virt);
 		return;
 	}
-	acpi_os_drop_map_ref(map);
+	refcount = acpi_os_drop_map_ref(map);
 	mutex_unlock(&acpi_ioremap_lock);
 
-	acpi_os_map_cleanup(map);
+	if (!refcount)
+		acpi_os_map_cleanup(map);
 }
 EXPORT_SYMBOL_GPL(acpi_os_unmap_iomem);
 
@@ -457,6 +461,7 @@ void acpi_os_unmap_generic_address(struct acpi_generic_address *gas)
 {
 	u64 addr;
 	struct acpi_ioremap *map;
+	unsigned long refcount;
 
 	if (gas->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)
 		return;
@@ -472,10 +477,11 @@ void acpi_os_unmap_generic_address(struct acpi_generic_address *gas)
 		mutex_unlock(&acpi_ioremap_lock);
 		return;
 	}
-	acpi_os_drop_map_ref(map);
+	refcount = acpi_os_drop_map_ref(map);
 	mutex_unlock(&acpi_ioremap_lock);
 
-	acpi_os_map_cleanup(map);
+	if (!refcount)
+		acpi_os_map_cleanup(map);
 }
 EXPORT_SYMBOL(acpi_os_unmap_generic_address);
 

commit aefcf2f4b58155d27340ba5f9ddbe9513da8286d
Merge: f1f2f614d535 45893a0abee6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 28 08:14:15 2019 -0700

    Merge branch 'next-lockdown' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull kernel lockdown mode from James Morris:
     "This is the latest iteration of the kernel lockdown patchset, from
      Matthew Garrett, David Howells and others.
    
      From the original description:
    
        This patchset introduces an optional kernel lockdown feature,
        intended to strengthen the boundary between UID 0 and the kernel.
        When enabled, various pieces of kernel functionality are restricted.
        Applications that rely on low-level access to either hardware or the
        kernel may cease working as a result - therefore this should not be
        enabled without appropriate evaluation beforehand.
    
        The majority of mainstream distributions have been carrying variants
        of this patchset for many years now, so there's value in providing a
        doesn't meet every distribution requirement, but gets us much closer
        to not requiring external patches.
    
      There are two major changes since this was last proposed for mainline:
    
       - Separating lockdown from EFI secure boot. Background discussion is
         covered here: https://lwn.net/Articles/751061/
    
       -  Implementation as an LSM, with a default stackable lockdown LSM
          module. This allows the lockdown feature to be policy-driven,
          rather than encoding an implicit policy within the mechanism.
    
      The new locked_down LSM hook is provided to allow LSMs to make a
      policy decision around whether kernel functionality that would allow
      tampering with or examining the runtime state of the kernel should be
      permitted.
    
      The included lockdown LSM provides an implementation with a simple
      policy intended for general purpose use. This policy provides a coarse
      level of granularity, controllable via the kernel command line:
    
        lockdown={integrity|confidentiality}
    
      Enable the kernel lockdown feature. If set to integrity, kernel features
      that allow userland to modify the running kernel are disabled. If set to
      confidentiality, kernel features that allow userland to extract
      confidential information from the kernel are also disabled.
    
      This may also be controlled via /sys/kernel/security/lockdown and
      overriden by kernel configuration.
    
      New or existing LSMs may implement finer-grained controls of the
      lockdown features. Refer to the lockdown_reason documentation in
      include/linux/security.h for details.
    
      The lockdown feature has had signficant design feedback and review
      across many subsystems. This code has been in linux-next for some
      weeks, with a few fixes applied along the way.
    
      Stephen Rothwell noted that commit 9d1f8be5cf42 ("bpf: Restrict bpf
      when kernel lockdown is in confidentiality mode") is missing a
      Signed-off-by from its author. Matthew responded that he is providing
      this under category (c) of the DCO"
    
    * 'next-lockdown' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (31 commits)
      kexec: Fix file verification on S390
      security: constify some arrays in lockdown LSM
      lockdown: Print current->comm in restriction messages
      efi: Restrict efivar_ssdt_load when the kernel is locked down
      tracefs: Restrict tracefs when the kernel is locked down
      debugfs: Restrict debugfs when the kernel is locked down
      kexec: Allow kexec_file() with appropriate IMA policy when locked down
      lockdown: Lock down perf when in confidentiality mode
      bpf: Restrict bpf when kernel lockdown is in confidentiality mode
      lockdown: Lock down tracing and perf kprobes when in confidentiality mode
      lockdown: Lock down /proc/kcore
      x86/mmiotrace: Lock down the testmmiotrace module
      lockdown: Lock down module params that specify hardware parameters (eg. ioport)
      lockdown: Lock down TIOCSSERIAL
      lockdown: Prohibit PCMCIA CIS storage when the kernel is locked down
      acpi: Disable ACPI table override if the kernel is locked down
      acpi: Ignore acpi_rsdp kernel param when the kernel has been locked down
      ACPI: Limit access to custom_method when the kernel is locked down
      x86/msr: Restrict MSR access when the kernel is locked down
      x86: Lock down IO port access when the kernel is locked down
      ...

commit 41fa1ee9c6d687afb05760dd349f361855f1d7f5
Author: Josh Boyer <jwboyer@redhat.com>
Date:   Mon Aug 19 17:17:51 2019 -0700

    acpi: Ignore acpi_rsdp kernel param when the kernel has been locked down
    
    This option allows userspace to pass the RSDP address to the kernel, which
    makes it possible for a user to modify the workings of hardware. Reject
    the option when the kernel is locked down. This requires some reworking
    of the existing RSDP command line logic, since the early boot code also
    makes use of a command-line passed RSDP when locating the SRAT table
    before the lockdown code has been initialised. This is achieved by
    separating the command line RSDP path in the early boot code from the
    generic RSDP path, and then copying the command line RSDP into boot
    params in the kernel proper if lockdown is not enabled. If lockdown is
    enabled and an RSDP is provided on the command line, this will only be
    used when parsing SRAT (which shouldn't permit kernel code execution)
    and will be ignored in the rest of the kernel.
    
    (Modified by Matthew Garrett in order to handle the early boot RSDP
    environment)
    
    Signed-off-by: Josh Boyer <jwboyer@redhat.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    cc: Dave Young <dyoung@redhat.com>
    cc: linux-acpi@vger.kernel.org
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index cc7507091dec..b7c3aeb175dd 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -26,6 +26,7 @@
 #include <linux/list.h>
 #include <linux/jiffies.h>
 #include <linux/semaphore.h>
+#include <linux/security.h>
 
 #include <asm/io.h>
 #include <linux/uaccess.h>
@@ -180,8 +181,19 @@ acpi_physical_address __init acpi_os_get_root_pointer(void)
 	acpi_physical_address pa;
 
 #ifdef CONFIG_KEXEC
-	if (acpi_rsdp)
+	/*
+	 * We may have been provided with an RSDP on the command line,
+	 * but if a malicious user has done so they may be pointing us
+	 * at modified ACPI tables that could alter kernel behaviour -
+	 * so, we check the lockdown status before making use of
+	 * it. If we trust it then also stash it in an architecture
+	 * specific location (if appropriate) so it can be carried
+	 * over further kexec()s.
+	 */
+	if (acpi_rsdp && !security_locked_down(LOCKDOWN_ACPI_TABLES)) {
+		acpi_arch_set_root_pointer(acpi_rsdp);
 		return acpi_rsdp;
+	}
 #endif
 	pa = acpi_arch_get_root_pointer();
 	if (pa)

commit bee6f87166e9c6b8d81a7570995bd637e8da485a
Author: Joel Fernandes (Google) <joel@joelfernandes.org>
Date:   Tue Jul 16 18:12:28 2019 -0400

    acpi: Use built-in RCU list checking for acpi_ioremaps list
    
    This commit applies the consolidated list_for_each_entry_rcu() support
    for lockdep conditions.
    
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    Signed-off-by: Paul E. McKenney <paulmck@linux.ibm.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 9c0edf2fc0dd..2f9d0d20b836 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -14,6 +14,7 @@
 #include <linux/slab.h>
 #include <linux/mm.h>
 #include <linux/highmem.h>
+#include <linux/lockdep.h>
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/kmod.h>
@@ -80,6 +81,7 @@ struct acpi_ioremap {
 
 static LIST_HEAD(acpi_ioremaps);
 static DEFINE_MUTEX(acpi_ioremap_lock);
+#define acpi_ioremap_lock_held() lock_is_held(&acpi_ioremap_lock.dep_map)
 
 static void __init acpi_request_region (struct acpi_generic_address *gas,
 	unsigned int length, char *desc)
@@ -206,7 +208,7 @@ acpi_map_lookup(acpi_physical_address phys, acpi_size size)
 {
 	struct acpi_ioremap *map;
 
-	list_for_each_entry_rcu(map, &acpi_ioremaps, list)
+	list_for_each_entry_rcu(map, &acpi_ioremaps, list, acpi_ioremap_lock_held())
 		if (map->phys <= phys &&
 		    phys + size <= map->phys + map->size)
 			return map;
@@ -249,7 +251,7 @@ acpi_map_lookup_virt(void __iomem *virt, acpi_size size)
 {
 	struct acpi_ioremap *map;
 
-	list_for_each_entry_rcu(map, &acpi_ioremaps, list)
+	list_for_each_entry_rcu(map, &acpi_ioremaps, list, acpi_ioremap_lock_held())
 		if (map->virt <= virt &&
 		    virt + size <= map->virt + map->size)
 			return map;

commit 9fe51603d953419b8da74f455269eca8e6b84228
Author: Qian Cai <cai@lca.pw>
Date:   Mon Jun 3 16:28:35 2019 -0400

    ACPI: OSL: Make a W=1 kernel-doc warning go away
    
    It appears that kernel-doc does not understand the return type *__ref,
    
    drivers/acpi/osl.c:306: warning: cannot understand function prototype:
    'void __iomem *__ref acpi_os_map_iomem(acpi_physical_address phys,
    acpi_size size)
    
    Signed-off-by: Qian Cai <cai@lca.pw>
    [ rjw: Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index cc7507091dec..9c0edf2fc0dd 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -301,8 +301,8 @@ static void acpi_unmap(acpi_physical_address pg_off, void __iomem *vaddr)
  * During early init (when acpi_permanent_mmap has not been set yet) this
  * routine simply calls __acpi_map_table() to get the job done.
  */
-void __iomem *__ref
-acpi_os_map_iomem(acpi_physical_address phys, acpi_size size)
+void __iomem __ref
+*acpi_os_map_iomem(acpi_physical_address phys, acpi_size size)
 {
 	struct acpi_ioremap *map;
 	void __iomem *virt;

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index f29e427d0d1d..cc7507091dec 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  acpi_osl.c - OS-dependent functions ($Revision: 83 $)
  *
@@ -6,21 +7,6 @@
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
  *  Copyright (c) 2008 Intel Corporation
  *   Author: Matthew Wilcox <willy@linux.intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
  */
 
 #include <linux/module.h>

commit bd23fac3eaaa8bd79c02a2f139f68ac6424a9a7c
Author: Sinan Kaya <okaya@kernel.org>
Date:   Wed Dec 19 22:46:55 2018 +0000

    ACPICA: Remove PCI bits from ACPICA when CONFIG_PCI is unset
    
    Allow ACPI to be built without PCI support in place.
    
    Signed-off-by: Sinan Kaya <okaya@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index b48874b8e1ea..f29e427d0d1d 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -769,6 +769,7 @@ acpi_os_write_memory(acpi_physical_address phys_addr, u64 value, u32 width)
 	return AE_OK;
 }
 
+#ifdef CONFIG_PCI
 acpi_status
 acpi_os_read_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
 			       u64 *value, u32 width)
@@ -827,6 +828,7 @@ acpi_os_write_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
 
 	return (result ? AE_ERROR : AE_OK);
 }
+#endif
 
 static void acpi_os_execute_deferred(struct work_struct *work)
 {

commit 0a1875ad29ef6436da3c184494b509697c8e0cf7
Merge: 1f825f74c113 d030fd0ec5c7 757c968c4423
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 18 12:37:51 2018 +0200

    Merge branches 'acpi-property' and 'acpi-sbs'
    
    * acpi-property:
      ACPI / property: Switch to bitmap_zalloc()
    
    * acpi-sbs:
      ACPI / SBS: Fix rare oops when removing modules
      ACPI / SBS: Fix GPE storm on recent MacBookPro's

commit 83b2348e2755db48fa8f40fdb791f366fabc0ba0
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Wed Oct 17 13:24:56 2018 -0700

    ACPI / OSL: Use 'jiffies' as the time bassis for acpi_os_get_timer()
    
    Since acpi_os_get_timer() may be called after the timer subsystem has
    been suspended, use the jiffies counter instead of ktime_get(). This
    patch avoids that the following warning is reported during hibernation:
    
    WARNING: CPU: 0 PID: 612 at kernel/time/timekeeping.c:751 ktime_get+0x116/0x120
    RIP: 0010:ktime_get+0x116/0x120
    Call Trace:
     acpi_os_get_timer+0xe/0x30
     acpi_ds_exec_begin_control_op+0x175/0x1de
     acpi_ds_exec_begin_op+0x2c7/0x39a
     acpi_ps_create_op+0x573/0x5e4
     acpi_ps_parse_loop+0x349/0x1220
     acpi_ps_parse_aml+0x25b/0x6da
     acpi_ps_execute_method+0x327/0x41b
     acpi_ns_evaluate+0x4e9/0x6f5
     acpi_ut_evaluate_object+0xd9/0x2f2
     acpi_rs_get_method_data+0x8f/0x114
     acpi_walk_resources+0x122/0x1b6
     acpi_pci_link_get_current.isra.2+0x157/0x280
     acpi_pci_link_set+0x32f/0x4a0
     irqrouter_resume+0x58/0x80
     syscore_resume+0x84/0x380
     hibernation_snapshot+0x20c/0x4f0
     hibernate+0x22d/0x3a6
     state_store+0x99/0xa0
     kobj_attr_store+0x37/0x50
     sysfs_kf_write+0x87/0xa0
     kernfs_fop_write+0x1a5/0x240
     __vfs_write+0xd2/0x410
     vfs_write+0x101/0x250
     ksys_write+0xab/0x120
     __x64_sys_write+0x43/0x50
     do_syscall_64+0x71/0x220
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    Fixes: 164a08cee135 (ACPICA: Dispatcher: Introduce timeout mechanism for infinite loop detection)
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    References: https://lists.01.org/pipermail/lkp/2018-April/008406.html
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Cc: 4.16+ <stable@vger.kernel.org> # 4.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 8df9abfa947b..ed73f6fb0779 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -617,15 +617,18 @@ void acpi_os_stall(u32 us)
 }
 
 /*
- * Support ACPI 3.0 AML Timer operand
- * Returns 64-bit free-running, monotonically increasing timer
- * with 100ns granularity
+ * Support ACPI 3.0 AML Timer operand. Returns a 64-bit free-running,
+ * monotonically increasing timer with 100ns granularity. Do not use
+ * ktime_get() to implement this function because this function may get
+ * called after timekeeping has been suspended. Note: calling this function
+ * after timekeeping has been suspended may lead to unexpected results
+ * because when timekeeping is suspended the jiffies counter is not
+ * incremented. See also timekeeping_suspend().
  */
 u64 acpi_os_get_timer(void)
 {
-	u64 time_ns = ktime_to_ns(ktime_get());
-	do_div(time_ns, 100);
-	return time_ns;
+	return (get_jiffies_64() - INITIAL_JIFFIES) *
+		(ACPI_100NSEC_PER_SEC / HZ);
 }
 
 acpi_status acpi_os_read_port(acpi_io_address port, u32 * value, u32 width)

commit 757c968c442397f1249bb775a7c8c03842e3e0c7
Author: Ronald Tschalär <ronald@innovation.ch>
Date:   Sun Sep 30 19:53:13 2018 -0700

    ACPI / SBS: Fix rare oops when removing modules
    
    There was a small race when removing the sbshc module where
    smbus_alarm() had queued acpi_smbus_callback() for deferred execution
    but it hadn't been run yet, so that when it did run hc had been freed
    and the module unloaded, resulting in an invalid paging request.
    
    A similar race existed when removing the sbs module with regards to
    acpi_sbs_callback() (which is called from acpi_smbus_callback()).
    
    We therefore need to ensure no callbacks are pending or executing before
    the cleanups are done and the modules are removed.
    
    Signed-off-by: Ronald TschalÃ¤r <ronald@innovation.ch>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 8df9abfa947b..9d139727f164 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1129,6 +1129,7 @@ void acpi_os_wait_events_complete(void)
 	flush_workqueue(kacpid_wq);
 	flush_workqueue(kacpi_notify_wq);
 }
+EXPORT_SYMBOL(acpi_os_wait_events_complete);
 
 struct acpi_hp_work {
 	struct work_struct work;

commit d2d2e3c46be5d6dd8001d0eebdf7cafb9bc7006b
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Thu Jun 21 16:43:17 2018 +0300

    acpi: Add helper for deactivating memory region
    
    Sometimes memory resource may be overlapping with
    SystemMemory Operation Region by design, for example if the
    memory region is used as a mailbox for communication with a
    firmware in the system. One occasion of such mailboxes is
    USB Type-C Connector System Software Interface (UCSI).
    
    With regions like that, it is important that the driver is
    able to map the memory with the requirements it has. For
    example, the driver should be allowed to map the memory as
    non-cached memory. However, if the operation region has been
    accessed before the driver has mapped the memory, the memory
    has been marked as write-back by the time the driver is
    loaded. That means the driver will fail to map the memory
    if it expects non-cached memory.
    
    To work around the problem, introducing helper that the
    drivers can use to temporarily deactivate (unmap)
    SystemMemory Operation Regions that overlap with their
    IO memory.
    
    Fixes: 8243edf44152 ("usb: typec: ucsi: Add ACPI driver")
    Cc: stable@vger.kernel.org
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 7ca41bf023c9..8df9abfa947b 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -45,6 +45,8 @@
 #include <linux/uaccess.h>
 #include <linux/io-64-nonatomic-lo-hi.h>
 
+#include "acpica/accommon.h"
+#include "acpica/acnamesp.h"
 #include "internal.h"
 
 #define _COMPONENT		ACPI_OS_SERVICES
@@ -1490,6 +1492,76 @@ int acpi_check_region(resource_size_t start, resource_size_t n,
 }
 EXPORT_SYMBOL(acpi_check_region);
 
+static acpi_status acpi_deactivate_mem_region(acpi_handle handle, u32 level,
+					      void *_res, void **return_value)
+{
+	struct acpi_mem_space_context **mem_ctx;
+	union acpi_operand_object *handler_obj;
+	union acpi_operand_object *region_obj2;
+	union acpi_operand_object *region_obj;
+	struct resource *res = _res;
+	acpi_status status;
+
+	region_obj = acpi_ns_get_attached_object(handle);
+	if (!region_obj)
+		return AE_OK;
+
+	handler_obj = region_obj->region.handler;
+	if (!handler_obj)
+		return AE_OK;
+
+	if (region_obj->region.space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)
+		return AE_OK;
+
+	if (!(region_obj->region.flags & AOPOBJ_SETUP_COMPLETE))
+		return AE_OK;
+
+	region_obj2 = acpi_ns_get_secondary_object(region_obj);
+	if (!region_obj2)
+		return AE_OK;
+
+	mem_ctx = (void *)&region_obj2->extra.region_context;
+
+	if (!(mem_ctx[0]->address >= res->start &&
+	      mem_ctx[0]->address < res->end))
+		return AE_OK;
+
+	status = handler_obj->address_space.setup(region_obj,
+						  ACPI_REGION_DEACTIVATE,
+						  NULL, (void **)mem_ctx);
+	if (ACPI_SUCCESS(status))
+		region_obj->region.flags &= ~(AOPOBJ_SETUP_COMPLETE);
+
+	return status;
+}
+
+/**
+ * acpi_release_memory - Release any mappings done to a memory region
+ * @handle: Handle to namespace node
+ * @res: Memory resource
+ * @level: A level that terminates the search
+ *
+ * Walks through @handle and unmaps all SystemMemory Operation Regions that
+ * overlap with @res and that have already been activated (mapped).
+ *
+ * This is a helper that allows drivers to place special requirements on memory
+ * region that may overlap with operation regions, primarily allowing them to
+ * safely map the region as non-cached memory.
+ *
+ * The unmapped Operation Regions will be automatically remapped next time they
+ * are called, so the drivers do not need to do anything else.
+ */
+acpi_status acpi_release_memory(acpi_handle handle, struct resource *res,
+				u32 level)
+{
+	if (!(res->flags & IORESOURCE_MEM))
+		return AE_TYPE;
+
+	return acpi_walk_namespace(ACPI_TYPE_REGION, handle, level,
+				   acpi_deactivate_mem_region, NULL, res, NULL);
+}
+EXPORT_SYMBOL_GPL(acpi_release_memory);
+
 /*
  * Let drivers know whether the resource checks are effective
  */

commit dfc9327ab7c99bc13e12106448615efba833886b
Author: Juergen Gross <jgross@suse.com>
Date:   Mon Feb 19 11:09:04 2018 +0100

    acpi: Introduce acpi_arch_get_root_pointer() for getting rsdp address
    
    Add an architecture specific function to get the address of the RSDP
    table. Per default it will just return 0 indicating falling back to
    the current mechanism.
    
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Eric Biederman <ebiederm@xmission.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: boris.ostrovsky@oracle.com
    Cc: lenb@kernel.org
    Cc: linux-acpi@vger.kernel.org
    Cc: xen-devel@lists.xenproject.org
    Link: http://lkml.kernel.org/r/20180219100906.14265-2-jgross@suse.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 3bb46cb24a99..7ca41bf023c9 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -189,12 +189,15 @@ early_param("acpi_rsdp", setup_acpi_rsdp);
 
 acpi_physical_address __init acpi_os_get_root_pointer(void)
 {
-	acpi_physical_address pa = 0;
+	acpi_physical_address pa;
 
 #ifdef CONFIG_KEXEC
 	if (acpi_rsdp)
 		return acpi_rsdp;
 #endif
+	pa = acpi_arch_get_root_pointer();
+	if (pa)
+		return pa;
 
 	if (efi_enabled(EFI_CONFIG_TABLES)) {
 		if (efi.acpi20 != EFI_INVALID_TABLE_ADDR)

commit eeb2d80d502af28e5660ff4bbe00f90ceb82c2db
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Oct 5 16:24:03 2017 -0700

    ACPI / LPIT: Add Low Power Idle Table (LPIT) support
    
    Add functionality to read LPIT table, which provides:
    
     - Sysfs interface to read residency counters via
       /sys/devices/system/cpu/cpuidle/low_power_idle_cpu_residency_us
       /sys/devices/system/cpu/cpuidle/low_power_idle_system_residency_us
    
    Here the count "low_power_idle_cpu_residency_us" shows the time spent
    by CPU package in low power state.  This is read via MSR interface,
    which points to MSR for PKG C10.
    
    Here the count "low_power_idle_system_residency_us" show the count the
    system was in low power state. This is read via MMIO interface. This
    is mapped to SLP_S0 residency on modern Intel systems. This residency
    is achieved only when CPU is in PKG C10 and all functional blocks are
    in low power state.
    
    It is possible that none of the above counters present or anyone of the
    counter present or all counters present.
    
    For example: On my Kabylake system both of the above counters present.
    After suspend to idle these counts updated and prints:
    
     6916179
     6998564
    
    This counter can be read by tools like turbostat to display. Or it can
    be used to debug, if modern systems are reaching desired low power state.
    
     - Provides an interface to read residency counter memory address
    
       This address can be used to get the base address of PMC memory
       mapped IO.  This is utilized by intel_pmc_core driver to print
       more debug information.
    
    In addition, to avoid code duplication to read iomem, removed the read of
    iomem from acpi_os_read_memory() in osl.c and made a common function
    acpi_os_read_iomem(). This new function is used for reading iomem in
    in both osl.c and acpi_lpit.c.
    
    Link: http://www.uefi.org/sites/default/files/resources/Intel_ACPI_Low_Power_S0_Idle.pdf
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index db78d353bab1..3bb46cb24a99 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -663,6 +663,29 @@ acpi_status acpi_os_write_port(acpi_io_address port, u32 value, u32 width)
 
 EXPORT_SYMBOL(acpi_os_write_port);
 
+int acpi_os_read_iomem(void __iomem *virt_addr, u64 *value, u32 width)
+{
+
+	switch (width) {
+	case 8:
+		*(u8 *) value = readb(virt_addr);
+		break;
+	case 16:
+		*(u16 *) value = readw(virt_addr);
+		break;
+	case 32:
+		*(u32 *) value = readl(virt_addr);
+		break;
+	case 64:
+		*(u64 *) value = readq(virt_addr);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 acpi_status
 acpi_os_read_memory(acpi_physical_address phys_addr, u64 *value, u32 width)
 {
@@ -670,6 +693,7 @@ acpi_os_read_memory(acpi_physical_address phys_addr, u64 *value, u32 width)
 	unsigned int size = width / 8;
 	bool unmap = false;
 	u64 dummy;
+	int error;
 
 	rcu_read_lock();
 	virt_addr = acpi_map_vaddr_lookup(phys_addr, size);
@@ -684,22 +708,8 @@ acpi_os_read_memory(acpi_physical_address phys_addr, u64 *value, u32 width)
 	if (!value)
 		value = &dummy;
 
-	switch (width) {
-	case 8:
-		*(u8 *) value = readb(virt_addr);
-		break;
-	case 16:
-		*(u16 *) value = readw(virt_addr);
-		break;
-	case 32:
-		*(u32 *) value = readl(virt_addr);
-		break;
-	case 64:
-		*(u64 *) value = readq(virt_addr);
-		break;
-	default:
-		BUG();
-	}
+	error = acpi_os_read_iomem(virt_addr, value, width);
+	BUG_ON(error);
 
 	if (unmap)
 		iounmap(virt_addr);

commit 0fc5e8f4e4b33ddfa1d1d673fcd420d6e13eb076
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Dec 28 15:28:49 2016 +0800

    ACPICA: Hardware: Add sleep register hooks
    
    ACPICA commit ba665dc8e20d9f7730466a659564dd6c557a6cbc
    
    In Linux, para-virtualization implmentation hooks critical register
    writes to prevent real hardware operations. This increases divergences
    when the sleep registers are cracked in Linux resident ACPICA.
    
    This patch tries to introduce a single OSL to reduce the divergences.
    
    Link: https://github.com/acpica/acpica/commit/ba665dc8
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 57fb5f468ac2..db78d353bab1 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1686,7 +1686,7 @@ acpi_status acpi_os_prepare_sleep(u8 sleep_state, u32 pm1a_control,
 	if (rc < 0)
 		return AE_ERROR;
 	else if (rc > 0)
-		return AE_CTRL_SKIP;
+		return AE_CTRL_TERMINATE;
 
 	return AE_OK;
 }
@@ -1697,6 +1697,7 @@ void acpi_os_set_prepare_sleep(int (*func)(u8 sleep_state,
 	__acpi_os_prepare_sleep = func;
 }
 
+#if (ACPI_REDUCED_HARDWARE)
 acpi_status acpi_os_prepare_extended_sleep(u8 sleep_state, u32 val_a,
 				  u32 val_b)
 {
@@ -1707,13 +1708,35 @@ acpi_status acpi_os_prepare_extended_sleep(u8 sleep_state, u32 val_a,
 	if (rc < 0)
 		return AE_ERROR;
 	else if (rc > 0)
-		return AE_CTRL_SKIP;
+		return AE_CTRL_TERMINATE;
 
 	return AE_OK;
 }
+#else
+acpi_status acpi_os_prepare_extended_sleep(u8 sleep_state, u32 val_a,
+				  u32 val_b)
+{
+	return AE_OK;
+}
+#endif
 
 void acpi_os_set_prepare_extended_sleep(int (*func)(u8 sleep_state,
 			       u32 val_a, u32 val_b))
 {
 	__acpi_os_prepare_extended_sleep = func;
 }
+
+acpi_status acpi_os_enter_sleep(u8 sleep_state,
+				u32 reg_a_value, u32 reg_b_value)
+{
+	acpi_status status;
+
+	if (acpi_gbl_reduced_hardware)
+		status = acpi_os_prepare_extended_sleep(sleep_state,
+							reg_a_value,
+							reg_b_value);
+	else
+		status = acpi_os_prepare_sleep(sleep_state,
+					       reg_a_value, reg_b_value);
+	return status;
+}

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index a404ff4d7151..57fb5f468ac2 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -42,7 +42,7 @@
 #include <linux/semaphore.h>
 
 #include <asm/io.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/io-64-nonatomic-lo-hi.h>
 
 #include "internal.h"

commit c8e008e2a6f9ec007a0e22e18eeb5bace5bf16c8
Merge: 7ae123edd37a 8d3523fb3b72 7020bcb82838
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Dec 22 14:34:24 2016 +0100

    Merge branches 'acpica' and 'acpi-scan'
    
    * acpica:
      ACPI / osl: Remove deprecated acpi_get_table_with_size()/early_acpi_os_unmap_memory()
      ACPI / osl: Remove acpi_get_table_with_size()/early_acpi_os_unmap_memory() users
      ACPICA: Tables: Allow FADT to be customized with virtual address
      ACPICA: Tables: Back port acpi_get_table_with_size() and early_acpi_os_unmap_memory() from Linux kernel
    
    * acpi-scan:
      ACPI: do not warn if _BQC does not exist

commit 8d3523fb3b727478ac528b307cb84460faa1c39e
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Dec 14 15:04:46 2016 +0800

    ACPI / osl: Remove deprecated acpi_get_table_with_size()/early_acpi_os_unmap_memory()
    
    Since all users are cleaned up, remove the 2 deprecated APIs due to no
    users.
    As a Linux variable rather than an ACPICA variable, acpi_gbl_permanent_mmap
    is renamed to acpi_permanent_mmap to have a consistent coding style across
    entire Linux ACPI subsystem.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 9316dfc19cea..8a7cab06e271 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -76,6 +76,7 @@ static struct workqueue_struct *kacpi_notify_wq;
 static struct workqueue_struct *kacpi_hotplug_wq;
 static bool acpi_os_initialized;
 unsigned int acpi_sci_irq = INVALID_ACPI_IRQ;
+bool acpi_permanent_mmap = false;
 
 /*
  * This list of permanent mappings is for memory that may be accessed from
@@ -313,7 +314,7 @@ static void acpi_unmap(acpi_physical_address pg_off, void __iomem *vaddr)
  * virtual address).  If not found, map it, add it to that list and return a
  * pointer to it.
  *
- * During early init (when acpi_gbl_permanent_mmap has not been set yet) this
+ * During early init (when acpi_permanent_mmap has not been set yet) this
  * routine simply calls __acpi_map_table() to get the job done.
  */
 void __iomem *__ref
@@ -329,7 +330,7 @@ acpi_os_map_iomem(acpi_physical_address phys, acpi_size size)
 		return NULL;
 	}
 
-	if (!acpi_gbl_permanent_mmap)
+	if (!acpi_permanent_mmap)
 		return __acpi_map_table((unsigned long)phys, size);
 
 	mutex_lock(&acpi_ioremap_lock);
@@ -399,7 +400,7 @@ static void acpi_os_map_cleanup(struct acpi_ioremap *map)
  * mappings, drop a reference to it and unmap it if there are no more active
  * references to it.
  *
- * During early init (when acpi_gbl_permanent_mmap has not been set yet) this
+ * During early init (when acpi_permanent_mmap has not been set yet) this
  * routine simply calls __acpi_unmap_table() to get the job done.  Since
  * __acpi_unmap_table() is an __init function, the __ref annotation is needed
  * here.
@@ -408,7 +409,7 @@ void __ref acpi_os_unmap_iomem(void __iomem *virt, acpi_size size)
 {
 	struct acpi_ioremap *map;
 
-	if (!acpi_gbl_permanent_mmap) {
+	if (!acpi_permanent_mmap) {
 		__acpi_unmap_table(virt, size);
 		return;
 	}
@@ -433,47 +434,6 @@ void __ref acpi_os_unmap_memory(void *virt, acpi_size size)
 }
 EXPORT_SYMBOL_GPL(acpi_os_unmap_memory);
 
-/*******************************************************************************
- *
- * acpi_get_table_with_size()/early_acpi_os_unmap_memory():
- *
- * These 2 functions are traditionally used by Linux to map/unmap physical
- * addressed ACPI tables during the early stage.
- * They are deprectated now. Do not use them in the new code, but use
- * acpi_get_table()/acpi_put_table() instead.
- *
- ******************************************************************************/
-acpi_status
-acpi_get_table_with_size(char *signature,
-	       u32 instance, struct acpi_table_header **out_table,
-	       acpi_size *tbl_size)
-{
-	acpi_status status;
-
-	status = acpi_get_table(signature, instance, out_table);
-	if (ACPI_SUCCESS(status)) {
-		/*
-		 * "tbl_size" is no longer used by
-		 * early_acpi_os_unmap_memory(), but is still used by the
-		 * ACPI table drivers. So sets it to the length of the
-		 * table when the tbl_size is requested.
-		 * "out_table" is not sanity checked as AE_BAD_PARAMETER
-		 * is returned if it is NULL.
-		 */
-		if (tbl_size && *out_table)
-			*tbl_size = (*out_table)->length;
-	}
-
-	return (status);
-}
-
-ACPI_EXPORT_SYMBOL(acpi_get_table_with_size)
-
-void __init early_acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
-{
-	acpi_put_table(ACPI_CAST_PTR(struct acpi_table_header, virt));
-}
-
 int acpi_os_map_generic_address(struct acpi_generic_address *gas)
 {
 	u64 addr;

commit 174cc7187e6f088942c8e74daa7baff7b44b33c9
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Dec 14 15:04:25 2016 +0800

    ACPICA: Tables: Back port acpi_get_table_with_size() and early_acpi_os_unmap_memory() from Linux kernel
    
    ACPICA commit cac6790954d4d752a083e6122220b8a22febcd07
    
    This patch back ports Linux acpi_get_table_with_size() and
    early_acpi_os_unmap_memory() into ACPICA upstream to reduce divergences.
    
    The 2 APIs are used by Linux as table management APIs for long time, it
    contains a hidden logic that during the early stage, the mapped tables
    should be unmapped before the early stage ends.
    
    During the early stage, tables are handled by the following sequence:
     acpi_get_table_with_size();
     parse the table
     early_acpi_os_unmap_memory();
    During the late stage, tables are handled by the following sequence:
     acpi_get_table();
     parse the table
    Linux uses acpi_gbl_permanent_mmap to distinguish the early stage and the
    late stage.
    
    The reasoning of introducing acpi_get_table_with_size() is: ACPICA will
    remember the early mapped pointer in acpi_get_table() and Linux isn't able to
    prevent ACPICA from using the wrong early mapped pointer during the late
    stage as there is no API provided from ACPICA to be an inverse of
    acpi_get_table() to forget the early mapped pointer.
    
    But how ACPICA can work with the early/late stage requirement? Inside of
    ACPICA, tables are ensured to be remained in "INSTALLED" state during the
    early stage, and they are carefully not transitioned to "VALIDATED" state
    until the late stage. So the same logic is in fact implemented inside of
    ACPICA in a different way. The gap is only that the feature is not provided
    to the OSPMs in an accessible external API style.
    
    It then is possible to fix the gap by providing an inverse of
    acpi_get_table() from ACPICA, so that the two Linux sequences can be
    combined:
     acpi_get_table();
     parse the table
     acpi_put_table();
    In order to work easier with the current Linux code, acpi_get_table() and
    acpi_put_table() is implemented in a usage counting based style:
     1. When the usage count of the table is increased from 0 to 1, table is
        mapped and .Pointer is set with the mapping address (VALIDATED);
     2. When the usage count of the table is decreased from 1 to 0, .Pointer
        is unset and the mapping address is unmapped (INVALIDATED).
    So that we can deploy the new APIs to Linux with minimal effort by just
    invoking acpi_get_table() in acpi_get_table_with_size() and invoking
    acpi_put_table() in early_acpi_os_unmap_memory(). Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/cac67909
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 416953a42510..9316dfc19cea 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -433,10 +433,45 @@ void __ref acpi_os_unmap_memory(void *virt, acpi_size size)
 }
 EXPORT_SYMBOL_GPL(acpi_os_unmap_memory);
 
+/*******************************************************************************
+ *
+ * acpi_get_table_with_size()/early_acpi_os_unmap_memory():
+ *
+ * These 2 functions are traditionally used by Linux to map/unmap physical
+ * addressed ACPI tables during the early stage.
+ * They are deprectated now. Do not use them in the new code, but use
+ * acpi_get_table()/acpi_put_table() instead.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_get_table_with_size(char *signature,
+	       u32 instance, struct acpi_table_header **out_table,
+	       acpi_size *tbl_size)
+{
+	acpi_status status;
+
+	status = acpi_get_table(signature, instance, out_table);
+	if (ACPI_SUCCESS(status)) {
+		/*
+		 * "tbl_size" is no longer used by
+		 * early_acpi_os_unmap_memory(), but is still used by the
+		 * ACPI table drivers. So sets it to the length of the
+		 * table when the tbl_size is requested.
+		 * "out_table" is not sanity checked as AE_BAD_PARAMETER
+		 * is returned if it is NULL.
+		 */
+		if (tbl_size && *out_table)
+			*tbl_size = (*out_table)->length;
+	}
+
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_table_with_size)
+
 void __init early_acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 {
-	if (!acpi_gbl_permanent_mmap)
-		__acpi_unmap_table(virt, size);
+	acpi_put_table(ACPI_CAST_PTR(struct acpi_table_header, virt));
 }
 
 int acpi_os_map_generic_address(struct acpi_generic_address *gas)

commit 2fb65f09c2c6eaba5fcf848aa615f4837d540576
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Dec 2 19:42:47 2016 +0200

    ACPI / osl: Refactor acpi_os_get_root_pointer() to drop 'else':s
    
    There are few 'else' keywords which are redundant in
    acpi_os_get_root_pointer(). Refactor function to get rid of them.
    
    While here, switch to pr_err() instead of printk(KERN_ERR ...).
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index d47df72990dd..9a4c6abee63e 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -188,6 +188,8 @@ early_param("acpi_rsdp", setup_acpi_rsdp);
 
 acpi_physical_address __init acpi_os_get_root_pointer(void)
 {
+	acpi_physical_address pa = 0;
+
 #ifdef CONFIG_KEXEC
 	if (acpi_rsdp)
 		return acpi_rsdp;
@@ -196,21 +198,14 @@ acpi_physical_address __init acpi_os_get_root_pointer(void)
 	if (efi_enabled(EFI_CONFIG_TABLES)) {
 		if (efi.acpi20 != EFI_INVALID_TABLE_ADDR)
 			return efi.acpi20;
-		else if (efi.acpi != EFI_INVALID_TABLE_ADDR)
+		if (efi.acpi != EFI_INVALID_TABLE_ADDR)
 			return efi.acpi;
-		else {
-			printk(KERN_ERR PREFIX
-			       "System description tables not found\n");
-			return 0;
-		}
+		pr_err(PREFIX "System description tables not found\n");
 	} else if (IS_ENABLED(CONFIG_ACPI_LEGACY_TABLES_LOOKUP)) {
-		acpi_physical_address pa = 0;
-
 		acpi_find_root_pointer(&pa);
-		return pa;
 	}
 
-	return 0;
+	return pa;
 }
 
 /* Must be called with 'acpi_ioremap_lock' or RCU read lock held. */

commit 5dcb9ca8403c31f4a9a6e21b0057be3bdefb7414
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Dec 2 19:42:46 2016 +0200

    ACPI / osl: Propagate actual error code for kstrtoul()
    
    There is no need to override the error code returned by kstrtoul().
    Propagate it directly to the caller.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 416953a42510..d47df72990dd 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -181,9 +181,7 @@ void acpi_os_vprintf(const char *fmt, va_list args)
 static unsigned long acpi_rsdp;
 static int __init setup_acpi_rsdp(char *arg)
 {
-	if (kstrtoul(arg, 16, &acpi_rsdp))
-		return -EINVAL;
-	return 0;
+	return kstrtoul(arg, 16, &acpi_rsdp);
 }
 early_param("acpi_rsdp", setup_acpi_rsdp);
 #endif

commit abc4b9a53ea8153e0e028762b22cb213685c52e3
Author: Joe Perches <joe@perches.com>
Date:   Wed Oct 12 11:50:34 2016 -0700

    acpi_os_vprintf: Use printk_get_level() to avoid unnecessary KERN_CONT
    
    acpi_os_vprintf currently always uses a KERN_CONT prefix which may be
    followed immediately by a proper KERN_<LEVEL>.  Check if the buffer
    already has a KERN_<LEVEL> at the start of the buffer and avoid the
    unnecessary KERN_CONT.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 4305ee9db4b2..416953a42510 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -162,11 +162,18 @@ void acpi_os_vprintf(const char *fmt, va_list args)
 	if (acpi_in_debugger) {
 		kdb_printf("%s", buffer);
 	} else {
-		printk(KERN_CONT "%s", buffer);
+		if (printk_get_level(buffer))
+			printk("%s", buffer);
+		else
+			printk(KERN_CONT "%s", buffer);
 	}
 #else
-	if (acpi_debugger_write_log(buffer) < 0)
-		printk(KERN_CONT "%s", buffer);
+	if (acpi_debugger_write_log(buffer) < 0) {
+		if (printk_get_level(buffer))
+			printk("%s", buffer);
+		else
+			printk(KERN_CONT "%s", buffer);
+	}
 #endif
 }
 

commit bd721ea73e1f965569b40620538c942001f76294
Author: Fabian Frederick <fabf@skynet.be>
Date:   Tue Aug 2 14:03:33 2016 -0700

    treewide: replace obsolete _refok by __ref
    
    There was only one use of __initdata_refok and __exit_refok
    
    __init_refok was used 46 times against 82 for __ref.
    
    Those definitions are obsolete since commit 312b1485fb50 ("Introduce new
    section reference annotations tags: __ref, __refdata, __refconst")
    
    This patch removes the following compatibility definitions and replaces
    them treewide.
    
    /* compatibility defines */
    #define __init_refok     __ref
    #define __initdata_refok __refdata
    #define __exit_refok     __ref
    
    I can also provide separate patches if necessary.
    (One patch per tree and check in 1 month or 2 to remove old definitions)
    
    [akpm@linux-foundation.org: coding-style fixes]
    Link: http://lkml.kernel.org/r/1466796271-3043-1-git-send-email-fabf@skynet.be
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index b108f1358a32..4305ee9db4b2 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -309,7 +309,7 @@ static void acpi_unmap(acpi_physical_address pg_off, void __iomem *vaddr)
  * During early init (when acpi_gbl_permanent_mmap has not been set yet) this
  * routine simply calls __acpi_map_table() to get the job done.
  */
-void __iomem *__init_refok
+void __iomem *__ref
 acpi_os_map_iomem(acpi_physical_address phys, acpi_size size)
 {
 	struct acpi_ioremap *map;
@@ -362,8 +362,7 @@ acpi_os_map_iomem(acpi_physical_address phys, acpi_size size)
 }
 EXPORT_SYMBOL_GPL(acpi_os_map_iomem);
 
-void *__init_refok
-acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
+void *__ref acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 {
 	return (void *)acpi_os_map_iomem(phys, size);
 }

commit efc499f9807bfc179c66b7c3524e30370c6fd1b1
Merge: a6becfbaba80 702b07fcc9b2 74216699ddcc e5f660ebef68
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon May 16 16:45:25 2016 +0200

    Merge branches 'acpi-numa', 'acpi-tables' and 'acpi-osi'
    
    * acpi-numa:
      ACPI / SRAT: fix SRAT parsing order with both LAPIC and X2APIC present
    
    * acpi-tables:
      ACPI / tables: Fix DSDT override mechanism
      ACPI / tables: Convert initrd table override to table upgrade mechanism
      ACPI / x86: Cleanup initrd related code
      ACPI / tables: Move table override mechanisms to tables.c
    
    * acpi-osi:
      ACPI / osi: Collect _OSI handling into one single file
      ACPI / osi: Cleanup coding style issues before creating a separate OSI source file
      ACPI / osi: Cleanup OSI handling code to use bool
      ACPI / osi: Fix default _OSI(Darwin) support
      ACPI / osi: Add acpi_osi=!! to allow reverting acpi_osi=!
      ACPI / osi: Cleanup _OSI("Linux") related code before introducing new support
      ACPI / osi: Fix an issue that acpi_osi=!* cannot disable ACPICA internal strings
    
    Conflicts:
            drivers/acpi/internal.h

commit 74216699ddcca13541e8494cb2b995e6a44a04d9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 6 01:27:09 2016 +0200

    ACPI / tables: Fix DSDT override mechanism
    
    Commit 5ae74f2cc2f1 (ACPI / tables: Move table override mechanisms to
    tables.c) forgot to move the CONFIG_ACPI_CUSTOM_DSDT_FILE inclusion
    directive from osl.c to tables.c.  Fix that.
    
    Fixes: 5ae74f2cc2f1 (ACPI / tables: Move table override mechanisms to tables.c)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Lv Zheng <lv.zheng@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 0796ad96dc32..0155f8b8a79a 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -56,10 +56,6 @@ struct acpi_os_dpc {
 	struct work_struct work;
 };
 
-#ifdef CONFIG_ACPI_CUSTOM_DSDT
-#include CONFIG_ACPI_CUSTOM_DSDT_FILE
-#endif
-
 #ifdef ENABLE_DEBUGGER
 #include <linux/kdb.h>
 

commit e5f660ebef68e3ed1a988ad06ba23562153cee5c
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue May 3 16:49:01 2016 +0800

    ACPI / osi: Collect _OSI handling into one single file
    
    _OSI handling code grows giant and it's time to move them into one file.
    
    This patch collects all _OSI handling code into one single file.
    So that we only have the following functions to be used externally:
    
     early_acpi_osi_init(): Used by DMI detections;
     acpi_osi_init(): Used to initialize OSI command line settings and install
                      Linux specific _OSI handler;
     acpi_osi_setup(): The API that should be used by the external quirks.
     acpi_osi_is_win8(): The API is used by the external drivers to determine
                         if BIOS supports Win8.
    
    CONFIG_DMI is not useful as stub dmi_check_system() can make everything
    stub because of strip.
    
    No functional changes.
    
    Tested-by: Lukas Wunner <lukas@wunner.de>
    Tested-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 134051689d72..29af6b40c93f 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -96,74 +96,6 @@ struct acpi_ioremap {
 static LIST_HEAD(acpi_ioremaps);
 static DEFINE_MUTEX(acpi_ioremap_lock);
 
-static void __init acpi_osi_setup_late(void);
-
-/*
- * The story of _OSI(Linux)
- *
- * From pre-history through Linux-2.6.22,
- * Linux responded TRUE upon a BIOS OSI(Linux) query.
- *
- * Unfortunately, reference BIOS writers got wind of this
- * and put OSI(Linux) in their example code, quickly exposing
- * this string as ill-conceived and opening the door to
- * an un-bounded number of BIOS incompatibilities.
- *
- * For example, OSI(Linux) was used on resume to re-POST a
- * video card on one system, because Linux at that time
- * could not do a speedy restore in its native driver.
- * But then upon gaining quick native restore capability,
- * Linux has no way to tell the BIOS to skip the time-consuming
- * POST -- putting Linux at a permanent performance disadvantage.
- * On another system, the BIOS writer used OSI(Linux)
- * to infer native OS support for IPMI!  On other systems,
- * OSI(Linux) simply got in the way of Linux claiming to
- * be compatible with other operating systems, exposing
- * BIOS issues such as skipped device initialization.
- *
- * So "Linux" turned out to be a really poor chose of
- * OSI string, and from Linux-2.6.23 onward we respond FALSE.
- *
- * BIOS writers should NOT query _OSI(Linux) on future systems.
- * Linux will complain on the console when it sees it, and return FALSE.
- * To get Linux to return TRUE for your system  will require
- * a kernel source update to add a DMI entry,
- * or boot with "acpi_osi=Linux"
- */
-
-static struct acpi_osi_config {
-	unsigned int	linux_enable:1;
-	unsigned int	linux_dmi:1;
-	unsigned int	linux_cmdline:1;
-	unsigned int	darwin_enable:1;
-	unsigned int	darwin_dmi:1;
-	unsigned int	darwin_cmdline:1;
-	u8		default_disabling;
-} osi_config;
-
-static u32 acpi_osi_handler(acpi_string interface, u32 supported)
-{
-	if (!strcmp("Linux", interface)) {
-
-		pr_notice_once(FW_BUG PREFIX
-			"BIOS _OSI(Linux) query %s%s\n",
-			osi_config.linux_enable ? "honored" : "ignored",
-			osi_config.linux_cmdline ? " via cmdline" :
-			osi_config.linux_dmi ? " via DMI" : "");
-	}
-
-	if (!strcmp("Darwin", interface)) {
-
-		pr_notice_once(PREFIX
-			"BIOS _OSI(Darwin) query %s%s\n",
-			osi_config.darwin_enable ? "honored" : "ignored",
-			osi_config.darwin_cmdline ? " via cmdline" :
-			osi_config.darwin_dmi ? " via DMI" : "");
-	}
-
-	return supported;
-}
-
 static void __init acpi_request_region (struct acpi_generic_address *gas,
 	unsigned int length, char *desc)
 {
@@ -1719,185 +1651,6 @@ static int __init acpi_os_name_setup(char *str)
 
 __setup("acpi_os_name=", acpi_os_name_setup);
 
-#define	OSI_STRING_LENGTH_MAX 64
-#define	OSI_STRING_ENTRIES_MAX 16
-
-struct acpi_osi_entry {
-	char string[OSI_STRING_LENGTH_MAX];
-	bool enable;
-};
-
-static struct acpi_osi_entry
-		osi_setup_entries[OSI_STRING_ENTRIES_MAX] __initdata = {
-	{"Module Device", true},
-	{"Processor Device", true},
-	{"3.0 _SCP Extensions", true},
-	{"Processor Aggregator Device", true},
-};
-
-void __init acpi_osi_setup(char *str)
-{
-	struct acpi_osi_entry *osi;
-	bool enable = true;
-	int i;
-
-	if (!acpi_gbl_create_osi_method)
-		return;
-
-	if (str == NULL || *str == '\0') {
-		pr_info(PREFIX "_OSI method disabled\n");
-		acpi_gbl_create_osi_method = FALSE;
-		return;
-	}
-
-	if (*str == '!') {
-		str++;
-		if (*str == '\0') {
-			/* Do not override acpi_osi=!* */
-			if (!osi_config.default_disabling)
-				osi_config.default_disabling =
-					ACPI_DISABLE_ALL_VENDOR_STRINGS;
-			return;
-		} else if (*str == '*') {
-			osi_config.default_disabling = ACPI_DISABLE_ALL_STRINGS;
-			for (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {
-				osi = &osi_setup_entries[i];
-				osi->enable = false;
-			}
-			return;
-		} else if (*str == '!') {
-			osi_config.default_disabling = 0;
-			return;
-		}
-		enable = false;
-	}
-
-	for (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {
-		osi = &osi_setup_entries[i];
-		if (!strcmp(osi->string, str)) {
-			osi->enable = enable;
-			break;
-		} else if (osi->string[0] == '\0') {
-			osi->enable = enable;
-			strncpy(osi->string, str, OSI_STRING_LENGTH_MAX);
-			break;
-		}
-	}
-}
-
-static void __init __acpi_osi_setup_darwin(bool enable)
-{
-	osi_config.darwin_enable = !!enable;
-	if (enable) {
-		acpi_osi_setup("!");
-		acpi_osi_setup("Darwin");
-	} else {
-		acpi_osi_setup("!!");
-		acpi_osi_setup("!Darwin");
-	}
-}
-
-static void __init acpi_osi_setup_darwin(bool enable)
-{
-	osi_config.darwin_cmdline = 1;
-	osi_config.darwin_dmi = 0;
-	__acpi_osi_setup_darwin(enable);
-}
-
-void __init acpi_osi_dmi_darwin(bool enable, const struct dmi_system_id *d)
-{
-	pr_notice(PREFIX "DMI detected to setup _OSI(\"Darwin\"): %s\n",
-		  d->ident);
-	osi_config.darwin_dmi = 1;
-	__acpi_osi_setup_darwin(enable);
-}
-
-static void __init __acpi_osi_setup_linux(bool enable)
-{
-	osi_config.linux_enable = !!enable;
-	if (enable)
-		acpi_osi_setup("Linux");
-	else
-		acpi_osi_setup("!Linux");
-}
-
-static void __init acpi_osi_setup_linux(bool enable)
-{
-	osi_config.linux_cmdline = 1;
-	osi_config.linux_dmi = 0;
-	__acpi_osi_setup_linux(enable);
-}
-
-void __init acpi_osi_dmi_linux(bool enable, const struct dmi_system_id *d)
-{
-	pr_notice(PREFIX "DMI detected to setup _OSI(\"Linux\"): %s\n",
-		  d->ident);
-	osi_config.linux_dmi = 1;
-	__acpi_osi_setup_linux(enable);
-}
-
-/*
- * Modify the list of "OS Interfaces" reported to BIOS via _OSI
- *
- * empty string disables _OSI
- * string starting with '!' disables that string
- * otherwise string is added to list, augmenting built-in strings
- */
-static void __init acpi_osi_setup_late(void)
-{
-	struct acpi_osi_entry *osi;
-	char *str;
-	int i;
-	acpi_status status;
-
-	if (osi_config.default_disabling) {
-		status = acpi_update_interfaces(osi_config.default_disabling);
-
-		if (ACPI_SUCCESS(status))
-			pr_info(PREFIX "Disabled all _OSI OS vendors%s\n",
-				osi_config.default_disabling ==
-				ACPI_DISABLE_ALL_STRINGS ?
-				" and feature groups" : "");
-	}
-
-	for (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {
-		osi = &osi_setup_entries[i];
-		str = osi->string;
-
-		if (*str == '\0')
-			break;
-		if (osi->enable) {
-			status = acpi_install_interface(str);
-
-			if (ACPI_SUCCESS(status))
-				pr_info(PREFIX "Added _OSI(%s)\n", str);
-		} else {
-			status = acpi_remove_interface(str);
-
-			if (ACPI_SUCCESS(status))
-				pr_info(PREFIX "Deleted _OSI(%s)\n", str);
-		}
-	}
-}
-
-static int __init osi_setup(char *str)
-{
-	if (str && !strcmp("Linux", str))
-		acpi_osi_setup_linux(true);
-	else if (str && !strcmp("!Linux", str))
-		acpi_osi_setup_linux(false);
-	else if (str && !strcmp("Darwin", str))
-		acpi_osi_setup_darwin(true);
-	else if (str && !strcmp("!Darwin", str))
-		acpi_osi_setup_darwin(false);
-	else
-		acpi_osi_setup(str);
-
-	return 1;
-}
-
-__setup("acpi_osi=", osi_setup);
-
 /*
  * Disable the auto-serialization of named objects creation methods.
  *
@@ -2017,12 +1770,6 @@ int acpi_resources_are_enforced(void)
 }
 EXPORT_SYMBOL(acpi_resources_are_enforced);
 
-bool acpi_osi_is_win8(void)
-{
-	return acpi_gbl_osi_data >= ACPI_OSI_WIN_8;
-}
-EXPORT_SYMBOL(acpi_osi_is_win8);
-
 /*
  * Deallocate the memory for a spinlock.
  */
@@ -2188,8 +1935,7 @@ acpi_status __init acpi_os_initialize1(void)
 	BUG_ON(!kacpid_wq);
 	BUG_ON(!kacpi_notify_wq);
 	BUG_ON(!kacpi_hotplug_wq);
-	acpi_install_interface_handler(acpi_osi_handler);
-	acpi_osi_setup_late();
+	acpi_osi_init();
 	return AE_OK;
 }
 

commit d5a91d74c6d7da2cebadbb9f2d03e56f84d7be62
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue May 3 16:48:53 2016 +0800

    ACPI / osi: Cleanup coding style issues before creating a separate OSI source file
    
    This patch performs necessary cleanups before moving OSI support to
    another file.
    
     1. Change printk into pr_xxx
     2. Do not initialize values to 0
     3. Do not append additional "return" at the end of the function
     4. Remove useless comments which may easily break line breaking rule
    
    After fixing the coding style issues, rename functions to make them looking
    like acpi_osi_xxx.
    
    No functional changes.
    
    Tested-by: Lukas Wunner <lukas@wunner.de>
    Tested-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e30f3251fd14..134051689d72 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -139,13 +139,13 @@ static struct acpi_osi_config {
 	unsigned int	darwin_dmi:1;
 	unsigned int	darwin_cmdline:1;
 	u8		default_disabling;
-} osi_config = {0, 0, 0, 0};
+} osi_config;
 
 static u32 acpi_osi_handler(acpi_string interface, u32 supported)
 {
 	if (!strcmp("Linux", interface)) {
 
-		printk_once(KERN_NOTICE FW_BUG PREFIX
+		pr_notice_once(FW_BUG PREFIX
 			"BIOS _OSI(Linux) query %s%s\n",
 			osi_config.linux_enable ? "honored" : "ignored",
 			osi_config.linux_cmdline ? " via cmdline" :
@@ -154,7 +154,7 @@ static u32 acpi_osi_handler(acpi_string interface, u32 supported)
 
 	if (!strcmp("Darwin", interface)) {
 
-		printk_once(KERN_NOTICE PREFIX
+		pr_notice_once(PREFIX
 			"BIOS _OSI(Darwin) query %s%s\n",
 			osi_config.darwin_enable ? "honored" : "ignored",
 			osi_config.darwin_cmdline ? " via cmdline" :
@@ -1719,15 +1719,15 @@ static int __init acpi_os_name_setup(char *str)
 
 __setup("acpi_os_name=", acpi_os_name_setup);
 
-#define	OSI_STRING_LENGTH_MAX 64	/* arbitrary */
-#define	OSI_STRING_ENTRIES_MAX 16	/* arbitrary */
+#define	OSI_STRING_LENGTH_MAX 64
+#define	OSI_STRING_ENTRIES_MAX 16
 
-struct osi_setup_entry {
+struct acpi_osi_entry {
 	char string[OSI_STRING_LENGTH_MAX];
 	bool enable;
 };
 
-static struct osi_setup_entry
+static struct acpi_osi_entry
 		osi_setup_entries[OSI_STRING_ENTRIES_MAX] __initdata = {
 	{"Module Device", true},
 	{"Processor Device", true},
@@ -1737,7 +1737,7 @@ static struct osi_setup_entry
 
 void __init acpi_osi_setup(char *str)
 {
-	struct osi_setup_entry *osi;
+	struct acpi_osi_entry *osi;
 	bool enable = true;
 	int i;
 
@@ -1745,7 +1745,7 @@ void __init acpi_osi_setup(char *str)
 		return;
 
 	if (str == NULL || *str == '\0') {
-		printk(KERN_INFO PREFIX "_OSI method disabled\n");
+		pr_info(PREFIX "_OSI method disabled\n");
 		acpi_gbl_create_osi_method = FALSE;
 		return;
 	}
@@ -1785,7 +1785,7 @@ void __init acpi_osi_setup(char *str)
 	}
 }
 
-static void __init set_osi_darwin(bool enable)
+static void __init __acpi_osi_setup_darwin(bool enable)
 {
 	osi_config.darwin_enable = !!enable;
 	if (enable) {
@@ -1797,57 +1797,43 @@ static void __init set_osi_darwin(bool enable)
 	}
 }
 
-static void __init acpi_cmdline_osi_darwin(bool enable)
+static void __init acpi_osi_setup_darwin(bool enable)
 {
-	/* cmdline set the default and override DMI */
 	osi_config.darwin_cmdline = 1;
 	osi_config.darwin_dmi = 0;
-	set_osi_darwin(enable);
-
-	return;
+	__acpi_osi_setup_darwin(enable);
 }
 
-void __init acpi_dmi_osi_darwin(bool enable, const struct dmi_system_id *d)
+void __init acpi_osi_dmi_darwin(bool enable, const struct dmi_system_id *d)
 {
-	printk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);
-
-	/* DMI knows that this box asks OSI(Darwin) */
+	pr_notice(PREFIX "DMI detected to setup _OSI(\"Darwin\"): %s\n",
+		  d->ident);
 	osi_config.darwin_dmi = 1;
-	set_osi_darwin(enable);
-
-	return;
+	__acpi_osi_setup_darwin(enable);
 }
 
-static void __init set_osi_linux(bool enable)
+static void __init __acpi_osi_setup_linux(bool enable)
 {
 	osi_config.linux_enable = !!enable;
 	if (enable)
 		acpi_osi_setup("Linux");
 	else
 		acpi_osi_setup("!Linux");
-
-	return;
 }
 
-static void __init acpi_cmdline_osi_linux(bool enable)
+static void __init acpi_osi_setup_linux(bool enable)
 {
-	/* cmdline set the default and override DMI */
 	osi_config.linux_cmdline = 1;
 	osi_config.linux_dmi = 0;
-	set_osi_linux(enable);
-
-	return;
+	__acpi_osi_setup_linux(enable);
 }
 
-void __init acpi_dmi_osi_linux(bool enable, const struct dmi_system_id *d)
+void __init acpi_osi_dmi_linux(bool enable, const struct dmi_system_id *d)
 {
-	printk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);
-
-	/* DMI knows that this box asks OSI(Linux) */
+	pr_notice(PREFIX "DMI detected to setup _OSI(\"Linux\"): %s\n",
+		  d->ident);
 	osi_config.linux_dmi = 1;
-	set_osi_linux(enable);
-
-	return;
+	__acpi_osi_setup_linux(enable);
 }
 
 /*
@@ -1859,7 +1845,7 @@ void __init acpi_dmi_osi_linux(bool enable, const struct dmi_system_id *d)
  */
 static void __init acpi_osi_setup_late(void)
 {
-	struct osi_setup_entry *osi;
+	struct acpi_osi_entry *osi;
 	char *str;
 	int i;
 	acpi_status status;
@@ -1868,7 +1854,7 @@ static void __init acpi_osi_setup_late(void)
 		status = acpi_update_interfaces(osi_config.default_disabling);
 
 		if (ACPI_SUCCESS(status))
-			printk(KERN_INFO PREFIX "Disabled all _OSI OS vendors%s\n",
+			pr_info(PREFIX "Disabled all _OSI OS vendors%s\n",
 				osi_config.default_disabling ==
 				ACPI_DISABLE_ALL_STRINGS ?
 				" and feature groups" : "");
@@ -1884,12 +1870,12 @@ static void __init acpi_osi_setup_late(void)
 			status = acpi_install_interface(str);
 
 			if (ACPI_SUCCESS(status))
-				printk(KERN_INFO PREFIX "Added _OSI(%s)\n", str);
+				pr_info(PREFIX "Added _OSI(%s)\n", str);
 		} else {
 			status = acpi_remove_interface(str);
 
 			if (ACPI_SUCCESS(status))
-				printk(KERN_INFO PREFIX "Deleted _OSI(%s)\n", str);
+				pr_info(PREFIX "Deleted _OSI(%s)\n", str);
 		}
 	}
 }
@@ -1897,13 +1883,13 @@ static void __init acpi_osi_setup_late(void)
 static int __init osi_setup(char *str)
 {
 	if (str && !strcmp("Linux", str))
-		acpi_cmdline_osi_linux(true);
+		acpi_osi_setup_linux(true);
 	else if (str && !strcmp("!Linux", str))
-		acpi_cmdline_osi_linux(false);
+		acpi_osi_setup_linux(false);
 	else if (str && !strcmp("Darwin", str))
-		acpi_cmdline_osi_darwin(true);
+		acpi_osi_setup_darwin(true);
 	else if (str && !strcmp("!Darwin", str))
-		acpi_cmdline_osi_darwin(false);
+		acpi_osi_setup_darwin(false);
 	else
 		acpi_osi_setup(str);
 

commit dc45eb20a83d11ed649169fbe9159ed6bf586c88
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue May 3 16:48:46 2016 +0800

    ACPI / osi: Cleanup OSI handling code to use bool
    
    This patch changes "int/unsigned int" to "bool" to simplify the code.
    
    Tested-by: Lukas Wunner <lukas@wunner.de>
    Tested-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 1b84e4635ae0..e30f3251fd14 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1785,11 +1785,9 @@ void __init acpi_osi_setup(char *str)
 	}
 }
 
-static void __init set_osi_darwin(unsigned int enable)
+static void __init set_osi_darwin(bool enable)
 {
-	if (osi_config.darwin_enable != enable)
-		osi_config.darwin_enable = enable;
-
+	osi_config.darwin_enable = !!enable;
 	if (enable) {
 		acpi_osi_setup("!");
 		acpi_osi_setup("Darwin");
@@ -1799,7 +1797,7 @@ static void __init set_osi_darwin(unsigned int enable)
 	}
 }
 
-static void __init acpi_cmdline_osi_darwin(unsigned int enable)
+static void __init acpi_cmdline_osi_darwin(bool enable)
 {
 	/* cmdline set the default and override DMI */
 	osi_config.darwin_cmdline = 1;
@@ -1809,13 +1807,10 @@ static void __init acpi_cmdline_osi_darwin(unsigned int enable)
 	return;
 }
 
-void __init acpi_dmi_osi_darwin(int enable, const struct dmi_system_id *d)
+void __init acpi_dmi_osi_darwin(bool enable, const struct dmi_system_id *d)
 {
 	printk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);
 
-	if (enable == -1)
-		return;
-
 	/* DMI knows that this box asks OSI(Darwin) */
 	osi_config.darwin_dmi = 1;
 	set_osi_darwin(enable);
@@ -1823,12 +1818,10 @@ void __init acpi_dmi_osi_darwin(int enable, const struct dmi_system_id *d)
 	return;
 }
 
-static void __init set_osi_linux(unsigned int enable)
+static void __init set_osi_linux(bool enable)
 {
-	if (osi_config.linux_enable != enable)
-		osi_config.linux_enable = enable;
-
-	if (osi_config.linux_enable)
+	osi_config.linux_enable = !!enable;
+	if (enable)
 		acpi_osi_setup("Linux");
 	else
 		acpi_osi_setup("!Linux");
@@ -1836,7 +1829,7 @@ static void __init set_osi_linux(unsigned int enable)
 	return;
 }
 
-static void __init acpi_cmdline_osi_linux(unsigned int enable)
+static void __init acpi_cmdline_osi_linux(bool enable)
 {
 	/* cmdline set the default and override DMI */
 	osi_config.linux_cmdline = 1;
@@ -1846,13 +1839,10 @@ static void __init acpi_cmdline_osi_linux(unsigned int enable)
 	return;
 }
 
-void __init acpi_dmi_osi_linux(int enable, const struct dmi_system_id *d)
+void __init acpi_dmi_osi_linux(bool enable, const struct dmi_system_id *d)
 {
 	printk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);
 
-	if (enable == -1)
-		return;
-
 	/* DMI knows that this box asks OSI(Linux) */
 	osi_config.linux_dmi = 1;
 	set_osi_linux(enable);
@@ -1907,13 +1897,13 @@ static void __init acpi_osi_setup_late(void)
 static int __init osi_setup(char *str)
 {
 	if (str && !strcmp("Linux", str))
-		acpi_cmdline_osi_linux(1);
+		acpi_cmdline_osi_linux(true);
 	else if (str && !strcmp("!Linux", str))
-		acpi_cmdline_osi_linux(0);
+		acpi_cmdline_osi_linux(false);
 	else if (str && !strcmp("Darwin", str))
-		acpi_cmdline_osi_darwin(1);
+		acpi_cmdline_osi_darwin(true);
 	else if (str && !strcmp("!Darwin", str))
-		acpi_cmdline_osi_darwin(0);
+		acpi_cmdline_osi_darwin(false);
 	else
 		acpi_osi_setup(str);
 

commit e10cfdc33a0f23dc8449be7267f0a642e96a2a24
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Tue May 3 16:48:39 2016 +0800

    ACPI / osi: Fix default _OSI(Darwin) support
    
    The following commit always reports positive value when Apple hardware
    queries _OSI("Darwin"):
    
     Commit: 7bc5a2bad0b8d9d1ac9f7b8b33150e4ddf197334
     Subject: ACPI: Support _OSI("Darwin") correctly
    
    However since this implementation places the judgement in runtime, it
    breaks acpi_osi=!Darwin and cannot return unsupported for _OSI("WinXXX")
    invoked before invoking _OSI("Darwin").
    
    This patch fixes the issues by reverting the wrong support and implementing
    the default behavior of _OSI("Darwin")/_OSI("WinXXX") on Apple hardware via
    DMI matching.
    
    Fixes: 7bc5a2bad0b8 (ACPI: Support _OSI("Darwin") correctly)
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=92111
    Reported-and-tested-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index f801b59f2a94..1b84e4635ae0 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -135,6 +135,9 @@ static struct acpi_osi_config {
 	unsigned int	linux_enable:1;
 	unsigned int	linux_dmi:1;
 	unsigned int	linux_cmdline:1;
+	unsigned int	darwin_enable:1;
+	unsigned int	darwin_dmi:1;
+	unsigned int	darwin_cmdline:1;
 	u8		default_disabling;
 } osi_config = {0, 0, 0, 0};
 
@@ -150,13 +153,12 @@ static u32 acpi_osi_handler(acpi_string interface, u32 supported)
 	}
 
 	if (!strcmp("Darwin", interface)) {
-		/*
-		 * Apple firmware will behave poorly if it receives positive
-		 * answers to "Darwin" and any other OS. Respond positively
-		 * to Darwin and then disable all other vendor strings.
-		 */
-		acpi_update_interfaces(ACPI_DISABLE_ALL_VENDOR_STRINGS);
-		supported = ACPI_UINT32_MAX;
+
+		printk_once(KERN_NOTICE PREFIX
+			"BIOS _OSI(Darwin) query %s%s\n",
+			osi_config.darwin_enable ? "honored" : "ignored",
+			osi_config.darwin_cmdline ? " via cmdline" :
+			osi_config.darwin_dmi ? " via DMI" : "");
 	}
 
 	return supported;
@@ -1783,6 +1785,44 @@ void __init acpi_osi_setup(char *str)
 	}
 }
 
+static void __init set_osi_darwin(unsigned int enable)
+{
+	if (osi_config.darwin_enable != enable)
+		osi_config.darwin_enable = enable;
+
+	if (enable) {
+		acpi_osi_setup("!");
+		acpi_osi_setup("Darwin");
+	} else {
+		acpi_osi_setup("!!");
+		acpi_osi_setup("!Darwin");
+	}
+}
+
+static void __init acpi_cmdline_osi_darwin(unsigned int enable)
+{
+	/* cmdline set the default and override DMI */
+	osi_config.darwin_cmdline = 1;
+	osi_config.darwin_dmi = 0;
+	set_osi_darwin(enable);
+
+	return;
+}
+
+void __init acpi_dmi_osi_darwin(int enable, const struct dmi_system_id *d)
+{
+	printk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);
+
+	if (enable == -1)
+		return;
+
+	/* DMI knows that this box asks OSI(Darwin) */
+	osi_config.darwin_dmi = 1;
+	set_osi_darwin(enable);
+
+	return;
+}
+
 static void __init set_osi_linux(unsigned int enable)
 {
 	if (osi_config.linux_enable != enable)
@@ -1870,6 +1910,10 @@ static int __init osi_setup(char *str)
 		acpi_cmdline_osi_linux(1);
 	else if (str && !strcmp("!Linux", str))
 		acpi_cmdline_osi_linux(0);
+	else if (str && !strcmp("Darwin", str))
+		acpi_cmdline_osi_darwin(1);
+	else if (str && !strcmp("!Darwin", str))
+		acpi_cmdline_osi_darwin(0);
 	else
 		acpi_osi_setup(str);
 

commit a707edebadf1230f202000f29b28b7586ada4aa3
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue May 3 16:48:32 2016 +0800

    ACPI / osi: Add acpi_osi=!! to allow reverting acpi_osi=!
    
    This patch introduces acpi_osi=!! so that quirks may use it to revert
    acpi_osi=!.
    
    Tested-by: Lukas Wunner <lukas@wunner.de>
    Tested-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 9f59dd1a0af7..f801b59f2a94 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1763,6 +1763,9 @@ void __init acpi_osi_setup(char *str)
 				osi->enable = false;
 			}
 			return;
+		} else if (*str == '!') {
+			osi_config.default_disabling = 0;
+			return;
 		}
 		enable = false;
 	}

commit dbee890bf69ad62c021e299e24881fdcd1f2c481
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue May 3 16:48:27 2016 +0800

    ACPI / osi: Cleanup _OSI("Linux") related code before introducing new support
    
    This patch cleans up OSI code in osl.c to make osi_linux work for OSI
    strings other than "Linux", so it can be re-used for other purposes.
    
    Tested-by: Lukas Wunner <lukas@wunner.de>
    Tested-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index f03677588b9d..9f59dd1a0af7 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -131,12 +131,12 @@ static void __init acpi_osi_setup_late(void);
  * or boot with "acpi_osi=Linux"
  */
 
-static struct osi_linux {
-	unsigned int	enable:1;
-	unsigned int	dmi:1;
-	unsigned int	cmdline:1;
+static struct acpi_osi_config {
+	unsigned int	linux_enable:1;
+	unsigned int	linux_dmi:1;
+	unsigned int	linux_cmdline:1;
 	u8		default_disabling;
-} osi_linux = {0, 0, 0, 0};
+} osi_config = {0, 0, 0, 0};
 
 static u32 acpi_osi_handler(acpi_string interface, u32 supported)
 {
@@ -144,9 +144,9 @@ static u32 acpi_osi_handler(acpi_string interface, u32 supported)
 
 		printk_once(KERN_NOTICE FW_BUG PREFIX
 			"BIOS _OSI(Linux) query %s%s\n",
-			osi_linux.enable ? "honored" : "ignored",
-			osi_linux.cmdline ? " via cmdline" :
-			osi_linux.dmi ? " via DMI" : "");
+			osi_config.linux_enable ? "honored" : "ignored",
+			osi_config.linux_cmdline ? " via cmdline" :
+			osi_config.linux_dmi ? " via DMI" : "");
 	}
 
 	if (!strcmp("Darwin", interface)) {
@@ -1752,12 +1752,12 @@ void __init acpi_osi_setup(char *str)
 		str++;
 		if (*str == '\0') {
 			/* Do not override acpi_osi=!* */
-			if (!osi_linux.default_disabling)
-				osi_linux.default_disabling =
+			if (!osi_config.default_disabling)
+				osi_config.default_disabling =
 					ACPI_DISABLE_ALL_VENDOR_STRINGS;
 			return;
 		} else if (*str == '*') {
-			osi_linux.default_disabling = ACPI_DISABLE_ALL_STRINGS;
+			osi_config.default_disabling = ACPI_DISABLE_ALL_STRINGS;
 			for (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {
 				osi = &osi_setup_entries[i];
 				osi->enable = false;
@@ -1782,10 +1782,10 @@ void __init acpi_osi_setup(char *str)
 
 static void __init set_osi_linux(unsigned int enable)
 {
-	if (osi_linux.enable != enable)
-		osi_linux.enable = enable;
+	if (osi_config.linux_enable != enable)
+		osi_config.linux_enable = enable;
 
-	if (osi_linux.enable)
+	if (osi_config.linux_enable)
 		acpi_osi_setup("Linux");
 	else
 		acpi_osi_setup("!Linux");
@@ -1795,8 +1795,9 @@ static void __init set_osi_linux(unsigned int enable)
 
 static void __init acpi_cmdline_osi_linux(unsigned int enable)
 {
-	osi_linux.cmdline = 1;	/* cmdline set the default and override DMI */
-	osi_linux.dmi = 0;
+	/* cmdline set the default and override DMI */
+	osi_config.linux_cmdline = 1;
+	osi_config.linux_dmi = 0;
 	set_osi_linux(enable);
 
 	return;
@@ -1809,7 +1810,8 @@ void __init acpi_dmi_osi_linux(int enable, const struct dmi_system_id *d)
 	if (enable == -1)
 		return;
 
-	osi_linux.dmi = 1;	/* DMI knows that this box asks OSI(Linux) */
+	/* DMI knows that this box asks OSI(Linux) */
+	osi_config.linux_dmi = 1;
 	set_osi_linux(enable);
 
 	return;
@@ -1829,12 +1831,12 @@ static void __init acpi_osi_setup_late(void)
 	int i;
 	acpi_status status;
 
-	if (osi_linux.default_disabling) {
-		status = acpi_update_interfaces(osi_linux.default_disabling);
+	if (osi_config.default_disabling) {
+		status = acpi_update_interfaces(osi_config.default_disabling);
 
 		if (ACPI_SUCCESS(status))
 			printk(KERN_INFO PREFIX "Disabled all _OSI OS vendors%s\n",
-				osi_linux.default_disabling ==
+				osi_config.default_disabling ==
 				ACPI_DISABLE_ALL_STRINGS ?
 				" and feature groups" : "");
 	}

commit 30c9bb0d7603e7b3f4d6a0ea231e1cddae020c32
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue May 3 16:48:20 2016 +0800

    ACPI / osi: Fix an issue that acpi_osi=!* cannot disable ACPICA internal strings
    
    The order of the _OSI related functionalities is as follows:
    
      acpi_blacklisted()
        acpi_dmi_osi_linux()
          acpi_osi_setup()
        acpi_osi_setup()
          acpi_update_interfaces() if "!*"
          <<<<<<<<<<<<<<<<<<<<<<<<
      parse_args()
        __setup("acpi_osi=")
          acpi_osi_setup_linux()
            acpi_update_interfaces() if "!*"
            <<<<<<<<<<<<<<<<<<<<<<<<
      acpi_early_init()
        acpi_initialize_subsystem()
          acpi_ut_initialize_interfaces()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      acpi_bus_init()
        acpi_os_initialize1()
          acpi_install_interface_handler(acpi_osi_handler)
          acpi_osi_setup_late()
            acpi_update_interfaces() for "!"
            >>>>>>>>>>>>>>>>>>>>>>>>
      acpi_osi_handler()
    
    Since acpi_osi_setup_linux() can override acpi_dmi_osi_linux(), the command
    line setting can override the DMI detection. That's why acpi_blacklisted()
    is put before __setup("acpi_osi=").
    
    Then we can notice the following wrong invocation order. There are
    acpi_update_interfaces() (marked by <<<<) calls invoked before
    acpi_ut_initialize_interfaces() (marked by ^^^^). This makes it impossible
    to use acpi_osi=!* correctly from OSI DMI table or from the command line.
    The use of acpi_osi=!* is meant to disable both ACPICA
    (acpi_gbl_supported_interfaces) and Linux specific strings
    (osi_setup_entries) while the ACPICA part should have stopped working
    because of the order issue.
    
    This patch fixes this issue by moving acpi_update_interfaces() to where
    it is invoked for acpi_osi=! (marked by >>>>) as this is ensured to be
    invoked after acpi_ut_initialize_interfaces() (marked by ^^^^). Linux
    specific strings are still handled in the original place in order to make
    the following command line working: acpi_osi=!* acpi_osi="Module Device".
    
    Note that since acpi_osi=!* is meant to further disable linux specific
    string comparing to the acpi_osi=!, there is no such use case in our bug
    fixing work and hence there is no one using acpi_osi=!* either from the
    command line or from the DMI quirks, this issue is just a theoretical
    issue.
    
    Fixes: 741d81280ad2 (ACPI: Add facility to remove all _OSI strings)
    Cc: 3.12+ <stable@vger.kernel.org> # 3.12+
    Tested-by: Lukas Wunner <lukas@wunner.de>
    Tested-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 814d5f83b75e..f03677588b9d 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -135,7 +135,7 @@ static struct osi_linux {
 	unsigned int	enable:1;
 	unsigned int	dmi:1;
 	unsigned int	cmdline:1;
-	unsigned int	default_disabling:1;
+	u8		default_disabling;
 } osi_linux = {0, 0, 0, 0};
 
 static u32 acpi_osi_handler(acpi_string interface, u32 supported)
@@ -1751,10 +1751,13 @@ void __init acpi_osi_setup(char *str)
 	if (*str == '!') {
 		str++;
 		if (*str == '\0') {
-			osi_linux.default_disabling = 1;
+			/* Do not override acpi_osi=!* */
+			if (!osi_linux.default_disabling)
+				osi_linux.default_disabling =
+					ACPI_DISABLE_ALL_VENDOR_STRINGS;
 			return;
 		} else if (*str == '*') {
-			acpi_update_interfaces(ACPI_DISABLE_ALL_STRINGS);
+			osi_linux.default_disabling = ACPI_DISABLE_ALL_STRINGS;
 			for (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {
 				osi = &osi_setup_entries[i];
 				osi->enable = false;
@@ -1827,10 +1830,13 @@ static void __init acpi_osi_setup_late(void)
 	acpi_status status;
 
 	if (osi_linux.default_disabling) {
-		status = acpi_update_interfaces(ACPI_DISABLE_ALL_VENDOR_STRINGS);
+		status = acpi_update_interfaces(osi_linux.default_disabling);
 
 		if (ACPI_SUCCESS(status))
-			printk(KERN_INFO PREFIX "Disabled all _OSI OS vendors\n");
+			printk(KERN_INFO PREFIX "Disabled all _OSI OS vendors%s\n",
+				osi_linux.default_disabling ==
+				ACPI_DISABLE_ALL_STRINGS ?
+				" and feature groups" : "");
 	}
 
 	for (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {

commit 5ae74f2cc2f150c1a5cee54cabbd71dd0661285a
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Apr 11 10:13:18 2016 +0800

    ACPI / tables: Move table override mechanisms to tables.c
    
    This patch moves acpi_os_table_override() and
    acpi_os_physical_table_override() to tables.c.
    
    Along with the mechanisms, acpi_initrd_initialize_tables() is also moved to
    tables.c to form a static function. The following functions are renamed
    according to this change:
     1. acpi_initrd_override() -> renamed to early_acpi_table_init(), which
        invokes acpi_table_initrd_init()
     2. acpi_os_physical_table_override() -> which invokes
        acpi_table_initrd_override()
     3. acpi_initialize_initrd_tables() -> renamed to acpi_table_initrd_scan()
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 814d5f83b75e..0796ad96dc32 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -602,280 +602,6 @@ acpi_os_predefined_override(const struct acpi_predefined_names *init_val,
 	return AE_OK;
 }
 
-static void acpi_table_taint(struct acpi_table_header *table)
-{
-	pr_warn(PREFIX
-		"Override [%4.4s-%8.8s], this is unsafe: tainting kernel\n",
-		table->signature, table->oem_table_id);
-	add_taint(TAINT_OVERRIDDEN_ACPI_TABLE, LOCKDEP_NOW_UNRELIABLE);
-}
-
-#ifdef CONFIG_ACPI_INITRD_TABLE_OVERRIDE
-#include <linux/earlycpio.h>
-#include <linux/memblock.h>
-
-static u64 acpi_tables_addr;
-static int all_tables_size;
-
-/* Copied from acpica/tbutils.c:acpi_tb_checksum() */
-static u8 __init acpi_table_checksum(u8 *buffer, u32 length)
-{
-	u8 sum = 0;
-	u8 *end = buffer + length;
-
-	while (buffer < end)
-		sum = (u8) (sum + *(buffer++));
-	return sum;
-}
-
-/* All but ACPI_SIG_RSDP and ACPI_SIG_FACS: */
-static const char * const table_sigs[] = {
-	ACPI_SIG_BERT, ACPI_SIG_CPEP, ACPI_SIG_ECDT, ACPI_SIG_EINJ,
-	ACPI_SIG_ERST, ACPI_SIG_HEST, ACPI_SIG_MADT, ACPI_SIG_MSCT,
-	ACPI_SIG_SBST, ACPI_SIG_SLIT, ACPI_SIG_SRAT, ACPI_SIG_ASF,
-	ACPI_SIG_BOOT, ACPI_SIG_DBGP, ACPI_SIG_DMAR, ACPI_SIG_HPET,
-	ACPI_SIG_IBFT, ACPI_SIG_IVRS, ACPI_SIG_MCFG, ACPI_SIG_MCHI,
-	ACPI_SIG_SLIC, ACPI_SIG_SPCR, ACPI_SIG_SPMI, ACPI_SIG_TCPA,
-	ACPI_SIG_UEFI, ACPI_SIG_WAET, ACPI_SIG_WDAT, ACPI_SIG_WDDT,
-	ACPI_SIG_WDRT, ACPI_SIG_DSDT, ACPI_SIG_FADT, ACPI_SIG_PSDT,
-	ACPI_SIG_RSDT, ACPI_SIG_XSDT, ACPI_SIG_SSDT, NULL };
-
-#define ACPI_HEADER_SIZE sizeof(struct acpi_table_header)
-
-#define ACPI_OVERRIDE_TABLES 64
-static struct cpio_data __initdata acpi_initrd_files[ACPI_OVERRIDE_TABLES];
-static DECLARE_BITMAP(acpi_initrd_installed, ACPI_OVERRIDE_TABLES);
-
-#define MAP_CHUNK_SIZE   (NR_FIX_BTMAPS << PAGE_SHIFT)
-
-void __init acpi_initrd_override(void *data, size_t size)
-{
-	int sig, no, table_nr = 0, total_offset = 0;
-	long offset = 0;
-	struct acpi_table_header *table;
-	char cpio_path[32] = "kernel/firmware/acpi/";
-	struct cpio_data file;
-
-	if (data == NULL || size == 0)
-		return;
-
-	for (no = 0; no < ACPI_OVERRIDE_TABLES; no++) {
-		file = find_cpio_data(cpio_path, data, size, &offset);
-		if (!file.data)
-			break;
-
-		data += offset;
-		size -= offset;
-
-		if (file.size < sizeof(struct acpi_table_header)) {
-			pr_err("ACPI OVERRIDE: Table smaller than ACPI header [%s%s]\n",
-				cpio_path, file.name);
-			continue;
-		}
-
-		table = file.data;
-
-		for (sig = 0; table_sigs[sig]; sig++)
-			if (!memcmp(table->signature, table_sigs[sig], 4))
-				break;
-
-		if (!table_sigs[sig]) {
-			pr_err("ACPI OVERRIDE: Unknown signature [%s%s]\n",
-				cpio_path, file.name);
-			continue;
-		}
-		if (file.size != table->length) {
-			pr_err("ACPI OVERRIDE: File length does not match table length [%s%s]\n",
-				cpio_path, file.name);
-			continue;
-		}
-		if (acpi_table_checksum(file.data, table->length)) {
-			pr_err("ACPI OVERRIDE: Bad table checksum [%s%s]\n",
-				cpio_path, file.name);
-			continue;
-		}
-
-		pr_info("%4.4s ACPI table found in initrd [%s%s][0x%x]\n",
-			table->signature, cpio_path, file.name, table->length);
-
-		all_tables_size += table->length;
-		acpi_initrd_files[table_nr].data = file.data;
-		acpi_initrd_files[table_nr].size = file.size;
-		table_nr++;
-	}
-	if (table_nr == 0)
-		return;
-
-	acpi_tables_addr =
-		memblock_find_in_range(0, max_low_pfn_mapped << PAGE_SHIFT,
-				       all_tables_size, PAGE_SIZE);
-	if (!acpi_tables_addr) {
-		WARN_ON(1);
-		return;
-	}
-	/*
-	 * Only calling e820_add_reserve does not work and the
-	 * tables are invalid (memory got used) later.
-	 * memblock_reserve works as expected and the tables won't get modified.
-	 * But it's not enough on X86 because ioremap will
-	 * complain later (used by acpi_os_map_memory) that the pages
-	 * that should get mapped are not marked "reserved".
-	 * Both memblock_reserve and e820_add_region (via arch_reserve_mem_area)
-	 * works fine.
-	 */
-	memblock_reserve(acpi_tables_addr, all_tables_size);
-	arch_reserve_mem_area(acpi_tables_addr, all_tables_size);
-
-	/*
-	 * early_ioremap only can remap 256k one time. If we map all
-	 * tables one time, we will hit the limit. Need to map chunks
-	 * one by one during copying the same as that in relocate_initrd().
-	 */
-	for (no = 0; no < table_nr; no++) {
-		unsigned char *src_p = acpi_initrd_files[no].data;
-		phys_addr_t size = acpi_initrd_files[no].size;
-		phys_addr_t dest_addr = acpi_tables_addr + total_offset;
-		phys_addr_t slop, clen;
-		char *dest_p;
-
-		total_offset += size;
-
-		while (size) {
-			slop = dest_addr & ~PAGE_MASK;
-			clen = size;
-			if (clen > MAP_CHUNK_SIZE - slop)
-				clen = MAP_CHUNK_SIZE - slop;
-			dest_p = early_ioremap(dest_addr & PAGE_MASK,
-						 clen + slop);
-			memcpy(dest_p + slop, src_p, clen);
-			early_iounmap(dest_p, clen + slop);
-			src_p += clen;
-			dest_addr += clen;
-			size -= clen;
-		}
-	}
-}
-
-acpi_status
-acpi_os_physical_table_override(struct acpi_table_header *existing_table,
-				acpi_physical_address *address, u32 *length)
-{
-	int table_offset = 0;
-	int table_index = 0;
-	struct acpi_table_header *table;
-	u32 table_length;
-
-	*length = 0;
-	*address = 0;
-	if (!acpi_tables_addr)
-		return AE_OK;
-
-	while (table_offset + ACPI_HEADER_SIZE <= all_tables_size) {
-		table = acpi_os_map_memory(acpi_tables_addr + table_offset,
-					   ACPI_HEADER_SIZE);
-		if (table_offset + table->length > all_tables_size) {
-			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
-			WARN_ON(1);
-			return AE_OK;
-		}
-
-		table_length = table->length;
-
-		/* Only override tables matched */
-		if (test_bit(table_index, acpi_initrd_installed) ||
-		    memcmp(existing_table->signature, table->signature, 4) ||
-		    memcmp(table->oem_table_id, existing_table->oem_table_id,
-			   ACPI_OEM_TABLE_ID_SIZE)) {
-			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
-			goto next_table;
-		}
-
-		*length = table_length;
-		*address = acpi_tables_addr + table_offset;
-		acpi_table_taint(existing_table);
-		acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
-		set_bit(table_index, acpi_initrd_installed);
-		break;
-
-next_table:
-		table_offset += table_length;
-		table_index++;
-	}
-	return AE_OK;
-}
-
-void __init acpi_initrd_initialize_tables(void)
-{
-	int table_offset = 0;
-	int table_index = 0;
-	u32 table_length;
-	struct acpi_table_header *table;
-
-	if (!acpi_tables_addr)
-		return;
-
-	while (table_offset + ACPI_HEADER_SIZE <= all_tables_size) {
-		table = acpi_os_map_memory(acpi_tables_addr + table_offset,
-					   ACPI_HEADER_SIZE);
-		if (table_offset + table->length > all_tables_size) {
-			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
-			WARN_ON(1);
-			return;
-		}
-
-		table_length = table->length;
-
-		/* Skip RSDT/XSDT which should only be used for override */
-		if (test_bit(table_index, acpi_initrd_installed) ||
-		    ACPI_COMPARE_NAME(table->signature, ACPI_SIG_RSDT) ||
-		    ACPI_COMPARE_NAME(table->signature, ACPI_SIG_XSDT)) {
-			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
-			goto next_table;
-		}
-
-		acpi_table_taint(table);
-		acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
-		acpi_install_table(acpi_tables_addr + table_offset, TRUE);
-		set_bit(table_index, acpi_initrd_installed);
-next_table:
-		table_offset += table_length;
-		table_index++;
-	}
-}
-#else
-acpi_status
-acpi_os_physical_table_override(struct acpi_table_header *existing_table,
-				acpi_physical_address *address,
-				u32 *table_length)
-{
-	*table_length = 0;
-	*address = 0;
-	return AE_OK;
-}
-
-void __init acpi_initrd_initialize_tables(void)
-{
-}
-#endif /* CONFIG_ACPI_INITRD_TABLE_OVERRIDE */
-
-acpi_status
-acpi_os_table_override(struct acpi_table_header *existing_table,
-		       struct acpi_table_header **new_table)
-{
-	if (!existing_table || !new_table)
-		return AE_BAD_PARAMETER;
-
-	*new_table = NULL;
-
-#ifdef CONFIG_ACPI_CUSTOM_DSDT
-	if (strncmp(existing_table->signature, "DSDT", 4) == 0)
-		*new_table = (struct acpi_table_header *)AmlCode;
-#endif
-	if (*new_table != NULL)
-		acpi_table_taint(existing_table);
-	return AE_OK;
-}
-
 static irqreturn_t acpi_irq(int irq, void *dev_id)
 {
 	u32 handled;

commit 80b28810cc98aadc80e7ce8cc155a774a7ada8ca
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Mar 24 09:38:28 2016 +0800

    ACPICA: Linuxize: reduce divergences for 20160212 release
    
    The patch reduces source code differences between the Linux kernel and the
    ACPICA upstream so that the linuxized ACPICA 20160212 release can be
    applied with reduced human intervention.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    [ rjw: White space damage fixes ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 814d5f83b75e..bef06c9503cd 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -582,7 +582,7 @@ static char acpi_os_name[ACPI_MAX_OVERRIDE_LEN];
 
 acpi_status
 acpi_os_predefined_override(const struct acpi_predefined_names *init_val,
-			    char **new_val)
+			    acpi_string *new_val)
 {
 	if (!init_val || !new_val)
 		return AE_BAD_PARAMETER;

commit c85cc817e5b6c45a78c3b34170dfeb6469b56d82
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Mar 2 14:16:25 2016 +0800

    ACPI / OSL: Add support to install tables via initrd
    
    This patch adds support to install tables from initrd.
    
    If a table in the initrd wasn't used by the override mechanism,
    the table would be installed after initializing all RSDT/XSDT
    tables.
    
    Link: https://lkml.org/lkml/2014/2/28/368
    Reported-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index a8c417c2f480..814d5f83b75e 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -644,6 +644,7 @@ static const char * const table_sigs[] = {
 
 #define ACPI_OVERRIDE_TABLES 64
 static struct cpio_data __initdata acpi_initrd_files[ACPI_OVERRIDE_TABLES];
+static DECLARE_BITMAP(acpi_initrd_installed, ACPI_OVERRIDE_TABLES);
 
 #define MAP_CHUNK_SIZE   (NR_FIX_BTMAPS << PAGE_SHIFT)
 
@@ -760,6 +761,7 @@ acpi_os_physical_table_override(struct acpi_table_header *existing_table,
 				acpi_physical_address *address, u32 *length)
 {
 	int table_offset = 0;
+	int table_index = 0;
 	struct acpi_table_header *table;
 	u32 table_length;
 
@@ -780,7 +782,8 @@ acpi_os_physical_table_override(struct acpi_table_header *existing_table,
 		table_length = table->length;
 
 		/* Only override tables matched */
-		if (memcmp(existing_table->signature, table->signature, 4) ||
+		if (test_bit(table_index, acpi_initrd_installed) ||
+		    memcmp(existing_table->signature, table->signature, 4) ||
 		    memcmp(table->oem_table_id, existing_table->oem_table_id,
 			   ACPI_OEM_TABLE_ID_SIZE)) {
 			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
@@ -791,13 +794,54 @@ acpi_os_physical_table_override(struct acpi_table_header *existing_table,
 		*address = acpi_tables_addr + table_offset;
 		acpi_table_taint(existing_table);
 		acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
+		set_bit(table_index, acpi_initrd_installed);
 		break;
 
 next_table:
 		table_offset += table_length;
+		table_index++;
 	}
 	return AE_OK;
 }
+
+void __init acpi_initrd_initialize_tables(void)
+{
+	int table_offset = 0;
+	int table_index = 0;
+	u32 table_length;
+	struct acpi_table_header *table;
+
+	if (!acpi_tables_addr)
+		return;
+
+	while (table_offset + ACPI_HEADER_SIZE <= all_tables_size) {
+		table = acpi_os_map_memory(acpi_tables_addr + table_offset,
+					   ACPI_HEADER_SIZE);
+		if (table_offset + table->length > all_tables_size) {
+			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
+			WARN_ON(1);
+			return;
+		}
+
+		table_length = table->length;
+
+		/* Skip RSDT/XSDT which should only be used for override */
+		if (test_bit(table_index, acpi_initrd_installed) ||
+		    ACPI_COMPARE_NAME(table->signature, ACPI_SIG_RSDT) ||
+		    ACPI_COMPARE_NAME(table->signature, ACPI_SIG_XSDT)) {
+			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
+			goto next_table;
+		}
+
+		acpi_table_taint(table);
+		acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
+		acpi_install_table(acpi_tables_addr + table_offset, TRUE);
+		set_bit(table_index, acpi_initrd_installed);
+next_table:
+		table_offset += table_length;
+		table_index++;
+	}
+}
 #else
 acpi_status
 acpi_os_physical_table_override(struct acpi_table_header *existing_table,
@@ -808,6 +852,10 @@ acpi_os_physical_table_override(struct acpi_table_header *existing_table,
 	*address = 0;
 	return AE_OK;
 }
+
+void __init acpi_initrd_initialize_tables(void)
+{
+}
 #endif /* CONFIG_ACPI_INITRD_TABLE_OVERRIDE */
 
 acpi_status

commit a543132ee04d1599a0abe913eaf43d1986021d24
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Mar 2 14:16:17 2016 +0800

    ACPI / OSL: Clean up initrd table override code
    
    This patch cleans up the initrd table override code by merging
    redundant logics and re-ordering code blocks.
    
    No functional changes.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 67da6fb72274..a8c417c2f480 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -602,6 +602,14 @@ acpi_os_predefined_override(const struct acpi_predefined_names *init_val,
 	return AE_OK;
 }
 
+static void acpi_table_taint(struct acpi_table_header *table)
+{
+	pr_warn(PREFIX
+		"Override [%4.4s-%8.8s], this is unsafe: tainting kernel\n",
+		table->signature, table->oem_table_id);
+	add_taint(TAINT_OVERRIDDEN_ACPI_TABLE, LOCKDEP_NOW_UNRELIABLE);
+}
+
 #ifdef CONFIG_ACPI_INITRD_TABLE_OVERRIDE
 #include <linux/earlycpio.h>
 #include <linux/memblock.h>
@@ -746,96 +754,78 @@ void __init acpi_initrd_override(void *data, size_t size)
 		}
 	}
 }
-#endif /* CONFIG_ACPI_INITRD_TABLE_OVERRIDE */
-
-static void acpi_table_taint(struct acpi_table_header *table)
-{
-	pr_warn(PREFIX
-		"Override [%4.4s-%8.8s], this is unsafe: tainting kernel\n",
-		table->signature, table->oem_table_id);
-	add_taint(TAINT_OVERRIDDEN_ACPI_TABLE, LOCKDEP_NOW_UNRELIABLE);
-}
-
-
-acpi_status
-acpi_os_table_override(struct acpi_table_header * existing_table,
-		       struct acpi_table_header ** new_table)
-{
-	if (!existing_table || !new_table)
-		return AE_BAD_PARAMETER;
-
-	*new_table = NULL;
-
-#ifdef CONFIG_ACPI_CUSTOM_DSDT
-	if (strncmp(existing_table->signature, "DSDT", 4) == 0)
-		*new_table = (struct acpi_table_header *)AmlCode;
-#endif
-	if (*new_table != NULL)
-		acpi_table_taint(existing_table);
-	return AE_OK;
-}
 
 acpi_status
 acpi_os_physical_table_override(struct acpi_table_header *existing_table,
-				acpi_physical_address *address,
-				u32 *table_length)
+				acpi_physical_address *address, u32 *length)
 {
-#ifndef CONFIG_ACPI_INITRD_TABLE_OVERRIDE
-	*table_length = 0;
-	*address = 0;
-	return AE_OK;
-#else
 	int table_offset = 0;
 	struct acpi_table_header *table;
+	u32 table_length;
 
-	*table_length = 0;
+	*length = 0;
 	*address = 0;
-
 	if (!acpi_tables_addr)
 		return AE_OK;
 
-	do {
-		if (table_offset + ACPI_HEADER_SIZE > all_tables_size) {
-			WARN_ON(1);
-			return AE_OK;
-		}
-
+	while (table_offset + ACPI_HEADER_SIZE <= all_tables_size) {
 		table = acpi_os_map_memory(acpi_tables_addr + table_offset,
 					   ACPI_HEADER_SIZE);
-
 		if (table_offset + table->length > all_tables_size) {
 			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
 			WARN_ON(1);
 			return AE_OK;
 		}
 
-		table_offset += table->length;
+		table_length = table->length;
 
-		if (memcmp(existing_table->signature, table->signature, 4)) {
-			acpi_os_unmap_memory(table,
-				     ACPI_HEADER_SIZE);
-			continue;
-		}
-
-		/* Only override tables with matching oem id */
-		if (memcmp(table->oem_table_id, existing_table->oem_table_id,
+		/* Only override tables matched */
+		if (memcmp(existing_table->signature, table->signature, 4) ||
+		    memcmp(table->oem_table_id, existing_table->oem_table_id,
 			   ACPI_OEM_TABLE_ID_SIZE)) {
-			acpi_os_unmap_memory(table,
-				     ACPI_HEADER_SIZE);
-			continue;
+			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
+			goto next_table;
 		}
 
-		table_offset -= table->length;
-		*table_length = table->length;
-		acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
+		*length = table_length;
 		*address = acpi_tables_addr + table_offset;
+		acpi_table_taint(existing_table);
+		acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
 		break;
-	} while (table_offset + ACPI_HEADER_SIZE < all_tables_size);
 
-	if (*address != 0)
-		acpi_table_taint(existing_table);
+next_table:
+		table_offset += table_length;
+	}
 	return AE_OK;
+}
+#else
+acpi_status
+acpi_os_physical_table_override(struct acpi_table_header *existing_table,
+				acpi_physical_address *address,
+				u32 *table_length)
+{
+	*table_length = 0;
+	*address = 0;
+	return AE_OK;
+}
+#endif /* CONFIG_ACPI_INITRD_TABLE_OVERRIDE */
+
+acpi_status
+acpi_os_table_override(struct acpi_table_header *existing_table,
+		       struct acpi_table_header **new_table)
+{
+	if (!existing_table || !new_table)
+		return AE_BAD_PARAMETER;
+
+	*new_table = NULL;
+
+#ifdef CONFIG_ACPI_CUSTOM_DSDT
+	if (strncmp(existing_table->signature, "DSDT", 4) == 0)
+		*new_table = (struct acpi_table_header *)AmlCode;
 #endif
+	if (*new_table != NULL)
+		acpi_table_taint(existing_table);
+	return AE_OK;
 }
 
 static irqreturn_t acpi_irq(int irq, void *dev_id)

commit 42d287d1a1e805ec98b5bdc4cca2660a56720ebd
Merge: b12745cce2c9 edc345d88462 76c599bcab26 9d128ed17c67 cd7f84c02825
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 12 01:10:03 2016 +0100

    Merge branches 'acpi-scan', 'acpi-bus', 'acpi-osl' and 'acpi-pm'
    
    * acpi-scan:
      ACPI: Fix white space in a structure definition
      ACPI / utils: Add acpi_dev_present()
      ACPI / scan: Fix acpi_bus_id_list bookkeeping
      ACPI / scan: set status to 0 if _STA failed
    
    * acpi-bus:
      ACPI / bus: Show _OSC UUID when _OSC fails
      ACPI / bus: Tidy up _OSC error spacing
    
    * acpi-osl:
      ACPI / OSL: Add kerneldoc comments to memory mapping functions
    
    * acpi-pm:
      ACPI / PM: Support D3 COLD device in old BIOS for ZPODD

commit 9d128ed17c672b1dffde4a328e9b3ee26d87a8f0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jan 2 03:10:29 2016 +0100

    ACPI / OSL: Add kerneldoc comments to memory mapping functions
    
    Add kerneldoc comments to acpi_os_map_iomem() and acpi_os_unmap_iomem()
    and explain why the latter needs the __ref annotation in one of them
    (as suggested by Mathias Krause).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Mathias Krause <minipli@googlemail.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 32d684af0ec7..d0ecf4efd79d 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -364,6 +364,19 @@ static void acpi_unmap(acpi_physical_address pg_off, void __iomem *vaddr)
 		iounmap(vaddr);
 }
 
+/**
+ * acpi_os_map_iomem - Get a virtual address for a given physical address range.
+ * @phys: Start of the physical address range to map.
+ * @size: Size of the physical address range to map.
+ *
+ * Look up the given physical address range in the list of existing ACPI memory
+ * mappings.  If found, get a reference to it and return a pointer to it (its
+ * virtual address).  If not found, map it, add it to that list and return a
+ * pointer to it.
+ *
+ * During early init (when acpi_gbl_permanent_mmap has not been set yet) this
+ * routine simply calls __acpi_map_table() to get the job done.
+ */
 void __iomem *__init_refok
 acpi_os_map_iomem(acpi_physical_address phys, acpi_size size)
 {
@@ -439,6 +452,20 @@ static void acpi_os_map_cleanup(struct acpi_ioremap *map)
 	}
 }
 
+/**
+ * acpi_os_unmap_iomem - Drop a memory mapping reference.
+ * @virt: Start of the address range to drop a reference to.
+ * @size: Size of the address range to drop a reference to.
+ *
+ * Look up the given virtual address range in the list of existing ACPI memory
+ * mappings, drop a reference to it and unmap it if there are no more active
+ * references to it.
+ *
+ * During early init (when acpi_gbl_permanent_mmap has not been set yet) this
+ * routine simply calls __acpi_unmap_table() to get the job done.  Since
+ * __acpi_unmap_table() is an __init function, the __ref annotation is needed
+ * here.
+ */
 void __ref acpi_os_unmap_iomem(void __iomem *virt, acpi_size size)
 {
 	struct acpi_ioremap *map;

commit 836d0830188a97d5c73e8eb514f346a857c086b9
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Dec 3 10:43:14 2015 +0800

    ACPI / debugger: Add module support for ACPI debugger
    
    This patch converts AML debugger into a loadable module.
    
    Note that, it implements driver unloading at the level dependent on the
    module reference count. Which means if ACPI debugger is being used by a
    userspace program, "rmmod acpi_dbg" should result in failure.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 4c1339819bfc..bb66093b7799 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -40,7 +40,6 @@
 #include <linux/list.h>
 #include <linux/jiffies.h>
 #include <linux/semaphore.h>
-#include <linux/acpi_dbg.h>
 
 #include <asm/io.h>
 #include <asm/uaccess.h>
@@ -221,6 +220,7 @@ void acpi_os_printf(const char *fmt, ...)
 	acpi_os_vprintf(fmt, args);
 	va_end(args);
 }
+EXPORT_SYMBOL(acpi_os_printf);
 
 void acpi_os_vprintf(const char *fmt, va_list args)
 {
@@ -235,7 +235,7 @@ void acpi_os_vprintf(const char *fmt, va_list args)
 		printk(KERN_CONT "%s", buffer);
 	}
 #else
-	if (acpi_aml_write_log(buffer) < 0)
+	if (acpi_debugger_write_log(buffer) < 0)
 		printk(KERN_CONT "%s", buffer);
 #endif
 }
@@ -1103,6 +1103,200 @@ static void acpi_os_execute_deferred(struct work_struct *work)
 	kfree(dpc);
 }
 
+#ifdef CONFIG_ACPI_DEBUGGER
+static struct acpi_debugger acpi_debugger;
+static bool acpi_debugger_initialized;
+
+int acpi_register_debugger(struct module *owner,
+			   const struct acpi_debugger_ops *ops)
+{
+	int ret = 0;
+
+	mutex_lock(&acpi_debugger.lock);
+	if (acpi_debugger.ops) {
+		ret = -EBUSY;
+		goto err_lock;
+	}
+
+	acpi_debugger.owner = owner;
+	acpi_debugger.ops = ops;
+
+err_lock:
+	mutex_unlock(&acpi_debugger.lock);
+	return ret;
+}
+EXPORT_SYMBOL(acpi_register_debugger);
+
+void acpi_unregister_debugger(const struct acpi_debugger_ops *ops)
+{
+	mutex_lock(&acpi_debugger.lock);
+	if (ops == acpi_debugger.ops) {
+		acpi_debugger.ops = NULL;
+		acpi_debugger.owner = NULL;
+	}
+	mutex_unlock(&acpi_debugger.lock);
+}
+EXPORT_SYMBOL(acpi_unregister_debugger);
+
+int acpi_debugger_create_thread(acpi_osd_exec_callback function, void *context)
+{
+	int ret;
+	int (*func)(acpi_osd_exec_callback, void *);
+	struct module *owner;
+
+	if (!acpi_debugger_initialized)
+		return -ENODEV;
+	mutex_lock(&acpi_debugger.lock);
+	if (!acpi_debugger.ops) {
+		ret = -ENODEV;
+		goto err_lock;
+	}
+	if (!try_module_get(acpi_debugger.owner)) {
+		ret = -ENODEV;
+		goto err_lock;
+	}
+	func = acpi_debugger.ops->create_thread;
+	owner = acpi_debugger.owner;
+	mutex_unlock(&acpi_debugger.lock);
+
+	ret = func(function, context);
+
+	mutex_lock(&acpi_debugger.lock);
+	module_put(owner);
+err_lock:
+	mutex_unlock(&acpi_debugger.lock);
+	return ret;
+}
+
+ssize_t acpi_debugger_write_log(const char *msg)
+{
+	ssize_t ret;
+	ssize_t (*func)(const char *);
+	struct module *owner;
+
+	if (!acpi_debugger_initialized)
+		return -ENODEV;
+	mutex_lock(&acpi_debugger.lock);
+	if (!acpi_debugger.ops) {
+		ret = -ENODEV;
+		goto err_lock;
+	}
+	if (!try_module_get(acpi_debugger.owner)) {
+		ret = -ENODEV;
+		goto err_lock;
+	}
+	func = acpi_debugger.ops->write_log;
+	owner = acpi_debugger.owner;
+	mutex_unlock(&acpi_debugger.lock);
+
+	ret = func(msg);
+
+	mutex_lock(&acpi_debugger.lock);
+	module_put(owner);
+err_lock:
+	mutex_unlock(&acpi_debugger.lock);
+	return ret;
+}
+
+ssize_t acpi_debugger_read_cmd(char *buffer, size_t buffer_length)
+{
+	ssize_t ret;
+	ssize_t (*func)(char *, size_t);
+	struct module *owner;
+
+	if (!acpi_debugger_initialized)
+		return -ENODEV;
+	mutex_lock(&acpi_debugger.lock);
+	if (!acpi_debugger.ops) {
+		ret = -ENODEV;
+		goto err_lock;
+	}
+	if (!try_module_get(acpi_debugger.owner)) {
+		ret = -ENODEV;
+		goto err_lock;
+	}
+	func = acpi_debugger.ops->read_cmd;
+	owner = acpi_debugger.owner;
+	mutex_unlock(&acpi_debugger.lock);
+
+	ret = func(buffer, buffer_length);
+
+	mutex_lock(&acpi_debugger.lock);
+	module_put(owner);
+err_lock:
+	mutex_unlock(&acpi_debugger.lock);
+	return ret;
+}
+
+int acpi_debugger_wait_command_ready(void)
+{
+	int ret;
+	int (*func)(bool, char *, size_t);
+	struct module *owner;
+
+	if (!acpi_debugger_initialized)
+		return -ENODEV;
+	mutex_lock(&acpi_debugger.lock);
+	if (!acpi_debugger.ops) {
+		ret = -ENODEV;
+		goto err_lock;
+	}
+	if (!try_module_get(acpi_debugger.owner)) {
+		ret = -ENODEV;
+		goto err_lock;
+	}
+	func = acpi_debugger.ops->wait_command_ready;
+	owner = acpi_debugger.owner;
+	mutex_unlock(&acpi_debugger.lock);
+
+	ret = func(acpi_gbl_method_executing,
+		   acpi_gbl_db_line_buf, ACPI_DB_LINE_BUFFER_SIZE);
+
+	mutex_lock(&acpi_debugger.lock);
+	module_put(owner);
+err_lock:
+	mutex_unlock(&acpi_debugger.lock);
+	return ret;
+}
+
+int acpi_debugger_notify_command_complete(void)
+{
+	int ret;
+	int (*func)(void);
+	struct module *owner;
+
+	if (!acpi_debugger_initialized)
+		return -ENODEV;
+	mutex_lock(&acpi_debugger.lock);
+	if (!acpi_debugger.ops) {
+		ret = -ENODEV;
+		goto err_lock;
+	}
+	if (!try_module_get(acpi_debugger.owner)) {
+		ret = -ENODEV;
+		goto err_lock;
+	}
+	func = acpi_debugger.ops->notify_command_complete;
+	owner = acpi_debugger.owner;
+	mutex_unlock(&acpi_debugger.lock);
+
+	ret = func();
+
+	mutex_lock(&acpi_debugger.lock);
+	module_put(owner);
+err_lock:
+	mutex_unlock(&acpi_debugger.lock);
+	return ret;
+}
+
+int __init acpi_debugger_init(void)
+{
+	mutex_init(&acpi_debugger.lock);
+	acpi_debugger_initialized = true;
+	return 0;
+}
+#endif
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_os_execute
@@ -1130,7 +1324,7 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 			  function, context));
 
 	if (type == OSL_DEBUGGER_MAIN_THREAD) {
-		ret = acpi_aml_create_thread(function, context);
+		ret = acpi_debugger_create_thread(function, context);
 		if (ret) {
 			pr_err("Call to kthread_create() failed.\n");
 			status = AE_ERROR;
@@ -1380,7 +1574,7 @@ acpi_status acpi_os_get_line(char *buffer, u32 buffer_length, u32 *bytes_read)
 #else
 	int ret;
 
-	ret = acpi_aml_read_cmd(buffer, buffer_length);
+	ret = acpi_debugger_read_cmd(buffer, buffer_length);
 	if (ret < 0)
 		return AE_ERROR;
 	if (bytes_read)
@@ -1389,12 +1583,13 @@ acpi_status acpi_os_get_line(char *buffer, u32 buffer_length, u32 *bytes_read)
 
 	return AE_OK;
 }
+EXPORT_SYMBOL(acpi_os_get_line);
 
 acpi_status acpi_os_wait_command_ready(void)
 {
 	int ret;
 
-	ret = acpi_aml_wait_command_ready();
+	ret = acpi_debugger_wait_command_ready();
 	if (ret < 0)
 		return AE_ERROR;
 	return AE_OK;
@@ -1404,7 +1599,7 @@ acpi_status acpi_os_notify_command_complete(void)
 {
 	int ret;
 
-	ret = acpi_aml_notify_command_complete();
+	ret = acpi_debugger_notify_command_complete();
 	if (ret < 0)
 		return AE_ERROR;
 	return AE_OK;

commit 8cfb0cdf07e2c260c4d1a102bfec35183907834f
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Dec 3 10:43:00 2015 +0800

    ACPI / debugger: Add IO interface to access debugger functionalities
    
    This patch adds /sys/kernel/debug/acpi/acpidbg, which can be used by
    userspace programs to access ACPICA debugger functionalities.
    
    Known issue:
    1. IO flush support
       acpi_os_notify_command_complete() and acpi_os_wait_command_ready() can
       be used by acpi_dbg module to implement .flush() filesystem operation.
       While this patch doesn't go that far. It then becomes userspace tool's
       duty now to flush old commands before executing new batch mode commands.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 32d684af0ec7..4c1339819bfc 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -40,6 +40,7 @@
 #include <linux/list.h>
 #include <linux/jiffies.h>
 #include <linux/semaphore.h>
+#include <linux/acpi_dbg.h>
 
 #include <asm/io.h>
 #include <asm/uaccess.h>
@@ -234,7 +235,8 @@ void acpi_os_vprintf(const char *fmt, va_list args)
 		printk(KERN_CONT "%s", buffer);
 	}
 #else
-	printk(KERN_CONT "%s", buffer);
+	if (acpi_aml_write_log(buffer) < 0)
+		printk(KERN_CONT "%s", buffer);
 #endif
 }
 
@@ -1127,6 +1129,15 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 			  "Scheduling function [%p(%p)] for deferred execution.\n",
 			  function, context));
 
+	if (type == OSL_DEBUGGER_MAIN_THREAD) {
+		ret = acpi_aml_create_thread(function, context);
+		if (ret) {
+			pr_err("Call to kthread_create() failed.\n");
+			status = AE_ERROR;
+		}
+		goto out_thread;
+	}
+
 	/*
 	 * Allocate/initialize DPC structure.  Note that this memory will be
 	 * freed by the callee.  The kernel handles the work_struct list  in a
@@ -1151,11 +1162,17 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 	if (type == OSL_NOTIFY_HANDLER) {
 		queue = kacpi_notify_wq;
 		INIT_WORK(&dpc->work, acpi_os_execute_deferred);
-	} else {
+	} else if (type == OSL_GPE_HANDLER) {
 		queue = kacpid_wq;
 		INIT_WORK(&dpc->work, acpi_os_execute_deferred);
+	} else {
+		pr_err("Unsupported os_execute type %d.\n", type);
+		status = AE_ERROR;
 	}
 
+	if (ACPI_FAILURE(status))
+		goto err_workqueue;
+
 	/*
 	 * On some machines, a software-initiated SMI causes corruption unless
 	 * the SMI runs on CPU 0.  An SMI can be initiated by any AML, but
@@ -1164,13 +1181,15 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 	 * queueing on CPU 0.
 	 */
 	ret = queue_work_on(0, queue, &dpc->work);
-
 	if (!ret) {
 		printk(KERN_ERR PREFIX
 			  "Call to queue_work() failed.\n");
 		status = AE_ERROR;
-		kfree(dpc);
 	}
+err_workqueue:
+	if (ACPI_FAILURE(status))
+		kfree(dpc);
+out_thread:
 	return status;
 }
 EXPORT_SYMBOL(acpi_os_execute);
@@ -1358,11 +1377,39 @@ acpi_status acpi_os_get_line(char *buffer, u32 buffer_length, u32 *bytes_read)
 		chars = strlen(buffer) - 1;
 		buffer[chars] = '\0';
 	}
+#else
+	int ret;
+
+	ret = acpi_aml_read_cmd(buffer, buffer_length);
+	if (ret < 0)
+		return AE_ERROR;
+	if (bytes_read)
+		*bytes_read = ret;
 #endif
 
 	return AE_OK;
 }
 
+acpi_status acpi_os_wait_command_ready(void)
+{
+	int ret;
+
+	ret = acpi_aml_wait_command_ready();
+	if (ret < 0)
+		return AE_ERROR;
+	return AE_OK;
+}
+
+acpi_status acpi_os_notify_command_complete(void)
+{
+	int ret;
+
+	ret = acpi_aml_notify_command_complete();
+	if (ret < 0)
+		return AE_ERROR;
+	return AE_OK;
+}
+
 acpi_status acpi_os_signal(u32 function, void *info)
 {
 	switch (function) {

commit 9cf5c095b65da63c08b928a7d0015d5d5dca8a66
Merge: 22402cd0af68 4008cb3ad223
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 6 14:22:15 2015 -0800

    Merge tag 'asm-generic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/asm-generic
    
    Pull asm-generic cleanups from Arnd Bergmann:
     "The asm-generic changes for 4.4 are mostly a series from Christoph
      Hellwig to clean up various abuses of headers in there.  The patch to
      rename the io-64-nonatomic-*.h headers caused some conflicts with new
      users, so I added a workaround that we can remove in the next merge
      window.
    
      The only other patch is a warning fix from Marek Vasut"
    
    * tag 'asm-generic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/asm-generic:
      asm-generic: temporarily add back asm-generic/io-64-nonatomic*.h
      asm-generic: cmpxchg: avoid warnings from macro-ized cmpxchg() implementations
      gpio-mxc: stop including <asm-generic/bug>
      n_tracesink: stop including <asm-generic/bug>
      n_tracerouter: stop including <asm-generic/bug>
      mlx5: stop including <asm-generic/kmap_types.h>
      hifn_795x: stop including <asm-generic/kmap_types.h>
      drbd: stop including <asm-generic/kmap_types.h>
      move count_zeroes.h out of asm-generic
      move io-64-nonatomic*.h out of asm-generic

commit 66c44877242d37873df2abb10e4fce26ff4fc9f9
Merge: 62839e2d0181 8c01275e0cdf 216574716885 584d8d1eb123 e58d154b6048
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 2 00:51:46 2015 +0100

    Merge branches 'acpi-osl', 'acpi-pad', 'acpi-video' and 'acpi-assorted'
    
    * acpi-osl:
      ACPI / PM: Fix incorrect wakeup IRQ setting during suspend-to-idle
      ACPI: Using correct irq when waiting for events
      ACPI: Use correct IRQ when uninstalling ACPI interrupt handler
    
    * acpi-pad:
      ACPI / PAD: power_saving_thread() is not freezable
    
    * acpi-video:
      ACPI / video: Add a quirk to force native backlight on Lenovo IdeaPad S405
    
    * acpi-assorted:
      ACPI / Documentation: add copy_dsdt to ACPI format options
      ACPI / sysfs: correctly check failing memory allocation

commit efb1cf7d28b8aeacec53e9ba8f3f2809c5cb9686
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Sun Oct 25 01:02:36 2015 +0800

    ACPI: Using correct irq when waiting for events
    
    When the system is waiting for GPE/fixed event handler to finish,
    it uses acpi_gbl_FADT.sci_interrupt directly as the IRQ number.
    However, the remapped IRQ returned by acpi_gsi_to_irq() should be
    passed to synchronize_hardirq() instead of it.
    
    Cc: 3.19+ <stable@vger.kernel.org> # 3.19+
    Acked-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 2a25919f8eab..2f6e3c6ad39b 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1183,8 +1183,8 @@ void acpi_os_wait_events_complete(void)
 	 * Make sure the GPE handler or the fixed event handler is not used
 	 * on another CPU after removal.
 	 */
-	if (acpi_irq_handler)
-		synchronize_hardirq(acpi_gbl_FADT.sci_interrupt);
+	if (acpi_sci_irq_valid())
+		synchronize_hardirq(acpi_sci_irq);
 	flush_workqueue(kacpid_wq);
 	flush_workqueue(kacpi_notify_wq);
 }

commit 49e4b84333f338d4f183f28f1f3c1131b9fb2b5a
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Sun Oct 25 01:02:19 2015 +0800

    ACPI: Use correct IRQ when uninstalling ACPI interrupt handler
    
    Currently when the system is trying to uninstall the ACPI interrupt
    handler, it uses acpi_gbl_FADT.sci_interrupt as the IRQ number.
    However, the IRQ number that the ACPI interrupt handled is installed
    for comes from acpi_gsi_to_irq() and that is the number that should
    be used for the handler removal.
    
    Fix this problem by using the mapped IRQ returned from acpi_gsi_to_irq()
    as appropriate.
    
    Cc: All applicable <stable@vger.kernel.org>
    Acked-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 739a4a6b3b9b..2a25919f8eab 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -81,6 +81,7 @@ static struct workqueue_struct *kacpid_wq;
 static struct workqueue_struct *kacpi_notify_wq;
 static struct workqueue_struct *kacpi_hotplug_wq;
 static bool acpi_os_initialized;
+unsigned int acpi_sci_irq = INVALID_ACPI_IRQ;
 
 /*
  * This list of permanent mappings is for memory that may be accessed from
@@ -856,17 +857,19 @@ acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,
 		acpi_irq_handler = NULL;
 		return AE_NOT_ACQUIRED;
 	}
+	acpi_sci_irq = irq;
 
 	return AE_OK;
 }
 
-acpi_status acpi_os_remove_interrupt_handler(u32 irq, acpi_osd_handler handler)
+acpi_status acpi_os_remove_interrupt_handler(u32 gsi, acpi_osd_handler handler)
 {
-	if (irq != acpi_gbl_FADT.sci_interrupt)
+	if (gsi != acpi_gbl_FADT.sci_interrupt || !acpi_sci_irq_valid())
 		return AE_BAD_PARAMETER;
 
-	free_irq(irq, acpi_irq);
+	free_irq(acpi_sci_irq, acpi_irq);
 	acpi_irq_handler = NULL;
+	acpi_sci_irq = INVALID_ACPI_IRQ;
 
 	return AE_OK;
 }

commit 4d946f7970e51d80f8358e0a619dfb17d89e0920
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Oct 19 10:25:56 2015 +0800

    ACPI: Enable build of AML interpreter debugger
    
    This patch enables ACPICA debugger files using a configurable
    CONFIG_ACPI_DEBUGGER configuration item. Those debugger related code that
    was originally masked as ACPI_FUTURE_USAGE now gets unmasked.
    
    Necessary OSL stubs are also added in this patch:
    1. acpi_os_readable(): This should be arch specific in Linux, while this
        patch doesn't introduce real implementation and a complex mechanism to
        allow architecture specific acpi_os_readable() to be implemented to
        validate the address. It may be done by future commits.
    2. acpi_os_get_line(): This is used to obtain debugger command input. This
        patch only introduces a simple KDB concept example in it and the
        example should be co-working with the code implemented in
        acpi_os_printf(). Since this KDB example won't be compiled unless
        ENABLE_DEBUGGER is defined and it seems Linux has already stopped to
        use ENABLE_DEBUGGER, thus do not expect it can work properly.
    
    This patch also cleans up all other ACPI_FUTURE_USAGE surroundings
    accordingly.
    1. Since linkage error can be automatically detected, declaration in the
       headers needn't be surrounded by ACPI_FUTURE_USAGE.
       So only the following separate exported fuction bodies are masked by
       this macro (other exported fucntions may have already been masked at
       entire module level via drivers/acpi/acpica/Makefile):
         acpi_install_exception_handler()
         acpi_subsystem_status()
         acpi_get_system_info()
         acpi_get_statistics()
         acpi_install_initialization_handler()
    2. Since strip can automatically zap the no-user functions, functions that
       are not marked with ACPI_EXPORT_SYMBOL() needn't get surrounded by
       ACPI_FUTURE_USAGE.
       So the following function which is not used by Linux kernel now won't
       get surrounded by this macro:
         acpi_ps_get_name()
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 739a4a6b3b9b..327291586f84 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -66,8 +66,6 @@ struct acpi_os_dpc {
 /* stuff for debugger support */
 int acpi_in_debugger;
 EXPORT_SYMBOL(acpi_in_debugger);
-
-extern char line_buf[80];
 #endif				/*ENABLE_DEBUGGER */
 
 static int (*__acpi_os_prepare_sleep)(u8 sleep_state, u32 pm1a_ctrl,
@@ -1345,15 +1343,13 @@ acpi_status acpi_os_signal_semaphore(acpi_handle handle, u32 units)
 	return AE_OK;
 }
 
-#ifdef ACPI_FUTURE_USAGE
-u32 acpi_os_get_line(char *buffer)
+acpi_status acpi_os_get_line(char *buffer, u32 buffer_length, u32 *bytes_read)
 {
-
 #ifdef ENABLE_DEBUGGER
 	if (acpi_in_debugger) {
 		u32 chars;
 
-		kdb_read(buffer, sizeof(line_buf));
+		kdb_read(buffer, buffer_length);
 
 		/* remove the CR kdb includes */
 		chars = strlen(buffer) - 1;
@@ -1361,9 +1357,8 @@ u32 acpi_os_get_line(char *buffer)
 	}
 #endif
 
-	return 0;
+	return AE_OK;
 }
-#endif				/*  ACPI_FUTURE_USAGE  */
 
 acpi_status acpi_os_signal(u32 function, void *info)
 {

commit 2f8e2c877784a0b23f02b41550170a24e14f5c95
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Aug 28 09:27:14 2015 +0200

    move io-64-nonatomic*.h out of asm-generic
    
    These are not implementations of default architecture code but helpers
    for drivers. Move them to the place they belong to.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Acked-by: Hitoshi Mitake <mitake.hitoshi@lab.ntt.co.jp>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 739a4a6b3b9b..7d0848190b75 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -43,7 +43,7 @@
 
 #include <asm/io.h>
 #include <asm/uaccess.h>
-#include <asm-generic/io-64-nonatomic-lo-hi.h>
+#include <linux/io-64-nonatomic-lo-hi.h>
 
 #include "internal.h"
 

commit 5d2a1a927d487d6bb60c87b837d82702d8ebcaad
Merge: ef5f5de069bd 5d0ddfebb930 b00855aecbb1 02b771b64b73 3277b4ea216e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 1 03:41:19 2015 +0200

    Merge branches 'acpi-pci', 'acpi-soc', 'acpi-ec' and 'acpi-osl'
    
    * acpi-pci:
      ACPI, PCI: Penalize legacy IRQ used by ACPI SCI
    
    * acpi-soc:
      ACPI / LPSS: Ignore 10ms delay for Braswell
    
    * acpi-ec:
      ACPI / EC: Fix an issue caused by the serialized _Qxx evaluations
    
    * acpi-osl:
      ACPI / osl: replace custom implementation of readq / writeq

commit 73990fc810bf84c5338d9596f8af8d70fe90ac72
Merge: 94f2bb9b599f 1dcc3d3362b0 b6fc6072b126 10742619ac63
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 1 03:38:22 2015 +0200

    Merge branches 'acpi-scan', 'acpi-processor' and 'acpi-assorted'
    
    * acpi-scan:
      ACPI / bus: Move ACPI bus type registration
      ACPI / scan: Move bus operations and notification routines to bus.c
      ACPI / scan: Move device matching code to bus.c
      ACPI / scan: Move sysfs-related device code to a separate file
    
    * acpi-processor:
      PCC: Disable compilation by default
      ACPI: Decouple ACPI idle and ACPI processor drivers
      ACPI: Split out ACPI PSS from ACPI Processor driver
      PCC: Initialize PCC Mailbox earlier at boot
      ACPI / processor: remove leftover __refdata annotations
    
    * acpi-assorted:
      ACPI: fix acpi_debugfs_init prototype
      ACPI: Remove FSF mailing addresses

commit 3277b4ea216e5cd7d3f6095ff40f1a9e574f37b3
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Aug 17 17:28:46 2015 +0300

    ACPI / osl: replace custom implementation of readq / writeq
    
    The readq() and writeq() helpers are available in the
    asm-generic/io-64-nonatomic-hi-lo.h and asm-generic/io-64-nonatomic-lo-hi.h
    headers. Replace custom implementation by the generic helpers.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 3b8963f21b36..64077e87477a 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -47,6 +47,7 @@
 
 #include <asm/io.h>
 #include <asm/uaccess.h>
+#include <asm-generic/io-64-nonatomic-lo-hi.h>
 
 #include "internal.h"
 
@@ -947,21 +948,6 @@ acpi_status acpi_os_write_port(acpi_io_address port, u32 value, u32 width)
 
 EXPORT_SYMBOL(acpi_os_write_port);
 
-#ifdef readq
-static inline u64 read64(const volatile void __iomem *addr)
-{
-	return readq(addr);
-}
-#else
-static inline u64 read64(const volatile void __iomem *addr)
-{
-	u64 l, h;
-	l = readl(addr);
-	h = readl(addr+4);
-	return l | (h << 32);
-}
-#endif
-
 acpi_status
 acpi_os_read_memory(acpi_physical_address phys_addr, u64 *value, u32 width)
 {
@@ -994,7 +980,7 @@ acpi_os_read_memory(acpi_physical_address phys_addr, u64 *value, u32 width)
 		*(u32 *) value = readl(virt_addr);
 		break;
 	case 64:
-		*(u64 *) value = read64(virt_addr);
+		*(u64 *) value = readq(virt_addr);
 		break;
 	default:
 		BUG();
@@ -1008,19 +994,6 @@ acpi_os_read_memory(acpi_physical_address phys_addr, u64 *value, u32 width)
 	return AE_OK;
 }
 
-#ifdef writeq
-static inline void write64(u64 val, volatile void __iomem *addr)
-{
-	writeq(val, addr);
-}
-#else
-static inline void write64(u64 val, volatile void __iomem *addr)
-{
-	writel(val, addr);
-	writel(val>>32, addr+4);
-}
-#endif
-
 acpi_status
 acpi_os_write_memory(acpi_physical_address phys_addr, u64 value, u32 width)
 {
@@ -1049,7 +1022,7 @@ acpi_os_write_memory(acpi_physical_address phys_addr, u64 value, u32 width)
 		writel(value, virt_addr);
 		break;
 	case 64:
-		write64(value, virt_addr);
+		writeq(value, virt_addr);
 		break;
 	default:
 		BUG();

commit 7901a052a981691d18f4e8f91fc27e40849b7336
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Aug 5 16:23:51 2015 +0800

    ACPI / sysfs: Update method tracing facility.
    
    This patch updates the method tracing facility as the acpi_debug_trace()
    API has been updated to allow it to trace AML interpreter execution, the
    meanings and the usages of the API parameters are changed due to the
    updates.
    
    The new API:
    1. Uses ACPI_TRACE_ENABLED flag to indicate the enabling of the tracer;
    2. Allows tracer still can be enabled when method name is not specified so
       that the AML interpreter execution can be traced without knowing the
       method name, which is useful for kernel boot tracing;
    3. Supports arbitrary full path name, it doesn't need to be a name related
       to an entrance of acpi_evaluate_object().
    
    Note that the sysfs parameters are also updated so that when reading the
    attribute files, ACPICA internal settings are returned.
    
    In order to make the sysfs parameters (acpi.trace_state) available during
    boot, this patch adds code to bypass ACPICA semaphore/mutex invocations
    when acpi mutex utilities haven't been initialized.
    
    This patch doesn't update documentation of method tracing facility, it will
    be updated by further patches.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 3b8963f21b36..6341cb523dc4 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -83,6 +83,7 @@ static void *acpi_irq_context;
 static struct workqueue_struct *kacpid_wq;
 static struct workqueue_struct *kacpi_notify_wq;
 static struct workqueue_struct *kacpi_hotplug_wq;
+static bool acpi_os_initialized;
 
 /*
  * This list of permanent mappings is for memory that may be accessed from
@@ -1316,6 +1317,9 @@ acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
 	long jiffies;
 	int ret = 0;
 
+	if (!acpi_os_initialized)
+		return AE_OK;
+
 	if (!sem || (units < 1))
 		return AE_BAD_PARAMETER;
 
@@ -1355,6 +1359,9 @@ acpi_status acpi_os_signal_semaphore(acpi_handle handle, u32 units)
 {
 	struct semaphore *sem = (struct semaphore *)handle;
 
+	if (!acpi_os_initialized)
+		return AE_OK;
+
 	if (!sem || (units < 1))
 		return AE_BAD_PARAMETER;
 
@@ -1863,6 +1870,7 @@ acpi_status __init acpi_os_initialize(void)
 		rv = acpi_os_map_generic_address(&acpi_gbl_FADT.reset_register);
 		pr_debug(PREFIX "%s: map reset_reg status %d\n", __func__, rv);
 	}
+	acpi_os_initialized = true;
 
 	return AE_OK;
 }

commit 4c62dbbce902cf2afa88cac89ec67c828160f431
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Jun 26 11:27:41 2015 +0300

    ACPI: Remove FSF mailing addresses
    
    There is no need to carry potentially outdated Free Software Foundation
    mailing address in file headers since the COPYING file includes it.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index c262e4acd68d..5e1f1bc5421e 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -19,10 +19,6 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
  */

commit 0294112ee3135fbd15eaa70015af8283642dd970
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jul 4 03:09:03 2015 +0200

    ACPI / PNP: Reserve ACPI resources at the fs_initcall_sync stage
    
    This effectively reverts the following three commits:
    
     7bc10388ccdd ACPI / resources: free memory on error in add_region_before()
     0f1b414d1907 ACPI / PNP: Avoid conflicting resource reservations
     b9a5e5e18fbf ACPI / init: Fix the ordering of acpi_reserve_resources()
    
    (commit b9a5e5e18fbf introduced regressions some of which, but not
    all, were addressed by commit 0f1b414d1907 and commit 7bc10388ccdd
    was a fixup on top of the latter) and causes ACPI fixed hardware
    resources to be reserved at the fs_initcall_sync stage of system
    initialization.
    
    The story is as follows.  First, a boot regression was reported due
    to an apparent resource reservation ordering change after a commit
    that shouldn't lead to such changes.  Investigation led to the
    conclusion that the problem happened because acpi_reserve_resources()
    was executed at the device_initcall() stage of system initialization
    which wasn't strictly ordered with respect to driver initialization
    (and with respect to the initialization of the pcieport driver in
    particular), so a random change causing the device initcalls to be
    run in a different order might break things.
    
    The response to that was to attempt to run acpi_reserve_resources()
    as soon as we knew that ACPI would be in use (commit b9a5e5e18fbf).
    However, that turned out to be too early, because it caused resource
    reservations made by the PNP system driver to fail on at least one
    system and that failure was addressed by commit 0f1b414d1907.
    
    That fix still turned out to be insufficient, though, because
    calling acpi_reserve_resources() before the fs_initcall stage of
    system initialization caused a boot regression to happen on the
    eCAFE EC-800-H20G/S netbook.  That meant that we only could call
    acpi_reserve_resources() at the fs_initcall initialization stage
    or later, but then we might just as well call it after the PNP
    initalization in which case commit 0f1b414d1907 wouldn't be
    necessary any more.
    
    For this reason, the changes made by commit 0f1b414d1907 are reverted
    (along with a memory leak fixup on top of that commit), the changes
    made by commit b9a5e5e18fbf that went too far are reverted too and
    acpi_reserve_resources() is changed into fs_initcall_sync, which
    will cause it to be executed after the PNP subsystem initialization
    (which is an fs_initcall) and before device initcalls (including
    the pcieport driver initialization) which should avoid the initial
    issue.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=100581
    Link: http://marc.info/?t=143092384600002&r=1&w=2
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=99831
    Link: http://marc.info/?t=143389402600001&r=1&w=2
    Fixes: b9a5e5e18fbf "ACPI / init: Fix the ordering of acpi_reserve_resources()"
    Reported-by: Roland Dreier <roland@purestorage.com>
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index c262e4acd68d..3b8963f21b36 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -175,10 +175,14 @@ static void __init acpi_request_region (struct acpi_generic_address *gas,
 	if (!addr || !length)
 		return;
 
-	acpi_reserve_region(addr, length, gas->space_id, 0, desc);
+	/* Resources are never freed */
+	if (gas->space_id == ACPI_ADR_SPACE_SYSTEM_IO)
+		request_region(addr, length, desc);
+	else if (gas->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)
+		request_mem_region(addr, length, desc);
 }
 
-static void __init acpi_reserve_resources(void)
+static int __init acpi_reserve_resources(void)
 {
 	acpi_request_region(&acpi_gbl_FADT.xpm1a_event_block, acpi_gbl_FADT.pm1_event_length,
 		"ACPI PM1a_EVT_BLK");
@@ -207,7 +211,10 @@ static void __init acpi_reserve_resources(void)
 	if (!(acpi_gbl_FADT.gpe1_block_length & 0x1))
 		acpi_request_region(&acpi_gbl_FADT.xgpe1_block,
 			       acpi_gbl_FADT.gpe1_block_length, "ACPI GPE1_BLK");
+
+	return 0;
 }
+fs_initcall_sync(acpi_reserve_resources);
 
 void acpi_os_printf(const char *fmt, ...)
 {
@@ -1862,7 +1869,6 @@ acpi_status __init acpi_os_initialize(void)
 
 acpi_status __init acpi_os_initialize1(void)
 {
-	acpi_reserve_resources();
 	kacpid_wq = alloc_workqueue("kacpid", 0, 1);
 	kacpi_notify_wq = alloc_workqueue("kacpi_notify", 0, 1);
 	kacpi_hotplug_wq = alloc_ordered_workqueue("kacpi_hotplug", 0);

commit 9bdc771f2c29a11920f477fba05a58e23ee42554
Merge: 7df9ab845ce5 ea7d521569a7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 2 17:11:28 2015 -0700

    Merge tag 'acpica-4.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPICA updates from Rafael Wysocki:
     "Additional ACPICA material for v4.2-rc1
    
      This will update the ACPICA code in the kernel to upstream revision
      20150619 (a bug-fix release mostly including stable-candidate fixes)
      and restore an earlier ACPICA commit that had to be reverted due to a
      regression introduced by it (the regression is addressed by
      blacklisting the only known system affected by it to date).
    
      The only new feature added by this update is the support for
      overriding objects in the ACPI namespace and a new ACPI table that can
      be used for that called the Override System Definition Table (OSDT).
      That should allow us to "patch" the ACPI namespace built from
      incomplete or incorrect ACPI System Definition tables (DSDT, SSDT)
      during system startup without the need to provide replacements for all
      of those tables in the future.
    
      Specifics:
    
       - Fix system resume problems related to 32-bit and 64-bit versions of
         the Firmware ACPI Control Structure (FACS) in the firmare (Lv
         Zheng)
    
       - Fix double initialization of the FACS (Lv Zheng)
    
       - Add _CLS object processing code to ACPICA (Suravee Suthikulpanit)
    
       - Add support for the (currently missing) new GIC version field in
         the Multiple APIC Description Table (MADT) (Hanjun Guo)
    
       - Add support for overriding objects in the ACPI namespace to ACPICA
         and OSDT support (Lv Zheng, Bob Moore, Zhang Rui)
    
       - Updates related to the TCPA and TPM2 ACPI tables (Bob Moore)
    
       - Restore the commit modifying _REV to always return "2" (as required
         by ACPI 6) and add a blacklisting mechanism for systems that may be
         affected by that change (Rafael J Wysocki)
    
       - Assorted fixes and cleanups (Bob Moore, Lv Zheng, Sascha Wildner)"
    
    * tag 'acpica-4.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (28 commits)
      Revert 'Revert "ACPICA: Permanently set _REV to the value '2'."'
      ACPI / init: Make it possible to override _REV
      ACPICA: Update version to 20150619
      ACPICA: Comment update, no functional change
      ACPICA: Update TPM2 ACPI table
      ACPICA: Update definitions for the TCPA and TPM2 ACPI tables
      ACPICA: Split C library prototypes to new header
      ACPICA: De-macroize calls to standard C library functions
      ACPI / acpidump: Update acpidump manual
      ACPICA: acpidump: Convert the default behavior to dump from /sys/firmware/acpi/tables
      ACPICA: acpidump: Allow customized tables to be dumped without accessing /dev/mem
      ACPICA: Cleanup output for the ASL Debug object
      ACPICA: Update for acpi_install_table memory types
      ACPICA: Namespace: Change namespace override to avoid node deletion
      ACPICA: Namespace: Add support of OSDT table
      ACPICA: Namespace: Add support to allow overriding objects
      ACPICA: ACPI 6.0: Add values for MADT GIC version field
      ACPICA: Utilities: Add _CLS processing
      ACPICA: Add dragon_fly support to unix file mapping file
      ACPICA: EFI: Add EFI interface definitions to eliminate dependency of GNU EFI
      ...

commit 18d78b64fddc11eb336f01e46ad3303a3f55d039
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 3 01:06:00 2015 +0200

    ACPI / init: Make it possible to override _REV
    
    The platform firmware on some systems expects Linux to return "5" as
    the supported ACPI revision which makes it expose system configuration
    information in a special way.
    
    For example, based on what ACPI exports as the supported revision,
    Dell XPS 13 (2015) configures its audio device to either work in HDA
    mode or in I2S mode, where the former is supposed to be used on Linux
    until the latter is fully supported (in the kernel as well as in user
    space).
    
    Since ACPI 6 mandates that _REV should return "2" if ACPI 2 or later
    is supported by the OS, a subsequent change will make that happen, so
    make it possible to override that on systems where "5" is expected to
    be returned for Linux to work correctly one them (such as the Dell
    machine mentioned above).
    
    Original-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 39748bb3a543..37e592798cd5 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -537,6 +537,19 @@ acpi_os_get_physical_address(void *virt, acpi_physical_address * phys)
 }
 #endif
 
+#ifdef CONFIG_ACPI_REV_OVERRIDE_POSSIBLE
+static bool acpi_rev_override;
+
+int __init acpi_rev_override_setup(char *str)
+{
+	acpi_rev_override = true;
+	return 1;
+}
+__setup("acpi_rev_override", acpi_rev_override_setup);
+#else
+#define acpi_rev_override	false
+#endif
+
 #define ACPI_MAX_OVERRIDE_LEN 100
 
 static char acpi_os_name[ACPI_MAX_OVERRIDE_LEN];
@@ -555,6 +568,11 @@ acpi_os_predefined_override(const struct acpi_predefined_names *init_val,
 		*new_val = acpi_os_name;
 	}
 
+	if (!memcmp(init_val->name, "_REV", 4) && acpi_rev_override) {
+		printk(KERN_INFO PREFIX "Overriding _REV return value to 5\n");
+		*new_val = (char *)5;
+	}
+
 	return AE_OK;
 }
 

commit 4def8a360fc6119e09916708cca0977a1495ccf4
Merge: 763d949581ed e7d024c00a4a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 19 01:17:26 2015 +0200

    Merge branch 'acpi-video'
    
    * acpi-video: (38 commits)
      ACPI / video: Make acpi_video_unregister_backlight() private
      acpi-video-detect: Remove old API
      toshiba-acpi: Port to new backlight interface selection API
      thinkpad-acpi: Port to new backlight interface selection API
      sony-laptop: Port to new backlight interface selection API
      samsung-laptop: Port to new backlight interface selection API
      msi-wmi: Port to new backlight interface selection API
      msi-laptop: Port to new backlight interface selection API
      intel-oaktrail: Port to new backlight interface selection API
      ideapad-laptop: Port to new backlight interface selection API
      fujitsu-laptop: Port to new backlight interface selection API
      eeepc-laptop: Port to new backlight interface selection API
      dell-wmi: Port to new backlight interface selection API
      dell-laptop: Port to new backlight interface selection API
      compal-laptop: Port to new backlight interface selection API
      asus-wmi: Port to new backlight interface selection API
      asus-laptop: Port to new backlight interface selection API
      apple-gmux: Port to new backlight interface selection API
      acer-wmi: Port to new backlight interface selection API
      ACPI / video: Fix acpi_video _register vs _unregister_backlight race
      ...

commit 4f1fd900c2bd0bf36832d489745b5f78847a1534
Merge: 3a5cf05adf90 3d56402d3fa8 20f34165a924 2bad7e27e02c 302ebef8894d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 19 01:16:21 2015 +0200

    Merge branches 'acpi-pm', 'acpi-apei', 'acpi-osl' and 'acpi-pci'
    
    * acpi-pm:
      ACPI / PM: Add missing pm_generic_complete() invocation
      ACPI / PM: Turn power resources on and off in the right order during resume
      ACPI / PM: Rework device power management to follow ACPI 6
      ACPI / PM: Drop stale comment from acpi_power_transition()
    
    * acpi-apei:
      GHES: Make NMI handler have a single reader
      GHES: Elliminate double-loop in the NMI handler
      GHES: Panic right after detection
      GHES: Carve out the panic functionality
      GHES: Carve out error queueing in a separate function
    
    * acpi-osl:
      ACPI / osl: use same type for acpi_predefined_names values as in definition
    
    * acpi-pci:
      ACPI / PCI: remove stale list_head in struct acpi_prt_entry

commit a87878bafa1f82c20eddaf2d23780b194c35ccf5
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Jun 16 16:27:46 2015 +0200

    acpi-video-detect: Move acpi_osi_is_win8 to osl.c
    
    acpi_osi_is_win8 needs access to acpi_gbl_osi_data which is not exported,
    so move it to osl.c. Alternatively we could export acpi_gbl_osi_data but
    that seems undesirable.
    
    This allows video_detect.c to be build as a module, besides that
    acpi_osi_is_win8() is something which does not really belong in
    video_detect.c in the first place.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 7ccba395c9dd..b906deb10df5 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1684,6 +1684,12 @@ int acpi_resources_are_enforced(void)
 }
 EXPORT_SYMBOL(acpi_resources_are_enforced);
 
+bool acpi_osi_is_win8(void)
+{
+	return acpi_gbl_osi_data >= ACPI_OSI_WIN_8;
+}
+EXPORT_SYMBOL(acpi_osi_is_win8);
+
 /*
  * Deallocate the memory for a spinlock.
  */

commit 0f1b414d190724617eb1cdd615592fa8cd9d0b50
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jun 18 18:32:02 2015 +0200

    ACPI / PNP: Avoid conflicting resource reservations
    
    Commit b9a5e5e18fbf "ACPI / init: Fix the ordering of
    acpi_reserve_resources()" overlooked the fact that the memory
    and/or I/O regions reserved by acpi_reserve_resources() may
    conflict with those reserved by the PNP "system" driver.
    
    If that conflict actually takes place, it causes the reservations
    made by the "system" driver to fail while before commit b9a5e5e18fbf
    all reservations made by it and by acpi_reserve_resources() would be
    successful.  In turn, that allows the resources that haven't been
    reserved by the "system" driver to be used by others (e.g. PCI) which
    sometimes leads to functional problems (up to and including boot
    failures).
    
    To fix that issue, introduce a common resource reservation routine,
    acpi_reserve_region(), to be used by both acpi_reserve_resources()
    and the "system" driver, that will track all resources reserved by
    it and avoid making conflicting requests.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=99831
    Link: http://marc.info/?t=143389402600001&r=1&w=2
    Fixes: b9a5e5e18fbf "ACPI / init: Fix the ordering of acpi_reserve_resources()"
    Reported-by: Roland Dreier <roland@purestorage.com>
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 7ccba395c9dd..5226a8b921ae 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -175,11 +175,7 @@ static void __init acpi_request_region (struct acpi_generic_address *gas,
 	if (!addr || !length)
 		return;
 
-	/* Resources are never freed */
-	if (gas->space_id == ACPI_ADR_SPACE_SYSTEM_IO)
-		request_region(addr, length, desc);
-	else if (gas->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)
-		request_mem_region(addr, length, desc);
+	acpi_reserve_region(addr, length, gas->space_id, 0, desc);
 }
 
 static void __init acpi_reserve_resources(void)

commit 2bad7e27e02ce0984c17e4074c63e7691291244f
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu May 14 15:31:25 2015 +0200

    ACPI / osl: use same type for acpi_predefined_names values as in definition
    
    In the definition of struct acpi_predefined_names, value is of
    type char *. Make the OSL override function also work with type
    char * (or, more precisely, with a pointer to it).
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 39748bb3a543..7a327b24df95 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -543,7 +543,7 @@ static char acpi_os_name[ACPI_MAX_OVERRIDE_LEN];
 
 acpi_status
 acpi_os_predefined_override(const struct acpi_predefined_names *init_val,
-			    acpi_string * new_val)
+			    char **new_val)
 {
 	if (!init_val || !new_val)
 		return AE_BAD_PARAMETER;

commit b9a5e5e18fbf223502c0b2264c15024e393da928
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 7 21:19:39 2015 +0200

    ACPI / init: Fix the ordering of acpi_reserve_resources()
    
    Since acpi_reserve_resources() is defined as a device_initcall(),
    there's no guarantee that it will be executed in the right order
    with respect to the rest of the ACPI initialization code.  On some
    systems this leads to breakage if, for example, the address range
    that should be reserved for the ACPI fixed registers is given to
    the PCI host bridge instead if the race is won by the wrong code
    path.
    
    Fix this by turning acpi_reserve_resources() into a void function
    and calling it directly from within the ACPI initialization sequence.
    
    Reported-and-tested-by: George McCollister <george.mccollister@gmail.com>
    Link: http://marc.info/?t=143092384600002&r=1&w=2
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 39748bb3a543..7ccba395c9dd 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -182,7 +182,7 @@ static void __init acpi_request_region (struct acpi_generic_address *gas,
 		request_mem_region(addr, length, desc);
 }
 
-static int __init acpi_reserve_resources(void)
+static void __init acpi_reserve_resources(void)
 {
 	acpi_request_region(&acpi_gbl_FADT.xpm1a_event_block, acpi_gbl_FADT.pm1_event_length,
 		"ACPI PM1a_EVT_BLK");
@@ -211,10 +211,7 @@ static int __init acpi_reserve_resources(void)
 	if (!(acpi_gbl_FADT.gpe1_block_length & 0x1))
 		acpi_request_region(&acpi_gbl_FADT.xgpe1_block,
 			       acpi_gbl_FADT.gpe1_block_length, "ACPI GPE1_BLK");
-
-	return 0;
 }
-device_initcall(acpi_reserve_resources);
 
 void acpi_os_printf(const char *fmt, ...)
 {
@@ -1845,6 +1842,7 @@ acpi_status __init acpi_os_initialize(void)
 
 acpi_status __init acpi_os_initialize1(void)
 {
+	acpi_reserve_resources();
 	kacpid_wq = alloc_workqueue("kacpid", 0, 1);
 	kacpi_notify_wq = alloc_workqueue("kacpi_notify", 0, 1);
 	kacpi_hotplug_wq = alloc_ordered_workqueue("kacpi_hotplug", 0);

commit aafc65c731fe2e6020850cd87ba69e96aaf38649
Author: Graeme Gregory <graeme.gregory@linaro.org>
Date:   Tue Mar 24 14:02:35 2015 +0000

    ACPI: add arm64 to the platforms that use ioremap
    
    Now with the base changes to the arm memory mapping it is safe
    to convert to using ioremap to map in the tables after
    acpi_gbl_permanent_mmap is set.
    
    CC: Rafael J Wysocki <rjw@rjwysocki.net>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Al Stone <al.stone@linaro.org>
    Signed-off-by: Graeme Gregory <graeme.gregory@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index f9eeae871593..39748bb3a543 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -336,11 +336,11 @@ acpi_map_lookup_virt(void __iomem *virt, acpi_size size)
 	return NULL;
 }
 
-#ifndef CONFIG_IA64
-#define should_use_kmap(pfn)   page_is_ram(pfn)
-#else
+#if defined(CONFIG_IA64) || defined(CONFIG_ARM64)
 /* ioremap will take care of cache attributes */
 #define should_use_kmap(pfn)   0
+#else
+#define should_use_kmap(pfn)   page_is_ram(pfn)
 #endif
 
 static void __iomem *acpi_map(acpi_physical_address pg_off, unsigned long pg_sz)

commit 90253a792ec23481402474704ef498ee81abe4e3
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Nov 5 15:06:13 2014 +0800

    ACPI / OSL: Add IRQ handler flushing support in the OSL.
    
    It is possible that a GPE handler or a fixed event handler still accessed
    after removing the handlers by invoking acpi_remove_gpe_handler() or
    acpi_remove_fixed_event_handler(), this possibility can crash OPSM after a
    module removal. In the Linux kernel, though all other GPE drivers are not
    modules, since the IPMI_SI (ipmi_si_intf.c) can be compiled as a module, we
    still need to consider a solution for this issue when the driver switches
    to ACPI_GPE_RAW_HANDLER mode in order to invoke GPE APIs.
    
    ACPICA expects acpi_os_wait_events_complete() to be invoked after GPE
    disabling so that OSPM can ensure all running GPE handlers have exitted.
    But currently acpi_os_wait_events_complete() can only flush _Lxx/_Exx
    evaluation work queue and this philosophy cannot work for drivers that have
    installed a dedicated GPE handler.
    
    The only way to protect a callback is to perform some state holders
    (reference count, state machine) before invoking the callback. Then this
    issue can only be fixed by the following means:
    1. Flush GPE in ACPICA before invoking the GPE handler. But currently,
       there is no such implementation in acpi_ev_gpe_dispatch().
    2. Flush GPE in ACPICA OSL before invoking the SCI handler. But currently,
       there is no such implementation in acpi_irq().
    3. Flush IRQ in OSPM IRQ layer before invoking the IRQ handler. In Linus
       kernel, this can be done by synchronize_irq().
    4. Flush scheduling in OSPM vector entry layer before invoking the vector.
       In Linux, this can be done by synchronize_sched().
    
    Since ACPICA expects the GPE handlers to be flushed by the ACPICA OSL or
    the GPE drivers. If it is implemented by the GPE driver, we should see
    synchronize_irq()/synchronize_sched() invoked in such drivers. If it is
    implemented by the ACPICA OSL, ACPICA currently provides
    acpi_os_wait_events_complete() hook to achieve this. After the following
    commit:
      Commit: 69c841b6dd8313c9a673246cc0e2535174272cab
      Author: Lv Zheng <lv.zheng@intel.com>
      Subject: ACPICA: Update use of acpi_os_wait_events_complete interface.
    The OSL acpi_os_wait_events_complete() is invoked after a GPE handler is
    removed from acpi_remove_gpe_handler() or a fixed event handler is removed
    from acpi_remove_fixed_event_handler(). Thus it is possible to implement
    GPE handler flushing using this ACPICA OSL now. So the solution 1 is
    currently not taken into account.
    
    By examining the IPMI_SI driver, we noticed that the IPMI_SI driver:
    1. Uses free_irq() to flush non GPE based IRQ handlers, in free_irq(),
       synchronize_irq() is invoked, and
    2. Uses acpi_remove_gpe_handler() to flush GPE based IRQ handlers, for such
       IRQ handlers, there is no synchronize_irq() invoked.
    Since there isn't synchronize_sched() implemented for this driver, from the
    driver's perspective, acpi_remove_gpe_handler() should have properly
    flushed the GPE handlers for it. Since the driver doesn't invoke
    synchronize_irq(), the solution 3 is not what the drivers expect.
    
    This patch implements solution 2. But since given the fact that the GPE is
    managed inside of ACPICA, and implementing the GPE flushing requires to
    implement the whole GPE management code again in the OSL, instead of
    flushing GPE, this patch flushes IRQ in acpi_os_wait_events_complete(). The
    flushing could last longer than expected as though the target GPE/fixed
    event that is removed can be fastly flushed, other GPEs/fix events can still
    be issued during the flushing period.
    
    This patch fixes this issue by invoking synchronize_hardirq() in
    acpi_os_wait_events_complete(). The reason why we don't invoke
    synchronize_irq() is: currently ACPICA is not threaded IRQ capable and the
    only difference between synchronize_irq() and synchronize_hardirq() is
    synchronize_irq() also flushes threaded IRQ handlers. Thus using
    synchronize_hardirq() can help to reduce the overall synchronization time
    for the current ACPICA implementation.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Robert Moore <robert.moore@intel.com>
    Cc: Corey Minyard <minyard@acm.org>
    Cc: linux-acpi@vger.kernel.org
    Cc: devel@acpica.org
    Cc: openipmi-developer@lists.sourceforge.net
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 217713c11aaa..f9eeae871593 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1188,6 +1188,12 @@ EXPORT_SYMBOL(acpi_os_execute);
 
 void acpi_os_wait_events_complete(void)
 {
+	/*
+	 * Make sure the GPE handler or the fixed event handler is not used
+	 * on another CPU after removal.
+	 */
+	if (acpi_irq_handler)
+		synchronize_hardirq(acpi_gbl_FADT.sci_interrupt);
 	flush_workqueue(kacpid_wq);
 	flush_workqueue(kacpi_notify_wq);
 }

commit 74b51ee152b6d99e61ba329799a039453fb9438f
Author: Konstantin Khlebnikov <koct9i@gmail.com>
Date:   Sun Nov 9 13:53:37 2014 +0400

    ACPI / osl: speedup grace period in acpi_os_map_cleanup
    
    ACPI maintains cache of ioremap regions to speed up operations and
    access to them from irq context where ioremap() calls aren't allowed.
    This code abuses synchronize_rcu() on unmap path for synchronization
    with fast-path in acpi_os_read/write_memory which uses this cache.
    
    Since v3.10 CPUs are allowed to enter idle state even if they have RCU
    callbacks queued, see commit c0f4dfd4f90f1667d234d21f15153ea09a2eaa66
    ("rcu: Make RCU_FAST_NO_HZ take advantage of numbered callbacks").
    That change caused problems with nvidia proprietary driver which calls
    acpi_os_map/unmap_generic_address several times during initialization.
    Each unmap calls synchronize_rcu and adds significant delay. Totally
    initialization is slowed for a couple of seconds and that is enough to
    trigger timeout in hardware, gpu decides to "fell off the bus". Widely
    spread workaround is reducing "rcu_idle_gp_delay" from 4 to 1 jiffy.
    
    This patch replaces synchronize_rcu() with synchronize_rcu_expedited()
    which is much faster.
    
    Link: https://devtalk.nvidia.com/default/topic/567297/linux/linux-3-10-driver-crash/
    Signed-off-by: Konstantin Khlebnikov <koct9i@gmail.com>
    Reported-and-tested-by: Alexander Monakov <amonakov@gmail.com>
    Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 9964f70be98d..217713c11aaa 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -436,7 +436,7 @@ static void acpi_os_drop_map_ref(struct acpi_ioremap *map)
 static void acpi_os_map_cleanup(struct acpi_ioremap *map)
 {
 	if (!map->refcount) {
-		synchronize_rcu();
+		synchronize_rcu_expedited();
 		acpi_unmap(map->phys, map->virt);
 		kfree(map);
 	}

commit 28c399e2a1ed03bd175858deef1e233317103089
Merge: 0ede470030a3 a8d46b9e4e48
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Oct 7 01:17:50 2014 +0200

    Merge branch 'acpi-pm'
    
    * acpi-pm:
      ACPI / sleep: Rework the handling of ACPI GPE wakeup from suspend-to-idle
      PM / sleep: Rename platform suspend/resume functions in suspend.c
      PM / sleep: Export dpm_suspend_late/noirq() and dpm_resume_early/noirq()

commit a8d46b9e4e487301affe84fa53de40b890898604
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 30 02:29:01 2014 +0200

    ACPI / sleep: Rework the handling of ACPI GPE wakeup from suspend-to-idle
    
    The ACPI GPE wakeup from suspend-to-idle is currently based on using
    the IRQF_NO_SUSPEND flag for the ACPI SCI, but that is problematic
    for a couple of reasons.  First, in principle the ACPI SCI may be
    shared and IRQF_NO_SUSPEND does not really work well with shared
    interrupts.  Second, it may require the ACPI subsystem to special-case
    the handling of device notifications depending on whether or not
    they are received during suspend-to-idle in some places which would
    lead to fragile code.  Finally, it's better the handle ACPI wakeup
    interrupts consistently with wakeup interrupts from other sources.
    
    For this reason, remove the IRQF_NO_SUSPEND flag from the ACPI SCI
    and use enable_irq_wake()/disable_irq_wake() with it instead, which
    requires two additional platform hooks to be added to struct
    platform_freeze_ops.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 3abe9b223ba7..5ca29b5af8d1 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -825,7 +825,7 @@ acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,
 
 	acpi_irq_handler = handler;
 	acpi_irq_context = context;
-	if (request_irq(irq, acpi_irq, IRQF_SHARED | IRQF_NO_SUSPEND, "acpi", acpi_irq)) {
+	if (request_irq(irq, acpi_irq, IRQF_SHARED, "acpi", acpi_irq)) {
 		printk(KERN_ERR PREFIX "SCI (IRQ%d) allocation failed\n", irq);
 		acpi_irq_handler = NULL;
 		return AE_NOT_ACQUIRED;

commit 7bc5a2bad0b8d9d1ac9f7b8b33150e4ddf197334
Author: Matthew Garrett <matthew.garrett@nebula.com>
Date:   Sat Sep 20 13:19:47 2014 +0200

    ACPI: Support _OSI("Darwin") correctly
    
    Apple hardware queries _OSI("Darwin") in order to determine whether the
    system is running OS X, and changes firmware behaviour based on the
    answer.  The most obvious difference in behaviour is that Thunderbolt
    hardware is forcibly powered down unless the system is running OS X. The
    obvious solution would be to simply add Darwin to the list of supported
    _OSI strings, but this causes problems.
    
    Recent Apple hardware includes two separate methods for checking _OSI
    strings. The first will check whether Darwin is supported, and if so
    will exit. The second will check whether Darwin is supported, but will
    then continue to check for further operating systems. If a further
    operating system is found then later firmware code will assume that the
    OS is not OS X.  This results in the unfortunate situation where the
    Thunderbolt controller is available at boot time but remains powered
    down after suspend.
    
    The easiest way to handle this is to special-case it in the
    Linux-specific OSI handling code. If we see Darwin, we should answer
    true and then disable all other _OSI vendor strings.
    
    The next problem is that the Apple PCI _OSC method has the following
    code:
    
    if (LEqual (0x01, OSDW ()))
      if (LAnd (LEqual (Arg0, GUID), NEXP)
        (do stuff)
      else
        (fail)
    NEXP is a value in high memory and is presumably under the control of
    the firmware. No methods sets it. The methods that are called in the "do
    stuff" path are dummies. Unless there's some additional firmware call in
    early boot, there's no way for this call to succeed - and even if it
    does, it doesn't do anything.
    
    The easiest way to handle this is simply to ignore it. We know which
    flags would be set, so just set them by hand if the platform is running
    in Darwin mode.
    
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>
    [andreas.noever@gmail.com: merged two patches, do not touch ACPICA]
    Signed-off-by: Andreas Noever <andreas.noever@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 3abe9b223ba7..938b6ac71dde 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -152,6 +152,16 @@ static u32 acpi_osi_handler(acpi_string interface, u32 supported)
 			osi_linux.dmi ? " via DMI" : "");
 	}
 
+	if (!strcmp("Darwin", interface)) {
+		/*
+		 * Apple firmware will behave poorly if it receives positive
+		 * answers to "Darwin" and any other OS. Respond positively
+		 * to Darwin and then disable all other vendor strings.
+		 */
+		acpi_update_interfaces(ACPI_DISABLE_ALL_VENDOR_STRINGS);
+		supported = ACPI_UINT32_MAX;
+	}
+
 	return supported;
 }
 

commit 8a1664be0b922dd6afd60eca96a992ef5ec22c40
Author: Graeme Gregory <graeme.gregory@linaro.org>
Date:   Fri Jul 18 18:02:52 2014 +0800

    ACPI: add config for BIOS table scan
    
    With the addition of ARM64 that does not have a traditional BIOS to
    scan, add a config option which is selected on x86 (ia64 doesn't need
    it either, it is EFI/UEFI based system) to do the traditional BIOS
    scanning for tables.
    
    Signed-off-by: Graeme Gregory <graeme.gregory@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index bad25b070fe0..3abe9b223ba7 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -259,12 +259,14 @@ acpi_physical_address __init acpi_os_get_root_pointer(void)
 			       "System description tables not found\n");
 			return 0;
 		}
-	} else {
+	} else if (IS_ENABLED(CONFIG_ACPI_LEGACY_TABLES_LOOKUP)) {
 		acpi_physical_address pa = 0;
 
 		acpi_find_root_pointer(&pa);
 		return pa;
 	}
+
+	return 0;
 }
 
 /* Must be called with 'acpi_ioremap_lock' or RCU read lock held. */

commit 3d915894f8317ac3e55b47da829aa65eb5f9ae97
Author: Christoph Jaeger <christophjaeger@linux.com>
Date:   Fri Jun 13 21:49:58 2014 +0200

    ACPI: use kstrto*() instead of simple_strto*()
    
    simple_strto*() are obsolete; use kstrto*() instead. Add proper error
    checking.
    
    Signed-off-by: Christoph Jaeger <christophjaeger@linux.com>
    Acked-by: David Rientjes <rientjes@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 3f2bdc812d23..bad25b070fe0 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -235,7 +235,8 @@ void acpi_os_vprintf(const char *fmt, va_list args)
 static unsigned long acpi_rsdp;
 static int __init setup_acpi_rsdp(char *arg)
 {
-	acpi_rsdp = simple_strtoul(arg, NULL, 16);
+	if (kstrtoul(arg, 16, &acpi_rsdp))
+		return -EINVAL;
 	return 0;
 }
 early_param("acpi_rsdp", setup_acpi_rsdp);

commit de815a6d00da0f8a59e8aebf8efe12e289552a8f
Merge: 9d674f2107b7 a4714a898e85 751109aad583
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jun 12 13:42:37 2014 +0200

    Merge branches 'acpi-general' and 'acpi-video'
    
    * acpi-general:
      ACPI: Fix bug when ACPI reset register is implemented in system memory
    
    * acpi-video:
      ACPI / video: Change the default for video.use_native_backlight to 1

commit a4714a898e85205e1118ec923cde43d88eb105f6
Author: Randy Wright <rwright@hp.com>
Date:   Wed Jun 4 08:55:59 2014 -0700

    ACPI: Fix bug when ACPI reset register is implemented in system memory
    
    Use acpi_os_map_generic_address to pre-map the reset register if it is
    memory mapped, thereby preventing the BUG_ON() in line 1319 of
    mm/vmalloc.c from triggering during panic-triggered reboots.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=77131
    Signed-off-by: Randy Wright <rwright@hp.com>
    Signed-off-by: David E. Box <david.e.box@linux.intel.com>
    [rjw: Changelog, simplified code]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 6776c599816f..88cddf84d245 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1798,6 +1798,16 @@ acpi_status __init acpi_os_initialize(void)
 	acpi_os_map_generic_address(&acpi_gbl_FADT.xpm1b_event_block);
 	acpi_os_map_generic_address(&acpi_gbl_FADT.xgpe0_block);
 	acpi_os_map_generic_address(&acpi_gbl_FADT.xgpe1_block);
+	if (acpi_gbl_FADT.flags & ACPI_FADT_RESET_REGISTER) {
+		/*
+		 * Use acpi_os_map_generic_address to pre-map the reset
+		 * register if it's in system memory.
+		 */
+		int rv;
+
+		rv = acpi_os_map_generic_address(&acpi_gbl_FADT.reset_register);
+		pr_debug(PREFIX "%s: map reset_reg status %d\n", __func__, rv);
+	}
 
 	return AE_OK;
 }
@@ -1826,6 +1836,8 @@ acpi_status acpi_os_terminate(void)
 	acpi_os_unmap_generic_address(&acpi_gbl_FADT.xgpe0_block);
 	acpi_os_unmap_generic_address(&acpi_gbl_FADT.xpm1b_event_block);
 	acpi_os_unmap_generic_address(&acpi_gbl_FADT.xpm1a_event_block);
+	if (acpi_gbl_FADT.flags & ACPI_FADT_RESET_REGISTER)
+		acpi_os_unmap_generic_address(&acpi_gbl_FADT.reset_register);
 
 	destroy_workqueue(kacpid_wq);
 	destroy_workqueue(kacpi_notify_wq);

commit a238317ce8185519ed083e81e84260907fbbcf7f
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue May 20 15:39:41 2014 +0800

    ACPI: Clean up acpi_os_map/unmap_memory() to eliminate __iomem.
    
    ACPICA doesn't include protections around address space checking, Linux
    build tests always complain increased sparse warnings around ACPICA
    internal acpi_os_map/unmap_memory() invocations.  This patch tries to fix
    this issue permanently.
    
    There are 2 choices left for us to solve this issue:
     1. Add __iomem address space awareness into ACPICA.
     2. Remove sparse checker of __iomem from ACPICA source code.
    
    This patch chooses solution 2, because:
     1.  Most of the acpi_os_map/unmap_memory() invocations are used for ACPICA.
         table mappings, which in fact are not IO addresses.
     2.  The only IO addresses usage is for "system memory space" mapping code in:
          drivers/acpi/acpica/exregion.c
          drivers/acpi/acpica/evrgnini.c
          drivers/acpi/acpica/exregion.c
        The mapped address is accessed in the handler of "system memory space"
        - acpi_ex_system_memory_space_handler().  This function in fact can be
        changed to invoke acpi_os_read/write_memory() so that __iomem can
        always be type-casted in the OSL layer.
    
    According to the above investigation, we drew the following conclusion:
    It is not a good idea to introduce __iomem address space awareness into
    ACPICA mostly in order to protect non-IO addresses.
    
    We can simply remove __iomem for acpi_os_map/unmap_memory() to remove
    __iomem checker for ACPICA code. Then we need to enforce external usages
    to invoke other APIs that are aware of __iomem address space.
    The external usages are:
     drivers/acpi/apei/einj.c
     drivers/acpi/acpi_extlog.c
     drivers/char/tpm/tpm_acpi.c
     drivers/acpi/nvs.c
    
    This patch thus performs cleanups in this way:
     1. Add acpi_os_map/unmap_iomem() to be invoked by non-ACPICA code.
     2. Remove __iomem from acpi_os_map/unmap_memory().
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 9aeae41e22fb..147bc1b91b42 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -355,7 +355,7 @@ static void acpi_unmap(acpi_physical_address pg_off, void __iomem *vaddr)
 }
 
 void __iomem *__init_refok
-acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
+acpi_os_map_iomem(acpi_physical_address phys, acpi_size size)
 {
 	struct acpi_ioremap *map;
 	void __iomem *virt;
@@ -401,10 +401,17 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 
 	list_add_tail_rcu(&map->list, &acpi_ioremaps);
 
- out:
+out:
 	mutex_unlock(&acpi_ioremap_lock);
 	return map->virt + (phys - map->phys);
 }
+EXPORT_SYMBOL_GPL(acpi_os_map_iomem);
+
+void *__init_refok
+acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
+{
+	return (void *)acpi_os_map_iomem(phys, size);
+}
 EXPORT_SYMBOL_GPL(acpi_os_map_memory);
 
 static void acpi_os_drop_map_ref(struct acpi_ioremap *map)
@@ -422,7 +429,7 @@ static void acpi_os_map_cleanup(struct acpi_ioremap *map)
 	}
 }
 
-void __ref acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
+void __ref acpi_os_unmap_iomem(void __iomem *virt, acpi_size size)
 {
 	struct acpi_ioremap *map;
 
@@ -443,6 +450,12 @@ void __ref acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 
 	acpi_os_map_cleanup(map);
 }
+EXPORT_SYMBOL_GPL(acpi_os_unmap_iomem);
+
+void __ref acpi_os_unmap_memory(void *virt, acpi_size size)
+{
+	return acpi_os_unmap_iomem((void __iomem *)virt, size);
+}
 EXPORT_SYMBOL_GPL(acpi_os_unmap_memory);
 
 void __init early_acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
@@ -464,7 +477,7 @@ int acpi_os_map_generic_address(struct acpi_generic_address *gas)
 	if (!addr || !gas->bit_width)
 		return -EINVAL;
 
-	virt = acpi_os_map_memory(addr, gas->bit_width / 8);
+	virt = acpi_os_map_iomem(addr, gas->bit_width / 8);
 	if (!virt)
 		return -EIO;
 

commit a94e88cdd8057fe8ea84bbb6d9a89a823c7bc49b
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Apr 4 12:39:11 2014 +0800

    ACPICA: Tables: Avoid SSDT installation with acpi_gbl_disable_ssdt_table_load.
    
    It is reported that when acpi_gbl_disable_ssdt_table_load is specified, user
    still can see it installed into /sys/firmware/acpi/tables on Linux boxes.
    This is because the option only stops table "loading", but doesn't stop
    table "installing", thus it is still in the acpi_gbl_root_table_list. With
    previous cleanups, it is possible to prevent SSDT installations to make
    it not such confusing.  The global variable is also renamed.  Lv Zheng.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    [rjw: Subject]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 6776c599816f..9aeae41e22fb 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1770,16 +1770,15 @@ acpi_status acpi_os_release_object(acpi_cache_t * cache, void *object)
 }
 #endif
 
-static int __init acpi_no_auto_ssdt_setup(char *s)
+static int __init acpi_no_static_ssdt_setup(char *s)
 {
-        printk(KERN_NOTICE PREFIX "SSDT auto-load disabled\n");
+	acpi_gbl_disable_ssdt_table_install = TRUE;
+	pr_info("ACPI: static SSDT installation disabled\n");
 
-        acpi_gbl_disable_ssdt_table_load = TRUE;
-
-        return 1;
+	return 0;
 }
 
-__setup("acpi_no_auto_ssdt", acpi_no_auto_ssdt_setup);
+early_param("acpi_no_static_ssdt", acpi_no_static_ssdt_setup);
 
 static int __init acpi_disable_return_repair(char *s)
 {

commit 2d0acb4af981e20eb626c6ea1925e95056220b2a
Author: jhbird.choi@samsung.com <jhbird.choi@samsung.com>
Date:   Thu Mar 20 16:35:56 2014 +0900

    ACPI: Clean up memory allocations
    
    Use acpi_os_allocate_zeroed instead of acpi_os_allocate + memset.
    
    Signed-off-by: Jonghwan Choi <jhbird.choi@samsung.com>
    [rjw: Subject and changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index f7fd72ac69cf..6776c599816f 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1219,10 +1219,9 @@ acpi_os_create_semaphore(u32 max_units, u32 initial_units, acpi_handle * handle)
 {
 	struct semaphore *sem = NULL;
 
-	sem = acpi_os_allocate(sizeof(struct semaphore));
+	sem = acpi_os_allocate_zeroed(sizeof(struct semaphore));
 	if (!sem)
 		return AE_NO_MEMORY;
-	memset(sem, 0, sizeof(struct semaphore));
 
 	sema_init(sem, initial_units);
 

commit 08476907abf25315acb4c9a72a0e78bf61456696
Merge: 0ecfe310f451 08e1d7c0290a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Apr 1 22:09:26 2014 +0200

    Merge branch 'acpica'
    
    * acpica:
      ACPICA: Enable auto-serialization as a default kernel behavior.
      ACPICA: Ignore sync_level for methods that have been auto-serialized.
      ACPICA: Add additional named objects for the auto-serialize method scan.
      ACPICA: Add auto-serialization support for ill-behaved control methods.
      ACPICA: Remove global option to serialize all control methods.

commit 08e1d7c0290aaef6bc6d68be8df753ffec02a6ae
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Mar 24 14:49:22 2014 +0800

    ACPICA: Enable auto-serialization as a default kernel behavior.
    
    The previous commit "ACPICA: Add auto-serialization support for ill-behaved
    control methods" introduced the auto-serialization facility as a workaround
    that can be enabled by "acpi_auto_serialize":
    
    This feature marks control methods that create named objects as "serialized"
    to avoid unwanted AE_ALREADY_EXISTS control method evaluation failures.
    
    Enable method auto-serialization as the default kernel behavior.  The new kernel
    parameter is also changed from "acpi_auto_serialize" to "acpi_no_auto_serialize"
    to reflect the default behavior.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=52191
    References: http://www.spinics.net/lists/linux-acpi/msg49496.html
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 74a160cf85b9..a3109ffcfa98 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1540,20 +1540,20 @@ static int __init osi_setup(char *str)
 __setup("acpi_osi=", osi_setup);
 
 /*
- * Enable the auto-serialization of named objects creation methods.
+ * Disable the auto-serialization of named objects creation methods.
  *
- * This feature is disabled by default.  It marks the AML control methods
+ * This feature is enabled by default.  It marks the AML control methods
  * that contain the opcodes to create named objects as "Serialized".
  */
-static int __init acpi_auto_serialize_setup(char *str)
+static int __init acpi_no_auto_serialize_setup(char *str)
 {
-	acpi_gbl_auto_serialize_methods = TRUE;
-	pr_info("ACPI: auto-serialization enabled\n");
+	acpi_gbl_auto_serialize_methods = FALSE;
+	pr_info("ACPI: auto-serialization disabled\n");
 
 	return 1;
 }
 
-__setup("acpi_auto_serialize", acpi_auto_serialize_setup);
+__setup("acpi_no_auto_serialize", acpi_no_auto_serialize_setup);
 
 /* Check of resource interference between native drivers and ACPI
  * OperationRegions (SystemIO and System Memory only).

commit 22b5afce6a0f29f995b0cce83a5033892dd306d8
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Mar 24 14:49:00 2014 +0800

    ACPICA: Add auto-serialization support for ill-behaved control methods.
    
    This change adds support to automatically mark a control method as
    "serialized" if the method creates any named objects. This will
    positively prevent the method from being entered by more than one
    thread and thus preventing a possible abort when an attempt is
    made to create an object twice.
    
    Implemented by parsing all non-serialize control methods at table
    load time.
    
    This feature is disabled by default and this patch also adds a new
    Linux kernel parameter "acpi_auto_serialize" to allow this feature
    to be turned on for a specific boot.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=52191
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index b7af3b758f32..74a160cf85b9 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1539,6 +1539,22 @@ static int __init osi_setup(char *str)
 
 __setup("acpi_osi=", osi_setup);
 
+/*
+ * Enable the auto-serialization of named objects creation methods.
+ *
+ * This feature is disabled by default.  It marks the AML control methods
+ * that contain the opcodes to create named objects as "Serialized".
+ */
+static int __init acpi_auto_serialize_setup(char *str)
+{
+	acpi_gbl_auto_serialize_methods = TRUE;
+	pr_info("ACPI: auto-serialization enabled\n");
+
+	return 1;
+}
+
+__setup("acpi_auto_serialize", acpi_auto_serialize_setup);
+
 /* Check of resource interference between native drivers and ACPI
  * OperationRegions (SystemIO and System Memory only).
  * IO ports and memory declared in ACPI might be used by the ACPI subsystem

commit e2b8ddcc6b3fbb860e15c5d52455735e128326aa
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Mar 24 14:48:45 2014 +0800

    ACPICA: Remove global option to serialize all control methods.
    
    According to the reports, the "acpi_serialize" mechanism is broken as:
    
     A. The parallel method calls can still happen when the interpreter lock is
        released under the following conditions:
        1. External callbacks are invoked, for example, by the region handlers,
           the exception handlers, etc.;
        2. Module level execution is performed when Load/LoadTable opcodes are
           executed, and
        3. The _REG control methods are invoked to complete the region
           registrations.
     B. For the following situations, the interpreter lock need to be released
        even for a serialized method while currently, the lock-releasing
        operation is marked as a no-op by
        acpi_ex_relinquish/reacquire_interpreter() when this mechanism is
        enabled:
        1. Wait opcode is executed,
        2. Acquire opcode is executed, and
        3. Sleep opcode is executed.
    
    This patch removes this mechanism and the internal
    acpi_ex_relinquish/reacquire_interpreter() APIs.  Lv Zheng.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=52191
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 0d7b7145399e..b7af3b758f32 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1539,18 +1539,6 @@ static int __init osi_setup(char *str)
 
 __setup("acpi_osi=", osi_setup);
 
-/* enable serialization to combat AE_ALREADY_EXISTS errors */
-static int __init acpi_serialize_setup(char *str)
-{
-	printk(KERN_INFO PREFIX "serialize enabled\n");
-
-	acpi_gbl_all_methods_serialized = TRUE;
-
-	return 1;
-}
-
-__setup("acpi_serialize", acpi_serialize_setup);
-
 /* Check of resource interference between native drivers and ACPI
  * OperationRegions (SystemIO and System Memory only).
  * IO ports and memory declared in ACPI might be used by the ACPI subsystem

commit 6ac4a2ab16af49a86ad16bdab1de72d5b809a9c1
Merge: 94a81caca375 6e596084833b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Mar 20 13:25:02 2014 +0100

    Merge branch 'acpica'
    
    * acpica: (29 commits)
      ACPICA: Revert "Headers: Deploy #pragma pack (push) and (pop)."
      ACPICA: Update version to 20140214.
      ACPICA: Prevent infinite loops when traversing corrupted lists.
      ACPICA: Debugger: Add missing objects; Traverse linked lists
      ACPICA: Add text: ACPICA policy for new _OSI strings. No functional change.
      ACPICA: Update for _PRP predefined name.
      ACPICA: Cleanup/improve global variable declarations.
      ACPICA: Comment update - no functional change.
      ACPICA: Do not abort _PRT repair on a single subpackage failure.
      ACPICA: Harden _PRT repair code; check for minimum package length.
      ACPICA: Restore code that repairs NULL package elements in return values.
      ACPICA: Properly handle NULL entries in _PRT return packages.
      ACPICA: Update conditional compilation flags for resource dump functions.
      ACPICA: Predefined names: Add support for the _PRP method.
      ACPICA: Headers: Deploy #pragma pack (push) and (pop).
      ACPICA: Add boot option to disable auto return object repair
      ACPICA: acpidump: Remove integer types translation protection.
      ACPICA: acpidump: Add sparse declarators support.
      ACPICA: Add "Windows 2013" string to _OSI support.
      ACPICA: Update version to 20140114.
      ...

commit e25c5abf4125526d62417f8b5a314e743eefe900
Merge: c730d30c313a 07070e12cf5c a59ffb2062df c1aaae673f68 e1c748179754 0bf6368ee8f2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Mar 20 13:20:47 2014 +0100

    Merge branches 'acpi-cleanup', 'acpi-thermal', 'acpi-pci', 'acpi-lpss' and 'acpi-button'
    
    * acpi-cleanup:
      ACPI: Remove duplicate definitions of PREFIX
      ACPI / tables: Replace printk with pr_*
    
    * acpi-thermal:
      ACPI / thermal: make acpi_thermal_check asynchronous on resume
    
    * acpi-pci:
      ACPI / PCI: Do not call ISA-specific code if ISA is not supported
    
    * acpi-lpss:
      ACPI / LPSS: Add Intel BayTrail ACPI mode PWM
    
    * acpi-button:
      ACPI / button: Add ACPI Button event via netlink routine

commit 07070e12cf5cab46a783a4753f07bb99e557473b
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Thu Mar 13 12:47:39 2014 +0800

    ACPI: Remove duplicate definitions of PREFIX
    
    We already have a macro for PREFIX of "ACPI: " in
    drivers/acpi/internal.h, so remove the duplicate ones
    in ACPI drivers when internal.h is included.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index fc1aa7909690..ee11657b3339 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -52,7 +52,7 @@
 
 #define _COMPONENT		ACPI_OS_SERVICES
 ACPI_MODULE_NAME("osl");
-#define PREFIX		"ACPI: "
+
 struct acpi_os_dpc {
 	acpi_osd_exec_callback function;
 	void *context;

commit 1e3bcb596c6b1cf6db93f8f506e2de260e771bad
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 3 00:40:38 2014 +0100

    ACPI / hotplug: Rework deferred execution of acpi_device_hotplug()
    
    Since the only function executed by acpi_hotplug_execute() is
    acpi_device_hotplug() and it only is called by the ACPI core,
    simplify its definition so that it only takes two arguments, the
    ACPI device object pointer and event code, rename it to
    acpi_hotplug_schedule() and move its header from acpi_bus.h to
    the ACPI core's internal header file internal.h.  Modify the
    definition of acpi_device_hotplug() so that its first argument is
    an ACPI device object pointer and modify the definition of
    struct acpi_hp_work accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index fc1aa7909690..afb4be566940 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1168,8 +1168,7 @@ void acpi_os_wait_events_complete(void)
 
 struct acpi_hp_work {
 	struct work_struct work;
-	acpi_hp_callback func;
-	void *data;
+	struct acpi_device *adev;
 	u32 src;
 };
 
@@ -1178,25 +1177,24 @@ static void acpi_hotplug_work_fn(struct work_struct *work)
 	struct acpi_hp_work *hpw = container_of(work, struct acpi_hp_work, work);
 
 	acpi_os_wait_events_complete();
-	hpw->func(hpw->data, hpw->src);
+	acpi_device_hotplug(hpw->adev, hpw->src);
 	kfree(hpw);
 }
 
-acpi_status acpi_hotplug_execute(acpi_hp_callback func, void *data, u32 src)
+acpi_status acpi_hotplug_schedule(struct acpi_device *adev, u32 src)
 {
 	struct acpi_hp_work *hpw;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
-		  "Scheduling function [%p(%p, %u)] for deferred execution.\n",
-		  func, data, src));
+		  "Scheduling hotplug event (%p, %u) for deferred execution.\n",
+		  adev, src));
 
 	hpw = kmalloc(sizeof(*hpw), GFP_KERNEL);
 	if (!hpw)
 		return AE_NO_MEMORY;
 
 	INIT_WORK(&hpw->work, acpi_hotplug_work_fn);
-	hpw->func = func;
-	hpw->data = data;
+	hpw->adev = adev;
 	hpw->src = src;
 	/*
 	 * We can't run hotplug code in kacpid_wq/kacpid_notify_wq etc., because

commit 4dde507fc1984435f28862ddd1beb90822aa116c
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Feb 11 11:01:52 2014 +0800

    ACPICA: Add boot option to disable auto return object repair
    
    Sometimes, there might be bugs caused by unexpected AML which is compliant
    to the Windows but not compliant to the Linux implementation.
    
    There is a predefined validation mechanism implemented in ACPICA to repair
    the unexpected AML evaluation results that are caused by the unexpected
    AMLs.  For example, BIOS may return misorder _CST result and the repair
    mechanism can make an ascending order on the returned _CST package object
    based on the C-state type.
    This mechanism is quite useful to implement an AML interpreter with better
    compliance with the real world where Windows is the de-facto standard and
    BIOS codes are only tested on one platform thus not compliant to the
    ACPI specification.
    
    But if a compliance issue hasn't been figured out yet, it will be
    difficult for developers to identify if the unexpected evaluation result
    is caused by this mechanism or by the AML interpreter.
    For example, _PR0 is expected to be a control method, but BIOS may use
    Package: "Name(_PR0, Package(1) {P1PR})".
    This boot option can disable the predefined validation mechanism so that
    developers can make sure the root cause comes from the parser/executer.
    
    This patch adds a new kernel parameter to disable this feature.
    
    A build test has been made on a Dell Inspiron mini 1100 (i386 z530)
    machine when this patch is applied and the corresponding boot test is
    performed w/ or w/o the new kernel parameter specified.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=67901
    Tested-by: Fabian Wehning <fabian.wehning@googlemail.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index fc1aa7909690..0d7b7145399e 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1780,6 +1780,17 @@ static int __init acpi_no_auto_ssdt_setup(char *s)
 
 __setup("acpi_no_auto_ssdt", acpi_no_auto_ssdt_setup);
 
+static int __init acpi_disable_return_repair(char *s)
+{
+	printk(KERN_NOTICE PREFIX
+	       "ACPI: Predefined validation mechanism disabled\n");
+	acpi_gbl_disable_auto_repair = TRUE;
+
+	return 1;
+}
+
+__setup("acpica_no_return_repair", acpi_disable_return_repair);
+
 acpi_status __init acpi_os_initialize(void)
 {
 	acpi_os_map_generic_address(&acpi_gbl_FADT.xpm1a_event_block);

commit 25d412d932fb3289ae5b510845d523330b80bb71
Merge: 98feb7cc61c5 c713cd7f2d79
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 12 23:45:04 2014 +0100

    Merge branch 'acpi-hotplug'
    
    * acpi-hotplug:
      ACPI / scan: ACPI device object sysfs attribute for _STA evaluation
      ACPI / hotplug / driver core: Handle containers in a special way
      ACPI / hotplug: Add demand_offline hotplug profile flag
      ACPI / bind: Move acpi_get_child() to drivers/ide/ide-acpi.c
      ACPI / bind: Pass struct acpi_device pointer to acpi_bind_one()
      ACPI / bind: Rework struct acpi_bus_type
      ACPI / bind: Redefine acpi_preset_companion()
      ACPI / bind: Redefine acpi_get_child()
      PCI / ACPI: Use acpi_find_child_device() for child devices lookup
      ACPI / bind: Simplify child device lookups
      ACPI / scan: Use direct recurrence for device hierarchy walks
      ACPI: Introduce acpi_set_device_status()
      ACPI / hotplug: Drop unfinished global notification handling routines
      ACPI / hotplug: Rework generic code to handle suprise removals
      ACPI / hotplug: Move container-specific code out of the core
      ACPI / hotplug: Make ACPI PCI root hotplug use common hotplug code
      ACPI / hotplug: Introduce common hotplug function acpi_device_hotplug()
      ACPI / hotplug: Do not fail bus and device checks for disabled hotplug
      ACPI / scan: Add acpi_device objects for all device nodes in the namespace
      ACPI / scan: Define non-empty device removal handler

commit 66e162b3931be6362bb6885ecc422d192f748145
Author: Rashika <rashika.kheria@gmail.com>
Date:   Tue Dec 17 14:43:05 2013 +0530

    ACPI / OSL: Mark the function acpi_table_checksum() as static
    
    Marks the function acpi_table_checksum() as static in osl.c
    because it is not used outside this file.
    
    This eliminates the following warning in osl.c:
    drivers/acpi/osl.c:547:11: warning: no previous prototype for
    ‘acpi_table_checksum’ [-Wmissing-prototypes]
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 26c111341ead..7865a8069340 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -540,7 +540,7 @@ static u64 acpi_tables_addr;
 static int all_tables_size;
 
 /* Copied from acpica/tbutils.c:acpi_tb_checksum() */
-u8 __init acpi_table_checksum(u8 *buffer, u32 length)
+static u8 __init acpi_table_checksum(u8 *buffer, u32 length)
 {
 	u8 sum = 0;
 	u8 *end = buffer + length;

commit cad1525a5e7443cd93368a22e5b7571c373c8cc0
Author: Al Stone <al.stone@linaro.org>
Date:   Wed Dec 4 12:59:11 2013 -0700

    ACPI: remove trailing whitespace
    
    Minor cleanup: remove some extra trailing white space.
    
    Signed-off-by: Al Stone <al.stone@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 064b8b365060..26c111341ead 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1278,7 +1278,7 @@ acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
 		jiffies = MAX_SCHEDULE_TIMEOUT;
 	else
 		jiffies = msecs_to_jiffies(timeout);
-	
+
 	ret = down_timeout(sem, jiffies);
 	if (ret)
 		status = AE_TIME;

commit 27d50c82714f6477ac690034b37d202f76eb4f70
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Dec 6 16:52:05 2013 +0800

    ACPI / i915: Fix incorrect <acpi/acpi.h> inclusions via <linux/acpi_io.h>
    
    To avoid build problems and breaking dependencies between ACPI header
    files, <acpi/acpi.h> should not be included directly by code outside
    of the ACPI core subsystem.  However, that is possible if
    <linux/acpi_io.h> is included, because that file contains
    a direct inclusion of <acpi/acpi.h>.
    
    For this reason, remove the direct <acpi/acpi.h> inclusion from
    <linux/acpi_io.h>, move that file from include/linux/ to include/acpi/
    and make <linux/acpi.h> include it for CONFIG_ACPI set along with the
    other ACPI header files.  Accordingly, Remove the inclusions of
    <linux/acpi_io.h> from everywhere.
    
    Of course, that causes the contents of the new <acpi/acpi_io.h> file
    to be available for CONFIG_ACPI set only, so intel_opregion.o that
    depends on it should also depend on CONFIG_ACPI (and it really should
    not be compiled for CONFIG_ACPI unset anyway).
    
    References: https://01.org/linuxgraphics/sites/default/files/documentation/acpi_igd_opregion_spec.pdf
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    [rjw: Subject and changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 244be2affea7..064b8b365060 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -39,7 +39,6 @@
 #include <linux/workqueue.h>
 #include <linux/nmi.h>
 #include <linux/acpi.h>
-#include <linux/acpi_io.h>
 #include <linux/efi.h>
 #include <linux/ioport.h>
 #include <linux/list.h>

commit 9ccad66f0171578445175ecd3bf66b35a96aaf6e
Merge: 8ff47aafb25c 8b48463f8942
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Dec 7 01:05:17 2013 +0100

    Merge branch 'acpi-cleanup' into acpi-hotplug
    
    Conflicts:
            drivers/acpi/scan.c

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 54a20ff4b864..244be2affea7 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -49,9 +49,6 @@
 #include <asm/io.h>
 #include <asm/uaccess.h>
 
-#include <acpi/acpi.h>
-#include <acpi/acpi_bus.h>
-#include <acpi/processor.h>
 #include "internal.h"
 
 #define _COMPONENT		ACPI_OS_SERVICES

commit d783156ea38431b20af0d4f910a6f9f9054d33b9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 22 21:52:12 2013 +0100

    ACPI / scan: Define non-empty device removal handler
    
    If an ACPI namespace node is removed (usually, as a result of a
    table unload), and there is a data object attached to that node,
    acpi_ns_delete_node() executes the removal handler submitted to
    acpi_attach_data() for that object.  That handler is currently empty
    for struct acpi_device objects, so it is necessary to detach those
    objects from the corresponding ACPI namespace nodes in advance every
    time a table unload may happen.  That is cumbersome and inefficient
    and leads to some design constraints that turn out to be quite
    inconvenient (in particular, struct acpi_device objects cannot be
    registered for namespace nodes representing devices that are not
    reported as present or functional by _STA).
    
    For this reason, introduce a non-empty removal handler for ACPI
    device objects that will unregister them when their ACPI namespace
    nodes go away.
    
    This code modification alone should not change functionality except
    for the ordering of the ACPI hotplug workqueue which should not
    matter (without subsequent code changes).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 54a20ff4b864..5b9a785e2155 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1215,6 +1215,10 @@ acpi_status acpi_hotplug_execute(acpi_hp_callback func, void *data, u32 src)
 	return AE_OK;
 }
 
+bool acpi_queue_hotplug_work(struct work_struct *work)
+{
+	return queue_work(kacpi_hotplug_wq, work);
+}
 
 acpi_status
 acpi_os_create_semaphore(u32 max_units, u32 initial_units, acpi_handle * handle)
@@ -1794,7 +1798,7 @@ acpi_status __init acpi_os_initialize1(void)
 {
 	kacpid_wq = alloc_workqueue("kacpid", 0, 1);
 	kacpi_notify_wq = alloc_workqueue("kacpi_notify", 0, 1);
-	kacpi_hotplug_wq = alloc_workqueue("kacpi_hotplug", 0, 1);
+	kacpi_hotplug_wq = alloc_ordered_workqueue("kacpi_hotplug", 0);
 	BUG_ON(!kacpid_wq);
 	BUG_ON(!kacpi_notify_wq);
 	BUG_ON(!kacpi_hotplug_wq);

commit 63ff4d0765a4e30afa659edbf09006987fc62499
Merge: 679d9980f991 7b98118aaa5d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 7 19:31:15 2013 +0100

    Merge branch 'acpi-hotplug'
    
    * acpi-hotplug:
      ACPI / hotplug: Consolidate deferred execution of ACPI hotplug routines
      ACPI / hotplug: Do not execute "insert in progress" _OST
      ACPI / hotplug: Carry out PCI root eject directly
      ACPI / hotplug: Merge device hot-removal routines
      ACPI / hotplug: Make acpi_bus_hot_remove_device() internal
      ACPI / hotplug: Simplify device ejection routines
      ACPI / hotplug: Fix handle_root_bridge_removal()
      ACPI / hotplug: Refuse to hot-remove all objects with disabled hotplug
      ACPI / scan: Start matching drivers after trying scan handlers
      ACPI: Remove acpi_pci_slot_init() headers from internal.h
    
    Conflicts:
            include/acpi/acpiosxf.h (with the 'acpica' branch)

commit 7b98118aaa5d75644c48f41fc5d0cc181e478383
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 7 01:45:40 2013 +0100

    ACPI / hotplug: Consolidate deferred execution of ACPI hotplug routines
    
    There are two different interfaces for queuing up work items on the
    ACPI hotplug workqueue, alloc_acpi_hp_work() used by PCI and PCI host
    bridge hotplug code and acpi_os_hotplug_execute() used by the common
    ACPI hotplug code and docking stations.  They both are somewhat
    cumbersome to use and work slightly differently.
    
    The users of alloc_acpi_hp_work() have to submit a work function that
    will extract the necessary data items from a struct acpi_hp_work
    object allocated by alloc_acpi_hp_work() and then will free that
    object, while it would be more straightforward to simply use a work
    function with one more argument and let the interface take care of
    the execution details.
    
    The users of acpi_os_hotplug_execute() also have to deal with the
    fact that it takes only one argument in addition to the work function
    pointer, although acpi_os_execute_deferred() actually takes care of
    the allocation and freeing of memory, so it would have been able to
    pass more arguments to the work function if it hadn't been
    constrained by the connection with acpi_os_execute().
    
    Moreover, while alloc_acpi_hp_work() makes GFP_KERNEL memory
    allocations, which is correct, because hotplug work items are
    always queued up from process context, acpi_os_hotplug_execute()
    uses GFP_ATOMIC, as that is needed by acpi_os_execute().  Also,
    acpi_os_execute_deferred() queued up by it waits for the ACPI event
    workqueues to flush before executing the work function, whereas
    alloc_acpi_hp_work() can't do anything similar.  That leads to
    somewhat arbitrary differences in behavior between various ACPI
    hotplug code paths and has to be straightened up.
    
    For this reason, replace both alloc_acpi_hp_work() and
    acpi_os_hotplug_execute() with a single interface,
    acpi_hotplug_execute(), combining their behavior and being more
    friendly to its users than any of the two.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e5f416c7f66e..cfc3e260a688 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -61,7 +61,6 @@ struct acpi_os_dpc {
 	acpi_osd_exec_callback function;
 	void *context;
 	struct work_struct work;
-	int wait;
 };
 
 #ifdef CONFIG_ACPI_CUSTOM_DSDT
@@ -1067,9 +1066,6 @@ static void acpi_os_execute_deferred(struct work_struct *work)
 {
 	struct acpi_os_dpc *dpc = container_of(work, struct acpi_os_dpc, work);
 
-	if (dpc->wait)
-		acpi_os_wait_events_complete();
-
 	dpc->function(dpc->context);
 	kfree(dpc);
 }
@@ -1089,8 +1085,8 @@ static void acpi_os_execute_deferred(struct work_struct *work)
  *
  ******************************************************************************/
 
-static acpi_status __acpi_os_execute(acpi_execute_type type,
-	acpi_osd_exec_callback function, void *context, int hp)
+acpi_status acpi_os_execute(acpi_execute_type type,
+			    acpi_osd_exec_callback function, void *context)
 {
 	acpi_status status = AE_OK;
 	struct acpi_os_dpc *dpc;
@@ -1117,20 +1113,11 @@ static acpi_status __acpi_os_execute(acpi_execute_type type,
 	dpc->context = context;
 
 	/*
-	 * We can't run hotplug code in keventd_wq/kacpid_wq/kacpid_notify_wq
-	 * because the hotplug code may call driver .remove() functions,
-	 * which invoke flush_scheduled_work/acpi_os_wait_events_complete
-	 * to flush these workqueues.
-	 *
 	 * To prevent lockdep from complaining unnecessarily, make sure that
 	 * there is a different static lockdep key for each workqueue by using
 	 * INIT_WORK() for each of them separately.
 	 */
-	if (hp) {
-		queue = kacpi_hotplug_wq;
-		dpc->wait = 1;
-		INIT_WORK(&dpc->work, acpi_os_execute_deferred);
-	} else if (type == OSL_NOTIFY_HANDLER) {
+	if (type == OSL_NOTIFY_HANDLER) {
 		queue = kacpi_notify_wq;
 		INIT_WORK(&dpc->work, acpi_os_execute_deferred);
 	} else {
@@ -1155,28 +1142,59 @@ static acpi_status __acpi_os_execute(acpi_execute_type type,
 	}
 	return status;
 }
+EXPORT_SYMBOL(acpi_os_execute);
 
-acpi_status acpi_os_execute(acpi_execute_type type,
-			    acpi_osd_exec_callback function, void *context)
+void acpi_os_wait_events_complete(void)
 {
-	return __acpi_os_execute(type, function, context, 0);
+	flush_workqueue(kacpid_wq);
+	flush_workqueue(kacpi_notify_wq);
 }
-EXPORT_SYMBOL(acpi_os_execute);
 
-acpi_status acpi_os_hotplug_execute(acpi_osd_exec_callback function,
-	void *context)
+struct acpi_hp_work {
+	struct work_struct work;
+	acpi_hp_callback func;
+	void *data;
+	u32 src;
+};
+
+static void acpi_hotplug_work_fn(struct work_struct *work)
 {
-	return __acpi_os_execute(0, function, context, 1);
+	struct acpi_hp_work *hpw = container_of(work, struct acpi_hp_work, work);
+
+	acpi_os_wait_events_complete();
+	hpw->func(hpw->data, hpw->src);
+	kfree(hpw);
 }
-EXPORT_SYMBOL(acpi_os_hotplug_execute);
 
-void acpi_os_wait_events_complete(void)
+acpi_status acpi_hotplug_execute(acpi_hp_callback func, void *data, u32 src)
 {
-	flush_workqueue(kacpid_wq);
-	flush_workqueue(kacpi_notify_wq);
+	struct acpi_hp_work *hpw;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+		  "Scheduling function [%p(%p, %u)] for deferred execution.\n",
+		  func, data, src));
+
+	hpw = kmalloc(sizeof(*hpw), GFP_KERNEL);
+	if (!hpw)
+		return AE_NO_MEMORY;
+
+	INIT_WORK(&hpw->work, acpi_hotplug_work_fn);
+	hpw->func = func;
+	hpw->data = data;
+	hpw->src = src;
+	/*
+	 * We can't run hotplug code in kacpid_wq/kacpid_notify_wq etc., because
+	 * the hotplug code may call driver .remove() functions, which may
+	 * invoke flush_scheduled_work()/acpi_os_wait_events_complete() to flush
+	 * these workqueues.
+	 */
+	if (!queue_work(kacpi_hotplug_wq, &hpw->work)) {
+		kfree(hpw);
+		return AE_ERROR;
+	}
+	return AE_OK;
 }
 
-EXPORT_SYMBOL(acpi_os_wait_events_complete);
 
 acpi_status
 acpi_os_create_semaphore(u32 max_units, u32 initial_units, acpi_handle * handle)
@@ -1825,25 +1843,3 @@ void acpi_os_set_prepare_extended_sleep(int (*func)(u8 sleep_state,
 {
 	__acpi_os_prepare_extended_sleep = func;
 }
-
-
-void alloc_acpi_hp_work(acpi_handle handle, u32 type, void *context,
-			void (*func)(struct work_struct *work))
-{
-	struct acpi_hp_work *hp_work;
-	int ret;
-
-	hp_work = kmalloc(sizeof(*hp_work), GFP_KERNEL);
-	if (!hp_work)
-		return;
-
-	hp_work->handle = handle;
-	hp_work->type = type;
-	hp_work->context = context;
-
-	INIT_WORK(&hp_work->work, func);
-	ret = queue_work(kacpi_hotplug_wq, &hp_work->work);
-	if (!ret)
-		kfree(hp_work);
-}
-EXPORT_SYMBOL_GPL(alloc_acpi_hp_work);

commit 5171f4fa744de840c2c20f5b65bd3ee1cd85d0e8
Merge: 975bcabb0543 b042453f3892
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Oct 28 01:20:24 2013 +0100

    Merge branch 'acpi-assorted'
    
    * acpi-assorted:
      ACPI: Add Toshiba NB100 to Vista _OSI blacklist
      ACPI / osl: remove an unneeded NULL check
      ACPI / platform: add ACPI ID for a Broadcom GPS chip
      ACPI: improve acpi_extract_package() utility
      ACPI / LPSS: fix UART Auto Flow Control
      ACPI / platform: Add ACPI IDs for Intel SST audio device
      x86 / ACPI: fix incorrect placement of __initdata tag
      ACPI / thermal: convert printk(LEVEL...) to pr_<lvl>
      ACPI / sysfs: make GPE sysfs attributes only accept correct values
      ACPI / EC: Convert all printk() calls to dynamic debug function
      ACPI / button: Using input_set_capability() to mark device's event capability
      ACPI / osl: implement acpi_os_sleep() with msleep()

commit 5e2be4e0edff4a1021b6743ca6859129cd8e7067
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Oct 18 12:01:43 2013 +0300

    ACPI / osl: remove an unneeded NULL check
    
    "str" is never NULL here so I have removed the check.  There are static
    checkers which complain about superfluous NULL checks because it may
    indicate confusion or a bug.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index b1629b571cb2..4923dd4232b3 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1335,7 +1335,7 @@ static int __init acpi_os_name_setup(char *str)
 	if (!str || !*str)
 		return 0;
 
-	for (; count-- && str && *str; str++) {
+	for (; count-- && *str; str++) {
 		if (isalnum(*str) || *str == ' ' || *str == ':')
 			*p++ = *str;
 		else if (*str == '\'' || *str == '"')

commit 302822996fd572676bb66a7c4351f6faa0e4ddfd
Author: Liu Chuansheng <chuansheng.liu@intel.com>
Date:   Thu Sep 12 01:42:57 2013 +0800

    ACPI / osl: implement acpi_os_sleep() with msleep()
    
    Currently, acpi_os_sleep() uses schedule_timeout_interruptible()
    which can be interrupted by a signal, and that causes the real sleep
    time to be shorter.
    
    According to the ACPI spec:
    
     The Sleep term is used to implement long-term timing requirements.
     Execution is delayed for at least the required number of milliseconds.
    
    The sleeping time should be at least the required number msecs, so use
    msleep() which guarantees that to implement it.
    
    Signed-off-by: Liu Chuansheng <chuansheng.liu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e5f416c7f66e..b1629b571cb2 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -820,7 +820,7 @@ acpi_status acpi_os_remove_interrupt_handler(u32 irq, acpi_osd_handler handler)
 
 void acpi_os_sleep(u64 ms)
 {
-	schedule_timeout_interruptible(msecs_to_jiffies(ms));
+	msleep(ms);
 }
 
 void acpi_os_stall(u32 us)

commit bee7f9c83e1d18af6fee06b97b6558cbd1cded45
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Sep 6 19:08:00 2013 -0700

    ACPI / x86: Increase override tables number limit
    
    Current ACPI tables in initrd is limited to 10, that is too small.
    64 should be good enough as we have 35 sigs and could have several
    SSDT.
    
    Two problems in current code prevent us from increasing limit:
     1. The cpio file info array is put in stack, as every element is 32
        bytes, could run out of stack if we have that array size to 64.
        We can move it out from stack, make it global and put it into the
        __initdata section.
     2. early_ioremap() only can remap 256k one time. Current code maps
        10 tables at a time. If we increased that limit, the whole size
        could be more than 256k, so early_ioremap() would fail with that.
        We can map chunks one by one during copying, instead of mapping
        all of them together.
    
    Signed-off-by: Yinghai <yinghai@kernel.org>
    Acked-by: Tejun Heo <tj@kernel.org>
    Tested-by: Thomas Renninger <trenn@suse.de>
    Reviewed-by: Tang Chen <tangchen@cn.fujitsu.com>
    Tested-by: Tang Chen <tangchen@cn.fujitsu.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e5f416c7f66e..88bb9d05b038 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -569,8 +569,10 @@ static const char * const table_sigs[] = {
 
 #define ACPI_HEADER_SIZE sizeof(struct acpi_table_header)
 
-/* Must not increase 10 or needs code modification below */
-#define ACPI_OVERRIDE_TABLES 10
+#define ACPI_OVERRIDE_TABLES 64
+static struct cpio_data __initdata acpi_initrd_files[ACPI_OVERRIDE_TABLES];
+
+#define MAP_CHUNK_SIZE   (NR_FIX_BTMAPS << PAGE_SHIFT)
 
 void __init acpi_initrd_override(void *data, size_t size)
 {
@@ -579,8 +581,6 @@ void __init acpi_initrd_override(void *data, size_t size)
 	struct acpi_table_header *table;
 	char cpio_path[32] = "kernel/firmware/acpi/";
 	struct cpio_data file;
-	struct cpio_data early_initrd_files[ACPI_OVERRIDE_TABLES];
-	char *p;
 
 	if (data == NULL || size == 0)
 		return;
@@ -625,8 +625,8 @@ void __init acpi_initrd_override(void *data, size_t size)
 			table->signature, cpio_path, file.name, table->length);
 
 		all_tables_size += table->length;
-		early_initrd_files[table_nr].data = file.data;
-		early_initrd_files[table_nr].size = file.size;
+		acpi_initrd_files[table_nr].data = file.data;
+		acpi_initrd_files[table_nr].size = file.size;
 		table_nr++;
 	}
 	if (table_nr == 0)
@@ -652,14 +652,34 @@ void __init acpi_initrd_override(void *data, size_t size)
 	memblock_reserve(acpi_tables_addr, all_tables_size);
 	arch_reserve_mem_area(acpi_tables_addr, all_tables_size);
 
-	p = early_ioremap(acpi_tables_addr, all_tables_size);
-
+	/*
+	 * early_ioremap only can remap 256k one time. If we map all
+	 * tables one time, we will hit the limit. Need to map chunks
+	 * one by one during copying the same as that in relocate_initrd().
+	 */
 	for (no = 0; no < table_nr; no++) {
-		memcpy(p + total_offset, early_initrd_files[no].data,
-		       early_initrd_files[no].size);
-		total_offset += early_initrd_files[no].size;
+		unsigned char *src_p = acpi_initrd_files[no].data;
+		phys_addr_t size = acpi_initrd_files[no].size;
+		phys_addr_t dest_addr = acpi_tables_addr + total_offset;
+		phys_addr_t slop, clen;
+		char *dest_p;
+
+		total_offset += size;
+
+		while (size) {
+			slop = dest_addr & ~PAGE_MASK;
+			clen = size;
+			if (clen > MAP_CHUNK_SIZE - slop)
+				clen = MAP_CHUNK_SIZE - slop;
+			dest_p = early_ioremap(dest_addr & PAGE_MASK,
+						 clen + slop);
+			memcpy(dest_p + slop, src_p, clen);
+			early_iounmap(dest_p, clen + slop);
+			src_p += clen;
+			dest_addr += clen;
+			size -= clen;
+		}
 	}
-	early_iounmap(p, all_tables_size);
 }
 #endif /* CONFIG_ACPI_INITRD_TABLE_OVERRIDE */
 

commit 0c581415b522267138d807814e526aa7534b9a61
Merge: afdca01c9821 7702ae0dd9b4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 27 01:29:04 2013 +0200

    Merge branch 'acpi-assorted'
    
    * acpi-assorted:
      ACPI / osl: Kill macro INVALID_TABLE().
      earlycpio.c: Fix the confusing comment of find_cpio_data().
      ACPI / x86: Print Hot-Pluggable Field in SRAT.
      ACPI / thermal: Use THERMAL_TRIPS_NONE macro to replace number
      ACPI / thermal: Remove unused macros in the driver/acpi/thermal.c
      ACPI / thermal: Remove the unused lock of struct acpi_thermal
      ACPI / osl: Fix osi_setup_entries[] __initdata attribute location
      ACPI / numa: Fix __init attribute location in slit_valid()
      ACPI / dock: Fix __init attribute location in find_dock_and_bay()
      ACPI / Sleep: Fix incorrect placement of __initdata
      ACPI / processor: Fix incorrect placement of __initdata
      ACPI / EC: Fix incorrect placement of __initdata
      ACPI / scan: Drop unnecessary label from acpi_create_platform_device()
      ACPI: Move acpi_bus_get_device() from bus.c to scan.c
      ACPI / scan: Allow platform device creation without any IO resources
      ACPI: Cleanup sparse warning on acpi_os_initialize1()
      platform / thinkpad: Remove deprecated hotkey_report_mode parameter
      ACPI: Remove the old /proc/acpi/event interface

commit afdca01c9821134e71011029a194dd8fcb88c97e
Merge: 4b319f290d3b 36b99b22877b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 27 01:28:48 2013 +0200

    Merge branch 'acpica'
    
    * acpica:
      ACPICA: Update version to 20130725.
      ACPICA: Update names for walk_namespace callbacks to clarify usage.
      ACPICA: Return error if DerefOf resolves to a null package element.
      ACPICA: Make ACPI Power Management Timer (PM Timer) optional.
      ACPICA: Fix divergences of the commit - ACPICA: Expose OSI version.
      ACPICA: Fix possible fault for methods that optionally have no return value.
      ACPICA: DeRefOf operator: Update to fully resolve FieldUnit and BufferField refs.
      ACPICA: Emit all unresolved method externals in a text block
      ACPICA: Export acpi_tb_validate_rsdp().
      ACPI: Add facility to remove all _OSI strings
      ACPI: Add facility to disable all _OSI OS vendor strings
      ACPICA: Add acpi_update_interfaces() public interface
      ACPICA: Update version to 20130626
      ACPICA: Fix compiler warnings for casting issues (only some compilers)
      ACPICA: Remove restriction of 256 maximum GPEs in any GPE block
      ACPICA: Disassembler: Expand maximum output string length to 64K
      ACPICA: TableManager: Export acpi_tb_scan_memory_for_rsdp()
      ACPICA: Update comments about behavior when _STA does not exist

commit 7702ae0dd9b40930931914866999a2ac9734d3eb
Author: Tang Chen <tangchen@cn.fujitsu.com>
Date:   Wed Aug 14 17:37:08 2013 +0800

    ACPI / osl: Kill macro INVALID_TABLE().
    
    The macro INVALID_TABLE() is defined like this:
    
     #define INVALID_TABLE(x, path, name)                                    \
             { pr_err("ACPI OVERRIDE: " x " [%s%s]\n", path, name); continue; }
    
    And it is used like this:
    
            for (...) {
                    ...
                    if (...)
                            INVALID_TABLE()
                    ...
            }
    
    The "continue" in the macro makes the code hard to understand.
    
    And also, this macro is only used several times in a single file.
    As suggested by Joe Perches <joe@perches.com>, we can remote it and
    use pr_err directly.
    
    So after this patch, this macro is removed, and pr_err() is used
    like this:
    
            for (...) {
                    ...
                    if (...) {
                            pr_err("ACPI OVERRIDE: ......");
                            continue;
                    }
                    ...
            }
    
    Signed-off-by: Tang Chen <tangchen@cn.fujitsu.com>
    Suggested-by: Joe Perches <joe@perches.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Reviewed-by: Zhang Yanfei <zhangyanfei@cn.fujitsu.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index eb95978854a3..6bc08272f050 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -564,10 +564,6 @@ static const char * const table_sigs[] = {
 	ACPI_SIG_WDRT, ACPI_SIG_DSDT, ACPI_SIG_FADT, ACPI_SIG_PSDT,
 	ACPI_SIG_RSDT, ACPI_SIG_XSDT, ACPI_SIG_SSDT, NULL };
 
-/* Non-fatal errors: Affected tables/files are ignored */
-#define INVALID_TABLE(x, path, name)					\
-	{ pr_err("ACPI OVERRIDE: " x " [%s%s]\n", path, name); continue; }
-
 #define ACPI_HEADER_SIZE sizeof(struct acpi_table_header)
 
 /* Must not increase 10 or needs code modification below */
@@ -594,9 +590,11 @@ void __init acpi_initrd_override(void *data, size_t size)
 		data += offset;
 		size -= offset;
 
-		if (file.size < sizeof(struct acpi_table_header))
-			INVALID_TABLE("Table smaller than ACPI header",
-				      cpio_path, file.name);
+		if (file.size < sizeof(struct acpi_table_header)) {
+			pr_err("ACPI OVERRIDE: Table smaller than ACPI header [%s%s]\n",
+				cpio_path, file.name);
+			continue;
+		}
 
 		table = file.data;
 
@@ -604,15 +602,21 @@ void __init acpi_initrd_override(void *data, size_t size)
 			if (!memcmp(table->signature, table_sigs[sig], 4))
 				break;
 
-		if (!table_sigs[sig])
-			INVALID_TABLE("Unknown signature",
-				      cpio_path, file.name);
-		if (file.size != table->length)
-			INVALID_TABLE("File length does not match table length",
-				      cpio_path, file.name);
-		if (acpi_table_checksum(file.data, table->length))
-			INVALID_TABLE("Bad table checksum",
-				      cpio_path, file.name);
+		if (!table_sigs[sig]) {
+			pr_err("ACPI OVERRIDE: Unknown signature [%s%s]\n",
+				cpio_path, file.name);
+			continue;
+		}
+		if (file.size != table->length) {
+			pr_err("ACPI OVERRIDE: File length does not match table length [%s%s]\n",
+				cpio_path, file.name);
+			continue;
+		}
+		if (acpi_table_checksum(file.data, table->length)) {
+			pr_err("ACPI OVERRIDE: Bad table checksum [%s%s]\n",
+				cpio_path, file.name);
+			continue;
+		}
 
 		pr_info("%4.4s ACPI table found in initrd [%s%s][0x%x]\n",
 			table->signature, cpio_path, file.name, table->length);

commit e73d3136355f511d3e1c2ef21acf02b19bd2b650
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Aug 13 18:31:15 2013 +0800

    ACPI / osl: Fix osi_setup_entries[] __initdata attribute location
    
    __initdata should come after the variable name being declared and
    nowhere else, in this way the variable will be placed in the
    intended section.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 605718f66642..eb95978854a3 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1352,8 +1352,8 @@ struct osi_setup_entry {
 	bool enable;
 };
 
-static struct osi_setup_entry __initdata
-		osi_setup_entries[OSI_STRING_ENTRIES_MAX] = {
+static struct osi_setup_entry
+		osi_setup_entries[OSI_STRING_ENTRIES_MAX] __initdata = {
 	{"Module Device", true},
 	{"Processor Device", true},
 	{"3.0 _SCP Extensions", true},

commit d6b47b122473885abc882e337ac2d321bbcfb378
Author: Ben Guthro <benjamin.guthro@citrix.com>
Date:   Tue Jul 30 08:24:52 2013 -0400

    ACPI / sleep: Introduce acpi_os_prepare_extended_sleep() for extended sleep path
    
    Like acpi_os_prepare_sleep(), register a callback for use in systems
    like tboot, and xen, which have system specific requirements outside
    of ACPICA.  This mirrors the functionality in acpi_os_prepare_sleep(),
    called from acpi_hw_sleep()
    
    Signed-off-by: Ben Guthro <benjamin.guthro@citrix.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 6ab2c3505520..a934950ff7a0 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -79,6 +79,8 @@ extern char line_buf[80];
 
 static int (*__acpi_os_prepare_sleep)(u8 sleep_state, u32 pm1a_ctrl,
 				      u32 pm1b_ctrl);
+static int (*__acpi_os_prepare_extended_sleep)(u8 sleep_state, u32 val_a,
+				      u32 val_b);
 
 static acpi_osd_handler acpi_irq_handler;
 static void *acpi_irq_context;
@@ -1779,6 +1781,28 @@ void acpi_os_set_prepare_sleep(int (*func)(u8 sleep_state,
 	__acpi_os_prepare_sleep = func;
 }
 
+acpi_status acpi_os_prepare_extended_sleep(u8 sleep_state, u32 val_a,
+				  u32 val_b)
+{
+	int rc = 0;
+	if (__acpi_os_prepare_extended_sleep)
+		rc = __acpi_os_prepare_extended_sleep(sleep_state,
+					     val_a, val_b);
+	if (rc < 0)
+		return AE_ERROR;
+	else if (rc > 0)
+		return AE_CTRL_SKIP;
+
+	return AE_OK;
+}
+
+void acpi_os_set_prepare_extended_sleep(int (*func)(u8 sleep_state,
+			       u32 val_a, u32 val_b))
+{
+	__acpi_os_prepare_extended_sleep = func;
+}
+
+
 void alloc_acpi_hp_work(acpi_handle handle, u32 type, void *context,
 			void (*func)(struct work_struct *work))
 {

commit 1129c92faa069581bf3acf34cae92477bd6161d8
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Jul 23 16:11:55 2013 +0800

    ACPI: Cleanup sparse warning on acpi_os_initialize1()
    
    This patch cleans up the following sparse warning:
    
    # make C=2 drivers/acpi/osl.o
    ...
    drivers/acpi/osl.c:1775:20: warning: symbol 'acpi_os_initialize1' was not declared. Should it be static?
    ...
      CC      drivers/acpi/osl.o
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 6ab2c3505520..605718f66642 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -52,6 +52,7 @@
 #include <acpi/acpi.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/processor.h>
+#include "internal.h"
 
 #define _COMPONENT		ACPI_OS_SERVICES
 ACPI_MODULE_NAME("osl");

commit 741d81280ad2b31fc3d76c49fa5c1fe09f3a6f68
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Jul 22 16:08:36 2013 +0800

    ACPI: Add facility to remove all _OSI strings
    
    This patch changes the "acpi_osi=" boot parameter implementation so
    that:
    1. "acpi_osi=!" can be used to disable all _OSI OS vendor strings by
       default.  It is meaningless to specify "acpi_osi=!" multiple
       times as it can only affect the default state of the target _OSI
       strings.
    2. "acpi_osi=!*" can be used to remove all _OSI OS vendor strings
       and all _OSI feature group strings.  It is useful to specify
       "acpi_osi=!*" multiple times through kernel command line to
       override the current state of the target _OSI strings.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Reviewed-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e8baa408faef..cc1ed12d0b89 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1380,6 +1380,13 @@ void __init acpi_osi_setup(char *str)
 		if (*str == '\0') {
 			osi_linux.default_disabling = 1;
 			return;
+		} else if (*str == '*') {
+			acpi_update_interfaces(ACPI_DISABLE_ALL_STRINGS);
+			for (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {
+				osi = &osi_setup_entries[i];
+				osi->enable = false;
+			}
+			return;
 		}
 		enable = false;
 	}

commit 5dc17986fdc3d2425838cb8d699152c3c30d1208
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Jul 22 16:08:25 2013 +0800

    ACPI: Add facility to disable all _OSI OS vendor strings
    
    This patch introduces "acpi_osi=!" command line to force Linux replying
    "UNSUPPORTED" to all of the _OSI strings.  This patch is based on an
    ACPICA enhancement - the new API acpi_update_interfaces().
    
    The _OSI object provides the platform with the ability to query OSPM
    to determine the set of ACPI related interfaces, behaviors, or
    features that the operating system supports.  The argument passed to
    the _OSI is a string like the followings:
    1. Feature Group String, examples include
       Module Device
       Processor Device
       3.0 _SCP Extensions
       Processor Aggregator Device
       ...
    2. OS Vendor String, examples include
       Linux
       FreeBSD
       Windows
       ...
    
    There are AML codes provided in the ACPI namespace written in the
    following style to determine OSPM interfaces / features:
        Method(OSCK)
        {
            if (CondRefOf(_OSI, Local0))
            {
                if (\_OSI("Windows"))
                {
                    Return (One)
                }
                if (\_OSI("Windows 2006"))
                {
                    Return (Ones)
                }
                Return (Zero)
            }
            Return (Zero)
        }
    
    There is a debugging facility implemented in Linux.  Users can pass
    "acpi_osi=" boot parameters to the kernel to tune the _OSI evaluation
    result so that certain AML codes can be executed.  Current
    implementation includes:
    1. 'acpi_osi=' - this makes CondRefOf(_OSI, Local0) TRUE
    2. 'acpi_osi="Windows"' - this makes \_OSI("Windows") TRUE
    3. 'acpi_osi="!Windows"' - this makes \_OSI("Windows") FALSE
    The function to implement this feature is also used as a quirk mechanism
    in the Linux ACPI subystem.
    
    When _OSI is evaluatated by the AML codes, ACPICA replies "SUPPORTED"
    to all Windows operating system vendor strings.  This is because
    Windows operating systems return "SUPPORTED" if the argument to the
    _OSI method specifies an earlier version of Windows.  Please refer to
    the following MSDN document:
    
    How to Identify the Windows Version in ACPI by Using _OSI
    http://msdn.microsoft.com/en-us/library/hardware/gg463275.aspx
    
    This adds difficulties when developers want to feed specific Windows
    operating system vendor string to the BIOS codes for debugging
    purpose, multiple acpi_osi="!xxx" have to be specified in the command
    line to force Linux replying "UNSUPPORTED" to the Windows OS vendor
    strings listed in the AML codes.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Reviewed-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 6ab2c3505520..e8baa408faef 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -140,7 +140,8 @@ static struct osi_linux {
 	unsigned int	enable:1;
 	unsigned int	dmi:1;
 	unsigned int	cmdline:1;
-} osi_linux = {0, 0, 0};
+	unsigned int	default_disabling:1;
+} osi_linux = {0, 0, 0, 0};
 
 static u32 acpi_osi_handler(acpi_string interface, u32 supported)
 {
@@ -1376,6 +1377,10 @@ void __init acpi_osi_setup(char *str)
 
 	if (*str == '!') {
 		str++;
+		if (*str == '\0') {
+			osi_linux.default_disabling = 1;
+			return;
+		}
 		enable = false;
 	}
 
@@ -1441,6 +1446,13 @@ static void __init acpi_osi_setup_late(void)
 	int i;
 	acpi_status status;
 
+	if (osi_linux.default_disabling) {
+		status = acpi_update_interfaces(ACPI_DISABLE_ALL_VENDOR_STRINGS);
+
+		if (ACPI_SUCCESS(status))
+			printk(KERN_INFO PREFIX "Disabled all _OSI OS vendors\n");
+	}
+
 	for (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {
 		osi = &osi_setup_entries[i];
 		str = osi->string;

commit 5c0b1b2003362c9015ee3324816c0966efaa0f88
Merge: d5ba5b141dae 10619066a353
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 29 15:03:44 2013 +0200

    Merge branch 'acpi-assorted'
    
    * acpi-assorted:
      ACPI: implement acpi_os_get_timer() according the spec

commit 10619066a353f27fe3700a448fa2b21643687840
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu May 23 10:27:46 2013 +0300

    ACPI: implement acpi_os_get_timer() according the spec
    
    ACPI Timer() opcode should return monotonically increasing clock with 100ns
    granularity according the ACPI 5.0 spec.
    
    Testing the current Timer() implementation with following ASL code (and an
    additional debug print in acpi_os_sleep() to get the sleep times dumped out
    to dmesg):
    
            // Test: 10ms
            Store(Timer, Local1)
            Sleep(10)
            Divide(Subtract(Timer, Local1), 10000,, Local1)
            Sleep(Local1)
    
            // Test: 200ms
            Store(Timer, Local1)
            Sleep(200)
            Divide(Subtract(Timer, Local1), 10000,, Local1)
            Sleep(Local1)
    
            // Test 1300ms
            Store(Timer, Local1)
            Sleep(1300)
            Divide(Subtract(Timer, Local1), 10000,, Local1)
            Sleep(Local1)
    
    The second sleep value is calculated using Timer(). If the implementation
    is good enough we should be able to get the second value pretty close to
    the first.
    
    However, the current Timer() gives pretty bad sleep times:
    
            [   11.488100] ACPI: acpi_os_get_timer() TBD
            [   11.492150] ACPI: Sleep(10)
            [   11.502993] ACPI: Sleep(0)
            [   11.506315] ACPI: Sleep(200)
            [   11.706237] ACPI: Sleep(0)
            [   11.709550] ACPI: Sleep(1300)
            [   13.008929] ACPI: Sleep(0)
    
    Fix this with the help of ktime_get(). Once the fix is applied and run
    against the same ASL code we get:
    
            [   11.486786] ACPI: Sleep(10)
            [   11.499029] ACPI: Sleep(12)
            [   11.512350] ACPI: Sleep(200)
            [   11.712282] ACPI: Sleep(200)
            [   11.912170] ACPI: Sleep(1300)
            [   13.211577] ACPI: Sleep(1300)
    
    That is much more closer to the values we expected.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e72186340fec..c29076909efe 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -835,19 +835,9 @@ void acpi_os_stall(u32 us)
  */
 u64 acpi_os_get_timer(void)
 {
-	static u64 t;
-
-#ifdef	CONFIG_HPET
-	/* TBD: use HPET if available */
-#endif
-
-#ifdef	CONFIG_X86_PM_TIMER
-	/* TBD: default to PM timer if HPET was not available */
-#endif
-	if (!t)
-		printk(KERN_ERR PREFIX "acpi_os_get_timer() TBD\n");
-
-	return ++t;
+	u64 time_ns = ktime_to_ns(ktime_get());
+	do_div(time_ns, 100);
+	return time_ns;
 }
 
 acpi_status acpi_os_read_port(acpi_io_address port, u32 * value, u32 width)

commit b75dd2977fc3c5848f739681fc799f27b1322e44
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Sat Jun 8 00:58:48 2013 +0000

    ACPICA: Add option to disable loading of SSDTs from the RSDT/XSDT
    
    Optionally do not load any SSDTs from the RSDT/XSDT during
    initialization.  This can be useful for overriding SSDTs
    using DSDT overriding, thus useful for debugging ACPI
    problems on some machines.  Lv Zheng. ACPICA BZ 1005.
    
    References: https://bugs.acpica.org/show_bug.cgi?id=1005
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e72186340fec..da6b6634e5b3 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1715,6 +1715,17 @@ acpi_status acpi_os_release_object(acpi_cache_t * cache, void *object)
 }
 #endif
 
+static int __init acpi_no_auto_ssdt_setup(char *s)
+{
+        printk(KERN_NOTICE PREFIX "SSDT auto-load disabled\n");
+
+        acpi_gbl_disable_ssdt_table_load = TRUE;
+
+        return 1;
+}
+
+__setup("acpi_no_auto_ssdt", acpi_no_auto_ssdt_setup);
+
 acpi_status __init acpi_os_initialize(void)
 {
 	acpi_os_map_generic_address(&acpi_gbl_FADT.xpm1a_event_block);

commit a6432ded299726f123b93d0132fead200551535c
Author: Wang YanQing <udknight@gmail.com>
Date:   Tue Apr 23 01:19:19 2013 +0200

    ACPI: Fix wrong parameter passed to memblock_reserve
    
    Commit 53aac44 (ACPI: Store valid ACPI tables passed via early initrd
    in reserved memblock areas) introduced acpi_initrd_override() that
    passes a wrong value as the second argument to memblock_reserve().
    
    Namely, the second argument of memblock_reserve() is the size of the
    region, not the address of the top of it, so make
    acpi_initrd_override() pass the size in there as appropriate.
    
    [rjw: Changelog]
    Signed-off-by: Wang YanQing <udknight@gmail.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Cc: 3.8+ <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 4d31748faca3..e72186340fec 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -641,7 +641,7 @@ void __init acpi_initrd_override(void *data, size_t size)
 	 * Both memblock_reserve and e820_add_region (via arch_reserve_mem_area)
 	 * works fine.
 	 */
-	memblock_reserve(acpi_tables_addr, acpi_tables_addr + all_tables_size);
+	memblock_reserve(acpi_tables_addr, all_tables_size);
 	arch_reserve_mem_area(acpi_tables_addr, all_tables_size);
 
 	p = early_ioremap(acpi_tables_addr, all_tables_size);

commit e4f5224464739a89e6a6c9169211ef4f76165056
Author: Alexandru Gheorghiu <gheorghiuandru@gmail.com>
Date:   Tue Mar 12 08:53:02 2013 +0000

    ACPI: Use resource_size() in osl.c
    
    Use the resource_size() function instead of explicit computation.
    
    [rjw: Subject and changelog]
    Signed-off-by: Alexandru Gheorghiu <gheorghiuandru@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 586e7e993d3d..4d31748faca3 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1555,7 +1555,7 @@ int acpi_check_resource_conflict(const struct resource *res)
 	else
 		space_id = ACPI_ADR_SPACE_SYSTEM_MEMORY;
 
-	length = res->end - res->start + 1;
+	length = resource_size(res);
 	if (acpi_enforce_resources != ENFORCE_RESOURCES_NO)
 		warn = 1;
 	clash = acpi_check_address_range(space_id, res->start, length, warn);

commit 556f12f602ac0a18a82ca83e9f8e8547688fc633
Merge: fffddfd6c8e0 018ba0a6efad
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 21:18:18 2013 -0800

    Merge tag 'pci-v3.9-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI changes from Bjorn Helgaas:
     "Host bridge hotplug
        - Major overhaul of ACPI host bridge add/start (Rafael Wysocki, Yinghai Lu)
        - Major overhaul of PCI/ACPI binding (Rafael Wysocki, Yinghai Lu)
        - Split out ACPI host bridge and ACPI PCI device hotplug (Yinghai Lu)
        - Stop caching _PRT and make independent of bus numbers (Yinghai Lu)
    
      PCI device hotplug
        - Clean up cpqphp dead code (Sasha Levin)
        - Disable ARI unless device and upstream bridge support it (Yijing Wang)
        - Initialize all hot-added devices (not functions 0-7) (Yijing Wang)
    
      Power management
        - Don't touch ASPM if disabled (Joe Lawrence)
        - Fix ASPM link state management (Myron Stowe)
    
      Miscellaneous
        - Fix PCI_EXP_FLAGS accessor (Alex Williamson)
        - Disable Bus Master in pci_device_shutdown (Konstantin Khlebnikov)
        - Document hotplug resource and MPS parameters (Yijing Wang)
        - Add accessor for PCIe capabilities (Myron Stowe)
        - Drop pciehp suspend/resume messages (Paul Bolle)
        - Make pci_slot built-in only (not a module) (Jiang Liu)
        - Remove unused PCI/ACPI bind ops (Jiang Liu)
        - Removed used pci_root_bus (Bjorn Helgaas)"
    
    * tag 'pci-v3.9-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (51 commits)
      PCI/ACPI: Don't cache _PRT, and don't associate them with bus numbers
      PCI: Fix PCI Express Capability accessors for PCI_EXP_FLAGS
      ACPI / PCI: Make pci_slot built-in only, not a module
      PCI/PM: Clear state_saved during suspend
      PCI: Use atomic_inc_return() rather than atomic_add_return()
      PCI: Catch attempts to disable already-disabled devices
      PCI: Disable Bus Master unconditionally in pci_device_shutdown()
      PCI: acpiphp: Remove dead code for PCI host bridge hotplug
      PCI: acpiphp: Create companion ACPI devices before creating PCI devices
      PCI: Remove unused "rc" in virtfn_add_bus()
      PCI: pciehp: Drop suspend/resume ENTRY messages
      PCI/ASPM: Don't touch ASPM if forcibly disabled
      PCI/ASPM: Deallocate upstream link state even if device is not PCIe
      PCI: Document MPS parameters pci=pcie_bus_safe, pci=pcie_bus_perf, etc
      PCI: Document hpiosize= and hpmemsize= resource reservation parameters
      PCI: Use PCI Express Capability accessor
      PCI: Introduce accessor to retrieve PCIe Capabilities Register
      PCI: Put pci_dev in device tree as early as possible
      PCI: Skip attaching driver in device_add()
      PCI: acpiphp: Keep driver loaded even if no slots found
      ...

commit 9043a2650cd21f96f831a97f516c2c302e21fb70
Merge: ab7826595e9e d9d8d7ed498e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 15:41:43 2013 -0800

    Merge tag 'modules-next-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux
    
    Pull module update from Rusty Russell:
     "The sweeping change is to make add_taint() explicitly indicate whether
      to disable lockdep, but it's a mechanical change."
    
    * tag 'modules-next-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux:
      MODSIGN: Add option to not sign modules during modules_install
      MODSIGN: Add -s <signature> option to sign-file
      MODSIGN: Specify the hash algorithm on sign-file command line
      MODSIGN: Simplify Makefile with a Kconfig helper
      module: clean up load_module a little more.
      modpost: Ignore ARC specific non-alloc sections
      module: constify within_module_*
      taint: add explicit flag to show whether lock dep is still OK.
      module: printk message when module signature fail taints kernel.

commit 7113fe74c10bc01abfdad2fe1f9ca023b0f83685
Merge: a68d35323b09 957d1282bb8c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 15 13:58:54 2013 +0100

    Merge branch 'pm-assorted'
    
    * pm-assorted:
      suspend: enable freeze timeout configuration through sys
      ACPI: enable ACPI SCI during suspend
      PM: Introduce suspend state PM_SUSPEND_FREEZE
      PM / Runtime: Add new helper function: pm_runtime_active()
      PM / tracing: remove deprecated power trace API
      PM: don't use [delayed_]work_pending()
      PM / Domains: don't use [delayed_]work_pending()

commit 89a22dadb8810983868f5bbbc5530b27bf714a60
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Mon Feb 4 07:10:10 2013 +0000

    ACPI: enable ACPI SCI during suspend
    
    Enable ACPI SCI during suspend so that SCI can be used
    as wake events for PM_SUSPEND_FREEZE.
    
    For S3/S4 transition,
    We disable all GPEs in suspend_ops->prepare_late() to
    fix a problem that GPEs may trigger SCI  before
    arch_suspend_disable_irqs() is run.
    So it is safe to leave the SCI enabled until
    arch_suspend_irq_disable() is run.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 3ff267861541..3adeb10ff3ec 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -787,7 +787,7 @@ acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,
 
 	acpi_irq_handler = handler;
 	acpi_irq_context = context;
-	if (request_irq(irq, acpi_irq, IRQF_SHARED, "acpi", acpi_irq)) {
+	if (request_irq(irq, acpi_irq, IRQF_SHARED | IRQF_NO_SUSPEND, "acpi", acpi_irq)) {
 		printk(KERN_ERR PREFIX "SCI (IRQ%d) allocation failed\n", irq);
 		acpi_irq_handler = NULL;
 		return AE_NOT_ACQUIRED;

commit 83e68189745ad931c2afd45d8ee3303929233e7f
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Wed Nov 14 09:42:35 2012 +0000

    efi: Make 'efi_enabled' a function to query EFI facilities
    
    Originally 'efi_enabled' indicated whether a kernel was booted from
    EFI firmware. Over time its semantics have changed, and it now
    indicates whether or not we are booted on an EFI machine with
    bit-native firmware, e.g. 64-bit kernel with 64-bit firmware.
    
    The immediate motivation for this patch is the bug report at,
    
        https://bugs.launchpad.net/ubuntu-cdimage/+bug/1040557
    
    which details how running a platform driver on an EFI machine that is
    designed to run under BIOS can cause the machine to become
    bricked. Also, the following report,
    
        https://bugzilla.kernel.org/show_bug.cgi?id=47121
    
    details how running said driver can also cause Machine Check
    Exceptions. Drivers need a new means of detecting whether they're
    running on an EFI machine, as sadly the expression,
    
        if (!efi_enabled)
    
    hasn't been a sufficient condition for quite some time.
    
    Users actually want to query 'efi_enabled' for different reasons -
    what they really want access to is the list of available EFI
    facilities.
    
    For instance, the x86 reboot code needs to know whether it can invoke
    the ResetSystem() function provided by the EFI runtime services, while
    the ACPI OSL code wants to know whether the EFI config tables were
    mapped successfully. There are also checks in some of the platform
    driver code to simply see if they're running on an EFI machine (which
    would make it a bad idea to do BIOS-y things).
    
    This patch is a prereq for the samsung-laptop fix patch.
    
    Cc: David Airlie <airlied@linux.ie>
    Cc: Corentin Chary <corentincj@iksaif.net>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Dave Jiang <dave.jiang@intel.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Colin Ian King <colin.king@canonical.com>
    Cc: Steve Langasek <steve.langasek@canonical.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad@kernel.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 3ff267861541..bd22f8667eed 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -250,7 +250,7 @@ acpi_physical_address __init acpi_os_get_root_pointer(void)
 		return acpi_rsdp;
 #endif
 
-	if (efi_enabled) {
+	if (efi_enabled(EFI_CONFIG_TABLES)) {
 		if (efi.acpi20 != EFI_INVALID_TABLE_ADDR)
 			return efi.acpi20;
 		else if (efi.acpi != EFI_INVALID_TABLE_ADDR)

commit 92d8aff3a317fcd6f78ed9ac13dbbaeae8cb11ed
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jan 21 13:20:47 2013 -0800

    PCI/ACPI: acpiphp: Rename alloc_acpiphp_hp_work() to alloc_acpi_hp_work()
    
    Will need to use it for PCI root bridge hotplug support, so rename
    *acpiphp* to *acpi* and move to osc.c.  Also make kacpi_hotplug_wq static
    after that.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    CC: Len Brown <lenb@kernel.org>
    CC: linux-acpi@vger.kernel.org

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 3ff267861541..59ec5f52e849 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -84,8 +84,7 @@ static acpi_osd_handler acpi_irq_handler;
 static void *acpi_irq_context;
 static struct workqueue_struct *kacpid_wq;
 static struct workqueue_struct *kacpi_notify_wq;
-struct workqueue_struct *kacpi_hotplug_wq;
-EXPORT_SYMBOL(kacpi_hotplug_wq);
+static struct workqueue_struct *kacpi_hotplug_wq;
 
 /*
  * This list of permanent mappings is for memory that may be accessed from
@@ -1778,3 +1777,24 @@ void acpi_os_set_prepare_sleep(int (*func)(u8 sleep_state,
 {
 	__acpi_os_prepare_sleep = func;
 }
+
+void alloc_acpi_hp_work(acpi_handle handle, u32 type, void *context,
+			void (*func)(struct work_struct *work))
+{
+	struct acpi_hp_work *hp_work;
+	int ret;
+
+	hp_work = kmalloc(sizeof(*hp_work), GFP_KERNEL);
+	if (!hp_work)
+		return;
+
+	hp_work->handle = handle;
+	hp_work->type = type;
+	hp_work->context = context;
+
+	INIT_WORK(&hp_work->work, func);
+	ret = queue_work(kacpi_hotplug_wq, &hp_work->work);
+	if (!ret)
+		kfree(hp_work);
+}
+EXPORT_SYMBOL_GPL(alloc_acpi_hp_work);

commit 373d4d099761cb1f637bed488ab3871945882273
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Jan 21 17:17:39 2013 +1030

    taint: add explicit flag to show whether lock dep is still OK.
    
    Fix up all callers as they were before, with make one change: an
    unsigned module taints the kernel, but doesn't turn off lockdep.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 3ff267861541..535e888bad78 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -661,7 +661,7 @@ static void acpi_table_taint(struct acpi_table_header *table)
 	pr_warn(PREFIX
 		"Override [%4.4s-%8.8s], this is unsafe: tainting kernel\n",
 		table->signature, table->oem_table_id);
-	add_taint(TAINT_OVERRIDDEN_ACPI_TABLE);
+	add_taint(TAINT_OVERRIDDEN_ACPI_TABLE, LOCKDEP_NOW_UNRELIABLE);
 }
 
 

commit 18dd0bf22b6f0c1bd5e4e813a42245ed86ec57b6
Merge: 2d9c8b5d6a5f 385ddeac7ed9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 14 10:03:23 2012 -0800

    Merge branch 'x86-acpi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 ACPI update from Peter Anvin:
     "This is a patchset which didn't make the last merge window.  It adds a
      debugging capability to feed ACPI tables via the initramfs.
    
      On a grander scope, it formalizes using the initramfs protocol for
      feeding arbitrary blobs which need to be accessed early to the kernel:
      they are fed first in the initramfs blob (lots of bootloaders can
      concatenate this at boot time, others can use a single file) in an
      uncompressed cpio archive using filenames starting with "kernel/".
    
      The ACPI maintainers requested that this patchset be fed via the x86
      tree rather than the ACPI tree as the footprint in the general x86
      code is much bigger than in the ACPI code proper."
    
    * 'x86-acpi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      X86 ACPI: Use #ifdef not #if for CONFIG_X86 check
      ACPI: Fix build when disabled
      ACPI: Document ACPI table overriding via initrd
      ACPI: Create acpi_table_taint() function to avoid code duplication
      ACPI: Implement physical address table override
      ACPI: Store valid ACPI tables passed via early initrd in reserved memblock areas
      x86, acpi: Introduce x86 arch specific arch_reserve_mem_area() for e820 handling
      lib: Add early cpio decoder

commit 3ae45a27df74358b4bcd3d5a67e47ad734a48945
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 2 13:09:08 2012 +0100

    ACPI: Make seemingly useless check in osl.c more understandable
    
    There is a seemingly useless check in drivers/acpi/osl.c added by
    commit bc73675 (ACPI: fixes a false alarm from lockdep), which really
    is necessary to avoid false positive lockdep complaints.  Document
    this and rearrange the code related to it so that it makes fewer
    checks.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 7dfe91d0173e..6dc4a2b1e956 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -932,7 +932,7 @@ static acpi_status __acpi_os_execute(acpi_execute_type type,
 	 * having a static work_struct.
 	 */
 
-	dpc = kmalloc(sizeof(struct acpi_os_dpc), GFP_ATOMIC);
+	dpc = kzalloc(sizeof(struct acpi_os_dpc), GFP_ATOMIC);
 	if (!dpc)
 		return AE_NO_MEMORY;
 
@@ -944,17 +944,22 @@ static acpi_status __acpi_os_execute(acpi_execute_type type,
 	 * because the hotplug code may call driver .remove() functions,
 	 * which invoke flush_scheduled_work/acpi_os_wait_events_complete
 	 * to flush these workqueues.
+	 *
+	 * To prevent lockdep from complaining unnecessarily, make sure that
+	 * there is a different static lockdep key for each workqueue by using
+	 * INIT_WORK() for each of them separately.
 	 */
-	queue = hp ? kacpi_hotplug_wq :
-		(type == OSL_NOTIFY_HANDLER ? kacpi_notify_wq : kacpid_wq);
-	dpc->wait = hp ? 1 : 0;
-
-	if (queue == kacpi_hotplug_wq)
+	if (hp) {
+		queue = kacpi_hotplug_wq;
+		dpc->wait = 1;
 		INIT_WORK(&dpc->work, acpi_os_execute_deferred);
-	else if (queue == kacpi_notify_wq)
+	} else if (type == OSL_NOTIFY_HANDLER) {
+		queue = kacpi_notify_wq;
 		INIT_WORK(&dpc->work, acpi_os_execute_deferred);
-	else
+	} else {
+		queue = kacpid_wq;
 		INIT_WORK(&dpc->work, acpi_os_execute_deferred);
+	}
 
 	/*
 	 * On some machines, a software-initiated SMI causes corruption unless

commit 61622accd05b158d05f967b627e72da23d64f2ed
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Thu Nov 1 14:42:12 2012 +0000

    ACPI: Export functions for hot-remove
    
    Exported acpi_os_hotplug_execute() and acpi_bus_hot_remove_device()
    so that they can be called from modules for hot-remove operations.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 9eaf708f5885..7dfe91d0173e 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -986,6 +986,7 @@ acpi_status acpi_os_hotplug_execute(acpi_osd_exec_callback function,
 {
 	return __acpi_os_execute(0, function, context, 1);
 }
+EXPORT_SYMBOL(acpi_os_hotplug_execute);
 
 void acpi_os_wait_events_complete(void)
 {

commit 325a8d36035f0623950e38e9cf7a47a48e72df11
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Oct 1 00:23:56 2012 +0200

    ACPI: Create acpi_table_taint() function to avoid code duplication
    
    There are two ways of overriding ACPI tables now, both need to taint the
    the kernel.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Link: http://lkml.kernel.org/r/1349043837-22659-6-git-send-email-trenn@suse.de
    Cc: Len Brown <lenb@kernel.org>
    Cc: Robert Moore <robert.moore@intel.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Eric Piel <eric.piel@tremplin-utc.net>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 007224bd4db7..a2845fff3997 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -656,6 +656,15 @@ void __init acpi_initrd_override(void *data, size_t size)
 }
 #endif /* CONFIG_ACPI_INITRD_TABLE_OVERRIDE */
 
+static void acpi_table_taint(struct acpi_table_header *table)
+{
+	pr_warn(PREFIX
+		"Override [%4.4s-%8.8s], this is unsafe: tainting kernel\n",
+		table->signature, table->oem_table_id);
+	add_taint(TAINT_OVERRIDDEN_ACPI_TABLE);
+}
+
+
 acpi_status
 acpi_os_table_override(struct acpi_table_header * existing_table,
 		       struct acpi_table_header ** new_table)
@@ -669,13 +678,8 @@ acpi_os_table_override(struct acpi_table_header * existing_table,
 	if (strncmp(existing_table->signature, "DSDT", 4) == 0)
 		*new_table = (struct acpi_table_header *)AmlCode;
 #endif
-	if (*new_table != NULL) {
-		printk(KERN_WARNING PREFIX "Override [%4.4s-%8.8s], "
-			   "this is unsafe: tainting kernel\n",
-		       existing_table->signature,
-		       existing_table->oem_table_id);
-		add_taint(TAINT_OVERRIDDEN_ACPI_TABLE);
-	}
+	if (*new_table != NULL)
+		acpi_table_taint(existing_table);
 	return AE_OK;
 }
 
@@ -736,6 +740,8 @@ acpi_os_physical_table_override(struct acpi_table_header *existing_table,
 		break;
 	} while (table_offset + ACPI_HEADER_SIZE < all_tables_size);
 
+	if (*address != 0)
+		acpi_table_taint(existing_table);
 	return AE_OK;
 #endif
 }

commit b2a35003dfbcc7b7a5e5c6e524e7d49ba66e0bb5
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Oct 1 00:23:55 2012 +0200

    ACPI: Implement physical address table override
    
    Previous patches stored ACPI tables provided via initrd in a memblock reserved
    area.
    If a table is loaded and the table type of an initrd provided one matches,
    the one from initrd is prefered.
    In case of a SSDT table, the OEM table id also has to match.
    
    ACPI tables can be loaded at boot time (static table pointers in XSDT),
    but also dynamically any time later via ASL commands load() or loadTable().
    The override mechanism always works.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Link: http://lkml.kernel.org/r/1349043837-22659-5-git-send-email-trenn@suse.de
    Cc: Len Brown <lenb@kernel.org>
    Cc: Robert Moore <robert.moore@intel.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Eric Piel <eric.piel@tremplin-utc.net>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index b20b07903218..007224bd4db7 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -681,12 +681,64 @@ acpi_os_table_override(struct acpi_table_header * existing_table,
 
 acpi_status
 acpi_os_physical_table_override(struct acpi_table_header *existing_table,
-				acpi_physical_address * new_address,
-				u32 *new_table_length)
+				acpi_physical_address *address,
+				u32 *table_length)
 {
-	return AE_SUPPORT;
-}
+#ifndef CONFIG_ACPI_INITRD_TABLE_OVERRIDE
+	*table_length = 0;
+	*address = 0;
+	return AE_OK;
+#else
+	int table_offset = 0;
+	struct acpi_table_header *table;
+
+	*table_length = 0;
+	*address = 0;
+
+	if (!acpi_tables_addr)
+		return AE_OK;
+
+	do {
+		if (table_offset + ACPI_HEADER_SIZE > all_tables_size) {
+			WARN_ON(1);
+			return AE_OK;
+		}
+
+		table = acpi_os_map_memory(acpi_tables_addr + table_offset,
+					   ACPI_HEADER_SIZE);
+
+		if (table_offset + table->length > all_tables_size) {
+			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
+			WARN_ON(1);
+			return AE_OK;
+		}
 
+		table_offset += table->length;
+
+		if (memcmp(existing_table->signature, table->signature, 4)) {
+			acpi_os_unmap_memory(table,
+				     ACPI_HEADER_SIZE);
+			continue;
+		}
+
+		/* Only override tables with matching oem id */
+		if (memcmp(table->oem_table_id, existing_table->oem_table_id,
+			   ACPI_OEM_TABLE_ID_SIZE)) {
+			acpi_os_unmap_memory(table,
+				     ACPI_HEADER_SIZE);
+			continue;
+		}
+
+		table_offset -= table->length;
+		*table_length = table->length;
+		acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
+		*address = acpi_tables_addr + table_offset;
+		break;
+	} while (table_offset + ACPI_HEADER_SIZE < all_tables_size);
+
+	return AE_OK;
+#endif
+}
 
 static irqreturn_t acpi_irq(int irq, void *dev_id)
 {

commit 53aac44c904abbad9f474f652f099de13b5c3563
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Oct 1 00:23:54 2012 +0200

    ACPI: Store valid ACPI tables passed via early initrd in reserved memblock areas
    
    A later patch will compare them with ACPI tables that get loaded at boot or
    runtime and if criteria match, a stored one is loaded.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Link: http://lkml.kernel.org/r/1349043837-22659-4-git-send-email-trenn@suse.de
    Cc: Len Brown <lenb@kernel.org>
    Cc: Robert Moore <robert.moore@intel.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Eric Piel <eric.piel@tremplin-utc.net>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 9eaf708f5885..b20b07903218 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -534,6 +534,128 @@ acpi_os_predefined_override(const struct acpi_predefined_names *init_val,
 	return AE_OK;
 }
 
+#ifdef CONFIG_ACPI_INITRD_TABLE_OVERRIDE
+#include <linux/earlycpio.h>
+#include <linux/memblock.h>
+
+static u64 acpi_tables_addr;
+static int all_tables_size;
+
+/* Copied from acpica/tbutils.c:acpi_tb_checksum() */
+u8 __init acpi_table_checksum(u8 *buffer, u32 length)
+{
+	u8 sum = 0;
+	u8 *end = buffer + length;
+
+	while (buffer < end)
+		sum = (u8) (sum + *(buffer++));
+	return sum;
+}
+
+/* All but ACPI_SIG_RSDP and ACPI_SIG_FACS: */
+static const char * const table_sigs[] = {
+	ACPI_SIG_BERT, ACPI_SIG_CPEP, ACPI_SIG_ECDT, ACPI_SIG_EINJ,
+	ACPI_SIG_ERST, ACPI_SIG_HEST, ACPI_SIG_MADT, ACPI_SIG_MSCT,
+	ACPI_SIG_SBST, ACPI_SIG_SLIT, ACPI_SIG_SRAT, ACPI_SIG_ASF,
+	ACPI_SIG_BOOT, ACPI_SIG_DBGP, ACPI_SIG_DMAR, ACPI_SIG_HPET,
+	ACPI_SIG_IBFT, ACPI_SIG_IVRS, ACPI_SIG_MCFG, ACPI_SIG_MCHI,
+	ACPI_SIG_SLIC, ACPI_SIG_SPCR, ACPI_SIG_SPMI, ACPI_SIG_TCPA,
+	ACPI_SIG_UEFI, ACPI_SIG_WAET, ACPI_SIG_WDAT, ACPI_SIG_WDDT,
+	ACPI_SIG_WDRT, ACPI_SIG_DSDT, ACPI_SIG_FADT, ACPI_SIG_PSDT,
+	ACPI_SIG_RSDT, ACPI_SIG_XSDT, ACPI_SIG_SSDT, NULL };
+
+/* Non-fatal errors: Affected tables/files are ignored */
+#define INVALID_TABLE(x, path, name)					\
+	{ pr_err("ACPI OVERRIDE: " x " [%s%s]\n", path, name); continue; }
+
+#define ACPI_HEADER_SIZE sizeof(struct acpi_table_header)
+
+/* Must not increase 10 or needs code modification below */
+#define ACPI_OVERRIDE_TABLES 10
+
+void __init acpi_initrd_override(void *data, size_t size)
+{
+	int sig, no, table_nr = 0, total_offset = 0;
+	long offset = 0;
+	struct acpi_table_header *table;
+	char cpio_path[32] = "kernel/firmware/acpi/";
+	struct cpio_data file;
+	struct cpio_data early_initrd_files[ACPI_OVERRIDE_TABLES];
+	char *p;
+
+	if (data == NULL || size == 0)
+		return;
+
+	for (no = 0; no < ACPI_OVERRIDE_TABLES; no++) {
+		file = find_cpio_data(cpio_path, data, size, &offset);
+		if (!file.data)
+			break;
+
+		data += offset;
+		size -= offset;
+
+		if (file.size < sizeof(struct acpi_table_header))
+			INVALID_TABLE("Table smaller than ACPI header",
+				      cpio_path, file.name);
+
+		table = file.data;
+
+		for (sig = 0; table_sigs[sig]; sig++)
+			if (!memcmp(table->signature, table_sigs[sig], 4))
+				break;
+
+		if (!table_sigs[sig])
+			INVALID_TABLE("Unknown signature",
+				      cpio_path, file.name);
+		if (file.size != table->length)
+			INVALID_TABLE("File length does not match table length",
+				      cpio_path, file.name);
+		if (acpi_table_checksum(file.data, table->length))
+			INVALID_TABLE("Bad table checksum",
+				      cpio_path, file.name);
+
+		pr_info("%4.4s ACPI table found in initrd [%s%s][0x%x]\n",
+			table->signature, cpio_path, file.name, table->length);
+
+		all_tables_size += table->length;
+		early_initrd_files[table_nr].data = file.data;
+		early_initrd_files[table_nr].size = file.size;
+		table_nr++;
+	}
+	if (table_nr == 0)
+		return;
+
+	acpi_tables_addr =
+		memblock_find_in_range(0, max_low_pfn_mapped << PAGE_SHIFT,
+				       all_tables_size, PAGE_SIZE);
+	if (!acpi_tables_addr) {
+		WARN_ON(1);
+		return;
+	}
+	/*
+	 * Only calling e820_add_reserve does not work and the
+	 * tables are invalid (memory got used) later.
+	 * memblock_reserve works as expected and the tables won't get modified.
+	 * But it's not enough on X86 because ioremap will
+	 * complain later (used by acpi_os_map_memory) that the pages
+	 * that should get mapped are not marked "reserved".
+	 * Both memblock_reserve and e820_add_region (via arch_reserve_mem_area)
+	 * works fine.
+	 */
+	memblock_reserve(acpi_tables_addr, acpi_tables_addr + all_tables_size);
+	arch_reserve_mem_area(acpi_tables_addr, all_tables_size);
+
+	p = early_ioremap(acpi_tables_addr, all_tables_size);
+
+	for (no = 0; no < table_nr; no++) {
+		memcpy(p + total_offset, early_initrd_files[no].data,
+		       early_initrd_files[no].size);
+		total_offset += early_initrd_files[no].size;
+	}
+	early_iounmap(p, all_tables_size);
+}
+#endif /* CONFIG_ACPI_INITRD_TABLE_OVERRIDE */
+
 acpi_status
 acpi_os_table_override(struct acpi_table_header * existing_table,
 		       struct acpi_table_header ** new_table)

commit bd6f10a5f984e48cb56a39f2698cd58e7a33d56b
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Tue May 22 16:43:49 2012 +0800

    ACPICA: Remove argument of acpi_os_wait_events_complete
    
    Remove the unused argument of acpi_os_wait_events_complete.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index c3881b2eb8b2..9eaf708f5885 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -891,7 +891,7 @@ static void acpi_os_execute_deferred(struct work_struct *work)
 	struct acpi_os_dpc *dpc = container_of(work, struct acpi_os_dpc, work);
 
 	if (dpc->wait)
-		acpi_os_wait_events_complete(NULL);
+		acpi_os_wait_events_complete();
 
 	dpc->function(dpc->context);
 	kfree(dpc);
@@ -987,7 +987,7 @@ acpi_status acpi_os_hotplug_execute(acpi_osd_exec_callback function,
 	return __acpi_os_execute(0, function, context, 1);
 }
 
-void acpi_os_wait_events_complete(void *context)
+void acpi_os_wait_events_complete(void)
 {
 	flush_workqueue(kacpid_wq);
 	flush_workqueue(kacpi_notify_wq);

commit 9ecf8c0d4f2ea5eb39e0924d9b102b5c3300f291
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Apr 18 12:29:32 2012 +0200

    Revert "ACPI: Make ACPI interrupt threaded"
    
    This reverts commit 6fe0d0628245fdcd6fad8b837c81e8f7ebc3364d.
    
    Paul bisected this regression.
    
    The conversion was done blindly and is wrong, as it does not provide a
    primary handler to disable the level type irq on the device level.
    Neither does it set the IRQF_ONESHOT flag which handles that at the irq
    line level.  This can't be done as the interrupt might be shared, though
    we might extend the core to force it.
    
    So an interrupt on this line will wake up the thread, but immediately
    unmask the irq after that.  Due to the interrupt being level type the
    hardware interrupt is raised over and over and prevents the irq thread
    from handling it.  Fail.
    
    request_irq() unfortunately does not refuse such a request and the patch
    was obviously never tested with real interrupts.
    
    Bisected-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index ba14fb93c929..c3881b2eb8b2 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -607,8 +607,7 @@ acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,
 
 	acpi_irq_handler = handler;
 	acpi_irq_context = context;
-	if (request_threaded_irq(irq, NULL, acpi_irq, IRQF_SHARED, "acpi",
-				 acpi_irq)) {
+	if (request_irq(irq, acpi_irq, IRQF_SHARED, "acpi", acpi_irq)) {
 		printk(KERN_ERR PREFIX "SCI (IRQ%d) allocation failed\n", irq);
 		acpi_irq_handler = NULL;
 		return AE_NOT_ACQUIRED;

commit d326f44e5f2204c7a24db69bfc6dd3fe5f86182b
Merge: ec612fcf43e0 e840dfe334b4
Author: Len Brown <len.brown@intel.com>
Date:   Fri Mar 30 16:35:53 2012 -0400

    Merge branch 'tboot' into release
    
    Conflicts:
            drivers/acpi/acpica/hwsleep.c
    
    Text conflict between:
    
    2feec47d4c5f80b05f1650f5a24865718978eea4
    (ACPICA: ACPI 5: Support for new FADT SleepStatus, SleepControl registers)
    
    which removed #include "actables.h"
    
    and
    
    09f98a825a821f7a3f1b162f9ed023f37213a63b
    (x86, acpi, tboot: Have a ACPI os prepare sleep instead of calling tboot_sleep.)
    
    which removed #include <linux/tboot.h>
    
    The resolution is to remove them both.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 1a05e4678724c4a5fe7b9e4e208b616dfe8c3a32
Merge: 5aa3c16c6b19 d1ff4b1cdbab cf450136bfde 02401c06b7f6 6fe0d0628245 9f324bda970c 372399787788 3e80acd1af40 344e222edf48 2815ab92ba3a 15aaa3465483 b60e7f616685
Author: Len Brown <len.brown@intel.com>
Date:   Fri Mar 30 16:10:37 2012 -0400

    Merge branches 'acpica', 'bgrt', 'bz-11533', 'cpuidle', 'ec', 'hotplug', 'misc', 'red-hat-bz-727865', 'thermal', 'throttling', 'turbostat' and 'video' into release
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit e252675fb722d4a307cc380a06a905f03cf9951c
Author: Jan Beulich <JBeulich@suse.com>
Date:   Fri Feb 24 11:41:53 2012 +0000

    ACPI: consistently use should_use_kmap()
    
    ... so that acpi_unmap()'s behavior gets in sync with acpi_map()'s.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 412a1e04a922..5aef087d42d0 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -347,7 +347,7 @@ static void acpi_unmap(acpi_physical_address pg_off, void __iomem *vaddr)
 	unsigned long pfn;
 
 	pfn = pg_off >> PAGE_SHIFT;
-	if (page_is_ram(pfn))
+	if (should_use_kmap(pfn))
 		kunmap(pfn_to_page(pfn));
 	else
 		iounmap(vaddr);

commit 6fe0d0628245fdcd6fad8b837c81e8f7ebc3364d
Author: Andi Kleen <andi@firstfloor.org>
Date:   Mon Feb 6 08:17:09 2012 -0800

    ACPI: Make ACPI interrupt threaded
    
    Some ACPI interrupt actions may need to wait, and it's easiest to
    have a thread context for this. So turn the ACPI interrupt
    into a threaded interrupt.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 412a1e04a922..02367a8a60e9 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -595,7 +595,8 @@ acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,
 
 	acpi_irq_handler = handler;
 	acpi_irq_context = context;
-	if (request_irq(irq, acpi_irq, IRQF_SHARED, "acpi", acpi_irq)) {
+	if (request_threaded_irq(irq, NULL, acpi_irq, IRQF_SHARED, "acpi",
+				 acpi_irq)) {
 		printk(KERN_ERR PREFIX "SCI (IRQ%d) allocation failed\n", irq);
 		acpi_irq_handler = NULL;
 		return AE_NOT_ACQUIRED;

commit f7b004a17c9183f023796dea0d70284684ec000d
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Feb 14 18:31:56 2012 +0800

    ACPICA: Add acpi_os_physical_table_override interface
    
    This interface allows the host to override a table via a
    physical address, instead of the logical address required by
    acpi_os_table_override. This simplifies the host implementation.
    Initial implementation by Thomas Renninger. ACPICA implementation
    creates a single function for table overrides that attempts both
    a logical and a physical override.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 1dea025e4e98..07d426425b59 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -554,6 +554,15 @@ acpi_os_table_override(struct acpi_table_header * existing_table,
 	return AE_OK;
 }
 
+acpi_status
+acpi_os_physical_table_override(struct acpi_table_header *existing_table,
+				acpi_physical_address * new_address,
+				u32 *new_table_length)
+{
+	return AE_SUPPORT;
+}
+
+
 static irqreturn_t acpi_irq(int irq, void *dev_id)
 {
 	u32 handled;

commit 653f4b538f66d37db560e0f56af08117136d29b7
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Feb 14 18:29:55 2012 +0800

    ACPICA: Expand OSL memory read/write interfaces to 64 bits
    
    This change expands acpi_os_read_memory and acpi_os_write_memory to a
    full 64 bits. This allows 64 bit transfers via the acpi_read and
    acpi_write interfaces. Note: The internal acpi_hw_read and acpi_hw_write
    interfaces remain at 32 bits, because 64 bits is not needed to
    access the standard ACPI registers.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 412a1e04a922..1dea025e4e98 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -699,49 +699,6 @@ acpi_status acpi_os_write_port(acpi_io_address port, u32 value, u32 width)
 
 EXPORT_SYMBOL(acpi_os_write_port);
 
-acpi_status
-acpi_os_read_memory(acpi_physical_address phys_addr, u32 * value, u32 width)
-{
-	void __iomem *virt_addr;
-	unsigned int size = width / 8;
-	bool unmap = false;
-	u32 dummy;
-
-	rcu_read_lock();
-	virt_addr = acpi_map_vaddr_lookup(phys_addr, size);
-	if (!virt_addr) {
-		rcu_read_unlock();
-		virt_addr = acpi_os_ioremap(phys_addr, size);
-		if (!virt_addr)
-			return AE_BAD_ADDRESS;
-		unmap = true;
-	}
-
-	if (!value)
-		value = &dummy;
-
-	switch (width) {
-	case 8:
-		*(u8 *) value = readb(virt_addr);
-		break;
-	case 16:
-		*(u16 *) value = readw(virt_addr);
-		break;
-	case 32:
-		*(u32 *) value = readl(virt_addr);
-		break;
-	default:
-		BUG();
-	}
-
-	if (unmap)
-		iounmap(virt_addr);
-	else
-		rcu_read_unlock();
-
-	return AE_OK;
-}
-
 #ifdef readq
 static inline u64 read64(const volatile void __iomem *addr)
 {
@@ -758,7 +715,7 @@ static inline u64 read64(const volatile void __iomem *addr)
 #endif
 
 acpi_status
-acpi_os_read_memory64(acpi_physical_address phys_addr, u64 *value, u32 width)
+acpi_os_read_memory(acpi_physical_address phys_addr, u64 *value, u32 width)
 {
 	void __iomem *virt_addr;
 	unsigned int size = width / 8;
@@ -803,45 +760,6 @@ acpi_os_read_memory64(acpi_physical_address phys_addr, u64 *value, u32 width)
 	return AE_OK;
 }
 
-acpi_status
-acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
-{
-	void __iomem *virt_addr;
-	unsigned int size = width / 8;
-	bool unmap = false;
-
-	rcu_read_lock();
-	virt_addr = acpi_map_vaddr_lookup(phys_addr, size);
-	if (!virt_addr) {
-		rcu_read_unlock();
-		virt_addr = acpi_os_ioremap(phys_addr, size);
-		if (!virt_addr)
-			return AE_BAD_ADDRESS;
-		unmap = true;
-	}
-
-	switch (width) {
-	case 8:
-		writeb(value, virt_addr);
-		break;
-	case 16:
-		writew(value, virt_addr);
-		break;
-	case 32:
-		writel(value, virt_addr);
-		break;
-	default:
-		BUG();
-	}
-
-	if (unmap)
-		iounmap(virt_addr);
-	else
-		rcu_read_unlock();
-
-	return AE_OK;
-}
-
 #ifdef writeq
 static inline void write64(u64 val, volatile void __iomem *addr)
 {
@@ -856,7 +774,7 @@ static inline void write64(u64 val, volatile void __iomem *addr)
 #endif
 
 acpi_status
-acpi_os_write_memory64(acpi_physical_address phys_addr, u64 value, u32 width)
+acpi_os_write_memory(acpi_physical_address phys_addr, u64 value, u32 width)
 {
 	void __iomem *virt_addr;
 	unsigned int size = width / 8;

commit e840dfe334b4791af07aadee1b2cf3c7c7363581
Merge: c16fa4f2ad19 a1f37788a6d8
Author: Len Brown <len.brown@intel.com>
Date:   Thu Mar 22 01:31:09 2012 -0400

    Merge branch 'stable/for-x86-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/konrad/xen into tboot

commit 09f98a825a821f7a3f1b162f9ed023f37213a63b
Author: Tang Liang <liang.tang@oracle.com>
Date:   Fri Dec 9 10:05:54 2011 +0800

    x86, acpi, tboot: Have a ACPI os prepare sleep instead of calling tboot_sleep.
    
    The ACPI suspend path makes a call to tboot_sleep right before
    it writes the PM1A, PM1B values. We replace the direct call to
    tboot via an registration callback similar to __acpi_register_gsi.
    
    CC: Len Brown <len.brown@intel.com>
    Acked-by: Joseph Cihula <joseph.cihula@intel.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    [v1: Added __attribute__ ((unused))]
    [v2: Introduced a wrapper instead of changing tboot_sleep return values]
    [v3: Added return value AE_CTRL_SKIP for acpi_os_sleep_prepare]
    Signed-off-by: Tang Liang <liang.tang@oracle.com>
    [v1: Fix compile issues on IA64 and PPC64]
    [v2: Fix where __acpi_os_prepare_sleep==NULL and did not go in sleep properly]
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index f31c5c5f1b7e..f3aae4ba507e 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -76,6 +76,9 @@ EXPORT_SYMBOL(acpi_in_debugger);
 extern char line_buf[80];
 #endif				/*ENABLE_DEBUGGER */
 
+static int (*__acpi_os_prepare_sleep)(u8 sleep_state, u32 pm1a_ctrl,
+				      u32 pm1b_ctrl);
+
 static acpi_osd_handler acpi_irq_handler;
 static void *acpi_irq_context;
 static struct workqueue_struct *kacpid_wq;
@@ -1659,3 +1662,24 @@ acpi_status acpi_os_terminate(void)
 
 	return AE_OK;
 }
+
+acpi_status acpi_os_prepare_sleep(u8 sleep_state, u32 pm1a_control,
+				  u32 pm1b_control)
+{
+	int rc = 0;
+	if (__acpi_os_prepare_sleep)
+		rc = __acpi_os_prepare_sleep(sleep_state,
+					     pm1a_control, pm1b_control);
+	if (rc < 0)
+		return AE_ERROR;
+	else if (rc > 0)
+		return AE_CTRL_SKIP;
+
+	return AE_OK;
+}
+
+void acpi_os_set_prepare_sleep(int (*func)(u8 sleep_state,
+			       u32 pm1a_ctrl, u32 pm1b_ctrl))
+{
+	__acpi_os_prepare_sleep = func;
+}

commit ba242d5b1a84bc6611732296517ee40d5a80a4d9
Author: Myron Stowe <mstowe@redhat.com>
Date:   Fri Jan 20 19:13:30 2012 -0700

    ACPI, APEI: Add RAM mapping support to ACPI
    
    This patch adds support for RAM to ACPI's mapping capabilities in order
    to support APEI error injection (EINJ) actions.
    
    This patch re-factors similar functionality introduced in commit
    76da3fb3575, bringing it into osl.c in preparation for removing
    ./drivers/acpi/atomicio.[ch].
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 5498a6d88ba2..412a1e04a922 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -31,6 +31,7 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
+#include <linux/highmem.h>
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/kmod.h>
@@ -321,6 +322,37 @@ acpi_map_lookup_virt(void __iomem *virt, acpi_size size)
 	return NULL;
 }
 
+#ifndef CONFIG_IA64
+#define should_use_kmap(pfn)   page_is_ram(pfn)
+#else
+/* ioremap will take care of cache attributes */
+#define should_use_kmap(pfn)   0
+#endif
+
+static void __iomem *acpi_map(acpi_physical_address pg_off, unsigned long pg_sz)
+{
+	unsigned long pfn;
+
+	pfn = pg_off >> PAGE_SHIFT;
+	if (should_use_kmap(pfn)) {
+		if (pg_sz > PAGE_SIZE)
+			return NULL;
+		return (void __iomem __force *)kmap(pfn_to_page(pfn));
+	} else
+		return acpi_os_ioremap(pg_off, pg_sz);
+}
+
+static void acpi_unmap(acpi_physical_address pg_off, void __iomem *vaddr)
+{
+	unsigned long pfn;
+
+	pfn = pg_off >> PAGE_SHIFT;
+	if (page_is_ram(pfn))
+		kunmap(pfn_to_page(pfn));
+	else
+		iounmap(vaddr);
+}
+
 void __iomem *__init_refok
 acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 {
@@ -353,7 +385,7 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 
 	pg_off = round_down(phys, PAGE_SIZE);
 	pg_sz = round_up(phys + size, PAGE_SIZE) - pg_off;
-	virt = acpi_os_ioremap(pg_off, pg_sz);
+	virt = acpi_map(pg_off, pg_sz);
 	if (!virt) {
 		mutex_unlock(&acpi_ioremap_lock);
 		kfree(map);
@@ -384,7 +416,7 @@ static void acpi_os_map_cleanup(struct acpi_ioremap *map)
 {
 	if (!map->refcount) {
 		synchronize_rcu();
-		iounmap(map->virt);
+		acpi_unmap(map->phys, map->virt);
 		kfree(map);
 	}
 }

commit e615bf5b5519862ab66172f4dec7455d6543a578
Author: Myron Stowe <mstowe@redhat.com>
Date:   Fri Jan 20 19:13:24 2012 -0700

    ACPI, APEI: Add 64-bit read/write support for APEI on i386
    
    Base ACPI (CA) currently does not support atomic 64-bit reads and writes
    (acpi_read() and acpi_write() split 64-bit loads/stores into two
    32-bit transfers) yet APEI expects 64-bit transfer capability, even
    when running on 32-bit systems.
    
    This patch implements 64-bit read and write routines for APEI usage.
    
    This patch re-factors similar functionality introduced in commit
    04c25997c97, bringing it into the ACPI subsystem in preparation for
    removing ./drivers/acpi/atomicio.[ch].  In the implementation I have
    replicated acpi_os_read_memory() and acpi_os_write_memory(), creating
    64-bit versions for APEI to utilize, as opposed to something more
    elegant.  My thinking is that we should attempt to see if we can get
    ACPI's CA/OSL changed so that the existing acpi_read() and acpi_write()
    interfaces are natively 64-bit capable and then subsequently remove the
    replication.
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index fcc12d842bcc..5498a6d88ba2 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -710,6 +710,67 @@ acpi_os_read_memory(acpi_physical_address phys_addr, u32 * value, u32 width)
 	return AE_OK;
 }
 
+#ifdef readq
+static inline u64 read64(const volatile void __iomem *addr)
+{
+	return readq(addr);
+}
+#else
+static inline u64 read64(const volatile void __iomem *addr)
+{
+	u64 l, h;
+	l = readl(addr);
+	h = readl(addr+4);
+	return l | (h << 32);
+}
+#endif
+
+acpi_status
+acpi_os_read_memory64(acpi_physical_address phys_addr, u64 *value, u32 width)
+{
+	void __iomem *virt_addr;
+	unsigned int size = width / 8;
+	bool unmap = false;
+	u64 dummy;
+
+	rcu_read_lock();
+	virt_addr = acpi_map_vaddr_lookup(phys_addr, size);
+	if (!virt_addr) {
+		rcu_read_unlock();
+		virt_addr = acpi_os_ioremap(phys_addr, size);
+		if (!virt_addr)
+			return AE_BAD_ADDRESS;
+		unmap = true;
+	}
+
+	if (!value)
+		value = &dummy;
+
+	switch (width) {
+	case 8:
+		*(u8 *) value = readb(virt_addr);
+		break;
+	case 16:
+		*(u16 *) value = readw(virt_addr);
+		break;
+	case 32:
+		*(u32 *) value = readl(virt_addr);
+		break;
+	case 64:
+		*(u64 *) value = read64(virt_addr);
+		break;
+	default:
+		BUG();
+	}
+
+	if (unmap)
+		iounmap(virt_addr);
+	else
+		rcu_read_unlock();
+
+	return AE_OK;
+}
+
 acpi_status
 acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
 {
@@ -749,6 +810,61 @@ acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
 	return AE_OK;
 }
 
+#ifdef writeq
+static inline void write64(u64 val, volatile void __iomem *addr)
+{
+	writeq(val, addr);
+}
+#else
+static inline void write64(u64 val, volatile void __iomem *addr)
+{
+	writel(val, addr);
+	writel(val>>32, addr+4);
+}
+#endif
+
+acpi_status
+acpi_os_write_memory64(acpi_physical_address phys_addr, u64 value, u32 width)
+{
+	void __iomem *virt_addr;
+	unsigned int size = width / 8;
+	bool unmap = false;
+
+	rcu_read_lock();
+	virt_addr = acpi_map_vaddr_lookup(phys_addr, size);
+	if (!virt_addr) {
+		rcu_read_unlock();
+		virt_addr = acpi_os_ioremap(phys_addr, size);
+		if (!virt_addr)
+			return AE_BAD_ADDRESS;
+		unmap = true;
+	}
+
+	switch (width) {
+	case 8:
+		writeb(value, virt_addr);
+		break;
+	case 16:
+		writew(value, virt_addr);
+		break;
+	case 32:
+		writel(value, virt_addr);
+		break;
+	case 64:
+		write64(value, virt_addr);
+		break;
+	default:
+		BUG();
+	}
+
+	if (unmap)
+		iounmap(virt_addr);
+	else
+		rcu_read_unlock();
+
+	return AE_OK;
+}
+
 acpi_status
 acpi_os_read_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
 			       u64 *value, u32 width)

commit cb7971756b901abd61d47f6eb1011066abfb348d
Merge: 037d76f40430 700130b41f4e
Author: Len Brown <len.brown@intel.com>
Date:   Wed Jan 18 00:46:30 2012 -0500

    Merge branch 'atomicio-remove' into release

commit 6f68c91c55ea3576d366797fa8d45e31c4aa79f8
Author: Myron Stowe <mstowe@redhat.com>
Date:   Mon Nov 7 16:23:34 2011 -0700

    ACPI: Export interfaces for ioremapping/iounmapping ACPI registers
    
    Export remapping and unmapping interfaces - acpi_os_map_generic_address()
    and acpi_os_unmap_generic_address() - for ACPI generic registers that are
    backed by memory mapped I/O (MMIO).
    
    The acpi_os_map_generic_address() and acpi_os_unmap_generic_address()
    declarations may more properly belong in include/acpi/acpiosxf.h next to
    acpi_os_read_memory() but I believe that would require the ACPI CA making
    them an official part of the ACPI CA - OS interface.
    
    ACPI Generic Address Structure (GAS) reference (ACPI's fixed/generic
    hardware registers use the GAS format):
      ACPI Specification, Revision 4.0, Section 5.2.3.1, "Generic Address
      Structure"
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 2e285cdbefb1..b11f2676f7c9 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -431,7 +431,7 @@ void __init early_acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 		__acpi_unmap_table(virt, size);
 }
 
-static int acpi_os_map_generic_address(struct acpi_generic_address *gas)
+int acpi_os_map_generic_address(struct acpi_generic_address *gas)
 {
 	u64 addr;
 	void __iomem *virt;
@@ -450,8 +450,9 @@ static int acpi_os_map_generic_address(struct acpi_generic_address *gas)
 
 	return 0;
 }
+EXPORT_SYMBOL(acpi_os_map_generic_address);
 
-static void acpi_os_unmap_generic_address(struct acpi_generic_address *gas)
+void acpi_os_unmap_generic_address(struct acpi_generic_address *gas)
 {
 	u64 addr;
 	struct acpi_ioremap *map;
@@ -475,6 +476,7 @@ static void acpi_os_unmap_generic_address(struct acpi_generic_address *gas)
 
 	acpi_os_map_cleanup(map);
 }
+EXPORT_SYMBOL(acpi_os_unmap_generic_address);
 
 #ifdef ACPI_FUTURE_USAGE
 acpi_status

commit bc9ffce27962c0c5fdc6adf74790ea0fcbe4a99c
Author: Myron Stowe <mstowe@redhat.com>
Date:   Mon Nov 7 16:23:27 2011 -0700

    ACPI: Fix possible alignment issues with GAS 'address' references
    
    Generic Address Structures (GAS) may reside within ACPI tables which
    are byte aligned.  This patch copies GAS 'address' references to a local
    variable, which will be naturally aligned, to be used going forward.
    
    ACPI Generic Address Structure (GAS) reference:
      ACPI Specification, Revision 4.0, Section 5.2.3.1, "Generic Address
      Structure"
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index f31c5c5f1b7e..2e285cdbefb1 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -166,17 +166,21 @@ static u32 acpi_osi_handler(acpi_string interface, u32 supported)
 	return supported;
 }
 
-static void __init acpi_request_region (struct acpi_generic_address *addr,
+static void __init acpi_request_region (struct acpi_generic_address *gas,
 	unsigned int length, char *desc)
 {
-	if (!addr->address || !length)
+	u64 addr;
+
+	/* Handle possible alignment issues */
+	memcpy(&addr, &gas->address, sizeof(addr));
+	if (!addr || !length)
 		return;
 
 	/* Resources are never freed */
-	if (addr->space_id == ACPI_ADR_SPACE_SYSTEM_IO)
-		request_region(addr->address, length, desc);
-	else if (addr->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)
-		request_mem_region(addr->address, length, desc);
+	if (gas->space_id == ACPI_ADR_SPACE_SYSTEM_IO)
+		request_region(addr, length, desc);
+	else if (gas->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)
+		request_mem_region(addr, length, desc);
 }
 
 static int __init acpi_reserve_resources(void)
@@ -427,35 +431,41 @@ void __init early_acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 		__acpi_unmap_table(virt, size);
 }
 
-static int acpi_os_map_generic_address(struct acpi_generic_address *addr)
+static int acpi_os_map_generic_address(struct acpi_generic_address *gas)
 {
+	u64 addr;
 	void __iomem *virt;
 
-	if (addr->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)
+	if (gas->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)
 		return 0;
 
-	if (!addr->address || !addr->bit_width)
+	/* Handle possible alignment issues */
+	memcpy(&addr, &gas->address, sizeof(addr));
+	if (!addr || !gas->bit_width)
 		return -EINVAL;
 
-	virt = acpi_os_map_memory(addr->address, addr->bit_width / 8);
+	virt = acpi_os_map_memory(addr, gas->bit_width / 8);
 	if (!virt)
 		return -EIO;
 
 	return 0;
 }
 
-static void acpi_os_unmap_generic_address(struct acpi_generic_address *addr)
+static void acpi_os_unmap_generic_address(struct acpi_generic_address *gas)
 {
+	u64 addr;
 	struct acpi_ioremap *map;
 
-	if (addr->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)
+	if (gas->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)
 		return;
 
-	if (!addr->address || !addr->bit_width)
+	/* Handle possible alignment issues */
+	memcpy(&addr, &gas->address, sizeof(addr));
+	if (!addr || !gas->bit_width)
 		return;
 
 	mutex_lock(&acpi_ioremap_lock);
-	map = acpi_map_lookup(addr->address, addr->bit_width / 8);
+	map = acpi_map_lookup(addr, gas->bit_width / 8);
 	if (!map) {
 		mutex_unlock(&acpi_ioremap_lock);
 		return;

commit f654c0fefa8c16d439185b61442710fadc167e78
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Thu Jan 12 13:10:32 2012 +0800

    ACPICA: Add support for region address conflict checking
    
    Allows drivers to determine if any memory or I/O addresses
    will conflict with addresses used by ACPI operation regions.
    Introduces a new interface, acpi_check_address_range.
    
    http://marc.info/?t=132251388700002&r=1&w=2
    
    Reported-and-tested-by: Luca Tettamanti <kronos.it@gmail.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index f31c5c5f1b7e..3e57fbdf50a3 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -83,19 +83,6 @@ static struct workqueue_struct *kacpi_notify_wq;
 struct workqueue_struct *kacpi_hotplug_wq;
 EXPORT_SYMBOL(kacpi_hotplug_wq);
 
-struct acpi_res_list {
-	resource_size_t start;
-	resource_size_t end;
-	acpi_adr_space_type resource_type; /* IO port, System memory, ...*/
-	char name[5];   /* only can have a length of 4 chars, make use of this
-			   one instead of res->name, no need to kalloc then */
-	struct list_head resource_list;
-	int count;
-};
-
-static LIST_HEAD(resource_list_head);
-static DEFINE_SPINLOCK(acpi_res_lock);
-
 /*
  * This list of permanent mappings is for memory that may be accessed from
  * interrupt context, where we can't do the ioremap().
@@ -1278,44 +1265,28 @@ __setup("acpi_enforce_resources=", acpi_enforce_resources_setup);
  * drivers */
 int acpi_check_resource_conflict(const struct resource *res)
 {
-	struct acpi_res_list *res_list_elem;
-	int ioport = 0, clash = 0;
+	acpi_adr_space_type space_id;
+	acpi_size length;
+	u8 warn = 0;
+	int clash = 0;
 
 	if (acpi_enforce_resources == ENFORCE_RESOURCES_NO)
 		return 0;
 	if (!(res->flags & IORESOURCE_IO) && !(res->flags & IORESOURCE_MEM))
 		return 0;
 
-	ioport = res->flags & IORESOURCE_IO;
-
-	spin_lock(&acpi_res_lock);
-	list_for_each_entry(res_list_elem, &resource_list_head,
-			    resource_list) {
-		if (ioport && (res_list_elem->resource_type
-			       != ACPI_ADR_SPACE_SYSTEM_IO))
-			continue;
-		if (!ioport && (res_list_elem->resource_type
-				!= ACPI_ADR_SPACE_SYSTEM_MEMORY))
-			continue;
+	if (res->flags & IORESOURCE_IO)
+		space_id = ACPI_ADR_SPACE_SYSTEM_IO;
+	else
+		space_id = ACPI_ADR_SPACE_SYSTEM_MEMORY;
 
-		if (res->end < res_list_elem->start
-		    || res_list_elem->end < res->start)
-			continue;
-		clash = 1;
-		break;
-	}
-	spin_unlock(&acpi_res_lock);
+	length = res->end - res->start + 1;
+	if (acpi_enforce_resources != ENFORCE_RESOURCES_NO)
+		warn = 1;
+	clash = acpi_check_address_range(space_id, res->start, length, warn);
 
 	if (clash) {
 		if (acpi_enforce_resources != ENFORCE_RESOURCES_NO) {
-			printk(KERN_WARNING "ACPI: resource %s %pR"
-			       " conflicts with ACPI region %s "
-			       "[%s 0x%zx-0x%zx]\n",
-			       res->name, res, res_list_elem->name,
-			       (res_list_elem->resource_type ==
-				ACPI_ADR_SPACE_SYSTEM_IO) ? "io" : "mem",
-			       (size_t) res_list_elem->start,
-			       (size_t) res_list_elem->end);
 			if (acpi_enforce_resources == ENFORCE_RESOURCES_LAX)
 				printk(KERN_NOTICE "ACPI: This conflict may"
 				       " cause random problems and system"
@@ -1467,155 +1438,6 @@ acpi_status acpi_os_release_object(acpi_cache_t * cache, void *object)
 	kmem_cache_free(cache, object);
 	return (AE_OK);
 }
-
-static inline int acpi_res_list_add(struct acpi_res_list *res)
-{
-	struct acpi_res_list *res_list_elem;
-
-	list_for_each_entry(res_list_elem, &resource_list_head,
-			    resource_list) {
-
-		if (res->resource_type == res_list_elem->resource_type &&
-		    res->start == res_list_elem->start &&
-		    res->end == res_list_elem->end) {
-
-			/*
-			 * The Region(addr,len) already exist in the list,
-			 * just increase the count
-			 */
-
-			res_list_elem->count++;
-			return 0;
-		}
-	}
-
-	res->count = 1;
-	list_add(&res->resource_list, &resource_list_head);
-	return 1;
-}
-
-static inline void acpi_res_list_del(struct acpi_res_list *res)
-{
-	struct acpi_res_list *res_list_elem;
-
-	list_for_each_entry(res_list_elem, &resource_list_head,
-			    resource_list) {
-
-		if (res->resource_type == res_list_elem->resource_type &&
-		    res->start == res_list_elem->start &&
-		    res->end == res_list_elem->end) {
-
-			/*
-			 * If the res count is decreased to 0,
-			 * remove and free it
-			 */
-
-			if (--res_list_elem->count == 0) {
-				list_del(&res_list_elem->resource_list);
-				kfree(res_list_elem);
-			}
-			return;
-		}
-	}
-}
-
-acpi_status
-acpi_os_invalidate_address(
-    u8                   space_id,
-    acpi_physical_address   address,
-    acpi_size               length)
-{
-	struct acpi_res_list res;
-
-	switch (space_id) {
-	case ACPI_ADR_SPACE_SYSTEM_IO:
-	case ACPI_ADR_SPACE_SYSTEM_MEMORY:
-		/* Only interference checks against SystemIO and SystemMemory
-		   are needed */
-		res.start = address;
-		res.end = address + length - 1;
-		res.resource_type = space_id;
-		spin_lock(&acpi_res_lock);
-		acpi_res_list_del(&res);
-		spin_unlock(&acpi_res_lock);
-		break;
-	case ACPI_ADR_SPACE_PCI_CONFIG:
-	case ACPI_ADR_SPACE_EC:
-	case ACPI_ADR_SPACE_SMBUS:
-	case ACPI_ADR_SPACE_CMOS:
-	case ACPI_ADR_SPACE_PCI_BAR_TARGET:
-	case ACPI_ADR_SPACE_DATA_TABLE:
-	case ACPI_ADR_SPACE_FIXED_HARDWARE:
-		break;
-	}
-	return AE_OK;
-}
-
-/******************************************************************************
- *
- * FUNCTION:    acpi_os_validate_address
- *
- * PARAMETERS:  space_id             - ACPI space ID
- *              address             - Physical address
- *              length              - Address length
- *
- * RETURN:      AE_OK if address/length is valid for the space_id. Otherwise,
- *              should return AE_AML_ILLEGAL_ADDRESS.
- *
- * DESCRIPTION: Validate a system address via the host OS. Used to validate
- *              the addresses accessed by AML operation regions.
- *
- *****************************************************************************/
-
-acpi_status
-acpi_os_validate_address (
-    u8                   space_id,
-    acpi_physical_address   address,
-    acpi_size               length,
-    char *name)
-{
-	struct acpi_res_list *res;
-	int added;
-	if (acpi_enforce_resources == ENFORCE_RESOURCES_NO)
-		return AE_OK;
-
-	switch (space_id) {
-	case ACPI_ADR_SPACE_SYSTEM_IO:
-	case ACPI_ADR_SPACE_SYSTEM_MEMORY:
-		/* Only interference checks against SystemIO and SystemMemory
-		   are needed */
-		res = kzalloc(sizeof(struct acpi_res_list), GFP_KERNEL);
-		if (!res)
-			return AE_OK;
-		/* ACPI names are fixed to 4 bytes, still better use strlcpy */
-		strlcpy(res->name, name, 5);
-		res->start = address;
-		res->end = address + length - 1;
-		res->resource_type = space_id;
-		spin_lock(&acpi_res_lock);
-		added = acpi_res_list_add(res);
-		spin_unlock(&acpi_res_lock);
-		pr_debug("%s %s resource: start: 0x%llx, end: 0x%llx, "
-			 "name: %s\n", added ? "Added" : "Already exist",
-			 (space_id == ACPI_ADR_SPACE_SYSTEM_IO)
-			 ? "SystemIO" : "System Memory",
-			 (unsigned long long)res->start,
-			 (unsigned long long)res->end,
-			 res->name);
-		if (!added)
-			kfree(res);
-		break;
-	case ACPI_ADR_SPACE_PCI_CONFIG:
-	case ACPI_ADR_SPACE_EC:
-	case ACPI_ADR_SPACE_SMBUS:
-	case ACPI_ADR_SPACE_CMOS:
-	case ACPI_ADR_SPACE_PCI_BAR_TARGET:
-	case ACPI_ADR_SPACE_DATA_TABLE:
-	case ACPI_ADR_SPACE_FIXED_HARDWARE:
-		break;
-	}
-	return AE_OK;
-}
 #endif
 
 acpi_status __init acpi_os_initialize(void)

commit 6af8bef14d6fc9e4e52c83fd646412e9dedadd26
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Wed Sep 28 19:40:53 2011 -0400

    PCI hotplug: acpiphp: Prevent deadlock on PCI-to-PCI bridge remove
    
    I originally submitted a patch to workaround this by pushing all Ejection
    Requests and Device Checks onto the kacpi_hotplug queue.
    
    http://marc.info/?l=linux-acpi&m=131678270930105&w=2
    
    The patch is still insufficient in that Bus Checks also need to be added.
    
    Rather than add all events, including non-PCI-hotplug events, to the
    hotplug queue, mjg suggested that a better approach would be to modify
    the acpiphp driver so only acpiphp events would be added to the
    kacpi_hotplug queue.
    
    It's a longer patch, but at least we maintain the benefit of having separate
    queues in ACPI.  This, of course, is still only a workaround the problem.
    As Bjorn and mjg pointed out, we have to refactor a lot of this code to do
    the right thing but at this point it is a better to have this code working.
    
    The acpi core places all events on the kacpi_notify queue.  When the acpiphp
    driver is loaded and a PCI card with a PCI-to-PCI bridge is removed the
    following call sequence occurs:
    
    cleanup_p2p_bridge()
                -> cleanup_bridge()
                        -> acpi_remove_notify_handler()
                                -> acpi_os_wait_events_complete()
                                        -> flush_workqueue(kacpi_notify_wq)
    
    which is the queue we are currently executing on and the process will hang.
    
    Move all hotplug acpiphp events onto the kacpi_hotplug workqueue.  In
    handle_hotplug_event_bridge() and handle_hotplug_event_func() we can simply
    push the rest of the work onto the kacpi_hotplug queue and then avoid the
    deadlock.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Cc: mjg@redhat.com
    Cc: bhelgaas@google.com
    Cc: linux-acpi@vger.kernel.org
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index fa32f584229f..f31c5c5f1b7e 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -80,7 +80,8 @@ static acpi_osd_handler acpi_irq_handler;
 static void *acpi_irq_context;
 static struct workqueue_struct *kacpid_wq;
 static struct workqueue_struct *kacpi_notify_wq;
-static struct workqueue_struct *kacpi_hotplug_wq;
+struct workqueue_struct *kacpi_hotplug_wq;
+EXPORT_SYMBOL(kacpi_hotplug_wq);
 
 struct acpi_res_list {
 	resource_size_t start;

commit 4a8f5058bde15d737abe39b5bed3f21dcb6599d2
Merge: 3eb208f0a36c eb03cb02b74d d7f6169a0d32 e4108292cc5b bb0c5ed6ec52 aa165971c292 4996c02306a2 6c8111e9a0e7
Author: Len Brown <len.brown@intel.com>
Date:   Tue Aug 2 17:22:09 2011 -0400

    Merge branches 'acpica', 'battery', 'boot-irqs', 'bz-24492', 'bz-9528', 'from-akpm', 'kexec-param' and 'misc' into release
    
    Conflicts:
            Documentation/kernel-parameters.txt
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit aa165971c2923d05988f920c978e438dbc7b0de6
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Thu Jul 28 13:48:43 2011 -0700

    ACPI: add missing _OSI strings
    
    Linux supports some optional features, but it should notify the BIOS about
    them via the _OSI method.  Currently Linux doesn't notify any, which might
    make such features not work because the BIOS doesn't know about them.
    
    Jarosz has a system which needs this to make ACPI processor aggregator
    device work.
    
    Reported-by: "Jarosz, Sebastian" <sebastian.jarosz@intel.com>
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Acked-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 372f9b70f7f4..0e4785703d45 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1083,7 +1083,13 @@ struct osi_setup_entry {
 	bool enable;
 };
 
-static struct osi_setup_entry __initdata osi_setup_entries[OSI_STRING_ENTRIES_MAX];
+static struct osi_setup_entry __initdata
+		osi_setup_entries[OSI_STRING_ENTRIES_MAX] = {
+	{"Module Device", true},
+	{"Processor Device", true},
+	{"3.0 _SCP Extensions", true},
+	{"Processor Aggregator Device", true},
+};
 
 void __init acpi_osi_setup(char *str)
 {

commit 8997621bb2daaf19a4e9d82f118224159d8054e2
Author: Len Brown <len.brown@intel.com>
Date:   Tue Aug 2 00:45:48 2011 -0400

    ACPI print OSI(Linux) warning only once
    
    This message gets repeated on some machines:
    https://bugzilla.kernel.org/show_bug.cgi?id=29292
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 52ca9649d769..37659804226c 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -155,7 +155,7 @@ static u32 acpi_osi_handler(acpi_string interface, u32 supported)
 {
 	if (!strcmp("Linux", interface)) {
 
-		printk(KERN_NOTICE FW_BUG PREFIX
+		printk_once(KERN_NOTICE FW_BUG PREFIX
 			"BIOS _OSI(Linux) query %s%s\n",
 			osi_linux.enable ? "honored" : "ignored",
 			osi_linux.cmdline ? " via cmdline" :

commit 4996c02306a25def1d352ec8e8f48895bbc7dea9
Author: Takao Indoh <indou.takao@jp.fujitsu.com>
Date:   Thu Jul 14 18:05:21 2011 -0400

    ACPI: introduce "acpi_rsdp=" parameter for kdump
    
    There is a problem with putting the first kernel in EFI virtual mode,
    it is that when the second kernel comes up it tries to initialize the
    EFI again and once we have put EFI in virtual mode we can not really
    do that.
    
    Actually, EFI is not necessary for kdump, we can boot the second kernel
    with "noefi" parameter, but the boot will mostly fail because 2nd kernel
    cannot find RSDP.
    
    In this situation, we introduced "acpi_rsdp=" kernel parameter, so that
    kexec-tools can pass the "noefi acpi_rsdp=X" to the second kernel to
    make kdump works. The physical address of the RSDP can be got from
    sysfs(/sys/firmware/efi/systab).
    
    Signed-off-by: Takao Indoh <indou.takao@jp.fujitsu.com>
    Reviewed-by: WANG Cong <amwang@redhat.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 52ca9649d769..27cd1408f6d8 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -237,8 +237,23 @@ void acpi_os_vprintf(const char *fmt, va_list args)
 #endif
 }
 
+#ifdef CONFIG_KEXEC
+static unsigned long acpi_rsdp;
+static int __init setup_acpi_rsdp(char *arg)
+{
+	acpi_rsdp = simple_strtoul(arg, NULL, 16);
+	return 0;
+}
+early_param("acpi_rsdp", setup_acpi_rsdp);
+#endif
+
 acpi_physical_address __init acpi_os_get_root_pointer(void)
 {
+#ifdef CONFIG_KEXEC
+	if (acpi_rsdp)
+		return acpi_rsdp;
+#endif
+
 	if (efi_enabled) {
 		if (efi.acpi20 != EFI_INVALID_TABLE_ADDR)
 			return efi.acpi20;

commit 07e49a7a31153a95caa270d8ad7350a0bcd4d511
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jul 6 20:44:25 2011 +0200

    ACPI: Fix lockdep false positives in acpi_power_off()
    
    All ACPICA locks are allocated by the same function,
    acpi_os_create_lock(), with the help of a local variable called
    "lock".  Thus, when lockdep is enabled, it uses "lock" as the
    name of all those locks and regards them as instances of the same
    lock, which causes it to report possible locking problems with them
    when there aren't any.
    
    To work around this problem, define acpi_os_create_lock() as a macro
    and make it pass its argument to spin_lock_init(), so that lockdep
    uses it as the name of the new lock.  Define this macron in a
    Linux-specific file, to minimize the resulting modifications of
    the OS-independent ACPICA parts.
    
    This change is based on an earlier patch from Andrea Righi and it
    addresses a regression from 2.6.39 tracked as
    https://bugzilla.kernel.org/show_bug.cgi?id=38152
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-and-tested-by: Borislav Petkov <bp@alien8.de>
    Tested-by: Andrea Righi <andrea@betterlinux.com>
    Reviewed-by: Florian Mickler <florian@mickler.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 52ca9649d769..372f9b70f7f4 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1332,23 +1332,6 @@ int acpi_resources_are_enforced(void)
 }
 EXPORT_SYMBOL(acpi_resources_are_enforced);
 
-/*
- * Create and initialize a spinlock.
- */
-acpi_status
-acpi_os_create_lock(acpi_spinlock *out_handle)
-{
-	spinlock_t *lock;
-
-	lock = ACPI_ALLOCATE(sizeof(spinlock_t));
-	if (!lock)
-		return AE_NO_MEMORY;
-	spin_lock_init(lock);
-	*out_handle = lock;
-
-	return AE_OK;
-}
-
 /*
  * Deallocate the memory for a spinlock.
  */

commit 6288cf1e768ae73db5ddaaae54d85245cc1c2b56
Merge: 0a63e2308cbb 526b4af47f44 932df7414336 534bc4e3d270 28c2103dad04 af986d101d14 b299eb5cde1a
Author: Len Brown <len.brown@intel.com>
Date:   Sun May 29 04:38:48 2011 -0400

    Merge branches 'acpica', 'aml-custom', 'bugzilla-16548', 'bugzilla-20242', 'd3-cold', 'ec-asus' and 'thermal-fix' into release

commit 9f63b88bd7a1ac1afbb4358772a39abaeddbdd13
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Wed Mar 23 17:26:34 2011 +0800

    ACPI: osl, add acpi_os_create_lock interface
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index c90c76aa7f8b..cf750a7a9523 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -883,14 +883,6 @@ void acpi_os_wait_events_complete(void *context)
 
 EXPORT_SYMBOL(acpi_os_wait_events_complete);
 
-/*
- * Deallocate the memory for a spinlock.
- */
-void acpi_os_delete_lock(acpi_spinlock handle)
-{
-	return;
-}
-
 acpi_status
 acpi_os_create_semaphore(u32 max_units, u32 initial_units, acpi_handle * handle)
 {
@@ -1321,6 +1313,31 @@ int acpi_resources_are_enforced(void)
 }
 EXPORT_SYMBOL(acpi_resources_are_enforced);
 
+/*
+ * Create and initialize a spinlock.
+ */
+acpi_status
+acpi_os_create_lock(acpi_spinlock *out_handle)
+{
+	spinlock_t *lock;
+
+	lock = ACPI_ALLOCATE(sizeof(spinlock_t));
+	if (!lock)
+		return AE_NO_MEMORY;
+	spin_lock_init(lock);
+	*out_handle = lock;
+
+	return AE_OK;
+}
+
+/*
+ * Deallocate the memory for a spinlock.
+ */
+void acpi_os_delete_lock(acpi_spinlock handle)
+{
+	ACPI_FREE(handle);
+}
+
 /*
  * Acquire a spinlock.
  *

commit 02e2407858fd62053bf60349c0e72cd1c7a4a60e
Merge: 96e1c408ea8a 6447f55da90b
Author: Len Brown <len.brown@intel.com>
Date:   Wed Mar 23 02:34:54 2011 -0400

    Merge branch 'linus' into release
    
    Conflicts:
            arch/x86/kernel/acpi/sleep.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit dd87cc53c42f3260b7eb7f60822de0fa9e58af59
Merge: 981858bd7a40 bb45e394e21e aad83b143008 23fe36306ea4
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Feb 24 20:00:44 2011 +0100

    Merge branches 'acpi-iomem', 'acpi-pm' and 'acpi-sci' into acpi-next

commit 23fe36306ea489eef7dd88506bdcefdc8da39c91
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:48:16 2011 +0100

    ACPI: Avoid calling request_irq() many times for the same interrupt
    
    In principle acpi_os_install_interrupt_handler() may be called
    multiple times for different interrupts, either from
    acpi_ev_get_gpe_xrupt_block(), or from acpi_ev_install_sci_handler().
    However, it always attempts to request the same interrupt,
    acpi_gbl_FADT.sci_interrupt and it doesn't check whether or not this
    interrupt has already been requested.
    
    Modify this function so that it refuses to request interrupts other
    than acpi_gbl_FADT.sci_interrupt and change
    acpi_os_remove_interrupt_handler() so that it refuses to free such
    interrupts.  Use the observation that the only supported ACPI
    interrupt must be equal to acpi_gbl_FADT.sci_interrupt and drop an
    unnecessary variable acpi_irq_irq.
    
    This change has been tested on Toshiba Portege R500 and HP nx6325
    without introducing any visible problems.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index c90c76aa7f8b..187dff96356b 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -76,7 +76,6 @@ EXPORT_SYMBOL(acpi_in_debugger);
 extern char line_buf[80];
 #endif				/*ENABLE_DEBUGGER */
 
-static unsigned int acpi_irq_irq;
 static acpi_osd_handler acpi_irq_handler;
 static void *acpi_irq_context;
 static struct workqueue_struct *kacpid_wq;
@@ -516,11 +515,15 @@ acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,
 	acpi_irq_stats_init();
 
 	/*
-	 * Ignore the GSI from the core, and use the value in our copy of the
-	 * FADT. It may not be the same if an interrupt source override exists
-	 * for the SCI.
+	 * ACPI interrupts different from the SCI in our copy of the FADT are
+	 * not supported.
 	 */
-	gsi = acpi_gbl_FADT.sci_interrupt;
+	if (gsi != acpi_gbl_FADT.sci_interrupt)
+		return AE_BAD_PARAMETER;
+
+	if (acpi_irq_handler)
+		return AE_ALREADY_ACQUIRED;
+
 	if (acpi_gsi_to_irq(gsi, &irq) < 0) {
 		printk(KERN_ERR PREFIX "SCI (ACPI GSI %d) not registered\n",
 		       gsi);
@@ -531,20 +534,20 @@ acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,
 	acpi_irq_context = context;
 	if (request_irq(irq, acpi_irq, IRQF_SHARED, "acpi", acpi_irq)) {
 		printk(KERN_ERR PREFIX "SCI (IRQ%d) allocation failed\n", irq);
+		acpi_irq_handler = NULL;
 		return AE_NOT_ACQUIRED;
 	}
-	acpi_irq_irq = irq;
 
 	return AE_OK;
 }
 
 acpi_status acpi_os_remove_interrupt_handler(u32 irq, acpi_osd_handler handler)
 {
-	if (irq) {
-		free_irq(irq, acpi_irq);
-		acpi_irq_handler = NULL;
-		acpi_irq_irq = 0;
-	}
+	if (irq != acpi_gbl_FADT.sci_interrupt)
+		return AE_BAD_PARAMETER;
+
+	free_irq(irq, acpi_irq);
+	acpi_irq_handler = NULL;
 
 	return AE_OK;
 }
@@ -1603,7 +1606,7 @@ acpi_status __init acpi_os_initialize1(void)
 acpi_status acpi_os_terminate(void)
 {
 	if (acpi_irq_handler) {
-		acpi_os_remove_interrupt_handler(acpi_irq_irq,
+		acpi_os_remove_interrupt_handler(acpi_gbl_FADT.sci_interrupt,
 						 acpi_irq_handler);
 	}
 

commit 13606a2de1996f8d83a9ce296f74022bdbadf712
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:38:25 2011 +0100

    ACPI: Introduce acpi_os_get_iomem()
    
    Introduce function acpi_os_get_iomem() that may be used by its callers
    to get a reference to an ACPI iomap.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 5389f9f2e2ff..52ca8721bc9c 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -285,6 +285,22 @@ acpi_map_vaddr_lookup(acpi_physical_address phys, unsigned int size)
 	return NULL;
 }
 
+void __iomem *acpi_os_get_iomem(acpi_physical_address phys, unsigned int size)
+{
+	struct acpi_ioremap *map;
+	void __iomem *virt = NULL;
+
+	mutex_lock(&acpi_ioremap_lock);
+	map = acpi_map_lookup(phys, size);
+	if (map) {
+		virt = map->virt + (phys - map->phys);
+		map->refcount++;
+	}
+	mutex_unlock(&acpi_ioremap_lock);
+	return virt;
+}
+EXPORT_SYMBOL_GPL(acpi_os_get_iomem);
+
 /* Must be called with 'acpi_ioremap_lock' or RCU read lock held. */
 static struct acpi_ioremap *
 acpi_map_lookup_virt(void __iomem *virt, acpi_size size)

commit b7c1fadd6c2eead56d0664a3a921980120de0c11
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:38:15 2011 +0100

    ACPI: Do not use krefs under a mutex in osl.c
    
    The reference counting of ACPI iomaps is carried out entirely under
    acpi_ioremap_lock, so it is sufficient to use simple counters instead
    of krefs for this purpose.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 445f205752a2..5389f9f2e2ff 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -105,7 +105,7 @@ struct acpi_ioremap {
 	void __iomem *virt;
 	acpi_physical_address phys;
 	acpi_size size;
-	struct kref ref;
+	unsigned long refcount;
 };
 
 static LIST_HEAD(acpi_ioremaps);
@@ -319,7 +319,7 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 	/* Check if there's a suitable mapping already. */
 	map = acpi_map_lookup(phys, size);
 	if (map) {
-		kref_get(&map->ref);
+		map->refcount++;
 		goto out;
 	}
 
@@ -342,7 +342,7 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 	map->virt = virt;
 	map->phys = pg_off;
 	map->size = pg_sz;
-	kref_init(&map->ref);
+	map->refcount = 1;
 
 	list_add_tail_rcu(&map->list, &acpi_ioremaps);
 
@@ -352,25 +352,24 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 }
 EXPORT_SYMBOL_GPL(acpi_os_map_memory);
 
-static void acpi_kref_del_iomap(struct kref *ref)
+static void acpi_os_drop_map_ref(struct acpi_ioremap *map)
 {
-	struct acpi_ioremap *map;
-
-	map = container_of(ref, struct acpi_ioremap, ref);
-	list_del_rcu(&map->list);
+	if (!--map->refcount)
+		list_del_rcu(&map->list);
 }
 
-static void acpi_os_remove_map(struct acpi_ioremap *map)
+static void acpi_os_map_cleanup(struct acpi_ioremap *map)
 {
-	synchronize_rcu();
-	iounmap(map->virt);
-	kfree(map);
+	if (!map->refcount) {
+		synchronize_rcu();
+		iounmap(map->virt);
+		kfree(map);
+	}
 }
 
 void __ref acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 {
 	struct acpi_ioremap *map;
-	int del;
 
 	if (!acpi_gbl_permanent_mmap) {
 		__acpi_unmap_table(virt, size);
@@ -384,11 +383,10 @@ void __ref acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 		WARN(true, PREFIX "%s: bad address %p\n", __func__, virt);
 		return;
 	}
-	del = kref_put(&map->ref, acpi_kref_del_iomap);
+	acpi_os_drop_map_ref(map);
 	mutex_unlock(&acpi_ioremap_lock);
 
-	if (del)
-		acpi_os_remove_map(map);
+	acpi_os_map_cleanup(map);
 }
 EXPORT_SYMBOL_GPL(acpi_os_unmap_memory);
 
@@ -418,7 +416,6 @@ static int acpi_os_map_generic_address(struct acpi_generic_address *addr)
 static void acpi_os_unmap_generic_address(struct acpi_generic_address *addr)
 {
 	struct acpi_ioremap *map;
-	int del;
 
 	if (addr->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)
 		return;
@@ -432,11 +429,10 @@ static void acpi_os_unmap_generic_address(struct acpi_generic_address *addr)
 		mutex_unlock(&acpi_ioremap_lock);
 		return;
 	}
-	del = kref_put(&map->ref, acpi_kref_del_iomap);
+	acpi_os_drop_map_ref(map);
 	mutex_unlock(&acpi_ioremap_lock);
 
-	if (del)
-		acpi_os_remove_map(map);
+	acpi_os_map_cleanup(map);
 }
 
 #ifdef ACPI_FUTURE_USAGE

commit 7ffd0443f2502478545e23e194b7eb8e16376072
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:38:05 2011 +0100

    ACPI: Make acpi_os_map_memory() avoid creating unnecessary mappings
    
    Modify acpi_os_map_memory() so that it doesn't call acpi_os_ioremap()
    unconditionally every time it is executed (except when
    acpi_gbl_permanent_mmap is unset), which pretty much defeats the
    purpose of maintaining the list of ACPI iomaps in osl.c.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index f6785bced215..445f205752a2 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -302,7 +302,7 @@ acpi_map_lookup_virt(void __iomem *virt, acpi_size size)
 void __iomem *__init_refok
 acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 {
-	struct acpi_ioremap *map, *tmp_map;
+	struct acpi_ioremap *map;
 	void __iomem *virt;
 	acpi_physical_address pg_off;
 	acpi_size pg_sz;
@@ -315,14 +315,25 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 	if (!acpi_gbl_permanent_mmap)
 		return __acpi_map_table((unsigned long)phys, size);
 
+	mutex_lock(&acpi_ioremap_lock);
+	/* Check if there's a suitable mapping already. */
+	map = acpi_map_lookup(phys, size);
+	if (map) {
+		kref_get(&map->ref);
+		goto out;
+	}
+
 	map = kzalloc(sizeof(*map), GFP_KERNEL);
-	if (!map)
+	if (!map) {
+		mutex_unlock(&acpi_ioremap_lock);
 		return NULL;
+	}
 
 	pg_off = round_down(phys, PAGE_SIZE);
 	pg_sz = round_up(phys + size, PAGE_SIZE) - pg_off;
 	virt = acpi_os_ioremap(pg_off, pg_sz);
 	if (!virt) {
+		mutex_unlock(&acpi_ioremap_lock);
 		kfree(map);
 		return NULL;
 	}
@@ -333,19 +344,10 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 	map->size = pg_sz;
 	kref_init(&map->ref);
 
-	mutex_lock(&acpi_ioremap_lock);
-	/* Check if page has already been mapped. */
-	tmp_map = acpi_map_lookup(phys, size);
-	if (tmp_map) {
-		kref_get(&tmp_map->ref);
-		mutex_unlock(&acpi_ioremap_lock);
-		iounmap(map->virt);
-		kfree(map);
-		return tmp_map->virt + (phys - tmp_map->phys);
-	}
 	list_add_tail_rcu(&map->list, &acpi_ioremaps);
-	mutex_unlock(&acpi_ioremap_lock);
 
+ out:
+	mutex_unlock(&acpi_ioremap_lock);
 	return map->virt + (phys - map->phys);
 }
 EXPORT_SYMBOL_GPL(acpi_os_map_memory);

commit 7fe135dc058faea0ce319a03e3b6f98c5049955c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:37:53 2011 +0100

    ACPI: Avoid walking the list of memory mappings in osl.c twice in a row
    
    Make acpi_os_unmap_generic_address() use acpi_map_lookup() to find
    the desired iomap and drop the reference to it directly (and
    eventually remove it if necessary) instead of calling
    acpi_os_unmap_memory(), which requires us to walk the list of ACPI
    iomaps twice in a row (first, to get the virtual address associated
    with the iomap and second, to get the iomap itself).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 97061928249a..f6785bced215 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -358,6 +358,13 @@ static void acpi_kref_del_iomap(struct kref *ref)
 	list_del_rcu(&map->list);
 }
 
+static void acpi_os_remove_map(struct acpi_ioremap *map)
+{
+	synchronize_rcu();
+	iounmap(map->virt);
+	kfree(map);
+}
+
 void __ref acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 {
 	struct acpi_ioremap *map;
@@ -372,20 +379,14 @@ void __ref acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 	map = acpi_map_lookup_virt(virt, size);
 	if (!map) {
 		mutex_unlock(&acpi_ioremap_lock);
-		printk(KERN_ERR PREFIX "%s: bad address %p\n", __func__, virt);
-		dump_stack();
+		WARN(true, PREFIX "%s: bad address %p\n", __func__, virt);
 		return;
 	}
-
 	del = kref_put(&map->ref, acpi_kref_del_iomap);
 	mutex_unlock(&acpi_ioremap_lock);
 
-	if (!del)
-		return;
-
-	synchronize_rcu();
-	iounmap(map->virt);
-	kfree(map);
+	if (del)
+		acpi_os_remove_map(map);
 }
 EXPORT_SYMBOL_GPL(acpi_os_unmap_memory);
 
@@ -414,8 +415,8 @@ static int acpi_os_map_generic_address(struct acpi_generic_address *addr)
 
 static void acpi_os_unmap_generic_address(struct acpi_generic_address *addr)
 {
-	void __iomem *virt;
-	acpi_size size = addr->bit_width / 8;
+	struct acpi_ioremap *map;
+	int del;
 
 	if (addr->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)
 		return;
@@ -424,10 +425,16 @@ static void acpi_os_unmap_generic_address(struct acpi_generic_address *addr)
 		return;
 
 	mutex_lock(&acpi_ioremap_lock);
-	virt = acpi_map_vaddr_lookup(addr->address, size);
+	map = acpi_map_lookup(addr->address, addr->bit_width / 8);
+	if (!map) {
+		mutex_unlock(&acpi_ioremap_lock);
+		return;
+	}
+	del = kref_put(&map->ref, acpi_kref_del_iomap);
 	mutex_unlock(&acpi_ioremap_lock);
 
-	acpi_os_unmap_memory(virt, size);
+	if (del)
+		acpi_os_remove_map(map);
 }
 
 #ifdef ACPI_FUTURE_USAGE

commit 7bbb890358b96cb6f77adc6815f2072bdf813d5d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:37:42 2011 +0100

    ACPI: Change acpi_ioremap_lock into a mutex
    
    There's no reason why acpi_ioremap_lock has to be a spinlock,
    because all of the functions it is used in may sleep anyway and
    there's no reason why it should be locked with interrupts off.
    Use a mutex instead (that's going to allow us to put some more
    operations under the lock later).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index ff2189d3fa06..97061928249a 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -109,7 +109,7 @@ struct acpi_ioremap {
 };
 
 static LIST_HEAD(acpi_ioremaps);
-static DEFINE_SPINLOCK(acpi_ioremap_lock);
+static DEFINE_MUTEX(acpi_ioremap_lock);
 
 static void __init acpi_osi_setup_late(void);
 
@@ -303,7 +303,6 @@ void __iomem *__init_refok
 acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 {
 	struct acpi_ioremap *map, *tmp_map;
-	unsigned long flags;
 	void __iomem *virt;
 	acpi_physical_address pg_off;
 	acpi_size pg_sz;
@@ -334,18 +333,18 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 	map->size = pg_sz;
 	kref_init(&map->ref);
 
-	spin_lock_irqsave(&acpi_ioremap_lock, flags);
+	mutex_lock(&acpi_ioremap_lock);
 	/* Check if page has already been mapped. */
 	tmp_map = acpi_map_lookup(phys, size);
 	if (tmp_map) {
 		kref_get(&tmp_map->ref);
-		spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
+		mutex_unlock(&acpi_ioremap_lock);
 		iounmap(map->virt);
 		kfree(map);
 		return tmp_map->virt + (phys - tmp_map->phys);
 	}
 	list_add_tail_rcu(&map->list, &acpi_ioremaps);
-	spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
+	mutex_unlock(&acpi_ioremap_lock);
 
 	return map->virt + (phys - map->phys);
 }
@@ -362,7 +361,6 @@ static void acpi_kref_del_iomap(struct kref *ref)
 void __ref acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 {
 	struct acpi_ioremap *map;
-	unsigned long flags;
 	int del;
 
 	if (!acpi_gbl_permanent_mmap) {
@@ -370,17 +368,17 @@ void __ref acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 		return;
 	}
 
-	spin_lock_irqsave(&acpi_ioremap_lock, flags);
+	mutex_lock(&acpi_ioremap_lock);
 	map = acpi_map_lookup_virt(virt, size);
 	if (!map) {
-		spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
+		mutex_unlock(&acpi_ioremap_lock);
 		printk(KERN_ERR PREFIX "%s: bad address %p\n", __func__, virt);
 		dump_stack();
 		return;
 	}
 
 	del = kref_put(&map->ref, acpi_kref_del_iomap);
-	spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
+	mutex_unlock(&acpi_ioremap_lock);
 
 	if (!del)
 		return;
@@ -417,7 +415,6 @@ static int acpi_os_map_generic_address(struct acpi_generic_address *addr)
 static void acpi_os_unmap_generic_address(struct acpi_generic_address *addr)
 {
 	void __iomem *virt;
-	unsigned long flags;
 	acpi_size size = addr->bit_width / 8;
 
 	if (addr->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)
@@ -426,9 +423,9 @@ static void acpi_os_unmap_generic_address(struct acpi_generic_address *addr)
 	if (!addr->address || !addr->bit_width)
 		return;
 
-	spin_lock_irqsave(&acpi_ioremap_lock, flags);
+	mutex_lock(&acpi_ioremap_lock);
 	virt = acpi_map_vaddr_lookup(addr->address, size);
-	spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
+	mutex_unlock(&acpi_ioremap_lock);
 
 	acpi_os_unmap_memory(virt, size);
 }

commit 073b4964b3b75fd9e19bf3933b26d9c23591c9db
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:37:31 2011 +0100

    ACPI: Do not export functions that are only used in osl.c
    
    The functions acpi_os_map_generic_address() and
    acpi_os_unmap_generic_address() are only used in drivers/acpi/osl.c,
    so make them static and remove the extern definitions of them from
    include/linux/acpi_io.h.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index c90c76aa7f8b..ff2189d3fa06 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -397,7 +397,7 @@ void __init early_acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 		__acpi_unmap_table(virt, size);
 }
 
-int acpi_os_map_generic_address(struct acpi_generic_address *addr)
+static int acpi_os_map_generic_address(struct acpi_generic_address *addr)
 {
 	void __iomem *virt;
 
@@ -413,9 +413,8 @@ int acpi_os_map_generic_address(struct acpi_generic_address *addr)
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(acpi_os_map_generic_address);
 
-void acpi_os_unmap_generic_address(struct acpi_generic_address *addr)
+static void acpi_os_unmap_generic_address(struct acpi_generic_address *addr)
 {
 	void __iomem *virt;
 	unsigned long flags;
@@ -433,7 +432,6 @@ void acpi_os_unmap_generic_address(struct acpi_generic_address *addr)
 
 	acpi_os_unmap_memory(virt, size);
 }
-EXPORT_SYMBOL_GPL(acpi_os_unmap_generic_address);
 
 #ifdef ACPI_FUTURE_USAGE
 acpi_status

commit 43d133c18b44e7d82d82ef0dcc2bddd55d5dfe81
Merge: 4149efb22da6 6f576d57f1fa
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 21 09:43:56 2011 +0100

    Merge branch 'master' into for-2.6.39

commit 884b821fa27a5e3714d4871976d3e7c3abfa0d1b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:37:16 2011 +0100

    ACPI: Fix acpi_os_read_memory() and acpi_os_write_memory() (v2)
    
    The functions acpi_os_read_memory() and acpi_os_write_memory() do
    two wrong things.  First, they shouldn't call rcu_read_unlock()
    before the looked up address is actually used for I/O, because in
    that case the iomap it belongs to may be removed before the I/O
    is done.  Second, if they have to create a new mapping, they should
    check the returned virtual address and tell the caller that the
    operation failed if it is NULL (in fact, I think they even should not
    attempt to map an address that's not present in one of the existing
    ACPI iomaps, because that may cause problems to happen when they are
    called from nonpreemptible context and their callers ought to know
    what they are doing and map the requisite memory regions beforehand).
    
    Make these functions call rcu_read_unlock() when the I/O is complete
    (or if it's necessary to map the given address "on the fly") and
    return an error code if the requested physical address is not present
    in the existing ACPI iomaps and cannot be mapped.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index b0931818cf98..c90c76aa7f8b 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -636,17 +636,21 @@ EXPORT_SYMBOL(acpi_os_write_port);
 acpi_status
 acpi_os_read_memory(acpi_physical_address phys_addr, u32 * value, u32 width)
 {
-	u32 dummy;
 	void __iomem *virt_addr;
-	int size = width / 8, unmap = 0;
+	unsigned int size = width / 8;
+	bool unmap = false;
+	u32 dummy;
 
 	rcu_read_lock();
 	virt_addr = acpi_map_vaddr_lookup(phys_addr, size);
-	rcu_read_unlock();
 	if (!virt_addr) {
+		rcu_read_unlock();
 		virt_addr = acpi_os_ioremap(phys_addr, size);
-		unmap = 1;
+		if (!virt_addr)
+			return AE_BAD_ADDRESS;
+		unmap = true;
 	}
+
 	if (!value)
 		value = &dummy;
 
@@ -666,6 +670,8 @@ acpi_os_read_memory(acpi_physical_address phys_addr, u32 * value, u32 width)
 
 	if (unmap)
 		iounmap(virt_addr);
+	else
+		rcu_read_unlock();
 
 	return AE_OK;
 }
@@ -674,14 +680,17 @@ acpi_status
 acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
 {
 	void __iomem *virt_addr;
-	int size = width / 8, unmap = 0;
+	unsigned int size = width / 8;
+	bool unmap = false;
 
 	rcu_read_lock();
 	virt_addr = acpi_map_vaddr_lookup(phys_addr, size);
-	rcu_read_unlock();
 	if (!virt_addr) {
+		rcu_read_unlock();
 		virt_addr = acpi_os_ioremap(phys_addr, size);
-		unmap = 1;
+		if (!virt_addr)
+			return AE_BAD_ADDRESS;
+		unmap = true;
 	}
 
 	switch (width) {
@@ -700,6 +709,8 @@ acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
 
 	if (unmap)
 		iounmap(virt_addr);
+	else
+		rcu_read_unlock();
 
 	return AE_OK;
 }

commit 44d2588e1102b4e35022d03b7f124dd6ea013ce8
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Feb 1 11:42:42 2011 +0100

    acpi: kacpi*_wq don't need WQ_MEM_RECLAIM
    
    ACPI workqueues aren't used during memory reclaming.  Use
    alloc_workqueue() to create workqueues w/o rescuers.
    
    If the purpose of the separation between kacpid_wq and kacpi_notify_wq
    was to give notifications better response time, kacpi_notify_wq can be
    dropped and kacpi_wq can be created with higher @max_active.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Len Brown <lenb@kernel.org>
    Cc: linux-acpi@vger.kernel.org

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index b0931818cf98..60a80cbfcdc7 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1578,9 +1578,9 @@ acpi_status __init acpi_os_initialize(void)
 
 acpi_status __init acpi_os_initialize1(void)
 {
-	kacpid_wq = create_workqueue("kacpid");
-	kacpi_notify_wq = create_workqueue("kacpi_notify");
-	kacpi_hotplug_wq = create_workqueue("kacpi_hotplug");
+	kacpid_wq = alloc_workqueue("kacpid", 0, 1);
+	kacpi_notify_wq = alloc_workqueue("kacpi_notify", 0, 1);
+	kacpi_hotplug_wq = alloc_workqueue("kacpi_hotplug", 0, 1);
 	BUG_ON(!kacpid_wq);
 	BUG_ON(!kacpi_notify_wq);
 	BUG_ON(!kacpi_hotplug_wq);

commit 2d6d9fd3a54a28c6f67f26eb6c74803307a1b11e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jan 19 22:27:14 2011 +0100

    ACPI: Introduce acpi_os_ioremap()
    
    Commit ca9b600be38c ("ACPI / PM: Make suspend_nvs_save() use
    acpi_os_map_memory()") attempted to prevent the code in osl.c and nvs.c
    from using different ioremap() variants by making the latter use
    acpi_os_map_memory() for mapping the NVS pages.  However, that also
    requires acpi_os_unmap_memory() to be used for unmapping them, which
    causes synchronize_rcu() to be executed many times in a row
    unnecessarily and introduces substantial delays during resume on some
    systems.
    
    Instead of using acpi_os_map_memory() for mapping the NVS pages in nvs.c
    introduce acpi_os_ioremap() calling ioremap_cache() and make the code in
    both osl.c and nvs.c use it.
    
    Reported-by: Jeff Chua <jeff.chua.linux@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e2dd6de5d50c..b0931818cf98 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -38,6 +38,7 @@
 #include <linux/workqueue.h>
 #include <linux/nmi.h>
 #include <linux/acpi.h>
+#include <linux/acpi_io.h>
 #include <linux/efi.h>
 #include <linux/ioport.h>
 #include <linux/list.h>
@@ -302,9 +303,10 @@ void __iomem *__init_refok
 acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 {
 	struct acpi_ioremap *map, *tmp_map;
-	unsigned long flags, pg_sz;
+	unsigned long flags;
 	void __iomem *virt;
-	phys_addr_t pg_off;
+	acpi_physical_address pg_off;
+	acpi_size pg_sz;
 
 	if (phys > ULONG_MAX) {
 		printk(KERN_ERR PREFIX "Cannot map memory that high\n");
@@ -320,7 +322,7 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 
 	pg_off = round_down(phys, PAGE_SIZE);
 	pg_sz = round_up(phys + size, PAGE_SIZE) - pg_off;
-	virt = ioremap_cache(pg_off, pg_sz);
+	virt = acpi_os_ioremap(pg_off, pg_sz);
 	if (!virt) {
 		kfree(map);
 		return NULL;
@@ -642,7 +644,7 @@ acpi_os_read_memory(acpi_physical_address phys_addr, u32 * value, u32 width)
 	virt_addr = acpi_map_vaddr_lookup(phys_addr, size);
 	rcu_read_unlock();
 	if (!virt_addr) {
-		virt_addr = ioremap_cache(phys_addr, size);
+		virt_addr = acpi_os_ioremap(phys_addr, size);
 		unmap = 1;
 	}
 	if (!value)
@@ -678,7 +680,7 @@ acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
 	virt_addr = acpi_map_vaddr_lookup(phys_addr, size);
 	rcu_read_unlock();
 	if (!virt_addr) {
-		virt_addr = ioremap_cache(phys_addr, size);
+		virt_addr = acpi_os_ioremap(phys_addr, size);
 		unmap = 1;
 	}
 

commit eab001bf88f68653e87a7d90124a2241131dbeda
Merge: 156d821270e1 106d1a0ab2a3
Author: Len Brown <len.brown@intel.com>
Date:   Wed Jan 12 12:16:14 2011 -0500

    Merge branch 'misc' into test

commit 106d1a0ab2a354b97df3e232be7dedbfaf8e901d
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Dec 20 12:11:45 2010 +0100

    ACPI: fix resource check message
    
    printk("%pR",...)
    is for formatting struct resource only.
    But the list built up in drivers/acpi/osl.c uses it's own struct:
    struct acpi_res_list {}
    
    Without this patch you can see wrongly formatted resources (SMRG is of IO type):
    
    ACPI: resource 0000:00:1f.3 [io  0x0400-0x041f] conflicts with AC
          PI region SMRG [mem 0x00000400-0x0000040f 64bit pref disabled]
    
    https://bugzilla.kernel.org/show_bug.cgi?id=26342
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    CC: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 966feddf6b1b..6eaa13cdf767 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1192,8 +1192,7 @@ __setup("acpi_enforce_resources=", acpi_enforce_resources_setup);
 int acpi_check_resource_conflict(const struct resource *res)
 {
 	struct acpi_res_list *res_list_elem;
-	int ioport;
-	int clash = 0;
+	int ioport = 0, clash = 0;
 
 	if (acpi_enforce_resources == ENFORCE_RESOURCES_NO)
 		return 0;
@@ -1223,9 +1222,13 @@ int acpi_check_resource_conflict(const struct resource *res)
 	if (clash) {
 		if (acpi_enforce_resources != ENFORCE_RESOURCES_NO) {
 			printk(KERN_WARNING "ACPI: resource %s %pR"
-			       " conflicts with ACPI region %s %pR\n",
+			       " conflicts with ACPI region %s "
+			       "[%s 0x%zx-0x%zx]\n",
 			       res->name, res, res_list_elem->name,
-			       res_list_elem);
+			       (res_list_elem->resource_type ==
+				ACPI_ADR_SPACE_SYSTEM_IO) ? "io" : "mem",
+			       (size_t) res_list_elem->start,
+			       (size_t) res_list_elem->end);
 			if (acpi_enforce_resources == ENFORCE_RESOURCES_LAX)
 				printk(KERN_NOTICE "ACPI: This conflict may"
 				       " cause random problems and system"

commit 6d5bbf00d251cc73223a71422d69e069dc2e0b8d
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 7 01:46:40 2011 +0100

    ACPI: Use ioremap_cache()
    
    Although the temporary boot-time ACPI table mappings
    were set up with CPU caching enabled, the permanent table
    mappings and AML run-time region memory accesses were
    set up with ioremap(), which on x86 is a synonym for
    ioremap_nocache().
    
    Changing this to ioremap_cache() improves performance as
    seen when accessing the tables via acpidump,
    or /sys/firmware/acpi/tables.  It should also improve
    AML run-time performance.
    
    No change on ia64.
    
    Reported-by: Jack Steiner <steiner@sgi.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 055d7b701fff..3a7b4879fd99 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -320,7 +320,7 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 
 	pg_off = round_down(phys, PAGE_SIZE);
 	pg_sz = round_up(phys + size, PAGE_SIZE) - pg_off;
-	virt = ioremap(pg_off, pg_sz);
+	virt = ioremap_cache(pg_off, pg_sz);
 	if (!virt) {
 		kfree(map);
 		return NULL;
@@ -642,7 +642,7 @@ acpi_os_read_memory(acpi_physical_address phys_addr, u32 * value, u32 width)
 	virt_addr = acpi_map_vaddr_lookup(phys_addr, size);
 	rcu_read_unlock();
 	if (!virt_addr) {
-		virt_addr = ioremap(phys_addr, size);
+		virt_addr = ioremap_cache(phys_addr, size);
 		unmap = 1;
 	}
 	if (!value)
@@ -678,7 +678,7 @@ acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
 	virt_addr = acpi_map_vaddr_lookup(phys_addr, size);
 	rcu_read_unlock();
 	if (!virt_addr) {
-		virt_addr = ioremap(phys_addr, size);
+		virt_addr = ioremap_cache(phys_addr, size);
 		unmap = 1;
 	}
 

commit 6cc5615f7c4decd7b6c4da9317d0e0b5fbdf7290
Merge: a5dc4f898c2a 3138b32d5e09 12b3b5afed67 bec4f22a2dbd 12d3206466d2
Author: Len Brown <len.brown@intel.com>
Date:   Sat Dec 11 02:02:02 2010 -0500

    Merge branches 'bugzilla-15418', 'bugzilla-21722', 'bugzilla-22932', 'misc-2.6.37' and 'osi-regression' into release

commit 32d47eeff05981bfb89a95747eb182bc12630d58
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Wed Dec 8 10:40:36 2010 +0800

    ACPI: fix a section mismatch
    
    WARNING: drivers/acpi/acpi.o(.text+0xeda): Section mismatch in reference from the function acpi_os_initialize1() to the function .init.text:set_osi_linux()
    
    The function acpi_os_initialize1() references
    the function __init set_osi_linux().
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 966feddf6b1b..f7227e990b0f 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1530,7 +1530,7 @@ acpi_status __init acpi_os_initialize(void)
 	return AE_OK;
 }
 
-acpi_status acpi_os_initialize1(void)
+acpi_status __init acpi_os_initialize1(void)
 {
 	kacpid_wq = create_workqueue("kacpid");
 	kacpi_notify_wq = create_workqueue("kacpi_notify");

commit 12d3206466d2074ef0684aaf7759ae01a0a92560
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Thu Dec 9 16:51:06 2010 +0800

    ACPI: fix allowing to add/remove multiple _OSI strings
    
    commit b0ed7a91(ACPICA/ACPI: Add new host interfaces for _OSI suppor)
    introduced another regression that only one _OSI string can be added or
    removed.
    
    Now multiple _OSI strings can be added or removed, for example
    
    acpi_osi=Linux acpi_osi=FreeBSD acpi_osi="!Windows 2006"
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 6867443c4941..d0a1bb54367b 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -110,9 +110,6 @@ struct acpi_ioremap {
 static LIST_HEAD(acpi_ioremaps);
 static DEFINE_SPINLOCK(acpi_ioremap_lock);
 
-#define	OSI_STRING_LENGTH_MAX 64	/* arbitrary */
-static char osi_setup_string[OSI_STRING_LENGTH_MAX];
-
 static void __init acpi_osi_setup_late(void);
 
 /*
@@ -1054,16 +1051,47 @@ static int __init acpi_os_name_setup(char *str)
 
 __setup("acpi_os_name=", acpi_os_name_setup);
 
+#define	OSI_STRING_LENGTH_MAX 64	/* arbitrary */
+#define	OSI_STRING_ENTRIES_MAX 16	/* arbitrary */
+
+struct osi_setup_entry {
+	char string[OSI_STRING_LENGTH_MAX];
+	bool enable;
+};
+
+static struct osi_setup_entry __initdata osi_setup_entries[OSI_STRING_ENTRIES_MAX];
+
 void __init acpi_osi_setup(char *str)
 {
+	struct osi_setup_entry *osi;
+	bool enable = true;
+	int i;
+
 	if (!acpi_gbl_create_osi_method)
 		return;
 
 	if (str == NULL || *str == '\0') {
 		printk(KERN_INFO PREFIX "_OSI method disabled\n");
 		acpi_gbl_create_osi_method = FALSE;
-	} else
-		strncpy(osi_setup_string, str, OSI_STRING_LENGTH_MAX);
+		return;
+	}
+
+	if (*str == '!') {
+		str++;
+		enable = false;
+	}
+
+	for (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {
+		osi = &osi_setup_entries[i];
+		if (!strcmp(osi->string, str)) {
+			osi->enable = enable;
+			break;
+		} else if (osi->string[0] == '\0') {
+			osi->enable = enable;
+			strncpy(osi->string, str, OSI_STRING_LENGTH_MAX);
+			break;
+		}
+	}
 }
 
 static void __init set_osi_linux(unsigned int enable)
@@ -1110,22 +1138,28 @@ void __init acpi_dmi_osi_linux(int enable, const struct dmi_system_id *d)
  */
 static void __init acpi_osi_setup_late(void)
 {
-	char *str = osi_setup_string;
+	struct osi_setup_entry *osi;
+	char *str;
+	int i;
 	acpi_status status;
 
-	if (*str == '\0')
-		return;
+	for (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {
+		osi = &osi_setup_entries[i];
+		str = osi->string;
 
-	if (*str == '!') {
-		status = acpi_remove_interface(++str);
+		if (*str == '\0')
+			break;
+		if (osi->enable) {
+			status = acpi_install_interface(str);
 
-		if (ACPI_SUCCESS(status))
-			printk(KERN_INFO PREFIX "Deleted _OSI(%s)\n", str);
-	} else {
-		status = acpi_install_interface(str);
+			if (ACPI_SUCCESS(status))
+				printk(KERN_INFO PREFIX "Added _OSI(%s)\n", str);
+		} else {
+			status = acpi_remove_interface(str);
 
-		if (ACPI_SUCCESS(status))
-			printk(KERN_INFO PREFIX "Added _OSI(%s)\n", str);
+			if (ACPI_SUCCESS(status))
+				printk(KERN_INFO PREFIX "Deleted _OSI(%s)\n", str);
+		}
 	}
 }
 

commit d90aa92c0c1625d7f02050e4d2924805840cda3d
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Thu Dec 9 16:50:52 2010 +0800

    acpi: fix _OSI string setup regression
    
    commit b0ed7a91(ACPICA/ACPI: Add new host interfaces for _OSI suppor)
    introduced a regression that _OSI string setup fails.
    
    There are 2 paths to setup _OSI string.
    
    DMI:
    acpi_dmi_osi_linux -> set_osi_linux -> acpi_osi_setup -> copy _OSI
    string to osi_setup_string
    
    Boot command line:
    acpi_osi_setup -> copy _OSI string to osi_setup_string
    
    Later, acpi_osi_setup_late will be called to handle osi_setup_string.
    If _OSI string is "Linux" or "!Linux", then the call path is,
    
    acpi_osi_setup_late -> acpi_cmdline_osi_linux -> set_osi_linux ->
    acpi_osi_setup -> copy _OSI string to osi_setup_string
    
    This actually never installs _OSI string(acpi_install_interface not
    called), but just copy the _OSI string to osi_setup_string.
    
    This patch fixes the regression.
    
    Reported-and-tested-by: Lukas Hejtmanek <xhejtman@ics.muni.cz>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 966feddf6b1b..6867443c4941 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -152,8 +152,7 @@ static struct osi_linux {
 	unsigned int	enable:1;
 	unsigned int	dmi:1;
 	unsigned int	cmdline:1;
-	unsigned int	known:1;
-} osi_linux = { 0, 0, 0, 0};
+} osi_linux = {0, 0, 0};
 
 static u32 acpi_osi_handler(acpi_string interface, u32 supported)
 {
@@ -1055,13 +1054,22 @@ static int __init acpi_os_name_setup(char *str)
 
 __setup("acpi_os_name=", acpi_os_name_setup);
 
+void __init acpi_osi_setup(char *str)
+{
+	if (!acpi_gbl_create_osi_method)
+		return;
+
+	if (str == NULL || *str == '\0') {
+		printk(KERN_INFO PREFIX "_OSI method disabled\n");
+		acpi_gbl_create_osi_method = FALSE;
+	} else
+		strncpy(osi_setup_string, str, OSI_STRING_LENGTH_MAX);
+}
+
 static void __init set_osi_linux(unsigned int enable)
 {
-	if (osi_linux.enable != enable) {
+	if (osi_linux.enable != enable)
 		osi_linux.enable = enable;
-		printk(KERN_NOTICE PREFIX "%sed _OSI(Linux)\n",
-			enable ? "Add": "Delet");
-	}
 
 	if (osi_linux.enable)
 		acpi_osi_setup("Linux");
@@ -1073,7 +1081,8 @@ static void __init set_osi_linux(unsigned int enable)
 
 static void __init acpi_cmdline_osi_linux(unsigned int enable)
 {
-	osi_linux.cmdline = 1;	/* cmdline set the default */
+	osi_linux.cmdline = 1;	/* cmdline set the default and override DMI */
+	osi_linux.dmi = 0;
 	set_osi_linux(enable);
 
 	return;
@@ -1081,15 +1090,12 @@ static void __init acpi_cmdline_osi_linux(unsigned int enable)
 
 void __init acpi_dmi_osi_linux(int enable, const struct dmi_system_id *d)
 {
-	osi_linux.dmi = 1;	/* DMI knows that this box asks OSI(Linux) */
-
 	printk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);
 
 	if (enable == -1)
 		return;
 
-	osi_linux.known = 1;	/* DMI knows which OSI(Linux) default needed */
-
+	osi_linux.dmi = 1;	/* DMI knows that this box asks OSI(Linux) */
 	set_osi_linux(enable);
 
 	return;
@@ -1105,36 +1111,37 @@ void __init acpi_dmi_osi_linux(int enable, const struct dmi_system_id *d)
 static void __init acpi_osi_setup_late(void)
 {
 	char *str = osi_setup_string;
+	acpi_status status;
 
 	if (*str == '\0')
 		return;
 
-	if (!strcmp("!Linux", str)) {
-		acpi_cmdline_osi_linux(0);	/* !enable */
-	} else if (*str == '!') {
-		if (acpi_remove_interface(++str) == AE_OK)
+	if (*str == '!') {
+		status = acpi_remove_interface(++str);
+
+		if (ACPI_SUCCESS(status))
 			printk(KERN_INFO PREFIX "Deleted _OSI(%s)\n", str);
-	} else if (!strcmp("Linux", str)) {
-		acpi_cmdline_osi_linux(1);	/* enable */
 	} else {
-		if (acpi_install_interface(str) == AE_OK)
+		status = acpi_install_interface(str);
+
+		if (ACPI_SUCCESS(status))
 			printk(KERN_INFO PREFIX "Added _OSI(%s)\n", str);
 	}
 }
 
-int __init acpi_osi_setup(char *str)
+static int __init osi_setup(char *str)
 {
-	if (str == NULL || *str == '\0') {
-		printk(KERN_INFO PREFIX "_OSI method disabled\n");
-		acpi_gbl_create_osi_method = FALSE;
-	} else {
-		strncpy(osi_setup_string, str, OSI_STRING_LENGTH_MAX);
-	}
+	if (str && !strcmp("Linux", str))
+		acpi_cmdline_osi_linux(1);
+	else if (str && !strcmp("!Linux", str))
+		acpi_cmdline_osi_linux(0);
+	else
+		acpi_osi_setup(str);
 
 	return 1;
 }
 
-__setup("acpi_osi=", acpi_osi_setup);
+__setup("acpi_osi=", osi_setup);
 
 /* enable serialization to combat AE_ALREADY_EXISTS errors */
 static int __init acpi_serialize_setup(char *str)

commit 7e31842441776b4d6ec7fd916c91663ad05b7814
Merge: 1bd64d42abdd b1d248d96c71
Author: Len Brown <len.brown@intel.com>
Date:   Tue Oct 26 14:51:00 2010 -0400

    Merge branch 'misc' into release

commit 1bd64d42abdd4f9d44f77011a31f0292112f4c3b
Merge: 4895ae6f9f81 4a3cba5e72a5
Author: Len Brown <len.brown@intel.com>
Date:   Tue Oct 26 14:50:56 2010 -0400

    Merge branch 'acpi-mmio' into release
    
    Conflicts:
            drivers/acpi/osl.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 4a3cba5e72a5232842ff7c1ca691ec3450af64b9
Author: Myron Stowe <myron.stowe@hp.com>
Date:   Thu Oct 21 14:24:14 2010 -0600

    ACPI: Page based coalescing of I/O remappings optimization
    
    This patch optimizes ACPI MMIO remappings by keeping track of the
    remappings on a PAGE_SIZE granularity.
    
    When an ioremap() occurs, the underlying infrastructure works on a 'page'
    based granularity.  As such, an ioremap() request for 1 byte for example,
    will end up mapping in an entire (PAGE_SIZE) page.  Huang Ying took
    advantage of this in commit 15651291a2f8c11e7e6a42d8bfde7a213ff13262 by
    checking if subsequent ioremap() requests reside within any of the list's
    existing remappings still in place, and if so, incrementing a reference
    count on the existing mapping as opposed to performing another ioremap().
    
    Signed-off-by: Myron Stowe <myron.stowe@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 32826893c2e6..885e222bcabd 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -104,6 +104,7 @@ struct acpi_ioremap {
 	void __iomem *virt;
 	acpi_physical_address phys;
 	acpi_size size;
+	struct kref ref;
 };
 
 static LIST_HEAD(acpi_ioremaps);
@@ -245,15 +246,28 @@ acpi_physical_address __init acpi_os_get_root_pointer(void)
 }
 
 /* Must be called with 'acpi_ioremap_lock' or RCU read lock held. */
-static void __iomem *
-acpi_map_vaddr_lookup(acpi_physical_address phys, acpi_size size)
+static struct acpi_ioremap *
+acpi_map_lookup(acpi_physical_address phys, acpi_size size)
 {
 	struct acpi_ioremap *map;
 
 	list_for_each_entry_rcu(map, &acpi_ioremaps, list)
 		if (map->phys <= phys &&
 		    phys + size <= map->phys + map->size)
-			return map->virt + (phys - map->phys);
+			return map;
+
+	return NULL;
+}
+
+/* Must be called with 'acpi_ioremap_lock' or RCU read lock held. */
+static void __iomem *
+acpi_map_vaddr_lookup(acpi_physical_address phys, unsigned int size)
+{
+	struct acpi_ioremap *map;
+
+	map = acpi_map_lookup(phys, size);
+	if (map)
+		return map->virt + (phys - map->phys);
 
 	return NULL;
 }
@@ -265,7 +279,8 @@ acpi_map_lookup_virt(void __iomem *virt, acpi_size size)
 	struct acpi_ioremap *map;
 
 	list_for_each_entry_rcu(map, &acpi_ioremaps, list)
-		if (map->virt == virt && map->size == size)
+		if (map->virt <= virt &&
+		    virt + size <= map->virt + map->size)
 			return map;
 
 	return NULL;
@@ -274,9 +289,10 @@ acpi_map_lookup_virt(void __iomem *virt, acpi_size size)
 void __iomem *__init_refok
 acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 {
-	struct acpi_ioremap *map;
-	unsigned long flags;
+	struct acpi_ioremap *map, *tmp_map;
+	unsigned long flags, pg_sz;
 	void __iomem *virt;
+	phys_addr_t pg_off;
 
 	if (phys > ULONG_MAX) {
 		printk(KERN_ERR PREFIX "Cannot map memory that high\n");
@@ -290,7 +306,9 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 	if (!map)
 		return NULL;
 
-	virt = ioremap(phys, size);
+	pg_off = round_down(phys, PAGE_SIZE);
+	pg_sz = round_up(phys + size, PAGE_SIZE) - pg_off;
+	virt = ioremap(pg_off, pg_sz);
 	if (!virt) {
 		kfree(map);
 		return NULL;
@@ -298,21 +316,40 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 
 	INIT_LIST_HEAD(&map->list);
 	map->virt = virt;
-	map->phys = phys;
-	map->size = size;
+	map->phys = pg_off;
+	map->size = pg_sz;
+	kref_init(&map->ref);
 
 	spin_lock_irqsave(&acpi_ioremap_lock, flags);
+	/* Check if page has already been mapped. */
+	tmp_map = acpi_map_lookup(phys, size);
+	if (tmp_map) {
+		kref_get(&tmp_map->ref);
+		spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
+		iounmap(map->virt);
+		kfree(map);
+		return tmp_map->virt + (phys - tmp_map->phys);
+	}
 	list_add_tail_rcu(&map->list, &acpi_ioremaps);
 	spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
 
-	return virt;
+	return map->virt + (phys - map->phys);
 }
 EXPORT_SYMBOL_GPL(acpi_os_map_memory);
 
+static void acpi_kref_del_iomap(struct kref *ref)
+{
+	struct acpi_ioremap *map;
+
+	map = container_of(ref, struct acpi_ioremap, ref);
+	list_del_rcu(&map->list);
+}
+
 void __ref acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 {
 	struct acpi_ioremap *map;
 	unsigned long flags;
+	int del;
 
 	if (!acpi_gbl_permanent_mmap) {
 		__acpi_unmap_table(virt, size);
@@ -328,9 +365,12 @@ void __ref acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 		return;
 	}
 
-	list_del_rcu(&map->list);
+	del = kref_put(&map->ref, acpi_kref_del_iomap);
 	spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
 
+	if (!del)
+		return;
+
 	synchronize_rcu();
 	iounmap(map->virt);
 	kfree(map);

commit 78cdb3ed4053798c894899b15d2255fb880edad4
Author: Myron Stowe <myron.stowe@hp.com>
Date:   Thu Oct 21 14:24:09 2010 -0600

    ACPI: Convert simple locking to RCU based locking
    
    Convert the simple locking introduced earlier for the ACPI MMIO
    remappings list to an RCU based locking scheme.
    
    Signed-off-by: Myron Stowe <myron.stowe@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index c63d4cb37dab..32826893c2e6 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -244,13 +244,13 @@ acpi_physical_address __init acpi_os_get_root_pointer(void)
 	}
 }
 
-/* Must be called with 'acpi_ioremap_lock' lock held. */
+/* Must be called with 'acpi_ioremap_lock' or RCU read lock held. */
 static void __iomem *
 acpi_map_vaddr_lookup(acpi_physical_address phys, acpi_size size)
 {
 	struct acpi_ioremap *map;
 
-	list_for_each_entry(map, &acpi_ioremaps, list)
+	list_for_each_entry_rcu(map, &acpi_ioremaps, list)
 		if (map->phys <= phys &&
 		    phys + size <= map->phys + map->size)
 			return map->virt + (phys - map->phys);
@@ -258,13 +258,13 @@ acpi_map_vaddr_lookup(acpi_physical_address phys, acpi_size size)
 	return NULL;
 }
 
-/* Must be called with 'acpi_ioremap_lock' lock held. */
+/* Must be called with 'acpi_ioremap_lock' or RCU read lock held. */
 static struct acpi_ioremap *
 acpi_map_lookup_virt(void __iomem *virt, acpi_size size)
 {
 	struct acpi_ioremap *map;
 
-	list_for_each_entry(map, &acpi_ioremaps, list)
+	list_for_each_entry_rcu(map, &acpi_ioremaps, list)
 		if (map->virt == virt && map->size == size)
 			return map;
 
@@ -302,7 +302,7 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 	map->size = size;
 
 	spin_lock_irqsave(&acpi_ioremap_lock, flags);
-	list_add_tail(&map->list, &acpi_ioremaps);
+	list_add_tail_rcu(&map->list, &acpi_ioremaps);
 	spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
 
 	return virt;
@@ -328,9 +328,10 @@ void __ref acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 		return;
 	}
 
-	list_del(&map->list);
+	list_del_rcu(&map->list);
 	spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
 
+	synchronize_rcu();
 	iounmap(map->virt);
 	kfree(map);
 }
@@ -584,11 +585,10 @@ acpi_os_read_memory(acpi_physical_address phys_addr, u32 * value, u32 width)
 	u32 dummy;
 	void __iomem *virt_addr;
 	int size = width / 8, unmap = 0;
-	unsigned long flags;
 
-	spin_lock_irqsave(&acpi_ioremap_lock, flags);
+	rcu_read_lock();
 	virt_addr = acpi_map_vaddr_lookup(phys_addr, size);
-	spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
+	rcu_read_unlock();
 	if (!virt_addr) {
 		virt_addr = ioremap(phys_addr, size);
 		unmap = 1;
@@ -621,11 +621,10 @@ acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
 {
 	void __iomem *virt_addr;
 	int size = width / 8, unmap = 0;
-	unsigned long flags;
 
-	spin_lock_irqsave(&acpi_ioremap_lock, flags);
+	rcu_read_lock();
 	virt_addr = acpi_map_vaddr_lookup(phys_addr, size);
-	spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
+	rcu_read_unlock();
 	if (!virt_addr) {
 		virt_addr = ioremap(phys_addr, size);
 		unmap = 1;

commit d362edaf5386acedad4319a6721bb1540b74dcf7
Author: Myron Stowe <myron.stowe@hp.com>
Date:   Thu Oct 21 14:24:04 2010 -0600

    ACPI: Pre-map 'system event' related register blocks
    
    During ACPI initialization, pre-map fixed hardware registers that are
    accessed during ACPI's 'system event' related IRQ handing.
    
    ACPI's 'system event' handing accesses specific fixed hardware
    registers; namely PM1a event, PM1b event, GPE0, and GPE1 register
    blocks which are declared within the FADT.  If these registers are
    backed by MMIO, as opposed to I/O port space, accessing them within
    interrupt context will cause a panic as acpi_os_read_memory()
    depends on ioremap() in such cases - BZ 18012.
    
    By utilizing the functionality provided in the previous two patches -
    ACPI: Maintain a list of ACPI memory mapped I/O remappings, and, ACPI:
    Add interfaces for ioremapping/iounmapping ACPI registers - accesses
    to ACPI MMIO areas will now be safe from within interrupt contexts (IRQ
    and/or NMI) provided the area was pre-mapped.  This solves BZ 18012.
    
    ACPI "System Event" reference(s):
      ACPI Specification, Revision 4.0, Section 3 "ACPI Overview",
      3.8 "System Events", 5.6 "ACPI Event Programming Model".
    
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=18012
    
    Reported-by: <bjorn.helgaas@hp.com>
    Signed-off-by: Myron Stowe <myron.stowe@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index fc6c5d21c3eb..c63d4cb37dab 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -199,36 +199,6 @@ static int __init acpi_reserve_resources(void)
 }
 device_initcall(acpi_reserve_resources);
 
-acpi_status __init acpi_os_initialize(void)
-{
-	return AE_OK;
-}
-
-acpi_status acpi_os_initialize1(void)
-{
-	kacpid_wq = create_workqueue("kacpid");
-	kacpi_notify_wq = create_workqueue("kacpi_notify");
-	kacpi_hotplug_wq = create_workqueue("kacpi_hotplug");
-	BUG_ON(!kacpid_wq);
-	BUG_ON(!kacpi_notify_wq);
-	BUG_ON(!kacpi_hotplug_wq);
-	return AE_OK;
-}
-
-acpi_status acpi_os_terminate(void)
-{
-	if (acpi_irq_handler) {
-		acpi_os_remove_interrupt_handler(acpi_irq_irq,
-						 acpi_irq_handler);
-	}
-
-	destroy_workqueue(kacpid_wq);
-	destroy_workqueue(kacpi_notify_wq);
-	destroy_workqueue(kacpi_hotplug_wq);
-
-	return AE_OK;
-}
-
 void acpi_os_printf(const char *fmt, ...)
 {
 	va_list args;
@@ -1598,5 +1568,44 @@ acpi_os_validate_address (
 	}
 	return AE_OK;
 }
-
 #endif
+
+acpi_status __init acpi_os_initialize(void)
+{
+	acpi_os_map_generic_address(&acpi_gbl_FADT.xpm1a_event_block);
+	acpi_os_map_generic_address(&acpi_gbl_FADT.xpm1b_event_block);
+	acpi_os_map_generic_address(&acpi_gbl_FADT.xgpe0_block);
+	acpi_os_map_generic_address(&acpi_gbl_FADT.xgpe1_block);
+
+	return AE_OK;
+}
+
+acpi_status acpi_os_initialize1(void)
+{
+	kacpid_wq = create_workqueue("kacpid");
+	kacpi_notify_wq = create_workqueue("kacpi_notify");
+	kacpi_hotplug_wq = create_workqueue("kacpi_hotplug");
+	BUG_ON(!kacpid_wq);
+	BUG_ON(!kacpi_notify_wq);
+	BUG_ON(!kacpi_hotplug_wq);
+	return AE_OK;
+}
+
+acpi_status acpi_os_terminate(void)
+{
+	if (acpi_irq_handler) {
+		acpi_os_remove_interrupt_handler(acpi_irq_irq,
+						 acpi_irq_handler);
+	}
+
+	acpi_os_unmap_generic_address(&acpi_gbl_FADT.xgpe1_block);
+	acpi_os_unmap_generic_address(&acpi_gbl_FADT.xgpe0_block);
+	acpi_os_unmap_generic_address(&acpi_gbl_FADT.xpm1b_event_block);
+	acpi_os_unmap_generic_address(&acpi_gbl_FADT.xpm1a_event_block);
+
+	destroy_workqueue(kacpid_wq);
+	destroy_workqueue(kacpi_notify_wq);
+	destroy_workqueue(kacpi_hotplug_wq);
+
+	return AE_OK;
+}

commit 29718521237a1b1607ea05b49243100ea2044337
Author: Myron Stowe <myron.stowe@hp.com>
Date:   Thu Oct 21 14:23:59 2010 -0600

    ACPI: Add interfaces for ioremapping/iounmapping ACPI registers
    
    Add remapping and unmapping interfaces for ACPI registers that are
    backed by memory mapped I/O (MMIO).  These interfaces, along with
    the MMIO remapping list, enable accesses of such registers from within
    interrupt context.
    
    ACPI Generic Address Structure (GAS) reference (ACPI's fixed/generic
    hardware registers use the GAS format):
      ACPI Specification, Revision 4.0, Section 5.2.3.1, "Generic Address
      Structure".
    
    Signed-off-by: Myron Stowe <myron.stowe@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index bd72129e35f2..fc6c5d21c3eb 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -372,6 +372,44 @@ void __init early_acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 		__acpi_unmap_table(virt, size);
 }
 
+int acpi_os_map_generic_address(struct acpi_generic_address *addr)
+{
+	void __iomem *virt;
+
+	if (addr->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)
+		return 0;
+
+	if (!addr->address || !addr->bit_width)
+		return -EINVAL;
+
+	virt = acpi_os_map_memory(addr->address, addr->bit_width / 8);
+	if (!virt)
+		return -EIO;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(acpi_os_map_generic_address);
+
+void acpi_os_unmap_generic_address(struct acpi_generic_address *addr)
+{
+	void __iomem *virt;
+	unsigned long flags;
+	acpi_size size = addr->bit_width / 8;
+
+	if (addr->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)
+		return;
+
+	if (!addr->address || !addr->bit_width)
+		return;
+
+	spin_lock_irqsave(&acpi_ioremap_lock, flags);
+	virt = acpi_map_vaddr_lookup(addr->address, size);
+	spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
+
+	acpi_os_unmap_memory(virt, size);
+}
+EXPORT_SYMBOL_GPL(acpi_os_unmap_generic_address);
+
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_os_get_physical_address(void *virt, acpi_physical_address * phys)

commit 620242ae8c3d9c0b1a77451744fb2d855d1e7342
Author: Myron Stowe <myron.stowe@hp.com>
Date:   Thu Oct 21 14:23:53 2010 -0600

    ACPI: Maintain a list of ACPI memory mapped I/O remappings
    
    For memory mapped I/O (MMIO) remappings, add a list to maintain the
    remappings and augment the corresponding mapping and unmapping interface
    routines (acpi_os_map_memory() and acpi_os_unmap_memory()) to
    dynamically add to, and delete from, the list.
    
    The current ACPI I/O accessing methods - acpi_read() and acpi_write() -
    end up calling ioremap() when accessing MMIO.  This prevents use of these
    methods within interrupt context (IRQ and/or NMI), since ioremap() may
    block to allocate memory.  Maintaining a list of MMIO remappings enables
    accesses to such areas from within interrupt context provided they have
    been pre-mapped.
    
    Signed-off-by: Myron Stowe <myron.stowe@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 58842fb9fd90..bd72129e35f2 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -95,6 +95,20 @@ struct acpi_res_list {
 static LIST_HEAD(resource_list_head);
 static DEFINE_SPINLOCK(acpi_res_lock);
 
+/*
+ * This list of permanent mappings is for memory that may be accessed from
+ * interrupt context, where we can't do the ioremap().
+ */
+struct acpi_ioremap {
+	struct list_head list;
+	void __iomem *virt;
+	acpi_physical_address phys;
+	acpi_size size;
+};
+
+static LIST_HEAD(acpi_ioremaps);
+static DEFINE_SPINLOCK(acpi_ioremap_lock);
+
 #define	OSI_STRING_LENGTH_MAX 64	/* arbitrary */
 static char osi_additional_string[OSI_STRING_LENGTH_MAX];
 
@@ -260,29 +274,95 @@ acpi_physical_address __init acpi_os_get_root_pointer(void)
 	}
 }
 
+/* Must be called with 'acpi_ioremap_lock' lock held. */
+static void __iomem *
+acpi_map_vaddr_lookup(acpi_physical_address phys, acpi_size size)
+{
+	struct acpi_ioremap *map;
+
+	list_for_each_entry(map, &acpi_ioremaps, list)
+		if (map->phys <= phys &&
+		    phys + size <= map->phys + map->size)
+			return map->virt + (phys - map->phys);
+
+	return NULL;
+}
+
+/* Must be called with 'acpi_ioremap_lock' lock held. */
+static struct acpi_ioremap *
+acpi_map_lookup_virt(void __iomem *virt, acpi_size size)
+{
+	struct acpi_ioremap *map;
+
+	list_for_each_entry(map, &acpi_ioremaps, list)
+		if (map->virt == virt && map->size == size)
+			return map;
+
+	return NULL;
+}
+
 void __iomem *__init_refok
 acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 {
+	struct acpi_ioremap *map;
+	unsigned long flags;
+	void __iomem *virt;
+
 	if (phys > ULONG_MAX) {
 		printk(KERN_ERR PREFIX "Cannot map memory that high\n");
 		return NULL;
 	}
-	if (acpi_gbl_permanent_mmap)
-		/*
-		* ioremap checks to ensure this is in reserved space
-		*/
-		return ioremap((unsigned long)phys, size);
-	else
+
+	if (!acpi_gbl_permanent_mmap)
 		return __acpi_map_table((unsigned long)phys, size);
+
+	map = kzalloc(sizeof(*map), GFP_KERNEL);
+	if (!map)
+		return NULL;
+
+	virt = ioremap(phys, size);
+	if (!virt) {
+		kfree(map);
+		return NULL;
+	}
+
+	INIT_LIST_HEAD(&map->list);
+	map->virt = virt;
+	map->phys = phys;
+	map->size = size;
+
+	spin_lock_irqsave(&acpi_ioremap_lock, flags);
+	list_add_tail(&map->list, &acpi_ioremaps);
+	spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
+
+	return virt;
 }
 EXPORT_SYMBOL_GPL(acpi_os_map_memory);
 
 void __ref acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 {
-	if (acpi_gbl_permanent_mmap)
-		iounmap(virt);
-	else
+	struct acpi_ioremap *map;
+	unsigned long flags;
+
+	if (!acpi_gbl_permanent_mmap) {
 		__acpi_unmap_table(virt, size);
+		return;
+	}
+
+	spin_lock_irqsave(&acpi_ioremap_lock, flags);
+	map = acpi_map_lookup_virt(virt, size);
+	if (!map) {
+		spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
+		printk(KERN_ERR PREFIX "%s: bad address %p\n", __func__, virt);
+		dump_stack();
+		return;
+	}
+
+	list_del(&map->list);
+	spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
+
+	iounmap(map->virt);
+	kfree(map);
 }
 EXPORT_SYMBOL_GPL(acpi_os_unmap_memory);
 
@@ -495,8 +575,16 @@ acpi_os_read_memory(acpi_physical_address phys_addr, u32 * value, u32 width)
 {
 	u32 dummy;
 	void __iomem *virt_addr;
-
-	virt_addr = ioremap(phys_addr, width / 8);
+	int size = width / 8, unmap = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&acpi_ioremap_lock, flags);
+	virt_addr = acpi_map_vaddr_lookup(phys_addr, size);
+	spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
+	if (!virt_addr) {
+		virt_addr = ioremap(phys_addr, size);
+		unmap = 1;
+	}
 	if (!value)
 		value = &dummy;
 
@@ -514,7 +602,8 @@ acpi_os_read_memory(acpi_physical_address phys_addr, u32 * value, u32 width)
 		BUG();
 	}
 
-	iounmap(virt_addr);
+	if (unmap)
+		iounmap(virt_addr);
 
 	return AE_OK;
 }
@@ -523,8 +612,16 @@ acpi_status
 acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
 {
 	void __iomem *virt_addr;
-
-	virt_addr = ioremap(phys_addr, width / 8);
+	int size = width / 8, unmap = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&acpi_ioremap_lock, flags);
+	virt_addr = acpi_map_vaddr_lookup(phys_addr, size);
+	spin_unlock_irqrestore(&acpi_ioremap_lock, flags);
+	if (!virt_addr) {
+		virt_addr = ioremap(phys_addr, size);
+		unmap = 1;
+	}
 
 	switch (width) {
 	case 8:
@@ -540,7 +637,8 @@ acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
 		BUG();
 	}
 
-	iounmap(virt_addr);
+	if (unmap)
+		iounmap(virt_addr);
 
 	return AE_OK;
 }

commit b3ba1efec2a58f4dc0647f4c0099c27d6ab92595
Author: Myron Stowe <myron.stowe@hp.com>
Date:   Thu Oct 21 14:23:48 2010 -0600

    ACPI: Fix ioremap size for MMIO reads and writes
    
    The size used for I/O remapping MMIO read and write accesses has not
    accounted for the basis of ACPI's Generic Address Structure (GAS)
    'Register Bit Width' field which is bits, not bytes.  This patch
    adjusts the ioremap() 'size' argument accordingly.
    
    ACPI "Generic Register" reference:
      ACPI Specification, Revision 4.0, Section 5.2.3.1, "Generic Address
      Structure".
    
    Signed-off-by: Myron Stowe <myron.stowe@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 65b25a303b86..58842fb9fd90 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -496,7 +496,7 @@ acpi_os_read_memory(acpi_physical_address phys_addr, u32 * value, u32 width)
 	u32 dummy;
 	void __iomem *virt_addr;
 
-	virt_addr = ioremap(phys_addr, width);
+	virt_addr = ioremap(phys_addr, width / 8);
 	if (!value)
 		value = &dummy;
 
@@ -524,7 +524,7 @@ acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
 {
 	void __iomem *virt_addr;
 
-	virt_addr = ioremap(phys_addr, width);
+	virt_addr = ioremap(phys_addr, width / 8);
 
 	switch (width) {
 	case 8:

commit 5ba8b1c6fe40c314a02e28553c25552d8f1442e7
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Mon Oct 18 08:42:48 2010 -0700

    ACPI: remove dead code
    
    Found by running make namespacecheck on linux-next
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 65b25a303b86..82097fd5a75b 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -779,16 +779,6 @@ void acpi_os_wait_events_complete(void *context)
 
 EXPORT_SYMBOL(acpi_os_wait_events_complete);
 
-/*
- * Allocate the memory for a spinlock and initialize it.
- */
-acpi_status acpi_os_create_lock(acpi_spinlock * handle)
-{
-	spin_lock_init(*handle);
-
-	return AE_OK;
-}
-
 /*
  * Deallocate the memory for a spinlock.
  */
@@ -1152,21 +1142,6 @@ int acpi_check_region(resource_size_t start, resource_size_t n,
 }
 EXPORT_SYMBOL(acpi_check_region);
 
-int acpi_check_mem_region(resource_size_t start, resource_size_t n,
-		      const char *name)
-{
-	struct resource res = {
-		.start = start,
-		.end   = start + n - 1,
-		.name  = name,
-		.flags = IORESOURCE_MEM,
-	};
-
-	return acpi_check_resource_conflict(&res);
-
-}
-EXPORT_SYMBOL(acpi_check_mem_region);
-
 /*
  * Let drivers know whether the resource checks are effective
  */

commit 3af283e1141474925b33383425bbe038e75fd03a
Author: Len Brown <len.brown@intel.com>
Date:   Fri Oct 15 21:38:57 2010 -0400

    ACPI: add FW_BUG to OSI(Linux) message
    
    Linux-2.6.22 initiated a dmesg complaint when it saw BIOS that invoked
    OSI(Linux).  Linux-2.6.23 continued that complaint and started our
    policy of ignoring the bogus BIOS request.
    
    Past-time for Linux to label that complaint with FW_BUG.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 90a8e86e86f5..d3bed219c442 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -144,7 +144,7 @@ static u32 acpi_osi_handler(acpi_string interface, u32 supported)
 {
 	if (!strcmp("Linux", interface)) {
 
-		printk(KERN_NOTICE PREFIX
+		printk(KERN_NOTICE FW_BUG PREFIX
 			"BIOS _OSI(Linux) query %s%s\n",
 			osi_linux.enable ? "honored" : "ignored",
 			osi_linux.cmdline ? " via cmdline" :

commit 95abccb576c44bc593e05fa1245d0ad26ce6107b
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Sep 15 13:22:46 2010 +0800

    ACPICA: Obsolete the acpi_os_derive_pci_id OSL interface
    
    This function is not OS-dependent and has been replaced by
    acpi_hw_derive_pci_id, which is now in the ACPICA core code.  Local
    implementations of acpi_os_derive_pci_id are no longer necessary and
    are removed. ACPICA BZ 857.
    
    http://www.acpica.org/bugzilla/show_bug.cgi?id=857
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 6652c4929391..90a8e86e86f5 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -622,74 +622,6 @@ acpi_os_write_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
 	return (result ? AE_ERROR : AE_OK);
 }
 
-/* TODO: Change code to take advantage of driver model more */
-static void acpi_os_derive_pci_id_2(acpi_handle rhandle,	/* upper bound  */
-				    acpi_handle chandle,	/* current node */
-				    struct acpi_pci_id **id,
-				    int *is_bridge, u8 * bus_number)
-{
-	acpi_handle handle;
-	struct acpi_pci_id *pci_id = *id;
-	acpi_status status;
-	unsigned long long temp;
-	acpi_object_type type;
-
-	acpi_get_parent(chandle, &handle);
-	if (handle != rhandle) {
-		acpi_os_derive_pci_id_2(rhandle, handle, &pci_id, is_bridge,
-					bus_number);
-
-		status = acpi_get_type(handle, &type);
-		if ((ACPI_FAILURE(status)) || (type != ACPI_TYPE_DEVICE))
-			return;
-
-		status = acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL,
-					  &temp);
-		if (ACPI_SUCCESS(status)) {
-			u64 val;
-			pci_id->device = ACPI_HIWORD(ACPI_LODWORD(temp));
-			pci_id->function = ACPI_LOWORD(ACPI_LODWORD(temp));
-
-			if (*is_bridge)
-				pci_id->bus = *bus_number;
-
-			/* any nicer way to get bus number of bridge ? */
-			status =
-			    acpi_os_read_pci_configuration(pci_id, 0x0e, &val,
-							   8);
-			if (ACPI_SUCCESS(status)
-			    && ((val & 0x7f) == 1 || (val & 0x7f) == 2)) {
-				status =
-				    acpi_os_read_pci_configuration(pci_id, 0x18,
-								   &val, 8);
-				if (!ACPI_SUCCESS(status)) {
-					/* Certainly broken...  FIX ME */
-					return;
-				}
-				*is_bridge = 1;
-				pci_id->bus = val;
-				status =
-				    acpi_os_read_pci_configuration(pci_id, 0x19,
-								   &val, 8);
-				if (ACPI_SUCCESS(status)) {
-					*bus_number = val;
-				}
-			} else
-				*is_bridge = 0;
-		}
-	}
-}
-
-void acpi_os_derive_pci_id(acpi_handle rhandle,	/* upper bound  */
-			   acpi_handle chandle,	/* current node */
-			   struct acpi_pci_id **id)
-{
-	int is_bridge = 1;
-	u8 bus_number = (*id)->bus;
-
-	acpi_os_derive_pci_id_2(rhandle, chandle, id, &is_bridge, &bus_number);
-}
-
 static void acpi_os_execute_deferred(struct work_struct *work)
 {
 	struct acpi_os_dpc *dpc = container_of(work, struct acpi_os_dpc, work);

commit b0ed7a915abac309fcb5a51bccd3782e3daa7417
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Fri Aug 6 09:35:51 2010 +0800

    ACPICA/ACPI: Add new host interfaces for _OSI support
    
    Adds install/remove interfaces so that the host can dynamically
    alter the global _OSI table. Also adds support for _OSI handlers.
    Additional support: new debugger command (osi), and test support in
    the acpiexec utility. Adds new file, utilities/utosi.c.
    ACPICA bugzilla 836.
    
    The Linux OSL _OSI code is also changed.
    acpi_osi_setup can't call acpi_install/remove_interface because ACPICA
    is not initialized yet at this early time.
    So we just save the osi string in acpi_osi_setup and will handle it
    later in a new function acpi_osi_setup_late.
    
    http://www.acpica.org/bugzilla/show_bug.cgi?id=836
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index a351291496ff..6652c4929391 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -96,7 +96,9 @@ static LIST_HEAD(resource_list_head);
 static DEFINE_SPINLOCK(acpi_res_lock);
 
 #define	OSI_STRING_LENGTH_MAX 64	/* arbitrary */
-static char osi_additional_string[OSI_STRING_LENGTH_MAX];
+static char osi_setup_string[OSI_STRING_LENGTH_MAX];
+
+static void __init acpi_osi_setup_late(void);
 
 /*
  * The story of _OSI(Linux)
@@ -138,6 +140,20 @@ static struct osi_linux {
 	unsigned int	known:1;
 } osi_linux = { 0, 0, 0, 0};
 
+static u32 acpi_osi_handler(acpi_string interface, u32 supported)
+{
+	if (!strcmp("Linux", interface)) {
+
+		printk(KERN_NOTICE PREFIX
+			"BIOS _OSI(Linux) query %s%s\n",
+			osi_linux.enable ? "honored" : "ignored",
+			osi_linux.cmdline ? " via cmdline" :
+			osi_linux.dmi ? " via DMI" : "");
+	}
+
+	return supported;
+}
+
 static void __init acpi_request_region (struct acpi_generic_address *addr,
 	unsigned int length, char *desc)
 {
@@ -198,6 +214,8 @@ acpi_status acpi_os_initialize1(void)
 	BUG_ON(!kacpid_wq);
 	BUG_ON(!kacpi_notify_wq);
 	BUG_ON(!kacpi_hotplug_wq);
+	acpi_install_interface_handler(acpi_osi_handler);
+	acpi_osi_setup_late();
 	return AE_OK;
 }
 
@@ -979,6 +997,12 @@ static void __init set_osi_linux(unsigned int enable)
 		printk(KERN_NOTICE PREFIX "%sed _OSI(Linux)\n",
 			enable ? "Add": "Delet");
 	}
+
+	if (osi_linux.enable)
+		acpi_osi_setup("Linux");
+	else
+		acpi_osi_setup("!Linux");
+
 	return;
 }
 
@@ -1013,21 +1037,33 @@ void __init acpi_dmi_osi_linux(int enable, const struct dmi_system_id *d)
  * string starting with '!' disables that string
  * otherwise string is added to list, augmenting built-in strings
  */
-int __init acpi_osi_setup(char *str)
+static void __init acpi_osi_setup_late(void)
 {
-	if (str == NULL || *str == '\0') {
-		printk(KERN_INFO PREFIX "_OSI method disabled\n");
-		acpi_gbl_create_osi_method = FALSE;
-	} else if (!strcmp("!Linux", str)) {
+	char *str = osi_setup_string;
+
+	if (*str == '\0')
+		return;
+
+	if (!strcmp("!Linux", str)) {
 		acpi_cmdline_osi_linux(0);	/* !enable */
 	} else if (*str == '!') {
-		if (acpi_osi_invalidate(++str) == AE_OK)
+		if (acpi_remove_interface(++str) == AE_OK)
 			printk(KERN_INFO PREFIX "Deleted _OSI(%s)\n", str);
 	} else if (!strcmp("Linux", str)) {
 		acpi_cmdline_osi_linux(1);	/* enable */
-	} else if (*osi_additional_string == '\0') {
-		strncpy(osi_additional_string, str, OSI_STRING_LENGTH_MAX);
-		printk(KERN_INFO PREFIX "Added _OSI(%s)\n", str);
+	} else {
+		if (acpi_install_interface(str) == AE_OK)
+			printk(KERN_INFO PREFIX "Added _OSI(%s)\n", str);
+	}
+}
+
+int __init acpi_osi_setup(char *str)
+{
+	if (str == NULL || *str == '\0') {
+		printk(KERN_INFO PREFIX "_OSI method disabled\n");
+		acpi_gbl_create_osi_method = FALSE;
+	} else {
+		strncpy(osi_setup_string, str, OSI_STRING_LENGTH_MAX);
 	}
 
 	return 1;
@@ -1284,38 +1320,6 @@ acpi_status acpi_os_release_object(acpi_cache_t * cache, void *object)
 	return (AE_OK);
 }
 
-/******************************************************************************
- *
- * FUNCTION:    acpi_os_validate_interface
- *
- * PARAMETERS:  interface           - Requested interface to be validated
- *
- * RETURN:      AE_OK if interface is supported, AE_SUPPORT otherwise
- *
- * DESCRIPTION: Match an interface string to the interfaces supported by the
- *              host. Strings originate from an AML call to the _OSI method.
- *
- *****************************************************************************/
-
-acpi_status
-acpi_os_validate_interface (char *interface)
-{
-	if (!strncmp(osi_additional_string, interface, OSI_STRING_LENGTH_MAX))
-		return AE_OK;
-	if (!strcmp("Linux", interface)) {
-
-		printk(KERN_NOTICE PREFIX
-			"BIOS _OSI(Linux) query %s%s\n",
-			osi_linux.enable ? "honored" : "ignored",
-			osi_linux.cmdline ? " via cmdline" :
-			osi_linux.dmi ? " via DMI" : "");
-
-		if (osi_linux.enable)
-			return AE_OK;
-	}
-	return AE_SUPPORT;
-}
-
 static inline int acpi_res_list_add(struct acpi_res_list *res)
 {
 	struct acpi_res_list *res_list_elem;

commit c5f0231ee6b0441e4c45f461f2b6652b10195494
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Aug 6 08:57:53 2010 +0800

    ACPICA: Fix acpi_os_read_pci_configuration prototype
    
    Prototype in acpiosxf.h had the output value pointer as a (u32 *).
    Should be a (u64 *).
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 65b25a303b86..a351291496ff 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -547,9 +547,10 @@ acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
 
 acpi_status
 acpi_os_read_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
-			       u32 *value, u32 width)
+			       u64 *value, u32 width)
 {
 	int result, size;
+	u32 value32;
 
 	if (!value)
 		return AE_BAD_PARAMETER;
@@ -570,7 +571,8 @@ acpi_os_read_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
 
 	result = raw_pci_read(pci_id->segment, pci_id->bus,
 				PCI_DEVFN(pci_id->device, pci_id->function),
-				reg, size, value);
+				reg, size, &value32);
+	*value = value32;
 
 	return (result ? AE_ERROR : AE_OK);
 }
@@ -626,7 +628,7 @@ static void acpi_os_derive_pci_id_2(acpi_handle rhandle,	/* upper bound  */
 		status = acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL,
 					  &temp);
 		if (ACPI_SUCCESS(status)) {
-			u32 val;
+			u64 val;
 			pci_id->device = ACPI_HIWORD(ACPI_LODWORD(temp));
 			pci_id->function = ACPI_LOWORD(ACPI_LODWORD(temp));
 

commit 95ee46aa8698f2000647dfb362400fadbb5807cf
Merge: cfa806f05980 92fa5bd9a946
Author: Len Brown <len.brown@intel.com>
Date:   Sun Aug 15 01:06:31 2010 -0400

    Merge branch 'linus' into release
    
    Conflicts:
            drivers/acpi/debug.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit cfa806f059801dbe7e435745eb2e187c8bfe1e7f
Author: Andi Kleen <andi@firstfloor.org>
Date:   Tue Jul 20 15:18:36 2010 -0700

    gcc-4.6: ACPI: fix unused but set variables in ACPI
    
    Some minor improvements in error handling, but overall it was mostly dead
    code.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 44bddc5bc6ad..03017b1eb38b 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -141,15 +141,14 @@ static struct osi_linux {
 static void __init acpi_request_region (struct acpi_generic_address *addr,
 	unsigned int length, char *desc)
 {
-	struct resource *res;
-
 	if (!addr->address || !length)
 		return;
 
+	/* Resources are never freed */
 	if (addr->space_id == ACPI_ADR_SPACE_SYSTEM_IO)
-		res = request_region(addr->address, length, desc);
+		request_region(addr->address, length, desc);
 	else if (addr->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)
-		res = request_mem_region(addr->address, length, desc);
+		request_mem_region(addr->address, length, desc);
 }
 
 static int __init acpi_reserve_resources(void)

commit 9e50ab91d025afc17ca14a1764be2e1d0c24245d
Merge: 3cc08fc35db7 a0d468718b90
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 7 17:08:30 2010 -0700

    Merge branch 'acpica' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'acpica' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6: (27 commits)
      ACPI / ACPICA: Simplify acpi_ev_initialize_gpe_block()
      ACPI / ACPICA: Fail acpi_gpe_wakeup() if ACPI_GPE_CAN_WAKE is unset
      ACPI / ACPICA: Do not execute _PRW methods during initialization
      ACPI: Fix bogus GPE test in acpi_bus_set_run_wake_flags()
      ACPICA: Update version to 20100702
      ACPICA: Fix for Alias references within Package objects
      ACPICA: Fix lint warning for 64-bit constant
      ACPICA: Remove obsolete GPE function
      ACPICA: Update debug output components
      ACPICA: Add support for WDDT - Watchdog Descriptor Table
      ACPICA: Drop acpi_set_gpe
      ACPICA: Use low-level GPE enable during GPE block initialization
      ACPI / EC: Do not use acpi_set_gpe
      ACPI / EC: Drop suspend and resume routines
      ACPICA: Remove wakeup GPE reference counting which is not used
      ACPICA: Introduce acpi_gpe_wakeup()
      ACPICA: Rename acpi_hw_gpe_register_bit
      ACPICA: Update version to 20100528
      ACPICA: Add signatures for undefined tables: ATKG, GSCI, IEIT
      ACPICA: Optimization: Reduce the number of namespace walks
      ...

commit 9874647ba1bdf3e1af25e079070a00676f60f2f0
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 8 00:43:36 2010 +0200

    ACPI / ACPICA: Do not execute _PRW methods during initialization
    
    Currently, during initialization ACPICA walks the entire ACPI
    namespace in search of any device objects with assciated _PRW
    methods.  All of the _PRW methods found are executed in the process
    to extract the GPE information returned by them, so that the GPEs in
    question can be marked as "able to wakeup" (more precisely, the
    ACPI_GPE_CAN_WAKE flag is set for them).  The only purpose of this
    exercise is to avoid enabling the CAN_WAKE GPEs automatically, even
    if there are _Lxx/_Exx methods associated with them.  However, it is
    both costly and unnecessary, because the host OS has to execute the
    _PRW methods anyway to check which devices can wake up the system
    from sleep states.  Moreover, it then uses full information
    returned by _PRW, including the GPE information, so it can take care
    of disabling the GPEs if necessary.
    
    Remove the code that walks the namespace and executes _PRW from
    ACPICA and modify comments to reflect that change.  Make
    acpi_bus_set_run_wake_flags() disable GPEs for wakeup devices
    so that they don't cause spurious wakeup events to be signaled.
    This not only reduces the complexity of the ACPICA initialization
    code, but in some cases it should reduce the kernel boot time as
    well.
    
    Unfortunately, for this purpose we need a new ACPICA function,
    acpi_gpe_can_wake(), to be called by the host OS in order to disable
    the GPEs that can wake up the system and were previously enabled by
    acpi_ev_initialize_gpe_block() or acpi_ev_update_gpes() (such a GPE
    should be disabled only once, because the initialization code enables
    it only once, but it may be pointed to by _PRW for multiple devices
    and that's why the additional function is necessary).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 78418ce4fc78..44bddc5bc6ad 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1064,26 +1064,6 @@ static int __init acpi_serialize_setup(char *str)
 
 __setup("acpi_serialize", acpi_serialize_setup);
 
-/*
- * Wake and Run-Time GPES are expected to be separate.
- * We disable wake-GPEs at run-time to prevent spurious
- * interrupts.
- *
- * However, if a system exists that shares Wake and
- * Run-time events on the same GPE this flag is available
- * to tell Linux to keep the wake-time GPEs enabled at run-time.
- */
-static int __init acpi_wake_gpes_always_on_setup(char *str)
-{
-	printk(KERN_INFO PREFIX "wake GPEs not disabled\n");
-
-	acpi_gbl_leave_wake_gpes_disabled = FALSE;
-
-	return 1;
-}
-
-__setup("acpi_wake_gpes_always_on", acpi_wake_gpes_always_on_setup);
-
 /* Check of resource interference between native drivers and ACPI
  * OperationRegions (SystemIO and System Memory only).
  * IO ports and memory declared in ACPI might be used by the ACPI subsystem

commit 8fec62b2d9d0c80b594d0d85678bfdf57a70df1b
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jun 29 10:07:09 2010 +0200

    acpi: use queue_work_on() instead of binding workqueue worker to cpu0
    
    ACPI works need to be executed on cpu0 and acpi/osl.c achieves this by
    creating singlethread workqueue and then binding it to cpu0 from a
    work which is quite unorthodox.  Make it create regular workqueues and
    use queue_work_on() instead.  This is in preparation of concurrency
    managed workqueue and the extra workers won't be a problem after it's
    implemented.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 78418ce4fc78..46cce391fa46 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -191,36 +191,11 @@ acpi_status __init acpi_os_initialize(void)
 	return AE_OK;
 }
 
-static void bind_to_cpu0(struct work_struct *work)
-{
-	set_cpus_allowed_ptr(current, cpumask_of(0));
-	kfree(work);
-}
-
-static void bind_workqueue(struct workqueue_struct *wq)
-{
-	struct work_struct *work;
-
-	work = kzalloc(sizeof(struct work_struct), GFP_KERNEL);
-	INIT_WORK(work, bind_to_cpu0);
-	queue_work(wq, work);
-}
-
 acpi_status acpi_os_initialize1(void)
 {
-	/*
-	 * On some machines, a software-initiated SMI causes corruption unless
-	 * the SMI runs on CPU 0.  An SMI can be initiated by any AML, but
-	 * typically it's done in GPE-related methods that are run via
-	 * workqueues, so we can avoid the known corruption cases by binding
-	 * the workqueues to CPU 0.
-	 */
-	kacpid_wq = create_singlethread_workqueue("kacpid");
-	bind_workqueue(kacpid_wq);
-	kacpi_notify_wq = create_singlethread_workqueue("kacpi_notify");
-	bind_workqueue(kacpi_notify_wq);
-	kacpi_hotplug_wq = create_singlethread_workqueue("kacpi_hotplug");
-	bind_workqueue(kacpi_hotplug_wq);
+	kacpid_wq = create_workqueue("kacpid");
+	kacpi_notify_wq = create_workqueue("kacpi_notify");
+	kacpi_hotplug_wq = create_workqueue("kacpi_hotplug");
 	BUG_ON(!kacpid_wq);
 	BUG_ON(!kacpi_notify_wq);
 	BUG_ON(!kacpi_hotplug_wq);
@@ -766,7 +741,14 @@ static acpi_status __acpi_os_execute(acpi_execute_type type,
 	else
 		INIT_WORK(&dpc->work, acpi_os_execute_deferred);
 
-	ret = queue_work(queue, &dpc->work);
+	/*
+	 * On some machines, a software-initiated SMI causes corruption unless
+	 * the SMI runs on CPU 0.  An SMI can be initiated by any AML, but
+	 * typically it's done in GPE-related methods that are run via
+	 * workqueues, so we can avoid the known corruption cases by always
+	 * queueing on CPU 0.
+	 */
+	ret = queue_work_on(0, queue, &dpc->work);
 
 	if (!ret) {
 		printk(KERN_ERR PREFIX

commit 70dd6beac02f43a5099fcf5fddf68cfee0cbf479
Author: Jean Delvare <khali@linux-fr.org>
Date:   Thu May 27 19:58:37 2010 +0200

    hwmon: (asus_atk0110) Don't load if ACPI resources aren't enforced
    
    When the user passes the kernel parameter acpi_enforce_resources=lax,
    the ACPI resources are no longer protected, so a native driver can
    make use of them. In that case, we do not want the asus_atk0110 to be
    loaded. Unfortunately, this driver loads automatically due to its
    MODULE_DEVICE_TABLE, so the user ends up with two drivers loaded for
    the same device - this is bad.
    
    So I suggest that we prevent the asus_atk0110 driver from loading if
    acpi_enforce_resources=lax.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Luca Tettamanti <kronos.it@gmail.com>
    Cc: Len Brown <lenb@kernel.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 4bc1c4178f50..78418ce4fc78 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1206,6 +1206,15 @@ int acpi_check_mem_region(resource_size_t start, resource_size_t n,
 }
 EXPORT_SYMBOL(acpi_check_mem_region);
 
+/*
+ * Let drivers know whether the resource checks are effective
+ */
+int acpi_resources_are_enforced(void)
+{
+	return acpi_enforce_resources == ENFORCE_RESOURCES_STRICT;
+}
+EXPORT_SYMBOL(acpi_resources_are_enforced);
+
 /*
  * Acquire a spinlock.
  *

commit 6c9468e9eb1252eaefd94ce7f06e1be9b0b641b1
Merge: 4cb3ca7cd7e2 c81eddb0e372
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Apr 23 02:08:44 2010 +0200

    Merge branch 'master' into for-next

commit c25f7cf2032aaac9bd50d6eee982719878538082
Merge: f79e1cec8c8a dadf28a10c3e ac7729da880e 3162b6f0c5e1 bc73675b99fd b7b30de53aef bf02bd2590eb 1638bca898e5 0f9b75ef3722 17c452f99cf5
Author: Len Brown <len.brown@intel.com>
Date:   Tue Apr 6 17:06:22 2010 -0400

    Merge branches 'battery', 'bugzilla-14667', 'bugzilla-15096', 'bugzilla-15480', 'bugzilla-15521', 'bugzilla-15605', 'gpe-reference-counters', 'misc', 'pxm-fix' and 'video-random-key' into release

commit 1638bca898e55f1c89f18b2e5accfac8591fed61
Author: Chase Douglas <chase.douglas@canonical.com>
Date:   Mon Mar 22 15:08:09 2010 -0400

    ACPI: Reduce ACPI resource conflict message to KERN_WARNING, printk cleanup
    
    By default, ACPI resource conflict messages are logged at level
    KERN_ERR. This is a rather high level for a message that is more a
    warning than an indication of a real kernel error. Also, KERN_ERR level
    messages can appear over some boot splash screens, and this message is
    not serious enough to warrant such treatment. Thus, the log level has
    been reduced to KERN_WARNING.
    
    [lenb changed to KERN_WARNING rather than all the way to KERN_INFO]
    
    Also, cleanup message to use %pR resource printing format.
    
    Signed-off-by: Chase Douglas <chase.douglas@canonical.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 8e6d8665f0ae..6e49f62723bf 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1151,16 +1151,10 @@ int acpi_check_resource_conflict(const struct resource *res)
 
 	if (clash) {
 		if (acpi_enforce_resources != ENFORCE_RESOURCES_NO) {
-			printk("%sACPI: %s resource %s [0x%llx-0x%llx]"
-			       " conflicts with ACPI region %s"
-			       " [0x%llx-0x%llx]\n",
-			       acpi_enforce_resources == ENFORCE_RESOURCES_LAX
-			       ? KERN_WARNING : KERN_ERR,
-			       ioport ? "I/O" : "Memory", res->name,
-			       (long long) res->start, (long long) res->end,
-			       res_list_elem->name,
-			       (long long) res_list_elem->start,
-			       (long long) res_list_elem->end);
+			printk(KERN_WARNING "ACPI: resource %s %pR"
+			       " conflicts with ACPI region %s %pR\n",
+			       res->name, res, res_list_elem->name,
+			       res_list_elem);
 			if (acpi_enforce_resources == ENFORCE_RESOURCES_LAX)
 				printk(KERN_NOTICE "ACPI: This conflict may"
 				       " cause random problems and system"

commit bc73675b99fd9850dd914be01d71af99c5d2a1ae
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Mon Mar 22 15:48:54 2010 +0800

    ACPI: fixes a false alarm from lockdep
    
    fixes a false alarm from lockdep, as acpi hotplug workqueue waits other
    workqueues.
    http://bugzilla.kernel.org/show_bug.cgi?id=14553
    https://bugzilla.kernel.org/show_bug.cgi?id=15521
    
    Original-patch-from: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 8e6d8665f0ae..900da68fbb5e 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -758,7 +758,14 @@ static acpi_status __acpi_os_execute(acpi_execute_type type,
 	queue = hp ? kacpi_hotplug_wq :
 		(type == OSL_NOTIFY_HANDLER ? kacpi_notify_wq : kacpid_wq);
 	dpc->wait = hp ? 1 : 0;
-	INIT_WORK(&dpc->work, acpi_os_execute_deferred);
+
+	if (queue == kacpi_hotplug_wq)
+		INIT_WORK(&dpc->work, acpi_os_execute_deferred);
+	else if (queue == kacpi_notify_wq)
+		INIT_WORK(&dpc->work, acpi_os_execute_deferred);
+	else
+		INIT_WORK(&dpc->work, acpi_os_execute_deferred);
+
 	ret = queue_work(queue, &dpc->work);
 
 	if (!ret) {

commit 88393161210493e317ae391696ee8ef463cb3c23
Author: Thomas Weber <swirl@gmx.li>
Date:   Tue Mar 16 11:47:56 2010 +0100

    Fix typos in comments
    
    [Ss]ytem => [Ss]ystem
    udpate => update
    paramters => parameters
    orginal => original
    
    Signed-off-by: Thomas Weber <swirl@gmx.li>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 8e6d8665f0ae..f92531fbd501 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1405,7 +1405,7 @@ acpi_os_invalidate_address(
 	switch (space_id) {
 	case ACPI_ADR_SPACE_SYSTEM_IO:
 	case ACPI_ADR_SPACE_SYSTEM_MEMORY:
-		/* Only interference checks against SystemIO and SytemMemory
+		/* Only interference checks against SystemIO and SystemMemory
 		   are needed */
 		res.start = address;
 		res.end = address + length - 1;
@@ -1457,7 +1457,7 @@ acpi_os_validate_address (
 	switch (space_id) {
 	case ACPI_ADR_SPACE_SYSTEM_IO:
 	case ACPI_ADR_SPACE_SYSTEM_MEMORY:
-		/* Only interference checks against SystemIO and SytemMemory
+		/* Only interference checks against SystemIO and SystemMemory
 		   are needed */
 		res = kzalloc(sizeof(struct acpi_res_list), GFP_KERNEL);
 		if (!res)

commit 439913fffd39374c3737186b22d2d56c3a0ae526
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Thu Jan 28 10:53:19 2010 +0800

    ACPI: replace acpi_integer by u64
    
    acpi_integer is now obsolete and removed from the ACPICA code base,
    replaced by u64.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 02e8464e480f..8e6d8665f0ae 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -436,7 +436,7 @@ acpi_status acpi_os_remove_interrupt_handler(u32 irq, acpi_osd_handler handler)
  * Running in interpreter thread context, safe to sleep
  */
 
-void acpi_os_sleep(acpi_integer ms)
+void acpi_os_sleep(u64 ms)
 {
 	schedule_timeout_interruptible(msecs_to_jiffies(ms));
 }
@@ -603,7 +603,7 @@ acpi_os_read_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
 
 acpi_status
 acpi_os_write_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
-				acpi_integer value, u32 width)
+				u64 value, u32 width)
 {
 	int result, size;
 

commit 876fba43cc810e3c37ce26995933f9547b83cb0e
Author: Jean Delvare <khali@linux-fr.org>
Date:   Wed Nov 11 15:22:15 2009 +0100

    ACPI: add const to acpi_check_resource_conflict()
    
    acpi_check_resource_conflict() doesn't change the resource
    it operates on, so the res parameter can be marked const.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 7c1c59ea9ec6..02e8464e480f 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1118,7 +1118,7 @@ __setup("acpi_enforce_resources=", acpi_enforce_resources_setup);
 
 /* Check for resource conflicts between ACPI OperationRegions and native
  * drivers */
-int acpi_check_resource_conflict(struct resource *res)
+int acpi_check_resource_conflict(const struct resource *res)
 {
 	struct acpi_res_list *res_list_elem;
 	int ioport;

commit 14f03343ad1080c2fea29ab2c13f05b976c4584e
Author: Jean Delvare <jdelvare@suse.de>
Date:   Tue Sep 8 15:31:46 2009 +0200

    ACPI: Clarify resource conflict message
    
    The message "ACPI: Device needs an ACPI driver" is misleading. The
    device _may_ need an ACPI driver, if the BIOS implemented a custom
    API for the device in question (which, AFAIK, can't be checked.) If
    not, then either a generic ACPI driver may be used (for example
    "thermal"), or nothing can be done (other than a white list).
    
    I propose to reword the message to:
    
    ACPI: If an ACPI driver is available for this device, you should use
    it instead of the native driver
    
    which I think is more correct. Comments and suggestions welcome.
    
    I also added a message warning about possible problems and system
    instability when users pass acpi_enforce_resources=lax, as suggested
    by Len.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Cc: Thomas Renninger <trenn@suse.de>
    Cc: Alan Jenkins <sourcejedi.lkml@googlemail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 5633b86e3ed1..7c1c59ea9ec6 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1161,7 +1161,13 @@ int acpi_check_resource_conflict(struct resource *res)
 			       res_list_elem->name,
 			       (long long) res_list_elem->start,
 			       (long long) res_list_elem->end);
-			printk(KERN_INFO "ACPI: Device needs an ACPI driver\n");
+			if (acpi_enforce_resources == ENFORCE_RESOURCES_LAX)
+				printk(KERN_NOTICE "ACPI: This conflict may"
+				       " cause random problems and system"
+				       " instability\n");
+			printk(KERN_INFO "ACPI: If an ACPI driver is available"
+			       " for this device, you should use it instead of"
+			       " the native driver\n");
 		}
 		if (acpi_enforce_resources == ENFORCE_RESOURCES_STRICT)
 			return -EBUSY;

commit e68110fb54c3c784fb66be67d8d18a86286eefdd
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Sep 24 09:34:38 2009 -0600

    ACPI: remove cpumask_t usage
    
    set_cpus_allowed() is on the way out; replace it with
    set_cpus_allowed_ptr().
    
    Reference: http://lkml.org/lkml/2008/11/6/448
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 56071b67bed5..5633b86e3ed1 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -193,7 +193,7 @@ acpi_status __init acpi_os_initialize(void)
 
 static void bind_to_cpu0(struct work_struct *work)
 {
-	set_cpus_allowed(current, cpumask_of_cpu(0));
+	set_cpus_allowed_ptr(current, cpumask_of(0));
 	kfree(work);
 }
 

commit 59fc9e5e21baf2bf5c87d8006e006007c3a708c2
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Aug 31 22:32:15 2009 +0000

    ACPI: remove null pointer checks in deferred execution path
    
    Better to oops and learn about a bug than to silently cover it up.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index d753206f0734..56071b67bed5 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -699,18 +699,12 @@ void acpi_os_derive_pci_id(acpi_handle rhandle,	/* upper bound  */
 static void acpi_os_execute_deferred(struct work_struct *work)
 {
 	struct acpi_os_dpc *dpc = container_of(work, struct acpi_os_dpc, work);
-	if (!dpc) {
-		printk(KERN_ERR PREFIX "Invalid (NULL) context\n");
-		return;
-	}
 
 	if (dpc->wait)
 		acpi_os_wait_events_complete(NULL);
 
 	dpc->function(dpc->context);
 	kfree(dpc);
-
-	return;
 }
 
 /*******************************************************************************
@@ -739,9 +733,6 @@ static acpi_status __acpi_os_execute(acpi_execute_type type,
 			  "Scheduling function [%p(%p)] for deferred execution.\n",
 			  function, context));
 
-	if (!function)
-		return AE_BAD_PARAMETER;
-
 	/*
 	 * Allocate/initialize DPC structure.  Note that this memory will be
 	 * freed by the callee.  The kernel handles the work_struct list  in a

commit 9ac6185669d0d277c4082fa92ba8eb2e55534cbf
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Aug 31 22:32:10 2009 +0000

    ACPI: simplify deferred execution path
    
    We had two functions, acpi_os_execute_deferred() and
    acpi_os_execute_hp_deferred() that differed only in that the
    latter did acpi_os_wait_events_complete(NULL) before executing
    the deferred function.
    
    This patch consolidates those two functions and uses a flag in
    the struct acpi_os_dpc to determine whether to do the wait.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index c5b4f1ed9b71..d753206f0734 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -58,6 +58,7 @@ struct acpi_os_dpc {
 	acpi_osd_exec_callback function;
 	void *context;
 	struct work_struct work;
+	int wait;
 };
 
 #ifdef CONFIG_ACPI_CUSTOM_DSDT
@@ -703,21 +704,8 @@ static void acpi_os_execute_deferred(struct work_struct *work)
 		return;
 	}
 
-	dpc->function(dpc->context);
-	kfree(dpc);
-
-	return;
-}
-
-static void acpi_os_execute_hp_deferred(struct work_struct *work)
-{
-	struct acpi_os_dpc *dpc = container_of(work, struct acpi_os_dpc, work);
-	if (!dpc) {
-		printk(KERN_ERR PREFIX "Invalid (NULL) context\n");
-		return;
-	}
-
-	acpi_os_wait_events_complete(NULL);
+	if (dpc->wait)
+		acpi_os_wait_events_complete(NULL);
 
 	dpc->function(dpc->context);
 	kfree(dpc);
@@ -746,7 +734,6 @@ static acpi_status __acpi_os_execute(acpi_execute_type type,
 	acpi_status status = AE_OK;
 	struct acpi_os_dpc *dpc;
 	struct workqueue_struct *queue;
-	work_func_t func;
 	int ret;
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
 			  "Scheduling function [%p(%p)] for deferred execution.\n",
@@ -779,8 +766,8 @@ static acpi_status __acpi_os_execute(acpi_execute_type type,
 	 */
 	queue = hp ? kacpi_hotplug_wq :
 		(type == OSL_NOTIFY_HANDLER ? kacpi_notify_wq : kacpid_wq);
-	func = hp ? acpi_os_execute_hp_deferred : acpi_os_execute_deferred;
-	INIT_WORK(&dpc->work, func);
+	dpc->wait = hp ? 1 : 0;
+	INIT_WORK(&dpc->work, acpi_os_execute_deferred);
 	ret = queue_work(queue, &dpc->work);
 
 	if (!ret) {

commit a5fe1a03f7720b8da8364a1737e1e5a357904e99
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Thu Aug 13 10:43:27 2009 +0800

    ACPICA: fix leak of acpi_os_validate_address
    
    http://bugzilla.kernel.org/show_bug.cgi?id=13620
    
    If the dynamic region is created and added to resource list over and over again,
    it has the potential to be a memory leak by growing the list every time.
    
    This patch fixes the memory leak, as below
    
    1) add a new field "count" to struct acpi_res_list.
    
       When inserting, if the region(addr, len) is already in the resource
       list, we just increase "count", otherwise, the region is inserted
       with count=1.
    
       When deleting, the "count" is decreased, if it's decreased to 0,
       the region is deleted from the resource list.
    
       With "count", the region with same address and length can only be
       inserted to the resource list once, so prevent potential memory leak.
    
    2) add a new function acpi_os_invalidate_address, which is called when
       region is deleted.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 5691f165a952..c5b4f1ed9b71 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -88,6 +88,7 @@ struct acpi_res_list {
 	char name[5];   /* only can have a length of 4 chars, make use of this
 			   one instead of res->name, no need to kalloc then */
 	struct list_head resource_list;
+	int count;
 };
 
 static LIST_HEAD(resource_list_head);
@@ -1358,6 +1359,89 @@ acpi_os_validate_interface (char *interface)
 	return AE_SUPPORT;
 }
 
+static inline int acpi_res_list_add(struct acpi_res_list *res)
+{
+	struct acpi_res_list *res_list_elem;
+
+	list_for_each_entry(res_list_elem, &resource_list_head,
+			    resource_list) {
+
+		if (res->resource_type == res_list_elem->resource_type &&
+		    res->start == res_list_elem->start &&
+		    res->end == res_list_elem->end) {
+
+			/*
+			 * The Region(addr,len) already exist in the list,
+			 * just increase the count
+			 */
+
+			res_list_elem->count++;
+			return 0;
+		}
+	}
+
+	res->count = 1;
+	list_add(&res->resource_list, &resource_list_head);
+	return 1;
+}
+
+static inline void acpi_res_list_del(struct acpi_res_list *res)
+{
+	struct acpi_res_list *res_list_elem;
+
+	list_for_each_entry(res_list_elem, &resource_list_head,
+			    resource_list) {
+
+		if (res->resource_type == res_list_elem->resource_type &&
+		    res->start == res_list_elem->start &&
+		    res->end == res_list_elem->end) {
+
+			/*
+			 * If the res count is decreased to 0,
+			 * remove and free it
+			 */
+
+			if (--res_list_elem->count == 0) {
+				list_del(&res_list_elem->resource_list);
+				kfree(res_list_elem);
+			}
+			return;
+		}
+	}
+}
+
+acpi_status
+acpi_os_invalidate_address(
+    u8                   space_id,
+    acpi_physical_address   address,
+    acpi_size               length)
+{
+	struct acpi_res_list res;
+
+	switch (space_id) {
+	case ACPI_ADR_SPACE_SYSTEM_IO:
+	case ACPI_ADR_SPACE_SYSTEM_MEMORY:
+		/* Only interference checks against SystemIO and SytemMemory
+		   are needed */
+		res.start = address;
+		res.end = address + length - 1;
+		res.resource_type = space_id;
+		spin_lock(&acpi_res_lock);
+		acpi_res_list_del(&res);
+		spin_unlock(&acpi_res_lock);
+		break;
+	case ACPI_ADR_SPACE_PCI_CONFIG:
+	case ACPI_ADR_SPACE_EC:
+	case ACPI_ADR_SPACE_SMBUS:
+	case ACPI_ADR_SPACE_CMOS:
+	case ACPI_ADR_SPACE_PCI_BAR_TARGET:
+	case ACPI_ADR_SPACE_DATA_TABLE:
+	case ACPI_ADR_SPACE_FIXED_HARDWARE:
+		break;
+	}
+	return AE_OK;
+}
+
 /******************************************************************************
  *
  * FUNCTION:    acpi_os_validate_address
@@ -1382,6 +1466,7 @@ acpi_os_validate_address (
     char *name)
 {
 	struct acpi_res_list *res;
+	int added;
 	if (acpi_enforce_resources == ENFORCE_RESOURCES_NO)
 		return AE_OK;
 
@@ -1399,14 +1484,17 @@ acpi_os_validate_address (
 		res->end = address + length - 1;
 		res->resource_type = space_id;
 		spin_lock(&acpi_res_lock);
-		list_add(&res->resource_list, &resource_list_head);
+		added = acpi_res_list_add(res);
 		spin_unlock(&acpi_res_lock);
-		pr_debug("Added %s resource: start: 0x%llx, end: 0x%llx, "
-			 "name: %s\n", (space_id == ACPI_ADR_SPACE_SYSTEM_IO)
+		pr_debug("%s %s resource: start: 0x%llx, end: 0x%llx, "
+			 "name: %s\n", added ? "Added" : "Already exist",
+			 (space_id == ACPI_ADR_SPACE_SYSTEM_IO)
 			 ? "SystemIO" : "System Memory",
 			 (unsigned long long)res->start,
 			 (unsigned long long)res->end,
 			 res->name);
+		if (!added)
+			kfree(res);
 		break;
 	case ACPI_ADR_SPACE_PCI_CONFIG:
 	case ACPI_ADR_SPACE_EC:

commit 74b5820808215f65b70b05a099d6d3c969b82689
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Jul 29 15:54:25 2009 -0600

    ACPI: bind workqueues to CPU 0 to avoid SMI corruption
    
    On some machines, a software-initiated SMI causes corruption unless the
    SMI runs on CPU 0.  An SMI can be initiated by any AML, but typically it's
    done in GPE-related methods that are run via workqueues, so we can avoid
    the known corruption cases by binding the workqueues to CPU 0.
    
    References:
        http://bugzilla.kernel.org/show_bug.cgi?id=13751
        https://bugs.launchpad.net/bugs/157171
        https://bugs.launchpad.net/bugs/157691
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 71670719d61a..5691f165a952 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -189,11 +189,36 @@ acpi_status __init acpi_os_initialize(void)
 	return AE_OK;
 }
 
+static void bind_to_cpu0(struct work_struct *work)
+{
+	set_cpus_allowed(current, cpumask_of_cpu(0));
+	kfree(work);
+}
+
+static void bind_workqueue(struct workqueue_struct *wq)
+{
+	struct work_struct *work;
+
+	work = kzalloc(sizeof(struct work_struct), GFP_KERNEL);
+	INIT_WORK(work, bind_to_cpu0);
+	queue_work(wq, work);
+}
+
 acpi_status acpi_os_initialize1(void)
 {
+	/*
+	 * On some machines, a software-initiated SMI causes corruption unless
+	 * the SMI runs on CPU 0.  An SMI can be initiated by any AML, but
+	 * typically it's done in GPE-related methods that are run via
+	 * workqueues, so we can avoid the known corruption cases by binding
+	 * the workqueues to CPU 0.
+	 */
 	kacpid_wq = create_singlethread_workqueue("kacpid");
+	bind_workqueue(kacpid_wq);
 	kacpi_notify_wq = create_singlethread_workqueue("kacpi_notify");
+	bind_workqueue(kacpi_notify_wq);
 	kacpi_hotplug_wq = create_singlethread_workqueue("kacpi_hotplug");
+	bind_workqueue(kacpi_hotplug_wq);
 	BUG_ON(!kacpid_wq);
 	BUG_ON(!kacpi_notify_wq);
 	BUG_ON(!kacpi_hotplug_wq);

commit c02256be79a1a3557332ac51e653d574a2a7d2b5
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Jun 23 10:20:29 2009 +0800

    ACPI: fix a deadlock in hotplug case
    
    we used to run the hotplug code in keventd_wq.
    But when hot removing the ACPI battery device,
    power_supply_unregister invokes flush_scheduled_work.
    This causes a deadlock. i.e
    1. When dock is unplugged, all the hotplug code is run on kevent_wq.
    2. the hotplug code removes all the child devices of dock device.
    3. removing the child device may invoke flush_scheduled_work
    4. flush_scheduled_work waits until all the work on kevent_wq to be
       finished, while this will never be true because the hotplug code
       is running on keventd_wq...
    
    Introduce a new workqueue for hotplug in this patch.
    http://bugzilla.kernel.org/show_bug.cgi?id=13533
    
    Tested-by: Paul Martin <pm@debian.org>
    Tested-by: Vojtech Gondzala <vojtech.gondzala@gmail.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Reviewed-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index d916bea729f1..71670719d61a 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -79,6 +79,7 @@ static acpi_osd_handler acpi_irq_handler;
 static void *acpi_irq_context;
 static struct workqueue_struct *kacpid_wq;
 static struct workqueue_struct *kacpi_notify_wq;
+static struct workqueue_struct *kacpi_hotplug_wq;
 
 struct acpi_res_list {
 	resource_size_t start;
@@ -192,8 +193,10 @@ acpi_status acpi_os_initialize1(void)
 {
 	kacpid_wq = create_singlethread_workqueue("kacpid");
 	kacpi_notify_wq = create_singlethread_workqueue("kacpi_notify");
+	kacpi_hotplug_wq = create_singlethread_workqueue("kacpi_hotplug");
 	BUG_ON(!kacpid_wq);
 	BUG_ON(!kacpi_notify_wq);
+	BUG_ON(!kacpi_hotplug_wq);
 	return AE_OK;
 }
 
@@ -206,6 +209,7 @@ acpi_status acpi_os_terminate(void)
 
 	destroy_workqueue(kacpid_wq);
 	destroy_workqueue(kacpi_notify_wq);
+	destroy_workqueue(kacpi_hotplug_wq);
 
 	return AE_OK;
 }
@@ -716,6 +720,7 @@ static acpi_status __acpi_os_execute(acpi_execute_type type,
 	acpi_status status = AE_OK;
 	struct acpi_os_dpc *dpc;
 	struct workqueue_struct *queue;
+	work_func_t func;
 	int ret;
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
 			  "Scheduling function [%p(%p)] for deferred execution.\n",
@@ -740,15 +745,17 @@ static acpi_status __acpi_os_execute(acpi_execute_type type,
 	dpc->function = function;
 	dpc->context = context;
 
-	if (!hp) {
-		INIT_WORK(&dpc->work, acpi_os_execute_deferred);
-		queue = (type == OSL_NOTIFY_HANDLER) ?
-			kacpi_notify_wq : kacpid_wq;
-		ret = queue_work(queue, &dpc->work);
-	} else {
-		INIT_WORK(&dpc->work, acpi_os_execute_hp_deferred);
-		ret = schedule_work(&dpc->work);
-	}
+	/*
+	 * We can't run hotplug code in keventd_wq/kacpid_wq/kacpid_notify_wq
+	 * because the hotplug code may call driver .remove() functions,
+	 * which invoke flush_scheduled_work/acpi_os_wait_events_complete
+	 * to flush these workqueues.
+	 */
+	queue = hp ? kacpi_hotplug_wq :
+		(type == OSL_NOTIFY_HANDLER ? kacpi_notify_wq : kacpid_wq);
+	func = hp ? acpi_os_execute_hp_deferred : acpi_os_execute_deferred;
+	INIT_WORK(&dpc->work, func);
+	ret = queue_work(queue, &dpc->work);
 
 	if (!ret) {
 		printk(KERN_ERR PREFIX

commit 88bea188b85f9cefefbbd56b8a48d0f798409177
Author: Len Brown <len.brown@intel.com>
Date:   Tue Apr 21 00:35:47 2009 -0400

    ACPI: add /sys/firmware/acpi/interrupts/sci_not counter
    
    This counter may prove useful in debugging some
    spurious interrupt issues seen in the field.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index d59f08ecaf16..d916bea729f1 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -353,8 +353,10 @@ static irqreturn_t acpi_irq(int irq, void *dev_id)
 	if (handled) {
 		acpi_irq_handled++;
 		return IRQ_HANDLED;
-	} else
+	} else {
+		acpi_irq_not_handled++;
 		return IRQ_NONE;
+	}
 }
 
 acpi_status

commit 478c6a43fcbc6c11609f8cee7c7b57223907754f
Merge: 8a3f257c704e 6bb597507f98
Author: Len Brown <len.brown@intel.com>
Date:   Sun Apr 5 02:14:15 2009 -0400

    Merge branch 'linus' into release
    
    Conflicts:
            arch/x86/kernel/cpu/cpufreq/longhaul.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 7e90560c50f754d65884e251e94c1efa2a4b5784
Author: Luca Tettamanti <kronos.it@gmail.com>
Date:   Mon Mar 30 00:01:27 2009 +0200

    ACPI: acpi_enforce_resource=strict by default
    
    Enforce strict resource checking - disallowing access by native
    drivers to IO ports and memory regions claimed by ACPI firmware.
    
    The patch is mainly aimed to block native hwmon drivers from touching
    monitoring chips that ACPI thinks it own.
    
    If this causes a regression, boot with "acpi_enforce_resources=lax"
    which was the previous default.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=12376
    http://bugzilla.kernel.org/show_bug.cgi?id=12541
    
    Signed-off-by: Luca Tettamanti <kronos.it@gmail.com>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 1e35f342957c..f50ca1ea80c3 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1063,9 +1063,9 @@ __setup("acpi_wake_gpes_always_on", acpi_wake_gpes_always_on_setup);
  * in arbitrary AML code and can interfere with legacy drivers.
  * acpi_enforce_resources= can be set to:
  *
- *   - strict           (2)
+ *   - strict (default) (2)
  *     -> further driver trying to access the resources will not load
- *   - lax (default)    (1)
+ *   - lax              (1)
  *     -> further driver trying to access the resources will load, but you
  *     get a system message that something might go wrong...
  *
@@ -1077,7 +1077,7 @@ __setup("acpi_wake_gpes_always_on", acpi_wake_gpes_always_on_setup);
 #define ENFORCE_RESOURCES_LAX    1
 #define ENFORCE_RESOURCES_NO     0
 
-static unsigned int acpi_enforce_resources = ENFORCE_RESOURCES_LAX;
+static unsigned int acpi_enforce_resources = ENFORCE_RESOURCES_STRICT;
 
 static int __init acpi_enforce_resources_setup(char *str)
 {

commit 6e15cf04860074ad032e88c306bea656bbdd0f22
Merge: be0ea69674ed 60db56422043
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Mar 26 21:39:17 2009 +0100

    Merge branch 'core/percpu' into percpu-cpumask-x86-for-linus-2
    
    Conflicts:
            arch/parisc/kernel/irq.c
            arch/x86/include/asm/fixmap_64.h
            arch/x86/include/asm/setup.h
            kernel/irq/handle.c
    
    Semantic merge:
            arch/x86/include/asm/fixmap.h
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 7b46ecd5fcebf381a7bde966db352d8fb1b8e944
Author: Len Brown <len.brown@intel.com>
Date:   Wed Feb 25 18:00:18 2009 -0500

    Revert "ACPI: make some IO ports off-limits to AML"
    
    This reverts commit 5ec5d38a1c8af255ffc481c81eef13e9155524b3.
    because it caused spurious dmesg warmings.
    We'll implement the check for off-limit ports
    in a more clever way in the future.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=12758
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index b3193ec0a2ef..1e35f342957c 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1317,54 +1317,6 @@ acpi_os_validate_interface (char *interface)
 	return AE_SUPPORT;
 }
 
-#ifdef	CONFIG_X86
-
-struct aml_port_desc {
-	uint	start;
-	uint	end;
-	char*   name;
-	char	warned;
-};
-
-static struct aml_port_desc aml_invalid_port_list[] = {
-	{0x20, 0x21, "PIC0", 0},
-	{0xA0, 0xA1, "PIC1", 0},
-	{0x4D0, 0x4D1, "ELCR", 0}
-};
-
-/*
- * valid_aml_io_address()
- *
- * if valid, return true
- * else invalid, warn once, return false
- */
-static bool valid_aml_io_address(uint address, uint length)
-{
-	int i;
-	int entries = sizeof(aml_invalid_port_list) / sizeof(struct aml_port_desc);
-
-	for (i = 0; i < entries; ++i) {
-		if ((address >= aml_invalid_port_list[i].start &&
-			address <= aml_invalid_port_list[i].end) ||
-			(address + length >= aml_invalid_port_list[i].start &&
-			address  + length <= aml_invalid_port_list[i].end))
-		{
-			if (!aml_invalid_port_list[i].warned)
-			{
-				printk(KERN_ERR "ACPI: Denied BIOS AML access"
-					" to invalid port 0x%x+0x%x (%s)\n",
-					address, length,
-					aml_invalid_port_list[i].name);
-				aml_invalid_port_list[i].warned = 1;
-			}
-			return false;	/* invalid */
-		}
-	}
-	return true;	/* valid */
-}
-#else
-static inline bool valid_aml_io_address(uint address, uint length) { return true; }
-#endif
 /******************************************************************************
  *
  * FUNCTION:    acpi_os_validate_address
@@ -1394,8 +1346,6 @@ acpi_os_validate_address (
 
 	switch (space_id) {
 	case ACPI_ADR_SPACE_SYSTEM_IO:
-		if (!valid_aml_io_address(address, length))
-			return AE_AML_ILLEGAL_ADDRESS;
 	case ACPI_ADR_SPACE_SYSTEM_MEMORY:
 		/* Only interference checks against SystemIO and SytemMemory
 		   are needed */

commit 0d3a9cf5ab041c15691fd03dab3af0841af63606
Author: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
Date:   Sun Feb 22 14:58:56 2009 -0800

    acpi: add some missing section markers
    
    early_acpi_os_unmap_memory() is an __init function, and
    acpi_os_unmap_memory() is allowed to access an __init function
    until acpi_gbl_permanent_mmap is set up.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Cc: Len Brown <len.brown@intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index d1dd5160daa9..2b6c59028254 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -272,7 +272,7 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 }
 EXPORT_SYMBOL_GPL(acpi_os_map_memory);
 
-void acpi_os_unmap_memory(void __iomem * virt, acpi_size size)
+void __ref acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 {
 	if (acpi_gbl_permanent_mmap)
 		iounmap(virt);
@@ -281,7 +281,7 @@ void acpi_os_unmap_memory(void __iomem * virt, acpi_size size)
 }
 EXPORT_SYMBOL_GPL(acpi_os_unmap_memory);
 
-void early_acpi_os_unmap_memory(void __iomem * virt, acpi_size size)
+void __init early_acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
 {
 	if (!acpi_gbl_permanent_mmap)
 		__acpi_unmap_table(virt, size);

commit 7d97277b754d3ee098a5ec69b6aaafb00c94e2f2
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Sat Feb 7 15:39:41 2009 -0800

    acpi/x86: introduce __apci_map_table, v4
    
    to prevent wrongly overwriting fixmap that still want to use.
    
    ACPI used to rely on low mappings being all linearly mapped and
    grew a habit: it never really unmapped certain kinds of tables
    after use.
    
    This can cause problems - for example the hypothetical case
    when some spurious access still references it.
    
    v2: remove prev_map and prev_size in __apci_map_table
    v3: let acpi_os_unmap_memory() call early_iounmap too, so remove extral calling to
    early_acpi_os_unmap_memory
    v4: fix typo in one acpi_get_table_with_size calling
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Acked-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index b3193ec0a2ef..d1dd5160daa9 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -274,12 +274,19 @@ EXPORT_SYMBOL_GPL(acpi_os_map_memory);
 
 void acpi_os_unmap_memory(void __iomem * virt, acpi_size size)
 {
-	if (acpi_gbl_permanent_mmap) {
+	if (acpi_gbl_permanent_mmap)
 		iounmap(virt);
-	}
+	else
+		__acpi_unmap_table(virt, size);
 }
 EXPORT_SYMBOL_GPL(acpi_os_unmap_memory);
 
+void early_acpi_os_unmap_memory(void __iomem * virt, acpi_size size)
+{
+	if (!acpi_gbl_permanent_mmap)
+		__acpi_unmap_table(virt, size);
+}
+
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_os_get_physical_address(void *virt, acpi_physical_address * phys)

commit 2d29c6a075787f2c1bc49b86a084d2b878f72fc4
Merge: 2b25c9f01aa5 0a3db1cec5d4 9fdd54f20672 5ec5d38a1c8a 4312495f7db6 370154bbefb6 4d9391557b68 62663ea82203
Author: Len Brown <len.brown@intel.com>
Date:   Sat Feb 7 01:34:56 2009 -0500

    Merge branches 'release', 'asus', 'bugzilla-12450', 'cpuidle', 'debug', 'ec', 'misc', 'printk' and 'processor' into release

commit 4d9391557b68475b118ec7626607c37b14ae8c16
Author: Frank Seidel <frank@f-seidel.de>
Date:   Wed Feb 4 17:03:07 2009 +0100

    ACPI: add missing KERN_* constants to printks
    
    According to kerneljanitors todo list all printk calls (beginning
    a new line) should have an according KERN_* constant.
    Those are the missing peaces here for the acpi subsystem.
    
    Signed-off-by: Frank Seidel <frank@f-seidel.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 6729a4992f2b..1e35f342957c 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -228,10 +228,10 @@ void acpi_os_vprintf(const char *fmt, va_list args)
 	if (acpi_in_debugger) {
 		kdb_printf("%s", buffer);
 	} else {
-		printk("%s", buffer);
+		printk(KERN_CONT "%s", buffer);
 	}
 #else
-	printk("%s", buffer);
+	printk(KERN_CONT "%s", buffer);
 #endif
 }
 

commit 5ec5d38a1c8af255ffc481c81eef13e9155524b3
Author: Len Brown <len.brown@intel.com>
Date:   Tue Feb 3 22:52:12 2009 -0500

    ACPI: make some IO ports off-limits to AML
    
    ACPICA exports acpi_os_validate_address() so the OS
    can prevent BIOS AML from accessing specified addresses.
    
    Start using this interface to prevent AML from accessing
    some well known IO addresses that the OS "owns".
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 6729a4992f2b..4fb01b0133c7 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1317,6 +1317,54 @@ acpi_os_validate_interface (char *interface)
 	return AE_SUPPORT;
 }
 
+#ifdef	CONFIG_X86
+
+struct aml_port_desc {
+	uint	start;
+	uint	end;
+	char*   name;
+	char	warned;
+};
+
+static struct aml_port_desc aml_invalid_port_list[] = {
+	{0x20, 0x21, "PIC0", 0},
+	{0xA0, 0xA1, "PIC1", 0},
+	{0x4D0, 0x4D1, "ELCR", 0}
+};
+
+/*
+ * valid_aml_io_address()
+ *
+ * if valid, return true
+ * else invalid, warn once, return false
+ */
+static bool valid_aml_io_address(uint address, uint length)
+{
+	int i;
+	int entries = sizeof(aml_invalid_port_list) / sizeof(struct aml_port_desc);
+
+	for (i = 0; i < entries; ++i) {
+		if ((address >= aml_invalid_port_list[i].start &&
+			address <= aml_invalid_port_list[i].end) ||
+			(address + length >= aml_invalid_port_list[i].start &&
+			address  + length <= aml_invalid_port_list[i].end))
+		{
+			if (!aml_invalid_port_list[i].warned)
+			{
+				printk(KERN_ERR "ACPI: Denied BIOS AML access"
+					" to invalid port 0x%x+0x%x (%s)\n",
+					address, length,
+					aml_invalid_port_list[i].name);
+				aml_invalid_port_list[i].warned = 1;
+			}
+			return false;	/* invalid */
+		}
+	}
+	return true;	/* valid */
+}
+#else
+static inline bool valid_aml_io_address(uint address, uint length) { return true; }
+#endif
 /******************************************************************************
  *
  * FUNCTION:    acpi_os_validate_address
@@ -1346,6 +1394,8 @@ acpi_os_validate_address (
 
 	switch (space_id) {
 	case ACPI_ADR_SPACE_SYSTEM_IO:
+		if (!valid_aml_io_address(address, length))
+			return AE_AML_ILLEGAL_ADDRESS;
 	case ACPI_ADR_SPACE_SYSTEM_MEMORY:
 		/* Only interference checks against SystemIO and SytemMemory
 		   are needed */

commit 889c78be9e8d84ea7f991b9b868e006cdb8e42b0
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Wed Dec 31 09:23:57 2008 +0800

    ACPI: osl.c: replace return_ACPI_STATUS with return
    
    return_ACPI_STATUS is an internal acpica function, replace it with return.
    acpi_gbl_permanent_mmap moved from acglobal.h to acpixf.h for external use
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index c8111424dcb8..6729a4992f2b 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -726,7 +726,7 @@ static acpi_status __acpi_os_execute(acpi_execute_type type,
 
 	dpc = kmalloc(sizeof(struct acpi_os_dpc), GFP_ATOMIC);
 	if (!dpc)
-		return_ACPI_STATUS(AE_NO_MEMORY);
+		return AE_NO_MEMORY;
 
 	dpc->function = function;
 	dpc->context = context;
@@ -747,7 +747,7 @@ static acpi_status __acpi_os_execute(acpi_execute_type type,
 		status = AE_ERROR;
 		kfree(dpc);
 	}
-	return_ACPI_STATUS(status);
+	return status;
 }
 
 acpi_status acpi_os_execute(acpi_execute_type type,

commit a6e0887f21bbab337ee32d9c0a84d7c0b6e9141b
Author: Len Brown <len.brown@intel.com>
Date:   Sat Nov 8 01:21:10 2008 -0500

    ACPI: delete OSI(Linux) DMI dmesg spam
    
    Linux will continue to ignore OSI(Linux),
    except for a white-list containing a few systems.
    
    So delete the black-list,
    and stop soliciting user-feedback on the console.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 4be252145cb4..c8111424dcb8 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -35,7 +35,6 @@
 #include <linux/interrupt.h>
 #include <linux/kmod.h>
 #include <linux/delay.h>
-#include <linux/dmi.h>
 #include <linux/workqueue.h>
 #include <linux/nmi.h>
 #include <linux/acpi.h>
@@ -97,54 +96,44 @@ static DEFINE_SPINLOCK(acpi_res_lock);
 static char osi_additional_string[OSI_STRING_LENGTH_MAX];
 
 /*
- * "Ode to _OSI(Linux)"
+ * The story of _OSI(Linux)
  *
- * osi_linux -- Control response to BIOS _OSI(Linux) query.
+ * From pre-history through Linux-2.6.22,
+ * Linux responded TRUE upon a BIOS OSI(Linux) query.
  *
- * As Linux evolves, the features that it supports change.
- * So an OSI string such as "Linux" is not specific enough
- * to be useful across multiple versions of Linux.  It
- * doesn't identify any particular feature, interface,
- * or even any particular version of Linux...
+ * Unfortunately, reference BIOS writers got wind of this
+ * and put OSI(Linux) in their example code, quickly exposing
+ * this string as ill-conceived and opening the door to
+ * an un-bounded number of BIOS incompatibilities.
  *
- * Unfortunately, Linux-2.6.22 and earlier responded "yes"
- * to a BIOS _OSI(Linux) query.  When
- * a reference mobile BIOS started using it, its use
- * started to spread to many vendor platforms.
- * As it is not supportable, we need to halt that spread.
+ * For example, OSI(Linux) was used on resume to re-POST a
+ * video card on one system, because Linux at that time
+ * could not do a speedy restore in its native driver.
+ * But then upon gaining quick native restore capability,
+ * Linux has no way to tell the BIOS to skip the time-consuming
+ * POST -- putting Linux at a permanent performance disadvantage.
+ * On another system, the BIOS writer used OSI(Linux)
+ * to infer native OS support for IPMI!  On other systems,
+ * OSI(Linux) simply got in the way of Linux claiming to
+ * be compatible with other operating systems, exposing
+ * BIOS issues such as skipped device initialization.
  *
- * Today, most BIOS references to _OSI(Linux) are noise --
- * they have no functional effect and are just dead code
- * carried over from the reference BIOS.
- *
- * The next most common case is that _OSI(Linux) harms Linux,
- * usually by causing the BIOS to follow paths that are
- * not tested during Windows validation.
- *
- * Finally, there is a short list of platforms
- * where OSI(Linux) benefits Linux.
- *
- * In Linux-2.6.23, OSI(Linux) is first disabled by default.
- * DMI is used to disable the dmesg warning about OSI(Linux)
- * on platforms where it is known to have no effect.
- * But a dmesg warning remains for systems where
- * we do not know if OSI(Linux) is good or bad for the system.
- * DMI is also used to enable OSI(Linux) for the machines
- * that are known to need it.
+ * So "Linux" turned out to be a really poor chose of
+ * OSI string, and from Linux-2.6.23 onward we respond FALSE.
  *
  * BIOS writers should NOT query _OSI(Linux) on future systems.
- * It will be ignored by default, and to get Linux to
- * not ignore it will require a kernel source update to
- * add a DMI entry, or a boot-time "acpi_osi=Linux" invocation.
+ * Linux will complain on the console when it sees it, and return FALSE.
+ * To get Linux to return TRUE for your system  will require
+ * a kernel source update to add a DMI entry,
+ * or boot with "acpi_osi=Linux"
  */
-#define OSI_LINUX_ENABLE 0
 
 static struct osi_linux {
 	unsigned int	enable:1;
 	unsigned int	dmi:1;
 	unsigned int	cmdline:1;
 	unsigned int	known:1;
-} osi_linux = { OSI_LINUX_ENABLE, 0, 0, 0};
+} osi_linux = { 0, 0, 0, 0};
 
 static void __init acpi_request_region (struct acpi_generic_address *addr,
 	unsigned int length, char *desc)
@@ -1296,34 +1285,6 @@ acpi_status acpi_os_release_object(acpi_cache_t * cache, void *object)
 	return (AE_OK);
 }
 
-/**
- *	acpi_dmi_dump - dump DMI slots needed for blacklist entry
- *
- *	Returns 0 on success
- */
-static int acpi_dmi_dump(void)
-{
-
-	if (!dmi_available)
-		return -1;
-
-	printk(KERN_NOTICE PREFIX "DMI System Vendor: %s\n",
-		dmi_get_system_info(DMI_SYS_VENDOR));
-	printk(KERN_NOTICE PREFIX "DMI Product Name: %s\n",
-		dmi_get_system_info(DMI_PRODUCT_NAME));
-	printk(KERN_NOTICE PREFIX "DMI Product Version: %s\n",
-		dmi_get_system_info(DMI_PRODUCT_VERSION));
-	printk(KERN_NOTICE PREFIX "DMI Board Name: %s\n",
-		dmi_get_system_info(DMI_BOARD_NAME));
-	printk(KERN_NOTICE PREFIX "DMI BIOS Vendor: %s\n",
-		dmi_get_system_info(DMI_BIOS_VENDOR));
-	printk(KERN_NOTICE PREFIX "DMI BIOS Date: %s\n",
-		dmi_get_system_info(DMI_BIOS_DATE));
-
-	return 0;
-}
-
-
 /******************************************************************************
  *
  * FUNCTION:    acpi_os_validate_interface
@@ -1350,21 +1311,6 @@ acpi_os_validate_interface (char *interface)
 			osi_linux.cmdline ? " via cmdline" :
 			osi_linux.dmi ? " via DMI" : "");
 
-		if (!osi_linux.dmi) {
-			if (acpi_dmi_dump())
-				printk(KERN_NOTICE PREFIX
-					"[please extract dmidecode output]\n");
-			printk(KERN_NOTICE PREFIX
-				"Please send DMI info above to "
-				"linux-acpi@vger.kernel.org\n");
-		}
-		if (!osi_linux.known && !osi_linux.cmdline) {
-			printk(KERN_NOTICE PREFIX
-				"If \"acpi_osi=%sLinux\" works better, "
-				"please notify linux-acpi@vger.kernel.org\n",
-				osi_linux.enable ? "!" : "");
-		}
-
 		if (osi_linux.enable)
 			return AE_OK;
 	}

commit 7674416db4ee3d43813dddb650364ca994755256
Merge: 0ca9413c234a 27663c5855b1
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:33:29 2008 -0400

    Merge branch 'ull' into test
    
    Conflicts:
            drivers/acpi/bay.c
            drivers/acpi/dock.c
            drivers/ata/libata-acpi.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 47bf31adc541bef0c20de15e800e0011f1ae70c7
Merge: 4538fad56ee1 0a918a9432cc
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:25:26 2008 -0400

    Merge branch 'dock' into test
    
    Conflicts:
            drivers/acpi/osl.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 55ac9a018f83e4f42f3c6ce98a8dbda73b985935
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Sun Sep 28 14:51:56 2008 +0800

    ACPI: replace ACPI_DEBUG_PRINT((ACPI_DB_ERROR, ...) with printk
    
    ACPI_DB_ERROR and ACPI_DB_WARN were removed from ACPICA core.
    So replace ACPI_DEBUG_PRINT((ACPI_DB_ERROR, ...) with printk(KERN_ERR PREFIX ...)
    and ACPI_DEBUG_PRINT((ACPI_DB_WARN, ...) with printk(KERN_WARNING PREFIX ...)
    
    We do not use ACPI_ERROR/ACPI_WARNING since they're not exported, see
    -------------------------------------------------------------
    commit 6468463abd7051fcc29f3ee7c931f9bbbb26f5a4
    Author: Len Brown <len.brown@intel.com>
    Date:   Mon Jun 26 23:41:38 2006 -0400
    
        ACPI: un-export ACPI_ERROR() -- use printk(KERN_ERR...)
    
        Signed-off-by: Len Brown <len.brown@intel.com>
    -------------------------------------------------------------
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 235a1386888a..1420a9f69e5d 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -729,8 +729,8 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 	INIT_WORK(&dpc->work, acpi_os_execute_deferred);
 	queue = (type == OSL_NOTIFY_HANDLER) ? kacpi_notify_wq : kacpid_wq;
 	if (!queue_work(queue, &dpc->work)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			  "Call to queue_work() failed.\n"));
+		printk(KERN_ERR PREFIX
+			  "Call to queue_work() failed.\n");
 		status = AE_ERROR;
 		kfree(dpc);
 	}

commit 27663c5855b10af9ec67bc7dfba001426ba21222
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Fri Oct 10 02:22:59 2008 -0400

    ACPI: Change acpi_evaluate_integer to support 64-bit on 32-bit kernels
    
    As of version 2.0, ACPI can return 64-bit integers.  The current
    acpi_evaluate_integer only supports 64-bit integers on 64-bit platforms.
    Change the argument to take a pointer to an acpi_integer so we support
    64-bit integers on all platforms.
    
    lenb: replaced use of "acpi_integer" with "unsigned long long"
    lenb: fixed bug in acpi_thermal_trips_update()
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 235a1386888a..f58fcbbc810d 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -608,7 +608,7 @@ static void acpi_os_derive_pci_id_2(acpi_handle rhandle,	/* upper bound  */
 	acpi_handle handle;
 	struct acpi_pci_id *pci_id = *id;
 	acpi_status status;
-	unsigned long temp;
+	unsigned long long temp;
 	acpi_object_type type;
 
 	acpi_get_parent(chandle, &handle);
@@ -620,8 +620,7 @@ static void acpi_os_derive_pci_id_2(acpi_handle rhandle,	/* upper bound  */
 		if ((ACPI_FAILURE(status)) || (type != ACPI_TYPE_DEVICE))
 			return;
 
-		status =
-		    acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL,
+		status = acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL,
 					  &temp);
 		if (ACPI_SUCCESS(status)) {
 			u32 val;

commit 19cd847ab24fefe9e50101ec94479e0400a08650
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Aug 28 10:05:06 2008 +0800

    ACPI: fix hotplug race
    
    The hotplug notification handler and drivers' notification handler all
    run in one workqueue.  Before hotplug removes an acpi device, the
    device driver's notification handler is already be recorded to run just
    after global notification handler.  After hotplug notification handler
    runs, acpica will notice a NULL notification handler and crash.
    
    So now we run run hotplug in another workqueue and wait
    for all acpi notication handlers finish.
    This was found in battery hotplug, but actually all
    hotplug can be affected.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 235a1386888a..750e0df15604 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -682,6 +682,22 @@ static void acpi_os_execute_deferred(struct work_struct *work)
 	return;
 }
 
+static void acpi_os_execute_hp_deferred(struct work_struct *work)
+{
+	struct acpi_os_dpc *dpc = container_of(work, struct acpi_os_dpc, work);
+	if (!dpc) {
+		printk(KERN_ERR PREFIX "Invalid (NULL) context\n");
+		return;
+	}
+
+	acpi_os_wait_events_complete(NULL);
+
+	dpc->function(dpc->context);
+	kfree(dpc);
+
+	return;
+}
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_os_execute
@@ -697,12 +713,13 @@ static void acpi_os_execute_deferred(struct work_struct *work)
  *
  ******************************************************************************/
 
-acpi_status acpi_os_execute(acpi_execute_type type,
-			    acpi_osd_exec_callback function, void *context)
+static acpi_status __acpi_os_execute(acpi_execute_type type,
+	acpi_osd_exec_callback function, void *context, int hp)
 {
 	acpi_status status = AE_OK;
 	struct acpi_os_dpc *dpc;
 	struct workqueue_struct *queue;
+	int ret;
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
 			  "Scheduling function [%p(%p)] for deferred execution.\n",
 			  function, context));
@@ -726,9 +743,17 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 	dpc->function = function;
 	dpc->context = context;
 
-	INIT_WORK(&dpc->work, acpi_os_execute_deferred);
-	queue = (type == OSL_NOTIFY_HANDLER) ? kacpi_notify_wq : kacpid_wq;
-	if (!queue_work(queue, &dpc->work)) {
+	if (!hp) {
+		INIT_WORK(&dpc->work, acpi_os_execute_deferred);
+		queue = (type == OSL_NOTIFY_HANDLER) ?
+			kacpi_notify_wq : kacpid_wq;
+		ret = queue_work(queue, &dpc->work);
+	} else {
+		INIT_WORK(&dpc->work, acpi_os_execute_hp_deferred);
+		ret = schedule_work(&dpc->work);
+	}
+
+	if (!ret) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
 			  "Call to queue_work() failed.\n"));
 		status = AE_ERROR;
@@ -737,8 +762,19 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 	return_ACPI_STATUS(status);
 }
 
+acpi_status acpi_os_execute(acpi_execute_type type,
+			    acpi_osd_exec_callback function, void *context)
+{
+	return __acpi_os_execute(type, function, context, 0);
+}
 EXPORT_SYMBOL(acpi_os_execute);
 
+acpi_status acpi_os_hotplug_execute(acpi_osd_exec_callback function,
+	void *context)
+{
+	return __acpi_os_execute(0, function, context, 1);
+}
+
 void acpi_os_wait_events_complete(void *context)
 {
 	flush_workqueue(kacpid_wq);

commit 2f67a0695dc389247c05041b05d2a2b06fc102a3
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Apr 29 02:34:42 2008 -0400

    flush kacpi_notify_wq before removing notify handler
    
    Flush kacpi_notify_wq before notify handler is removed,
    this can fix a bug which the deferred notify handler is executed
    after the notify_handler has already been removed.
    http://bugzilla.kernel.org/show_bug.cgi?id=9772
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index a498a6cc68fe..235a1386888a 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -742,6 +742,7 @@ EXPORT_SYMBOL(acpi_os_execute);
 void acpi_os_wait_events_complete(void *context)
 {
 	flush_workqueue(kacpid_wq);
+	flush_workqueue(kacpi_notify_wq);
 }
 
 EXPORT_SYMBOL(acpi_os_wait_events_complete);

commit f1241c87a16c4fe9f4f51d6ed3589f031c505e8d
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri Mar 14 13:43:13 2008 -0400

    Add down_timeout and change ACPI to use it
    
    ACPI currently emulates a timeout for semaphores with calls to
    down_trylock and sleep.  This produces horrible behaviour in terms of
    fairness and excessive wakeups.  Now that we have a unified semaphore
    implementation, adding a real down_trylock is almost trivial.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index a697fb6cf050..a498a6cc68fe 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -4,6 +4,8 @@
  *  Copyright (C) 2000       Andrew Henroid
  *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (c) 2008 Intel Corporation
+ *   Author: Matthew Wilcox <willy@linux.intel.com>
  *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
@@ -37,15 +39,18 @@
 #include <linux/workqueue.h>
 #include <linux/nmi.h>
 #include <linux/acpi.h>
-#include <acpi/acpi.h>
-#include <asm/io.h>
-#include <acpi/acpi_bus.h>
-#include <acpi/processor.h>
-#include <asm/uaccess.h>
-
 #include <linux/efi.h>
 #include <linux/ioport.h>
 #include <linux/list.h>
+#include <linux/jiffies.h>
+#include <linux/semaphore.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <acpi/acpi.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/processor.h>
 
 #define _COMPONENT		ACPI_OS_SERVICES
 ACPI_MODULE_NAME("osl");
@@ -764,7 +769,6 @@ acpi_os_create_semaphore(u32 max_units, u32 initial_units, acpi_handle * handle)
 {
 	struct semaphore *sem = NULL;
 
-
 	sem = acpi_os_allocate(sizeof(struct semaphore));
 	if (!sem)
 		return AE_NO_MEMORY;
@@ -791,12 +795,12 @@ acpi_status acpi_os_delete_semaphore(acpi_handle handle)
 {
 	struct semaphore *sem = (struct semaphore *)handle;
 
-
 	if (!sem)
 		return AE_BAD_PARAMETER;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Deleting semaphore[%p].\n", handle));
 
+	BUG_ON(!list_empty(&sem->wait_list));
 	kfree(sem);
 	sem = NULL;
 
@@ -804,21 +808,15 @@ acpi_status acpi_os_delete_semaphore(acpi_handle handle)
 }
 
 /*
- * TODO: The kernel doesn't have a 'down_timeout' function -- had to
- * improvise.  The process is to sleep for one scheduler quantum
- * until the semaphore becomes available.  Downside is that this
- * may result in starvation for timeout-based waits when there's
- * lots of semaphore activity.
- *
  * TODO: Support for units > 1?
  */
 acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
 {
 	acpi_status status = AE_OK;
 	struct semaphore *sem = (struct semaphore *)handle;
+	long jiffies;
 	int ret = 0;
 
-
 	if (!sem || (units < 1))
 		return AE_BAD_PARAMETER;
 
@@ -828,58 +826,14 @@ acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
 	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Waiting for semaphore[%p|%d|%d]\n",
 			  handle, units, timeout));
 
-	/*
-	 * This can be called during resume with interrupts off.
-	 * Like boot-time, we should be single threaded and will
-	 * always get the lock if we try -- timeout or not.
-	 * If this doesn't succeed, then we will oops courtesy of
-	 * might_sleep() in down().
-	 */
-	if (!down_trylock(sem))
-		return AE_OK;
-
-	switch (timeout) {
-		/*
-		 * No Wait:
-		 * --------
-		 * A zero timeout value indicates that we shouldn't wait - just
-		 * acquire the semaphore if available otherwise return AE_TIME
-		 * (a.k.a. 'would block').
-		 */
-	case 0:
-		if (down_trylock(sem))
-			status = AE_TIME;
-		break;
-
-		/*
-		 * Wait Indefinitely:
-		 * ------------------
-		 */
-	case ACPI_WAIT_FOREVER:
-		down(sem);
-		break;
-
-		/*
-		 * Wait w/ Timeout:
-		 * ----------------
-		 */
-	default:
-		// TODO: A better timeout algorithm?
-		{
-			int i = 0;
-			static const int quantum_ms = 1000 / HZ;
-
-			ret = down_trylock(sem);
-			for (i = timeout; (i > 0 && ret != 0); i -= quantum_ms) {
-				schedule_timeout_interruptible(1);
-				ret = down_trylock(sem);
-			}
-
-			if (ret != 0)
-				status = AE_TIME;
-		}
-		break;
-	}
+	if (timeout == ACPI_WAIT_FOREVER)
+		jiffies = MAX_SCHEDULE_TIMEOUT;
+	else
+		jiffies = msecs_to_jiffies(timeout);
+	
+	ret = down_timeout(sem, jiffies);
+	if (ret)
+		status = AE_TIME;
 
 	if (ACPI_FAILURE(status)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_MUTEX,
@@ -902,7 +856,6 @@ acpi_status acpi_os_signal_semaphore(acpi_handle handle, u32 units)
 {
 	struct semaphore *sem = (struct semaphore *)handle;
 
-
 	if (!sem || (units < 1))
 		return AE_BAD_PARAMETER;
 

commit 9a9e0d685553af76cb6ae2af93cca4913e7fcd47
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 15 11:53:32 2008 -0700

    ACPI: Remove ACPI_CUSTOM_DSDT_INITRD option
    
    This essentially reverts commit 71fc47a9adf8ee89e5c96a47222915c5485ac437
    ("ACPI: basic initramfs DSDT override support"), because the code simply
    isn't ready.
    
    It did ugly things to the init sequence to populate the rootfs image
    early, but that just ended up showing other problems with the whole
    approach.  The fact is, the VFS layer simply isn't initialized this
    early, and the relevant ACPI code should either run much later, or this
    shouldn't be done at all.
    
    For 2.6.25, we'll just pick the latter option.  We can revisit this
    concept later if necessary.
    
    Cc: Dave Hansen <haveblue@us.ibm.com>
    Cc: Tilman Schmidt <tilman@imap.cc>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Thomas Renninger <trenn@suse.de>
    Cc: Eric Piel <eric.piel@tremplin-utc.net>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Markus Gaugusch <dsdt@gaugusch.at>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 065819ba87c7..a697fb6cf050 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -91,10 +91,6 @@ static DEFINE_SPINLOCK(acpi_res_lock);
 #define	OSI_STRING_LENGTH_MAX 64	/* arbitrary */
 static char osi_additional_string[OSI_STRING_LENGTH_MAX];
 
-#ifdef CONFIG_ACPI_CUSTOM_DSDT_INITRD
-static int acpi_no_initrd_override;
-#endif
-
 /*
  * "Ode to _OSI(Linux)"
  *
@@ -324,67 +320,6 @@ acpi_os_predefined_override(const struct acpi_predefined_names *init_val,
 	return AE_OK;
 }
 
-#ifdef CONFIG_ACPI_CUSTOM_DSDT_INITRD
-static struct acpi_table_header *acpi_find_dsdt_initrd(void)
-{
-	struct file *firmware_file;
-	mm_segment_t oldfs;
-	unsigned long len, len2;
-	struct acpi_table_header *dsdt_buffer, *ret = NULL;
-	struct kstat stat;
-	char *ramfs_dsdt_name = "/DSDT.aml";
-
-	printk(KERN_INFO PREFIX "Checking initramfs for custom DSDT\n");
-
-	/*
-	 * Never do this at home, only the user-space is allowed to open a file.
-	 * The clean way would be to use the firmware loader.
-	 * But this code must be run before there is any userspace available.
-	 * A static/init firmware infrastructure doesn't exist yet...
-	 */
-	if (vfs_stat(ramfs_dsdt_name, &stat) < 0)
-		return ret;
-
-	len = stat.size;
-	/* check especially against empty files */
-	if (len <= 4) {
-		printk(KERN_ERR PREFIX "Failed: DSDT only %lu bytes.\n", len);
-		return ret;
-	}
-
-	firmware_file = filp_open(ramfs_dsdt_name, O_RDONLY, 0);
-	if (IS_ERR(firmware_file)) {
-		printk(KERN_ERR PREFIX "Failed to open %s.\n", ramfs_dsdt_name);
-		return ret;
-	}
-
-	dsdt_buffer = kmalloc(len, GFP_ATOMIC);
-	if (!dsdt_buffer) {
-		printk(KERN_ERR PREFIX "Failed to allocate %lu bytes.\n", len);
-		goto err;
-	}
-
-	oldfs = get_fs();
-	set_fs(KERNEL_DS);
-	len2 = vfs_read(firmware_file, (char __user *)dsdt_buffer, len,
-		&firmware_file->f_pos);
-	set_fs(oldfs);
-	if (len2 < len) {
-		printk(KERN_ERR PREFIX "Failed to read %lu bytes from %s.\n",
-			len, ramfs_dsdt_name);
-		ACPI_FREE(dsdt_buffer);
-		goto err;
-	}
-
-	printk(KERN_INFO PREFIX "Found %lu byte DSDT in %s.\n",
-			len, ramfs_dsdt_name);
-	ret = dsdt_buffer;
-err:
-	filp_close(firmware_file, NULL);
-	return ret;
-}
-#endif
-
 acpi_status
 acpi_os_table_override(struct acpi_table_header * existing_table,
 		       struct acpi_table_header ** new_table)
@@ -397,16 +332,6 @@ acpi_os_table_override(struct acpi_table_header * existing_table,
 #ifdef CONFIG_ACPI_CUSTOM_DSDT
 	if (strncmp(existing_table->signature, "DSDT", 4) == 0)
 		*new_table = (struct acpi_table_header *)AmlCode;
-#endif
-#ifdef CONFIG_ACPI_CUSTOM_DSDT_INITRD
-	if ((strncmp(existing_table->signature, "DSDT", 4) == 0) &&
-	    !acpi_no_initrd_override) {
-		struct acpi_table_header *initrd_table;
-
-		initrd_table = acpi_find_dsdt_initrd();
-		if (initrd_table)
-			*new_table = initrd_table;
-	}
 #endif
 	if (*new_table != NULL) {
 		printk(KERN_WARNING PREFIX "Override [%4.4s-%8.8s], "
@@ -418,15 +343,6 @@ acpi_os_table_override(struct acpi_table_header * existing_table,
 	return AE_OK;
 }
 
-#ifdef CONFIG_ACPI_CUSTOM_DSDT_INITRD
-static int __init acpi_no_initrd_override_setup(char *s)
-{
-	acpi_no_initrd_override = 1;
-	return 1;
-}
-__setup("acpi_no_initrd_override", acpi_no_initrd_override_setup);
-#endif
-
 static irqreturn_t acpi_irq(int irq, void *dev_id)
 {
 	u32 handled;

commit bd12935f04066df31903eaf74b1cec03319ecd2e
Author: Jean Delvare <khali@linux-fr.org>
Date:   Wed Feb 27 20:56:01 2008 +0100

    ACPI: Fix a duplicate log level
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 8edba7b678eb..065819ba87c7 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1237,7 +1237,7 @@ int acpi_check_resource_conflict(struct resource *res)
 
 	if (clash) {
 		if (acpi_enforce_resources != ENFORCE_RESOURCES_NO) {
-			printk(KERN_INFO "%sACPI: %s resource %s [0x%llx-0x%llx]"
+			printk("%sACPI: %s resource %s [0x%llx-0x%llx]"
 			       " conflicts with ACPI region %s"
 			       " [0x%llx-0x%llx]\n",
 			       acpi_enforce_resources == ENFORCE_RESOURCES_LAX

commit f60d63f642d824914677fb40330671117dc39c3b
Merge: 46c1fbdb7191 fe8e288a63f2 6bf69b5ebf22
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 14 02:44:28 2008 -0500

    Merge branches 'release', 'dmi', 'idle' and 'misc' into release

commit 46c1fbdb7191bf07979d7cd5f08d1a86458181a2
Author: Len Brown <len.brown@intel.com>
Date:   Wed Feb 13 23:13:25 2008 -0500

    ACPI: DMI: quirk for FSC ESPRIMO Mobile V5505
    
    http://bugzilla.kernel.org/show_bug.cgi?id=9939
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 15e602377655..0467171dbdb8 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1109,7 +1109,7 @@ void __init acpi_dmi_osi_linux(int enable, const struct dmi_system_id *d)
  * string starting with '!' disables that string
  * otherwise string is added to list, augmenting built-in strings
  */
-static int __init acpi_osi_setup(char *str)
+int __init acpi_osi_setup(char *str)
 {
 	if (str == NULL || *str == '\0') {
 		printk(KERN_INFO PREFIX "_OSI method disabled\n");

commit adba2a876c1c971980f9bb3c6c8e20c61490647b
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Feb 13 23:29:58 2008 +0200

    ACPI: static acpi_find_dsdt_initrd()
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 346f0494dbbb..b51954d80ef9 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -325,7 +325,7 @@ acpi_os_predefined_override(const struct acpi_predefined_names *init_val,
 }
 
 #ifdef CONFIG_ACPI_CUSTOM_DSDT_INITRD
-struct acpi_table_header *acpi_find_dsdt_initrd(void)
+static struct acpi_table_header *acpi_find_dsdt_initrd(void)
 {
 	struct file *firmware_file;
 	mm_segment_t oldfs;

commit bfaed45e30f19bb4cee779f3229d2744bc2b2c46
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Feb 13 23:30:00 2008 +0200

    ACPI: static acpi_no_initrd_override_setup()
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Eric Piel <eric.piel@tremplin-utc.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 15e602377655..346f0494dbbb 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -419,7 +419,7 @@ acpi_os_table_override(struct acpi_table_header * existing_table,
 }
 
 #ifdef CONFIG_ACPI_CUSTOM_DSDT_INITRD
-int __init acpi_no_initrd_override_setup(char *s)
+static int __init acpi_no_initrd_override_setup(char *s)
 {
 	acpi_no_initrd_override = 1;
 	return 1;

commit 10270d4838bdc493781f5a1cf2e90e9c34c9142f
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Wed Feb 13 09:56:14 2008 -0800

    acpi: fix acpi_os_read_pci_configuration() misuse of raw_pci_read()
    
    The raw_pci_read() interface (as the raw_pci_ops->read() before it)
    unconditionally fills in a 32-bit integer return value regardless of the
    size of the operation requested.
    
    So claiming to take a "void *" is wrong, as is passing in a pointer to
    just a byte variable.
    
    Noticed by pageexec when enabling -fstack-protector (which needs other
    patches too to actually work, but that's a separate issue).
    
    Acked-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 34b3386dedca..15e602377655 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -623,7 +623,7 @@ acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
 
 acpi_status
 acpi_os_read_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
-			       void *value, u32 width)
+			       u32 *value, u32 width)
 {
 	int result, size;
 
@@ -689,7 +689,6 @@ static void acpi_os_derive_pci_id_2(acpi_handle rhandle,	/* upper bound  */
 	acpi_status status;
 	unsigned long temp;
 	acpi_object_type type;
-	u8 tu8;
 
 	acpi_get_parent(chandle, &handle);
 	if (handle != rhandle) {
@@ -704,6 +703,7 @@ static void acpi_os_derive_pci_id_2(acpi_handle rhandle,	/* upper bound  */
 		    acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL,
 					  &temp);
 		if (ACPI_SUCCESS(status)) {
+			u32 val;
 			pci_id->device = ACPI_HIWORD(ACPI_LODWORD(temp));
 			pci_id->function = ACPI_LOWORD(ACPI_LODWORD(temp));
 
@@ -712,24 +712,24 @@ static void acpi_os_derive_pci_id_2(acpi_handle rhandle,	/* upper bound  */
 
 			/* any nicer way to get bus number of bridge ? */
 			status =
-			    acpi_os_read_pci_configuration(pci_id, 0x0e, &tu8,
+			    acpi_os_read_pci_configuration(pci_id, 0x0e, &val,
 							   8);
 			if (ACPI_SUCCESS(status)
-			    && ((tu8 & 0x7f) == 1 || (tu8 & 0x7f) == 2)) {
+			    && ((val & 0x7f) == 1 || (val & 0x7f) == 2)) {
 				status =
 				    acpi_os_read_pci_configuration(pci_id, 0x18,
-								   &tu8, 8);
+								   &val, 8);
 				if (!ACPI_SUCCESS(status)) {
 					/* Certainly broken...  FIX ME */
 					return;
 				}
 				*is_bridge = 1;
-				pci_id->bus = tu8;
+				pci_id->bus = val;
 				status =
 				    acpi_os_read_pci_configuration(pci_id, 0x19,
-								   &tu8, 8);
+								   &val, 8);
 				if (ACPI_SUCCESS(status)) {
-					*bus_number = tu8;
+					*bus_number = val;
 				}
 			} else
 				*is_bridge = 0;

commit b6ce068a1285a24185b01be8a49021827516b3e1
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Feb 10 09:45:28 2008 -0500

    Change pci_raw_ops to pci_raw_read/write
    
    We want to allow different implementations of pci_raw_ops for standard
    and extended config space on x86.  Rather than clutter generic code with
    knowledge of this, we make pci_raw_ops private to x86 and use it to
    implement the new raw interface -- raw_pci_read() and raw_pci_write().
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index a14501c98f40..34b3386dedca 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -200,15 +200,6 @@ acpi_status __init acpi_os_initialize(void)
 
 acpi_status acpi_os_initialize1(void)
 {
-	/*
-	 * Initialize PCI configuration space access, as we'll need to access
-	 * it while walking the namespace (bus 0 and root bridges w/ _BBNs).
-	 */
-	if (!raw_pci_ops) {
-		printk(KERN_ERR PREFIX
-		       "Access to PCI configuration space unavailable\n");
-		return AE_NULL_ENTRY;
-	}
 	kacpid_wq = create_singlethread_workqueue("kacpid");
 	kacpi_notify_wq = create_singlethread_workqueue("kacpi_notify");
 	BUG_ON(!kacpid_wq);
@@ -653,11 +644,9 @@ acpi_os_read_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
 		return AE_ERROR;
 	}
 
-	BUG_ON(!raw_pci_ops);
-
-	result = raw_pci_ops->read(pci_id->segment, pci_id->bus,
-				   PCI_DEVFN(pci_id->device, pci_id->function),
-				   reg, size, value);
+	result = raw_pci_read(pci_id->segment, pci_id->bus,
+				PCI_DEVFN(pci_id->device, pci_id->function),
+				reg, size, value);
 
 	return (result ? AE_ERROR : AE_OK);
 }
@@ -682,11 +671,9 @@ acpi_os_write_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
 		return AE_ERROR;
 	}
 
-	BUG_ON(!raw_pci_ops);
-
-	result = raw_pci_ops->write(pci_id->segment, pci_id->bus,
-				    PCI_DEVFN(pci_id->device, pci_id->function),
-				    reg, size, value);
+	result = raw_pci_write(pci_id->segment, pci_id->bus,
+				PCI_DEVFN(pci_id->device, pci_id->function),
+				reg, size, value);
 
 	return (result ? AE_ERROR : AE_OK);
 }

commit b0b23e0ade6aa265d7278e06d50bc10ec81dd174
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 7 14:42:25 2008 -0500

    ACPI: add newline to printk
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 27ccd68b8f46..a14501c98f40 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -343,7 +343,7 @@ struct acpi_table_header *acpi_find_dsdt_initrd(void)
 	struct kstat stat;
 	char *ramfs_dsdt_name = "/DSDT.aml";
 
-	printk(KERN_INFO PREFIX "Checking initramfs for custom DSDT");
+	printk(KERN_INFO PREFIX "Checking initramfs for custom DSDT\n");
 
 	/*
 	 * Never do this at home, only the user-space is allowed to open a file.

commit 81e242d0efafb319938d511b115088a5c4523c91
Merge: a733a5da97b2 04d94886b47b
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 7 04:01:53 2008 -0500

    Merge branches 'release' and 'dsdt-override' into release

commit 04d94886b47b5133915021dcfb1108a8576f6ea7
Author: Len Brown <len.brown@intel.com>
Date:   Wed Feb 6 19:49:54 2008 -0500

    ACPI: update intrd DSDT override console messages
    
    also, address some checkpatch.pl violations
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 2b41bdddbeb6..2a400e08e74c 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -326,49 +326,50 @@ struct acpi_table_header *acpi_find_dsdt_initrd(void)
 	struct kstat stat;
 	char *ramfs_dsdt_name = "/DSDT.aml";
 
-	printk(KERN_INFO PREFIX "Looking for DSDT in initramfs... ");
+	printk(KERN_INFO PREFIX "Checking initramfs for custom DSDT");
 
 	/*
 	 * Never do this at home, only the user-space is allowed to open a file.
-	 * The clean way would be to use the firmware loader. But this code must be run
-	 * before there is any userspace available. So we need a static/init firmware
-	 * infrastructure, which doesn't exist yet...
+	 * The clean way would be to use the firmware loader.
+	 * But this code must be run before there is any userspace available.
+	 * A static/init firmware infrastructure doesn't exist yet...
 	 */
-	if (vfs_stat(ramfs_dsdt_name, &stat) < 0) {
-		printk("not found.\n");
+	if (vfs_stat(ramfs_dsdt_name, &stat) < 0)
 		return ret;
-	}
 
 	len = stat.size;
 	/* check especially against empty files */
 	if (len <= 4) {
-		printk("error, file is too small: only %lu bytes.\n", len);
+		printk(KERN_ERR PREFIX "Failed: DSDT only %lu bytes.\n", len);
 		return ret;
 	}
 
 	firmware_file = filp_open(ramfs_dsdt_name, O_RDONLY, 0);
 	if (IS_ERR(firmware_file)) {
-		printk("error, could not open file %s.\n", ramfs_dsdt_name);
+		printk(KERN_ERR PREFIX "Failed to open %s.\n", ramfs_dsdt_name);
 		return ret;
 	}
 
-	dsdt_buffer = ACPI_ALLOCATE(len);
+	dsdt_buffer = kmalloc(len, GFP_ATOMIC);
 	if (!dsdt_buffer) {
-		printk("error when allocating %lu bytes of memory.\n", len);
+		printk(KERN_ERR PREFIX "Failed to allocate %lu bytes.\n", len);
 		goto err;
 	}
 
 	oldfs = get_fs();
 	set_fs(KERNEL_DS);
-	len2 = vfs_read(firmware_file, (char __user *)dsdt_buffer, len, &firmware_file->f_pos);
+	len2 = vfs_read(firmware_file, (char __user *)dsdt_buffer, len,
+		&firmware_file->f_pos);
 	set_fs(oldfs);
 	if (len2 < len) {
-		printk("error trying to read %lu bytes from %s.\n", len, ramfs_dsdt_name);
+		printk(KERN_ERR PREFIX "Failed to read %lu bytes from %s.\n",
+			len, ramfs_dsdt_name);
 		ACPI_FREE(dsdt_buffer);
 		goto err;
 	}
 
-	printk("successfully read %lu bytes from %s.\n", len, ramfs_dsdt_name);
+	printk(KERN_INFO PREFIX "Found %lu byte DSDT in %s.\n",
+			len, ramfs_dsdt_name);
 	ret = dsdt_buffer;
 err:
 	filp_close(firmware_file, NULL);
@@ -392,7 +393,9 @@ acpi_os_table_override(struct acpi_table_header * existing_table,
 #ifdef CONFIG_ACPI_CUSTOM_DSDT_INITRD
 	if ((strncmp(existing_table->signature, "DSDT", 4) == 0) &&
 	    !acpi_no_initrd_override) {
-		struct acpi_table_header *initrd_table = acpi_find_dsdt_initrd();
+		struct acpi_table_header *initrd_table;
+
+		initrd_table = acpi_find_dsdt_initrd();
 		if (initrd_table)
 			*new_table = initrd_table;
 	}

commit 9cbc7960288d28aec95257af59854e1d14ba23b8
Author: Éric Piel <Eric.Piel@tremplin-utc.net>
Date:   Tue Feb 5 00:04:58 2008 +0100

    ACPI: Add "acpi_no_initrd_override" kernel parameter
    
    The acpi_no_initrd_override parameter permits to disable the load of an ACPI
    table from the initramfs.
    
    Signed-off-by: Eric Piel <eric.piel@tremplin-utc.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index bbd8360bfb23..2b41bdddbeb6 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -77,6 +77,10 @@ static struct workqueue_struct *kacpi_notify_wq;
 #define	OSI_STRING_LENGTH_MAX 64	/* arbitrary */
 static char osi_additional_string[OSI_STRING_LENGTH_MAX];
 
+#ifdef CONFIG_ACPI_CUSTOM_DSDT_INITRD
+static int acpi_no_initrd_override;
+#endif
+
 /*
  * "Ode to _OSI(Linux)"
  *
@@ -386,7 +390,8 @@ acpi_os_table_override(struct acpi_table_header * existing_table,
 		*new_table = (struct acpi_table_header *)AmlCode;
 #endif
 #ifdef CONFIG_ACPI_CUSTOM_DSDT_INITRD
-	if (strncmp(existing_table->signature, "DSDT", 4) == 0) {
+	if ((strncmp(existing_table->signature, "DSDT", 4) == 0) &&
+	    !acpi_no_initrd_override) {
 		struct acpi_table_header *initrd_table = acpi_find_dsdt_initrd();
 		if (initrd_table)
 			*new_table = initrd_table;
@@ -402,6 +407,15 @@ acpi_os_table_override(struct acpi_table_header * existing_table,
 	return AE_OK;
 }
 
+#ifdef CONFIG_ACPI_CUSTOM_DSDT_INITRD
+int __init acpi_no_initrd_override_setup(char *s)
+{
+	acpi_no_initrd_override = 1;
+	return 1;
+}
+__setup("acpi_no_initrd_override", acpi_no_initrd_override_setup);
+#endif
+
 static irqreturn_t acpi_irq(int irq, void *dev_id)
 {
 	return (*acpi_irq_handler) (acpi_irq_context) ? IRQ_HANDLED : IRQ_NONE;

commit a733a5da97b238e3e3167d3d0aee8fe1e8d04e97
Merge: 299cfe38081b 299cfe38081b 9e52797131e8
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 7 03:38:22 2008 -0500

    Merge branches 'release' and 'fluff' into release
    
    Conflicts:
    
            drivers/acpi/scan.c
            include/linux/acpi.h
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit e5685b9d35c2cc0a98425b05df30cb837dd1e632
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Oct 24 18:24:42 2007 +0200

    ACPI: misc cleanups
    
        This patch contains the following possible cleanups:
        - make the following needlessly global code static:
          - drivers/acpi/bay.c:dev_attr_eject
          - drivers/acpi/bay.c:dev_attr_present
          - drivers/acpi/dock.c:dev_attr_docked
          - drivers/acpi/dock.c:dev_attr_flags
          - drivers/acpi/dock.c:dev_attr_uid
          - drivers/acpi/dock.c:dev_attr_undock
          - drivers/acpi/pci_bind.c:acpi_pci_unbind()
          - drivers/acpi/pci_link.c:acpi_link_lock
          - drivers/acpi/sbs.c:acpi_sbs_callback()
          - drivers/acpi/sbshc.c:acpi_smbus_transaction()
          - drivers/acpi/sleep/main.c:acpi_sleep_prepare()
        - #if 0 the following unused global functions:
          - drivers/acpi/numa.c:acpi_unmap_pxm_to_node()
        - remove the following unused EXPORT_SYMBOL's:
          - acpi_register_gsi
          - acpi_unregister_gsi
          - acpi_strict
          - acpi_bus_receive_event
          - register_acpi_bus_type
          - unregister_acpi_bus_type
          - acpi_os_printf
          - acpi_os_sleep
          - acpi_os_stall
          - acpi_os_read_pci_configuration
          - acpi_os_create_semaphore
          - acpi_os_delete_semaphore
          - acpi_os_wait_semaphore
          - acpi_os_signal_semaphore
          - acpi_os_signal
          - acpi_pci_irq_enable
          - acpi_get_pxm
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e53fb516f9d4..7fcacc5ed821 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -219,8 +219,6 @@ void acpi_os_printf(const char *fmt, ...)
 	va_end(args);
 }
 
-EXPORT_SYMBOL(acpi_os_printf);
-
 void acpi_os_vprintf(const char *fmt, va_list args)
 {
 	static char buffer[512];
@@ -384,8 +382,6 @@ void acpi_os_sleep(acpi_integer ms)
 	schedule_timeout_interruptible(msecs_to_jiffies(ms));
 }
 
-EXPORT_SYMBOL(acpi_os_sleep);
-
 void acpi_os_stall(u32 us)
 {
 	while (us) {
@@ -399,8 +395,6 @@ void acpi_os_stall(u32 us)
 	}
 }
 
-EXPORT_SYMBOL(acpi_os_stall);
-
 /*
  * Support ACPI 3.0 AML Timer operand
  * Returns 64-bit free-running, monotonically increasing timer
@@ -550,8 +544,6 @@ acpi_os_read_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
 	return (result ? AE_ERROR : AE_OK);
 }
 
-EXPORT_SYMBOL(acpi_os_read_pci_configuration);
-
 acpi_status
 acpi_os_write_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
 				acpi_integer value, u32 width)
@@ -793,8 +785,6 @@ acpi_os_create_semaphore(u32 max_units, u32 initial_units, acpi_handle * handle)
 	return AE_OK;
 }
 
-EXPORT_SYMBOL(acpi_os_create_semaphore);
-
 /*
  * TODO: A better way to delete semaphores?  Linux doesn't have a
  * 'delete_semaphore()' function -- may result in an invalid
@@ -818,8 +808,6 @@ acpi_status acpi_os_delete_semaphore(acpi_handle handle)
 	return AE_OK;
 }
 
-EXPORT_SYMBOL(acpi_os_delete_semaphore);
-
 /*
  * TODO: The kernel doesn't have a 'down_timeout' function -- had to
  * improvise.  The process is to sleep for one scheduler quantum
@@ -912,8 +900,6 @@ acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
 	return status;
 }
 
-EXPORT_SYMBOL(acpi_os_wait_semaphore);
-
 /*
  * TODO: Support for units > 1?
  */
@@ -936,8 +922,6 @@ acpi_status acpi_os_signal_semaphore(acpi_handle handle, u32 units)
 	return AE_OK;
 }
 
-EXPORT_SYMBOL(acpi_os_signal_semaphore);
-
 #ifdef ACPI_FUTURE_USAGE
 u32 acpi_os_get_line(char *buffer)
 {
@@ -981,8 +965,6 @@ acpi_status acpi_os_signal(u32 function, void *info)
 	return AE_OK;
 }
 
-EXPORT_SYMBOL(acpi_os_signal);
-
 static int __init acpi_os_name_setup(char *str)
 {
 	char *p = acpi_os_name;

commit 299cfe38081bea6dcd8b882375f6f65a980bccf9
Merge: 8976b6fd7a00 443dea72d5f4
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 7 03:31:17 2008 -0500

    Merge branches 'release' and 'hwmon-conflicts' into release

commit e5e54bc86a1fed9849b22fd736c30b23c4719046
Merge: 70ec75c5b8e0 5229e87d59ce
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 7 03:13:36 2008 -0500

    Merge branches 'release' and 'stats' into release

commit 70ec75c5b8e0bda7a16fb387f91e08545f379a0e
Merge: 4f4ae0d42680 2fdf07417e57 23b168d425ca
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 7 03:13:13 2008 -0500

    Merge branches 'release', 'misc' and 'misc-2.6.25' into release

commit 7924e4f6519dd5b349ed146fe9fe35206730be67
Merge: 5531d2850446 17bc54eef91d
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 7 03:11:47 2008 -0500

    Merge branches 'release' and 'gpe-ack' into release

commit 5531d28504461c4e96c6fbd80655a2bfd6481583
Merge: acf63867ae06 a64217b922e5
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 7 03:11:31 2008 -0500

    Merge branches 'release' and 'dmi' into release

commit c64768a7d671bcde80bca2aed93f9e07edc069c3
Merge: 8f859016ea49 a7f9b1f24974 b4d2730a0dda 37748ebf8888 ed9cbcd40004 856608ee5e1e cfaf3747ff3d 223630fe3dc5 38531e6fe51a b3b233c7d948 239665a3bb0a 0119509c4fbc 975c30257e75 087980295082
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 7 03:09:43 2008 -0500

    Merge branches 'release', 'bugzilla-6217', 'bugzilla-6629', 'bugzilla-6933', 'bugzilla-7186', 'bugzilla-8269', 'bugzilla-8570', 'bugzilla-9139', 'bugzilla-9277', 'bugzilla-9341', 'bugzilla-9444', 'bugzilla-9614', 'bugzilla-9643' and 'bugzilla-9644' into release

commit 443dea72d5f428170de6d6e3c4c1a1e2b7632b65
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Feb 4 23:31:23 2008 -0800

    ACPI: Export acpi_check_resource_conflict
    
    Export acpi_check_resource_conflict(), sometimes drivers already have
    a struct resource at hand so no need to use the wrappers to build a new
    one.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Cc: "Mark M. Hoffman" <mhoffman@lightlink.com>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 222f7b1b66f7..bc1604bfa4db 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1157,7 +1157,7 @@ __setup("acpi_enforce_resources=", acpi_enforce_resources_setup);
 
 /* Check for resource conflicts between ACPI OperationRegions and native
  * drivers */
-static int acpi_check_resource_conflict(struct resource *res)
+int acpi_check_resource_conflict(struct resource *res)
 {
 	struct acpi_res_list *res_list_elem;
 	int ioport;
@@ -1207,6 +1207,7 @@ static int acpi_check_resource_conflict(struct resource *res)
 	}
 	return 0;
 }
+EXPORT_SYMBOL(acpi_check_resource_conflict);
 
 int acpi_check_region(resource_size_t start, resource_size_t n,
 		      const char *name)

commit df92e695998e1bc6e426a840eb86d6d1ee87e2a5
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Feb 4 23:31:22 2008 -0800

    ACPI: track opregion names to avoid driver resource conflicts.
    
    Small ACPICA extension to be able to store the name of operation regions in osl.c later
    
    In ACPI, AML can define accesses to IO ports and System Memory by Operation
    Regions.  Those are not registered as done by PNPACPI using resource templates
    (and _CRS/_SRS methods).
    
    The IO ports and System Memory regions may get accessed by arbitrary AML code.
     When native drivers are accessing the same resources bad things can happen
    (e.g.  a critical shutdown temperature of 3000 C every 2 months or so).
    
    It is not really possible to register the operation regions via
    request_resource, as they often overlap with pnp or other resources (e.g.
    statically setup IO resources below 0x100).
    
    This approach stores all Operation Region declarations (IO and System Memory
    only) at ACPI table parse time.  It offers a similar functionality like
    request_region and let drivers which are known to possibly use the same IO
    ports and Memory which are also often used by ACPI (hwmon and i2c) check for
    ACPI interference.
    
    A boot parameter acpi_enforce_resources=strict/lax/no is provided, which
    is default set to lax:
      - strict: let conflicting drivers fail to load with an error message
      - lax:    let conflicting driver work normal with a warning message
      - no:     no functional change at all
    Depending on the feedback and the kind of interferences we see, this
    should be set to strict at later time.
    
    Goal of this patch set is:
      - Identify ACPI interferences in bug reports (very hard to reproduce
        and to identify)
      - Find BIOSes for that an ACPI driver should exist for specific HW
        instead of a native one.
      - stability in general
    
    Provide acpi_check_{mem_}region.
    
    Drivers can additionally check against possible ACPI interference by also
    invoking this shortly before they call request_region.
    If -EBUSY is returned, the driver must not load.
    Use acpi_enforce_resources=strict/lax/no options to:
      - strict: let conflicting drivers fail to load with an error message
      - lax:    let conflicting driver work normal with a warning message
      - no:     no functional change at all
    
    Cc: "Mark M. Hoffman" <mhoffman@lightlink.com>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e53fb516f9d4..222f7b1b66f7 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -44,6 +44,8 @@
 #include <asm/uaccess.h>
 
 #include <linux/efi.h>
+#include <linux/ioport.h>
+#include <linux/list.h>
 
 #define _COMPONENT		ACPI_OS_SERVICES
 ACPI_MODULE_NAME("osl");
@@ -74,6 +76,18 @@ static void *acpi_irq_context;
 static struct workqueue_struct *kacpid_wq;
 static struct workqueue_struct *kacpi_notify_wq;
 
+struct acpi_res_list {
+	resource_size_t start;
+	resource_size_t end;
+	acpi_adr_space_type resource_type; /* IO port, System memory, ...*/
+	char name[5];   /* only can have a length of 4 chars, make use of this
+			   one instead of res->name, no need to kalloc then */
+	struct list_head resource_list;
+};
+
+static LIST_HEAD(resource_list_head);
+static DEFINE_SPINLOCK(acpi_res_lock);
+
 #define	OSI_STRING_LENGTH_MAX 64	/* arbitrary */
 static char osi_additional_string[OSI_STRING_LENGTH_MAX];
 
@@ -1102,6 +1116,127 @@ static int __init acpi_wake_gpes_always_on_setup(char *str)
 
 __setup("acpi_wake_gpes_always_on", acpi_wake_gpes_always_on_setup);
 
+/* Check of resource interference between native drivers and ACPI
+ * OperationRegions (SystemIO and System Memory only).
+ * IO ports and memory declared in ACPI might be used by the ACPI subsystem
+ * in arbitrary AML code and can interfere with legacy drivers.
+ * acpi_enforce_resources= can be set to:
+ *
+ *   - strict           (2)
+ *     -> further driver trying to access the resources will not load
+ *   - lax (default)    (1)
+ *     -> further driver trying to access the resources will load, but you
+ *     get a system message that something might go wrong...
+ *
+ *   - no               (0)
+ *     -> ACPI Operation Region resources will not be registered
+ *
+ */
+#define ENFORCE_RESOURCES_STRICT 2
+#define ENFORCE_RESOURCES_LAX    1
+#define ENFORCE_RESOURCES_NO     0
+
+static unsigned int acpi_enforce_resources = ENFORCE_RESOURCES_LAX;
+
+static int __init acpi_enforce_resources_setup(char *str)
+{
+	if (str == NULL || *str == '\0')
+		return 0;
+
+	if (!strcmp("strict", str))
+		acpi_enforce_resources = ENFORCE_RESOURCES_STRICT;
+	else if (!strcmp("lax", str))
+		acpi_enforce_resources = ENFORCE_RESOURCES_LAX;
+	else if (!strcmp("no", str))
+		acpi_enforce_resources = ENFORCE_RESOURCES_NO;
+
+	return 1;
+}
+
+__setup("acpi_enforce_resources=", acpi_enforce_resources_setup);
+
+/* Check for resource conflicts between ACPI OperationRegions and native
+ * drivers */
+static int acpi_check_resource_conflict(struct resource *res)
+{
+	struct acpi_res_list *res_list_elem;
+	int ioport;
+	int clash = 0;
+
+	if (acpi_enforce_resources == ENFORCE_RESOURCES_NO)
+		return 0;
+	if (!(res->flags & IORESOURCE_IO) && !(res->flags & IORESOURCE_MEM))
+		return 0;
+
+	ioport = res->flags & IORESOURCE_IO;
+
+	spin_lock(&acpi_res_lock);
+	list_for_each_entry(res_list_elem, &resource_list_head,
+			    resource_list) {
+		if (ioport && (res_list_elem->resource_type
+			       != ACPI_ADR_SPACE_SYSTEM_IO))
+			continue;
+		if (!ioport && (res_list_elem->resource_type
+				!= ACPI_ADR_SPACE_SYSTEM_MEMORY))
+			continue;
+
+		if (res->end < res_list_elem->start
+		    || res_list_elem->end < res->start)
+			continue;
+		clash = 1;
+		break;
+	}
+	spin_unlock(&acpi_res_lock);
+
+	if (clash) {
+		if (acpi_enforce_resources != ENFORCE_RESOURCES_NO) {
+			printk(KERN_INFO "%sACPI: %s resource %s [0x%llx-0x%llx]"
+			       " conflicts with ACPI region %s"
+			       " [0x%llx-0x%llx]\n",
+			       acpi_enforce_resources == ENFORCE_RESOURCES_LAX
+			       ? KERN_WARNING : KERN_ERR,
+			       ioport ? "I/O" : "Memory", res->name,
+			       (long long) res->start, (long long) res->end,
+			       res_list_elem->name,
+			       (long long) res_list_elem->start,
+			       (long long) res_list_elem->end);
+			printk(KERN_INFO "ACPI: Device needs an ACPI driver\n");
+		}
+		if (acpi_enforce_resources == ENFORCE_RESOURCES_STRICT)
+			return -EBUSY;
+	}
+	return 0;
+}
+
+int acpi_check_region(resource_size_t start, resource_size_t n,
+		      const char *name)
+{
+	struct resource res = {
+		.start = start,
+		.end   = start + n - 1,
+		.name  = name,
+		.flags = IORESOURCE_IO,
+	};
+
+	return acpi_check_resource_conflict(&res);
+}
+EXPORT_SYMBOL(acpi_check_region);
+
+int acpi_check_mem_region(resource_size_t start, resource_size_t n,
+		      const char *name)
+{
+	struct resource res = {
+		.start = start,
+		.end   = start + n - 1,
+		.name  = name,
+		.flags = IORESOURCE_MEM,
+	};
+
+	return acpi_check_resource_conflict(&res);
+
+}
+EXPORT_SYMBOL(acpi_check_mem_region);
+
 /*
  * Acquire a spinlock.
  *
@@ -1303,10 +1438,46 @@ acpi_status
 acpi_os_validate_address (
     u8                   space_id,
     acpi_physical_address   address,
-    acpi_size               length)
+    acpi_size               length,
+    char *name)
 {
+	struct acpi_res_list *res;
+	if (acpi_enforce_resources == ENFORCE_RESOURCES_NO)
+		return AE_OK;
 
-    return AE_OK;
+	switch (space_id) {
+	case ACPI_ADR_SPACE_SYSTEM_IO:
+	case ACPI_ADR_SPACE_SYSTEM_MEMORY:
+		/* Only interference checks against SystemIO and SytemMemory
+		   are needed */
+		res = kzalloc(sizeof(struct acpi_res_list), GFP_KERNEL);
+		if (!res)
+			return AE_OK;
+		/* ACPI names are fixed to 4 bytes, still better use strlcpy */
+		strlcpy(res->name, name, 5);
+		res->start = address;
+		res->end = address + length - 1;
+		res->resource_type = space_id;
+		spin_lock(&acpi_res_lock);
+		list_add(&res->resource_list, &resource_list_head);
+		spin_unlock(&acpi_res_lock);
+		pr_debug("Added %s resource: start: 0x%llx, end: 0x%llx, "
+			 "name: %s\n", (space_id == ACPI_ADR_SPACE_SYSTEM_IO)
+			 ? "SystemIO" : "System Memory",
+			 (unsigned long long)res->start,
+			 (unsigned long long)res->end,
+			 res->name);
+		break;
+	case ACPI_ADR_SPACE_PCI_CONFIG:
+	case ACPI_ADR_SPACE_EC:
+	case ACPI_ADR_SPACE_SMBUS:
+	case ACPI_ADR_SPACE_CMOS:
+	case ACPI_ADR_SPACE_PCI_BAR_TARGET:
+	case ACPI_ADR_SPACE_DATA_TABLE:
+	case ACPI_ADR_SPACE_FIXED_HARDWARE:
+		break;
+	}
+	return AE_OK;
 }
 
 #endif

commit 5229e87d59cef33539322948bd8e3b5a537f7c97
Author: Len Brown <len.brown@intel.com>
Date:   Wed Feb 6 01:26:55 2008 -0500

    ACPI: create /sys/firmware/acpi/interrupts
    
    See Documentation/ABI/testing/sysfs-firmware-acpi
    
    Based-on-original-patch-by: Luming Yu <luming.yu@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e53fb516f9d4..1087efeca9b1 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -332,7 +332,15 @@ acpi_os_table_override(struct acpi_table_header * existing_table,
 
 static irqreturn_t acpi_irq(int irq, void *dev_id)
 {
-	return (*acpi_irq_handler) (acpi_irq_context) ? IRQ_HANDLED : IRQ_NONE;
+	u32 handled;
+
+	handled = (*acpi_irq_handler) (acpi_irq_context);
+
+	if (handled) {
+		acpi_irq_handled++;
+		return IRQ_HANDLED;
+	} else
+		return IRQ_NONE;
 }
 
 acpi_status
@@ -341,6 +349,8 @@ acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,
 {
 	unsigned int irq;
 
+	acpi_irq_stats_init();
+
 	/*
 	 * Ignore the GSI from the core, and use the value in our copy of the
 	 * FADT. It may not be the same if an interrupt source override exists

commit 6ed31e92e94830c138fbd470486383380710069a
Author: Éric Piel <Eric.Piel@tremplin-utc.net>
Date:   Tue Feb 5 00:04:50 2008 +0100

    ACPI: Taint kernel on ACPI table override (format corrected)
    
    When an ACPI table is overridden (for now this can happen only for DSDT)
    display a big warning and taint the kernel with flag A.
    
    Signed-off-by: Eric Piel <eric.piel@tremplin-utc.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 131936e7ff17..bbd8360bfb23 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -392,6 +392,13 @@ acpi_os_table_override(struct acpi_table_header * existing_table,
 			*new_table = initrd_table;
 	}
 #endif
+	if (*new_table != NULL) {
+		printk(KERN_WARNING PREFIX "Override [%4.4s-%8.8s], "
+			   "this is unsafe: tainting kernel\n",
+		       existing_table->signature,
+		       existing_table->oem_table_id);
+		add_taint(TAINT_OVERRIDDEN_ACPI_TABLE);
+	}
 	return AE_OK;
 }
 

commit 71fc47a9adf8ee89e5c96a47222915c5485ac437
Author: Markus Gaugusch <dsdt@gaugusch.at>
Date:   Tue Feb 5 00:04:06 2008 +0100

    ACPI: basic initramfs DSDT override support
    
    The basics of DSDT from initramfs. In case this option is selected,
    populate_rootfs() is called a bit earlier to have the initramfs content
    available during ACPI initialization.
    
    This is a very similar path to the one available at
    http://gaugusch.at/kernel.shtml but with some update in the
    documentation, default set to No and the change of populate_rootfs() the
    "Jeff Mahony way" (which avoids reading the initramfs twice).
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Eric Piel <eric.piel@tremplin-utc.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e53fb516f9d4..131936e7ff17 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -312,6 +312,66 @@ acpi_os_predefined_override(const struct acpi_predefined_names *init_val,
 	return AE_OK;
 }
 
+#ifdef CONFIG_ACPI_CUSTOM_DSDT_INITRD
+struct acpi_table_header *acpi_find_dsdt_initrd(void)
+{
+	struct file *firmware_file;
+	mm_segment_t oldfs;
+	unsigned long len, len2;
+	struct acpi_table_header *dsdt_buffer, *ret = NULL;
+	struct kstat stat;
+	char *ramfs_dsdt_name = "/DSDT.aml";
+
+	printk(KERN_INFO PREFIX "Looking for DSDT in initramfs... ");
+
+	/*
+	 * Never do this at home, only the user-space is allowed to open a file.
+	 * The clean way would be to use the firmware loader. But this code must be run
+	 * before there is any userspace available. So we need a static/init firmware
+	 * infrastructure, which doesn't exist yet...
+	 */
+	if (vfs_stat(ramfs_dsdt_name, &stat) < 0) {
+		printk("not found.\n");
+		return ret;
+	}
+
+	len = stat.size;
+	/* check especially against empty files */
+	if (len <= 4) {
+		printk("error, file is too small: only %lu bytes.\n", len);
+		return ret;
+	}
+
+	firmware_file = filp_open(ramfs_dsdt_name, O_RDONLY, 0);
+	if (IS_ERR(firmware_file)) {
+		printk("error, could not open file %s.\n", ramfs_dsdt_name);
+		return ret;
+	}
+
+	dsdt_buffer = ACPI_ALLOCATE(len);
+	if (!dsdt_buffer) {
+		printk("error when allocating %lu bytes of memory.\n", len);
+		goto err;
+	}
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	len2 = vfs_read(firmware_file, (char __user *)dsdt_buffer, len, &firmware_file->f_pos);
+	set_fs(oldfs);
+	if (len2 < len) {
+		printk("error trying to read %lu bytes from %s.\n", len, ramfs_dsdt_name);
+		ACPI_FREE(dsdt_buffer);
+		goto err;
+	}
+
+	printk("successfully read %lu bytes from %s.\n", len, ramfs_dsdt_name);
+	ret = dsdt_buffer;
+err:
+	filp_close(firmware_file, NULL);
+	return ret;
+}
+#endif
+
 acpi_status
 acpi_os_table_override(struct acpi_table_header * existing_table,
 		       struct acpi_table_header ** new_table)
@@ -319,13 +379,18 @@ acpi_os_table_override(struct acpi_table_header * existing_table,
 	if (!existing_table || !new_table)
 		return AE_BAD_PARAMETER;
 
+	*new_table = NULL;
+
 #ifdef CONFIG_ACPI_CUSTOM_DSDT
 	if (strncmp(existing_table->signature, "DSDT", 4) == 0)
 		*new_table = (struct acpi_table_header *)AmlCode;
-	else
-		*new_table = NULL;
-#else
-	*new_table = NULL;
+#endif
+#ifdef CONFIG_ACPI_CUSTOM_DSDT_INITRD
+	if (strncmp(existing_table->signature, "DSDT", 4) == 0) {
+		struct acpi_table_header *initrd_table = acpi_find_dsdt_initrd();
+		if (initrd_table)
+			*new_table = initrd_table;
+	}
 #endif
 	return AE_OK;
 }

commit 1d15d84e8b443971cafd885d18f091814ba32cb7
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Jan 29 00:10:15 2008 +0200

    ACPI: make struct osi_linux static
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 71b0c32979f3..fde7ac82d611 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -120,7 +120,7 @@ static char osi_additional_string[OSI_STRING_LENGTH_MAX];
  */
 #define OSI_LINUX_ENABLE 0
 
-struct osi_linux {
+static struct osi_linux {
 	unsigned int	enable:1;
 	unsigned int	dmi:1;
 	unsigned int	cmdline:1;

commit 12d3931c1007a7ad47364a4884e5a6c6e25aa5e1
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Jan 29 00:10:12 2008 +0200

    ACPI: make acpi_dmi_dump() static
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 347cda21c0ed..71b0c32979f3 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1213,7 +1213,7 @@ acpi_status acpi_os_release_object(acpi_cache_t * cache, void *object)
  *
  *	Returns 0 on success
  */
-int acpi_dmi_dump(void)
+static int acpi_dmi_dump(void)
 {
 
 	if (!dmi_available)

commit e6298c6d60838495978cdbe5555dc290785bb961
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 25 15:40:02 2008 -0500

    DMI: remove duplicate helper routine
    
    Use existing dmi_get_system_info(),
    Delete duplicate dmi_get_slot()
    
    Spotted-by: Wim Van Sebroeck <wim@iguana.be>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e53fb516f9d4..347cda21c0ed 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1220,17 +1220,17 @@ int acpi_dmi_dump(void)
 		return -1;
 
 	printk(KERN_NOTICE PREFIX "DMI System Vendor: %s\n",
-		dmi_get_slot(DMI_SYS_VENDOR));
+		dmi_get_system_info(DMI_SYS_VENDOR));
 	printk(KERN_NOTICE PREFIX "DMI Product Name: %s\n",
-		dmi_get_slot(DMI_PRODUCT_NAME));
+		dmi_get_system_info(DMI_PRODUCT_NAME));
 	printk(KERN_NOTICE PREFIX "DMI Product Version: %s\n",
-		dmi_get_slot(DMI_PRODUCT_VERSION));
+		dmi_get_system_info(DMI_PRODUCT_VERSION));
 	printk(KERN_NOTICE PREFIX "DMI Board Name: %s\n",
-		dmi_get_slot(DMI_BOARD_NAME));
+		dmi_get_system_info(DMI_BOARD_NAME));
 	printk(KERN_NOTICE PREFIX "DMI BIOS Vendor: %s\n",
-		dmi_get_slot(DMI_BIOS_VENDOR));
+		dmi_get_system_info(DMI_BIOS_VENDOR));
 	printk(KERN_NOTICE PREFIX "DMI BIOS Date: %s\n",
-		dmi_get_slot(DMI_BIOS_DATE));
+		dmi_get_system_info(DMI_BIOS_DATE));
 
 	return 0;
 }

commit d4b7dc499daae909e62dc260b95cd618f2970ded
Author: Len Brown <len.brown@intel.com>
Date:   Wed Jan 23 20:50:56 2008 -0500

    ACPI: make _OSI(Linux) console messages smarter
    
    If BIOS invokes _OSI(Linux), the kernel response
    depends on what the ACPI DMI list knows about the system,
    and that is reflectd in dmesg:
    
    1) System unknown to DMI:
    
    ACPI: BIOS _OSI(Linux) query ignored
    ACPI: DMI System Vendor: LENOVO
    ACPI: DMI Product Name: 7661W1P
    ACPI: DMI Product Version: ThinkPad T61
    ACPI: DMI Board Name: 7661W1P
    ACPI: DMI BIOS Vendor: LENOVO
    ACPI: DMI BIOS Date: 10/18/2007
    ACPI: Please send DMI info above to linux-acpi@vger.kernel.org
    ACPI: If "acpi_osi=Linux" works better, please notify linux-acpi@vger.kernel.org
    
    2) System known to DMI, but effect of OSI(Linux) unknown:
    
    ACPI: DMI detected: Lenovo ThinkPad T61
    ...
    ACPI: BIOS _OSI(Linux) query ignored via DMI
    ACPI: If "acpi_osi=Linux" works better, please notify linux-acpi@vger.kernel.org
    
    3) System known to DMI, which disables _OSI(Linux):
    
    ACPI: DMI detected: Lenovo ThinkPad T61
    ...
    ACPI: BIOS _OSI(Linux) query ignored via DMI
    
    4) System known to DMI, which enable _OSI(Linux):
    
    ACPI: DMI detected: Lenovo ThinkPad T61
    ACPI: Added _OSI(Linux)
    ...
    ACPI: BIOS _OSI(Linux) query honored via DMI
    
    cmdline overrides take precidence over the built-in
    default and the DMI prescribed default.
    cmdline "acpi_osi=Linux" results in:
    
    ACPI: BIOS _OSI(Linux) query honored via cmdline
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 15f095ea795e..e53fb516f9d4 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -77,7 +77,55 @@ static struct workqueue_struct *kacpi_notify_wq;
 #define	OSI_STRING_LENGTH_MAX 64	/* arbitrary */
 static char osi_additional_string[OSI_STRING_LENGTH_MAX];
 
-static int osi_linux;		/* disable _OSI(Linux) by default */
+/*
+ * "Ode to _OSI(Linux)"
+ *
+ * osi_linux -- Control response to BIOS _OSI(Linux) query.
+ *
+ * As Linux evolves, the features that it supports change.
+ * So an OSI string such as "Linux" is not specific enough
+ * to be useful across multiple versions of Linux.  It
+ * doesn't identify any particular feature, interface,
+ * or even any particular version of Linux...
+ *
+ * Unfortunately, Linux-2.6.22 and earlier responded "yes"
+ * to a BIOS _OSI(Linux) query.  When
+ * a reference mobile BIOS started using it, its use
+ * started to spread to many vendor platforms.
+ * As it is not supportable, we need to halt that spread.
+ *
+ * Today, most BIOS references to _OSI(Linux) are noise --
+ * they have no functional effect and are just dead code
+ * carried over from the reference BIOS.
+ *
+ * The next most common case is that _OSI(Linux) harms Linux,
+ * usually by causing the BIOS to follow paths that are
+ * not tested during Windows validation.
+ *
+ * Finally, there is a short list of platforms
+ * where OSI(Linux) benefits Linux.
+ *
+ * In Linux-2.6.23, OSI(Linux) is first disabled by default.
+ * DMI is used to disable the dmesg warning about OSI(Linux)
+ * on platforms where it is known to have no effect.
+ * But a dmesg warning remains for systems where
+ * we do not know if OSI(Linux) is good or bad for the system.
+ * DMI is also used to enable OSI(Linux) for the machines
+ * that are known to need it.
+ *
+ * BIOS writers should NOT query _OSI(Linux) on future systems.
+ * It will be ignored by default, and to get Linux to
+ * not ignore it will require a kernel source update to
+ * add a DMI entry, or a boot-time "acpi_osi=Linux" invocation.
+ */
+#define OSI_LINUX_ENABLE 0
+
+struct osi_linux {
+	unsigned int	enable:1;
+	unsigned int	dmi:1;
+	unsigned int	cmdline:1;
+	unsigned int	known:1;
+} osi_linux = { OSI_LINUX_ENABLE, 0, 0, 0};
 
 static void __init acpi_request_region (struct acpi_generic_address *addr,
 	unsigned int length, char *desc)
@@ -959,13 +1007,37 @@ static int __init acpi_os_name_setup(char *str)
 
 __setup("acpi_os_name=", acpi_os_name_setup);
 
-static void enable_osi_linux(int enable) {
+static void __init set_osi_linux(unsigned int enable)
+{
+	if (osi_linux.enable != enable) {
+		osi_linux.enable = enable;
+		printk(KERN_NOTICE PREFIX "%sed _OSI(Linux)\n",
+			enable ? "Add": "Delet");
+	}
+	return;
+}
+
+static void __init acpi_cmdline_osi_linux(unsigned int enable)
+{
+	osi_linux.cmdline = 1;	/* cmdline set the default */
+	set_osi_linux(enable);
+
+	return;
+}
+
+void __init acpi_dmi_osi_linux(int enable, const struct dmi_system_id *d)
+{
+	osi_linux.dmi = 1;	/* DMI knows that this box asks OSI(Linux) */
+
+	printk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);
+
+	if (enable == -1)
+		return;
+
+	osi_linux.known = 1;	/* DMI knows which OSI(Linux) default needed */
 
-	if (osi_linux != enable)
-		printk(KERN_INFO PREFIX "%sabled _OSI(Linux)\n",
-			enable ? "En": "Dis");
+	set_osi_linux(enable);
 
-	osi_linux = enable;
 	return;
 }
 
@@ -982,12 +1054,12 @@ static int __init acpi_osi_setup(char *str)
 		printk(KERN_INFO PREFIX "_OSI method disabled\n");
 		acpi_gbl_create_osi_method = FALSE;
 	} else if (!strcmp("!Linux", str)) {
-		enable_osi_linux(0);
+		acpi_cmdline_osi_linux(0);	/* !enable */
 	} else if (*str == '!') {
 		if (acpi_osi_invalidate(++str) == AE_OK)
 			printk(KERN_INFO PREFIX "Deleted _OSI(%s)\n", str);
 	} else if (!strcmp("Linux", str)) {
-		enable_osi_linux(1);
+		acpi_cmdline_osi_linux(1);	/* enable */
 	} else if (*osi_additional_string == '\0') {
 		strncpy(osi_additional_string, str, OSI_STRING_LENGTH_MAX);
 		printk(KERN_INFO PREFIX "Added _OSI(%s)\n", str);
@@ -1183,19 +1255,29 @@ acpi_os_validate_interface (char *interface)
 	if (!strncmp(osi_additional_string, interface, OSI_STRING_LENGTH_MAX))
 		return AE_OK;
 	if (!strcmp("Linux", interface)) {
-		printk(KERN_WARNING PREFIX
-			"System BIOS is requesting _OSI(Linux)\n");
-		if (acpi_dmi_dump())
-			printk(KERN_NOTICE PREFIX
-				"[please extract dmidecode output]\n");
-		printk(KERN_NOTICE PREFIX
-			"Please send DMI info above to "
-			"linux-acpi@vger.kernel.org\n");
+
 		printk(KERN_NOTICE PREFIX
-			"If \"acpi_osi=%sLinux\" works better, "
-			"please notify linux-acpi@vger.kernel.org\n",
-			osi_linux ? "!" : "");
-		if(osi_linux)
+			"BIOS _OSI(Linux) query %s%s\n",
+			osi_linux.enable ? "honored" : "ignored",
+			osi_linux.cmdline ? " via cmdline" :
+			osi_linux.dmi ? " via DMI" : "");
+
+		if (!osi_linux.dmi) {
+			if (acpi_dmi_dump())
+				printk(KERN_NOTICE PREFIX
+					"[please extract dmidecode output]\n");
+			printk(KERN_NOTICE PREFIX
+				"Please send DMI info above to "
+				"linux-acpi@vger.kernel.org\n");
+		}
+		if (!osi_linux.known && !osi_linux.cmdline) {
+			printk(KERN_NOTICE PREFIX
+				"If \"acpi_osi=%sLinux\" works better, "
+				"please notify linux-acpi@vger.kernel.org\n",
+				osi_linux.enable ? "!" : "");
+		}
+
+		if (osi_linux.enable)
 			return AE_OK;
 	}
 	return AE_SUPPORT;

commit 7ce95ce5c6dbbc3f70933f04537860ffd9dbe17e
Author: Len Brown <len.brown@intel.com>
Date:   Wed Jan 23 20:06:41 2008 -0500

    ACPI: Delete Intel Customer Reference Board (CRB) from OSI(Linux) DMI list
    
    Linux does not want BIOS writers to invoke _OSI(Linux) -
    for in the field it causes more Windows incompatibility problems
    than it solves.
    
    So when it is seen in the BIOS for an Intel Customer Reference Board,
    Linux should ignore its effect by default, and should complain loudly.
    Otherwise, the reference BIOS will go unfixed, and the bad BIOS
    will spread to the field.
    
    Users of this board can get the old behavior with "acpi_osi=Linux"
    
    As this was the only entry, delete acpi_osl_dmi_table[].
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 2203153b5402..15f095ea795e 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -79,10 +79,6 @@ static char osi_additional_string[OSI_STRING_LENGTH_MAX];
 
 static int osi_linux;		/* disable _OSI(Linux) by default */
 
-#ifdef CONFIG_DMI
-static struct __initdata dmi_system_id acpi_osl_dmi_table[];
-#endif
-
 static void __init acpi_request_region (struct acpi_generic_address *addr,
 	unsigned int length, char *desc)
 {
@@ -133,7 +129,6 @@ device_initcall(acpi_reserve_resources);
 
 acpi_status __init acpi_os_initialize(void)
 {
-	dmi_check_system(acpi_osl_dmi_table);
 	return AE_OK;
 }
 
@@ -1232,28 +1227,4 @@ acpi_os_validate_address (
     return AE_OK;
 }
 
-#ifdef CONFIG_DMI
-static int dmi_osi_linux(const struct dmi_system_id *d)
-{
-	printk(KERN_NOTICE "%s detected: enabling _OSI(Linux)\n", d->ident);
-	enable_osi_linux(1);
-	return 0;
-}
-
-static struct dmi_system_id acpi_osl_dmi_table[] __initdata = {
-	/*
-	 * Boxes that need _OSI(Linux)
-	 */
-	{
-	 .callback = dmi_osi_linux,
-	 .ident = "Intel Napa CRB",
-	 .matches = {
-		     DMI_MATCH(DMI_BOARD_VENDOR, "Intel Corporation"),
-		     DMI_MATCH(DMI_BOARD_NAME, "MPAD-MSAE Customer Reference Boards"),
-		     },
-	 },
-	{}
-};
-#endif /* CONFIG_DMI */
-
 #endif

commit f40cd6fddcb1d51d8a2a67ddc81c14a3532f3cb7
Author: Len Brown <len.brown@intel.com>
Date:   Wed Jan 23 20:04:28 2008 -0500

    ACPI: on OSI(Linux), print needed DMI rather than requesting dmidecode output
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 93ad5f40f2ea..2203153b5402 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1190,10 +1190,16 @@ acpi_os_validate_interface (char *interface)
 	if (!strcmp("Linux", interface)) {
 		printk(KERN_WARNING PREFIX
 			"System BIOS is requesting _OSI(Linux)\n");
-		printk(KERN_WARNING PREFIX
-			"If \"acpi_osi=Linux\" works better,\n"
-			"Please send dmidecode "
-			"to linux-acpi@vger.kernel.org\n");
+		if (acpi_dmi_dump())
+			printk(KERN_NOTICE PREFIX
+				"[please extract dmidecode output]\n");
+		printk(KERN_NOTICE PREFIX
+			"Please send DMI info above to "
+			"linux-acpi@vger.kernel.org\n");
+		printk(KERN_NOTICE PREFIX
+			"If \"acpi_osi=%sLinux\" works better, "
+			"please notify linux-acpi@vger.kernel.org\n",
+			osi_linux ? "!" : "");
 		if(osi_linux)
 			return AE_OK;
 	}

commit 5a4e143271b97dcaa113761a76942c4d4bc273a2
Author: Len Brown <len.brown@intel.com>
Date:   Wed Jan 23 20:01:22 2008 -0500

    ACPI: create acpi_dmi_dump()
    
    A utility routine to print common entries used
    for ACPI-related DMI blacklist entries.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e3a673a00845..93ad5f40f2ea 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1141,6 +1141,34 @@ acpi_status acpi_os_release_object(acpi_cache_t * cache, void *object)
 	return (AE_OK);
 }
 
+/**
+ *	acpi_dmi_dump - dump DMI slots needed for blacklist entry
+ *
+ *	Returns 0 on success
+ */
+int acpi_dmi_dump(void)
+{
+
+	if (!dmi_available)
+		return -1;
+
+	printk(KERN_NOTICE PREFIX "DMI System Vendor: %s\n",
+		dmi_get_slot(DMI_SYS_VENDOR));
+	printk(KERN_NOTICE PREFIX "DMI Product Name: %s\n",
+		dmi_get_slot(DMI_PRODUCT_NAME));
+	printk(KERN_NOTICE PREFIX "DMI Product Version: %s\n",
+		dmi_get_slot(DMI_PRODUCT_VERSION));
+	printk(KERN_NOTICE PREFIX "DMI Board Name: %s\n",
+		dmi_get_slot(DMI_BOARD_NAME));
+	printk(KERN_NOTICE PREFIX "DMI BIOS Vendor: %s\n",
+		dmi_get_slot(DMI_BIOS_VENDOR));
+	printk(KERN_NOTICE PREFIX "DMI BIOS Date: %s\n",
+		dmi_get_slot(DMI_BIOS_DATE));
+
+	return 0;
+}
+
+
 /******************************************************************************
  *
  * FUNCTION:    acpi_os_validate_interface

commit 239665a3bb0a2234980f918913add31bc536cfd1
Author: Len Brown <len.brown@intel.com>
Date:   Fri Nov 23 20:08:02 2007 -0500

    ACPI: tables: complete searching upon RSDP w/ bad checksum.
    
    ACPI tables follow a tree structure in memory.
    The root of the tree is the RSDP (Root System Description Pointer).
    
    To find the RSDP, the OS searches for the signature "RSD PTR "
    in well known physical memory locations.  Then the OS computes
    a table checksum to verify that the signature is really part
    of a valid table header.
    
    Some systems have a proper signature but an invalid checksum;
    followed elsewhere by a proper signature with valid checksum.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=9444
    
    The Linux RSDP scanning code bailed out on those systems
    and as a result they booted with ACPI disabled.
    
    Fix this by deleting the Linux RSDP scanning code and
    plugging in the ACPICA RSDP scanning code.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index aabc6ca4a81c..101691ef66cb 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -207,8 +207,12 @@ acpi_physical_address __init acpi_os_get_root_pointer(void)
 			       "System description tables not found\n");
 			return 0;
 		}
-	} else
-		return acpi_find_rsdp();
+	} else {
+		acpi_physical_address pa = 0;
+
+		acpi_find_root_pointer(&pa);
+		return pa;
+	}
 }
 
 void __iomem *acpi_os_map_memory(acpi_physical_address phys, acpi_size size)

commit 2fdf07417e57136cf6baedf9508e2169a059ebea
Author: Jan Beulich <jbeulich@novell.com>
Date:   Thu Dec 13 08:33:59 2007 +0000

    acpi: make __acpi_map_table() and __init function
    
    .. as it it used only during early boot.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    
     arch/ia64/kernel/acpi.c     |    2 +-
     arch/x86/kernel/acpi/boot.c |    4 ++--
     drivers/acpi/osl.c          |    3 ++-
     3 files changed, 5 insertions(+), 4 deletions(-)
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e3a673a00845..82525d9cccb0 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -211,7 +211,8 @@ acpi_physical_address __init acpi_os_get_root_pointer(void)
 		return acpi_find_rsdp();
 }
 
-void __iomem *acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
+void __iomem *__init_refok
+acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 {
 	if (phys > ULONG_MAX) {
 		printk(KERN_ERR PREFIX "Cannot map memory that high\n");

commit 17bc54eef91df29f0a22e8a1562a404cf7a68e74
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Tue Nov 13 13:05:45 2007 +0300

    ACPI: Defer enabling of level GPE until all pending notifies done
    
    Level GPE should not be enabled until all work caused by it is done,
    e.g. all Notify() methods are completed.
    This can be accomplished by appending enable_gpe function to the end
    of notify queue.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Acked-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e3a673a00845..21d34595dbae 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -618,25 +618,6 @@ static void acpi_os_execute_deferred(struct work_struct *work)
 	dpc->function(dpc->context);
 	kfree(dpc);
 
-	/* Yield cpu to notify thread */
-	cond_resched();
-
-	return;
-}
-
-static void acpi_os_execute_notify(struct work_struct *work)
-{
-	struct acpi_os_dpc *dpc = container_of(work, struct acpi_os_dpc, work);
-
-	if (!dpc) {
-		printk(KERN_ERR PREFIX "Invalid (NULL) context\n");
-		return;
-	}
-
-	dpc->function(dpc->context);
-
-	kfree(dpc);
-
 	return;
 }
 
@@ -660,7 +641,7 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 {
 	acpi_status status = AE_OK;
 	struct acpi_os_dpc *dpc;
-
+	struct workqueue_struct *queue;
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
 			  "Scheduling function [%p(%p)] for deferred execution.\n",
 			  function, context));
@@ -684,20 +665,13 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 	dpc->function = function;
 	dpc->context = context;
 
-	if (type == OSL_NOTIFY_HANDLER) {
-		INIT_WORK(&dpc->work, acpi_os_execute_notify);
-		if (!queue_work(kacpi_notify_wq, &dpc->work)) {
-			status = AE_ERROR;
-			kfree(dpc);
-		}
-	} else {
-		INIT_WORK(&dpc->work, acpi_os_execute_deferred);
-		if (!queue_work(kacpid_wq, &dpc->work)) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Call to queue_work() failed.\n"));
-			status = AE_ERROR;
-			kfree(dpc);
-		}
+	INIT_WORK(&dpc->work, acpi_os_execute_deferred);
+	queue = (type == OSL_NOTIFY_HANDLER) ? kacpi_notify_wq : kacpid_wq;
+	if (!queue_work(queue, &dpc->work)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			  "Call to queue_work() failed.\n"));
+		status = AE_ERROR;
+		kfree(dpc);
 	}
 	return_ACPI_STATUS(status);
 }

commit 49fbabf56dc715bbb51e59742e82ba762790aac0
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Thu Nov 15 17:01:06 2007 +0800

    ACPI: Handle I/O access width requestst that are not a multiple of 8 bits.
    
    We've run into BIOS that hand us 4-bit access width requests
    for T-state control when the code expected only multipls of 8-bits.
    Round up.
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index aabc6ca4a81c..e3a673a00845 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -387,17 +387,14 @@ acpi_status acpi_os_read_port(acpi_io_address port, u32 * value, u32 width)
 	if (!value)
 		value = &dummy;
 
-	switch (width) {
-	case 8:
+	*value = 0;
+	if (width <= 8) {
 		*(u8 *) value = inb(port);
-		break;
-	case 16:
+	} else if (width <= 16) {
 		*(u16 *) value = inw(port);
-		break;
-	case 32:
+	} else if (width <= 32) {
 		*(u32 *) value = inl(port);
-		break;
-	default:
+	} else {
 		BUG();
 	}
 
@@ -408,17 +405,13 @@ EXPORT_SYMBOL(acpi_os_read_port);
 
 acpi_status acpi_os_write_port(acpi_io_address port, u32 value, u32 width)
 {
-	switch (width) {
-	case 8:
+	if (width <= 8) {
 		outb(value, port);
-		break;
-	case 16:
+	} else if (width <= 16) {
 		outw(value, port);
-		break;
-	case 32:
+	} else if (width <= 32) {
 		outl(value, port);
-		break;
-	default:
+	} else {
 		BUG();
 	}
 

commit c4ec20717313daafba59225f812db89595952b83
Merge: ec2626815bf9 00a2b433557f
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Fri Oct 19 13:12:46 2007 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6: (41 commits)
      ACPICA: hw: Don't carry spinlock over suspend
      ACPICA: hw: remove use_lock flag from acpi_hw_register_{read, write}
      ACPI: cpuidle: port idle timer suspend/resume workaround to cpuidle
      ACPI: clean up acpi_enter_sleep_state_prep
      Hibernation: Make sure that ACPI is enabled in acpi_hibernation_finish
      ACPI: suppress uninitialized var warning
      cpuidle: consolidate 2.6.22 cpuidle branch into one patch
      ACPI: thinkpad-acpi: skip blanks before the data when parsing sysfs
      ACPI: AC: Add sysfs interface
      ACPI: SBS: Add sysfs alarm
      ACPI: SBS: Add ACPI_PROCFS around procfs handling code.
      ACPI: SBS: Add support for power_supply class (and sysfs)
      ACPI: SBS: Make SBS reads table-driven.
      ACPI: SBS: Simplify data structures in SBS
      ACPI: SBS: Split host controller (ACPI0001) from SBS driver (ACPI0002)
      ACPI: EC: Add new query handler to list head.
      ACPI: Add acpi_bus_generate_event4() function
      ACPI: Battery: add sysfs alarm
      ACPI: Battery: Add sysfs support
      ACPI: Battery: Misc clean-ups, no functional changes
      ...
    
    Fix up conflicts in drivers/misc/thinkpad_acpi.[ch] manually

commit 4f86d3a8e297205780cca027e974fd5f81064780
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 3 18:58:00 2007 -0400

    cpuidle: consolidate 2.6.22 cpuidle branch into one patch
    
    commit e5a16b1f9eec0af7cfa0830304b41c1c0833cf9f
    Author: Len Brown <len.brown@intel.com>
    Date:   Tue Oct 2 23:44:44 2007 -0400
    
        cpuidle: shrink diff
    
        processor_idle.c |  440 +++++++++++++++++++++++++++++++++++++++++--
        1 file changed, 429 insertions(+), 11 deletions(-)
    
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit dfbb9d5aedfb18848a3e0d6f6e3e4969febb209c
    Author: Len Brown <len.brown@intel.com>
    Date:   Wed Sep 26 02:17:55 2007 -0400
    
        cpuidle: reduce diff size
    
        Reduces the cpuidle processor_idle.c diff vs 2.6.22 from this
         processor_idle.c | 2006 ++++++++++++++++++++++++++-----------------
         1 file changed, 1219 insertions(+), 787 deletions(-)
    
        to this:
         processor_idle.c |  502 +++++++++++++++++++++++++++++++++++++++----
         1 file changed, 458 insertions(+), 44 deletions(-)
    
        ...for the purpose of making the cpuilde patch less invasive
        and easier to review.
    
        no functional changes.  build tested only.
    
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 889172fc915f5a7fe20f35b133cbd205ce69bf6c
    Author: Venki Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Thu Sep 13 13:40:05 2007 -0700
    
        cpuidle: Retain old ACPI policy for !CONFIG_CPU_IDLE
    
        Retain the old policy in processor_idle, so that when CPU_IDLE is not
        configured, old C-state policy will still be used. This provides a
        clean gradual migration path from old ACPI policy to new cpuidle
        based policy.
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 9544a8181edc7ecc33b3bfd69271571f98ed08bc
    Author: Venki Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Thu Sep 13 13:39:17 2007 -0700
    
        cpuidle: Configure governors by default
    
        Quoting Len "Do not give an option to users to shoot themselves in the foot".
    
        Remove the configurability of ladder and menu governors as they are
        needed for default policy of cpuidle. That way users will not be able to
        have cpuidle without any policy loosing all C-state power savings.
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 8975059a2c1e56cfe83d1bcf031bcf4cb39be743
    Author: Adam Belay <abelay@novell.com>
    Date:   Tue Aug 21 18:27:07 2007 -0400
    
        CPUIDLE: load ACPI properly when CPUIDLE is disabled
    
        Change the registration return codes for when CPUIDLE
        support is not compiled into the kernel.  As a result, the ACPI
        processor driver will load properly even if CPUIDLE is unavailable.
        However, it may be possible to cleanup the ACPI processor driver further
        and eliminate some dead code paths.
    
        Signed-off-by: Adam Belay <abelay@novell.com>
        Acked-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit e0322e2b58dd1b12ec669bf84693efe0dc2414a8
    Author: Adam Belay <abelay@novell.com>
    Date:   Tue Aug 21 18:26:06 2007 -0400
    
        CPUIDLE: remove cpuidle_get_bm_activity()
    
        Remove cpuidle_get_bm_activity() and updates governors
        accordingly.
    
        Signed-off-by: Adam Belay <abelay@novell.com>
        Acked-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 18a6e770d5c82ba26653e53d240caa617e09e9ab
    Author: Adam Belay <abelay@novell.com>
    Date:   Tue Aug 21 18:25:58 2007 -0400
    
        CPUIDLE: max_cstate fix
    
        Currently max_cstate is limited to 0, resulting in no idle processor
        power management on ACPI platforms.  This patch restores the value to
        the array size.
    
        Signed-off-by: Adam Belay <abelay@novell.com>
        Acked-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 1fdc0887286179b40ce24bcdbde663172e205ef0
    Author: Adam Belay <abelay@novell.com>
    Date:   Tue Aug 21 18:25:40 2007 -0400
    
        CPUIDLE: handle BM detection inside the ACPI Processor driver
    
        Update the ACPI processor driver to detect BM activity and
        limit state entry depth internally, rather than exposing such
        requirements to CPUIDLE.  As a result, CPUIDLE can drop this
        ACPI-specific interface and become more platform independent.  BM
        activity is now handled much more aggressively than it was in the
        original implementation, so some testing coverage may be needed to
        verify that this doesn't introduce any DMA buffer under-run issues.
    
        Signed-off-by: Adam Belay <abelay@novell.com>
        Acked-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 0ef38840db666f48e3cdd2b769da676c57228dd9
    Author: Adam Belay <abelay@novell.com>
    Date:   Tue Aug 21 18:25:14 2007 -0400
    
        CPUIDLE: menu governor updates
    
        Tweak the menu governor to more effectively handle non-timer
        break events.  Non-timer break events are detected by comparing the
        actual sleep time to the expected sleep time.  In future revisions, it
        may be more reliable to use the timer data structures directly.
    
        Signed-off-by: Adam Belay <abelay@novell.com>
        Acked-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit bb4d74fca63fa96cf3ace644b15ae0f12b7df5a1
    Author: Adam Belay <abelay@novell.com>
    Date:   Tue Aug 21 18:24:40 2007 -0400
    
        CPUIDLE: fix 'current_governor' sysfs entry
    
        Allow the "current_governor" sysfs entry to properly handle
        input terminated with '\n'.
    
        Signed-off-by: Adam Belay <abelay@novell.com>
        Acked-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit df3c71559bb69b125f1a48971bf0d17f78bbdf47
    Author: Len Brown <len.brown@intel.com>
    Date:   Sun Aug 12 02:00:45 2007 -0400
    
        cpuidle: fix IA64 build (again)
    
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit a02064579e3f9530fd31baae16b1fc46b5a7bca8
    Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Sun Aug 12 01:39:27 2007 -0400
    
        cpuidle: Remove support for runtime changing of max_cstate
    
        Remove support for runtime changeability of max_cstate. Drivers can use
        use latency APIs.
    
        max_cstate can still be used as a boot time option and dmi override.
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 0912a44b13adf22f5e3f607d263aed23b4910d7e
    Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Sun Aug 12 01:39:16 2007 -0400
    
        cpuidle: Remove ACPI cstate_limit calls from ipw2100
    
        ipw2100 already has code to use accetable_latency interfaces to limit the
        C-state. Remove the calls to acpi_set_cstate_limit and acpi_get_cstate_limit
        as they are redundant.
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit c649a76e76be6bff1fd770d0a775798813a3f6e0
    Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Sun Aug 12 01:35:39 2007 -0400
    
        cpuidle: compile fix for pause and resume functions
    
        Fix the compilation failure when cpuidle is not compiled in.
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Acked-by: Adam Belay <adam.belay@novell.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 2305a5920fb8ee6ccec1c62ade05aa8351091d71
    Author: Adam Belay <abelay@novell.com>
    Date:   Thu Jul 19 00:49:00 2007 -0400
    
        cpuidle: re-write
    
        Some portions have been rewritten to make the code cleaner and lighter
        weight.  The following is a list of changes:
    
        1.) the state name is now included in the sysfs interface
        2.) detection, hotplug, and available state modifications are handled by
        CPUIDLE drivers directly
        3.) the CPUIDLE idle handler is only ever installed when at least one
        cpuidle_device is enabled and ready
        4.) the menu governor BM code no longer overflows
        5.) the sysfs attributes are now printed as unsigned integers, avoiding
        negative values
        6.) a variety of other small cleanups
    
        Also, Idle drivers are no longer swappable during runtime through the
        CPUIDLE sysfs inteface.  On i386 and x86_64 most idle handlers (e.g.
        poll, mwait, halt, etc.) don't benefit from an infrastructure that
        supports multiple states, so I think using a more general case idle
        handler selection mechanism would be cleaner.
    
        Signed-off-by: Adam Belay <abelay@novell.com>
        Acked-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Acked-by: Shaohua Li <shaohua.li@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit df25b6b56955714e6e24b574d88d1fd11f0c3ee5
    Author: Len Brown <len.brown@intel.com>
    Date:   Tue Jul 24 17:08:21 2007 -0400
    
        cpuidle: fix IA64 buid
    
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit fd6ada4c14488755ff7068860078c437431fbccd
    Author: Adrian Bunk <bunk@stusta.de>
    Date:   Mon Jul 9 11:33:13 2007 -0700
    
        cpuidle: static
    
        make cpuidle_replace_governor() static
    
        Signed-off-by: Adrian Bunk <bunk@stusta.de>
        Cc: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit c1d4a2cebcadf2429c0c72e1d29aa2a9684c32e0
    Author: Adrian Bunk <bunk@stusta.de>
    Date:   Tue Jul 3 00:54:40 2007 -0400
    
        cpuidle: static
    
        This patch makes the needlessly global struct menu_governor static.
    
        Signed-off-by: Adrian Bunk <bunk@stusta.de>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit dbf8780c6e8d572c2c273da97ed1cca7608fd999
    Author: Andrew Morton <akpm@linux-foundation.org>
    Date:   Tue Jul 3 00:49:14 2007 -0400
    
        export symbol tick_nohz_get_sleep_length
    
        ERROR: "tick_nohz_get_sleep_length" [drivers/cpuidle/governors/menu.ko] undefined!
        ERROR: "tick_nohz_get_idle_jiffies" [drivers/cpuidle/governors/menu.ko] undefined!
    
        And please be sure to get your changes to core kernel suitably reviewed.
    
        Cc: Adam Belay <abelay@novell.com>
        Cc: Venki Pallipadi <venkatesh.pallipadi@intel.com>
        Cc: Ingo Molnar <mingo@elte.hu>
        Cc: Thomas Gleixner <tglx@linutronix.de>
        Cc: john stultz <johnstul@us.ibm.com>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 29f0e248e7017be15f99febf9143a2cef00b2961
    Author: Andrew Morton <akpm@linux-foundation.org>
    Date:   Tue Jul 3 00:43:04 2007 -0400
    
        tick.h needs hrtimer.h
    
        It uses hrtimers.
    
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit e40cede7d63a029e92712a3fe02faee60cc38fb4
    Author: Venki Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Tue Jul 3 00:40:34 2007 -0400
    
        cpuidle: first round of documentation updates
    
        Documentation changes based on Pavel's feedback.
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 83b42be2efece386976507555c29e7773a0dfcd1
    Author: Venki Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Tue Jul 3 00:39:25 2007 -0400
    
        cpuidle: add rating to the governors and pick the one with highest rating by default
    
        Introduce a governor rating scheme to pick the right governor by default.
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit d2a74b8c5e8f22def4709330d4bfc4a29209b71c
    Author: Venki Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Tue Jul 3 00:38:08 2007 -0400
    
        cpuidle: make cpuidle sysfs driver governor switch off by default
    
        Make default cpuidle sysfs to show current_governor and current_driver in
        read-only mode.  More elaborate available_governors and available_drivers with
        writeable current_governor and current_driver interface only appear with
        "cpuidle_sysfs_switch" boot parameter.
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 1f60a0e80bf83cf6b55c8845bbe5596ed8f6307b
    Author: Venki Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Tue Jul 3 00:37:00 2007 -0400
    
        cpuidle: menu governor: change the early break condition
    
        Change the C-state early break out algorithm in menu governor.
    
        We only look at early breakouts that result in wakeups shorter than idle
        state's target_residency.  If such a breakout is frequent enough, eliminate
        the particular idle state upto a timeout period.
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 45a42095cf64b003b4a69be3ce7f434f97d7af51
    Author: Venki Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Tue Jul 3 00:35:38 2007 -0400
    
        cpuidle: fix uninitialized variable in sysfs routine
    
        Fix the uninitialized usage of ret.
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 80dca7cdba3e6ee13eae277660873ab9584eb3be
    Author: Venki Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Tue Jul 3 00:34:16 2007 -0400
    
        cpuidle: reenable /proc/acpi//power interface for the time being
    
        Keep /proc/acpi/processor/CPU*/power around for a while as powertop depends
        on it. It will be marked deprecated and removed in future. powertop can use
        cpuidle interfaces instead.
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 589c37c2646c5e3813a51255a5ee1159cb4c33fc
    Author: Venki Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Tue Jul 3 00:32:37 2007 -0400
    
        cpuidle: menu governor and hrtimer compile fix
    
        Compile fix for menu governor.
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 0ba80bd9ab3ed304cb4f19b722e4cc6740588b5e
    Author: Len Brown <len.brown@intel.com>
    Date:   Thu May 31 22:51:43 2007 -0400
    
        cpuidle: build fix - cpuidle vs ipw2100 module
    
        ERROR: "acpi_set_cstate_limit" [drivers/net/wireless/ipw2100.ko] undefined!
    
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit d7d8fa7f96a7f7682be7c6cc0cc53fa7a18c3b58
    Author: Adam Belay <abelay@novell.com>
    Date:   Sat Mar 24 03:47:07 2007 -0400
    
        cpuidle: add the 'menu' governor
    
        Here is my first take at implementing an idle PM governor that takes
        full advantage of NO_HZ.  I call it the 'menu' governor because it
        considers the full list of idle states before each entry.
    
        I've kept the implementation fairly simple.  It attempts to guess the
        next residency time and then chooses a state that would meet at least
        the break-even point between power savings and entry cost.  To this end,
        it selects the deepest idle state that satisfies the following
        constraints:
             1. If the idle time elapsed since bus master activity was detected
                is below a threshold (currently 20 ms), then limit the selection
                to C2-type or above.
             2. Do not choose a state with a break-even residency that exceeds
                the expected time remaining until the next timer interrupt.
             3. Do not choose a state with a break-even residency that exceeds
                the elapsed time between the last pair of break events,
                excluding timer interrupts.
    
        This governor has an advantage over "ladder" governor because it
        proactively checks how much time remains until the next timer interrupt
        using the tick infrastructure.  Also, it handles device interrupt
        activity more intelligently by not including timer interrupts in break
        event calculations.  Finally, it doesn't make policy decisions using the
        number of state entries, which can have variable residency times (NO_HZ
        makes these potentially very large), and instead only considers sleep
        time deltas.
    
        The menu governor can be selected during runtime using the cpuidle sysfs
        interface like so:
        "echo "menu" > /sys/devices/system/cpu/cpuidle/current_governor"
    
        Signed-off-by: Adam Belay <abelay@novell.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit a4bec7e65aa3b7488b879d971651cc99a6c410fe
    Author: Adam Belay <abelay@novell.com>
    Date:   Sat Mar 24 03:47:03 2007 -0400
    
        cpuidle: export time until next timer interrupt using NO_HZ
    
        Expose information about the time remaining until the next
        timer interrupt expires by utilizing the dynticks infrastructure.
        Also modify the main idle loop to allow dynticks to handle
        non-interrupt break events (e.g. DMA).  Finally, expose sleep ticks
        information to external code.  Thomas Gleixner is responsible for much
        of the code in this patch.  However, I've made some additional changes,
        so I'm probably responsible if there are any bugs or oversights :)
    
        Signed-off-by: Adam Belay <abelay@novell.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 2929d8996fbc77f41a5ff86bb67cdde3ca7d2d72
    Author: Adam Belay <abelay@novell.com>
    Date:   Sat Mar 24 03:46:58 2007 -0400
    
        cpuidle: governor API changes
    
        This patch prepares cpuidle for the menu governor.  It adds an optional
        stage after idle state entry to give the governor an opportunity to
        check why the state was exited.  Also it makes sure the idle loop
        returns after each state entry, allowing the appropriate dynticks code
        to run.
    
        Signed-off-by: Adam Belay <abelay@novell.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 3a7fd42f9825c3b03e364ca59baa751bb350775f
    Author: Venki Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Thu Apr 26 00:03:59 2007 -0700
    
        cpuidle: hang fix
    
        Prevent hang on x86-64, when ACPI processor driver is added as a module on
        a system that does not support C-states.
    
        x86-64 expects all idle handlers to enable interrupts before returning from
        idle handler.  This is due to enter_idle(), exit_idle() races.  Make
        cpuidle_idle_call() confirm to this when there is no pm_idle_old.
    
        Also, cpuidle look at the return values of attch_driver() and set
        current_driver to NULL if attach fails on all CPUs.
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 4893339a142afbd5b7c01ffadfd53d14746e858e
    Author: Shaohua Li <shaohua.li@intel.com>
    Date:   Thu Apr 26 10:40:09 2007 +0800
    
        cpuidle: add support for max_cstate limit
    
        With CPUIDLE framework, the max_cstate (to limit max cpu c-state)
        parameter is ingored. Some systems require it to ignore C2/C3
        and some drivers like ipw require it too.
    
        Signed-off-by: Shaohua Li <shaohua.li@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 43bbbbe1cb998cbd2df656f55bb3bfe30f30e7d1
    Author: Shaohua Li <shaohua.li@intel.com>
    Date:   Thu Apr 26 10:40:13 2007 +0800
    
        cpuidle: add cpuidle_fore_redetect_devices API
    
        add cpuidle_force_redetect_devices API,
        which forces all CPU redetect idle states.
        Next patch will use it.
    
        Signed-off-by: Shaohua Li <shaohua.li@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit d1edadd608f24836def5ec483d2edccfb37b1d19
    Author: Shaohua Li <shaohua.li@intel.com>
    Date:   Thu Apr 26 10:40:01 2007 +0800
    
        cpuidle: fix sysfs related issue
    
        Fix the cpuidle sysfs issue.
        a. make kobject dynamicaly allocated
        b. fixed sysfs init issue to avoid suspend/resume issue
    
        Signed-off-by: Shaohua Li <shaohua.li@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 7169a5cc0d67b263978859672e86c13c23a5570d
    Author: Randy Dunlap <randy.dunlap@oracle.com>
    Date:   Wed Mar 28 22:52:53 2007 -0400
    
        cpuidle: 1-bit field must be unsigned
    
        A 1-bit bitfield has no room for a sign bit.
        drivers/cpuidle/governors/ladder.c:54:16: error: dubious bitfield without explicit `signed' or `unsigned'
    
        Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
        Cc: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 4658620158dc2fbd9e4bcb213c5b6fb5d05ba7d4
    Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Wed Mar 28 22:52:41 2007 -0400
    
        cpuidle: fix boot hang
    
        Patch for cpuidle boot hang reported by Larry Finger here.
        http://www.ussg.iu.edu/hypermail/linux/kernel/0703.2/2025.html
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Cc: Larry Finger <larry.finger@lwfinger.net>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit c17e168aa6e5fe3851baaae8df2fbc1cf11443a9
    Author: Len Brown <len.brown@intel.com>
    Date:   Wed Mar 7 04:37:53 2007 -0500
    
        cpuidle: ladder does not depend on ACPI
    
        build fix for CONFIG_ACPI=n
    
        In file included from drivers/cpuidle/governors/ladder.c:21:
        include/acpi/processor.h:88: error: expected specifier-qualifier-list before âacpi_integerâ
        include/acpi/processor.h:106: error: expected specifier-qualifier-list before âacpi_integerâ
        include/acpi/processor.h:168: error: expected specifier-qualifier-list before âacpi_handleâ
    
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 8c91d958246bde68db0c3f0c57b535962ce861cb
    Author: Adrian Bunk <bunk@stusta.de>
    Date:   Tue Mar 6 02:29:40 2007 -0800
    
        cpuidle: make code static
    
        This patch makes the following needlessly global code static:
        - driver.c: __cpuidle_find_driver()
        - governor.c: __cpuidle_find_governor()
        - ladder.c: struct ladder_governor
    
        Signed-off-by: Adrian Bunk <bunk@stusta.de>
        Cc: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Cc: Adam Belay <abelay@novell.com>
        Cc: Shaohua Li <shaohua.li@intel.com>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 0c39dc3187094c72c33ab65a64d2017b21f372d2
    Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Wed Mar 7 02:38:22 2007 -0500
    
        cpu_idle: fix build break
    
        This patch fixes a build breakage with !CONFIG_HOTPLUG_CPU and
        CONFIG_CPU_IDLE.
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Adrian Bunk <bunk@stusta.de>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 8112e3b115659b07df340ef170515799c0105f82
    Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Tue Mar 6 02:29:39 2007 -0800
    
        cpuidle: build fix for !CPU_IDLE
    
        Fix the compile issues when CPU_IDLE is not configured.
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Cc: Adam Belay <abelay@novell.com>
        Cc: Shaohua Li <shaohua.li@intel.com>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 1eb4431e9599cd25e0d9872f3c2c8986821839dd
    Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Thu Feb 22 13:54:57 2007 -0800
    
        cpuidle take2: Basic documentation for cpuidle
    
        Documentation for cpuidle infrastructure
    
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Adam Belay <abelay@novell.com>
        Signed-off-by: Shaohua Li <shaohua.li@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit ef5f15a8b79123a047285ec2e3899108661df779
    Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Thu Feb 22 13:54:03 2007 -0800
    
        cpuidle take2: Hookup ACPI C-states driver with cpuidle
    
        Hookup ACPI C-states onto generic cpuidle infrastructure.
    
        drivers/acpi/procesor_idle.c is now a ACPI C-states driver that registers as
        a driver in cpuidle infrastructure and the policy part is removed from
        drivers/acpi/processor_idle.c. We use governor in cpuidle instead.
    
        Signed-off-by: Shaohua Li <shaohua.li@intel.com>
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Adam Belay <abelay@novell.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    commit 987196fa82d4db52c407e8c9d5dec884ba602183
    Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Thu Feb 22 13:52:57 2007 -0800
    
        cpuidle take2: Core cpuidle infrastructure
    
        Announcing 'cpuidle', a new CPU power management infrastructure to manage
        idle CPUs in a clean and efficient manner.
        cpuidle separates out the drivers that can provide support for multiple types
        of idle states and policy governors that decide on what idle state to use
        at run time.
        A cpuidle driver can support multiple idle states based on parameters like
        varying power consumption, wakeup latency, etc (ACPI C-states for example).
        A cpuidle governor can be usage model specific (laptop, server,
        laptop on battery etc).
        Main advantage of the infrastructure being, it allows independent development
        of drivers and governors and allows for better CPU power management.
    
        A huge thanks to Adam Belay and Shaohua Li who were part of this mini-project
        since its beginning and are greatly responsible for this patchset.
    
        This patch:
    
        Core cpuidle infrastructure.
        Introduces a new abstraction layer for cpuidle:
        * which manages drivers that can support multiple idles states. Drivers
          can be generic or particular to specific hardware/platform
        * allows pluging in multiple policy governors that can take idle state policy
          decision
        * The core also has a set of sysfs interfaces with which administrato can know
          about supported drivers and governors and switch them at run time.
    
        Signed-off-by: Adam Belay <abelay@novell.com>
        Signed-off-by: Shaohua Li <shaohua.li@intel.com>
        Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 12c09fafce9a..5d14d4f10b12 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1042,14 +1042,6 @@ static int __init acpi_wake_gpes_always_on_setup(char *str)
 
 __setup("acpi_wake_gpes_always_on", acpi_wake_gpes_always_on_setup);
 
-/*
- * max_cstate is defined in the base kernel so modules can
- * change it w/o depending on the state of the processor module.
- */
-unsigned int max_cstate = ACPI_PROCESSOR_MAX_POWER;
-
-EXPORT_SYMBOL(max_cstate);
-
 /*
  * Acquire a spinlock.
  *

commit 1855256c497ecfefc730df6032243f26855ce52c
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Oct 3 15:15:40 2007 -0400

    drivers/firmware: const-ify DMI API and internals
    
    Three main sets of changes:
    
    1) dmi_get_system_info() return value should have been marked const,
       since callers should not be changing that data.
    
    2) const-ify DMI internals, since DMI firmware tables should,
       whenever possible, be marked const to ensure we never ever write to
       that data area.
    
    3) const-ify DMI API, to enable marking tables const where possible
       in low-level drivers.
    
    And if we're really lucky, this might enable some additional
    optimizations on the part of the compiler.
    
    The bulk of the changes are #2 and #3, which are interrelated.  #1 could
    have been a separate patch, but it was so small compared to the others,
    it was easier to roll it into this changeset.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 12c09fafce9a..352cf81af581 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1214,7 +1214,7 @@ acpi_os_validate_address (
 }
 
 #ifdef CONFIG_DMI
-static int dmi_osi_linux(struct dmi_system_id *d)
+static int dmi_osi_linux(const struct dmi_system_id *d)
 {
 	printk(KERN_NOTICE "%s detected: enabling _OSI(Linux)\n", d->ident);
 	enable_osi_linux(1);

commit b4b613fd83853f8c688b3de20ab1a42331257975
Merge: 5e16e3f0e24d 3c6394c5bd04
Author: Len Brown <len.brown@intel.com>
Date:   Sun Jul 22 02:29:41 2007 -0400

    Pull osi into release branch

commit 20c2df83d25c6a95affe6157a4c9cac4cf5ffaac
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jul 20 10:11:58 2007 +0900

    mm: Remove slab destructors from kmem_cache_create().
    
    Slab destructors were no longer supported after Christoph's
    c59def9f222d44bb7e2f0a559f2906191a0862d7 change. They've been
    BUGs for both slab and slub, and slob never supported them
    either.
    
    This rips out support for the dtor pointer from kmem_cache_create()
    completely and fixes up every single callsite in the kernel (there were
    about 224, not including the slab allocator definitions themselves,
    or the documentation references).
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 2e7ba615d760..00d53c2fd1e8 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1098,7 +1098,7 @@ void acpi_os_release_lock(acpi_spinlock lockp, acpi_cpu_flags flags)
 acpi_status
 acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)
 {
-	*cache = kmem_cache_create(name, size, 0, 0, NULL, NULL);
+	*cache = kmem_cache_create(name, size, 0, 0, NULL);
 	if (*cache == NULL)
 		return AE_ERROR;
 	else

commit 3312111d1bd1a409892031f7979c57a52b01185c
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Jul 3 00:56:05 2007 -0400

    ACPI: static
    
    make the needlessly global osi_linux static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 3f244eb99e04..5cfb7b5cc0b8 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -77,7 +77,7 @@ static struct workqueue_struct *kacpi_notify_wq;
 #define	OSI_STRING_LENGTH_MAX 64	/* arbitrary */
 static char osi_additional_string[OSI_STRING_LENGTH_MAX];
 
-int osi_linux;		/* disable _OSI(Linux) by default */
+static int osi_linux;		/* disable _OSI(Linux) by default */
 
 #ifdef CONFIG_DMI
 static struct __initdata dmi_system_id acpi_osl_dmi_table[];

commit aa2e09da2a332e748532aa2a71b090e7e7c3203d
Author: Len Brown <lenb@kernel.org>
Date:   Mon Jul 2 23:57:45 2007 -0400

    ACPI: fix acpi_osi=!Linux
    
    Need to check for special case "acpi_osi=!Linux" before handling the
    general case "acpi_osi=!*", or it will have no effect.
    
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 58ceb18ec997..2e7ba615d760 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -999,11 +999,11 @@ static int __init acpi_osi_setup(char *str)
 	if (str == NULL || *str == '\0') {
 		printk(KERN_INFO PREFIX "_OSI method disabled\n");
 		acpi_gbl_create_osi_method = FALSE;
+	} else if (!strcmp("!Linux", str)) {
+		enable_osi_linux(0);
 	} else if (*str == '!') {
 		if (acpi_osi_invalidate(++str) == AE_OK)
 			printk(KERN_INFO PREFIX "Deleted _OSI(%s)\n", str);
-	} else if (!strcmp("!Linux", str)) {
-		enable_osi_linux(0);
 	} else if (!strcmp("Linux", str)) {
 		enable_osi_linux(1);
 	} else if (*osi_additional_string == '\0') {

commit 072971d7d3e70ddac5c5be3436d929470cc2b3fb
Author: Len Brown <len.brown@intel.com>
Date:   Sat Jun 9 01:42:00 2007 -0400

    ACPI: disable _OSI(Linux) by default
    
    In Linux-2.6.22 we expanded the boot parameter osi=
    so that it can enable and !enable an OSI string.
    
    _OSI(Linux) is a special case because we know that there
    are both systems that require it set, and systems
    require that it _not_ to be set.  In the long term it can't
    be set, for the same reason _OS(Linux) can't be enabled --
    it tends to confuse BIOS that are not properly
    validated with Linux.  Further, the semantics and version
    information of _OSI(Linux) were never actually defined.
    
    The kernel prints out a message if it sees _OSI(Linux)
    requested, and there is a DMI workaround to invoke
    "osi=Linux" automatically for existing systems that need it.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=7787
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 58ceb18ec997..3f244eb99e04 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -77,13 +77,7 @@ static struct workqueue_struct *kacpi_notify_wq;
 #define	OSI_STRING_LENGTH_MAX 64	/* arbitrary */
 static char osi_additional_string[OSI_STRING_LENGTH_MAX];
 
-#define OSI_LINUX_ENABLED
-#ifdef	OSI_LINUX_ENABLED
-int osi_linux = 1;	/* enable _OSI(Linux) by default */
-#else
 int osi_linux;		/* disable _OSI(Linux) by default */
-#endif
-
 
 #ifdef CONFIG_DMI
 static struct __initdata dmi_system_id acpi_osl_dmi_table[];
@@ -1183,17 +1177,10 @@ acpi_os_validate_interface (char *interface)
 	if (!strcmp("Linux", interface)) {
 		printk(KERN_WARNING PREFIX
 			"System BIOS is requesting _OSI(Linux)\n");
-#ifdef	OSI_LINUX_ENABLED
-		printk(KERN_WARNING PREFIX
-			"Please test with \"acpi_osi=!Linux\"\n"
-			"Please send dmidecode "
-			"to linux-acpi@vger.kernel.org\n");
-#else
 		printk(KERN_WARNING PREFIX
 			"If \"acpi_osi=Linux\" works better,\n"
 			"Please send dmidecode "
 			"to linux-acpi@vger.kernel.org\n");
-#endif
 		if(osi_linux)
 			return AE_OK;
 	}
@@ -1227,36 +1214,14 @@ acpi_os_validate_address (
 }
 
 #ifdef CONFIG_DMI
-#ifdef	OSI_LINUX_ENABLED
-static int dmi_osi_not_linux(struct dmi_system_id *d)
-{
-	printk(KERN_NOTICE "%s detected: requires not _OSI(Linux)\n", d->ident);
-	enable_osi_linux(0);
-	return 0;
-}
-#else
 static int dmi_osi_linux(struct dmi_system_id *d)
 {
-	printk(KERN_NOTICE "%s detected: requires _OSI(Linux)\n", d->ident);
+	printk(KERN_NOTICE "%s detected: enabling _OSI(Linux)\n", d->ident);
 	enable_osi_linux(1);
 	return 0;
 }
-#endif
 
 static struct dmi_system_id acpi_osl_dmi_table[] __initdata = {
-#ifdef	OSI_LINUX_ENABLED
-	/*
-	 * Boxes that need NOT _OSI(Linux)
-	 */
-	{
-	 .callback = dmi_osi_not_linux,
-	 .ident = "Toshiba Satellite P100",
-	 .matches = {
-		     DMI_MATCH(DMI_BOARD_VENDOR, "TOSHIBA"),
-		     DMI_MATCH(DMI_BOARD_NAME, "Satellite P100"),
-		     },
-	 },
-#else
 	/*
 	 * Boxes that need _OSI(Linux)
 	 */
@@ -1268,7 +1233,6 @@ static struct dmi_system_id acpi_osl_dmi_table[] __initdata = {
 		     DMI_MATCH(DMI_BOARD_NAME, "MPAD-MSAE Customer Reference Boards"),
 		     },
 	 },
-#endif
 	{}
 };
 #endif /* CONFIG_DMI */

commit dd272b5716a54afa33a69f2241284d8ec60b7892
Author: Len Brown <len.brown@intel.com>
Date:   Wed May 30 00:26:11 2007 -0400

    ACPI: add __init to acpi_initialize_subsystem()
    
    Add __init to:
    acpi_initialize_subsystem() (and un-export it)
    acpi_os_initialize()
    
    Add __initdata to:
    acpi_osl_dmi_table[]
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e349879d9246..58ceb18ec997 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -86,7 +86,7 @@ int osi_linux;		/* disable _OSI(Linux) by default */
 
 
 #ifdef CONFIG_DMI
-static struct dmi_system_id acpi_osl_dmi_table[];
+static struct __initdata dmi_system_id acpi_osl_dmi_table[];
 #endif
 
 static void __init acpi_request_region (struct acpi_generic_address *addr,
@@ -137,7 +137,7 @@ static int __init acpi_reserve_resources(void)
 }
 device_initcall(acpi_reserve_resources);
 
-acpi_status acpi_os_initialize(void)
+acpi_status __init acpi_os_initialize(void)
 {
 	dmi_check_system(acpi_osl_dmi_table);
 	return AE_OK;
@@ -1243,7 +1243,7 @@ static int dmi_osi_linux(struct dmi_system_id *d)
 }
 #endif
 
-static struct dmi_system_id acpi_osl_dmi_table[] = {
+static struct dmi_system_id acpi_osl_dmi_table[] __initdata = {
 #ifdef	OSI_LINUX_ENABLED
 	/*
 	 * Boxes that need NOT _OSI(Linux)

commit f507654d450d329c81a70eec0096d5dfe67802ec
Author: Len Brown <len.brown@intel.com>
Date:   Wed May 30 00:10:38 2007 -0400

    ACPI: Make _OSI(Linux) a special case
    
    _OSI("Linux") is like _OS("Linux"), it is ill-defined and
    virtually no BIOS vendors test interaction with it.
    As a result, it can do more damage than good because
    it causes the BIOS to follow un-tested paths.
    
    Recently, several machines have turned up that erroneously
    test this string in a way which causes them to _not_ test other
    compatibility strings, including the ZI9 and Toshiba.
    So it appears that this bad code has made it into
    a BIOS vendor's reference BIOS.
    
    Linux has no choice but to stop advertising compatibility
    with _OSI string "Linux" - as there are an unbounded
    number of possible incompatibilities going forward.
    
    But some BIOSes have already shipped which do use it
    for things like conditionally re-enabling video on resume
    from S3.  (Too bad they didn't do that unconditionally)
    
    Add special case code for _OSI(Linux)
    Squawk to dmesg if _OSI(Linux) is requested
    Add DMI list both to enable and disable _OSI(Linux)
    But for now, keep the default enabled via
    #define OSI_LINUX_ENABLED.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=7787
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index f4760cfa61e1..e349879d9246 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -33,6 +33,7 @@
 #include <linux/interrupt.h>
 #include <linux/kmod.h>
 #include <linux/delay.h>
+#include <linux/dmi.h>
 #include <linux/workqueue.h>
 #include <linux/nmi.h>
 #include <linux/acpi.h>
@@ -76,6 +77,18 @@ static struct workqueue_struct *kacpi_notify_wq;
 #define	OSI_STRING_LENGTH_MAX 64	/* arbitrary */
 static char osi_additional_string[OSI_STRING_LENGTH_MAX];
 
+#define OSI_LINUX_ENABLED
+#ifdef	OSI_LINUX_ENABLED
+int osi_linux = 1;	/* enable _OSI(Linux) by default */
+#else
+int osi_linux;		/* disable _OSI(Linux) by default */
+#endif
+
+
+#ifdef CONFIG_DMI
+static struct dmi_system_id acpi_osl_dmi_table[];
+#endif
+
 static void __init acpi_request_region (struct acpi_generic_address *addr,
 	unsigned int length, char *desc)
 {
@@ -126,6 +139,7 @@ device_initcall(acpi_reserve_resources);
 
 acpi_status acpi_os_initialize(void)
 {
+	dmi_check_system(acpi_osl_dmi_table);
 	return AE_OK;
 }
 
@@ -963,6 +977,16 @@ static int __init acpi_os_name_setup(char *str)
 
 __setup("acpi_os_name=", acpi_os_name_setup);
 
+static void enable_osi_linux(int enable) {
+
+	if (osi_linux != enable)
+		printk(KERN_INFO PREFIX "%sabled _OSI(Linux)\n",
+			enable ? "En": "Dis");
+
+	osi_linux = enable;
+	return;
+}
+
 /*
  * Modify the list of "OS Interfaces" reported to BIOS via _OSI
  *
@@ -978,6 +1002,10 @@ static int __init acpi_osi_setup(char *str)
 	} else if (*str == '!') {
 		if (acpi_osi_invalidate(++str) == AE_OK)
 			printk(KERN_INFO PREFIX "Deleted _OSI(%s)\n", str);
+	} else if (!strcmp("!Linux", str)) {
+		enable_osi_linux(0);
+	} else if (!strcmp("Linux", str)) {
+		enable_osi_linux(1);
 	} else if (*osi_additional_string == '\0') {
 		strncpy(osi_additional_string, str, OSI_STRING_LENGTH_MAX);
 		printk(KERN_INFO PREFIX "Added _OSI(%s)\n", str);
@@ -1152,6 +1180,23 @@ acpi_os_validate_interface (char *interface)
 {
 	if (!strncmp(osi_additional_string, interface, OSI_STRING_LENGTH_MAX))
 		return AE_OK;
+	if (!strcmp("Linux", interface)) {
+		printk(KERN_WARNING PREFIX
+			"System BIOS is requesting _OSI(Linux)\n");
+#ifdef	OSI_LINUX_ENABLED
+		printk(KERN_WARNING PREFIX
+			"Please test with \"acpi_osi=!Linux\"\n"
+			"Please send dmidecode "
+			"to linux-acpi@vger.kernel.org\n");
+#else
+		printk(KERN_WARNING PREFIX
+			"If \"acpi_osi=Linux\" works better,\n"
+			"Please send dmidecode "
+			"to linux-acpi@vger.kernel.org\n");
+#endif
+		if(osi_linux)
+			return AE_OK;
+	}
 	return AE_SUPPORT;
 }
 
@@ -1181,5 +1226,51 @@ acpi_os_validate_address (
     return AE_OK;
 }
 
+#ifdef CONFIG_DMI
+#ifdef	OSI_LINUX_ENABLED
+static int dmi_osi_not_linux(struct dmi_system_id *d)
+{
+	printk(KERN_NOTICE "%s detected: requires not _OSI(Linux)\n", d->ident);
+	enable_osi_linux(0);
+	return 0;
+}
+#else
+static int dmi_osi_linux(struct dmi_system_id *d)
+{
+	printk(KERN_NOTICE "%s detected: requires _OSI(Linux)\n", d->ident);
+	enable_osi_linux(1);
+	return 0;
+}
+#endif
+
+static struct dmi_system_id acpi_osl_dmi_table[] = {
+#ifdef	OSI_LINUX_ENABLED
+	/*
+	 * Boxes that need NOT _OSI(Linux)
+	 */
+	{
+	 .callback = dmi_osi_not_linux,
+	 .ident = "Toshiba Satellite P100",
+	 .matches = {
+		     DMI_MATCH(DMI_BOARD_VENDOR, "TOSHIBA"),
+		     DMI_MATCH(DMI_BOARD_NAME, "Satellite P100"),
+		     },
+	 },
+#else
+	/*
+	 * Boxes that need _OSI(Linux)
+	 */
+	{
+	 .callback = dmi_osi_linux,
+	 .ident = "Intel Napa CRB",
+	 .matches = {
+		     DMI_MATCH(DMI_BOARD_VENDOR, "Intel Corporation"),
+		     DMI_MATCH(DMI_BOARD_NAME, "MPAD-MSAE Customer Reference Boards"),
+		     },
+	 },
+#endif
+	{}
+};
+#endif /* CONFIG_DMI */
 
 #endif

commit ae00d812436dc968f4a5dea7757b6a94910b6dc4
Author: Len Brown <len.brown@intel.com>
Date:   Tue May 29 18:43:33 2007 -0400

    ACPI: extend "acpi_osi=" boot option
    
    The boot option "acpi_osi=" has always disabled Linux _OSI support,
    thus disabling all OS Interface strings which are advertised
    by Linux to the BIOS.
    
    Now...
    acpi_osi="string" adds the interface string, and
    acpi_osi="!string" invalidates the pre-defined interface string
    
    eg. acpi_osi="!Windows 2006"
    would disable Linux's claim of Vista compatibility.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index b998340e23d4..f4760cfa61e1 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -73,6 +73,9 @@ static void *acpi_irq_context;
 static struct workqueue_struct *kacpid_wq;
 static struct workqueue_struct *kacpi_notify_wq;
 
+#define	OSI_STRING_LENGTH_MAX 64	/* arbitrary */
+static char osi_additional_string[OSI_STRING_LENGTH_MAX];
+
 static void __init acpi_request_region (struct acpi_generic_address *addr,
 	unsigned int length, char *desc)
 {
@@ -961,19 +964,23 @@ static int __init acpi_os_name_setup(char *str)
 __setup("acpi_os_name=", acpi_os_name_setup);
 
 /*
- * _OSI control
+ * Modify the list of "OS Interfaces" reported to BIOS via _OSI
+ *
  * empty string disables _OSI
- * TBD additional string adds to _OSI
+ * string starting with '!' disables that string
+ * otherwise string is added to list, augmenting built-in strings
  */
 static int __init acpi_osi_setup(char *str)
 {
 	if (str == NULL || *str == '\0') {
 		printk(KERN_INFO PREFIX "_OSI method disabled\n");
 		acpi_gbl_create_osi_method = FALSE;
-	} else {
-		/* TBD */
-		printk(KERN_ERR PREFIX "_OSI additional string ignored -- %s\n",
-		       str);
+	} else if (*str == '!') {
+		if (acpi_osi_invalidate(++str) == AE_OK)
+			printk(KERN_INFO PREFIX "Deleted _OSI(%s)\n", str);
+	} else if (*osi_additional_string == '\0') {
+		strncpy(osi_additional_string, str, OSI_STRING_LENGTH_MAX);
+		printk(KERN_INFO PREFIX "Added _OSI(%s)\n", str);
 	}
 
 	return 1;
@@ -1143,11 +1150,11 @@ acpi_status acpi_os_release_object(acpi_cache_t * cache, void *object)
 acpi_status
 acpi_os_validate_interface (char *interface)
 {
-
-    return AE_SUPPORT;
+	if (!strncmp(osi_additional_string, interface, OSI_STRING_LENGTH_MAX))
+		return AE_OK;
+	return AE_SUPPORT;
 }
 
-
 /******************************************************************************
  *
  * FUNCTION:    acpi_os_validate_address

commit 88db5e1489f23876a226f5393fd978ddc09dc5f9
Author: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Wed May 9 23:31:03 2007 -0400

    ACPI: created a dedicated workqueue for notify() execution
    
    HP nx6125/nx6325/... machines have a _GPE handler with an infinite
    loop sending Notify() events to different ACPI subsystems.
    
    Notify handler in ACPI driver is a C-routine, which may call ACPI
    interpreter again to get access to some ACPI variables
    (acpi_evaluate_xxx).
    On these HP machines such an evaluation changes state of some variable
    and lets the loop above break.
    
    In the current ACPI implementation Notify requests are being deferred
    to the same kacpid workqueue on which the above GPE handler with
    infinite loop is executing. Thus we have a deadlock -- loop will
    continue to spin, sending notify events, and at the same time
    preventing these notify events from being run on a workqueue. All
    notify events are deferred, thus we see increase in memory consumption
    noticed by author of the thread. Also as GPE handling is bloked,
    machines overheat. Eventually by external poll of the same
    acpi_evaluate, kacpid is released and all the queued notify events are
    free to run, thus 100% cpu utilization by kacpid for several seconds
    or more.
    
    To prevent all these horrors it's needed to not put notify events to
    kacpid workqueue by either executing them immediately or putting them
    on some other thread. It's dangerous to execute notify events in
    place, as it will put several ACPI interpreter stacks on top of each
    other (at least 4 in case of nx6125), thus causing kernel  stack
    overflow.
    
    First attempt to create a new thread was done by Peter Wainwright
    He created a bunch of threads, which were stealing work from a kacpid
    workqueue.
    This patch appeared in 2.6.15 kernel shipped with Ubuntu 6.06 LTS.
    
    Second attempt was done by me, I created a new thread for each Notify
    event. This worked OK on HP nx machines, but broke Linus' Compaq
    n620c, by producing threads with a speed what they stopped the machine
    completely. Thus this patch was reverted from 18-rc2 as I remember.
    I re-made the patch to create second workqueue just for notify events,
    thus hopping it will not break Linus' machine. Patch was tested on the
    same HP nx machines in #5534 and #7122, but I did not received reply
    from Linus on a test patch sent to him.
    Patch went to 19-rc and was rejected with much fanfare again.
    There was 4th patch, which inserted schedule_timeout(1) into deferred
    execution of kacpid, if we had any notify requests pending, but Linus
    decided that it was too complex (involved either changes to workqueue
    to see if it's empty or atomic inc/dec).
    Now you see last variant which adds yield() to every GPE execution.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=5534
    http://bugzilla.kernel.org/show_bug.cgi?id=8385
    
    Signed-off-by: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index c2bed56915e1..b998340e23d4 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -71,6 +71,7 @@ static unsigned int acpi_irq_irq;
 static acpi_osd_handler acpi_irq_handler;
 static void *acpi_irq_context;
 static struct workqueue_struct *kacpid_wq;
+static struct workqueue_struct *kacpi_notify_wq;
 
 static void __init acpi_request_region (struct acpi_generic_address *addr,
 	unsigned int length, char *desc)
@@ -137,8 +138,9 @@ acpi_status acpi_os_initialize1(void)
 		return AE_NULL_ENTRY;
 	}
 	kacpid_wq = create_singlethread_workqueue("kacpid");
+	kacpi_notify_wq = create_singlethread_workqueue("kacpi_notify");
 	BUG_ON(!kacpid_wq);
-
+	BUG_ON(!kacpi_notify_wq);
 	return AE_OK;
 }
 
@@ -150,6 +152,7 @@ acpi_status acpi_os_terminate(void)
 	}
 
 	destroy_workqueue(kacpid_wq);
+	destroy_workqueue(kacpi_notify_wq);
 
 	return AE_OK;
 }
@@ -601,6 +604,23 @@ void acpi_os_derive_pci_id(acpi_handle rhandle,	/* upper bound  */
 }
 
 static void acpi_os_execute_deferred(struct work_struct *work)
+{
+	struct acpi_os_dpc *dpc = container_of(work, struct acpi_os_dpc, work);
+	if (!dpc) {
+		printk(KERN_ERR PREFIX "Invalid (NULL) context\n");
+		return;
+	}
+
+	dpc->function(dpc->context);
+	kfree(dpc);
+
+	/* Yield cpu to notify thread */
+	cond_resched();
+
+	return;
+}
+
+static void acpi_os_execute_notify(struct work_struct *work)
 {
 	struct acpi_os_dpc *dpc = container_of(work, struct acpi_os_dpc, work);
 
@@ -637,14 +657,12 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 	acpi_status status = AE_OK;
 	struct acpi_os_dpc *dpc;
 
-	ACPI_FUNCTION_TRACE("os_queue_for_execution");
-
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
 			  "Scheduling function [%p(%p)] for deferred execution.\n",
 			  function, context));
 
 	if (!function)
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
+		return AE_BAD_PARAMETER;
 
 	/*
 	 * Allocate/initialize DPC structure.  Note that this memory will be
@@ -662,14 +680,21 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 	dpc->function = function;
 	dpc->context = context;
 
-	INIT_WORK(&dpc->work, acpi_os_execute_deferred);
-	if (!queue_work(kacpid_wq, &dpc->work)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+	if (type == OSL_NOTIFY_HANDLER) {
+		INIT_WORK(&dpc->work, acpi_os_execute_notify);
+		if (!queue_work(kacpi_notify_wq, &dpc->work)) {
+			status = AE_ERROR;
+			kfree(dpc);
+		}
+	} else {
+		INIT_WORK(&dpc->work, acpi_os_execute_deferred);
+		if (!queue_work(kacpid_wq, &dpc->work)) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
 				  "Call to queue_work() failed.\n"));
-		kfree(dpc);
-		status = AE_ERROR;
+			status = AE_ERROR;
+			kfree(dpc);
+		}
 	}
-
 	return_ACPI_STATUS(status);
 }
 

commit e63340ae6b6205fef26b40a75673d1c9c0c8bb90
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue May 8 00:28:08 2007 -0700

    header cleaning: don't include smp_lock.h when not used
    
    Remove includes of <linux/smp_lock.h> where it is not used/needed.
    Suggested by Al Viro.
    
    Builds cleanly on x86_64, i386, alpha, ia64, powerpc, sparc,
    sparc64, and arm (all 59 defconfigs).
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 971eca4864fa..c2bed56915e1 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -30,7 +30,6 @@
 #include <linux/slab.h>
 #include <linux/mm.h>
 #include <linux/pci.h>
-#include <linux/smp_lock.h>
 #include <linux/interrupt.h>
 #include <linux/kmod.h>
 #include <linux/delay.h>

commit 8800c0ebf5e8363dab66647512dcef5b83203dec
Merge: 9cdd79c9b998 5ee6edbcde4d
Author: Len Brown <len.brown@intel.com>
Date:   Fri Feb 16 22:11:02 2007 -0500

    Pull remove-hotkey into release branch

commit c0cd79d11412969b6b8fa1624cdc1277db82e2fe
Merge: 81450b73dde0 db2d4ccdc8f9
Author: Len Brown <len.brown@intel.com>
Date:   Fri Feb 16 22:10:32 2007 -0500

    Pull fluff into release branch
    
    Conflicts:
    
            arch/x86_64/pci/mmconfig.c
            drivers/acpi/bay.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 5ee6edbcde4d3b14e4e03d4b331df1099a34aa8d
Author: Len Brown <len.brown@intel.com>
Date:   Sat Feb 10 01:18:25 2007 -0500

    ACPI: hotkey: remove driver, per feature-removal-schedule.txt
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 0f6f3bcbc8eb..368e111100bd 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -68,9 +68,6 @@ EXPORT_SYMBOL(acpi_in_debugger);
 extern char line_buf[80];
 #endif				/*ENABLE_DEBUGGER */
 
-int acpi_specific_hotkey_enabled = TRUE;
-EXPORT_SYMBOL(acpi_specific_hotkey_enabled);
-
 static unsigned int acpi_irq_irq;
 static acpi_osd_handler acpi_irq_handler;
 static void *acpi_irq_context;
@@ -1012,14 +1009,6 @@ static int __init acpi_wake_gpes_always_on_setup(char *str)
 
 __setup("acpi_wake_gpes_always_on", acpi_wake_gpes_always_on_setup);
 
-static int __init acpi_hotkey_setup(char *str)
-{
-	acpi_specific_hotkey_enabled = FALSE;
-	return 1;
-}
-
-__setup("acpi_generic_hotkey", acpi_hotkey_setup);
-
 /*
  * max_cstate is defined in the base kernel so modules can
  * change it w/o depending on the state of the processor module.

commit fc955f670c0a66aca965605dae797e747b2bef7d
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 15 22:11:48 2007 -0500

    ACPI: remove acpi_os_readable(), acpi_os_writable()
    
    ...which are now unused
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 63060a17f7ed..99d6c5128280 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -890,26 +890,6 @@ u32 acpi_os_get_line(char *buffer)
 }
 #endif				/*  ACPI_FUTURE_USAGE  */
 
-/* Assumes no unreadable holes inbetween */
-u8 acpi_os_readable(void *ptr, acpi_size len)
-{
-#if defined(__i386__) || defined(__x86_64__)
-	char tmp;
-	return !__get_user(tmp, (char __user *)ptr)
-	    && !__get_user(tmp, (char __user *)ptr + len - 1);
-#endif
-	return 1;
-}
-
-#ifdef ACPI_FUTURE_USAGE
-u8 acpi_os_writable(void *ptr, acpi_size len)
-{
-	/* could do dummy write (racy) or a kernel page table lookup.
-	   The later may be difficult at early boot when kmap doesn't work yet. */
-	return 1;
-}
-#endif
-
 acpi_status acpi_os_signal(u32 function, void *info)
 {
 	switch (function) {

commit 70c0846e430881967776582e13aefb81407919f1
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue Feb 13 16:11:36 2007 -0800

    ACPI: Fix sparse warnings
    
    Use NULL for pointers
    
    drivers/acpi/osl.c:208:10: warning: Using plain integer as NULL pointer
    drivers/acpi/tables/tbxface.c:411:49: warning: Using plain integer as NULL pointer
    drivers/acpi/processor_core.c:1008:10: warning: Using plain integer as NULL pointer
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 0f6f3bcbc8eb..63060a17f7ed 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -205,7 +205,7 @@ void __iomem *acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 {
 	if (phys > ULONG_MAX) {
 		printk(KERN_ERR PREFIX "Cannot map memory that high\n");
-		return 0;
+		return NULL;
 	}
 	if (acpi_gbl_permanent_mmap)
 		/*

commit f52fd66d2ea794010c2d7536cf8e6abed0ac4947
Author: Len Brown <len.brown@intel.com>
Date:   Mon Feb 12 22:42:12 2007 -0500

    ACPI: clean up ACPI_MODULE_NAME() use
    
    cosmetic only
    
    Make "module name" actually match the file name.
    Invoke with ';' as leaving it off confuses Lindent and gcc doesn't care.
    Fix indentation where Lindent did get confused.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 0f6f3bcbc8eb..851ac492dbbc 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -46,7 +46,7 @@
 #include <linux/efi.h>
 
 #define _COMPONENT		ACPI_OS_SERVICES
-ACPI_MODULE_NAME("osl")
+ACPI_MODULE_NAME("osl");
 #define PREFIX		"ACPI: "
 struct acpi_os_dpc {
 	acpi_osd_exec_callback function;

commit eee3c859c486d4f110f154807430eaf825ff4a3d
Merge: 547352660506 fb5c3e1b6d30
Author: Len Brown <len.brown@intel.com>
Date:   Sat Feb 3 01:38:16 2007 -0500

    Pull motherboard into test branch
    
    Conflicts:
    
            drivers/acpi/motherboard.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit cee324b145a1e5488b34191de670e5ed1d346ebb
Author: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Fri Feb 2 19:48:22 2007 +0300

    ACPICA: use new ACPI headers.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index c1c2100fe133..a28f5b8972b4 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -245,7 +245,7 @@ acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,
 	 * FADT. It may not be the same if an interrupt source override exists
 	 * for the SCI.
 	 */
-	gsi = acpi_fadt.sci_int;
+	gsi = acpi_gbl_FADT.sci_interrupt;
 	if (acpi_gsi_to_irq(gsi, &irq) < 0) {
 		printk(KERN_ERR PREFIX "SCI (ACPI GSI %d) not registered\n",
 		       gsi);

commit ad71860a17ba33eb0e673e9e2cf5ba0d8e3e3fdd
Author: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Fri Feb 2 19:48:19 2007 +0300

    ACPICA: minimal patch to integrate new tables into Linux
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 57ae1e5cde0a..c1c2100fe133 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -36,6 +36,7 @@
 #include <linux/delay.h>
 #include <linux/workqueue.h>
 #include <linux/nmi.h>
+#include <linux/acpi.h>
 #include <acpi/acpi.h>
 #include <asm/io.h>
 #include <acpi/acpi_bus.h>
@@ -136,53 +137,43 @@ void acpi_os_vprintf(const char *fmt, va_list args)
 #endif
 }
 
-acpi_status acpi_os_get_root_pointer(u32 flags, struct acpi_pointer *addr)
+acpi_physical_address __init acpi_os_get_root_pointer(void)
 {
 	if (efi_enabled) {
-		addr->pointer_type = ACPI_PHYSICAL_POINTER;
 		if (efi.acpi20 != EFI_INVALID_TABLE_ADDR)
-			addr->pointer.physical = efi.acpi20;
+			return efi.acpi20;
 		else if (efi.acpi != EFI_INVALID_TABLE_ADDR)
-			addr->pointer.physical = efi.acpi;
+			return efi.acpi;
 		else {
 			printk(KERN_ERR PREFIX
 			       "System description tables not found\n");
-			return AE_NOT_FOUND;
+			return 0;
 		}
-	} else {
-		if (ACPI_FAILURE(acpi_find_root_pointer(flags, addr))) {
-			printk(KERN_ERR PREFIX
-			       "System description tables not found\n");
-			return AE_NOT_FOUND;
-		}
-	}
-
-	return AE_OK;
+	} else
+		return acpi_find_rsdp();
 }
 
-acpi_status
-acpi_os_map_memory(acpi_physical_address phys, acpi_size size,
-		   void __iomem ** virt)
+void __iomem *acpi_os_map_memory(acpi_physical_address phys, acpi_size size)
 {
 	if (phys > ULONG_MAX) {
 		printk(KERN_ERR PREFIX "Cannot map memory that high\n");
-		return AE_BAD_PARAMETER;
+		return 0;
 	}
-	/*
-	 * ioremap checks to ensure this is in reserved space
-	 */
-	*virt = ioremap((unsigned long)phys, size);
-
-	if (!*virt)
-		return AE_NO_MEMORY;
-
-	return AE_OK;
+	if (acpi_gbl_permanent_mmap)
+		/*
+		* ioremap checks to ensure this is in reserved space
+		*/
+		return ioremap((unsigned long)phys, size);
+	else
+		return __acpi_map_table((unsigned long)phys, size);
 }
 EXPORT_SYMBOL_GPL(acpi_os_map_memory);
 
 void acpi_os_unmap_memory(void __iomem * virt, acpi_size size)
 {
-	iounmap(virt);
+	if (acpi_gbl_permanent_mmap) {
+		iounmap(virt);
+	}
 }
 EXPORT_SYMBOL_GPL(acpi_os_unmap_memory);
 

commit 9a47cdb1bb85e7944fb7419e4078c46516ef7335
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jan 18 16:42:55 2007 -0700

    ACPI: move FADT resource reservations from motherboard driver to osl
    
    Resources described by the FADT aren't really a good fit for the
    ACPI motherboard driver.
    
    The motherboard driver cares about PNP0C01 and PNP0C02 devices and
    their resources.
    
    The FADT describes some resources used by the ACPI core.  Often, they
    are also described by by the _CRS of a motherboard device, but I think
    it's better to reserve them specifically in the ACPI osl.c because
    (a) the motherboard driver is optional and ACPI uses the resources even
    if the driver is absent, and (b) I want to remove the ACPI motherboard
    driver because it's mostly redundant with the PNP system.c driver.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 02b30ae6a68e..0acd0e716ba4 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -75,6 +75,54 @@ static acpi_osd_handler acpi_irq_handler;
 static void *acpi_irq_context;
 static struct workqueue_struct *kacpid_wq;
 
+static void __init acpi_request_region (struct acpi_generic_address *addr,
+	unsigned int length, char *desc)
+{
+	struct resource *res;
+
+	if (!addr->address || !length)
+		return;
+
+	if (addr->address_space_id == ACPI_ADR_SPACE_SYSTEM_IO)
+		res = request_region(addr->address, length, desc);
+	else if (addr->address_space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)
+		res = request_mem_region(addr->address, length, desc);
+}
+
+static int __init acpi_reserve_resources(void)
+{
+	acpi_request_region(&acpi_fadt.xpm1a_evt_blk, acpi_fadt.pm1_evt_len,
+		"ACPI PM1a_EVT_BLK");
+
+	acpi_request_region(&acpi_fadt.xpm1b_evt_blk, acpi_fadt.pm1_evt_len,
+		"ACPI PM1b_EVT_BLK");
+
+	acpi_request_region(&acpi_fadt.xpm1a_cnt_blk, acpi_fadt.pm1_cnt_len,
+		"ACPI PM1a_CNT_BLK");
+
+	acpi_request_region(&acpi_fadt.xpm1b_cnt_blk, acpi_fadt.pm1_cnt_len,
+		"ACPI PM1b_CNT_BLK");
+
+	if (acpi_fadt.pm_tm_len == 4)
+		acpi_request_region(&acpi_fadt.xpm_tmr_blk, 4, "ACPI PM_TMR");
+
+	acpi_request_region(&acpi_fadt.xpm2_cnt_blk, acpi_fadt.pm2_cnt_len,
+		"ACPI PM2_CNT_BLK");
+
+	/* Length of GPE blocks must be a non-negative multiple of 2 */
+
+	if (!(acpi_fadt.gpe0_blk_len & 0x1))
+		acpi_request_region(&acpi_fadt.xgpe0_blk,
+			       acpi_fadt.gpe0_blk_len, "ACPI GPE0_BLK");
+
+	if (!(acpi_fadt.gpe1_blk_len & 0x1))
+		acpi_request_region(&acpi_fadt.xgpe1_blk,
+			       acpi_fadt.gpe1_blk_len, "ACPI GPE1_BLK");
+
+	return 0;
+}
+device_initcall(acpi_reserve_resources);
+
 acpi_status acpi_os_initialize(void)
 {
 	return AE_OK;

commit 3be11c8f4f2fa194834c2e83540f34da442b8977
Merge: 706b75ddbe36 6796a1204cfe
Author: Len Brown <len.brown@intel.com>
Date:   Wed Dec 20 02:52:50 2006 -0500

    Pull bugfix into test branch

commit a6fdbf90b94fa4e2f5f7cbb526c71160b6c561c8
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Dec 19 12:56:13 2006 -0800

    ACPI: fix NULL check in drivers/acpi/osl.c
    
    Spotted by the Coverity checker.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index c84286cbbe25..e10679ce1e0e 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1032,7 +1032,7 @@ acpi_status
 acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)
 {
 	*cache = kmem_cache_create(name, size, 0, 0, NULL, NULL);
-	if (cache == NULL)
+	if (*cache == NULL)
 		return AE_ERROR;
 	else
 		return AE_OK;

commit cece901481bafbf14de8cbd3a89ae869ea881055
Merge: cfee47f99bc1 50dd096973f1
Author: Len Brown <len.brown@intel.com>
Date:   Sat Dec 16 01:04:27 2006 -0500

    Pull style into test branch
    
    Conflicts:
    
            drivers/acpi/button.c
            drivers/acpi/ec.c
            drivers/acpi/osl.c
            drivers/acpi/sbs.c

commit 65f27f38446e1976cc98fd3004b110fedcddd189
Author: David Howells <dhowells@redhat.com>
Date:   Wed Nov 22 14:55:48 2006 +0000

    WorkStruct: Pass the work_struct pointer instead of context data
    
    Pass the work_struct pointer to the work function rather than context data.
    The work function can use container_of() to work out the data.
    
    For the cases where the container of the work_struct may go away the moment the
    pending bit is cleared, it is made possible to defer the release of the
    structure by deferring the clearing of the pending bit.
    
    To make this work, an extra flag is introduced into the management side of the
    work_struct.  This governs auto-release of the structure upon execution.
    
    Ordinarily, the work queue executor would release the work_struct for further
    scheduling or deallocation by clearing the pending bit prior to jumping to the
    work function.  This means that, unless the driver makes some guarantee itself
    that the work_struct won't go away, the work function may not access anything
    else in the work_struct or its container lest they be deallocated..  This is a
    problem if the auxiliary data is taken away (as done by the last patch).
    
    However, if the pending bit is *not* cleared before jumping to the work
    function, then the work function *may* access the work_struct and its container
    with no problems.  But then the work function must itself release the
    work_struct by calling work_release().
    
    In most cases, automatic release is fine, so this is the default.  Special
    initiators exist for the non-auto-release case (ending in _NAR).
    
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 068fe4f100b0..02b30ae6a68e 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -50,6 +50,7 @@ ACPI_MODULE_NAME("osl")
 struct acpi_os_dpc {
 	acpi_osd_exec_callback function;
 	void *context;
+	struct work_struct work;
 };
 
 #ifdef CONFIG_ACPI_CUSTOM_DSDT
@@ -564,12 +565,9 @@ void acpi_os_derive_pci_id(acpi_handle rhandle,	/* upper bound  */
 	acpi_os_derive_pci_id_2(rhandle, chandle, id, &is_bridge, &bus_number);
 }
 
-static void acpi_os_execute_deferred(void *context)
+static void acpi_os_execute_deferred(struct work_struct *work)
 {
-	struct acpi_os_dpc *dpc = NULL;
-
-
-	dpc = (struct acpi_os_dpc *)context;
+	struct acpi_os_dpc *dpc = container_of(work, struct acpi_os_dpc, work);
 	if (!dpc) {
 		printk(KERN_ERR PREFIX "Invalid (NULL) context\n");
 		return;
@@ -602,7 +600,6 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 {
 	acpi_status status = AE_OK;
 	struct acpi_os_dpc *dpc;
-	struct work_struct *task;
 
 	ACPI_FUNCTION_TRACE("os_queue_for_execution");
 
@@ -615,28 +612,22 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 
 	/*
 	 * Allocate/initialize DPC structure.  Note that this memory will be
-	 * freed by the callee.  The kernel handles the tq_struct list  in a
+	 * freed by the callee.  The kernel handles the work_struct list  in a
 	 * way that allows us to also free its memory inside the callee.
 	 * Because we may want to schedule several tasks with different
 	 * parameters we can't use the approach some kernel code uses of
-	 * having a static tq_struct.
-	 * We can save time and code by allocating the DPC and tq_structs
-	 * from the same memory.
+	 * having a static work_struct.
 	 */
 
-	dpc =
-	    kmalloc(sizeof(struct acpi_os_dpc) + sizeof(struct work_struct),
-		    GFP_ATOMIC);
+	dpc = kmalloc(sizeof(struct acpi_os_dpc), GFP_ATOMIC);
 	if (!dpc)
 		return_ACPI_STATUS(AE_NO_MEMORY);
 
 	dpc->function = function;
 	dpc->context = context;
 
-	task = (void *)(dpc + 1);
-	INIT_WORK(task, acpi_os_execute_deferred, (void *)dpc);
-
-	if (!queue_work(kacpid_wq, task)) {
+	INIT_WORK(&dpc->work, acpi_os_execute_deferred);
+	if (!queue_work(kacpid_wq, &dpc->work)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
 				  "Call to queue_work() failed.\n"));
 		kfree(dpc);

commit b976fe19acc565e5137e6f12af7b6633a23e6b7c
Author: Linus Torvalds <torvalds@evo.osdl.org>
Date:   Fri Nov 17 19:31:09 2006 -0800

    Revert "ACPI: created a dedicated workqueue for notify() execution"
    
    This reverts commit 37605a6900f6b4d886d995751fcfeef88c4e462c.
    
    Again.
    
    This same bug has now been introduced twice: it was done earlier by
    commit b8d35192c55fb055792ff0641408eaaec7c88988, only to be reverted
    last time in commit 72945b2b90a5554975b8f72673ab7139d232a121.
    
    We must NOT try to queue up notify handlers to another thread than the
    normal ACPI execution thread, because the notifications on some systems
    seem to just keep on accumulating until we run out of memory and/or
    threads.
    
    Keeping events within the one deferred execution thread automatically
    throttles the events properly.
    
    At least the Compaq N620c will lock up completely on the first thermal
    event without this patch reverted.
    
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Alexey Starikovskiy <alexey.y.starikovskiy@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index c84286cbbe25..068fe4f100b0 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -73,7 +73,6 @@ static unsigned int acpi_irq_irq;
 static acpi_osd_handler acpi_irq_handler;
 static void *acpi_irq_context;
 static struct workqueue_struct *kacpid_wq;
-static struct workqueue_struct *kacpi_notify_wq;
 
 acpi_status acpi_os_initialize(void)
 {
@@ -92,9 +91,8 @@ acpi_status acpi_os_initialize1(void)
 		return AE_NULL_ENTRY;
 	}
 	kacpid_wq = create_singlethread_workqueue("kacpid");
-	kacpi_notify_wq = create_singlethread_workqueue("kacpi_notify");
 	BUG_ON(!kacpid_wq);
-	BUG_ON(!kacpi_notify_wq);
+
 	return AE_OK;
 }
 
@@ -106,7 +104,6 @@ acpi_status acpi_os_terminate(void)
 	}
 
 	destroy_workqueue(kacpid_wq);
-	destroy_workqueue(kacpi_notify_wq);
 
 	return AE_OK;
 }
@@ -569,7 +566,10 @@ void acpi_os_derive_pci_id(acpi_handle rhandle,	/* upper bound  */
 
 static void acpi_os_execute_deferred(void *context)
 {
-	struct acpi_os_dpc *dpc = (struct acpi_os_dpc *)context;
+	struct acpi_os_dpc *dpc = NULL;
+
+
+	dpc = (struct acpi_os_dpc *)context;
 	if (!dpc) {
 		printk(KERN_ERR PREFIX "Invalid (NULL) context\n");
 		return;
@@ -604,12 +604,14 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 	struct acpi_os_dpc *dpc;
 	struct work_struct *task;
 
+	ACPI_FUNCTION_TRACE("os_queue_for_execution");
+
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
 			  "Scheduling function [%p(%p)] for deferred execution.\n",
 			  function, context));
 
 	if (!function)
-		return AE_BAD_PARAMETER;
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
 
 	/*
 	 * Allocate/initialize DPC structure.  Note that this memory will be
@@ -622,20 +624,26 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 	 * from the same memory.
 	 */
 
-	dpc = kmalloc(sizeof(struct acpi_os_dpc) +
-			sizeof(struct work_struct), GFP_ATOMIC);
+	dpc =
+	    kmalloc(sizeof(struct acpi_os_dpc) + sizeof(struct work_struct),
+		    GFP_ATOMIC);
 	if (!dpc)
-		return AE_NO_MEMORY;
+		return_ACPI_STATUS(AE_NO_MEMORY);
+
 	dpc->function = function;
 	dpc->context = context;
+
 	task = (void *)(dpc + 1);
 	INIT_WORK(task, acpi_os_execute_deferred, (void *)dpc);
-	if (!queue_work((type == OSL_NOTIFY_HANDLER)?
-			kacpi_notify_wq : kacpid_wq, task)) {
-		status = AE_ERROR;
+
+	if (!queue_work(kacpid_wq, task)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Call to queue_work() failed.\n"));
 		kfree(dpc);
+		status = AE_ERROR;
 	}
-	return status;
+
+	return_ACPI_STATUS(status);
 }
 
 EXPORT_SYMBOL(acpi_os_execute);

commit 50dd096973f1d95aa03c6a6d9e148d706b62b68e
Author: Jan Engelhardt <jengelh@linux01.gwdg.de>
Date:   Sun Oct 1 00:28:50 2006 +0200

    ACPI: Remove unnecessary from/to-void* and to-void casts in drivers/acpi
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 068fe4f100b0..2ed2d701f6e1 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -569,7 +569,7 @@ static void acpi_os_execute_deferred(void *context)
 	struct acpi_os_dpc *dpc = NULL;
 
 
-	dpc = (struct acpi_os_dpc *)context;
+	dpc = context;
 	if (!dpc) {
 		printk(KERN_ERR PREFIX "Invalid (NULL) context\n");
 		return;
@@ -1060,7 +1060,7 @@ acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)
 
 acpi_status acpi_os_purge_cache(acpi_cache_t * cache)
 {
-	(void)kmem_cache_shrink(cache);
+	kmem_cache_shrink(cache);
 	return (AE_OK);
 }
 

commit 37605a6900f6b4d886d995751fcfeef88c4e462c
Author: Alexey Y. Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Tue Sep 26 04:20:47 2006 -0400

    ACPI: created a dedicated workqueue for notify() execution
    
    http://bugzilla.kernel.org/show_bug.cgi?id=5534#c160
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 068fe4f100b0..c84286cbbe25 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -73,6 +73,7 @@ static unsigned int acpi_irq_irq;
 static acpi_osd_handler acpi_irq_handler;
 static void *acpi_irq_context;
 static struct workqueue_struct *kacpid_wq;
+static struct workqueue_struct *kacpi_notify_wq;
 
 acpi_status acpi_os_initialize(void)
 {
@@ -91,8 +92,9 @@ acpi_status acpi_os_initialize1(void)
 		return AE_NULL_ENTRY;
 	}
 	kacpid_wq = create_singlethread_workqueue("kacpid");
+	kacpi_notify_wq = create_singlethread_workqueue("kacpi_notify");
 	BUG_ON(!kacpid_wq);
-
+	BUG_ON(!kacpi_notify_wq);
 	return AE_OK;
 }
 
@@ -104,6 +106,7 @@ acpi_status acpi_os_terminate(void)
 	}
 
 	destroy_workqueue(kacpid_wq);
+	destroy_workqueue(kacpi_notify_wq);
 
 	return AE_OK;
 }
@@ -566,10 +569,7 @@ void acpi_os_derive_pci_id(acpi_handle rhandle,	/* upper bound  */
 
 static void acpi_os_execute_deferred(void *context)
 {
-	struct acpi_os_dpc *dpc = NULL;
-
-
-	dpc = (struct acpi_os_dpc *)context;
+	struct acpi_os_dpc *dpc = (struct acpi_os_dpc *)context;
 	if (!dpc) {
 		printk(KERN_ERR PREFIX "Invalid (NULL) context\n");
 		return;
@@ -604,14 +604,12 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 	struct acpi_os_dpc *dpc;
 	struct work_struct *task;
 
-	ACPI_FUNCTION_TRACE("os_queue_for_execution");
-
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
 			  "Scheduling function [%p(%p)] for deferred execution.\n",
 			  function, context));
 
 	if (!function)
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
+		return AE_BAD_PARAMETER;
 
 	/*
 	 * Allocate/initialize DPC structure.  Note that this memory will be
@@ -624,26 +622,20 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 	 * from the same memory.
 	 */
 
-	dpc =
-	    kmalloc(sizeof(struct acpi_os_dpc) + sizeof(struct work_struct),
-		    GFP_ATOMIC);
+	dpc = kmalloc(sizeof(struct acpi_os_dpc) +
+			sizeof(struct work_struct), GFP_ATOMIC);
 	if (!dpc)
-		return_ACPI_STATUS(AE_NO_MEMORY);
-
+		return AE_NO_MEMORY;
 	dpc->function = function;
 	dpc->context = context;
-
 	task = (void *)(dpc + 1);
 	INIT_WORK(task, acpi_os_execute_deferred, (void *)dpc);
-
-	if (!queue_work(kacpid_wq, task)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Call to queue_work() failed.\n"));
-		kfree(dpc);
+	if (!queue_work((type == OSL_NOTIFY_HANDLER)?
+			kacpi_notify_wq : kacpid_wq, task)) {
 		status = AE_ERROR;
+		kfree(dpc);
 	}
-
-	return_ACPI_STATUS(status);
+	return status;
 }
 
 EXPORT_SYMBOL(acpi_os_execute);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 20beea778ea2..068fe4f100b0 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -237,7 +237,7 @@ acpi_os_table_override(struct acpi_table_header * existing_table,
 	return AE_OK;
 }
 
-static irqreturn_t acpi_irq(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t acpi_irq(int irq, void *dev_id)
 {
 	return (*acpi_irq_handler) (acpi_irq_context) ? IRQ_HANDLED : IRQ_NONE;
 }

commit 1a1d92c10dd24bbdc28b3d6e2d03ec199dd3a65b
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Sep 27 01:49:40 2006 -0700

    [PATCH] Really ignore kmem_cache_destroy return value
    
    * Rougly half of callers already do it by not checking return value
    * Code in drivers/acpi/osl.c does the following to be sure:
    
            (void)kmem_cache_destroy(cache);
    
    * Those who check it printk something, however, slab_error already printed
      the name of failed cache.
    * XFS BUGs on failed kmem_cache_destroy which is not the decision
      low-level filesystem driver should make. Converted to ignore.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 507f051d1cef..20beea778ea2 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1079,7 +1079,7 @@ acpi_status acpi_os_purge_cache(acpi_cache_t * cache)
 
 acpi_status acpi_os_delete_cache(acpi_cache_t * cache)
 {
-	(void)kmem_cache_destroy(cache);
+	kmem_cache_destroy(cache);
 	return (AE_OK);
 }
 

commit d68909f4c3eee09c13d4e5c86512c6c075553dbd
Author: Len Brown <len.brown@intel.com>
Date:   Wed Aug 16 19:16:58 2006 -0400

    ACPI: avoid irqrouter_resume might_sleep oops on resume from S4
    
    __might_sleep+0x8e/0x93
    acpi_os_wait_semaphore+0x50/0xa3
    acpi_ut_acquire_mutex+0x28/0x6a
    acpi_ns_get_node+0x46/0x88
    acpi_ns_evaluate+0x2d/0xfc
    acpi_rs_set_srs_method_data+0xc5/0xe1
    acpi_set_current_resources+0x31/0x3f
    acpi_pci_link_set+0xfc/0x1a5
    irqrouter_resume+0x48/0x5f
    
    and
    
    __might_sleep+0x8e/0x93
    kmem_cache_alloc+0x2a/0x8f
    acpi_evaluate_integer+0x32/0x96
    acpi_bus_get_status+0x30/0x84
    acpi_pci_link_set+0x12a/0x1a5
    irqrouter_resume+0x48/0x5f
    
    http://bugzilla.kernel.org/show_bug.cgi?id=6810
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index b7d1514cd199..507f051d1cef 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -746,6 +746,16 @@ acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
 	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Waiting for semaphore[%p|%d|%d]\n",
 			  handle, units, timeout));
 
+	/*
+	 * This can be called during resume with interrupts off.
+	 * Like boot-time, we should be single threaded and will
+	 * always get the lock if we try -- timeout or not.
+	 * If this doesn't succeed, then we will oops courtesy of
+	 * might_sleep() in down().
+	 */
+	if (!down_trylock(sem))
+		return AE_OK;
+
 	switch (timeout) {
 		/*
 		 * No Wait:

commit 72945b2b90a5554975b8f72673ab7139d232a121
Author: Len Brown <len.brown@intel.com>
Date:   Wed Jul 12 22:46:42 2006 -0400

    [PATCH] Revert "ACPI: execute Notify() handlers on new thread"
    
    This effectively reverts commit b8d35192c55fb055792ff0641408eaaec7c88988
    by reverts acpi_os_queue_for_execution() to what it was before that,
    except it changes the name to acpi_os_execute() to match ACPICA
    20060512.
    
    Signed-off-by: Len Brown <len.brown@intel.com>
    
    [ The thread execution doesn't actually solve the bug it set out to
      solve (see
    
            http://bugzilla.kernel.org/show_bug.cgi?id=5534
    
      for more details) because the new events can get caught behind the AML
      semaphore or other serialization.  And when that happens, the notify
      threads keep on piling up until the system dies. ]
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 47dfde95b8f8..b7d1514cd199 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -36,7 +36,6 @@
 #include <linux/delay.h>
 #include <linux/workqueue.h>
 #include <linux/nmi.h>
-#include <linux/kthread.h>
 #include <acpi/acpi.h>
 #include <asm/io.h>
 #include <acpi/acpi_bus.h>
@@ -583,16 +582,6 @@ static void acpi_os_execute_deferred(void *context)
 	return;
 }
 
-static int acpi_os_execute_thread(void *context)
-{
-	struct acpi_os_dpc *dpc = (struct acpi_os_dpc *)context;
-	if (dpc) {
-		dpc->function(dpc->context);
-		kfree(dpc);
-	}
-	do_exit(0);
-}
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_os_execute
@@ -614,10 +603,16 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 	acpi_status status = AE_OK;
 	struct acpi_os_dpc *dpc;
 	struct work_struct *task;
-	struct task_struct *p;
+
+	ACPI_FUNCTION_TRACE("os_queue_for_execution");
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+			  "Scheduling function [%p(%p)] for deferred execution.\n",
+			  function, context));
 
 	if (!function)
-		return AE_BAD_PARAMETER;
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+
 	/*
 	 * Allocate/initialize DPC structure.  Note that this memory will be
 	 * freed by the callee.  The kernel handles the tq_struct list  in a
@@ -628,34 +623,27 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 	 * We can save time and code by allocating the DPC and tq_structs
 	 * from the same memory.
 	 */
-	if (type == OSL_NOTIFY_HANDLER) {
-		dpc = kmalloc(sizeof(struct acpi_os_dpc), GFP_KERNEL);
-	} else {
-		dpc = kmalloc(sizeof(struct acpi_os_dpc) +
-				sizeof(struct work_struct), GFP_ATOMIC);
-	}
+
+	dpc =
+	    kmalloc(sizeof(struct acpi_os_dpc) + sizeof(struct work_struct),
+		    GFP_ATOMIC);
 	if (!dpc)
-		return AE_NO_MEMORY;
+		return_ACPI_STATUS(AE_NO_MEMORY);
+
 	dpc->function = function;
 	dpc->context = context;
 
-	if (type == OSL_NOTIFY_HANDLER) {
-		p = kthread_create(acpi_os_execute_thread, dpc, "kacpid_notify");
-		if (!IS_ERR(p)) {
-			wake_up_process(p);
-		} else {
-			status = AE_NO_MEMORY;
-			kfree(dpc);
-		}
-	} else {
-		task = (void *)(dpc + 1);
-		INIT_WORK(task, acpi_os_execute_deferred, (void *)dpc);
-		if (!queue_work(kacpid_wq, task)) {
-			status = AE_ERROR;
-			kfree(dpc);
-		}
+	task = (void *)(dpc + 1);
+	INIT_WORK(task, acpi_os_execute_deferred, (void *)dpc);
+
+	if (!queue_work(kacpid_wq, task)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Call to queue_work() failed.\n"));
+		kfree(dpc);
+		status = AE_ERROR;
 	}
-	return status;
+
+	return_ACPI_STATUS(status);
 }
 
 EXPORT_SYMBOL(acpi_os_execute);

commit e21c1ca3f98529921c829a792dfdbfc5a5dc393b
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jul 10 01:35:51 2006 -0400

    ACPI: acpi_os_allocate() fixes
    
    Replace acpi_in_resume with a more general hack
    to check irqs_disabled() on any kmalloc() from ACPI.
    While setting (system_state != SYSTEM_RUNNING) on resume
    seemed more general, Andrew Morton preferred this approach.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=3469
    
    Make acpi_os_allocate() into an inline function to
    allow /proc/slab_allocators to work.
    
    Delete some memset() that could fault on allocation failure.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index eedb05c6dc7b..47dfde95b8f8 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -136,16 +136,6 @@ void acpi_os_vprintf(const char *fmt, va_list args)
 #endif
 }
 
-
-extern int acpi_in_resume;
-void *acpi_os_allocate(acpi_size size)
-{
-	if (acpi_in_resume)
-		return kmalloc(size, GFP_ATOMIC);
-	else
-		return kmalloc(size, GFP_KERNEL);
-}
-
 acpi_status acpi_os_get_root_pointer(u32 flags, struct acpi_pointer *addr)
 {
 	if (efi_enabled) {
@@ -1115,26 +1105,6 @@ acpi_status acpi_os_release_object(acpi_cache_t * cache, void *object)
 	return (AE_OK);
 }
 
-/*******************************************************************************
- *
- * FUNCTION:    acpi_os_acquire_object
- *
- * PARAMETERS:  Cache           - Handle to cache object
- *              ReturnObject    - Where the object is returned
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Return a zero-filled object.
- *
- ******************************************************************************/
-
-void *acpi_os_acquire_object(acpi_cache_t * cache)
-{
-	void *object = kmem_cache_zalloc(cache, GFP_KERNEL);
-	WARN_ON(!object);
-	return object;
-}
-
 /******************************************************************************
  *
  * FUNCTION:    acpi_os_validate_interface

commit e82ca04387dd6c98722f5f48235089839fd04268
Merge: 075395d22864 309b0f125a22
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon Jul 3 21:32:50 2006 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6: (44 commits)
      ACPI: remove function tracing macros from drivers/acpi/*.c
      ACPI: add support for Smart Battery
      ACPI: handle battery notify event on broken BIOS
      ACPI: handle AC notify event on broken BIOS
      ACPI: asus_acpi: add S1N WLED control
      ACPI: asus_acpi: correct M6N/M6R display nodes
      ACPI: asus_acpi: add S1N WLED control
      ACPI: asus_acpi: rework model detection
      ACPI: asus_acpi: support L5D
      ACPI: asus_acpi: handle internal Bluetooth / support W5A
      ACPI: asus_acpi: support A4G
      ACPI: asus_acpi: support W3400N
      ACPI: asus_acpi: LED display support
      ACPI: asus_acpi: support A3G
      ACPI: asus_acpi: misc cleanups
      ACPI: video: Remove unneeded acpi_handle from driver.
      ACPI: thermal: Remove unneeded acpi_handle from driver.
      ACPI: power: Remove unneeded acpi_handle from driver.
      ACPI: pci_root: Remove unneeded acpi_handle from driver.
      ACPI: pci_link: Remove unneeded acpi_handle from driver.
      ...

commit dace145374b8e39aeb920304c358ab5e220341ab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:38 2006 -0700

    [PATCH] irq-flags: misc drivers: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 5dd2ed11a387..5a468e2779ae 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -280,7 +280,7 @@ acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,
 
 	acpi_irq_handler = handler;
 	acpi_irq_context = context;
-	if (request_irq(irq, acpi_irq, SA_SHIRQ, "acpi", acpi_irq)) {
+	if (request_irq(irq, acpi_irq, IRQF_SHARED, "acpi", acpi_irq)) {
 		printk(KERN_ERR PREFIX "SCI (IRQ%d) allocation failed\n", irq);
 		return AE_NOT_ACQUIRED;
 	}

commit b197ba3c70638a3a2ae39296781912f26ac0f991
Merge: fc25465f0941 02438d8771ae
Author: Len Brown <len.brown@intel.com>
Date:   Sat Jul 1 17:19:08 2006 -0400

    Pull acpi_os_free into release branch

commit 22a3e233ca08a2ddc949ba1ae8f6e16ec7ef1a13
Merge: 39302175c26d 6ab3d5624e17
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Fri Jun 30 15:39:30 2006 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/bunk/trivial
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/bunk/trivial:
      Remove obsolete #include <linux/config.h>
      remove obsolete swsusp_encrypt
      arch/arm26/Kconfig typos
      Documentation/IPMI typos
      Kconfig: Typos in net/sched/Kconfig
      v9fs: do not include linux/version.h
      Documentation/DocBook/mtdnand.tmpl: typo fixes
      typo fixes: specfic -> specific
      typo fixes in Documentation/networking/pktgen.txt
      typo fixes: occuring -> occurring
      typo fixes: infomation -> information
      typo fixes: disadvantadge -> disadvantage
      typo fixes: aquire -> acquire
      typo fixes: mecanism -> mechanism
      typo fixes: bandwith -> bandwidth
      fix a typo in the RTC_CLASS help text
      smb is no longer maintained
    
    Manually merged trivial conflict in arch/um/kernel/vmlinux.lds.S

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 1bb558adee66..41da26a04cb4 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -25,7 +25,6 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>

commit 02438d8771ae6a4b215938959827692026380bf9
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jun 30 03:19:10 2006 -0400

    ACPI: delete acpi_os_free(), use kfree() directly
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index afd937b158b3..c68b1bb138c3 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -147,13 +147,6 @@ void *acpi_os_allocate(acpi_size size)
 		return kmalloc(size, GFP_KERNEL);
 }
 
-void acpi_os_free(void *ptr)
-{
-	kfree(ptr);
-}
-
-EXPORT_SYMBOL(acpi_os_free);
-
 acpi_status acpi_os_get_root_pointer(u32 flags, struct acpi_pointer *addr)
 {
 	if (efi_enabled) {
@@ -743,7 +736,7 @@ acpi_status acpi_os_delete_semaphore(acpi_handle handle)
 
 	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Deleting semaphore[%p].\n", handle));
 
-	acpi_os_free(sem);
+	kfree(sem);
 	sem = NULL;
 
 	return AE_OK;

commit 967440e3be1af06ad4dc7bb18d2e3c16130fe067
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jun 23 17:04:00 2006 -0400

    ACPI: ACPICA 20060623
    
    Implemented a new acpi_spinlock type for the OSL lock
    interfaces.  This allows the type to be customized to
    the host OS for improved efficiency (since a spinlock is
    usually a very small object.)
    
    Implemented support for "ignored" bits in the ACPI
    registers.  According to the ACPI specification, these
    bits should be preserved when writing the registers via
    a read/modify/write cycle. There are 3 bits preserved
    in this manner: PM1_CONTROL[0] (SCI_EN), PM1_CONTROL[9],
    and PM1_STATUS[11].
    http://bugzilla.kernel.org/show_bug.cgi?id=3691
    
    Implemented the initial deployment of new OSL mutex
    interfaces.  Since some host operating systems have
    separate mutex and semaphore objects, this feature was
    requested. The base code now uses mutexes (and the new
    mutex interfaces) wherever a binary semaphore was used
    previously. However, for the current release, the mutex
    interfaces are defined as macros to map them to the
    existing semaphore interfaces.
    
    Fixed several problems with the support for the control
    method SyncLevel parameter. The SyncLevel now works
    according to the ACPI specification and in concert with the
    Mutex SyncLevel parameter, since the current SyncLevel is
    a property of the executing thread. Mutual exclusion for
    control methods is now implemented with a mutex instead
    of a semaphore.
    
    Fixed three instances of the use of the C shift operator
    in the bitfield support code (exfldio.c) to avoid the use
    of a shift value larger than the target data width. The
    behavior of C compilers is undefined in this case and can
    cause unpredictable results, and therefore the case must
    be detected and avoided.  (Fiodor Suietov)
    
    Added an info message whenever an SSDT or OEM table
    is loaded dynamically via the Load() or LoadTable()
    ASL operators. This should improve debugging capability
    since it will show exactly what tables have been loaded
    (beyond the tables present in the RSDT/XSDT.)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 8e46d1b39491..afd937b158b3 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -688,18 +688,9 @@ EXPORT_SYMBOL(acpi_os_wait_events_complete);
 /*
  * Allocate the memory for a spinlock and initialize it.
  */
-acpi_status acpi_os_create_lock(acpi_handle * out_handle)
+acpi_status acpi_os_create_lock(acpi_spinlock * handle)
 {
-	spinlock_t *lock_ptr;
-
-
-	lock_ptr = acpi_os_allocate(sizeof(spinlock_t));
-
-	spin_lock_init(lock_ptr);
-
-	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Creating spinlock[%p].\n", lock_ptr));
-
-	*out_handle = lock_ptr;
+	spin_lock_init(*handle);
 
 	return AE_OK;
 }
@@ -707,13 +698,8 @@ acpi_status acpi_os_create_lock(acpi_handle * out_handle)
 /*
  * Deallocate the memory for a spinlock.
  */
-void acpi_os_delete_lock(acpi_handle handle)
+void acpi_os_delete_lock(acpi_spinlock handle)
 {
-
-	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Deleting spinlock[%p].\n", handle));
-
-	acpi_os_free(handle);
-
 	return;
 }
 
@@ -1037,10 +1023,10 @@ EXPORT_SYMBOL(max_cstate);
  * handle is a pointer to the spinlock_t.
  */
 
-acpi_cpu_flags acpi_os_acquire_lock(acpi_handle handle)
+acpi_cpu_flags acpi_os_acquire_lock(acpi_spinlock lockp)
 {
 	acpi_cpu_flags flags;
-	spin_lock_irqsave((spinlock_t *) handle, flags);
+	spin_lock_irqsave(lockp, flags);
 	return flags;
 }
 
@@ -1048,9 +1034,9 @@ acpi_cpu_flags acpi_os_acquire_lock(acpi_handle handle)
  * Release a spinlock. See above.
  */
 
-void acpi_os_release_lock(acpi_handle handle, acpi_cpu_flags flags)
+void acpi_os_release_lock(acpi_spinlock lockp, acpi_cpu_flags flags)
 {
-	spin_unlock_irqrestore((spinlock_t *) handle, flags);
+	spin_unlock_irqrestore(lockp, flags);
 }
 
 #ifndef ACPI_USE_LOCAL_CACHE

commit d550d98d3317378d93a4869db204725d270ec812
Author: Patrick Mochel <mochel@linux.intel.com>
Date:   Tue Jun 27 00:41:40 2006 -0400

    ACPI: delete tracing macros from drivers/acpi/*.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 7d4cc122b026..8e46d1b39491 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -587,19 +587,18 @@ static void acpi_os_execute_deferred(void *context)
 {
 	struct acpi_os_dpc *dpc = NULL;
 
-	ACPI_FUNCTION_TRACE("os_execute_deferred");
 
 	dpc = (struct acpi_os_dpc *)context;
 	if (!dpc) {
 		printk(KERN_ERR PREFIX "Invalid (NULL) context\n");
-		return_VOID;
+		return;
 	}
 
 	dpc->function(dpc->context);
 
 	kfree(dpc);
 
-	return_VOID;
+	return;
 }
 
 static int acpi_os_execute_thread(void *context)
@@ -693,7 +692,6 @@ acpi_status acpi_os_create_lock(acpi_handle * out_handle)
 {
 	spinlock_t *lock_ptr;
 
-	ACPI_FUNCTION_TRACE("os_create_lock");
 
 	lock_ptr = acpi_os_allocate(sizeof(spinlock_t));
 
@@ -703,7 +701,7 @@ acpi_status acpi_os_create_lock(acpi_handle * out_handle)
 
 	*out_handle = lock_ptr;
 
-	return_ACPI_STATUS(AE_OK);
+	return AE_OK;
 }
 
 /*
@@ -711,13 +709,12 @@ acpi_status acpi_os_create_lock(acpi_handle * out_handle)
  */
 void acpi_os_delete_lock(acpi_handle handle)
 {
-	ACPI_FUNCTION_TRACE("os_create_lock");
 
 	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Deleting spinlock[%p].\n", handle));
 
 	acpi_os_free(handle);
 
-	return_VOID;
+	return;
 }
 
 acpi_status
@@ -725,11 +722,10 @@ acpi_os_create_semaphore(u32 max_units, u32 initial_units, acpi_handle * handle)
 {
 	struct semaphore *sem = NULL;
 
-	ACPI_FUNCTION_TRACE("os_create_semaphore");
 
 	sem = acpi_os_allocate(sizeof(struct semaphore));
 	if (!sem)
-		return_ACPI_STATUS(AE_NO_MEMORY);
+		return AE_NO_MEMORY;
 	memset(sem, 0, sizeof(struct semaphore));
 
 	sema_init(sem, initial_units);
@@ -739,7 +735,7 @@ acpi_os_create_semaphore(u32 max_units, u32 initial_units, acpi_handle * handle)
 	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Creating semaphore[%p|%d].\n",
 			  *handle, initial_units));
 
-	return_ACPI_STATUS(AE_OK);
+	return AE_OK;
 }
 
 EXPORT_SYMBOL(acpi_os_create_semaphore);
@@ -755,17 +751,16 @@ acpi_status acpi_os_delete_semaphore(acpi_handle handle)
 {
 	struct semaphore *sem = (struct semaphore *)handle;
 
-	ACPI_FUNCTION_TRACE("os_delete_semaphore");
 
 	if (!sem)
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
+		return AE_BAD_PARAMETER;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Deleting semaphore[%p].\n", handle));
 
 	acpi_os_free(sem);
 	sem = NULL;
 
-	return_ACPI_STATUS(AE_OK);
+	return AE_OK;
 }
 
 EXPORT_SYMBOL(acpi_os_delete_semaphore);
@@ -785,13 +780,12 @@ acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
 	struct semaphore *sem = (struct semaphore *)handle;
 	int ret = 0;
 
-	ACPI_FUNCTION_TRACE("os_wait_semaphore");
 
 	if (!sem || (units < 1))
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
+		return AE_BAD_PARAMETER;
 
 	if (units > 1)
-		return_ACPI_STATUS(AE_SUPPORT);
+		return AE_SUPPORT;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Waiting for semaphore[%p|%d|%d]\n",
 			  handle, units, timeout));
@@ -850,7 +844,7 @@ acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
 				  units, timeout));
 	}
 
-	return_ACPI_STATUS(status);
+	return status;
 }
 
 EXPORT_SYMBOL(acpi_os_wait_semaphore);
@@ -862,20 +856,19 @@ acpi_status acpi_os_signal_semaphore(acpi_handle handle, u32 units)
 {
 	struct semaphore *sem = (struct semaphore *)handle;
 
-	ACPI_FUNCTION_TRACE("os_signal_semaphore");
 
 	if (!sem || (units < 1))
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
+		return AE_BAD_PARAMETER;
 
 	if (units > 1)
-		return_ACPI_STATUS(AE_SUPPORT);
+		return AE_SUPPORT;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Signaling semaphore[%p|%d]\n", handle,
 			  units));
 
 	up(sem);
 
-	return_ACPI_STATUS(AE_OK);
+	return AE_OK;
 }
 
 EXPORT_SYMBOL(acpi_os_signal_semaphore);

commit 6468463abd7051fcc29f3ee7c931f9bbbb26f5a4
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jun 26 23:41:38 2006 -0400

    ACPI: un-export ACPI_ERROR() -- use printk(KERN_ERR...)
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 2d90b8d2dd73..7d4cc122b026 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -591,7 +591,7 @@ static void acpi_os_execute_deferred(void *context)
 
 	dpc = (struct acpi_os_dpc *)context;
 	if (!dpc) {
-		ACPI_ERROR((AE_INFO, "Invalid (NULL) context"));
+		printk(KERN_ERR PREFIX "Invalid (NULL) context\n");
 		return_VOID;
 	}
 

commit 9e7e2c047503db5a094ab30c7b4b8a5a0a324915
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Apr 27 05:25:00 2006 -0400

    ACPI: acpi_os_wait_semaphore(): silence complaint
    
    The ASL Acquire operator (17.5.1 in ACPI 3.0 spec) is allowed to time out
    and return True without acquiring the semaphore.  There's no indication in
    the spec that this is an actual error, so this message should be
    debug-only, as the message for successful acquisition is.
    
    This used to be an ACPI_DEBUG_PRINT, but it was mis-classified as
    ACPI_DB_ERROR rather than ACPI_DB_MUTEX, so it got swept up in Thomas'
    recent patch to enable ACPI error messages even without CONFIG_ACPI_DEBUG.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 740a3c414898..2d90b8d2dd73 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -840,7 +840,7 @@ acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
 	}
 
 	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, status,
+		ACPI_DEBUG_PRINT((ACPI_DB_MUTEX,
 				  "Failed to acquire semaphore[%p|%d|%d], %s",
 				  handle, units, timeout,
 				  acpi_format_exception(status)));

commit a6fc67202e0224e6c9d1d285cc0b444bce887ed5
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jun 26 23:58:43 2006 -0400

    ACPI: Enable ACPI error messages w/o CONFIG_ACPI_DEBUG
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 1bb558adee66..740a3c414898 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -137,6 +137,7 @@ void acpi_os_vprintf(const char *fmt, va_list args)
 #endif
 }
 
+
 extern int acpi_in_resume;
 void *acpi_os_allocate(acpi_size size)
 {
@@ -590,7 +591,7 @@ static void acpi_os_execute_deferred(void *context)
 
 	dpc = (struct acpi_os_dpc *)context;
 	if (!dpc) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
+		ACPI_ERROR((AE_INFO, "Invalid (NULL) context"));
 		return_VOID;
 	}
 
@@ -839,13 +840,13 @@ acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
 	}
 
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Failed to acquire semaphore[%p|%d|%d], %s\n",
+		ACPI_EXCEPTION((AE_INFO, status,
+				  "Failed to acquire semaphore[%p|%d|%d], %s",
 				  handle, units, timeout,
 				  acpi_format_exception(status)));
 	} else {
 		ACPI_DEBUG_PRINT((ACPI_DB_MUTEX,
-				  "Acquired semaphore[%p|%d|%d]\n", handle,
+				  "Acquired semaphore[%p|%d|%d]", handle,
 				  units, timeout));
 	}
 

commit 4c90ece249992c7a2e3fc921e5cdb8eb92193067
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jun 8 16:29:00 2006 -0400

    ACPI: ACPICA 20060608
    
    Converted the locking mutex used for the ACPI hardware
    to a spinlock. This change should eliminate all problems
    caused by attempting to acquire a semaphore at interrupt
    level, and it means that all ACPICA external interfaces
    that directly access the ACPI hardware can be safely
    called from interrupt level.
    
    Fixed a regression introduced in 20060526 where the ACPI
    device initialization could be prematurely aborted with
    an AE_NOT_FOUND if a device did not have an optional
    _INI method.
    
    Fixed an IndexField issue where a write to the Data
    Register should be limited in size to the AccessSize
    (width) of the IndexField itself. (BZ 433, Fiodor Suietov)
    
    Fixed problem reports (Valery Podrezov) integrated: - Allow
    store of ThermalZone objects to Debug object.
    http://bugzilla.kernel.org/show_bug.cgi?id=5369
    http://bugzilla.kernel.org/show_bug.cgi?id=5370
    
    Fixed problem reports (Fiodor Suietov) integrated: -
    acpi_get_table_header() doesn't handle multiple instances
    correctly (BZ 364)
    
    Removed four global mutexes that were obsolete and were
    no longer being used.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e80ca4730a44..1bb558adee66 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -795,9 +795,6 @@ acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
 	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Waiting for semaphore[%p|%d|%d]\n",
 			  handle, units, timeout));
 
-	if (in_atomic())
-		timeout = 0;
-
 	switch (timeout) {
 		/*
 		 * No Wait:

commit b8d35192c55fb055792ff0641408eaaec7c88988
Author: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Fri May 5 03:23:00 2006 -0400

    ACPI: execute Notify() handlers on new thread
    
    http://bugzilla.kernel.org/show_bug.cgi?id=5534
    
    Thanks to Peter Wainwright for isolating the issue.
    Thanks to Andi Kleen and Bob Moore for feedback.
    Thanks to Richard Mace and others for testing.
    Updates by Konstantin Karasyov.
    
    Signed-off-by: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 109c3f8ae7df..e80ca4730a44 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -37,6 +37,7 @@
 #include <linux/delay.h>
 #include <linux/workqueue.h>
 #include <linux/nmi.h>
+#include <linux/kthread.h>
 #include <acpi/acpi.h>
 #include <asm/io.h>
 #include <acpi/acpi_bus.h>
@@ -600,23 +601,41 @@ static void acpi_os_execute_deferred(void *context)
 	return_VOID;
 }
 
-acpi_status
-acpi_os_queue_for_execution(u32 priority,
+static int acpi_os_execute_thread(void *context)
+{
+	struct acpi_os_dpc *dpc = (struct acpi_os_dpc *)context;
+	if (dpc) {
+		dpc->function(dpc->context);
+		kfree(dpc);
+	}
+	do_exit(0);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_execute
+ *
+ * PARAMETERS:  Type               - Type of the callback
+ *              Function           - Function to be executed
+ *              Context            - Function parameters
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Depending on type, either queues function for deferred execution or
+ *              immediately executes function on a separate thread.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_os_execute(acpi_execute_type type,
 			    acpi_osd_exec_callback function, void *context)
 {
 	acpi_status status = AE_OK;
 	struct acpi_os_dpc *dpc;
 	struct work_struct *task;
-
-	ACPI_FUNCTION_TRACE("os_queue_for_execution");
-
-	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
-			  "Scheduling function [%p(%p)] for deferred execution.\n",
-			  function, context));
+	struct task_struct *p;
 
 	if (!function)
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-
+		return AE_BAD_PARAMETER;
 	/*
 	 * Allocate/initialize DPC structure.  Note that this memory will be
 	 * freed by the callee.  The kernel handles the tq_struct list  in a
@@ -627,30 +646,37 @@ acpi_os_queue_for_execution(u32 priority,
 	 * We can save time and code by allocating the DPC and tq_structs
 	 * from the same memory.
 	 */
-
-	dpc =
-	    kmalloc(sizeof(struct acpi_os_dpc) + sizeof(struct work_struct),
-		    GFP_ATOMIC);
+	if (type == OSL_NOTIFY_HANDLER) {
+		dpc = kmalloc(sizeof(struct acpi_os_dpc), GFP_KERNEL);
+	} else {
+		dpc = kmalloc(sizeof(struct acpi_os_dpc) +
+				sizeof(struct work_struct), GFP_ATOMIC);
+	}
 	if (!dpc)
-		return_ACPI_STATUS(AE_NO_MEMORY);
-
+		return AE_NO_MEMORY;
 	dpc->function = function;
 	dpc->context = context;
 
-	task = (void *)(dpc + 1);
-	INIT_WORK(task, acpi_os_execute_deferred, (void *)dpc);
-
-	if (!queue_work(kacpid_wq, task)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Call to queue_work() failed.\n"));
-		kfree(dpc);
-		status = AE_ERROR;
+	if (type == OSL_NOTIFY_HANDLER) {
+		p = kthread_create(acpi_os_execute_thread, dpc, "kacpid_notify");
+		if (!IS_ERR(p)) {
+			wake_up_process(p);
+		} else {
+			status = AE_NO_MEMORY;
+			kfree(dpc);
+		}
+	} else {
+		task = (void *)(dpc + 1);
+		INIT_WORK(task, acpi_os_execute_deferred, (void *)dpc);
+		if (!queue_work(kacpid_wq, task)) {
+			status = AE_ERROR;
+			kfree(dpc);
+		}
 	}
-
-	return_ACPI_STATUS(status);
+	return status;
 }
 
-EXPORT_SYMBOL(acpi_os_queue_for_execution);
+EXPORT_SYMBOL(acpi_os_execute);
 
 void acpi_os_wait_events_complete(void *context)
 {

commit b229cf92eee616c7cb5ad8cdb35a19b119f00bc8
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Apr 21 17:15:00 2006 -0400

    ACPI: ACPICA 20060421
    
    Removed a device initialization optimization introduced in
    20051216 where the _STA method was not run unless an _INI
    was also present for the same device. This optimization
    could cause problems because it could allow _INI methods
    to be run within a not-present device subtree (If a
    not-present device had no _INI, _STA would not be run,
    the not-present status would not be discovered, and the
    children of the device would be incorrectly traversed.)
    
    Implemented a new _STA optimization where namespace
    subtrees that do not contain _INI are identified and
    ignored during device initialization. Selectively running
    _STA can significantly improve boot time on large machines
    (with assistance from Len Brown.)
    
    Implemented support for the device initialization case
    where the returned _STA flags indicate a device not-present
    but functioning. In this case, _INI is not run, but the
    device children are examined for presence, as per the
    ACPI specification.
    
    Implemented an additional change to the IndexField support
    in order to conform to MS behavior. The value written to
    the Index Register is not simply a byte offset, it is a
    byte offset in units of the access width of the parent
    Index Field. (Fiodor Suietov)
    
    Defined and deployed a new OSL interface,
    acpi_os_validate_address().  This interface is called during
    the creation of all AML operation regions, and allows
    the host OS to exert control over what addresses it will
    allow the AML code to access. Operation Regions whose
    addresses are disallowed will cause a runtime exception
    when they are actually accessed (will not affect or abort
    table loading.)
    
    Defined and deployed a new OSL interface,
    acpi_os_validate_interface().  This interface allows the host OS
    to match the various "optional" interface/behavior strings
    for the _OSI predefined control method as appropriate
    (with assistance from Bjorn Helgaas.)
    
    Restructured and corrected various problems in the
    exception handling code paths within DsCallControlMethod
    and DsTerminateControlMethod in dsmethod (with assistance
    from Takayoshi Kochi.)
    
    Modified the Linux source converter to ignore quoted string
    literals while converting identifiers from mixed to lower
    case. This will correct problems with the disassembler
    and other areas where such strings must not be modified.
    
    The ACPI_FUNCTION_* macros no longer require quotes around
    the function name. This allows the Linux source converter
    to convert the names, now that the converter ignores
    quoted strings.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 006b31a56559..109c3f8ae7df 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1042,12 +1042,12 @@ void acpi_os_release_lock(acpi_handle handle, acpi_cpu_flags flags)
  *
  * FUNCTION:    acpi_os_create_cache
  *
- * PARAMETERS:  CacheName       - Ascii name for the cache
- *              ObjectSize      - Size of each cached object
- *              MaxDepth        - Maximum depth of the cache (in objects)
- *              ReturnCache     - Where the new cache object is returned
+ * PARAMETERS:  name      - Ascii name for the cache
+ *              size      - Size of each cached object
+ *              depth     - Maximum depth of the cache (in objects) <ignored>
+ *              cache     - Where the new cache object is returned
  *
- * RETURN:      Status
+ * RETURN:      status
  *
  * DESCRIPTION: Create a cache object
  *
@@ -1057,7 +1057,10 @@ acpi_status
 acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)
 {
 	*cache = kmem_cache_create(name, size, 0, 0, NULL, NULL);
-	return AE_OK;
+	if (cache == NULL)
+		return AE_ERROR;
+	else
+		return AE_OK;
 }
 
 /*******************************************************************************
@@ -1137,4 +1140,52 @@ void *acpi_os_acquire_object(acpi_cache_t * cache)
 	return object;
 }
 
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_os_validate_interface
+ *
+ * PARAMETERS:  interface           - Requested interface to be validated
+ *
+ * RETURN:      AE_OK if interface is supported, AE_SUPPORT otherwise
+ *
+ * DESCRIPTION: Match an interface string to the interfaces supported by the
+ *              host. Strings originate from an AML call to the _OSI method.
+ *
+ *****************************************************************************/
+
+acpi_status
+acpi_os_validate_interface (char *interface)
+{
+
+    return AE_SUPPORT;
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_os_validate_address
+ *
+ * PARAMETERS:  space_id             - ACPI space ID
+ *              address             - Physical address
+ *              length              - Address length
+ *
+ * RETURN:      AE_OK if address/length is valid for the space_id. Otherwise,
+ *              should return AE_AML_ILLEGAL_ADDRESS.
+ *
+ * DESCRIPTION: Validate a system address via the host OS. Used to validate
+ *              the addresses accessed by AML operation regions.
+ *
+ *****************************************************************************/
+
+acpi_status
+acpi_os_validate_address (
+    u8                   space_id,
+    acpi_physical_address   address,
+    acpi_size               length)
+{
+
+    return AE_OK;
+}
+
+
 #endif

commit 61686124f47d7c4b78610346c5f8f9d8a6d46bb5
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Mar 17 16:44:00 2006 -0500

    [ACPI] ACPICA 20060317
    
    Implemented the use of a cache object for all internal
    namespace nodes. Since there are about 1000 static nodes
    in a typical system, this will decrease memory use for
    cache implementations that minimize per-allocation overhead
    (such as a slab allocator.)
    
    Removed the reference count mechanism for internal
    namespace nodes, since it was deemed unnecessary. This
    reduces the size of each namespace node by about 5%-10%
    on all platforms. Nodes are now 20 bytes for the 32-bit
    case, and 32 bytes for the 64-bit case.
    
    Optimized several internal data structures to reduce
    object size on 64-bit platforms by packing data within
    the 64-bit alignment. This includes the frequently used
    ACPI_OPERAND_OBJECT, of which there can be ~1000 static
    instances corresponding to the namespace objects.
    
    Added two new strings for the predefined _OSI method:
    "Windows 2001.1 SP1" and "Windows 2006".
    
    Split the allocation tracking mechanism out to a separate
    file, from utalloc.c to uttrack.c. This mechanism appears
    to be only useful for application-level code. Kernels may
    wish to not include uttrack.c in distributions.
    
    Removed all remnants of the obsolete ACPI_REPORT_* macros
    and the associated code. (These macros have been replaced
    by the ACPI_ERROR and ACPI_WARNING macros.)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 56d97f1d108f..006b31a56559 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1126,14 +1126,13 @@ acpi_status acpi_os_release_object(acpi_cache_t * cache, void *object)
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Get an object from the specified cache.  If cache is empty,
- *              the object is allocated.
+ * DESCRIPTION: Return a zero-filled object.
  *
  ******************************************************************************/
 
 void *acpi_os_acquire_object(acpi_cache_t * cache)
 {
-	void *object = kmem_cache_alloc(cache, GFP_KERNEL);
+	void *object = kmem_cache_zalloc(cache, GFP_KERNEL);
 	WARN_ON(!object);
 	return object;
 }

commit ec7381d6bfd3e7b8d2880dd5e9d03b131b0603f6
Author: Len Brown <lenb@toshiba.site>
Date:   Sat Apr 1 05:12:23 2006 -0500

    ACPI: inline trivial acpi_os_get_thread_id()
    
    acpi_os_get_thread_id() is used only for debugging
    code that is not enabled on Linux, so stub it out.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 13b5fd5854a8..56d97f1d108f 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -896,14 +896,6 @@ u8 acpi_os_writable(void *ptr, acpi_size len)
 }
 #endif
 
-u32 acpi_os_get_thread_id(void)
-{
-	if (!in_atomic())
-		return current->pid;
-
-	return 0;
-}
-
 acpi_status acpi_os_signal(u32 function, void *info)
 {
 	switch (function) {

commit 9f4fd61fa7c13ea905dac18b9baa766a35b88485
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Sun Mar 26 01:37:10 2006 -0800

    [PATCH] ACPI: clean up memory attribute checking for map/read/write
    
    ia64 ioremap is now smart enough to use the correct memory attributes, so
    remove the EFI checks from osl.c.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Matt Domsch <Matt_Domsch@dell.com>
    Cc: "Tolentino, Matthew E" <matthew.e.tolentino@intel.com>
    Cc: "Brown, Len" <len.brown@intel.com>
    Cc: Andi Kleen <ak@muc.de>
    Acked-by: "Luck, Tony" <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index fc8a3bce6cbb..13b5fd5854a8 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -180,22 +180,14 @@ acpi_status
 acpi_os_map_memory(acpi_physical_address phys, acpi_size size,
 		   void __iomem ** virt)
 {
-	if (efi_enabled) {
-		if (EFI_MEMORY_WB & efi_mem_attributes(phys)) {
-			*virt = (void __iomem *)phys_to_virt(phys);
-		} else {
-			*virt = ioremap(phys, size);
-		}
-	} else {
-		if (phys > ULONG_MAX) {
-			printk(KERN_ERR PREFIX "Cannot map memory that high\n");
-			return AE_BAD_PARAMETER;
-		}
-		/*
-		 * ioremap checks to ensure this is in reserved space
-		 */
-		*virt = ioremap((unsigned long)phys, size);
+	if (phys > ULONG_MAX) {
+		printk(KERN_ERR PREFIX "Cannot map memory that high\n");
+		return AE_BAD_PARAMETER;
 	}
+	/*
+	 * ioremap checks to ensure this is in reserved space
+	 */
+	*virt = ioremap((unsigned long)phys, size);
 
 	if (!*virt)
 		return AE_NO_MEMORY;
@@ -407,18 +399,8 @@ acpi_os_read_memory(acpi_physical_address phys_addr, u32 * value, u32 width)
 {
 	u32 dummy;
 	void __iomem *virt_addr;
-	int iomem = 0;
 
-	if (efi_enabled) {
-		if (EFI_MEMORY_WB & efi_mem_attributes(phys_addr)) {
-			/* HACK ALERT! We can use readb/w/l on real memory too.. */
-			virt_addr = (void __iomem *)phys_to_virt(phys_addr);
-		} else {
-			iomem = 1;
-			virt_addr = ioremap(phys_addr, width);
-		}
-	} else
-		virt_addr = (void __iomem *)phys_to_virt(phys_addr);
+	virt_addr = ioremap(phys_addr, width);
 	if (!value)
 		value = &dummy;
 
@@ -436,10 +418,7 @@ acpi_os_read_memory(acpi_physical_address phys_addr, u32 * value, u32 width)
 		BUG();
 	}
 
-	if (efi_enabled) {
-		if (iomem)
-			iounmap(virt_addr);
-	}
+	iounmap(virt_addr);
 
 	return AE_OK;
 }
@@ -448,18 +427,8 @@ acpi_status
 acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
 {
 	void __iomem *virt_addr;
-	int iomem = 0;
 
-	if (efi_enabled) {
-		if (EFI_MEMORY_WB & efi_mem_attributes(phys_addr)) {
-			/* HACK ALERT! We can use writeb/w/l on real memory too */
-			virt_addr = (void __iomem *)phys_to_virt(phys_addr);
-		} else {
-			iomem = 1;
-			virt_addr = ioremap(phys_addr, width);
-		}
-	} else
-		virt_addr = (void __iomem *)phys_to_virt(phys_addr);
+	virt_addr = ioremap(phys_addr, width);
 
 	switch (width) {
 	case 8:
@@ -475,8 +444,7 @@ acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
 		BUG();
 	}
 
-	if (iomem)
-		iounmap(virt_addr);
+	iounmap(virt_addr);
 
 	return AE_OK;
 }

commit b2c99e3c70d77fb194df5aa1642030080d28ea48
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Sun Mar 26 01:37:08 2006 -0800

    [PATCH] EFI: keep physical table addresses in efi structure
    
    Almost all users of the table addresses from the EFI system table want
    physical addresses.  So rather than doing the pa->va->pa conversion, just keep
    physical addresses in struct efi.
    
    This fixes a DMI bug: the efi structure contained the physical SMBIOS address
    on x86 but the virtual address on ia64, so dmi_scan_machine() used ioremap()
    on a virtual address on ia64.
    
    This is essentially the same as an earlier patch by Matt Tolentino:
            http://marc.theaimsgroup.com/?l=linux-kernel&m=112130292316281&w=2
    except that this changes all table addresses, not just ACPI addresses.
    
    Matt's original patch was backed out because it caused MCAs on HP sx1000
    systems.  That problem is resolved by the ioremap() attribute checking added
    for ia64.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Matt Domsch <Matt_Domsch@dell.com>
    Cc: "Tolentino, Matthew E" <matthew.e.tolentino@intel.com>
    Cc: "Brown, Len" <len.brown@intel.com>
    Cc: Andi Kleen <ak@muc.de>
    Acked-by: "Luck, Tony" <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index ac5bbaedac1b..fc8a3bce6cbb 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -156,12 +156,10 @@ acpi_status acpi_os_get_root_pointer(u32 flags, struct acpi_pointer *addr)
 {
 	if (efi_enabled) {
 		addr->pointer_type = ACPI_PHYSICAL_POINTER;
-		if (efi.acpi20)
-			addr->pointer.physical =
-			    (acpi_physical_address) virt_to_phys(efi.acpi20);
-		else if (efi.acpi)
-			addr->pointer.physical =
-			    (acpi_physical_address) virt_to_phys(efi.acpi);
+		if (efi.acpi20 != EFI_INVALID_TABLE_ADDR)
+			addr->pointer.physical = efi.acpi20;
+		else if (efi.acpi != EFI_INVALID_TABLE_ADDR)
+			addr->pointer.physical = efi.acpi;
 		else {
 			printk(KERN_ERR PREFIX
 			       "System description tables not found\n");

commit b8e4d89357fc434618a59c1047cac72641191805
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 27 16:43:00 2006 -0500

    [ACPI] ACPICA 20060127
    
    Implemented support in the Resource Manager to allow
    unresolved namestring references within resource package
    objects for the _PRT method. This support is in addition
    to the previously implemented unresolved reference
    support within the AML parser. If the interpreter slack
    mode is enabled (true on Linux unless acpi=strict),
    these unresolved references will be passed through
    to the caller as a NULL package entry.
    http://bugzilla.kernel.org/show_bug.cgi?id=5741
    
    Implemented and deployed new macros and functions for
    error and warning messages across the subsystem. These
    macros are simpler and generate less code than their
    predecessors. The new macros ACPI_ERROR, ACPI_EXCEPTION,
    ACPI_WARNING, and ACPI_INFO replace the ACPI_REPORT_*
    macros.
    
    Implemented the acpi_cpu_flags type to simplify host OS
    integration of the Acquire/Release Lock OSL interfaces.
    Suggested by Steven Rostedt and Andrew Morton.
    
    Fixed a problem where Alias ASL operators are sometimes
    not correctly resolved. causing AE_AML_INTERNAL
    http://bugzilla.kernel.org/show_bug.cgi?id=5189
    http://bugzilla.kernel.org/show_bug.cgi?id=5674
    
    Fixed several problems with the implementation of the
    ConcatenateResTemplate ASL operator. As per the ACPI
    specification, zero length buffers are now treated as a
    single EndTag. One-length buffers always cause a fatal
    exception. Non-zero length buffers that do not end with
    a full 2-byte EndTag cause a fatal exception.
    
    Fixed a possible structure overwrite in the
    AcpiGetObjectInfo external interface. (With assistance
    from Thomas Renninger)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index cc4a4903842a..ac5bbaedac1b 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1062,9 +1062,9 @@ EXPORT_SYMBOL(max_cstate);
  * handle is a pointer to the spinlock_t.
  */
 
-acpi_native_uint acpi_os_acquire_lock(acpi_handle handle)
+acpi_cpu_flags acpi_os_acquire_lock(acpi_handle handle)
 {
-	unsigned long flags;
+	acpi_cpu_flags flags;
 	spin_lock_irqsave((spinlock_t *) handle, flags);
 	return flags;
 }
@@ -1073,9 +1073,9 @@ acpi_native_uint acpi_os_acquire_lock(acpi_handle handle)
  * Release a spinlock. See above.
  */
 
-void acpi_os_release_lock(acpi_handle handle, acpi_native_uint flags)
+void acpi_os_release_lock(acpi_handle handle, acpi_cpu_flags flags)
 {
-	spin_unlock_irqrestore((spinlock_t *) handle, (unsigned long) flags);
+	spin_unlock_irqrestore((spinlock_t *) handle, flags);
 }
 
 #ifndef ACPI_USE_LOCAL_CACHE

commit 9fdb62af92c741addbea15545f214a6e89460865
Merge: 3ee68c4af3fd 876c184b31dc 729b4d4ce198 cf8247884018 dacd9b803555 63c94b68ec30 35f652b5ef4e 1a38416cea8a 4a90c7e86202 aea19aa0780d 757b18661ea0 c4bb6f5ad968
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jan 24 17:52:48 2006 -0500

    [ACPI] merge 3549 4320 4485 4588 4980 5483 5651 acpica asus fops pnpacpi branches into release
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 55a82ab3181be039c6440d3f2f69260ad6fe2988
Author: Kylene Jo Hall <kjhall@us.ibm.com>
Date:   Sun Jan 8 01:03:15 2006 -0800

    [PATCH] tpm: add bios measurement log
    
    According to the TCG specifications measurements or hashes of the BIOS code
    and data are extended into TPM PCRS and a log is kept in an ACPI table of
    these extensions for later validation if desired.  This patch exports the
    values in the ACPI table through a security-fs seq_file.
    
    Signed-off-by: Seiji Munetoh <munetoh@jp.ibm.com>
    Signed-off-by: Stefan Berger <stefanb@us.ibm.com>
    Signed-off-by: Reiner Sailer <sailer@us.ibm.com>
    Signed-off-by: Kylene Hall <kjhall@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e3cd0b16031a..20c9a37643c7 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -204,11 +204,13 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size,
 
 	return AE_OK;
 }
+EXPORT_SYMBOL_GPL(acpi_os_map_memory);
 
 void acpi_os_unmap_memory(void __iomem * virt, acpi_size size)
 {
 	iounmap(virt);
 }
+EXPORT_SYMBOL_GPL(acpi_os_unmap_memory);
 
 #ifdef ACPI_FUTURE_USAGE
 acpi_status

commit dacd9b80355525be0e3c519687868410e304ad1c
Author: Yu Luming <luming.yu@intel.com>
Date:   Sat Dec 31 01:45:00 2005 -0500

    [ACPI] fix acpi_os_wait_sempahore() finite timeout case (AE_TIME warning)
    
    Before this fix, the finite timeout case
    behaved like the no-timeout (trylock) case.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=4588
    
    Signed-off-by: Luming Yu <luming.yu@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e3cd0b16031a..8653dac01a76 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -836,7 +836,7 @@ acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
 			static const int quantum_ms = 1000 / HZ;
 
 			ret = down_trylock(sem);
-			for (i = timeout; (i > 0 && ret < 0); i -= quantum_ms) {
+			for (i = timeout; (i > 0 && ret != 0); i -= quantum_ms) {
 				schedule_timeout_interruptible(1);
 				ret = down_trylock(sem);
 			}

commit 3173cdfe02995f6c6841a28b5148f94cefd8ab77
Author: Len Brown <len.brown@intel.com>
Date:   Wed Dec 28 03:20:03 2005 -0500

    [ACPI] fix osl.c build warning
    
    typecheck complains on i386 that u32 != unsigned long
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 4ece850b2af1..58e7c47354ee 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1073,7 +1073,7 @@ acpi_native_uint acpi_os_acquire_lock(acpi_handle handle)
 
 void acpi_os_release_lock(acpi_handle handle, acpi_native_uint flags)
 {
-	spin_unlock_irqrestore((spinlock_t *) handle, flags);
+	spin_unlock_irqrestore((spinlock_t *) handle, (unsigned long) flags);
 }
 
 #ifndef ACPI_USE_LOCAL_CACHE

commit 0897831bb54eb36fd9e2a22da7f0f64be1b20d09
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Oct 21 00:00:00 2005 -0400

    [ACPI] ACPICA 20051021
    
    Implemented support for the EM64T and other x86_64
    processors. This essentially entails recognizing
    that these processors support non-aligned memory
    transfers. Previously, all 64-bit processors were assumed
    to lack hardware support for non-aligned transfers.
    
    Completed conversion of the Resource Manager to nearly
    full table-driven operation. Specifically, the resource
    conversion code (convert AML to internal format and the
    reverse) and the debug code to dump internal resource
    descriptors are fully table-driven, reducing code and data
    size and improving maintainability.
    
    The OSL interfaces for Acquire and Release Lock now use a
    64-bit flag word on 64-bit processors instead of a fixed
    32-bit word. (Alexey Starikovskiy)
    
    Implemented support within the resource conversion code
    for the Type-Specific byte within the various ACPI 3.0
    *WordSpace macros.
    
    Fixed some issues within the resource conversion code for
    the type-specific flags for both Memory and I/O address
    resource descriptors. For Memory, implemented support
    for the MTP and TTP flags. For I/O, split the TRS and TTP
    flags into two separate fields.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e3cd0b16031a..4ece850b2af1 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1058,11 +1058,9 @@ EXPORT_SYMBOL(max_cstate);
  * Acquire a spinlock.
  *
  * handle is a pointer to the spinlock_t.
- * flags is *not* the result of save_flags - it is an ACPI-specific flag variable
- *   that indicates whether we are at interrupt level.
  */
 
-unsigned long acpi_os_acquire_lock(acpi_handle handle)
+acpi_native_uint acpi_os_acquire_lock(acpi_handle handle)
 {
 	unsigned long flags;
 	spin_lock_irqsave((spinlock_t *) handle, flags);
@@ -1073,7 +1071,7 @@ unsigned long acpi_os_acquire_lock(acpi_handle handle)
  * Release a spinlock. See above.
  */
 
-void acpi_os_release_lock(acpi_handle handle, unsigned long flags)
+void acpi_os_release_lock(acpi_handle handle, acpi_native_uint flags)
 {
 	spin_unlock_irqrestore((spinlock_t *) handle, flags);
 }

commit 01a527ec7c62efea601a39f0cd8e6a8517259014
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Mon Nov 7 01:01:14 2005 -0800

    [PATCH] drivers/acpi: fix-up schedule_timeout() usage
    
    Use schedule_timeout_interruptible() instead of
    set_current_state()/schedule_timeout() to reduce kernel size.  Also use
    msecs_to_jiffies() instead of direct HZ division to avoid rounding errors.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Cc: "Brown, Len" <len.brown@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index d528c750a380..e3cd0b16031a 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -313,8 +313,7 @@ acpi_status acpi_os_remove_interrupt_handler(u32 irq, acpi_osd_handler handler)
 
 void acpi_os_sleep(acpi_integer ms)
 {
-	current->state = TASK_INTERRUPTIBLE;
-	schedule_timeout(((signed long)ms * HZ) / 1000);
+	schedule_timeout_interruptible(msecs_to_jiffies(ms));
 }
 
 EXPORT_SYMBOL(acpi_os_sleep);
@@ -838,8 +837,7 @@ acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
 
 			ret = down_trylock(sem);
 			for (i = timeout; (i > 0 && ret < 0); i -= quantum_ms) {
-				current->state = TASK_INTERRUPTIBLE;
-				schedule_timeout(1);
+				schedule_timeout_interruptible(1);
 				ret = down_trylock(sem);
 			}
 

commit 8713cbefafbb5a101ade541a4b0ffa108bf697cc
Author: Adrian Bunk <bunk@stusta.de>
Date:   Fri Sep 2 17:16:48 2005 -0400

    [ACPI] add static to function definitions
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index dc69d8760a54..d528c750a380 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1040,7 +1040,7 @@ static int __init acpi_wake_gpes_always_on_setup(char *str)
 
 __setup("acpi_wake_gpes_always_on", acpi_wake_gpes_always_on_setup);
 
-int __init acpi_hotkey_setup(char *str)
+static int __init acpi_hotkey_setup(char *str)
 {
 	acpi_specific_hotkey_enabled = FALSE;
 	return 1;

commit 6153df7b2f4d27c8bde054db1b947369a6f64d83
Author: Len Brown <len.brown@intel.com>
Date:   Thu Aug 25 12:27:09 2005 -0400

    [ACPI] delete CONFIG_ACPI_PCI
    
    Delete the ability to build an ACPI kernel that does
    not include PCI support.  When such a machine is created
    and it requires a tuned kernel, send a patch.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=1364
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 81f0eb863a76..dc69d8760a54 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -86,13 +86,11 @@ acpi_status acpi_os_initialize1(void)
 	 * Initialize PCI configuration space access, as we'll need to access
 	 * it while walking the namespace (bus 0 and root bridges w/ _BBNs).
 	 */
-#ifdef CONFIG_ACPI_PCI
 	if (!raw_pci_ops) {
 		printk(KERN_ERR PREFIX
 		       "Access to PCI configuration space unavailable\n");
 		return AE_NULL_ENTRY;
 	}
-#endif
 	kacpid_wq = create_singlethread_workqueue("kacpid");
 	BUG_ON(!kacpid_wq);
 
@@ -484,8 +482,6 @@ acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
 	return AE_OK;
 }
 
-#ifdef CONFIG_ACPI_PCI
-
 acpi_status
 acpi_os_read_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
 			       void *value, u32 width)
@@ -618,30 +614,6 @@ void acpi_os_derive_pci_id(acpi_handle rhandle,	/* upper bound  */
 	acpi_os_derive_pci_id_2(rhandle, chandle, id, &is_bridge, &bus_number);
 }
 
-#else				/*!CONFIG_ACPI_PCI */
-
-acpi_status
-acpi_os_write_pci_configuration(struct acpi_pci_id * pci_id,
-				u32 reg, acpi_integer value, u32 width)
-{
-	return AE_SUPPORT;
-}
-
-acpi_status
-acpi_os_read_pci_configuration(struct acpi_pci_id * pci_id,
-			       u32 reg, void *value, u32 width)
-{
-	return AE_SUPPORT;
-}
-
-void acpi_os_derive_pci_id(acpi_handle rhandle,	/* upper bound  */
-			   acpi_handle chandle,	/* current node */
-			   struct acpi_pci_id **id)
-{
-}
-
-#endif				/*CONFIG_ACPI_PCI */
-
 static void acpi_os_execute_deferred(void *context)
 {
 	struct acpi_os_dpc *dpc = NULL;

commit cb220c1af49644786944c549518b491d4c654030
Merge: 1dadb3dadfaa f6869979bec3
Author: Len Brown <len.brown@intel.com>
Date:   Mon Aug 15 15:56:23 2005 -0400

    Merge 'acpi-2.6.12' branch into to-akpm

commit f6869979bec3cc2efddc7359f30ba37642084fb7
Merge: 50526df605e7 30e332f3307e
Author: Len Brown <len.brown@intel.com>
Date:   Mon Aug 15 15:52:00 2005 -0400

    Merge to-linus-stable into to-akpm

commit 30e332f3307e9f7718490a706e5ce99f0d3a7b26
Author: Luming Yu <luming.yu@intel.com>
Date:   Fri Aug 12 00:31:00 2005 -0400

    [ACPI] re-enable platform-specific hotkey drivers by default
    
    When both platform-specific and generic drivers exist,
    enable generic over-ride with "acpi_generic_hotkey".
    
    http://bugzilla.kernel.org/show_bug.cgi?id=4953
    
    Signed-off-by: Luming Yu <luming.yu@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index bdd9f37f8101..cb16cc11fee8 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -71,7 +71,7 @@ EXPORT_SYMBOL(acpi_in_debugger);
 extern char line_buf[80];
 #endif /*ENABLE_DEBUGGER*/
 
-int acpi_specific_hotkey_enabled;
+int acpi_specific_hotkey_enabled = TRUE;
 EXPORT_SYMBOL(acpi_specific_hotkey_enabled);
 
 static unsigned int acpi_irq_irq;
@@ -1158,11 +1158,11 @@ __setup("acpi_wake_gpes_always_on", acpi_wake_gpes_always_on_setup);
 int __init
 acpi_hotkey_setup(char *str)
 {
-	acpi_specific_hotkey_enabled = TRUE;
+	acpi_specific_hotkey_enabled = FALSE;
 	return 1;
 }
 
-__setup("acpi_specific_hotkey", acpi_hotkey_setup);
+__setup("acpi_generic_hotkey", acpi_hotkey_setup);
 
 /*
  * max_cstate is defined in the base kernel so modules can

commit 4be44fcd3bf648b782f4460fd06dfae6c42ded4b
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 5 00:44:28 2005 -0400

    [ACPI] Lindent all ACPI files
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index f3a807c342c0..9127760d36c5 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -45,16 +45,12 @@
 
 #include <linux/efi.h>
 
-
 #define _COMPONENT		ACPI_OS_SERVICES
-ACPI_MODULE_NAME	("osl")
-
+ACPI_MODULE_NAME("osl")
 #define PREFIX		"ACPI: "
-
-struct acpi_os_dpc
-{
-    acpi_osd_exec_callback  function;
-    void		    *context;
+struct acpi_os_dpc {
+	acpi_osd_exec_callback function;
+	void *context;
 };
 
 #ifdef CONFIG_ACPI_CUSTOM_DSDT
@@ -69,7 +65,7 @@ int acpi_in_debugger;
 EXPORT_SYMBOL(acpi_in_debugger);
 
 extern char line_buf[80];
-#endif /*ENABLE_DEBUGGER*/
+#endif				/*ENABLE_DEBUGGER */
 
 int acpi_specific_hotkey_enabled;
 EXPORT_SYMBOL(acpi_specific_hotkey_enabled);
@@ -79,14 +75,12 @@ static acpi_osd_handler acpi_irq_handler;
 static void *acpi_irq_context;
 static struct workqueue_struct *kacpid_wq;
 
-acpi_status
-acpi_os_initialize(void)
+acpi_status acpi_os_initialize(void)
 {
 	return AE_OK;
 }
 
-acpi_status
-acpi_os_initialize1(void)
+acpi_status acpi_os_initialize1(void)
 {
 	/*
 	 * Initialize PCI configuration space access, as we'll need to access
@@ -94,7 +88,8 @@ acpi_os_initialize1(void)
 	 */
 #ifdef CONFIG_ACPI_PCI
 	if (!raw_pci_ops) {
-		printk(KERN_ERR PREFIX "Access to PCI configuration space unavailable\n");
+		printk(KERN_ERR PREFIX
+		       "Access to PCI configuration space unavailable\n");
 		return AE_NULL_ENTRY;
 	}
 #endif
@@ -104,8 +99,7 @@ acpi_os_initialize1(void)
 	return AE_OK;
 }
 
-acpi_status
-acpi_os_terminate(void)
+acpi_status acpi_os_terminate(void)
 {
 	if (acpi_irq_handler) {
 		acpi_os_remove_interrupt_handler(acpi_irq_irq,
@@ -117,21 +111,20 @@ acpi_os_terminate(void)
 	return AE_OK;
 }
 
-void
-acpi_os_printf(const char *fmt,...)
+void acpi_os_printf(const char *fmt, ...)
 {
 	va_list args;
 	va_start(args, fmt);
 	acpi_os_vprintf(fmt, args);
 	va_end(args);
 }
+
 EXPORT_SYMBOL(acpi_os_printf);
 
-void
-acpi_os_vprintf(const char *fmt, va_list args)
+void acpi_os_vprintf(const char *fmt, va_list args)
 {
 	static char buffer[512];
-	
+
 	vsprintf(buffer, fmt, args);
 
 #ifdef ENABLE_DEBUGGER
@@ -146,8 +139,7 @@ acpi_os_vprintf(const char *fmt, va_list args)
 }
 
 extern int acpi_in_resume;
-void *
-acpi_os_allocate(acpi_size size)
+void *acpi_os_allocate(acpi_size size)
 {
 	if (acpi_in_resume)
 		return kmalloc(size, GFP_ATOMIC);
@@ -155,31 +147,32 @@ acpi_os_allocate(acpi_size size)
 		return kmalloc(size, GFP_KERNEL);
 }
 
-void
-acpi_os_free(void *ptr)
+void acpi_os_free(void *ptr)
 {
 	kfree(ptr);
 }
+
 EXPORT_SYMBOL(acpi_os_free);
 
-acpi_status
-acpi_os_get_root_pointer(u32 flags, struct acpi_pointer *addr)
+acpi_status acpi_os_get_root_pointer(u32 flags, struct acpi_pointer *addr)
 {
 	if (efi_enabled) {
 		addr->pointer_type = ACPI_PHYSICAL_POINTER;
 		if (efi.acpi20)
 			addr->pointer.physical =
-				(acpi_physical_address) virt_to_phys(efi.acpi20);
+			    (acpi_physical_address) virt_to_phys(efi.acpi20);
 		else if (efi.acpi)
 			addr->pointer.physical =
-				(acpi_physical_address) virt_to_phys(efi.acpi);
+			    (acpi_physical_address) virt_to_phys(efi.acpi);
 		else {
-			printk(KERN_ERR PREFIX "System description tables not found\n");
+			printk(KERN_ERR PREFIX
+			       "System description tables not found\n");
 			return AE_NOT_FOUND;
 		}
 	} else {
 		if (ACPI_FAILURE(acpi_find_root_pointer(flags, addr))) {
-			printk(KERN_ERR PREFIX "System description tables not found\n");
+			printk(KERN_ERR PREFIX
+			       "System description tables not found\n");
 			return AE_NOT_FOUND;
 		}
 	}
@@ -188,11 +181,12 @@ acpi_os_get_root_pointer(u32 flags, struct acpi_pointer *addr)
 }
 
 acpi_status
-acpi_os_map_memory(acpi_physical_address phys, acpi_size size, void __iomem **virt)
+acpi_os_map_memory(acpi_physical_address phys, acpi_size size,
+		   void __iomem ** virt)
 {
 	if (efi_enabled) {
 		if (EFI_MEMORY_WB & efi_mem_attributes(phys)) {
-			*virt = (void __iomem *) phys_to_virt(phys);
+			*virt = (void __iomem *)phys_to_virt(phys);
 		} else {
 			*virt = ioremap(phys, size);
 		}
@@ -202,9 +196,9 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size, void __iomem **vi
 			return AE_BAD_PARAMETER;
 		}
 		/*
-	 	 * ioremap checks to ensure this is in reserved space
-	 	 */
-		*virt = ioremap((unsigned long) phys, size);
+		 * ioremap checks to ensure this is in reserved space
+		 */
+		*virt = ioremap((unsigned long)phys, size);
 	}
 
 	if (!*virt)
@@ -213,17 +207,16 @@ acpi_os_map_memory(acpi_physical_address phys, acpi_size size, void __iomem **vi
 	return AE_OK;
 }
 
-void
-acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
+void acpi_os_unmap_memory(void __iomem * virt, acpi_size size)
 {
 	iounmap(virt);
 }
 
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
-acpi_os_get_physical_address(void *virt, acpi_physical_address *phys)
+acpi_os_get_physical_address(void *virt, acpi_physical_address * phys)
 {
-	if(!phys || !virt)
+	if (!phys || !virt)
 		return AE_BAD_PARAMETER;
 
 	*phys = virt_to_phys(virt);
@@ -237,16 +230,16 @@ acpi_os_get_physical_address(void *virt, acpi_physical_address *phys)
 static char acpi_os_name[ACPI_MAX_OVERRIDE_LEN];
 
 acpi_status
-acpi_os_predefined_override (const struct acpi_predefined_names *init_val,
-		             acpi_string *new_val)
+acpi_os_predefined_override(const struct acpi_predefined_names *init_val,
+			    acpi_string * new_val)
 {
 	if (!init_val || !new_val)
 		return AE_BAD_PARAMETER;
 
 	*new_val = NULL;
-	if (!memcmp (init_val->name, "_OS_", 4) && strlen(acpi_os_name)) {
+	if (!memcmp(init_val->name, "_OS_", 4) && strlen(acpi_os_name)) {
 		printk(KERN_INFO PREFIX "Overriding _OS definition to '%s'\n",
-			acpi_os_name);
+		       acpi_os_name);
 		*new_val = acpi_os_name;
 	}
 
@@ -254,15 +247,15 @@ acpi_os_predefined_override (const struct acpi_predefined_names *init_val,
 }
 
 acpi_status
-acpi_os_table_override (struct acpi_table_header *existing_table,
-			struct acpi_table_header **new_table)
+acpi_os_table_override(struct acpi_table_header * existing_table,
+		       struct acpi_table_header ** new_table)
 {
 	if (!existing_table || !new_table)
 		return AE_BAD_PARAMETER;
 
 #ifdef CONFIG_ACPI_CUSTOM_DSDT
 	if (strncmp(existing_table->signature, "DSDT", 4) == 0)
-		*new_table = (struct acpi_table_header*)AmlCode;
+		*new_table = (struct acpi_table_header *)AmlCode;
 	else
 		*new_table = NULL;
 #else
@@ -271,14 +264,14 @@ acpi_os_table_override (struct acpi_table_header *existing_table,
 	return AE_OK;
 }
 
-static irqreturn_t
-acpi_irq(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t acpi_irq(int irq, void *dev_id, struct pt_regs *regs)
 {
-	return (*acpi_irq_handler)(acpi_irq_context) ? IRQ_HANDLED : IRQ_NONE;
+	return (*acpi_irq_handler) (acpi_irq_context) ? IRQ_HANDLED : IRQ_NONE;
 }
 
 acpi_status
-acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler, void *context)
+acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,
+				  void *context)
 {
 	unsigned int irq;
 
@@ -305,8 +298,7 @@ acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler, void *conte
 	return AE_OK;
 }
 
-acpi_status
-acpi_os_remove_interrupt_handler(u32 irq, acpi_osd_handler handler)
+acpi_status acpi_os_remove_interrupt_handler(u32 irq, acpi_osd_handler handler)
 {
 	if (irq) {
 		free_irq(irq, acpi_irq);
@@ -321,16 +313,15 @@ acpi_os_remove_interrupt_handler(u32 irq, acpi_osd_handler handler)
  * Running in interpreter thread context, safe to sleep
  */
 
-void
-acpi_os_sleep(acpi_integer ms)
+void acpi_os_sleep(acpi_integer ms)
 {
 	current->state = TASK_INTERRUPTIBLE;
-	schedule_timeout(((signed long) ms * HZ) / 1000);
+	schedule_timeout(((signed long)ms * HZ) / 1000);
 }
+
 EXPORT_SYMBOL(acpi_os_sleep);
 
-void
-acpi_os_stall(u32 us)
+void acpi_os_stall(u32 us)
 {
 	while (us) {
 		u32 delay = 1000;
@@ -342,6 +333,7 @@ acpi_os_stall(u32 us)
 		us -= delay;
 	}
 }
+
 EXPORT_SYMBOL(acpi_os_stall);
 
 /*
@@ -349,8 +341,7 @@ EXPORT_SYMBOL(acpi_os_stall);
  * Returns 64-bit free-running, monotonically increasing timer
  * with 100ns granularity
  */
-u64
-acpi_os_get_timer (void)
+u64 acpi_os_get_timer(void)
 {
 	static u64 t;
 
@@ -367,27 +358,22 @@ acpi_os_get_timer (void)
 	return ++t;
 }
 
-acpi_status
-acpi_os_read_port(
-	acpi_io_address	port,
-	u32		*value,
-	u32		width)
+acpi_status acpi_os_read_port(acpi_io_address port, u32 * value, u32 width)
 {
 	u32 dummy;
 
 	if (!value)
 		value = &dummy;
 
-	switch (width)
-	{
+	switch (width) {
 	case 8:
-		*(u8*)  value = inb(port);
+		*(u8 *) value = inb(port);
 		break;
 	case 16:
-		*(u16*) value = inw(port);
+		*(u16 *) value = inw(port);
 		break;
 	case 32:
-		*(u32*) value = inl(port);
+		*(u32 *) value = inl(port);
 		break;
 	default:
 		BUG();
@@ -395,16 +381,12 @@ acpi_os_read_port(
 
 	return AE_OK;
 }
+
 EXPORT_SYMBOL(acpi_os_read_port);
 
-acpi_status
-acpi_os_write_port(
-	acpi_io_address	port,
-	u32		value,
-	u32		width)
+acpi_status acpi_os_write_port(acpi_io_address port, u32 value, u32 width)
 {
-	switch (width)
-	{
+	switch (width) {
 	case 8:
 		outb(value, port);
 		break;
@@ -420,40 +402,38 @@ acpi_os_write_port(
 
 	return AE_OK;
 }
+
 EXPORT_SYMBOL(acpi_os_write_port);
 
 acpi_status
-acpi_os_read_memory(
-	acpi_physical_address	phys_addr,
-	u32			*value,
-	u32			width)
+acpi_os_read_memory(acpi_physical_address phys_addr, u32 * value, u32 width)
 {
-	u32			dummy;
-	void __iomem		*virt_addr;
-	int			iomem = 0;
+	u32 dummy;
+	void __iomem *virt_addr;
+	int iomem = 0;
 
 	if (efi_enabled) {
 		if (EFI_MEMORY_WB & efi_mem_attributes(phys_addr)) {
 			/* HACK ALERT! We can use readb/w/l on real memory too.. */
-			virt_addr = (void __iomem *) phys_to_virt(phys_addr);
+			virt_addr = (void __iomem *)phys_to_virt(phys_addr);
 		} else {
 			iomem = 1;
 			virt_addr = ioremap(phys_addr, width);
 		}
 	} else
-		virt_addr = (void __iomem *) phys_to_virt(phys_addr);
+		virt_addr = (void __iomem *)phys_to_virt(phys_addr);
 	if (!value)
 		value = &dummy;
 
 	switch (width) {
 	case 8:
-		*(u8*) value = readb(virt_addr);
+		*(u8 *) value = readb(virt_addr);
 		break;
 	case 16:
-		*(u16*) value = readw(virt_addr);
+		*(u16 *) value = readw(virt_addr);
 		break;
 	case 32:
-		*(u32*) value = readl(virt_addr);
+		*(u32 *) value = readl(virt_addr);
 		break;
 	default:
 		BUG();
@@ -468,24 +448,21 @@ acpi_os_read_memory(
 }
 
 acpi_status
-acpi_os_write_memory(
-	acpi_physical_address	phys_addr,
-	u32			value,
-	u32			width)
+acpi_os_write_memory(acpi_physical_address phys_addr, u32 value, u32 width)
 {
-	void __iomem		*virt_addr;
-	int			iomem = 0;
+	void __iomem *virt_addr;
+	int iomem = 0;
 
 	if (efi_enabled) {
 		if (EFI_MEMORY_WB & efi_mem_attributes(phys_addr)) {
 			/* HACK ALERT! We can use writeb/w/l on real memory too */
-			virt_addr = (void __iomem *) phys_to_virt(phys_addr);
+			virt_addr = (void __iomem *)phys_to_virt(phys_addr);
 		} else {
 			iomem = 1;
 			virt_addr = ioremap(phys_addr, width);
 		}
 	} else
-		virt_addr = (void __iomem *) phys_to_virt(phys_addr);
+		virt_addr = (void __iomem *)phys_to_virt(phys_addr);
 
 	switch (width) {
 	case 8:
@@ -510,7 +487,8 @@ acpi_os_write_memory(
 #ifdef CONFIG_ACPI_PCI
 
 acpi_status
-acpi_os_read_pci_configuration (struct acpi_pci_id *pci_id, u32 reg, void *value, u32 width)
+acpi_os_read_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
+			       void *value, u32 width)
 {
 	int result, size;
 
@@ -534,15 +512,17 @@ acpi_os_read_pci_configuration (struct acpi_pci_id *pci_id, u32 reg, void *value
 	BUG_ON(!raw_pci_ops);
 
 	result = raw_pci_ops->read(pci_id->segment, pci_id->bus,
-				PCI_DEVFN(pci_id->device, pci_id->function),
-				reg, size, value);
+				   PCI_DEVFN(pci_id->device, pci_id->function),
+				   reg, size, value);
 
 	return (result ? AE_ERROR : AE_OK);
 }
+
 EXPORT_SYMBOL(acpi_os_read_pci_configuration);
 
 acpi_status
-acpi_os_write_pci_configuration (struct acpi_pci_id *pci_id, u32 reg, acpi_integer value, u32 width)
+acpi_os_write_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
+				acpi_integer value, u32 width)
 {
 	int result, size;
 
@@ -563,56 +543,62 @@ acpi_os_write_pci_configuration (struct acpi_pci_id *pci_id, u32 reg, acpi_integ
 	BUG_ON(!raw_pci_ops);
 
 	result = raw_pci_ops->write(pci_id->segment, pci_id->bus,
-				PCI_DEVFN(pci_id->device, pci_id->function),
-				reg, size, value);
+				    PCI_DEVFN(pci_id->device, pci_id->function),
+				    reg, size, value);
 
 	return (result ? AE_ERROR : AE_OK);
 }
 
 /* TODO: Change code to take advantage of driver model more */
-static void
-acpi_os_derive_pci_id_2 (
-	acpi_handle		rhandle,        /* upper bound  */
-	acpi_handle		chandle,        /* current node */
-	struct acpi_pci_id	**id,
-	int			*is_bridge,
-	u8			*bus_number)
+static void acpi_os_derive_pci_id_2(acpi_handle rhandle,	/* upper bound  */
+				    acpi_handle chandle,	/* current node */
+				    struct acpi_pci_id **id,
+				    int *is_bridge, u8 * bus_number)
 {
-	acpi_handle		handle;
-	struct acpi_pci_id	*pci_id = *id;
-	acpi_status		status;
-	unsigned long		temp;
-	acpi_object_type	type;
-	u8			tu8;
+	acpi_handle handle;
+	struct acpi_pci_id *pci_id = *id;
+	acpi_status status;
+	unsigned long temp;
+	acpi_object_type type;
+	u8 tu8;
 
 	acpi_get_parent(chandle, &handle);
 	if (handle != rhandle) {
-		acpi_os_derive_pci_id_2(rhandle, handle, &pci_id, is_bridge, bus_number);
+		acpi_os_derive_pci_id_2(rhandle, handle, &pci_id, is_bridge,
+					bus_number);
 
 		status = acpi_get_type(handle, &type);
-		if ( (ACPI_FAILURE(status)) || (type != ACPI_TYPE_DEVICE) )
+		if ((ACPI_FAILURE(status)) || (type != ACPI_TYPE_DEVICE))
 			return;
 
-		status = acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL, &temp);
+		status =
+		    acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL,
+					  &temp);
 		if (ACPI_SUCCESS(status)) {
-			pci_id->device  = ACPI_HIWORD (ACPI_LODWORD (temp));
-			pci_id->function = ACPI_LOWORD (ACPI_LODWORD (temp));
+			pci_id->device = ACPI_HIWORD(ACPI_LODWORD(temp));
+			pci_id->function = ACPI_LOWORD(ACPI_LODWORD(temp));
 
 			if (*is_bridge)
 				pci_id->bus = *bus_number;
 
 			/* any nicer way to get bus number of bridge ? */
-			status = acpi_os_read_pci_configuration(pci_id, 0x0e, &tu8, 8);
-			if (ACPI_SUCCESS(status) &&
-			    ((tu8 & 0x7f) == 1 || (tu8 & 0x7f) == 2)) {
-				status = acpi_os_read_pci_configuration(pci_id, 0x18, &tu8, 8);
+			status =
+			    acpi_os_read_pci_configuration(pci_id, 0x0e, &tu8,
+							   8);
+			if (ACPI_SUCCESS(status)
+			    && ((tu8 & 0x7f) == 1 || (tu8 & 0x7f) == 2)) {
+				status =
+				    acpi_os_read_pci_configuration(pci_id, 0x18,
+								   &tu8, 8);
 				if (!ACPI_SUCCESS(status)) {
 					/* Certainly broken...  FIX ME */
 					return;
 				}
 				*is_bridge = 1;
 				pci_id->bus = tu8;
-				status = acpi_os_read_pci_configuration(pci_id, 0x19, &tu8, 8);
+				status =
+				    acpi_os_read_pci_configuration(pci_id, 0x19,
+								   &tu8, 8);
 				if (ACPI_SUCCESS(status)) {
 					*bus_number = tu8;
 				}
@@ -622,11 +608,9 @@ acpi_os_derive_pci_id_2 (
 	}
 }
 
-void
-acpi_os_derive_pci_id (
-	acpi_handle		rhandle,        /* upper bound  */
-	acpi_handle		chandle,        /* current node */
-	struct acpi_pci_id	**id)
+void acpi_os_derive_pci_id(acpi_handle rhandle,	/* upper bound  */
+			   acpi_handle chandle,	/* current node */
+			   struct acpi_pci_id **id)
 {
 	int is_bridge = 1;
 	u8 bus_number = (*id)->bus;
@@ -634,49 +618,39 @@ acpi_os_derive_pci_id (
 	acpi_os_derive_pci_id_2(rhandle, chandle, id, &is_bridge, &bus_number);
 }
 
-#else /*!CONFIG_ACPI_PCI*/
+#else				/*!CONFIG_ACPI_PCI */
 
 acpi_status
-acpi_os_write_pci_configuration (
-	struct acpi_pci_id	*pci_id,
-	u32			reg,
-	acpi_integer		value,
-	u32			width)
+acpi_os_write_pci_configuration(struct acpi_pci_id * pci_id,
+				u32 reg, acpi_integer value, u32 width)
 {
 	return AE_SUPPORT;
 }
 
 acpi_status
-acpi_os_read_pci_configuration (
-	struct acpi_pci_id	*pci_id,
-	u32			reg,
-	void			*value,
-	u32			width)
+acpi_os_read_pci_configuration(struct acpi_pci_id * pci_id,
+			       u32 reg, void *value, u32 width)
 {
 	return AE_SUPPORT;
 }
 
-void
-acpi_os_derive_pci_id (
-	acpi_handle		rhandle,        /* upper bound  */
-	acpi_handle		chandle,        /* current node */
-	struct acpi_pci_id	**id)
+void acpi_os_derive_pci_id(acpi_handle rhandle,	/* upper bound  */
+			   acpi_handle chandle,	/* current node */
+			   struct acpi_pci_id **id)
 {
 }
 
-#endif /*CONFIG_ACPI_PCI*/
+#endif				/*CONFIG_ACPI_PCI */
 
-static void
-acpi_os_execute_deferred (
-	void *context)
+static void acpi_os_execute_deferred(void *context)
 {
-	struct acpi_os_dpc	*dpc = NULL;
+	struct acpi_os_dpc *dpc = NULL;
 
-	ACPI_FUNCTION_TRACE ("os_execute_deferred");
+	ACPI_FUNCTION_TRACE("os_execute_deferred");
 
-	dpc = (struct acpi_os_dpc *) context;
+	dpc = (struct acpi_os_dpc *)context;
 	if (!dpc) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
 		return_VOID;
 	}
 
@@ -688,21 +662,21 @@ acpi_os_execute_deferred (
 }
 
 acpi_status
-acpi_os_queue_for_execution(
-	u32			priority,
-	acpi_osd_exec_callback	function,
-	void			*context)
+acpi_os_queue_for_execution(u32 priority,
+			    acpi_osd_exec_callback function, void *context)
 {
-	acpi_status 		status = AE_OK;
-	struct acpi_os_dpc	*dpc;
-	struct work_struct	*task;
+	acpi_status status = AE_OK;
+	struct acpi_os_dpc *dpc;
+	struct work_struct *task;
 
-	ACPI_FUNCTION_TRACE ("os_queue_for_execution");
+	ACPI_FUNCTION_TRACE("os_queue_for_execution");
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Scheduling function [%p(%p)] for deferred execution.\n", function, context));
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+			  "Scheduling function [%p(%p)] for deferred execution.\n",
+			  function, context));
 
 	if (!function)
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
 
 	/*
 	 * Allocate/initialize DPC structure.  Note that this memory will be
@@ -715,67 +689,65 @@ acpi_os_queue_for_execution(
 	 * from the same memory.
 	 */
 
-	dpc = kmalloc(sizeof(struct acpi_os_dpc)+sizeof(struct work_struct), GFP_ATOMIC);
+	dpc =
+	    kmalloc(sizeof(struct acpi_os_dpc) + sizeof(struct work_struct),
+		    GFP_ATOMIC);
 	if (!dpc)
-		return_ACPI_STATUS (AE_NO_MEMORY);
+		return_ACPI_STATUS(AE_NO_MEMORY);
 
 	dpc->function = function;
 	dpc->context = context;
 
-	task = (void *)(dpc+1);
-	INIT_WORK(task, acpi_os_execute_deferred, (void*)dpc);
+	task = (void *)(dpc + 1);
+	INIT_WORK(task, acpi_os_execute_deferred, (void *)dpc);
 
 	if (!queue_work(kacpid_wq, task)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Call to queue_work() failed.\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Call to queue_work() failed.\n"));
 		kfree(dpc);
 		status = AE_ERROR;
 	}
 
-	return_ACPI_STATUS (status);
+	return_ACPI_STATUS(status);
 }
+
 EXPORT_SYMBOL(acpi_os_queue_for_execution);
 
-void
-acpi_os_wait_events_complete(
-	void *context)
+void acpi_os_wait_events_complete(void *context)
 {
 	flush_workqueue(kacpid_wq);
 }
+
 EXPORT_SYMBOL(acpi_os_wait_events_complete);
 
 /*
  * Allocate the memory for a spinlock and initialize it.
  */
-acpi_status
-acpi_os_create_lock (
-	acpi_handle	*out_handle)
+acpi_status acpi_os_create_lock(acpi_handle * out_handle)
 {
 	spinlock_t *lock_ptr;
 
-	ACPI_FUNCTION_TRACE ("os_create_lock");
+	ACPI_FUNCTION_TRACE("os_create_lock");
 
 	lock_ptr = acpi_os_allocate(sizeof(spinlock_t));
 
 	spin_lock_init(lock_ptr);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Creating spinlock[%p].\n", lock_ptr));
+	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Creating spinlock[%p].\n", lock_ptr));
 
 	*out_handle = lock_ptr;
 
-	return_ACPI_STATUS (AE_OK);
+	return_ACPI_STATUS(AE_OK);
 }
 
-
 /*
  * Deallocate the memory for a spinlock.
  */
-void
-acpi_os_delete_lock (
-	acpi_handle	handle)
+void acpi_os_delete_lock(acpi_handle handle)
 {
-	ACPI_FUNCTION_TRACE ("os_create_lock");
+	ACPI_FUNCTION_TRACE("os_create_lock");
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Deleting spinlock[%p].\n", handle));
+	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Deleting spinlock[%p].\n", handle));
 
 	acpi_os_free(handle);
 
@@ -783,30 +755,28 @@ acpi_os_delete_lock (
 }
 
 acpi_status
-acpi_os_create_semaphore(
-	u32		max_units,
-	u32		initial_units,
-	acpi_handle	*handle)
+acpi_os_create_semaphore(u32 max_units, u32 initial_units, acpi_handle * handle)
 {
-	struct semaphore	*sem = NULL;
+	struct semaphore *sem = NULL;
 
-	ACPI_FUNCTION_TRACE ("os_create_semaphore");
+	ACPI_FUNCTION_TRACE("os_create_semaphore");
 
 	sem = acpi_os_allocate(sizeof(struct semaphore));
 	if (!sem)
-		return_ACPI_STATUS (AE_NO_MEMORY);
+		return_ACPI_STATUS(AE_NO_MEMORY);
 	memset(sem, 0, sizeof(struct semaphore));
 
 	sema_init(sem, initial_units);
 
-	*handle = (acpi_handle*)sem;
+	*handle = (acpi_handle *) sem;
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Creating semaphore[%p|%d].\n", *handle, initial_units));
+	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Creating semaphore[%p|%d].\n",
+			  *handle, initial_units));
 
-	return_ACPI_STATUS (AE_OK);
+	return_ACPI_STATUS(AE_OK);
 }
-EXPORT_SYMBOL(acpi_os_create_semaphore);
 
+EXPORT_SYMBOL(acpi_os_create_semaphore);
 
 /*
  * TODO: A better way to delete semaphores?  Linux doesn't have a
@@ -815,25 +785,24 @@ EXPORT_SYMBOL(acpi_os_create_semaphore);
  * we at least check for blocked threads and signal/cancel them?
  */
 
-acpi_status
-acpi_os_delete_semaphore(
-	acpi_handle	handle)
+acpi_status acpi_os_delete_semaphore(acpi_handle handle)
 {
-	struct semaphore *sem = (struct semaphore*) handle;
+	struct semaphore *sem = (struct semaphore *)handle;
 
-	ACPI_FUNCTION_TRACE ("os_delete_semaphore");
+	ACPI_FUNCTION_TRACE("os_delete_semaphore");
 
 	if (!sem)
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Deleting semaphore[%p].\n", handle));
+	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Deleting semaphore[%p].\n", handle));
 
-	acpi_os_free(sem); sem =  NULL;
+	acpi_os_free(sem);
+	sem = NULL;
 
-	return_ACPI_STATUS (AE_OK);
+	return_ACPI_STATUS(AE_OK);
 }
-EXPORT_SYMBOL(acpi_os_delete_semaphore);
 
+EXPORT_SYMBOL(acpi_os_delete_semaphore);
 
 /*
  * TODO: The kernel doesn't have a 'down_timeout' function -- had to
@@ -844,31 +813,27 @@ EXPORT_SYMBOL(acpi_os_delete_semaphore);
  *
  * TODO: Support for units > 1?
  */
-acpi_status
-acpi_os_wait_semaphore(
-	acpi_handle		handle,
-	u32			units,
-	u16			timeout)
+acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
 {
-	acpi_status		status = AE_OK;
-	struct semaphore	*sem = (struct semaphore*)handle;
-	int			ret = 0;
+	acpi_status status = AE_OK;
+	struct semaphore *sem = (struct semaphore *)handle;
+	int ret = 0;
 
-	ACPI_FUNCTION_TRACE ("os_wait_semaphore");
+	ACPI_FUNCTION_TRACE("os_wait_semaphore");
 
 	if (!sem || (units < 1))
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
 
 	if (units > 1)
-		return_ACPI_STATUS (AE_SUPPORT);
+		return_ACPI_STATUS(AE_SUPPORT);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Waiting for semaphore[%p|%d|%d]\n", handle, units, timeout));
+	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Waiting for semaphore[%p|%d|%d]\n",
+			  handle, units, timeout));
 
 	if (in_atomic())
 		timeout = 0;
 
-	switch (timeout)
-	{
+	switch (timeout) {
 		/*
 		 * No Wait:
 		 * --------
@@ -876,8 +841,8 @@ acpi_os_wait_semaphore(
 		 * acquire the semaphore if available otherwise return AE_TIME
 		 * (a.k.a. 'would block').
 		 */
-		case 0:
-		if(down_trylock(sem))
+	case 0:
+		if (down_trylock(sem))
 			status = AE_TIME;
 		break;
 
@@ -885,7 +850,7 @@ acpi_os_wait_semaphore(
 		 * Wait Indefinitely:
 		 * ------------------
 		 */
-		case ACPI_WAIT_FOREVER:
+	case ACPI_WAIT_FOREVER:
 		down(sem);
 		break;
 
@@ -893,11 +858,11 @@ acpi_os_wait_semaphore(
 		 * Wait w/ Timeout:
 		 * ----------------
 		 */
-		default:
+	default:
 		// TODO: A better timeout algorithm?
 		{
 			int i = 0;
-			static const int quantum_ms = 1000/HZ;
+			static const int quantum_ms = 1000 / HZ;
 
 			ret = down_trylock(sem);
 			for (i = timeout; (i > 0 && ret < 0); i -= quantum_ms) {
@@ -905,7 +870,7 @@ acpi_os_wait_semaphore(
 				schedule_timeout(1);
 				ret = down_trylock(sem);
 			}
-	
+
 			if (ret != 0)
 				status = AE_TIME;
 		}
@@ -913,47 +878,48 @@ acpi_os_wait_semaphore(
 	}
 
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Failed to acquire semaphore[%p|%d|%d], %s\n", 
-			handle, units, timeout, acpi_format_exception(status)));
-	}
-	else {
-		ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Acquired semaphore[%p|%d|%d]\n", handle, units, timeout));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Failed to acquire semaphore[%p|%d|%d], %s\n",
+				  handle, units, timeout,
+				  acpi_format_exception(status)));
+	} else {
+		ACPI_DEBUG_PRINT((ACPI_DB_MUTEX,
+				  "Acquired semaphore[%p|%d|%d]\n", handle,
+				  units, timeout));
 	}
 
-	return_ACPI_STATUS (status);
+	return_ACPI_STATUS(status);
 }
-EXPORT_SYMBOL(acpi_os_wait_semaphore);
 
+EXPORT_SYMBOL(acpi_os_wait_semaphore);
 
 /*
  * TODO: Support for units > 1?
  */
-acpi_status
-acpi_os_signal_semaphore(
-    acpi_handle 	    handle,
-    u32 		    units)
+acpi_status acpi_os_signal_semaphore(acpi_handle handle, u32 units)
 {
-	struct semaphore *sem = (struct semaphore *) handle;
+	struct semaphore *sem = (struct semaphore *)handle;
 
-	ACPI_FUNCTION_TRACE ("os_signal_semaphore");
+	ACPI_FUNCTION_TRACE("os_signal_semaphore");
 
 	if (!sem || (units < 1))
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
 
 	if (units > 1)
-		return_ACPI_STATUS (AE_SUPPORT);
+		return_ACPI_STATUS(AE_SUPPORT);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Signaling semaphore[%p|%d]\n", handle, units));
+	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Signaling semaphore[%p|%d]\n", handle,
+			  units));
 
 	up(sem);
 
-	return_ACPI_STATUS (AE_OK);
+	return_ACPI_STATUS(AE_OK);
 }
+
 EXPORT_SYMBOL(acpi_os_signal_semaphore);
 
 #ifdef ACPI_FUTURE_USAGE
-u32
-acpi_os_get_line(char *buffer)
+u32 acpi_os_get_line(char *buffer)
 {
 
 #ifdef ENABLE_DEBUGGER
@@ -970,22 +936,21 @@ acpi_os_get_line(char *buffer)
 
 	return 0;
 }
-#endif  /*  ACPI_FUTURE_USAGE  */
+#endif				/*  ACPI_FUTURE_USAGE  */
 
 /* Assumes no unreadable holes inbetween */
-u8
-acpi_os_readable(void *ptr, acpi_size len)
+u8 acpi_os_readable(void *ptr, acpi_size len)
 {
-#if defined(__i386__) || defined(__x86_64__) 
+#if defined(__i386__) || defined(__x86_64__)
 	char tmp;
-	return !__get_user(tmp, (char __user *)ptr) && !__get_user(tmp, (char __user *)ptr + len - 1);
+	return !__get_user(tmp, (char __user *)ptr)
+	    && !__get_user(tmp, (char __user *)ptr + len - 1);
 #endif
 	return 1;
 }
 
 #ifdef ACPI_FUTURE_USAGE
-u8
-acpi_os_writable(void *ptr, acpi_size len)
+u8 acpi_os_writable(void *ptr, acpi_size len)
 {
 	/* could do dummy write (racy) or a kernel page table lookup.
 	   The later may be difficult at early boot when kmap doesn't work yet. */
@@ -993,8 +958,7 @@ acpi_os_writable(void *ptr, acpi_size len)
 }
 #endif
 
-u32
-acpi_os_get_thread_id (void)
+u32 acpi_os_get_thread_id(void)
 {
 	if (!in_atomic())
 		return current->pid;
@@ -1002,13 +966,9 @@ acpi_os_get_thread_id (void)
 	return 0;
 }
 
-acpi_status
-acpi_os_signal (
-    u32		function,
-    void	*info)
+acpi_status acpi_os_signal(u32 function, void *info)
 {
-	switch (function)
-	{
+	switch (function) {
 	case ACPI_SIGNAL_FATAL:
 		printk(KERN_ERR PREFIX "Fatal opcode executed\n");
 		break;
@@ -1028,13 +988,13 @@ acpi_os_signal (
 
 	return AE_OK;
 }
+
 EXPORT_SYMBOL(acpi_os_signal);
 
-static int __init
-acpi_os_name_setup(char *str)
+static int __init acpi_os_name_setup(char *str)
 {
 	char *p = acpi_os_name;
-	int count = ACPI_MAX_OVERRIDE_LEN-1;
+	int count = ACPI_MAX_OVERRIDE_LEN - 1;
 
 	if (!str || !*str)
 		return 0;
@@ -1050,7 +1010,7 @@ acpi_os_name_setup(char *str)
 	*p = 0;
 
 	return 1;
-		
+
 }
 
 __setup("acpi_os_name=", acpi_os_name_setup);
@@ -1060,16 +1020,15 @@ __setup("acpi_os_name=", acpi_os_name_setup);
  * empty string disables _OSI
  * TBD additional string adds to _OSI
  */
-static int __init
-acpi_osi_setup(char *str)
+static int __init acpi_osi_setup(char *str)
 {
 	if (str == NULL || *str == '\0') {
 		printk(KERN_INFO PREFIX "_OSI method disabled\n");
 		acpi_gbl_create_osi_method = FALSE;
-	} else
-	{
+	} else {
 		/* TBD */
-		printk(KERN_ERR PREFIX "_OSI additional string ignored -- %s\n", str);
+		printk(KERN_ERR PREFIX "_OSI additional string ignored -- %s\n",
+		       str);
 	}
 
 	return 1;
@@ -1078,8 +1037,7 @@ acpi_osi_setup(char *str)
 __setup("acpi_osi=", acpi_osi_setup);
 
 /* enable serialization to combat AE_ALREADY_EXISTS errors */
-static int __init
-acpi_serialize_setup(char *str)
+static int __init acpi_serialize_setup(char *str)
 {
 	printk(KERN_INFO PREFIX "serialize enabled\n");
 
@@ -1099,8 +1057,7 @@ __setup("acpi_serialize", acpi_serialize_setup);
  * Run-time events on the same GPE this flag is available
  * to tell Linux to keep the wake-time GPEs enabled at run-time.
  */
-static int __init
-acpi_wake_gpes_always_on_setup(char *str)
+static int __init acpi_wake_gpes_always_on_setup(char *str)
 {
 	printk(KERN_INFO PREFIX "wake GPEs not disabled\n");
 
@@ -1111,8 +1068,7 @@ acpi_wake_gpes_always_on_setup(char *str)
 
 __setup("acpi_wake_gpes_always_on", acpi_wake_gpes_always_on_setup);
 
-int __init
-acpi_hotkey_setup(char *str)
+int __init acpi_hotkey_setup(char *str)
 {
 	acpi_specific_hotkey_enabled = TRUE;
 	return 1;
@@ -1126,7 +1082,6 @@ __setup("acpi_specific_hotkey", acpi_hotkey_setup);
  */
 unsigned int max_cstate = ACPI_PROCESSOR_MAX_POWER;
 
-
 EXPORT_SYMBOL(max_cstate);
 
 /*
@@ -1137,12 +1092,10 @@ EXPORT_SYMBOL(max_cstate);
  *   that indicates whether we are at interrupt level.
  */
 
-unsigned long
-acpi_os_acquire_lock (
-	acpi_handle	handle)
+unsigned long acpi_os_acquire_lock(acpi_handle handle)
 {
 	unsigned long flags;
-	spin_lock_irqsave((spinlock_t *)handle, flags);
+	spin_lock_irqsave((spinlock_t *) handle, flags);
 	return flags;
 }
 
@@ -1150,15 +1103,11 @@ acpi_os_acquire_lock (
  * Release a spinlock. See above.
  */
 
-void
-acpi_os_release_lock (
-	acpi_handle	handle,
-	unsigned long	flags)
+void acpi_os_release_lock(acpi_handle handle, unsigned long flags)
 {
-	spin_unlock_irqrestore((spinlock_t *)handle, flags);
+	spin_unlock_irqrestore((spinlock_t *) handle, flags);
 }
 
-
 #ifndef ACPI_USE_LOCAL_CACHE
 
 /*******************************************************************************
@@ -1177,13 +1126,9 @@ acpi_os_release_lock (
  ******************************************************************************/
 
 acpi_status
-acpi_os_create_cache (
-    char                    *name,
-    u16                  size,
-    u16                  depth,
-    acpi_cache_t 	    **cache)
+acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)
 {
-	*cache = kmem_cache_create (name, size, 0, 0, NULL, NULL);
+	*cache = kmem_cache_create(name, size, 0, 0, NULL, NULL);
 	return AE_OK;
 }
 
@@ -1199,12 +1144,10 @@ acpi_os_create_cache (
  *
  ******************************************************************************/
 
-acpi_status
-acpi_os_purge_cache (
-    acpi_cache_t        *cache)
+acpi_status acpi_os_purge_cache(acpi_cache_t * cache)
 {
-    (void) kmem_cache_shrink(cache);
-    return (AE_OK);
+	(void)kmem_cache_shrink(cache);
+	return (AE_OK);
 }
 
 /*******************************************************************************
@@ -1220,12 +1163,10 @@ acpi_os_purge_cache (
  *
  ******************************************************************************/
 
-acpi_status
-acpi_os_delete_cache (
-    acpi_cache_t *cache)
+acpi_status acpi_os_delete_cache(acpi_cache_t * cache)
 {
-    (void)kmem_cache_destroy(cache);
-    return (AE_OK);
+	(void)kmem_cache_destroy(cache);
+	return (AE_OK);
 }
 
 /*******************************************************************************
@@ -1242,13 +1183,10 @@ acpi_os_delete_cache (
  *
  ******************************************************************************/
 
-acpi_status
-acpi_os_release_object (
-    acpi_cache_t *cache,
-    void *object)
+acpi_status acpi_os_release_object(acpi_cache_t * cache, void *object)
 {
-    kmem_cache_free(cache, object);
-    return (AE_OK);
+	kmem_cache_free(cache, object);
+	return (AE_OK);
 }
 
 /*******************************************************************************
@@ -1265,14 +1203,11 @@ acpi_os_release_object (
  *
  ******************************************************************************/
 
-void *
-acpi_os_acquire_object (
-    acpi_cache_t *cache)
+void *acpi_os_acquire_object(acpi_cache_t * cache)
 {
-    void *object = kmem_cache_alloc(cache, GFP_KERNEL);
-    WARN_ON(!object);
-    return object;
+	void *object = kmem_cache_alloc(cache, GFP_KERNEL);
+	WARN_ON(!object);
+	return object;
 }
 
 #endif
-

commit 5d2a22079c825669d91a3a200332f1053b4b61b0
Merge: 1c5ad84516ae bd6dbdf3c7b9
Author: Len Brown <len.brown@intel.com>
Date:   Thu Aug 4 18:09:09 2005 -0400

    /home/lenb/src/to-akpm branch 'acpi-2.6.12'

commit 11e981f1e02c2a36465cbb208b21cb8b6480f399
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Wed Aug 3 23:46:33 2005 -0400

    [ACPI] S3 resume: avoid kmalloc() might_sleep oops symptom
    
    ACPI now uses kmalloc(...,GPF_ATOMIC) during suspend/resume.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=3469
    
    Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index bdd9f37f8101..7289da3c4db6 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -145,10 +145,14 @@ acpi_os_vprintf(const char *fmt, va_list args)
 #endif
 }
 
+extern int acpi_in_resume;
 void *
 acpi_os_allocate(acpi_size size)
 {
-	return kmalloc(size, GFP_KERNEL);
+	if (acpi_in_resume)
+		return kmalloc(size, GFP_ATOMIC);
+	else
+		return kmalloc(size, GFP_KERNEL);
 }
 
 void

commit 73459f73e5d1602c59ebec114fc45185521353c1
Author: Robert Moore <robert.moore@intel.com>
Date:   Fri Jun 24 00:00:00 2005 -0400

    ACPICA 20050617-0624 from Bob Moore <robert.moore@intel.com>
    
    ACPICA 20050617:
    
    Moved the object cache operations into the OS interface
    layer (OSL) to allow the host OS to handle these operations
    if desired (for example, the Linux OSL will invoke the
    slab allocator).  This support is optional; the compile
    time define ACPI_USE_LOCAL_CACHE may be used to utilize
    the original cache code in the ACPI CA core.  The new OSL
    interfaces are shown below.  See utalloc.c for an example
    implementation, and acpiosxf.h for the exact interface
    definitions.  Thanks to Alexey Starikovskiy.
            acpi_os_create_cache
            acpi_os_delete_cache
            acpi_os_purge_cache
            acpi_os_acquire_object
            acpi_os_release_object
    
    Modified the interfaces to acpi_os_acquire_lock and
    acpi_os_release_lock to return and restore a flags
    parameter.  This fits better with many OS lock models.
    Note: the current execution state (interrupt handler
    or not) is no longer passed to these interfaces.  If
    necessary, the OSL must determine this state by itself, a
    simple and fast operation.  Thanks to Alexey Starikovskiy.
    
    Fixed a problem in the ACPI table handling where a valid
    XSDT was assumed present if the revision of the RSDP
    was 2 or greater.  According to the ACPI specification,
    the XSDT is optional in all cases, and the table manager
    therefore now checks for both an RSDP >=2 and a valid
    XSDT pointer.  Otherwise, the RSDT pointer is used.
    Some ACPI 2.0 compliant BIOSs contain only the RSDT.
    
    Fixed an interpreter problem with the Mid() operator in the
    case of an input string where the resulting output string
    is of zero length.  It now correctly returns a valid,
    null terminated string object instead of a string object
    with a null pointer.
    
    Fixed a problem with the control method argument handling
    to allow a store to an Arg object that already contains an
    object of type Device.  The Device object is now correctly
    overwritten.  Previously, an error was returned.
    
    ACPICA 20050624:
    
    Modified the new OSL cache interfaces to use ACPI_CACHE_T
    as the type for the host-defined cache object.  This allows
    the OSL implementation to define and type this object in
    any manner desired, simplifying the OSL implementation.
    For example, ACPI_CACHE_T is defined as kmem_cache_t for
    Linux, and should be defined in the OS-specific header
    file for other operating systems as required.
    
    Changed the interface to AcpiOsAcquireObject to directly
    return the requested object as the function return (instead
    of ACPI_STATUS.) This change was made for performance
    reasons, since this is the purpose of the interface in the
    first place.  acpi_os_acquire_object is now similar to the
    acpi_os_allocate interface.  Thanks to Alexey Starikovskiy.
    
    Modified the initialization sequence in
    acpi_initialize_subsystem to call the OSL interface
    acpi_osl_initialize first, before any local initialization.
    This change was required because the global initialization
    now calls OSL interfaces.
    
    Restructured the code base to split some files because
    of size and/or because the code logically belonged in a
    separate file.  New files are listed below.
    
      utilities/utcache.c   /* Local cache interfaces */
      utilities/utmutex.c   /* Local mutex support */
      utilities/utstate.c   /* State object support */
      parser/psloop.c       /* Main AML parse loop */
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index bdd9f37f8101..56e7cedba919 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -778,54 +778,6 @@ acpi_os_delete_lock (
 	return_VOID;
 }
 
-/*
- * Acquire a spinlock.
- *
- * handle is a pointer to the spinlock_t.
- * flags is *not* the result of save_flags - it is an ACPI-specific flag variable
- *   that indicates whether we are at interrupt level.
- */
-void
-acpi_os_acquire_lock (
-	acpi_handle	handle,
-	u32		flags)
-{
-	ACPI_FUNCTION_TRACE ("os_acquire_lock");
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Acquiring spinlock[%p] from %s level\n", handle,
-		((flags & ACPI_NOT_ISR) ? "non-interrupt" : "interrupt")));
-
-	if (flags & ACPI_NOT_ISR)
-		ACPI_DISABLE_IRQS();
-
-	spin_lock((spinlock_t *)handle);
-
-	return_VOID;
-}
-
-
-/*
- * Release a spinlock. See above.
- */
-void
-acpi_os_release_lock (
-	acpi_handle	handle,
-	u32		flags)
-{
-	ACPI_FUNCTION_TRACE ("os_release_lock");
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Releasing spinlock[%p] from %s level\n", handle,
-		((flags & ACPI_NOT_ISR) ? "non-interrupt" : "interrupt")));
-
-	spin_unlock((spinlock_t *)handle);
-
-	if (flags & ACPI_NOT_ISR)
-		ACPI_ENABLE_IRQS();
-
-	return_VOID;
-}
-
-
 acpi_status
 acpi_os_create_semaphore(
 	u32		max_units,
@@ -1172,3 +1124,151 @@ unsigned int max_cstate = ACPI_PROCESSOR_MAX_POWER;
 
 
 EXPORT_SYMBOL(max_cstate);
+
+/*
+ * Acquire a spinlock.
+ *
+ * handle is a pointer to the spinlock_t.
+ * flags is *not* the result of save_flags - it is an ACPI-specific flag variable
+ *   that indicates whether we are at interrupt level.
+ */
+
+unsigned long
+acpi_os_acquire_lock (
+	acpi_handle	handle)
+{
+	unsigned long flags;
+	spin_lock_irqsave((spinlock_t *)handle, flags);
+	return flags;
+}
+
+/*
+ * Release a spinlock. See above.
+ */
+
+void
+acpi_os_release_lock (
+	acpi_handle	handle,
+	unsigned long	flags)
+{
+	spin_unlock_irqrestore((spinlock_t *)handle, flags);
+}
+
+
+#ifndef ACPI_USE_LOCAL_CACHE
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_create_cache
+ *
+ * PARAMETERS:  CacheName       - Ascii name for the cache
+ *              ObjectSize      - Size of each cached object
+ *              MaxDepth        - Maximum depth of the cache (in objects)
+ *              ReturnCache     - Where the new cache object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a cache object
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_os_create_cache (
+    char                    *name,
+    u16                  size,
+    u16                  depth,
+    acpi_cache_t 	    **cache)
+{
+	*cache = kmem_cache_create (name, size, 0, 0, NULL, NULL);
+	return AE_OK;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_purge_cache
+ *
+ * PARAMETERS:  Cache           - Handle to cache object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Free all objects within the requested cache.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_os_purge_cache (
+    acpi_cache_t        *cache)
+{
+    (void) kmem_cache_shrink(cache);
+    return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_delete_cache
+ *
+ * PARAMETERS:  Cache           - Handle to cache object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Free all objects within the requested cache and delete the
+ *              cache object.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_os_delete_cache (
+    acpi_cache_t *cache)
+{
+    (void)kmem_cache_destroy(cache);
+    return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_release_object
+ *
+ * PARAMETERS:  Cache       - Handle to cache object
+ *              Object      - The object to be released
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Release an object to the specified cache.  If cache is full,
+ *              the object is deleted.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_os_release_object (
+    acpi_cache_t *cache,
+    void *object)
+{
+    kmem_cache_free(cache, object);
+    return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_acquire_object
+ *
+ * PARAMETERS:  Cache           - Handle to cache object
+ *              ReturnObject    - Where the object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get an object from the specified cache.  If cache is empty,
+ *              the object is allocated.
+ *
+ ******************************************************************************/
+
+void *
+acpi_os_acquire_object (
+    acpi_cache_t *cache)
+{
+    void *object = kmem_cache_alloc(cache, GFP_KERNEL);
+    WARN_ON(!object);
+    return object;
+}
+
+#endif
+

commit fb9802fa59b196d7f90bb3c2e33c555c6bdc4c54
Author: Luming Yu <luming.yu@intel.com>
Date:   Fri Mar 18 18:03:45 2005 -0500

    [ACPI] generic Hot Key support
    
    See Documentation/acpi-hotkey.txt
    
    Use cmdline "acpi_specific_hotkey" to enable
    legacy platform specific drivers.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=3887
    
    Signed-off-by: Luming Yu <luming.yu@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 5a9128de6226..bdd9f37f8101 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -71,6 +71,9 @@ EXPORT_SYMBOL(acpi_in_debugger);
 extern char line_buf[80];
 #endif /*ENABLE_DEBUGGER*/
 
+int acpi_specific_hotkey_enabled;
+EXPORT_SYMBOL(acpi_specific_hotkey_enabled);
+
 static unsigned int acpi_irq_irq;
 static acpi_osd_handler acpi_irq_handler;
 static void *acpi_irq_context;
@@ -1152,6 +1155,15 @@ acpi_wake_gpes_always_on_setup(char *str)
 
 __setup("acpi_wake_gpes_always_on", acpi_wake_gpes_always_on_setup);
 
+int __init
+acpi_hotkey_setup(char *str)
+{
+	acpi_specific_hotkey_enabled = TRUE;
+	return 1;
+}
+
+__setup("acpi_specific_hotkey", acpi_hotkey_setup);
+
 /*
  * max_cstate is defined in the base kernel so modules can
  * change it w/o depending on the state of the processor module.

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
new file mode 100644
index 000000000000..5a9128de6226
--- /dev/null
+++ b/drivers/acpi/osl.c
@@ -0,0 +1,1162 @@
+/*
+ *  acpi_osl.c - OS-dependent functions ($Revision: 83 $)
+ *
+ *  Copyright (C) 2000       Andrew Henroid
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/smp_lock.h>
+#include <linux/interrupt.h>
+#include <linux/kmod.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/nmi.h>
+#include <acpi/acpi.h>
+#include <asm/io.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/processor.h>
+#include <asm/uaccess.h>
+
+#include <linux/efi.h>
+
+
+#define _COMPONENT		ACPI_OS_SERVICES
+ACPI_MODULE_NAME	("osl")
+
+#define PREFIX		"ACPI: "
+
+struct acpi_os_dpc
+{
+    acpi_osd_exec_callback  function;
+    void		    *context;
+};
+
+#ifdef CONFIG_ACPI_CUSTOM_DSDT
+#include CONFIG_ACPI_CUSTOM_DSDT_FILE
+#endif
+
+#ifdef ENABLE_DEBUGGER
+#include <linux/kdb.h>
+
+/* stuff for debugger support */
+int acpi_in_debugger;
+EXPORT_SYMBOL(acpi_in_debugger);
+
+extern char line_buf[80];
+#endif /*ENABLE_DEBUGGER*/
+
+static unsigned int acpi_irq_irq;
+static acpi_osd_handler acpi_irq_handler;
+static void *acpi_irq_context;
+static struct workqueue_struct *kacpid_wq;
+
+acpi_status
+acpi_os_initialize(void)
+{
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_initialize1(void)
+{
+	/*
+	 * Initialize PCI configuration space access, as we'll need to access
+	 * it while walking the namespace (bus 0 and root bridges w/ _BBNs).
+	 */
+#ifdef CONFIG_ACPI_PCI
+	if (!raw_pci_ops) {
+		printk(KERN_ERR PREFIX "Access to PCI configuration space unavailable\n");
+		return AE_NULL_ENTRY;
+	}
+#endif
+	kacpid_wq = create_singlethread_workqueue("kacpid");
+	BUG_ON(!kacpid_wq);
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_terminate(void)
+{
+	if (acpi_irq_handler) {
+		acpi_os_remove_interrupt_handler(acpi_irq_irq,
+						 acpi_irq_handler);
+	}
+
+	destroy_workqueue(kacpid_wq);
+
+	return AE_OK;
+}
+
+void
+acpi_os_printf(const char *fmt,...)
+{
+	va_list args;
+	va_start(args, fmt);
+	acpi_os_vprintf(fmt, args);
+	va_end(args);
+}
+EXPORT_SYMBOL(acpi_os_printf);
+
+void
+acpi_os_vprintf(const char *fmt, va_list args)
+{
+	static char buffer[512];
+	
+	vsprintf(buffer, fmt, args);
+
+#ifdef ENABLE_DEBUGGER
+	if (acpi_in_debugger) {
+		kdb_printf("%s", buffer);
+	} else {
+		printk("%s", buffer);
+	}
+#else
+	printk("%s", buffer);
+#endif
+}
+
+void *
+acpi_os_allocate(acpi_size size)
+{
+	return kmalloc(size, GFP_KERNEL);
+}
+
+void
+acpi_os_free(void *ptr)
+{
+	kfree(ptr);
+}
+EXPORT_SYMBOL(acpi_os_free);
+
+acpi_status
+acpi_os_get_root_pointer(u32 flags, struct acpi_pointer *addr)
+{
+	if (efi_enabled) {
+		addr->pointer_type = ACPI_PHYSICAL_POINTER;
+		if (efi.acpi20)
+			addr->pointer.physical =
+				(acpi_physical_address) virt_to_phys(efi.acpi20);
+		else if (efi.acpi)
+			addr->pointer.physical =
+				(acpi_physical_address) virt_to_phys(efi.acpi);
+		else {
+			printk(KERN_ERR PREFIX "System description tables not found\n");
+			return AE_NOT_FOUND;
+		}
+	} else {
+		if (ACPI_FAILURE(acpi_find_root_pointer(flags, addr))) {
+			printk(KERN_ERR PREFIX "System description tables not found\n");
+			return AE_NOT_FOUND;
+		}
+	}
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_map_memory(acpi_physical_address phys, acpi_size size, void __iomem **virt)
+{
+	if (efi_enabled) {
+		if (EFI_MEMORY_WB & efi_mem_attributes(phys)) {
+			*virt = (void __iomem *) phys_to_virt(phys);
+		} else {
+			*virt = ioremap(phys, size);
+		}
+	} else {
+		if (phys > ULONG_MAX) {
+			printk(KERN_ERR PREFIX "Cannot map memory that high\n");
+			return AE_BAD_PARAMETER;
+		}
+		/*
+	 	 * ioremap checks to ensure this is in reserved space
+	 	 */
+		*virt = ioremap((unsigned long) phys, size);
+	}
+
+	if (!*virt)
+		return AE_NO_MEMORY;
+
+	return AE_OK;
+}
+
+void
+acpi_os_unmap_memory(void __iomem *virt, acpi_size size)
+{
+	iounmap(virt);
+}
+
+#ifdef ACPI_FUTURE_USAGE
+acpi_status
+acpi_os_get_physical_address(void *virt, acpi_physical_address *phys)
+{
+	if(!phys || !virt)
+		return AE_BAD_PARAMETER;
+
+	*phys = virt_to_phys(virt);
+
+	return AE_OK;
+}
+#endif
+
+#define ACPI_MAX_OVERRIDE_LEN 100
+
+static char acpi_os_name[ACPI_MAX_OVERRIDE_LEN];
+
+acpi_status
+acpi_os_predefined_override (const struct acpi_predefined_names *init_val,
+		             acpi_string *new_val)
+{
+	if (!init_val || !new_val)
+		return AE_BAD_PARAMETER;
+
+	*new_val = NULL;
+	if (!memcmp (init_val->name, "_OS_", 4) && strlen(acpi_os_name)) {
+		printk(KERN_INFO PREFIX "Overriding _OS definition to '%s'\n",
+			acpi_os_name);
+		*new_val = acpi_os_name;
+	}
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_table_override (struct acpi_table_header *existing_table,
+			struct acpi_table_header **new_table)
+{
+	if (!existing_table || !new_table)
+		return AE_BAD_PARAMETER;
+
+#ifdef CONFIG_ACPI_CUSTOM_DSDT
+	if (strncmp(existing_table->signature, "DSDT", 4) == 0)
+		*new_table = (struct acpi_table_header*)AmlCode;
+	else
+		*new_table = NULL;
+#else
+	*new_table = NULL;
+#endif
+	return AE_OK;
+}
+
+static irqreturn_t
+acpi_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	return (*acpi_irq_handler)(acpi_irq_context) ? IRQ_HANDLED : IRQ_NONE;
+}
+
+acpi_status
+acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler, void *context)
+{
+	unsigned int irq;
+
+	/*
+	 * Ignore the GSI from the core, and use the value in our copy of the
+	 * FADT. It may not be the same if an interrupt source override exists
+	 * for the SCI.
+	 */
+	gsi = acpi_fadt.sci_int;
+	if (acpi_gsi_to_irq(gsi, &irq) < 0) {
+		printk(KERN_ERR PREFIX "SCI (ACPI GSI %d) not registered\n",
+		       gsi);
+		return AE_OK;
+	}
+
+	acpi_irq_handler = handler;
+	acpi_irq_context = context;
+	if (request_irq(irq, acpi_irq, SA_SHIRQ, "acpi", acpi_irq)) {
+		printk(KERN_ERR PREFIX "SCI (IRQ%d) allocation failed\n", irq);
+		return AE_NOT_ACQUIRED;
+	}
+	acpi_irq_irq = irq;
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_remove_interrupt_handler(u32 irq, acpi_osd_handler handler)
+{
+	if (irq) {
+		free_irq(irq, acpi_irq);
+		acpi_irq_handler = NULL;
+		acpi_irq_irq = 0;
+	}
+
+	return AE_OK;
+}
+
+/*
+ * Running in interpreter thread context, safe to sleep
+ */
+
+void
+acpi_os_sleep(acpi_integer ms)
+{
+	current->state = TASK_INTERRUPTIBLE;
+	schedule_timeout(((signed long) ms * HZ) / 1000);
+}
+EXPORT_SYMBOL(acpi_os_sleep);
+
+void
+acpi_os_stall(u32 us)
+{
+	while (us) {
+		u32 delay = 1000;
+
+		if (delay > us)
+			delay = us;
+		udelay(delay);
+		touch_nmi_watchdog();
+		us -= delay;
+	}
+}
+EXPORT_SYMBOL(acpi_os_stall);
+
+/*
+ * Support ACPI 3.0 AML Timer operand
+ * Returns 64-bit free-running, monotonically increasing timer
+ * with 100ns granularity
+ */
+u64
+acpi_os_get_timer (void)
+{
+	static u64 t;
+
+#ifdef	CONFIG_HPET
+	/* TBD: use HPET if available */
+#endif
+
+#ifdef	CONFIG_X86_PM_TIMER
+	/* TBD: default to PM timer if HPET was not available */
+#endif
+	if (!t)
+		printk(KERN_ERR PREFIX "acpi_os_get_timer() TBD\n");
+
+	return ++t;
+}
+
+acpi_status
+acpi_os_read_port(
+	acpi_io_address	port,
+	u32		*value,
+	u32		width)
+{
+	u32 dummy;
+
+	if (!value)
+		value = &dummy;
+
+	switch (width)
+	{
+	case 8:
+		*(u8*)  value = inb(port);
+		break;
+	case 16:
+		*(u16*) value = inw(port);
+		break;
+	case 32:
+		*(u32*) value = inl(port);
+		break;
+	default:
+		BUG();
+	}
+
+	return AE_OK;
+}
+EXPORT_SYMBOL(acpi_os_read_port);
+
+acpi_status
+acpi_os_write_port(
+	acpi_io_address	port,
+	u32		value,
+	u32		width)
+{
+	switch (width)
+	{
+	case 8:
+		outb(value, port);
+		break;
+	case 16:
+		outw(value, port);
+		break;
+	case 32:
+		outl(value, port);
+		break;
+	default:
+		BUG();
+	}
+
+	return AE_OK;
+}
+EXPORT_SYMBOL(acpi_os_write_port);
+
+acpi_status
+acpi_os_read_memory(
+	acpi_physical_address	phys_addr,
+	u32			*value,
+	u32			width)
+{
+	u32			dummy;
+	void __iomem		*virt_addr;
+	int			iomem = 0;
+
+	if (efi_enabled) {
+		if (EFI_MEMORY_WB & efi_mem_attributes(phys_addr)) {
+			/* HACK ALERT! We can use readb/w/l on real memory too.. */
+			virt_addr = (void __iomem *) phys_to_virt(phys_addr);
+		} else {
+			iomem = 1;
+			virt_addr = ioremap(phys_addr, width);
+		}
+	} else
+		virt_addr = (void __iomem *) phys_to_virt(phys_addr);
+	if (!value)
+		value = &dummy;
+
+	switch (width) {
+	case 8:
+		*(u8*) value = readb(virt_addr);
+		break;
+	case 16:
+		*(u16*) value = readw(virt_addr);
+		break;
+	case 32:
+		*(u32*) value = readl(virt_addr);
+		break;
+	default:
+		BUG();
+	}
+
+	if (efi_enabled) {
+		if (iomem)
+			iounmap(virt_addr);
+	}
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_write_memory(
+	acpi_physical_address	phys_addr,
+	u32			value,
+	u32			width)
+{
+	void __iomem		*virt_addr;
+	int			iomem = 0;
+
+	if (efi_enabled) {
+		if (EFI_MEMORY_WB & efi_mem_attributes(phys_addr)) {
+			/* HACK ALERT! We can use writeb/w/l on real memory too */
+			virt_addr = (void __iomem *) phys_to_virt(phys_addr);
+		} else {
+			iomem = 1;
+			virt_addr = ioremap(phys_addr, width);
+		}
+	} else
+		virt_addr = (void __iomem *) phys_to_virt(phys_addr);
+
+	switch (width) {
+	case 8:
+		writeb(value, virt_addr);
+		break;
+	case 16:
+		writew(value, virt_addr);
+		break;
+	case 32:
+		writel(value, virt_addr);
+		break;
+	default:
+		BUG();
+	}
+
+	if (iomem)
+		iounmap(virt_addr);
+
+	return AE_OK;
+}
+
+#ifdef CONFIG_ACPI_PCI
+
+acpi_status
+acpi_os_read_pci_configuration (struct acpi_pci_id *pci_id, u32 reg, void *value, u32 width)
+{
+	int result, size;
+
+	if (!value)
+		return AE_BAD_PARAMETER;
+
+	switch (width) {
+	case 8:
+		size = 1;
+		break;
+	case 16:
+		size = 2;
+		break;
+	case 32:
+		size = 4;
+		break;
+	default:
+		return AE_ERROR;
+	}
+
+	BUG_ON(!raw_pci_ops);
+
+	result = raw_pci_ops->read(pci_id->segment, pci_id->bus,
+				PCI_DEVFN(pci_id->device, pci_id->function),
+				reg, size, value);
+
+	return (result ? AE_ERROR : AE_OK);
+}
+EXPORT_SYMBOL(acpi_os_read_pci_configuration);
+
+acpi_status
+acpi_os_write_pci_configuration (struct acpi_pci_id *pci_id, u32 reg, acpi_integer value, u32 width)
+{
+	int result, size;
+
+	switch (width) {
+	case 8:
+		size = 1;
+		break;
+	case 16:
+		size = 2;
+		break;
+	case 32:
+		size = 4;
+		break;
+	default:
+		return AE_ERROR;
+	}
+
+	BUG_ON(!raw_pci_ops);
+
+	result = raw_pci_ops->write(pci_id->segment, pci_id->bus,
+				PCI_DEVFN(pci_id->device, pci_id->function),
+				reg, size, value);
+
+	return (result ? AE_ERROR : AE_OK);
+}
+
+/* TODO: Change code to take advantage of driver model more */
+static void
+acpi_os_derive_pci_id_2 (
+	acpi_handle		rhandle,        /* upper bound  */
+	acpi_handle		chandle,        /* current node */
+	struct acpi_pci_id	**id,
+	int			*is_bridge,
+	u8			*bus_number)
+{
+	acpi_handle		handle;
+	struct acpi_pci_id	*pci_id = *id;
+	acpi_status		status;
+	unsigned long		temp;
+	acpi_object_type	type;
+	u8			tu8;
+
+	acpi_get_parent(chandle, &handle);
+	if (handle != rhandle) {
+		acpi_os_derive_pci_id_2(rhandle, handle, &pci_id, is_bridge, bus_number);
+
+		status = acpi_get_type(handle, &type);
+		if ( (ACPI_FAILURE(status)) || (type != ACPI_TYPE_DEVICE) )
+			return;
+
+		status = acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL, &temp);
+		if (ACPI_SUCCESS(status)) {
+			pci_id->device  = ACPI_HIWORD (ACPI_LODWORD (temp));
+			pci_id->function = ACPI_LOWORD (ACPI_LODWORD (temp));
+
+			if (*is_bridge)
+				pci_id->bus = *bus_number;
+
+			/* any nicer way to get bus number of bridge ? */
+			status = acpi_os_read_pci_configuration(pci_id, 0x0e, &tu8, 8);
+			if (ACPI_SUCCESS(status) &&
+			    ((tu8 & 0x7f) == 1 || (tu8 & 0x7f) == 2)) {
+				status = acpi_os_read_pci_configuration(pci_id, 0x18, &tu8, 8);
+				if (!ACPI_SUCCESS(status)) {
+					/* Certainly broken...  FIX ME */
+					return;
+				}
+				*is_bridge = 1;
+				pci_id->bus = tu8;
+				status = acpi_os_read_pci_configuration(pci_id, 0x19, &tu8, 8);
+				if (ACPI_SUCCESS(status)) {
+					*bus_number = tu8;
+				}
+			} else
+				*is_bridge = 0;
+		}
+	}
+}
+
+void
+acpi_os_derive_pci_id (
+	acpi_handle		rhandle,        /* upper bound  */
+	acpi_handle		chandle,        /* current node */
+	struct acpi_pci_id	**id)
+{
+	int is_bridge = 1;
+	u8 bus_number = (*id)->bus;
+
+	acpi_os_derive_pci_id_2(rhandle, chandle, id, &is_bridge, &bus_number);
+}
+
+#else /*!CONFIG_ACPI_PCI*/
+
+acpi_status
+acpi_os_write_pci_configuration (
+	struct acpi_pci_id	*pci_id,
+	u32			reg,
+	acpi_integer		value,
+	u32			width)
+{
+	return AE_SUPPORT;
+}
+
+acpi_status
+acpi_os_read_pci_configuration (
+	struct acpi_pci_id	*pci_id,
+	u32			reg,
+	void			*value,
+	u32			width)
+{
+	return AE_SUPPORT;
+}
+
+void
+acpi_os_derive_pci_id (
+	acpi_handle		rhandle,        /* upper bound  */
+	acpi_handle		chandle,        /* current node */
+	struct acpi_pci_id	**id)
+{
+}
+
+#endif /*CONFIG_ACPI_PCI*/
+
+static void
+acpi_os_execute_deferred (
+	void *context)
+{
+	struct acpi_os_dpc	*dpc = NULL;
+
+	ACPI_FUNCTION_TRACE ("os_execute_deferred");
+
+	dpc = (struct acpi_os_dpc *) context;
+	if (!dpc) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
+		return_VOID;
+	}
+
+	dpc->function(dpc->context);
+
+	kfree(dpc);
+
+	return_VOID;
+}
+
+acpi_status
+acpi_os_queue_for_execution(
+	u32			priority,
+	acpi_osd_exec_callback	function,
+	void			*context)
+{
+	acpi_status 		status = AE_OK;
+	struct acpi_os_dpc	*dpc;
+	struct work_struct	*task;
+
+	ACPI_FUNCTION_TRACE ("os_queue_for_execution");
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Scheduling function [%p(%p)] for deferred execution.\n", function, context));
+
+	if (!function)
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+
+	/*
+	 * Allocate/initialize DPC structure.  Note that this memory will be
+	 * freed by the callee.  The kernel handles the tq_struct list  in a
+	 * way that allows us to also free its memory inside the callee.
+	 * Because we may want to schedule several tasks with different
+	 * parameters we can't use the approach some kernel code uses of
+	 * having a static tq_struct.
+	 * We can save time and code by allocating the DPC and tq_structs
+	 * from the same memory.
+	 */
+
+	dpc = kmalloc(sizeof(struct acpi_os_dpc)+sizeof(struct work_struct), GFP_ATOMIC);
+	if (!dpc)
+		return_ACPI_STATUS (AE_NO_MEMORY);
+
+	dpc->function = function;
+	dpc->context = context;
+
+	task = (void *)(dpc+1);
+	INIT_WORK(task, acpi_os_execute_deferred, (void*)dpc);
+
+	if (!queue_work(kacpid_wq, task)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Call to queue_work() failed.\n"));
+		kfree(dpc);
+		status = AE_ERROR;
+	}
+
+	return_ACPI_STATUS (status);
+}
+EXPORT_SYMBOL(acpi_os_queue_for_execution);
+
+void
+acpi_os_wait_events_complete(
+	void *context)
+{
+	flush_workqueue(kacpid_wq);
+}
+EXPORT_SYMBOL(acpi_os_wait_events_complete);
+
+/*
+ * Allocate the memory for a spinlock and initialize it.
+ */
+acpi_status
+acpi_os_create_lock (
+	acpi_handle	*out_handle)
+{
+	spinlock_t *lock_ptr;
+
+	ACPI_FUNCTION_TRACE ("os_create_lock");
+
+	lock_ptr = acpi_os_allocate(sizeof(spinlock_t));
+
+	spin_lock_init(lock_ptr);
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Creating spinlock[%p].\n", lock_ptr));
+
+	*out_handle = lock_ptr;
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+
+/*
+ * Deallocate the memory for a spinlock.
+ */
+void
+acpi_os_delete_lock (
+	acpi_handle	handle)
+{
+	ACPI_FUNCTION_TRACE ("os_create_lock");
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Deleting spinlock[%p].\n", handle));
+
+	acpi_os_free(handle);
+
+	return_VOID;
+}
+
+/*
+ * Acquire a spinlock.
+ *
+ * handle is a pointer to the spinlock_t.
+ * flags is *not* the result of save_flags - it is an ACPI-specific flag variable
+ *   that indicates whether we are at interrupt level.
+ */
+void
+acpi_os_acquire_lock (
+	acpi_handle	handle,
+	u32		flags)
+{
+	ACPI_FUNCTION_TRACE ("os_acquire_lock");
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Acquiring spinlock[%p] from %s level\n", handle,
+		((flags & ACPI_NOT_ISR) ? "non-interrupt" : "interrupt")));
+
+	if (flags & ACPI_NOT_ISR)
+		ACPI_DISABLE_IRQS();
+
+	spin_lock((spinlock_t *)handle);
+
+	return_VOID;
+}
+
+
+/*
+ * Release a spinlock. See above.
+ */
+void
+acpi_os_release_lock (
+	acpi_handle	handle,
+	u32		flags)
+{
+	ACPI_FUNCTION_TRACE ("os_release_lock");
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Releasing spinlock[%p] from %s level\n", handle,
+		((flags & ACPI_NOT_ISR) ? "non-interrupt" : "interrupt")));
+
+	spin_unlock((spinlock_t *)handle);
+
+	if (flags & ACPI_NOT_ISR)
+		ACPI_ENABLE_IRQS();
+
+	return_VOID;
+}
+
+
+acpi_status
+acpi_os_create_semaphore(
+	u32		max_units,
+	u32		initial_units,
+	acpi_handle	*handle)
+{
+	struct semaphore	*sem = NULL;
+
+	ACPI_FUNCTION_TRACE ("os_create_semaphore");
+
+	sem = acpi_os_allocate(sizeof(struct semaphore));
+	if (!sem)
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	memset(sem, 0, sizeof(struct semaphore));
+
+	sema_init(sem, initial_units);
+
+	*handle = (acpi_handle*)sem;
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Creating semaphore[%p|%d].\n", *handle, initial_units));
+
+	return_ACPI_STATUS (AE_OK);
+}
+EXPORT_SYMBOL(acpi_os_create_semaphore);
+
+
+/*
+ * TODO: A better way to delete semaphores?  Linux doesn't have a
+ * 'delete_semaphore()' function -- may result in an invalid
+ * pointer dereference for non-synchronized consumers.	Should
+ * we at least check for blocked threads and signal/cancel them?
+ */
+
+acpi_status
+acpi_os_delete_semaphore(
+	acpi_handle	handle)
+{
+	struct semaphore *sem = (struct semaphore*) handle;
+
+	ACPI_FUNCTION_TRACE ("os_delete_semaphore");
+
+	if (!sem)
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Deleting semaphore[%p].\n", handle));
+
+	acpi_os_free(sem); sem =  NULL;
+
+	return_ACPI_STATUS (AE_OK);
+}
+EXPORT_SYMBOL(acpi_os_delete_semaphore);
+
+
+/*
+ * TODO: The kernel doesn't have a 'down_timeout' function -- had to
+ * improvise.  The process is to sleep for one scheduler quantum
+ * until the semaphore becomes available.  Downside is that this
+ * may result in starvation for timeout-based waits when there's
+ * lots of semaphore activity.
+ *
+ * TODO: Support for units > 1?
+ */
+acpi_status
+acpi_os_wait_semaphore(
+	acpi_handle		handle,
+	u32			units,
+	u16			timeout)
+{
+	acpi_status		status = AE_OK;
+	struct semaphore	*sem = (struct semaphore*)handle;
+	int			ret = 0;
+
+	ACPI_FUNCTION_TRACE ("os_wait_semaphore");
+
+	if (!sem || (units < 1))
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+
+	if (units > 1)
+		return_ACPI_STATUS (AE_SUPPORT);
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Waiting for semaphore[%p|%d|%d]\n", handle, units, timeout));
+
+	if (in_atomic())
+		timeout = 0;
+
+	switch (timeout)
+	{
+		/*
+		 * No Wait:
+		 * --------
+		 * A zero timeout value indicates that we shouldn't wait - just
+		 * acquire the semaphore if available otherwise return AE_TIME
+		 * (a.k.a. 'would block').
+		 */
+		case 0:
+		if(down_trylock(sem))
+			status = AE_TIME;
+		break;
+
+		/*
+		 * Wait Indefinitely:
+		 * ------------------
+		 */
+		case ACPI_WAIT_FOREVER:
+		down(sem);
+		break;
+
+		/*
+		 * Wait w/ Timeout:
+		 * ----------------
+		 */
+		default:
+		// TODO: A better timeout algorithm?
+		{
+			int i = 0;
+			static const int quantum_ms = 1000/HZ;
+
+			ret = down_trylock(sem);
+			for (i = timeout; (i > 0 && ret < 0); i -= quantum_ms) {
+				current->state = TASK_INTERRUPTIBLE;
+				schedule_timeout(1);
+				ret = down_trylock(sem);
+			}
+	
+			if (ret != 0)
+				status = AE_TIME;
+		}
+		break;
+	}
+
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Failed to acquire semaphore[%p|%d|%d], %s\n", 
+			handle, units, timeout, acpi_format_exception(status)));
+	}
+	else {
+		ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Acquired semaphore[%p|%d|%d]\n", handle, units, timeout));
+	}
+
+	return_ACPI_STATUS (status);
+}
+EXPORT_SYMBOL(acpi_os_wait_semaphore);
+
+
+/*
+ * TODO: Support for units > 1?
+ */
+acpi_status
+acpi_os_signal_semaphore(
+    acpi_handle 	    handle,
+    u32 		    units)
+{
+	struct semaphore *sem = (struct semaphore *) handle;
+
+	ACPI_FUNCTION_TRACE ("os_signal_semaphore");
+
+	if (!sem || (units < 1))
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+
+	if (units > 1)
+		return_ACPI_STATUS (AE_SUPPORT);
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Signaling semaphore[%p|%d]\n", handle, units));
+
+	up(sem);
+
+	return_ACPI_STATUS (AE_OK);
+}
+EXPORT_SYMBOL(acpi_os_signal_semaphore);
+
+#ifdef ACPI_FUTURE_USAGE
+u32
+acpi_os_get_line(char *buffer)
+{
+
+#ifdef ENABLE_DEBUGGER
+	if (acpi_in_debugger) {
+		u32 chars;
+
+		kdb_read(buffer, sizeof(line_buf));
+
+		/* remove the CR kdb includes */
+		chars = strlen(buffer) - 1;
+		buffer[chars] = '\0';
+	}
+#endif
+
+	return 0;
+}
+#endif  /*  ACPI_FUTURE_USAGE  */
+
+/* Assumes no unreadable holes inbetween */
+u8
+acpi_os_readable(void *ptr, acpi_size len)
+{
+#if defined(__i386__) || defined(__x86_64__) 
+	char tmp;
+	return !__get_user(tmp, (char __user *)ptr) && !__get_user(tmp, (char __user *)ptr + len - 1);
+#endif
+	return 1;
+}
+
+#ifdef ACPI_FUTURE_USAGE
+u8
+acpi_os_writable(void *ptr, acpi_size len)
+{
+	/* could do dummy write (racy) or a kernel page table lookup.
+	   The later may be difficult at early boot when kmap doesn't work yet. */
+	return 1;
+}
+#endif
+
+u32
+acpi_os_get_thread_id (void)
+{
+	if (!in_atomic())
+		return current->pid;
+
+	return 0;
+}
+
+acpi_status
+acpi_os_signal (
+    u32		function,
+    void	*info)
+{
+	switch (function)
+	{
+	case ACPI_SIGNAL_FATAL:
+		printk(KERN_ERR PREFIX "Fatal opcode executed\n");
+		break;
+	case ACPI_SIGNAL_BREAKPOINT:
+		/*
+		 * AML Breakpoint
+		 * ACPI spec. says to treat it as a NOP unless
+		 * you are debugging.  So if/when we integrate
+		 * AML debugger into the kernel debugger its
+		 * hook will go here.  But until then it is
+		 * not useful to print anything on breakpoints.
+		 */
+		break;
+	default:
+		break;
+	}
+
+	return AE_OK;
+}
+EXPORT_SYMBOL(acpi_os_signal);
+
+static int __init
+acpi_os_name_setup(char *str)
+{
+	char *p = acpi_os_name;
+	int count = ACPI_MAX_OVERRIDE_LEN-1;
+
+	if (!str || !*str)
+		return 0;
+
+	for (; count-- && str && *str; str++) {
+		if (isalnum(*str) || *str == ' ' || *str == ':')
+			*p++ = *str;
+		else if (*str == '\'' || *str == '"')
+			continue;
+		else
+			break;
+	}
+	*p = 0;
+
+	return 1;
+		
+}
+
+__setup("acpi_os_name=", acpi_os_name_setup);
+
+/*
+ * _OSI control
+ * empty string disables _OSI
+ * TBD additional string adds to _OSI
+ */
+static int __init
+acpi_osi_setup(char *str)
+{
+	if (str == NULL || *str == '\0') {
+		printk(KERN_INFO PREFIX "_OSI method disabled\n");
+		acpi_gbl_create_osi_method = FALSE;
+	} else
+	{
+		/* TBD */
+		printk(KERN_ERR PREFIX "_OSI additional string ignored -- %s\n", str);
+	}
+
+	return 1;
+}
+
+__setup("acpi_osi=", acpi_osi_setup);
+
+/* enable serialization to combat AE_ALREADY_EXISTS errors */
+static int __init
+acpi_serialize_setup(char *str)
+{
+	printk(KERN_INFO PREFIX "serialize enabled\n");
+
+	acpi_gbl_all_methods_serialized = TRUE;
+
+	return 1;
+}
+
+__setup("acpi_serialize", acpi_serialize_setup);
+
+/*
+ * Wake and Run-Time GPES are expected to be separate.
+ * We disable wake-GPEs at run-time to prevent spurious
+ * interrupts.
+ *
+ * However, if a system exists that shares Wake and
+ * Run-time events on the same GPE this flag is available
+ * to tell Linux to keep the wake-time GPEs enabled at run-time.
+ */
+static int __init
+acpi_wake_gpes_always_on_setup(char *str)
+{
+	printk(KERN_INFO PREFIX "wake GPEs not disabled\n");
+
+	acpi_gbl_leave_wake_gpes_disabled = FALSE;
+
+	return 1;
+}
+
+__setup("acpi_wake_gpes_always_on", acpi_wake_gpes_always_on_setup);
+
+/*
+ * max_cstate is defined in the base kernel so modules can
+ * change it w/o depending on the state of the processor module.
+ */
+unsigned int max_cstate = ACPI_PROCESSOR_MAX_POWER;
+
+
+EXPORT_SYMBOL(max_cstate);
