commit e6d701dca9893990d999fd145e3e07223c002b06
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Thu Jun 11 21:51:50 2020 -0700

    ACPI: sysfs: Fix pm_profile_attr type
    
    When running a kernel with Clang's Control Flow Integrity implemented,
    there is a violation that happens when accessing
    /sys/firmware/acpi/pm_profile:
    
    $ cat /sys/firmware/acpi/pm_profile
    0
    
    $ dmesg
    ...
    [   17.352564] ------------[ cut here ]------------
    [   17.352568] CFI failure (target: acpi_show_profile+0x0/0x8):
    [   17.352572] WARNING: CPU: 3 PID: 497 at kernel/cfi.c:29 __cfi_check_fail+0x33/0x40
    [   17.352573] Modules linked in:
    [   17.352575] CPU: 3 PID: 497 Comm: cat Tainted: G        W         5.7.0-microsoft-standard+ #1
    [   17.352576] RIP: 0010:__cfi_check_fail+0x33/0x40
    [   17.352577] Code: 48 c7 c7 50 b3 85 84 48 c7 c6 50 0a 4e 84 e8 a4 d8 60 00 85 c0 75 02 5b c3 48 c7 c7 dc 5e 49 84 48 89 de 31 c0 e8 7d 06 eb ff <0f> 0b 5b c3 00 00 cc cc 00 00 cc cc 00 85 f6 74 25 41 b9 ea ff ff
    [   17.352577] RSP: 0018:ffffaa6dc3c53d30 EFLAGS: 00010246
    [   17.352578] RAX: 331267e0c06cee00 RBX: ffffffff83d85890 RCX: ffffffff8483a6f8
    [   17.352579] RDX: ffff9cceabbb37c0 RSI: 0000000000000082 RDI: ffffffff84bb9e1c
    [   17.352579] RBP: ffffffff845b2bc8 R08: 0000000000000001 R09: ffff9cceabbba200
    [   17.352579] R10: 000000000000019d R11: 0000000000000000 R12: ffff9cc947766f00
    [   17.352580] R13: ffffffff83d6bd50 R14: ffff9ccc6fa80000 R15: ffffffff845bd328
    [   17.352582] FS:  00007fdbc8d13580(0000) GS:ffff9cce91ac0000(0000) knlGS:0000000000000000
    [   17.352582] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   17.352583] CR2: 00007fdbc858e000 CR3: 00000005174d0000 CR4: 0000000000340ea0
    [   17.352584] Call Trace:
    [   17.352586]  ? rev_id_show+0x8/0x8
    [   17.352587]  ? __cfi_check+0x45bac/0x4b640
    [   17.352589]  ? kobj_attr_show+0x73/0x80
    [   17.352590]  ? sysfs_kf_seq_show+0xc1/0x140
    [   17.352592]  ? ext4_seq_options_show.cfi_jt+0x8/0x8
    [   17.352593]  ? seq_read+0x180/0x600
    [   17.352595]  ? sysfs_create_file_ns.cfi_jt+0x10/0x10
    [   17.352596]  ? tlbflush_read_file+0x8/0x8
    [   17.352597]  ? __vfs_read+0x6b/0x220
    [   17.352598]  ? handle_mm_fault+0xa23/0x11b0
    [   17.352599]  ? vfs_read+0xa2/0x130
    [   17.352599]  ? ksys_read+0x6a/0xd0
    [   17.352601]  ? __do_sys_getpgrp+0x8/0x8
    [   17.352602]  ? do_syscall_64+0x72/0x120
    [   17.352603]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9
    [   17.352604] ---[ end trace 7b1fa81dc897e419 ]---
    
    When /sys/firmware/acpi/pm_profile is read, sysfs_kf_seq_show is called,
    which in turn calls kobj_attr_show, which gets the ->show callback
    member by calling container_of on attr (casting it to struct
    kobj_attribute) then calls it.
    
    There is a CFI violation because pm_profile_attr is of type
    struct device_attribute but kobj_attr_show calls ->show expecting it
    to be from struct kobj_attribute. CFI checking ensures that function
    pointer types match when doing indirect calls. Fix pm_profile_attr to
    be defined in terms of kobj_attribute so there is no violation or
    mismatch.
    
    Fixes: 362b646062b2 ("ACPI: Export FADT pm_profile integer value to userspace")
    Link: https://github.com/ClangBuiltLinux/linux/issues/1051
    Reported-by: yuu ichii <byahu140@heisei.be>
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Cc: 3.10+ <stable@vger.kernel.org> # 3.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 3a89909b50a6..76c668c05fa0 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -938,13 +938,13 @@ static void __exit interrupt_stats_exit(void)
 }
 
 static ssize_t
-acpi_show_profile(struct device *dev, struct device_attribute *attr,
+acpi_show_profile(struct kobject *kobj, struct kobj_attribute *attr,
 		  char *buf)
 {
 	return sprintf(buf, "%d\n", acpi_gbl_FADT.preferred_profile);
 }
 
-static const struct device_attribute pm_profile_attr =
+static const struct kobj_attribute pm_profile_attr =
 	__ATTR(pm_profile, S_IRUGO, acpi_show_profile, NULL);
 
 static ssize_t hotplug_enabled_show(struct kobject *kobj,

commit 6e6c25283dff866308c87b49434c7dbad4774cc0
Author: Qiushi Wu <wu000273@umn.edu>
Date:   Wed May 27 16:17:17 2020 -0500

    ACPI: sysfs: Fix reference count leak in acpi_sysfs_add_hotplug_profile()
    
    kobject_init_and_add() takes reference even when it fails.
    Thus, when kobject_init_and_add() returns an error,
    kobject_put() must be called to properly clean up the kobject.
    
    Fixes: 3f8055c35836 ("ACPI / hotplug: Introduce user space interface for hotplug profiles")
    Signed-off-by: Qiushi Wu <wu000273@umn.edu>
    Cc: 3.10+ <stable@vger.kernel.org> # 3.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index c60d2c6d31d6..3a89909b50a6 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -993,8 +993,10 @@ void acpi_sysfs_add_hotplug_profile(struct acpi_hotplug_profile *hotplug,
 
 	error = kobject_init_and_add(&hotplug->kobj,
 		&acpi_hotplug_profile_ktype, hotplug_kobj, "%s", name);
-	if (error)
+	if (error) {
+		kobject_put(&hotplug->kobj);
 		goto err_out;
+	}
 
 	kobject_uevent(&hotplug->kobj, KOBJ_ADD);
 	return;

commit a7583e72a5f22470d3e6fd3b6ba912892242339f
Author: Yunfeng Ye <yeyunfeng@huawei.com>
Date:   Thu Nov 14 15:16:24 2019 +0800

    ACPI: sysfs: Change ACPI_MASKABLE_GPE_MAX to 0x100
    
    The commit 0f27cff8597d ("ACPI: sysfs: Make ACPI GPE mask kernel
    parameter cover all GPEs") says:
      "Use a bitmap of size 0xFF instead of a u64 for the GPE mask so 256
       GPEs can be masked"
    
    But the masking of GPE 0xFF it not supported and the check condition
    "gpe > ACPI_MASKABLE_GPE_MAX" is not valid because the type of gpe is
    u8.
    
    So modify the macro ACPI_MASKABLE_GPE_MAX to 0x100, and drop the "gpe >
    ACPI_MASKABLE_GPE_MAX" check. In addition, update the docs "Format" for
    acpi_mask_gpe parameter.
    
    Fixes: 0f27cff8597d ("ACPI: sysfs: Make ACPI GPE mask kernel parameter cover all GPEs")
    Signed-off-by: Yunfeng Ye <yeyunfeng@huawei.com>
    [ rjw: Use u16 as gpe data type in acpi_gpe_apply_masked_gpes() ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 75948a3f1a20..c60d2c6d31d6 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -819,14 +819,14 @@ static ssize_t counter_set(struct kobject *kobj,
  * interface:
  *   echo unmask > /sys/firmware/acpi/interrupts/gpe00
  */
-#define ACPI_MASKABLE_GPE_MAX	0xFF
+#define ACPI_MASKABLE_GPE_MAX	0x100
 static DECLARE_BITMAP(acpi_masked_gpes_map, ACPI_MASKABLE_GPE_MAX) __initdata;
 
 static int __init acpi_gpe_set_masked_gpes(char *val)
 {
 	u8 gpe;
 
-	if (kstrtou8(val, 0, &gpe) || gpe > ACPI_MASKABLE_GPE_MAX)
+	if (kstrtou8(val, 0, &gpe))
 		return -EINVAL;
 	set_bit(gpe, acpi_masked_gpes_map);
 
@@ -838,7 +838,7 @@ void __init acpi_gpe_apply_masked_gpes(void)
 {
 	acpi_handle handle;
 	acpi_status status;
-	u8 gpe;
+	u16 gpe;
 
 	for_each_set_bit(gpe, acpi_masked_gpes_map, ACPI_MASKABLE_GPE_MAX) {
 		status = acpi_get_gpe_device(gpe, &handle);

commit 3278675567dfb901d831d46849c386a4f932905e
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Apr 8 13:42:25 2019 -0700

    ACPICA: Rename nameseg length macro/define for clarity
    
    ACPICA commit 24870bd9e73d71e2a1ff0a1e94519f8f8409e57d
    
    ACPI_NAME_SIZE changed to ACPI_NAMESEG_SIZE
    This clarifies that this is the length of an individual
    nameseg, not the length of a generic namestring/namepath.
    Improves understanding of the code.
    
    Link: https://github.com/acpica/acpica/commit/24870bd9
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 262d6ee4735d..75948a3f1a20 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -327,9 +327,9 @@ static struct kobject *hotplug_kobj;
 
 struct acpi_table_attr {
 	struct bin_attribute attr;
-	char name[ACPI_NAME_SIZE];
+	char name[ACPI_NAMESEG_SIZE];
 	int instance;
-	char filename[ACPI_NAME_SIZE+ACPI_INST_SIZE];
+	char filename[ACPI_NAMESEG_SIZE+ACPI_INST_SIZE];
 	struct list_head node;
 };
 
@@ -383,7 +383,7 @@ static int acpi_table_attr_init(struct kobject *tables_obj,
 	}
 
 	ACPI_COPY_NAMESEG(table_attr->filename, table_header->signature);
-	table_attr->filename[ACPI_NAME_SIZE] = '\0';
+	table_attr->filename[ACPI_NAMESEG_SIZE] = '\0';
 	if (table_attr->instance > 1 || (table_attr->instance == 1 &&
 					 !acpi_get_table
 					 (table_header->signature, 2, &header))) {

commit 5599fb69355d7a558f32206dac7539e945a1f604
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Apr 8 13:42:24 2019 -0700

    ACPICA: Rename nameseg compare macro for clarity
    
    ACPICA commit 92ec0935f27e217dff0b176fca02c2ec3d782bb5
    
    ACPI_COMPARE_NAME changed to ACPI_COMPARE_NAMESEG
    This clarifies (1) this is a compare on 4-byte namesegs, not
    a generic compare. Improves understanding of the code.
    
    Link: https://github.com/acpica/acpica/commit/92ec0935
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index fa76f5e41b5c..262d6ee4735d 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -368,10 +368,10 @@ static int acpi_table_attr_init(struct kobject *tables_obj,
 	char instance_str[ACPI_INST_SIZE];
 
 	sysfs_attr_init(&table_attr->attr.attr);
-	ACPI_MOVE_NAME(table_attr->name, table_header->signature);
+	ACPI_COPY_NAMESEG(table_attr->name, table_header->signature);
 
 	list_for_each_entry(attr, &acpi_table_attr_list, node) {
-		if (ACPI_COMPARE_NAME(table_attr->name, attr->name))
+		if (ACPI_COMPARE_NAMESEG(table_attr->name, attr->name))
 			if (table_attr->instance < attr->instance)
 				table_attr->instance = attr->instance;
 	}
@@ -382,7 +382,7 @@ static int acpi_table_attr_init(struct kobject *tables_obj,
 		return -ERANGE;
 	}
 
-	ACPI_MOVE_NAME(table_attr->filename, table_header->signature);
+	ACPI_COPY_NAMESEG(table_attr->filename, table_header->signature);
 	table_attr->filename[ACPI_NAME_SIZE] = '\0';
 	if (table_attr->instance > 1 || (table_attr->instance == 1 &&
 					 !acpi_get_table
@@ -484,7 +484,7 @@ static int acpi_table_data_init(struct acpi_table_header *th)
 	int i;
 
 	for (i = 0; i < NUM_ACPI_DATA_OBJS; i++) {
-		if (ACPI_COMPARE_NAME(th->signature, acpi_data_objs[i].name)) {
+		if (ACPI_COMPARE_NAMESEG(th->signature, acpi_data_objs[i].name)) {
 			data_attr = kzalloc(sizeof(*data_attr), GFP_KERNEL);
 			if (!data_attr)
 				return -ENOMEM;

commit 3fd16d70166194dd0bf0f7a555779a42ee267223
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Mar 12 10:30:29 2019 +0100

    ACPI: sysfs: Prevent get_status() from returning acpi_status
    
    The return value of get_status() is passed to user space on errors,
    so it should not return acpi_status values then.  Make it return
    error values that are meaningful for user space instead.
    
    This also makes a Clang warning regarding the initialization of a
    local variable in get_status() go away.
    
    Reported-by: Nathan Chancellor <natechancellor@gmail.com>
    Reviewed-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 41324f0b1bee..fa76f5e41b5c 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -648,26 +648,29 @@ static void acpi_global_event_handler(u32 event_type, acpi_handle device,
 	}
 }
 
-static int get_status(u32 index, acpi_event_status *status,
+static int get_status(u32 index, acpi_event_status *ret,
 		      acpi_handle *handle)
 {
-	int result;
+	acpi_status status;
 
 	if (index >= num_gpes + ACPI_NUM_FIXED_EVENTS)
 		return -EINVAL;
 
 	if (index < num_gpes) {
-		result = acpi_get_gpe_device(index, handle);
-		if (result) {
+		status = acpi_get_gpe_device(index, handle);
+		if (ACPI_FAILURE(status)) {
 			ACPI_EXCEPTION((AE_INFO, AE_NOT_FOUND,
 					"Invalid GPE 0x%x", index));
-			return result;
+			return -ENXIO;
 		}
-		result = acpi_get_gpe_status(*handle, index, status);
-	} else if (index < (num_gpes + ACPI_NUM_FIXED_EVENTS))
-		result = acpi_get_event_status(index - num_gpes, status);
+		status = acpi_get_gpe_status(*handle, index, ret);
+	} else {
+		status = acpi_get_event_status(index - num_gpes, ret);
+	}
+	if (ACPI_FAILURE(status))
+		return -EIO;
 
-	return result;
+	return 0;
 }
 
 static ssize_t counter_show(struct kobject *kobj,

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 4fc59c3bc673..41324f0b1bee 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -857,12 +857,12 @@ void acpi_irq_stats_init(void)
 	num_gpes = acpi_current_gpe_count;
 	num_counters = num_gpes + ACPI_NUM_FIXED_EVENTS + NUM_COUNTERS_EXTRA;
 
-	all_attrs = kzalloc(sizeof(struct attribute *) * (num_counters + 1),
+	all_attrs = kcalloc(num_counters + 1, sizeof(struct attribute *),
 			    GFP_KERNEL);
 	if (all_attrs == NULL)
 		return;
 
-	all_counters = kzalloc(sizeof(struct event_counter) * (num_counters),
+	all_counters = kcalloc(num_counters, sizeof(struct event_counter),
 			       GFP_KERNEL);
 	if (all_counters == NULL)
 		goto fail;
@@ -871,7 +871,7 @@ void acpi_irq_stats_init(void)
 	if (ACPI_FAILURE(status))
 		goto fail;
 
-	counter_attrs = kzalloc(sizeof(struct kobj_attribute) * (num_counters),
+	counter_attrs = kcalloc(num_counters, sizeof(struct kobj_attribute),
 				GFP_KERNEL);
 	if (counter_attrs == NULL)
 		goto fail;

commit 0f27cff8597d86f881ea8274b49b63b678c14a3c
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Nov 30 15:05:59 2017 -0500

    ACPI: sysfs: Make ACPI GPE mask kernel parameter cover all GPEs
    
    The acpi_mask_gpe= kernel parameter documentation states that the range
    of mask is 128 GPEs (0x00 to 0x7F).  The acpi_masked_gpes mask is a u64 so
    only 64 GPEs (0x00 to 0x3F) can really be masked.
    
    Use a bitmap of size 0xFF instead of a u64 for the GPE mask so 256
    GPEs can be masked.
    
    Fixes: 9c4aa1eecb48 (ACPI / sysfs: Provide quirk mechanism to prevent GPE flooding)
    Signed-off-by: Prarit Bharava <prarit@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 06a150bb35bf..4fc59c3bc673 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -816,14 +816,8 @@ static ssize_t counter_set(struct kobject *kobj,
  * interface:
  *   echo unmask > /sys/firmware/acpi/interrupts/gpe00
  */
-
-/*
- * Currently, the GPE flooding prevention only supports to mask the GPEs
- * numbered from 00 to 7f.
- */
-#define ACPI_MASKABLE_GPE_MAX	0x80
-
-static u64 __initdata acpi_masked_gpes;
+#define ACPI_MASKABLE_GPE_MAX	0xFF
+static DECLARE_BITMAP(acpi_masked_gpes_map, ACPI_MASKABLE_GPE_MAX) __initdata;
 
 static int __init acpi_gpe_set_masked_gpes(char *val)
 {
@@ -831,7 +825,7 @@ static int __init acpi_gpe_set_masked_gpes(char *val)
 
 	if (kstrtou8(val, 0, &gpe) || gpe > ACPI_MASKABLE_GPE_MAX)
 		return -EINVAL;
-	acpi_masked_gpes |= ((u64)1<<gpe);
+	set_bit(gpe, acpi_masked_gpes_map);
 
 	return 1;
 }
@@ -843,15 +837,11 @@ void __init acpi_gpe_apply_masked_gpes(void)
 	acpi_status status;
 	u8 gpe;
 
-	for (gpe = 0;
-	     gpe < min_t(u8, ACPI_MASKABLE_GPE_MAX, acpi_current_gpe_count);
-	     gpe++) {
-		if (acpi_masked_gpes & ((u64)1<<gpe)) {
-			status = acpi_get_gpe_device(gpe, &handle);
-			if (ACPI_SUCCESS(status)) {
-				pr_info("Masking GPE 0x%x.\n", gpe);
-				(void)acpi_mask_gpe(handle, gpe, TRUE);
-			}
+	for_each_set_bit(gpe, acpi_masked_gpes_map, ACPI_MASKABLE_GPE_MAX) {
+		status = acpi_get_gpe_device(gpe, &handle);
+		if (ACPI_SUCCESS(status)) {
+			pr_info("Masking GPE 0x%x.\n", gpe);
+			(void)acpi_mask_gpe(handle, gpe, TRUE);
 		}
 	}
 }

commit 1be2172e96e33bfa22a5c7a651f768ef30ce3984
Merge: 3c18767a4565 ece1996a21ee
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 15 13:46:33 2017 -0800

    Merge tag 'modules-for-v4.15' of git://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux
    
    Pull module updates from Jessica Yu:
     "Summary of modules changes for the 4.15 merge window:
    
       - treewide module_param_call() cleanup, fix up set/get function
         prototype mismatches, from Kees Cook
    
       - minor code cleanups"
    
    * tag 'modules-for-v4.15' of git://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux:
      module: Do not paper over type mismatches in module_param_call()
      treewide: Fix function prototypes for module_param_call()
      module: Prepare to convert all module_param_call() prototypes
      kernel/module: Delete an error message for a failed memory allocation in add_module_usage()

commit 3e87ead41224fca9dbc3c8646b5cff8168348aba
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Oct 2 15:40:33 2017 +0100

    ACPI / sysfs: Make function param_set_trace_method_name() static
    
    The function param_set_trace_method_name is local to the source and does
    not need to be in global scope, so make it static.
    
    Cleans up sparse warning:
    symbol 'param_set_trace_method_name' was not declared. Should it be static?
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 0fd57bf33524..bc303df60d5d 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -169,7 +169,8 @@ module_param_cb(debug_level, &param_ops_debug_level, &acpi_dbg_level, 0644);
 
 static char trace_method_name[1024];
 
-int param_set_trace_method_name(const char *val, const struct kernel_param *kp)
+static int param_set_trace_method_name(const char *val,
+				       const struct kernel_param *kp)
 {
 	u32 saved_flags = 0;
 	bool is_abs_path = true;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 78a5a23010ab..0fd57bf33524 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * sysfs.c - ACPI sysfs interface to userspace.
  */

commit e4dca7b7aa08b22893c45485d222b5807c1375ae
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 17 19:04:42 2017 -0700

    treewide: Fix function prototypes for module_param_call()
    
    Several function prototypes for the set/get functions defined by
    module_param_call() have a slightly wrong argument types. This fixes
    those in an effort to clean up the calls when running under type-enforced
    compiler instrumentation for CFI. This is the result of running the
    following semantic patch:
    
    @match_module_param_call_function@
    declarer name module_param_call;
    identifier _name, _set_func, _get_func;
    expression _arg, _mode;
    @@
    
     module_param_call(_name, _set_func, _get_func, _arg, _mode);
    
    @fix_set_prototype
     depends on match_module_param_call_function@
    identifier match_module_param_call_function._set_func;
    identifier _val, _param;
    type _val_type, _param_type;
    @@
    
     int _set_func(
    -_val_type _val
    +const char * _val
     ,
    -_param_type _param
    +const struct kernel_param * _param
     ) { ... }
    
    @fix_get_prototype
     depends on match_module_param_call_function@
    identifier match_module_param_call_function._get_func;
    identifier _val, _param;
    type _val_type, _param_type;
    @@
    
     int _get_func(
    -_val_type _val
    +char * _val
     ,
    -_param_type _param
    +const struct kernel_param * _param
     ) { ... }
    
    Two additional by-hand changes are included for places where the above
    Coccinelle script didn't notice them:
    
            drivers/platform/x86/thinkpad_acpi.c
            fs/lockd/svc.c
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 78a5a23010ab..cf2c1b2b2d64 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -229,7 +229,8 @@ module_param_cb(trace_method_name, &param_ops_trace_method, &trace_method_name,
 module_param_cb(trace_debug_layer, &param_ops_trace_attrib, &acpi_gbl_trace_dbg_layer, 0644);
 module_param_cb(trace_debug_level, &param_ops_trace_attrib, &acpi_gbl_trace_dbg_level, 0644);
 
-static int param_set_trace_state(const char *val, struct kernel_param *kp)
+static int param_set_trace_state(const char *val,
+				 const struct kernel_param *kp)
 {
 	acpi_status status;
 	const char *method = trace_method_name;
@@ -265,7 +266,7 @@ static int param_set_trace_state(const char *val, struct kernel_param *kp)
 	return 0;
 }
 
-static int param_get_trace_state(char *buffer, struct kernel_param *kp)
+static int param_get_trace_state(char *buffer, const struct kernel_param *kp)
 {
 	if (!(acpi_gbl_trace_flags & ACPI_TRACE_ENABLED))
 		return sprintf(buffer, "disable");
@@ -294,7 +295,8 @@ MODULE_PARM_DESC(aml_debug_output,
 		 "To enable/disable the ACPI Debug Object output.");
 
 /* /sys/module/acpi/parameters/acpica_version */
-static int param_get_acpica_version(char *buffer, struct kernel_param *kp)
+static int param_get_acpica_version(char *buffer,
+				    const struct kernel_param *kp)
 {
 	int result;
 

commit 298bd7fb26cb2797a8b19b66a68389b3f27ae7e2
Merge: 940c8df63a53 7dae6326ed76 e931d0dab439 5e9323219410
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Sep 3 23:55:34 2017 +0200

    Merge branches 'acpi-sysfs', 'acpi-apei' and 'acpi-blacklist'
    
    * acpi-sysfs:
      ACPI / sysfs: Extend ACPI sysfs to provide access to boot error region
    
    * acpi-apei:
      ACPI / APEI: Suppress message if HEST not present
      ACPI, APEI, EINJ: Subtract any matching Register Region from Trigger resources
      ACPI: APEI: fix the wrong iteration of generic error status block
      ACPI: APEI: Enable APEI multiple GHES source to share a single external IRQ
    
    * acpi-blacklist:
      intel_pstate: convert to use acpi_match_platform_list()
      ACPI / blacklist: add acpi_match_platform_list()

commit 7dae6326ed76431653793df0388b3a404de1217e
Author: Tony Luck <tony.luck@intel.com>
Date:   Fri Aug 18 16:19:00 2017 -0700

    ACPI / sysfs: Extend ACPI sysfs to provide access to boot error region
    
    The ACPI sysfs interface provides a way to read each ACPI table from
    userspace via entries in /sys/firmware/acpi/tables/
    
    The BERT table simply provides the size and address of the error
    record in BIOS reserved memory and users may want access to this
    record.
    
    In an earlier age we might have used /dev/mem to retrieve this error
    record, but many systems disable /dev/mem for security reasons.
    
    Extend this driver to provide read-only access to the data via a
    file in a new directory /sys/firmware/acpi/tables/data/BERT
    
    Acked-by: Punit Agrawal <punit.agrawal@arm.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    
    v4: fix typo reported by Punit
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index e414fabf7315..faa1aa3ed0e1 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -306,11 +306,13 @@ module_param_call(acpica_version, NULL, param_get_acpica_version, NULL, 0444);
 /*
  * ACPI table sysfs I/F:
  * /sys/firmware/acpi/tables/
+ * /sys/firmware/acpi/tables/data/
  * /sys/firmware/acpi/tables/dynamic/
  */
 
 static LIST_HEAD(acpi_table_attr_list);
 static struct kobject *tables_kobj;
+static struct kobject *tables_data_kobj;
 static struct kobject *dynamic_tables_kobj;
 static struct kobject *hotplug_kobj;
 
@@ -325,6 +327,11 @@ struct acpi_table_attr {
 	struct list_head node;
 };
 
+struct acpi_data_attr {
+	struct bin_attribute attr;
+	u64	addr;
+};
+
 static ssize_t acpi_table_show(struct file *filp, struct kobject *kobj,
 			       struct bin_attribute *bin_attr, char *buf,
 			       loff_t offset, size_t count)
@@ -420,6 +427,70 @@ acpi_status acpi_sysfs_table_handler(u32 event, void *table, void *context)
 	return AE_OK;
 }
 
+static ssize_t acpi_data_show(struct file *filp, struct kobject *kobj,
+			      struct bin_attribute *bin_attr, char *buf,
+			      loff_t offset, size_t count)
+{
+	struct acpi_data_attr *data_attr;
+	void __iomem *base;
+	ssize_t rc;
+
+	data_attr = container_of(bin_attr, struct acpi_data_attr, attr);
+
+	base = acpi_os_map_memory(data_attr->addr, data_attr->attr.size);
+	if (!base)
+		return -ENOMEM;
+	rc = memory_read_from_buffer(buf, count, &offset, base,
+				     data_attr->attr.size);
+	acpi_os_unmap_memory(base, data_attr->attr.size);
+
+	return rc;
+}
+
+static int acpi_bert_data_init(void *th, struct acpi_data_attr *data_attr)
+{
+	struct acpi_table_bert *bert = th;
+
+	if (bert->header.length < sizeof(struct acpi_table_bert) ||
+	    bert->region_length < sizeof(struct acpi_hest_generic_status)) {
+		kfree(data_attr);
+		return -EINVAL;
+	}
+	data_attr->addr = bert->address;
+	data_attr->attr.size = bert->region_length;
+	data_attr->attr.attr.name = "BERT";
+
+	return sysfs_create_bin_file(tables_data_kobj, &data_attr->attr);
+}
+
+static struct acpi_data_obj {
+	char *name;
+	int (*fn)(void *, struct acpi_data_attr *);
+} acpi_data_objs[] = {
+	{ ACPI_SIG_BERT, acpi_bert_data_init },
+};
+
+#define NUM_ACPI_DATA_OBJS ARRAY_SIZE(acpi_data_objs)
+
+static int acpi_table_data_init(struct acpi_table_header *th)
+{
+	struct acpi_data_attr *data_attr;
+	int i;
+
+	for (i = 0; i < NUM_ACPI_DATA_OBJS; i++) {
+		if (ACPI_COMPARE_NAME(th->signature, acpi_data_objs[i].name)) {
+			data_attr = kzalloc(sizeof(*data_attr), GFP_KERNEL);
+			if (!data_attr)
+				return -ENOMEM;
+			sysfs_attr_init(&data_attr->attr.attr);
+			data_attr->attr.read = acpi_data_show;
+			data_attr->attr.attr.mode = 0400;
+			return acpi_data_objs[i].fn(th, data_attr);
+		}
+	}
+	return 0;
+}
+
 static int acpi_tables_sysfs_init(void)
 {
 	struct acpi_table_attr *table_attr;
@@ -432,6 +503,10 @@ static int acpi_tables_sysfs_init(void)
 	if (!tables_kobj)
 		goto err;
 
+	tables_data_kobj = kobject_create_and_add("data", tables_kobj);
+	if (!tables_data_kobj)
+		goto err_tables_data;
+
 	dynamic_tables_kobj = kobject_create_and_add("dynamic", tables_kobj);
 	if (!dynamic_tables_kobj)
 		goto err_dynamic_tables;
@@ -456,13 +531,17 @@ static int acpi_tables_sysfs_init(void)
 			return ret;
 		}
 		list_add_tail(&table_attr->node, &acpi_table_attr_list);
+		acpi_table_data_init(table_header);
 	}
 
 	kobject_uevent(tables_kobj, KOBJ_ADD);
+	kobject_uevent(tables_data_kobj, KOBJ_ADD);
 	kobject_uevent(dynamic_tables_kobj, KOBJ_ADD);
 
 	return 0;
 err_dynamic_tables:
+	kobject_put(tables_data_kobj);
+err_tables_data:
 	kobject_put(tables_kobj);
 err:
 	return -ENOMEM;

commit 7db8d1d904e4b64d0d8e2bce75b59f59d445e1e2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Aug 11 01:31:54 2017 +0200

    ACPI: Add debug statements to acpi_global_event_handler()
    
    It sometimes is useful to examine the timing of ACPI events during
    certain operations only, like during system suspend/resume, so add
    pr_debug() statements for that to acpi_global_event_handler().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index e414fabf7315..32d7e43b64c4 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -2,6 +2,8 @@
  * sysfs.c - ACPI sysfs interface to userspace.
  */
 
+#define pr_fmt(fmt) "ACPI: " fmt
+
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/moduleparam.h>
@@ -552,11 +554,15 @@ static void fixed_event_count(u32 event_number)
 static void acpi_global_event_handler(u32 event_type, acpi_handle device,
 	u32 event_number, void *context)
 {
-	if (event_type == ACPI_EVENT_TYPE_GPE)
+	if (event_type == ACPI_EVENT_TYPE_GPE) {
 		gpe_count(event_number);
-
-	if (event_type == ACPI_EVENT_TYPE_FIXED)
+		pr_debug("GPE event 0x%02x\n", event_number);
+	} else if (event_type == ACPI_EVENT_TYPE_FIXED) {
 		fixed_event_count(event_number);
+		pr_debug("Fixed event 0x%02x\n", event_number);
+	} else {
+		pr_debug("Other event 0x%02x\n", event_number);
+	}
 }
 
 static int get_status(u32 index, acpi_event_status *status,

commit 60319130254084b337e02439d3b4ec301b6328bb
Merge: 5ed02dbb4974 878d8db039da 2ea65321b835 0de0e198bc71
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 3 00:03:29 2017 +0200

    Merge branches 'acpi-button', 'acpica' and 'acpi-sysfs'
    
    * acpi-button:
      Revert "ACPI / button: Change default behavior to lid_init_state=open"
    
    * acpica:
      ACPICA: Tables: Fix regression introduced by a too early mechanism enabling
    
    * acpi-sysfs:
      ACPI / sysfs: fix acpi_get_table() leak / acpi-sysfs denial of service

commit 0de0e198bc7191a0e46cf71f66fec4d07ca91396
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Apr 25 12:58:31 2017 -0700

    ACPI / sysfs: fix acpi_get_table() leak / acpi-sysfs denial of service
    
    Reading an ACPI table through the /sys/firmware/acpi/tables interface
    more than 65,536 times leads to the following log message:
    
     ACPI Error: Table ffff88033595eaa8, Validation count is zero after increment
      (20170119/tbutils-423)
    
    ...and the table being unavailable until the next reboot. Add the
    missing acpi_put_table() so the table ->validation_count is decremented
    after each read.
    
    Reported-by: Anush Seetharaman <anush.seetharaman@intel.com>
    Fixes: 174cc7187e6f "ACPICA: Tables: Back port acpi_get_table_with_size() ..."
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Cc: 4.10+ <stable@vger.kernel.org> # 4.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index cf05ae973381..5180fef9eb49 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -333,14 +333,17 @@ static ssize_t acpi_table_show(struct file *filp, struct kobject *kobj,
 	    container_of(bin_attr, struct acpi_table_attr, attr);
 	struct acpi_table_header *table_header = NULL;
 	acpi_status status;
+	ssize_t rc;
 
 	status = acpi_get_table(table_attr->name, table_attr->instance,
 				&table_header);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
-	return memory_read_from_buffer(buf, count, &offset,
-				       table_header, table_header->length);
+	rc = memory_read_from_buffer(buf, count, &offset, table_header,
+			table_header->length);
+	acpi_put_table(table_header);
+	return rc;
 }
 
 static int acpi_table_attr_init(struct kobject *tables_obj,

commit ffc10d82ff5df7087a9b737de55a69ac4f89bf56
Author: Michal Hocko <mhocko@suse.com>
Date:   Mon Apr 3 09:40:23 2017 +0200

    ACPI / scan: Drop support for force_remove
    
    /sys/firmware/acpi/hotplug/force_remove was presumably added to support
    auto offlining in the past. This is, however, inherently dangerous for
    some hotplugable resources like memory. The memory offlining fails when
    the memory is still in use and cannot be dropped or migrated. If we
    ignore the failure we are basically allowing for subtle memory
    corruption or a crash.
    
    We have actually noticed the later while hitting BUG() during the memory
    hotremove (remove_memory):
            ret = walk_memory_range(PFN_DOWN(start), PFN_UP(start + size - 1), NULL,
                            check_memblock_offlined_cb);
            if (ret)
                    BUG();
    
    it took us quite non-trivial time realize that the customer had
    force_remove enabled. Even if the BUG was removed here and we could
    propagate the error up the call chain it wouldn't help at all because
    then we would hit a crash or a memory corruption later and harder to
    debug. So force_remove is unfixable for the memory hotremove. We haven't
    checked other hotplugable resources to be prone to a similar problems.
    
    Remove the force_remove functionality because it is not fixable currently.
    Keep the sysfs file and report an error if somebody tries to enable it.
    Encourage users to report about the missing functionality and work with
    them with an alternative solution.
    
    Reviewed-by: Lee, Chun-Yi <jlee@suse.com>
    Signed-off-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index cf05ae973381..1b5ee1e0e5a3 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -921,7 +921,7 @@ void acpi_sysfs_add_hotplug_profile(struct acpi_hotplug_profile *hotplug,
 static ssize_t force_remove_show(struct kobject *kobj,
 				 struct kobj_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%d\n", !!acpi_force_hot_remove);
+	return sprintf(buf, "%d\n", 0);
 }
 
 static ssize_t force_remove_store(struct kobject *kobj,
@@ -935,9 +935,10 @@ static ssize_t force_remove_store(struct kobject *kobj,
 	if (ret < 0)
 		return ret;
 
-	lock_device_hotplug();
-	acpi_force_hot_remove = val;
-	unlock_device_hotplug();
+	if (val) {
+		pr_err("Enabling force_remove is not supported anymore. Please report to linux-acpi@vger.kernel.org if you depend on this functionality\n");
+		return -EINVAL;
+	}
 	return size;
 }
 

commit 9c4aa1eecb48cfac18ed5e3aca9d9ae58fbafc11
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Dec 16 12:07:57 2016 +0800

    ACPI / sysfs: Provide quirk mechanism to prevent GPE flooding
    
    Sometimes, the users may require a quirk to be provided from ACPI subsystem
    core to prevent a GPE from flooding.
    Normally, if a GPE cannot be dispatched, ACPICA core automatically prevents
    the GPE from firing. But there are cases the GPE is dispatched by _Lxx/_Exx
    provided via AML table, and OSPM is lacking of the knowledge to get
    _Lxx/_Exx correctly executed to handle the GPE, thus the GPE flooding may
    still occur.
    
    The existing quirk mechanism can be enabled/disabled using the following
    commands to prevent such kind of GPE flooding during runtime:
     # echo mask > /sys/firmware/acpi/interrupts/gpe00
     # echo unmask > /sys/firmware/acpi/interrupts/gpe00
    To avoid GPE flooding during boot, we need a boot stage mechanism.
    
    This patch provides such a boot stage quirk mechanism to stop this kind of
    GPE flooding. This patch doesn't fix any feature gap but since the new
    feature gaps could be found in the future endlessly, and can disappear if
    the feature gaps are filled, providing a boot parameter rather than a DMI
    table should suffice.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=53071
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=117481
    Link: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/887793
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 703c26e7022c..cf05ae973381 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -708,6 +708,62 @@ static ssize_t counter_set(struct kobject *kobj,
 	return result ? result : size;
 }
 
+/*
+ * A Quirk Mechanism for GPE Flooding Prevention:
+ *
+ * Quirks may be needed to prevent GPE flooding on a specific GPE. The
+ * flooding typically cannot be detected and automatically prevented by
+ * ACPI_GPE_DISPATCH_NONE check because there is a _Lxx/_Exx prepared in
+ * the AML tables. This normally indicates a feature gap in Linux, thus
+ * instead of providing endless quirk tables, we provide a boot parameter
+ * for those who want this quirk. For example, if the users want to prevent
+ * the GPE flooding for GPE 00, they need to specify the following boot
+ * parameter:
+ *   acpi_mask_gpe=0x00
+ * The masking status can be modified by the following runtime controlling
+ * interface:
+ *   echo unmask > /sys/firmware/acpi/interrupts/gpe00
+ */
+
+/*
+ * Currently, the GPE flooding prevention only supports to mask the GPEs
+ * numbered from 00 to 7f.
+ */
+#define ACPI_MASKABLE_GPE_MAX	0x80
+
+static u64 __initdata acpi_masked_gpes;
+
+static int __init acpi_gpe_set_masked_gpes(char *val)
+{
+	u8 gpe;
+
+	if (kstrtou8(val, 0, &gpe) || gpe > ACPI_MASKABLE_GPE_MAX)
+		return -EINVAL;
+	acpi_masked_gpes |= ((u64)1<<gpe);
+
+	return 1;
+}
+__setup("acpi_mask_gpe=", acpi_gpe_set_masked_gpes);
+
+void __init acpi_gpe_apply_masked_gpes(void)
+{
+	acpi_handle handle;
+	acpi_status status;
+	u8 gpe;
+
+	for (gpe = 0;
+	     gpe < min_t(u8, ACPI_MASKABLE_GPE_MAX, acpi_current_gpe_count);
+	     gpe++) {
+		if (acpi_masked_gpes & ((u64)1<<gpe)) {
+			status = acpi_get_gpe_device(gpe, &handle);
+			if (ACPI_SUCCESS(status)) {
+				pr_info("Masking GPE 0x%x.\n", gpe);
+				(void)acpi_mask_gpe(handle, gpe, TRUE);
+			}
+		}
+	}
+}
+
 void acpi_irq_stats_init(void)
 {
 	acpi_status status;

commit 914c619409ea509f335add941ad515fb590ee6c5
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Sep 13 17:48:34 2016 +0800

    ACPI / sysfs: Update sysfs signature handling code
    
    This patch cleans up sysfs table signature handling code:
    
     1. Convert the signature handling code to use the ACPICA APIs to
        benefit from the future improvements of the APIs.
    
     2. Add 'filename' attribute in order to handle both BE/LE name tags.
    
     3. Add instance check in order to avoid the possible buffer overflow
        related to the table file name.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index c88d4bdf2165..703c26e7022c 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -314,10 +314,14 @@ static struct kobject *tables_kobj;
 static struct kobject *dynamic_tables_kobj;
 static struct kobject *hotplug_kobj;
 
+#define ACPI_MAX_TABLE_INSTANCES	999
+#define ACPI_INST_SIZE			4 /* including trailing 0 */
+
 struct acpi_table_attr {
 	struct bin_attribute attr;
-	char name[8];
+	char name[ACPI_NAME_SIZE];
 	int instance;
+	char filename[ACPI_NAME_SIZE+ACPI_INST_SIZE];
 	struct list_head node;
 };
 
@@ -329,14 +333,9 @@ static ssize_t acpi_table_show(struct file *filp, struct kobject *kobj,
 	    container_of(bin_attr, struct acpi_table_attr, attr);
 	struct acpi_table_header *table_header = NULL;
 	acpi_status status;
-	char name[ACPI_NAME_SIZE];
 
-	if (strncmp(table_attr->name, "NULL", 4))
-		memcpy(name, table_attr->name, ACPI_NAME_SIZE);
-	else
-		memcpy(name, "\0\0\0\0", 4);
-
-	status = acpi_get_table(name, table_attr->instance, &table_header);
+	status = acpi_get_table(table_attr->name, table_attr->instance,
+				&table_header);
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
@@ -344,38 +343,45 @@ static ssize_t acpi_table_show(struct file *filp, struct kobject *kobj,
 				       table_header, table_header->length);
 }
 
-static void acpi_table_attr_init(struct acpi_table_attr *table_attr,
-				 struct acpi_table_header *table_header)
+static int acpi_table_attr_init(struct kobject *tables_obj,
+				struct acpi_table_attr *table_attr,
+				struct acpi_table_header *table_header)
 {
 	struct acpi_table_header *header = NULL;
 	struct acpi_table_attr *attr = NULL;
+	char instance_str[ACPI_INST_SIZE];
 
 	sysfs_attr_init(&table_attr->attr.attr);
-	if (table_header->signature[0] != '\0')
-		memcpy(table_attr->name, table_header->signature,
-		       ACPI_NAME_SIZE);
-	else
-		memcpy(table_attr->name, "NULL", 4);
+	ACPI_MOVE_NAME(table_attr->name, table_header->signature);
 
 	list_for_each_entry(attr, &acpi_table_attr_list, node) {
-		if (!memcmp(table_attr->name, attr->name, ACPI_NAME_SIZE))
+		if (ACPI_COMPARE_NAME(table_attr->name, attr->name))
 			if (table_attr->instance < attr->instance)
 				table_attr->instance = attr->instance;
 	}
 	table_attr->instance++;
+	if (table_attr->instance > ACPI_MAX_TABLE_INSTANCES) {
+		pr_warn("%4.4s: too many table instances\n",
+			table_attr->name);
+		return -ERANGE;
+	}
 
+	ACPI_MOVE_NAME(table_attr->filename, table_header->signature);
+	table_attr->filename[ACPI_NAME_SIZE] = '\0';
 	if (table_attr->instance > 1 || (table_attr->instance == 1 &&
 					 !acpi_get_table
-					 (table_header->signature, 2, &header)))
-		sprintf(table_attr->name + ACPI_NAME_SIZE, "%d",
-			table_attr->instance);
+					 (table_header->signature, 2, &header))) {
+		snprintf(instance_str, sizeof(instance_str), "%u",
+			 table_attr->instance);
+		strcat(table_attr->filename, instance_str);
+	}
 
 	table_attr->attr.size = table_header->length;
 	table_attr->attr.read = acpi_table_show;
-	table_attr->attr.attr.name = table_attr->name;
+	table_attr->attr.attr.name = table_attr->filename;
 	table_attr->attr.attr.mode = 0400;
 
-	return;
+	return sysfs_create_bin_file(tables_obj, &table_attr->attr);
 }
 
 acpi_status acpi_sysfs_table_handler(u32 event, void *table, void *context)
@@ -389,13 +395,12 @@ acpi_status acpi_sysfs_table_handler(u32 event, void *table, void *context)
 		if (!table_attr)
 			return AE_NO_MEMORY;
 
-		acpi_table_attr_init(table_attr, table);
-		if (sysfs_create_bin_file(dynamic_tables_kobj,
-					  &table_attr->attr)) {
+		if (acpi_table_attr_init(dynamic_tables_kobj,
+					 table_attr, table)) {
 			kfree(table_attr);
 			return AE_ERROR;
-		} else
-			list_add_tail(&table_attr->node, &acpi_table_attr_list);
+		}
+		list_add_tail(&table_attr->node, &acpi_table_attr_list);
 		break;
 	case ACPI_TABLE_EVENT_LOAD:
 	case ACPI_TABLE_EVENT_UNLOAD:
@@ -437,13 +442,12 @@ static int acpi_tables_sysfs_init(void)
 		if (ACPI_FAILURE(status))
 			continue;
 
-		table_attr = NULL;
 		table_attr = kzalloc(sizeof(*table_attr), GFP_KERNEL);
 		if (!table_attr)
 			return -ENOMEM;
 
-		acpi_table_attr_init(table_attr, table_header);
-		ret = sysfs_create_bin_file(tables_kobj, &table_attr->attr);
+		ret = acpi_table_attr_init(tables_kobj,
+					   table_attr, table_header);
 		if (ret) {
 			kfree(table_attr);
 			return ret;

commit 307ecb0aa3a24528efd1cfcea8215b2d82df6e10
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Sep 13 17:48:27 2016 +0800

    ACPI / sysfs: Fix an issue for LoadTable opcode
    
    OEM tables can be installed via RSDT/XSDT, in this case, they have already
    been created under /sys/firmware/acpi/tables.
    
    For this kind of tables, normally LoadTable opcode will be executed to load
    them. If LoadTable opcode is executed after acpi_sysfs_init(),
    acpi_sysfs_table_handler() will be invoked, thus a redundant table file
    will be created under /sys/firmware/acpi/tables/dynamic. Then running
    "acpidump" on such platform results in an error, complaining blank empty
    table (see Link 1 below).
    
    The bug can be reproduced by customizing an OEM1 table, allowing it to be
    overridden via 'table_sigs' (drivers/acpi/tables.c), adding the following
    code to the customized DSDT to load it:
    
      Name (OEMH, Zero)
      Name (OEMF, One)
      If (LEqual (OEMF, One)) {
          Store (LoadTable ("OEM1", "Intel", "Test"), OEMH)
          Store (Zero, OEMF)
      }
    
    In order to make sure that the OEM1 table is installed after
    acpi_sysfs_init(), acpi_sysfs_init() can be moved before invoking
    acpi_load_tables(). Then the following command execution result can be
    seen:
     # acpidump > acpidump.txt
     Could not read table header: /sysfs/firmware/acpi/tables/dynamic/OEM12
     Could not get ACPI table at index 17, AE_BAD_HEADER
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=150841 # [1]
    Link: https://github.com/acpica/acpica/commit/ed6a5fbc
    Reported-by: Jason Voelz <jason.voelz@intel.com>
    Reported-by: Francisco Leoner <francisco.j.lenoer.soto@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 703c993888b2..c88d4bdf2165 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -383,7 +383,7 @@ acpi_status acpi_sysfs_table_handler(u32 event, void *table, void *context)
 	struct acpi_table_attr *table_attr;
 
 	switch (event) {
-	case ACPI_TABLE_EVENT_LOAD:
+	case ACPI_TABLE_EVENT_INSTALL:
 		table_attr =
 		    kzalloc(sizeof(struct acpi_table_attr), GFP_KERNEL);
 		if (!table_attr)
@@ -397,7 +397,9 @@ acpi_status acpi_sysfs_table_handler(u32 event, void *table, void *context)
 		} else
 			list_add_tail(&table_attr->node, &acpi_table_attr_list);
 		break;
+	case ACPI_TABLE_EVENT_LOAD:
 	case ACPI_TABLE_EVENT_UNLOAD:
+	case ACPI_TABLE_EVENT_UNINSTALL:
 		/*
 		 * we do not need to do anything right now
 		 * because the table is not deleted from the

commit 18864cc4892d207bf8bb81898f5dc7fe9e66d6f0
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Aug 4 16:43:45 2016 +0800

    ACPI / sysfs: Use new GPE masking mechanism in GPE interface
    
    Now GPE can be masked via the new acpi_mask_gpe() API and this patch
    modifies /sys/firmware/acpi/interrupts/gpexx to use this new facility.
    
    Writes "mask/unmask" to this file now invokes acpi_mask_gpe().
    
    Reads from this file now returns new "EN/STS" when the corresponding GPE
    hardware register's EN/STS bits are flagged, and new "masked/unmasked"
    attribute to indicate the status of the masking mechanism.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    [ rjw: Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 358165e9f5b8..703c993888b2 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -597,14 +597,27 @@ static ssize_t counter_show(struct kobject *kobj,
 	if (result)
 		goto end;
 
+	if (status & ACPI_EVENT_FLAG_ENABLE_SET)
+		size += sprintf(buf + size, "  EN");
+	else
+		size += sprintf(buf + size, "    ");
+	if (status & ACPI_EVENT_FLAG_STATUS_SET)
+		size += sprintf(buf + size, " STS");
+	else
+		size += sprintf(buf + size, "    ");
+
 	if (!(status & ACPI_EVENT_FLAG_HAS_HANDLER))
-		size += sprintf(buf + size, "   invalid");
+		size += sprintf(buf + size, " invalid     ");
 	else if (status & ACPI_EVENT_FLAG_ENABLED)
-		size += sprintf(buf + size, "   enabled");
+		size += sprintf(buf + size, " enabled     ");
 	else if (status & ACPI_EVENT_FLAG_WAKE_ENABLED)
-		size += sprintf(buf + size, "   wake_enabled");
+		size += sprintf(buf + size, " wake_enabled");
 	else
-		size += sprintf(buf + size, "   disabled");
+		size += sprintf(buf + size, " disabled    ");
+	if (status & ACPI_EVENT_FLAG_MASKED)
+		size += sprintf(buf + size, " masked  ");
+	else
+		size += sprintf(buf + size, " unmasked");
 
 end:
 	size += sprintf(buf + size, "\n");
@@ -655,8 +668,12 @@ static ssize_t counter_set(struct kobject *kobj,
 			 !(status & ACPI_EVENT_FLAG_ENABLED))
 			result = acpi_enable_gpe(handle, index);
 		else if (!strcmp(buf, "clear\n") &&
-			 (status & ACPI_EVENT_FLAG_SET))
+			 (status & ACPI_EVENT_FLAG_STATUS_SET))
 			result = acpi_clear_gpe(handle, index);
+		else if (!strcmp(buf, "mask\n"))
+			result = acpi_mask_gpe(handle, index, TRUE);
+		else if (!strcmp(buf, "unmask\n"))
+			result = acpi_mask_gpe(handle, index, FALSE);
 		else if (!kstrtoul(buf, 0, &tmp))
 			all_counters[index].count = tmp;
 		else
@@ -664,13 +681,13 @@ static ssize_t counter_set(struct kobject *kobj,
 	} else if (index < num_gpes + ACPI_NUM_FIXED_EVENTS) {
 		int event = index - num_gpes;
 		if (!strcmp(buf, "disable\n") &&
-		    (status & ACPI_EVENT_FLAG_ENABLED))
+		    (status & ACPI_EVENT_FLAG_ENABLE_SET))
 			result = acpi_disable_event(event, ACPI_NOT_ISR);
 		else if (!strcmp(buf, "enable\n") &&
-			 !(status & ACPI_EVENT_FLAG_ENABLED))
+			 !(status & ACPI_EVENT_FLAG_ENABLE_SET))
 			result = acpi_enable_event(event, ACPI_NOT_ISR);
 		else if (!strcmp(buf, "clear\n") &&
-			 (status & ACPI_EVENT_FLAG_SET))
+			 (status & ACPI_EVENT_FLAG_STATUS_SET))
 			result = acpi_clear_event(event);
 		else if (!kstrtoul(buf, 0, &tmp))
 			all_counters[index].count = tmp;

commit 68bdb6773289f8c9a36633f9f6525b127c093258
Author: Octavian Purdila <octavian.purdila@intel.com>
Date:   Fri Jul 8 19:13:09 2016 +0300

    ACPI: add support for ACPI reconfiguration notifiers
    
    Add support for ACPI reconfiguration notifiers to allow subsystems
    to react to changes in the ACPI tables that happen after the initial
    enumeration. This is similar with the way dynamic device tree
    notifications work.
    
    The reconfigure notifications supported for now are device add and
    device remove.
    
    Since ACPICA allows only one table notification handler, this patch
    makes the table notifier function generic and moves it out of the
    sysfs specific code.
    
    Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 4b3a9e27f1b6..358165e9f5b8 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -378,8 +378,7 @@ static void acpi_table_attr_init(struct acpi_table_attr *table_attr,
 	return;
 }
 
-static acpi_status
-acpi_sysfs_table_handler(u32 event, void *table, void *context)
+acpi_status acpi_sysfs_table_handler(u32 event, void *table, void *context)
 {
 	struct acpi_table_attr *table_attr;
 
@@ -452,9 +451,8 @@ static int acpi_tables_sysfs_init(void)
 
 	kobject_uevent(tables_kobj, KOBJ_ADD);
 	kobject_uevent(dynamic_tables_kobj, KOBJ_ADD);
-	status = acpi_install_table_handler(acpi_sysfs_table_handler, NULL);
 
-	return ACPI_FAILURE(status) ? -EINVAL : 0;
+	return 0;
 err_dynamic_tables:
 	kobject_put(tables_kobj);
 err:

commit f18ebc211e259d4f591e39e74b2aa2de226c9a1d
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu May 5 16:23:04 2016 +0300

    ACPI / sysfs: fix error code in get_status()
    
    The problem with ornamental, do-nothing gotos is that they lead to
    "forgot to set the error code" bugs.  We should be returning -EINVAL
    here but we don't.  It leads to an uninitalized variable in
    counter_show():
    
        drivers/acpi/sysfs.c:603 counter_show()
        error: uninitialized symbol 'status'.
    
    Fixes: 1c8fce27e275 (ACPI: introduce drivers/acpi/sysfs.c)
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 0243d375c6fd..4b3a9e27f1b6 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -555,23 +555,22 @@ static void acpi_global_event_handler(u32 event_type, acpi_handle device,
 static int get_status(u32 index, acpi_event_status *status,
 		      acpi_handle *handle)
 {
-	int result = 0;
+	int result;
 
 	if (index >= num_gpes + ACPI_NUM_FIXED_EVENTS)
-		goto end;
+		return -EINVAL;
 
 	if (index < num_gpes) {
 		result = acpi_get_gpe_device(index, handle);
 		if (result) {
 			ACPI_EXCEPTION((AE_INFO, AE_NOT_FOUND,
 					"Invalid GPE 0x%x", index));
-			goto end;
+			return result;
 		}
 		result = acpi_get_gpe_status(*handle, index, status);
 	} else if (index < (num_gpes + ACPI_NUM_FIXED_EVENTS))
 		result = acpi_get_event_status(index - num_gpes, status);
 
-end:
 	return result;
 }
 

commit bc1e49df345cf9be38ba29ead45a12f86ceb5fe2
Author: Insu Yun <wuninsu@gmail.com>
Date:   Thu Oct 15 12:19:30 2015 -0400

    ACPI / sysfs: correctly check failing memory allocation
    
    Since kobject_create_and_add() can fail under memory pressure,
    its return value needs to be checked against NULL before passing
    it to sysfs_create_file().
    
    Signed-off-by: Insu Yun <wuninsu@gmail.com>
    [ rjw: Subject & changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 40a42655227c..0243d375c6fd 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -878,6 +878,9 @@ int __init acpi_sysfs_init(void)
 		return result;
 
 	hotplug_kobj = kobject_create_and_add("hotplug", acpi_kobj);
+	if (!hotplug_kobj)
+		return -ENOMEM;
+
 	result = sysfs_create_file(hotplug_kobj, &force_remove_attr.attr);
 	if (result)
 		return result;

commit a0186bcf7c21907c78ab2b4bc50f3fb2b5047806
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Aug 5 16:23:57 2015 +0800

    ACPI / sysfs: Add support to allow leading "\" missing in trace_method_name.
    
    Since _SB.PCI0 can be used as relative path from root and can be easily
    converted into internal trace_method_name format, we allow users to specify
    trace_method_name using relative paths from root.
    Note this is useful for grub2 for which users failed to pass "\" from the
    grub configuration file.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 8979e4a8d066..40a42655227c 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -164,14 +164,18 @@ static const struct kernel_param_ops param_ops_debug_level = {
 module_param_cb(debug_layer, &param_ops_debug_layer, &acpi_dbg_layer, 0644);
 module_param_cb(debug_level, &param_ops_debug_level, &acpi_dbg_level, 0644);
 
-static char* trace_method_name;
-static bool trace_method_kmalloced;
+static char trace_method_name[1024];
 
 int param_set_trace_method_name(const char *val, const struct kernel_param *kp)
 {
 	u32 saved_flags = 0;
+	bool is_abs_path = true;
 
-	if (strlen(val) > 1024) {
+	if (*val != '\\')
+		is_abs_path = false;
+
+	if ((is_abs_path && strlen(val) > 1023) ||
+	    (!is_abs_path && strlen(val) > 1022)) {
 		pr_err("%s: string parameter too long\n", kp->name);
 		return -ENOSPC;
 	}
@@ -187,19 +191,13 @@ int param_set_trace_method_name(const char *val, const struct kernel_param *kp)
 			       acpi_gbl_trace_dbg_layer,
 			       0);
 
-	if (trace_method_kmalloced)
-		kfree(trace_method_name);
-	trace_method_name = NULL;
-	trace_method_kmalloced = false;
-
 	/* This is a hack.  We can't kmalloc in early boot. */
-	if (slab_is_available()) {
-		trace_method_name = kstrdup(val, GFP_KERNEL);
-		if (!trace_method_name)
-			return -ENOMEM;
-		trace_method_kmalloced = true;
-	} else
-		trace_method_name = (char *)val;
+	if (is_abs_path)
+		strcpy(trace_method_name, val);
+	else {
+		trace_method_name[0] = '\\';
+		strcpy(trace_method_name+1, val);
+	}
 
 	/* Restore the original tracer state */
 	(void)acpi_debug_trace(trace_method_name,

commit 7901a052a981691d18f4e8f91fc27e40849b7336
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Aug 5 16:23:51 2015 +0800

    ACPI / sysfs: Update method tracing facility.
    
    This patch updates the method tracing facility as the acpi_debug_trace()
    API has been updated to allow it to trace AML interpreter execution, the
    meanings and the usages of the API parameters are changed due to the
    updates.
    
    The new API:
    1. Uses ACPI_TRACE_ENABLED flag to indicate the enabling of the tracer;
    2. Allows tracer still can be enabled when method name is not specified so
       that the AML interpreter execution can be traced without knowing the
       method name, which is useful for kernel boot tracing;
    3. Supports arbitrary full path name, it doesn't need to be a name related
       to an entrance of acpi_evaluate_object().
    
    Note that the sysfs parameters are also updated so that when reading the
    attribute files, ACPICA internal settings are returned.
    
    In order to make the sysfs parameters (acpi.trace_state) available during
    boot, this patch adds code to bypass ACPICA semaphore/mutex invocations
    when acpi mutex utilities haven't been initialized.
    
    This patch doesn't update documentation of method tracing facility, it will
    be updated by further patches.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 7ab6ba46866f..8979e4a8d066 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -70,6 +70,7 @@ static const struct acpi_dlevel acpi_debug_levels[] = {
 	ACPI_DEBUG_INIT(ACPI_LV_DEBUG_OBJECT),
 	ACPI_DEBUG_INIT(ACPI_LV_INFO),
 	ACPI_DEBUG_INIT(ACPI_LV_REPAIR),
+	ACPI_DEBUG_INIT(ACPI_LV_TRACE_POINT),
 
 	ACPI_DEBUG_INIT(ACPI_LV_INIT_NAMES),
 	ACPI_DEBUG_INIT(ACPI_LV_PARSE),
@@ -163,55 +164,118 @@ static const struct kernel_param_ops param_ops_debug_level = {
 module_param_cb(debug_layer, &param_ops_debug_layer, &acpi_dbg_layer, 0644);
 module_param_cb(debug_level, &param_ops_debug_level, &acpi_dbg_level, 0644);
 
-static char trace_method_name[6];
-module_param_string(trace_method_name, trace_method_name, 6, 0644);
-static unsigned int trace_debug_layer;
-module_param(trace_debug_layer, uint, 0644);
-static unsigned int trace_debug_level;
-module_param(trace_debug_level, uint, 0644);
+static char* trace_method_name;
+static bool trace_method_kmalloced;
 
-static int param_set_trace_state(const char *val, struct kernel_param *kp)
+int param_set_trace_method_name(const char *val, const struct kernel_param *kp)
 {
-	int result = 0;
+	u32 saved_flags = 0;
 
-	if (!strncmp(val, "enable", sizeof("enable") - 1)) {
-		result = acpi_debug_trace(trace_method_name, trace_debug_level,
-					  trace_debug_layer, 0);
-		if (result)
-			result = -EBUSY;
-		goto exit;
+	if (strlen(val) > 1024) {
+		pr_err("%s: string parameter too long\n", kp->name);
+		return -ENOSPC;
 	}
 
-	if (!strncmp(val, "disable", sizeof("disable") - 1)) {
-		int name = 0;
-		result = acpi_debug_trace((char *)&name, trace_debug_level,
-					  trace_debug_layer, 0);
-		if (result)
-			result = -EBUSY;
-		goto exit;
-	}
+	/*
+	 * It's not safe to update acpi_gbl_trace_method_name without
+	 * having the tracer stopped, so we save the original tracer
+	 * state and disable it.
+	 */
+	saved_flags = acpi_gbl_trace_flags;
+	(void)acpi_debug_trace(NULL,
+			       acpi_gbl_trace_dbg_level,
+			       acpi_gbl_trace_dbg_layer,
+			       0);
+
+	if (trace_method_kmalloced)
+		kfree(trace_method_name);
+	trace_method_name = NULL;
+	trace_method_kmalloced = false;
+
+	/* This is a hack.  We can't kmalloc in early boot. */
+	if (slab_is_available()) {
+		trace_method_name = kstrdup(val, GFP_KERNEL);
+		if (!trace_method_name)
+			return -ENOMEM;
+		trace_method_kmalloced = true;
+	} else
+		trace_method_name = (char *)val;
 
-	if (!strncmp(val, "1", 1)) {
-		result = acpi_debug_trace(trace_method_name, trace_debug_level,
-					  trace_debug_layer, 1);
-		if (result)
-			result = -EBUSY;
-		goto exit;
-	}
+	/* Restore the original tracer state */
+	(void)acpi_debug_trace(trace_method_name,
+			       acpi_gbl_trace_dbg_level,
+			       acpi_gbl_trace_dbg_layer,
+			       saved_flags);
 
-	result = -EINVAL;
-exit:
-	return result;
+	return 0;
+}
+
+static int param_get_trace_method_name(char *buffer, const struct kernel_param *kp)
+{
+	return scnprintf(buffer, PAGE_SIZE, "%s", acpi_gbl_trace_method_name);
+}
+
+static const struct kernel_param_ops param_ops_trace_method = {
+	.set = param_set_trace_method_name,
+	.get = param_get_trace_method_name,
+};
+
+static const struct kernel_param_ops param_ops_trace_attrib = {
+	.set = param_set_uint,
+	.get = param_get_uint,
+};
+
+module_param_cb(trace_method_name, &param_ops_trace_method, &trace_method_name, 0644);
+module_param_cb(trace_debug_layer, &param_ops_trace_attrib, &acpi_gbl_trace_dbg_layer, 0644);
+module_param_cb(trace_debug_level, &param_ops_trace_attrib, &acpi_gbl_trace_dbg_level, 0644);
+
+static int param_set_trace_state(const char *val, struct kernel_param *kp)
+{
+	acpi_status status;
+	const char *method = trace_method_name;
+	u32 flags = 0;
+
+/* So "xxx-once" comparison should go prior than "xxx" comparison */
+#define acpi_compare_param(val, key)	\
+	strncmp((val), (key), sizeof(key) - 1)
+
+	if (!acpi_compare_param(val, "enable")) {
+		method = NULL;
+		flags = ACPI_TRACE_ENABLED;
+	} else if (!acpi_compare_param(val, "disable"))
+		method = NULL;
+	else if (!acpi_compare_param(val, "method-once"))
+		flags = ACPI_TRACE_ENABLED | ACPI_TRACE_ONESHOT;
+	else if (!acpi_compare_param(val, "method"))
+		flags = ACPI_TRACE_ENABLED;
+	else if (!acpi_compare_param(val, "opcode-once"))
+		flags = ACPI_TRACE_ENABLED | ACPI_TRACE_ONESHOT | ACPI_TRACE_OPCODE;
+	else if (!acpi_compare_param(val, "opcode"))
+		flags = ACPI_TRACE_ENABLED | ACPI_TRACE_OPCODE;
+	else
+		return -EINVAL;
+
+	status = acpi_debug_trace(method,
+				  acpi_gbl_trace_dbg_level,
+				  acpi_gbl_trace_dbg_layer,
+				  flags);
+	if (ACPI_FAILURE(status))
+		return -EBUSY;
+
+	return 0;
 }
 
 static int param_get_trace_state(char *buffer, struct kernel_param *kp)
 {
-	if (!acpi_gbl_trace_method_name)
+	if (!(acpi_gbl_trace_flags & ACPI_TRACE_ENABLED))
 		return sprintf(buffer, "disable");
 	else {
-		if (acpi_gbl_trace_flags & 1)
-			return sprintf(buffer, "1");
-		else
+		if (acpi_gbl_trace_method_name) {
+			if (acpi_gbl_trace_flags & ACPI_TRACE_ONESHOT)
+				return sprintf(buffer, "method-once");
+			else
+				return sprintf(buffer, "method");
+		} else
 			return sprintf(buffer, "enable");
 	}
 	return 0;

commit 93d988310bb2f5ed16ba075bbc4281aa06907e72
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Aug 5 16:23:43 2015 +0800

    ACPI / sysfs: Add ACPI_LV_REPAIR debug level.
    
    This patch updates debug_level file, adding ACPI_LV_REPAIR.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 0876d77b3206..7ab6ba46866f 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -69,6 +69,7 @@ static const struct acpi_dlevel acpi_debug_levels[] = {
 	ACPI_DEBUG_INIT(ACPI_LV_INIT),
 	ACPI_DEBUG_INIT(ACPI_LV_DEBUG_OBJECT),
 	ACPI_DEBUG_INIT(ACPI_LV_INFO),
+	ACPI_DEBUG_INIT(ACPI_LV_REPAIR),
 
 	ACPI_DEBUG_INIT(ACPI_LV_INIT_NAMES),
 	ACPI_DEBUG_INIT(ACPI_LV_PARSE),

commit 7b1a13228b321ea27bd53070bcd332417069ace8
Author: Nan Li <nli@suse.com>
Date:   Wed Mar 4 18:48:35 2015 +0800

    ACPI / sysfs: Treat the count field of counter_show() as unsigned
    
    The count field is an unsigned 32bit value, and the
    counter_show() function should also treat it as a unsigned
    value.
    
    Otherwise the counter may show negative number as we found on a
    machine:
    ...
    gpe23:        0   invalid
    gpe24: -2071733   enabled
    gpe25:        0   invalid
    ...
    gpe_all: -2070980
    sci: -2070949
    
    Signed-off-by: Nan Li <nli@suse.com>
    Signed-off-by: Lee, Chun-Yi <jlee@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 13e577c80201..0876d77b3206 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -527,7 +527,7 @@ static ssize_t counter_show(struct kobject *kobj,
 	    acpi_irq_not_handled;
 	all_counters[num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_GPE].count =
 	    acpi_gpe_count;
-	size = sprintf(buf, "%8d", all_counters[index].count);
+	size = sprintf(buf, "%8u", all_counters[index].count);
 
 	/* "gpe_all" or "sci" */
 	if (index >= num_gpes + ACPI_NUM_FIXED_EVENTS)

commit 2f8572344e65296d13c1a771cacfea60916d91dc
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Oct 10 10:40:05 2014 +0800

    ACPICA: Events: Reduce source code difference for the ACPI_EVENT_FLAG_HANDLE renaming.
    
    This patch is partial linuxized result of the following ACPICA commit:
      ACPICA commit: a73b66c6aa1846d055bb6390d9c9b9902f7d804d
      Subject: Add "has handler" flag to event/gpe status interfaces.
      This change adds a new flag, ACPI_EVENT_FLAGS_HAS_HANDLER to the
      acpi_get_event_status and acpi_get_gpe_status external interfaces. It
      is set if the event/gpe currently has a handler associated with it.
    This patch contains the code to rename ACPI_EVENT_FLAG_HANDLE to
    ACPI_EVENT_FLAG_HAS_HANDLER, and the corresponding updates of its usages.
    
    Link: https://github.com/acpica/acpica/commit/a73b66c6
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 38cb9782d4b8..13e577c80201 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -537,7 +537,7 @@ static ssize_t counter_show(struct kobject *kobj,
 	if (result)
 		goto end;
 
-	if (!(status & ACPI_EVENT_FLAG_HANDLE))
+	if (!(status & ACPI_EVENT_FLAG_HAS_HANDLER))
 		size += sprintf(buf + size, "   invalid");
 	else if (status & ACPI_EVENT_FLAG_ENABLED)
 		size += sprintf(buf + size, "   enabled");
@@ -581,7 +581,7 @@ static ssize_t counter_set(struct kobject *kobj,
 	if (result)
 		goto end;
 
-	if (!(status & ACPI_EVENT_FLAG_HANDLE)) {
+	if (!(status & ACPI_EVENT_FLAG_HAS_HANDLER)) {
 		printk(KERN_WARNING PREFIX
 		       "Can not change Invalid GPE/Fixed Event status\n");
 		return -EINVAL;

commit 07070e12cf5cab46a783a4753f07bb99e557473b
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Thu Mar 13 12:47:39 2014 +0800

    ACPI: Remove duplicate definitions of PREFIX
    
    We already have a macro for PREFIX of "ACPI: " in
    drivers/acpi/internal.h, so remove the duplicate ones
    in ACPI drivers when internal.h is included.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 91a32cefb11f..38cb9782d4b8 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -12,8 +12,6 @@
 #define _COMPONENT		ACPI_SYSTEM_COMPONENT
 ACPI_MODULE_NAME("sysfs");
 
-#define PREFIX "ACPI: "
-
 #ifdef CONFIG_ACPI_DEBUG
 /*
  * ACPI debug sysfs I/F, including:

commit 82e180598b54873553fb1d285fb0c90fc54f8f23
Merge: 09da8dfa9868 f778d1218f10 a951c773bc39 49a12877d277 79c0373f3e84 481c13814a4e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 29 11:47:18 2014 +0100

    Merge branches 'acpi-processor', 'acpi-hotplug', 'acpi-init', 'acpi-pm' and 'acpica'
    
    * acpi-processor:
      ACPI / scan: reduce log level of "ACPI: \_PR_.CPU4: failed to get CPU APIC ID"
      ACPI / processor: Return specific error value when mapping lapic id
    
    * acpi-hotplug:
      ACPI / scan: Clear match_driver flag in acpi_bus_trim()
    
    * acpi-init:
      ACPI / init: Flag use of ACPI and ACPI idioms for power supplies to regulator API
    
    * acpi-pm:
      ACPI / PM: Use ACPI_COMPANION() to get ACPI companions of devices
    
    * acpica:
      ACPICA: Remove bool usage from ACPICA.

commit 481c13814a4ecc8305fb7c871067a73cafd09d07
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Jan 24 08:49:51 2014 +0800

    ACPICA: Remove bool usage from ACPICA.
    
    The use of "bool" is not safe for ACPICA code where it is originally using
    a "BOOLEAN" defined as "unsigned char".
    
    This patch removes the only "bool" usage from kernel source tree to reduce
    the source code differences between Linux and ACPICA upstream.
    
    This patch is required by future acpidump release automation.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 6dbc3ca45223..3e0b54fb075b 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -226,7 +226,7 @@ module_param_call(trace_state, param_set_trace_state, param_get_trace_state,
 /* /sys/modules/acpi/parameters/aml_debug_output */
 
 module_param_named(aml_debug_output, acpi_gbl_enable_aml_debug_object,
-		   bool, 0644);
+		   byte, 0644);
 MODULE_PARM_DESC(aml_debug_output,
 		 "To enable/disable the ACPI Debug Object output.");
 

commit 98feb7cc61c50fe0fa36eeb994d5db527ca9e103
Merge: 7e22e91102c6 f8a571b2a128
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 12 23:44:09 2014 +0100

    Merge branch 'acpi-cleanup'
    
    * acpi-cleanup: (22 commits)
      ACPI / tables: Return proper error codes from acpi_table_parse() and fix comment.
      ACPI / tables: Check if id is NULL in acpi_table_parse()
      ACPI / proc: Include appropriate header file in proc.c
      ACPI / EC: Remove unused functions and add prototype declaration in internal.h
      ACPI / dock: Include appropriate header file in dock.c
      ACPI / PCI: Include appropriate header file in pci_link.c
      ACPI / PCI: Include appropriate header file in pci_slot.c
      ACPI / EC: Mark the function acpi_ec_add_debugfs() as static in ec_sys.c
      ACPI / NVS: Include appropriate header file in nvs.c
      ACPI / OSL: Mark the function acpi_table_checksum() as static
      ACPI / processor: initialize a variable to silence compiler warning
      ACPI / processor: use ACPI_COMPANION() to get ACPI device
      ACPI: correct minor typos
      ACPI / sleep: Drop redundant acpi_disabled check
      ACPI / dock: Drop redundant acpi_disabled check
      ACPI / table: Replace '1' with specific error return values
      ACPI: remove trailing whitespace
      ACPI / IBFT: Fix incorrect <acpi/acpi.h> inclusion in iSCSI boot firmware module
      ACPI / i915: Fix incorrect <acpi/acpi.h> inclusions via <linux/acpi_io.h>
      SFI / ACPI: Fix warnings reported during builds with W=1
      ...
    
    Conflicts:
            drivers/acpi/nvs.c
            drivers/hwmon/asus_atk0110.c

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index db5293650f62..ba07d9a927ab 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -5,7 +5,7 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/moduleparam.h>
-#include <acpi/acpi_drivers.h>
+#include <linux/acpi.h>
 
 #include "internal.h"
 

commit de03beedb43fa1fd26792a4e502eeacbf5a6bade
Author: Jeremy Compostella <jeremy.compostella@intel.com>
Date:   Thu Nov 21 11:20:23 2013 +0100

    ACPI / sysfs: Fix incorrect ACPI tables walk in acpi_tables_sysfs_init()
    
    When executing on an ACPI Hardware Reduced hardware, all the ACPI
    tables are not exposed in sysfs due to the fact that FACS is
    silently ignored by the kernel in the ACPI hardware reduced mode
    and, moreover, the acpi_tables_sysfs_init() ACPI table walk
    is buggy and stops too soon.
    
    The acpi_tables_sysfs_init() function should rely on the acpi_status
    return value from acpi_get_table_by_index() to decide whether or not
    to stop the iteration (the walk should only be terminated when that
    value is AE_BAD_PARAMETER).  This way, when running in an ACPI Harware
    Reduced environment (where the FACS table is silently ignored by the
    kernel) or if some ACPI tables are not correctly memory mapped or
    have bad checksums, it will still walk through the remaining tables
    that may be correct.
    
    [rjw: Changelog]
    Signed-off-by: Jeremy Compostella <jeremy.compostella@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 45f82c751225..6dbc3ca45223 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -354,8 +354,9 @@ static int acpi_tables_sysfs_init(void)
 {
 	struct acpi_table_attr *table_attr;
 	struct acpi_table_header *table_header = NULL;
-	int table_index = 0;
-	int result;
+	int table_index;
+	acpi_status status;
+	int ret;
 
 	tables_kobj = kobject_create_and_add("tables", acpi_kobj);
 	if (!tables_kobj)
@@ -365,33 +366,34 @@ static int acpi_tables_sysfs_init(void)
 	if (!dynamic_tables_kobj)
 		goto err_dynamic_tables;
 
-	do {
-		result = acpi_get_table_by_index(table_index, &table_header);
-		if (!result) {
-			table_index++;
-			table_attr = NULL;
-			table_attr =
-			    kzalloc(sizeof(struct acpi_table_attr), GFP_KERNEL);
-			if (!table_attr)
-				return -ENOMEM;
-
-			acpi_table_attr_init(table_attr, table_header);
-			result =
-			    sysfs_create_bin_file(tables_kobj,
-						  &table_attr->attr);
-			if (result) {
-				kfree(table_attr);
-				return result;
-			} else
-				list_add_tail(&table_attr->node,
-					      &acpi_table_attr_list);
+	for (table_index = 0;; table_index++) {
+		status = acpi_get_table_by_index(table_index, &table_header);
+
+		if (status == AE_BAD_PARAMETER)
+			break;
+
+		if (ACPI_FAILURE(status))
+			continue;
+
+		table_attr = NULL;
+		table_attr = kzalloc(sizeof(*table_attr), GFP_KERNEL);
+		if (!table_attr)
+			return -ENOMEM;
+
+		acpi_table_attr_init(table_attr, table_header);
+		ret = sysfs_create_bin_file(tables_kobj, &table_attr->attr);
+		if (ret) {
+			kfree(table_attr);
+			return ret;
 		}
-	} while (!result);
+		list_add_tail(&table_attr->node, &acpi_table_attr_list);
+	}
+
 	kobject_uevent(tables_kobj, KOBJ_ADD);
 	kobject_uevent(dynamic_tables_kobj, KOBJ_ADD);
-	result = acpi_install_table_handler(acpi_sysfs_table_handler, NULL);
+	status = acpi_install_table_handler(acpi_sysfs_table_handler, NULL);
 
-	return result == AE_OK ? 0 : -EINVAL;
+	return ACPI_FAILURE(status) ? -EINVAL : 0;
 err_dynamic_tables:
 	kobject_put(tables_kobj);
 err:

commit 083ca8c4172585409170dac9955a1da8137fef49
Author: Daisuke HATAYAMA <d.hatayama@jp.fujitsu.com>
Date:   Tue Nov 19 17:54:47 2013 +0900

    ACPI / sysfs: Set file size for each exposed ACPI table
    
    Currently, each of the ACPI tables exported from
    /sys/firmware/acpi/tables is of zero size:
    
    $ LANG=C ls -ld /sys/firmware/acpi/tables/*
    -r-------- 1 root root 0 Nov 19 09:48 /sys/firmware/acpi/tables/APIC
    -r-------- 1 root root 0 Nov 19 09:48 /sys/firmware/acpi/tables/BOOT
    -r-------- 1 root root 0 Nov 19 14:25 /sys/firmware/acpi/tables/DSDT
    -r-------- 1 root root 0 Nov 19 14:25 /sys/firmware/acpi/tables/FACP
    -r-------- 1 root root 0 Nov 19 14:25 /sys/firmware/acpi/tables/FACS
    -r-------- 1 root root 0 Nov 19 14:25 /sys/firmware/acpi/tables/MCFG
    -r-------- 1 root root 0 Nov 19 14:25 /sys/firmware/acpi/tables/SRAT
    drwxr-xr-x 2 root root 0 Nov 19 09:48 /sys/firmware/acpi/tables/dynamic/
    
    due to which, user-land tools fail reading each table. For example:
    
    $ acpidump -f /sys/firmware/acpi/tables/SRAT
    Could not get input file size: /sys/firmware/acpi/tables/SRAT
    
    To deal with the issue, this patch assigns size of each ACPI table to
    the corresponding sysfs file.
    
    $ LANG=C ls -hld /sys/firmware/acpi/tables/*
    -r-------- 1 root root  94 Nov 19 16:45 /sys/firmware/acpi/tables/APIC
    -r-------- 1 root root  40 Nov 19 16:45 /sys/firmware/acpi/tables/BOOT
    -r-------- 1 root root 58K Nov 19 16:55 /sys/firmware/acpi/tables/DSDT
    -r-------- 1 root root 244 Nov 19 16:55 /sys/firmware/acpi/tables/FACP
    -r-------- 1 root root  64 Nov 19 16:55 /sys/firmware/acpi/tables/FACS
    -r-------- 1 root root  60 Nov 19 16:55 /sys/firmware/acpi/tables/MCFG
    -r-------- 1 root root 168 Nov 19 16:45 /sys/firmware/acpi/tables/SRAT
    drwxr-xr-x 2 root root   0 Nov 19 16:55 /sys/firmware/acpi/tables/dynamic/
    
    Then, user-land tools work well like:
    
    $ acpidump -f /sys/firmware/acpi/tables/SRAT
    SRAT @ 0x0000000000000000
      0000: 53 52 41 54 A8 00 00 00 02 65 56 4D 57 41 52 45  SRAT.....eVMWARE
      0010: 4D 45 4D 50 4C 55 47 20 00 00 04 06 56 4D 57 20  MEMPLUG ....VMW
      0020: 01 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00  ................
      0030: 01 28 00 00 00 00 00 00 00 00 00 00 00 00 00 00  .(..............
      0040: 00 00 0A 00 00 00 00 00 00 00 00 00 01 00 00 00  ................
      0050: 00 00 00 00 00 00 00 00 01 28 00 00 00 00 00 00  .........(......
      0060: 00 00 10 00 00 00 00 00 00 00 F0 BF 00 00 00 00  ................
      0070: 00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00  ................
      0080: 01 28 00 00 00 00 00 00 00 00 00 00 01 00 00 00  .(..............
      0090: 00 00 00 40 00 00 00 00 00 00 00 00 01 00 00 00  ...@............
      00A0: 00 00 00 00 00 00 00 00                          ........
    
    Signed-off-by: HATAYAMA Daisuke <d.hatayama@jp.fujitsu.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index db5293650f62..45f82c751225 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -309,7 +309,7 @@ static void acpi_table_attr_init(struct acpi_table_attr *table_attr,
 		sprintf(table_attr->name + ACPI_NAME_SIZE, "%d",
 			table_attr->instance);
 
-	table_attr->attr.size = 0;
+	table_attr->attr.size = table_header->length;
 	table_attr->attr.read = acpi_table_show;
 	table_attr->attr.attr.name = table_attr->name;
 	table_attr->attr.attr.mode = 0400;

commit 5171f4fa744de840c2c20f5b65bd3ee1cd85d0e8
Merge: 975bcabb0543 b042453f3892
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Oct 28 01:20:24 2013 +0100

    Merge branch 'acpi-assorted'
    
    * acpi-assorted:
      ACPI: Add Toshiba NB100 to Vista _OSI blacklist
      ACPI / osl: remove an unneeded NULL check
      ACPI / platform: add ACPI ID for a Broadcom GPS chip
      ACPI: improve acpi_extract_package() utility
      ACPI / LPSS: fix UART Auto Flow Control
      ACPI / platform: Add ACPI IDs for Intel SST audio device
      x86 / ACPI: fix incorrect placement of __initdata tag
      ACPI / thermal: convert printk(LEVEL...) to pr_<lvl>
      ACPI / sysfs: make GPE sysfs attributes only accept correct values
      ACPI / EC: Convert all printk() calls to dynamic debug function
      ACPI / button: Using input_set_capability() to mark device's event capability
      ACPI / osl: implement acpi_os_sleep() with msleep()

commit acd3e2c99464c0391885d58dbe7c99a11d4c0289
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Sep 25 14:23:20 2013 -0600

    ACPI / hotplug: Use kobject_init_and_add() instead of _init() and _add()
    
    Use kobject_init_and_add() since we have nothing special to do between
    kobject_init() and kobject_add().
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 75432819579c..bb6045c5385b 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -762,9 +762,8 @@ void acpi_sysfs_add_hotplug_profile(struct acpi_hotplug_profile *hotplug,
 	if (!hotplug_kobj)
 		goto err_out;
 
-	kobject_init(&hotplug->kobj, &acpi_hotplug_profile_ktype);
-
-	error = kobject_add(&hotplug->kobj, hotplug_kobj, "%s", name);
+	error = kobject_init_and_add(&hotplug->kobj,
+		&acpi_hotplug_profile_ktype, hotplug_kobj, "%s", name);
 	if (error)
 		goto err_out;
 

commit cae712724161c27f5e8c39bb3946449e1c179881
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Sep 25 14:23:12 2013 -0600

    ACPI / hotplug: Don't set kobject parent pointer explicitly
    
    kobject_add() sets the parent pointer, so we don't need to do it
    explicitly.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index ea685835b834..75432819579c 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -764,7 +764,6 @@ void acpi_sysfs_add_hotplug_profile(struct acpi_hotplug_profile *hotplug,
 
 	kobject_init(&hotplug->kobj, &acpi_hotplug_profile_ktype);
 
-	hotplug->kobj.parent = hotplug_kobj;
 	error = kobject_add(&hotplug->kobj, hotplug_kobj, "%s", name);
 	if (error)
 		goto err_out;

commit 9b5b06740194c8fa1cddb3aa5fe69fd6f5199bc4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Sep 25 14:23:04 2013 -0600

    ACPI / hotplug: Set kobject name via kobject_add(), not kobject_set_name()
    
    Set the kobject name via kobject_add() instead of using kobject_set_name(),
    which is deprecated per Documentation/kobject.txt.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 05306a59aedc..ea685835b834 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -763,12 +763,9 @@ void acpi_sysfs_add_hotplug_profile(struct acpi_hotplug_profile *hotplug,
 		goto err_out;
 
 	kobject_init(&hotplug->kobj, &acpi_hotplug_profile_ktype);
-	error = kobject_set_name(&hotplug->kobj, "%s", name);
-	if (error)
-		goto err_out;
 
 	hotplug->kobj.parent = hotplug_kobj;
-	error = kobject_add(&hotplug->kobj, hotplug_kobj, NULL);
+	error = kobject_add(&hotplug->kobj, hotplug_kobj, "%s", name);
 	if (error)
 		goto err_out;
 

commit c48b156517348a0130e9e6edbeba95f9b4e50d65
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Thu Sep 12 03:32:05 2013 -0400

    ACPI / sysfs: make GPE sysfs attributes only accept correct values
    
    According to the design, GPE sysfs attributes should accept "disable",
    "enable", "clear" and integer numbers as params. Current code checks
    "disable", "enable" and "clear" first. If the param doesn't match,
    pass it to strtoul() as a string representing an integer number and
    assign the return value to the given GPE count. It is missing the check
    of whether or not the param really represents an integer number and
    strtoul() will return 0 if the string is not a number.  This causes any
    params except for "enable", "disable", "clear" and a number to make the
    GPE count become 0. This patch is to use kstrtoul() to replace strtoul()
    and check the return value. If the convertion is successful, use as the
    new GPE count. If not, return an error.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 05306a59aedc..b55778704444 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -564,6 +564,7 @@ static ssize_t counter_set(struct kobject *kobj,
 	acpi_event_status status;
 	acpi_handle handle;
 	int result = 0;
+	unsigned long tmp;
 
 	if (index == num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_SCI) {
 		int i;
@@ -596,8 +597,10 @@ static ssize_t counter_set(struct kobject *kobj,
 		else if (!strcmp(buf, "clear\n") &&
 			 (status & ACPI_EVENT_FLAG_SET))
 			result = acpi_clear_gpe(handle, index);
+		else if (!kstrtoul(buf, 0, &tmp))
+			all_counters[index].count = tmp;
 		else
-			all_counters[index].count = strtoul(buf, NULL, 0);
+			result = -EINVAL;
 	} else if (index < num_gpes + ACPI_NUM_FIXED_EVENTS) {
 		int event = index - num_gpes;
 		if (!strcmp(buf, "disable\n") &&
@@ -609,8 +612,10 @@ static ssize_t counter_set(struct kobject *kobj,
 		else if (!strcmp(buf, "clear\n") &&
 			 (status & ACPI_EVENT_FLAG_SET))
 			result = acpi_clear_event(event);
+		else if (!kstrtoul(buf, 0, &tmp))
+			all_counters[index].count = tmp;
 		else
-			all_counters[index].count = strtoul(buf, NULL, 0);
+			result = -EINVAL;
 	} else
 		all_counters[index].count = strtoul(buf, NULL, 0);
 

commit 7f0ef0267e20d62d45d527911a993b1e998f4968
Merge: 862f00125491 9307c2952450
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 3 17:12:13 2013 -0700

    Merge branch 'akpm' (updates from Andrew Morton)
    
    Merge first patch-bomb from Andrew Morton:
     - various misc bits
     - I'm been patchmonkeying ocfs2 for a while, as Joel and Mark have been
       distracted.  There has been quite a bit of activity.
     - About half the MM queue
     - Some backlight bits
     - Various lib/ updates
     - checkpatch updates
     - zillions more little rtc patches
     - ptrace
     - signals
     - exec
     - procfs
     - rapidio
     - nbd
     - aoe
     - pps
     - memstick
     - tools/testing/selftests updates
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (445 commits)
      tools/testing/selftests: don't assume the x bit is set on scripts
      selftests: add .gitignore for kcmp
      selftests: fix clean target in kcmp Makefile
      selftests: add .gitignore for vm
      selftests: add hugetlbfstest
      self-test: fix make clean
      selftests: exit 1 on failure
      kernel/resource.c: remove the unneeded assignment in function __find_resource
      aio: fix wrong comment in aio_complete()
      drivers/w1/slaves/w1_ds2408.c: add magic sequence to disable P0 test mode
      drivers/memstick/host/r592.c: convert to module_pci_driver
      drivers/memstick/host/jmb38x_ms: convert to module_pci_driver
      pps-gpio: add device-tree binding and support
      drivers/pps/clients/pps-gpio.c: convert to module_platform_driver
      drivers/pps/clients/pps-gpio.c: convert to devm_* helpers
      drivers/parport/share.c: use kzalloc
      Documentation/accounting/getdelays.c: avoid strncpy in accounting tool
      aoe: update internal version number to v83
      aoe: update copyright date
      aoe: perform I/O completions in parallel
      ...

commit 096a8aac6bf4a5a0b2ef812ad76d056bbf3fb2af
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jul 3 15:04:55 2013 -0700

    clean up scary strncpy(dst, src, strlen(src)) uses
    
    Fix various weird constructions of strncpy(dst, src, strlen(src)).
    
    Length limits should be about the space available in the destination,
    not repurposed as a method to either always include or always exclude a
    trailing NULL byte.  Either the NULL should always be copied (using
    strlcpy), or it should not be copied (using something like memcpy).
    Readable code should not depend on the weird behavior of strncpy when it
    hits the length limit.  Better to avoid the anti-pattern entirely.
    
    [akpm@linux-foundation.org: revert getdelays.c part due to missing bsd/string.h]
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>       [staging]
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>        [acpi]
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Ursula Braun <ursula.braun@de.ibm.com>
    Cc: Frank Blaschka <blaschka@linux.vnet.ibm.com>
    Cc: Richard Weinberger <richard@nod.at>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index fcae5fa2e1b3..193745d96fcc 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -677,10 +677,9 @@ void acpi_irq_stats_init(void)
 		else
 			sprintf(buffer, "bug%02X", i);
 
-		name = kzalloc(strlen(buffer) + 1, GFP_KERNEL);
+		name = kstrdup(buffer, GFP_KERNEL);
 		if (name == NULL)
 			goto fail;
-		strncpy(name, buffer, strlen(buffer) + 1);
 
 		sysfs_attr_init(&counter_attrs[i].attr);
 		counter_attrs[i].attr.name = name;

commit 683058e315f00a216fd6c79df4f63bc9945ca434
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 3 00:26:16 2013 +0200

    ACPI / hotplug: Use device offline/online for graceful hot-removal
    
    Modify the generic ACPI hotplug code to be able to check if devices
    scheduled for hot-removal may be gracefully removed from the system
    using the device offline/online mechanism introduced previously.
    
    Namely, make acpi_scan_hot_remove() handling device hot-removal call
    device_offline() for all physical companions of the ACPI device nodes
    involved in the operation and check the results.  If any of the
    device_offline() calls fails, the function will not progress to the
    removal phase (which cannot be aborted), unless its (new) force
    argument is set (in case of a failing offline it will put the devices
    offlined by it back online).
    
    In support of 'forced' device hot-removal, add a new sysfs attribute
    'force_remove' that will reside under /sys/firmware/acpi/hotplug/.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index fcae5fa2e1b3..5c5d1624fa2c 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -780,6 +780,33 @@ void acpi_sysfs_add_hotplug_profile(struct acpi_hotplug_profile *hotplug,
 	pr_err(PREFIX "Unable to add hotplug profile '%s'\n", name);
 }
 
+static ssize_t force_remove_show(struct kobject *kobj,
+				 struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", !!acpi_force_hot_remove);
+}
+
+static ssize_t force_remove_store(struct kobject *kobj,
+				  struct kobj_attribute *attr,
+				  const char *buf, size_t size)
+{
+	bool val;
+	int ret;
+
+	ret = strtobool(buf, &val);
+	if (ret < 0)
+		return ret;
+
+	lock_device_hotplug();
+	acpi_force_hot_remove = val;
+	unlock_device_hotplug();
+	return size;
+}
+
+static const struct kobj_attribute force_remove_attr =
+	__ATTR(force_remove, S_IRUGO | S_IWUSR, force_remove_show,
+	       force_remove_store);
+
 int __init acpi_sysfs_init(void)
 {
 	int result;
@@ -789,6 +816,10 @@ int __init acpi_sysfs_init(void)
 		return result;
 
 	hotplug_kobj = kobject_create_and_add("hotplug", acpi_kobj);
+	result = sysfs_create_file(hotplug_kobj, &force_remove_attr.attr);
+	if (result)
+		return result;
+
 	result = sysfs_create_file(acpi_kobj, &pm_profile_attr.attr);
 	return result;
 }

commit b09753ec80914424527955147c359e9ac3a87682
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Mar 19 00:16:15 2013 +0100

    ACPI / hotplug: Make acpi_hotplug_profile_ktype static
    
    The acpi_hotplug_profile_ktype object should be static, so make that
    be the case.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 83db3a68a7ee..fcae5fa2e1b3 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -750,7 +750,7 @@ static struct attribute *hotplug_profile_attrs[] = {
 	NULL
 };
 
-struct kobj_type acpi_hotplug_profile_ktype = {
+static struct kobj_type acpi_hotplug_profile_ktype = {
 	.sysfs_ops = &kobj_sysfs_ops,
 	.default_attrs = hotplug_profile_attrs,
 };

commit 3f8055c3583640ed3e4c81864dd76e06a7faa505
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Mar 3 23:08:16 2013 +0100

    ACPI / hotplug: Introduce user space interface for hotplug profiles
    
    Introduce user space interface for manipulating hotplug profiles
    associated with ACPI scan handlers.
    
    The interface consists of sysfs directories under
    /sys/firmware/acpi/hotplug/, one for each hotplug profile, containing
    an attribute allowing user space to manipulate the enabled field of
    the corresponding profile.  Namely, switching the enabled attribute
    from '0' to '1' will cause the common hotplug notify handler to be
    installed for all ACPI namespace objects representing devices matching
    the scan handler associated with the given hotplug profile (and
    analogously for the converse switch).
    
    Drivers willing to use the new user space interface should add their
    ACPI scan handlers with the help of new funtion
    acpi_scan_add_handler_with_hotplug().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 41c0504470db..83db3a68a7ee 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -7,6 +7,8 @@
 #include <linux/moduleparam.h>
 #include <acpi/acpi_drivers.h>
 
+#include "internal.h"
+
 #define _COMPONENT		ACPI_SYSTEM_COMPONENT
 ACPI_MODULE_NAME("sysfs");
 
@@ -249,6 +251,7 @@ module_param_call(acpica_version, NULL, param_get_acpica_version, NULL, 0444);
 static LIST_HEAD(acpi_table_attr_list);
 static struct kobject *tables_kobj;
 static struct kobject *dynamic_tables_kobj;
+static struct kobject *hotplug_kobj;
 
 struct acpi_table_attr {
 	struct bin_attribute attr;
@@ -716,6 +719,67 @@ acpi_show_profile(struct device *dev, struct device_attribute *attr,
 static const struct device_attribute pm_profile_attr =
 	__ATTR(pm_profile, S_IRUGO, acpi_show_profile, NULL);
 
+static ssize_t hotplug_enabled_show(struct kobject *kobj,
+				    struct kobj_attribute *attr, char *buf)
+{
+	struct acpi_hotplug_profile *hotplug = to_acpi_hotplug_profile(kobj);
+
+	return sprintf(buf, "%d\n", hotplug->enabled);
+}
+
+static ssize_t hotplug_enabled_store(struct kobject *kobj,
+				     struct kobj_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct acpi_hotplug_profile *hotplug = to_acpi_hotplug_profile(kobj);
+	unsigned int val;
+
+	if (kstrtouint(buf, 10, &val) || val > 1)
+		return -EINVAL;
+
+	acpi_scan_hotplug_enabled(hotplug, val);
+	return size;
+}
+
+static struct kobj_attribute hotplug_enabled_attr =
+	__ATTR(enabled, S_IRUGO | S_IWUSR, hotplug_enabled_show,
+		hotplug_enabled_store);
+
+static struct attribute *hotplug_profile_attrs[] = {
+	&hotplug_enabled_attr.attr,
+	NULL
+};
+
+struct kobj_type acpi_hotplug_profile_ktype = {
+	.sysfs_ops = &kobj_sysfs_ops,
+	.default_attrs = hotplug_profile_attrs,
+};
+
+void acpi_sysfs_add_hotplug_profile(struct acpi_hotplug_profile *hotplug,
+				    const char *name)
+{
+	int error;
+
+	if (!hotplug_kobj)
+		goto err_out;
+
+	kobject_init(&hotplug->kobj, &acpi_hotplug_profile_ktype);
+	error = kobject_set_name(&hotplug->kobj, "%s", name);
+	if (error)
+		goto err_out;
+
+	hotplug->kobj.parent = hotplug_kobj;
+	error = kobject_add(&hotplug->kobj, hotplug_kobj, NULL);
+	if (error)
+		goto err_out;
+
+	kobject_uevent(&hotplug->kobj, KOBJ_ADD);
+	return;
+
+ err_out:
+	pr_err(PREFIX "Unable to add hotplug profile '%s'\n", name);
+}
+
 int __init acpi_sysfs_init(void)
 {
 	int result;
@@ -723,6 +787,8 @@ int __init acpi_sysfs_init(void)
 	result = acpi_tables_sysfs_init();
 	if (result)
 		return result;
+
+	hotplug_kobj = kobject_create_and_add("hotplug", acpi_kobj);
 	result = sysfs_create_file(acpi_kobj, &pm_profile_attr.attr);
 	return result;
 }

commit c628423777d9df5e48ea8c5695aacd105cf4f768
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Nov 29 11:53:14 2012 +0000

    ACPI sysfs: remove unnecessary newline from exception
    
    ACPI_EXCEPTION() already appends a newline, so there is no
    need for the invalid GPE message to include one too.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index ea61ca9129cd..41c0504470db 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -498,7 +498,7 @@ static int get_status(u32 index, acpi_event_status *status,
 		result = acpi_get_gpe_device(index, handle);
 		if (result) {
 			ACPI_EXCEPTION((AE_INFO, AE_NOT_FOUND,
-					"Invalid GPE 0x%x\n", index));
+					"Invalid GPE 0x%x", index));
 			goto end;
 		}
 		result = acpi_get_gpe_status(*handle, index, status);

commit 644ef74e6d187ca2e8a23ff41a513964de36f93e
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Oct 31 02:25:36 2012 +0000

    ACPICA: Fix AcpiSrc caused divergences.
    
    There are definitions that can been converted into new styles by
    the recent AcpiSrc while they remain the old styles in the Linux.
    This patch fixes those definitions that will be converted by the
    AcpiSrc.
    
    This patch will not affect the generated vmlinux binary.
    This will decrease 97 lines of 20120913 divergence.diff.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 7c3f98ba4afe..ea61ca9129cd 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -476,7 +476,7 @@ static void fixed_event_count(u32 event_number)
 	return;
 }
 
-static void acpi_gbl_event_handler(u32 event_type, acpi_handle device,
+static void acpi_global_event_handler(u32 event_type, acpi_handle device,
 	u32 event_number, void *context)
 {
 	if (event_type == ACPI_EVENT_TYPE_GPE)
@@ -638,7 +638,7 @@ void acpi_irq_stats_init(void)
 	if (all_counters == NULL)
 		goto fail;
 
-	status = acpi_install_global_event_handler(acpi_gbl_event_handler, NULL);
+	status = acpi_install_global_event_handler(acpi_global_event_handler, NULL);
 	if (ACPI_FAILURE(status))
 		goto fail;
 

commit 869639f9e7ff5ca337b27469c298dd11c29cf0fa
Author: Len Brown <len.brown@intel.com>
Date:   Thu Jul 26 21:32:01 2012 -0400

    ACPI: replace strlen("string") with sizeof("string") -1
    
    ...both give the number of chars in the string
    without the '\0', as strncmp() wants,
    but sizeof() is compile-time.
    
    Reported-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Pavel Vasilyev <pavel@pavlinux.ru>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 240a24400976..7c3f98ba4afe 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -173,7 +173,7 @@ static int param_set_trace_state(const char *val, struct kernel_param *kp)
 {
 	int result = 0;
 
-	if (!strncmp(val, "enable", strlen("enable"))) {
+	if (!strncmp(val, "enable", sizeof("enable") - 1)) {
 		result = acpi_debug_trace(trace_method_name, trace_debug_level,
 					  trace_debug_layer, 0);
 		if (result)
@@ -181,7 +181,7 @@ static int param_set_trace_state(const char *val, struct kernel_param *kp)
 		goto exit;
 	}
 
-	if (!strncmp(val, "disable", strlen("disable"))) {
+	if (!strncmp(val, "disable", sizeof("disable") - 1)) {
 		int name = 0;
 		result = acpi_debug_trace((char *)&name, trace_debug_level,
 					  trace_debug_layer, 0);

commit 9f132652d94c96476b0b0a8caf0c10e96ab10fa8
Author: Pavel Vasilyev <pavel@pavlinux.ru>
Date:   Tue Jun 5 00:02:05 2012 -0400

    ACPI sysfs.c strlen fix
    
    Current code is ignoring the last character of "enable" and "disable"
    in comparisons.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=33732
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 9f66181c814e..240a24400976 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -173,7 +173,7 @@ static int param_set_trace_state(const char *val, struct kernel_param *kp)
 {
 	int result = 0;
 
-	if (!strncmp(val, "enable", strlen("enable") - 1)) {
+	if (!strncmp(val, "enable", strlen("enable"))) {
 		result = acpi_debug_trace(trace_method_name, trace_debug_level,
 					  trace_debug_layer, 0);
 		if (result)
@@ -181,7 +181,7 @@ static int param_set_trace_state(const char *val, struct kernel_param *kp)
 		goto exit;
 	}
 
-	if (!strncmp(val, "disable", strlen("disable") - 1)) {
+	if (!strncmp(val, "disable", strlen("disable"))) {
 		int name = 0;
 		result = acpi_debug_trace((char *)&name, trace_debug_level,
 					  trace_debug_layer, 0);

commit 362b646062b2073bd5c38efb42171d86e4f717e6
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Nov 4 03:33:46 2011 +0100

    ACPI: Export FADT pm_profile integer value to userspace
    
    There are a lot userspace approaches to detect the usage of the
    platform (laptop, workstation, server, ...) and adjust kernel tunables
    accordingly (io/process scheduler, power management, ...).
    
    These approaches need constant maintaining and are ugly to implement
    (detect PCMCIA controller -> laptop,
    does not work on recent systems anymore, ...)
    On ACPI systems there is an easy and reliable way (if implemented
    in BIOS and most recent platforms have this value set).
    -> export it to userspace.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index c538d0ef10ff..9f66181c814e 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -706,11 +706,23 @@ static void __exit interrupt_stats_exit(void)
 	return;
 }
 
+static ssize_t
+acpi_show_profile(struct device *dev, struct device_attribute *attr,
+		  char *buf)
+{
+	return sprintf(buf, "%d\n", acpi_gbl_FADT.preferred_profile);
+}
+
+static const struct device_attribute pm_profile_attr =
+	__ATTR(pm_profile, S_IRUGO, acpi_show_profile, NULL);
+
 int __init acpi_sysfs_init(void)
 {
 	int result;
 
 	result = acpi_tables_sysfs_init();
-
+	if (result)
+		return result;
+	result = sysfs_create_file(acpi_kobj, &pm_profile_attr.attr);
 	return result;
 }

commit 9c8b04be443b33939f374a811c82abeebe0a61d1
Author: Vasiliy Kulikov <segoon@openwall.com>
Date:   Sat Jun 25 21:07:52 2011 +0400

    ACPI: constify ops structs
    
    Structs battery_file, acpi_dock_ops, file_operations,
    thermal_cooling_device_ops, thermal_zone_device_ops, kernel_param_ops
    are not changed in runtime.  It is safe to make them const.
    register_hotplug_dock_device() was altered to take const "ops" argument
    to respect acpi_dock_ops' const notion.
    
    Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 77255f250dbb..c538d0ef10ff 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -149,12 +149,12 @@ static int param_get_debug_level(char *buffer, const struct kernel_param *kp)
 	return result;
 }
 
-static struct kernel_param_ops param_ops_debug_layer = {
+static const struct kernel_param_ops param_ops_debug_layer = {
 	.set = param_set_uint,
 	.get = param_get_debug_layer,
 };
 
-static struct kernel_param_ops param_ops_debug_level = {
+static const struct kernel_param_ops param_ops_debug_level = {
 	.set = param_set_uint,
 	.get = param_get_debug_level,
 };

commit aecad432fd68dafa5b3b497c4816fbfce6fd4066
Author: Thomas Renninger <trenn@suse.de>
Date:   Thu May 26 12:26:23 2011 +0200

    ACPI: Cleanup custom_method debug stuff
    
    - Move param aml_debug_output to other params into sysfs.c
    - Split acpi_debugfs_init to prepare custom_method to be
      an own .config option and driver.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: rui.zhang@intel.com
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 61891e75583d..77255f250dbb 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -220,6 +220,14 @@ module_param_call(trace_state, param_set_trace_state, param_get_trace_state,
 		  NULL, 0644);
 #endif /* CONFIG_ACPI_DEBUG */
 
+
+/* /sys/modules/acpi/parameters/aml_debug_output */
+
+module_param_named(aml_debug_output, acpi_gbl_enable_aml_debug_object,
+		   bool, 0644);
+MODULE_PARM_DESC(aml_debug_output,
+		 "To enable/disable the ACPI Debug Object output.");
+
 /* /sys/module/acpi/parameters/acpica_version */
 static int param_get_acpica_version(char *buffer, struct kernel_param *kp)
 {

commit a0fcdb237fcd4eaa7e5009b28ef5be07415f287d
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Dec 13 13:39:26 2010 +0800

    ACPICA: Global event handler
    
    The global event handler is called whenever a general purpose
    or fixed ACPI event occurs.
    
    Also update Linux OSL to collect events counter with
    global event handler.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index f8588f81048a..61891e75583d 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -438,7 +438,7 @@ static void delete_gpe_attr_array(void)
 	return;
 }
 
-void acpi_os_gpe_count(u32 gpe_number)
+static void gpe_count(u32 gpe_number)
 {
 	acpi_gpe_count++;
 
@@ -454,7 +454,7 @@ void acpi_os_gpe_count(u32 gpe_number)
 	return;
 }
 
-void acpi_os_fixed_event_count(u32 event_number)
+static void fixed_event_count(u32 event_number)
 {
 	if (!all_counters)
 		return;
@@ -468,6 +468,16 @@ void acpi_os_fixed_event_count(u32 event_number)
 	return;
 }
 
+static void acpi_gbl_event_handler(u32 event_type, acpi_handle device,
+	u32 event_number, void *context)
+{
+	if (event_type == ACPI_EVENT_TYPE_GPE)
+		gpe_count(event_number);
+
+	if (event_type == ACPI_EVENT_TYPE_FIXED)
+		fixed_event_count(event_number);
+}
+
 static int get_status(u32 index, acpi_event_status *status,
 		      acpi_handle *handle)
 {
@@ -601,6 +611,7 @@ static ssize_t counter_set(struct kobject *kobj,
 
 void acpi_irq_stats_init(void)
 {
+	acpi_status status;
 	int i;
 
 	if (all_counters)
@@ -619,6 +630,10 @@ void acpi_irq_stats_init(void)
 	if (all_counters == NULL)
 		goto fail;
 
+	status = acpi_install_global_event_handler(acpi_gbl_event_handler, NULL);
+	if (ACPI_FAILURE(status))
+		goto fail;
+
 	counter_attrs = kzalloc(sizeof(struct kobj_attribute) * (num_counters),
 				GFP_KERNEL);
 	if (counter_attrs == NULL)

commit ec652b351f48ed4cd6796181fbb41759ff88cc0a
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Mon Aug 30 14:08:02 2010 +0800

    ACPI: fix build warnings resulting from merge window conflict
    
    drivers/acpi/sysfs.c:154: warning: passing argument 1 of '__check_old_set_param' from incompatible pointer type
    include/linux/moduleparam.h:165: note: expected 'int (*)(const char *, struct kernel_param *)' but argument is of type 'int (*)(const char *, const struct kernel_param *)'
    
    Introduced by commit 1c8fce27e275fd7c6b75bc6455745f02d3903ee6 ("ACPI:
    introduce drivers/acpi/sysfs.c") interacting with commit
    9bbb9e5a33109b2832e2e63dcc7a132924ab374b ("param: use ops in struct
    kernel_param, rather than get and set fns directly").
    
    Use module_param_cb instead of the obsoleted module_param_call to fix a build warning.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 68e2e4582fa2..f8588f81048a 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -100,7 +100,7 @@ static const struct acpi_dlevel acpi_debug_levels[] = {
 	ACPI_DEBUG_INIT(ACPI_LV_EVENTS),
 };
 
-static int param_get_debug_layer(char *buffer, struct kernel_param *kp)
+static int param_get_debug_layer(char *buffer, const struct kernel_param *kp)
 {
 	int result = 0;
 	int i;
@@ -128,7 +128,7 @@ static int param_get_debug_layer(char *buffer, struct kernel_param *kp)
 	return result;
 }
 
-static int param_get_debug_level(char *buffer, struct kernel_param *kp)
+static int param_get_debug_level(char *buffer, const struct kernel_param *kp)
 {
 	int result = 0;
 	int i;
@@ -149,10 +149,18 @@ static int param_get_debug_level(char *buffer, struct kernel_param *kp)
 	return result;
 }
 
-module_param_call(debug_layer, param_set_uint, param_get_debug_layer,
-		  &acpi_dbg_layer, 0644);
-module_param_call(debug_level, param_set_uint, param_get_debug_level,
-		  &acpi_dbg_level, 0644);
+static struct kernel_param_ops param_ops_debug_layer = {
+	.set = param_set_uint,
+	.get = param_get_debug_layer,
+};
+
+static struct kernel_param_ops param_ops_debug_level = {
+	.set = param_set_uint,
+	.get = param_get_debug_level,
+};
+
+module_param_cb(debug_layer, &param_ops_debug_layer, &acpi_dbg_layer, 0644);
+module_param_cb(debug_level, &param_ops_debug_level, &acpi_dbg_level, 0644);
 
 static char trace_method_name[6];
 module_param_string(trace_method_name, trace_method_name, 6, 0644);

commit 1c8fce27e275fd7c6b75bc6455745f02d3903ee6
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Jul 15 10:46:30 2010 +0800

    ACPI: introduce drivers/acpi/sysfs.c
    
    Introduce drivers/acpi/sysfs.c.
    
    code for ACPI sysfs I/F, including
    #ifdef ACPI_DEBUG
    /sys/module/acpi/parameters/debug_layer
    /sys/module/acpi/parameters/debug_level
    /sys/module/acpi/parameters/trace_method_name
    /sys/module/acpi/parameters/trace_debug_layer
    /sys/module/acpi/parameters/trace_debug_level
    /sys/module/acpi/parameters/trace_state
    #endif
    /sys/module/acpi/parameters/acpica_version
    /sys/firmware/acpi/tables/
    /sys/firmware/acpi/interrupts/
    is moved to this file.
    
    No function change in this patch.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
new file mode 100644
index 000000000000..68e2e4582fa2
--- /dev/null
+++ b/drivers/acpi/sysfs.c
@@ -0,0 +1,685 @@
+/*
+ * sysfs.c - ACPI sysfs interface to userspace.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <acpi/acpi_drivers.h>
+
+#define _COMPONENT		ACPI_SYSTEM_COMPONENT
+ACPI_MODULE_NAME("sysfs");
+
+#define PREFIX "ACPI: "
+
+#ifdef CONFIG_ACPI_DEBUG
+/*
+ * ACPI debug sysfs I/F, including:
+ * /sys/modules/acpi/parameters/debug_layer
+ * /sys/modules/acpi/parameters/debug_level
+ * /sys/modules/acpi/parameters/trace_method_name
+ * /sys/modules/acpi/parameters/trace_state
+ * /sys/modules/acpi/parameters/trace_debug_layer
+ * /sys/modules/acpi/parameters/trace_debug_level
+ */
+
+struct acpi_dlayer {
+	const char *name;
+	unsigned long value;
+};
+struct acpi_dlevel {
+	const char *name;
+	unsigned long value;
+};
+#define ACPI_DEBUG_INIT(v)	{ .name = #v, .value = v }
+
+static const struct acpi_dlayer acpi_debug_layers[] = {
+	ACPI_DEBUG_INIT(ACPI_UTILITIES),
+	ACPI_DEBUG_INIT(ACPI_HARDWARE),
+	ACPI_DEBUG_INIT(ACPI_EVENTS),
+	ACPI_DEBUG_INIT(ACPI_TABLES),
+	ACPI_DEBUG_INIT(ACPI_NAMESPACE),
+	ACPI_DEBUG_INIT(ACPI_PARSER),
+	ACPI_DEBUG_INIT(ACPI_DISPATCHER),
+	ACPI_DEBUG_INIT(ACPI_EXECUTER),
+	ACPI_DEBUG_INIT(ACPI_RESOURCES),
+	ACPI_DEBUG_INIT(ACPI_CA_DEBUGGER),
+	ACPI_DEBUG_INIT(ACPI_OS_SERVICES),
+	ACPI_DEBUG_INIT(ACPI_CA_DISASSEMBLER),
+	ACPI_DEBUG_INIT(ACPI_COMPILER),
+	ACPI_DEBUG_INIT(ACPI_TOOLS),
+
+	ACPI_DEBUG_INIT(ACPI_BUS_COMPONENT),
+	ACPI_DEBUG_INIT(ACPI_AC_COMPONENT),
+	ACPI_DEBUG_INIT(ACPI_BATTERY_COMPONENT),
+	ACPI_DEBUG_INIT(ACPI_BUTTON_COMPONENT),
+	ACPI_DEBUG_INIT(ACPI_SBS_COMPONENT),
+	ACPI_DEBUG_INIT(ACPI_FAN_COMPONENT),
+	ACPI_DEBUG_INIT(ACPI_PCI_COMPONENT),
+	ACPI_DEBUG_INIT(ACPI_POWER_COMPONENT),
+	ACPI_DEBUG_INIT(ACPI_CONTAINER_COMPONENT),
+	ACPI_DEBUG_INIT(ACPI_SYSTEM_COMPONENT),
+	ACPI_DEBUG_INIT(ACPI_THERMAL_COMPONENT),
+	ACPI_DEBUG_INIT(ACPI_MEMORY_DEVICE_COMPONENT),
+	ACPI_DEBUG_INIT(ACPI_VIDEO_COMPONENT),
+	ACPI_DEBUG_INIT(ACPI_PROCESSOR_COMPONENT),
+};
+
+static const struct acpi_dlevel acpi_debug_levels[] = {
+	ACPI_DEBUG_INIT(ACPI_LV_INIT),
+	ACPI_DEBUG_INIT(ACPI_LV_DEBUG_OBJECT),
+	ACPI_DEBUG_INIT(ACPI_LV_INFO),
+
+	ACPI_DEBUG_INIT(ACPI_LV_INIT_NAMES),
+	ACPI_DEBUG_INIT(ACPI_LV_PARSE),
+	ACPI_DEBUG_INIT(ACPI_LV_LOAD),
+	ACPI_DEBUG_INIT(ACPI_LV_DISPATCH),
+	ACPI_DEBUG_INIT(ACPI_LV_EXEC),
+	ACPI_DEBUG_INIT(ACPI_LV_NAMES),
+	ACPI_DEBUG_INIT(ACPI_LV_OPREGION),
+	ACPI_DEBUG_INIT(ACPI_LV_BFIELD),
+	ACPI_DEBUG_INIT(ACPI_LV_TABLES),
+	ACPI_DEBUG_INIT(ACPI_LV_VALUES),
+	ACPI_DEBUG_INIT(ACPI_LV_OBJECTS),
+	ACPI_DEBUG_INIT(ACPI_LV_RESOURCES),
+	ACPI_DEBUG_INIT(ACPI_LV_USER_REQUESTS),
+	ACPI_DEBUG_INIT(ACPI_LV_PACKAGE),
+
+	ACPI_DEBUG_INIT(ACPI_LV_ALLOCATIONS),
+	ACPI_DEBUG_INIT(ACPI_LV_FUNCTIONS),
+	ACPI_DEBUG_INIT(ACPI_LV_OPTIMIZATIONS),
+
+	ACPI_DEBUG_INIT(ACPI_LV_MUTEX),
+	ACPI_DEBUG_INIT(ACPI_LV_THREADS),
+	ACPI_DEBUG_INIT(ACPI_LV_IO),
+	ACPI_DEBUG_INIT(ACPI_LV_INTERRUPTS),
+
+	ACPI_DEBUG_INIT(ACPI_LV_AML_DISASSEMBLE),
+	ACPI_DEBUG_INIT(ACPI_LV_VERBOSE_INFO),
+	ACPI_DEBUG_INIT(ACPI_LV_FULL_TABLES),
+	ACPI_DEBUG_INIT(ACPI_LV_EVENTS),
+};
+
+static int param_get_debug_layer(char *buffer, struct kernel_param *kp)
+{
+	int result = 0;
+	int i;
+
+	result = sprintf(buffer, "%-25s\tHex        SET\n", "Description");
+
+	for (i = 0; i < ARRAY_SIZE(acpi_debug_layers); i++) {
+		result += sprintf(buffer + result, "%-25s\t0x%08lX [%c]\n",
+				  acpi_debug_layers[i].name,
+				  acpi_debug_layers[i].value,
+				  (acpi_dbg_layer & acpi_debug_layers[i].value)
+				  ? '*' : ' ');
+	}
+	result +=
+	    sprintf(buffer + result, "%-25s\t0x%08X [%c]\n", "ACPI_ALL_DRIVERS",
+		    ACPI_ALL_DRIVERS,
+		    (acpi_dbg_layer & ACPI_ALL_DRIVERS) ==
+		    ACPI_ALL_DRIVERS ? '*' : (acpi_dbg_layer & ACPI_ALL_DRIVERS)
+		    == 0 ? ' ' : '-');
+	result +=
+	    sprintf(buffer + result,
+		    "--\ndebug_layer = 0x%08X ( * = enabled)\n",
+		    acpi_dbg_layer);
+
+	return result;
+}
+
+static int param_get_debug_level(char *buffer, struct kernel_param *kp)
+{
+	int result = 0;
+	int i;
+
+	result = sprintf(buffer, "%-25s\tHex        SET\n", "Description");
+
+	for (i = 0; i < ARRAY_SIZE(acpi_debug_levels); i++) {
+		result += sprintf(buffer + result, "%-25s\t0x%08lX [%c]\n",
+				  acpi_debug_levels[i].name,
+				  acpi_debug_levels[i].value,
+				  (acpi_dbg_level & acpi_debug_levels[i].value)
+				  ? '*' : ' ');
+	}
+	result +=
+	    sprintf(buffer + result, "--\ndebug_level = 0x%08X (* = enabled)\n",
+		    acpi_dbg_level);
+
+	return result;
+}
+
+module_param_call(debug_layer, param_set_uint, param_get_debug_layer,
+		  &acpi_dbg_layer, 0644);
+module_param_call(debug_level, param_set_uint, param_get_debug_level,
+		  &acpi_dbg_level, 0644);
+
+static char trace_method_name[6];
+module_param_string(trace_method_name, trace_method_name, 6, 0644);
+static unsigned int trace_debug_layer;
+module_param(trace_debug_layer, uint, 0644);
+static unsigned int trace_debug_level;
+module_param(trace_debug_level, uint, 0644);
+
+static int param_set_trace_state(const char *val, struct kernel_param *kp)
+{
+	int result = 0;
+
+	if (!strncmp(val, "enable", strlen("enable") - 1)) {
+		result = acpi_debug_trace(trace_method_name, trace_debug_level,
+					  trace_debug_layer, 0);
+		if (result)
+			result = -EBUSY;
+		goto exit;
+	}
+
+	if (!strncmp(val, "disable", strlen("disable") - 1)) {
+		int name = 0;
+		result = acpi_debug_trace((char *)&name, trace_debug_level,
+					  trace_debug_layer, 0);
+		if (result)
+			result = -EBUSY;
+		goto exit;
+	}
+
+	if (!strncmp(val, "1", 1)) {
+		result = acpi_debug_trace(trace_method_name, trace_debug_level,
+					  trace_debug_layer, 1);
+		if (result)
+			result = -EBUSY;
+		goto exit;
+	}
+
+	result = -EINVAL;
+exit:
+	return result;
+}
+
+static int param_get_trace_state(char *buffer, struct kernel_param *kp)
+{
+	if (!acpi_gbl_trace_method_name)
+		return sprintf(buffer, "disable");
+	else {
+		if (acpi_gbl_trace_flags & 1)
+			return sprintf(buffer, "1");
+		else
+			return sprintf(buffer, "enable");
+	}
+	return 0;
+}
+
+module_param_call(trace_state, param_set_trace_state, param_get_trace_state,
+		  NULL, 0644);
+#endif /* CONFIG_ACPI_DEBUG */
+
+/* /sys/module/acpi/parameters/acpica_version */
+static int param_get_acpica_version(char *buffer, struct kernel_param *kp)
+{
+	int result;
+
+	result = sprintf(buffer, "%x", ACPI_CA_VERSION);
+
+	return result;
+}
+
+module_param_call(acpica_version, NULL, param_get_acpica_version, NULL, 0444);
+
+/*
+ * ACPI table sysfs I/F:
+ * /sys/firmware/acpi/tables/
+ * /sys/firmware/acpi/tables/dynamic/
+ */
+
+static LIST_HEAD(acpi_table_attr_list);
+static struct kobject *tables_kobj;
+static struct kobject *dynamic_tables_kobj;
+
+struct acpi_table_attr {
+	struct bin_attribute attr;
+	char name[8];
+	int instance;
+	struct list_head node;
+};
+
+static ssize_t acpi_table_show(struct file *filp, struct kobject *kobj,
+			       struct bin_attribute *bin_attr, char *buf,
+			       loff_t offset, size_t count)
+{
+	struct acpi_table_attr *table_attr =
+	    container_of(bin_attr, struct acpi_table_attr, attr);
+	struct acpi_table_header *table_header = NULL;
+	acpi_status status;
+	char name[ACPI_NAME_SIZE];
+
+	if (strncmp(table_attr->name, "NULL", 4))
+		memcpy(name, table_attr->name, ACPI_NAME_SIZE);
+	else
+		memcpy(name, "\0\0\0\0", 4);
+
+	status = acpi_get_table(name, table_attr->instance, &table_header);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	return memory_read_from_buffer(buf, count, &offset,
+				       table_header, table_header->length);
+}
+
+static void acpi_table_attr_init(struct acpi_table_attr *table_attr,
+				 struct acpi_table_header *table_header)
+{
+	struct acpi_table_header *header = NULL;
+	struct acpi_table_attr *attr = NULL;
+
+	sysfs_attr_init(&table_attr->attr.attr);
+	if (table_header->signature[0] != '\0')
+		memcpy(table_attr->name, table_header->signature,
+		       ACPI_NAME_SIZE);
+	else
+		memcpy(table_attr->name, "NULL", 4);
+
+	list_for_each_entry(attr, &acpi_table_attr_list, node) {
+		if (!memcmp(table_attr->name, attr->name, ACPI_NAME_SIZE))
+			if (table_attr->instance < attr->instance)
+				table_attr->instance = attr->instance;
+	}
+	table_attr->instance++;
+
+	if (table_attr->instance > 1 || (table_attr->instance == 1 &&
+					 !acpi_get_table
+					 (table_header->signature, 2, &header)))
+		sprintf(table_attr->name + ACPI_NAME_SIZE, "%d",
+			table_attr->instance);
+
+	table_attr->attr.size = 0;
+	table_attr->attr.read = acpi_table_show;
+	table_attr->attr.attr.name = table_attr->name;
+	table_attr->attr.attr.mode = 0400;
+
+	return;
+}
+
+static acpi_status
+acpi_sysfs_table_handler(u32 event, void *table, void *context)
+{
+	struct acpi_table_attr *table_attr;
+
+	switch (event) {
+	case ACPI_TABLE_EVENT_LOAD:
+		table_attr =
+		    kzalloc(sizeof(struct acpi_table_attr), GFP_KERNEL);
+		if (!table_attr)
+			return AE_NO_MEMORY;
+
+		acpi_table_attr_init(table_attr, table);
+		if (sysfs_create_bin_file(dynamic_tables_kobj,
+					  &table_attr->attr)) {
+			kfree(table_attr);
+			return AE_ERROR;
+		} else
+			list_add_tail(&table_attr->node, &acpi_table_attr_list);
+		break;
+	case ACPI_TABLE_EVENT_UNLOAD:
+		/*
+		 * we do not need to do anything right now
+		 * because the table is not deleted from the
+		 * global table list when unloading it.
+		 */
+		break;
+	default:
+		return AE_BAD_PARAMETER;
+	}
+	return AE_OK;
+}
+
+static int acpi_tables_sysfs_init(void)
+{
+	struct acpi_table_attr *table_attr;
+	struct acpi_table_header *table_header = NULL;
+	int table_index = 0;
+	int result;
+
+	tables_kobj = kobject_create_and_add("tables", acpi_kobj);
+	if (!tables_kobj)
+		goto err;
+
+	dynamic_tables_kobj = kobject_create_and_add("dynamic", tables_kobj);
+	if (!dynamic_tables_kobj)
+		goto err_dynamic_tables;
+
+	do {
+		result = acpi_get_table_by_index(table_index, &table_header);
+		if (!result) {
+			table_index++;
+			table_attr = NULL;
+			table_attr =
+			    kzalloc(sizeof(struct acpi_table_attr), GFP_KERNEL);
+			if (!table_attr)
+				return -ENOMEM;
+
+			acpi_table_attr_init(table_attr, table_header);
+			result =
+			    sysfs_create_bin_file(tables_kobj,
+						  &table_attr->attr);
+			if (result) {
+				kfree(table_attr);
+				return result;
+			} else
+				list_add_tail(&table_attr->node,
+					      &acpi_table_attr_list);
+		}
+	} while (!result);
+	kobject_uevent(tables_kobj, KOBJ_ADD);
+	kobject_uevent(dynamic_tables_kobj, KOBJ_ADD);
+	result = acpi_install_table_handler(acpi_sysfs_table_handler, NULL);
+
+	return result == AE_OK ? 0 : -EINVAL;
+err_dynamic_tables:
+	kobject_put(tables_kobj);
+err:
+	return -ENOMEM;
+}
+
+/*
+ * Detailed ACPI IRQ counters:
+ * /sys/firmware/acpi/interrupts/
+ */
+
+u32 acpi_irq_handled;
+u32 acpi_irq_not_handled;
+
+#define COUNT_GPE 0
+#define COUNT_SCI 1		/* acpi_irq_handled */
+#define COUNT_SCI_NOT 2		/* acpi_irq_not_handled */
+#define COUNT_ERROR 3		/* other */
+#define NUM_COUNTERS_EXTRA 4
+
+struct event_counter {
+	u32 count;
+	u32 flags;
+};
+
+static struct event_counter *all_counters;
+static u32 num_gpes;
+static u32 num_counters;
+static struct attribute **all_attrs;
+static u32 acpi_gpe_count;
+
+static struct attribute_group interrupt_stats_attr_group = {
+	.name = "interrupts",
+};
+
+static struct kobj_attribute *counter_attrs;
+
+static void delete_gpe_attr_array(void)
+{
+	struct event_counter *tmp = all_counters;
+
+	all_counters = NULL;
+	kfree(tmp);
+
+	if (counter_attrs) {
+		int i;
+
+		for (i = 0; i < num_gpes; i++)
+			kfree(counter_attrs[i].attr.name);
+
+		kfree(counter_attrs);
+	}
+	kfree(all_attrs);
+
+	return;
+}
+
+void acpi_os_gpe_count(u32 gpe_number)
+{
+	acpi_gpe_count++;
+
+	if (!all_counters)
+		return;
+
+	if (gpe_number < num_gpes)
+		all_counters[gpe_number].count++;
+	else
+		all_counters[num_gpes + ACPI_NUM_FIXED_EVENTS +
+			     COUNT_ERROR].count++;
+
+	return;
+}
+
+void acpi_os_fixed_event_count(u32 event_number)
+{
+	if (!all_counters)
+		return;
+
+	if (event_number < ACPI_NUM_FIXED_EVENTS)
+		all_counters[num_gpes + event_number].count++;
+	else
+		all_counters[num_gpes + ACPI_NUM_FIXED_EVENTS +
+			     COUNT_ERROR].count++;
+
+	return;
+}
+
+static int get_status(u32 index, acpi_event_status *status,
+		      acpi_handle *handle)
+{
+	int result = 0;
+
+	if (index >= num_gpes + ACPI_NUM_FIXED_EVENTS)
+		goto end;
+
+	if (index < num_gpes) {
+		result = acpi_get_gpe_device(index, handle);
+		if (result) {
+			ACPI_EXCEPTION((AE_INFO, AE_NOT_FOUND,
+					"Invalid GPE 0x%x\n", index));
+			goto end;
+		}
+		result = acpi_get_gpe_status(*handle, index, status);
+	} else if (index < (num_gpes + ACPI_NUM_FIXED_EVENTS))
+		result = acpi_get_event_status(index - num_gpes, status);
+
+end:
+	return result;
+}
+
+static ssize_t counter_show(struct kobject *kobj,
+			    struct kobj_attribute *attr, char *buf)
+{
+	int index = attr - counter_attrs;
+	int size;
+	acpi_handle handle;
+	acpi_event_status status;
+	int result = 0;
+
+	all_counters[num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_SCI].count =
+	    acpi_irq_handled;
+	all_counters[num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_SCI_NOT].count =
+	    acpi_irq_not_handled;
+	all_counters[num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_GPE].count =
+	    acpi_gpe_count;
+	size = sprintf(buf, "%8d", all_counters[index].count);
+
+	/* "gpe_all" or "sci" */
+	if (index >= num_gpes + ACPI_NUM_FIXED_EVENTS)
+		goto end;
+
+	result = get_status(index, &status, &handle);
+	if (result)
+		goto end;
+
+	if (!(status & ACPI_EVENT_FLAG_HANDLE))
+		size += sprintf(buf + size, "   invalid");
+	else if (status & ACPI_EVENT_FLAG_ENABLED)
+		size += sprintf(buf + size, "   enabled");
+	else if (status & ACPI_EVENT_FLAG_WAKE_ENABLED)
+		size += sprintf(buf + size, "   wake_enabled");
+	else
+		size += sprintf(buf + size, "   disabled");
+
+end:
+	size += sprintf(buf + size, "\n");
+	return result ? result : size;
+}
+
+/*
+ * counter_set() sets the specified counter.
+ * setting the total "sci" file to any value clears all counters.
+ * enable/disable/clear a gpe/fixed event in user space.
+ */
+static ssize_t counter_set(struct kobject *kobj,
+			   struct kobj_attribute *attr, const char *buf,
+			   size_t size)
+{
+	int index = attr - counter_attrs;
+	acpi_event_status status;
+	acpi_handle handle;
+	int result = 0;
+
+	if (index == num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_SCI) {
+		int i;
+		for (i = 0; i < num_counters; ++i)
+			all_counters[i].count = 0;
+		acpi_gpe_count = 0;
+		acpi_irq_handled = 0;
+		acpi_irq_not_handled = 0;
+		goto end;
+	}
+
+	/* show the event status for both GPEs and Fixed Events */
+	result = get_status(index, &status, &handle);
+	if (result)
+		goto end;
+
+	if (!(status & ACPI_EVENT_FLAG_HANDLE)) {
+		printk(KERN_WARNING PREFIX
+		       "Can not change Invalid GPE/Fixed Event status\n");
+		return -EINVAL;
+	}
+
+	if (index < num_gpes) {
+		if (!strcmp(buf, "disable\n") &&
+		    (status & ACPI_EVENT_FLAG_ENABLED))
+			result = acpi_disable_gpe(handle, index);
+		else if (!strcmp(buf, "enable\n") &&
+			 !(status & ACPI_EVENT_FLAG_ENABLED))
+			result = acpi_enable_gpe(handle, index);
+		else if (!strcmp(buf, "clear\n") &&
+			 (status & ACPI_EVENT_FLAG_SET))
+			result = acpi_clear_gpe(handle, index);
+		else
+			all_counters[index].count = strtoul(buf, NULL, 0);
+	} else if (index < num_gpes + ACPI_NUM_FIXED_EVENTS) {
+		int event = index - num_gpes;
+		if (!strcmp(buf, "disable\n") &&
+		    (status & ACPI_EVENT_FLAG_ENABLED))
+			result = acpi_disable_event(event, ACPI_NOT_ISR);
+		else if (!strcmp(buf, "enable\n") &&
+			 !(status & ACPI_EVENT_FLAG_ENABLED))
+			result = acpi_enable_event(event, ACPI_NOT_ISR);
+		else if (!strcmp(buf, "clear\n") &&
+			 (status & ACPI_EVENT_FLAG_SET))
+			result = acpi_clear_event(event);
+		else
+			all_counters[index].count = strtoul(buf, NULL, 0);
+	} else
+		all_counters[index].count = strtoul(buf, NULL, 0);
+
+	if (ACPI_FAILURE(result))
+		result = -EINVAL;
+end:
+	return result ? result : size;
+}
+
+void acpi_irq_stats_init(void)
+{
+	int i;
+
+	if (all_counters)
+		return;
+
+	num_gpes = acpi_current_gpe_count;
+	num_counters = num_gpes + ACPI_NUM_FIXED_EVENTS + NUM_COUNTERS_EXTRA;
+
+	all_attrs = kzalloc(sizeof(struct attribute *) * (num_counters + 1),
+			    GFP_KERNEL);
+	if (all_attrs == NULL)
+		return;
+
+	all_counters = kzalloc(sizeof(struct event_counter) * (num_counters),
+			       GFP_KERNEL);
+	if (all_counters == NULL)
+		goto fail;
+
+	counter_attrs = kzalloc(sizeof(struct kobj_attribute) * (num_counters),
+				GFP_KERNEL);
+	if (counter_attrs == NULL)
+		goto fail;
+
+	for (i = 0; i < num_counters; ++i) {
+		char buffer[12];
+		char *name;
+
+		if (i < num_gpes)
+			sprintf(buffer, "gpe%02X", i);
+		else if (i == num_gpes + ACPI_EVENT_PMTIMER)
+			sprintf(buffer, "ff_pmtimer");
+		else if (i == num_gpes + ACPI_EVENT_GLOBAL)
+			sprintf(buffer, "ff_gbl_lock");
+		else if (i == num_gpes + ACPI_EVENT_POWER_BUTTON)
+			sprintf(buffer, "ff_pwr_btn");
+		else if (i == num_gpes + ACPI_EVENT_SLEEP_BUTTON)
+			sprintf(buffer, "ff_slp_btn");
+		else if (i == num_gpes + ACPI_EVENT_RTC)
+			sprintf(buffer, "ff_rt_clk");
+		else if (i == num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_GPE)
+			sprintf(buffer, "gpe_all");
+		else if (i == num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_SCI)
+			sprintf(buffer, "sci");
+		else if (i == num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_SCI_NOT)
+			sprintf(buffer, "sci_not");
+		else if (i == num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_ERROR)
+			sprintf(buffer, "error");
+		else
+			sprintf(buffer, "bug%02X", i);
+
+		name = kzalloc(strlen(buffer) + 1, GFP_KERNEL);
+		if (name == NULL)
+			goto fail;
+		strncpy(name, buffer, strlen(buffer) + 1);
+
+		sysfs_attr_init(&counter_attrs[i].attr);
+		counter_attrs[i].attr.name = name;
+		counter_attrs[i].attr.mode = 0644;
+		counter_attrs[i].show = counter_show;
+		counter_attrs[i].store = counter_set;
+
+		all_attrs[i] = &counter_attrs[i].attr;
+	}
+
+	interrupt_stats_attr_group.attrs = all_attrs;
+	if (!sysfs_create_group(acpi_kobj, &interrupt_stats_attr_group))
+		return;
+
+fail:
+	delete_gpe_attr_array();
+	return;
+}
+
+static void __exit interrupt_stats_exit(void)
+{
+	sysfs_remove_group(acpi_kobj, &interrupt_stats_attr_group);
+
+	delete_gpe_attr_array();
+
+	return;
+}
+
+int __init acpi_sysfs_init(void)
+{
+	int result;
+
+	result = acpi_tables_sysfs_init();
+
+	return result;
+}
