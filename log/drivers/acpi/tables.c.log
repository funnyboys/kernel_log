commit 88055d8f4a715d52b9b981f717e9e51cf4668d5d
Author: Cezary Rojewski <cezary.rojewski@intel.com>
Date:   Fri Mar 27 15:21:08 2020 -0700

    ACPICA: Add NHLT table signature
    
    ACPICA commit 422166b656565d180bb3aac712009bdce5e70cdd
    
    NHLT (Non-HDAudio Link Table) provides configuration of audio
    endpoints for Intel SST (Smart Sound Technology) DSP products.
    Similarly to other ACPI tables, data provided by BIOS may not
    describe it correctly, thus overriding is required.
    
    ACPI override mechanism checks for unknown signature before
    proceeding. Update known signatures array to support NHLT.
    
    Link: https://github.com/acpica/acpica/commit/422166b6
    Signed-off-by: Cezary Rojewski <cezary.rojewski@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Kaneda <erik.kaneda@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 180ac4329763..0e905c3d1645 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -501,7 +501,7 @@ static const char * const table_sigs[] = {
 	ACPI_SIG_WDDT, ACPI_SIG_WDRT, ACPI_SIG_DSDT, ACPI_SIG_FADT,
 	ACPI_SIG_PSDT, ACPI_SIG_RSDT, ACPI_SIG_XSDT, ACPI_SIG_SSDT,
 	ACPI_SIG_IORT, ACPI_SIG_NFIT, ACPI_SIG_HMAT, ACPI_SIG_PPTT,
-	NULL };
+	ACPI_SIG_NHLT, NULL };
 
 #define ACPI_HEADER_SIZE sizeof(struct acpi_table_header)
 

commit aefcf2f4b58155d27340ba5f9ddbe9513da8286d
Merge: f1f2f614d535 45893a0abee6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 28 08:14:15 2019 -0700

    Merge branch 'next-lockdown' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull kernel lockdown mode from James Morris:
     "This is the latest iteration of the kernel lockdown patchset, from
      Matthew Garrett, David Howells and others.
    
      From the original description:
    
        This patchset introduces an optional kernel lockdown feature,
        intended to strengthen the boundary between UID 0 and the kernel.
        When enabled, various pieces of kernel functionality are restricted.
        Applications that rely on low-level access to either hardware or the
        kernel may cease working as a result - therefore this should not be
        enabled without appropriate evaluation beforehand.
    
        The majority of mainstream distributions have been carrying variants
        of this patchset for many years now, so there's value in providing a
        doesn't meet every distribution requirement, but gets us much closer
        to not requiring external patches.
    
      There are two major changes since this was last proposed for mainline:
    
       - Separating lockdown from EFI secure boot. Background discussion is
         covered here: https://lwn.net/Articles/751061/
    
       -  Implementation as an LSM, with a default stackable lockdown LSM
          module. This allows the lockdown feature to be policy-driven,
          rather than encoding an implicit policy within the mechanism.
    
      The new locked_down LSM hook is provided to allow LSMs to make a
      policy decision around whether kernel functionality that would allow
      tampering with or examining the runtime state of the kernel should be
      permitted.
    
      The included lockdown LSM provides an implementation with a simple
      policy intended for general purpose use. This policy provides a coarse
      level of granularity, controllable via the kernel command line:
    
        lockdown={integrity|confidentiality}
    
      Enable the kernel lockdown feature. If set to integrity, kernel features
      that allow userland to modify the running kernel are disabled. If set to
      confidentiality, kernel features that allow userland to extract
      confidential information from the kernel are also disabled.
    
      This may also be controlled via /sys/kernel/security/lockdown and
      overriden by kernel configuration.
    
      New or existing LSMs may implement finer-grained controls of the
      lockdown features. Refer to the lockdown_reason documentation in
      include/linux/security.h for details.
    
      The lockdown feature has had signficant design feedback and review
      across many subsystems. This code has been in linux-next for some
      weeks, with a few fixes applied along the way.
    
      Stephen Rothwell noted that commit 9d1f8be5cf42 ("bpf: Restrict bpf
      when kernel lockdown is in confidentiality mode") is missing a
      Signed-off-by from its author. Matthew responded that he is providing
      this under category (c) of the DCO"
    
    * 'next-lockdown' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (31 commits)
      kexec: Fix file verification on S390
      security: constify some arrays in lockdown LSM
      lockdown: Print current->comm in restriction messages
      efi: Restrict efivar_ssdt_load when the kernel is locked down
      tracefs: Restrict tracefs when the kernel is locked down
      debugfs: Restrict debugfs when the kernel is locked down
      kexec: Allow kexec_file() with appropriate IMA policy when locked down
      lockdown: Lock down perf when in confidentiality mode
      bpf: Restrict bpf when kernel lockdown is in confidentiality mode
      lockdown: Lock down tracing and perf kprobes when in confidentiality mode
      lockdown: Lock down /proc/kcore
      x86/mmiotrace: Lock down the testmmiotrace module
      lockdown: Lock down module params that specify hardware parameters (eg. ioport)
      lockdown: Lock down TIOCSSERIAL
      lockdown: Prohibit PCMCIA CIS storage when the kernel is locked down
      acpi: Disable ACPI table override if the kernel is locked down
      acpi: Ignore acpi_rsdp kernel param when the kernel has been locked down
      ACPI: Limit access to custom_method when the kernel is locked down
      x86/msr: Restrict MSR access when the kernel is locked down
      x86: Lock down IO port access when the kernel is locked down
      ...

commit 6ea0e815fc5e18597724169caa6e4d46dd8e693d
Author: Linn Crosetto <lcrosetto@gmail.com>
Date:   Mon Aug 19 17:17:52 2019 -0700

    acpi: Disable ACPI table override if the kernel is locked down
    
    >From the kernel documentation (initrd_table_override.txt):
    
      If the ACPI_INITRD_TABLE_OVERRIDE compile option is true, it is possible
      to override nearly any ACPI table provided by the BIOS with an
      instrumented, modified one.
    
    When lockdown is enabled, the kernel should disallow any unauthenticated
    changes to kernel space.  ACPI tables contain code invoked by the kernel,
    so do not allow ACPI tables to be overridden if the kernel is locked down.
    
    Signed-off-by: Linn Crosetto <lcrosetto@gmail.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    cc: linux-acpi@vger.kernel.org
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index de974322a197..b7c29a11c0c1 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -20,6 +20,7 @@
 #include <linux/memblock.h>
 #include <linux/earlycpio.h>
 #include <linux/initrd.h>
+#include <linux/security.h>
 #include "internal.h"
 
 #ifdef CONFIG_ACPI_CUSTOM_DSDT
@@ -577,6 +578,11 @@ void __init acpi_table_upgrade(void)
 	if (table_nr == 0)
 		return;
 
+	if (security_locked_down(LOCKDOWN_ACPI_TABLES)) {
+		pr_notice("kernel is locked down, ignoring table override\n");
+		return;
+	}
+
 	acpi_tables_addr =
 		memblock_find_in_range(0, ACPI_TABLE_UPGRADE_MAX_PHYS,
 				       all_tables_size, PAGE_SIZE);

commit c78fea61f0c1f8568fbbb36ac3d1e1c85a903ae4
Author: Andrea Oliveri <oliveriandrea@gmail.com>
Date:   Mon Jun 10 14:45:41 2019 +0200

    ACPI: tables: Allow BGRT to be overridden
    
    Thinkpad T Series expose a malformed BGRT table with Version field set
    to 0. This fact prevents bootsplashes (as Plymouth) to correctly show
    the manufacturer logo. This patch permits to override malformed BGRT
    table with a correct one defined by the user.
    
    Signed-off-by: Andrea Oliveri <oliveriandrea@gmail.com>
    [ rjw: Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index de974322a197..b32327759380 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -490,16 +490,17 @@ static u8 __init acpi_table_checksum(u8 *buffer, u32 length)
 
 /* All but ACPI_SIG_RSDP and ACPI_SIG_FACS: */
 static const char * const table_sigs[] = {
-	ACPI_SIG_BERT, ACPI_SIG_CPEP, ACPI_SIG_ECDT, ACPI_SIG_EINJ,
-	ACPI_SIG_ERST, ACPI_SIG_HEST, ACPI_SIG_MADT, ACPI_SIG_MSCT,
-	ACPI_SIG_SBST, ACPI_SIG_SLIT, ACPI_SIG_SRAT, ACPI_SIG_ASF,
-	ACPI_SIG_BOOT, ACPI_SIG_DBGP, ACPI_SIG_DMAR, ACPI_SIG_HPET,
-	ACPI_SIG_IBFT, ACPI_SIG_IVRS, ACPI_SIG_MCFG, ACPI_SIG_MCHI,
-	ACPI_SIG_SLIC, ACPI_SIG_SPCR, ACPI_SIG_SPMI, ACPI_SIG_TCPA,
-	ACPI_SIG_UEFI, ACPI_SIG_WAET, ACPI_SIG_WDAT, ACPI_SIG_WDDT,
-	ACPI_SIG_WDRT, ACPI_SIG_DSDT, ACPI_SIG_FADT, ACPI_SIG_PSDT,
-	ACPI_SIG_RSDT, ACPI_SIG_XSDT, ACPI_SIG_SSDT, ACPI_SIG_IORT,
-	ACPI_SIG_NFIT, ACPI_SIG_HMAT, ACPI_SIG_PPTT, NULL };
+	ACPI_SIG_BERT, ACPI_SIG_BGRT, ACPI_SIG_CPEP, ACPI_SIG_ECDT,
+	ACPI_SIG_EINJ, ACPI_SIG_ERST, ACPI_SIG_HEST, ACPI_SIG_MADT,
+	ACPI_SIG_MSCT, ACPI_SIG_SBST, ACPI_SIG_SLIT, ACPI_SIG_SRAT,
+	ACPI_SIG_ASF,  ACPI_SIG_BOOT, ACPI_SIG_DBGP, ACPI_SIG_DMAR,
+	ACPI_SIG_HPET, ACPI_SIG_IBFT, ACPI_SIG_IVRS, ACPI_SIG_MCFG,
+	ACPI_SIG_MCHI, ACPI_SIG_SLIC, ACPI_SIG_SPCR, ACPI_SIG_SPMI,
+	ACPI_SIG_TCPA, ACPI_SIG_UEFI, ACPI_SIG_WAET, ACPI_SIG_WDAT,
+	ACPI_SIG_WDDT, ACPI_SIG_WDRT, ACPI_SIG_DSDT, ACPI_SIG_FADT,
+	ACPI_SIG_PSDT, ACPI_SIG_RSDT, ACPI_SIG_XSDT, ACPI_SIG_SSDT,
+	ACPI_SIG_IORT, ACPI_SIG_NFIT, ACPI_SIG_HMAT, ACPI_SIG_PPTT,
+	NULL };
 
 #define ACPI_HEADER_SIZE sizeof(struct acpi_table_header)
 

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 3b5d04fd5e3e..de974322a197 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -1,22 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  acpi_tables.c - ACPI Boot-Time Table Parsing
  *
  *  Copyright (C) 2001 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
  */
 
 /* Uncomment next line to get verbose printout */

commit cf482a49af564a3044de3178ea28f10ad5921b38
Merge: 01e5d1830cf5 70e16a620e07
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 13:01:40 2019 -0700

    Merge tag 'driver-core-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core/kobject updates from Greg KH:
     "Here is the "big" set of driver core patches for 5.2-rc1
    
      There are a number of ACPI patches in here as well, as Rafael said
      they should go through this tree due to the driver core changes they
      required. They have all been acked by the ACPI developers.
    
      There are also a number of small subsystem-specific changes in here,
      due to some changes to the kobject core code. Those too have all been
      acked by the various subsystem maintainers.
    
      As for content, it's pretty boring outside of the ACPI changes:
       - spdx cleanups
       - kobject documentation updates
       - default attribute groups for kobjects
       - other minor kobject/driver core fixes
    
      All have been in linux-next for a while with no reported issues"
    
    * tag 'driver-core-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (47 commits)
      kobject: clean up the kobject add documentation a bit more
      kobject: Fix kernel-doc comment first line
      kobject: Remove docstring reference to kset
      firmware_loader: Fix a typo ("syfs" -> "sysfs")
      kobject: fix dereference before null check on kobj
      Revert "driver core: platform: Fix the usage of platform device name(pdev->name)"
      init/config: Do not select BUILD_BIN2C for IKCONFIG
      Provide in-kernel headers to make extending kernel easier
      kobject: Improve doc clarity kobject_init_and_add()
      kobject: Improve docs for kobject_add/del
      driver core: platform: Fix the usage of platform device name(pdev->name)
      livepatch: Replace klp_ktype_patch's default_attrs with groups
      cpufreq: schedutil: Replace default_attrs field with groups
      padata: Replace padata_attr_type default_attrs field with groups
      irqdesc: Replace irq_kobj_type's default_attrs field with groups
      net-sysfs: Replace ktype default_attrs field with groups
      block: Replace all ktype default_attrs with groups
      samples/kobject: Replace foo_ktype's default_attrs field with groups
      kobject: Add support for default attribute groups to kobj_type
      driver core: Postpone DMA tear-down until after devres release for probe failure
      ...

commit 91751459ecad7c12ef20e839fcba2ee573c0c5d5
Merge: 317e2cac4551 5ceb5f0522bd 2e018c59fe8f b0f65b917987 fbc9418f099d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon May 6 10:49:39 2019 +0200

    Merge branches 'acpi-scan', 'acpi-tables', 'acpi-misc' and 'acpi-pm'
    
    * acpi-scan:
      ACPI / scan: Add labels for PNP button devices
      ACPI / scan: Simplify acpi_bus_extract_wakeup_device_power_package()
    
    * acpi-tables:
      ACPI / tables: Clean up whitespace
    
    * acpi-misc:
      ACPI / DPTF: Use dev_get_drvdata()
      ACPI: event: replace strcpy() by strscpy()
      ACPI: Fix comment typos
    
    * acpi-pm:
      ACPI: PM: Print debug messages when enabling GPEs for wakeup

commit 5599fb69355d7a558f32206dac7539e945a1f604
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Apr 8 13:42:24 2019 -0700

    ACPICA: Rename nameseg compare macro for clarity
    
    ACPICA commit 92ec0935f27e217dff0b176fca02c2ec3d782bb5
    
    ACPI_COMPARE_NAME changed to ACPI_COMPARE_NAMESEG
    This clarifies (1) this is a compare on 4-byte namesegs, not
    a generic compare. Improves understanding of the code.
    
    Link: https://github.com/acpica/acpica/commit/92ec0935
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 8fccbe49612a..1ffd7b9eefc5 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -670,8 +670,8 @@ static void __init acpi_table_initrd_scan(void)
 		table_length = table->length;
 
 		/* Skip RSDT/XSDT which should only be used for override */
-		if (ACPI_COMPARE_NAME(table->signature, ACPI_SIG_RSDT) ||
-		    ACPI_COMPARE_NAME(table->signature, ACPI_SIG_XSDT)) {
+		if (ACPI_COMPARE_NAMESEG(table->signature, ACPI_SIG_RSDT) ||
+		    ACPI_COMPARE_NAMESEG(table->signature, ACPI_SIG_XSDT)) {
 			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
 			goto next_table;
 		}

commit 3bc0e8eb179deebf1c06f5c4261d362c24b26ce1
Author: Keith Busch <keith.busch@intel.com>
Date:   Mon Mar 11 14:55:58 2019 -0600

    acpi: Add HMAT to generic parsing tables
    
    The Heterogeneous Memory Attribute Table (HMAT) header has different
    field lengths than the existing parsing uses. Add the HMAT type to the
    parsing rules so it may be generically parsed.
    
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Tested-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Tested-by: Brice Goglin <Brice.Goglin@inria.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 7553774a22b7..3d0da38f94c6 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -51,6 +51,7 @@ static int acpi_apic_instance __initdata;
 
 enum acpi_subtable_type {
 	ACPI_SUBTABLE_COMMON,
+	ACPI_SUBTABLE_HMAT,
 };
 
 struct acpi_subtable_entry {
@@ -232,6 +233,8 @@ acpi_get_entry_type(struct acpi_subtable_entry *entry)
 	switch (entry->type) {
 	case ACPI_SUBTABLE_COMMON:
 		return entry->hdr->common.type;
+	case ACPI_SUBTABLE_HMAT:
+		return entry->hdr->hmat.type;
 	}
 	return 0;
 }
@@ -242,6 +245,8 @@ acpi_get_entry_length(struct acpi_subtable_entry *entry)
 	switch (entry->type) {
 	case ACPI_SUBTABLE_COMMON:
 		return entry->hdr->common.length;
+	case ACPI_SUBTABLE_HMAT:
+		return entry->hdr->hmat.length;
 	}
 	return 0;
 }
@@ -252,6 +257,8 @@ acpi_get_subtable_header_length(struct acpi_subtable_entry *entry)
 	switch (entry->type) {
 	case ACPI_SUBTABLE_COMMON:
 		return sizeof(entry->hdr->common);
+	case ACPI_SUBTABLE_HMAT:
+		return sizeof(entry->hdr->hmat);
 	}
 	return 0;
 }
@@ -259,6 +266,8 @@ acpi_get_subtable_header_length(struct acpi_subtable_entry *entry)
 static enum acpi_subtable_type __init
 acpi_get_subtable_type(char *id)
 {
+	if (strncmp(id, ACPI_SIG_HMAT, 4) == 0)
+		return ACPI_SUBTABLE_HMAT;
 	return ACPI_SUBTABLE_COMMON;
 }
 

commit 60574d1e05b094d222162260dd9cac49f4d0996a
Author: Keith Busch <keith.busch@intel.com>
Date:   Mon Mar 11 14:55:57 2019 -0600

    acpi: Create subtable parsing infrastructure
    
    Parsing entries in an ACPI table had assumed a generic header
    structure. There is no standard ACPI header, though, so less common
    layouts with different field sizes required custom parsers to go through
    their subtable entry list.
    
    Create the infrastructure for adding different table types so parsing
    the entries array may be more reused for all ACPI system tables and
    the common code doesn't need to be duplicated.
    
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Tested-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Tested-by: Brice Goglin <Brice.Goglin@inria.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 8fccbe49612a..7553774a22b7 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -49,6 +49,15 @@ static struct acpi_table_desc initial_tables[ACPI_MAX_TABLES] __initdata;
 
 static int acpi_apic_instance __initdata;
 
+enum acpi_subtable_type {
+	ACPI_SUBTABLE_COMMON,
+};
+
+struct acpi_subtable_entry {
+	union acpi_subtable_headers *hdr;
+	enum acpi_subtable_type type;
+};
+
 /*
  * Disable table checksum verification for the early stage due to the size
  * limitation of the current x86 early mapping implementation.
@@ -217,6 +226,42 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 	}
 }
 
+static unsigned long __init
+acpi_get_entry_type(struct acpi_subtable_entry *entry)
+{
+	switch (entry->type) {
+	case ACPI_SUBTABLE_COMMON:
+		return entry->hdr->common.type;
+	}
+	return 0;
+}
+
+static unsigned long __init
+acpi_get_entry_length(struct acpi_subtable_entry *entry)
+{
+	switch (entry->type) {
+	case ACPI_SUBTABLE_COMMON:
+		return entry->hdr->common.length;
+	}
+	return 0;
+}
+
+static unsigned long __init
+acpi_get_subtable_header_length(struct acpi_subtable_entry *entry)
+{
+	switch (entry->type) {
+	case ACPI_SUBTABLE_COMMON:
+		return sizeof(entry->hdr->common);
+	}
+	return 0;
+}
+
+static enum acpi_subtable_type __init
+acpi_get_subtable_type(char *id)
+{
+	return ACPI_SUBTABLE_COMMON;
+}
+
 /**
  * acpi_parse_entries_array - for each proc_num find a suitable subtable
  *
@@ -246,8 +291,8 @@ acpi_parse_entries_array(char *id, unsigned long table_size,
 		struct acpi_subtable_proc *proc, int proc_num,
 		unsigned int max_entries)
 {
-	struct acpi_subtable_header *entry;
-	unsigned long table_end;
+	struct acpi_subtable_entry entry;
+	unsigned long table_end, subtable_len, entry_len;
 	int count = 0;
 	int errs = 0;
 	int i;
@@ -270,19 +315,20 @@ acpi_parse_entries_array(char *id, unsigned long table_size,
 
 	/* Parse all entries looking for a match. */
 
-	entry = (struct acpi_subtable_header *)
+	entry.type = acpi_get_subtable_type(id);
+	entry.hdr = (union acpi_subtable_headers *)
 	    ((unsigned long)table_header + table_size);
+	subtable_len = acpi_get_subtable_header_length(&entry);
 
-	while (((unsigned long)entry) + sizeof(struct acpi_subtable_header) <
-	       table_end) {
+	while (((unsigned long)entry.hdr) + subtable_len  < table_end) {
 		if (max_entries && count >= max_entries)
 			break;
 
 		for (i = 0; i < proc_num; i++) {
-			if (entry->type != proc[i].id)
+			if (acpi_get_entry_type(&entry) != proc[i].id)
 				continue;
 			if (!proc[i].handler ||
-			     (!errs && proc[i].handler(entry, table_end))) {
+			     (!errs && proc[i].handler(entry.hdr, table_end))) {
 				errs++;
 				continue;
 			}
@@ -297,13 +343,14 @@ acpi_parse_entries_array(char *id, unsigned long table_size,
 		 * If entry->length is 0, break from this loop to avoid
 		 * infinite loop.
 		 */
-		if (entry->length == 0) {
+		entry_len = acpi_get_entry_length(&entry);
+		if (entry_len == 0) {
 			pr_err("[%4.4s:0x%02x] Invalid zero length\n", id, proc->id);
 			return -EINVAL;
 		}
 
-		entry = (struct acpi_subtable_header *)
-		    ((unsigned long)entry + entry->length);
+		entry.hdr = (union acpi_subtable_headers *)
+		    ((unsigned long)entry.hdr + entry_len);
 	}
 
 	if (max_entries && count > max_entries) {

commit 2e018c59fe8fbc4ae1a8db1523ea0f6159f48b4b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Mar 25 13:34:01 2019 -0500

    ACPI / tables: Clean up whitespace
    
    Cleanup some whitespace to match the rest of the file.  No functional
    change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 8fccbe49612a..4672f9ef183a 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -240,8 +240,7 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
  * On success returns sum of all matching entries for all proc handlers.
  * Otherwise, -ENODEV or -EINVAL is returned.
  */
-static int __init
-acpi_parse_entries_array(char *id, unsigned long table_size,
+static int __init acpi_parse_entries_array(char *id, unsigned long table_size,
 		struct acpi_table_header *table_header,
 		struct acpi_subtable_proc *proc, int proc_num,
 		unsigned int max_entries)
@@ -314,8 +313,7 @@ acpi_parse_entries_array(char *id, unsigned long table_size,
 	return errs ? -EINVAL : count;
 }
 
-int __init
-acpi_table_parse_entries_array(char *id,
+int __init acpi_table_parse_entries_array(char *id,
 			 unsigned long table_size,
 			 struct acpi_subtable_proc *proc, int proc_num,
 			 unsigned int max_entries)
@@ -346,8 +344,7 @@ acpi_table_parse_entries_array(char *id,
 	return count;
 }
 
-int __init
-acpi_table_parse_entries(char *id,
+int __init acpi_table_parse_entries(char *id,
 			unsigned long table_size,
 			int entry_id,
 			acpi_tbl_entry_handler handler,
@@ -362,8 +359,7 @@ acpi_table_parse_entries(char *id,
 						max_entries);
 }
 
-int __init
-acpi_table_parse_madt(enum acpi_madt_type id,
+int __init acpi_table_parse_madt(enum acpi_madt_type id,
 		      acpi_tbl_entry_handler handler, unsigned int max_entries)
 {
 	return acpi_table_parse_entries(ACPI_SIG_MADT,
@@ -725,8 +721,7 @@ static void *amlcode __attribute__ ((weakref("AmlCode")));
 static void *dsdt_amlcode __attribute__ ((weakref("dsdt_aml_code")));
 #endif
 
-acpi_status
-acpi_os_table_override(struct acpi_table_header *existing_table,
+acpi_status acpi_os_table_override(struct acpi_table_header *existing_table,
 		       struct acpi_table_header **new_table)
 {
 	if (!existing_table || !new_table)
@@ -788,7 +783,6 @@ static int __init acpi_parse_apic_instance(char *str)
 
 	return 0;
 }
-
 early_param("acpi_apic_instance", acpi_parse_apic_instance);
 
 static int __init acpi_force_table_verification_setup(char *s)
@@ -797,7 +791,6 @@ static int __init acpi_force_table_verification_setup(char *s)
 
 	return 0;
 }
-
 early_param("acpi_force_table_verification", acpi_force_table_verification_setup);
 
 static int __init acpi_force_32bit_fadt_addr(char *s)
@@ -807,5 +800,4 @@ static int __init acpi_force_32bit_fadt_addr(char *s)
 
 	return 0;
 }
-
 early_param("acpi_force_32bit_fadt_addr", acpi_force_32bit_fadt_addr);

commit 98a455d91e7116ca417bc37da6aa2dd633206a6f
Author: Shunyong Yang <shunyong.yang@hxt-semitech.com>
Date:   Tue Dec 18 14:02:45 2018 +0800

    ACPI / tables: table override from built-in initrd
    
    In some scenario, we need to build initrd with kernel in a single image.
    This can simplify system deployment process by downloading the whole system
    once, such as in IC verification.
    
    This patch adds support to override ACPI tables from built-in initrd.
    
    Signed-off-by: Shunyong Yang <shunyong.yang@hxt-semitech.com>
    [ rjw: Minor cleanups ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 48eabb6c2d4f..8fccbe49612a 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -473,14 +473,22 @@ static DECLARE_BITMAP(acpi_initrd_installed, NR_ACPI_INITRD_TABLES);
 
 void __init acpi_table_upgrade(void)
 {
-	void *data = (void *)initrd_start;
-	size_t size = initrd_end - initrd_start;
+	void *data;
+	size_t size;
 	int sig, no, table_nr = 0, total_offset = 0;
 	long offset = 0;
 	struct acpi_table_header *table;
 	char cpio_path[32] = "kernel/firmware/acpi/";
 	struct cpio_data file;
 
+	if (IS_ENABLED(CONFIG_ACPI_TABLE_OVERRIDE_VIA_BUILTIN_INITRD)) {
+		data = __initramfs_start;
+		size = __initramfs_size;
+	} else {
+		data = (void *)initrd_start;
+		size = initrd_end - initrd_start;
+	}
+
 	if (data == NULL || size == 0)
 		return;
 

commit 1f000e1bfff42e960e5d4562213a95016acc712f
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Thu Dec 20 12:38:56 2018 -0700

    ACPI / tables: Add an ifdef around amlcode and dsdt_amlcode
    
    Clang warns:
    
    drivers/acpi/tables.c:715:14: warning: unused variable 'amlcode'
    [-Wunused-variable]
    static void *amlcode __attribute__ ((weakref("AmlCode")));
                 ^
    drivers/acpi/tables.c:716:14: warning: unused variable 'dsdt_amlcode'
    [-Wunused-variable]
    static void *dsdt_amlcode __attribute__ ((weakref("dsdt_aml_code")));
                 ^
    2 warnings generated.
    
    The only uses of these variables are hiddem behind CONFIG_ACPI_CUSTOM_DSDT
    so do the same thing here.
    
    Fixes: 82e4eb4e9653 (ACPI / tables: add DSDT AmlCode new declaration name support)
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index ccb90eff00e5..48eabb6c2d4f 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -712,8 +712,10 @@ acpi_os_physical_table_override(struct acpi_table_header *existing_table,
 					  table_length);
 }
 
+#ifdef CONFIG_ACPI_CUSTOM_DSDT
 static void *amlcode __attribute__ ((weakref("AmlCode")));
 static void *dsdt_amlcode __attribute__ ((weakref("dsdt_aml_code")));
+#endif
 
 acpi_status
 acpi_os_table_override(struct acpi_table_header *existing_table,

commit 82e4eb4e96539c76518425a5b5a6c56fa400bce3
Author: Wang Dongsheng <dongsheng.wang@hxt-semitech.com>
Date:   Tue Nov 13 18:46:23 2018 +0800

    ACPI / tables: add DSDT AmlCode new declaration name support
    
    A new naming rule was added in ACPICA version 20180427 changing
    the DSDT AML code name from "AmlCode" to "dsdt_aml_code".
    
    That change was made by commit 83b2fa943ba8 "ACPICA: iASL: Enhance
    the -tc option (create AML hex file in C)".
    
    Tested:
    ACPICA release version 20180427+.
    ARM64: QCOM QDF2400
    GCC: 4.8.5 20150623
    
    Signed-off-by: Wang Dongsheng <dongsheng.wang@hxt-semitech.com>
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 61203eebf3a1..ccb90eff00e5 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -712,6 +712,9 @@ acpi_os_physical_table_override(struct acpi_table_header *existing_table,
 					  table_length);
 }
 
+static void *amlcode __attribute__ ((weakref("AmlCode")));
+static void *dsdt_amlcode __attribute__ ((weakref("dsdt_aml_code")));
+
 acpi_status
 acpi_os_table_override(struct acpi_table_header *existing_table,
 		       struct acpi_table_header **new_table)
@@ -722,8 +725,11 @@ acpi_os_table_override(struct acpi_table_header *existing_table,
 	*new_table = NULL;
 
 #ifdef CONFIG_ACPI_CUSTOM_DSDT
-	if (strncmp(existing_table->signature, "DSDT", 4) == 0)
-		*new_table = (struct acpi_table_header *)AmlCode;
+	if (!strncmp(existing_table->signature, "DSDT", 4)) {
+		*new_table = (struct acpi_table_header *)&amlcode;
+		if (!(*new_table))
+			*new_table = (struct acpi_table_header *)&dsdt_amlcode;
+	}
 #endif
 	if (*new_table != NULL)
 		acpi_table_taint(existing_table);

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index a3d012b08fc5..61203eebf3a1 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -31,9 +31,8 @@
 #include <linux/irq.h>
 #include <linux/errno.h>
 #include <linux/acpi.h>
-#include <linux/bootmem.h>
-#include <linux/earlycpio.h>
 #include <linux/memblock.h>
+#include <linux/earlycpio.h>
 #include <linux/initrd.h>
 #include "internal.h"
 

commit 410feb75de245664d66bc05ab2e2412751d10acf
Merge: 2996148a9d41 0fe42512b2f0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 8 11:10:58 2018 -0700

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Catalin Marinas:
     "Apart from the core arm64 and perf changes, the Spectre v4 mitigation
      touches the arm KVM code and the ACPI PPTT support touches drivers/
      (acpi and cacheinfo). I should have the maintainers' acks in place.
    
      Summary:
    
       - Spectre v4 mitigation (Speculative Store Bypass Disable) support
         for arm64 using SMC firmware call to set a hardware chicken bit
    
       - ACPI PPTT (Processor Properties Topology Table) parsing support and
         enable the feature for arm64
    
       - Report signal frame size to user via auxv (AT_MINSIGSTKSZ). The
         primary motivation is Scalable Vector Extensions which requires
         more space on the signal frame than the currently defined
         MINSIGSTKSZ
    
       - ARM perf patches: allow building arm-cci as module, demote
         dev_warn() to dev_dbg() in arm-ccn event_init(), miscellaneous
         cleanups
    
       - cmpwait() WFE optimisation to avoid some spurious wakeups
    
       - L1_CACHE_BYTES reverted back to 64 (for performance reasons that
         have to do with some network allocations) while keeping
         ARCH_DMA_MINALIGN to 128. cache_line_size() returns the actual
         hardware Cache Writeback Granule
    
       - Turn LSE atomics on by default in Kconfig
    
       - Kernel fault reporting tidying
    
       - Some #include and miscellaneous cleanups"
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (53 commits)
      arm64: Fix syscall restarting around signal suppressed by tracer
      arm64: topology: Avoid checking numa mask for scheduler MC selection
      ACPI / PPTT: fix build when CONFIG_ACPI_PPTT is not enabled
      arm64: cpu_errata: include required headers
      arm64: KVM: Move VCPU_WORKAROUND_2_FLAG macros to the top of the file
      arm64: signal: Report signal frame size to userspace via auxv
      arm64/sve: Thin out initialisation sanity-checks for sve_max_vl
      arm64: KVM: Add ARCH_WORKAROUND_2 discovery through ARCH_FEATURES_FUNC_ID
      arm64: KVM: Handle guest's ARCH_WORKAROUND_2 requests
      arm64: KVM: Add ARCH_WORKAROUND_2 support for guests
      arm64: KVM: Add HYP per-cpu accessors
      arm64: ssbd: Add prctl interface for per-thread mitigation
      arm64: ssbd: Introduce thread flag to control userspace mitigation
      arm64: ssbd: Restore mitigation status on CPU resume
      arm64: ssbd: Skip apply_ssbd if not using dynamic mitigation
      arm64: ssbd: Add global mitigation state accessor
      arm64: Add 'ssbd' command-line option
      arm64: Add ARCH_WORKAROUND_2 probing
      arm64: Add per-cpu infrastructure to call ARCH_WORKAROUND_2
      arm64: Call ARCH_WORKAROUND_2 on transitions between EL0 and EL1
      ...

commit bce1a65172d1172a8ec26c8251b9a4a97a3cae23
Author: Jeremy Linton <jeremy.linton@arm.com>
Date:   Fri May 11 18:58:06 2018 -0500

    ACPI: Add PPTT to injectable table list
    
    Add ACPI_SIG_PPTT to the table so initrd's can override the
    system topology.
    
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Tested-by: Vijaya Kumar K <vkilari@codeaurora.org>
    Tested-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Tested-by: Tomasz Nowicki <Tomasz.Nowicki@cavium.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Geoffrey Blake <geoffrey.blake@arm.com>
    Signed-off-by: Jeremy Linton <jeremy.linton@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 849c4fb19b03..30d93bf7c6a2 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -457,7 +457,7 @@ static const char * const table_sigs[] = {
 	ACPI_SIG_UEFI, ACPI_SIG_WAET, ACPI_SIG_WDAT, ACPI_SIG_WDDT,
 	ACPI_SIG_WDRT, ACPI_SIG_DSDT, ACPI_SIG_FADT, ACPI_SIG_PSDT,
 	ACPI_SIG_RSDT, ACPI_SIG_XSDT, ACPI_SIG_SSDT, ACPI_SIG_IORT,
-	ACPI_SIG_NFIT, ACPI_SIG_HMAT, NULL };
+	ACPI_SIG_NFIT, ACPI_SIG_HMAT, ACPI_SIG_PPTT, NULL };
 
 #define ACPI_HEADER_SIZE sizeof(struct acpi_table_header)
 

commit 904aaf8050439510fb48cafb26a91034b0e7e615
Author: Al Stone <ahs3@redhat.com>
Date:   Mon Apr 30 18:39:05 2018 -0600

    ACPI / tables: improve comments regarding acpi_parse_entries_array()
    
    I found the description of the table_size argument to the function
    acpi_parse_entries_array() unclear and ambiguous.  This is a minor
    documentation change to improve that description so I don't misuse
    the argument again in the future, and it is hopefully clearer to
    other future users.
    
    Signed-off-by: Al Stone <ahs3@redhat.com>
    [ rjw: Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 849c4fb19b03..4a3410aa6540 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -222,7 +222,7 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
  * acpi_parse_entries_array - for each proc_num find a suitable subtable
  *
  * @id: table id (for debugging purposes)
- * @table_size: single entry size
+ * @table_size: size of the root table
  * @table_header: where does the table start?
  * @proc: array of acpi_subtable_proc struct containing entry id
  *        and associated handler with it
@@ -233,6 +233,11 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
  * on it. Assumption is that there's only single handler for particular
  * entry id.
  *
+ * The table_size is not the size of the complete ACPI table (the length
+ * field in the header struct), but only the size of the root table; i.e.,
+ * the offset from the very first byte of the complete ACPI table, to the
+ * first byte of the very first subtable.
+ *
  * On success returns sum of all matching entries for all proc handlers.
  * Otherwise, -ENODEV or -EINVAL is returned.
  */
@@ -400,7 +405,7 @@ int __init acpi_table_parse(char *id, acpi_tbl_table_handler handler)
 		return -ENODEV;
 }
 
-/* 
+/*
  * The BIOS is supposed to supply a single APIC/MADT,
  * but some report two.  Provide a knob to use either.
  * (don't you wish instance 0 and 1 were not the same?)

commit 24bada7991d9f1d412f9bfca36716e8457cb4f90
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Dec 8 08:29:25 2017 -0800

    ACPI: add NFIT and HMAT to the initrd override list
    
    These tables, NFIT and HMAT, are essential for describing
    next-generation platform memory topologies and performance
    characteristics. Allow them to be overridden for debug and test and
    purposes.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 7bcb66ccccf3..849c4fb19b03 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -457,7 +457,7 @@ static const char * const table_sigs[] = {
 	ACPI_SIG_UEFI, ACPI_SIG_WAET, ACPI_SIG_WDAT, ACPI_SIG_WDDT,
 	ACPI_SIG_WDRT, ACPI_SIG_DSDT, ACPI_SIG_FADT, ACPI_SIG_PSDT,
 	ACPI_SIG_RSDT, ACPI_SIG_XSDT, ACPI_SIG_SSDT, ACPI_SIG_IORT,
-	NULL };
+	ACPI_SIG_NFIT, ACPI_SIG_HMAT, NULL };
 
 #define ACPI_HEADER_SIZE sizeof(struct acpi_table_header)
 

commit 890674343bb2d546825f713542b1e199f0728732
Author: Shunyong Yang <shunyong.yang@hxt-semitech.com>
Date:   Tue Feb 6 14:37:12 2018 +0800

    ACPI / tables: Add IORT to injectable table list
    
    Loading IORT table from initrd can be used to fix severe firmware
    IORT defects temporarily before platform/BIOS vendor releases an
    upgraded BIOS binary.
    
    Moreover, it is very powerful to debug SMMU node/device probe, MSI
    allocation, stream id translation and IORT table from firmware.
    
    It is also very useful to enable SMMU and devices behind SMMU before
    firmware is ready.
    
    This patch adds ACPI_SIG_IORT to the table, which enables IORT
    from initrd to override which from firmware.
    
    Signed-off-by: Yang Shunyong <shunyong.yang@hxt-semitech.com>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 80ce2a7d224b..7bcb66ccccf3 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -456,7 +456,8 @@ static const char * const table_sigs[] = {
 	ACPI_SIG_SLIC, ACPI_SIG_SPCR, ACPI_SIG_SPMI, ACPI_SIG_TCPA,
 	ACPI_SIG_UEFI, ACPI_SIG_WAET, ACPI_SIG_WDAT, ACPI_SIG_WDDT,
 	ACPI_SIG_WDRT, ACPI_SIG_DSDT, ACPI_SIG_FADT, ACPI_SIG_PSDT,
-	ACPI_SIG_RSDT, ACPI_SIG_XSDT, ACPI_SIG_SSDT, NULL };
+	ACPI_SIG_RSDT, ACPI_SIG_XSDT, ACPI_SIG_SSDT, ACPI_SIG_IORT,
+	NULL };
 
 #define ACPI_HEADER_SIZE sizeof(struct acpi_table_header)
 

commit 023e2ee16c51da7f6a9455ac936e4fb00295f47a
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Jul 10 15:23:45 2017 +0800

    ACPICA: Tables: Change table duplication check to be related to acpi_gbl_verify_table_checksum
    
    ACPICA commit 3d837b5d4b1033942b4d91c7d3801a09c3157918
    
    acpi_gbl_verify_table_checksum is used to avoid validating (mapping) an entire
    table in OS boot stage. 2nd "Reload" check in acpi_tb_install_standard_table()
    is prepared for the same purpose. So this patch combines them together
    using a renamed acpi_gbl_enable_table_validation flag. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/3d837b5d
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index ff425390bfa8..80ce2a7d224b 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -740,10 +740,10 @@ int __init acpi_table_init(void)
 
 	if (acpi_verify_table_checksum) {
 		pr_info("Early table checksum verification enabled\n");
-		acpi_gbl_verify_table_checksum = TRUE;
+		acpi_gbl_enable_table_validation = TRUE;
 	} else {
 		pr_info("Early table checksum verification disabled\n");
-		acpi_gbl_verify_table_checksum = FALSE;
+		acpi_gbl_enable_table_validation = FALSE;
 	}
 
 	status = acpi_initialize_tables(initial_tables, ACPI_MAX_TABLES, 0);

commit 16b76293c5c81e6345323d7aef41b26e8390f62d
Merge: 3dee9fb2a4ce da63b6b20077
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 1 20:51:12 2017 -0700

    Merge branch 'x86-boot-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 boot updates from Ingo Molnar:
     "The biggest changes in this cycle were:
    
       - reworking of the e820 code: separate in-kernel and boot-ABI data
         structures and apply a whole range of cleanups to the kernel side.
    
         No change in functionality.
    
       - enable KASLR by default: it's used by all major distros and it's
         out of the experimental stage as well.
    
       - ... misc fixes and cleanups"
    
    * 'x86-boot-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (63 commits)
      x86/KASLR: Fix kexec kernel boot crash when KASLR randomization fails
      x86/reboot: Turn off KVM when halting a CPU
      x86/boot: Fix BSS corruption/overwrite bug in early x86 kernel startup
      x86: Enable KASLR by default
      boot/param: Move next_arg() function to lib/cmdline.c for later reuse
      x86/boot: Fix Sparse warning by including required header file
      x86/boot/64: Rename start_cpu()
      x86/xen: Update e820 table handling to the new core x86 E820 code
      x86/boot: Fix pr_debug() API braindamage
      xen, x86/headers: Add <linux/device.h> dependency to <asm/xen/page.h>
      x86/boot/e820: Simplify e820__update_table()
      x86/boot/e820: Separate the E820 ABI structures from the in-kernel structures
      x86/boot/e820: Fix and clean up e820_type switch() statements
      x86/boot/e820: Rename the remaining E820 APIs to the e820__*() prefix
      x86/boot/e820: Remove unnecessary #include's
      x86/boot/e820: Rename e820_mark_nosave_regions() to e820__register_nosave_regions()
      x86/boot/e820: Rename e820_reserve_resources*() to e820__reserve_resources*()
      x86/boot/e820: Use bool in query APIs
      x86/boot/e820: Document e820__reserve_setup_data()
      x86/boot/e820: Clean up __e820__update_table() et al
      ...

commit f49c3f90a31f6e19ef3343dcc8809dac1019b59e
Author: Baoquan He <bhe@redhat.com>
Date:   Fri Apr 7 16:22:47 2017 +0800

    ACPI / tables: Drop acpi_parse_entries() which is not used
    
    Function acpi_parse_entries() is not used any more and if necessary,
    acpi_table_parse_entries() can be used instead of it, so drop it.
    
    Signed-off-by: Baoquan He <bhe@redhat.com>
    [ rjw: Subject / changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 2604189d6cd1..0dae722ab2ec 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -310,22 +310,6 @@ acpi_parse_entries_array(char *id, unsigned long table_size,
 	return errs ? -EINVAL : count;
 }
 
-int __init
-acpi_parse_entries(char *id,
-			unsigned long table_size,
-			acpi_tbl_entry_handler handler,
-			struct acpi_table_header *table_header,
-			int entry_id, unsigned int max_entries)
-{
-	struct acpi_subtable_proc proc = {
-		.id		= entry_id,
-		.handler	= handler,
-	};
-
-	return acpi_parse_entries_array(id, table_size, table_header,
-			&proc, 1, max_entries);
-}
-
 int __init
 acpi_table_parse_entries_array(char *id,
 			 unsigned long table_size,

commit ab6bc04cfdbd5da00a85909c054770a606e7c804
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jan 28 14:19:36 2017 +0100

    x86/boot/e820: Create coherent API function names for E820 range operations
    
    We have these three related functions:
    
     extern void e820_add_region(u64 start, u64 size, int type);
     extern u64  e820_update_range(u64 start, u64 size, unsigned old_type, unsigned new_type);
     extern u64  e820_remove_range(u64 start, u64 size, unsigned old_type, int checktype);
    
    But it's not clear from the naming that they are 3 operations based around the
    same 'memory range' concept. Rename them to better signal this, and move
    the prototypes next to each other:
    
     extern void e820__range_add   (u64 start, u64 size, int type);
     extern u64  e820__range_update(u64 start, u64 size, unsigned old_type, unsigned new_type);
     extern u64  e820__range_remove(u64 start, u64 size, unsigned old_type, int checktype);
    
    Note that this improved organization of the functions shows another problem that was easy
    to miss before: sometimes the E820 entry type is 'int', sometimes 'unsigned int' - but this
    will be fixed in a separate patch.
    
    No change in functionality.
    
    Cc: Alex Thorlton <athorlton@sgi.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Jackson <pj@sgi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 2604189d6cd1..9b9ac04593fb 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -556,7 +556,7 @@ void __init acpi_table_upgrade(void)
 	 * But it's not enough on X86 because ioremap will
 	 * complain later (used by acpi_os_map_memory) that the pages
 	 * that should get mapped are not marked "reserved".
-	 * Both memblock_reserve and e820_add_region (via arch_reserve_mem_area)
+	 * Both memblock_reserve and e820__range_add (via arch_reserve_mem_area)
 	 * works fine.
 	 */
 	memblock_reserve(acpi_tables_addr, all_tables_size);

commit 6b11d1d677132816252004426ef220ccd3c92d2f
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Dec 14 15:04:39 2016 +0800

    ACPI / osl: Remove acpi_get_table_with_size()/early_acpi_os_unmap_memory() users
    
    This patch removes the users of the deprectated APIs:
     acpi_get_table_with_size()
     early_acpi_os_unmap_memory()
    The following APIs should be used instead of:
     acpi_get_table()
     acpi_put_table()
    
    The deprecated APIs are invented to be a replacement of acpi_get_table()
    during the early stage so that the early mapped pointer will not be stored
    in ACPICA core and thus the late stage acpi_get_table() won't return a
    wrong pointer. The mapping size is returned just because it is required by
    early_acpi_os_unmap_memory() to unmap the pointer during early stage.
    
    But as the mapping size equals to the acpi_table_header.length
    (see acpi_tb_init_table_descriptor() and acpi_tb_validate_table()), when
    such a convenient result is returned, driver code will start to use it
    instead of accessing acpi_table_header to obtain the length.
    
    Thus this patch cleans up the drivers by replacing returned table size with
    acpi_table_header.length, and should be a no-op.
    
    Reported-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index cdd56c4657e0..2604189d6cd1 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -333,7 +333,6 @@ acpi_table_parse_entries_array(char *id,
 			 unsigned int max_entries)
 {
 	struct acpi_table_header *table_header = NULL;
-	acpi_size tbl_size;
 	int count;
 	u32 instance = 0;
 
@@ -346,7 +345,7 @@ acpi_table_parse_entries_array(char *id,
 	if (!strncmp(id, ACPI_SIG_MADT, 4))
 		instance = acpi_apic_instance;
 
-	acpi_get_table_with_size(id, instance, &table_header, &tbl_size);
+	acpi_get_table(id, instance, &table_header);
 	if (!table_header) {
 		pr_warn("%4.4s not present\n", id);
 		return -ENODEV;
@@ -355,7 +354,7 @@ acpi_table_parse_entries_array(char *id,
 	count = acpi_parse_entries_array(id, table_size, table_header,
 			proc, proc_num, max_entries);
 
-	early_acpi_os_unmap_memory((char *)table_header, tbl_size);
+	acpi_put_table(table_header);
 	return count;
 }
 
@@ -397,7 +396,6 @@ acpi_table_parse_madt(enum acpi_madt_type id,
 int __init acpi_table_parse(char *id, acpi_tbl_table_handler handler)
 {
 	struct acpi_table_header *table = NULL;
-	acpi_size tbl_size;
 
 	if (acpi_disabled)
 		return -ENODEV;
@@ -406,13 +404,13 @@ int __init acpi_table_parse(char *id, acpi_tbl_table_handler handler)
 		return -EINVAL;
 
 	if (strncmp(id, ACPI_SIG_MADT, 4) == 0)
-		acpi_get_table_with_size(id, acpi_apic_instance, &table, &tbl_size);
+		acpi_get_table(id, acpi_apic_instance, &table);
 	else
-		acpi_get_table_with_size(id, 0, &table, &tbl_size);
+		acpi_get_table(id, 0, &table);
 
 	if (table) {
 		handler(table);
-		early_acpi_os_unmap_memory(table, tbl_size);
+		acpi_put_table(table);
 		return 0;
 	} else
 		return -ENODEV;
@@ -426,16 +424,15 @@ int __init acpi_table_parse(char *id, acpi_tbl_table_handler handler)
 static void __init check_multiple_madt(void)
 {
 	struct acpi_table_header *table = NULL;
-	acpi_size tbl_size;
 
-	acpi_get_table_with_size(ACPI_SIG_MADT, 2, &table, &tbl_size);
+	acpi_get_table(ACPI_SIG_MADT, 2, &table);
 	if (table) {
 		pr_warn("BIOS bug: multiple APIC/MADT found, using %d\n",
 			acpi_apic_instance);
 		pr_warn("If \"acpi_apic_instance=%d\" works better, "
 			"notify linux-acpi@vger.kernel.org\n",
 			acpi_apic_instance ? 0 : 2);
-		early_acpi_os_unmap_memory(table, tbl_size);
+		acpi_put_table(table);
 
 	} else
 		acpi_apic_instance = 0;

commit ffcbed8418f8d850f27372d5f9b69aa05fd12217
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Thu Sep 8 15:55:41 2016 +0000

    ACPI / tables: Remove duplicated include from tables.c
    
    Remove duplicated include.
    
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 4dfbf491b6e3..cdd56c4657e0 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -35,7 +35,6 @@
 #include <linux/earlycpio.h>
 #include <linux/memblock.h>
 #include <linux/initrd.h>
-#include <linux/acpi.h>
 #include "internal.h"
 
 #ifdef CONFIG_ACPI_CUSTOM_DSDT

commit 99b0efd7c886f4c985cb2727a86548413922cbe2
Author: Al Stone <ahs3@redhat.com>
Date:   Fri Aug 19 18:48:13 2016 -0600

    ACPI / tables: do not report the number of entries ignored by acpi_parse_entries()
    
    The function acpi_parse_entries_array() has a limiting parameter,
    max_entries, which tells the function to stop looking at subtables
    once that limit has been reached.  If the limit is reached, it is
    reported.  However, the logic is incorrect in that the loop to
    examine all subtables will always report that zero subtables have
    been ignored since it does not continue once the max_entries have
    been reached.
    
    One approach to fixing this would be to correct the logic so that
    all subtables are examined, even if we have hit the max_entries, but
    without executing all the callback functions.  This could be risky
    since we cannot guarantee that no callback will ever have side effects
    that another callback depends on to work correctly.
    
    So, the simplest approach is to just remove the part of the error
    message that will always be incorrect.
    
    Signed-off-by: Al Stone <ahs3@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index b7dac30adf0c..4dfbf491b6e3 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -304,8 +304,8 @@ acpi_parse_entries_array(char *id, unsigned long table_size,
 	}
 
 	if (max_entries && count > max_entries) {
-		pr_warn("[%4.4s:0x%02x] ignored %i entries of %i found\n",
-			id, proc->id, count - max_entries, count);
+		pr_warn("[%4.4s:0x%02x] found the maximum %i entries\n",
+			id, proc->id, count);
 	}
 
 	return errs ? -EINVAL : count;

commit 8726d4f441505def8a488d50e50568403f6ad191
Author: Al Stone <ahs3@redhat.com>
Date:   Fri Aug 19 18:48:12 2016 -0600

    ACPI / tables: fix acpi_parse_entries_array() so it traverses all subtables
    
    The acpi_parse_entries_array() function currently returns the very first
    time there is any error found by one of the callback functions, or if one
    of the callbacks returns a non-zero value.  However, the ACPI subtables
    being traversed could still have valid entries that could be used by one
    of the callback functions.  And, if the comments are correct, that is
    what should happen -- always traverse all of the subtables, calling as
    many of the callbacks as possible.
    
    This patch makes the function consistent with its description so that it
    will properly invoke all callbacks for all matching entries, for all
    subtables, instead of stopping abruptly as it does today.
    
    This does change the semantics of using acpi_parse_entries_array().  In
    examining all users of the function, none of them rely on the current
    behavior; that is, there appears to be no assumption that either all
    subtables are traversed and all callbacks invoked, or that the function
    will return immediately on any error from a callback.  Each callback
    operates independently.  Hence, there should be no functional change
    due to this change in semantics.
    
    Future patches being prepared will rely on this new behavior; indeed,
    they were written assuming the acpi_parse_entries_array() function
    operated as its comments describe.  For example, a callback that
    counts the number of subtables of a specific type can now be assured
    that as many subtables as possible have been enumerated.
    
    Signed-off-by: Al Stone <ahs3@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index bf273c70977a..b7dac30adf0c 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -246,6 +246,7 @@ acpi_parse_entries_array(char *id, unsigned long table_size,
 	struct acpi_subtable_header *entry;
 	unsigned long table_end;
 	int count = 0;
+	int errs = 0;
 	int i;
 
 	if (acpi_disabled)
@@ -278,8 +279,10 @@ acpi_parse_entries_array(char *id, unsigned long table_size,
 			if (entry->type != proc[i].id)
 				continue;
 			if (!proc[i].handler ||
-			     proc[i].handler(entry, table_end))
-				return -EINVAL;
+			     (!errs && proc[i].handler(entry, table_end))) {
+				errs++;
+				continue;
+			}
 
 			proc[i].count++;
 			break;
@@ -305,7 +308,7 @@ acpi_parse_entries_array(char *id, unsigned long table_size,
 			id, proc->id, count - max_entries, count);
 	}
 
-	return count;
+	return errs ? -EINVAL : count;
 }
 
 int __init

commit fa162a05de280e7e62f30eac4dc591e8f5052483
Author: Al Stone <ahs3@redhat.com>
Date:   Fri Aug 19 18:48:11 2016 -0600

    ACPI / tables: fix incorrect counts returned by acpi_parse_entries_array()
    
    The static function acpi_parse_entries_array() is provided an array of
    type struct acpi_subtable_proc that has a callback function and a count.
    The count should reflect how many times the callback has been called.
    However, the current code only increments the 0th element of the array,
    regardless of the number of entries in the array, or which callback has
    been invoked.  The result is that we know the total number of callbacks
    made but we cannot determine which callbacks were made, nor how often.
    The fix is to index into the array of structs and increment the proper
    counts.
    
    There is one place in the x86 code for acpi_parse_madt_lapic_entries()
    where the counts for each callback are used.  If no LAPICs *and* no
    X2APICs are found, an ENODEV is supposed to be returned; as it stands,
    the count of X2APICs will always be zero, regardless of what is in the
    MADT.  Should there be no LAPICs, ENODEV will be returned in error, if
    there are X2APICs in the MADT.
    
    Otherwise, there are no other functional consequences of the count being
    done as it currently is; all other uses simply check that the return value
    from acpi_parse_entries_array() or passed back via its callers is either
    non-zero, an error, or in one case just ignored.
    
    In future patches, I will also need these counts to be correct; I need
    to count the number of instances of subtables of certain types within
    the MADT to determine whether or not an ACPI IORT is required or not,
    and report when it is not present when it should be.
    
    Signed-off-by: Al Stone <ahs3@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 9f0ad6ebb368..bf273c70977a 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -281,7 +281,7 @@ acpi_parse_entries_array(char *id, unsigned long table_size,
 			     proc[i].handler(entry, table_end))
 				return -EINVAL;
 
-			proc->count++;
+			proc[i].count++;
 			break;
 		}
 		if (i != proc_num)

commit 84b06ca319dae15f40fd7ff2bfff4769ab8cc58d
Author: Aleksey Makarov <aleksey.makarov@linaro.org>
Date:   Mon Jun 20 13:56:11 2016 +0300

    ACPI / tables: move arch-specific symbol to asm/acpi.h
    
    The constant that defines max phys address where the new upgraded
    ACPI table should be allocated is arch-specific.  Move it to
    <asm/acpi.h>
    
    Signed-off-by: Aleksey Makarov <aleksey.makarov@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index b05df13bd79f..9f0ad6ebb368 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -35,6 +35,7 @@
 #include <linux/earlycpio.h>
 #include <linux/memblock.h>
 #include <linux/initrd.h>
+#include <linux/acpi.h>
 #include "internal.h"
 
 #ifdef CONFIG_ACPI_CUSTOM_DSDT
@@ -543,7 +544,7 @@ void __init acpi_table_upgrade(void)
 		return;
 
 	acpi_tables_addr =
-		memblock_find_in_range(0, max_low_pfn_mapped << PAGE_SHIFT,
+		memblock_find_in_range(0, ACPI_TABLE_UPGRADE_MAX_PHYS,
 				       all_tables_size, PAGE_SIZE);
 	if (!acpi_tables_addr) {
 		WARN_ON(1);

commit da3d3f98d28bc071a2d566aefc8c461bd564be35
Author: Aleksey Makarov <aleksey.makarov@linaro.org>
Date:   Mon Jun 20 13:56:10 2016 +0300

    ACPI / tables: table upgrade: refactor function definitions
    
    Refer initrd_start, initrd_end directly from drivers/acpi/tables.c.
    This allows to use the table upgrade feature in architectures
    other than x86.  Also this simplifies header files.
    
    The patch renames acpi_table_initrd_init() to acpi_table_upgrade()
    (what reflects the purpose of the function) and removes the unneeded
    wraps early_acpi_table_init() and early_initrd_acpi_init().
    
    Signed-off-by: Aleksey Makarov <aleksey.makarov@linaro.org>
    Acked-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index f829e6a2e663..b05df13bd79f 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -34,6 +34,7 @@
 #include <linux/bootmem.h>
 #include <linux/earlycpio.h>
 #include <linux/memblock.h>
+#include <linux/initrd.h>
 #include "internal.h"
 
 #ifdef CONFIG_ACPI_CUSTOM_DSDT
@@ -481,8 +482,10 @@ static DECLARE_BITMAP(acpi_initrd_installed, NR_ACPI_INITRD_TABLES);
 
 #define MAP_CHUNK_SIZE   (NR_FIX_BTMAPS << PAGE_SHIFT)
 
-static void __init acpi_table_initrd_init(void *data, size_t size)
+void __init acpi_table_upgrade(void)
 {
+	void *data = (void *)initrd_start;
+	size_t size = initrd_end - initrd_start;
 	int sig, no, table_nr = 0, total_offset = 0;
 	long offset = 0;
 	struct acpi_table_header *table;
@@ -696,10 +699,6 @@ static void __init acpi_table_initrd_scan(void)
 	}
 }
 #else
-static void __init acpi_table_initrd_init(void *data, size_t size)
-{
-}
-
 static acpi_status
 acpi_table_initrd_override(struct acpi_table_header *existing_table,
 			   acpi_physical_address *address,
@@ -742,11 +741,6 @@ acpi_os_table_override(struct acpi_table_header *existing_table,
 	return AE_OK;
 }
 
-void __init early_acpi_table_init(void *data, size_t size)
-{
-	acpi_table_initrd_init(data, size);
-}
-
 /*
  * acpi_table_init()
  *

commit ce0c1fcc7357ef0ec93c5a1cd1a759729d27599a
Author: Aleksey Makarov <aleksey.makarov@linaro.org>
Date:   Mon Jun 20 13:56:09 2016 +0300

    ACPI / tables: table upgrade: use cacheable map for tables
    
    The new memory allocated in acpi_table_initrd_init() is used to
    copy the upgraded tables to it.  So it should be mapped with
    early_memunmap() instead of early_ioremap().
    
    This is critical for ARM.
    
    Signed-off-by: Aleksey Makarov <aleksey.makarov@linaro.org>
    Acked-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index a372f9eaa15d..f829e6a2e663 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -578,10 +578,10 @@ static void __init acpi_table_initrd_init(void *data, size_t size)
 			clen = size;
 			if (clen > MAP_CHUNK_SIZE - slop)
 				clen = MAP_CHUNK_SIZE - slop;
-			dest_p = early_ioremap(dest_addr & PAGE_MASK,
-						 clen + slop);
+			dest_p = early_memremap(dest_addr & PAGE_MASK,
+						clen + slop);
 			memcpy(dest_p + slop, src_p, clen);
-			early_iounmap(dest_p, clen + slop);
+			early_memunmap(dest_p, clen + slop);
 			src_p += clen;
 			dest_addr += clen;
 			size -= clen;

commit 74216699ddcca13541e8494cb2b995e6a44a04d9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 6 01:27:09 2016 +0200

    ACPI / tables: Fix DSDT override mechanism
    
    Commit 5ae74f2cc2f1 (ACPI / tables: Move table override mechanisms to
    tables.c) forgot to move the CONFIG_ACPI_CUSTOM_DSDT_FILE inclusion
    directive from osl.c to tables.c.  Fix that.
    
    Fixes: 5ae74f2cc2f1 (ACPI / tables: Move table override mechanisms to tables.c)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Lv Zheng <lv.zheng@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 08795fbde3fa..a372f9eaa15d 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -36,6 +36,10 @@
 #include <linux/memblock.h>
 #include "internal.h"
 
+#ifdef CONFIG_ACPI_CUSTOM_DSDT
+#include CONFIG_ACPI_CUSTOM_DSDT_FILE
+#endif
+
 #define ACPI_MAX_TABLES		128
 
 static char *mps_inti_flags_polarity[] = { "dfl", "high", "res", "low" };

commit 5d8813271f8a7c86027afb2ef554f2a5a9ba7c15
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Apr 11 10:13:33 2016 +0800

    ACPI / tables: Convert initrd table override to table upgrade mechanism
    
    This patch converts the initrd table override mechanism to the table
    upgrade mechanism by restricting its usage to the tables released with
    compatibility and more recent revision.
    
    This use case has been encouraged by the ACPI specification:
    
     1. OEMID:
        An OEM-supplied string that identifies the OEM.
    
     2. OEM Table ID:
        An OEM-supplied string that the OEM uses to identify the particular data
        table. This field is particularly useful when defining a definition
        block to distinguish definition block functions. OEM assigns each
        dissimilar table a new OEM Table Id.
    
     3. OEM Revision:
        An OEM-supplied revision number. Larger numbers are assumed to be newer
        revisions.
    
    For OEMs, good practices will ensure consistency when assigning OEMID and
    OEM Table ID fields in any table. The intent of these fields is to allow
    for a binary control system that support services can use. Because many
    support function can be automated, it is useful when a tool can
    programatically determine which table release is a compatible and more
    recent revision of a prior table on the same OEMID and OEM Table ID.
    
    The facility can now be used by the vendors to upgrade wrong tables for bug
    fixing purpose, thus lockdep disabling taint is not suitable for it and it
    should be a default 'y' option to implement the spec encouraged use case.
    
    Note that, by implementing table upgrade inside of ACPICA itself, it is
    possible to remove acpi_table_initrd_override() and tables can be upgraded
    by acpi_install_table() automatically. Though current ACPICA impelentation
    hasn't implemented this, this patched changes the table flag setting timing
    to allow this to be implemented in ACPICA without changing the code here.
    
    Documentation of initrd override mechanism is upgraded accordingly.
    
    Original-by: Octavian Purdila <octavian.purdila@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 2e74dbf45dd4..08795fbde3fa 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -442,7 +442,7 @@ static void acpi_table_taint(struct acpi_table_header *table)
 	add_taint(TAINT_OVERRIDDEN_ACPI_TABLE, LOCKDEP_NOW_UNRELIABLE);
 }
 
-#ifdef CONFIG_ACPI_INITRD_TABLE_OVERRIDE
+#ifdef CONFIG_ACPI_TABLE_UPGRADE
 static u64 acpi_tables_addr;
 static int all_tables_size;
 
@@ -471,9 +471,9 @@ static const char * const table_sigs[] = {
 
 #define ACPI_HEADER_SIZE sizeof(struct acpi_table_header)
 
-#define ACPI_OVERRIDE_TABLES 64
-static struct cpio_data __initdata acpi_initrd_files[ACPI_OVERRIDE_TABLES];
-static DECLARE_BITMAP(acpi_initrd_installed, ACPI_OVERRIDE_TABLES);
+#define NR_ACPI_INITRD_TABLES 64
+static struct cpio_data __initdata acpi_initrd_files[NR_ACPI_INITRD_TABLES];
+static DECLARE_BITMAP(acpi_initrd_installed, NR_ACPI_INITRD_TABLES);
 
 #define MAP_CHUNK_SIZE   (NR_FIX_BTMAPS << PAGE_SHIFT)
 
@@ -488,7 +488,7 @@ static void __init acpi_table_initrd_init(void *data, size_t size)
 	if (data == NULL || size == 0)
 		return;
 
-	for (no = 0; no < ACPI_OVERRIDE_TABLES; no++) {
+	for (no = 0; no < NR_ACPI_INITRD_TABLES; no++) {
 		file = find_cpio_data(cpio_path, data, size, &offset);
 		if (!file.data)
 			break;
@@ -611,19 +611,30 @@ acpi_table_initrd_override(struct acpi_table_header *existing_table,
 		table_length = table->length;
 
 		/* Only override tables matched */
-		if (test_bit(table_index, acpi_initrd_installed) ||
-		    memcmp(existing_table->signature, table->signature, 4) ||
+		if (memcmp(existing_table->signature, table->signature, 4) ||
+		    memcmp(table->oem_id, existing_table->oem_id,
+			   ACPI_OEM_ID_SIZE) ||
 		    memcmp(table->oem_table_id, existing_table->oem_table_id,
 			   ACPI_OEM_TABLE_ID_SIZE)) {
 			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
 			goto next_table;
 		}
+		/*
+		 * Mark the table to avoid being used in
+		 * acpi_table_initrd_scan() and check the revision.
+		 */
+		if (test_and_set_bit(table_index, acpi_initrd_installed) ||
+		    existing_table->oem_revision >= table->oem_revision) {
+			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
+			goto next_table;
+		}
 
 		*length = table_length;
 		*address = acpi_tables_addr + table_offset;
-		acpi_table_taint(existing_table);
+		pr_info("Table Upgrade: override [%4.4s-%6.6s-%8.8s]\n",
+			table->signature, table->oem_id,
+			table->oem_table_id);
 		acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
-		set_bit(table_index, acpi_initrd_installed);
 		break;
 
 next_table:
@@ -655,17 +666,26 @@ static void __init acpi_table_initrd_scan(void)
 		table_length = table->length;
 
 		/* Skip RSDT/XSDT which should only be used for override */
-		if (test_bit(table_index, acpi_initrd_installed) ||
-		    ACPI_COMPARE_NAME(table->signature, ACPI_SIG_RSDT) ||
+		if (ACPI_COMPARE_NAME(table->signature, ACPI_SIG_RSDT) ||
 		    ACPI_COMPARE_NAME(table->signature, ACPI_SIG_XSDT)) {
 			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
 			goto next_table;
 		}
+		/*
+		 * Mark the table to avoid being used in
+		 * acpi_table_initrd_override(). Though this is not possible
+		 * because override is disabled in acpi_install_table().
+		 */
+		if (test_and_set_bit(table_index, acpi_initrd_installed)) {
+			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
+			goto next_table;
+		}
 
-		acpi_table_taint(table);
+		pr_info("Table Upgrade: install [%4.4s-%6.6s-%8.8s]\n",
+			table->signature, table->oem_id,
+			table->oem_table_id);
 		acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
 		acpi_install_table(acpi_tables_addr + table_offset, TRUE);
-		set_bit(table_index, acpi_initrd_installed);
 next_table:
 		table_offset += table_length;
 		table_index++;
@@ -689,7 +709,7 @@ acpi_table_initrd_override(struct acpi_table_header *existing_table,
 static void __init acpi_table_initrd_scan(void)
 {
 }
-#endif /* CONFIG_ACPI_INITRD_TABLE_OVERRIDE */
+#endif /* CONFIG_ACPI_TABLE_UPGRADE */
 
 acpi_status
 acpi_os_physical_table_override(struct acpi_table_header *existing_table,

commit 5ae74f2cc2f150c1a5cee54cabbd71dd0661285a
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Apr 11 10:13:18 2016 +0800

    ACPI / tables: Move table override mechanisms to tables.c
    
    This patch moves acpi_os_table_override() and
    acpi_os_physical_table_override() to tables.c.
    
    Along with the mechanisms, acpi_initrd_initialize_tables() is also moved to
    tables.c to form a static function. The following functions are renamed
    according to this change:
     1. acpi_initrd_override() -> renamed to early_acpi_table_init(), which
        invokes acpi_table_initrd_init()
     2. acpi_os_physical_table_override() -> which invokes
        acpi_table_initrd_override()
     3. acpi_initialize_initrd_tables() -> renamed to acpi_table_initrd_scan()
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index f49c02442d65..2e74dbf45dd4 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -32,6 +32,8 @@
 #include <linux/errno.h>
 #include <linux/acpi.h>
 #include <linux/bootmem.h>
+#include <linux/earlycpio.h>
+#include <linux/memblock.h>
 #include "internal.h"
 
 #define ACPI_MAX_TABLES		128
@@ -433,6 +435,294 @@ static void __init check_multiple_madt(void)
 	return;
 }
 
+static void acpi_table_taint(struct acpi_table_header *table)
+{
+	pr_warn("Override [%4.4s-%8.8s], this is unsafe: tainting kernel\n",
+		table->signature, table->oem_table_id);
+	add_taint(TAINT_OVERRIDDEN_ACPI_TABLE, LOCKDEP_NOW_UNRELIABLE);
+}
+
+#ifdef CONFIG_ACPI_INITRD_TABLE_OVERRIDE
+static u64 acpi_tables_addr;
+static int all_tables_size;
+
+/* Copied from acpica/tbutils.c:acpi_tb_checksum() */
+static u8 __init acpi_table_checksum(u8 *buffer, u32 length)
+{
+	u8 sum = 0;
+	u8 *end = buffer + length;
+
+	while (buffer < end)
+		sum = (u8) (sum + *(buffer++));
+	return sum;
+}
+
+/* All but ACPI_SIG_RSDP and ACPI_SIG_FACS: */
+static const char * const table_sigs[] = {
+	ACPI_SIG_BERT, ACPI_SIG_CPEP, ACPI_SIG_ECDT, ACPI_SIG_EINJ,
+	ACPI_SIG_ERST, ACPI_SIG_HEST, ACPI_SIG_MADT, ACPI_SIG_MSCT,
+	ACPI_SIG_SBST, ACPI_SIG_SLIT, ACPI_SIG_SRAT, ACPI_SIG_ASF,
+	ACPI_SIG_BOOT, ACPI_SIG_DBGP, ACPI_SIG_DMAR, ACPI_SIG_HPET,
+	ACPI_SIG_IBFT, ACPI_SIG_IVRS, ACPI_SIG_MCFG, ACPI_SIG_MCHI,
+	ACPI_SIG_SLIC, ACPI_SIG_SPCR, ACPI_SIG_SPMI, ACPI_SIG_TCPA,
+	ACPI_SIG_UEFI, ACPI_SIG_WAET, ACPI_SIG_WDAT, ACPI_SIG_WDDT,
+	ACPI_SIG_WDRT, ACPI_SIG_DSDT, ACPI_SIG_FADT, ACPI_SIG_PSDT,
+	ACPI_SIG_RSDT, ACPI_SIG_XSDT, ACPI_SIG_SSDT, NULL };
+
+#define ACPI_HEADER_SIZE sizeof(struct acpi_table_header)
+
+#define ACPI_OVERRIDE_TABLES 64
+static struct cpio_data __initdata acpi_initrd_files[ACPI_OVERRIDE_TABLES];
+static DECLARE_BITMAP(acpi_initrd_installed, ACPI_OVERRIDE_TABLES);
+
+#define MAP_CHUNK_SIZE   (NR_FIX_BTMAPS << PAGE_SHIFT)
+
+static void __init acpi_table_initrd_init(void *data, size_t size)
+{
+	int sig, no, table_nr = 0, total_offset = 0;
+	long offset = 0;
+	struct acpi_table_header *table;
+	char cpio_path[32] = "kernel/firmware/acpi/";
+	struct cpio_data file;
+
+	if (data == NULL || size == 0)
+		return;
+
+	for (no = 0; no < ACPI_OVERRIDE_TABLES; no++) {
+		file = find_cpio_data(cpio_path, data, size, &offset);
+		if (!file.data)
+			break;
+
+		data += offset;
+		size -= offset;
+
+		if (file.size < sizeof(struct acpi_table_header)) {
+			pr_err("ACPI OVERRIDE: Table smaller than ACPI header [%s%s]\n",
+				cpio_path, file.name);
+			continue;
+		}
+
+		table = file.data;
+
+		for (sig = 0; table_sigs[sig]; sig++)
+			if (!memcmp(table->signature, table_sigs[sig], 4))
+				break;
+
+		if (!table_sigs[sig]) {
+			pr_err("ACPI OVERRIDE: Unknown signature [%s%s]\n",
+				cpio_path, file.name);
+			continue;
+		}
+		if (file.size != table->length) {
+			pr_err("ACPI OVERRIDE: File length does not match table length [%s%s]\n",
+				cpio_path, file.name);
+			continue;
+		}
+		if (acpi_table_checksum(file.data, table->length)) {
+			pr_err("ACPI OVERRIDE: Bad table checksum [%s%s]\n",
+				cpio_path, file.name);
+			continue;
+		}
+
+		pr_info("%4.4s ACPI table found in initrd [%s%s][0x%x]\n",
+			table->signature, cpio_path, file.name, table->length);
+
+		all_tables_size += table->length;
+		acpi_initrd_files[table_nr].data = file.data;
+		acpi_initrd_files[table_nr].size = file.size;
+		table_nr++;
+	}
+	if (table_nr == 0)
+		return;
+
+	acpi_tables_addr =
+		memblock_find_in_range(0, max_low_pfn_mapped << PAGE_SHIFT,
+				       all_tables_size, PAGE_SIZE);
+	if (!acpi_tables_addr) {
+		WARN_ON(1);
+		return;
+	}
+	/*
+	 * Only calling e820_add_reserve does not work and the
+	 * tables are invalid (memory got used) later.
+	 * memblock_reserve works as expected and the tables won't get modified.
+	 * But it's not enough on X86 because ioremap will
+	 * complain later (used by acpi_os_map_memory) that the pages
+	 * that should get mapped are not marked "reserved".
+	 * Both memblock_reserve and e820_add_region (via arch_reserve_mem_area)
+	 * works fine.
+	 */
+	memblock_reserve(acpi_tables_addr, all_tables_size);
+	arch_reserve_mem_area(acpi_tables_addr, all_tables_size);
+
+	/*
+	 * early_ioremap only can remap 256k one time. If we map all
+	 * tables one time, we will hit the limit. Need to map chunks
+	 * one by one during copying the same as that in relocate_initrd().
+	 */
+	for (no = 0; no < table_nr; no++) {
+		unsigned char *src_p = acpi_initrd_files[no].data;
+		phys_addr_t size = acpi_initrd_files[no].size;
+		phys_addr_t dest_addr = acpi_tables_addr + total_offset;
+		phys_addr_t slop, clen;
+		char *dest_p;
+
+		total_offset += size;
+
+		while (size) {
+			slop = dest_addr & ~PAGE_MASK;
+			clen = size;
+			if (clen > MAP_CHUNK_SIZE - slop)
+				clen = MAP_CHUNK_SIZE - slop;
+			dest_p = early_ioremap(dest_addr & PAGE_MASK,
+						 clen + slop);
+			memcpy(dest_p + slop, src_p, clen);
+			early_iounmap(dest_p, clen + slop);
+			src_p += clen;
+			dest_addr += clen;
+			size -= clen;
+		}
+	}
+}
+
+static acpi_status
+acpi_table_initrd_override(struct acpi_table_header *existing_table,
+			   acpi_physical_address *address, u32 *length)
+{
+	int table_offset = 0;
+	int table_index = 0;
+	struct acpi_table_header *table;
+	u32 table_length;
+
+	*length = 0;
+	*address = 0;
+	if (!acpi_tables_addr)
+		return AE_OK;
+
+	while (table_offset + ACPI_HEADER_SIZE <= all_tables_size) {
+		table = acpi_os_map_memory(acpi_tables_addr + table_offset,
+					   ACPI_HEADER_SIZE);
+		if (table_offset + table->length > all_tables_size) {
+			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
+			WARN_ON(1);
+			return AE_OK;
+		}
+
+		table_length = table->length;
+
+		/* Only override tables matched */
+		if (test_bit(table_index, acpi_initrd_installed) ||
+		    memcmp(existing_table->signature, table->signature, 4) ||
+		    memcmp(table->oem_table_id, existing_table->oem_table_id,
+			   ACPI_OEM_TABLE_ID_SIZE)) {
+			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
+			goto next_table;
+		}
+
+		*length = table_length;
+		*address = acpi_tables_addr + table_offset;
+		acpi_table_taint(existing_table);
+		acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
+		set_bit(table_index, acpi_initrd_installed);
+		break;
+
+next_table:
+		table_offset += table_length;
+		table_index++;
+	}
+	return AE_OK;
+}
+
+static void __init acpi_table_initrd_scan(void)
+{
+	int table_offset = 0;
+	int table_index = 0;
+	u32 table_length;
+	struct acpi_table_header *table;
+
+	if (!acpi_tables_addr)
+		return;
+
+	while (table_offset + ACPI_HEADER_SIZE <= all_tables_size) {
+		table = acpi_os_map_memory(acpi_tables_addr + table_offset,
+					   ACPI_HEADER_SIZE);
+		if (table_offset + table->length > all_tables_size) {
+			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
+			WARN_ON(1);
+			return;
+		}
+
+		table_length = table->length;
+
+		/* Skip RSDT/XSDT which should only be used for override */
+		if (test_bit(table_index, acpi_initrd_installed) ||
+		    ACPI_COMPARE_NAME(table->signature, ACPI_SIG_RSDT) ||
+		    ACPI_COMPARE_NAME(table->signature, ACPI_SIG_XSDT)) {
+			acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
+			goto next_table;
+		}
+
+		acpi_table_taint(table);
+		acpi_os_unmap_memory(table, ACPI_HEADER_SIZE);
+		acpi_install_table(acpi_tables_addr + table_offset, TRUE);
+		set_bit(table_index, acpi_initrd_installed);
+next_table:
+		table_offset += table_length;
+		table_index++;
+	}
+}
+#else
+static void __init acpi_table_initrd_init(void *data, size_t size)
+{
+}
+
+static acpi_status
+acpi_table_initrd_override(struct acpi_table_header *existing_table,
+			   acpi_physical_address *address,
+			   u32 *table_length)
+{
+	*table_length = 0;
+	*address = 0;
+	return AE_OK;
+}
+
+static void __init acpi_table_initrd_scan(void)
+{
+}
+#endif /* CONFIG_ACPI_INITRD_TABLE_OVERRIDE */
+
+acpi_status
+acpi_os_physical_table_override(struct acpi_table_header *existing_table,
+				acpi_physical_address *address,
+				u32 *table_length)
+{
+	return acpi_table_initrd_override(existing_table, address,
+					  table_length);
+}
+
+acpi_status
+acpi_os_table_override(struct acpi_table_header *existing_table,
+		       struct acpi_table_header **new_table)
+{
+	if (!existing_table || !new_table)
+		return AE_BAD_PARAMETER;
+
+	*new_table = NULL;
+
+#ifdef CONFIG_ACPI_CUSTOM_DSDT
+	if (strncmp(existing_table->signature, "DSDT", 4) == 0)
+		*new_table = (struct acpi_table_header *)AmlCode;
+#endif
+	if (*new_table != NULL)
+		acpi_table_taint(existing_table);
+	return AE_OK;
+}
+
+void __init early_acpi_table_init(void *data, size_t size)
+{
+	acpi_table_initrd_init(data, size);
+}
+
 /*
  * acpi_table_init()
  *
@@ -457,7 +747,7 @@ int __init acpi_table_init(void)
 	status = acpi_initialize_tables(initial_tables, ACPI_MAX_TABLES, 0);
 	if (ACPI_FAILURE(status))
 		return -EINVAL;
-	acpi_initrd_initialize_tables();
+	acpi_table_initrd_scan();
 
 	check_multiple_madt();
 	return 0;

commit bdeabccdf9703a8efd71f19d7f31fc60d3538d08
Merge: 02fd4e76a62f 1b6e75ee2959 1d751584e00b 0f9aeb7a6a84 bea3c377c286
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 14 14:21:23 2016 +0100

    Merge branches 'acpi-ec', 'acpi-fan', 'acpi-video' and 'acpi-misc'
    
    * acpi-ec:
      ACPI / EC: Deny write access unless requested by module param
    
    * acpi-fan:
      ACPI / fan: Make struct dev_pm_ops const
    
    * acpi-video:
      ACPI / video: remove unused device_decode array
    
    * acpi-misc:
      ACPI / util: remove redundant check if element is NULL
      ACPI: Add acpi_force_32bit_fadt_addr option to force 32 bit FADT addresses
      drivers/acpi: make pmic/intel_pmic_crc.c explicitly non-modular
      drivers/acpi: make apei/ghes.c more explicitly non-modular
      drivers/acpi: make bgrt driver explicitly non-modular

commit c85cc817e5b6c45a78c3b34170dfeb6469b56d82
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Mar 2 14:16:25 2016 +0800

    ACPI / OSL: Add support to install tables via initrd
    
    This patch adds support to install tables from initrd.
    
    If a table in the initrd wasn't used by the override mechanism,
    the table would be installed after initializing all RSDT/XSDT
    tables.
    
    Link: https://lkml.org/lkml/2014/2/28/368
    Reported-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 6c0f0794aa82..57c0a4525dba 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -32,6 +32,7 @@
 #include <linux/errno.h>
 #include <linux/acpi.h>
 #include <linux/bootmem.h>
+#include "internal.h"
 
 #define ACPI_MAX_TABLES		128
 
@@ -456,6 +457,7 @@ int __init acpi_table_init(void)
 	status = acpi_initialize_tables(initial_tables, ACPI_MAX_TABLES, 0);
 	if (ACPI_FAILURE(status))
 		return -EINVAL;
+	acpi_initrd_initialize_tables();
 
 	check_multiple_madt();
 	return 0;

commit b2ca5dae31d61c4610ea3228f43f7cc66312897c
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Jan 21 17:05:47 2016 +0000

    ACPI: Add acpi_force_32bit_fadt_addr option to force 32 bit FADT addresses
    
    Some HP laptops seem to have invalid 64 bit FADT X_PM* addresses
    which are causing various boot issues.  In these cases, it would
    be useful to force ACPI to use the valid legacy 32 bit equivalent
    PM addresses.  Add a acpi_force_32bit_fadt_addr to set the ACPICA
    acpi_gbl_use32_bit_fadt_addresses to TRUE to force this override.
    
    Link: https://bugs.launchpad.net/bugs/1529381
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 6c0f0794aa82..ebdf5643cd8e 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -484,3 +484,13 @@ static int __init acpi_force_table_verification_setup(char *s)
 }
 
 early_param("acpi_force_table_verification", acpi_force_table_verification_setup);
+
+static int __init acpi_force_32bit_fadt_addr(char *s)
+{
+	pr_info("Forcing 32 Bit FADT addresses\n");
+	acpi_gbl_use32_bit_fadt_addresses = TRUE;
+
+	return 0;
+}
+
+early_param("acpi_force_32bit_fadt_addr", acpi_force_32bit_fadt_addr);

commit 362414d9d2824ee0f4910a73e880860a90e75c3c
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Sep 22 15:29:25 2015 +0300

    ACPI / tables: test the correct variable
    
    The intent was to test "proc[i].handler" instead of "proc->handler".
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index c1ff58de99e9..6c0f0794aa82 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -268,7 +268,8 @@ acpi_parse_entries_array(char *id, unsigned long table_size,
 		for (i = 0; i < proc_num; i++) {
 			if (entry->type != proc[i].id)
 				continue;
-			if (!proc->handler || proc[i].handler(entry, table_end))
+			if (!proc[i].handler ||
+			     proc[i].handler(entry, table_end))
 				return -EINVAL;
 
 			proc->count++;

commit 9b3fedde27d3d63055c43c05e8254e252e58ba48
Author: Lukasz Anaczkowski <lukasz.anaczkowski@intel.com>
Date:   Wed Sep 9 15:47:28 2015 +0200

    ACPI / tables: Add acpi_subtable_proc to ACPI table parsers
    
    ACPI subtable parsing needs to be extended to allow two or more
    handlers to be run in the same ACPI table walk, thus adding
    acpi_subtable_proc structure which stores
     () ACPI table id
     () handler that processes table
     () counter how many items has been processed
    and passing it to acpi_parse_entries_array() and
    acpi_table_parse_entries_array().
    
    This is needed to fix CPU enumeration when APIC/X2APIC entries
    are interleaved.
    
    Signed-off-by: Lukasz Anaczkowski <lukasz.anaczkowski@intel.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 17a6fa01a338..c1ff58de99e9 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -210,20 +210,39 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 	}
 }
 
-int __init
-acpi_parse_entries(char *id, unsigned long table_size,
-		acpi_tbl_entry_handler handler,
+/**
+ * acpi_parse_entries_array - for each proc_num find a suitable subtable
+ *
+ * @id: table id (for debugging purposes)
+ * @table_size: single entry size
+ * @table_header: where does the table start?
+ * @proc: array of acpi_subtable_proc struct containing entry id
+ *        and associated handler with it
+ * @proc_num: how big proc is?
+ * @max_entries: how many entries can we process?
+ *
+ * For each proc_num find a subtable with proc->id and run proc->handler
+ * on it. Assumption is that there's only single handler for particular
+ * entry id.
+ *
+ * On success returns sum of all matching entries for all proc handlers.
+ * Otherwise, -ENODEV or -EINVAL is returned.
+ */
+static int __init
+acpi_parse_entries_array(char *id, unsigned long table_size,
 		struct acpi_table_header *table_header,
-		int entry_id, unsigned int max_entries)
+		struct acpi_subtable_proc *proc, int proc_num,
+		unsigned int max_entries)
 {
 	struct acpi_subtable_header *entry;
-	int count = 0;
 	unsigned long table_end;
+	int count = 0;
+	int i;
 
 	if (acpi_disabled)
 		return -ENODEV;
 
-	if (!id || !handler)
+	if (!id)
 		return -EINVAL;
 
 	if (!table_size)
@@ -243,20 +262,27 @@ acpi_parse_entries(char *id, unsigned long table_size,
 
 	while (((unsigned long)entry) + sizeof(struct acpi_subtable_header) <
 	       table_end) {
-		if (entry->type == entry_id
-		    && (!max_entries || count < max_entries)) {
-			if (handler(entry, table_end))
+		if (max_entries && count >= max_entries)
+			break;
+
+		for (i = 0; i < proc_num; i++) {
+			if (entry->type != proc[i].id)
+				continue;
+			if (!proc->handler || proc[i].handler(entry, table_end))
 				return -EINVAL;
 
-			count++;
+			proc->count++;
+			break;
 		}
+		if (i != proc_num)
+			count++;
 
 		/*
 		 * If entry->length is 0, break from this loop to avoid
 		 * infinite loop.
 		 */
 		if (entry->length == 0) {
-			pr_err("[%4.4s:0x%02x] Invalid zero length\n", id, entry_id);
+			pr_err("[%4.4s:0x%02x] Invalid zero length\n", id, proc->id);
 			return -EINVAL;
 		}
 
@@ -266,17 +292,32 @@ acpi_parse_entries(char *id, unsigned long table_size,
 
 	if (max_entries && count > max_entries) {
 		pr_warn("[%4.4s:0x%02x] ignored %i entries of %i found\n",
-			id, entry_id, count - max_entries, count);
+			id, proc->id, count - max_entries, count);
 	}
 
 	return count;
 }
 
 int __init
-acpi_table_parse_entries(char *id,
+acpi_parse_entries(char *id,
+			unsigned long table_size,
+			acpi_tbl_entry_handler handler,
+			struct acpi_table_header *table_header,
+			int entry_id, unsigned int max_entries)
+{
+	struct acpi_subtable_proc proc = {
+		.id		= entry_id,
+		.handler	= handler,
+	};
+
+	return acpi_parse_entries_array(id, table_size, table_header,
+			&proc, 1, max_entries);
+}
+
+int __init
+acpi_table_parse_entries_array(char *id,
 			 unsigned long table_size,
-			 int entry_id,
-			 acpi_tbl_entry_handler handler,
+			 struct acpi_subtable_proc *proc, int proc_num,
 			 unsigned int max_entries)
 {
 	struct acpi_table_header *table_header = NULL;
@@ -287,7 +328,7 @@ acpi_table_parse_entries(char *id,
 	if (acpi_disabled)
 		return -ENODEV;
 
-	if (!id || !handler)
+	if (!id)
 		return -EINVAL;
 
 	if (!strncmp(id, ACPI_SIG_MADT, 4))
@@ -299,13 +340,29 @@ acpi_table_parse_entries(char *id,
 		return -ENODEV;
 	}
 
-	count = acpi_parse_entries(id, table_size, handler, table_header,
-			entry_id, max_entries);
+	count = acpi_parse_entries_array(id, table_size, table_header,
+			proc, proc_num, max_entries);
 
 	early_acpi_os_unmap_memory((char *)table_header, tbl_size);
 	return count;
 }
 
+int __init
+acpi_table_parse_entries(char *id,
+			unsigned long table_size,
+			int entry_id,
+			acpi_tbl_entry_handler handler,
+			unsigned int max_entries)
+{
+	struct acpi_subtable_proc proc = {
+		.id		= entry_id,
+		.handler	= handler,
+	};
+
+	return acpi_table_parse_entries_array(id, table_size, &proc, 1,
+						max_entries);
+}
+
 int __init
 acpi_table_parse_madt(enum acpi_madt_type id,
 		      acpi_tbl_entry_handler handler, unsigned int max_entries)

commit 4c62dbbce902cf2afa88cac89ec67c828160f431
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Jun 26 11:27:41 2015 +0300

    ACPI: Remove FSF mailing addresses
    
    There is no need to carry potentially outdated Free Software Foundation
    mailing address in file headers since the COPYING file includes it.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 2e19189da0ee..17a6fa01a338 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -15,10 +15,6 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
  */

commit 4c1c8d7a7ebc8b909493a14b21b233e5377b69aa
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Mar 24 14:02:44 2015 +0000

    ACPI / table: Print GIC information when MADT is parsed
    
    When MADT is parsed, print GIC information as debug message:
    
    ACPI: GICC (acpi_id[0x0000] address[00000000e112f000] MPIDR[0x0] enabled)
    ACPI: GICC (acpi_id[0x0001] address[00000000e112f000] MPIDR[0x1] enabled)
    ...
    ACPI: GICC (acpi_id[0x0201] address[00000000e112f000] MPIDR[0x201] enabled)
    
    This debug information will be very helpful to bring up early systems to
    see if acpi_id and MPIDR are matched or not as spec defined.
    
    CC: Rafael J. Wysocki <rjw@rjwysocki.net>
    Tested-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Tested-by: Mark Langsdorf <mlangsdo@redhat.com>
    Tested-by: Jon Masters <jcm@redhat.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index f4e5b888b98e..2e19189da0ee 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -185,6 +185,28 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		}
 		break;
 
+	case ACPI_MADT_TYPE_GENERIC_INTERRUPT:
+		{
+			struct acpi_madt_generic_interrupt *p =
+				(struct acpi_madt_generic_interrupt *)header;
+			pr_debug("GICC (acpi_id[0x%04x] address[%llx] MPIDR[0x%llx] %s)\n",
+				 p->uid, p->base_address,
+				 p->arm_mpidr,
+				 (p->flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");
+
+		}
+		break;
+
+	case ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR:
+		{
+			struct acpi_madt_generic_distributor *p =
+				(struct acpi_madt_generic_distributor *)header;
+			pr_debug("GIC Distributor (gic_id[0x%04x] address[%llx] gsi_base[%d])\n",
+				 p->gic_id, p->base_address,
+				 p->global_irq_base);
+		}
+		break;
+
 	default:
 		pr_warn("Found unsupported MADT entry (type = 0x%x)\n",
 			header->type);

commit 07f438df22886432ff50772446768f65fbbf3ee0
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Mar 24 14:02:34 2015 +0000

    ACPI / table: Use pr_debug() instead of pr_info() for MADT table scanning
    
    For a normal 8 cpu sockets system, it will up to 240 cpu threads (Xeon E7
    v2 family for now), and we need 240 entries for local apic or local x2apic
    in MADT table, so it will be much verbose information printed with a slow
    uart console when system booted, this will be even worse with large system
    with 16/32 cpu sockets.
    
    This patch just use pr_debug() instead of pr_info() for ioapic/iosapic,
    local apic/x2apic/sapic structures when scanning the MADT table to remove
    those verbose information, but leave other structures unchanged.
    
    CC: Rafael J Wysocki <rjw@rjwysocki.net>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Olof Johansson <olof@lixom.net>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 93b81523a2fe..f4e5b888b98e 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -23,6 +23,8 @@
  *
  */
 
+/* Uncomment next line to get verbose printout */
+/* #define DEBUG */
 #define pr_fmt(fmt) "ACPI: " fmt
 
 #include <linux/init.h>
@@ -61,9 +63,9 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		{
 			struct acpi_madt_local_apic *p =
 			    (struct acpi_madt_local_apic *)header;
-			pr_info("LAPIC (acpi_id[0x%02x] lapic_id[0x%02x] %s)\n",
-				p->processor_id, p->id,
-				(p->lapic_flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");
+			pr_debug("LAPIC (acpi_id[0x%02x] lapic_id[0x%02x] %s)\n",
+				 p->processor_id, p->id,
+				 (p->lapic_flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");
 		}
 		break;
 
@@ -71,9 +73,9 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		{
 			struct acpi_madt_local_x2apic *p =
 			    (struct acpi_madt_local_x2apic *)header;
-			pr_info("X2APIC (apic_id[0x%02x] uid[0x%02x] %s)\n",
-				p->local_apic_id, p->uid,
-				(p->lapic_flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");
+			pr_debug("X2APIC (apic_id[0x%02x] uid[0x%02x] %s)\n",
+				 p->local_apic_id, p->uid,
+				 (p->lapic_flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");
 		}
 		break;
 
@@ -81,8 +83,8 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		{
 			struct acpi_madt_io_apic *p =
 			    (struct acpi_madt_io_apic *)header;
-			pr_info("IOAPIC (id[0x%02x] address[0x%08x] gsi_base[%d])\n",
-				p->id, p->address, p->global_irq_base);
+			pr_debug("IOAPIC (id[0x%02x] address[0x%08x] gsi_base[%d])\n",
+				 p->id, p->address, p->global_irq_base);
 		}
 		break;
 
@@ -155,9 +157,9 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		{
 			struct acpi_madt_io_sapic *p =
 			    (struct acpi_madt_io_sapic *)header;
-			pr_info("IOSAPIC (id[0x%x] address[%p] gsi_base[%d])\n",
-				p->id, (void *)(unsigned long)p->address,
-				p->global_irq_base);
+			pr_debug("IOSAPIC (id[0x%x] address[%p] gsi_base[%d])\n",
+				 p->id, (void *)(unsigned long)p->address,
+				 p->global_irq_base);
 		}
 		break;
 
@@ -165,9 +167,9 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		{
 			struct acpi_madt_local_sapic *p =
 			    (struct acpi_madt_local_sapic *)header;
-			pr_info("LSAPIC (acpi_id[0x%02x] lsapic_id[0x%02x] lsapic_eid[0x%02x] %s)\n",
-				p->processor_id, p->id, p->eid,
-				(p->lapic_flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");
+			pr_debug("LSAPIC (acpi_id[0x%02x] lsapic_id[0x%02x] lsapic_eid[0x%02x] %s)\n",
+				 p->processor_id, p->id, p->eid,
+				 (p->lapic_flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");
 		}
 		break;
 

commit 4ceacd02f5a1795c5c697e0345ee10beef675290
Author: Tomasz Nowicki <tomasz.nowicki@linaro.org>
Date:   Wed Nov 26 22:01:14 2014 +0800

    ACPI / table: Always count matched and successfully parsed entries
    
    acpi_parse_entries() allows to traverse all available table entries (aka
    subtables) by passing max_entries parameter equal to 0, but since its count
    variable is only incremented if max_entries is not 0, the function always
    returns 0 for max_entries equal to 0.  It would be more useful if it returned
    the number of entries matched instead, so make it increment count in that
    case too.
    
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index f1debe97dcfc..93b81523a2fe 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -224,10 +224,13 @@ acpi_parse_entries(char *id, unsigned long table_size,
 	while (((unsigned long)entry) + sizeof(struct acpi_subtable_header) <
 	       table_end) {
 		if (entry->type == entry_id
-		    && (!max_entries || count++ < max_entries))
+		    && (!max_entries || count < max_entries)) {
 			if (handler(entry, table_end))
 				return -EINVAL;
 
+			count++;
+		}
+
 		/*
 		 * If entry->length is 0, break from this loop to avoid
 		 * infinite loop.

commit f08bb472bff3c0397fb7d6f47bc5cec41dad76e3
Author: Ashwin Chaugule <ashwin.chaugule@linaro.org>
Date:   Wed Nov 26 22:01:13 2014 +0800

    ACPI / table: Add new function to get table entries
    
    The acpi_table_parse() function has a callback that
    passes a pointer to a table_header. Add a new function
    which takes this pointer and parses its entries. This
    eliminates the need to re-traverse all the tables for
    each call. e.g. as in acpi_table_parse_madt() which is
    normally called after acpi_table_parse().
    
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Ashwin Chaugule <ashwin.chaugule@linaro.org>
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 6d5a6cda0734..f1debe97dcfc 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -190,30 +190,24 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 	}
 }
 
-
 int __init
-acpi_table_parse_entries(char *id,
-			     unsigned long table_size,
-			     int entry_id,
-			     acpi_tbl_entry_handler handler,
-			     unsigned int max_entries)
+acpi_parse_entries(char *id, unsigned long table_size,
+		acpi_tbl_entry_handler handler,
+		struct acpi_table_header *table_header,
+		int entry_id, unsigned int max_entries)
 {
-	struct acpi_table_header *table_header = NULL;
 	struct acpi_subtable_header *entry;
-	unsigned int count = 0;
+	int count = 0;
 	unsigned long table_end;
-	acpi_size tbl_size;
 
 	if (acpi_disabled)
 		return -ENODEV;
 
-	if (!handler)
+	if (!id || !handler)
 		return -EINVAL;
 
-	if (strncmp(id, ACPI_SIG_MADT, 4) == 0)
-		acpi_get_table_with_size(id, acpi_apic_instance, &table_header, &tbl_size);
-	else
-		acpi_get_table_with_size(id, 0, &table_header, &tbl_size);
+	if (!table_size)
+		return -EINVAL;
 
 	if (!table_header) {
 		pr_warn("%4.4s not present\n", id);
@@ -232,7 +226,7 @@ acpi_table_parse_entries(char *id,
 		if (entry->type == entry_id
 		    && (!max_entries || count++ < max_entries))
 			if (handler(entry, table_end))
-				goto err;
+				return -EINVAL;
 
 		/*
 		 * If entry->length is 0, break from this loop to avoid
@@ -240,22 +234,53 @@ acpi_table_parse_entries(char *id,
 		 */
 		if (entry->length == 0) {
 			pr_err("[%4.4s:0x%02x] Invalid zero length\n", id, entry_id);
-			goto err;
+			return -EINVAL;
 		}
 
 		entry = (struct acpi_subtable_header *)
 		    ((unsigned long)entry + entry->length);
 	}
+
 	if (max_entries && count > max_entries) {
 		pr_warn("[%4.4s:0x%02x] ignored %i entries of %i found\n",
 			id, entry_id, count - max_entries, count);
 	}
 
-	early_acpi_os_unmap_memory((char *)table_header, tbl_size);
 	return count;
-err:
+}
+
+int __init
+acpi_table_parse_entries(char *id,
+			 unsigned long table_size,
+			 int entry_id,
+			 acpi_tbl_entry_handler handler,
+			 unsigned int max_entries)
+{
+	struct acpi_table_header *table_header = NULL;
+	acpi_size tbl_size;
+	int count;
+	u32 instance = 0;
+
+	if (acpi_disabled)
+		return -ENODEV;
+
+	if (!id || !handler)
+		return -EINVAL;
+
+	if (!strncmp(id, ACPI_SIG_MADT, 4))
+		instance = acpi_apic_instance;
+
+	acpi_get_table_with_size(id, instance, &table_header, &tbl_size);
+	if (!table_header) {
+		pr_warn("%4.4s not present\n", id);
+		return -ENODEV;
+	}
+
+	count = acpi_parse_entries(id, table_size, handler, table_header,
+			entry_id, max_entries);
+
 	early_acpi_os_unmap_memory((char *)table_header, tbl_size);
-	return -EINVAL;
+	return count;
 }
 
 int __init

commit 3d915894f8317ac3e55b47da829aa65eb5f9ae97
Author: Christoph Jaeger <christophjaeger@linux.com>
Date:   Fri Jun 13 21:49:58 2014 +0200

    ACPI: use kstrto*() instead of simple_strto*()
    
    simple_strto*() are obsolete; use kstrto*() instead. Add proper error
    checking.
    
    Signed-off-by: Christoph Jaeger <christophjaeger@linux.com>
    Acked-by: David Rientjes <rientjes@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 05550ba44d32..6d5a6cda0734 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -360,7 +360,8 @@ static int __init acpi_parse_apic_instance(char *str)
 	if (!str)
 		return -EINVAL;
 
-	acpi_apic_instance = simple_strtoul(str, NULL, 0);
+	if (kstrtoint(str, 0, &acpi_apic_instance))
+		return -EINVAL;
 
 	pr_notice("Shall use APIC/MADT table %d\n", acpi_apic_instance);
 

commit 4fc0a7e889e5540305926e41931cf3bc0a60abb2
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Sat May 31 08:15:02 2014 +0800

    ACPI: Fix x86 regression related to early mapping size limitation
    
    The following warning message is triggered:
     WARNING: CPU: 0 PID: 0 at mm/early_ioremap.c:136 __early_ioremap+0x11f/0x1f2()
     Modules linked in:
     CPU: 0 PID: 0 Comm: swapper Not tainted 3.15.0-rc1-00017-g86dfc6f3-dirty #298
     Hardware name: Intel Corporation S2600CP/S2600CP, BIOS SE5C600.86B.99.99.x036.091920111209 09/19/2011
      0000000000000009 ffffffff81b75c40 ffffffff817c627b 0000000000000000
      ffffffff81b75c78 ffffffff81067b5d 000000000000007b 8000000000000563
      00000000b96b20dc 0000000000000001 ffffffffff300e0c ffffffff81b75c88
     Call Trace:
      [<ffffffff817c627b>] dump_stack+0x45/0x56
      [<ffffffff81067b5d>] warn_slowpath_common+0x7d/0xa0
      [<ffffffff81067c3a>] warn_slowpath_null+0x1a/0x20
      [<ffffffff81d4b9d5>] __early_ioremap+0x11f/0x1f2
      [<ffffffff81d4bc5b>] early_ioremap+0x13/0x15
      [<ffffffff81d2b8f3>] __acpi_map_table+0x13/0x18
      [<ffffffff817b8d1a>] acpi_os_map_memory+0x26/0x14e
      [<ffffffff813ff018>] acpi_tb_acquire_table+0x42/0x70
      [<ffffffff813ff086>] acpi_tb_validate_table+0x27/0x37
      [<ffffffff813ff0e5>] acpi_tb_verify_table+0x22/0xd8
      [<ffffffff813ff6a8>] acpi_tb_install_non_fixed_table+0x60/0x1c9
      [<ffffffff81d61024>] acpi_tb_parse_root_table+0x218/0x26a
      [<ffffffff81d1b120>] ? early_idt_handlers+0x120/0x120
      [<ffffffff81d610cd>] acpi_initialize_tables+0x57/0x59
      [<ffffffff81d5f25d>] acpi_table_init+0x1b/0x99
      [<ffffffff81d2bca0>] acpi_boot_table_init+0x1e/0x85
      [<ffffffff81d23043>] setup_arch+0x99d/0xcc6
      [<ffffffff81d1b120>] ? early_idt_handlers+0x120/0x120
      [<ffffffff81d1bbbe>] start_kernel+0x8b/0x415
      [<ffffffff81d1b120>] ? early_idt_handlers+0x120/0x120
      [<ffffffff81d1b5ee>] x86_64_start_reservations+0x2a/0x2c
      [<ffffffff81d1b72e>] x86_64_start_kernel+0x13e/0x14d
     ---[ end trace 11ae599a1898f4e7 ]---
    when installing the following table during early stage:
     ACPI: SSDT 0x00000000B9638018 07A0C4 (v02 INTEL  S2600CP  00004000 INTL 20100331)
    The regression is caused by the size limitation of the x86 early IO mapping.
    
    The root cause is:
     1. ACPICA doesn't split IO memory mapping and table mapping;
     2. Linux x86 OSL implements acpi_os_map_memory() using a size limited fix-map
        mechanism during early boot stage, which is more suitable for only IO
        mappings.
    
    This patch fixes this issue by utilizing acpi_gbl_verify_table_checksum to
    disable the table mapping during early stage and enabling it again for the
    late stage. In this way, the normal code path is not affected. Then after
    the code related to the root cause is cleaned up, the early checksum
    verification can be easily re-enabled.
    
    A new boot parameter - acpi_force_table_verification is introduced for
    the platforms that require the checksum verification to stop loading bad
    tables.
    
    This fix also covers the checksum verification for the table overrides. Now
    large tables can also be overridden using the initrd override mechanism.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Reported-and-tested-by: Yuanhan Liu <yuanhan.liu@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 21782290df41..05550ba44d32 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -44,6 +44,12 @@ static struct acpi_table_desc initial_tables[ACPI_MAX_TABLES] __initdata;
 
 static int acpi_apic_instance __initdata;
 
+/*
+ * Disable table checksum verification for the early stage due to the size
+ * limitation of the current x86 early mapping implementation.
+ */
+static bool acpi_verify_table_checksum __initdata = false;
+
 void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 {
 	if (!header)
@@ -333,6 +339,14 @@ int __init acpi_table_init(void)
 {
 	acpi_status status;
 
+	if (acpi_verify_table_checksum) {
+		pr_info("Early table checksum verification enabled\n");
+		acpi_gbl_verify_table_checksum = TRUE;
+	} else {
+		pr_info("Early table checksum verification disabled\n");
+		acpi_gbl_verify_table_checksum = FALSE;
+	}
+
 	status = acpi_initialize_tables(initial_tables, ACPI_MAX_TABLES, 0);
 	if (ACPI_FAILURE(status))
 		return -EINVAL;
@@ -354,3 +368,12 @@ static int __init acpi_parse_apic_instance(char *str)
 }
 
 early_param("acpi_apic_instance", acpi_parse_apic_instance);
+
+static int __init acpi_force_table_verification_setup(char *s)
+{
+	acpi_verify_table_checksum = true;
+
+	return 0;
+}
+
+early_param("acpi_force_table_verification", acpi_force_table_verification_setup);

commit 730bf5ebb4dfb3ec654bb6c270aa55de70ebf54d
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Thu Feb 20 15:45:33 2014 +0800

    ACPI / tables: Replace printk with pr_*
    
    This patch just does some cleanup to replace printk with pr_*,
    and introduces pr_fmt() to remove all PREFIXs in tables.c,
    no functional change.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 5837f857ac2e..21782290df41 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -23,6 +23,8 @@
  *
  */
 
+#define pr_fmt(fmt) "ACPI: " fmt
+
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/smp.h>
@@ -33,8 +35,6 @@
 #include <linux/acpi.h>
 #include <linux/bootmem.h>
 
-#define PREFIX			"ACPI: "
-
 #define ACPI_MAX_TABLES		128
 
 static char *mps_inti_flags_polarity[] = { "dfl", "high", "res", "low" };
@@ -55,10 +55,9 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		{
 			struct acpi_madt_local_apic *p =
 			    (struct acpi_madt_local_apic *)header;
-			printk(KERN_INFO PREFIX
-			       "LAPIC (acpi_id[0x%02x] lapic_id[0x%02x] %s)\n",
-			       p->processor_id, p->id,
-			       (p->lapic_flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");
+			pr_info("LAPIC (acpi_id[0x%02x] lapic_id[0x%02x] %s)\n",
+				p->processor_id, p->id,
+				(p->lapic_flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");
 		}
 		break;
 
@@ -66,11 +65,9 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		{
 			struct acpi_madt_local_x2apic *p =
 			    (struct acpi_madt_local_x2apic *)header;
-			printk(KERN_INFO PREFIX
-			       "X2APIC (apic_id[0x%02x] uid[0x%02x] %s)\n",
-			       p->local_apic_id, p->uid,
-			       (p->lapic_flags & ACPI_MADT_ENABLED) ?
-			       "enabled" : "disabled");
+			pr_info("X2APIC (apic_id[0x%02x] uid[0x%02x] %s)\n",
+				p->local_apic_id, p->uid,
+				(p->lapic_flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");
 		}
 		break;
 
@@ -78,9 +75,8 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		{
 			struct acpi_madt_io_apic *p =
 			    (struct acpi_madt_io_apic *)header;
-			printk(KERN_INFO PREFIX
-			       "IOAPIC (id[0x%02x] address[0x%08x] gsi_base[%d])\n",
-			       p->id, p->address, p->global_irq_base);
+			pr_info("IOAPIC (id[0x%02x] address[0x%08x] gsi_base[%d])\n",
+				p->id, p->address, p->global_irq_base);
 		}
 		break;
 
@@ -88,18 +84,15 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		{
 			struct acpi_madt_interrupt_override *p =
 			    (struct acpi_madt_interrupt_override *)header;
-			printk(KERN_INFO PREFIX
-			       "INT_SRC_OVR (bus %d bus_irq %d global_irq %d %s %s)\n",
-			       p->bus, p->source_irq, p->global_irq,
-			       mps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK],
-			       mps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2]);
+			pr_info("INT_SRC_OVR (bus %d bus_irq %d global_irq %d %s %s)\n",
+				p->bus, p->source_irq, p->global_irq,
+				mps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK],
+				mps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2]);
 			if (p->inti_flags  &
 			    ~(ACPI_MADT_POLARITY_MASK | ACPI_MADT_TRIGGER_MASK))
-				printk(KERN_INFO PREFIX
-				       "INT_SRC_OVR unexpected reserved flags: 0x%x\n",
-				       p->inti_flags  &
+				pr_info("INT_SRC_OVR unexpected reserved flags: 0x%x\n",
+					p->inti_flags  &
 					~(ACPI_MADT_POLARITY_MASK | ACPI_MADT_TRIGGER_MASK));
-
 		}
 		break;
 
@@ -107,11 +100,10 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		{
 			struct acpi_madt_nmi_source *p =
 			    (struct acpi_madt_nmi_source *)header;
-			printk(KERN_INFO PREFIX
-			       "NMI_SRC (%s %s global_irq %d)\n",
-			       mps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK],
-			       mps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2],
-			       p->global_irq);
+			pr_info("NMI_SRC (%s %s global_irq %d)\n",
+				mps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK],
+				mps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2],
+				p->global_irq);
 		}
 		break;
 
@@ -119,12 +111,11 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		{
 			struct acpi_madt_local_apic_nmi *p =
 			    (struct acpi_madt_local_apic_nmi *)header;
-			printk(KERN_INFO PREFIX
-			       "LAPIC_NMI (acpi_id[0x%02x] %s %s lint[0x%x])\n",
-			       p->processor_id,
-			       mps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK	],
-			       mps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2],
-			       p->lint);
+			pr_info("LAPIC_NMI (acpi_id[0x%02x] %s %s lint[0x%x])\n",
+				p->processor_id,
+				mps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK	],
+				mps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2],
+				p->lint);
 		}
 		break;
 
@@ -137,12 +128,11 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 			polarity = p->inti_flags & ACPI_MADT_POLARITY_MASK;
 			trigger = (p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2;
 
-			printk(KERN_INFO PREFIX
-			       "X2APIC_NMI (uid[0x%02x] %s %s lint[0x%x])\n",
-			       p->uid,
-			       mps_inti_flags_polarity[polarity],
-			       mps_inti_flags_trigger[trigger],
-			       p->lint);
+			pr_info("X2APIC_NMI (uid[0x%02x] %s %s lint[0x%x])\n",
+				p->uid,
+				mps_inti_flags_polarity[polarity],
+				mps_inti_flags_trigger[trigger],
+				p->lint);
 		}
 		break;
 
@@ -150,9 +140,8 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		{
 			struct acpi_madt_local_apic_override *p =
 			    (struct acpi_madt_local_apic_override *)header;
-			printk(KERN_INFO PREFIX
-			       "LAPIC_ADDR_OVR (address[%p])\n",
-			       (void *)(unsigned long)p->address);
+			pr_info("LAPIC_ADDR_OVR (address[%p])\n",
+				(void *)(unsigned long)p->address);
 		}
 		break;
 
@@ -160,10 +149,9 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		{
 			struct acpi_madt_io_sapic *p =
 			    (struct acpi_madt_io_sapic *)header;
-			printk(KERN_INFO PREFIX
-			       "IOSAPIC (id[0x%x] address[%p] gsi_base[%d])\n",
-			       p->id, (void *)(unsigned long)p->address,
-			       p->global_irq_base);
+			pr_info("IOSAPIC (id[0x%x] address[%p] gsi_base[%d])\n",
+				p->id, (void *)(unsigned long)p->address,
+				p->global_irq_base);
 		}
 		break;
 
@@ -171,10 +159,9 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		{
 			struct acpi_madt_local_sapic *p =
 			    (struct acpi_madt_local_sapic *)header;
-			printk(KERN_INFO PREFIX
-			       "LSAPIC (acpi_id[0x%02x] lsapic_id[0x%02x] lsapic_eid[0x%02x] %s)\n",
-			       p->processor_id, p->id, p->eid,
-			       (p->lapic_flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");
+			pr_info("LSAPIC (acpi_id[0x%02x] lsapic_id[0x%02x] lsapic_eid[0x%02x] %s)\n",
+				p->processor_id, p->id, p->eid,
+				(p->lapic_flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");
 		}
 		break;
 
@@ -182,19 +169,17 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		{
 			struct acpi_madt_interrupt_source *p =
 			    (struct acpi_madt_interrupt_source *)header;
-			printk(KERN_INFO PREFIX
-			       "PLAT_INT_SRC (%s %s type[0x%x] id[0x%04x] eid[0x%x] iosapic_vector[0x%x] global_irq[0x%x]\n",
-			       mps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK],
-			       mps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2],
-			       p->type, p->id, p->eid, p->io_sapic_vector,
-			       p->global_irq);
+			pr_info("PLAT_INT_SRC (%s %s type[0x%x] id[0x%04x] eid[0x%x] iosapic_vector[0x%x] global_irq[0x%x]\n",
+				mps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK],
+				mps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2],
+				p->type, p->id, p->eid, p->io_sapic_vector,
+				p->global_irq);
 		}
 		break;
 
 	default:
-		printk(KERN_WARNING PREFIX
-		       "Found unsupported MADT entry (type = 0x%x)\n",
-		       header->type);
+		pr_warn("Found unsupported MADT entry (type = 0x%x)\n",
+			header->type);
 		break;
 	}
 }
@@ -225,7 +210,7 @@ acpi_table_parse_entries(char *id,
 		acpi_get_table_with_size(id, 0, &table_header, &tbl_size);
 
 	if (!table_header) {
-		printk(KERN_WARNING PREFIX "%4.4s not present\n", id);
+		pr_warn("%4.4s not present\n", id);
 		return -ENODEV;
 	}
 
@@ -248,7 +233,7 @@ acpi_table_parse_entries(char *id,
 		 * infinite loop.
 		 */
 		if (entry->length == 0) {
-			pr_err(PREFIX "[%4.4s:0x%02x] Invalid zero length\n", id, entry_id);
+			pr_err("[%4.4s:0x%02x] Invalid zero length\n", id, entry_id);
 			goto err;
 		}
 
@@ -256,8 +241,8 @@ acpi_table_parse_entries(char *id,
 		    ((unsigned long)entry + entry->length);
 	}
 	if (max_entries && count > max_entries) {
-		printk(KERN_WARNING PREFIX "[%4.4s:0x%02x] ignored %i entries of "
-		       "%i found\n", id, entry_id, count - max_entries, count);
+		pr_warn("[%4.4s:0x%02x] ignored %i entries of %i found\n",
+			id, entry_id, count - max_entries, count);
 	}
 
 	early_acpi_os_unmap_memory((char *)table_header, tbl_size);
@@ -322,13 +307,11 @@ static void __init check_multiple_madt(void)
 
 	acpi_get_table_with_size(ACPI_SIG_MADT, 2, &table, &tbl_size);
 	if (table) {
-		printk(KERN_WARNING PREFIX
-		       "BIOS bug: multiple APIC/MADT found,"
-		       " using %d\n", acpi_apic_instance);
-		printk(KERN_WARNING PREFIX
-		       "If \"acpi_apic_instance=%d\" works better, "
-		       "notify linux-acpi@vger.kernel.org\n",
-		       acpi_apic_instance ? 0 : 2);
+		pr_warn("BIOS bug: multiple APIC/MADT found, using %d\n",
+			acpi_apic_instance);
+		pr_warn("If \"acpi_apic_instance=%d\" works better, "
+			"notify linux-acpi@vger.kernel.org\n",
+			acpi_apic_instance ? 0 : 2);
 		early_acpi_os_unmap_memory(table, tbl_size);
 
 	} else
@@ -365,8 +348,7 @@ static int __init acpi_parse_apic_instance(char *str)
 
 	acpi_apic_instance = simple_strtoul(str, NULL, 0);
 
-	printk(KERN_NOTICE PREFIX "Shall use APIC/MADT table %d\n",
-	       acpi_apic_instance);
+	pr_notice("Shall use APIC/MADT table %d\n", acpi_apic_instance);
 
 	return 0;
 }

commit f8a571b2a128a1697624c1b132f3af07848ebbcf
Author: tangchen <tangchen@cn.fujitsu.com>
Date:   Mon Jan 6 16:47:59 2014 +0800

    ACPI / tables: Return proper error codes from acpi_table_parse() and fix comment.
    
    The comment about return value of acpi_table_parse() is incorrect.
    This patch fix it.
    
    Since all callers only check if the function succeeded or not, this
    patch simplifies the semantics by returning -errno for all failure
    cases. This will also simply the comment.
    
    As suggested by Toshi Kani <toshi.kani@hp.com>, also change the stub
    in linux/acpi.h to return -ENODEV.
    
    Signed-off-by: Tang Chen <tangchen@cn.fujitsu.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index a17619bfb57b..5837f857ac2e 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -278,12 +278,13 @@ acpi_table_parse_madt(enum acpi_madt_type id,
 
 /**
  * acpi_table_parse - find table with @id, run @handler on it
- *
  * @id: table id to find
  * @handler: handler to run
  *
  * Scan the ACPI System Descriptor Table (STD) for a table matching @id,
- * run @handler on it.  Return 0 if table found, return on if not.
+ * run @handler on it.
+ *
+ * Return 0 if table found, -errno if not.
  */
 int __init acpi_table_parse(char *id, acpi_tbl_table_handler handler)
 {

commit de2d1a7e9310c4d1464faf469c737f08b5608600
Author: tangchen <tangchen@cn.fujitsu.com>
Date:   Mon Jan 6 16:43:54 2014 +0800

    ACPI / tables: Check if id is NULL in acpi_table_parse()
    
    strncmp() does not check if the params are NULL. In acpi_table_parse(),
    if @id is NULL, the kernel will panic.
    
    Signed-off-by: Tang Chen <tangchen@cn.fujitsu.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 4ec44258e4ff..a17619bfb57b 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -293,7 +293,7 @@ int __init acpi_table_parse(char *id, acpi_tbl_table_handler handler)
 	if (acpi_disabled)
 		return -ENODEV;
 
-	if (!handler)
+	if (!id || !handler)
 		return -EINVAL;
 
 	if (strncmp(id, ACPI_SIG_MADT, 4) == 0)

commit 95df812dbdc350bfcf31e247e9100c378a472480
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Thu Dec 5 23:42:38 2013 +0800

    ACPI / table: Replace '1' with specific error return values
    
    After commit 7f8f97c3cc (ACPI: acpi_table_parse() now returns
    success/fail, not count), acpi_table_parse() returns '1' when it is
    unable to find the table, but it should return a negative error code
    in that case.  Make it return -ENODEV instead.
    
    Fix the same problem in acpi_table_init() analogously.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    [rjw: Subject and changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index d67a1fe07f0e..4ec44258e4ff 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -306,7 +306,7 @@ int __init acpi_table_parse(char *id, acpi_tbl_table_handler handler)
 		early_acpi_os_unmap_memory(table, tbl_size);
 		return 0;
 	} else
-		return 1;
+		return -ENODEV;
 }
 
 /* 
@@ -351,7 +351,7 @@ int __init acpi_table_init(void)
 
 	status = acpi_initialize_tables(initial_tables, ACPI_MAX_TABLES, 0);
 	if (ACPI_FAILURE(status))
-		return 1;
+		return -EINVAL;
 
 	check_multiple_madt();
 	return 0;

commit b43e1065cab4b5be90c016b2f076086b70cd1556
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Sat Jan 12 15:29:38 2013 +0000

    ACPICA: Cleanup table handler naming conflicts.
    
    This is a cosmetic patch only. Comparison of the resulting binary showed
    only line number differences.
    
    This patch does not affect the generation of the Linux binary.
    This patch decreases 44 lines of 20121114 divergence.diff.
    
    There are naming conflicts between Linux and ACPICA on table handlers. This
    patch cleans up this conflicts to reduce the source code diff between Linux
    and ACPICA.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 2572d9715bda..d67a1fe07f0e 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -204,7 +204,7 @@ int __init
 acpi_table_parse_entries(char *id,
 			     unsigned long table_size,
 			     int entry_id,
-			     acpi_table_entry_handler handler,
+			     acpi_tbl_entry_handler handler,
 			     unsigned int max_entries)
 {
 	struct acpi_table_header *table_header = NULL;
@@ -269,7 +269,7 @@ acpi_table_parse_entries(char *id,
 
 int __init
 acpi_table_parse_madt(enum acpi_madt_type id,
-		      acpi_table_entry_handler handler, unsigned int max_entries)
+		      acpi_tbl_entry_handler handler, unsigned int max_entries)
 {
 	return acpi_table_parse_entries(ACPI_SIG_MADT,
 					    sizeof(struct acpi_table_madt), id,
@@ -285,7 +285,7 @@ acpi_table_parse_madt(enum acpi_madt_type id,
  * Scan the ACPI System Descriptor Table (STD) for a table matching @id,
  * run @handler on it.  Return 0 if table found, return on if not.
  */
-int __init acpi_table_parse(char *id, acpi_table_handler handler)
+int __init acpi_table_parse(char *id, acpi_tbl_table_handler handler)
 {
 	struct acpi_table_header *table = NULL;
 	acpi_size tbl_size;

commit 369d913b242cae2205471b11b6e33ac368ed33ec
Author: Fenghua Yu <fenghua.yu@intel.com>
Date:   Tue Sep 25 11:11:43 2012 -0700

    ACPI: Harden acpi_table_parse_entries() against BIOS bug
    
    Parsing acpi table entries may fall into an infinite loop on a buggy BIOS
    which has entry length=0 in acpi table.
    
    Instead of kernel hang with few failure clue which leads to heavy lifting debug
    effort, this patch hardens kernel boot by booting into non NUMA mode. The debug
    info left in log buffer helps people identify the issue.
    
    Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index f336bca7c450..2572d9715bda 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -240,10 +240,17 @@ acpi_table_parse_entries(char *id,
 	       table_end) {
 		if (entry->type == entry_id
 		    && (!max_entries || count++ < max_entries))
-			if (handler(entry, table_end)) {
-				early_acpi_os_unmap_memory((char *)table_header, tbl_size);
-				return -EINVAL;
-			}
+			if (handler(entry, table_end))
+				goto err;
+
+		/*
+		 * If entry->length is 0, break from this loop to avoid
+		 * infinite loop.
+		 */
+		if (entry->length == 0) {
+			pr_err(PREFIX "[%4.4s:0x%02x] Invalid zero length\n", id, entry_id);
+			goto err;
+		}
 
 		entry = (struct acpi_subtable_header *)
 		    ((unsigned long)entry + entry->length);
@@ -255,6 +262,9 @@ acpi_table_parse_entries(char *id,
 
 	early_acpi_os_unmap_memory((char *)table_header, tbl_size);
 	return count;
+err:
+	early_acpi_os_unmap_memory((char *)table_header, tbl_size);
+	return -EINVAL;
 }
 
 int __init

commit 68ca406930d6380b3be7ada5f15fcf85bfcbd552
Author: Len Brown <len.brown@intel.com>
Date:   Fri Feb 19 00:09:22 2010 -0500

    ACPI: delete the "acpi=ht" boot option
    
    acpi=ht was important in 2003 -- before ACPI was
    universally deployed and enabled by default in
    the major Linux distributions.
    
    At that time, there were a fair number of people who
    or chose to, or needed to, run with acpi=off,
    yet also wanted access to Hyper-threading.
    
    Today we find that many invocations of "acpi=ht"
    are accidental, and thus is it possible that it
    is doing more harm than good.
    
    In 2.6.34, we warn on invocation of acpi=ht.
    In 2.6.35, we delete the boot option.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 8a0ed2800e63..f336bca7c450 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -213,7 +213,7 @@ acpi_table_parse_entries(char *id,
 	unsigned long table_end;
 	acpi_size tbl_size;
 
-	if (acpi_disabled && !acpi_ht)
+	if (acpi_disabled)
 		return -ENODEV;
 
 	if (!handler)
@@ -280,7 +280,7 @@ int __init acpi_table_parse(char *id, acpi_table_handler handler)
 	struct acpi_table_header *table = NULL;
 	acpi_size tbl_size;
 
-	if (acpi_disabled && !acpi_ht)
+	if (acpi_disabled)
 		return -ENODEV;
 
 	if (!handler)

commit 49bf83a45fc677db1ed44d0e072e6aaeabe4e124
Author: Len Brown <len.brown@intel.com>
Date:   Tue Feb 16 03:45:45 2010 -0500

    ACPI: fix "acpi=ht" boot option
    
    We broke "acpi=ht" in 2.6.32 by disabling MADT parsing
    for acpi=disabled.  e5b8fc6ac158f65598f58dba2c0d52ba3b412f52
    This also broke systems which invoked acpi=ht via DMI blacklist.
    
    acpi=ht is a really ugly hack,
    but restore it for those that still use it.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=14886
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index f336bca7c450..8a0ed2800e63 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -213,7 +213,7 @@ acpi_table_parse_entries(char *id,
 	unsigned long table_end;
 	acpi_size tbl_size;
 
-	if (acpi_disabled)
+	if (acpi_disabled && !acpi_ht)
 		return -ENODEV;
 
 	if (!handler)
@@ -280,7 +280,7 @@ int __init acpi_table_parse(char *id, acpi_table_handler handler)
 	struct acpi_table_header *table = NULL;
 	acpi_size tbl_size;
 
-	if (acpi_disabled)
+	if (acpi_disabled && !acpi_ht)
 		return -ENODEV;
 
 	if (!handler)

commit e5b8fc6ac158f65598f58dba2c0d52ba3b412f52
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jul 7 23:22:58 2009 -0400

    ACPI: check acpi_disabled in acpi_table_parse() and acpi_table_parse_entries()
    
    Allow consumers of the acpi_table_parse()/acpi_table_parse_entries() API
    to gracefully handle the acpi_disabled=1 case via return value
    rather than checking the global flag themselves.
    
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 646d39c031ca..f336bca7c450 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -213,6 +213,9 @@ acpi_table_parse_entries(char *id,
 	unsigned long table_end;
 	acpi_size tbl_size;
 
+	if (acpi_disabled)
+		return -ENODEV;
+
 	if (!handler)
 		return -EINVAL;
 
@@ -277,6 +280,9 @@ int __init acpi_table_parse(char *id, acpi_table_handler handler)
 	struct acpi_table_header *table = NULL;
 	acpi_size tbl_size;
 
+	if (acpi_disabled)
+		return -ENODEV;
+
 	if (!handler)
 		return -EINVAL;
 

commit 478c6a43fcbc6c11609f8cee7c7b57223907754f
Merge: 8a3f257c704e 6bb597507f98
Author: Len Brown <len.brown@intel.com>
Date:   Sun Apr 5 02:14:15 2009 -0400

    Merge branch 'linus' into release
    
    Conflicts:
            arch/x86/kernel/cpu/cpufreq/longhaul.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 7237d3de78ff89ec2e18eae5fe962d063024fef5
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Mon Mar 30 13:55:30 2009 -0800

    x86, ACPI: add support for x2apic ACPI extensions
    
    All logical processors with APIC ID values of 255 and greater will have their
    APIC reported through Processor X2APIC structure (type-9 entry type) and all
    logical processors with APIC ID less than 255 will have their APIC reported
    through legacy Processor Local APIC (type-0 entry type) only. This is the
    same case even for NMI structure reporting.
    
    The Processor X2APIC Affinity structure provides the association between the
    X2APIC ID of a logical processor and the proximity domain to which the logical
    processor belongs.
    
    For OSPM, Procssor IDs outside the 0-254 range are to be declared as Device()
    objects in the ACPI namespace.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index a8852952fac4..991c006a301b 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -62,6 +62,18 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		}
 		break;
 
+	case ACPI_MADT_TYPE_LOCAL_X2APIC:
+		{
+			struct acpi_madt_local_x2apic *p =
+			    (struct acpi_madt_local_x2apic *)header;
+			printk(KERN_INFO PREFIX
+			       "X2APIC (apic_id[0x%02x] uid[0x%02x] %s)\n",
+			       p->local_apic_id, p->uid,
+			       (p->lapic_flags & ACPI_MADT_ENABLED) ?
+			       "enabled" : "disabled");
+		}
+		break;
+
 	case ACPI_MADT_TYPE_IO_APIC:
 		{
 			struct acpi_madt_io_apic *p =
@@ -116,6 +128,24 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 		}
 		break;
 
+	case ACPI_MADT_TYPE_LOCAL_X2APIC_NMI:
+		{
+			u16 polarity, trigger;
+			struct acpi_madt_local_x2apic_nmi *p =
+			    (struct acpi_madt_local_x2apic_nmi *)header;
+
+			polarity = p->inti_flags & ACPI_MADT_POLARITY_MASK;
+			trigger = (p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2;
+
+			printk(KERN_INFO PREFIX
+			       "X2APIC_NMI (uid[0x%02x] %s %s lint[0x%x])\n",
+			       p->uid,
+			       mps_inti_flags_polarity[polarity],
+			       mps_inti_flags_trigger[trigger],
+			       p->lint);
+		}
+		break;
+
 	case ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE:
 		{
 			struct acpi_madt_local_apic_override *p =

commit 7d97277b754d3ee098a5ec69b6aaafb00c94e2f2
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Sat Feb 7 15:39:41 2009 -0800

    acpi/x86: introduce __apci_map_table, v4
    
    to prevent wrongly overwriting fixmap that still want to use.
    
    ACPI used to rely on low mappings being all linearly mapped and
    grew a habit: it never really unmapped certain kinds of tables
    after use.
    
    This can cause problems - for example the hypothetical case
    when some spurious access still references it.
    
    v2: remove prev_map and prev_size in __apci_map_table
    v3: let acpi_os_unmap_memory() call early_iounmap too, so remove extral calling to
    early_acpi_os_unmap_memory
    v4: fix typo in one acpi_get_table_with_size calling
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Acked-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index a8852952fac4..fec1ae36d431 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -181,14 +181,15 @@ acpi_table_parse_entries(char *id,
 	struct acpi_subtable_header *entry;
 	unsigned int count = 0;
 	unsigned long table_end;
+	acpi_size tbl_size;
 
 	if (!handler)
 		return -EINVAL;
 
 	if (strncmp(id, ACPI_SIG_MADT, 4) == 0)
-		acpi_get_table(id, acpi_apic_instance, &table_header);
+		acpi_get_table_with_size(id, acpi_apic_instance, &table_header, &tbl_size);
 	else
-		acpi_get_table(id, 0, &table_header);
+		acpi_get_table_with_size(id, 0, &table_header, &tbl_size);
 
 	if (!table_header) {
 		printk(KERN_WARNING PREFIX "%4.4s not present\n", id);
@@ -206,8 +207,10 @@ acpi_table_parse_entries(char *id,
 	       table_end) {
 		if (entry->type == entry_id
 		    && (!max_entries || count++ < max_entries))
-			if (handler(entry, table_end))
+			if (handler(entry, table_end)) {
+				early_acpi_os_unmap_memory((char *)table_header, tbl_size);
 				return -EINVAL;
+			}
 
 		entry = (struct acpi_subtable_header *)
 		    ((unsigned long)entry + entry->length);
@@ -217,6 +220,7 @@ acpi_table_parse_entries(char *id,
 		       "%i found\n", id, entry_id, count - max_entries, count);
 	}
 
+	early_acpi_os_unmap_memory((char *)table_header, tbl_size);
 	return count;
 }
 
@@ -241,17 +245,19 @@ acpi_table_parse_madt(enum acpi_madt_type id,
 int __init acpi_table_parse(char *id, acpi_table_handler handler)
 {
 	struct acpi_table_header *table = NULL;
+	acpi_size tbl_size;
 
 	if (!handler)
 		return -EINVAL;
 
 	if (strncmp(id, ACPI_SIG_MADT, 4) == 0)
-		acpi_get_table(id, acpi_apic_instance, &table);
+		acpi_get_table_with_size(id, acpi_apic_instance, &table, &tbl_size);
 	else
-		acpi_get_table(id, 0, &table);
+		acpi_get_table_with_size(id, 0, &table, &tbl_size);
 
 	if (table) {
 		handler(table);
+		early_acpi_os_unmap_memory(table, tbl_size);
 		return 0;
 	} else
 		return 1;
@@ -265,8 +271,9 @@ int __init acpi_table_parse(char *id, acpi_table_handler handler)
 static void __init check_multiple_madt(void)
 {
 	struct acpi_table_header *table = NULL;
+	acpi_size tbl_size;
 
-	acpi_get_table(ACPI_SIG_MADT, 2, &table);
+	acpi_get_table_with_size(ACPI_SIG_MADT, 2, &table, &tbl_size);
 	if (table) {
 		printk(KERN_WARNING PREFIX
 		       "BIOS bug: multiple APIC/MADT found,"
@@ -275,6 +282,7 @@ static void __init check_multiple_madt(void)
 		       "If \"acpi_apic_instance=%d\" works better, "
 		       "notify linux-acpi@vger.kernel.org\n",
 		       acpi_apic_instance ? 0 : 2);
+		early_acpi_os_unmap_memory(table, tbl_size);
 
 	} else
 		acpi_apic_instance = 0;

commit 9e3a9d1ed8cc8db93e5c53e9a5b09065bd95de8b
Author: Len Brown <len.brown@intel.com>
Date:   Fri Feb 6 14:00:56 2009 -0500

    ACPI: disable ACPI cleanly when bad RSDP found
    
    When ACPI is disabled in the BIOS of this VIA C3 box,
    it invalidates the RSDP, which Linux notices:
    
    ACPI Error (tbxfroot-0218): A valid RSDP was not found [20080926]
    
    Bug Linux neglected to disable ACPI at that stage,
    and later scribbled on smp_found_config:
    
    ACPI: No APIC-table, disabling MPS
    
    But this box doesn't run well in legacy PIC mode,
    it needed IOAPIC mode to perform correctly:
    
    http://lkml.org/lkml/2009/2/5/39
    
    So exit ACPI mode cleanly when we first detect
    that it is hopeless.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 775c97a282bd..a8852952fac4 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -293,7 +293,12 @@ static void __init check_multiple_madt(void)
 
 int __init acpi_table_init(void)
 {
-	acpi_initialize_tables(initial_tables, ACPI_MAX_TABLES, 0);
+	acpi_status status;
+
+	status = acpi_initialize_tables(initial_tables, ACPI_MAX_TABLES, 0);
+	if (ACPI_FAILURE(status))
+		return 1;
+
 	check_multiple_madt();
 	return 0;
 }

commit f0df2d6b52ad7db5edf56909509d51be66fe90be
Author: Cyrill Gorcunov <gorcunov@gmail.com>
Date:   Wed Aug 20 16:41:45 2008 -0700

    acpi: add checking for NULL early param
    
    The early_param handling function could recieve NULL pointer as argument
    in case if user didn't enter parameter value.  So we have to be ready for
    a such situation and do check for NULL pointer if needed.
    
    Signed-off-by: Cyrill Gorcunov <gorcunov@gmail.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index c3419182c9a7..775c97a282bd 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -300,6 +300,8 @@ int __init acpi_table_init(void)
 
 static int __init acpi_parse_apic_instance(char *str)
 {
+	if (!str)
+		return -EINVAL;
 
 	acpi_apic_instance = simple_strtoul(str, NULL, 0);
 

commit 4e381a4f06e3c7b350b55a2636b9d45691780eba
Author: Len Brown <len.brown@intel.com>
Date:   Fri Mar 30 14:16:10 2007 -0400

    Revert "ACPI: parse 2nd MADT by default"
    
    This reverts commit 09fe58356d148ff66901ddf639e725ca1a48a0af.
    http://bugzilla.kernel.org/show_bug.cgi?id=8283
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 96792a6cc164..c3419182c9a7 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -42,7 +42,7 @@ static char *mps_inti_flags_trigger[] = { "dfl", "edge", "res", "level" };
 
 static struct acpi_table_desc initial_tables[ACPI_MAX_TABLES] __initdata;
 
-static int acpi_apic_instance __initdata = 2;
+static int acpi_apic_instance __initdata;
 
 void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 {

commit 09fe58356d148ff66901ddf639e725ca1a48a0af
Author: Len Brown <len.brown@intel.com>
Date:   Sun Mar 11 03:32:00 2007 -0400

    ACPI: parse 2nd MADT by default
    
    http://bugzilla.kernel.org/show_bug.cgi?id=7465
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index c3419182c9a7..96792a6cc164 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -42,7 +42,7 @@ static char *mps_inti_flags_trigger[] = { "dfl", "edge", "res", "level" };
 
 static struct acpi_table_desc initial_tables[ACPI_MAX_TABLES] __initdata;
 
-static int acpi_apic_instance __initdata;
+static int acpi_apic_instance __initdata = 2;
 
 void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 {

commit a1fdcc0d2714b6622e3fd5c00db1635213d6c41a
Author: Len Brown <len.brown@intel.com>
Date:   Sun Mar 11 03:26:14 2007 -0400

    ACPI: Add support to parse 2nd MADT
    
    When a BIOS bug presents multiple APIC/MADTs,
    Linux currently uses the 1st and ignores the 2nd.
    
    But some machines work better if we use the 2nd.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=7465
    
    Add a warning and boot parameter "acpi_apic_instance=2"
    to allow parsing the 2nd.
    
    No change to default behaviour in this patch.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 849e2c361804..c3419182c9a7 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -42,7 +42,9 @@ static char *mps_inti_flags_trigger[] = { "dfl", "edge", "res", "level" };
 
 static struct acpi_table_desc initial_tables[ACPI_MAX_TABLES] __initdata;
 
-void acpi_table_print_madt_entry(struct acpi_subtable_header * header)
+static int acpi_apic_instance __initdata;
+
+void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 {
 	if (!header)
 		return;
@@ -183,8 +185,10 @@ acpi_table_parse_entries(char *id,
 	if (!handler)
 		return -EINVAL;
 
-	/* Locate the table (if exists). There should only be one. */
-	acpi_get_table(id, 0, &table_header);
+	if (strncmp(id, ACPI_SIG_MADT, 4) == 0)
+		acpi_get_table(id, acpi_apic_instance, &table_header);
+	else
+		acpi_get_table(id, 0, &table_header);
 
 	if (!table_header) {
 		printk(KERN_WARNING PREFIX "%4.4s not present\n", id);
@@ -237,10 +241,15 @@ acpi_table_parse_madt(enum acpi_madt_type id,
 int __init acpi_table_parse(char *id, acpi_table_handler handler)
 {
 	struct acpi_table_header *table = NULL;
+
 	if (!handler)
 		return -EINVAL;
 
-	acpi_get_table(id, 0, &table);
+	if (strncmp(id, ACPI_SIG_MADT, 4) == 0)
+		acpi_get_table(id, acpi_apic_instance, &table);
+	else
+		acpi_get_table(id, 0, &table);
+
 	if (table) {
 		handler(table);
 		return 0;
@@ -248,6 +257,31 @@ int __init acpi_table_parse(char *id, acpi_table_handler handler)
 		return 1;
 }
 
+/* 
+ * The BIOS is supposed to supply a single APIC/MADT,
+ * but some report two.  Provide a knob to use either.
+ * (don't you wish instance 0 and 1 were not the same?)
+ */
+static void __init check_multiple_madt(void)
+{
+	struct acpi_table_header *table = NULL;
+
+	acpi_get_table(ACPI_SIG_MADT, 2, &table);
+	if (table) {
+		printk(KERN_WARNING PREFIX
+		       "BIOS bug: multiple APIC/MADT found,"
+		       " using %d\n", acpi_apic_instance);
+		printk(KERN_WARNING PREFIX
+		       "If \"acpi_apic_instance=%d\" works better, "
+		       "notify linux-acpi@vger.kernel.org\n",
+		       acpi_apic_instance ? 0 : 2);
+
+	} else
+		acpi_apic_instance = 0;
+
+	return;
+}
+
 /*
  * acpi_table_init()
  *
@@ -257,9 +291,22 @@ int __init acpi_table_parse(char *id, acpi_table_handler handler)
  * result: sdt_entry[] is initialized
  */
 
-
 int __init acpi_table_init(void)
 {
 	acpi_initialize_tables(initial_tables, ACPI_MAX_TABLES, 0);
+	check_multiple_madt();
+	return 0;
+}
+
+static int __init acpi_parse_apic_instance(char *str)
+{
+
+	acpi_apic_instance = simple_strtoul(str, NULL, 0);
+
+	printk(KERN_NOTICE PREFIX "Shall use APIC/MADT table %d\n",
+	       acpi_apic_instance);
+
 	return 0;
 }
+
+early_param("acpi_apic_instance", acpi_parse_apic_instance);

commit c0cd79d11412969b6b8fa1624cdc1277db82e2fe
Merge: 81450b73dde0 db2d4ccdc8f9
Author: Len Brown <len.brown@intel.com>
Date:   Fri Feb 16 22:10:32 2007 -0500

    Pull fluff into release branch
    
    Conflicts:
    
            arch/x86_64/pci/mmconfig.c
            drivers/acpi/bay.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index ba4cb200314a..45bd17313c4a 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -25,7 +25,6 @@
 
 #include <linux/init.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
 #include <linux/smp.h>
 #include <linux/string.h>
 #include <linux/types.h>

commit 6eb87fed52b7f6ac200eaa649cc3221e239d0113
Author: Len Brown <len.brown@intel.com>
Date:   Sat Feb 10 22:17:07 2007 -0500

    ACPI: acpi_table_parse_madt_family() is not MADT specific
    
    acpi_table_parse_madt_family() is also used to parse SRAT entries.
    So re-name it to acpi_table_parse_entries(), and re-name the
    madt-specific variables within it accordingly.
    
    cosmetic only.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index f211fa35374c..4ed640031e9a 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -170,40 +170,40 @@ void acpi_table_print_madt_entry(struct acpi_subtable_header * header)
 
 
 int __init
-acpi_table_parse_madt_family(char *id,
-			     unsigned long madt_size,
+acpi_table_parse_entries(char *id,
+			     unsigned long table_size,
 			     int entry_id,
 			     acpi_table_entry_handler handler,
 			     unsigned int max_entries)
 {
-	struct acpi_table_header *madt = NULL;
+	struct acpi_table_header *table_header = NULL;
 	struct acpi_subtable_header *entry;
 	unsigned int count = 0;
-	unsigned long madt_end;
+	unsigned long table_end;
 
 	if (!handler)
 		return -EINVAL;
 
-	/* Locate the MADT (if exists). There should only be one. */
-	acpi_get_table(id, 0, &madt);
+	/* Locate the table (if exists). There should only be one. */
+	acpi_get_table(id, 0, &table_header);
 
-	if (!madt) {
+	if (!table_header) {
 		printk(KERN_WARNING PREFIX "%4.4s not present\n", id);
 		return -ENODEV;
 	}
 
-	madt_end = (unsigned long)madt + madt->length;
+	table_end = (unsigned long)table_header + table_header->length;
 
 	/* Parse all entries looking for a match. */
 
 	entry = (struct acpi_subtable_header *)
-	    ((unsigned long)madt + madt_size);
+	    ((unsigned long)table_header + table_size);
 
 	while (((unsigned long)entry) + sizeof(struct acpi_subtable_header) <
-	       madt_end) {
+	       table_end) {
 		if (entry->type == entry_id
 		    && (!max_entries || count++ < max_entries))
-			if (handler(entry, madt_end))
+			if (handler(entry, table_end))
 				return -EINVAL;
 
 		entry = (struct acpi_subtable_header *)
@@ -221,7 +221,7 @@ int __init
 acpi_table_parse_madt(enum acpi_madt_type id,
 		      acpi_table_entry_handler handler, unsigned int max_entries)
 {
-	return acpi_table_parse_madt_family(ACPI_SIG_MADT,
+	return acpi_table_parse_entries(ACPI_SIG_MADT,
 					    sizeof(struct acpi_table_madt), id,
 					    handler, max_entries);
 }

commit 5a8765a84c31ea51baf1f6c78116cd877bd8cd64
Author: Len Brown <len.brown@intel.com>
Date:   Sat Feb 10 21:35:47 2007 -0500

    ACPI: acpi_madt_entry_handler() is not MADT specific
    
    acpi_madt_entry_handler() is also used for the SRAT,
    so re-name it acpi_table_entry_handler().
    
    cosmetic only.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 2075ec7b827b..f211fa35374c 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -173,7 +173,7 @@ int __init
 acpi_table_parse_madt_family(char *id,
 			     unsigned long madt_size,
 			     int entry_id,
-			     acpi_madt_entry_handler handler,
+			     acpi_table_entry_handler handler,
 			     unsigned int max_entries)
 {
 	struct acpi_table_header *madt = NULL;
@@ -219,7 +219,7 @@ acpi_table_parse_madt_family(char *id,
 
 int __init
 acpi_table_parse_madt(enum acpi_madt_type id,
-		      acpi_madt_entry_handler handler, unsigned int max_entries)
+		      acpi_table_entry_handler handler, unsigned int max_entries)
 {
 	return acpi_table_parse_madt_family(ACPI_SIG_MADT,
 					    sizeof(struct acpi_table_madt), id,

commit 7f8f97c3cc75d5783d0b45cf323dedf17684be19
Author: Len Brown <len.brown@intel.com>
Date:   Sat Feb 10 21:28:03 2007 -0500

    ACPI: acpi_table_parse() now returns success/fail, not count
    
    Returning count for tables that are supposed to be unique
    was useless and confusing.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index ba4cb200314a..2075ec7b827b 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -226,6 +226,15 @@ acpi_table_parse_madt(enum acpi_madt_type id,
 					    handler, max_entries);
 }
 
+/**
+ * acpi_table_parse - find table with @id, run @handler on it
+ *
+ * @id: table id to find
+ * @handler: handler to run
+ *
+ * Scan the ACPI System Descriptor Table (STD) for a table matching @id,
+ * run @handler on it.  Return 0 if table found, return on if not.
+ */
 int __init acpi_table_parse(char *id, acpi_table_handler handler)
 {
 	struct acpi_table_header *table = NULL;
@@ -235,9 +244,9 @@ int __init acpi_table_parse(char *id, acpi_table_handler handler)
 	acpi_get_table(id, 0, &table);
 	if (table) {
 		handler(table);
-		return 1;
-	} else
 		return 0;
+	} else
+		return 1;
 }
 
 /*

commit 5f3b1a8b6737b09ce5df4ec9fad4ad271aecb5fb
Author: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Fri Feb 2 19:48:22 2007 +0300

    ACPICA: Remove duplicate table definitions (non-conflicting)
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 962ff29fbf07..ba4cb200314a 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -43,90 +43,92 @@ static char *mps_inti_flags_trigger[] = { "dfl", "edge", "res", "level" };
 
 static struct acpi_table_desc initial_tables[ACPI_MAX_TABLES] __initdata;
 
-void acpi_table_print_madt_entry(acpi_table_entry_header * header)
+void acpi_table_print_madt_entry(struct acpi_subtable_header * header)
 {
 	if (!header)
 		return;
 
 	switch (header->type) {
 
-	case ACPI_MADT_LAPIC:
+	case ACPI_MADT_TYPE_LOCAL_APIC:
 		{
-			struct acpi_table_lapic *p =
-			    (struct acpi_table_lapic *)header;
+			struct acpi_madt_local_apic *p =
+			    (struct acpi_madt_local_apic *)header;
 			printk(KERN_INFO PREFIX
 			       "LAPIC (acpi_id[0x%02x] lapic_id[0x%02x] %s)\n",
-			       p->acpi_id, p->id,
-			       p->flags.enabled ? "enabled" : "disabled");
+			       p->processor_id, p->id,
+			       (p->lapic_flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");
 		}
 		break;
 
-	case ACPI_MADT_IOAPIC:
+	case ACPI_MADT_TYPE_IO_APIC:
 		{
-			struct acpi_table_ioapic *p =
-			    (struct acpi_table_ioapic *)header;
+			struct acpi_madt_io_apic *p =
+			    (struct acpi_madt_io_apic *)header;
 			printk(KERN_INFO PREFIX
 			       "IOAPIC (id[0x%02x] address[0x%08x] gsi_base[%d])\n",
 			       p->id, p->address, p->global_irq_base);
 		}
 		break;
 
-	case ACPI_MADT_INT_SRC_OVR:
+	case ACPI_MADT_TYPE_INTERRUPT_OVERRIDE:
 		{
-			struct acpi_table_int_src_ovr *p =
-			    (struct acpi_table_int_src_ovr *)header;
+			struct acpi_madt_interrupt_override *p =
+			    (struct acpi_madt_interrupt_override *)header;
 			printk(KERN_INFO PREFIX
 			       "INT_SRC_OVR (bus %d bus_irq %d global_irq %d %s %s)\n",
-			       p->bus, p->bus_irq, p->global_irq,
-			       mps_inti_flags_polarity[p->flags.polarity],
-			       mps_inti_flags_trigger[p->flags.trigger]);
-			if (p->flags.reserved)
+			       p->bus, p->source_irq, p->global_irq,
+			       mps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK],
+			       mps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2]);
+			if (p->inti_flags  &
+			    ~(ACPI_MADT_POLARITY_MASK | ACPI_MADT_TRIGGER_MASK))
 				printk(KERN_INFO PREFIX
 				       "INT_SRC_OVR unexpected reserved flags: 0x%x\n",
-				       p->flags.reserved);
+				       p->inti_flags  &
+					~(ACPI_MADT_POLARITY_MASK | ACPI_MADT_TRIGGER_MASK));
 
 		}
 		break;
 
-	case ACPI_MADT_NMI_SRC:
+	case ACPI_MADT_TYPE_NMI_SOURCE:
 		{
-			struct acpi_table_nmi_src *p =
-			    (struct acpi_table_nmi_src *)header;
+			struct acpi_madt_nmi_source *p =
+			    (struct acpi_madt_nmi_source *)header;
 			printk(KERN_INFO PREFIX
 			       "NMI_SRC (%s %s global_irq %d)\n",
-			       mps_inti_flags_polarity[p->flags.polarity],
-			       mps_inti_flags_trigger[p->flags.trigger],
+			       mps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK],
+			       mps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2],
 			       p->global_irq);
 		}
 		break;
 
-	case ACPI_MADT_LAPIC_NMI:
+	case ACPI_MADT_TYPE_LOCAL_APIC_NMI:
 		{
-			struct acpi_table_lapic_nmi *p =
-			    (struct acpi_table_lapic_nmi *)header;
+			struct acpi_madt_local_apic_nmi *p =
+			    (struct acpi_madt_local_apic_nmi *)header;
 			printk(KERN_INFO PREFIX
 			       "LAPIC_NMI (acpi_id[0x%02x] %s %s lint[0x%x])\n",
-			       p->acpi_id,
-			       mps_inti_flags_polarity[p->flags.polarity],
-			       mps_inti_flags_trigger[p->flags.trigger],
+			       p->processor_id,
+			       mps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK	],
+			       mps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2],
 			       p->lint);
 		}
 		break;
 
-	case ACPI_MADT_LAPIC_ADDR_OVR:
+	case ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE:
 		{
-			struct acpi_table_lapic_addr_ovr *p =
-			    (struct acpi_table_lapic_addr_ovr *)header;
+			struct acpi_madt_local_apic_override *p =
+			    (struct acpi_madt_local_apic_override *)header;
 			printk(KERN_INFO PREFIX
 			       "LAPIC_ADDR_OVR (address[%p])\n",
 			       (void *)(unsigned long)p->address);
 		}
 		break;
 
-	case ACPI_MADT_IOSAPIC:
+	case ACPI_MADT_TYPE_IO_SAPIC:
 		{
-			struct acpi_table_iosapic *p =
-			    (struct acpi_table_iosapic *)header;
+			struct acpi_madt_io_sapic *p =
+			    (struct acpi_madt_io_sapic *)header;
 			printk(KERN_INFO PREFIX
 			       "IOSAPIC (id[0x%x] address[%p] gsi_base[%d])\n",
 			       p->id, (void *)(unsigned long)p->address,
@@ -134,26 +136,26 @@ void acpi_table_print_madt_entry(acpi_table_entry_header * header)
 		}
 		break;
 
-	case ACPI_MADT_LSAPIC:
+	case ACPI_MADT_TYPE_LOCAL_SAPIC:
 		{
-			struct acpi_table_lsapic *p =
-			    (struct acpi_table_lsapic *)header;
+			struct acpi_madt_local_sapic *p =
+			    (struct acpi_madt_local_sapic *)header;
 			printk(KERN_INFO PREFIX
 			       "LSAPIC (acpi_id[0x%02x] lsapic_id[0x%02x] lsapic_eid[0x%02x] %s)\n",
-			       p->acpi_id, p->id, p->eid,
-			       p->flags.enabled ? "enabled" : "disabled");
+			       p->processor_id, p->id, p->eid,
+			       (p->lapic_flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");
 		}
 		break;
 
-	case ACPI_MADT_PLAT_INT_SRC:
+	case ACPI_MADT_TYPE_INTERRUPT_SOURCE:
 		{
-			struct acpi_table_plat_int_src *p =
-			    (struct acpi_table_plat_int_src *)header;
+			struct acpi_madt_interrupt_source *p =
+			    (struct acpi_madt_interrupt_source *)header;
 			printk(KERN_INFO PREFIX
 			       "PLAT_INT_SRC (%s %s type[0x%x] id[0x%04x] eid[0x%x] iosapic_vector[0x%x] global_irq[0x%x]\n",
-			       mps_inti_flags_polarity[p->flags.polarity],
-			       mps_inti_flags_trigger[p->flags.trigger],
-			       p->type, p->id, p->eid, p->iosapic_vector,
+			       mps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK],
+			       mps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2],
+			       p->type, p->id, p->eid, p->io_sapic_vector,
 			       p->global_irq);
 		}
 		break;
@@ -175,7 +177,7 @@ acpi_table_parse_madt_family(char *id,
 			     unsigned int max_entries)
 {
 	struct acpi_table_header *madt = NULL;
-	acpi_table_entry_header *entry;
+	struct acpi_subtable_header *entry;
 	unsigned int count = 0;
 	unsigned long madt_end;
 
@@ -183,7 +185,6 @@ acpi_table_parse_madt_family(char *id,
 		return -EINVAL;
 
 	/* Locate the MADT (if exists). There should only be one. */
-
 	acpi_get_table(id, 0, &madt);
 
 	if (!madt) {
@@ -195,17 +196,17 @@ acpi_table_parse_madt_family(char *id,
 
 	/* Parse all entries looking for a match. */
 
-	entry = (acpi_table_entry_header *)
+	entry = (struct acpi_subtable_header *)
 	    ((unsigned long)madt + madt_size);
 
-	while (((unsigned long)entry) + sizeof(acpi_table_entry_header) <
+	while (((unsigned long)entry) + sizeof(struct acpi_subtable_header) <
 	       madt_end) {
 		if (entry->type == entry_id
 		    && (!max_entries || count++ < max_entries))
 			if (handler(entry, madt_end))
 				return -EINVAL;
 
-		entry = (acpi_table_entry_header *)
+		entry = (struct acpi_subtable_header *)
 		    ((unsigned long)entry + entry->length);
 	}
 	if (max_entries && count > max_entries) {
@@ -217,10 +218,10 @@ acpi_table_parse_madt_family(char *id,
 }
 
 int __init
-acpi_table_parse_madt(enum acpi_madt_entry_id id,
+acpi_table_parse_madt(enum acpi_madt_type id,
 		      acpi_madt_entry_handler handler, unsigned int max_entries)
 {
-	return acpi_table_parse_madt_family("APIC",
+	return acpi_table_parse_madt_family(ACPI_SIG_MADT,
 					    sizeof(struct acpi_table_madt), id,
 					    handler, max_entries);
 }
@@ -228,7 +229,6 @@ acpi_table_parse_madt(enum acpi_madt_entry_id id,
 int __init acpi_table_parse(char *id, acpi_table_handler handler)
 {
 	struct acpi_table_header *table = NULL;
-
 	if (!handler)
 		return -EINVAL;
 
@@ -245,10 +245,11 @@ int __init acpi_table_parse(char *id, acpi_table_handler handler)
  *
  * find RSDP, find and checksum SDT/XSDT.
  * checksum all tables, print SDT/XSDT
- * 
+ *
  * result: sdt_entry[] is initialized
  */
 
+
 int __init acpi_table_init(void)
 {
 	acpi_initialize_tables(initial_tables, ACPI_MAX_TABLES, 0);

commit ceb6c46839021d5c7c338d48deac616944660124
Author: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Fri Feb 2 19:48:22 2007 +0300

    ACPICA: Remove duplicate table manager
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 5bb143151169..962ff29fbf07 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -38,71 +38,11 @@
 
 #define ACPI_MAX_TABLES		128
 
-static char *acpi_table_signatures[ACPI_TABLE_COUNT] = {
-	[ACPI_TABLE_UNKNOWN] = "????",
-	[ACPI_APIC] = "APIC",
-	[ACPI_BOOT] = "BOOT",
-	[ACPI_DBGP] = "DBGP",
-	[ACPI_DSDT] = "DSDT",
-	[ACPI_ECDT] = "ECDT",
-	[ACPI_ETDT] = "ETDT",
-	[ACPI_FADT] = "FACP",
-	[ACPI_FACS] = "FACS",
-	[ACPI_OEMX] = "OEM",
-	[ACPI_PSDT] = "PSDT",
-	[ACPI_SBST] = "SBST",
-	[ACPI_SLIT] = "SLIT",
-	[ACPI_SPCR] = "SPCR",
-	[ACPI_SRAT] = "SRAT",
-	[ACPI_SSDT] = "SSDT",
-	[ACPI_SPMI] = "SPMI",
-	[ACPI_HPET] = "HPET",
-	[ACPI_MCFG] = "MCFG",
-};
-
 static char *mps_inti_flags_polarity[] = { "dfl", "high", "res", "low" };
 static char *mps_inti_flags_trigger[] = { "dfl", "edge", "res", "level" };
 
-/* System Description Table (RSDT/XSDT) */
-struct acpi_table_sdt {
-	unsigned long pa;
-	enum acpi_table_id id;
-	unsigned long size;
-} __attribute__ ((packed));
-
-static unsigned long sdt_pa;	/* Physical Address */
-static unsigned long sdt_count;	/* Table count */
-
-static struct acpi_table_sdt sdt_entry[ACPI_MAX_TABLES] __initdata;
 static struct acpi_table_desc initial_tables[ACPI_MAX_TABLES] __initdata;
 
-void acpi_table_print(struct acpi_table_header *header, unsigned long phys_addr)
-{
-	char *name = NULL;
-
-	if (!header)
-		return;
-
-	/* Some table signatures aren't good table names */
-
-	if (!strncmp((char *)&header->signature,
-		     acpi_table_signatures[ACPI_APIC],
-		     sizeof(header->signature))) {
-		name = "MADT";
-	} else if (!strncmp((char *)&header->signature,
-			    acpi_table_signatures[ACPI_FADT],
-			    sizeof(header->signature))) {
-		name = "FADT";
-	} else
-		name = header->signature;
-
-	printk(KERN_DEBUG PREFIX
-	       "%.4s (v%3.3d %6.6s %8.8s 0x%08x %.4s 0x%08x) @ 0x%p\n", name,
-	       header->revision, header->oem_id, header->oem_table_id,
-	       header->oem_revision, header->asl_compiler_id,
-	       header->asl_compiler_revision, (void *)phys_addr);
-}
-
 void acpi_table_print_madt_entry(acpi_table_entry_header * header)
 {
 	if (!header)
@@ -226,123 +166,32 @@ void acpi_table_print_madt_entry(acpi_table_entry_header * header)
 	}
 }
 
-static int
-acpi_table_compute_checksum(void *table_pointer, unsigned long length)
-{
-	u8 *p = table_pointer;
-	unsigned long remains = length;
-	unsigned long sum = 0;
-
-	if (!p || !length)
-		return -EINVAL;
-
-	while (remains--)
-		sum += *p++;
-
-	return (sum & 0xFF);
-}
-
-/*
- * acpi_get_table_header_early()
- * for acpi_blacklisted(), acpi_table_get_sdt()
- */
-int __init
-acpi_get_table_header_early(enum acpi_table_id id,
-			    struct acpi_table_header **header)
-{
-	unsigned int i;
-	enum acpi_table_id temp_id;
-
-	/* DSDT is different from the rest */
-	if (id == ACPI_DSDT)
-		temp_id = ACPI_FADT;
-	else
-		temp_id = id;
-
-	/* Locate the table. */
-
-	for (i = 0; i < sdt_count; i++) {
-		if (sdt_entry[i].id != temp_id)
-			continue;
-		*header = (void *)
-		    __acpi_map_table(sdt_entry[i].pa, sdt_entry[i].size);
-		if (!*header) {
-			printk(KERN_WARNING PREFIX "Unable to map %s\n",
-			       acpi_table_signatures[temp_id]);
-			return -ENODEV;
-		}
-		break;
-	}
-
-	if (!*header) {
-		printk(KERN_WARNING PREFIX "%s not present\n",
-		       acpi_table_signatures[id]);
-		return -ENODEV;
-	}
-
-	/* Map the DSDT header via the pointer in the FADT */
-	if (id == ACPI_DSDT) {
-		struct fadt_descriptor *fadt =
-		    (struct fadt_descriptor *)*header;
-
-		if (fadt->header.revision == 3 && fadt->Xdsdt) {
-			*header = (void *)__acpi_map_table(fadt->Xdsdt,
-							   sizeof(struct
-								  acpi_table_header));
-		} else if (fadt->dsdt) {
-			*header = (void *)__acpi_map_table(fadt->dsdt,
-							   sizeof(struct
-								  acpi_table_header));
-		} else
-			*header = NULL;
-
-		if (!*header) {
-			printk(KERN_WARNING PREFIX "Unable to map DSDT\n");
-			return -ENODEV;
-		}
-	}
-
-	return 0;
-}
 
 int __init
-acpi_table_parse_madt_family(enum acpi_table_id id,
+acpi_table_parse_madt_family(char *id,
 			     unsigned long madt_size,
 			     int entry_id,
 			     acpi_madt_entry_handler handler,
 			     unsigned int max_entries)
 {
-	void *madt = NULL;
+	struct acpi_table_header *madt = NULL;
 	acpi_table_entry_header *entry;
 	unsigned int count = 0;
 	unsigned long madt_end;
-	unsigned int i;
 
 	if (!handler)
 		return -EINVAL;
 
 	/* Locate the MADT (if exists). There should only be one. */
 
-	for (i = 0; i < sdt_count; i++) {
-		if (sdt_entry[i].id != id)
-			continue;
-		madt = (void *)
-		    __acpi_map_table(sdt_entry[i].pa, sdt_entry[i].size);
-		if (!madt) {
-			printk(KERN_WARNING PREFIX "Unable to map %s\n",
-			       acpi_table_signatures[id]);
-			return -ENODEV;
-		}
-		break;
-	}
+	acpi_get_table(id, 0, &madt);
 
 	if (!madt) {
-		printk(KERN_WARNING PREFIX "%s not present\n",
-		       acpi_table_signatures[id]);
+		printk(KERN_WARNING PREFIX "%4.4s not present\n", id);
 		return -ENODEV;
 	}
 
-	madt_end = (unsigned long)madt + sdt_entry[i].size;
+	madt_end = (unsigned long)madt + madt->length;
 
 	/* Parse all entries looking for a match. */
 
@@ -360,9 +209,8 @@ acpi_table_parse_madt_family(enum acpi_table_id id,
 		    ((unsigned long)entry + entry->length);
 	}
 	if (max_entries && count > max_entries) {
-		printk(KERN_WARNING PREFIX "[%s:0x%02x] ignored %i entries of "
-		       "%i found\n", acpi_table_signatures[id], entry_id,
-		       count - max_entries, count);
+		printk(KERN_WARNING PREFIX "[%4.4s:0x%02x] ignored %i entries of "
+		       "%i found\n", id, entry_id, count - max_entries, count);
 	}
 
 	return count;
@@ -372,195 +220,24 @@ int __init
 acpi_table_parse_madt(enum acpi_madt_entry_id id,
 		      acpi_madt_entry_handler handler, unsigned int max_entries)
 {
-	return acpi_table_parse_madt_family(ACPI_APIC,
+	return acpi_table_parse_madt_family("APIC",
 					    sizeof(struct acpi_table_madt), id,
 					    handler, max_entries);
 }
 
-int __init acpi_table_parse(enum acpi_table_id id, acpi_table_handler handler)
+int __init acpi_table_parse(char *id, acpi_table_handler handler)
 {
-	int count = 0;
-	unsigned int i = 0;
+	struct acpi_table_header *table = NULL;
 
 	if (!handler)
 		return -EINVAL;
 
-	for (i = 0; i < sdt_count; i++) {
-		if (sdt_entry[i].id != id)
-			continue;
-		count++;
-		if (count == 1)
-			handler(sdt_entry[i].pa, sdt_entry[i].size);
-
-		else
-			printk(KERN_WARNING PREFIX
-			       "%d duplicate %s table ignored.\n", count,
-			       acpi_table_signatures[id]);
-	}
-
-	return count;
-}
-
-static int __init acpi_table_get_sdt(struct acpi_table_rsdp *rsdp)
-{
-	struct acpi_table_header *header = NULL;
-	unsigned int i, id = 0;
-
-	if (!rsdp)
-		return -EINVAL;
-
-	/* First check XSDT (but only on ACPI 2.0-compatible systems) */
-
-	if ((rsdp->revision >= 2) && rsdp->xsdt_physical_address) {
-
-		struct acpi_table_xsdt *mapped_xsdt = NULL;
-
-		sdt_pa = rsdp->xsdt_physical_address;
-
-		/* map in just the header */
-		header = (struct acpi_table_header *)
-		    __acpi_map_table(sdt_pa, sizeof(struct acpi_table_header));
-
-		if (!header) {
-			printk(KERN_WARNING PREFIX
-			       "Unable to map XSDT header\n");
-			return -ENODEV;
-		}
-
-		/* remap in the entire table before processing */
-		mapped_xsdt = (struct acpi_table_xsdt *)
-		    __acpi_map_table(sdt_pa, header->length);
-		if (!mapped_xsdt) {
-			printk(KERN_WARNING PREFIX "Unable to map XSDT\n");
-			return -ENODEV;
-		}
-		header = &mapped_xsdt->header;
-
-		if (strncmp(header->signature, "XSDT", 4)) {
-			printk(KERN_WARNING PREFIX
-			       "XSDT signature incorrect\n");
-			return -ENODEV;
-		}
-
-		if (acpi_table_compute_checksum(header, header->length)) {
-			printk(KERN_WARNING PREFIX "Invalid XSDT checksum\n");
-			return -ENODEV;
-		}
-
-		sdt_count =
-		    (header->length - sizeof(struct acpi_table_header)) >> 3;
-		if (sdt_count > ACPI_MAX_TABLES) {
-			printk(KERN_WARNING PREFIX
-			       "Truncated %lu XSDT entries\n",
-			       (sdt_count - ACPI_MAX_TABLES));
-			sdt_count = ACPI_MAX_TABLES;
-		}
-
-		for (i = 0; i < sdt_count; i++)
-			sdt_entry[i].pa = (unsigned long)mapped_xsdt->table_offset_entry[i];
-	}
-
-	/* Then check RSDT */
-
-	else if (rsdp->rsdt_physical_address) {
-
-		struct acpi_table_rsdt *mapped_rsdt = NULL;
-
-		sdt_pa = rsdp->rsdt_physical_address;
-
-		/* map in just the header */
-		header = (struct acpi_table_header *)
-		    __acpi_map_table(sdt_pa, sizeof(struct acpi_table_header));
-		if (!header) {
-			printk(KERN_WARNING PREFIX
-			       "Unable to map RSDT header\n");
-			return -ENODEV;
-		}
-
-		/* remap in the entire table before processing */
-		mapped_rsdt = (struct acpi_table_rsdt *)
-		    __acpi_map_table(sdt_pa, header->length);
-		if (!mapped_rsdt) {
-			printk(KERN_WARNING PREFIX "Unable to map RSDT\n");
-			return -ENODEV;
-		}
-		header = &mapped_rsdt->header;
-
-		if (strncmp(header->signature, "RSDT", 4)) {
-			printk(KERN_WARNING PREFIX
-			       "RSDT signature incorrect\n");
-			return -ENODEV;
-		}
-
-		if (acpi_table_compute_checksum(header, header->length)) {
-			printk(KERN_WARNING PREFIX "Invalid RSDT checksum\n");
-			return -ENODEV;
-		}
-
-		sdt_count =
-		    (header->length - sizeof(struct acpi_table_header)) >> 2;
-		if (sdt_count > ACPI_MAX_TABLES) {
-			printk(KERN_WARNING PREFIX
-			       "Truncated %lu RSDT entries\n",
-			       (sdt_count - ACPI_MAX_TABLES));
-			sdt_count = ACPI_MAX_TABLES;
-		}
-
-		for (i = 0; i < sdt_count; i++)
-			sdt_entry[i].pa = (unsigned long)mapped_rsdt->table_offset_entry[i];
-	}
-
-	else {
-		printk(KERN_WARNING PREFIX
-		       "No System Description Table (RSDT/XSDT) specified in RSDP\n");
-		return -ENODEV;
-	}
-
-	acpi_table_print(header, sdt_pa);
-
-	for (i = 0; i < sdt_count; i++) {
-
-		/* map in just the header */
-		header = (struct acpi_table_header *)
-		    __acpi_map_table(sdt_entry[i].pa,
-				     sizeof(struct acpi_table_header));
-		if (!header)
-			continue;
-
-		/* remap in the entire table before processing */
-		header = (struct acpi_table_header *)
-		    __acpi_map_table(sdt_entry[i].pa, header->length);
-		if (!header)
-			continue;
-
-		acpi_table_print(header, sdt_entry[i].pa);
-
-		if (acpi_table_compute_checksum(header, header->length)) {
-			printk(KERN_WARNING "  >>> ERROR: Invalid checksum\n");
-			continue;
-		}
-
-		sdt_entry[i].size = header->length;
-
-		for (id = 0; id < ACPI_TABLE_COUNT; id++) {
-			if (!strncmp((char *)&header->signature,
-				     acpi_table_signatures[id],
-				     sizeof(header->signature))) {
-				sdt_entry[i].id = id;
-			}
-		}
-	}
-
-	/* 
-	 * The DSDT is *not* in the RSDT (why not? no idea.) but we want
-	 * to print its info, because this is what people usually blacklist
-	 * against. Unfortunately, we don't know the phys_addr, so just
-	 * print 0. Maybe no one will notice.
-	 */
-	if (!acpi_get_table_header_early(ACPI_DSDT, &header))
-		acpi_table_print(header, 0);
-
-	return 0;
+	acpi_get_table(id, 0, &table);
+	if (table) {
+		handler(table);
+		return 1;
+	} else
+		return 0;
 }
 
 /*
@@ -574,47 +251,6 @@ static int __init acpi_table_get_sdt(struct acpi_table_rsdp *rsdp)
 
 int __init acpi_table_init(void)
 {
-	struct acpi_table_rsdp *rsdp = NULL;
-	unsigned long rsdp_phys = 0;
-	int result = 0;
-
-	/* Locate and map the Root System Description Table (RSDP) */
-
-	rsdp_phys = acpi_find_rsdp();
-	if (!rsdp_phys) {
-		printk(KERN_ERR PREFIX "Unable to locate RSDP\n");
-		return -ENODEV;
-	}
-
-	rsdp = (struct acpi_table_rsdp *)__acpi_map_table(rsdp_phys,
-		sizeof(struct acpi_table_rsdp));
-	if (!rsdp) {
-		printk(KERN_WARNING PREFIX "Unable to map RSDP\n");
-		return -ENODEV;
-	}
-
-	printk(KERN_DEBUG PREFIX
-	       "RSDP (v%3.3d %6.6s                                ) @ 0x%p\n",
-	       rsdp->revision, rsdp->oem_id, (void *)rsdp_phys);
-
-	if (rsdp->revision < 2)
-		result =
-		    acpi_table_compute_checksum(rsdp, ACPI_RSDP_REV0_SIZE);
-	else
-		result =
-		    acpi_table_compute_checksum(rsdp, rsdp->length);
-
-	if (result) {
-		printk(KERN_WARNING "  >>> ERROR: Invalid checksum\n");
-		return -ENODEV;
-	}
-
-	/* Locate and map the System Description table (RSDT/XSDT) */
-
-	if (acpi_table_get_sdt(rsdp))
-		return -ENODEV;
-
 	acpi_initialize_tables(initial_tables, ACPI_MAX_TABLES, 0);
-
 	return 0;
 }

commit ad71860a17ba33eb0e673e9e2cf5ba0d8e3e3fdd
Author: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Fri Feb 2 19:48:19 2007 +0300

    ACPICA: minimal patch to integrate new tables into Linux
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index ffa30c9fccbf..5bb143151169 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -74,6 +74,7 @@ static unsigned long sdt_pa;	/* Physical Address */
 static unsigned long sdt_count;	/* Table count */
 
 static struct acpi_table_sdt sdt_entry[ACPI_MAX_TABLES] __initdata;
+static struct acpi_table_desc initial_tables[ACPI_MAX_TABLES] __initdata;
 
 void acpi_table_print(struct acpi_table_header *header, unsigned long phys_addr)
 {
@@ -284,12 +285,12 @@ acpi_get_table_header_early(enum acpi_table_id id,
 		struct fadt_descriptor *fadt =
 		    (struct fadt_descriptor *)*header;
 
-		if (fadt->revision == 3 && fadt->Xdsdt) {
+		if (fadt->header.revision == 3 && fadt->Xdsdt) {
 			*header = (void *)__acpi_map_table(fadt->Xdsdt,
 							   sizeof(struct
 								  acpi_table_header));
-		} else if (fadt->V1_dsdt) {
-			*header = (void *)__acpi_map_table(fadt->V1_dsdt,
+		} else if (fadt->dsdt) {
+			*header = (void *)__acpi_map_table(fadt->dsdt,
 							   sizeof(struct
 								  acpi_table_header));
 		} else
@@ -410,12 +411,11 @@ static int __init acpi_table_get_sdt(struct acpi_table_rsdp *rsdp)
 
 	/* First check XSDT (but only on ACPI 2.0-compatible systems) */
 
-	if ((rsdp->revision >= 2) &&
-	    (((struct acpi20_table_rsdp *)rsdp)->xsdt_address)) {
+	if ((rsdp->revision >= 2) && rsdp->xsdt_physical_address) {
 
 		struct acpi_table_xsdt *mapped_xsdt = NULL;
 
-		sdt_pa = ((struct acpi20_table_rsdp *)rsdp)->xsdt_address;
+		sdt_pa = rsdp->xsdt_physical_address;
 
 		/* map in just the header */
 		header = (struct acpi_table_header *)
@@ -457,16 +457,16 @@ static int __init acpi_table_get_sdt(struct acpi_table_rsdp *rsdp)
 		}
 
 		for (i = 0; i < sdt_count; i++)
-			sdt_entry[i].pa = (unsigned long)mapped_xsdt->entry[i];
+			sdt_entry[i].pa = (unsigned long)mapped_xsdt->table_offset_entry[i];
 	}
 
 	/* Then check RSDT */
 
-	else if (rsdp->rsdt_address) {
+	else if (rsdp->rsdt_physical_address) {
 
 		struct acpi_table_rsdt *mapped_rsdt = NULL;
 
-		sdt_pa = rsdp->rsdt_address;
+		sdt_pa = rsdp->rsdt_physical_address;
 
 		/* map in just the header */
 		header = (struct acpi_table_header *)
@@ -507,7 +507,7 @@ static int __init acpi_table_get_sdt(struct acpi_table_rsdp *rsdp)
 		}
 
 		for (i = 0; i < sdt_count; i++)
-			sdt_entry[i].pa = (unsigned long)mapped_rsdt->entry[i];
+			sdt_entry[i].pa = (unsigned long)mapped_rsdt->table_offset_entry[i];
 	}
 
 	else {
@@ -599,13 +599,10 @@ int __init acpi_table_init(void)
 
 	if (rsdp->revision < 2)
 		result =
-		    acpi_table_compute_checksum(rsdp,
-						sizeof(struct acpi_table_rsdp));
+		    acpi_table_compute_checksum(rsdp, ACPI_RSDP_REV0_SIZE);
 	else
 		result =
-		    acpi_table_compute_checksum(rsdp,
-						((struct acpi20_table_rsdp *)
-						 rsdp)->length);
+		    acpi_table_compute_checksum(rsdp, rsdp->length);
 
 	if (result) {
 		printk(KERN_WARNING "  >>> ERROR: Invalid checksum\n");
@@ -617,5 +614,7 @@ int __init acpi_table_init(void)
 	if (acpi_table_get_sdt(rsdp))
 		return -ENODEV;
 
+	acpi_initialize_tables(initial_tables, ACPI_MAX_TABLES, 0);
+
 	return 0;
 }

commit 50dd096973f1d95aa03c6a6d9e148d706b62b68e
Author: Jan Engelhardt <jengelh@linux01.gwdg.de>
Date:   Sun Oct 1 00:28:50 2006 +0200

    ACPI: Remove unnecessary from/to-void* and to-void casts in drivers/acpi
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index bfb3bfcf9e91..ffa30c9fccbf 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -228,7 +228,7 @@ void acpi_table_print_madt_entry(acpi_table_entry_header * header)
 static int
 acpi_table_compute_checksum(void *table_pointer, unsigned long length)
 {
-	u8 *p = (u8 *) table_pointer;
+	u8 *p = table_pointer;
 	unsigned long remains = length;
 	unsigned long sum = 0;
 

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index ed5e8816d83d..bfb3bfcf9e91 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -23,7 +23,6 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>

commit 793c2388cae3fd023b3b5166354931752d42353c
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Mar 31 00:00:00 2006 -0500

    ACPI: ACPICA 20060331
    
    Implemented header file support for the following
    additional ACPI tables: ASF!, BOOT, CPEP, DBGP, MCFG, SPCR,
    SPMI, TCPA, and WDRT. With this support, all current and
    known ACPI tables are now defined in the ACPICA headers and
    are available for use by device drivers and other software.
    
    Implemented support to allow tables that contain ACPI
    names with invalid characters to be loaded. Previously,
    this would cause the table load to fail, but since
    there are several known cases of such tables on
    existing machines, this change was made to enable
    ACPI support for them. Also, this matches the
    behavior of the Microsoft ACPI implementation.
    https://bugzilla.novell.com/show_bug.cgi?id=147621
    
    Fixed a couple regressions introduced during the memory
    optimization in the 20060317 release. The namespace
    node definition required additional reorganization and
    an internal datatype that had been changed to 8-bit was
    restored to 32-bit. (Valery Podrezov)
    
    Fixed a problem where a null pointer passed to
    acpi_ut_delete_generic_state() could be passed through
    to acpi_os_release_object which is unexpected. Such
    null pointers are now trapped and ignored, matching
    the behavior of the previous implementation before the
    deployment of acpi_os_release_object().  (Valery Podrezov,
    Fiodor Suietov)
    
    Fixed a memory mapping leak during the deletion of
    a SystemMemory operation region where a cached memory
    mapping was not deleted. This became a noticeable problem
    for operation regions that are defined within frequently
    used control methods. (Dana Meyers)
    
    Reorganized the ACPI table header files into two main
    files: one for the ACPI tables consumed by the ACPICA core,
    and another for the miscellaneous ACPI tables that are
    consumed by the drivers and other software. The various
    FADT definitions were merged into one common section and
    three different tables (ACPI 1.0, 1.0+, and 2.0)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 7f37c7cc5ef1..ed5e8816d83d 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -282,8 +282,8 @@ acpi_get_table_header_early(enum acpi_table_id id,
 
 	/* Map the DSDT header via the pointer in the FADT */
 	if (id == ACPI_DSDT) {
-		struct fadt_descriptor_rev2 *fadt =
-		    (struct fadt_descriptor_rev2 *)*header;
+		struct fadt_descriptor *fadt =
+		    (struct fadt_descriptor *)*header;
 
 		if (fadt->revision == 3 && fadt->Xdsdt) {
 			*header = (void *)__acpi_map_table(fadt->Xdsdt,

commit 23dd842c0033dbb05248c42929c3c526c55386de
Author: Tolentino, Matthew E <matthew.e.tolentino@intel.com>
Date:   Sun Mar 26 01:37:09 2006 -0800

    [PATCH] EFI fixes
    
    Here's a patch that fixes EFI boot for x86 on 2.6.16-rc5-mm3.  The
    off-by-one is admittedly my fault, but the other two fix up the rest.
    
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Matt Domsch <Matt_Domsch@dell.com>
    Cc: "Tolentino, Matthew E" <matthew.e.tolentino@intel.com>
    Cc: "Brown, Len" <len.brown@intel.com>
    Cc: Andi Kleen <ak@muc.de>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 31d4f3ffc265..7f37c7cc5ef1 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -587,7 +587,8 @@ int __init acpi_table_init(void)
 		return -ENODEV;
 	}
 
-	rsdp = (struct acpi_table_rsdp *)__va(rsdp_phys);
+	rsdp = (struct acpi_table_rsdp *)__acpi_map_table(rsdp_phys,
+		sizeof(struct acpi_table_rsdp));
 	if (!rsdp) {
 		printk(KERN_WARNING PREFIX "Unable to map RSDP\n");
 		return -ENODEV;

commit 04348e69e7e78ad69a09b2e1157f628d6c764370
Author: Len Brown <len.brown@intel.com>
Date:   Fri Dec 30 02:44:59 2005 -0500

    [ACPI] reduce kernel size: move 5BK .bss to 2.5KB .init.data
    
    put __initdata on sdt_entry[], as it is accessed only by __init functions.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=1311
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index a2bf25b05e1c..31d4f3ffc265 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -37,7 +37,7 @@
 
 #define PREFIX			"ACPI: "
 
-#define ACPI_MAX_TABLES		256
+#define ACPI_MAX_TABLES		128
 
 static char *acpi_table_signatures[ACPI_TABLE_COUNT] = {
 	[ACPI_TABLE_UNKNOWN] = "????",
@@ -74,7 +74,7 @@ struct acpi_table_sdt {
 static unsigned long sdt_pa;	/* Physical Address */
 static unsigned long sdt_count;	/* Table count */
 
-static struct acpi_table_sdt sdt_entry[ACPI_MAX_TABLES];
+static struct acpi_table_sdt sdt_entry[ACPI_MAX_TABLES] __initdata;
 
 void acpi_table_print(struct acpi_table_header *header, unsigned long phys_addr)
 {

commit 4be44fcd3bf648b782f4460fd06dfae6c42ded4b
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 5 00:44:28 2005 -0400

    [ACPI] Lindent all ACPI files
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index fb64bd5d2e18..a2bf25b05e1c 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -40,25 +40,25 @@
 #define ACPI_MAX_TABLES		256
 
 static char *acpi_table_signatures[ACPI_TABLE_COUNT] = {
-	[ACPI_TABLE_UNKNOWN]	= "????",
-	[ACPI_APIC]		= "APIC",
-	[ACPI_BOOT]		= "BOOT",
-	[ACPI_DBGP]		= "DBGP",
-	[ACPI_DSDT]		= "DSDT",
-	[ACPI_ECDT]		= "ECDT",
-	[ACPI_ETDT]		= "ETDT",
-	[ACPI_FADT]		= "FACP",
-	[ACPI_FACS]		= "FACS",
-	[ACPI_OEMX]		= "OEM",
-	[ACPI_PSDT]		= "PSDT",
-	[ACPI_SBST]		= "SBST",
-	[ACPI_SLIT]		= "SLIT",
-	[ACPI_SPCR]		= "SPCR",
-	[ACPI_SRAT]		= "SRAT",
-	[ACPI_SSDT]		= "SSDT",
-	[ACPI_SPMI]		= "SPMI",
-	[ACPI_HPET]		= "HPET",
-	[ACPI_MCFG]		= "MCFG",
+	[ACPI_TABLE_UNKNOWN] = "????",
+	[ACPI_APIC] = "APIC",
+	[ACPI_BOOT] = "BOOT",
+	[ACPI_DBGP] = "DBGP",
+	[ACPI_DSDT] = "DSDT",
+	[ACPI_ECDT] = "ECDT",
+	[ACPI_ETDT] = "ETDT",
+	[ACPI_FADT] = "FACP",
+	[ACPI_FACS] = "FACS",
+	[ACPI_OEMX] = "OEM",
+	[ACPI_PSDT] = "PSDT",
+	[ACPI_SBST] = "SBST",
+	[ACPI_SLIT] = "SLIT",
+	[ACPI_SPCR] = "SPCR",
+	[ACPI_SRAT] = "SRAT",
+	[ACPI_SSDT] = "SSDT",
+	[ACPI_SPMI] = "SPMI",
+	[ACPI_HPET] = "HPET",
+	[ACPI_MCFG] = "MCFG",
 };
 
 static char *mps_inti_flags_polarity[] = { "dfl", "high", "res", "low" };
@@ -66,52 +66,44 @@ static char *mps_inti_flags_trigger[] = { "dfl", "edge", "res", "level" };
 
 /* System Description Table (RSDT/XSDT) */
 struct acpi_table_sdt {
-	unsigned long		pa;
-	enum acpi_table_id	id;
-	unsigned long		size;
+	unsigned long pa;
+	enum acpi_table_id id;
+	unsigned long size;
 } __attribute__ ((packed));
 
-static unsigned long		sdt_pa;		/* Physical Address */
-static unsigned long		sdt_count;	/* Table count */
+static unsigned long sdt_pa;	/* Physical Address */
+static unsigned long sdt_count;	/* Table count */
 
-static struct acpi_table_sdt	sdt_entry[ACPI_MAX_TABLES];
+static struct acpi_table_sdt sdt_entry[ACPI_MAX_TABLES];
 
-void
-acpi_table_print (
-	struct acpi_table_header *header,
-	unsigned long		phys_addr)
+void acpi_table_print(struct acpi_table_header *header, unsigned long phys_addr)
 {
-	char			*name = NULL;
+	char *name = NULL;
 
 	if (!header)
 		return;
 
 	/* Some table signatures aren't good table names */
 
-	if (!strncmp((char *) &header->signature,
-		acpi_table_signatures[ACPI_APIC],
-		sizeof(header->signature))) {
+	if (!strncmp((char *)&header->signature,
+		     acpi_table_signatures[ACPI_APIC],
+		     sizeof(header->signature))) {
 		name = "MADT";
-	}
-	else if (!strncmp((char *) &header->signature,
-		acpi_table_signatures[ACPI_FADT],
-		sizeof(header->signature))) {
+	} else if (!strncmp((char *)&header->signature,
+			    acpi_table_signatures[ACPI_FADT],
+			    sizeof(header->signature))) {
 		name = "FADT";
-	}
-	else
+	} else
 		name = header->signature;
 
-	printk(KERN_DEBUG PREFIX "%.4s (v%3.3d %6.6s %8.8s 0x%08x %.4s 0x%08x) @ 0x%p\n",
-		name, header->revision, header->oem_id,
-		header->oem_table_id, header->oem_revision,
-		header->asl_compiler_id, header->asl_compiler_revision,
-		(void *) phys_addr);
+	printk(KERN_DEBUG PREFIX
+	       "%.4s (v%3.3d %6.6s %8.8s 0x%08x %.4s 0x%08x) @ 0x%p\n", name,
+	       header->revision, header->oem_id, header->oem_table_id,
+	       header->oem_revision, header->asl_compiler_id,
+	       header->asl_compiler_revision, (void *)phys_addr);
 }
 
-
-void
-acpi_table_print_madt_entry (
-	acpi_table_entry_header	*header)
+void acpi_table_print_madt_entry(acpi_table_entry_header * header)
 {
 	if (!header)
 		return;
@@ -119,113 +111,127 @@ acpi_table_print_madt_entry (
 	switch (header->type) {
 
 	case ACPI_MADT_LAPIC:
-	{
-		struct acpi_table_lapic *p =
-			(struct acpi_table_lapic*) header;
-		printk(KERN_INFO PREFIX "LAPIC (acpi_id[0x%02x] lapic_id[0x%02x] %s)\n",
-			p->acpi_id, p->id, p->flags.enabled?"enabled":"disabled");
-	}
+		{
+			struct acpi_table_lapic *p =
+			    (struct acpi_table_lapic *)header;
+			printk(KERN_INFO PREFIX
+			       "LAPIC (acpi_id[0x%02x] lapic_id[0x%02x] %s)\n",
+			       p->acpi_id, p->id,
+			       p->flags.enabled ? "enabled" : "disabled");
+		}
 		break;
 
 	case ACPI_MADT_IOAPIC:
-	{
-		struct acpi_table_ioapic *p =
-			(struct acpi_table_ioapic*) header;
-		printk(KERN_INFO PREFIX "IOAPIC (id[0x%02x] address[0x%08x] gsi_base[%d])\n",
-			p->id, p->address, p->global_irq_base);
-	}
+		{
+			struct acpi_table_ioapic *p =
+			    (struct acpi_table_ioapic *)header;
+			printk(KERN_INFO PREFIX
+			       "IOAPIC (id[0x%02x] address[0x%08x] gsi_base[%d])\n",
+			       p->id, p->address, p->global_irq_base);
+		}
 		break;
 
 	case ACPI_MADT_INT_SRC_OVR:
-	{
-		struct acpi_table_int_src_ovr *p =
-			(struct acpi_table_int_src_ovr*) header;
-		printk(KERN_INFO PREFIX "INT_SRC_OVR (bus %d bus_irq %d global_irq %d %s %s)\n",
-			p->bus, p->bus_irq, p->global_irq,
-			mps_inti_flags_polarity[p->flags.polarity],
-			mps_inti_flags_trigger[p->flags.trigger]);
-		if(p->flags.reserved)
-			printk(KERN_INFO PREFIX "INT_SRC_OVR unexpected reserved flags: 0x%x\n",
-				p->flags.reserved);
+		{
+			struct acpi_table_int_src_ovr *p =
+			    (struct acpi_table_int_src_ovr *)header;
+			printk(KERN_INFO PREFIX
+			       "INT_SRC_OVR (bus %d bus_irq %d global_irq %d %s %s)\n",
+			       p->bus, p->bus_irq, p->global_irq,
+			       mps_inti_flags_polarity[p->flags.polarity],
+			       mps_inti_flags_trigger[p->flags.trigger]);
+			if (p->flags.reserved)
+				printk(KERN_INFO PREFIX
+				       "INT_SRC_OVR unexpected reserved flags: 0x%x\n",
+				       p->flags.reserved);
 
-	}
+		}
 		break;
 
 	case ACPI_MADT_NMI_SRC:
-	{
-		struct acpi_table_nmi_src *p =
-			(struct acpi_table_nmi_src*) header;
-		printk(KERN_INFO PREFIX "NMI_SRC (%s %s global_irq %d)\n",
-			mps_inti_flags_polarity[p->flags.polarity],
-			mps_inti_flags_trigger[p->flags.trigger], p->global_irq);
-	}
+		{
+			struct acpi_table_nmi_src *p =
+			    (struct acpi_table_nmi_src *)header;
+			printk(KERN_INFO PREFIX
+			       "NMI_SRC (%s %s global_irq %d)\n",
+			       mps_inti_flags_polarity[p->flags.polarity],
+			       mps_inti_flags_trigger[p->flags.trigger],
+			       p->global_irq);
+		}
 		break;
 
 	case ACPI_MADT_LAPIC_NMI:
-	{
-		struct acpi_table_lapic_nmi *p =
-			(struct acpi_table_lapic_nmi*) header;
-		printk(KERN_INFO PREFIX "LAPIC_NMI (acpi_id[0x%02x] %s %s lint[0x%x])\n",
-			p->acpi_id,
-			mps_inti_flags_polarity[p->flags.polarity],
-			mps_inti_flags_trigger[p->flags.trigger], p->lint);
-	}
+		{
+			struct acpi_table_lapic_nmi *p =
+			    (struct acpi_table_lapic_nmi *)header;
+			printk(KERN_INFO PREFIX
+			       "LAPIC_NMI (acpi_id[0x%02x] %s %s lint[0x%x])\n",
+			       p->acpi_id,
+			       mps_inti_flags_polarity[p->flags.polarity],
+			       mps_inti_flags_trigger[p->flags.trigger],
+			       p->lint);
+		}
 		break;
 
 	case ACPI_MADT_LAPIC_ADDR_OVR:
-	{
-		struct acpi_table_lapic_addr_ovr *p =
-			(struct acpi_table_lapic_addr_ovr*) header;
-		printk(KERN_INFO PREFIX "LAPIC_ADDR_OVR (address[%p])\n",
-			(void *) (unsigned long) p->address);
-	}
+		{
+			struct acpi_table_lapic_addr_ovr *p =
+			    (struct acpi_table_lapic_addr_ovr *)header;
+			printk(KERN_INFO PREFIX
+			       "LAPIC_ADDR_OVR (address[%p])\n",
+			       (void *)(unsigned long)p->address);
+		}
 		break;
 
 	case ACPI_MADT_IOSAPIC:
-	{
-		struct acpi_table_iosapic *p =
-			(struct acpi_table_iosapic*) header;
-		printk(KERN_INFO PREFIX "IOSAPIC (id[0x%x] address[%p] gsi_base[%d])\n",
-			p->id, (void *) (unsigned long) p->address, p->global_irq_base);
-	}
+		{
+			struct acpi_table_iosapic *p =
+			    (struct acpi_table_iosapic *)header;
+			printk(KERN_INFO PREFIX
+			       "IOSAPIC (id[0x%x] address[%p] gsi_base[%d])\n",
+			       p->id, (void *)(unsigned long)p->address,
+			       p->global_irq_base);
+		}
 		break;
 
 	case ACPI_MADT_LSAPIC:
-	{
-		struct acpi_table_lsapic *p =
-			(struct acpi_table_lsapic*) header;
-		printk(KERN_INFO PREFIX "LSAPIC (acpi_id[0x%02x] lsapic_id[0x%02x] lsapic_eid[0x%02x] %s)\n",
-			p->acpi_id, p->id, p->eid, p->flags.enabled?"enabled":"disabled");
-	}
+		{
+			struct acpi_table_lsapic *p =
+			    (struct acpi_table_lsapic *)header;
+			printk(KERN_INFO PREFIX
+			       "LSAPIC (acpi_id[0x%02x] lsapic_id[0x%02x] lsapic_eid[0x%02x] %s)\n",
+			       p->acpi_id, p->id, p->eid,
+			       p->flags.enabled ? "enabled" : "disabled");
+		}
 		break;
 
 	case ACPI_MADT_PLAT_INT_SRC:
-	{
-		struct acpi_table_plat_int_src *p =
-			(struct acpi_table_plat_int_src*) header;
-		printk(KERN_INFO PREFIX "PLAT_INT_SRC (%s %s type[0x%x] id[0x%04x] eid[0x%x] iosapic_vector[0x%x] global_irq[0x%x]\n",
-			mps_inti_flags_polarity[p->flags.polarity],
-			mps_inti_flags_trigger[p->flags.trigger],
-			p->type, p->id, p->eid, p->iosapic_vector, p->global_irq);
-	}
+		{
+			struct acpi_table_plat_int_src *p =
+			    (struct acpi_table_plat_int_src *)header;
+			printk(KERN_INFO PREFIX
+			       "PLAT_INT_SRC (%s %s type[0x%x] id[0x%04x] eid[0x%x] iosapic_vector[0x%x] global_irq[0x%x]\n",
+			       mps_inti_flags_polarity[p->flags.polarity],
+			       mps_inti_flags_trigger[p->flags.trigger],
+			       p->type, p->id, p->eid, p->iosapic_vector,
+			       p->global_irq);
+		}
 		break;
 
 	default:
-		printk(KERN_WARNING PREFIX "Found unsupported MADT entry (type = 0x%x)\n",
-			header->type);
+		printk(KERN_WARNING PREFIX
+		       "Found unsupported MADT entry (type = 0x%x)\n",
+		       header->type);
 		break;
 	}
 }
 
-
 static int
-acpi_table_compute_checksum (
-	void			*table_pointer,
-	unsigned long		length)
+acpi_table_compute_checksum(void *table_pointer, unsigned long length)
 {
-	u8			*p = (u8 *) table_pointer;
-	unsigned long		remains = length;
-	unsigned long		sum = 0;
+	u8 *p = (u8 *) table_pointer;
+	unsigned long remains = length;
+	unsigned long sum = 0;
 
 	if (!p || !length)
 		return -EINVAL;
@@ -241,9 +247,8 @@ acpi_table_compute_checksum (
  * for acpi_blacklisted(), acpi_table_get_sdt()
  */
 int __init
-acpi_get_table_header_early (
-	enum acpi_table_id	id,
-	struct acpi_table_header **header)
+acpi_get_table_header_early(enum acpi_table_id id,
+			    struct acpi_table_header **header)
 {
 	unsigned int i;
 	enum acpi_table_id temp_id;
@@ -260,7 +265,7 @@ acpi_get_table_header_early (
 		if (sdt_entry[i].id != temp_id)
 			continue;
 		*header = (void *)
-			__acpi_map_table(sdt_entry[i].pa, sdt_entry[i].size);
+		    __acpi_map_table(sdt_entry[i].pa, sdt_entry[i].size);
 		if (!*header) {
 			printk(KERN_WARNING PREFIX "Unable to map %s\n",
 			       acpi_table_signatures[temp_id]);
@@ -277,14 +282,17 @@ acpi_get_table_header_early (
 
 	/* Map the DSDT header via the pointer in the FADT */
 	if (id == ACPI_DSDT) {
-		struct fadt_descriptor_rev2 *fadt = (struct fadt_descriptor_rev2 *) *header;
+		struct fadt_descriptor_rev2 *fadt =
+		    (struct fadt_descriptor_rev2 *)*header;
 
 		if (fadt->revision == 3 && fadt->Xdsdt) {
-			*header = (void *) __acpi_map_table(fadt->Xdsdt,
-					sizeof(struct acpi_table_header));
+			*header = (void *)__acpi_map_table(fadt->Xdsdt,
+							   sizeof(struct
+								  acpi_table_header));
 		} else if (fadt->V1_dsdt) {
-			*header = (void *) __acpi_map_table(fadt->V1_dsdt,
-					sizeof(struct acpi_table_header));
+			*header = (void *)__acpi_map_table(fadt->V1_dsdt,
+							   sizeof(struct
+								  acpi_table_header));
 		} else
 			*header = NULL;
 
@@ -296,21 +304,19 @@ acpi_get_table_header_early (
 
 	return 0;
 }
-	 
 
 int __init
-acpi_table_parse_madt_family (
-	enum acpi_table_id	id,
-	unsigned long		madt_size,
-	int			entry_id,
-	acpi_madt_entry_handler	handler,
-	unsigned int		max_entries)
+acpi_table_parse_madt_family(enum acpi_table_id id,
+			     unsigned long madt_size,
+			     int entry_id,
+			     acpi_madt_entry_handler handler,
+			     unsigned int max_entries)
 {
-	void			*madt = NULL;
-	acpi_table_entry_header	*entry;
-	unsigned int		count = 0;
-	unsigned long		madt_end;
-	unsigned int		i;
+	void *madt = NULL;
+	acpi_table_entry_header *entry;
+	unsigned int count = 0;
+	unsigned long madt_end;
+	unsigned int i;
 
 	if (!handler)
 		return -EINVAL;
@@ -321,7 +327,7 @@ acpi_table_parse_madt_family (
 		if (sdt_entry[i].id != id)
 			continue;
 		madt = (void *)
-			__acpi_map_table(sdt_entry[i].pa, sdt_entry[i].size);
+		    __acpi_map_table(sdt_entry[i].pa, sdt_entry[i].size);
 		if (!madt) {
 			printk(KERN_WARNING PREFIX "Unable to map %s\n",
 			       acpi_table_signatures[id]);
@@ -336,21 +342,22 @@ acpi_table_parse_madt_family (
 		return -ENODEV;
 	}
 
-	madt_end = (unsigned long) madt + sdt_entry[i].size;
+	madt_end = (unsigned long)madt + sdt_entry[i].size;
 
 	/* Parse all entries looking for a match. */
 
 	entry = (acpi_table_entry_header *)
-		((unsigned long) madt + madt_size);
+	    ((unsigned long)madt + madt_size);
 
-	while (((unsigned long) entry) + sizeof(acpi_table_entry_header) < madt_end) {
-		if (entry->type == entry_id &&
-		    (!max_entries || count++ < max_entries))
+	while (((unsigned long)entry) + sizeof(acpi_table_entry_header) <
+	       madt_end) {
+		if (entry->type == entry_id
+		    && (!max_entries || count++ < max_entries))
 			if (handler(entry, madt_end))
 				return -EINVAL;
 
 		entry = (acpi_table_entry_header *)
-			((unsigned long) entry + entry->length);
+		    ((unsigned long)entry + entry->length);
 	}
 	if (max_entries && count > max_entries) {
 		printk(KERN_WARNING PREFIX "[%s:0x%02x] ignored %i entries of "
@@ -361,25 +368,19 @@ acpi_table_parse_madt_family (
 	return count;
 }
 
-
 int __init
-acpi_table_parse_madt (
-	enum acpi_madt_entry_id	id,
-	acpi_madt_entry_handler	handler,
-	unsigned int max_entries)
+acpi_table_parse_madt(enum acpi_madt_entry_id id,
+		      acpi_madt_entry_handler handler, unsigned int max_entries)
 {
-	return acpi_table_parse_madt_family(ACPI_APIC, sizeof(struct acpi_table_madt),
-					    id, handler, max_entries);
+	return acpi_table_parse_madt_family(ACPI_APIC,
+					    sizeof(struct acpi_table_madt), id,
+					    handler, max_entries);
 }
 
-
-int __init
-acpi_table_parse (
-	enum acpi_table_id	id,
-	acpi_table_handler	handler)
+int __init acpi_table_parse(enum acpi_table_id id, acpi_table_handler handler)
 {
-	int			count = 0;
-	unsigned int		i = 0;
+	int count = 0;
+	unsigned int i = 0;
 
 	if (!handler)
 		return -EINVAL;
@@ -392,20 +393,18 @@ acpi_table_parse (
 			handler(sdt_entry[i].pa, sdt_entry[i].size);
 
 		else
-			printk(KERN_WARNING PREFIX "%d duplicate %s table ignored.\n",
-				count, acpi_table_signatures[id]);
+			printk(KERN_WARNING PREFIX
+			       "%d duplicate %s table ignored.\n", count,
+			       acpi_table_signatures[id]);
 	}
 
 	return count;
 }
 
-
-static int __init
-acpi_table_get_sdt (
-	struct acpi_table_rsdp	*rsdp)
+static int __init acpi_table_get_sdt(struct acpi_table_rsdp *rsdp)
 {
 	struct acpi_table_header *header = NULL;
-	unsigned int		i, id = 0;
+	unsigned int i, id = 0;
 
 	if (!rsdp)
 		return -EINVAL;
@@ -413,24 +412,25 @@ acpi_table_get_sdt (
 	/* First check XSDT (but only on ACPI 2.0-compatible systems) */
 
 	if ((rsdp->revision >= 2) &&
-		(((struct acpi20_table_rsdp*)rsdp)->xsdt_address)) {
-			
-		struct acpi_table_xsdt	*mapped_xsdt = NULL;
+	    (((struct acpi20_table_rsdp *)rsdp)->xsdt_address)) {
+
+		struct acpi_table_xsdt *mapped_xsdt = NULL;
 
-		sdt_pa = ((struct acpi20_table_rsdp*)rsdp)->xsdt_address;
+		sdt_pa = ((struct acpi20_table_rsdp *)rsdp)->xsdt_address;
 
 		/* map in just the header */
 		header = (struct acpi_table_header *)
-			__acpi_map_table(sdt_pa, sizeof(struct acpi_table_header));
+		    __acpi_map_table(sdt_pa, sizeof(struct acpi_table_header));
 
 		if (!header) {
-			printk(KERN_WARNING PREFIX "Unable to map XSDT header\n");
+			printk(KERN_WARNING PREFIX
+			       "Unable to map XSDT header\n");
 			return -ENODEV;
 		}
 
 		/* remap in the entire table before processing */
 		mapped_xsdt = (struct acpi_table_xsdt *)
-			__acpi_map_table(sdt_pa, header->length);
+		    __acpi_map_table(sdt_pa, header->length);
 		if (!mapped_xsdt) {
 			printk(KERN_WARNING PREFIX "Unable to map XSDT\n");
 			return -ENODEV;
@@ -438,7 +438,8 @@ acpi_table_get_sdt (
 		header = &mapped_xsdt->header;
 
 		if (strncmp(header->signature, "XSDT", 4)) {
-			printk(KERN_WARNING PREFIX "XSDT signature incorrect\n");
+			printk(KERN_WARNING PREFIX
+			       "XSDT signature incorrect\n");
 			return -ENODEV;
 		}
 
@@ -447,36 +448,39 @@ acpi_table_get_sdt (
 			return -ENODEV;
 		}
 
-		sdt_count = (header->length - sizeof(struct acpi_table_header)) >> 3;
+		sdt_count =
+		    (header->length - sizeof(struct acpi_table_header)) >> 3;
 		if (sdt_count > ACPI_MAX_TABLES) {
-			printk(KERN_WARNING PREFIX "Truncated %lu XSDT entries\n",
-				(sdt_count - ACPI_MAX_TABLES));
+			printk(KERN_WARNING PREFIX
+			       "Truncated %lu XSDT entries\n",
+			       (sdt_count - ACPI_MAX_TABLES));
 			sdt_count = ACPI_MAX_TABLES;
 		}
 
 		for (i = 0; i < sdt_count; i++)
-			sdt_entry[i].pa = (unsigned long) mapped_xsdt->entry[i];
+			sdt_entry[i].pa = (unsigned long)mapped_xsdt->entry[i];
 	}
 
 	/* Then check RSDT */
 
 	else if (rsdp->rsdt_address) {
 
-		struct acpi_table_rsdt	*mapped_rsdt = NULL;
+		struct acpi_table_rsdt *mapped_rsdt = NULL;
 
 		sdt_pa = rsdp->rsdt_address;
 
 		/* map in just the header */
 		header = (struct acpi_table_header *)
-			__acpi_map_table(sdt_pa, sizeof(struct acpi_table_header));
+		    __acpi_map_table(sdt_pa, sizeof(struct acpi_table_header));
 		if (!header) {
-			printk(KERN_WARNING PREFIX "Unable to map RSDT header\n");
+			printk(KERN_WARNING PREFIX
+			       "Unable to map RSDT header\n");
 			return -ENODEV;
 		}
 
 		/* remap in the entire table before processing */
 		mapped_rsdt = (struct acpi_table_rsdt *)
-			__acpi_map_table(sdt_pa, header->length);
+		    __acpi_map_table(sdt_pa, header->length);
 		if (!mapped_rsdt) {
 			printk(KERN_WARNING PREFIX "Unable to map RSDT\n");
 			return -ENODEV;
@@ -484,7 +488,8 @@ acpi_table_get_sdt (
 		header = &mapped_rsdt->header;
 
 		if (strncmp(header->signature, "RSDT", 4)) {
-			printk(KERN_WARNING PREFIX "RSDT signature incorrect\n");
+			printk(KERN_WARNING PREFIX
+			       "RSDT signature incorrect\n");
 			return -ENODEV;
 		}
 
@@ -493,19 +498,22 @@ acpi_table_get_sdt (
 			return -ENODEV;
 		}
 
-		sdt_count = (header->length - sizeof(struct acpi_table_header)) >> 2;
+		sdt_count =
+		    (header->length - sizeof(struct acpi_table_header)) >> 2;
 		if (sdt_count > ACPI_MAX_TABLES) {
-			printk(KERN_WARNING PREFIX "Truncated %lu RSDT entries\n",
-				(sdt_count - ACPI_MAX_TABLES));
+			printk(KERN_WARNING PREFIX
+			       "Truncated %lu RSDT entries\n",
+			       (sdt_count - ACPI_MAX_TABLES));
 			sdt_count = ACPI_MAX_TABLES;
 		}
 
 		for (i = 0; i < sdt_count; i++)
-			sdt_entry[i].pa = (unsigned long) mapped_rsdt->entry[i];
+			sdt_entry[i].pa = (unsigned long)mapped_rsdt->entry[i];
 	}
 
 	else {
-		printk(KERN_WARNING PREFIX "No System Description Table (RSDT/XSDT) specified in RSDP\n");
+		printk(KERN_WARNING PREFIX
+		       "No System Description Table (RSDT/XSDT) specified in RSDP\n");
 		return -ENODEV;
 	}
 
@@ -515,18 +523,17 @@ acpi_table_get_sdt (
 
 		/* map in just the header */
 		header = (struct acpi_table_header *)
-			__acpi_map_table(sdt_entry[i].pa,
-				sizeof(struct acpi_table_header));
+		    __acpi_map_table(sdt_entry[i].pa,
+				     sizeof(struct acpi_table_header));
 		if (!header)
 			continue;
 
 		/* remap in the entire table before processing */
 		header = (struct acpi_table_header *)
-			__acpi_map_table(sdt_entry[i].pa,
-				header->length);
+		    __acpi_map_table(sdt_entry[i].pa, header->length);
 		if (!header)
 			continue;
-	               
+
 		acpi_table_print(header, sdt_entry[i].pa);
 
 		if (acpi_table_compute_checksum(header, header->length)) {
@@ -537,9 +544,9 @@ acpi_table_get_sdt (
 		sdt_entry[i].size = header->length;
 
 		for (id = 0; id < ACPI_TABLE_COUNT; id++) {
-			if (!strncmp((char *) &header->signature,
-				acpi_table_signatures[id],
-				sizeof(header->signature))) {
+			if (!strncmp((char *)&header->signature,
+				     acpi_table_signatures[id],
+				     sizeof(header->signature))) {
 				sdt_entry[i].id = id;
 			}
 		}
@@ -551,7 +558,7 @@ acpi_table_get_sdt (
 	 * against. Unfortunately, we don't know the phys_addr, so just
 	 * print 0. Maybe no one will notice.
 	 */
-	if(!acpi_get_table_header_early(ACPI_DSDT, &header))
+	if (!acpi_get_table_header_early(ACPI_DSDT, &header))
 		acpi_table_print(header, 0);
 
 	return 0;
@@ -566,12 +573,11 @@ acpi_table_get_sdt (
  * result: sdt_entry[] is initialized
  */
 
-int __init
-acpi_table_init (void)
+int __init acpi_table_init(void)
 {
-	struct acpi_table_rsdp	*rsdp = NULL;
-	unsigned long		rsdp_phys = 0;
-	int			result = 0;
+	struct acpi_table_rsdp *rsdp = NULL;
+	unsigned long rsdp_phys = 0;
+	int result = 0;
 
 	/* Locate and map the Root System Description Table (RSDP) */
 
@@ -581,19 +587,25 @@ acpi_table_init (void)
 		return -ENODEV;
 	}
 
-	rsdp = (struct acpi_table_rsdp *) __va(rsdp_phys);
+	rsdp = (struct acpi_table_rsdp *)__va(rsdp_phys);
 	if (!rsdp) {
 		printk(KERN_WARNING PREFIX "Unable to map RSDP\n");
 		return -ENODEV;
 	}
 
-	printk(KERN_DEBUG PREFIX "RSDP (v%3.3d %6.6s                                ) @ 0x%p\n",
-		rsdp->revision, rsdp->oem_id, (void *) rsdp_phys);
+	printk(KERN_DEBUG PREFIX
+	       "RSDP (v%3.3d %6.6s                                ) @ 0x%p\n",
+	       rsdp->revision, rsdp->oem_id, (void *)rsdp_phys);
 
 	if (rsdp->revision < 2)
-		result = acpi_table_compute_checksum(rsdp, sizeof(struct acpi_table_rsdp));
+		result =
+		    acpi_table_compute_checksum(rsdp,
+						sizeof(struct acpi_table_rsdp));
 	else
-		result = acpi_table_compute_checksum(rsdp, ((struct acpi20_table_rsdp *)rsdp)->length);
+		result =
+		    acpi_table_compute_checksum(rsdp,
+						((struct acpi20_table_rsdp *)
+						 rsdp)->length);
 
 	if (result) {
 		printk(KERN_WARNING "  >>> ERROR: Invalid checksum\n");

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
new file mode 100644
index 000000000000..fb64bd5d2e18
--- /dev/null
+++ b/drivers/acpi/tables.c
@@ -0,0 +1,609 @@
+/*
+ *  acpi_tables.c - ACPI Boot-Time Table Parsing
+ *
+ *  Copyright (C) 2001 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/irq.h>
+#include <linux/errno.h>
+#include <linux/acpi.h>
+#include <linux/bootmem.h>
+
+#define PREFIX			"ACPI: "
+
+#define ACPI_MAX_TABLES		256
+
+static char *acpi_table_signatures[ACPI_TABLE_COUNT] = {
+	[ACPI_TABLE_UNKNOWN]	= "????",
+	[ACPI_APIC]		= "APIC",
+	[ACPI_BOOT]		= "BOOT",
+	[ACPI_DBGP]		= "DBGP",
+	[ACPI_DSDT]		= "DSDT",
+	[ACPI_ECDT]		= "ECDT",
+	[ACPI_ETDT]		= "ETDT",
+	[ACPI_FADT]		= "FACP",
+	[ACPI_FACS]		= "FACS",
+	[ACPI_OEMX]		= "OEM",
+	[ACPI_PSDT]		= "PSDT",
+	[ACPI_SBST]		= "SBST",
+	[ACPI_SLIT]		= "SLIT",
+	[ACPI_SPCR]		= "SPCR",
+	[ACPI_SRAT]		= "SRAT",
+	[ACPI_SSDT]		= "SSDT",
+	[ACPI_SPMI]		= "SPMI",
+	[ACPI_HPET]		= "HPET",
+	[ACPI_MCFG]		= "MCFG",
+};
+
+static char *mps_inti_flags_polarity[] = { "dfl", "high", "res", "low" };
+static char *mps_inti_flags_trigger[] = { "dfl", "edge", "res", "level" };
+
+/* System Description Table (RSDT/XSDT) */
+struct acpi_table_sdt {
+	unsigned long		pa;
+	enum acpi_table_id	id;
+	unsigned long		size;
+} __attribute__ ((packed));
+
+static unsigned long		sdt_pa;		/* Physical Address */
+static unsigned long		sdt_count;	/* Table count */
+
+static struct acpi_table_sdt	sdt_entry[ACPI_MAX_TABLES];
+
+void
+acpi_table_print (
+	struct acpi_table_header *header,
+	unsigned long		phys_addr)
+{
+	char			*name = NULL;
+
+	if (!header)
+		return;
+
+	/* Some table signatures aren't good table names */
+
+	if (!strncmp((char *) &header->signature,
+		acpi_table_signatures[ACPI_APIC],
+		sizeof(header->signature))) {
+		name = "MADT";
+	}
+	else if (!strncmp((char *) &header->signature,
+		acpi_table_signatures[ACPI_FADT],
+		sizeof(header->signature))) {
+		name = "FADT";
+	}
+	else
+		name = header->signature;
+
+	printk(KERN_DEBUG PREFIX "%.4s (v%3.3d %6.6s %8.8s 0x%08x %.4s 0x%08x) @ 0x%p\n",
+		name, header->revision, header->oem_id,
+		header->oem_table_id, header->oem_revision,
+		header->asl_compiler_id, header->asl_compiler_revision,
+		(void *) phys_addr);
+}
+
+
+void
+acpi_table_print_madt_entry (
+	acpi_table_entry_header	*header)
+{
+	if (!header)
+		return;
+
+	switch (header->type) {
+
+	case ACPI_MADT_LAPIC:
+	{
+		struct acpi_table_lapic *p =
+			(struct acpi_table_lapic*) header;
+		printk(KERN_INFO PREFIX "LAPIC (acpi_id[0x%02x] lapic_id[0x%02x] %s)\n",
+			p->acpi_id, p->id, p->flags.enabled?"enabled":"disabled");
+	}
+		break;
+
+	case ACPI_MADT_IOAPIC:
+	{
+		struct acpi_table_ioapic *p =
+			(struct acpi_table_ioapic*) header;
+		printk(KERN_INFO PREFIX "IOAPIC (id[0x%02x] address[0x%08x] gsi_base[%d])\n",
+			p->id, p->address, p->global_irq_base);
+	}
+		break;
+
+	case ACPI_MADT_INT_SRC_OVR:
+	{
+		struct acpi_table_int_src_ovr *p =
+			(struct acpi_table_int_src_ovr*) header;
+		printk(KERN_INFO PREFIX "INT_SRC_OVR (bus %d bus_irq %d global_irq %d %s %s)\n",
+			p->bus, p->bus_irq, p->global_irq,
+			mps_inti_flags_polarity[p->flags.polarity],
+			mps_inti_flags_trigger[p->flags.trigger]);
+		if(p->flags.reserved)
+			printk(KERN_INFO PREFIX "INT_SRC_OVR unexpected reserved flags: 0x%x\n",
+				p->flags.reserved);
+
+	}
+		break;
+
+	case ACPI_MADT_NMI_SRC:
+	{
+		struct acpi_table_nmi_src *p =
+			(struct acpi_table_nmi_src*) header;
+		printk(KERN_INFO PREFIX "NMI_SRC (%s %s global_irq %d)\n",
+			mps_inti_flags_polarity[p->flags.polarity],
+			mps_inti_flags_trigger[p->flags.trigger], p->global_irq);
+	}
+		break;
+
+	case ACPI_MADT_LAPIC_NMI:
+	{
+		struct acpi_table_lapic_nmi *p =
+			(struct acpi_table_lapic_nmi*) header;
+		printk(KERN_INFO PREFIX "LAPIC_NMI (acpi_id[0x%02x] %s %s lint[0x%x])\n",
+			p->acpi_id,
+			mps_inti_flags_polarity[p->flags.polarity],
+			mps_inti_flags_trigger[p->flags.trigger], p->lint);
+	}
+		break;
+
+	case ACPI_MADT_LAPIC_ADDR_OVR:
+	{
+		struct acpi_table_lapic_addr_ovr *p =
+			(struct acpi_table_lapic_addr_ovr*) header;
+		printk(KERN_INFO PREFIX "LAPIC_ADDR_OVR (address[%p])\n",
+			(void *) (unsigned long) p->address);
+	}
+		break;
+
+	case ACPI_MADT_IOSAPIC:
+	{
+		struct acpi_table_iosapic *p =
+			(struct acpi_table_iosapic*) header;
+		printk(KERN_INFO PREFIX "IOSAPIC (id[0x%x] address[%p] gsi_base[%d])\n",
+			p->id, (void *) (unsigned long) p->address, p->global_irq_base);
+	}
+		break;
+
+	case ACPI_MADT_LSAPIC:
+	{
+		struct acpi_table_lsapic *p =
+			(struct acpi_table_lsapic*) header;
+		printk(KERN_INFO PREFIX "LSAPIC (acpi_id[0x%02x] lsapic_id[0x%02x] lsapic_eid[0x%02x] %s)\n",
+			p->acpi_id, p->id, p->eid, p->flags.enabled?"enabled":"disabled");
+	}
+		break;
+
+	case ACPI_MADT_PLAT_INT_SRC:
+	{
+		struct acpi_table_plat_int_src *p =
+			(struct acpi_table_plat_int_src*) header;
+		printk(KERN_INFO PREFIX "PLAT_INT_SRC (%s %s type[0x%x] id[0x%04x] eid[0x%x] iosapic_vector[0x%x] global_irq[0x%x]\n",
+			mps_inti_flags_polarity[p->flags.polarity],
+			mps_inti_flags_trigger[p->flags.trigger],
+			p->type, p->id, p->eid, p->iosapic_vector, p->global_irq);
+	}
+		break;
+
+	default:
+		printk(KERN_WARNING PREFIX "Found unsupported MADT entry (type = 0x%x)\n",
+			header->type);
+		break;
+	}
+}
+
+
+static int
+acpi_table_compute_checksum (
+	void			*table_pointer,
+	unsigned long		length)
+{
+	u8			*p = (u8 *) table_pointer;
+	unsigned long		remains = length;
+	unsigned long		sum = 0;
+
+	if (!p || !length)
+		return -EINVAL;
+
+	while (remains--)
+		sum += *p++;
+
+	return (sum & 0xFF);
+}
+
+/*
+ * acpi_get_table_header_early()
+ * for acpi_blacklisted(), acpi_table_get_sdt()
+ */
+int __init
+acpi_get_table_header_early (
+	enum acpi_table_id	id,
+	struct acpi_table_header **header)
+{
+	unsigned int i;
+	enum acpi_table_id temp_id;
+
+	/* DSDT is different from the rest */
+	if (id == ACPI_DSDT)
+		temp_id = ACPI_FADT;
+	else
+		temp_id = id;
+
+	/* Locate the table. */
+
+	for (i = 0; i < sdt_count; i++) {
+		if (sdt_entry[i].id != temp_id)
+			continue;
+		*header = (void *)
+			__acpi_map_table(sdt_entry[i].pa, sdt_entry[i].size);
+		if (!*header) {
+			printk(KERN_WARNING PREFIX "Unable to map %s\n",
+			       acpi_table_signatures[temp_id]);
+			return -ENODEV;
+		}
+		break;
+	}
+
+	if (!*header) {
+		printk(KERN_WARNING PREFIX "%s not present\n",
+		       acpi_table_signatures[id]);
+		return -ENODEV;
+	}
+
+	/* Map the DSDT header via the pointer in the FADT */
+	if (id == ACPI_DSDT) {
+		struct fadt_descriptor_rev2 *fadt = (struct fadt_descriptor_rev2 *) *header;
+
+		if (fadt->revision == 3 && fadt->Xdsdt) {
+			*header = (void *) __acpi_map_table(fadt->Xdsdt,
+					sizeof(struct acpi_table_header));
+		} else if (fadt->V1_dsdt) {
+			*header = (void *) __acpi_map_table(fadt->V1_dsdt,
+					sizeof(struct acpi_table_header));
+		} else
+			*header = NULL;
+
+		if (!*header) {
+			printk(KERN_WARNING PREFIX "Unable to map DSDT\n");
+			return -ENODEV;
+		}
+	}
+
+	return 0;
+}
+	 
+
+int __init
+acpi_table_parse_madt_family (
+	enum acpi_table_id	id,
+	unsigned long		madt_size,
+	int			entry_id,
+	acpi_madt_entry_handler	handler,
+	unsigned int		max_entries)
+{
+	void			*madt = NULL;
+	acpi_table_entry_header	*entry;
+	unsigned int		count = 0;
+	unsigned long		madt_end;
+	unsigned int		i;
+
+	if (!handler)
+		return -EINVAL;
+
+	/* Locate the MADT (if exists). There should only be one. */
+
+	for (i = 0; i < sdt_count; i++) {
+		if (sdt_entry[i].id != id)
+			continue;
+		madt = (void *)
+			__acpi_map_table(sdt_entry[i].pa, sdt_entry[i].size);
+		if (!madt) {
+			printk(KERN_WARNING PREFIX "Unable to map %s\n",
+			       acpi_table_signatures[id]);
+			return -ENODEV;
+		}
+		break;
+	}
+
+	if (!madt) {
+		printk(KERN_WARNING PREFIX "%s not present\n",
+		       acpi_table_signatures[id]);
+		return -ENODEV;
+	}
+
+	madt_end = (unsigned long) madt + sdt_entry[i].size;
+
+	/* Parse all entries looking for a match. */
+
+	entry = (acpi_table_entry_header *)
+		((unsigned long) madt + madt_size);
+
+	while (((unsigned long) entry) + sizeof(acpi_table_entry_header) < madt_end) {
+		if (entry->type == entry_id &&
+		    (!max_entries || count++ < max_entries))
+			if (handler(entry, madt_end))
+				return -EINVAL;
+
+		entry = (acpi_table_entry_header *)
+			((unsigned long) entry + entry->length);
+	}
+	if (max_entries && count > max_entries) {
+		printk(KERN_WARNING PREFIX "[%s:0x%02x] ignored %i entries of "
+		       "%i found\n", acpi_table_signatures[id], entry_id,
+		       count - max_entries, count);
+	}
+
+	return count;
+}
+
+
+int __init
+acpi_table_parse_madt (
+	enum acpi_madt_entry_id	id,
+	acpi_madt_entry_handler	handler,
+	unsigned int max_entries)
+{
+	return acpi_table_parse_madt_family(ACPI_APIC, sizeof(struct acpi_table_madt),
+					    id, handler, max_entries);
+}
+
+
+int __init
+acpi_table_parse (
+	enum acpi_table_id	id,
+	acpi_table_handler	handler)
+{
+	int			count = 0;
+	unsigned int		i = 0;
+
+	if (!handler)
+		return -EINVAL;
+
+	for (i = 0; i < sdt_count; i++) {
+		if (sdt_entry[i].id != id)
+			continue;
+		count++;
+		if (count == 1)
+			handler(sdt_entry[i].pa, sdt_entry[i].size);
+
+		else
+			printk(KERN_WARNING PREFIX "%d duplicate %s table ignored.\n",
+				count, acpi_table_signatures[id]);
+	}
+
+	return count;
+}
+
+
+static int __init
+acpi_table_get_sdt (
+	struct acpi_table_rsdp	*rsdp)
+{
+	struct acpi_table_header *header = NULL;
+	unsigned int		i, id = 0;
+
+	if (!rsdp)
+		return -EINVAL;
+
+	/* First check XSDT (but only on ACPI 2.0-compatible systems) */
+
+	if ((rsdp->revision >= 2) &&
+		(((struct acpi20_table_rsdp*)rsdp)->xsdt_address)) {
+			
+		struct acpi_table_xsdt	*mapped_xsdt = NULL;
+
+		sdt_pa = ((struct acpi20_table_rsdp*)rsdp)->xsdt_address;
+
+		/* map in just the header */
+		header = (struct acpi_table_header *)
+			__acpi_map_table(sdt_pa, sizeof(struct acpi_table_header));
+
+		if (!header) {
+			printk(KERN_WARNING PREFIX "Unable to map XSDT header\n");
+			return -ENODEV;
+		}
+
+		/* remap in the entire table before processing */
+		mapped_xsdt = (struct acpi_table_xsdt *)
+			__acpi_map_table(sdt_pa, header->length);
+		if (!mapped_xsdt) {
+			printk(KERN_WARNING PREFIX "Unable to map XSDT\n");
+			return -ENODEV;
+		}
+		header = &mapped_xsdt->header;
+
+		if (strncmp(header->signature, "XSDT", 4)) {
+			printk(KERN_WARNING PREFIX "XSDT signature incorrect\n");
+			return -ENODEV;
+		}
+
+		if (acpi_table_compute_checksum(header, header->length)) {
+			printk(KERN_WARNING PREFIX "Invalid XSDT checksum\n");
+			return -ENODEV;
+		}
+
+		sdt_count = (header->length - sizeof(struct acpi_table_header)) >> 3;
+		if (sdt_count > ACPI_MAX_TABLES) {
+			printk(KERN_WARNING PREFIX "Truncated %lu XSDT entries\n",
+				(sdt_count - ACPI_MAX_TABLES));
+			sdt_count = ACPI_MAX_TABLES;
+		}
+
+		for (i = 0; i < sdt_count; i++)
+			sdt_entry[i].pa = (unsigned long) mapped_xsdt->entry[i];
+	}
+
+	/* Then check RSDT */
+
+	else if (rsdp->rsdt_address) {
+
+		struct acpi_table_rsdt	*mapped_rsdt = NULL;
+
+		sdt_pa = rsdp->rsdt_address;
+
+		/* map in just the header */
+		header = (struct acpi_table_header *)
+			__acpi_map_table(sdt_pa, sizeof(struct acpi_table_header));
+		if (!header) {
+			printk(KERN_WARNING PREFIX "Unable to map RSDT header\n");
+			return -ENODEV;
+		}
+
+		/* remap in the entire table before processing */
+		mapped_rsdt = (struct acpi_table_rsdt *)
+			__acpi_map_table(sdt_pa, header->length);
+		if (!mapped_rsdt) {
+			printk(KERN_WARNING PREFIX "Unable to map RSDT\n");
+			return -ENODEV;
+		}
+		header = &mapped_rsdt->header;
+
+		if (strncmp(header->signature, "RSDT", 4)) {
+			printk(KERN_WARNING PREFIX "RSDT signature incorrect\n");
+			return -ENODEV;
+		}
+
+		if (acpi_table_compute_checksum(header, header->length)) {
+			printk(KERN_WARNING PREFIX "Invalid RSDT checksum\n");
+			return -ENODEV;
+		}
+
+		sdt_count = (header->length - sizeof(struct acpi_table_header)) >> 2;
+		if (sdt_count > ACPI_MAX_TABLES) {
+			printk(KERN_WARNING PREFIX "Truncated %lu RSDT entries\n",
+				(sdt_count - ACPI_MAX_TABLES));
+			sdt_count = ACPI_MAX_TABLES;
+		}
+
+		for (i = 0; i < sdt_count; i++)
+			sdt_entry[i].pa = (unsigned long) mapped_rsdt->entry[i];
+	}
+
+	else {
+		printk(KERN_WARNING PREFIX "No System Description Table (RSDT/XSDT) specified in RSDP\n");
+		return -ENODEV;
+	}
+
+	acpi_table_print(header, sdt_pa);
+
+	for (i = 0; i < sdt_count; i++) {
+
+		/* map in just the header */
+		header = (struct acpi_table_header *)
+			__acpi_map_table(sdt_entry[i].pa,
+				sizeof(struct acpi_table_header));
+		if (!header)
+			continue;
+
+		/* remap in the entire table before processing */
+		header = (struct acpi_table_header *)
+			__acpi_map_table(sdt_entry[i].pa,
+				header->length);
+		if (!header)
+			continue;
+	               
+		acpi_table_print(header, sdt_entry[i].pa);
+
+		if (acpi_table_compute_checksum(header, header->length)) {
+			printk(KERN_WARNING "  >>> ERROR: Invalid checksum\n");
+			continue;
+		}
+
+		sdt_entry[i].size = header->length;
+
+		for (id = 0; id < ACPI_TABLE_COUNT; id++) {
+			if (!strncmp((char *) &header->signature,
+				acpi_table_signatures[id],
+				sizeof(header->signature))) {
+				sdt_entry[i].id = id;
+			}
+		}
+	}
+
+	/* 
+	 * The DSDT is *not* in the RSDT (why not? no idea.) but we want
+	 * to print its info, because this is what people usually blacklist
+	 * against. Unfortunately, we don't know the phys_addr, so just
+	 * print 0. Maybe no one will notice.
+	 */
+	if(!acpi_get_table_header_early(ACPI_DSDT, &header))
+		acpi_table_print(header, 0);
+
+	return 0;
+}
+
+/*
+ * acpi_table_init()
+ *
+ * find RSDP, find and checksum SDT/XSDT.
+ * checksum all tables, print SDT/XSDT
+ * 
+ * result: sdt_entry[] is initialized
+ */
+
+int __init
+acpi_table_init (void)
+{
+	struct acpi_table_rsdp	*rsdp = NULL;
+	unsigned long		rsdp_phys = 0;
+	int			result = 0;
+
+	/* Locate and map the Root System Description Table (RSDP) */
+
+	rsdp_phys = acpi_find_rsdp();
+	if (!rsdp_phys) {
+		printk(KERN_ERR PREFIX "Unable to locate RSDP\n");
+		return -ENODEV;
+	}
+
+	rsdp = (struct acpi_table_rsdp *) __va(rsdp_phys);
+	if (!rsdp) {
+		printk(KERN_WARNING PREFIX "Unable to map RSDP\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_DEBUG PREFIX "RSDP (v%3.3d %6.6s                                ) @ 0x%p\n",
+		rsdp->revision, rsdp->oem_id, (void *) rsdp_phys);
+
+	if (rsdp->revision < 2)
+		result = acpi_table_compute_checksum(rsdp, sizeof(struct acpi_table_rsdp));
+	else
+		result = acpi_table_compute_checksum(rsdp, ((struct acpi20_table_rsdp *)rsdp)->length);
+
+	if (result) {
+		printk(KERN_WARNING "  >>> ERROR: Invalid checksum\n");
+		return -ENODEV;
+	}
+
+	/* Locate and map the System Description table (RSDT/XSDT) */
+
+	if (acpi_table_get_sdt(rsdp))
+		return -ENODEV;
+
+	return 0;
+}
