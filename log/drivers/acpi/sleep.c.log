commit 118d6e98293b30aee378a6b08d27a35320a3e34f
Merge: 355ba37d756c 48ccdeddc547
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 2 13:25:52 2020 -0700

    Merge tag 'acpi-5.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI updates from Rafael Wysocki:
     "These update the ACPICA code in the kernel to upstream revision
      20200430, fix several reference counting errors related to ACPI
      tables, add _Exx / _Lxx support to the GED driver, add a new
      acpi_evaluate_reg() helper, add new DPTF battery participant driver
      and extend the DPFT power participant driver, improve the handling of
      memory failures in the APEI code, add a blacklist entry to the
      backlight driver, update the PMIC driver and the processor idle
      driver, fix two kobject reference count leaks, and make a few janitory
      changes.
    
      Specifics:
    
       - Update the ACPICA code in the kernel to upstream revision 20200430:
    
          - Move acpi_gbl_next_cmd_num definition (Erik Kaneda).
    
          - Ignore AE_ALREADY_EXISTS status in the disassembler when parsing
            create operators (Erik Kaneda).
    
          - Add status checks to the dispatcher (Erik Kaneda).
    
          - Fix required parameters for _NIG and _NIH (Erik Kaneda).
    
          - Make acpi_protocol_lengths static (Yue Haibing).
    
       - Fix ACPI table reference counting errors in several places, mostly
         in error code paths (Hanjun Guo).
    
       - Extend the Generic Event Device (GED) driver to support _Exx and
         _Lxx handler methods (Ard Biesheuvel).
    
       - Add new acpi_evaluate_reg() helper and modify the ACPI PCI hotplug
         code to use it (Hans de Goede).
    
       - Add new DPTF battery participant driver and make the DPFT power
         participant driver create more sysfs device attributes (Srinivas
         Pandruvada).
    
       - Improve the handling of memory failures in APEI (James Morse).
    
       - Add new blacklist entry for Acer TravelMate 5735Z to the backlight
         driver (Paul Menzel).
    
       - Add i2c address for thermal control to the PMIC driver (Mauro
         Carvalho Chehab).
    
       - Allow the ACPI processor idle driver to work on platforms with only
         one ACPI C-state present (Zhang Rui).
    
       - Fix kobject reference count leaks in error code paths in two places
         (Qiushi Wu).
    
       - Delete unused proc filename macros and make some symbols static
         (Pascal Terjan, Zheng Zengkai, Zou Wei)"
    
    * tag 'acpi-5.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (32 commits)
      ACPI: CPPC: Fix reference count leak in acpi_cppc_processor_probe()
      ACPI: sysfs: Fix reference count leak in acpi_sysfs_add_hotplug_profile()
      ACPI: GED: use correct trigger type field in _Exx / _Lxx handling
      ACPI: DPTF: Add battery participant driver
      ACPI: DPTF: Additional sysfs attributes for power participant driver
      ACPI: video: Use native backlight on Acer TravelMate 5735Z
      arm64: acpi: Make apei_claim_sea() synchronise with APEI's irq work
      ACPI: APEI: Kick the memory_failure() queue for synchronous errors
      mm/memory-failure: Add memory_failure_queue_kick()
      ACPI / PMIC: Add i2c address for thermal control
      ACPI: GED: add support for _Exx / _Lxx handler methods
      ACPI: Delete unused proc filename macros
      ACPI: hotplug: PCI: Use the new acpi_evaluate_reg() helper
      ACPI: utils: Add acpi_evaluate_reg() helper
      ACPI: debug: Make two functions static
      ACPI: sleep: Put the FACS table after using it
      ACPI: scan: Put SPCR and STAO table after using it
      ACPI: EC: Put the ACPI table after using it
      ACPI: APEI: Put the HEST table for error path
      ACPI: APEI: Put the error record serialization table for error path
      ...

commit 48c604151a55629ea0a2c22c51a331a3360dbdbc
Merge: 6e6c25283dff 2d2feb681317 95722237cb2a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 1 15:22:05 2020 +0200

    Merge branches 'acpica' and 'acpi-tables'
    
    * acpica:
      ACPICA: Update version to 20200430
      ACPICA: Fix required parameters for _NIG and _NIH
      ACPICA: Dispatcher: add status checks
      ACPICA: Disassembler: ignore AE_ALREADY_EXISTS status when parsing create operators
      ACPICA: Move acpi_gbl_next_cmd_num definition to acglobal.h
      ACPICA: Make acpi_protocol_lengths static
    
    * acpi-tables:
      ACPI: sleep: Put the FACS table after using it
      ACPI: scan: Put SPCR and STAO table after using it
      ACPI: EC: Put the ACPI table after using it
      ACPI: APEI: Put the HEST table for error path
      ACPI: APEI: Put the error record serialization table for error path
      ACPI: APEI: Put the error injection table for error path and module exit
      ACPI: APEI: Put the boot error record table after parsing
      ACPI: watchdog: Put the watchdog action table after parsing
      ACPI: LPIT: Put the low power idle table after using it

commit 3441362b08dc16669adc0e7d3f3454ae38619229
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue May 19 13:36:48 2020 +0200

    ACPI: PM: s2idle: Print type of wakeup debug messages
    
    Since acpi_s2idle_wake() knows the category of wakeup causing the
    system to resume from suspend-to-idle, make it print a unique message
    for each of them to help diagnose wakeup issues.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index fd9d4e8318e9..31c9d0c8ae11 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -992,23 +992,31 @@ static bool acpi_s2idle_wake(void)
 		 * wakeup is pending anyway and the SCI is not the source of
 		 * it).
 		 */
-		if (irqd_is_wakeup_armed(irq_get_irq_data(acpi_sci_irq)))
+		if (irqd_is_wakeup_armed(irq_get_irq_data(acpi_sci_irq))) {
+			pm_pr_dbg("Wakeup unrelated to ACPI SCI\n");
 			return true;
+		}
 
 		/*
 		 * If the status bit of any enabled fixed event is set, the
 		 * wakeup is regarded as valid.
 		 */
-		if (acpi_any_fixed_event_status_set())
+		if (acpi_any_fixed_event_status_set()) {
+			pm_pr_dbg("ACPI fixed event wakeup\n");
 			return true;
+		}
 
 		/* Check wakeups from drivers sharing the SCI. */
-		if (acpi_check_wakeup_handlers())
+		if (acpi_check_wakeup_handlers()) {
+			pm_pr_dbg("ACPI custom handler wakeup\n");
 			return true;
+		}
 
 		/* Check non-EC GPE wakeups and dispatch the EC GPE. */
-		if (acpi_ec_dispatch_gpe())
+		if (acpi_ec_dispatch_gpe()) {
+			pm_pr_dbg("ACPI non-EC GPE wakeup\n");
 			return true;
+		}
 
 		/*
 		 * Cancel the SCI wakeup and process all pending events in case
@@ -1027,8 +1035,10 @@ static bool acpi_s2idle_wake(void)
 		 * are pending here, they must be resulting from the processing
 		 * of EC events above or coming from somewhere else.
 		 */
-		if (pm_wakeup_pending())
+		if (pm_wakeup_pending()) {
+			pm_pr_dbg("Wakeup after ACPI Notify sync\n");
 			return true;
+		}
 
 		rearm_wake_irq(acpi_sci_irq);
 	}

commit 607b9df63057a56f6172d560d5366cca6a030c76
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 15 12:58:19 2020 +0200

    ACPI: EC: PM: Avoid flushing EC work when EC GPE is inactive
    
    Flushing the EC work while suspended to idle when the EC GPE status
    is not set causes some EC wakeup events (notably power button and
    lid ones) to be missed after a series of spurious wakeups on the Dell
    XPS13 9360 in my office.
    
    If that happens, the machine cannot be woken up from suspend-to-idle
    by the power button or lid status change and it needs to be woken up
    in some other way (eg. by a key press).
    
    Flushing the EC work only after successful dispatching the EC GPE,
    which means that its status has been set, avoids the issue, so change
    the code in question accordingly.
    
    Fixes: 7b301750f7f8 ("ACPI: EC: PM: Avoid premature returns from acpi_s2idle_wake()")
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Chris Chiu <chiu@endlessm.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 3850704570c0..fd9d4e8318e9 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -980,13 +980,6 @@ static int acpi_s2idle_prepare_late(void)
 	return 0;
 }
 
-static void acpi_s2idle_sync(void)
-{
-	/* The EC driver uses special workqueues that need to be flushed. */
-	acpi_ec_flush_work();
-	acpi_os_wait_events_complete(); /* synchronize Notify handling */
-}
-
 static bool acpi_s2idle_wake(void)
 {
 	if (!acpi_sci_irq_valid())
@@ -1018,7 +1011,7 @@ static bool acpi_s2idle_wake(void)
 			return true;
 
 		/*
-		 * Cancel the wakeup and process all pending events in case
+		 * Cancel the SCI wakeup and process all pending events in case
 		 * there are any wakeup ones in there.
 		 *
 		 * Note that if any non-EC GPEs are active at this point, the
@@ -1026,8 +1019,7 @@ static bool acpi_s2idle_wake(void)
 		 * should be missed by canceling the wakeup here.
 		 */
 		pm_system_cancel_wakeup();
-
-		acpi_s2idle_sync();
+		acpi_os_wait_events_complete();
 
 		/*
 		 * The SCI is in the "suspended" state now and it cannot produce
@@ -1060,7 +1052,8 @@ static void acpi_s2idle_restore(void)
 	 * of GPEs.
 	 */
 	acpi_os_wait_events_complete(); /* synchronize GPE processing */
-	acpi_s2idle_sync();
+	acpi_ec_flush_work(); /* flush the EC driver's workqueues */
+	acpi_os_wait_events_complete(); /* synchronize Notify handling */
 
 	s2idle_wakeup = false;
 

commit 7b301750f7f8f6503e11f1af4a03832525f58c66
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat May 9 10:44:41 2020 +0200

    ACPI: EC: PM: Avoid premature returns from acpi_s2idle_wake()
    
    If the EC GPE status is not set after checking all of the other GPEs,
    acpi_s2idle_wake() returns 'false', to indicate that the SCI event
    that has just triggered is not a system wakeup one, but it does that
    without canceling the pending wakeup and re-arming the SCI for system
    wakeup which is a mistake, because it may cause s2idle_loop() to busy
    spin until the next valid wakeup event.  [If that happens, the first
    spurious wakeup is still pending after acpi_s2idle_wake() has
    returned, so s2idle_enter() does nothing, acpi_s2idle_wake()
    is called again and it sees that the SCI has triggered, but no GPEs
    are active, so 'false' is returned again, and so on.]
    
    Fix that by moving all of the GPE checking logic from
    acpi_s2idle_wake() to acpi_ec_dispatch_gpe() and making the
    latter return 'true' only if a non-EC GPE has triggered and
    'false' otherwise, which will cause acpi_s2idle_wake() to
    cancel the pending SCI wakeup and re-arm the SCI for system
    wakeup regardless of the EC GPE status.
    
    This also addresses a lockup observed on an Elitegroup EF20EA laptop
    after attempting to wake it up from suspend-to-idle by a key press.
    
    Fixes: d5406284ff80 ("ACPI: PM: s2idle: Refine active GPEs check")
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=207603
    Reported-by: Todd Brandt <todd.e.brandt@linux.intel.com>
    Fixes: fdde0ff8590b ("ACPI: PM: s2idle: Prevent spurious SCIs from waking up the system")
    Link: https://lore.kernel.org/linux-acpi/CAB4CAwdqo7=MvyG_PE+PGVfeA17AHF5i5JucgaKqqMX6mjArbQ@mail.gmail.com/
    Reported-by: Chris Chiu <chiu@endlessm.com>
    Tested-by: Chris Chiu <chiu@endlessm.com>
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 4edc8a3ce40f..3850704570c0 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -1013,20 +1013,10 @@ static bool acpi_s2idle_wake(void)
 		if (acpi_check_wakeup_handlers())
 			return true;
 
-		/*
-		 * If the status bit is set for any enabled GPE other than the
-		 * EC one, the wakeup is regarded as a genuine one.
-		 */
-		if (acpi_ec_other_gpes_active())
+		/* Check non-EC GPE wakeups and dispatch the EC GPE. */
+		if (acpi_ec_dispatch_gpe())
 			return true;
 
-		/*
-		 * If the EC GPE status bit has not been set, the wakeup is
-		 * regarded as a spurious one.
-		 */
-		if (!acpi_ec_dispatch_gpe())
-			return false;
-
 		/*
 		 * Cancel the wakeup and process all pending events in case
 		 * there are any wakeup ones in there.

commit 95722237cb2ae4f7b73471058cdb19e8f4057c93
Author: Hanjun Guo <guohanjun@huawei.com>
Date:   Thu May 7 17:09:21 2020 +0800

    ACPI: sleep: Put the FACS table after using it
    
    Put the FACS table after using it to release the table
    mapping.
    
    Signed-off-by: Hanjun Guo <guohanjun@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 4edc8a3ce40f..30e2df9b4e0d 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -1297,8 +1297,10 @@ static void acpi_sleep_hibernate_setup(void)
 		return;
 
 	acpi_get_table(ACPI_SIG_FACS, 1, (struct acpi_table_header **)&facs);
-	if (facs)
+	if (facs) {
 		s4_hardware_signature = facs->hardware_signature;
+		acpi_put_table((struct acpi_table_header *)facs);
+	}
 }
 #else /* !CONFIG_HIBERNATION */
 static inline void acpi_sleep_hibernate_setup(void) {}

commit ddfd9dcf270ce23ed1985b66fcfa163920e2e1b8
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Apr 3 17:48:33 2020 +0200

    ACPI: PM: Add acpi_[un]register_wakeup_handler()
    
    Since commit fdde0ff8590b ("ACPI: PM: s2idle: Prevent spurious SCIs from
    waking up the system") the SCI triggering without there being a wakeup
    cause recognized by the ACPI sleep code will no longer wakeup the system.
    
    This works as intended, but this is a problem for devices where the SCI
    is shared with another device which is also a wakeup source.
    
    In the past these, from the pov of the ACPI sleep code, spurious SCIs
    would still cause a wakeup so the wakeup from the device sharing the
    interrupt would actually wakeup the system. This now no longer works.
    
    This is a problem on e.g. Bay Trail-T and Cherry Trail devices where
    some peripherals (typically the XHCI controller) can signal a
    Power Management Event (PME) to the Power Management Controller (PMC)
    to wakeup the system, this uses the same interrupt as the SCI.
    These wakeups are handled through a special INT0002 ACPI device which
    checks for events in the GPE0a_STS for this and takes care of acking
    the PME so that the shared interrupt stops triggering.
    
    The change to the ACPI sleep code to ignore the spurious SCI, causes
    the system to no longer wakeup on these PME events. To make things
    worse this means that the INT0002 device driver interrupt handler will
    no longer run, causing the PME to not get cleared and resulting in the
    system hanging. Trying to wakeup the system after such a PME through e.g.
    the power button no longer works.
    
    Add an acpi_register_wakeup_handler() function which registers
    a handler to be called from acpi_s2idle_wake() and when the handler
    returns true, return true from acpi_s2idle_wake().
    
    The INT0002 driver will use this mechanism to check the GPE0a_STS
    register from acpi_s2idle_wake() and to tell the system to wakeup
    if a PME is signaled in the register.
    
    Fixes: fdde0ff8590b ("ACPI: PM: s2idle: Prevent spurious SCIs from waking up the system")
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index bb1ae400ec1f..4edc8a3ce40f 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -1009,6 +1009,10 @@ static bool acpi_s2idle_wake(void)
 		if (acpi_any_fixed_event_status_set())
 			return true;
 
+		/* Check wakeups from drivers sharing the SCI. */
+		if (acpi_check_wakeup_handlers())
+			return true;
+
 		/*
 		 * If the status bit is set for any enabled GPE other than the
 		 * EC one, the wakeup is regarded as a genuine one.

commit d5406284ff803a578ca503373624312770319054
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Mar 25 11:55:48 2020 +0100

    ACPI: PM: s2idle: Refine active GPEs check
    
    The check for any active GPEs added by commit fdde0ff8590b ("ACPI:
    PM: s2idle: Prevent spurious SCIs from waking up the system") turns
    out to be insufficiently precise to prevent some systems from
    resuming prematurely due to a spurious EC wakeup, so refine it
    by first checking if any GPEs other than the EC GPE are active
    and skipping all of the SCIs coming from the EC that do not produce
    any genuine wakeup events after processing.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=206629
    Fixes: fdde0ff8590b ("ACPI: PM: s2idle: Prevent spurious SCIs from waking up the system")
    Reported-by: Ondřej Caletka <ondrej@caletka.cz>
    Tested-by: Ondřej Caletka <ondrej@caletka.cz>
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index a66078644fc5..bb1ae400ec1f 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -1010,18 +1010,19 @@ static bool acpi_s2idle_wake(void)
 			return true;
 
 		/*
-		 * If there are no EC events to process and at least one of the
-		 * other enabled GPEs is active, the wakeup is regarded as a
-		 * genuine one.
-		 *
-		 * Note that the checks below must be carried out in this order
-		 * to avoid returning prematurely due to a change of the EC GPE
-		 * status bit from unset to set between the checks with the
-		 * status bits of all the other GPEs unset.
+		 * If the status bit is set for any enabled GPE other than the
+		 * EC one, the wakeup is regarded as a genuine one.
 		 */
-		if (acpi_any_gpe_status_set(U32_MAX) && !acpi_ec_dispatch_gpe())
+		if (acpi_ec_other_gpes_active())
 			return true;
 
+		/*
+		 * If the EC GPE status bit has not been set, the wakeup is
+		 * regarded as a spurious one.
+		 */
+		if (!acpi_ec_dispatch_gpe())
+			return false;
+
 		/*
 		 * Cancel the wakeup and process all pending events in case
 		 * there are any wakeup ones in there.

commit 0ce792d660bda990c675eaf14ce09594a9b85cbf
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Mar 25 11:54:29 2020 +0100

    ACPICA: Allow acpi_any_gpe_status_set() to skip one GPE
    
    The check carried out by acpi_any_gpe_status_set() is not precise enough
    for the suspend-to-idle implementation in Linux and in some cases it is
    necessary make it skip one GPE (specifically, the EC GPE) from the check
    to prevent a race condition leading to a premature system resume from
    occurring.
    
    For this reason, redefine acpi_any_gpe_status_set() to take the number
    of a GPE to skip as an argument.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=206629
    Tested-by: Ondřej Caletka <ondrej@caletka.cz>
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 22b8af33e15f..a66078644fc5 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -1019,7 +1019,7 @@ static bool acpi_s2idle_wake(void)
 		 * status bit from unset to set between the checks with the
 		 * status bits of all the other GPEs unset.
 		 */
-		if (acpi_any_gpe_status_set() && !acpi_ec_dispatch_gpe())
+		if (acpi_any_gpe_status_set(U32_MAX) && !acpi_ec_dispatch_gpe())
 			return true;
 
 		/*

commit 243a98894dc525ad2fbeb608722fcb682be3186d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 20 15:07:29 2020 +0100

    ACPI: PM: s2idle: Fix comment in acpi_s2idle_prepare_late()
    
    Fix a comment in acpi_s2idle_prepare_late() that has become outdated
    after commit f0ac20c3f613 ("ACPI: EC: Fix flushing of pending work").
    
    Fixes: f0ac20c3f613 ("ACPI: EC: Fix flushing of pending work")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index e5f95922bc21..22b8af33e15f 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -982,10 +982,7 @@ static int acpi_s2idle_prepare_late(void)
 
 static void acpi_s2idle_sync(void)
 {
-	/*
-	 * The EC driver uses the system workqueue and an additional special
-	 * one, so those need to be flushed too.
-	 */
+	/* The EC driver uses special workqueues that need to be flushed. */
 	acpi_ec_flush_work();
 	acpi_os_wait_events_complete(); /* synchronize Notify handling */
 }

commit 63fb9623427fbb44e3782233b6e4714057b76ff2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 21 01:46:18 2020 +0100

    ACPI: PM: s2idle: Check fixed wakeup events in acpi_s2idle_wake()
    
    Commit fdde0ff8590b ("ACPI: PM: s2idle: Prevent spurious SCIs from
    waking up the system") overlooked the fact that fixed events can wake
    up the system too and broke RTC wakeup from suspend-to-idle as a
    result.
    
    Fix this issue by checking the fixed events in acpi_s2idle_wake() in
    addition to checking wakeup GPEs and break out of the suspend-to-idle
    loop if the status bits of any enabled fixed events are set then.
    
    Fixes: fdde0ff8590b ("ACPI: PM: s2idle: Prevent spurious SCIs from waking up the system")
    Reported-and-tested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 152f7fc0b200..e5f95922bc21 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -1005,6 +1005,13 @@ static bool acpi_s2idle_wake(void)
 		if (irqd_is_wakeup_armed(irq_get_irq_data(acpi_sci_irq)))
 			return true;
 
+		/*
+		 * If the status bit of any enabled fixed event is set, the
+		 * wakeup is regarded as valid.
+		 */
+		if (acpi_any_fixed_event_status_set())
+			return true;
+
 		/*
 		 * If there are no EC events to process and at least one of the
 		 * other enabled GPEs is active, the wakeup is regarded as a

commit fdde0ff8590b4c1c41b3227f5ac4265fccccb96b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 11 17:53:52 2020 +0100

    ACPI: PM: s2idle: Prevent spurious SCIs from waking up the system
    
    If the platform triggers a spurious SCI even though the status bit
    is not set for any GPE when the system is suspended to idle, it will
    be treated as a genuine wakeup, so avoid that by checking if any GPEs
    are active at all before returning 'true' from acpi_s2idle_wake().
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=206413
    Fixes: 56b991849009 ("PM: sleep: Simplify suspend-to-idle control flow")
    Reported-by: Tsuchiya Yuto <kitakar@gmail.com>
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 2c695b196cd2..152f7fc0b200 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -1006,10 +1006,16 @@ static bool acpi_s2idle_wake(void)
 			return true;
 
 		/*
-		 * If there are no EC events to process, the wakeup is regarded
-		 * as a genuine one.
+		 * If there are no EC events to process and at least one of the
+		 * other enabled GPEs is active, the wakeup is regarded as a
+		 * genuine one.
+		 *
+		 * Note that the checks below must be carried out in this order
+		 * to avoid returning prematurely due to a change of the EC GPE
+		 * status bit from unset to set between the checks with the
+		 * status bits of all the other GPEs unset.
 		 */
-		if (!acpi_ec_dispatch_gpe())
+		if (acpi_any_gpe_status_set() && !acpi_ec_dispatch_gpe())
 			return true;
 
 		/*

commit e3728b50cd9be7d4b1469447cdf1feb93e3b7adb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 11 10:11:02 2020 +0100

    ACPI: PM: s2idle: Avoid possible race related to the EC GPE
    
    It is theoretically possible for the ACPI EC GPE to be set after the
    s2idle_ops->wake() called from s2idle_loop() has returned and before
    the subsequent pm_wakeup_pending() check is carried out.  If that
    happens, the resulting wakeup event will cause the system to resume
    even though it may be a spurious one.
    
    To avoid that race, first make the ->wake() callback in struct
    platform_s2idle_ops return a bool value indicating whether or not
    to let the system resume and rearrange s2idle_loop() to use that
    value instad of the direct pm_wakeup_pending() call if ->wake() is
    present.
    
    Next, rework acpi_s2idle_wake() to process EC events and check
    pm_wakeup_pending() before re-arming the SCI for system wakeup
    to prevent it from triggering prematurely and add comments to
    that function to explain the rationale for the new code flow.
    
    Fixes: 56b991849009 ("PM: sleep: Simplify suspend-to-idle control flow")
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 439880629839..2c695b196cd2 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -990,21 +990,28 @@ static void acpi_s2idle_sync(void)
 	acpi_os_wait_events_complete(); /* synchronize Notify handling */
 }
 
-static void acpi_s2idle_wake(void)
+static bool acpi_s2idle_wake(void)
 {
-	/*
-	 * If IRQD_WAKEUP_ARMED is set for the SCI at this point, the SCI has
-	 * not triggered while suspended, so bail out.
-	 */
-	if (!acpi_sci_irq_valid() ||
-	    irqd_is_wakeup_armed(irq_get_irq_data(acpi_sci_irq)))
-		return;
+	if (!acpi_sci_irq_valid())
+		return pm_wakeup_pending();
+
+	while (pm_wakeup_pending()) {
+		/*
+		 * If IRQD_WAKEUP_ARMED is set for the SCI at this point, the
+		 * SCI has not triggered while suspended, so bail out (the
+		 * wakeup is pending anyway and the SCI is not the source of
+		 * it).
+		 */
+		if (irqd_is_wakeup_armed(irq_get_irq_data(acpi_sci_irq)))
+			return true;
+
+		/*
+		 * If there are no EC events to process, the wakeup is regarded
+		 * as a genuine one.
+		 */
+		if (!acpi_ec_dispatch_gpe())
+			return true;
 
-	/*
-	 * If there are EC events to process, the wakeup may be a spurious one
-	 * coming from the EC.
-	 */
-	if (acpi_ec_dispatch_gpe()) {
 		/*
 		 * Cancel the wakeup and process all pending events in case
 		 * there are any wakeup ones in there.
@@ -1017,8 +1024,19 @@ static void acpi_s2idle_wake(void)
 
 		acpi_s2idle_sync();
 
+		/*
+		 * The SCI is in the "suspended" state now and it cannot produce
+		 * new wakeup events till the rearming below, so if any of them
+		 * are pending here, they must be resulting from the processing
+		 * of EC events above or coming from somewhere else.
+		 */
+		if (pm_wakeup_pending())
+			return true;
+
 		rearm_wake_irq(acpi_sci_irq);
 	}
+
+	return false;
 }
 
 static void acpi_s2idle_restore_early(void)

commit 8c53b318b222eff55d2900b554094a099b1a30f6
Author: Sean Christopherson <sean.j.christopherson@intel.com>
Date:   Tue Nov 26 08:54:16 2019 -0800

    ACPI/sleep: Convert acpi_wakeup_address into a function
    
    Convert acpi_wakeup_address from a raw variable into a function so that
    x86 can wrap its dereference of the real mode boot header in a function
    instead of broadcasting it to the world via a #define.  This sets the
    stage for a future patch to move x86's definition of the new function,
    acpi_get_wakeup_address(), out of asm/acpi.h and thus break acpi.h's
    dependency on asm/realmode.h.
    
    No functional change intended.
    
    Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
    Link: https://lkml.kernel.org/r/20191126165417.22423-12-sean.j.christopherson@intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 6747a279621b..439880629839 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -61,8 +61,11 @@ static struct notifier_block tts_notifier = {
 static int acpi_sleep_prepare(u32 acpi_state)
 {
 #ifdef CONFIG_ACPI_SLEEP
+	unsigned long acpi_wakeup_address;
+
 	/* do we have a wakeup address for S2 and S3? */
 	if (acpi_state == ACPI_STATE_S3) {
+		acpi_wakeup_address = acpi_get_wakeup_address();
 		if (!acpi_wakeup_address)
 			return -EFAULT;
 		acpi_set_waking_vector(acpi_wakeup_address);

commit 024aa8732acb7d2503eae43c3fe3504d0a8646d0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 28 23:50:40 2019 +0100

    ACPI: PM: s2idle: Rework ACPI events synchronization
    
    Note that the EC GPE processing need not be synchronized in
    acpi_s2idle_wake() after invoking acpi_ec_dispatch_gpe(), because
    that function checks the GPE status and dispatches its handler if
    need be and the SCI action handler is not going to run anyway at
    that point.
    
    Moreover, it is better to drain all of the pending ACPI events
    before restoring the working-state configuration of GPEs in
    acpi_s2idle_restore(), because those events are likely to be related
    to system wakeup, in which case they will not be relevant going
    forward.
    
    Rework the code to take these observations into account.
    
    Tested-by: Kenneth R. Crudup <kenny@panix.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 2af937a8b1c5..6747a279621b 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -977,6 +977,16 @@ static int acpi_s2idle_prepare_late(void)
 	return 0;
 }
 
+static void acpi_s2idle_sync(void)
+{
+	/*
+	 * The EC driver uses the system workqueue and an additional special
+	 * one, so those need to be flushed too.
+	 */
+	acpi_ec_flush_work();
+	acpi_os_wait_events_complete(); /* synchronize Notify handling */
+}
+
 static void acpi_s2idle_wake(void)
 {
 	/*
@@ -1001,13 +1011,8 @@ static void acpi_s2idle_wake(void)
 		 * should be missed by canceling the wakeup here.
 		 */
 		pm_system_cancel_wakeup();
-		/*
-		 * The EC driver uses the system workqueue and an additional
-		 * special one, so those need to be flushed too.
-		 */
-		acpi_os_wait_events_complete(); /* synchronize EC GPE processing */
-		acpi_ec_flush_work();
-		acpi_os_wait_events_complete(); /* synchronize Notify handling */
+
+		acpi_s2idle_sync();
 
 		rearm_wake_irq(acpi_sci_irq);
 	}
@@ -1024,6 +1029,13 @@ static void acpi_s2idle_restore_early(void)
 
 static void acpi_s2idle_restore(void)
 {
+	/*
+	 * Drain pending events before restoring the working-state configuration
+	 * of GPEs.
+	 */
+	acpi_os_wait_events_complete(); /* synchronize GPE processing */
+	acpi_s2idle_sync();
+
 	s2idle_wakeup = false;
 
 	acpi_enable_all_runtime_gpes();

commit 2189624b3c5a6fb03416129e35c09aa5151b7392
Author: Mario Limonciello <mario.limonciello@dell.com>
Date:   Thu Sep 26 11:08:57 2019 -0500

    ACPI: PM: Drop Dell XPS13 9360 from LPS0 Idle _DSM blacklist
    
    This reverts part of commit 71630b7a832f ("ACPI / PM: Blacklist Low
    Power S0 Idle _DSM for Dell XPS13 9360") to remove the S0ix blacklist
    for the XPS 9360.
    
    The problems with this system occurred in one possible NVME SSD when
    putting system into s0ix.  As the NVME sleep behavior has been adjusted
    in commit d916b1be94b6 ("nvme-pci: use host managed power state for
    suspend") this is expected to be now resolved.
    
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=196907
    Signed-off-by: Mario Limonciello <mario.limonciello@dell.com>
    Tested-by: Paul Menzel <pmenzel@molgen.mpg.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 9fa77d72ef27..2af937a8b1c5 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -361,19 +361,6 @@ static const struct dmi_system_id acpisleep_dmi_table[] __initconst = {
 		DMI_MATCH(DMI_PRODUCT_NAME, "80E3"),
 		},
 	},
-	/*
-	 * https://bugzilla.kernel.org/show_bug.cgi?id=196907
-	 * Some Dell XPS13 9360 cannot do suspend-to-idle using the Low Power
-	 * S0 Idle firmware interface.
-	 */
-	{
-	.callback = init_default_s3,
-	.ident = "Dell XPS13 9360",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
-		DMI_MATCH(DMI_PRODUCT_NAME, "XPS 13 9360"),
-		},
-	},
 	/*
 	 * ThinkPad X1 Tablet(2016) cannot do suspend-to-idle using
 	 * the Low Power S0 Idle firmware interface (see

commit b90ff3554aa3e123bb7e6d08789f6fd92d86ddde
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 21 11:40:19 2019 +0200

    ACPI: PM: s2idle: Always set up EC GPE for system wakeup
    
    Commit 10a08fd65ec1 ("ACPI: PM: Set up EC GPE for system wakeup from
    drivers that need it") assumed that the EC GPE would only need to be
    set up for system wakeup if either the intel-hid or the intel-vbtn
    driver was in use, but that turns out to be incorrect.  In particular,
    on ASUS Zenbook UX430UNR/i7-8550U, if the EC GPE is not enabled while
    suspended, the system cannot be woken up by opening the lid or
    pressing a key, and that machine doesn't use any of the drivers
    mentioned above.
    
    For this reason, always set up the EC GPE for system wakeup from
    suspend-to-idle by setting and clearing its wake mask in the ACPI
    suspend-to-idle callbacks.
    
    Fixes: 10a08fd65ec1 ("ACPI: PM: Set up EC GPE for system wakeup from drivers that need it")
    Reported-by: Kristian Klausen <kristian@klausen.dk>
    Tested-by: Kristian Klausen <kristian@klausen.dk>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index c52ecbda863f..9fa77d72ef27 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -938,6 +938,13 @@ static int lps0_device_attach(struct acpi_device *adev,
 	if (mem_sleep_default > PM_SUSPEND_MEM && !acpi_sleep_default_s3)
 		mem_sleep_current = PM_SUSPEND_TO_IDLE;
 
+	/*
+	 * Some LPS0 systems, like ASUS Zenbook UX430UNR/i7-8550U, require the
+	 * EC GPE to be enabled while suspended for certain wakeup devices to
+	 * work, so mark it as wakeup-capable.
+	 */
+	acpi_ec_mark_gpe_for_wake();
+
 	return 0;
 }
 
@@ -954,8 +961,10 @@ static int acpi_s2idle_begin(void)
 
 static int acpi_s2idle_prepare(void)
 {
-	if (acpi_sci_irq_valid())
+	if (acpi_sci_irq_valid()) {
 		enable_irq_wake(acpi_sci_irq);
+		acpi_ec_set_gpe_wake_mask(ACPI_GPE_ENABLE);
+	}
 
 	acpi_enable_wakeup_devices(ACPI_STATE_S0);
 
@@ -1034,8 +1043,10 @@ static void acpi_s2idle_restore(void)
 
 	acpi_disable_wakeup_devices(ACPI_STATE_S0);
 
-	if (acpi_sci_irq_valid())
+	if (acpi_sci_irq_valid()) {
+		acpi_ec_set_gpe_wake_mask(ACPI_GPE_DISABLE);
 		disable_irq_wake(acpi_sci_irq);
+	}
 }
 
 static void acpi_s2idle_end(void)

commit 45dc1576e4575ba621cb6d017faf41531d8c1073
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Aug 19 12:35:03 2019 +0200

    ACPI: PM: s2idle: Avoid rearming SCI for wakeup unnecessarily
    
    It is only necessary to rearm the ACPI SCI for wakeup if
    pm_system_cancel_wakeup() has been called, so invoke
    rearm_wake_irq() only in that case.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 8f7e95f97e1f..c52ecbda863f 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -1012,9 +1012,9 @@ static void acpi_s2idle_wake(void)
 		acpi_os_wait_events_complete(); /* synchronize EC GPE processing */
 		acpi_ec_flush_work();
 		acpi_os_wait_events_complete(); /* synchronize Notify handling */
-	}
 
-	rearm_wake_irq(acpi_sci_irq);
+		rearm_wake_irq(acpi_sci_irq);
+	}
 }
 
 static void acpi_s2idle_restore_early(void)

commit ac9eafbe930abb589e9289842a99cc575cadb854
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 1 19:31:10 2019 +0200

    ACPI: PM: s2idle: Execute LPS0 _DSM functions with suspended devices
    
    According to Section 3.5 of the "Intel Low Power S0 Idle" document [1],
    Function 5 of the LPS0 _DSM is expected to be invoked when the system
    configuration matches the criteria for entering the target low-power
    state of the platform.  In particular, this means that all devices
    should be suspended and in low-power states already when that function
    is invoked.
    
    This is not the case currently, however, because Function 5 of the
    LPS0 _DSM is invoked by it before the "noirq" phase of device suspend,
    which means that some devices may not have been put into low-power
    states yet at that point.  That is a consequence of the previous
    design of the suspend-to-idle flow that allowed the "noirq" phase of
    device suspend and the "noirq" phase of device resume to be carried
    out for multiple times while "suspended" (if any spurious wakeup
    events were detected) and the point of the LPS0 _DSM Function 5
    invocation was chosen so as to call it (and LPS0 _DSM Function 6
    analogously) once per suspend-resume cycle (regardless of how many
    times the "noirq" phases of device suspend and resume were carried
    out while "suspended").
    
    Now that the suspend-to-idle flow has been redesigned to carry out
    the "noirq" phases of device suspend and resume once in each cycle,
    the code can be reordered to follow the specification that it is
    based on more closely.
    
    For this purpose, add ->prepare_late and ->restore_early platform
    callbacks for suspend-to-idle, to be executed, respectively, after
    the "noirq" phase of suspending devices and before the "noirq"
    phase of resuming them and make ACPI use them for the invocation
    of LPS0 _DSM functions as appropriate.
    
    While at it, move the LPS0 entry requirements check to be made
    before invoking Functions 3 and 5 of the LPS0 _DSM (also once
    per cycle) as follows from the specification [1].
    
    Link: https://uefi.org/sites/default/files/resources/Intel_ACPI_Low_Power_S0_Idle.pdf # [1]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 864bb18d3a5d..8f7e95f97e1f 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -954,11 +954,6 @@ static int acpi_s2idle_begin(void)
 
 static int acpi_s2idle_prepare(void)
 {
-	if (lps0_device_handle && !sleep_no_lps0) {
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_OFF);
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY);
-	}
-
 	if (acpi_sci_irq_valid())
 		enable_irq_wake(acpi_sci_irq);
 
@@ -972,11 +967,22 @@ static int acpi_s2idle_prepare(void)
 	return 0;
 }
 
-static void acpi_s2idle_wake(void)
+static int acpi_s2idle_prepare_late(void)
 {
-	if (lps0_device_handle && !sleep_no_lps0 && pm_debug_messages_on)
+	if (!lps0_device_handle || sleep_no_lps0)
+		return 0;
+
+	if (pm_debug_messages_on)
 		lpi_check_constraints();
 
+	acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_OFF);
+	acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY);
+
+	return 0;
+}
+
+static void acpi_s2idle_wake(void)
+{
 	/*
 	 * If IRQD_WAKEUP_ARMED is set for the SCI at this point, the SCI has
 	 * not triggered while suspended, so bail out.
@@ -1011,6 +1017,15 @@ static void acpi_s2idle_wake(void)
 	rearm_wake_irq(acpi_sci_irq);
 }
 
+static void acpi_s2idle_restore_early(void)
+{
+	if (!lps0_device_handle || sleep_no_lps0)
+		return;
+
+	acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT);
+	acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_ON);
+}
+
 static void acpi_s2idle_restore(void)
 {
 	s2idle_wakeup = false;
@@ -1021,11 +1036,6 @@ static void acpi_s2idle_restore(void)
 
 	if (acpi_sci_irq_valid())
 		disable_irq_wake(acpi_sci_irq);
-
-	if (lps0_device_handle && !sleep_no_lps0) {
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT);
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_ON);
-	}
 }
 
 static void acpi_s2idle_end(void)
@@ -1036,7 +1046,9 @@ static void acpi_s2idle_end(void)
 static const struct platform_s2idle_ops acpi_s2idle_ops = {
 	.begin = acpi_s2idle_begin,
 	.prepare = acpi_s2idle_prepare,
+	.prepare_late = acpi_s2idle_prepare_late,
 	.wake = acpi_s2idle_wake,
+	.restore_early = acpi_s2idle_restore_early,
 	.restore = acpi_s2idle_restore,
 	.end = acpi_s2idle_end,
 };

commit 6e86633a791fdf631617ef3a9af3263141d34bc9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 31 11:05:42 2019 +0200

    ACPI: PM: s2idle: Eliminate acpi_sleep_no_ec_events()
    
    Change acpi_ec_suspend() to use pm_suspend_no_platform() instead of
    acpi_sleep_no_ec_events(), which allows the latter to be eliminated
    along with the s2idle_in_progress variable which is only used by it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 4a94600fea39..864bb18d3a5d 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -696,7 +696,6 @@ static const struct platform_suspend_ops acpi_suspend_ops_old = {
 	.recover = acpi_pm_finish,
 };
 
-static bool s2idle_in_progress;
 static bool s2idle_wakeup;
 
 /*
@@ -950,7 +949,6 @@ static struct acpi_scan_handler lps0_handler = {
 static int acpi_s2idle_begin(void)
 {
 	acpi_scan_lock_acquire();
-	s2idle_in_progress = true;
 	return 0;
 }
 
@@ -1032,7 +1030,6 @@ static void acpi_s2idle_restore(void)
 
 static void acpi_s2idle_end(void)
 {
-	s2idle_in_progress = false;
 	acpi_scan_lock_release();
 }
 
@@ -1060,7 +1057,6 @@ static void acpi_sleep_suspend_setup(void)
 }
 
 #else /* !CONFIG_SUSPEND */
-#define s2idle_in_progress	(false)
 #define s2idle_wakeup		(false)
 #define lps0_device_handle	(NULL)
 static inline void acpi_sleep_suspend_setup(void) {}
@@ -1071,11 +1067,6 @@ bool acpi_s2idle_wakeup(void)
 	return s2idle_wakeup;
 }
 
-bool acpi_sleep_no_ec_events(void)
-{
-	return !s2idle_in_progress;
-}
-
 #ifdef CONFIG_PM_SLEEP
 static u32 saved_bm_rld;
 

commit 068b47d0984b8756ae71702a1a87aa226cb72fe8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 31 11:05:25 2019 +0200

    ACPI: PM: s2idle: Add acpi.sleep_no_lps0 module parameter
    
    Add a module parameter to prevent the ACPI LPS0 _DSM functions
    from being invoked (if need be) and rework the suspend-to-idle
    blacklist entries in acpisleep_dmi_table[] to make them simply
    prevent suspend-to-idle from being used by default on the systems
    in question (which really is the original purpose of those entries).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 3d706938980a..4a94600fea39 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -89,6 +89,10 @@ bool acpi_sleep_state_supported(u8 sleep_state)
 }
 
 #ifdef CONFIG_ACPI_SLEEP
+static bool sleep_no_lps0 __read_mostly;
+module_param(sleep_no_lps0, bool, 0644);
+MODULE_PARM_DESC(sleep_no_lps0, "Do not use the special LPS0 device interface");
+
 static u32 acpi_target_sleep_state = ACPI_STATE_S0;
 
 u32 acpi_target_system_state(void)
@@ -158,11 +162,11 @@ static int __init init_nvs_nosave(const struct dmi_system_id *d)
 	return 0;
 }
 
-static bool acpi_sleep_no_lps0;
+static bool acpi_sleep_default_s3;
 
-static int __init init_no_lps0(const struct dmi_system_id *d)
+static int __init init_default_s3(const struct dmi_system_id *d)
 {
-	acpi_sleep_no_lps0 = true;
+	acpi_sleep_default_s3 = true;
 	return 0;
 }
 
@@ -363,7 +367,7 @@ static const struct dmi_system_id acpisleep_dmi_table[] __initconst = {
 	 * S0 Idle firmware interface.
 	 */
 	{
-	.callback = init_no_lps0,
+	.callback = init_default_s3,
 	.ident = "Dell XPS13 9360",
 	.matches = {
 		DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
@@ -376,7 +380,7 @@ static const struct dmi_system_id acpisleep_dmi_table[] __initconst = {
 	 * https://bugzilla.kernel.org/show_bug.cgi?id=199057).
 	 */
 	{
-	.callback = init_no_lps0,
+	.callback = init_default_s3,
 	.ident = "ThinkPad X1 Tablet(2016)",
 	.matches = {
 		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
@@ -524,8 +528,9 @@ static void acpi_pm_end(void)
 	acpi_sleep_tts_switch(acpi_target_sleep_state);
 }
 #else /* !CONFIG_ACPI_SLEEP */
+#define sleep_no_lps0	(1)
 #define acpi_target_sleep_state	ACPI_STATE_S0
-#define acpi_sleep_no_lps0	(false)
+#define acpi_sleep_default_s3	(1)
 static inline void acpi_sleep_dmi_check(void) {}
 #endif /* CONFIG_ACPI_SLEEP */
 
@@ -904,12 +909,6 @@ static int lps0_device_attach(struct acpi_device *adev,
 	if (lps0_device_handle)
 		return 0;
 
-	if (acpi_sleep_no_lps0) {
-		acpi_handle_info(adev->handle,
-				 "Low Power S0 Idle interface disabled\n");
-		return 0;
-	}
-
 	if (!(acpi_gbl_FADT.flags & ACPI_FADT_LOW_POWER_S0))
 		return 0;
 
@@ -937,7 +936,7 @@ static int lps0_device_attach(struct acpi_device *adev,
 	 * Use suspend-to-idle by default if the default suspend mode was not
 	 * set from the command line.
 	 */
-	if (mem_sleep_default > PM_SUSPEND_MEM)
+	if (mem_sleep_default > PM_SUSPEND_MEM && !acpi_sleep_default_s3)
 		mem_sleep_current = PM_SUSPEND_TO_IDLE;
 
 	return 0;
@@ -957,7 +956,7 @@ static int acpi_s2idle_begin(void)
 
 static int acpi_s2idle_prepare(void)
 {
-	if (lps0_device_handle) {
+	if (lps0_device_handle && !sleep_no_lps0) {
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_OFF);
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY);
 	}
@@ -977,7 +976,7 @@ static int acpi_s2idle_prepare(void)
 
 static void acpi_s2idle_wake(void)
 {
-	if (lps0_device_handle && pm_debug_messages_on)
+	if (lps0_device_handle && !sleep_no_lps0 && pm_debug_messages_on)
 		lpi_check_constraints();
 
 	/*
@@ -1025,7 +1024,7 @@ static void acpi_s2idle_restore(void)
 	if (acpi_sci_irq_valid())
 		disable_irq_wake(acpi_sci_irq);
 
-	if (lps0_device_handle) {
+	if (lps0_device_handle && !sleep_no_lps0) {
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT);
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_ON);
 	}

commit 2e2c2fdc53437beffd2cf26aaf6187e602d565bc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 31 11:05:15 2019 +0200

    ACPI: PM: s2idle: Rearrange lps0_device_attach()
    
    To allow a subsequent change to be simpler, rearrange the code in
    lps0_device_attach() to reduce the indentation level and (while
    at it) make it avoid calling lpi_device_get_constraints() when
    lps0_device_handle is not going to be set.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 9cb0532f7471..3d706938980a 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -916,28 +916,30 @@ static int lps0_device_attach(struct acpi_device *adev,
 	guid_parse(ACPI_LPS0_DSM_UUID, &lps0_dsm_guid);
 	/* Check if the _DSM is present and as expected. */
 	out_obj = acpi_evaluate_dsm(adev->handle, &lps0_dsm_guid, 1, 0, NULL);
-	if (out_obj && out_obj->type == ACPI_TYPE_BUFFER) {
-		char bitmask = *(char *)out_obj->buffer.pointer;
-
-		lps0_dsm_func_mask = bitmask;
-		lps0_device_handle = adev->handle;
-		/*
-		 * Use suspend-to-idle by default if the default
-		 * suspend mode was not set from the command line.
-		 */
-		if (mem_sleep_default > PM_SUSPEND_MEM)
-			mem_sleep_current = PM_SUSPEND_TO_IDLE;
-
-		acpi_handle_debug(adev->handle, "_DSM function mask: 0x%x\n",
-				  bitmask);
-	} else {
+	if (!out_obj || out_obj->type != ACPI_TYPE_BUFFER) {
 		acpi_handle_debug(adev->handle,
 				  "_DSM function 0 evaluation failed\n");
+		return 0;
 	}
+
+	lps0_dsm_func_mask = *(char *)out_obj->buffer.pointer;
+
 	ACPI_FREE(out_obj);
 
+	acpi_handle_debug(adev->handle, "_DSM function mask: 0x%x\n",
+			  lps0_dsm_func_mask);
+
+	lps0_device_handle = adev->handle;
+
 	lpi_device_get_constraints();
 
+	/*
+	 * Use suspend-to-idle by default if the default suspend mode was not
+	 * set from the command line.
+	 */
+	if (mem_sleep_default > PM_SUSPEND_MEM)
+		mem_sleep_current = PM_SUSPEND_TO_IDLE;
+
 	return 0;
 }
 

commit 10a08fd65ec1a68ccd86b19ec822ed5f2e50113f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 30 11:55:59 2019 +0200

    ACPI: PM: Set up EC GPE for system wakeup from drivers that need it
    
    The EC GPE needs to be set up for system wakeup only if there is a
    driver depending on it, either intel-hid or intel-vbtn, bound to a
    button device that is expected to wake up the system from sleep (such
    as the power button on some Dell systems, like the XPS13 9360).  It
    doesn't need to be set up for waking up the system from sleep in any
    other cases and whether or not it is expected to wake up the system
    from sleep doesn't depend on whether or not the LPS0 device is
    present in the ACPI namespace.
    
    For this reason, rearrange the ACPI suspend-to-idle code to make the
    drivers depending on the EC GPE wakeup take care of setting it up and
    decouple that from the LPS0 device handling.
    
    While at it, make intel-hid and intel-vbtn prepare for system wakeup
    only if they are allowed to wake up the system from sleep by user
    space (via sysfs).
    
    [Note that acpi_ec_mark_gpe_for_wake() and acpi_ec_set_gpe_wake_mask()
     are there to prevent the EC GPE from being disabled by the
     acpi_enable_all_wakeup_gpes() call in acpi_s2idle_prepare(), so on
     systems with either intel-hid or intel-vbtn this change doesn't
     affect any interactions with the hardware or platform firmware.]
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 970ae7c7a3f7..9cb0532f7471 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -930,8 +930,6 @@ static int lps0_device_attach(struct acpi_device *adev,
 
 		acpi_handle_debug(adev->handle, "_DSM function mask: 0x%x\n",
 				  bitmask);
-
-		acpi_ec_mark_gpe_for_wake();
 	} else {
 		acpi_handle_debug(adev->handle,
 				  "_DSM function 0 evaluation failed\n");
@@ -960,8 +958,6 @@ static int acpi_s2idle_prepare(void)
 	if (lps0_device_handle) {
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_OFF);
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY);
-
-		acpi_ec_set_gpe_wake_mask(ACPI_GPE_ENABLE);
 	}
 
 	if (acpi_sci_irq_valid())
@@ -979,10 +975,7 @@ static int acpi_s2idle_prepare(void)
 
 static void acpi_s2idle_wake(void)
 {
-	if (!lps0_device_handle)
-		return;
-
-	if (pm_debug_messages_on)
+	if (lps0_device_handle && pm_debug_messages_on)
 		lpi_check_constraints();
 
 	/*
@@ -1031,8 +1024,6 @@ static void acpi_s2idle_restore(void)
 		disable_irq_wake(acpi_sci_irq);
 
 	if (lps0_device_handle) {
-		acpi_ec_set_gpe_wake_mask(ACPI_GPE_DISABLE);
-
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT);
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_ON);
 	}
@@ -1081,7 +1072,7 @@ bool acpi_s2idle_wakeup(void)
 
 bool acpi_sleep_no_ec_events(void)
 {
-	return !s2idle_in_progress || !lps0_device_handle;
+	return !s2idle_in_progress;
 }
 
 #ifdef CONFIG_PM_SLEEP

commit 56b991849009f5def0443bfb2f48c8321d888e15
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 15 23:52:03 2019 +0200

    PM: sleep: Simplify suspend-to-idle control flow
    
    After commit 33e4f80ee69b ("ACPI / PM: Ignore spurious SCI wakeups
    from suspend-to-idle") the "noirq" phases of device suspend and
    resume may run for multiple times during suspend-to-idle, if there
    are spurious system wakeup events while suspended.  However, this
    is complicated and fragile and actually unnecessary.
    
    The main reason for doing this is that on some systems the EC may
    signal system wakeup events (power button events, for example) as
    well as events that should not cause the system to resume (spurious
    system wakeup events).  Thus, in order to determine whether or not
    a given event signaled by the EC while suspended is a proper system
    wakeup one, the EC GPE needs to be dispatched and to start with that
    was achieved by allowing the ACPI SCI action handler to run, which
    was only possible after calling resume_device_irqs().
    
    However, dispatching the EC GPE this way turned out to take too much
    time in some cases and some EC events might be missed due to that, so
    commit 68e22011856f ("ACPI: EC: Dispatch the EC GPE directly on
    s2idle wake") started to dispatch the EC GPE right after a wakeup
    event has been detected, so in fact the full ACPI SCI action handler
    doesn't need to run any more to deal with the wakeups coming from the
    EC.
    
    Use this observation to simplify the suspend-to-idle control flow
    so that the "noirq" phases of device suspend and resume are each
    run only once in every suspend-to-idle cycle, which is reported to
    significantly reduce power drawn by some systems when suspended to
    idle (by allowing them to reach a deep platform-wide low-power state
    through the suspend-to-idle flow).  [What appears to happen is that
    the "noirq" resume of devices after a spurious EC wakeup brings some
    devices into a state in which they prevent the platform from reaching
    the deep low-power state going forward, even after a subsequent
    "noirq" suspend phase, and on some systems the EC triggers such
    wakeups already when the "noirq" suspend of devices is running for
    the first time in the given suspend/resume cycle, so the platform
    cannot reach the deep low-power state at all.]
    
    First, make acpi_s2idle_wake() use the acpi_ec_dispatch_gpe() return
    value to determine whether or not the wakeup may have been triggered
    by the EC (in which case the system wakeup is canceled and ACPI
    events are processed in order to determine whether or not the event
    is a proper system wakeup one) and use rearm_wake_irq() (introduced
    by a previous change) in it to rearm the ACPI SCI for system wakeup
    detection in case the system will remain suspended.
    
    Second, drop acpi_s2idle_sync(), which is not needed any more, and
    the corresponding global platform suspend-to-idle callback.
    
    Next, drop the pm_wakeup_pending() check (which is an optimization
    only) from __device_suspend_noirq() to prevent it from returning
    errors on system wakeups occurring before the "noirq" phase of
    device suspend is complete (as in the case of suspend-to-idle it is
    not known whether or not these wakeups are suprious at that point),
    in order to avoid having to carry out a "noirq" resume of devices
    on a spurious system wakeup.
    
    Finally, change the code flow in s2idle_loop() to (1) run the
    "noirq" suspend of devices once before starting the loop, (2) check
    for spurious EC wakeups (via the platform ->wake callback) for the
    first time before calling s2idle_enter(), and (3) run the "noirq"
    resume of devices once after leaving the loop.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 3debe1a42655..970ae7c7a3f7 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -986,33 +986,37 @@ static void acpi_s2idle_wake(void)
 		lpi_check_constraints();
 
 	/*
-	 * If IRQD_WAKEUP_ARMED is not set for the SCI at this point, it means
-	 * that the SCI has triggered while suspended, so cancel the wakeup in
-	 * case it has not been a wakeup event (the GPEs will be checked later).
+	 * If IRQD_WAKEUP_ARMED is set for the SCI at this point, the SCI has
+	 * not triggered while suspended, so bail out.
 	 */
-	if (acpi_sci_irq_valid() &&
-	    !irqd_is_wakeup_armed(irq_get_irq_data(acpi_sci_irq))) {
+	if (!acpi_sci_irq_valid() ||
+	    irqd_is_wakeup_armed(irq_get_irq_data(acpi_sci_irq)))
+		return;
+
+	/*
+	 * If there are EC events to process, the wakeup may be a spurious one
+	 * coming from the EC.
+	 */
+	if (acpi_ec_dispatch_gpe()) {
+		/*
+		 * Cancel the wakeup and process all pending events in case
+		 * there are any wakeup ones in there.
+		 *
+		 * Note that if any non-EC GPEs are active at this point, the
+		 * SCI will retrigger after the rearming below, so no events
+		 * should be missed by canceling the wakeup here.
+		 */
 		pm_system_cancel_wakeup();
 		/*
-		 * On some platforms with the LPS0 _DSM device noirq resume
-		 * takes too much time for EC wakeup events to survive, so look
-		 * for them now.
+		 * The EC driver uses the system workqueue and an additional
+		 * special one, so those need to be flushed too.
 		 */
-		acpi_ec_dispatch_gpe();
+		acpi_os_wait_events_complete(); /* synchronize EC GPE processing */
+		acpi_ec_flush_work();
+		acpi_os_wait_events_complete(); /* synchronize Notify handling */
 	}
-}
 
-static void acpi_s2idle_sync(void)
-{
-	/*
-	 * Process all pending events in case there are any wakeup ones.
-	 *
-	 * The EC driver uses the system workqueue and an additional special
-	 * one, so those need to be flushed too.
-	 */
-	acpi_os_wait_events_complete();	/* synchronize SCI IRQ handling */
-	acpi_ec_flush_work();
-	acpi_os_wait_events_complete();	/* synchronize Notify handling */
+	rearm_wake_irq(acpi_sci_irq);
 }
 
 static void acpi_s2idle_restore(void)
@@ -1044,7 +1048,6 @@ static const struct platform_s2idle_ops acpi_s2idle_ops = {
 	.begin = acpi_s2idle_begin,
 	.prepare = acpi_s2idle_prepare,
 	.wake = acpi_s2idle_wake,
-	.sync = acpi_s2idle_sync,
 	.restore = acpi_s2idle_restore,
 	.end = acpi_s2idle_end,
 };

commit 41275eb5c7181febdfaa63c3a0ad9b7acdadcd52
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 15 23:51:19 2019 +0200

    ACPI: PM: Set s2idle_wakeup earlier and clear it later
    
    The role of the s2idle_wakeup variable is to cause
    acpi_pm_wakeup_event() and acpi_pm_notify_handler() to
    increment pm_abort_suspend and trigger a wakeup from
    suspend-to-idle in case the ACPI SCI wakeup was canceled
    by acpi_s2idle_wake().
    
    However, for this purpose it need not be set in acpi_s2idle_wake()
    and cleared in acpi_s2idle_sync(), respectively.  In fact, it
    may be set as early as in acpi_s2idle_prepare() and cleared as
    late as in acpi_s2idle_restore(), so do that to allow subsequent
    changes to be simpler.
    
    This change is not expected to alter functionality.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index f0fe7c15d657..3debe1a42655 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -972,6 +972,8 @@ static int acpi_s2idle_prepare(void)
 	/* Change the configuration of GPEs to avoid spurious wakeup. */
 	acpi_enable_all_wakeup_gpes();
 	acpi_os_wait_events_complete();
+
+	s2idle_wakeup = true;
 	return 0;
 }
 
@@ -991,7 +993,6 @@ static void acpi_s2idle_wake(void)
 	if (acpi_sci_irq_valid() &&
 	    !irqd_is_wakeup_armed(irq_get_irq_data(acpi_sci_irq))) {
 		pm_system_cancel_wakeup();
-		s2idle_wakeup = true;
 		/*
 		 * On some platforms with the LPS0 _DSM device noirq resume
 		 * takes too much time for EC wakeup events to survive, so look
@@ -1012,11 +1013,12 @@ static void acpi_s2idle_sync(void)
 	acpi_os_wait_events_complete();	/* synchronize SCI IRQ handling */
 	acpi_ec_flush_work();
 	acpi_os_wait_events_complete();	/* synchronize Notify handling */
-	s2idle_wakeup = false;
 }
 
 static void acpi_s2idle_restore(void)
 {
+	s2idle_wakeup = false;
+
 	acpi_enable_all_runtime_gpes();
 
 	acpi_disable_wakeup_devices(ACPI_STATE_S0);

commit 50e163d43ab123193a7f381528a7485881f730e9
Merge: 5004efbb3611 ad5a449b707b 9ed411c06dd1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 8 10:49:36 2019 +0200

    Merge branches 'acpi-pm' and 'pm-pci'
    
    * acpi-pm:
      ACPI: PM: Make acpi_sleep_state_supported() non-static
      ACPI: PM: Allow transitions to D0 to occur in special cases
      ACPI: PM: Avoid evaluating _PS3 on transitions from D3hot to D3cold
      ACPI / sleep: Switch to use acpi_dev_get_first_match_dev()
      ACPI / LPIT: Correct LPIT end address for lpit_process()
    
    * pm-pci:
      ACPI: PM: Unexport acpi_device_get_power()
      PCI: PM/ACPI: Refresh all stale power state data in pci_pm_complete()
      PCI / ACPI: Add _PR0 dependent devices
      ACPI / PM: Introduce concept of a _PR0 dependent device
      PCI / ACPI: Use cached ACPI device state to get PCI device power state
      PCI: Do not poll for PME if the device is in D3cold
      PCI: Add missing link delays required by the PCIe spec
      PCI: PM: Replace pci_dev_keep_suspended() with two functions
      PCI: PM: Avoid resuming devices in D3hot during system suspend

commit ad5a449b707b909a91ed59109f421a1b965c6004
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Jul 4 02:43:32 2019 +0000

    ACPI: PM: Make acpi_sleep_state_supported() non-static
    
    With some upcoming patches to save/restore the Hyper-V drivers related
    states, a Linux VM running on Hyper-V will be able to hibernate. When
    a Linux VM hibernates, unluckily we must disable the memory hot-add/remove
    and balloon up/down capabilities in the hv_balloon driver
    (drivers/hv/hv_balloon.c), because these can not really work according to
    the design of the related back-end driver on the host.
    
    By default, Hyper-V does not enable the virtual ACPI S4 state for a VM;
    on recent Hyper-V hosts, the administrator is able to enable the virtual
    ACPI S4 state for a VM, so we hope to use the presence of the virtual ACPI
    S4 state as a hint for hv_balloon to disable the aforementioned
    capabilities. In this way, hibernation will work more reliably, from the
    user's perspective.
    
    By marking acpi_sleep_state_supported() non-static, we'll be able to
    implement a hv_is_hibernation_supported() API in the always-built-in
    module arch/x86/hyperv/hv_init.c, and the API will be called by hv_balloon.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index e21a0f5fdadd..a64b81719611 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -79,7 +79,7 @@ static int acpi_sleep_prepare(u32 acpi_state)
 	return 0;
 }
 
-static bool acpi_sleep_state_supported(u8 sleep_state)
+bool acpi_sleep_state_supported(u8 sleep_state)
 {
 	acpi_status status;
 	u8 type_a, type_b;

commit a3487d8f30635e3fa9db986cee6fca8012a996f4
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jun 12 13:07:02 2019 +0300

    ACPI / sleep: Switch to use acpi_dev_get_first_match_dev()
    
    Switch the acpi_pm_finish() to use acpi_dev_get_first_match_dev() instead of
    custom approach.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index e52f1238d2d6..e21a0f5fdadd 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -454,14 +454,6 @@ static int acpi_pm_prepare(void)
 	return error;
 }
 
-static int find_powerf_dev(struct device *dev, void *data)
-{
-	struct acpi_device *device = to_acpi_device(dev);
-	const char *hid = acpi_device_hid(device);
-
-	return !strcmp(hid, ACPI_BUTTON_HID_POWERF);
-}
-
 /**
  *	acpi_pm_finish - Instruct the platform to leave a sleep state.
  *
@@ -470,7 +462,7 @@ static int find_powerf_dev(struct device *dev, void *data)
  */
 static void acpi_pm_finish(void)
 {
-	struct device *pwr_btn_dev;
+	struct acpi_device *pwr_btn_adev;
 	u32 acpi_state = acpi_target_sleep_state;
 
 	acpi_ec_unblock_transactions();
@@ -501,11 +493,11 @@ static void acpi_pm_finish(void)
 		return;
 
 	pwr_btn_event_pending = false;
-	pwr_btn_dev = bus_find_device(&acpi_bus_type, NULL, NULL,
-				      find_powerf_dev);
-	if (pwr_btn_dev) {
-		pm_wakeup_event(pwr_btn_dev, 0);
-		put_device(pwr_btn_dev);
+	pwr_btn_adev = acpi_dev_get_first_match_dev(ACPI_BUTTON_HID_POWERF,
+						    NULL, -1);
+	if (pwr_btn_adev) {
+		pm_wakeup_event(&pwr_btn_adev->dev, 0);
+		acpi_dev_put(pwr_btn_adev);
 	}
 }
 

commit 55716d26439f5c4008b0bcb7f17d1f7c0d8fbcfc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:42 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 428
    
    Based on 1 normalized pattern(s):
    
      this file is released under the gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 68 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190114.292346262@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index a34deccd7317..8ff08e531443 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * sleep.c - ACPI sleep support.
  *
@@ -5,9 +6,6 @@
  * Copyright (c) 2004 David Shaohua Li <shaohua.li@intel.com>
  * Copyright (c) 2000-2003 Patrick Mochel
  * Copyright (c) 2003 Open Source Development Lab
- *
- * This file is released under the GPLv2.
- *
  */
 
 #include <linux/delay.h>

commit bb1869012d7b78d1474808cb4c8bd8b272645876
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 16 12:43:19 2019 +0200

    ACPI: PM: Call pm_set_suspend_via_firmware() during hibernation
    
    On systems with ACPI platform firmware the last stage of hibernation
    is analogous to system suspend to S3 (suspend-to-RAM), so it should
    be handled analogously.  In particular, pm_suspend_via_firmware()
    should return 'true' in that stage to let the callers of it know that
    control will be passed to the platform firmware going forward, so
    pm_set_suspend_via_firmware() needs to be called then in analogy with
    acpi_suspend_begin().
    
    However, the platform hibernation ->begin() callback is invoked
    during the "freeze" transition (before creating a snapshot image of
    system memory) as well as during the "hibernate" transition which is
    the last stage of it and pm_set_suspend_via_firmware() should be
    invoked by that callback in the latter stage only.
    
    In order to implement that redefine the hibernation ->begin()
    callback to take a pm_message_t argument to indicate which stage
    of hibernation is taking place and rework acpi_hibernation_begin()
    and acpi_hibernation_begin_old() to take it into account as needed.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index e52f1238d2d6..a34deccd7317 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -1132,15 +1132,19 @@ void __init acpi_no_s4_hw_signature(void)
 	nosigcheck = true;
 }
 
-static int acpi_hibernation_begin(void)
+static int acpi_hibernation_begin(pm_message_t stage)
 {
-	int error;
+	if (!nvs_nosave) {
+		int error = suspend_nvs_alloc();
+		if (error)
+			return error;
+	}
 
-	error = nvs_nosave ? 0 : suspend_nvs_alloc();
-	if (!error)
-		acpi_pm_start(ACPI_STATE_S4);
+	if (stage.event == PM_EVENT_HIBERNATE)
+		pm_set_suspend_via_firmware();
 
-	return error;
+	acpi_pm_start(ACPI_STATE_S4);
+	return 0;
 }
 
 static int acpi_hibernation_enter(void)
@@ -1200,7 +1204,7 @@ static const struct platform_hibernation_ops acpi_hibernation_ops = {
  *		function is used if the pre-ACPI 2.0 suspend ordering has been
  *		requested.
  */
-static int acpi_hibernation_begin_old(void)
+static int acpi_hibernation_begin_old(pm_message_t stage)
 {
 	int error;
 	/*
@@ -1211,16 +1215,21 @@ static int acpi_hibernation_begin_old(void)
 	acpi_sleep_tts_switch(ACPI_STATE_S4);
 
 	error = acpi_sleep_prepare(ACPI_STATE_S4);
+	if (error)
+		return error;
 
-	if (!error) {
-		if (!nvs_nosave)
-			error = suspend_nvs_alloc();
-		if (!error) {
-			acpi_target_sleep_state = ACPI_STATE_S4;
-			acpi_scan_lock_acquire();
-		}
+	if (!nvs_nosave) {
+		error = suspend_nvs_alloc();
+		if (error)
+			return error;
 	}
-	return error;
+
+	if (stage.event == PM_EVENT_HIBERNATE)
+		pm_set_suspend_via_firmware();
+
+	acpi_target_sleep_state = ACPI_STATE_S4;
+	acpi_scan_lock_acquire();
+	return 0;
 }
 
 /*

commit 2f844b61db8297a1f7a06adf2eb5c43381f2c183
Author: Rajat Jain <rajatja@google.com>
Date:   Mon May 13 12:17:08 2019 -0700

    ACPI: PM: Set enable_for_wake for wakeup GPEs during suspend-to-idle
    
    I noticed that recently multiple systems (chromebooks) couldn't wake
    from S0ix using LID or Keyboard after updating to a newer kernel. I
    bisected and it turned up commit f941d3e41da7 ("ACPI: EC / PM: Disable
    non-wakeup GPEs for suspend-to-idle"). I checked that the issue got
    fixed if that commit was reverted.
    
    I debugged and found that although PNP0C0D:00 (representing the LID)
    is wake capable and should wakeup the system per the code in
    acpi_wakeup_gpe_init() and in drivers/acpi/button.c:
    
    localhost /sys # cat /proc/acpi/wakeup
    Device  S-state   Status   Sysfs node
    LID0      S4    *enabled   platform:PNP0C0D:00
    CREC      S5    *disabled  platform:GOOG0004:00
                    *disabled  platform:cros-ec-dev.1.auto
                    *disabled  platform:cros-ec-accel.0
                    *disabled  platform:cros-ec-accel.1
                    *disabled  platform:cros-ec-gyro.0
                    *disabled  platform:cros-ec-ring.0
                    *disabled  platform:cros-usbpd-charger.2.auto
                    *disabled  platform:cros-usbpd-logger.3.auto
    D015      S3    *enabled   i2c:i2c-ELAN0000:00
    PENH      S3    *enabled   platform:PRP0001:00
    XHCI      S3    *enabled   pci:0000:00:14.0
    GLAN      S4    *disabled
    WIFI      S3    *disabled  pci:0000:00:14.3
    localhost /sys #
    
    On debugging, I found that its corresponding GPE is not being enabled.
    The particular GPE's "gpe_register_info->enable_for_wake" does not
    have any bits set when acpi_enable_all_wakeup_gpes() comes around to
    use it. I looked at code and could not find any other code path that
    should set the bits in "enable_for_wake" bitmask for the wake enabled
    devices for s2idle.  [I do see that it happens for S3 in
    acpi_sleep_prepare()].
    
    Thus I used the same call to enable the GPEs for wake enabled devices,
    and verified that this fixes the regression I was seeing on multiple
    of my devices.
    
    [ rjw: The problem is that commit f941d3e41da7 ("ACPI: EC / PM:
      Disable non-wakeup GPEs for suspend-to-idle") forgot to add
      the acpi_enable_wakeup_devices() call for s2idle along with
      acpi_enable_all_wakeup_gpes(). ]
    
    Fixes: f941d3e41da7 ("ACPI: EC / PM: Disable non-wakeup GPEs for suspend-to-idle")
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=203579
    Signed-off-by: Rajat Jain <rajatja@google.com>
    [ rjw: Subject & changelog ]
    Cc: 5.0+ <stable@vger.kernel.org> # 5.0+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 403c4ff15349..e52f1238d2d6 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -977,6 +977,8 @@ static int acpi_s2idle_prepare(void)
 	if (acpi_sci_irq_valid())
 		enable_irq_wake(acpi_sci_irq);
 
+	acpi_enable_wakeup_devices(ACPI_STATE_S0);
+
 	/* Change the configuration of GPEs to avoid spurious wakeup. */
 	acpi_enable_all_wakeup_gpes();
 	acpi_os_wait_events_complete();
@@ -1027,6 +1029,8 @@ static void acpi_s2idle_restore(void)
 {
 	acpi_enable_all_runtime_gpes();
 
+	acpi_disable_wakeup_devices(ACPI_STATE_S0);
+
 	if (acpi_sci_irq_valid())
 		disable_irq_wake(acpi_sci_irq);
 

commit 7edcbbf29006be46d5dbce5bac9aae73f3056d14
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Dec 17 12:22:43 2018 +0100

    ACPI: PM: Loop in full LPS0 mode only
    
    After a previous change, all non-wakeup GPEs are disabled for
    suspend-to-idle unless full Low-Power S0 (LPS0) mode is in use, so
    it is not necessary to do anything in acpi_s2idle_wake() unless in
    full LPS0 mode, which is only when lps0_device_handle is set.
    
    Modify the code accordingly.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 74c489047f57..403c4ff15349 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -985,6 +985,8 @@ static int acpi_s2idle_prepare(void)
 
 static void acpi_s2idle_wake(void)
 {
+	if (!lps0_device_handle)
+		return;
 
 	if (pm_debug_messages_on)
 		lpi_check_constraints();
@@ -1003,8 +1005,7 @@ static void acpi_s2idle_wake(void)
 		 * takes too much time for EC wakeup events to survive, so look
 		 * for them now.
 		 */
-		if (lps0_device_handle)
-			acpi_ec_dispatch_gpe();
+		acpi_ec_dispatch_gpe();
 	}
 }
 

commit f941d3e41da7f86bdb9dcc1977c2bcc6b89bfe47
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Dec 17 12:21:55 2018 +0100

    ACPI: EC / PM: Disable non-wakeup GPEs for suspend-to-idle
    
    There are systems in which non-wakeup GPEs fire during the "noirq"
    suspend stage of suspending devices and that effectively prevents the
    system that tries to suspend to idle from entering any low-power
    state at all.  If the offending GPE fires regularly and often enough,
    the system appears to be suspended, but in fact it is in a tight loop
    over "noirq" suspend and "noirq" resume of devices all the time.
    
    To prevent that from happening, disable all non-wakeup GPEs except
    for the EC GPE for suspend-to-idle (the EC GPE is special, because
    on some systems it has to be enabled for power button wakeup events
    to be generated as expected).
    
    Fixes: 147a7d9d25ca (ACPI / PM: Do not reconfigure GPEs for suspend-to-idle)
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=201987
    Reported-by: Zhang Rui <rui.zhang@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 754d59f95500..74c489047f57 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -940,6 +940,8 @@ static int lps0_device_attach(struct acpi_device *adev,
 
 		acpi_handle_debug(adev->handle, "_DSM function mask: 0x%x\n",
 				  bitmask);
+
+		acpi_ec_mark_gpe_for_wake();
 	} else {
 		acpi_handle_debug(adev->handle,
 				  "_DSM function 0 evaluation failed\n");
@@ -968,11 +970,16 @@ static int acpi_s2idle_prepare(void)
 	if (lps0_device_handle) {
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_OFF);
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY);
+
+		acpi_ec_set_gpe_wake_mask(ACPI_GPE_ENABLE);
 	}
 
 	if (acpi_sci_irq_valid())
 		enable_irq_wake(acpi_sci_irq);
 
+	/* Change the configuration of GPEs to avoid spurious wakeup. */
+	acpi_enable_all_wakeup_gpes();
+	acpi_os_wait_events_complete();
 	return 0;
 }
 
@@ -1017,10 +1024,14 @@ static void acpi_s2idle_sync(void)
 
 static void acpi_s2idle_restore(void)
 {
+	acpi_enable_all_runtime_gpes();
+
 	if (acpi_sci_irq_valid())
 		disable_irq_wake(acpi_sci_irq);
 
 	if (lps0_device_handle) {
+		acpi_ec_set_gpe_wake_mask(ACPI_GPE_DISABLE);
+
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT);
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_ON);
 	}

commit 231f9415001138a000cd0f881c46654b7ea3f8c5
Author: Willy Tarreau <w@1wt.eu>
Date:   Mon Jul 9 14:03:55 2018 +0200

    ACPI / PM: save NVS memory for ASUS 1025C laptop
    
    Every time I tried to upgrade my laptop from 3.10.x to 4.x I faced an
    issue by which the fan would run at full speed upon resume. Bisecting
    it showed me the issue was introduced in 3.17 by commit 821d6f0359b0
    (ACPI / sleep: Do not save NVS for new machines to accelerate S3). This
    code only affects machines built starting as of 2012, but this Asus
    1025C laptop was made in 2012 and apparently needs the NVS data to be
    saved, otherwise the CPU's thermal state is not properly reported on
    resume and the fan runs at full speed upon resume.
    
    Here's a very simple way to check if such a machine is affected :
    
      # cat /sys/class/thermal/thermal_zone0/temp
      55000
    
      ( now suspend, wait one second and resume )
    
      # cat /sys/class/thermal/thermal_zone0/temp
      0
    
      (and after ~15 seconds the fan starts to spin)
    
    Let's apply the same quirk as commit cbc00c13 (ACPI: save NVS memory
    for Lenovo G50-45) and reuse the function it provides. Note that this
    commit was already backported to 4.9.x but not 4.4.x.
    
    Cc: 3.17+ <stable@vger.kernel.org> # 3.17+: requires cbc00c13
    Signed-off-by: Willy Tarreau <w@1wt.eu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 06ba8cc68889..754d59f95500 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -338,6 +338,14 @@ static const struct dmi_system_id acpisleep_dmi_table[] __initconst = {
 		DMI_MATCH(DMI_PRODUCT_NAME, "K54HR"),
 		},
 	},
+	{
+	.callback = init_nvs_save_s3,
+	.ident = "Asus 1025C",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
+		DMI_MATCH(DMI_PRODUCT_NAME, "1025C"),
+		},
+	},
 	/*
 	 * https://bugzilla.kernel.org/show_bug.cgi?id=189431
 	 * Lenovo G50-45 is a platform later than 2012, but needs nvs memory

commit 6f9db69ad93cd6ab77d5571cf748ff7cdcfb0285
Author: Tristian Celestin <tristiancelestin@fastmail.com>
Date:   Fri Jun 15 04:50:18 2018 -0400

    ACPI / PM: Default to s2idle in all machines supporting LP S0
    
    The Dell Venue Pro 7140 supports the Low Power S0 Idle state, but
    does not support any of the _DSM functions that the current heuristic
    checks for.
    
    Since suspend-to-mem can not be safely performed on this machine,
    and since the bitfield check can't cover this case, it is safer
    to enable s2idle by default by checking for the presence of the
    _DSM alone and removing the bitfield check.
    
    Signed-off-by: Tristian Celestin <tristiancelestin@fastmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 5d0486f1cfcd..06ba8cc68889 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -718,9 +718,6 @@ static const struct acpi_device_id lps0_device_ids[] = {
 #define ACPI_LPS0_ENTRY		5
 #define ACPI_LPS0_EXIT		6
 
-#define ACPI_LPS0_SCREEN_MASK	((1 << ACPI_LPS0_SCREEN_OFF) | (1 << ACPI_LPS0_SCREEN_ON))
-#define ACPI_LPS0_PLATFORM_MASK	((1 << ACPI_LPS0_ENTRY) | (1 << ACPI_LPS0_EXIT))
-
 static acpi_handle lps0_device_handle;
 static guid_t lps0_dsm_guid;
 static char lps0_dsm_func_mask;
@@ -924,17 +921,14 @@ static int lps0_device_attach(struct acpi_device *adev,
 	if (out_obj && out_obj->type == ACPI_TYPE_BUFFER) {
 		char bitmask = *(char *)out_obj->buffer.pointer;
 
-		if ((bitmask & ACPI_LPS0_PLATFORM_MASK) == ACPI_LPS0_PLATFORM_MASK ||
-		    (bitmask & ACPI_LPS0_SCREEN_MASK) == ACPI_LPS0_SCREEN_MASK) {
-			lps0_dsm_func_mask = bitmask;
-			lps0_device_handle = adev->handle;
-			/*
-			 * Use suspend-to-idle by default if the default
-			 * suspend mode was not set from the command line.
-			 */
-			if (mem_sleep_default > PM_SUSPEND_MEM)
-				mem_sleep_current = PM_SUSPEND_TO_IDLE;
-		}
+		lps0_dsm_func_mask = bitmask;
+		lps0_device_handle = adev->handle;
+		/*
+		 * Use suspend-to-idle by default if the default
+		 * suspend mode was not set from the command line.
+		 */
+		if (mem_sleep_default > PM_SUSPEND_MEM)
+			mem_sleep_current = PM_SUSPEND_TO_IDLE;
 
 		acpi_handle_debug(adev->handle, "_DSM function mask: 0x%x\n",
 				  bitmask);

commit 68e22011856f036bd9b0328b9b62d953e668a7ae
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed May 16 14:13:21 2018 +0200

    ACPI: EC: Dispatch the EC GPE directly on s2idle wake
    
    On platforms where the Low Power S0 Idle _DSM interface is used,
    on wakeup from suspend-to-idle, when it is known that the ACPI SCI
    has triggered while suspended, dispatch the EC GPE in order to catch
    all EC events that may have triggered the wakeup before carrying out
    the noirq phase of device resume.
    
    That is needed to handle power button wakeup on some platforms where
    the EC goes into a low-power mode during suspend-to-idle and while in
    that mode it will discard events after a timeout.  If that timeout is
    shorter than the time it takes to complete the noirq resume of
    devices, looking for EC events after the latter is too late.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reported-by: Zhang Rui <rui.zhang@intel.com>
    Tested-by: Wendy Wang <wendy.wang@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 974e58457697..5d0486f1cfcd 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -989,6 +989,13 @@ static void acpi_s2idle_wake(void)
 	    !irqd_is_wakeup_armed(irq_get_irq_data(acpi_sci_irq))) {
 		pm_system_cancel_wakeup();
 		s2idle_wakeup = true;
+		/*
+		 * On some platforms with the LPS0 _DSM device noirq resume
+		 * takes too much time for EC wakeup events to survive, so look
+		 * for them now.
+		 */
+		if (lps0_device_handle)
+			acpi_ec_dispatch_gpe();
 	}
 }
 

commit 855c1c2fce8bdbd796cba1d1456ca8f0e876c2f1
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Tue Apr 10 23:07:51 2018 +0800

    ACPI / PM: Blacklist Low Power S0 Idle _DSM for ThinkPad X1 Tablet(2016)
    
    ThinkPad X1 Tablet(2016) is reported to have issues with
    the Low Power S0 Idle _DSM interface and since this machine
    model generally can do ACPI S3 just fine, and user would
    like to use S3 as default sleep model, add a blacklist
    entry to disable that interface for ThinkPad X1 Tablet(2016).
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=199057
    Reported-and-tested-by: Robin Lee <robinlee.sysu@gmail.com>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 99a1a650326d..974e58457697 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -364,6 +364,19 @@ static const struct dmi_system_id acpisleep_dmi_table[] __initconst = {
 		DMI_MATCH(DMI_PRODUCT_NAME, "XPS 13 9360"),
 		},
 	},
+	/*
+	 * ThinkPad X1 Tablet(2016) cannot do suspend-to-idle using
+	 * the Low Power S0 Idle firmware interface (see
+	 * https://bugzilla.kernel.org/show_bug.cgi?id=199057).
+	 */
+	{
+	.callback = init_no_lps0,
+	.ident = "ThinkPad X1 Tablet(2016)",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "20GGA00L00"),
+		},
+	},
 	{},
 };
 

commit f2d285669aae656dfeafa0bf25e86bbbc5d22329
Merge: be5537542743 103cf0e5799c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 3 10:45:39 2018 -0700

    Merge tag 'pm-4.17-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael Wysocki:
     "These update the cpuidle poll state definition to reduce excessive
      energy usage related to it, add new CPU ID to the RAPL power capping
      driver, update the ACPI system suspend code to handle some special
      cases better, extend the PM core's device links code slightly, add new
      sysfs attribute for better suspend-to-idle diagnostics and easier
      hibernation handling, update power management tools and clean up
      cpufreq quite a bit.
    
      Specifics:
    
       - Modify the cpuidle poll state implementation to prevent CPUs from
         staying in the loop in there for excessive times (Rafael Wysocki).
    
       - Add Intel Cannon Lake chips support to the RAPL power capping
         driver (Joe Konno).
    
       - Add reference counting to the device links handling code in the PM
         core (Lukas Wunner).
    
       - Avoid reconfiguring GPEs on suspend-to-idle in the ACPI system
         suspend code (Rafael Wysocki).
    
       - Allow devices to be put into deeper low-power states via ACPI if
         both _SxD and _SxW are missing (Daniel Drake).
    
       - Reorganize the core ACPI suspend-to-idle wakeup code to avoid a
         keyboard wakeup issue on Asus UX331UA (Chris Chiu).
    
       - Prevent the PCMCIA library code from aborting suspend-to-idle due
         to noirq suspend failures resulting from incorrect assumptions
         (Rafael Wysocki).
    
       - Add coupled cpuidle supprt to the Exynos3250 platform (Marek
         Szyprowski).
    
       - Add new sysfs file to make it easier to specify the image storage
         location during hibernation (Mario Limonciello).
    
       - Add sysfs files for collecting suspend-to-idle usage and time
         statistics for CPU idle states (Rafael Wysocki).
    
       - Update the pm-graph utilities (Todd Brandt).
    
       - Reduce the kernel log noise related to reporting Low-power Idle
         constraings by the ACPI system suspend code (Rafael Wysocki).
    
       - Make it easier to distinguish dedicated wakeup IRQs in the
         /proc/interrupts output (Tony Lindgren).
    
       - Add the frequency table validation in cpufreq to the core and drop
         it from a number of cpufreq drivers (Viresh Kumar).
    
       - Drop "cooling-{min|max}-level" for CPU nodes from a couple of DT
         bindings (Viresh Kumar).
    
       - Clean up the CPU online error code path in the cpufreq core (Viresh
         Kumar).
    
       - Fix assorted issues in the SCPI, CPPC, mediatek and tegra186
         cpufreq drivers (Arnd Bergmann, Chunyu Hu, George Cherian, Viresh
         Kumar).
    
       - Drop memory allocation error messages from a few places in cpufreq
         and cpuildle drivers (Markus Elfring)"
    
    * tag 'pm-4.17-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (56 commits)
      ACPI / PM: Fix keyboard wakeup from suspend-to-idle on ASUS UX331UA
      cpufreq: CPPC: Use transition_delay_us depending transition_latency
      PM / hibernate: Change message when writing to /sys/power/resume
      PM / hibernate: Make passing hibernate offsets more friendly
      cpuidle: poll_state: Avoid invoking local_clock() too often
      PM: cpuidle/suspend: Add s2idle usage and time state attributes
      cpuidle: Enable coupled cpuidle support on Exynos3250 platform
      cpuidle: poll_state: Add time limit to poll_idle()
      cpufreq: tegra186: Don't validate the frequency table twice
      cpufreq: speedstep: Don't validate the frequency table twice
      cpufreq: sparc: Don't validate the frequency table twice
      cpufreq: sh: Don't validate the frequency table twice
      cpufreq: sfi: Don't validate the frequency table twice
      cpufreq: scpi: Don't validate the frequency table twice
      cpufreq: sc520: Don't validate the frequency table twice
      cpufreq: s3c24xx: Don't validate the frequency table twice
      cpufreq: qoirq: Don't validate the frequency table twice
      cpufreq: pxa: Don't validate the frequency table twice
      cpufreq: ppc_cbe: Don't validate the frequency table twice
      cpufreq: powernow: Don't validate the frequency table twice
      ...

commit 6f1d7c45dbbadd1a3c6eb9a9a485ef1975be4760
Author: Chris Chiu <chiu@endlessm.com>
Date:   Sat Mar 31 10:09:31 2018 +0800

    ACPI / PM: Fix keyboard wakeup from suspend-to-idle on ASUS UX331UA
    
    This issue happens on new ASUS laptop UX331UA which has modern
    standby mode (suspend-to-idle). Pressing keys on the PS2 keyboard
    can't wake up the system from suspend-to-idle which is not expected.
    However, pressing power button can wake up without problem.
    
    Per the engineers of ASUS, the keypress event is routed to Embedded
    Controller (EC) in standby mode. EC then signals the SCI event to
    BIOS so BIOS would Notify() power button to wake up the system. It's
    from BIOS perspective. What we observe here is that kernel receives
    the SCI event from SCI interrupt handler which informs that the GPE
    status bit belongs to EC needs to be handled and then queries the EC
    to find out what event is pending. Then execute the following ACPI
    _QDF method which defined in ACPI DSDT for EC to notify power button.
    
     Method (_QDF, 0, NotSerialized)  // _Qxx: EC Query
            {
                Notify (PWRB, 0x80) // Status Change
            }
    
    With more debug messages added to analyze this problem, we find that
    the keypress does wake up the system from suspend-to-idle but it's back
    to suspend again almost immediately. As we see in the following messages,
    the acpi_button_notify() is invoked but acpi_pm_wakeup_event() can not
    really wake up the system here because acpi_s2idle_wakeup() is false.
    The acpi_s2idle_wakeup() returnd false because the acpi_s2idle_sync() has
    alrealdy exited.
    
    [   52.987048] s2idle_loop going s2idle
    [   59.713392] acpi_s2idle_wake enter
    [   59.713394] acpi_s2idle_wake exit
    [   59.760888] acpi_ev_gpe_detect enter
    [   59.760893] acpi_s2idle_sync enter
    [   59.760893] acpi_ec_query_flushed ec pending queries 0
    [   59.760953] Read registers for GPE 50-57: Status=01, Enable=01, RunEnable=01, WakeEnable=00
    [   59.760955] ACPI: EC: ===== IRQ (1) =====
    [   59.760972] ACPI: EC: EC_SC(R) = 0x28 SCI_EVT=1 BURST=0 CMD=1 IBF=0 OBF=0
    [   59.760979] ACPI: EC: +++++ Polling enabled +++++
    [   59.760979] ACPI: EC: ##### Command(QR_EC) submitted/blocked #####
    [   59.761003] acpi_s2idle_sync exit
    [   59.769587] ACPI: EC: ##### Query(0xdf) started #####
    [   59.769611] ACPI: EC: ##### Query(0xdf) stopped #####
    [   59.774154] acpi_button_notify button type 1
    [   59.813175] s2idle_loop going s2idle
    
    acpi_s2idle_sync() already makes an effort to flush the EC event
    queue, but in this case, the EC event has yet to be generated when
    the call to acpi_ec_flush_work() is made. The event is generated
    shortly after, through the ongoing handling of the SCI interrupt
    which is happening on another CPU, and we must synchronize that
    to make sure that it has run and completed. Adding another call to
    acpi_os_wait_events_complete() solves this issue, since that
    function synchronizes with SCI interrupt completion.
    
    Signed-off-by: Chris Chiu <chiu@endlessm.com>
    [ rjw: Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index b5d27a4213ab..4a59c16915c3 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -989,8 +989,9 @@ static void acpi_s2idle_sync(void)
 	 * The EC driver uses the system workqueue and an additional special
 	 * one, so those need to be flushed too.
 	 */
+	acpi_os_wait_events_complete();	/* synchronize SCI IRQ handling */
 	acpi_ec_flush_work();
-	acpi_os_wait_events_complete();
+	acpi_os_wait_events_complete();	/* synchronize Notify handling */
 	s2idle_wakeup = false;
 }
 

commit fa54150aad84dbbd92b26ce47e6b2cf7c686dca0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Mar 13 10:47:36 2018 +0100

    ACPI / PM: Reduce LPI constraints logging noise
    
    If a device referred to by ACPI LPI constrains (coming from function 1
    of the Low Power S0 Idle _DSM interface) is not power-manageable via
    ACPI (no _PS0 method and no power resources), the code generating
    diagnostic information for the LPI constraints will print a message
    about that to the kernel log on every system suspend-resume cycle
    (possibly for multiple times).
    
    That is not very useful and noisy, so modify that code to disregard
    the LPI list entries corresponding to the devices that are not power-
    manageable after printing that information for them once.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index c53119740a3c..b5d27a4213ab 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -851,23 +851,25 @@ static void lpi_check_constraints(void)
 	int i;
 
 	for (i = 0; i < lpi_constraints_table_size; ++i) {
+		acpi_handle handle = lpi_constraints_table[i].handle;
 		struct acpi_device *adev;
 
-		if (acpi_bus_get_device(lpi_constraints_table[i].handle, &adev))
+		if (!handle || acpi_bus_get_device(handle, &adev))
 			continue;
 
-		acpi_handle_debug(adev->handle,
+		acpi_handle_debug(handle,
 			"LPI: required min power state:%s current power state:%s\n",
 			acpi_power_state_string(lpi_constraints_table[i].min_dstate),
 			acpi_power_state_string(adev->power.state));
 
 		if (!adev->flags.power_manageable) {
-			acpi_handle_info(adev->handle, "LPI: Device not power manageble\n");
+			acpi_handle_info(handle, "LPI: Device not power manageable\n");
+			lpi_constraints_table[i].handle = NULL;
 			continue;
 		}
 
 		if (adev->power.state < lpi_constraints_table[i].min_dstate)
-			acpi_handle_info(adev->handle,
+			acpi_handle_info(handle,
 				"LPI: Constraint not met; min power state:%s current power state:%s\n",
 				acpi_power_state_string(lpi_constraints_table[i].min_dstate),
 				acpi_power_state_string(adev->power.state));

commit 9c0a30b67bd916a7da1a7101dbf3115e5f10d852
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Feb 22 14:59:22 2018 +0200

    ACPI/sleep: Simplify code by using the new dmi_get_bios_year() helper
    
    ...instead of open coding its functionality.
    
    No changes in functionality.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Jean Delvare <jdelvare@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-pci@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180222125923.57385-3-andriy.shevchenko@linux.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 46cde0912762..b35923e3a926 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -376,12 +376,10 @@ void __init acpi_sleep_no_blacklist(void)
 
 static void __init acpi_sleep_dmi_check(void)
 {
-	int year;
-
 	if (ignore_blacklist)
 		return;
 
-	if (dmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL) && year >= 2012)
+	if (dmi_get_bios_year() >= 2012)
 		acpi_nvs_nosave_s3();
 
 	dmi_check_system(acpisleep_dmi_table);

commit 147a7d9d25ca2551aab15071cb1f048ecd9b7953
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 20 12:10:32 2018 +0100

    ACPI / PM: Do not reconfigure GPEs for suspend-to-idle
    
    It is reported that commit 235d81a630ca (ACPI / PM: Clean up device
    wakeup enable/disable code) broke wakeup from suspend-to-idle on
    some platforms.  That is due to the acpi_enable_all_wakeup_gpes() in
    acpi_s2idle_prepare() which needs acpi_enable_wakeup_devices() to be
    called before it as the latter sets up the GPE masks used by the
    former and commit 235d81a630ca removed acpi_enable_wakeup_devices()
    invocation from the suspend-to-idle path.
    
    However, acpi_enable_wakeup_devices() does more than just setting
    the GPE masks and the remaining part of it is not necessary for
    suspend-to-idle.  Moreover, non-wakeup GPEs are disabled on suspend-
    to-idle entry to avoid spurious wakeups, but that should not be
    strictly necessary any more after commit 33e4f80ee69b (ACPI / PM:
    Ignore spurious SCI wakeups from suspend-to-idle) which prevents
    spurious GPE wakeups from resuming the system.  The only consequence
    of leaving non-wakeup GPEs enabled may be more interrupt-related
    activity while suspended, which is not ideal (more energy is used
    if that happens), but it is not critical too.
    
    For this reason, drop the GPE reconfiguration from the suspend-to-idle
    path entirely.
    
    This change also allows Dells XPS13 9360 blacklisted by commit
    71630b7a832f (ACPI / PM: Blacklist Low Power S0 Idle _DSM for Dell
    XPS13 9360) to use the power button for waking up from suspend-
    to-idle and it helps at least one other older Dell system (the
    wakeup button GPE on that one is not listed in _PRW for any
    devices, so it is not regarded as a wakeup one and gets disabled
    on suspend-to-idle entry today).
    
    Fixes: 235d81a630ca (ACPI / PM: Clean up device wakeup enable/disable code)
    Reported-by: Du Wenkai <wenkai.du@intel.com>
    Tested-by: Du Wenkai <wenkai.du@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 46cde0912762..c53119740a3c 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -953,15 +953,8 @@ static int acpi_s2idle_prepare(void)
 	if (lps0_device_handle) {
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_OFF);
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY);
-	} else {
-		/*
-		 * The configuration of GPEs is changed here to avoid spurious
-		 * wakeups, but that should not be necessary if this is a
-		 * "low-power S0" platform and the low-power S0 _DSM is present.
-		 */
-		acpi_enable_all_wakeup_gpes();
-		acpi_os_wait_events_complete();
 	}
+
 	if (acpi_sci_irq_valid())
 		enable_irq_wake(acpi_sci_irq);
 
@@ -1007,8 +1000,6 @@ static void acpi_s2idle_restore(void)
 	if (lps0_device_handle) {
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT);
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_ON);
-	} else {
-		acpi_enable_all_runtime_gpes();
 	}
 }
 

commit 29a5a6d7082427371519ae1e186d9e35612801fb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 11 02:13:58 2018 +0100

    ACPI / PM: Use Low Power S0 Idle on more systems
    
    Some systems don't support the ACPI_LPS0_ENTRY and ACPI_LPS0_EXIT
    functions in their Low Power S0 Idle _DSM, but still expect EC
    events to be processed in the suspend-to-idle state for power button
    wakeup (among other things) to work.  Surface Pro3 turns out to be
    one of them.
    
    Fortunately, it still provides Low Power S0 Idle _DSM with the screen
    on/off functions supported, so modify the ACPI suspend-to-idle to use
    the Low Power S0 Idle code path for all systems supporting the
    ACPI_LPS0_ENTRY and ACPI_LPS0_EXIT or the ACPI_LPS0_SCREEN_OFF and
    ACPI_LPS0_SCREEN_ON functions in their Low Power S0 Idle _DSM.
    
    Potentially, that will cause more systems to use suspend-to-idle by
    default, so some future corrections may be necessary if it leads
    to issues, but let it remain more straightforward for now.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=198389#add_comment
    Reported-by: Valentin Manea <valy@mrs.ro>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Valentin Manea <valy@mrs.ro>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 15cd862a87c2..46cde0912762 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -707,7 +707,8 @@ static const struct acpi_device_id lps0_device_ids[] = {
 #define ACPI_LPS0_ENTRY		5
 #define ACPI_LPS0_EXIT		6
 
-#define ACPI_S2IDLE_FUNC_MASK	((1 << ACPI_LPS0_ENTRY) | (1 << ACPI_LPS0_EXIT))
+#define ACPI_LPS0_SCREEN_MASK	((1 << ACPI_LPS0_SCREEN_OFF) | (1 << ACPI_LPS0_SCREEN_ON))
+#define ACPI_LPS0_PLATFORM_MASK	((1 << ACPI_LPS0_ENTRY) | (1 << ACPI_LPS0_EXIT))
 
 static acpi_handle lps0_device_handle;
 static guid_t lps0_dsm_guid;
@@ -910,7 +911,8 @@ static int lps0_device_attach(struct acpi_device *adev,
 	if (out_obj && out_obj->type == ACPI_TYPE_BUFFER) {
 		char bitmask = *(char *)out_obj->buffer.pointer;
 
-		if ((bitmask & ACPI_S2IDLE_FUNC_MASK) == ACPI_S2IDLE_FUNC_MASK) {
+		if ((bitmask & ACPI_LPS0_PLATFORM_MASK) == ACPI_LPS0_PLATFORM_MASK ||
+		    (bitmask & ACPI_LPS0_SCREEN_MASK) == ACPI_LPS0_SCREEN_MASK) {
 			lps0_dsm_func_mask = bitmask;
 			lps0_device_handle = adev->handle;
 			/*

commit 57044031b0cb11325e1034394a4721484f9dc9fe
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Nov 15 02:16:55 2017 +0100

    ACPI / PM: Make it possible to ignore the system sleep blacklist
    
    The ACPI code supporting system transitions to sleep states uses
    an internal blacklist to apply special handling to some machines
    reported to behave incorrectly in some ways.
    
    However, some entries of that blacklist cover problematic as well as
    non-problematic systems, so give the users of the latter a chance to
    ignore the blacklist and run their systems in the default way by
    adding acpi_sleep=nobl to the kernel command line.
    
    For example, that allows the users of Dell XPS13 9360 systems not
    affected by the issue that caused the blacklist entry for this
    machine to be added by commit 71630b7a832f (ACPI / PM: Blacklist Low
    Power S0 Idle _DSM for Dell XPS13 9360) to use suspend-to-idle with
    the Low Power S0 Idle _DSM interface which in principle should be
    more energy-efficient than S3 on them.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 8082871b409a..15cd862a87c2 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -367,10 +367,20 @@ static const struct dmi_system_id acpisleep_dmi_table[] __initconst = {
 	{},
 };
 
+static bool ignore_blacklist;
+
+void __init acpi_sleep_no_blacklist(void)
+{
+	ignore_blacklist = true;
+}
+
 static void __init acpi_sleep_dmi_check(void)
 {
 	int year;
 
+	if (ignore_blacklist)
+		return;
+
 	if (dmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL) && year >= 2012)
 		acpi_nvs_nosave_s3();
 

commit 71630b7a832f699d6a6764ae75797e4e743ae348
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 6 23:56:57 2017 +0100

    ACPI / PM: Blacklist Low Power S0 Idle _DSM for Dell XPS13 9360
    
    At least one Dell XPS13 9360 is reported to have serious issues with
    the Low Power S0 Idle _DSM interface and since this machine model
    generally can do ACPI S3 just fine, add a blacklist entry to disable
    that interface for Dell XPS13 9360.
    
    Fixes: 8110dd281e15 (ACPI / sleep: EC-based wakeup from suspend-to-idle on recent systems)
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=196907
    Reported-by: Paul Menzel <pmenzel@molgen.mpg.de>
    Tested-by: Paul Menzel <pmenzel@molgen.mpg.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: 4.13+ <stable@vger.kernel.org> # 4.13+

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 6804ddab3052..8082871b409a 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -160,6 +160,14 @@ static int __init init_nvs_nosave(const struct dmi_system_id *d)
 	return 0;
 }
 
+static bool acpi_sleep_no_lps0;
+
+static int __init init_no_lps0(const struct dmi_system_id *d)
+{
+	acpi_sleep_no_lps0 = true;
+	return 0;
+}
+
 static const struct dmi_system_id acpisleep_dmi_table[] __initconst = {
 	{
 	.callback = init_old_suspend_ordering,
@@ -343,6 +351,19 @@ static const struct dmi_system_id acpisleep_dmi_table[] __initconst = {
 		DMI_MATCH(DMI_PRODUCT_NAME, "80E3"),
 		},
 	},
+	/*
+	 * https://bugzilla.kernel.org/show_bug.cgi?id=196907
+	 * Some Dell XPS13 9360 cannot do suspend-to-idle using the Low Power
+	 * S0 Idle firmware interface.
+	 */
+	{
+	.callback = init_no_lps0,
+	.ident = "Dell XPS13 9360",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+		DMI_MATCH(DMI_PRODUCT_NAME, "XPS 13 9360"),
+		},
+	},
 	{},
 };
 
@@ -485,6 +506,7 @@ static void acpi_pm_end(void)
 }
 #else /* !CONFIG_ACPI_SLEEP */
 #define acpi_target_sleep_state	ACPI_STATE_S0
+#define acpi_sleep_no_lps0	(false)
 static inline void acpi_sleep_dmi_check(void) {}
 #endif /* CONFIG_ACPI_SLEEP */
 
@@ -863,6 +885,12 @@ static int lps0_device_attach(struct acpi_device *adev,
 	if (lps0_device_handle)
 		return 0;
 
+	if (acpi_sleep_no_lps0) {
+		acpi_handle_info(adev->handle,
+				 "Low Power S0 Idle interface disabled\n");
+		return 0;
+	}
+
 	if (!(acpi_gbl_FADT.flags & ACPI_FADT_LOW_POWER_S0))
 		return 0;
 

commit 6faadbbb7f9da70ce484f98f72223c20125a1009
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Sep 14 11:59:30 2017 +0200

    dmi: Mark all struct dmi_system_id instances const
    
    ... and __initconst if applicable.
    
    Based on similar work for an older kernel in the Grsecurity patch.
    
    [JD: fix toshiba-wmi build]
    [JD: add htcpen]
    [JD: move __initconst where checkscript wants it]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jean Delvare <jdelvare@suse.de>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 9fdd014759f8..6804ddab3052 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -160,7 +160,7 @@ static int __init init_nvs_nosave(const struct dmi_system_id *d)
 	return 0;
 }
 
-static struct dmi_system_id acpisleep_dmi_table[] __initdata = {
+static const struct dmi_system_id acpisleep_dmi_table[] __initconst = {
 	{
 	.callback = init_old_suspend_ordering,
 	.ident = "Abit KN9 (nForce4 variant)",

commit 53ac64aac9af8cd0e5456c8a9bb68c47b571b0a9
Merge: 439644096c1a 298bd7fb26cb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 5 12:45:03 2017 -0700

    Merge tag 'acpi-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI updates from Rafael Wysocki:
     "These include a usual ACPICA code update (this time to upstream
      revision 20170728), a fix for a boot crash on some systems with
      Thunderbolt devices connected at boot time, a rework of the handling
      of PCI bridges when setting up device wakeup, new support for Apple
      device properties, support for DMA configurations reported via ACPI on
      ARM64, APEI-related updates, ACPI EC driver updates and assorted minor
      modifications in several places.
    
      Specifics:
    
       - Update the ACPICA code in the kernel to upstream revision 20170728
         including:
          * Alias operator handling update (Bob Moore).
          * Deferred resolution of reference package elements (Bob Moore).
          * Support for the _DMA method in walk resources (Bob Moore).
          * Tables handling update and support for deferred table
            verification (Lv Zheng).
          * Update of SMMU models for IORT (Robin Murphy).
          * Compiler and disassembler updates (Alex James, Erik Schmauss,
            Ganapatrao Kulkarni, James Morse).
          * Tools updates (Erik Schmauss, Lv Zheng).
          * Assorted minor fixes and cleanups (Bob Moore, Kees Cook, Lv
            Zheng, Shao Ming).
    
       - Rework the initialization of non-wakeup GPEs with method handlers
         in order to address a boot crash on some systems with Thunderbolt
         devices connected at boot time where we miss an early hotplug event
         due to a delay in GPE enabling (Rafael Wysocki).
    
       - Rework the handling of PCI bridges when setting up ACPI-based
         device wakeup in order to avoid disabling wakeup for bridges
         prematurely (Rafael Wysocki).
    
       - Consolidate Apple DMI checks throughout the tree, add support for
         Apple device properties to the device properties framework and use
         these properties for the handling of I2C and SPI devices on Apple
         systems (Lukas Wunner).
    
       - Add support for _DMA to the ACPI-based device properties lookup
         code and make it possible to use the information from there to
         configure DMA regions on ARM64 systems (Lorenzo Pieralisi).
    
       - Fix several issues in the APEI code, add support for exporting the
         BERT error region over sysfs and update APEI MAINTAINERS entry with
         reviewers information (Borislav Petkov, Dongjiu Geng, Loc Ho, Punit
         Agrawal, Tony Luck, Yazen Ghannam).
    
       - Fix a potential initialization ordering issue in the ACPI EC driver
         and clean it up somewhat (Lv Zheng).
    
       - Update the ACPI SPCR driver to extend the existing XGENE 8250
         workaround in it to a new platform (m400) and to work around an
         Xgene UART clock issue (Graeme Gregory).
    
       - Add a new utility function to the ACPI core to support using ACPI
         OEM ID / OEM Table ID / Revision for system identification in
         blacklisting or similar and switch over the existing code already
         using this information to this new interface (Toshi Kani).
    
       - Fix an xpower PMIC issue related to GPADC reads that always return
         0 without extra pin manipulations (Hans de Goede).
    
       - Add statements to print debug messages in a couple of places in the
         ACPI core for easier diagnostics (Rafael Wysocki).
    
       - Clean up the ACPI processor driver slightly (Colin Ian King, Hanjun
         Guo).
    
       - Clean up the ACPI x86 boot code somewhat (Andy Shevchenko).
    
       - Add a quirk for Dell OptiPlex 9020M to the ACPI backlight driver
         (Alex Hung).
    
       - Assorted fixes, cleanups and updates related to ACPI (Amitoj Kaur
         Chawla, Bhumika Goyal, Frank Rowand, Jean Delvare, Punit Agrawal,
         Ronald Tschalär, Sumeet Pawnikar)"
    
    * tag 'acpi-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (75 commits)
      ACPI / APEI: Suppress message if HEST not present
      intel_pstate: convert to use acpi_match_platform_list()
      ACPI / blacklist: add acpi_match_platform_list()
      ACPI, APEI, EINJ: Subtract any matching Register Region from Trigger resources
      ACPI: make device_attribute const
      ACPI / sysfs: Extend ACPI sysfs to provide access to boot error region
      ACPI: APEI: fix the wrong iteration of generic error status block
      ACPI / processor: make function acpi_processor_check_duplicates() static
      ACPI / EC: Clean up EC GPE mask flag
      ACPI: EC: Fix possible issues related to EC initialization order
      ACPI / PM: Add debug statements to acpi_pm_notify_handler()
      ACPI: Add debug statements to acpi_global_event_handler()
      ACPI / scan: Enable GPEs before scanning the namespace
      ACPICA: Make it possible to enable runtime GPEs earlier
      ACPICA: Dispatch active GPEs at init time
      ACPI: SPCR: work around clock issue on xgene UART
      ACPI: SPCR: extend XGENE 8250 workaround to m400
      ACPI / LPSS: Don't abort ACPI scan on missing mem resource
      mailbox: pcc: Drop uninformative output during boot
      ACPI/IORT: Add IORT named component memory address limits
      ...

commit 7b01463e51f6849d0787b24d06a62efcb243dd44
Merge: a1b5fd8fa29f 726fb6b4f2a8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Sep 4 00:06:02 2017 +0200

    Merge branch 'pm-sleep'
    
    * pm-sleep:
      ACPI / PM: Check low power idle constraints for debug only
      PM / s2idle: Rename platform operations structure
      PM / s2idle: Rename ->enter_freeze to ->enter_s2idle
      PM / s2idle: Rename freeze_state enum and related items
      PM / s2idle: Rename PM_SUSPEND_FREEZE to PM_SUSPEND_TO_IDLE
      ACPI / PM: Prefer suspend-to-idle over S3 on some systems
      platform/x86: intel-hid: Wake up Dell Latitude 7275 from suspend-to-idle
      PM / suspend: Define pr_fmt() in suspend.c
      PM / suspend: Use mem_sleep_labels[] strings in messages
      PM / sleep: Put pm_test under CONFIG_PM_SLEEP_DEBUG
      PM / sleep: Check pm_wakeup_pending() in __device_suspend_noirq()
      PM / core: Add error argument to dpm_show_time()
      PM / core: Split dpm_suspend_noirq() and dpm_resume_noirq()
      PM / s2idle: Rearrange the main suspend-to-idle loop
      PM / timekeeping: Print debug messages when requested
      PM / sleep: Mark suspend/hibernation start and finish
      PM / sleep: Do not print debug messages by default
      PM / suspend: Export pm_suspend_target_state

commit 726fb6b4f2a82a14a906f39bdabac4863b87c01a
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Aug 15 18:16:59 2017 -0700

    ACPI / PM: Check low power idle constraints for debug only
    
    For SoC to achieve its lowest power platform idle state a set of hardware
    preconditions must be met. These preconditions or constraints can be
    obtained by issuing a device specific method (_DSM) with function "1".
    Refer to the document provided in the link below.
    
    Here during initialization (from attach() callback of LPS0 device), invoke
    function 1 to get the device constraints. Each enabled constraint is
    stored in a table.
    
    The devices in this table are used to check whether they were in required
    minimum state, while entering suspend. This check is done from platform
    freeze wake() callback, only when /sys/power/pm_debug_messages attribute
    is non zero.
    
    If any constraint is not met and device is ACPI power managed then it
    prints the device information to kernel logs.
    
    Also if debug is enabled in acpi/sleep.c, the constraint table and state
    of each device on wake is dumped in kernel logs.
    
    Since pm_debug_messages_on setting is used as condition to check
    constraints outside kernel/power/main.c, pm_debug_messages_on is changed
    to a global variable.
    
    Link: http://www.uefi.org/sites/default/files/resources/Intel_ACPI_Low_Power_S0_Idle.pdf
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index f7a8abbeac6e..61b2e9f17c4e 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -669,6 +669,7 @@ static const struct acpi_device_id lps0_device_ids[] = {
 
 #define ACPI_LPS0_DSM_UUID	"c4eb40a0-6cd2-11e2-bcfd-0800200c9a66"
 
+#define ACPI_LPS0_GET_DEVICE_CONSTRAINTS	1
 #define ACPI_LPS0_SCREEN_OFF	3
 #define ACPI_LPS0_SCREEN_ON	4
 #define ACPI_LPS0_ENTRY		5
@@ -680,6 +681,166 @@ static acpi_handle lps0_device_handle;
 static guid_t lps0_dsm_guid;
 static char lps0_dsm_func_mask;
 
+/* Device constraint entry structure */
+struct lpi_device_info {
+	char *name;
+	int enabled;
+	union acpi_object *package;
+};
+
+/* Constraint package structure */
+struct lpi_device_constraint {
+	int uid;
+	int min_dstate;
+	int function_states;
+};
+
+struct lpi_constraints {
+	acpi_handle handle;
+	int min_dstate;
+};
+
+static struct lpi_constraints *lpi_constraints_table;
+static int lpi_constraints_table_size;
+
+static void lpi_device_get_constraints(void)
+{
+	union acpi_object *out_obj;
+	int i;
+
+	out_obj = acpi_evaluate_dsm_typed(lps0_device_handle, &lps0_dsm_guid,
+					  1, ACPI_LPS0_GET_DEVICE_CONSTRAINTS,
+					  NULL, ACPI_TYPE_PACKAGE);
+
+	acpi_handle_debug(lps0_device_handle, "_DSM function 1 eval %s\n",
+			  out_obj ? "successful" : "failed");
+
+	if (!out_obj)
+		return;
+
+	lpi_constraints_table = kcalloc(out_obj->package.count,
+					sizeof(*lpi_constraints_table),
+					GFP_KERNEL);
+	if (!lpi_constraints_table)
+		goto free_acpi_buffer;
+
+	acpi_handle_debug(lps0_device_handle, "LPI: constraints list begin:\n");
+
+	for (i = 0; i < out_obj->package.count; i++) {
+		struct lpi_constraints *constraint;
+		acpi_status status;
+		union acpi_object *package = &out_obj->package.elements[i];
+		struct lpi_device_info info = { };
+		int package_count = 0, j;
+
+		if (!package)
+			continue;
+
+		for (j = 0; j < package->package.count; ++j) {
+			union acpi_object *element =
+					&(package->package.elements[j]);
+
+			switch (element->type) {
+			case ACPI_TYPE_INTEGER:
+				info.enabled = element->integer.value;
+				break;
+			case ACPI_TYPE_STRING:
+				info.name = element->string.pointer;
+				break;
+			case ACPI_TYPE_PACKAGE:
+				package_count = element->package.count;
+				info.package = element->package.elements;
+				break;
+			}
+		}
+
+		if (!info.enabled || !info.package || !info.name)
+			continue;
+
+		constraint = &lpi_constraints_table[lpi_constraints_table_size];
+
+		status = acpi_get_handle(NULL, info.name, &constraint->handle);
+		if (ACPI_FAILURE(status))
+			continue;
+
+		acpi_handle_debug(lps0_device_handle,
+				  "index:%d Name:%s\n", i, info.name);
+
+		constraint->min_dstate = -1;
+
+		for (j = 0; j < package_count; ++j) {
+			union acpi_object *info_obj = &info.package[j];
+			union acpi_object *cnstr_pkg;
+			union acpi_object *obj;
+			struct lpi_device_constraint dev_info;
+
+			switch (info_obj->type) {
+			case ACPI_TYPE_INTEGER:
+				/* version */
+				break;
+			case ACPI_TYPE_PACKAGE:
+				if (info_obj->package.count < 2)
+					break;
+
+				cnstr_pkg = info_obj->package.elements;
+				obj = &cnstr_pkg[0];
+				dev_info.uid = obj->integer.value;
+				obj = &cnstr_pkg[1];
+				dev_info.min_dstate = obj->integer.value;
+
+				acpi_handle_debug(lps0_device_handle,
+					"uid:%d min_dstate:%s\n",
+					dev_info.uid,
+					acpi_power_state_string(dev_info.min_dstate));
+
+				constraint->min_dstate = dev_info.min_dstate;
+				break;
+			}
+		}
+
+		if (constraint->min_dstate < 0) {
+			acpi_handle_debug(lps0_device_handle,
+					  "Incomplete constraint defined\n");
+			continue;
+		}
+
+		lpi_constraints_table_size++;
+	}
+
+	acpi_handle_debug(lps0_device_handle, "LPI: constraints list end\n");
+
+free_acpi_buffer:
+	ACPI_FREE(out_obj);
+}
+
+static void lpi_check_constraints(void)
+{
+	int i;
+
+	for (i = 0; i < lpi_constraints_table_size; ++i) {
+		struct acpi_device *adev;
+
+		if (acpi_bus_get_device(lpi_constraints_table[i].handle, &adev))
+			continue;
+
+		acpi_handle_debug(adev->handle,
+			"LPI: required min power state:%s current power state:%s\n",
+			acpi_power_state_string(lpi_constraints_table[i].min_dstate),
+			acpi_power_state_string(adev->power.state));
+
+		if (!adev->flags.power_manageable) {
+			acpi_handle_info(adev->handle, "LPI: Device not power manageble\n");
+			continue;
+		}
+
+		if (adev->power.state < lpi_constraints_table[i].min_dstate)
+			acpi_handle_info(adev->handle,
+				"LPI: Constraint not met; min power state:%s current power state:%s\n",
+				acpi_power_state_string(lpi_constraints_table[i].min_dstate),
+				acpi_power_state_string(adev->power.state));
+	}
+}
+
 static void acpi_sleep_run_lps0_dsm(unsigned int func)
 {
 	union acpi_object *out_obj;
@@ -729,6 +890,9 @@ static int lps0_device_attach(struct acpi_device *adev,
 				  "_DSM function 0 evaluation failed\n");
 	}
 	ACPI_FREE(out_obj);
+
+	lpi_device_get_constraints();
+
 	return 0;
 }
 
@@ -766,6 +930,10 @@ static int acpi_s2idle_prepare(void)
 
 static void acpi_s2idle_wake(void)
 {
+
+	if (pm_debug_messages_on)
+		lpi_check_constraints();
+
 	/*
 	 * If IRQD_WAKEUP_ARMED is not set for the SCI at this point, it means
 	 * that the SCI has triggered while suspended, so cancel the wakeup in

commit 23d5855f4774f4f7c246a67057ecacc904696d8a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 10 00:15:30 2017 +0200

    PM / s2idle: Rename platform operations structure
    
    Rename struct platform_freeze_ops to platform_s2idle_ops to make it
    clear that the callbacks in it are used during suspend-to-idle
    suspend/resume transitions and rename the related functions,
    variables and so on accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index a0a6fd10fb5f..f7a8abbeac6e 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -737,14 +737,14 @@ static struct acpi_scan_handler lps0_handler = {
 	.attach = lps0_device_attach,
 };
 
-static int acpi_freeze_begin(void)
+static int acpi_s2idle_begin(void)
 {
 	acpi_scan_lock_acquire();
 	s2idle_in_progress = true;
 	return 0;
 }
 
-static int acpi_freeze_prepare(void)
+static int acpi_s2idle_prepare(void)
 {
 	if (lps0_device_handle) {
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_OFF);
@@ -764,7 +764,7 @@ static int acpi_freeze_prepare(void)
 	return 0;
 }
 
-static void acpi_freeze_wake(void)
+static void acpi_s2idle_wake(void)
 {
 	/*
 	 * If IRQD_WAKEUP_ARMED is not set for the SCI at this point, it means
@@ -778,7 +778,7 @@ static void acpi_freeze_wake(void)
 	}
 }
 
-static void acpi_freeze_sync(void)
+static void acpi_s2idle_sync(void)
 {
 	/*
 	 * Process all pending events in case there are any wakeup ones.
@@ -791,7 +791,7 @@ static void acpi_freeze_sync(void)
 	s2idle_wakeup = false;
 }
 
-static void acpi_freeze_restore(void)
+static void acpi_s2idle_restore(void)
 {
 	if (acpi_sci_irq_valid())
 		disable_irq_wake(acpi_sci_irq);
@@ -804,19 +804,19 @@ static void acpi_freeze_restore(void)
 	}
 }
 
-static void acpi_freeze_end(void)
+static void acpi_s2idle_end(void)
 {
 	s2idle_in_progress = false;
 	acpi_scan_lock_release();
 }
 
-static const struct platform_freeze_ops acpi_freeze_ops = {
-	.begin = acpi_freeze_begin,
-	.prepare = acpi_freeze_prepare,
-	.wake = acpi_freeze_wake,
-	.sync = acpi_freeze_sync,
-	.restore = acpi_freeze_restore,
-	.end = acpi_freeze_end,
+static const struct platform_s2idle_ops acpi_s2idle_ops = {
+	.begin = acpi_s2idle_begin,
+	.prepare = acpi_s2idle_prepare,
+	.wake = acpi_s2idle_wake,
+	.sync = acpi_s2idle_sync,
+	.restore = acpi_s2idle_restore,
+	.end = acpi_s2idle_end,
 };
 
 static void acpi_sleep_suspend_setup(void)
@@ -831,7 +831,7 @@ static void acpi_sleep_suspend_setup(void)
 		&acpi_suspend_ops_old : &acpi_suspend_ops);
 
 	acpi_scan_add_handler(&lps0_handler);
-	freeze_set_ops(&acpi_freeze_ops);
+	s2idle_set_ops(&acpi_s2idle_ops);
 }
 
 #else /* !CONFIG_SUSPEND */

commit 690cbb90a709c1b9389c6cb8e1978e77553ce0fb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 10 00:13:07 2017 +0200

    PM / s2idle: Rename PM_SUSPEND_FREEZE to PM_SUSPEND_TO_IDLE
    
    To make it clear that the symbol in question refers to
    suspend-to-idle, rename it from PM_SUSPEND_FREEZE to
    PM_SUSPEND_TO_IDLE.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index b363283dfcd9..a0a6fd10fb5f 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -719,7 +719,7 @@ static int lps0_device_attach(struct acpi_device *adev,
 			 * suspend mode was not set from the command line.
 			 */
 			if (mem_sleep_default > PM_SUSPEND_MEM)
-				mem_sleep_current = PM_SUSPEND_FREEZE;
+				mem_sleep_current = PM_SUSPEND_TO_IDLE;
 		}
 
 		acpi_handle_debug(adev->handle, "_DSM function mask: 0x%x\n",

commit e870c6c87cf9484090d28f2a68aa29e008960c93
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 31 23:43:18 2017 +0200

    ACPI / PM: Prefer suspend-to-idle over S3 on some systems
    
    Modify the ACPI system sleep support setup code to select
    suspend-to-idle as the default system sleep state if
    (1) the ACPI_FADT_LOW_POWER_S0 flag is set in the FADT and
    (2) the Low Power Idle S0 _DSM interface has been discovered and
    (3) the default sleep state was not selected from the kernel command
    line.
    
    The main motivation for this change is that systems where the (1) and
    (2) conditions are met typically ship with OSes that don't exercise
    the S3 path in the platform firmware which remains untested and turns
    out to be non-functional at least in some cases.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mario Limonciello <mario.limonciello@dell.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index be17664736b2..b363283dfcd9 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -714,6 +714,12 @@ static int lps0_device_attach(struct acpi_device *adev,
 		if ((bitmask & ACPI_S2IDLE_FUNC_MASK) == ACPI_S2IDLE_FUNC_MASK) {
 			lps0_dsm_func_mask = bitmask;
 			lps0_device_handle = adev->handle;
+			/*
+			 * Use suspend-to-idle by default if the default
+			 * suspend mode was not set from the command line.
+			 */
+			if (mem_sleep_default > PM_SUSPEND_MEM)
+				mem_sleep_current = PM_SUSPEND_FREEZE;
 		}
 
 		acpi_handle_debug(adev->handle, "_DSM function mask: 0x%x\n",

commit a042e0c62b38e7bb8b5edadc46c2ff23d1091111
Author: Jean Delvare <jdelvare@suse.de>
Date:   Mon Jul 31 11:40:13 2017 +0200

    ACPI / sleep: Make acpi_sleep_syscore_init() static
    
    Function acpi_sleep_syscore_init has no external user so it should be
    static.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index fa8243c5c062..dd5f21ca483e 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -870,7 +870,7 @@ static struct syscore_ops acpi_sleep_syscore_ops = {
 	.resume = acpi_restore_bm_rld,
 };
 
-void acpi_sleep_syscore_init(void)
+static void acpi_sleep_syscore_init(void)
 {
 	register_syscore_ops(&acpi_sleep_syscore_ops);
 }

commit 880a66275ef4d1e08e5d4dcf4cec768de18c68ef
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jul 20 03:43:12 2017 +0200

    ACPI / PM / EC: Flush all EC work in acpi_freeze_sync()
    
    Commit eed4d47efe95 (ACPI / sleep: Ignore spurious SCI wakeups from
    suspend-to-idle) introduced acpi_freeze_sync() whose purpose is to
    flush all of the processing of possible wakeup events signaled via
    the ACPI SCI.  However, it doesn't flush the query workqueue used
    by the EC driver, so the events generated by the EC may not be
    processed timely which leads to issues (increased overhead at least,
    lost events possibly).
    
    To fix that introduce acpi_ec_flush_work() that will flush all of
    the outstanding EC work and call it from acpi_freeze_sync().
    
    Fixes: eed4d47efe95 (ACPI / sleep: Ignore spurious SCI wakeups from suspend-to-idle)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index be17664736b2..fa8243c5c062 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -777,11 +777,11 @@ static void acpi_freeze_sync(void)
 	/*
 	 * Process all pending events in case there are any wakeup ones.
 	 *
-	 * The EC driver uses the system workqueue, so that one needs to be
-	 * flushed too.
+	 * The EC driver uses the system workqueue and an additional special
+	 * one, so those need to be flushed too.
 	 */
+	acpi_ec_flush_work();
 	acpi_os_wait_events_complete();
-	flush_scheduled_work();
 	s2idle_wakeup = false;
 }
 

commit 8110dd281e155e5010ffd657bba4742ebef7a93f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 23 15:24:32 2017 +0200

    ACPI / sleep: EC-based wakeup from suspend-to-idle on recent systems
    
    Some recent Dell laptops, including the XPS13 model numbers 9360 and
    9365, cannot be woken up from suspend-to-idle by pressing the power
    button which is unexpected and makes that feature less usable on
    those systems.  Moreover, on the 9365 ACPI S3 (suspend-to-RAM) is
    not expected to be used at all (the OS these systems ship with never
    exercises the ACPI S3 path in the firmware) and suspend-to-idle is
    the only viable system suspend mechanism there.
    
    The reason why the power button wakeup from suspend-to-idle doesn't
    work on those systems is because their power button events are
    signaled by the EC (Embedded Controller), whose GPE (General Purpose
    Event) line is disabled during suspend-to-idle transitions in Linux.
    That is done on purpose, because in general the EC tends to be noisy
    for various reasons (battery and thermal updates and similar, for
    example) and all events signaled by it would kick the CPUs out of
    deep idle states while in suspend-to-idle, which effectively might
    defeat its purpose.
    
    Of course, on the Dell systems in question the EC GPE must be enabled
    during suspend-to-idle transitions for the button press events to
    be signaled while suspended at all, but fortunately there is a way
    out of this puzzle.
    
    First of all, those systems have the ACPI_FADT_LOW_POWER_S0 flag set
    in their ACPI tables, which means that the OS is expected to prefer
    the "low power S0 idle" system state over ACPI S3 on them.  That
    causes the most recent versions of other OSes to simply ignore ACPI
    S3 on those systems, so it is reasonable to expect that it should not
    be necessary to block GPEs during suspend-to-idle on them.
    
    Second, in addition to that, the systems in question provide a special
    firmware interface that can be used to indicate to the platform that
    the OS is transitioning into a system-wide low-power state in which
    certain types of activity are not desirable or that it is leaving
    such a state and that (in principle) should allow the platform to
    adjust its operation mode accordingly.
    
    That interface is a special _DSM object under a System Power
    Management Controller device (PNP0D80).  The expected way to use it
    is to invoke function 0 from it on system initialization, functions
    3 and 5 during suspend transitions and functions 4 and 6 during
    resume transitions (to reverse the actions carried out by the
    former).  In particular, function 5 from the "Low-Power S0" device
    _DSM is expected to cause the platform to put itself into a low-power
    operation mode which should include making the EC less verbose (so to
    speak).  Next, on resume, function 6 switches the platform back to
    the "working-state" operation mode.
    
    In accordance with the above, modify the ACPI suspend-to-idle code
    to look for the "Low-Power S0" _DSM interface on platforms with the
    ACPI_FADT_LOW_POWER_S0 flag set in the ACPI tables.  If it's there,
    use it during suspend-to-idle transitions as prescribed and avoid
    changing the GPE configuration in that case.  [That should reflect
    what the most recent versions of other OSes do.]
    
    Also modify the ACPI EC driver to make it handle events during
    suspend-to-idle in the usual way if the "Low-Power S0" _DSM interface
    is going to be used to make the power button events work while
    suspended on the Dell machines mentioned above
    
    Link: http://www.uefi.org/sites/default/files/resources/Intel_ACPI_Low_Power_S0_Idle.pdf
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 555de11a56b6..be17664736b2 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -650,18 +650,108 @@ static const struct platform_suspend_ops acpi_suspend_ops_old = {
 	.recover = acpi_pm_finish,
 };
 
+static bool s2idle_in_progress;
 static bool s2idle_wakeup;
 
+/*
+ * On platforms supporting the Low Power S0 Idle interface there is an ACPI
+ * device object with the PNP0D80 compatible device ID (System Power Management
+ * Controller) and a specific _DSM method under it.  That method, if present,
+ * can be used to indicate to the platform that the OS is transitioning into a
+ * low-power state in which certain types of activity are not desirable or that
+ * it is leaving such a state, which allows the platform to adjust its operation
+ * mode accordingly.
+ */
+static const struct acpi_device_id lps0_device_ids[] = {
+	{"PNP0D80", },
+	{"", },
+};
+
+#define ACPI_LPS0_DSM_UUID	"c4eb40a0-6cd2-11e2-bcfd-0800200c9a66"
+
+#define ACPI_LPS0_SCREEN_OFF	3
+#define ACPI_LPS0_SCREEN_ON	4
+#define ACPI_LPS0_ENTRY		5
+#define ACPI_LPS0_EXIT		6
+
+#define ACPI_S2IDLE_FUNC_MASK	((1 << ACPI_LPS0_ENTRY) | (1 << ACPI_LPS0_EXIT))
+
+static acpi_handle lps0_device_handle;
+static guid_t lps0_dsm_guid;
+static char lps0_dsm_func_mask;
+
+static void acpi_sleep_run_lps0_dsm(unsigned int func)
+{
+	union acpi_object *out_obj;
+
+	if (!(lps0_dsm_func_mask & (1 << func)))
+		return;
+
+	out_obj = acpi_evaluate_dsm(lps0_device_handle, &lps0_dsm_guid, 1, func, NULL);
+	ACPI_FREE(out_obj);
+
+	acpi_handle_debug(lps0_device_handle, "_DSM function %u evaluation %s\n",
+			  func, out_obj ? "successful" : "failed");
+}
+
+static int lps0_device_attach(struct acpi_device *adev,
+			      const struct acpi_device_id *not_used)
+{
+	union acpi_object *out_obj;
+
+	if (lps0_device_handle)
+		return 0;
+
+	if (!(acpi_gbl_FADT.flags & ACPI_FADT_LOW_POWER_S0))
+		return 0;
+
+	guid_parse(ACPI_LPS0_DSM_UUID, &lps0_dsm_guid);
+	/* Check if the _DSM is present and as expected. */
+	out_obj = acpi_evaluate_dsm(adev->handle, &lps0_dsm_guid, 1, 0, NULL);
+	if (out_obj && out_obj->type == ACPI_TYPE_BUFFER) {
+		char bitmask = *(char *)out_obj->buffer.pointer;
+
+		if ((bitmask & ACPI_S2IDLE_FUNC_MASK) == ACPI_S2IDLE_FUNC_MASK) {
+			lps0_dsm_func_mask = bitmask;
+			lps0_device_handle = adev->handle;
+		}
+
+		acpi_handle_debug(adev->handle, "_DSM function mask: 0x%x\n",
+				  bitmask);
+	} else {
+		acpi_handle_debug(adev->handle,
+				  "_DSM function 0 evaluation failed\n");
+	}
+	ACPI_FREE(out_obj);
+	return 0;
+}
+
+static struct acpi_scan_handler lps0_handler = {
+	.ids = lps0_device_ids,
+	.attach = lps0_device_attach,
+};
+
 static int acpi_freeze_begin(void)
 {
 	acpi_scan_lock_acquire();
+	s2idle_in_progress = true;
 	return 0;
 }
 
 static int acpi_freeze_prepare(void)
 {
-	acpi_enable_all_wakeup_gpes();
-	acpi_os_wait_events_complete();
+	if (lps0_device_handle) {
+		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_OFF);
+		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY);
+	} else {
+		/*
+		 * The configuration of GPEs is changed here to avoid spurious
+		 * wakeups, but that should not be necessary if this is a
+		 * "low-power S0" platform and the low-power S0 _DSM is present.
+		 */
+		acpi_enable_all_wakeup_gpes();
+		acpi_os_wait_events_complete();
+	}
 	if (acpi_sci_irq_valid())
 		enable_irq_wake(acpi_sci_irq);
 
@@ -700,11 +790,17 @@ static void acpi_freeze_restore(void)
 	if (acpi_sci_irq_valid())
 		disable_irq_wake(acpi_sci_irq);
 
-	acpi_enable_all_runtime_gpes();
+	if (lps0_device_handle) {
+		acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT);
+		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_ON);
+	} else {
+		acpi_enable_all_runtime_gpes();
+	}
 }
 
 static void acpi_freeze_end(void)
 {
+	s2idle_in_progress = false;
 	acpi_scan_lock_release();
 }
 
@@ -727,11 +823,15 @@ static void acpi_sleep_suspend_setup(void)
 
 	suspend_set_ops(old_suspend_ordering ?
 		&acpi_suspend_ops_old : &acpi_suspend_ops);
+
+	acpi_scan_add_handler(&lps0_handler);
 	freeze_set_ops(&acpi_freeze_ops);
 }
 
 #else /* !CONFIG_SUSPEND */
-#define s2idle_wakeup	(false)
+#define s2idle_in_progress	(false)
+#define s2idle_wakeup		(false)
+#define lps0_device_handle	(NULL)
 static inline void acpi_sleep_suspend_setup(void) {}
 #endif /* !CONFIG_SUSPEND */
 
@@ -740,6 +840,11 @@ bool acpi_s2idle_wakeup(void)
 	return s2idle_wakeup;
 }
 
+bool acpi_sleep_no_ec_events(void)
+{
+	return !s2idle_in_progress || !lps0_device_handle;
+}
+
 #ifdef CONFIG_PM_SLEEP
 static u32 saved_bm_rld;
 

commit 33e4f80ee69b5168badf37edbfed796eb48434b9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 12 22:56:34 2017 +0200

    ACPI / PM: Ignore spurious SCI wakeups from suspend-to-idle
    
    The ACPI SCI (System Control Interrupt) is set up as a wakeup IRQ
    during suspend-to-idle transitions and, consequently, any events
    signaled through it wake up the system from that state.  However,
    on some systems some of the events signaled via the ACPI SCI while
    suspended to idle should not cause the system to wake up.  In fact,
    quite often they should just be discarded.
    
    Arguably, systems should not resume entirely on such events, but in
    order to decide which events really should cause the system to resume
    and which are spurious, it is necessary to resume up to the point
    when ACPI SCIs are actually handled and processed, which is after
    executing dpm_resume_noirq() in the system resume path.
    
    For this reasons, add a loop around freeze_enter() in which the
    platforms can process events signaled via multiplexed IRQ lines
    like the ACPI SCI and add suspend-to-idle hooks that can be
    used for this purpose to struct platform_freeze_ops.
    
    In the ACPI case, the ->wake hook is used for checking if the SCI
    has triggered while suspended and deferring the interrupt-induced
    system wakeup until the events signaled through it are actually
    processed sufficiently to decide whether or not the system should
    resume.  In turn, the ->sync hook allows all of the relevant event
    queues to be flushed so as to prevent events from being missed due
    to race conditions.
    
    In addition to that, some ACPI code processing wakeup events needs
    to be modified to use the "hard" version of wakeup triggers, so that
    it will cause a system resume to happen on device-induced wakeup
    events even if the "soft" mechanism to prevent the system from
    suspending is not enabled.  However, to preserve the existing
    behavior with respect to suspend-to-RAM, this only is done in
    the suspend-to-idle case and only if an SCI has occurred while
    suspended.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index a4782c75ebdd..555de11a56b6 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -650,6 +650,8 @@ static const struct platform_suspend_ops acpi_suspend_ops_old = {
 	.recover = acpi_pm_finish,
 };
 
+static bool s2idle_wakeup;
+
 static int acpi_freeze_begin(void)
 {
 	acpi_scan_lock_acquire();
@@ -666,6 +668,33 @@ static int acpi_freeze_prepare(void)
 	return 0;
 }
 
+static void acpi_freeze_wake(void)
+{
+	/*
+	 * If IRQD_WAKEUP_ARMED is not set for the SCI at this point, it means
+	 * that the SCI has triggered while suspended, so cancel the wakeup in
+	 * case it has not been a wakeup event (the GPEs will be checked later).
+	 */
+	if (acpi_sci_irq_valid() &&
+	    !irqd_is_wakeup_armed(irq_get_irq_data(acpi_sci_irq))) {
+		pm_system_cancel_wakeup();
+		s2idle_wakeup = true;
+	}
+}
+
+static void acpi_freeze_sync(void)
+{
+	/*
+	 * Process all pending events in case there are any wakeup ones.
+	 *
+	 * The EC driver uses the system workqueue, so that one needs to be
+	 * flushed too.
+	 */
+	acpi_os_wait_events_complete();
+	flush_scheduled_work();
+	s2idle_wakeup = false;
+}
+
 static void acpi_freeze_restore(void)
 {
 	if (acpi_sci_irq_valid())
@@ -682,6 +711,8 @@ static void acpi_freeze_end(void)
 static const struct platform_freeze_ops acpi_freeze_ops = {
 	.begin = acpi_freeze_begin,
 	.prepare = acpi_freeze_prepare,
+	.wake = acpi_freeze_wake,
+	.sync = acpi_freeze_sync,
 	.restore = acpi_freeze_restore,
 	.end = acpi_freeze_end,
 };
@@ -700,9 +731,15 @@ static void acpi_sleep_suspend_setup(void)
 }
 
 #else /* !CONFIG_SUSPEND */
+#define s2idle_wakeup	(false)
 static inline void acpi_sleep_suspend_setup(void) {}
 #endif /* !CONFIG_SUSPEND */
 
+bool acpi_s2idle_wakeup(void)
+{
+	return s2idle_wakeup;
+}
+
 #ifdef CONFIG_PM_SLEEP
 static u32 saved_bm_rld;
 

commit 235d81a630ca2d39818da96f0c14bc960ffbaeb5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 12 22:51:07 2017 +0200

    ACPI / PM: Clean up device wakeup enable/disable code
    
    The wakeup.flags.enabled flag in struct acpi_device is not used
    consistently, as there is no reason why it should only apply
    to the enabling/disabling of the wakeup GPE, so put the invocation
    of acpi_enable_wakeup_device_power() under it too.
    
    Moreover, it is not necessary to call
    acpi_enable_wakeup_devices() and acpi_disable_wakeup_devices() for
    suspend-to-idle, so don't do that.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 097d630ab886..a4782c75ebdd 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -658,19 +658,19 @@ static int acpi_freeze_begin(void)
 
 static int acpi_freeze_prepare(void)
 {
-	acpi_enable_wakeup_devices(ACPI_STATE_S0);
 	acpi_enable_all_wakeup_gpes();
 	acpi_os_wait_events_complete();
 	if (acpi_sci_irq_valid())
 		enable_irq_wake(acpi_sci_irq);
+
 	return 0;
 }
 
 static void acpi_freeze_restore(void)
 {
-	acpi_disable_wakeup_devices(ACPI_STATE_S0);
 	if (acpi_sci_irq_valid())
 		disable_irq_wake(acpi_sci_irq);
+
 	acpi_enable_all_runtime_gpes();
 }
 

commit fbd78afe34d9cc3a86aff7cc214d9f06e815e63e
Merge: 3c2993b8c614 57caf4ec2b8b f3b7eaae1b35
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 9 01:25:16 2017 +0200

    Merge branches 'intel_pstate' and 'pm-sleep'
    
    * intel_pstate:
      cpufreq: intel_pstate: Avoid division by 0 in min_perf_pct_min()
    
    * pm-sleep:
      Revert "ACPI / sleep: Ignore spurious SCI wakeups from suspend-to-idle"

commit f3b7eaae1b35eb8077610eb7c7db042c9b0645e1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 7 00:57:37 2017 +0200

    Revert "ACPI / sleep: Ignore spurious SCI wakeups from suspend-to-idle"
    
    Revert commit eed4d47efe95 (ACPI / sleep: Ignore spurious SCI wakeups
    from suspend-to-idle) as it turned out to be premature and triggered
    a number of different issues on various systems.
    
    That includes, but is not limited to, premature suspend-to-RAM aborts
    on Dell XPS 13 (9343) reported by Dominik.
    
    The issue the commit in question attempted to address is real and
    will need to be taken care of going forward, but evidently more work
    is needed for this purpose.
    
    Reported-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index e84005d642e6..a4327af676fe 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -662,40 +662,14 @@ static int acpi_freeze_prepare(void)
 	acpi_os_wait_events_complete();
 	if (acpi_sci_irq_valid())
 		enable_irq_wake(acpi_sci_irq);
-
 	return 0;
 }
 
-static void acpi_freeze_wake(void)
-{
-	/*
-	 * If IRQD_WAKEUP_ARMED is not set for the SCI at this point, it means
-	 * that the SCI has triggered while suspended, so cancel the wakeup in
-	 * case it has not been a wakeup event (the GPEs will be checked later).
-	 */
-	if (acpi_sci_irq_valid() &&
-	    !irqd_is_wakeup_armed(irq_get_irq_data(acpi_sci_irq)))
-		pm_system_cancel_wakeup();
-}
-
-static void acpi_freeze_sync(void)
-{
-	/*
-	 * Process all pending events in case there are any wakeup ones.
-	 *
-	 * The EC driver uses the system workqueue, so that one needs to be
-	 * flushed too.
-	 */
-	acpi_os_wait_events_complete();
-	flush_scheduled_work();
-}
-
 static void acpi_freeze_restore(void)
 {
 	acpi_disable_wakeup_devices(ACPI_STATE_S0);
 	if (acpi_sci_irq_valid())
 		disable_irq_wake(acpi_sci_irq);
-
 	acpi_enable_all_runtime_gpes();
 }
 
@@ -707,8 +681,6 @@ static void acpi_freeze_end(void)
 static const struct platform_freeze_ops acpi_freeze_ops = {
 	.begin = acpi_freeze_begin,
 	.prepare = acpi_freeze_prepare,
-	.wake = acpi_freeze_wake,
-	.sync = acpi_freeze_sync,
 	.restore = acpi_freeze_restore,
 	.end = acpi_freeze_end,
 };

commit dc9edaab90de9441cc28ac570b23b0d2bdba7879
Merge: 2e4ab937ec49 46436eb2f9e6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 10 09:35:42 2017 -0700

    Merge tag 'acpi-extra-4.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more ACPI updates from Rafael Wysocki:
     "These update the ACPICA code in the kernel to upstream revision
      20170303 which adds a few minor fixes and improvements, update ACPI
      SoC drivers with new device IDs, platform-related information and
      similar, fix the register information in the xpower PMIC driver,
      introduce a concept of "always present" devices to the ACPI device
      enumeration code and use it to fix a problem with one platform, and
      fix a system resume issue related to power resources.
    
      Specifics:
    
       - Update the ACPICA code in the kernel to upstream revision 20170303
         which includes:
          * Minor fixes and improvements in the core code (Bob Moore,
            Seunghun Han).
          * Debugger fixes (Colin Ian King, Lv Zheng).
          * Compiler/disassembler improvements (Bob Moore, David Box, Lv
            Zheng).
          * Build-related update (Lv Zheng).
    
       - Add new device IDs and platform-related information to the ACPI
         drivers for Intel (LPSS) and AMD (APD) SoCs (Hanjun Guo, Hans de
         Goede).
    
       - Make it possible to quirk ACPI-enumerated devices as "always
         present" on platforms where they are incorrectly reported as not
         present by the AML and add the INT0002 device ID to the list of
         "always present" devices (Hans de Goede).
    
       - Fix the register information in the xpower PMIC driver and add
         comments to map the registers to symbols used by AML to it (Hans de
         Goede).
    
       - Move the code turning off unused ACPI power resources during system
         resume to a point after all devices have been resumed to avoid
         issues with power resources that do not behave as expected (Hans de
         Goede)"
    
    * tag 'acpi-extra-4.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (22 commits)
      ACPI / power: Delay turning off unused power resources after suspend
      ACPI / PMIC: xpower: Fix power_table addresses
      ACPI / LPSS: Call pwm_add_table() for Bay Trail PWM device
      ACPICA: Update version to 20170303
      ACPICA: iasl: add ASL conversion tool
      ACPICA: Local cache support: Allow small cache objects
      ACPICA: Disassembler: Do not unconditionally remove temporary names
      ACPICA: iasl: Fix IORT SMMU GSI disassembling
      ACPICA: Cleanup AML opcode definitions, no functional change
      ACPICA: Debugger: Add interpreter blocking mark for single-step mode
      ACPICA: debugger: fix memory leak on Pathname
      ACPICA: Update for automatic repair code for objects returned by evaluate_object
      ACPICA: Namespace: fix operand cache leak
      ACPICA: Fix several incorrect invocations of ACPICA return macro
      ACPICA: Fix a module for excessive debug output
      ACPICA: Update some function headers, no funtional change
      ACPICA: Disassembler: Enhance resource descriptor detection
      i2c: designware: Add ACPI HID for Hisilicon Hip07/08 I2C controller
      ACPI / APD: Add clock frequency for Hisilicon Hip07/08 I2C controller
      ACPI / bus: Add INT0002 to list of always-present devices
      ...

commit eed4d47efe9508b855b09754cf6de4325d8a2f0d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Apr 26 23:23:03 2017 +0200

    ACPI / sleep: Ignore spurious SCI wakeups from suspend-to-idle
    
    The ACPI SCI (System Control Interrupt) is set up as a wakeup IRQ
    during suspend-to-idle transitions and, consequently, any events
    signaled through it wake up the system from that state.  However,
    on some systems some of the events signaled via the ACPI SCI while
    suspended to idle should not cause the system to wake up.  In fact,
    quite often they should just be discarded.
    
    Arguably, systems should not resume entirely on such events, but in
    order to decide which events really should cause the system to resume
    and which are spurious, it is necessary to resume up to the point
    when ACPI SCIs are actually handled and processed, which is after
    executing dpm_resume_noirq() in the system resume path.
    
    For this reasons, add a loop around freeze_enter() in which the
    platforms can process events signaled via multiplexed IRQ lines
    like the ACPI SCI and add suspend-to-idle hooks that can be
    used for this purpose to struct platform_freeze_ops.
    
    In the ACPI case, the ->wake hook is used for checking if the SCI
    has triggered while suspended and deferring the interrupt-induced
    system wakeup until the events signaled through it are actually
    processed sufficiently to decide whether or not the system should
    resume.  In turn, the ->sync hook allows all of the relevant event
    queues to be flushed so as to prevent events from being missed due
    to race conditions.
    
    In addition to that, some ACPI code processing wakeup events needs
    to be modified to use the "hard" version of wakeup triggers, so that
    it will cause a system resume to happen on device-induced wakeup
    events even if the "soft" mechanism to prevent the system from
    suspending is not enabled (that also helps to catch device-induced
    wakeup events occurring during suspend transitions in progress).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index a4327af676fe..e84005d642e6 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -662,14 +662,40 @@ static int acpi_freeze_prepare(void)
 	acpi_os_wait_events_complete();
 	if (acpi_sci_irq_valid())
 		enable_irq_wake(acpi_sci_irq);
+
 	return 0;
 }
 
+static void acpi_freeze_wake(void)
+{
+	/*
+	 * If IRQD_WAKEUP_ARMED is not set for the SCI at this point, it means
+	 * that the SCI has triggered while suspended, so cancel the wakeup in
+	 * case it has not been a wakeup event (the GPEs will be checked later).
+	 */
+	if (acpi_sci_irq_valid() &&
+	    !irqd_is_wakeup_armed(irq_get_irq_data(acpi_sci_irq)))
+		pm_system_cancel_wakeup();
+}
+
+static void acpi_freeze_sync(void)
+{
+	/*
+	 * Process all pending events in case there are any wakeup ones.
+	 *
+	 * The EC driver uses the system workqueue, so that one needs to be
+	 * flushed too.
+	 */
+	acpi_os_wait_events_complete();
+	flush_scheduled_work();
+}
+
 static void acpi_freeze_restore(void)
 {
 	acpi_disable_wakeup_devices(ACPI_STATE_S0);
 	if (acpi_sci_irq_valid())
 		disable_irq_wake(acpi_sci_irq);
+
 	acpi_enable_all_runtime_gpes();
 }
 
@@ -681,6 +707,8 @@ static void acpi_freeze_end(void)
 static const struct platform_freeze_ops acpi_freeze_ops = {
 	.begin = acpi_freeze_begin,
 	.prepare = acpi_freeze_prepare,
+	.wake = acpi_freeze_wake,
+	.sync = acpi_freeze_sync,
 	.restore = acpi_freeze_restore,
 	.end = acpi_freeze_end,
 };

commit 8ece1d83346bcc431090d59a2184276192189cdd
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Apr 30 22:54:16 2017 +0200

    ACPI / power: Delay turning off unused power resources after suspend
    
    Commit 660b1113e0f3 (ACPI / PM: Fix consistency check for power resources
    during resume) introduced a check for ACPI power resources which have
    been turned on by the BIOS during suspend and turns these back off again.
    
    This is causing problems on a Dell Venue Pro 11 7130 (i5-4300Y) it causes
    the following messages to show up in dmesg:
    
    [  131.014605] ACPI: Waking up from system sleep state S3
    [  131.150271] acpi LNXPOWER:07: Turning OFF
    [  131.150323] acpi LNXPOWER:06: Turning OFF
    [  131.150911] acpi LNXPOWER:00: Turning OFF
    [  131.169014] ACPI : EC: interrupt unblocked
    [  131.181811] xhci_hcd 0000:00:14.0: System wakeup disabled by ACPI
    [  133.535728] pci_raw_set_power_state: 76 callbacks suppressed
    [  133.535735] iwlwifi 0000:01:00.0: Refused to change power state,
                   currently in D3
    [  133.597672] PM: noirq resume of devices complete after 2428.891 msecs
    
    Followed by a bunch of iwlwifi errors later on and the pcie device
    dropping from the bus (acpiphp thinks it has been unplugged).
    
    Disabling the turning off of unused power resources fixes this. Instead
    of adding a quirk for this system, this commit fixes this by moving the
    disabling of unused power resources to later in the resume sequence
    when the iwlwifi card has been moved out of D3 so the ref_count for
    its power resource no longer is 0.
    
    This new behavior seems to match the intend of the original commit which
    commit-msg says: "(... which means that no devices are going to need them
    any time soon) and we should turn them off".
    
    This also avoids power resources which we need when bringing devices out
    of D3 from getting bounced off and then back on again.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index a4327af676fe..097d630ab886 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -474,6 +474,7 @@ static void acpi_pm_start(u32 acpi_state)
  */
 static void acpi_pm_end(void)
 {
+	acpi_turn_off_unused_power_resources();
 	acpi_scan_lock_release();
 	/*
 	 * This is necessary in case acpi_pm_finish() is not called during a

commit cbc00c1310d34139a63946482b40a6b261a03fb9
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Mon Jan 16 10:55:45 2017 +0800

    ACPI: save NVS memory for Lenovo G50-45
    
    In commit 821d6f0359b0 (ACPI / sleep: Do not save NVS for new machines to
    accelerate S3), to optimize S3 suspend/resume speed, code is introduced
    to ignore NVS memory saving during S3 for all the platforms later than
    2012.
    
    But, Lenovo G50-45, a platform released in 2015, still needs NVS memory
    saving during S3. A quirk is introduced for this platform.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=189431
    Tested-by: Przemek <soprwa@gmail.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    [ rjw: Drop unnecessary code ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 54abb26b7366..a4327af676fe 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -130,6 +130,12 @@ void __init acpi_nvs_nosave_s3(void)
 	nvs_nosave_s3 = true;
 }
 
+static int __init init_nvs_save_s3(const struct dmi_system_id *d)
+{
+	nvs_nosave_s3 = false;
+	return 0;
+}
+
 /*
  * ACPI 1.0 wants us to execute _PTS before suspending devices, so we allow the
  * user to request that behavior by using the 'acpi_old_suspend_ordering'
@@ -324,6 +330,19 @@ static struct dmi_system_id acpisleep_dmi_table[] __initdata = {
 		DMI_MATCH(DMI_PRODUCT_NAME, "K54HR"),
 		},
 	},
+	/*
+	 * https://bugzilla.kernel.org/show_bug.cgi?id=189431
+	 * Lenovo G50-45 is a platform later than 2012, but needs nvs memory
+	 * saving during S3.
+	 */
+	{
+	.callback = init_nvs_save_s3,
+	.ident = "Lenovo G50-45",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "80E3"),
+		},
+	},
 	{},
 };
 

commit ff7e593c9cf3ccceaab7ac600cbd52cb9ff4c57a
Merge: 7a308bb3016f e326ce013a8e 1443ebbacfd7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 27 00:08:59 2017 +0100

    Merge branches 'pm-sleep' and 'pm-cpufreq'
    
    * pm-sleep:
      Revert "PM / sleep / ACPI: Use the ACPI_FADT_LOW_POWER_S0 flag"
    
    * pm-cpufreq:
      cpufreq: intel_pstate: Fix sysfs limits enforcement for performance policy

commit e326ce013a8e851193eb337aafb1aa396c533a61
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 20 03:25:34 2017 +0100

    Revert "PM / sleep / ACPI: Use the ACPI_FADT_LOW_POWER_S0 flag"
    
    Revert commit 08b98d329165 (PM / sleep / ACPI: Use the ACPI_FADT_LOW_POWER_S0
    flag) as it caused system suspend (in the default configuration) to fail
    on Dell XPS13 (9360) with the Kaby Lake processor.
    
    Fixes: 08b98d329165 (PM / sleep / ACPI: Use the ACPI_FADT_LOW_POWER_S0 flag)
    Reported-by: Paul Menzel <pmenzel@molgen.mpg.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index ce1855fd584b..deb0ff78eba8 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -691,14 +691,6 @@ static void acpi_sleep_suspend_setup(void)
 		if (acpi_sleep_state_supported(i))
 			sleep_states[i] = 1;
 
-	/*
-	 * Use suspend-to-idle by default if ACPI_FADT_LOW_POWER_S0 is set and
-	 * the default suspend mode was not selected from the command line.
-	 */
-	if (acpi_gbl_FADT.flags & ACPI_FADT_LOW_POWER_S0 &&
-	    mem_sleep_default > PM_SUSPEND_MEM)
-		mem_sleep_default = PM_SUSPEND_FREEZE;
-
 	suspend_set_ops(old_suspend_ordering ?
 		&acpi_suspend_ops_old : &acpi_suspend_ops);
 	freeze_set_ops(&acpi_freeze_ops);

commit 631ddaba5905c4348c88a62af4367b8e12737533
Merge: b19ad3b9f1fd 9320f95c0b8f bd9089162d80
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Dec 12 20:46:35 2016 +0100

    Merge branches 'pm-sleep' and 'powercap'
    
    * pm-sleep:
      PM / sleep: Print active wakeup sources when blocking on wakeup_count reads
      x86/suspend: fix false positive KASAN warning on suspend/resume
      PM / sleep / ACPI: Use the ACPI_FADT_LOW_POWER_S0 flag
      PM / sleep: System sleep state selection interface rework
      PM / hibernate: Verify the consistent of e820 memory map by md5 digest
    
    * powercap:
      powercap / RAPL: Add Knights Mill CPUID
      powercap/intel_rapl: fix and tidy up error handling
      powercap/intel_rapl: Track active CPUs internally
      powercap/intel_rapl: Cleanup duplicated init code
      powercap/intel rapl: Convert to hotplug state machine
      powercap/intel_rapl: Propagate error code when registration fails
      powercap/intel_rapl: Add missing domain data update on hotplug

commit 7e5c07af8693e72b23aefb70da88b31b30c35b22
Merge: 9c763584b7c8 9713adc2a1a5 effb46b40f80
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 25 22:24:07 2016 +0100

    Merge branches 'acpi-sleep-fixes' and 'acpi-wdat-fixes'
    
    * acpi-sleep-fixes:
      Revert "ACPI: Execute _PTS before system reboot"
    
    * acpi-wdat-fixes:
      watchdog: wdat_wdt: Select WATCHDOG_CORE

commit 08b98d3291652bdcd1029a059e39fbcae5ad93e2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 17 03:28:53 2016 +0100

    PM / sleep / ACPI: Use the ACPI_FADT_LOW_POWER_S0 flag
    
    Modify the ACPI system sleep support setup code to select
    suspend-to-idle as the default system sleep state if the
    ACPI_FADT_LOW_POWER_S0 flag is set in the FADT and the
    default sleep state was not selected from the kernel command
    line.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mario Limonciello <mario.limonciello@dell.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index deb0ff78eba8..ce1855fd584b 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -691,6 +691,14 @@ static void acpi_sleep_suspend_setup(void)
 		if (acpi_sleep_state_supported(i))
 			sleep_states[i] = 1;
 
+	/*
+	 * Use suspend-to-idle by default if ACPI_FADT_LOW_POWER_S0 is set and
+	 * the default suspend mode was not selected from the command line.
+	 */
+	if (acpi_gbl_FADT.flags & ACPI_FADT_LOW_POWER_S0 &&
+	    mem_sleep_default > PM_SUSPEND_MEM)
+		mem_sleep_default = PM_SUSPEND_FREEZE;
+
 	suspend_set_ops(old_suspend_ordering ?
 		&acpi_suspend_ops_old : &acpi_suspend_ops);
 	freeze_set_ops(&acpi_freeze_ops);

commit 9713adc2a1a5488f4889c657a0c0ce0c16056d3c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 21 14:25:49 2016 +0100

    Revert "ACPI: Execute _PTS before system reboot"
    
    Revert commit 2c85025c75df (ACPI: Execute _PTS before system reboot)
    as it is reported to cause poweroff and reboot to hang on Dell
    Latitude E7250.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=187061
    Reported-by:  Gianpaolo <gianpaoloc@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 2b38c1bb0446..7a2e4d45b266 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -47,32 +47,15 @@ static void acpi_sleep_tts_switch(u32 acpi_state)
 	}
 }
 
-static void acpi_sleep_pts_switch(u32 acpi_state)
-{
-	acpi_status status;
-
-	status = acpi_execute_simple_method(NULL, "\\_PTS", acpi_state);
-	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
-		/*
-		 * OS can't evaluate the _PTS object correctly. Some warning
-		 * message will be printed. But it won't break anything.
-		 */
-		printk(KERN_NOTICE "Failure in evaluating _PTS object\n");
-	}
-}
-
-static int sleep_notify_reboot(struct notifier_block *this,
+static int tts_notify_reboot(struct notifier_block *this,
 			unsigned long code, void *x)
 {
 	acpi_sleep_tts_switch(ACPI_STATE_S5);
-
-	acpi_sleep_pts_switch(ACPI_STATE_S5);
-
 	return NOTIFY_DONE;
 }
 
-static struct notifier_block sleep_notifier = {
-	.notifier_call	= sleep_notify_reboot,
+static struct notifier_block tts_notifier = {
+	.notifier_call	= tts_notify_reboot,
 	.next		= NULL,
 	.priority	= 0,
 };
@@ -916,9 +899,9 @@ int __init acpi_sleep_init(void)
 	pr_info(PREFIX "(supports%s)\n", supported);
 
 	/*
-	 * Register the sleep_notifier to reboot notifier list so that the _TTS
-	 * and _PTS object can also be evaluated when the system enters S5.
+	 * Register the tts_notifier to reboot notifier list so that the _TTS
+	 * object can also be evaluated when the system enters S5.
 	 */
-	register_reboot_notifier(&sleep_notifier);
+	register_reboot_notifier(&tts_notifier);
 	return 0;
 }

commit 0137a337d7760c265a7d126964297e41ba9a1cb3
Merge: 0d573c6a0101 cda3b9178510 97cb159fd91d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Oct 2 01:40:07 2016 +0200

    Merge branches 'acpi-wdat' and 'acpi-ec'
    
    * acpi-wdat:
      watchdog: wdat_wdt: Fix warning for using 0 as NULL
      watchdog: wdat_wdt: fix return value check in wdat_wdt_probe()
      platform/x86: intel_pmc_ipc: Do not create iTCO watchdog when WDAT table exists
      i2c: i801: Do not create iTCO watchdog when WDAT table exists
      mfd: lpc_ich: Do not create iTCO watchdog when WDAT table exists
      ACPI / watchdog: Add support for WDAT hardware watchdog
    
    * acpi-ec:
      ACPI / EC: Fix issues related to boot_ec
      ACPI / EC: Fix a gap that ECDT EC cannot handle EC events
      ACPI / EC: Fix a memory leakage issue in acpi_ec_add()
      ACPI / EC: Cleanup first_ec/boot_ec code
      ACPI / EC: Enable event freeze mode to improve event handling for suspend process
      ACPI / EC: Add PM operations to improve event handling for suspend process
      ACPI / EC: Add PM operations to improve event handling for resume process
      ACPI / EC: Fix an issue that SCI_EVT cannot be detected after event is enabled
      ACPI / EC: Add EC_FLAGS_QUERY_ENABLED to reveal a hidden logic
      ACPI / EC: Add PM operations for suspend/resume noirq stage

commit c2b46d679b30c5c0d7eb47a21085943242bdd8dc
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Aug 3 16:01:36 2016 +0800

    ACPI / EC: Add PM operations to improve event handling for resume process
    
    This patch makes 2 changes:
    
    1. Restore old behavior
    Originally, EC driver stops handling both events and transactions in
    acpi_ec_block_transactions(), and restarts to handle transactions in
    acpi_ec_unblock_transactions_early(), restarts to handle both events and
    transactions in acpi_ec_unblock_transactions().
    While currently, EC driver still stops handling both events and
    transactions in acpi_ec_block_transactions(), but restarts to handle both
    events and transactions in acpi_ec_unblock_transactions_early().
    This patch tries to restore the old behavior by dropping
    __acpi_ec_enable_event() from acpi_unblock_transactions_early().
    
    2. Improve old behavior
    However this still cannot fix the real issue as both of the
    acpi_ec_unblock_xxx() functions are invoked in the noirq stage. Since the
    EC driver actually doesn't implement the event handling in the polling
    mode, re-enabling the event handling too early in the noirq stage could
    result in the problem that if there is no triggering source causing
    advance_transaction() to be invoked, pending SCI_EVT cannot be detected by
    the EC driver and _Qxx cannot be triggered.
    It actually makes sense to restart the event handling in any point during
    resuming after the noirq stage. Just like the boot stage where the event
    handling is enabled in .add(), this patch further moves
    acpi_ec_enable_event() to .resume(). After doing that, the following 2
    functions can be combined:
    acpi_ec_unblock_transactions_early()/acpi_ec_unblock_transactions().
    
    The differences of the event handling availability between the old behavior
    (this patch isn't applied) and the new behavior (this patch is applied) are
    as follows:
                            !Applied        Applied
    before suspend          Y               Y
    suspend before EC       Y               Y
    suspend after EC        Y               Y
    suspend_late            Y               Y
    suspend_noirq           Y (actually N)  Y (actually N)
    resume_noirq            Y (actually N)  Y (actually N)
    resume_late             Y (actually N)  Y (actually N)
    resume before EC        Y (actually N)  Y (actually N)
    resume after EC         Y (actually N)  Y
    after resume            Y (actually N)  Y
    Where "actually N" means if there is no triggering source, the EC driver
    is actually not able to notice the pending SCI_EVT occurred in the noirq
    stage. So we can clearly see that this patch has improved the situation.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Tested-by: Todd E Brandt <todd.e.brandt@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 2b38c1bb0446..bb1e0d21f828 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -586,7 +586,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	 */
 	acpi_disable_all_gpes();
 	/* Allow EC transactions to happen. */
-	acpi_ec_unblock_transactions_early();
+	acpi_ec_unblock_transactions();
 
 	suspend_nvs_restore();
 
@@ -784,7 +784,7 @@ static void acpi_hibernation_leave(void)
 	/* Restore the NVS memory area */
 	suspend_nvs_restore();
 	/* Allow EC transactions to happen. */
-	acpi_ec_unblock_transactions_early();
+	acpi_ec_unblock_transactions();
 }
 
 static void acpi_pm_thaw(void)

commit 18864cc4892d207bf8bb81898f5dc7fe9e66d6f0
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Aug 4 16:43:45 2016 +0800

    ACPI / sysfs: Use new GPE masking mechanism in GPE interface
    
    Now GPE can be masked via the new acpi_mask_gpe() API and this patch
    modifies /sys/firmware/acpi/interrupts/gpexx to use this new facility.
    
    Writes "mask/unmask" to this file now invokes acpi_mask_gpe().
    
    Reads from this file now returns new "EN/STS" when the corresponding GPE
    hardware register's EN/STS bits are flagged, and new "masked/unmasked"
    attribute to indicate the status of the masking mechanism.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    [ rjw: Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 2b38c1bb0446..97886634e39f 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -572,7 +572,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 
 		acpi_get_event_status(ACPI_EVENT_POWER_BUTTON, &pwr_btn_status);
 
-		if (pwr_btn_status & ACPI_EVENT_FLAG_SET) {
+		if (pwr_btn_status & ACPI_EVENT_FLAG_STATUS_SET) {
 			acpi_clear_event(ACPI_EVENT_POWER_BUTTON);
 			/* Flag for later */
 			pwr_btn_event_pending = true;

commit 2c85025c75dfe7ddc2bb33363a998dad59383f94
Author: Ocean He <hehy1@lenovo.com>
Date:   Mon Jun 27 14:50:16 2016 +0000

    ACPI: Execute _PTS before system reboot
    
    The _PTS control method is defined in the section 7.4.1 of acpi 6.0
    spec. The _PTS control method is executed by the OS during the sleep
    transition process for S1, S2, S3, S4, and for orderly S5 shutdown.
    
    The _PTS control method provides the BIOS a mechanism for performing
    some housekeeping, such as writing the sleep type value to the embedded
    controller, before entering the system sleeping state. Note that some
    Lenovo Server BIOS use this mechanism to detect reboot event and
    prompt user by popped dialog box.
    
    According to section 7.5 of acpi 6.0 spec, _PTS should run after _TTS.
    Add a _PTS evaulation to the existing _TTS reboot notifier and change
    the notifier name to reflect the fact that it's not for _TTS only any
    more.
    
    Signed-off-by: Ocean He <hehy1@lenovo.com>
    Signed-off-by: Nagananda Chumbalkar <nchumbalkar@lenovo.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 7a2e4d45b266..2b38c1bb0446 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -47,15 +47,32 @@ static void acpi_sleep_tts_switch(u32 acpi_state)
 	}
 }
 
-static int tts_notify_reboot(struct notifier_block *this,
+static void acpi_sleep_pts_switch(u32 acpi_state)
+{
+	acpi_status status;
+
+	status = acpi_execute_simple_method(NULL, "\\_PTS", acpi_state);
+	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
+		/*
+		 * OS can't evaluate the _PTS object correctly. Some warning
+		 * message will be printed. But it won't break anything.
+		 */
+		printk(KERN_NOTICE "Failure in evaluating _PTS object\n");
+	}
+}
+
+static int sleep_notify_reboot(struct notifier_block *this,
 			unsigned long code, void *x)
 {
 	acpi_sleep_tts_switch(ACPI_STATE_S5);
+
+	acpi_sleep_pts_switch(ACPI_STATE_S5);
+
 	return NOTIFY_DONE;
 }
 
-static struct notifier_block tts_notifier = {
-	.notifier_call	= tts_notify_reboot,
+static struct notifier_block sleep_notifier = {
+	.notifier_call	= sleep_notify_reboot,
 	.next		= NULL,
 	.priority	= 0,
 };
@@ -899,9 +916,9 @@ int __init acpi_sleep_init(void)
 	pr_info(PREFIX "(supports%s)\n", supported);
 
 	/*
-	 * Register the tts_notifier to reboot notifier list so that the _TTS
-	 * object can also be evaluated when the system enters S5.
+	 * Register the sleep_notifier to reboot notifier list so that the _TTS
+	 * and _PTS object can also be evaluated when the system enters S5.
 	 */
-	register_reboot_notifier(&tts_notifier);
+	register_reboot_notifier(&sleep_notifier);
 	return 0;
 }

commit 1373718194ebebc43c00d8f117e03885749495b0
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Tue Mar 22 08:51:10 2016 +0800

    ACPI / PM: Introduce efi poweroff for HW-full platforms without _S5
    
    The problem is Linux registers pm_power_off = efi_power_off only if
    we are in hardware reduced mode. Actually, what we also want is to do
    this when ACPI S5 is simply not supported on non-legacy platforms.
    Since some future Intel platforms are HW-full mode where the DSDT
    fails to supply an _S5 object(without SLP_TYP), we should let such
    kind of platform to leverage efi runtime service to poweroff.
    
    This patch uses efi power off as first choice when S5 is unavailable,
    even if there is a customized poweroff(driver provided, eg).
    Meanwhile, the legacy platforms will not be affected because there is
    no path for them to overwrite the pm_power_off to efi power off.
    
    Suggested-by: Len Brown <len.brown@intel.com>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 2a8b59644297..7a2e4d45b266 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -26,6 +26,11 @@
 #include "internal.h"
 #include "sleep.h"
 
+/*
+ * Some HW-full platforms do not have _S5, so they may need
+ * to leverage efi power off for a shutdown.
+ */
+bool acpi_no_s5;
 static u8 sleep_states[ACPI_S_STATE_COUNT];
 
 static void acpi_sleep_tts_switch(u32 acpi_state)
@@ -882,6 +887,8 @@ int __init acpi_sleep_init(void)
 		sleep_states[ACPI_STATE_S5] = 1;
 		pm_power_off_prepare = acpi_power_off_prepare;
 		pm_power_off = acpi_power_off;
+	} else {
+		acpi_no_s5 = true;
 	}
 
 	supported[0] = 0;

commit 3513ac743df4a8522270bde4a20d75a42874487e
Merge: 33068b61f8c0 f447671b9e4f 02113ba93ea4 027b6934aaa3 fbda4b38fa39
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 25 00:58:18 2016 +0100

    Merge branches 'pm-avs', 'pm-clk', 'pm-devfreq' and 'pm-sleep'
    
    * pm-avs:
      PM / AVS: rockchip-io: add io selectors and supplies for rk3399
    
    * pm-clk:
      PM / clk: Add support for obtaining clocks from device-tree
    
    * pm-devfreq:
      PM / devfreq: Spelling s/frequnecy/frequency/
    
    * pm-sleep:
      ACPI / PM: Runtime resume devices when waking from hibernate
      PM / sleep: Clear pm_suspend_global_flags upon hibernate

commit fbda4b38fa3995aa0777fe9cbbdcb223c6292083
Author: Lukas Wunner <lukas@wunner.de>
Date:   Wed Mar 23 00:11:20 2016 +0100

    ACPI / PM: Runtime resume devices when waking from hibernate
    
    Commit 58a1fbbb2ee8 ("PM / PCI / ACPI: Kick devices that might have been
    reset by firmware") added a runtime resume for devices that were runtime
    suspended when the system entered suspend-to-RAM.
    
    Briefly, the motivation was to ensure that devices did not remain in a
    reset-power-on state after resume, potentially preventing deep SoC-wide
    low-power states from being entered on idle.
    
    Currently we're not doing the same when leaving suspend-to-disk and this
    asymmetry is a problem if drivers rely on the automatic resume triggered
    by pm_complete_with_resume_check(). Fix it.
    
    Fixes: 58a1fbbb2ee8 (PM / PCI / ACPI: Kick devices that might have been reset by firmware)
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Cc: 4.4+ <stable@vger.kernel.org> # 4.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 9cb975200cac..f054cadf30d8 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -714,6 +714,7 @@ static int acpi_hibernation_enter(void)
 
 static void acpi_hibernation_leave(void)
 {
+	pm_set_resume_via_firmware();
 	/*
 	 * If ACPI is not enabled by the BIOS and the boot kernel, we need to
 	 * enable it here.

commit 504997cf96fabf67b4768b7a8ca1a1b622abd839
Author: Sudeep Holla <Sudeep.Holla@arm.com>
Date:   Wed Feb 17 12:03:23 2016 +0000

    ACPI / sleep: move acpi_processor_sleep to sleep.c
    
    acpi_processor_sleep is neither related nor used by CPUIdle framework.
    It's used in system suspend/resume path as a syscore operation. It makes
    more sense to move it to acpi/sleep.c where all the S-state transition
    (a.k.a. Linux system suspend/hiberate) related code are present.
    
    Also make it depend on CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT so that
    it's not compiled on architecture like ARM64 where S-states are not
    yet defined in ACPI.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 9cb975200cac..fbfcce3b5227 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -19,6 +19,7 @@
 #include <linux/reboot.h>
 #include <linux/acpi.h>
 #include <linux/module.h>
+#include <linux/syscore_ops.h>
 #include <asm/io.h>
 #include <trace/events/power.h>
 
@@ -677,6 +678,39 @@ static void acpi_sleep_suspend_setup(void)
 static inline void acpi_sleep_suspend_setup(void) {}
 #endif /* !CONFIG_SUSPEND */
 
+#ifdef CONFIG_PM_SLEEP
+static u32 saved_bm_rld;
+
+static int  acpi_save_bm_rld(void)
+{
+	acpi_read_bit_register(ACPI_BITREG_BUS_MASTER_RLD, &saved_bm_rld);
+	return 0;
+}
+
+static void  acpi_restore_bm_rld(void)
+{
+	u32 resumed_bm_rld = 0;
+
+	acpi_read_bit_register(ACPI_BITREG_BUS_MASTER_RLD, &resumed_bm_rld);
+	if (resumed_bm_rld == saved_bm_rld)
+		return;
+
+	acpi_write_bit_register(ACPI_BITREG_BUS_MASTER_RLD, saved_bm_rld);
+}
+
+static struct syscore_ops acpi_sleep_syscore_ops = {
+	.suspend = acpi_save_bm_rld,
+	.resume = acpi_restore_bm_rld,
+};
+
+void acpi_sleep_syscore_init(void)
+{
+	register_syscore_ops(&acpi_sleep_syscore_ops);
+}
+#else
+static inline void acpi_sleep_syscore_init(void) {}
+#endif /* CONFIG_PM_SLEEP */
+
 #ifdef CONFIG_HIBERNATION
 static unsigned long s4_hardware_signature;
 static struct acpi_table_facs *facs;
@@ -839,6 +873,7 @@ int __init acpi_sleep_init(void)
 
 	sleep_states[ACPI_STATE_S0] = 1;
 
+	acpi_sleep_syscore_init();
 	acpi_sleep_suspend_setup();
 	acpi_sleep_hibernate_setup();
 

commit e3e9b577b477edbf50e6c1f93beee89f450f2b68
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jan 4 22:05:20 2016 +0100

    ACPICA: Drop Linux-specific waking vector functions
    
    Commit f06147f9fbf1 (ACPICA: Hardware: Enable firmware waking vector
    for both 32-bit and 64-bit FACS) added three functions that aren't
    present in upstream ACPICA, acpi_hw_set_firmware_waking_vectors(),
    acpi_set_firmware_waking_vectors() and acpi_set_firmware_waking_vector64(),
    to allow Linux to use the previously existing API for setting the
    platform firmware waking vector.
    
    However, that wasn't necessary, since the ACPI sleep support code
    in Linux can be modified to use the upstream ACPICA's API easily
    and the additional functions may be dropped which reduces the code
    size and puts the kernel's ACPICA code more in line with the upstream.
    
    Make the changes as per the above.  While at it, make the relevant
    function desctiption comments reflect the upstream ACPICA's ones.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Lv Zheng <lv.zheng@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 0d94621dc856..9cb975200cac 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -61,7 +61,7 @@ static int acpi_sleep_prepare(u32 acpi_state)
 	if (acpi_state == ACPI_STATE_S3) {
 		if (!acpi_wakeup_address)
 			return -EFAULT;
-		acpi_set_firmware_waking_vector(acpi_wakeup_address);
+		acpi_set_waking_vector(acpi_wakeup_address);
 
 	}
 	ACPI_FLUSH_CPU_CACHE();
@@ -410,7 +410,7 @@ static void acpi_pm_finish(void)
 	acpi_leave_sleep_state(acpi_state);
 
 	/* reset firmware waking vector */
-	acpi_set_firmware_waking_vector((acpi_physical_address) 0);
+	acpi_set_waking_vector(0);
 
 	acpi_target_sleep_state = ACPI_STATE_S0;
 

commit 9bb4064ca3bd771f8df88529a3578f9bb5243911
Merge: 66c44877242d d439e64f22ce
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 2 00:52:19 2015 +0100

    Merge branch 'pm-sleep'
    
    * pm-sleep:
      PM / hibernate: fix a comment typo
      input: i8042: Avoid resetting controller on system suspend/resume
      PM / PCI / ACPI: Kick devices that might have been reset by firmware
      PM / sleep: Add flags to indicate platform firmware involvement
      PM / sleep: Drop pm_request_idle() from pm_generic_complete()
      PCI / PM: Avoid resuming more devices during system suspend
      PM / wakeup: wakeup_source_create: use kstrdup_const
      PM / sleep: Report interrupt that caused system wakeup

commit 8c01275e0cdf1959aa25c322fd5870c097733195
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Sun Oct 25 01:02:46 2015 +0800

    ACPI / PM: Fix incorrect wakeup IRQ setting during suspend-to-idle
    
    For an ACPI compatible system, the SCI (ACPI System Control
    Interrupt) is used to wake the system up from suspend-to-idle.
    Once the CPU is woken up by the SCI, the interrupt handler will
    first check if the current IRQ has been configured for system
    wakeup, so irq_pm_check_wakeup() is invoked to validate the IRQ
    number.  However, during suspend-to-idle, enable_irq_wake() is
    called for acpi_gbl_FADT.sci_interrupt, although the IRQ number
    that the SCI handler has been installed for should be passed to
    it instead.  Thus, if acpi_gbl_FADT.sci_interrupt happens to be
    different from that number, ACPI interrupts will not be able to
    wake up the system from sleep.
    
    Fix this problem by passing the IRQ number returned by
    acpi_gsi_to_irq() to enable_irq_wake() instead of
    acpi_gbl_FADT.sci_interrupt.
    
    Cc: 3.18+ <stable@vger.kernel.org> # 3.18+
    Acked-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 2f0d4db40a9e..3fe1fbec7677 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -632,14 +632,16 @@ static int acpi_freeze_prepare(void)
 	acpi_enable_wakeup_devices(ACPI_STATE_S0);
 	acpi_enable_all_wakeup_gpes();
 	acpi_os_wait_events_complete();
-	enable_irq_wake(acpi_gbl_FADT.sci_interrupt);
+	if (acpi_sci_irq_valid())
+		enable_irq_wake(acpi_sci_irq);
 	return 0;
 }
 
 static void acpi_freeze_restore(void)
 {
 	acpi_disable_wakeup_devices(ACPI_STATE_S0);
-	disable_irq_wake(acpi_gbl_FADT.sci_interrupt);
+	if (acpi_sci_irq_valid())
+		disable_irq_wake(acpi_sci_irq);
 	acpi_enable_all_runtime_gpes();
 }
 

commit ef25ba0476015908ef5960f9faac149ddf34ede0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 7 00:49:34 2015 +0200

    PM / sleep: Add flags to indicate platform firmware involvement
    
    There are quite a few cases in which device drivers, bus types or
    even the PM core itself may benefit from knowing whether or not
    the platform firmware will be involved in the upcoming system power
    transition (during system suspend) or whether or not it was involved
    in it (during system resume).
    
    For this reason, introduce global system suspend flags that can be
    used by the platform code to expose that information for the benefit
    of the other parts of the kernel and make the ACPI core set them
    as appropriate.
    
    Users of the new flags will be added later.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 2f0d4db40a9e..a0b4d781e606 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -487,6 +487,8 @@ static int acpi_suspend_begin(suspend_state_t pm_state)
 		pr_err("ACPI does not support sleep state S%u\n", acpi_state);
 		return -ENOSYS;
 	}
+	if (acpi_state > ACPI_STATE_S1)
+		pm_set_suspend_via_firmware();
 
 	acpi_pm_start(acpi_state);
 	return 0;
@@ -522,6 +524,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 		if (error)
 			return error;
 		pr_info(PREFIX "Low-level resume complete\n");
+		pm_set_resume_via_firmware();
 		break;
 	}
 	trace_suspend_resume(TPS("acpi_suspend"), acpi_state, false);

commit 7b02ccea2e70e5e3e9fccf36123b77240323b8d6
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Fri Mar 27 18:08:48 2015 +0800

    ACPI / PM: Enable all wakeup GPEs in suspend-to-idle
    
    Currently, in suspend-to-idle, wakeup GPE for PCI devices are
    handled properly because acpi_pci_sleep_wake() invokes acpi_enable_gpe()
    to enable the wakeup GPE directly. But for the other wakeup-capable
    devices in ACPI bus, acpi_enable_wakeup_devices() should be invoked
    to update enable_for_wake mask in gpe_register_info structure, thus
    acpi_enable_all_wakeup_gpes() can enable the wakeup GPE referred in
    _PRW methods. And acpi_disable_wakeup_devices() will be called
    before disable_irq_wake() in acpi_freeze_restore() to restore the mask.
    
    This patch fixes a power button wakeup problem on Surface Pro 3,
    on which platform power button uses EC to deliver event
    (EC GPE is referred in _PRW).
    
    Note: enabling EC GPE during freeze state may bring some risks
    because EC events are expected to fire more frequently than others.
    Thus it may bring the system out of freeze state unnecessarily.
    (We already have comments about this in bugzilla)
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=84651
    Reported-and-tested-by: Ethan Schoonover <es@ethanschoonover.com>
    Tested-by: Peter Amidon <psa.pub.0@picnicpark.org>
    Tested-by: Yani Ioadnnou <yani.ioannou@gmail.com>
    Tested-by: Mister Wardrop <mister.wardrop@gmail.com>
    Tested-by: Anton Anikin <anton@anikin.name>
    Tested-by: Keith McClelland <zismylaptop@gmail.com>
    Reviewed-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 24a830b39ec3..2f0d4db40a9e 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -629,6 +629,7 @@ static int acpi_freeze_begin(void)
 
 static int acpi_freeze_prepare(void)
 {
+	acpi_enable_wakeup_devices(ACPI_STATE_S0);
 	acpi_enable_all_wakeup_gpes();
 	acpi_os_wait_events_complete();
 	enable_irq_wake(acpi_gbl_FADT.sci_interrupt);
@@ -637,6 +638,7 @@ static int acpi_freeze_prepare(void)
 
 static void acpi_freeze_restore(void)
 {
+	acpi_disable_wakeup_devices(ACPI_STATE_S0);
 	disable_irq_wake(acpi_gbl_FADT.sci_interrupt);
 	acpi_enable_all_runtime_gpes();
 }

commit b8ee29786f6c0a887a65240fe0289b7ffc227a55
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Mar 17 15:29:23 2015 +0100

    ACPI / sleep: Drop acpi_suspend() which is not used
    
    The acpi_suspend() function has no callers, so drop it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 7f251dd1a687..24a830b39ec3 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -806,21 +806,6 @@ static void acpi_sleep_hibernate_setup(void)
 static inline void acpi_sleep_hibernate_setup(void) {}
 #endif /* !CONFIG_HIBERNATION */
 
-int acpi_suspend(u32 acpi_state)
-{
-	suspend_state_t states[] = {
-		[1] = PM_SUSPEND_STANDBY,
-		[3] = PM_SUSPEND_MEM,
-		[5] = PM_SUSPEND_MAX
-	};
-
-	if (acpi_state < 6 && states[acpi_state])
-		return pm_suspend(states[acpi_state]);
-	if (acpi_state == 4)
-		return hibernate();
-	return -EINVAL;
-}
-
 static void acpi_power_off_prepare(void)
 {
 	/* Prepare to power off the system */

commit 8b691c9cf297bc32a021b7fef0dd0e32f130e542
Author: Jan Beulich <JBeulich@suse.com>
Date:   Fri Jan 23 08:12:06 2015 +0000

    ACPI / sleep: mark acpi_sleep_dmi_check() __init
    
    This makes a difference if the compiler decides not to inline the
    function, as then the function's reference to acpisleep_dmi_table[]
    yields a section mismatch warning.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 8aa9254a387f..7f251dd1a687 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -321,7 +321,7 @@ static struct dmi_system_id acpisleep_dmi_table[] __initdata = {
 	{},
 };
 
-static void acpi_sleep_dmi_check(void)
+static void __init acpi_sleep_dmi_check(void)
 {
 	int year;
 

commit c52fa70c79acbb1d4868fee244a638d6ee6f5aab
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Dec 1 23:51:13 2014 +0100

    ACPI / sleep: Drain outstanding events after disabling multiple GPEs
    
    After multiple GPEs have been disabled at the low level in one go,
    like when acpi_disable_all_gpes() is called, we should always drain
    all of the outstanding events from them, or interesting races become
    possible.
    
    For this reason, call acpi_os_wait_events_complete() after
    acpi_enable_all_wakeup_gpes() and acpi_disable_all_gpes() in
    acpi_freeze_prepare() and acpi_power_off_prepare(), respectively.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 05a31b573fc3..8aa9254a387f 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -630,6 +630,7 @@ static int acpi_freeze_begin(void)
 static int acpi_freeze_prepare(void)
 {
 	acpi_enable_all_wakeup_gpes();
+	acpi_os_wait_events_complete();
 	enable_irq_wake(acpi_gbl_FADT.sci_interrupt);
 	return 0;
 }
@@ -825,6 +826,7 @@ static void acpi_power_off_prepare(void)
 	/* Prepare to power off the system */
 	acpi_sleep_prepare(ACPI_STATE_S5);
 	acpi_disable_all_gpes();
+	acpi_os_wait_events_complete();
 }
 
 static void acpi_power_off(void)

commit a8d46b9e4e487301affe84fa53de40b890898604
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 30 02:29:01 2014 +0200

    ACPI / sleep: Rework the handling of ACPI GPE wakeup from suspend-to-idle
    
    The ACPI GPE wakeup from suspend-to-idle is currently based on using
    the IRQF_NO_SUSPEND flag for the ACPI SCI, but that is problematic
    for a couple of reasons.  First, in principle the ACPI SCI may be
    shared and IRQF_NO_SUSPEND does not really work well with shared
    interrupts.  Second, it may require the ACPI subsystem to special-case
    the handling of device notifications depending on whether or not
    they are received during suspend-to-idle in some places which would
    lead to fragile code.  Finally, it's better the handle ACPI wakeup
    interrupts consistently with wakeup interrupts from other sources.
    
    For this reason, remove the IRQF_NO_SUSPEND flag from the ACPI SCI
    and use enable_irq_wake()/disable_irq_wake() with it instead, which
    requires two additional platform hooks to be added to struct
    platform_freeze_ops.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 54da4a3fe65e..05a31b573fc3 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -14,6 +14,7 @@
 #include <linux/irq.h>
 #include <linux/dmi.h>
 #include <linux/device.h>
+#include <linux/interrupt.h>
 #include <linux/suspend.h>
 #include <linux/reboot.h>
 #include <linux/acpi.h>
@@ -626,6 +627,19 @@ static int acpi_freeze_begin(void)
 	return 0;
 }
 
+static int acpi_freeze_prepare(void)
+{
+	acpi_enable_all_wakeup_gpes();
+	enable_irq_wake(acpi_gbl_FADT.sci_interrupt);
+	return 0;
+}
+
+static void acpi_freeze_restore(void)
+{
+	disable_irq_wake(acpi_gbl_FADT.sci_interrupt);
+	acpi_enable_all_runtime_gpes();
+}
+
 static void acpi_freeze_end(void)
 {
 	acpi_scan_lock_release();
@@ -633,6 +647,8 @@ static void acpi_freeze_end(void)
 
 static const struct platform_freeze_ops acpi_freeze_ops = {
 	.begin = acpi_freeze_begin,
+	.prepare = acpi_freeze_prepare,
+	.restore = acpi_freeze_restore,
 	.end = acpi_freeze_end,
 };
 

commit 821d6f0359b0614792ab8e2fb93b503e25a65079
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Jul 23 14:42:33 2014 +0800

    ACPI / sleep: Do not save NVS for new machines to accelerate S3
    
    NVS region is saved and restored unconditionally for machines without
    nvs_nosave quirk during S3. Tested some new machines and the operation
    is not necessary. Saving NVS region also affects S2RAM speed. The time of
    NVS saving and restoring depends on the size of NVS region and it consumes
    7~10ms normally.
    
    This patch is to make machines produced from 2012 to now not saving NVS region
    to accelerate S3.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index b3e3cc73ba79..54da4a3fe65e 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -322,6 +322,11 @@ static struct dmi_system_id acpisleep_dmi_table[] __initdata = {
 
 static void acpi_sleep_dmi_check(void)
 {
+	int year;
+
+	if (dmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL) && year >= 2012)
+		acpi_nvs_nosave_s3();
+
 	dmi_check_system(acpisleep_dmi_table);
 }
 

commit bb3632c6101b2fad07e6246721466b984b1e0e9d
Author: Todd E Brandt <todd.e.brandt@linux.intel.com>
Date:   Fri Jun 6 05:40:17 2014 -0700

    PM / sleep: trace events for suspend/resume
    
    Adds trace events that give finer resolution into suspend/resume. These
    events are graphed in the timelines generated by the analyze_suspend.py
    script. They represent large areas of time consumed that are typical to
    suspend and resume.
    
    The event is triggered by calling the function "trace_suspend_resume"
    with three arguments: a string (the name of the event to be displayed
    in the timeline), an integer (case specific number, such as the power
    state or cpu number), and a boolean (where true is used to denote the start
    of the timeline event, and false to denote the end).
    
    The suspend_resume trace event reproduces the data that the machine_suspend
    trace event did, so the latter has been removed.
    
    Signed-off-by: Todd Brandt <todd.e.brandt@intel.com>
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index c11e3795431b..b3e3cc73ba79 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -19,6 +19,7 @@
 #include <linux/acpi.h>
 #include <linux/module.h>
 #include <asm/io.h>
+#include <trace/events/power.h>
 
 #include "internal.h"
 #include "sleep.h"
@@ -501,6 +502,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 
 	ACPI_FLUSH_CPU_CACHE();
 
+	trace_suspend_resume(TPS("acpi_suspend"), acpi_state, true);
 	switch (acpi_state) {
 	case ACPI_STATE_S1:
 		barrier();
@@ -516,6 +518,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 		pr_info(PREFIX "Low-level resume complete\n");
 		break;
 	}
+	trace_suspend_resume(TPS("acpi_suspend"), acpi_state, false);
 
 	/* This violates the spec but is required for bug compatibility. */
 	acpi_write_bit_register(ACPI_BITREG_SCI_ENABLE, 1);

commit 1f0b63866fc1be700260547be8edf8e6f0af37f2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 15 23:29:57 2014 +0200

    ACPI / PM: Hold ACPI scan lock over the "freeze" sleep state
    
    The "freeze" sleep state suffers from the same issue that was
    addressed by commit ad07277e82de (ACPI / PM: Hold acpi_scan_lock over
    system PM transitions) for ACPI sleep states, that is, things break
    if ->remove() is called for devices whose system resume callbacks
    haven't been executed yet.
    
    It also can be addressed in the same way, by holding the ACPI scan
    lock over the "freeze" sleep state and PM transitions to and from
    that state, but ->begin() and ->end() platform operations for the
    "freeze" sleep state are needed for this purpose.
    
    This change has been tested on Acer Aspire S5 with Thunderbolt.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 2281ca31c1bc..c11e3795431b 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -612,6 +612,22 @@ static const struct platform_suspend_ops acpi_suspend_ops_old = {
 	.recover = acpi_pm_finish,
 };
 
+static int acpi_freeze_begin(void)
+{
+	acpi_scan_lock_acquire();
+	return 0;
+}
+
+static void acpi_freeze_end(void)
+{
+	acpi_scan_lock_release();
+}
+
+static const struct platform_freeze_ops acpi_freeze_ops = {
+	.begin = acpi_freeze_begin,
+	.end = acpi_freeze_end,
+};
+
 static void acpi_sleep_suspend_setup(void)
 {
 	int i;
@@ -622,7 +638,9 @@ static void acpi_sleep_suspend_setup(void)
 
 	suspend_set_ops(old_suspend_ordering ?
 		&acpi_suspend_ops_old : &acpi_suspend_ops);
+	freeze_set_ops(&acpi_freeze_ops);
 }
+
 #else /* !CONFIG_SUSPEND */
 static inline void acpi_sleep_suspend_setup(void) {}
 #endif /* !CONFIG_SUSPEND */

commit fad16dd9c962229c5965ec6f5cd5f48180f94fd4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 8 23:22:15 2014 +0200

    ACPI / PM: Export acpi_target_system_state() to modules
    
    Export the acpi_target_system_state() function to modules so that
    modular drivers can use it to check what the target ACPI sleep state
    of the system is (that is needed for i915 mostly at this point).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index c40fb2e81bbc..2281ca31c1bc 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -89,6 +89,7 @@ u32 acpi_target_system_state(void)
 {
 	return acpi_target_sleep_state;
 }
+EXPORT_SYMBOL_GPL(acpi_target_system_state);
 
 static bool pwr_btn_event_pending;
 

commit a4e90bed511220ff601d064c9e5d583e91308f65
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Mar 13 22:11:39 2014 +0100

    ACPI / sleep: Add extra checks for HW Reduced ACPI mode sleep states
    
    If the HW Reduced ACPI mode bit is set in the FADT, ACPICA uses
    the optional sleep control and sleep status registers for making
    the system enter sleep states (including S5), so it is not possible
    to use system sleep states or power it off using ACPI if the HW
    Reduced ACPI mode bit is set and those registers are not available.
    
    For this reason, add a new function, acpi_sleep_state_supported(),
    checking if the HW Reduced ACPI mode bit is set and whether or not
    system sleep states are usable in that case in addition to checking
    the return value of acpi_get_sleep_type_data() and make the ACPI
    sleep setup routines use that function to check the availability of
    system sleep states.
    
    Among other things, this prevents the kernel from attempting to
    use ACPI for powering off HW Reduced ACPI systems without the sleep
    control and sleep status registers, because ACPI power off doesn't
    have a chance to work on them.  That allows alternative power off
    mechanisms that may actually work to be used on those systems.  The
    affected machines include Dell Venue 8 Pro, Asus T100TA, Haswell
    Desktop SDP and Ivy Bridge EP Demo depot.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=70931
    Reported-by: Adam Williamson <awilliam@redhat.com>
    Tested-by: Aubrey Li <aubrey.li@linux.intel.com>
    Cc: 3.4+ <stable@vger.kernel.org> # 3.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index b718806657cd..c40fb2e81bbc 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -71,6 +71,17 @@ static int acpi_sleep_prepare(u32 acpi_state)
 	return 0;
 }
 
+static bool acpi_sleep_state_supported(u8 sleep_state)
+{
+	acpi_status status;
+	u8 type_a, type_b;
+
+	status = acpi_get_sleep_type_data(sleep_state, &type_a, &type_b);
+	return ACPI_SUCCESS(status) && (!acpi_gbl_reduced_hardware
+		|| (acpi_gbl_FADT.sleep_control.address
+			&& acpi_gbl_FADT.sleep_status.address));
+}
+
 #ifdef CONFIG_ACPI_SLEEP
 static u32 acpi_target_sleep_state = ACPI_STATE_S0;
 
@@ -604,15 +615,9 @@ static void acpi_sleep_suspend_setup(void)
 {
 	int i;
 
-	for (i = ACPI_STATE_S1; i < ACPI_STATE_S4; i++) {
-		acpi_status status;
-		u8 type_a, type_b;
-
-		status = acpi_get_sleep_type_data(i, &type_a, &type_b);
-		if (ACPI_SUCCESS(status)) {
+	for (i = ACPI_STATE_S1; i < ACPI_STATE_S4; i++)
+		if (acpi_sleep_state_supported(i))
 			sleep_states[i] = 1;
-		}
-	}
 
 	suspend_set_ops(old_suspend_ordering ?
 		&acpi_suspend_ops_old : &acpi_suspend_ops);
@@ -740,11 +745,7 @@ static const struct platform_hibernation_ops acpi_hibernation_ops_old = {
 
 static void acpi_sleep_hibernate_setup(void)
 {
-	acpi_status status;
-	u8 type_a, type_b;
-
-	status = acpi_get_sleep_type_data(ACPI_STATE_S4, &type_a, &type_b);
-	if (ACPI_FAILURE(status))
+	if (!acpi_sleep_state_supported(ACPI_STATE_S4))
 		return;
 
 	hibernation_set_ops(old_suspend_ordering ?
@@ -793,8 +794,6 @@ static void acpi_power_off(void)
 
 int __init acpi_sleep_init(void)
 {
-	acpi_status status;
-	u8 type_a, type_b;
 	char supported[ACPI_S_STATE_COUNT * 3 + 1];
 	char *pos = supported;
 	int i;
@@ -806,8 +805,7 @@ int __init acpi_sleep_init(void)
 	acpi_sleep_suspend_setup();
 	acpi_sleep_hibernate_setup();
 
-	status = acpi_get_sleep_type_data(ACPI_STATE_S5, &type_a, &type_b);
-	if (ACPI_SUCCESS(status)) {
+	if (acpi_sleep_state_supported(ACPI_STATE_S5)) {
 		sleep_states[ACPI_STATE_S5] = 1;
 		pm_power_off_prepare = acpi_power_off_prepare;
 		pm_power_off = acpi_power_off;

commit 4c7b70406e5aadc1c78db4d375d5744df65c5b58
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Mar 9 18:30:50 2014 +0100

    Revert "ACPI / sleep: pm_power_off needs more sanity checks to be installed"
    
    Revert commit 3130497f5bab ("ACPI / sleep: pm_power_off needs more
    sanity checks to be installed") that breaks power ACPI power off on a
    lot of systems, because it checks wrong registers.
    
    Fixes: 3130497f5bab ("ACPI / sleep: pm_power_off needs more sanity checks to be installed")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index b0f6c4a2a119..b718806657cd 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -807,12 +807,7 @@ int __init acpi_sleep_init(void)
 	acpi_sleep_hibernate_setup();
 
 	status = acpi_get_sleep_type_data(ACPI_STATE_S5, &type_a, &type_b);
-	/*
-	 * Check both ACPI S5 object and ACPI sleep registers to
-	 * install pm_power_off_prepare/pm_power_off hook
-	 */
-	if (ACPI_SUCCESS(status) && acpi_gbl_FADT.sleep_control.address
-	    && acpi_gbl_FADT.sleep_status.address) {
+	if (ACPI_SUCCESS(status)) {
 		sleep_states[ACPI_STATE_S5] = 1;
 		pm_power_off_prepare = acpi_power_off_prepare;
 		pm_power_off = acpi_power_off;

commit 3130497f5babd42b24a7febda46b46116e0adc83
Author: Li, Aubrey <aubrey.li@linux.intel.com>
Date:   Sun Mar 2 08:53:57 2014 +0800

    ACPI / sleep: pm_power_off needs more sanity checks to be installed
    
    Sleep control and status registers need santity checks as well before
    ACPI installs acpi_power_off to pm_power_off hook. The checking code in
    acpi_enter_sleep_state() is too late, we should not allow a not-working
    pm_power_off function to be hooked up.
    
    Signed-off-by: Aubrey Li <aubrey.li@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index b718806657cd..b0f6c4a2a119 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -807,7 +807,12 @@ int __init acpi_sleep_init(void)
 	acpi_sleep_hibernate_setup();
 
 	status = acpi_get_sleep_type_data(ACPI_STATE_S5, &type_a, &type_b);
-	if (ACPI_SUCCESS(status)) {
+	/*
+	 * Check both ACPI S5 object and ACPI sleep registers to
+	 * install pm_power_off_prepare/pm_power_off hook
+	 */
+	if (ACPI_SUCCESS(status) && acpi_gbl_FADT.sleep_control.address
+	    && acpi_gbl_FADT.sleep_status.address) {
 		sleep_states[ACPI_STATE_S5] = 1;
 		pm_power_off_prepare = acpi_power_off_prepare;
 		pm_power_off = acpi_power_off;

commit bcc7201a91176f815f48f8ad889a20c5c829d9a9
Merge: fbb9c10d40f8 42b946bb35ef 2d4054d84224 ec9c9c2ec1d1 b981513f806d 5c551e624abb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 12 23:46:55 2014 +0100

    Merge branches 'acpi-gpe', 'acpi-video', 'acpi-thermal', 'acpi-processor', 'acpi-sleep'
    
    * acpi-gpe:
      ACPI / EC: disable GPE before removing GPE handler
      ACPI / Button: Fix enabling button GPEs twice
    
    * acpi-video:
      ACPI: Blacklist Win8 OSI for some HP laptop 2013 models
      ACPI / video: Fix typo in video_detect.c
    
    * acpi-thermal:
      ACPI / thermal: remove const from thermal_zone_device_ops declaration
    
    * acpi-processor:
      ACPI / scan: bail out early if failed to parse APIC ID for CPU
    
    * acpi-sleep:
      ACPI / sleep: remove panic in case hardware has changed after S4

commit 98feb7cc61c50fe0fa36eeb994d5db527ca9e103
Merge: 7e22e91102c6 f8a571b2a128
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 12 23:44:09 2014 +0100

    Merge branch 'acpi-cleanup'
    
    * acpi-cleanup: (22 commits)
      ACPI / tables: Return proper error codes from acpi_table_parse() and fix comment.
      ACPI / tables: Check if id is NULL in acpi_table_parse()
      ACPI / proc: Include appropriate header file in proc.c
      ACPI / EC: Remove unused functions and add prototype declaration in internal.h
      ACPI / dock: Include appropriate header file in dock.c
      ACPI / PCI: Include appropriate header file in pci_link.c
      ACPI / PCI: Include appropriate header file in pci_slot.c
      ACPI / EC: Mark the function acpi_ec_add_debugfs() as static in ec_sys.c
      ACPI / NVS: Include appropriate header file in nvs.c
      ACPI / OSL: Mark the function acpi_table_checksum() as static
      ACPI / processor: initialize a variable to silence compiler warning
      ACPI / processor: use ACPI_COMPANION() to get ACPI device
      ACPI: correct minor typos
      ACPI / sleep: Drop redundant acpi_disabled check
      ACPI / dock: Drop redundant acpi_disabled check
      ACPI / table: Replace '1' with specific error return values
      ACPI: remove trailing whitespace
      ACPI / IBFT: Fix incorrect <acpi/acpi.h> inclusion in iSCSI boot firmware module
      ACPI / i915: Fix incorrect <acpi/acpi.h> inclusions via <linux/acpi_io.h>
      SFI / ACPI: Fix warnings reported during builds with W=1
      ...
    
    Conflicts:
            drivers/acpi/nvs.c
            drivers/hwmon/asus_atk0110.c

commit 5c551e624abba6782034edd5b9eb58ac6f146b38
Author: Oliver Neukum <oneukum@suse.de>
Date:   Fri Jan 10 10:51:53 2014 +0100

    ACPI / sleep: remove panic in case hardware has changed after S4
    
    Some BIOSes change hardware based on the state of
    a laptop's lid. If the lid is closed, the touchpad is
    disabled and the checksum changes. Windows 8 no longer
    aborts resume if the checksum has changed.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    [rjw: Use pr_crit() for the message and don't break the string]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 721e949e606e..32f7dee2f16b 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -670,11 +670,8 @@ static void acpi_hibernation_leave(void)
 	/* Reprogram control registers */
 	acpi_leave_sleep_state_prep(ACPI_STATE_S4);
 	/* Check the hardware signature */
-	if (facs && s4_hardware_signature != facs->hardware_signature) {
-		printk(KERN_EMERG "ACPI: Hardware changed while hibernated, "
-			"cannot resume!\n");
-		panic("ACPI S4 hardware signature mismatch");
-	}
+	if (facs && s4_hardware_signature != facs->hardware_signature)
+		pr_crit("ACPI: Hardware changed while hibernated, success doubtful!\n");
 	/* Restore the NVS memory area */
 	suspend_nvs_restore();
 	/* Allow EC transactions to happen. */

commit 100eb0b04293fbb7af689ff7ddfe8fc8a46ab65c
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Fri Dec 6 00:03:41 2013 +0800

    ACPI / sleep: Drop redundant acpi_disabled check
    
    acpi_sleep_init() is only called from acpi_bus_init() and the
    code logic shows that it doesn't need to check acpi_disabled:
    
    acpi_init();
            if (acpi_disabled) return;
            acpi_bus_init();
                    acpi_sleep_init();
                            if (acpi_disabled)
                                    return 0;
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    [rjw: Subject and changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index ea9cc373ffd8..cb889c715e14 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -802,9 +802,6 @@ int __init acpi_sleep_init(void)
 	char *pos = supported;
 	int i;
 
-	if (acpi_disabled)
-		return 0;
-
 	acpi_sleep_dmi_check();
 
 	sleep_states[ACPI_STATE_S0] = 1;

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 14df30580e15..ea9cc373ffd8 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -18,12 +18,8 @@
 #include <linux/reboot.h>
 #include <linux/acpi.h>
 #include <linux/module.h>
-
 #include <asm/io.h>
 
-#include <acpi/acpi_bus.h>
-#include <acpi/acpi_drivers.h>
-
 #include "internal.h"
 #include "sleep.h"
 

commit 51468a9d3a80249a218a854100c6d5d0eb8b781e
Author: Al Stone <al.stone@linaro.org>
Date:   Wed Nov 20 15:45:51 2013 -0700

    ACPI / sleep: clean up compiler warning about uninitialized field
    
    Initialize pwr_btn_status as disabled which (a) makes sure it is
    in a proper state to start, and (b) cleans up a compiler warning
    about an uninitialized variable.
    
    Signed-off-by: Al Stone <al.stone@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 14df30580e15..721e949e606e 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -525,7 +525,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	 * generate wakeup events.
 	 */
 	if (ACPI_SUCCESS(status) && (acpi_state == ACPI_STATE_S3)) {
-		acpi_event_status pwr_btn_status;
+		acpi_event_status pwr_btn_status = ACPI_EVENT_FLAG_DISABLED;
 
 		acpi_get_event_status(ACPI_EVENT_POWER_BUTTON, &pwr_btn_status);
 

commit 0c581415b522267138d807814e526aa7534b9a61
Merge: afdca01c9821 7702ae0dd9b4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 27 01:29:04 2013 +0200

    Merge branch 'acpi-assorted'
    
    * acpi-assorted:
      ACPI / osl: Kill macro INVALID_TABLE().
      earlycpio.c: Fix the confusing comment of find_cpio_data().
      ACPI / x86: Print Hot-Pluggable Field in SRAT.
      ACPI / thermal: Use THERMAL_TRIPS_NONE macro to replace number
      ACPI / thermal: Remove unused macros in the driver/acpi/thermal.c
      ACPI / thermal: Remove the unused lock of struct acpi_thermal
      ACPI / osl: Fix osi_setup_entries[] __initdata attribute location
      ACPI / numa: Fix __init attribute location in slit_valid()
      ACPI / dock: Fix __init attribute location in find_dock_and_bay()
      ACPI / Sleep: Fix incorrect placement of __initdata
      ACPI / processor: Fix incorrect placement of __initdata
      ACPI / EC: Fix incorrect placement of __initdata
      ACPI / scan: Drop unnecessary label from acpi_create_platform_device()
      ACPI: Move acpi_bus_get_device() from bus.c to scan.c
      ACPI / scan: Allow platform device creation without any IO resources
      ACPI: Cleanup sparse warning on acpi_os_initialize1()
      platform / thinkpad: Remove deprecated hotkey_report_mode parameter
      ACPI: Remove the old /proc/acpi/event interface

commit ad07277e82dedabacc52c82746633680a3187d25
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 20 01:42:32 2013 +0200

    ACPI / PM: Hold acpi_scan_lock over system PM transitions
    
    Bad things happen if ACPI hotplug events are handled during system
    PM transitions, especially if devices are removed as a result.
    To prevent those bad things from happening, acquire acpi_scan_lock
    when a PM transition is started and release it when that transition
    is complete or has been aborted.
    
    This fixes resume lockup on my test-bed Acer Aspire S5 that happens
    when Thunderbolt devices are disconnected from the machine while
    suspended.
    
    Also fixes the analogous problem for Mika Westerberg on an
    Intel DZ77RE-75K board.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 81b0f03d97db..1dec53decffa 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -420,10 +420,21 @@ static void acpi_pm_finish(void)
 }
 
 /**
- *	acpi_pm_end - Finish up suspend sequence.
+ * acpi_pm_start - Start system PM transition.
+ */
+static void acpi_pm_start(u32 acpi_state)
+{
+	acpi_target_sleep_state = acpi_state;
+	acpi_sleep_tts_switch(acpi_target_sleep_state);
+	acpi_scan_lock_acquire();
+}
+
+/**
+ * acpi_pm_end - Finish up system PM transition.
  */
 static void acpi_pm_end(void)
 {
+	acpi_scan_lock_release();
 	/*
 	 * This is necessary in case acpi_pm_finish() is not called during a
 	 * failing transition to a sleep state.
@@ -451,21 +462,19 @@ static u32 acpi_suspend_states[] = {
 static int acpi_suspend_begin(suspend_state_t pm_state)
 {
 	u32 acpi_state = acpi_suspend_states[pm_state];
-	int error = 0;
+	int error;
 
 	error = (nvs_nosave || nvs_nosave_s3) ? 0 : suspend_nvs_alloc();
 	if (error)
 		return error;
 
-	if (sleep_states[acpi_state]) {
-		acpi_target_sleep_state = acpi_state;
-		acpi_sleep_tts_switch(acpi_target_sleep_state);
-	} else {
-		printk(KERN_ERR "ACPI does not support this state: %d\n",
-			pm_state);
-		error = -ENOSYS;
+	if (!sleep_states[acpi_state]) {
+		pr_err("ACPI does not support sleep state S%u\n", acpi_state);
+		return -ENOSYS;
 	}
-	return error;
+
+	acpi_pm_start(acpi_state);
+	return 0;
 }
 
 /**
@@ -631,10 +640,8 @@ static int acpi_hibernation_begin(void)
 	int error;
 
 	error = nvs_nosave ? 0 : suspend_nvs_alloc();
-	if (!error) {
-		acpi_target_sleep_state = ACPI_STATE_S4;
-		acpi_sleep_tts_switch(acpi_target_sleep_state);
-	}
+	if (!error)
+		acpi_pm_start(ACPI_STATE_S4);
 
 	return error;
 }
@@ -713,8 +720,10 @@ static int acpi_hibernation_begin_old(void)
 	if (!error) {
 		if (!nvs_nosave)
 			error = suspend_nvs_alloc();
-		if (!error)
+		if (!error) {
 			acpi_target_sleep_state = ACPI_STATE_S4;
+			acpi_scan_lock_acquire();
+		}
 	}
 	return error;
 }

commit 3e4376ffcec8e51091bd8ea54da8323e7b912971
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Wed Aug 7 17:16:57 2013 +0530

    ACPI / Sleep: Fix incorrect placement of __initdata
    
    __initdata should be placed between the variable name and equal
    sign for the variable to be placed in the intended section.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 187ab61889e6..72554fd31044 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -141,7 +141,7 @@ static int __init init_nvs_nosave(const struct dmi_system_id *d)
 	return 0;
 }
 
-static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
+static struct dmi_system_id acpisleep_dmi_table[] __initdata = {
 	{
 	.callback = init_old_suspend_ordering,
 	.ident = "Abit KN9 (nForce4 variant)",

commit 0db98202605c3d32e023d43c30b5bd878f520976
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Sat Jun 29 00:24:39 2013 +0800

    ACPI: introduce helper function acpi_execute_simple_method()
    
    Introduce helper function acpi_execute_simple_method() and use it in
    a number of places to simplify code.
    
    [rjw: Changelog]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 187ab61889e6..81b0f03d97db 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -31,12 +31,9 @@ static u8 sleep_states[ACPI_S_STATE_COUNT];
 
 static void acpi_sleep_tts_switch(u32 acpi_state)
 {
-	union acpi_object in_arg = { ACPI_TYPE_INTEGER };
-	struct acpi_object_list arg_list = { 1, &in_arg };
-	acpi_status status = AE_OK;
+	acpi_status status;
 
-	in_arg.integer.value = acpi_state;
-	status = acpi_evaluate_object(NULL, "\\_TTS", &arg_list, NULL);
+	status = acpi_execute_simple_method(NULL, "\\_TTS", acpi_state);
 	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
 		/*
 		 * OS can't evaluate the _TTS object correctly. Some warning

commit d6a77ead21b69c395ca6d09a066ededfac601bcc
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue May 14 17:09:16 2013 +0000

    x86 / ACPI / sleep: Provide registration for acpi_suspend_lowlevel.
    
    Which by default will be x86_acpi_suspend_lowlevel.
    This registration allows us to register another callback
    if there is a need to use another platform specific callback.
    
    Signed-off-by: Liang Tang <liang.tang@oracle.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Tested-by: Ben Guthro <benjamin.guthro@citrix.com>
    Acked-by: "H. Peter Anvin" <hpa@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 9c1a435d10e6..187ab61889e6 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -494,6 +494,8 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 		break;
 
 	case ACPI_STATE_S3:
+		if (!acpi_suspend_lowlevel)
+			return -ENOSYS;
 		error = acpi_suspend_lowlevel();
 		if (error)
 			return error;

commit 469dd1c4ac0869cf7d1f87eac9b5a93865c10b76
Author: Fabio Valentini <fafatheone@gmail.com>
Date:   Mon Mar 11 19:16:34 2013 +0000

    ACPI / PM: fix suspend and resume on Sony Vaio VGN-FW21M
    
    Add Sony Vaio VGN-FW21M to the device blacklist in
    drivers/acpi/sleep.c.
    
    Fixes suspend/resume on this device (device no longer reboots
    instead of resuming).
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=55001
    Signed-off-by: Fabio Valentini <fafatheone@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 24213033fbae..9c1a435d10e6 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -193,6 +193,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 	},
 	{
 	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VGN-FW21M",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-FW21M"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
 	.ident = "Sony Vaio VPCEB17FX",
 	.matches = {
 		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),

commit ed4cf5b23f9d21c441e5c8feead86f2e4a436923
Author: Joe Perches <joe@perches.com>
Date:   Fri Feb 22 07:37:36 2013 +0000

    ACPI / Sleep: Avoid interleaved message on errors
    
    Got this dmesg log on an Acer Aspire 725.
    
    [    0.256351] ACPI: (supports S0ACPI Exception: AE_NOT_FOUND, While evaluating Sleep State [\_S1_] (20130117/hwxface-568)
    [    0.256373] ACPI Exception: AE_NOT_FOUND, While evaluating Sleep State [\_S2_] (20130117/hwxface-568)
    [    0.256391]  S3 S4 S5)
    
    Avoid this interleaving error messages.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 6d3a06a629a1..24213033fbae 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -599,7 +599,6 @@ static void acpi_sleep_suspend_setup(void)
 		status = acpi_get_sleep_type_data(i, &type_a, &type_b);
 		if (ACPI_SUCCESS(status)) {
 			sleep_states[i] = 1;
-			pr_cont(" S%d", i);
 		}
 	}
 
@@ -742,7 +741,6 @@ static void acpi_sleep_hibernate_setup(void)
 	hibernation_set_ops(old_suspend_ordering ?
 			&acpi_hibernation_ops_old : &acpi_hibernation_ops);
 	sleep_states[ACPI_STATE_S4] = 1;
-	pr_cont(KERN_CONT " S4");
 	if (nosigcheck)
 		return;
 
@@ -788,6 +786,9 @@ int __init acpi_sleep_init(void)
 {
 	acpi_status status;
 	u8 type_a, type_b;
+	char supported[ACPI_S_STATE_COUNT * 3 + 1];
+	char *pos = supported;
+	int i;
 
 	if (acpi_disabled)
 		return 0;
@@ -795,7 +796,6 @@ int __init acpi_sleep_init(void)
 	acpi_sleep_dmi_check();
 
 	sleep_states[ACPI_STATE_S0] = 1;
-	pr_info(PREFIX "(supports S0");
 
 	acpi_sleep_suspend_setup();
 	acpi_sleep_hibernate_setup();
@@ -803,11 +803,17 @@ int __init acpi_sleep_init(void)
 	status = acpi_get_sleep_type_data(ACPI_STATE_S5, &type_a, &type_b);
 	if (ACPI_SUCCESS(status)) {
 		sleep_states[ACPI_STATE_S5] = 1;
-		pr_cont(" S5");
 		pm_power_off_prepare = acpi_power_off_prepare;
 		pm_power_off = acpi_power_off;
 	}
-	pr_cont(")\n");
+
+	supported[0] = 0;
+	for (i = 0; i < ACPI_S_STATE_COUNT; i++) {
+		if (sleep_states[i])
+			pos += sprintf(pos, " S%d", i);
+	}
+	pr_info(PREFIX "(supports%s)\n", supported);
+
 	/*
 	 * Register the tts_notifier to reboot notifier list so that the _TTS
 	 * object can also be evaluated when the system enters S5.

commit a68d35323b091f51e0957313f0f871f187879143
Merge: e8f71df72333 66f2fda93b67
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 15 13:58:43 2013 +0100

    Merge branch 'acpi-assorted'
    
    * acpi-assorted:
      ACPI: Add DMI entry for Sony VGN-FW41E_H
      ACPI: fix obsolete comment in custom_method.c
      ACPI / thermal: Use mode to enable/disable kernel thermal processing
      ACPI thermal: remove unnecessary newline from exception message
      ACPI sysfs: remove unnecessary newline from exception
      ACPI video: remove unnecessary newline from error messages
      ACPI: SRAT: report non-volatile memory in debug
      ACPI: Rework acpi_get_child() to be more efficient

commit 66f2fda93b67fa744d406e6dcf443f67bac204b6
Author: Joseph Salisbury <joseph.salisbury@canonical.com>
Date:   Tue Feb 5 00:16:29 2013 +0000

    ACPI: Add DMI entry for Sony VGN-FW41E_H
    
    This patch adds a quirk to allow the Sony VGN-FW41E_H to suspend/resume
    properly.
    
    References: http://bugs.launchpad.net/bugs/1113547
    Signed-off-by: Joseph Salisbury <joseph.salisbury@canonical.com>
    Cc: All <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 2fcc67d34b11..df8505147b27 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -177,6 +177,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 	},
 	{
 	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VGN-FW41E_H",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-FW41E_H"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
 	.ident = "Sony Vaio VGN-FW21E",
 	.matches = {
 		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),

commit 02040f0bba996f93e2a237089aff343515b49fcf
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:09 2013 +0100

    ACPI / PM: Consolidate suspend-specific and hibernate-specific code
    
    Move some suspend-specific and hibernate-specific code from
    acpi_sleep_init() into separate functions to get rid of explicit
    #ifdefs in acpi_sleep_init().  Use pr_info() to start and pr_cont()
    to continue printing the supported ACPI sleep states line.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 4ef0328579cc..277aa825edd9 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -579,7 +579,28 @@ static const struct platform_suspend_ops acpi_suspend_ops_old = {
 	.end = acpi_pm_end,
 	.recover = acpi_pm_finish,
 };
-#endif /* CONFIG_SUSPEND */
+
+static void acpi_sleep_suspend_setup(void)
+{
+	int i;
+
+	for (i = ACPI_STATE_S1; i < ACPI_STATE_S4; i++) {
+		acpi_status status;
+		u8 type_a, type_b;
+
+		status = acpi_get_sleep_type_data(i, &type_a, &type_b);
+		if (ACPI_SUCCESS(status)) {
+			sleep_states[i] = 1;
+			pr_cont(" S%d", i);
+		}
+	}
+
+	suspend_set_ops(old_suspend_ordering ?
+		&acpi_suspend_ops_old : &acpi_suspend_ops);
+}
+#else /* !CONFIG_SUSPEND */
+static inline void acpi_sleep_suspend_setup(void) {}
+#endif /* !CONFIG_SUSPEND */
 
 #ifdef CONFIG_HIBERNATION
 static unsigned long s4_hardware_signature;
@@ -700,7 +721,30 @@ static const struct platform_hibernation_ops acpi_hibernation_ops_old = {
 	.restore_cleanup = acpi_pm_thaw,
 	.recover = acpi_pm_finish,
 };
-#endif /* CONFIG_HIBERNATION */
+
+static void acpi_sleep_hibernate_setup(void)
+{
+	acpi_status status;
+	u8 type_a, type_b;
+
+	status = acpi_get_sleep_type_data(ACPI_STATE_S4, &type_a, &type_b);
+	if (ACPI_FAILURE(status))
+		return;
+
+	hibernation_set_ops(old_suspend_ordering ?
+			&acpi_hibernation_ops_old : &acpi_hibernation_ops);
+	sleep_states[ACPI_STATE_S4] = 1;
+	pr_cont(KERN_CONT " S4");
+	if (nosigcheck)
+		return;
+
+	acpi_get_table(ACPI_SIG_FACS, 1, (struct acpi_table_header **)&facs);
+	if (facs)
+		s4_hardware_signature = facs->hardware_signature;
+}
+#else /* !CONFIG_HIBERNATION */
+static inline void acpi_sleep_hibernate_setup(void) {}
+#endif /* !CONFIG_HIBERNATION */
 
 int acpi_suspend(u32 acpi_state)
 {
@@ -736,9 +780,6 @@ int __init acpi_sleep_init(void)
 {
 	acpi_status status;
 	u8 type_a, type_b;
-#ifdef CONFIG_SUSPEND
-	int i = 0;
-#endif
 
 	if (acpi_disabled)
 		return 0;
@@ -746,45 +787,19 @@ int __init acpi_sleep_init(void)
 	acpi_sleep_dmi_check();
 
 	sleep_states[ACPI_STATE_S0] = 1;
-	printk(KERN_INFO PREFIX "(supports S0");
+	pr_info(PREFIX "(supports S0");
 
-#ifdef CONFIG_SUSPEND
-	for (i = ACPI_STATE_S1; i < ACPI_STATE_S4; i++) {
-		status = acpi_get_sleep_type_data(i, &type_a, &type_b);
-		if (ACPI_SUCCESS(status)) {
-			sleep_states[i] = 1;
-			printk(KERN_CONT " S%d", i);
-		}
-	}
+	acpi_sleep_suspend_setup();
+	acpi_sleep_hibernate_setup();
 
-	suspend_set_ops(old_suspend_ordering ?
-		&acpi_suspend_ops_old : &acpi_suspend_ops);
-#endif
-
-#ifdef CONFIG_HIBERNATION
-	status = acpi_get_sleep_type_data(ACPI_STATE_S4, &type_a, &type_b);
-	if (ACPI_SUCCESS(status)) {
-		hibernation_set_ops(old_suspend_ordering ?
-			&acpi_hibernation_ops_old : &acpi_hibernation_ops);
-		sleep_states[ACPI_STATE_S4] = 1;
-		printk(KERN_CONT " S4");
-		if (!nosigcheck) {
-			acpi_get_table(ACPI_SIG_FACS, 1,
-				(struct acpi_table_header **)&facs);
-			if (facs)
-				s4_hardware_signature =
-					facs->hardware_signature;
-		}
-	}
-#endif
 	status = acpi_get_sleep_type_data(ACPI_STATE_S5, &type_a, &type_b);
 	if (ACPI_SUCCESS(status)) {
 		sleep_states[ACPI_STATE_S5] = 1;
-		printk(KERN_CONT " S5");
+		pr_cont(" S5");
 		pm_power_off_prepare = acpi_power_off_prepare;
 		pm_power_off = acpi_power_off;
 	}
-	printk(KERN_CONT ")\n");
+	pr_cont(")\n");
 	/*
 	 * Register the tts_notifier to reboot notifier list so that the _TTS
 	 * object can also be evaluated when the system enters S5.

commit 781d737c7466845035e5ce02885c7436b5278b90
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:06 2013 +0100

    ACPI: Drop power resources driver
    
    The ACPI power resources driver is not very useful, because the only
    thing it really does is to restore the state of the power resources
    that were "on" before system suspend or hibernation, but that may be
    achieved in a different way.
    
    Drop the ACPI power resources driver entirely and add
    acpi_resume_power_resources() that will walk the list of all
    registered power resources during system resume and turn on the ones
    that were "on" before the preceding system suspend or hibernation.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 2fcc67d34b11..4ef0328579cc 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -386,6 +386,8 @@ static void acpi_pm_finish(void)
 
 	acpi_target_sleep_state = ACPI_STATE_S0;
 
+	acpi_resume_power_resources();
+
 	/* If we were woken with the fixed power button, provide a small
 	 * hint to userspace in the form of a wakeup event on the fixed power
 	 * button device (if it can be found).

commit 6b728f1a906976ec658827adc9c2d27608aa8517
Merge: d9ba1025a46d a6b5e88c0e42
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Dec 4 13:46:08 2012 +0100

    Merge branch 'acpi-general'
    
    * acpi-general:
      ACPI / PNP: Do not crash due to stale pointer use during system resume
      ACPI / video: Add "Asus UL30VT" to ACPI video detect blacklist
      ACPI: do acpisleep dmi check when CONFIG_ACPI_SLEEP is set

commit 0ac1b1d7b7424cd6f129b5454b504b3cae746f0e
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri Nov 30 12:57:03 2012 +0100

    ACPI: do acpisleep dmi check when CONFIG_ACPI_SLEEP is set
    
    The current acpisleep DMI checks only run when CONFIG_SUSPEND is set.
    And this may break hibernation on some platforms when CONFIG_SUSPEND
    is cleared.
    
    Move acpisleep DMI check into #ifdef CONFIG_ACPI_SLEEP instead.
    
    [rjw: Added acpi_sleep_dmi_check() and rebased on top of earlier
     patches adding entries to acpisleep_dmi_table[].]
    References: https://bugzilla.kernel.org/show_bug.cgi?id=45921
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 1463c56092c4..6efef87b405c 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -124,6 +124,180 @@ void __init acpi_old_suspend_ordering(void)
 	old_suspend_ordering = true;
 }
 
+static int __init init_old_suspend_ordering(const struct dmi_system_id *d)
+{
+	acpi_old_suspend_ordering();
+	return 0;
+}
+
+static int __init init_nvs_nosave(const struct dmi_system_id *d)
+{
+	acpi_nvs_nosave();
+	return 0;
+}
+
+static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
+	{
+	.callback = init_old_suspend_ordering,
+	.ident = "Abit KN9 (nForce4 variant)",
+	.matches = {
+		DMI_MATCH(DMI_BOARD_VENDOR, "http://www.abit.com.tw/"),
+		DMI_MATCH(DMI_BOARD_NAME, "KN9 Series(NF-CK804)"),
+		},
+	},
+	{
+	.callback = init_old_suspend_ordering,
+	.ident = "HP xw4600 Workstation",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "HP xw4600 Workstation"),
+		},
+	},
+	{
+	.callback = init_old_suspend_ordering,
+	.ident = "Asus Pundit P1-AH2 (M2N8L motherboard)",
+	.matches = {
+		DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTek Computer INC."),
+		DMI_MATCH(DMI_BOARD_NAME, "M2N8L"),
+		},
+	},
+	{
+	.callback = init_old_suspend_ordering,
+	.ident = "Panasonic CF51-2L",
+	.matches = {
+		DMI_MATCH(DMI_BOARD_VENDOR,
+				"Matsushita Electric Industrial Co.,Ltd."),
+		DMI_MATCH(DMI_BOARD_NAME, "CF51-2L"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VGN-FW21E",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-FW21E"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VPCEB17FX",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VPCEB17FX"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VGN-SR11M",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-SR11M"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Everex StepNote Series",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Everex Systems, Inc."),
+		DMI_MATCH(DMI_PRODUCT_NAME, "Everex StepNote Series"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VPCEB1Z1E",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VPCEB1Z1E"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VGN-NW130D",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-NW130D"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VPCCW29FX",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VPCCW29FX"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Averatec AV1020-ED2",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "AVERATEC"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "1000 Series"),
+		},
+	},
+	{
+	.callback = init_old_suspend_ordering,
+	.ident = "Asus A8N-SLI DELUXE",
+	.matches = {
+		DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC."),
+		DMI_MATCH(DMI_BOARD_NAME, "A8N-SLI DELUXE"),
+		},
+	},
+	{
+	.callback = init_old_suspend_ordering,
+	.ident = "Asus A8N-SLI Premium",
+	.matches = {
+		DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC."),
+		DMI_MATCH(DMI_BOARD_NAME, "A8N-SLI Premium"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VGN-SR26GN_P",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-SR26GN_P"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VPCEB1S1E",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VPCEB1S1E"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VGN-FW520F",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-FW520F"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Asus K54C",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
+		DMI_MATCH(DMI_PRODUCT_NAME, "K54C"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Asus K54HR",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
+		DMI_MATCH(DMI_PRODUCT_NAME, "K54HR"),
+		},
+	},
+	{},
+};
+
+static void acpi_sleep_dmi_check(void)
+{
+	dmi_check_system(acpisleep_dmi_table);
+}
+
 /**
  * acpi_pm_freeze - Disable the GPEs and suspend EC transactions.
  */
@@ -239,6 +413,7 @@ static void acpi_pm_end(void)
 }
 #else /* !CONFIG_ACPI_SLEEP */
 #define acpi_target_sleep_state	ACPI_STATE_S0
+static inline void acpi_sleep_dmi_check(void) {}
 #endif /* CONFIG_ACPI_SLEEP */
 
 #ifdef CONFIG_SUSPEND
@@ -397,175 +572,6 @@ static const struct platform_suspend_ops acpi_suspend_ops_old = {
 	.end = acpi_pm_end,
 	.recover = acpi_pm_finish,
 };
-
-static int __init init_old_suspend_ordering(const struct dmi_system_id *d)
-{
-	old_suspend_ordering = true;
-	return 0;
-}
-
-static int __init init_nvs_nosave(const struct dmi_system_id *d)
-{
-	acpi_nvs_nosave();
-	return 0;
-}
-
-static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
-	{
-	.callback = init_old_suspend_ordering,
-	.ident = "Abit KN9 (nForce4 variant)",
-	.matches = {
-		DMI_MATCH(DMI_BOARD_VENDOR, "http://www.abit.com.tw/"),
-		DMI_MATCH(DMI_BOARD_NAME, "KN9 Series(NF-CK804)"),
-		},
-	},
-	{
-	.callback = init_old_suspend_ordering,
-	.ident = "HP xw4600 Workstation",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "HP xw4600 Workstation"),
-		},
-	},
-	{
-	.callback = init_old_suspend_ordering,
-	.ident = "Asus Pundit P1-AH2 (M2N8L motherboard)",
-	.matches = {
-		DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTek Computer INC."),
-		DMI_MATCH(DMI_BOARD_NAME, "M2N8L"),
-		},
-	},
-	{
-	.callback = init_old_suspend_ordering,
-	.ident = "Panasonic CF51-2L",
-	.matches = {
-		DMI_MATCH(DMI_BOARD_VENDOR,
-				"Matsushita Electric Industrial Co.,Ltd."),
-		DMI_MATCH(DMI_BOARD_NAME, "CF51-2L"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VGN-FW21E",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-FW21E"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VPCEB17FX",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VPCEB17FX"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VGN-SR11M",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-SR11M"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Everex StepNote Series",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Everex Systems, Inc."),
-		DMI_MATCH(DMI_PRODUCT_NAME, "Everex StepNote Series"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VPCEB1Z1E",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VPCEB1Z1E"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VGN-NW130D",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-NW130D"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VPCCW29FX",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VPCCW29FX"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Averatec AV1020-ED2",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "AVERATEC"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "1000 Series"),
-		},
-	},
-	{
-	.callback = init_old_suspend_ordering,
-	.ident = "Asus A8N-SLI DELUXE",
-	.matches = {
-		DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC."),
-		DMI_MATCH(DMI_BOARD_NAME, "A8N-SLI DELUXE"),
-		},
-	},
-	{
-	.callback = init_old_suspend_ordering,
-	.ident = "Asus A8N-SLI Premium",
-	.matches = {
-		DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC."),
-		DMI_MATCH(DMI_BOARD_NAME, "A8N-SLI Premium"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VGN-SR26GN_P",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-SR26GN_P"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VPCEB1S1E",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VPCEB1S1E"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VGN-FW520F",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-FW520F"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Asus K54C",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
-		DMI_MATCH(DMI_PRODUCT_NAME, "K54C"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Asus K54HR",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
-		DMI_MATCH(DMI_PRODUCT_NAME, "K54HR"),
-		},
-	},
-	{},
-};
 #endif /* CONFIG_SUSPEND */
 
 #ifdef CONFIG_HIBERNATION
@@ -896,13 +902,13 @@ int __init acpi_sleep_init(void)
 	u8 type_a, type_b;
 #ifdef CONFIG_SUSPEND
 	int i = 0;
-
-	dmi_check_system(acpisleep_dmi_table);
 #endif
 
 	if (acpi_disabled)
 		return 0;
 
+	acpi_sleep_dmi_check();
+
 	sleep_states[ACPI_STATE_S0] = 1;
 	printk(KERN_INFO PREFIX "(supports S0");
 

commit d4c091f13dc4d30e4af43c0ccf8c82b3277574ca
Merge: 08ab72980a77 261cba2deb7d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 29 21:43:06 2012 +0100

    Merge branch 'acpi-general'
    
    * acpi-general: (38 commits)
      ACPI / thermal: _TMP and _CRT/_HOT/_PSV/_ACx dependency fix
      ACPI: drop unnecessary local variable from acpi_system_write_wakeup_device()
      ACPI: Fix logging when no pci_irq is allocated
      ACPI: Update Dock hotplug error messages
      ACPI: Update Container hotplug error messages
      ACPI: Update Memory hotplug error messages
      ACPI: Update CPU hotplug error messages
      ACPI: Add acpi_handle_<level>() interfaces
      ACPI: remove use of __devexit
      ACPI / PM: Add Sony Vaio VPCEB1S1E to nonvs blacklist.
      ACPI / battery: Correct battery capacity values on Thinkpads
      Revert "ACPI / x86: Add quirk for "CheckPoint P-20-00" to not use bridge _CRS_ info"
      ACPI: create _SUN sysfs file
      ACPI / memhotplug: bind the memory device when the driver is being loaded
      ACPI / memhotplug: don't allow to eject the memory device if it is being used
      ACPI / memhotplug: free memory device if acpi_memory_enable_device() failed
      ACPI / memhotplug: fix memory leak when memory device is unbound from acpi_memhotplug
      ACPI / memhotplug: deal with eject request in hotplug queue
      ACPI / memory-hotplug: add memory offline code to acpi_memory_device_remove()
      ACPI / memory-hotplug: call acpi_bus_trim() to remove memory device
      ...
    
    Conflicts:
            include/linux/acpi.h (two additions at the end of the same file)

commit 876ab79055019e248508cfd0dee7caa3c0c831ed
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Nov 21 23:12:12 2012 +0100

    ACPI / PM: Add Sony Vaio VPCEB1S1E to nonvs blacklist.
    
    Sony Vaio VPCEB1S1E does not resume correctly without
    acpi_sleep=nonvs, so add it to the ACPI sleep blacklist.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=48781
    Reported-by: Sébastien Wilmet <swilmet@gnome.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 8640782944cc..1463c56092c4 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -534,6 +534,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 	},
 	{
 	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VPCEB1S1E",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VPCEB1S1E"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
 	.ident = "Sony Vaio VGN-FW520F",
 	.matches = {
 		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),

commit 1bad2f19f7f79d1ec9e6c48168fd7ce8dc1c305f
Author: Kristen Carlson Accardi <kristen@linux.intel.com>
Date:   Fri Oct 26 13:39:15 2012 +0200

    ACPI / Sleep: add acpi_sleep=nonvs_s3 parameter
    
    The ACPI specificiation would like us to save NVS at hibernation time,
    but makes no mention of saving NVS over S3.  Not all versions of
    Windows do this either, and it is clear that not all machines need NVS
    saved/restored over S3.  Allow the user to improve their suspend/resume
    time by disabling the NVS save/restore at S3 time, but continue to do
    the NVS save/restore for S4 as specified.
    
    Signed-off-by: Kristen Carlson Accardi <kristen@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index fdcdbb652915..8640782944cc 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -97,6 +97,21 @@ void __init acpi_nvs_nosave(void)
 	nvs_nosave = true;
 }
 
+/*
+ * The ACPI specification wants us to save NVS memory regions during hibernation
+ * but says nothing about saving NVS during S3.  Not all versions of Windows
+ * save NVS on S3 suspend either, and it is clear that not all systems need
+ * NVS to be saved at S3 time.  To improve suspend/resume time, allow the
+ * user to disable saving NVS on S3 if their system does not require it, but
+ * continue to save/restore NVS for S4 as specified.
+ */
+static bool nvs_nosave_s3;
+
+void __init acpi_nvs_nosave_s3(void)
+{
+	nvs_nosave_s3 = true;
+}
+
 /*
  * ACPI 1.0 wants us to execute _PTS before suspending devices, so we allow the
  * user to request that behavior by using the 'acpi_old_suspend_ordering'
@@ -243,7 +258,7 @@ static int acpi_suspend_begin(suspend_state_t pm_state)
 	u32 acpi_state = acpi_suspend_states[pm_state];
 	int error = 0;
 
-	error = nvs_nosave ? 0 : suspend_nvs_alloc();
+	error = (nvs_nosave || nvs_nosave_s3) ? 0 : suspend_nvs_alloc();
 	if (error)
 		return error;
 

commit a6ae7594b1b157e0e7976ed105a7be27d69a5361
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 2 01:40:53 2012 +0100

    ACPI / PM: Move device PM functions related to sleep states
    
    Introduce helper function returning the target sleep state of the
    system and use it to move the remaining device power management
    functions from sleep.c to device_pm.c.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 77c517f6f6d0..13a285dffaca 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -80,6 +80,12 @@ static int acpi_sleep_prepare(u32 acpi_state)
 
 #ifdef CONFIG_ACPI_SLEEP
 static u32 acpi_target_sleep_state = ACPI_STATE_S0;
+
+u32 acpi_target_system_state(void)
+{
+	return acpi_target_sleep_state;
+}
+
 static bool pwr_btn_event_pending;
 
 /*
@@ -680,63 +686,6 @@ int acpi_suspend(u32 acpi_state)
 	return -EINVAL;
 }
 
-#ifdef CONFIG_PM
-/**
- * acpi_pm_device_sleep_state - Get preferred power state of ACPI device.
- * @dev: Device whose preferred target power state to return.
- * @d_min_p: Location to store the upper limit of the allowed states range.
- * @d_max_in: Deepest low-power state to take into consideration.
- * Return value: Preferred power state of the device on success, -ENODEV
- * (if there's no 'struct acpi_device' for @dev) or -EINVAL on failure
- *
- * The caller must ensure that @dev is valid before using this function.
- */
-int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
-{
-	acpi_handle handle = DEVICE_ACPI_HANDLE(dev);
-	struct acpi_device *adev;
-
-	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &adev))) {
-		dev_dbg(dev, "ACPI handle without context in %s!\n", __func__);
-		return -ENODEV;
-	}
-
-	return acpi_device_power_state(dev, adev, acpi_target_sleep_state,
-				       d_max_in, d_min_p);
-}
-EXPORT_SYMBOL(acpi_pm_device_sleep_state);
-#endif /* CONFIG_PM */
-
-#ifdef CONFIG_PM_SLEEP
-/**
- * acpi_pm_device_sleep_wake - Enable or disable device to wake up the system.
- * @dev: Device to enable/desible to wake up the system from sleep states.
- * @enable: Whether to enable or disable @dev to wake up the system.
- */
-int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
-{
-	acpi_handle handle;
-	struct acpi_device *adev;
-	int error;
-
-	if (!device_can_wakeup(dev))
-		return -EINVAL;
-
-	handle = DEVICE_ACPI_HANDLE(dev);
-	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &adev))) {
-		dev_dbg(dev, "ACPI handle without context in %s!\n", __func__);
-		return -ENODEV;
-	}
-
-	error = __acpi_device_sleep_wake(adev, acpi_target_sleep_state, enable);
-	if (!error)
-		dev_info(dev, "System wakeup %s by ACPI\n",
-				enable ? "enabled" : "disabled");
-
-	return error;
-}
-#endif  /* CONFIG_PM_SLEEP */
-
 static void acpi_power_off_prepare(void)
 {
 	/* Prepare to power off the system */

commit dee8370cc87e505ef39567f0974e73d59e75d76b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 2 01:40:36 2012 +0100

    ACPI / PM: Split device wakeup management routines
    
    Two device wakeup management routines in device_pm.c and sleep.c,
    acpi_pm_device_run_wake() and acpi_pm_device_sleep_wake(), take a
    device pointer argument and use it to obtain the ACPI handle of the
    corresponding ACPI namespace node.  That handle is then used to get
    the address of the struct acpi_device object corresponding to the
    struct device passed as the argument.
    
    Unfortunately, that last operation may be costly, because it involves
    taking the global ACPI namespace mutex, so it shouldn't be carried
    out too often.  However, the callers of those routines usually call
    them in a row with acpi_pm_device_sleep_state() which also takes that
    mutex for the same reason, so it would be more efficient if they ran
    acpi_bus_get_device() themselves to obtain a pointer to the struct
    acpi_device object in question and then passed that pointer to the
    appropriate PM routines.
    
    To make that possible, split each of the PM routines mentioned above
    in two parts, one taking a struct acpi_device pointer argument and
    the other implementing the current interface for compatibility.
    
    Additionally, change acpi_pm_device_run_wake() to actually return
    an error code if there is an error while setting up runtime remote
    wakeup for the device.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 241304ee4068..77c517f6f6d0 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -724,15 +724,13 @@ int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
 
 	handle = DEVICE_ACPI_HANDLE(dev);
 	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &adev))) {
-		dev_dbg(dev, "ACPI handle has no context in %s!\n", __func__);
+		dev_dbg(dev, "ACPI handle without context in %s!\n", __func__);
 		return -ENODEV;
 	}
 
-	error = enable ?
-		acpi_enable_wakeup_device_power(adev, acpi_target_sleep_state) :
-		acpi_disable_wakeup_device_power(adev);
+	error = __acpi_device_sleep_wake(adev, acpi_target_sleep_state, enable);
 	if (!error)
-		dev_info(dev, "wake-up capability %s by ACPI\n",
+		dev_info(dev, "System wakeup %s by ACPI\n",
 				enable ? "enabled" : "disabled");
 
 	return error;

commit cd7bd02d319eb34fa33d1705cf63f64928643708
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 2 01:40:28 2012 +0100

    ACPI / PM: Move runtime remote wakeup setup routine to device_pm.c
    
    The ACPI function for setting up devices to do runtime remote
    wakeup is now located in drivers/acpi/sleep.c, but
    drivers/acpi/device_pm.c is a more logical place for it, so move it
    there.
    
    No functional changes should result from this modification.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index fa20d0171887..241304ee4068 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -18,7 +18,6 @@
 #include <linux/reboot.h>
 #include <linux/acpi.h>
 #include <linux/module.h>
-#include <linux/pm_runtime.h>
 
 #include <asm/io.h>
 
@@ -708,44 +707,6 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 EXPORT_SYMBOL(acpi_pm_device_sleep_state);
 #endif /* CONFIG_PM */
 
-#ifdef CONFIG_PM_RUNTIME
-/**
- * acpi_pm_device_run_wake - Enable/disable remote wakeup for given device.
- * @phys_dev: Device to enable/disable the platform to wake up.
- * @enable: Whether to enable or disable the wakeup functionality.
- *
- * Find the ACPI device object corresponding to @phys_dev and try to
- * enable/disable the GPE associated with it, so that it can generate
- * wakeup signals for the device in response to external (remote) events.
- */
-int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
-{
-	struct acpi_device *dev;
-	acpi_handle handle;
-
-	if (!device_run_wake(phys_dev))
-		return -EINVAL;
-
-	handle = DEVICE_ACPI_HANDLE(phys_dev);
-	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &dev))) {
-		dev_dbg(phys_dev, "ACPI handle has no context in %s!\n",
-			__func__);
-		return -ENODEV;
-	}
-
-	if (enable) {
-		acpi_enable_wakeup_device_power(dev, ACPI_STATE_S0);
-		acpi_enable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number);
-	} else {
-		acpi_disable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number);
-		acpi_disable_wakeup_device_power(dev);
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(acpi_pm_device_run_wake);
-#endif /* CONFIG_PM_RUNTIME */
-
 #ifdef CONFIG_PM_SLEEP
 /**
  * acpi_pm_device_sleep_wake - Enable or disable device to wake up the system.

commit 86b3832c64b6d01092216d84dc6a6b300875d0bb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 2 01:40:18 2012 +0100

    ACPI / PM: Move device power state selection routine to device_pm.c
    
    The ACPI function for choosing device power state is now located
    in drivers/acpi/sleep.c, but drivers/acpi/device_pm.c is a more
    logical place for it, so move it there.
    
    However, instead of moving the function entirely, move its core only
    under a different name and with a different list of arguments, so
    that it is more flexible, and leave a wrapper around it in the
    original location.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 4defa0297ee4..fa20d0171887 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -19,7 +19,6 @@
 #include <linux/acpi.h>
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
-#include <linux/pm_qos.h>
 
 #include <asm/io.h>
 
@@ -691,101 +690,20 @@ int acpi_suspend(u32 acpi_state)
  * Return value: Preferred power state of the device on success, -ENODEV
  * (if there's no 'struct acpi_device' for @dev) or -EINVAL on failure
  *
- * Find the lowest power (highest number) ACPI device power state that the
- * device can be in while the system is in the sleep state represented
- * by %acpi_target_sleep_state.  If @d_min_p is set, the highest power (lowest
- * number) device power state that @dev can be in for the given system sleep
- * state is stored at the location pointed to by it.
- *
  * The caller must ensure that @dev is valid before using this function.
  */
 int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 {
 	acpi_handle handle = DEVICE_ACPI_HANDLE(dev);
 	struct acpi_device *adev;
-	char acpi_method[] = "_SxD";
-	unsigned long long d_min, d_max;
-	bool wakeup = false;
 
-	if (d_max_in < ACPI_STATE_D0 || d_max_in > ACPI_STATE_D3)
-		return -EINVAL;
 	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &adev))) {
-		printk(KERN_DEBUG "ACPI handle has no context!\n");
+		dev_dbg(dev, "ACPI handle without context in %s!\n", __func__);
 		return -ENODEV;
 	}
-	if (d_max_in > ACPI_STATE_D3_HOT) {
-		enum pm_qos_flags_status stat;
-
-		stat = dev_pm_qos_flags(dev, PM_QOS_FLAG_NO_POWER_OFF);
-		if (stat == PM_QOS_FLAGS_ALL)
-			d_max_in = ACPI_STATE_D3_HOT;
-	}
-
-	acpi_method[2] = '0' + acpi_target_sleep_state;
-	/*
-	 * If the sleep state is S0, the lowest limit from ACPI is D3,
-	 * but if the device has _S0W, we will use the value from _S0W
-	 * as the lowest limit from ACPI.  Finally, we will constrain
-	 * the lowest limit with the specified one.
-	 */
-	d_min = ACPI_STATE_D0;
-	d_max = ACPI_STATE_D3;
-
-	/*
-	 * If present, _SxD methods return the minimum D-state (highest power
-	 * state) we can use for the corresponding S-states.  Otherwise, the
-	 * minimum D-state is D0 (ACPI 3.x).
-	 *
-	 * NOTE: We rely on acpi_evaluate_integer() not clobbering the integer
-	 * provided -- that's our fault recovery, we ignore retval.
-	 */
-	if (acpi_target_sleep_state > ACPI_STATE_S0) {
-		acpi_evaluate_integer(handle, acpi_method, NULL, &d_min);
-		wakeup = device_may_wakeup(dev) && adev->wakeup.flags.valid
-			&& adev->wakeup.sleep_state >= acpi_target_sleep_state;
-	} else if (dev_pm_qos_flags(dev, PM_QOS_FLAG_REMOTE_WAKEUP) !=
-			PM_QOS_FLAGS_NONE) {
-		wakeup = adev->wakeup.flags.valid;
-	}
-
-	/*
-	 * If _PRW says we can wake up the system from the target sleep state,
-	 * the D-state returned by _SxD is sufficient for that (we assume a
-	 * wakeup-aware driver if wake is set).  Still, if _SxW exists
-	 * (ACPI 3.x), it should return the maximum (lowest power) D-state that
-	 * can wake the system.  _S0W may be valid, too.
-	 */
-	if (wakeup) {
-		acpi_status status;
-
-		acpi_method[3] = 'W';
-		status = acpi_evaluate_integer(handle, acpi_method, NULL,
-						&d_max);
-		if (ACPI_FAILURE(status)) {
-			if (acpi_target_sleep_state != ACPI_STATE_S0 ||
-			    status != AE_NOT_FOUND)
-				d_max = d_min;
-		} else if (d_max < d_min) {
-			/* Warn the user of the broken DSDT */
-			printk(KERN_WARNING "ACPI: Wrong value from %s\n",
-				acpi_method);
-			/* Sanitize it */
-			d_min = d_max;
-		}
-	}
 
-	if (d_max_in < d_min)
-		return -EINVAL;
-	if (d_min_p)
-		*d_min_p = d_min;
-	/* constrain d_max with specified lowest limit (max number) */
-	if (d_max > d_max_in) {
-		for (d_max = d_max_in; d_max > d_min; d_max--) {
-			if (adev->power.states[d_max].flags.valid)
-				break;
-		}
-	}
-	return d_max;
+	return acpi_device_power_state(dev, adev, acpi_target_sleep_state,
+				       d_max_in, d_min_p);
 }
 EXPORT_SYMBOL(acpi_pm_device_sleep_state);
 #endif /* CONFIG_PM */

commit bdda27fb98463244f056852f800bbce7db67dc4a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Oct 26 13:40:04 2012 +0200

    ACPI / PM: Fix device PM kernedoc comments and #ifdefs
    
    The kerneldoc comments for acpi_pm_device_sleep_state(),
    acpi_pm_device_run_wake(), and acpi_pm_device_sleep_wake() are
    outdated or otherwise inaccurate and/or don't follow the common
    kerneldoc patterns, so fix them.
    
    Additionally, notice that acpi_pm_device_run_wake() should be under
    CONFIG_PM_RUNTIME rather than under CONFIG_PM_SLEEP, so fix that too.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 69134653909c..4defa0297ee4 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -684,28 +684,21 @@ int acpi_suspend(u32 acpi_state)
 
 #ifdef CONFIG_PM
 /**
- *	acpi_pm_device_sleep_state - return preferred power state of ACPI device
- *		in the system sleep state given by %acpi_target_sleep_state
- *	@dev: device to examine; its driver model wakeup flags control
- *		whether it should be able to wake up the system
- *	@d_min_p: used to store the upper limit of allowed states range
- *	@d_max_in: specify the lowest allowed states
- *	Return value: preferred power state of the device on success, -ENODEV
- *	(ie. if there's no 'struct acpi_device' for @dev) or -EINVAL on failure
+ * acpi_pm_device_sleep_state - Get preferred power state of ACPI device.
+ * @dev: Device whose preferred target power state to return.
+ * @d_min_p: Location to store the upper limit of the allowed states range.
+ * @d_max_in: Deepest low-power state to take into consideration.
+ * Return value: Preferred power state of the device on success, -ENODEV
+ * (if there's no 'struct acpi_device' for @dev) or -EINVAL on failure
  *
- *	Find the lowest power (highest number) ACPI device power state that
- *	device @dev can be in while the system is in the sleep state represented
- *	by %acpi_target_sleep_state.  If @wake is nonzero, the device should be
- *	able to wake up the system from this sleep state.  If @d_min_p is set,
- *	the highest power (lowest number) device power state of @dev allowed
- *	in this system sleep state is stored at the location pointed to by it.
+ * Find the lowest power (highest number) ACPI device power state that the
+ * device can be in while the system is in the sleep state represented
+ * by %acpi_target_sleep_state.  If @d_min_p is set, the highest power (lowest
+ * number) device power state that @dev can be in for the given system sleep
+ * state is stored at the location pointed to by it.
  *
- *	The caller must ensure that @dev is valid before using this function.
- *	The caller is also responsible for figuring out if the device is
- *	supposed to be able to wake up the system and passing this information
- *	via @wake.
+ * The caller must ensure that @dev is valid before using this function.
  */
-
 int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 {
 	acpi_handle handle = DEVICE_ACPI_HANDLE(dev);
@@ -797,14 +790,15 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 EXPORT_SYMBOL(acpi_pm_device_sleep_state);
 #endif /* CONFIG_PM */
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM_RUNTIME
 /**
- * acpi_pm_device_run_wake - Enable/disable wake-up for given device.
- * @phys_dev: Device to enable/disable the platform to wake-up the system for.
- * @enable: Whether enable or disable the wake-up functionality.
+ * acpi_pm_device_run_wake - Enable/disable remote wakeup for given device.
+ * @phys_dev: Device to enable/disable the platform to wake up.
+ * @enable: Whether to enable or disable the wakeup functionality.
  *
- * Find the ACPI device object corresponding to @pci_dev and try to
- * enable/disable the GPE associated with it.
+ * Find the ACPI device object corresponding to @phys_dev and try to
+ * enable/disable the GPE associated with it, so that it can generate
+ * wakeup signals for the device in response to external (remote) events.
  */
 int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
 {
@@ -832,12 +826,13 @@ int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
 	return 0;
 }
 EXPORT_SYMBOL(acpi_pm_device_run_wake);
+#endif /* CONFIG_PM_RUNTIME */
 
+#ifdef CONFIG_PM_SLEEP
 /**
- *	acpi_pm_device_sleep_wake - enable or disable the system wake-up
- *                                  capability of given device
- *	@dev: device to handle
- *	@enable: 'true' - enable, 'false' - disable the wake-up capability
+ * acpi_pm_device_sleep_wake - Enable or disable device to wake up the system.
+ * @dev: Device to enable/desible to wake up the system from sleep states.
+ * @enable: Whether to enable or disable @dev to wake up the system.
  */
 int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
 {

commit 8b713a88cc8b746f975958183fa641e9f1c8086d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 24 02:08:38 2012 +0200

    PM / ACPI: Take device PM QoS flags into account
    
    Make ACPI power management routines and PCI power management
    routines depending on ACPI take device PM QoS flags into account
    when deciding what power state to put the device into.
    
    In particular, after this change acpi_pm_device_sleep_state() will
    not return ACPI_STATE_D3_COLD as the deepest available low-power
    state if PM_QOS_FLAG_NO_POWER_OFF is requested for the device and it
    will not require remote wakeup to work for the device in the returned
    low-power state if there is at least one PM QoS flags request for the
    device, but PM_QOS_FLAG_REMOTE_WAKEUP is not requested for it.
    
    Accordingly, acpi_pci_set_power_state() will refuse to put the
    device into D3cold if PM_QOS_FLAG_NO_POWER_OFF is requested for it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Jean Pihet <j-pihet@ti.com>
    Reviewed-by: Huang Ying <ying.huang@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index fdcdbb652915..69134653909c 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -19,6 +19,7 @@
 #include <linux/acpi.h>
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
+#include <linux/pm_qos.h>
 
 #include <asm/io.h>
 
@@ -711,6 +712,7 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 	struct acpi_device *adev;
 	char acpi_method[] = "_SxD";
 	unsigned long long d_min, d_max;
+	bool wakeup = false;
 
 	if (d_max_in < ACPI_STATE_D0 || d_max_in > ACPI_STATE_D3)
 		return -EINVAL;
@@ -718,6 +720,13 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 		printk(KERN_DEBUG "ACPI handle has no context!\n");
 		return -ENODEV;
 	}
+	if (d_max_in > ACPI_STATE_D3_HOT) {
+		enum pm_qos_flags_status stat;
+
+		stat = dev_pm_qos_flags(dev, PM_QOS_FLAG_NO_POWER_OFF);
+		if (stat == PM_QOS_FLAGS_ALL)
+			d_max_in = ACPI_STATE_D3_HOT;
+	}
 
 	acpi_method[2] = '0' + acpi_target_sleep_state;
 	/*
@@ -737,8 +746,14 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 	 * NOTE: We rely on acpi_evaluate_integer() not clobbering the integer
 	 * provided -- that's our fault recovery, we ignore retval.
 	 */
-	if (acpi_target_sleep_state > ACPI_STATE_S0)
+	if (acpi_target_sleep_state > ACPI_STATE_S0) {
 		acpi_evaluate_integer(handle, acpi_method, NULL, &d_min);
+		wakeup = device_may_wakeup(dev) && adev->wakeup.flags.valid
+			&& adev->wakeup.sleep_state >= acpi_target_sleep_state;
+	} else if (dev_pm_qos_flags(dev, PM_QOS_FLAG_REMOTE_WAKEUP) !=
+			PM_QOS_FLAGS_NONE) {
+		wakeup = adev->wakeup.flags.valid;
+	}
 
 	/*
 	 * If _PRW says we can wake up the system from the target sleep state,
@@ -747,9 +762,7 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 	 * (ACPI 3.x), it should return the maximum (lowest power) D-state that
 	 * can wake the system.  _S0W may be valid, too.
 	 */
-	if (acpi_target_sleep_state == ACPI_STATE_S0 ||
-	    (device_may_wakeup(dev) && adev->wakeup.flags.valid &&
-	     adev->wakeup.sleep_state >= acpi_target_sleep_state)) {
+	if (wakeup) {
 		acpi_status status;
 
 		acpi_method[3] = 'W';

commit 9d0b01a1bbb7a4ad23000240b67bca33c4235fcf
Merge: 3f6f49c7854c b7db60f45d74 095adbb64411 2d9c86774756
Author: Len Brown <len.brown@intel.com>
Date:   Fri Aug 3 00:31:23 2012 -0400

    Merge branches 'delete-gts-bfs', 'misc', 'novell-bugzilla-757888-numa' and 'osc-pcie' into base

commit 3f6f49c7854c9294119437a82c5b35be78f9cea6
Author: Len Brown <len.brown@intel.com>
Date:   Thu Jul 26 20:08:54 2012 -0400

    ACPI: delete _GTS/_BFS support
    
    _GTS and _BFS were added to the suspend/resume flow
    in the ACPI 2.0 specification.
    
    Linux dutifully implemented _GTS and _BFS.
    We discovered that it was rarely seen in systems
    in the field.  Further, some of those systems had
    AML so bogus that it could never work -- proof that
    no other operating system supports _GTS and _BFS.
    So we made _GTS and _BFS optional via modparam,
    and disabled them by default.
    
    But we've had to complicate some code to keep
    this support in the kernel, as these methods are defined
    to be evaluated very close to sleep entry and exit.
    Indeed, no other AML is ever evaluated with interrupts off.
    
    We have submitted a proposal for _GTS and _BFS
    to be officially removed from the ACPI specification
    on the next revision.  Here we remove it from Linux.
    
    Signed-off-by: Len Brown <len.brown@intel.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 23a53c013f1e..bd35e3c5e530 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -28,34 +28,6 @@
 #include "internal.h"
 #include "sleep.h"
 
-u8 wake_sleep_flags = ACPI_NO_OPTIONAL_METHODS;
-static unsigned int gts, bfs;
-static int set_param_wake_flag(const char *val, struct kernel_param *kp)
-{
-	int ret = param_set_int(val, kp);
-
-	if (ret)
-		return ret;
-
-	if (kp->arg == (const char *)&gts) {
-		if (gts)
-			wake_sleep_flags |= ACPI_EXECUTE_GTS;
-		else
-			wake_sleep_flags &= ~ACPI_EXECUTE_GTS;
-	}
-	if (kp->arg == (const char *)&bfs) {
-		if (bfs)
-			wake_sleep_flags |= ACPI_EXECUTE_BFS;
-		else
-			wake_sleep_flags &= ~ACPI_EXECUTE_BFS;
-	}
-	return ret;
-}
-module_param_call(gts, set_param_wake_flag, param_get_int, &gts, 0644);
-module_param_call(bfs, set_param_wake_flag, param_get_int, &bfs, 0644);
-MODULE_PARM_DESC(gts, "Enable evaluation of _GTS on suspend.");
-MODULE_PARM_DESC(bfs, "Enable evaluation of _BFS on resume".);
-
 static u8 sleep_states[ACPI_S_STATE_COUNT];
 static bool pwr_btn_event_pending;
 
@@ -305,7 +277,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	switch (acpi_state) {
 	case ACPI_STATE_S1:
 		barrier();
-		status = acpi_enter_sleep_state(acpi_state, wake_sleep_flags);
+		status = acpi_enter_sleep_state(acpi_state);
 		break;
 
 	case ACPI_STATE_S3:
@@ -319,8 +291,8 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	/* This violates the spec but is required for bug compatibility. */
 	acpi_write_bit_register(ACPI_BITREG_SCI_ENABLE, 1);
 
-	/* Reprogram control registers and execute _BFS */
-	acpi_leave_sleep_state_prep(acpi_state, wake_sleep_flags);
+	/* Reprogram control registers */
+	acpi_leave_sleep_state_prep(acpi_state);
 
 	/* ACPI 3.0 specs (P62) says that it's the responsibility
 	 * of the OSPM to clear the status bit [ implying that the
@@ -603,9 +575,9 @@ static int acpi_hibernation_enter(void)
 	ACPI_FLUSH_CPU_CACHE();
 
 	/* This shouldn't return.  If it returns, we have a problem */
-	status = acpi_enter_sleep_state(ACPI_STATE_S4, wake_sleep_flags);
-	/* Reprogram control registers and execute _BFS */
-	acpi_leave_sleep_state_prep(ACPI_STATE_S4, wake_sleep_flags);
+	status = acpi_enter_sleep_state(ACPI_STATE_S4);
+	/* Reprogram control registers */
+	acpi_leave_sleep_state_prep(ACPI_STATE_S4);
 
 	return ACPI_SUCCESS(status) ? 0 : -EFAULT;
 }
@@ -617,8 +589,8 @@ static void acpi_hibernation_leave(void)
 	 * enable it here.
 	 */
 	acpi_enable();
-	/* Reprogram control registers and execute _BFS */
-	acpi_leave_sleep_state_prep(ACPI_STATE_S4, wake_sleep_flags);
+	/* Reprogram control registers */
+	acpi_leave_sleep_state_prep(ACPI_STATE_S4);
 	/* Check the hardware signature */
 	if (facs && s4_hardware_signature != facs->hardware_signature) {
 		printk(KERN_EMERG "ACPI: Hardware changed while hibernated, "
@@ -876,33 +848,7 @@ static void acpi_power_off(void)
 	/* acpi_sleep_prepare(ACPI_STATE_S5) should have already been called */
 	printk(KERN_DEBUG "%s called\n", __func__);
 	local_irq_disable();
-	acpi_enter_sleep_state(ACPI_STATE_S5, wake_sleep_flags);
-}
-
-/*
- * ACPI 2.0 created the optional _GTS and _BFS,
- * but industry adoption has been neither rapid nor broad.
- *
- * Linux gets into trouble when it executes poorly validated
- * paths through the BIOS, so disable _GTS and _BFS by default,
- * but do speak up and offer the option to enable them.
- */
-static void __init acpi_gts_bfs_check(void)
-{
-	acpi_handle dummy;
-
-	if (ACPI_SUCCESS(acpi_get_handle(ACPI_ROOT_OBJECT, METHOD_PATHNAME__GTS, &dummy)))
-	{
-		printk(KERN_NOTICE PREFIX "BIOS offers _GTS\n");
-		printk(KERN_NOTICE PREFIX "If \"acpi.gts=1\" improves suspend, "
-			"please notify linux-acpi@vger.kernel.org\n");
-	}
-	if (ACPI_SUCCESS(acpi_get_handle(ACPI_ROOT_OBJECT, METHOD_PATHNAME__BFS, &dummy)))
-	{
-		printk(KERN_NOTICE PREFIX "BIOS offers _BFS\n");
-		printk(KERN_NOTICE PREFIX "If \"acpi.bfs=1\" improves resume, "
-			"please notify linux-acpi@vger.kernel.org\n");
-	}
+	acpi_enter_sleep_state(ACPI_STATE_S5);
 }
 
 int __init acpi_sleep_init(void)
@@ -963,6 +909,5 @@ int __init acpi_sleep_init(void)
 	 * object can also be evaluated when the system enters S5.
 	 */
 	register_reboot_notifier(&tts_notifier);
-	acpi_gts_bfs_check();
 	return 0;
 }

commit a5ca7345c1e67cd12cf75a9ec034c7d34786ae79
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 23 21:01:02 2012 +0200

    ACPI / PM: Fix build warning in sleep.c for CONFIG_ACPI_SLEEP unset
    
    If CONFIG_ACPI_SLEEP is unset, the compiler complains that
    pwr_btn_event_pending is defined but not used.  To silence the
    warning, move the definition of pwr_btn_event_pending under an
    appropriate #ifdef.
    
    Reported-by: Paul E. McKenney <paul.mckenney@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Paul E. McKenney <paul.mckenney@linaro.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 88561029cca8..dca8074b6704 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -57,7 +57,6 @@ MODULE_PARM_DESC(gts, "Enable evaluation of _GTS on suspend.");
 MODULE_PARM_DESC(bfs, "Enable evaluation of _BFS on resume".);
 
 static u8 sleep_states[ACPI_S_STATE_COUNT];
-static bool pwr_btn_event_pending;
 
 static void acpi_sleep_tts_switch(u32 acpi_state)
 {
@@ -110,6 +109,7 @@ static int acpi_sleep_prepare(u32 acpi_state)
 
 #ifdef CONFIG_ACPI_SLEEP
 static u32 acpi_target_sleep_state = ACPI_STATE_S0;
+static bool pwr_btn_event_pending;
 
 /*
  * The ACPI specification wants us to save NVS memory regions during hibernation

commit 476525004ac7e2f990b6956efcd44d0780c2ab4c
Merge: bd22dc17e499 ec033d0a0290
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 26 14:28:55 2012 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux
    
    Pull ACPI & power management update from Len Brown:
     "Re-write of the turbostat tool.
         lower overhead was necessary for measuring very large system when
         they are very idle.
    
      IVB support in intel_idle
         It's what I run on my IVB, others should be able to also:-)
    
      ACPICA core update
         We have found some bugs due to divergence between Linux and the
         upstream ACPICA base.  Most of these patches are to reduce that
         divergence to reduce the risk of future bugs.
    
      Some cpuidle updates, mostly for non-Intel
         More will be coming, as they depend on this part.
    
      Some thermal management changes needed by non-ACPI systems.
    
      Some _OST (OS Status Indication) updates for hot ACPI hot-plug."
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux: (51 commits)
      Thermal: Documentation update
      Thermal: Add Hysteresis attributes
      Thermal: Make Thermal trip points writeable
      ACPI/AC: prevent OOPS on some boxes due to missing check power_supply_register() return value check
      tools/power: turbostat: fix large c1% issue
      tools/power: turbostat v2 - re-write for efficiency
      ACPICA: Update to version 20120711
      ACPICA: AcpiSrc: Fix some translation issues for Linux conversion
      ACPICA: Update header files copyrights to 2012
      ACPICA: Add new ACPI table load/unload external interfaces
      ACPICA: Split file: tbxface.c -> tbxfload.c
      ACPICA: Add PCC address space to space ID decode function
      ACPICA: Fix some comment fields
      ACPICA: Table manager: deploy new firmware error/warning interfaces
      ACPICA: Add new interfaces for BIOS(firmware) errors and warnings
      ACPICA: Split exception code utilities to a new file, utexcep.c
      ACPI: acpi_pad: tune round_robin_time
      ACPICA: Update to version 20120620
      ACPICA: Add support for implicit notify on multiple devices
      ACPICA: Update comments; no functional change
      ...

commit ec033d0a02901551346b9f43f8ff9bad51378891
Merge: fa7584e13ac8 819f1a64beb6 f712c71f7b2b a58e1150225c 20ff51a36b2c 1b0a0e9a15b9 6edab08c24f9 c2f4191a9c4d f197ac13f6ee 8eaa8d6ca277 b9c7aff481f1 c3ae331d1c2f
Author: Len Brown <len.brown@intel.com>
Date:   Thu Jul 26 00:03:58 2012 -0400

    Merge branches 'acpi_pad', 'acpica', 'apei-bugzilla-43282', 'battery', 'cpuidle-coupled', 'cpuidle-tweaks', 'intel_idle-ivb', 'ost', 'red-hat-bz-772730', 'thermal', 'thermal-spear' and 'turbostat-v2' into release

commit 8407884dd9164ec18ed2afc00f56b87e36c51fcf
Merge: dc7f71f486f4 bdc0077af574
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Jul 25 15:58:48 2012 -0400

    Merge branch 'master' [vanilla Linus master] into libata-dev.git/upstream
    
    Two bits were appended to the end of the bitfield
    list in struct scsi_device.  Resolve that conflict
    by including both bits.
    
    Conflicts:
            include/scsi/scsi_device.h

commit 3bd46600a7a7e938c54df8cdbac9910668c7dfb0
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Jun 25 16:13:06 2012 +0800

    libata-acpi: add ata port runtime D3Cold support
    
    ATA port may support runtime D3Cold state, for example, Zero-power ODD case.
    This patch adds wakeup notifier and enable/disable run_wake during
    supend/resume.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 88561029cca8..1784cb30e7cf 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -795,6 +795,7 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p)
 		*d_min_p = d_min;
 	return d_max;
 }
+EXPORT_SYMBOL(acpi_pm_device_sleep_state);
 #endif /* CONFIG_PM */
 
 #ifdef CONFIG_PM_SLEEP
@@ -831,6 +832,7 @@ int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
 
 	return 0;
 }
+EXPORT_SYMBOL(acpi_pm_device_run_wake);
 
 /**
  *	acpi_pm_device_sleep_wake - enable or disable the system wake-up

commit ee85f543710dd56ce526cb44e39191f32972e5ad
Author: Huang Ying <ying.huang@intel.com>
Date:   Sat Jun 23 10:23:48 2012 +0800

    ACPI/PM: specify lowest allowed state for device sleep state
    
    Lower device sleep state can save more power, but has more exit
    latency too.  Sometimes, to satisfy some power QoS and other
    requirement, we need to constrain the lowest device sleep state.
    
    In this patch, a parameter to specify lowest allowed state for
    acpi_pm_device_sleep_state is added.  So that the caller can enforce
    the constraint via the parameter.
    
    This is needed by PCIe D3cold support, where the lowest power state
    allowed may be D3_HOT instead of default D3_COLD.
    
    CC: Len Brown <lenb@kernel.org>
    CC: linux-acpi@vger.kernel.org
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 88561029cca8..1cc02ca2af2a 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -716,8 +716,9 @@ int acpi_suspend(u32 acpi_state)
  *	@dev: device to examine; its driver model wakeup flags control
  *		whether it should be able to wake up the system
  *	@d_min_p: used to store the upper limit of allowed states range
- *	Return value: preferred power state of the device on success, -ENODEV on
- *		failure (ie. if there's no 'struct acpi_device' for @dev)
+ *	@d_max_in: specify the lowest allowed states
+ *	Return value: preferred power state of the device on success, -ENODEV
+ *	(ie. if there's no 'struct acpi_device' for @dev) or -EINVAL on failure
  *
  *	Find the lowest power (highest number) ACPI device power state that
  *	device @dev can be in while the system is in the sleep state represented
@@ -732,13 +733,15 @@ int acpi_suspend(u32 acpi_state)
  *	via @wake.
  */
 
-int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p)
+int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 {
 	acpi_handle handle = DEVICE_ACPI_HANDLE(dev);
 	struct acpi_device *adev;
 	char acpi_method[] = "_SxD";
 	unsigned long long d_min, d_max;
 
+	if (d_max_in < ACPI_STATE_D0 || d_max_in > ACPI_STATE_D3)
+		return -EINVAL;
 	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &adev))) {
 		printk(KERN_DEBUG "ACPI handle has no context!\n");
 		return -ENODEV;
@@ -746,8 +749,10 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p)
 
 	acpi_method[2] = '0' + acpi_target_sleep_state;
 	/*
-	 * If the sleep state is S0, we will return D3, but if the device has
-	 * _S0W, we will use the value from _S0W
+	 * If the sleep state is S0, the lowest limit from ACPI is D3,
+	 * but if the device has _S0W, we will use the value from _S0W
+	 * as the lowest limit from ACPI.  Finally, we will constrain
+	 * the lowest limit with the specified one.
 	 */
 	d_min = ACPI_STATE_D0;
 	d_max = ACPI_STATE_D3;
@@ -791,8 +796,17 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p)
 		}
 	}
 
+	if (d_max_in < d_min)
+		return -EINVAL;
 	if (d_min_p)
 		*d_min_p = d_min;
+	/* constrain d_max with specified lowest limit (max number) */
+	if (d_max > d_max_in) {
+		for (d_max = d_max_in; d_max > d_min; d_max--) {
+			if (adev->power.states[d_max].flags.valid)
+				break;
+		}
+	}
 	return d_max;
 }
 #endif /* CONFIG_PM */

commit d3514abcf5b896a3a66d8b7c960a0018a52ebc2c
Merge: c59714569642 7ae30986dc63 dbe9a2edd17d 650a37f32d2b 7e1bd6e38b1f d8e725f356fd
Author: Len Brown <len.brown@intel.com>
Date:   Mon Jun 4 00:48:41 2012 -0400

    Merge branches 'bugfix-battery', 'bugfix-misc', 'bugfix-rafael', 'bugfix-turbostat', 'bugfix-video' and 'workaround-pss' into release
    
    bug fixes
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 4d578573b8328ce5aa6500b955444b89afa3c72c
Merge: 68e3e92620c3 dbe9a2edd17d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 3 20:15:57 2012 -0700

    Merge branch 'pm-acpi' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull some left-over PM patches from Rafael J. Wysocki.
    
    * 'pm-acpi' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      ACPI / PM: Make acpi_pm_device_sleep_state() follow the specification
      ACPI / PM: Make __acpi_bus_get_power() cover D3cold correctly
      ACPI / PM: Fix error messages in drivers/acpi/bus.c
      rtc-cmos / PM: report wakeup event on ACPI RTC alarm
      ACPI / PM: Generate wakeup events on fixed power button

commit bd6f10a5f984e48cb56a39f2698cd58e7a33d56b
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Tue May 22 16:43:49 2012 +0800

    ACPICA: Remove argument of acpi_os_wait_events_complete
    
    Remove the unused argument of acpi_os_wait_events_complete.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index eb6fd233764b..9a14f90d98ec 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -144,7 +144,7 @@ void __init acpi_old_suspend_ordering(void)
 static int acpi_pm_freeze(void)
 {
 	acpi_disable_all_gpes();
-	acpi_os_wait_events_complete(NULL);
+	acpi_os_wait_events_complete();
 	acpi_ec_block_transactions();
 	return 0;
 }

commit 319b6ffc6df892e4ccffff823cc5521a4a5d2dca
Author: H. Peter Anvin <hpa@kernel.org>
Date:   Wed May 30 12:33:41 2012 +0300

    x86, realmode: Unbreak the ia64 build of drivers/acpi/sleep.c
    
    Revert usage of acpi_wakeup_address and move definition
    to x86 architecture code in order to make compilation work
    in ia64.
    
    [jsakkine: tested compilation in ia64/x86-64 and added
    proper commit message]
    
    Reported-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Originally-by: H. Peter Anvin <hpa@kernel.org>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@intel.com>
    Link: http://lkml.kernel.org/r/1338370421-27735-1-git-send-email-jarkko.sakkinen@intel.com
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index ebaa04593236..74ee4ab577b6 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -25,8 +25,6 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
-#include <asm/realmode.h>
-
 #include "internal.h"
 #include "sleep.h"
 
@@ -93,13 +91,11 @@ static struct notifier_block tts_notifier = {
 static int acpi_sleep_prepare(u32 acpi_state)
 {
 #ifdef CONFIG_ACPI_SLEEP
-	unsigned long wakeup_pa = real_mode_header->wakeup_start;
 	/* do we have a wakeup address for S2 and S3? */
 	if (acpi_state == ACPI_STATE_S3) {
-		if (!wakeup_pa)
+		if (!acpi_wakeup_address)
 			return -EFAULT;
-		acpi_set_firmware_waking_vector(
-				(acpi_physical_address)wakeup_pa);
+		acpi_set_firmware_waking_vector(acpi_wakeup_address);
 
 	}
 	ACPI_FLUSH_CPU_CACHE();

commit 731a7378b81c2f5fa88ca1ae20b83d548d5613dc
Merge: 87a5af24e548 61f544616904
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 29 20:14:53 2012 -0700

    Merge branch 'x86-trampoline-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 trampoline rework from H. Peter Anvin:
     "This code reworks all the "trampoline"/"realmode" code (various bits
      that need to live in the first megabyte of memory, most but not all of
      which runs in real mode at some point) in the kernel into a single
      object.  The main reason for doing this is that it eliminates the last
      place in the kernel where we needed pages to be mapped RWX.  This code
      separates all that code into proper R/RW/RX pages."
    
    Fix up conflicts in arch/x86/kernel/Makefile (mca removed next to reboot
    code), and arch/x86/kernel/reboot.c (reboot code moved around in one
    branch, modified in this one), and arch/x86/tools/relocs.c (mostly same
    code came in earlier due to working around the ld bugs just before the
    3.4 release).
    
    Also remove stale x86-relocs entry from scripts/.gitignore as per Peter
    Anvin.
    
    * commit '61f5446169046c217a5479517edac3a890c3bee7': (36 commits)
      x86, realmode: Move end signature into header.S
      x86, relocs: When printing an error, say relative or absolute
      x86, relocs: More relocations which may end up as absolute
      x86, relocs: Workaround for binutils 2.22.52.0.1 section bug
      xen-acpi-processor: Add missing #include <xen/xen.h>
      acpi, bgrd: Add missing <linux/io.h> to drivers/acpi/bgrt.c
      x86, realmode: Change EFER to a single u64 field
      x86, realmode: Move kernel/realmode.c to realmode/init.c
      x86, realmode: Move not-common bits out of trampoline_common.S
      x86, realmode: Mask out EFER.LMA when saving trampoline EFER
      x86, realmode: Fix no cache bits test in reboot_32.S
      x86, realmode: Make sure all generated files are listed in targets
      x86, realmode: build fix: remove duplicate build
      x86, realmode: read cr4 and EFER from kernel for 64-bit trampoline
      x86, realmode: fixes compilation issue in tboot.c
      x86, realmode: move relocs from scripts/ to arch/x86/tools
      x86, realmode: header for trampoline code
      x86, realmode: flattened rm hierachy
      x86, realmode: don't copy real_mode_header
      x86, realmode: fix 64-bit wakeup sequence
      ...

commit dbe9a2edd17d843d80faf2b99f20a691c1853418
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue May 29 21:21:07 2012 +0200

    ACPI / PM: Make acpi_pm_device_sleep_state() follow the specification
    
    The comparison between the system sleep state being entered
    and the lowest system sleep state the given device may wake up
    from in acpi_pm_device_sleep_state() is reversed, because the
    specification (ACPI 5.0) says that for wakeup to work:
    
    "The sleeping state being entered must be less than or equal to the
     power state declared in element 1 of the _PRW object."
    
    In other words, the state returned by _PRW is the deepest
    (lowest-power) system sleep state the device is capable of waking up
    the system from.
    
    Moreover, acpi_pm_device_sleep_state() also should check if the
    wakeup capability is supported through ACPI, because in principle it
    may be done via native PCIe PME, for example, in which case _SxW
    should not be evaluated.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index a564fc3ffa1c..d8b381e94ee2 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -773,8 +773,8 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p)
 	 * can wake the system.  _S0W may be valid, too.
 	 */
 	if (acpi_target_sleep_state == ACPI_STATE_S0 ||
-	    (device_may_wakeup(dev) &&
-	     adev->wakeup.sleep_state <= acpi_target_sleep_state)) {
+	    (device_may_wakeup(dev) && adev->wakeup.flags.valid &&
+	     adev->wakeup.sleep_state >= acpi_target_sleep_state)) {
 		acpi_status status;
 
 		acpi_method[3] = 'W';

commit c10d7a13846bffa5c77f1122500b687ab902e2d2
Author: Daniel Drake <dsd@laptop.org>
Date:   Thu May 10 00:08:43 2012 +0100

    ACPI / PM: Generate wakeup events on fixed power button
    
    When the system is woken up by the ACPI fixed power button, currently there
    is no way of userspace becoming aware that the power button was pressed.
    
    OLPC would like to know this, so that we can respond appropriately.
    For example, if the system was woken up by a network packet, we know
    we can go back to sleep very quickly. But if the user explicitly woke the
    system with the power button, we're going to want to stay awake for a
    while.
    
    The wakeup count mechanism seems like a good fit for communicating this.
    Mark the fixed power button as wakeup-enabled, and increment its wakeup
    counter when the system is woken with the power button. (The wakeup counter
    is also incremented when the power button is pressed during system
    operation; this is already handled by an existing acpi-button codepath).
    
    Signed-off-by: Daniel Drake <dsd@laptop.org>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index eb6fd233764b..a564fc3ffa1c 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -57,6 +57,7 @@ MODULE_PARM_DESC(gts, "Enable evaluation of _GTS on suspend.");
 MODULE_PARM_DESC(bfs, "Enable evaluation of _BFS on resume".);
 
 static u8 sleep_states[ACPI_S_STATE_COUNT];
+static bool pwr_btn_event_pending;
 
 static void acpi_sleep_tts_switch(u32 acpi_state)
 {
@@ -186,6 +187,14 @@ static int acpi_pm_prepare(void)
 	return error;
 }
 
+static int find_powerf_dev(struct device *dev, void *data)
+{
+	struct acpi_device *device = to_acpi_device(dev);
+	const char *hid = acpi_device_hid(device);
+
+	return !strcmp(hid, ACPI_BUTTON_HID_POWERF);
+}
+
 /**
  *	acpi_pm_finish - Instruct the platform to leave a sleep state.
  *
@@ -194,6 +203,7 @@ static int acpi_pm_prepare(void)
  */
 static void acpi_pm_finish(void)
 {
+	struct device *pwr_btn_dev;
 	u32 acpi_state = acpi_target_sleep_state;
 
 	acpi_ec_unblock_transactions();
@@ -211,6 +221,23 @@ static void acpi_pm_finish(void)
 	acpi_set_firmware_waking_vector((acpi_physical_address) 0);
 
 	acpi_target_sleep_state = ACPI_STATE_S0;
+
+	/* If we were woken with the fixed power button, provide a small
+	 * hint to userspace in the form of a wakeup event on the fixed power
+	 * button device (if it can be found).
+	 *
+	 * We delay the event generation til now, as the PM layer requires
+	 * timekeeping to be running before we generate events. */
+	if (!pwr_btn_event_pending)
+		return;
+
+	pwr_btn_event_pending = false;
+	pwr_btn_dev = bus_find_device(&acpi_bus_type, NULL, NULL,
+				      find_powerf_dev);
+	if (pwr_btn_dev) {
+		pm_wakeup_event(pwr_btn_dev, 0);
+		put_device(pwr_btn_dev);
+	}
 }
 
 /**
@@ -300,9 +327,23 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	/* ACPI 3.0 specs (P62) says that it's the responsibility
 	 * of the OSPM to clear the status bit [ implying that the
 	 * POWER_BUTTON event should not reach userspace ]
+	 *
+	 * However, we do generate a small hint for userspace in the form of
+	 * a wakeup event. We flag this condition for now and generate the
+	 * event later, as we're currently too early in resume to be able to
+	 * generate wakeup events.
 	 */
-	if (ACPI_SUCCESS(status) && (acpi_state == ACPI_STATE_S3))
-		acpi_clear_event(ACPI_EVENT_POWER_BUTTON);
+	if (ACPI_SUCCESS(status) && (acpi_state == ACPI_STATE_S3)) {
+		acpi_event_status pwr_btn_status;
+
+		acpi_get_event_status(ACPI_EVENT_POWER_BUTTON, &pwr_btn_status);
+
+		if (pwr_btn_status & ACPI_EVENT_FLAG_SET) {
+			acpi_clear_event(ACPI_EVENT_POWER_BUTTON);
+			/* Flag for later */
+			pwr_btn_event_pending = true;
+		}
+	}
 
 	/*
 	 * Disable and clear GPE status before interrupt is enabled. Some GPEs

commit b429dbf6e866bd6dadb56fae66f61f611cde57ff
Author: Jarkko Sakkinen <jarkko.sakkinen@intel.com>
Date:   Tue May 8 21:22:41 2012 +0300

    x86, realmode: don't copy real_mode_header
    
    Replaced copying of real_mode_header with a pointer
    to beginning of RM memory.
    
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@intel.com>
    Link: http://lkml.kernel.org/r/1336501366-28617-19-git-send-email-jarkko.sakkinen@intel.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index e77aa4a1c9f6..06139005c4dd 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -93,7 +93,7 @@ static struct notifier_block tts_notifier = {
 static int acpi_sleep_prepare(u32 acpi_state)
 {
 #ifdef CONFIG_ACPI_SLEEP
-	unsigned long wakeup_pa = real_mode_header.wakeup_start;
+	unsigned long wakeup_pa = real_mode_header->wakeup_start;
 	/* do we have a wakeup address for S2 and S3? */
 	if (acpi_state == ACPI_STATE_S3) {
 		if (!wakeup_pa)

commit c9b77ccb52a5c77233b0e557b7d4417b00ef4012
Author: Jarkko Sakkinen <jarkko.sakkinen@intel.com>
Date:   Tue May 8 21:22:29 2012 +0300

    x86, realmode: Move ACPI wakeup to unified realmode code
    
    Migrated ACPI wakeup code to the real-mode blob.
    Code existing in .x86_trampoline  can be completely
    removed. Static descriptor table in wakeup_asm.S is
    courtesy of H. Peter Anvin.
    
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@intel.com>
    Link: http://lkml.kernel.org/r/1336501366-28617-7-git-send-email-jarkko.sakkinen@intel.com
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Len Brown <len.brown@intel.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index eb6fd233764b..e77aa4a1c9f6 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -25,6 +25,8 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
+#include <asm/realmode.h>
+
 #include "internal.h"
 #include "sleep.h"
 
@@ -91,13 +93,13 @@ static struct notifier_block tts_notifier = {
 static int acpi_sleep_prepare(u32 acpi_state)
 {
 #ifdef CONFIG_ACPI_SLEEP
+	unsigned long wakeup_pa = real_mode_header.wakeup_start;
 	/* do we have a wakeup address for S2 and S3? */
 	if (acpi_state == ACPI_STATE_S3) {
-		if (!acpi_wakeup_address) {
+		if (!wakeup_pa)
 			return -EFAULT;
-		}
 		acpi_set_firmware_waking_vector(
-				(acpi_physical_address)acpi_wakeup_address);
+				(acpi_physical_address)wakeup_pa);
 
 	}
 	ACPI_FLUSH_CPU_CACHE();

commit be96447e0d49622fe00b07474f9a86805d389ca7
Author: Kay Sievers <kay@vrfy.org>
Date:   Tue May 8 17:24:20 2012 +0200

    acpi: use KERN_CONT in printk() continuation lines
    
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index eb6fd233764b..06527c526618 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -887,7 +887,7 @@ int __init acpi_sleep_init(void)
 		status = acpi_get_sleep_type_data(i, &type_a, &type_b);
 		if (ACPI_SUCCESS(status)) {
 			sleep_states[i] = 1;
-			printk(" S%d", i);
+			printk(KERN_CONT " S%d", i);
 		}
 	}
 
@@ -901,7 +901,7 @@ int __init acpi_sleep_init(void)
 		hibernation_set_ops(old_suspend_ordering ?
 			&acpi_hibernation_ops_old : &acpi_hibernation_ops);
 		sleep_states[ACPI_STATE_S4] = 1;
-		printk(" S4");
+		printk(KERN_CONT " S4");
 		if (!nosigcheck) {
 			acpi_get_table(ACPI_SIG_FACS, 1,
 				(struct acpi_table_header **)&facs);
@@ -914,11 +914,11 @@ int __init acpi_sleep_init(void)
 	status = acpi_get_sleep_type_data(ACPI_STATE_S5, &type_a, &type_b);
 	if (ACPI_SUCCESS(status)) {
 		sleep_states[ACPI_STATE_S5] = 1;
-		printk(" S5");
+		printk(KERN_CONT " S5");
 		pm_power_off_prepare = acpi_power_off_prepare;
 		pm_power_off = acpi_power_off;
 	}
-	printk(")\n");
+	printk(KERN_CONT ")\n");
 	/*
 	 * Register the tts_notifier to reboot notifier list so that the _TTS
 	 * object can also be evaluated when the system enters S5.

commit 2a14e541ed87bca0c125b82961ca3c6f808607d2
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Sun Apr 22 23:03:17 2012 -0400

    ACPI: Convert wake_sleep_flags to a value instead of function
    
    With commit a2ef5c4fd44ce3922435139393b89f2cce47f576
    "ACPI: Move module parameter gts and bfs to sleep.c" the wake_sleep_flags
    is required when calling acpi_enter_sleep_state, which means
    that if there are functions outside the sleep.c code they
    can't get the wake_sleep_flags values.
    
    This converts the function in to a exported value and converts
    the module config operands to a function.
    
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Lin Ming <ming.m.lin@intel.com>
    [v2: Parameters can be turned on/off dynamically]
    [v3: unsigned char -> u8]
    [v4: val -> kp->arg]
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Link: http://lkml.kernel.org/r/1335150198-21899-2-git-send-email-konrad.wilk@oracle.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 1d661b5c3287..eb6fd233764b 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -28,23 +28,33 @@
 #include "internal.h"
 #include "sleep.h"
 
+u8 wake_sleep_flags = ACPI_NO_OPTIONAL_METHODS;
 static unsigned int gts, bfs;
-module_param(gts, uint, 0644);
-module_param(bfs, uint, 0644);
-MODULE_PARM_DESC(gts, "Enable evaluation of _GTS on suspend.");
-MODULE_PARM_DESC(bfs, "Enable evaluation of _BFS on resume".);
-
-static u8 wake_sleep_flags(void)
+static int set_param_wake_flag(const char *val, struct kernel_param *kp)
 {
-	u8 flags = ACPI_NO_OPTIONAL_METHODS;
+	int ret = param_set_int(val, kp);
 
-	if (gts)
-		flags |= ACPI_EXECUTE_GTS;
-	if (bfs)
-		flags |= ACPI_EXECUTE_BFS;
+	if (ret)
+		return ret;
 
-	return flags;
+	if (kp->arg == (const char *)&gts) {
+		if (gts)
+			wake_sleep_flags |= ACPI_EXECUTE_GTS;
+		else
+			wake_sleep_flags &= ~ACPI_EXECUTE_GTS;
+	}
+	if (kp->arg == (const char *)&bfs) {
+		if (bfs)
+			wake_sleep_flags |= ACPI_EXECUTE_BFS;
+		else
+			wake_sleep_flags &= ~ACPI_EXECUTE_BFS;
+	}
+	return ret;
 }
+module_param_call(gts, set_param_wake_flag, param_get_int, &gts, 0644);
+module_param_call(bfs, set_param_wake_flag, param_get_int, &bfs, 0644);
+MODULE_PARM_DESC(gts, "Enable evaluation of _GTS on suspend.");
+MODULE_PARM_DESC(bfs, "Enable evaluation of _BFS on resume".);
 
 static u8 sleep_states[ACPI_S_STATE_COUNT];
 
@@ -263,7 +273,6 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 {
 	acpi_status status = AE_OK;
 	u32 acpi_state = acpi_target_sleep_state;
-	u8 flags = wake_sleep_flags();
 	int error;
 
 	ACPI_FLUSH_CPU_CACHE();
@@ -271,7 +280,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	switch (acpi_state) {
 	case ACPI_STATE_S1:
 		barrier();
-		status = acpi_enter_sleep_state(acpi_state, flags);
+		status = acpi_enter_sleep_state(acpi_state, wake_sleep_flags);
 		break;
 
 	case ACPI_STATE_S3:
@@ -286,7 +295,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	acpi_write_bit_register(ACPI_BITREG_SCI_ENABLE, 1);
 
 	/* Reprogram control registers and execute _BFS */
-	acpi_leave_sleep_state_prep(acpi_state, flags);
+	acpi_leave_sleep_state_prep(acpi_state, wake_sleep_flags);
 
 	/* ACPI 3.0 specs (P62) says that it's the responsibility
 	 * of the OSPM to clear the status bit [ implying that the
@@ -550,30 +559,27 @@ static int acpi_hibernation_begin(void)
 
 static int acpi_hibernation_enter(void)
 {
-	u8 flags = wake_sleep_flags();
 	acpi_status status = AE_OK;
 
 	ACPI_FLUSH_CPU_CACHE();
 
 	/* This shouldn't return.  If it returns, we have a problem */
-	status = acpi_enter_sleep_state(ACPI_STATE_S4, flags);
+	status = acpi_enter_sleep_state(ACPI_STATE_S4, wake_sleep_flags);
 	/* Reprogram control registers and execute _BFS */
-	acpi_leave_sleep_state_prep(ACPI_STATE_S4, flags);
+	acpi_leave_sleep_state_prep(ACPI_STATE_S4, wake_sleep_flags);
 
 	return ACPI_SUCCESS(status) ? 0 : -EFAULT;
 }
 
 static void acpi_hibernation_leave(void)
 {
-	u8 flags = wake_sleep_flags();
-
 	/*
 	 * If ACPI is not enabled by the BIOS and the boot kernel, we need to
 	 * enable it here.
 	 */
 	acpi_enable();
 	/* Reprogram control registers and execute _BFS */
-	acpi_leave_sleep_state_prep(ACPI_STATE_S4, flags);
+	acpi_leave_sleep_state_prep(ACPI_STATE_S4, wake_sleep_flags);
 	/* Check the hardware signature */
 	if (facs && s4_hardware_signature != facs->hardware_signature) {
 		printk(KERN_EMERG "ACPI: Hardware changed while hibernated, "
@@ -828,12 +834,10 @@ static void acpi_power_off_prepare(void)
 
 static void acpi_power_off(void)
 {
-	u8 flags = wake_sleep_flags();
-
 	/* acpi_sleep_prepare(ACPI_STATE_S5) should have already been called */
 	printk(KERN_DEBUG "%s called\n", __func__);
 	local_irq_disable();
-	acpi_enter_sleep_state(ACPI_STATE_S5, flags);
+	acpi_enter_sleep_state(ACPI_STATE_S5, wake_sleep_flags);
 }
 
 /*

commit ec612fcf43e09f5e05d37baf4d3f138b3fcc2f3d
Merge: 73f05330497b b24e50988536
Author: Len Brown <len.brown@intel.com>
Date:   Fri Mar 30 16:21:26 2012 -0400

    Merge branch 'd3' into release
    
    Conflicts:
            drivers/acpi/sleep.c
    
    This was a text conflict between
    a2ef5c4fd44ce3922435139393b89f2cce47f576
    (ACPI: Move module parameter gts and bfs to sleep.c)
    
    which added #include <linux/module.h>
    
    and
    
    b24e5098853653554baf6ec975b9e855f3d6e5c0
    (ACPI, PCI: Move acpi_dev_run_wake() to ACPI core)
    
    which added #include <linux/pm_runtime.h>
    
    The resolution was to take them both.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit b24e5098853653554baf6ec975b9e855f3d6e5c0
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Tue Mar 27 15:43:25 2012 +0800

    ACPI, PCI: Move acpi_dev_run_wake() to ACPI core
    
    acpi_dev_run_wake() is a generic function which can be used by
    other subsystem too. Rename it to acpi_pm_device_run_wake, to be
    consistent with acpi_pm_device_sleep_wake.
    
    Then move it to ACPI core.
    
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index ca191ff97844..00fa664d5fd8 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -17,6 +17,7 @@
 #include <linux/suspend.h>
 #include <linux/reboot.h>
 #include <linux/acpi.h>
+#include <linux/pm_runtime.h>
 
 #include <asm/io.h>
 
@@ -729,6 +730,40 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p)
 #endif /* CONFIG_PM */
 
 #ifdef CONFIG_PM_SLEEP
+/**
+ * acpi_pm_device_run_wake - Enable/disable wake-up for given device.
+ * @phys_dev: Device to enable/disable the platform to wake-up the system for.
+ * @enable: Whether enable or disable the wake-up functionality.
+ *
+ * Find the ACPI device object corresponding to @pci_dev and try to
+ * enable/disable the GPE associated with it.
+ */
+int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
+{
+	struct acpi_device *dev;
+	acpi_handle handle;
+
+	if (!device_run_wake(phys_dev))
+		return -EINVAL;
+
+	handle = DEVICE_ACPI_HANDLE(phys_dev);
+	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &dev))) {
+		dev_dbg(phys_dev, "ACPI handle has no context in %s!\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (enable) {
+		acpi_enable_wakeup_device_power(dev, ACPI_STATE_S0);
+		acpi_enable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number);
+	} else {
+		acpi_disable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number);
+		acpi_disable_wakeup_device_power(dev);
+	}
+
+	return 0;
+}
+
 /**
  *	acpi_pm_device_sleep_wake - enable or disable the system wake-up
  *                                  capability of given device

commit a2ef5c4fd44ce3922435139393b89f2cce47f576
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Wed Mar 21 10:58:46 2012 +0800

    ACPI: Move module parameter gts and bfs to sleep.c
    
    Move linux specific module parameter gts and bfs out of ACPICA core
    code to sleep.c.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 8f1fb4520d24..acf81fe86b53 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -17,6 +17,7 @@
 #include <linux/suspend.h>
 #include <linux/reboot.h>
 #include <linux/acpi.h>
+#include <linux/module.h>
 
 #include <asm/io.h>
 
@@ -26,6 +27,24 @@
 #include "internal.h"
 #include "sleep.h"
 
+static unsigned int gts, bfs;
+module_param(gts, uint, 0644);
+module_param(bfs, uint, 0644);
+MODULE_PARM_DESC(gts, "Enable evaluation of _GTS on suspend.");
+MODULE_PARM_DESC(bfs, "Enable evaluation of _BFS on resume".);
+
+static u8 wake_sleep_flags(void)
+{
+	u8 flags = ACPI_NO_OPTIONAL_METHODS;
+
+	if (gts)
+		flags |= ACPI_EXECUTE_GTS;
+	if (bfs)
+		flags |= ACPI_EXECUTE_BFS;
+
+	return flags;
+}
+
 static u8 sleep_states[ACPI_S_STATE_COUNT];
 
 static void acpi_sleep_tts_switch(u32 acpi_state)
@@ -243,6 +262,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 {
 	acpi_status status = AE_OK;
 	u32 acpi_state = acpi_target_sleep_state;
+	u8 flags = wake_sleep_flags();
 	int error;
 
 	ACPI_FLUSH_CPU_CACHE();
@@ -250,8 +270,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	switch (acpi_state) {
 	case ACPI_STATE_S1:
 		barrier();
-		status = acpi_enter_sleep_state(acpi_state,
-				ACPI_NO_OPTIONAL_METHODS);
+		status = acpi_enter_sleep_state(acpi_state, flags);
 		break;
 
 	case ACPI_STATE_S3:
@@ -266,7 +285,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	acpi_write_bit_register(ACPI_BITREG_SCI_ENABLE, 1);
 
 	/* Reprogram control registers and execute _BFS */
-	acpi_leave_sleep_state_prep(acpi_state, ACPI_NO_OPTIONAL_METHODS);
+	acpi_leave_sleep_state_prep(acpi_state, flags);
 
 	/* ACPI 3.0 specs (P62) says that it's the responsibility
 	 * of the OSPM to clear the status bit [ implying that the
@@ -530,27 +549,30 @@ static int acpi_hibernation_begin(void)
 
 static int acpi_hibernation_enter(void)
 {
+	u8 flags = wake_sleep_flags();
 	acpi_status status = AE_OK;
 
 	ACPI_FLUSH_CPU_CACHE();
 
 	/* This shouldn't return.  If it returns, we have a problem */
-	status = acpi_enter_sleep_state(ACPI_STATE_S4, ACPI_NO_OPTIONAL_METHODS);
+	status = acpi_enter_sleep_state(ACPI_STATE_S4, flags);
 	/* Reprogram control registers and execute _BFS */
-	acpi_leave_sleep_state_prep(ACPI_STATE_S4, ACPI_NO_OPTIONAL_METHODS);
+	acpi_leave_sleep_state_prep(ACPI_STATE_S4, flags);
 
 	return ACPI_SUCCESS(status) ? 0 : -EFAULT;
 }
 
 static void acpi_hibernation_leave(void)
 {
+	u8 flags = wake_sleep_flags();
+
 	/*
 	 * If ACPI is not enabled by the BIOS and the boot kernel, we need to
 	 * enable it here.
 	 */
 	acpi_enable();
 	/* Reprogram control registers and execute _BFS */
-	acpi_leave_sleep_state_prep(ACPI_STATE_S4, ACPI_NO_OPTIONAL_METHODS);
+	acpi_leave_sleep_state_prep(ACPI_STATE_S4, flags);
 	/* Check the hardware signature */
 	if (facs && s4_hardware_signature != facs->hardware_signature) {
 		printk(KERN_EMERG "ACPI: Hardware changed while hibernated, "
@@ -771,10 +793,12 @@ static void acpi_power_off_prepare(void)
 
 static void acpi_power_off(void)
 {
+	u8 flags = wake_sleep_flags();
+
 	/* acpi_sleep_prepare(ACPI_STATE_S5) should have already been called */
 	printk(KERN_DEBUG "%s called\n", __func__);
 	local_irq_disable();
-	acpi_enter_sleep_state(ACPI_STATE_S5, ACPI_NO_OPTIONAL_METHODS);
+	acpi_enter_sleep_state(ACPI_STATE_S5, flags);
 }
 
 /*

commit 8a73b17e4c0e09cb5b80deee5451e29b830df4cc
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Wed Mar 21 10:01:49 2012 +0800

    ACPICA: Sleep/Wake interfaces: optionally execute _GTS and _BFS
    
    Enhanced the sleep/wake interfaces to optionally execute the
    _GTS method (Going To Sleep), and the _BFS method (Back From
    Sleep).  Windows apparently does not execute these methods, and
    therefore these methods are often untested. It has been seen on
    some systems where the execution of these methods causes errors
    and also prevents the machine from entering S5. It is therefore
    suggested that host operating systems do not execute these methods
    by default. In the future, perhaps these methods can be optionally
    executed based on the age of the system and/or what is the newest
    version of Windows that the BIOS asks for via _OSI.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 4fda549fa599..8f1fb4520d24 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -250,7 +250,8 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	switch (acpi_state) {
 	case ACPI_STATE_S1:
 		barrier();
-		status = acpi_enter_sleep_state(acpi_state);
+		status = acpi_enter_sleep_state(acpi_state,
+				ACPI_NO_OPTIONAL_METHODS);
 		break;
 
 	case ACPI_STATE_S3:
@@ -265,7 +266,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	acpi_write_bit_register(ACPI_BITREG_SCI_ENABLE, 1);
 
 	/* Reprogram control registers and execute _BFS */
-	acpi_leave_sleep_state_prep(acpi_state);
+	acpi_leave_sleep_state_prep(acpi_state, ACPI_NO_OPTIONAL_METHODS);
 
 	/* ACPI 3.0 specs (P62) says that it's the responsibility
 	 * of the OSPM to clear the status bit [ implying that the
@@ -534,9 +535,9 @@ static int acpi_hibernation_enter(void)
 	ACPI_FLUSH_CPU_CACHE();
 
 	/* This shouldn't return.  If it returns, we have a problem */
-	status = acpi_enter_sleep_state(ACPI_STATE_S4);
+	status = acpi_enter_sleep_state(ACPI_STATE_S4, ACPI_NO_OPTIONAL_METHODS);
 	/* Reprogram control registers and execute _BFS */
-	acpi_leave_sleep_state_prep(ACPI_STATE_S4);
+	acpi_leave_sleep_state_prep(ACPI_STATE_S4, ACPI_NO_OPTIONAL_METHODS);
 
 	return ACPI_SUCCESS(status) ? 0 : -EFAULT;
 }
@@ -549,7 +550,7 @@ static void acpi_hibernation_leave(void)
 	 */
 	acpi_enable();
 	/* Reprogram control registers and execute _BFS */
-	acpi_leave_sleep_state_prep(ACPI_STATE_S4);
+	acpi_leave_sleep_state_prep(ACPI_STATE_S4, ACPI_NO_OPTIONAL_METHODS);
 	/* Check the hardware signature */
 	if (facs && s4_hardware_signature != facs->hardware_signature) {
 		printk(KERN_EMERG "ACPI: Hardware changed while hibernated, "
@@ -773,7 +774,7 @@ static void acpi_power_off(void)
 	/* acpi_sleep_prepare(ACPI_STATE_S5) should have already been called */
 	printk(KERN_DEBUG "%s called\n", __func__);
 	local_irq_disable();
-	acpi_enter_sleep_state(ACPI_STATE_S5);
+	acpi_enter_sleep_state(ACPI_STATE_S5, ACPI_NO_OPTIONAL_METHODS);
 }
 
 /*

commit 4efeeecd884de36b77c64489dee7eb7ca4d6bed0
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Mar 21 09:42:45 2012 +0800

    ACPICA: Clarify METHOD_NAME* defines for full-pathname cases
    
    Changed the METHOD_NAME* defines that define a full pathname to
    the method to METHOD_PATHNAME* in order to make it clear that
    it is not a simple 4-character ACPI name. Used for the various
    sleep/wake methods.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index ca191ff97844..4fda549fa599 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -788,13 +788,13 @@ static void __init acpi_gts_bfs_check(void)
 {
 	acpi_handle dummy;
 
-	if (ACPI_SUCCESS(acpi_get_handle(ACPI_ROOT_OBJECT, METHOD_NAME__GTS, &dummy)))
+	if (ACPI_SUCCESS(acpi_get_handle(ACPI_ROOT_OBJECT, METHOD_PATHNAME__GTS, &dummy)))
 	{
 		printk(KERN_NOTICE PREFIX "BIOS offers _GTS\n");
 		printk(KERN_NOTICE PREFIX "If \"acpi.gts=1\" improves suspend, "
 			"please notify linux-acpi@vger.kernel.org\n");
 	}
-	if (ACPI_SUCCESS(acpi_get_handle(ACPI_ROOT_OBJECT, METHOD_NAME__BFS, &dummy)))
+	if (ACPI_SUCCESS(acpi_get_handle(ACPI_ROOT_OBJECT, METHOD_PATHNAME__BFS, &dummy)))
 	{
 		printk(KERN_NOTICE PREFIX "BIOS offers _BFS\n");
 		printk(KERN_NOTICE PREFIX "If \"acpi.bfs=1\" improves resume, "

commit 93f770846e8dedc5d9117bd4ad9d7efd18420627
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Sat Jan 21 09:23:56 2012 +0800

    ACPI / PM: Add Sony Vaio VPCCW29FX to nonvs blacklist.
    
    Sony Vaio VPCCW29FX does not resume correctly without
    acpi_sleep=nonvs, so add it to the ACPI sleep blacklist.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=34722
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 0a7ed69546ba..ca191ff97844 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -438,6 +438,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 	},
 	{
 	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VPCCW29FX",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VPCCW29FX"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
 	.ident = "Averatec AV1020-ED2",
 	.matches = {
 		DMI_MATCH(DMI_SYS_VENDOR, "AVERATEC"),

commit 5a50a7c32d630d6cdb13d69afabb0cc81b2f379c
Author: Keng-Yu Lin <kengyu@canonical.com>
Date:   Fri Dec 2 00:04:23 2011 +0100

    ACPI / PM: Do not save/restore NVS on Asus K54C/K54HR
    
    The models do not resume correctly without acpi_sleep=nonvs.
    
    Signed-off-by: Keng-Yu Lin <kengyu@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 6d9a3ab58db2..0a7ed69546ba 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -476,6 +476,22 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-FW520F"),
 		},
 	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Asus K54C",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
+		DMI_MATCH(DMI_PRODUCT_NAME, "K54C"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Asus K54HR",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
+		DMI_MATCH(DMI_PRODUCT_NAME, "K54HR"),
+		},
+	},
 	{},
 };
 #endif /* CONFIG_SUSPEND */

commit ddf6ce45a7b1193f3cf20ad234f35af3b998b8f8
Author: Dave Jones <davej@redhat.com>
Date:   Thu Nov 3 00:58:59 2011 +0100

    ACPI / PM: Add Sony VPCEB17FX to nonvs blacklist
    
    Another entry for the nonvs blacklist, as noted by a user in
    https://bugzilla.redhat.com/show_bug.cgi?id=641789#c12
    
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 0e46faef1d30..6d9a3ab58db2 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -398,6 +398,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 	},
 	{
 	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VPCEB17FX",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VPCEB17FX"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
 	.ident = "Sony Vaio VGN-SR11M",
 	.matches = {
 		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),

commit d11c78e97e1d46a93eb468794da82a090143a72e
Author: Dave Jones <davej@redhat.com>
Date:   Wed Oct 19 23:15:11 2011 +0200

    ACPI / PM: Add Sony VGN-FW21E to nonvs blacklist.
    
    As noted by a user in https://bugzilla.redhat.com/show_bug.cgi?id=641789
    The Sony VGN-FW21E also needs the nonvs by default workaround added.
    
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 28a3e96a902d..0e46faef1d30 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -390,6 +390,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 	},
 	{
 	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VGN-FW21E",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-FW21E"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
 	.ident = "Sony Vaio VGN-SR11M",
 	.matches = {
 		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),

commit 731b25a4ad3c27b44f3447382da18b59167eb7a1
Author: Bogdan Radulescu <bogdan@nimblex.net>
Date:   Thu Oct 6 20:35:12 2011 +0200

    PM / ACPI: Blacklist Vaio VGN-FW520F machine known to require acpi_sleep=nonvs
    
    Sony Vaio VGN-FW520F does not resume correctly without
    acpi_sleep=nonvs, so add it to the ACPI sleep blacklist.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=16396#c86
    Signed-off-by: Bogdan Radulescu <bogdan@nimblex.net>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 8c3e514a343f..28a3e96a902d 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -452,6 +452,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-SR26GN_P"),
 		},
 	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VGN-FW520F",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-FW520F"),
+		},
+	},
 	{},
 };
 #endif /* CONFIG_SUSPEND */

commit 89e8ea1278fb3b237159a1ca193002ef5c8652d8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 6 20:35:03 2011 +0200

    PM / ACPI: Blacklist Sony Vaio known to require acpi_sleep=nonvs
    
    Apparently, Sony Vaio VGN-SR26GN_P does not resume correctly without
    acpi_sleep=nonvs, so add it to the ACPI sleep blacklist.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=16396#c91
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 3ed80b2ca907..8c3e514a343f 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -444,6 +444,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		DMI_MATCH(DMI_BOARD_NAME, "A8N-SLI Premium"),
 		},
 	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VGN-SR26GN_P",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-SR26GN_P"),
+		},
+	},
 	{},
 };
 #endif /* CONFIG_SUSPEND */

commit bb0c5ed6ec523199e34e81dcef8e987507553b63
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Sat Jul 30 01:40:48 2011 -0400

    ACPI: DMI workaround for Asus A8N-SLI Premium and Asus A8N-SLI DELUX
    
    DMI workaround for A8N-SLI Premium and A8N-SLI DELUXE
    to enable the s3 suspend old ordering.
    http://bugzilla.kernel.org/show_bug.cgi?id=9528
    
    Tested-by: Heiko Ettelbrück <hbruckynews@gmx.de>
    Tested-by: Brian Beardall <brian@rapsure.net>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 6c949602cbd1..3ed80b2ca907 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -428,6 +428,22 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		DMI_MATCH(DMI_PRODUCT_NAME, "1000 Series"),
 		},
 	},
+	{
+	.callback = init_old_suspend_ordering,
+	.ident = "Asus A8N-SLI DELUXE",
+	.matches = {
+		DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC."),
+		DMI_MATCH(DMI_BOARD_NAME, "A8N-SLI DELUXE"),
+		},
+	},
+	{
+	.callback = init_old_suspend_ordering,
+	.ident = "Asus A8N-SLI Premium",
+	.matches = {
+		DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC."),
+		DMI_MATCH(DMI_BOARD_NAME, "A8N-SLI Premium"),
+		},
+	},
 	{},
 };
 #endif /* CONFIG_SUSPEND */

commit 02e2407858fd62053bf60349c0e72cd1c7a4a60e
Merge: 96e1c408ea8a 6447f55da90b
Author: Len Brown <len.brown@intel.com>
Date:   Wed Mar 23 02:34:54 2011 -0400

    Merge branch 'linus' into release
    
    Conflicts:
            arch/x86/kernel/acpi/sleep.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit e7fd3b4669f5b835c8afce28425d9f698a558115
Merge: fc82e1d59a24 2ae9d293b14d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 16 10:10:02 2011 -0700

    Merge branch 'x86-trampoline-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-trampoline-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86: Fix binutils-2.21 symbol related build failures
      x86-64, trampoline: Remove unused variable
      x86, reboot: Fix the use of passed arguments in 32-bit BIOS reboot
      x86, reboot: Move the real-mode reboot code to an assembly file
      x86: Make the GDT_ENTRY() macro in <asm/segment.h> safe for assembly
      x86, trampoline: Use the unified trampoline setup for ACPI wakeup
      x86, trampoline: Common infrastructure for low memory trampolines
    
    Fix up trivial conflicts in arch/x86/kernel/Makefile

commit aa33860158114d0df3c7997bc1dd41c0168e1c2a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Feb 11 00:06:54 2011 +0100

    PM: Remove CONFIG_PM_OPS
    
    After redefining CONFIG_PM to depend on (CONFIG_PM_SLEEP ||
    CONFIG_PM_RUNTIME) the CONFIG_PM_OPS option is redundant and can be
    replaced with CONFIG_PM.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index d6a8cd14de2e..8ea092fad3f6 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -585,7 +585,7 @@ int acpi_suspend(u32 acpi_state)
 	return -EINVAL;
 }
 
-#ifdef CONFIG_PM_OPS
+#ifdef CONFIG_PM
 /**
  *	acpi_pm_device_sleep_state - return preferred power state of ACPI device
  *		in the system sleep state given by %acpi_target_sleep_state
@@ -671,7 +671,7 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p)
 		*d_min_p = d_min;
 	return d_max;
 }
-#endif /* CONFIG_PM_OPS */
+#endif /* CONFIG_PM */
 
 #ifdef CONFIG_PM_SLEEP
 /**

commit aad83b143008e1d406248803550bfbfc600b6398
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:42:35 2011 +0100

    ACPI / PM: acpi_hibernation_enter() need not switch interrupts off
    
    The function acpi_hibernation_enter() is always called with
    interrupts off, so it doesn't need to switch them off and on.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 0a81bf11f473..84f57143ad7c 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -457,16 +457,13 @@ static int acpi_hibernation_begin(void)
 static int acpi_hibernation_enter(void)
 {
 	acpi_status status = AE_OK;
-	unsigned long flags = 0;
 
 	ACPI_FLUSH_CPU_CACHE();
 
-	local_irq_save(flags);
 	/* This shouldn't return.  If it returns, we have a problem */
 	status = acpi_enter_sleep_state(ACPI_STATE_S4);
 	/* Reprogram control registers and execute _BFS */
 	acpi_leave_sleep_state_prep(ACPI_STATE_S4);
-	local_irq_restore(flags);
 
 	return ACPI_SUCCESS(status) ? 0 : -EFAULT;
 }

commit f1a2003e22f6b50ea21f7f4b38b38c5ebc9c8017
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:42:22 2011 +0100

    ACPI / PM: Merge do_suspend_lowlevel() into acpi_save_state_mem()
    
    The function do_suspend_lowlevel() is specific to x86 and defined in
    assembly code, so it should be called from the x86 low-level suspend
    code rather than from acpi_suspend_enter().
    
    Merge do_suspend_lowlevel() into the x86's acpi_save_state_mem() and
    change the name of the latter to acpi_suspend_lowlevel(), so that the
    function's purpose is better reflected by its name.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 2307604064b3..0a81bf11f473 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -199,8 +199,6 @@ static void acpi_pm_end(void)
 #endif /* CONFIG_ACPI_SLEEP */
 
 #ifdef CONFIG_SUSPEND
-extern void do_suspend_lowlevel(void);
-
 static u32 acpi_suspend_states[] = {
 	[PM_SUSPEND_ON] = ACPI_STATE_S0,
 	[PM_SUSPEND_STANDBY] = ACPI_STATE_S1,
@@ -255,10 +253,9 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 		break;
 
 	case ACPI_STATE_S3:
-		error = acpi_save_state_mem();
+		error = acpi_suspend_lowlevel();
 		if (error)
 			return error;
-		do_suspend_lowlevel();
 		pr_info(PREFIX "Low-level resume complete\n");
 		break;
 	}

commit 979f11b060c0b35b03b86ae854d6f21a710305d0
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:42:09 2011 +0100

    ACPI / PM: Call acpi_save_state_mem() right before low-level suspend
    
    Since acpi_save_state_mem() is only called by acpi_suspend_enter()
    if the target sleep state is S3, it's better to call it under the
    switch (acpi_state), right before do_suspend_lowlevel().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 6bea2fe8434b..2307604064b3 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -244,17 +244,10 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 {
 	acpi_status status = AE_OK;
 	u32 acpi_state = acpi_target_sleep_state;
+	int error;
 
 	ACPI_FLUSH_CPU_CACHE();
 
-	/* Do arch specific saving of state. */
-	if (acpi_state == ACPI_STATE_S3) {
-		int error = acpi_save_state_mem();
-
-		if (error)
-			return error;
-	}
-
 	switch (acpi_state) {
 	case ACPI_STATE_S1:
 		barrier();
@@ -262,6 +255,9 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 		break;
 
 	case ACPI_STATE_S3:
+		error = acpi_save_state_mem();
+		if (error)
+			return error;
 		do_suspend_lowlevel();
 		pr_info(PREFIX "Low-level resume complete\n");
 		break;

commit 7a63f08b2b904d25e966dd0e15c9af4a13c80b90
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:41:57 2011 +0100

    ACPI / PM: Modify the "low-level resume finished" message
    
    Move the low-level resume completion message to the point where
    control goes back to acpi_suspend_enter() during resume and change
    it so that it's more informative.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 3b549379801a..6bea2fe8434b 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -263,6 +263,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 
 	case ACPI_STATE_S3:
 		do_suspend_lowlevel();
+		pr_info(PREFIX "Low-level resume complete\n");
 		break;
 	}
 
@@ -288,8 +289,6 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	/* Allow EC transactions to happen. */
 	acpi_ec_unblock_transactions_early();
 
-	printk(KERN_DEBUG "Back to C!\n");
-
 	suspend_nvs_restore();
 
 	return ACPI_SUCCESS(status) ? 0 : -EFAULT;

commit 82911fe1988fadfc9c01673202cbc411aa803244
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:41:47 2011 +0100

    ACPI / PM: acpi_suspend_enter() need not switch interrupts off
    
    The function acpi_suspend_enter() is always called with interrupts
    off, so it doesn't need to switch them off and on.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 67dcd3886563..3b549379801a 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -243,7 +243,6 @@ static int acpi_suspend_begin(suspend_state_t pm_state)
 static int acpi_suspend_enter(suspend_state_t pm_state)
 {
 	acpi_status status = AE_OK;
-	unsigned long flags = 0;
 	u32 acpi_state = acpi_target_sleep_state;
 
 	ACPI_FLUSH_CPU_CACHE();
@@ -256,7 +255,6 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 			return error;
 	}
 
-	local_irq_save(flags);
 	switch (acpi_state) {
 	case ACPI_STATE_S1:
 		barrier();
@@ -290,7 +288,6 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	/* Allow EC transactions to happen. */
 	acpi_ec_unblock_transactions_early();
 
-	local_irq_restore(flags);
 	printk(KERN_DEBUG "Back to C!\n");
 
 	suspend_nvs_restore();

commit c41b93fb8551148a93d3bba870365e8489317f02
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:41:35 2011 +0100

    ACPI / PM: Drop acpi_restore_state_mem()
    
    The function acpi_restore_state_mem() has never been and most likely
    never will be used, so remove it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index d6a8cd14de2e..67dcd3886563 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -293,10 +293,6 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	local_irq_restore(flags);
 	printk(KERN_DEBUG "Back to C!\n");
 
-	/* restore processor state */
-	if (acpi_state == ACPI_STATE_S3)
-		acpi_restore_state_mem();
-
 	suspend_nvs_restore();
 
 	return ACPI_SUCCESS(status) ? 0 : -EFAULT;

commit d1ee433539ea5963a8f946f3428b335d1c5fdb20
Author: H. Peter Anvin <hpa@linux.intel.com>
Date:   Mon Feb 14 15:42:46 2011 -0800

    x86, trampoline: Use the unified trampoline setup for ACPI wakeup
    
    Use the unified trampoline allocation setup to allocate and install
    the ACPI wakeup code in low memory.
    
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
    LKML-Reference: <4D5DFBE4.7090104@intel.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Matthieu Castet <castet.matthieu@free.fr>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index d6a8cd14de2e..e9fef94d1039 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -16,6 +16,7 @@
 #include <linux/device.h>
 #include <linux/suspend.h>
 #include <linux/reboot.h>
+#include <linux/acpi.h>
 
 #include <asm/io.h>
 

commit d551d81d6a720542873f478def60baab6b5df403
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jan 19 22:27:55 2011 +0100

    ACPI / PM: Call suspend_nvs_free() earlier during resume
    
    It turns out that some device drivers map pages from the ACPI NVS region
    during resume using ioremap(), which conflicts with ioremap_cache() used
    for mapping those pages by the NVS save/restore code in nvs.c.
    
    Make the NVS pages mapped by the code in nvs.c be unmapped before device
    drivers' resume routines run.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index fdd3aeeb6def..d6a8cd14de2e 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -166,6 +166,7 @@ static void acpi_pm_finish(void)
 	u32 acpi_state = acpi_target_sleep_state;
 
 	acpi_ec_unblock_transactions();
+	suspend_nvs_free();
 
 	if (acpi_state == ACPI_STATE_S0)
 		return;
@@ -186,7 +187,6 @@ static void acpi_pm_finish(void)
  */
 static void acpi_pm_end(void)
 {
-	suspend_nvs_free();
 	/*
 	 * This is necessary in case acpi_pm_finish() is not called during a
 	 * failing transition to a sleep state.

commit 52cfd503ad7176d23a5dd7af3981744feb60622f
Merge: dc8e7e3ec60b 4263d9a3ae4d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 13 20:15:35 2011 -0800

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6: (59 commits)
      ACPI / PM: Fix build problems for !CONFIG_ACPI related to NVS rework
      ACPI: fix resource check message
      ACPI / Battery: Update information on info notification and resume
      ACPI: Drop device flag wake_capable
      ACPI: Always check if _PRW is present before trying to evaluate it
      ACPI / PM: Check status of power resources under mutexes
      ACPI / PM: Rename acpi_power_off_device()
      ACPI / PM: Drop acpi_power_nocheck
      ACPI / PM: Drop acpi_bus_get_power()
      Platform / x86: Make fujitsu_laptop use acpi_bus_update_power()
      ACPI / Fan: Rework the handling of power resources
      ACPI / PM: Register power resource devices as soon as they are needed
      ACPI / PM: Register acpi_power_driver early
      ACPI / PM: Add function for updating device power state consistently
      ACPI / PM: Add function for device power state initialization
      ACPI / PM: Introduce __acpi_bus_get_power()
      ACPI / PM: Introduce function for refcounting device power resources
      ACPI / PM: Add functions for manipulating lists of power resources
      ACPI / PM: Prevent acpi_power_get_inferred_state() from making changes
      ACPICA: Update version to 20101209
      ...

commit d16675e1f1de98cc73ae77c6df26154ffae6230a
Merge: fb4af417cce9 6d5bbf00d251
Author: Len Brown <len.brown@intel.com>
Date:   Wed Jan 12 04:56:08 2011 -0500

    Merge branch 'suspend-ioremap-cache' into release

commit 7b330707dddab1ad772898c1c82516342a551173
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jan 6 23:37:01 2011 +0100

    ACPI / PM: Blacklist Averatec machine known to require acpi_sleep=nonvs
    
    Apparently, Averatec AV1020-ED2 does not resume correctly without
    acpi_sleep=nonvs, so add it to the ACPI sleep blacklist.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=16396#c86
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index febb153b5a68..ddc5cce508a1 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -435,6 +435,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-NW130D"),
 		},
 	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Averatec AV1020-ED2",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "AVERATEC"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "1000 Series"),
+		},
+	},
 	{},
 };
 #endif /* CONFIG_SUSPEND */

commit 26fcaf60fe3861409eb4c455c5c0d0f00f599b08
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Fri Jan 7 01:42:31 2011 +0100

    PM: Fix oops in suspend/hibernate code related to failing ioremap()
    
    When ioremap() fails (which might happen for some reason), we nicely
    oops in suspend_nvs_save() due to NULL dereference by memcpy() in there.
    Fail gracefully instead.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index febb153b5a68..d8bca6c90719 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -124,8 +124,7 @@ static int acpi_pm_freeze(void)
 static int acpi_pm_pre_suspend(void)
 {
 	acpi_pm_freeze();
-	suspend_nvs_save();
-	return 0;
+	return suspend_nvs_save();
 }
 
 /**
@@ -151,7 +150,7 @@ static int acpi_pm_prepare(void)
 {
 	int error = __acpi_pm_prepare();
 	if (!error)
-		acpi_pm_pre_suspend();
+		error = acpi_pm_pre_suspend();
 
 	return error;
 }

commit 4b7bd364700d9ac8372eff48832062b936d0793b
Merge: c0d8768af260 90a8a73c06cc
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Dec 22 18:57:02 2010 +0100

    Merge branch 'master' into for-next
    
    Conflicts:
            MAINTAINERS
            arch/arm/mach-omap2/pm24xx.c
            drivers/scsi/bfa/bfa_fcpim.c
    
    Needed to update to apply fixes for which the old branch was too
    outdated.

commit 23437b5c50f523a87ca5c02fd883b069ca8be7f3
Merge: 6cc5615f7c4d 291a73c9be15
Author: Len Brown <len.brown@intel.com>
Date:   Mon Dec 13 22:40:54 2010 -0500

    Merge branch 'bugzilla-23002' into release

commit 291a73c9be15f12046a7291ec0bf7176a58d4f14
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Dec 12 21:10:42 2010 +0100

    ACPI / PM: Do not save/restore NVS on Sony Vaio VGN-NW130D
    
    The saving of the NVS memory area during suspend and restoring it
    during resume causes problems to appear on Sony Vaio VGN-NW130D, so
    blacklist that machine to avoid those problems.
    
    Addresses https://bugzilla.kernel.org/show_bug.cgi?id=23002
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-and-tested-by: Adriano <adriano.vilela@yahoo.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 721d93b3ceee..d8149424c812 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -427,6 +427,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		DMI_MATCH(DMI_PRODUCT_NAME, "VPCEB1Z1E"),
 		},
 	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VGN-NW130D",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-NW130D"),
+		},
+	},
 	{},
 };
 #endif /* CONFIG_SUSPEND */

commit 091aad6af4ab29af693ced5d6970ceee9d5981c8
Author: Jan Beulich <JBeulich@novell.com>
Date:   Tue Dec 7 14:52:25 2010 +0000

    ACPI: eliminate unused variable warning for !ACPI_SLEEP
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 721d93b3ceee..2182c5579230 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -27,8 +27,6 @@
 
 static u8 sleep_states[ACPI_S_STATE_COUNT];
 
-static u32 acpi_target_sleep_state = ACPI_STATE_S0;
-
 static void acpi_sleep_tts_switch(u32 acpi_state)
 {
 	union acpi_object in_arg = { ACPI_TYPE_INTEGER };
@@ -81,6 +79,8 @@ static int acpi_sleep_prepare(u32 acpi_state)
 }
 
 #ifdef CONFIG_ACPI_SLEEP
+static u32 acpi_target_sleep_state = ACPI_STATE_S0;
+
 /*
  * The ACPI specification wants us to save NVS memory regions during hibernation
  * and to restore them during the subsequent resume.  Windows does that also for

commit 2f55ac072f5344519348c0c94b3d2f4cca46847b
Author: Lionel Debroux <lionel_debroux@yahoo.fr>
Date:   Tue Nov 16 14:14:02 2010 +0100

    suspend: constify platform_suspend_ops
    
    While at it, fix two checkpatch errors.
    Several non-const struct instances constified by this patch were added after
    the introduction of platform_suspend_ops in checkpatch.pl's list of "should
    be const" structs (79404849e90a41ea2109bd0e2f7c7164b0c4ce73).
    
    Patch against mainline.
    Inspired by hunks of the grsecurity patch, updated for newer kernels.
    
    Signed-off-by: Lionel Debroux <lionel_debroux@yahoo.fr>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 5149c9bf7015..ba1caf724a16 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -319,7 +319,7 @@ static int acpi_suspend_state_valid(suspend_state_t pm_state)
 	}
 }
 
-static struct platform_suspend_ops acpi_suspend_ops = {
+static const struct platform_suspend_ops acpi_suspend_ops = {
 	.valid = acpi_suspend_state_valid,
 	.begin = acpi_suspend_begin,
 	.prepare_late = acpi_pm_prepare,
@@ -347,7 +347,7 @@ static int acpi_suspend_begin_old(suspend_state_t pm_state)
  * The following callbacks are used if the pre-ACPI 2.0 suspend ordering has
  * been requested.
  */
-static struct platform_suspend_ops acpi_suspend_ops_old = {
+static const struct platform_suspend_ops acpi_suspend_ops_old = {
 	.valid = acpi_suspend_state_valid,
 	.begin = acpi_suspend_begin_old,
 	.prepare_late = acpi_pm_pre_suspend,

commit 073ef1f6e508688392580e4f35dcad9aabd1e100
Author: Lionel Debroux <lionel_debroux@yahoo.fr>
Date:   Tue Nov 9 21:48:49 2010 +0100

    hibernation: constify platform_hibernation_ops
    
    Patch against mainline.
    
    Changes since v1: added one hunk; no longer adding "const" qualifier to
    pointers in platform_hibernation_ops after seeing
    b4144e4f6e3b448d322095ca08af393682a69e33.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 721d93b3ceee..5149c9bf7015 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -498,7 +498,7 @@ static void acpi_pm_thaw(void)
 	acpi_enable_all_runtime_gpes();
 }
 
-static struct platform_hibernation_ops acpi_hibernation_ops = {
+static const struct platform_hibernation_ops acpi_hibernation_ops = {
 	.begin = acpi_hibernation_begin,
 	.end = acpi_pm_end,
 	.pre_snapshot = acpi_pm_prepare,
@@ -541,7 +541,7 @@ static int acpi_hibernation_begin_old(void)
  * The following callbacks are used if the pre-ACPI 2.0 suspend ordering has
  * been requested.
  */
-static struct platform_hibernation_ops acpi_hibernation_ops_old = {
+static const struct platform_hibernation_ops acpi_hibernation_ops_old = {
 	.begin = acpi_hibernation_begin_old,
 	.end = acpi_pm_end,
 	.pre_snapshot = acpi_pm_pre_suspend,

commit 7e31842441776b4d6ec7fd916c91663ad05b7814
Merge: 1bd64d42abdd b1d248d96c71
Author: Len Brown <len.brown@intel.com>
Date:   Tue Oct 26 14:51:00 2010 -0400

    Merge branch 'misc' into release

commit af48931c4863ced64cc52c58757be6e254437f9a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Oct 17 21:01:21 2010 +0200

    ACPI / PM: Blacklist another machine that needs acpi_sleep=nonvs
    
    Sony Vaio VPCEB1Z1E is reported to require acpi_sleep=nonvs for
    suspend/resume to work on it correctly, so blacklist it.
    
    Reported-by: Emanuele Bigiarini <pulmro@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index b9af2c2ff926..05dc42c2a46b 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -419,6 +419,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		DMI_MATCH(DMI_PRODUCT_NAME, "Everex StepNote Series"),
 		},
 	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VPCEB1Z1E",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VPCEB1Z1E"),
+		},
+	},
 	{},
 };
 #endif /* CONFIG_SUSPEND */

commit 01eac60bccdb0ce49a2937d59da1e4749697a9aa
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Mon Oct 18 18:47:25 2010 -0700

    ACPI: static sleep_states[] and acpi_gts_bfs_check
    
    Only used in one file so should be static.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 4754ff6e70e6..b9af2c2ff926 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -25,7 +25,7 @@
 #include "internal.h"
 #include "sleep.h"
 
-u8 sleep_states[ACPI_S_STATE_COUNT];
+static u8 sleep_states[ACPI_S_STATE_COUNT];
 
 static void acpi_sleep_tts_switch(u32 acpi_state)
 {
@@ -702,7 +702,7 @@ static void acpi_power_off(void)
  * paths through the BIOS, so disable _GTS and _BFS by default,
  * but do speak up and offer the option to enable them.
  */
-void __init acpi_gts_bfs_check(void)
+static void __init acpi_gts_bfs_check(void)
 {
 	acpi_handle dummy;
 

commit 761afb869f649ea23e2dea7bfe9b550d3a1b7631
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 14 23:24:13 2010 +0200

    ACPI / PM: Fix problems with acpi_pm_device_sleep_state()
    
    There is a number of problems with acpi_pm_device_sleep_state() now.
    First, if _S0W is not defined, it prevents devices from being put
    into D3 by PCI runtime PM, which shouldn't happen.  Second, it
    shouldn't use adev->wakeup.state.enabled, because if it's set, it
    only means that either the device is permanently enabled to wake up
    the system, or that it has been enabled to do that through
    /proc/acpi/wakeup.  Finally, it should be compiled if CONFIG_PM_SLEEP
    is not set, so that PCI runtime PM works correctly in that case.
    Fix these problems.
    
    Reported-by: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 4754ff6e70e6..e807f4196f89 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -27,6 +27,8 @@
 
 u8 sleep_states[ACPI_S_STATE_COUNT];
 
+static u32 acpi_target_sleep_state = ACPI_STATE_S0;
+
 static void acpi_sleep_tts_switch(u32 acpi_state)
 {
 	union acpi_object in_arg = { ACPI_TYPE_INTEGER };
@@ -79,8 +81,6 @@ static int acpi_sleep_prepare(u32 acpi_state)
 }
 
 #ifdef CONFIG_ACPI_SLEEP
-static u32 acpi_target_sleep_state = ACPI_STATE_S0;
-
 /*
  * The ACPI specification wants us to save NVS memory regions during hibernation
  * and to restore them during the subsequent resume.  Windows does that also for
@@ -562,7 +562,7 @@ int acpi_suspend(u32 acpi_state)
 	return -EINVAL;
 }
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM_OPS
 /**
  *	acpi_pm_device_sleep_state - return preferred power state of ACPI device
  *		in the system sleep state given by %acpi_target_sleep_state
@@ -624,7 +624,7 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p)
 	 * can wake the system.  _S0W may be valid, too.
 	 */
 	if (acpi_target_sleep_state == ACPI_STATE_S0 ||
-	    (device_may_wakeup(dev) && adev->wakeup.state.enabled &&
+	    (device_may_wakeup(dev) &&
 	     adev->wakeup.sleep_state <= acpi_target_sleep_state)) {
 		acpi_status status;
 
@@ -632,7 +632,9 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p)
 		status = acpi_evaluate_integer(handle, acpi_method, NULL,
 						&d_max);
 		if (ACPI_FAILURE(status)) {
-			d_max = d_min;
+			if (acpi_target_sleep_state != ACPI_STATE_S0 ||
+			    status != AE_NOT_FOUND)
+				d_max = d_min;
 		} else if (d_max < d_min) {
 			/* Warn the user of the broken DSDT */
 			printk(KERN_WARNING "ACPI: Wrong value from %s\n",
@@ -646,7 +648,9 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p)
 		*d_min_p = d_min;
 	return d_max;
 }
+#endif /* CONFIG_PM_OPS */
 
+#ifdef CONFIG_PM_SLEEP
 /**
  *	acpi_pm_device_sleep_wake - enable or disable the system wake-up
  *                                  capability of given device
@@ -677,7 +681,7 @@ int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
 
 	return error;
 }
-#endif
+#endif  /* CONFIG_PM_SLEEP */
 
 static void acpi_power_off_prepare(void)
 {

commit 539986482b0db07b7164ab086d167ab99b4d3061
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Sep 24 16:46:14 2010 -0400

    PM / ACPI: Blacklist systems known to require acpi_sleep=nonvs
    
    Commit 2a6b69765ad794389f2fc3e14a0afa1a995221c2 (ACPI: Store NVS
    state even when entering suspend to RAM) changed the ACPI suspend
    to RAM code so that the NVS memory area is always unconditionally
    saved during suspend and restored during resume, since some systems
    evidently need that for the suspend-resume to work on them.  However,
    it turned out that this change broke suspend-resume on a few systems,
    so commit 72ad5d77fb981963edae15eee8196c80238f5ed0 (ACPI / Sleep:
    Allow the NVS saving to be skipped during suspend to RAM) introduced
    the acpi_sleep=nonvs command line switch to allow their users to
    work around this issue.  To keep track of the systems that require
    this workaround and to make the life of their users slightly easier
    blacklist them in acpisleep_dmi_table[].
    
    https://bugzilla.kernel.org/show_bug.cgi?id=16396
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index cf82989ae756..4754ff6e70e6 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -363,6 +363,12 @@ static int __init init_old_suspend_ordering(const struct dmi_system_id *d)
 	return 0;
 }
 
+static int __init init_nvs_nosave(const struct dmi_system_id *d)
+{
+	acpi_nvs_nosave();
+	return 0;
+}
+
 static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 	{
 	.callback = init_old_suspend_ordering,
@@ -397,6 +403,22 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		DMI_MATCH(DMI_BOARD_NAME, "CF51-2L"),
 		},
 	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VGN-SR11M",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-SR11M"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Everex StepNote Series",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Everex Systems, Inc."),
+		DMI_MATCH(DMI_PRODUCT_NAME, "Everex StepNote Series"),
+		},
+	},
 	{},
 };
 #endif /* CONFIG_SUSPEND */

commit c172cb73bc79fe69915b1a1a48e374aa4b1f8a59
Merge: e8eb6228094b 28f4f8a9def2
Author: Len Brown <len.brown@intel.com>
Date:   Sun Aug 15 00:25:40 2010 -0400

    Merge branch 'acpica-gpe' into release

commit f2a66185bed21427d8d347a42eaf0ad1d3d9fc63
Merge: 9fe6206f4006 618d7fd0d4e5
Author: Len Brown <len.brown@intel.com>
Date:   Sat Aug 14 23:55:44 2010 -0400

    Merge branch 'nvs' into release

commit 72ad5d77fb981963edae15eee8196c80238f5ed0
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jul 23 22:59:09 2010 +0200

    ACPI / Sleep: Allow the NVS saving to be skipped during suspend to RAM
    
    Commit 2a6b69765ad794389f2fc3e14a0afa1a995221c2
    (ACPI: Store NVS state even when entering suspend to RAM) caused the
    ACPI suspend code save the NVS area during suspend and restore it
    during resume unconditionally, although it is known that some systems
    need to use acpi_sleep=s4_nonvs for hibernation to work.  To allow
    the affected systems to avoid saving and restoring the NVS area
    during suspend to RAM and resume, introduce kernel command line
    option acpi_sleep=nonvs and make acpi_sleep=s4_nonvs work as its
    alias temporarily (add acpi_sleep=s4_nonvs to the feature removal
    file).
    
    Addresses https://bugzilla.kernel.org/show_bug.cgi?id=16396 .
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-and-tested-by: tomas m <tmezzadra@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 5b7c52e4a00f..2862c781b372 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -81,6 +81,20 @@ static int acpi_sleep_prepare(u32 acpi_state)
 #ifdef CONFIG_ACPI_SLEEP
 static u32 acpi_target_sleep_state = ACPI_STATE_S0;
 
+/*
+ * The ACPI specification wants us to save NVS memory regions during hibernation
+ * and to restore them during the subsequent resume.  Windows does that also for
+ * suspend to RAM.  However, it is known that this mechanism does not work on
+ * all machines, so we allow the user to disable it with the help of the
+ * 'acpi_sleep=nonvs' kernel command line option.
+ */
+static bool nvs_nosave;
+
+void __init acpi_nvs_nosave(void)
+{
+	nvs_nosave = true;
+}
+
 /*
  * ACPI 1.0 wants us to execute _PTS before suspending devices, so we allow the
  * user to request that behavior by using the 'acpi_old_suspend_ordering'
@@ -197,8 +211,7 @@ static int acpi_suspend_begin(suspend_state_t pm_state)
 	u32 acpi_state = acpi_suspend_states[pm_state];
 	int error = 0;
 
-	error = suspend_nvs_alloc();
-
+	error = nvs_nosave ? 0 : suspend_nvs_alloc();
 	if (error)
 		return error;
 
@@ -388,20 +401,6 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 #endif /* CONFIG_SUSPEND */
 
 #ifdef CONFIG_HIBERNATION
-/*
- * The ACPI specification wants us to save NVS memory regions during hibernation
- * and to restore them during the subsequent resume.  However, it is not certain
- * if this mechanism is going to work on all machines, so we allow the user to
- * disable this mechanism using the 'acpi_sleep=s4_nonvs' kernel command line
- * option.
- */
-static bool s4_no_nvs;
-
-void __init acpi_s4_no_nvs(void)
-{
-	s4_no_nvs = true;
-}
-
 static unsigned long s4_hardware_signature;
 static struct acpi_table_facs *facs;
 static bool nosigcheck;
@@ -415,7 +414,7 @@ static int acpi_hibernation_begin(void)
 {
 	int error;
 
-	error = s4_no_nvs ? 0 : suspend_nvs_alloc();
+	error = nvs_nosave ? 0 : suspend_nvs_alloc();
 	if (!error) {
 		acpi_target_sleep_state = ACPI_STATE_S4;
 		acpi_sleep_tts_switch(acpi_target_sleep_state);
@@ -510,7 +509,7 @@ static int acpi_hibernation_begin_old(void)
 	error = acpi_sleep_prepare(ACPI_STATE_S4);
 
 	if (!error) {
-		if (!s4_no_nvs)
+		if (!nvs_nosave)
 			error = suspend_nvs_alloc();
 		if (!error)
 			acpi_target_sleep_state = ACPI_STATE_S4;

commit e8b6f970107cfc9c00cdcdb12ec6c7e135cf379f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jun 25 01:18:39 2010 +0200

    ACPICA: Introduce acpi_gpe_wakeup()
    
    ACPICA uses reference counters to avoid disabling GPEs too early in
    case they have been enabled for many times.  This is done separately
    for runtime and for wakeup, but the wakeup GPE reference counter is
    not really necessary, because GPEs are only enabled to wake up the
    system at the hardware level by acpi_enter_sleep_state().  Thus it
    only is necessary to set the corresponding bits in the wakeup enable
    masks of these GPEs' registers right before the system enters a sleep
    state.  Moreover, the GPE wakeup enable bits can only be set when the
    target sleep state of the system is known and they need to be cleared
    immediately after wakeup regardless of how many wakeup devices are
    associated with a given GPE.
    
    On the basis of the above observations, introduce function
    acpi_gpe_wakeup() to be used for setting or clearing the enable bit
    corresponding to a given GPE in its enable register's enable_for_wake
    mask.  Modify the ACPI suspend and wakeup code the use
    acpi_gpe_wakeup() instead of acpi_{enable|disable}_gpe() to set
    and clear GPE enable bits in their registers' enable_for_wake masks
    during system transitions to a sleep state and back to the working
    state, respectively.  [This will allow us to drop the third
    argument of acpi_{enable|disable}_gpe() and simplify the GPE
    handling code.]
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 5b7c52e4a00f..aaa1af55e280 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -664,18 +664,9 @@ int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
 		return -ENODEV;
 	}
 
-	if (enable) {
-		error = acpi_enable_wakeup_device_power(adev,
-						acpi_target_sleep_state);
-		if (!error)
-			acpi_enable_gpe(adev->wakeup.gpe_device,
-					adev->wakeup.gpe_number,
-					ACPI_GPE_TYPE_WAKE);
-	} else {
-		acpi_disable_gpe(adev->wakeup.gpe_device, adev->wakeup.gpe_number,
-				ACPI_GPE_TYPE_WAKE);
-		error = acpi_disable_wakeup_device_power(adev);
-	}
+	error = enable ?
+		acpi_enable_wakeup_device_power(adev, acpi_target_sleep_state) :
+		acpi_disable_wakeup_device_power(adev);
 	if (!error)
 		dev_info(dev, "wake-up capability %s by ACPI\n",
 				enable ? "enabled" : "disabled");

commit 618d7fd0d4e51a45d25d9bc6097a0cb1e5a2f226
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jul 2 00:14:57 2010 +0200

    ACPI / Sleep: Drop acpi_suspend_finish()
    
    The function acpi_suspend_finish() is not necessary any more, because
    acpi_pm_finish() can be used instead of it just fine.  Remove it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 61c5bd03f733..5529c7023956 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -290,11 +290,6 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	return ACPI_SUCCESS(status) ? 0 : -EFAULT;
 }
 
-static void acpi_suspend_finish(void)
-{
-	acpi_pm_finish();
-}
-
 static int acpi_suspend_state_valid(suspend_state_t pm_state)
 {
 	u32 acpi_state;
@@ -316,7 +311,7 @@ static struct platform_suspend_ops acpi_suspend_ops = {
 	.begin = acpi_suspend_begin,
 	.prepare_late = acpi_pm_prepare,
 	.enter = acpi_suspend_enter,
-	.wake = acpi_suspend_finish,
+	.wake = acpi_pm_finish,
 	.end = acpi_pm_end,
 };
 
@@ -344,7 +339,7 @@ static struct platform_suspend_ops acpi_suspend_ops_old = {
 	.begin = acpi_suspend_begin_old,
 	.prepare_late = acpi_pm_pre_suspend,
 	.enter = acpi_suspend_enter,
-	.wake = acpi_suspend_finish,
+	.wake = acpi_pm_finish,
 	.end = acpi_pm_end,
 	.recover = acpi_pm_finish,
 };

commit c5f7a1bb65bca03253c189e946b3ca79669f08af
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jul 2 00:14:09 2010 +0200

    ACPI / Sleep: Consolidate suspend and hibernation routines
    
    Some hibernation and suspend routines can be merged, which reduces
    the complexity of code a bit.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 93441c95c53b..61c5bd03f733 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -104,6 +104,16 @@ static int acpi_pm_freeze(void)
 	return 0;
 }
 
+/**
+ * acpi_pre_suspend - Enable wakeup devices, "freeze" EC and save NVS.
+ */
+static int acpi_pm_pre_suspend(void)
+{
+	acpi_pm_freeze();
+	suspend_nvs_save();
+	return 0;
+}
+
 /**
  *	__acpi_pm_prepare - Prepare the platform to enter the target state.
  *
@@ -113,11 +123,9 @@ static int acpi_pm_freeze(void)
 static int __acpi_pm_prepare(void)
 {
 	int error = acpi_sleep_prepare(acpi_target_sleep_state);
-
-	suspend_nvs_save();
-
 	if (error)
 		acpi_target_sleep_state = ACPI_STATE_S0;
+
 	return error;
 }
 
@@ -128,9 +136,8 @@ static int __acpi_pm_prepare(void)
 static int acpi_pm_prepare(void)
 {
 	int error = __acpi_pm_prepare();
-
 	if (!error)
-		acpi_pm_freeze();
+		acpi_pm_pre_suspend();
 
 	return error;
 }
@@ -322,9 +329,9 @@ static struct platform_suspend_ops acpi_suspend_ops = {
 static int acpi_suspend_begin_old(suspend_state_t pm_state)
 {
 	int error = acpi_suspend_begin(pm_state);
-
 	if (!error)
 		error = __acpi_pm_prepare();
+
 	return error;
 }
 
@@ -335,7 +342,7 @@ static int acpi_suspend_begin_old(suspend_state_t pm_state)
 static struct platform_suspend_ops acpi_suspend_ops_old = {
 	.valid = acpi_suspend_state_valid,
 	.begin = acpi_suspend_begin_old,
-	.prepare_late = acpi_pm_freeze,
+	.prepare_late = acpi_pm_pre_suspend,
 	.enter = acpi_suspend_enter,
 	.wake = acpi_suspend_finish,
 	.end = acpi_pm_end,
@@ -423,16 +430,6 @@ static int acpi_hibernation_begin(void)
 	return error;
 }
 
-static int acpi_hibernation_pre_snapshot(void)
-{
-	int error = acpi_pm_prepare();
-
-	if (!error)
-		suspend_nvs_save();
-
-	return error;
-}
-
 static int acpi_hibernation_enter(void)
 {
 	acpi_status status = AE_OK;
@@ -480,7 +477,7 @@ static void acpi_pm_thaw(void)
 static struct platform_hibernation_ops acpi_hibernation_ops = {
 	.begin = acpi_hibernation_begin,
 	.end = acpi_pm_end,
-	.pre_snapshot = acpi_hibernation_pre_snapshot,
+	.pre_snapshot = acpi_pm_prepare,
 	.finish = acpi_pm_finish,
 	.prepare = acpi_pm_prepare,
 	.enter = acpi_hibernation_enter,
@@ -516,13 +513,6 @@ static int acpi_hibernation_begin_old(void)
 	return error;
 }
 
-static int acpi_hibernation_pre_snapshot_old(void)
-{
-	acpi_pm_freeze();
-	suspend_nvs_save();
-	return 0;
-}
-
 /*
  * The following callbacks are used if the pre-ACPI 2.0 suspend ordering has
  * been requested.
@@ -530,7 +520,7 @@ static int acpi_hibernation_pre_snapshot_old(void)
 static struct platform_hibernation_ops acpi_hibernation_ops_old = {
 	.begin = acpi_hibernation_begin_old,
 	.end = acpi_pm_end,
-	.pre_snapshot = acpi_hibernation_pre_snapshot_old,
+	.pre_snapshot = acpi_pm_pre_suspend,
 	.prepare = acpi_pm_freeze,
 	.finish = acpi_pm_finish,
 	.enter = acpi_hibernation_enter,

commit 78f5f023167813130d2cf657d1b9eadc32f0e992
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jul 6 22:09:38 2010 -0400

    ACPI / Wakeup: Simplify enabling of wakeup devices
    
    To simplify the enabling of wakeup devices during system suspend and
    hibernation, merge acpi_enable_wakeup_device_prep() with
    acpi_disable_wakeup_device() and remove unnecessary (and no longer
    valid) comments from the latter.  Rename acpi_enable_wakeup_device()
    to acpi_enable_wakeup_devices() and acpi_disable_wakeup_device()
    to acpi_disable_wakeup_devices(), because these functions usually
    operate on multiple device objects.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 8704ca78a8c4..93441c95c53b 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -73,8 +73,7 @@ static int acpi_sleep_prepare(u32 acpi_state)
 #endif
 	printk(KERN_INFO PREFIX "Preparing to enter system sleep state S%d\n",
 		acpi_state);
-	acpi_enable_wakeup_device_prep(acpi_state);
-	acpi_enable_wakeup_device(acpi_state);
+	acpi_enable_wakeup_devices(acpi_state);
 	acpi_enter_sleep_state_prep(acpi_state);
 	return 0;
 }
@@ -153,7 +152,7 @@ static void acpi_pm_finish(void)
 
 	printk(KERN_INFO PREFIX "Waking up from system sleep state S%d\n",
 		acpi_state);
-	acpi_disable_wakeup_device(acpi_state);
+	acpi_disable_wakeup_devices(acpi_state);
 	acpi_leave_sleep_state(acpi_state);
 
 	/* reset firmware waking vector */

commit 25bed55753b8cf243406e8837990b55946c5278d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jul 2 00:12:26 2010 +0200

    ACPI / Sleep: Rework enabling wakeup devices
    
    There is no reason why acpi_enable_wakeup_device() should be called
    with interrupts disabled, because it doesn't access hardware.  Thus
    it is possible to move it next to acpi_enable_wakeup_device_prep()
    and make the ACPI suspend, hibernate and poweroff code more
    straightforward.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index da68ed24f4c5..8704ca78a8c4 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -70,10 +70,11 @@ static int acpi_sleep_prepare(u32 acpi_state)
 
 	}
 	ACPI_FLUSH_CPU_CACHE();
-	acpi_enable_wakeup_device_prep(acpi_state);
 #endif
 	printk(KERN_INFO PREFIX "Preparing to enter system sleep state S%d\n",
 		acpi_state);
+	acpi_enable_wakeup_device_prep(acpi_state);
+	acpi_enable_wakeup_device(acpi_state);
 	acpi_enter_sleep_state_prep(acpi_state);
 	return 0;
 }
@@ -238,7 +239,6 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	}
 
 	local_irq_save(flags);
-	acpi_enable_wakeup_device(acpi_state);
 	switch (acpi_state) {
 	case ACPI_STATE_S1:
 		barrier();
@@ -442,7 +442,6 @@ static int acpi_hibernation_enter(void)
 	ACPI_FLUSH_CPU_CACHE();
 
 	local_irq_save(flags);
-	acpi_enable_wakeup_device(ACPI_STATE_S4);
 	/* This shouldn't return.  If it returns, we have a problem */
 	status = acpi_enter_sleep_state(ACPI_STATE_S4);
 	/* Reprogram control registers and execute _BFS */
@@ -696,7 +695,6 @@ static void acpi_power_off(void)
 	/* acpi_sleep_prepare(ACPI_STATE_S5) should have already been called */
 	printk(KERN_DEBUG "%s called\n", __func__);
 	local_irq_disable();
-	acpi_enable_wakeup_device(ACPI_STATE_S5);
 	acpi_enter_sleep_state(ACPI_STATE_S5);
 }
 

commit e96c4b081df0991a57b244f68c3955a9ea00bd0a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jul 6 18:28:35 2010 -0400

    ACPI / Sleep: Free NVS copy if suspending of devices fails
    
    If suspending of devices fails or system suspend is tested in the
    "devices" mode, the memory allocated for storing a copy of the ACPI
    NVS area will not be freed, because acpi_pm_finish() is not called
    in that case.  Fix this by moving the suspend_nvs_free() call to
    acpi_pm_end().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 5b7c52e4a00f..da68ed24f4c5 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -145,7 +145,6 @@ static void acpi_pm_finish(void)
 {
 	u32 acpi_state = acpi_target_sleep_state;
 
-	suspend_nvs_free();
 	acpi_ec_unblock_transactions();
 
 	if (acpi_state == ACPI_STATE_S0)
@@ -167,6 +166,7 @@ static void acpi_pm_finish(void)
  */
 static void acpi_pm_end(void)
 {
+	suspend_nvs_free();
 	/*
 	 * This is necessary in case acpi_pm_finish() is not called during a
 	 * failing transition to a sleep state.

commit 42de5532f4a58a52a60bdd8bd4f80f9f210dd65b
Merge: e9e8b4dd142d 2a6b69765ad7
Author: Len Brown <len.brown@intel.com>
Date:   Sat Jun 12 01:15:40 2010 -0400

    Merge branch 'bugzilla-13931-sleep-nvs' into release
    
    Conflicts:
            drivers/acpi/sleep.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 2a6b69765ad794389f2fc3e14a0afa1a995221c2
Author: Matthew Garrett <mjg@redhat.com>
Date:   Fri May 28 16:32:15 2010 -0400

    ACPI: Store NVS state even when entering suspend to RAM
    
    https://bugzilla.kernel.org/show_bug.cgi?id=13931 describes a bug where
    a system fails to successfully resume after the second suspend. Maxim
    Levitsky discovered that this could be rectified by forcibly saving
    and restoring the ACPI non-volatile state. The spec indicates that this
    is only required for S4, but testing the behaviour of Windows by adding
    an ACPI NVS region to qemu's e820 map and registering a custom memory
    read/write handler reveals that it's saved and restored even over suspend
    to RAM. We should mimic that behaviour to avoid other broken platforms.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index bcaa6efa8136..403daf0fc8a0 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -112,6 +112,8 @@ static int __acpi_pm_prepare(void)
 {
 	int error = acpi_sleep_prepare(acpi_target_sleep_state);
 
+	suspend_nvs_save();
+
 	if (error)
 		acpi_target_sleep_state = ACPI_STATE_S0;
 	return error;
@@ -140,6 +142,8 @@ static void acpi_pm_finish(void)
 {
 	u32 acpi_state = acpi_target_sleep_state;
 
+	suspend_nvs_free();
+
 	if (acpi_state == ACPI_STATE_S0)
 		return;
 
@@ -189,6 +193,11 @@ static int acpi_suspend_begin(suspend_state_t pm_state)
 	u32 acpi_state = acpi_suspend_states[pm_state];
 	int error = 0;
 
+	error = suspend_nvs_alloc();
+
+	if (error)
+		return error;
+
 	if (sleep_states[acpi_state]) {
 		acpi_target_sleep_state = acpi_state;
 		acpi_sleep_tts_switch(acpi_target_sleep_state);
@@ -264,6 +273,8 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	if (acpi_state == ACPI_STATE_S3)
 		acpi_restore_state_mem();
 
+	suspend_nvs_restore();
+
 	return ACPI_SUCCESS(status) ? 0 : -EFAULT;
 }
 
@@ -430,12 +441,6 @@ static int acpi_hibernation_enter(void)
 	return ACPI_SUCCESS(status) ? 0 : -EFAULT;
 }
 
-static void acpi_hibernation_finish(void)
-{
-	suspend_nvs_free();
-	acpi_pm_finish();
-}
-
 static void acpi_hibernation_leave(void)
 {
 	/*
@@ -473,7 +478,7 @@ static struct platform_hibernation_ops acpi_hibernation_ops = {
 	.begin = acpi_hibernation_begin,
 	.end = acpi_pm_end,
 	.pre_snapshot = acpi_hibernation_pre_snapshot,
-	.finish = acpi_hibernation_finish,
+	.finish = acpi_pm_finish,
 	.prepare = acpi_pm_prepare,
 	.enter = acpi_hibernation_enter,
 	.leave = acpi_hibernation_leave,
@@ -526,7 +531,7 @@ static struct platform_hibernation_ops acpi_hibernation_ops_old = {
 	.begin = acpi_hibernation_begin_old,
 	.end = acpi_pm_end,
 	.pre_snapshot = acpi_hibernation_pre_snapshot_old,
-	.finish = acpi_hibernation_finish,
+	.finish = acpi_pm_finish,
 	.prepare = acpi_pm_disable_gpes,
 	.enter = acpi_hibernation_enter,
 	.leave = acpi_hibernation_leave,

commit dd4c4f17d722ffeb2515bf781400675a30fcead7
Author: Matthew Garrett <mjg@redhat.com>
Date:   Fri May 28 16:32:14 2010 -0400

    suspend: Move NVS save/restore code to generic suspend functionality
    
    Saving platform non-volatile state may be required for suspend to RAM as
    well as hibernation. Move it to more generic code.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Maxim Levitsky <maximlevitsky@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 4ab2275b4461..bcaa6efa8136 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -393,7 +393,7 @@ static int acpi_hibernation_begin(void)
 {
 	int error;
 
-	error = s4_no_nvs ? 0 : hibernate_nvs_alloc();
+	error = s4_no_nvs ? 0 : suspend_nvs_alloc();
 	if (!error) {
 		acpi_target_sleep_state = ACPI_STATE_S4;
 		acpi_sleep_tts_switch(acpi_target_sleep_state);
@@ -407,7 +407,7 @@ static int acpi_hibernation_pre_snapshot(void)
 	int error = acpi_pm_prepare();
 
 	if (!error)
-		hibernate_nvs_save();
+		suspend_nvs_save();
 
 	return error;
 }
@@ -432,7 +432,7 @@ static int acpi_hibernation_enter(void)
 
 static void acpi_hibernation_finish(void)
 {
-	hibernate_nvs_free();
+	suspend_nvs_free();
 	acpi_pm_finish();
 }
 
@@ -452,7 +452,7 @@ static void acpi_hibernation_leave(void)
 		panic("ACPI S4 hardware signature mismatch");
 	}
 	/* Restore the NVS memory area */
-	hibernate_nvs_restore();
+	suspend_nvs_restore();
 }
 
 static int acpi_pm_pre_restore(void)
@@ -501,7 +501,7 @@ static int acpi_hibernation_begin_old(void)
 
 	if (!error) {
 		if (!s4_no_nvs)
-			error = hibernate_nvs_alloc();
+			error = suspend_nvs_alloc();
 		if (!error)
 			acpi_target_sleep_state = ACPI_STATE_S4;
 	}
@@ -513,7 +513,7 @@ static int acpi_hibernation_pre_snapshot_old(void)
 	int error = acpi_pm_disable_gpes();
 
 	if (!error)
-		hibernate_nvs_save();
+		suspend_nvs_save();
 
 	return error;
 }

commit b42f5b0f0fd8c1c442c1b29a3fbcb338e8bd7732
Merge: fe955682d215 0a76a34ff080
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jun 1 22:53:36 2010 -0400

    Merge branches 'bugzilla-14668' and 'misc-2.6.35' into release

commit fe955682d2153b35dffcf1673dff0491096a3f0a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Apr 9 01:40:38 2010 +0200

    ACPI / EC / PM: Fix names of functions that block/unblock EC transactions
    
    The names of the functions used for blocking/unblocking EC
    transactions during suspend/hibernation suggest that the transactions
    are suspended and resumed by them, while in fact they are disabled
    and enabled.  Rename the functions (and the flag used by them) to
    better reflect what they really do.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 24741ac65897..504a55edac49 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -116,7 +116,7 @@ static int acpi_pm_freeze(void)
 {
 	acpi_disable_all_gpes();
 	acpi_os_wait_events_complete(NULL);
-	acpi_ec_suspend_transactions();
+	acpi_ec_block_transactions();
 	return 0;
 }
 
@@ -279,7 +279,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	 */
 	acpi_disable_all_gpes();
 	/* Allow EC transactions to happen. */
-	acpi_ec_resume_transactions_early();
+	acpi_ec_unblock_transactions_early();
 
 	local_irq_restore(flags);
 	printk(KERN_DEBUG "Back to C!\n");
@@ -293,7 +293,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 
 static void acpi_suspend_finish(void)
 {
-	acpi_ec_resume_transactions();
+	acpi_ec_unblock_transactions();
 	acpi_pm_finish();
 }
 
@@ -597,7 +597,7 @@ static int acpi_hibernation_enter(void)
 static void acpi_hibernation_finish(void)
 {
 	hibernate_nvs_free();
-	acpi_ec_resume_transactions();
+	acpi_ec_unblock_transactions();
 	acpi_pm_finish();
 }
 
@@ -619,12 +619,12 @@ static void acpi_hibernation_leave(void)
 	/* Restore the NVS memory area */
 	hibernate_nvs_restore();
 	/* Allow EC transactions to happen. */
-	acpi_ec_resume_transactions_early();
+	acpi_ec_unblock_transactions_early();
 }
 
 static void acpi_pm_thaw(void)
 {
-	acpi_ec_resume_transactions();
+	acpi_ec_unblock_transactions();
 	acpi_enable_all_runtime_gpes();
 }
 

commit d5a64513c6a171262082c250592c062e97a2c693
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Apr 9 01:39:40 2010 +0200

    ACPI / EC / PM: Fix race between EC transactions and system suspend
    
    There still is a race that may result in suspending the system in
    the middle of an EC transaction in progress, which leads to problems
    (like the kernel thinking that the ACPI global lock is held during
    resume while in fact it's not).
    
    To remove the race condition, modify the ACPI platform suspend and
    hibernate callbacks so that EC transactions are blocked right after
    executing the _PTS global control method and are allowed to happen
    again right after the low-level wakeup.
    
    Introduce acpi_pm_freeze() that will disable GPEs, wait until the
    event queues are empty and block EC transactions.  Use it wherever
    GPEs are disabled in preparation for switching local interrupts off.
    Introduce acpi_pm_thaw() that will allow EC transactions to happen
    again and enable runtime GPEs.  Use it to balance acpi_pm_freeze()
    wherever necessary.
    
    In addition to that use acpi_ec_resume_transactions_early() to
    unblock EC transactions as early as reasonably possible during
    resume.  Also unblock EC transactions in acpi_hibernation_finish()
    and in the analogous suspend routine to make sure that the EC
    transactions are enabled in all error paths.
    
    Fixes https://bugzilla.kernel.org/show_bug.cgi?id=14668
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-and-tested-by: Maxim Levitsky <maximlevitsky@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index baa76bbf244a..24741ac65897 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -110,11 +110,13 @@ void __init acpi_old_suspend_ordering(void)
 }
 
 /**
- *	acpi_pm_disable_gpes - Disable the GPEs.
+ * acpi_pm_freeze - Disable the GPEs and suspend EC transactions.
  */
-static int acpi_pm_disable_gpes(void)
+static int acpi_pm_freeze(void)
 {
 	acpi_disable_all_gpes();
+	acpi_os_wait_events_complete(NULL);
+	acpi_ec_suspend_transactions();
 	return 0;
 }
 
@@ -142,7 +144,8 @@ static int acpi_pm_prepare(void)
 	int error = __acpi_pm_prepare();
 
 	if (!error)
-		acpi_disable_all_gpes();
+		acpi_pm_freeze();
+
 	return error;
 }
 
@@ -275,6 +278,8 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	 * acpi_leave_sleep_state will reenable specific GPEs later
 	 */
 	acpi_disable_all_gpes();
+	/* Allow EC transactions to happen. */
+	acpi_ec_resume_transactions_early();
 
 	local_irq_restore(flags);
 	printk(KERN_DEBUG "Back to C!\n");
@@ -286,6 +291,12 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 	return ACPI_SUCCESS(status) ? 0 : -EFAULT;
 }
 
+static void acpi_suspend_finish(void)
+{
+	acpi_ec_resume_transactions();
+	acpi_pm_finish();
+}
+
 static int acpi_suspend_state_valid(suspend_state_t pm_state)
 {
 	u32 acpi_state;
@@ -307,7 +318,7 @@ static struct platform_suspend_ops acpi_suspend_ops = {
 	.begin = acpi_suspend_begin,
 	.prepare_late = acpi_pm_prepare,
 	.enter = acpi_suspend_enter,
-	.wake = acpi_pm_finish,
+	.wake = acpi_suspend_finish,
 	.end = acpi_pm_end,
 };
 
@@ -333,9 +344,9 @@ static int acpi_suspend_begin_old(suspend_state_t pm_state)
 static struct platform_suspend_ops acpi_suspend_ops_old = {
 	.valid = acpi_suspend_state_valid,
 	.begin = acpi_suspend_begin_old,
-	.prepare_late = acpi_pm_disable_gpes,
+	.prepare_late = acpi_pm_freeze,
 	.enter = acpi_suspend_enter,
-	.wake = acpi_pm_finish,
+	.wake = acpi_suspend_finish,
 	.end = acpi_pm_end,
 	.recover = acpi_pm_finish,
 };
@@ -586,6 +597,7 @@ static int acpi_hibernation_enter(void)
 static void acpi_hibernation_finish(void)
 {
 	hibernate_nvs_free();
+	acpi_ec_resume_transactions();
 	acpi_pm_finish();
 }
 
@@ -606,17 +618,11 @@ static void acpi_hibernation_leave(void)
 	}
 	/* Restore the NVS memory area */
 	hibernate_nvs_restore();
+	/* Allow EC transactions to happen. */
+	acpi_ec_resume_transactions_early();
 }
 
-static int acpi_pm_pre_restore(void)
-{
-	acpi_disable_all_gpes();
-	acpi_os_wait_events_complete(NULL);
-	acpi_ec_suspend_transactions();
-	return 0;
-}
-
-static void acpi_pm_restore_cleanup(void)
+static void acpi_pm_thaw(void)
 {
 	acpi_ec_resume_transactions();
 	acpi_enable_all_runtime_gpes();
@@ -630,8 +636,8 @@ static struct platform_hibernation_ops acpi_hibernation_ops = {
 	.prepare = acpi_pm_prepare,
 	.enter = acpi_hibernation_enter,
 	.leave = acpi_hibernation_leave,
-	.pre_restore = acpi_pm_pre_restore,
-	.restore_cleanup = acpi_pm_restore_cleanup,
+	.pre_restore = acpi_pm_freeze,
+	.restore_cleanup = acpi_pm_thaw,
 };
 
 /**
@@ -663,12 +669,9 @@ static int acpi_hibernation_begin_old(void)
 
 static int acpi_hibernation_pre_snapshot_old(void)
 {
-	int error = acpi_pm_disable_gpes();
-
-	if (!error)
-		hibernate_nvs_save();
-
-	return error;
+	acpi_pm_freeze();
+	hibernate_nvs_save();
+	return 0;
 }
 
 /*
@@ -680,11 +683,11 @@ static struct platform_hibernation_ops acpi_hibernation_ops_old = {
 	.end = acpi_pm_end,
 	.pre_snapshot = acpi_hibernation_pre_snapshot_old,
 	.finish = acpi_hibernation_finish,
-	.prepare = acpi_pm_disable_gpes,
+	.prepare = acpi_pm_freeze,
 	.enter = acpi_hibernation_enter,
 	.leave = acpi_hibernation_leave,
-	.pre_restore = acpi_pm_pre_restore,
-	.restore_cleanup = acpi_pm_restore_cleanup,
+	.pre_restore = acpi_pm_freeze,
+	.restore_cleanup = acpi_pm_thaw,
 	.recover = acpi_pm_finish,
 };
 #endif /* CONFIG_HIBERNATION */

commit b6dacf63e9fb2e7a1369843d6cef332f76fca6a3
Author: Matthew Garrett <mjg@redhat.com>
Date:   Tue May 11 13:49:25 2010 -0400

    ACPI: Unconditionally set SCI_EN on resume
    
    The ACPI spec tells us that the firmware will reenable SCI_EN on resume.
    Reality disagrees in some cases. The ACPI spec tells us that the only way
    to set SCI_EN is via an SMM call.
    https://bugzilla.kernel.org/show_bug.cgi?id=13745 shows us that doing so
    may break machines. Tracing the ACPI calls made by Windows shows that it
    unconditionally sets SCI_EN on resume with a direct register write, and
    therefore the overwhelming probability is that everything is fine with
    this behaviour.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Tested-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index baa76bbf244a..4ab2275b4461 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -80,22 +80,6 @@ static int acpi_sleep_prepare(u32 acpi_state)
 
 #ifdef CONFIG_ACPI_SLEEP
 static u32 acpi_target_sleep_state = ACPI_STATE_S0;
-/*
- * According to the ACPI specification the BIOS should make sure that ACPI is
- * enabled and SCI_EN bit is set on wake-up from S1 - S3 sleep states.  Still,
- * some BIOSes don't do that and therefore we use acpi_enable() to enable ACPI
- * on such systems during resume.  Unfortunately that doesn't help in
- * particularly pathological cases in which SCI_EN has to be set directly on
- * resume, although the specification states very clearly that this flag is
- * owned by the hardware.  The set_sci_en_on_resume variable will be set in such
- * cases.
- */
-static bool set_sci_en_on_resume;
-
-void __init acpi_set_sci_en_on_resume(void)
-{
-	set_sci_en_on_resume = true;
-}
 
 /*
  * ACPI 1.0 wants us to execute _PTS before suspending devices, so we allow the
@@ -253,11 +237,8 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 		break;
 	}
 
-	/* If ACPI is not enabled by the BIOS, we need to enable it here. */
-	if (set_sci_en_on_resume)
-		acpi_write_bit_register(ACPI_BITREG_SCI_ENABLE, 1);
-	else
-		acpi_enable();
+	/* This violates the spec but is required for bug compatibility. */
+	acpi_write_bit_register(ACPI_BITREG_SCI_ENABLE, 1);
 
 	/* Reprogram control registers and execute _BFS */
 	acpi_leave_sleep_state_prep(acpi_state);
@@ -346,12 +327,6 @@ static int __init init_old_suspend_ordering(const struct dmi_system_id *d)
 	return 0;
 }
 
-static int __init init_set_sci_en_on_resume(const struct dmi_system_id *d)
-{
-	set_sci_en_on_resume = true;
-	return 0;
-}
-
 static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 	{
 	.callback = init_old_suspend_ordering,
@@ -370,22 +345,6 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		},
 	},
 	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Apple MacBook 1,1",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Apple Computer, Inc."),
-		DMI_MATCH(DMI_PRODUCT_NAME, "MacBook1,1"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Apple MacMini 1,1",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Apple Computer, Inc."),
-		DMI_MATCH(DMI_PRODUCT_NAME, "Macmini1,1"),
-		},
-	},
-	{
 	.callback = init_old_suspend_ordering,
 	.ident = "Asus Pundit P1-AH2 (M2N8L motherboard)",
 	.matches = {
@@ -394,94 +353,6 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		},
 	},
 	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Toshiba Satellite L300",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "Satellite L300"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Hewlett-Packard HP G7000 Notebook PC",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "HP G7000 Notebook PC"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Hewlett-Packard HP Pavilion dv3 Notebook PC",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "HP Pavilion dv3 Notebook PC"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Hewlett-Packard Pavilion dv4",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "HP Pavilion dv4"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Hewlett-Packard Pavilion dv7",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "HP Pavilion dv7"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Hewlett-Packard Compaq Presario C700 Notebook PC",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "Compaq Presario C700 Notebook PC"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Hewlett-Packard Compaq Presario CQ40 Notebook PC",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "Compaq Presario CQ40 Notebook PC"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Lenovo ThinkPad T410",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T410"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Lenovo ThinkPad T510",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T510"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Lenovo ThinkPad W510",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad W510"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Lenovo ThinkPad X201[s]",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X201"),
-		},
-	},
-	{
 	.callback = init_old_suspend_ordering,
 	.ident = "Panasonic CF51-2L",
 	.matches = {
@@ -490,30 +361,6 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		DMI_MATCH(DMI_BOARD_NAME, "CF51-2L"),
 		},
 	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Dell Studio 1558",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
-		DMI_MATCH(DMI_PRODUCT_NAME, "Studio 1558"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Dell Studio 1557",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
-		DMI_MATCH(DMI_PRODUCT_NAME, "Studio 1557"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Dell Studio 1555",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
-		DMI_MATCH(DMI_PRODUCT_NAME, "Studio 1555"),
-		},
-	},
 	{},
 };
 #endif /* CONFIG_SUSPEND */

commit 7d6fb7bd1919517937ec390f6ca2d7bcf4f89fb6
Author: Alex Chiang <achiang@canonical.com>
Date:   Tue May 11 10:21:38 2010 -0600

    ACPI: sleep: eliminate duplicate entries in acpisleep_dmi_table[]
    
    Duplicate entries ended up acpisleep_dmi_table[] by accident.
    They don't hurt functionality, but they are ugly, so let's get
    rid of them.
    
    Cc: stable@kernel.org
    Signed-off-by: Alex Chiang <achiang@canonical.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index e2e992599e68..baa76bbf244a 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -475,101 +475,13 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 	},
 	{
 	.callback = init_set_sci_en_on_resume,
-	.ident = "Lenovo ThinkPad X201",
+	.ident = "Lenovo ThinkPad X201[s]",
 	.matches = {
 		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
 		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X201"),
 		},
 	},
 	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Lenovo ThinkPad X201",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X201s"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Lenovo ThinkPad T410",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T410"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Lenovo ThinkPad T510",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T510"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Lenovo ThinkPad W510",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad W510"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Lenovo ThinkPad X201",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X201"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Lenovo ThinkPad X201",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X201s"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Lenovo ThinkPad T410",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T410"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Lenovo ThinkPad T510",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T510"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Lenovo ThinkPad W510",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad W510"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Lenovo ThinkPad X201",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X201"),
-		},
-	},
-	{
-	.callback = init_set_sci_en_on_resume,
-	.ident = "Lenovo ThinkPad X201",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X201s"),
-		},
-	},
-	{
 	.callback = init_old_suspend_ordering,
 	.ident = "Panasonic CF51-2L",
 	.matches = {

commit ea5bc73f4f56449b2d450068d492bcd17a675d7a
Author: Kamal Mostafa <kamal@canonical.com>
Date:   Tue Apr 27 14:02:40 2010 -0700

    ACPI: sleep: init_set_sci_en_on_resume for Dell Studio 155x
    
    Add Dell Studio models (1558, 1557, 1555) to the 'set_sci_en_on_resume'
    list to fix hang on resume.
    
    BugLink: http://bugs.launchpad.net/bugs/553498
    
    Signed-off-by: Kamal Mostafa <kamal@canonical.com>
    Acked-by: Alex Chiang <achiang@canonical.com>
    Cc: stable@kernel.org
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 0fc91a945ab4..e2e992599e68 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -578,6 +578,30 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		DMI_MATCH(DMI_BOARD_NAME, "CF51-2L"),
 		},
 	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Dell Studio 1558",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+		DMI_MATCH(DMI_PRODUCT_NAME, "Studio 1558"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Dell Studio 1557",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+		DMI_MATCH(DMI_PRODUCT_NAME, "Studio 1557"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Dell Studio 1555",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+		DMI_MATCH(DMI_PRODUCT_NAME, "Studio 1555"),
+		},
+	},
 	{},
 };
 #endif /* CONFIG_SUSPEND */

commit 07bedca29b0973f36a6b6db36936deed367164ed
Author: Alex Chiang <achiang@canonical.com>
Date:   Tue Apr 20 08:03:14 2010 -0600

    ACPI: DMI init_set_sci_en_on_resume for multiple Lenovo ThinkPads
    
    Multiple Lenovo ThinkPad models with Intel Core i5/i7 CPUs can
    successfully suspend/resume once, and then hang on the second s/r
    cycle.
    
    We got confirmation that this was due to a BIOS defect. The BIOS
    did not properly set SCI_EN coming out of S3. The BIOS guys
    hinted that The Other Leading OS ignores the fact that hardware
    owns the bit and sets it manually.
    
    In any case, an existing DMI table exists for machines where this
    defect is a known problem. Lenovo promise to fix their BIOS, but
    for folks who either won't or can't upgrade their BIOS, allow
    Linux to workaround the issue.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=15407
    https://bugs.launchpad.net/ubuntu/+source/linux/+bug/532374
    
    Confirmed by numerous testers in the launchpad bug that using
    acpi_sleep=sci_force_enable fixes the issue. We add the machines
    to acpisleep_dmi_table[] to automatically enable this workaround.
    
    Cc: stable@kernel.org
    Cc: Colin King <colin.king@canonical.com>
    Signed-off-by: Alex Chiang <achiang@canonical.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index f74834a544fd..0fc91a945ab4 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -450,6 +450,126 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		},
 	},
 	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Lenovo ThinkPad T410",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T410"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Lenovo ThinkPad T510",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T510"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Lenovo ThinkPad W510",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad W510"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Lenovo ThinkPad X201",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X201"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Lenovo ThinkPad X201",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X201s"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Lenovo ThinkPad T410",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T410"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Lenovo ThinkPad T510",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T510"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Lenovo ThinkPad W510",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad W510"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Lenovo ThinkPad X201",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X201"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Lenovo ThinkPad X201",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X201s"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Lenovo ThinkPad T410",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T410"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Lenovo ThinkPad T510",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T510"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Lenovo ThinkPad W510",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad W510"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Lenovo ThinkPad X201",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X201"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Lenovo ThinkPad X201",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X201s"),
+		},
+	},
+	{
 	.callback = init_old_suspend_ordering,
 	.ident = "Panasonic CF51-2L",
 	.matches = {

commit ec28dcc6b4c00b78ad269ad5b85ebd5c2d504825
Merge: c67fcd670b55 d06070509147 f6bb13aa1ea3 0c99c5288eb9 4c81ba4900ab 7e0e9c042790 149fe9c293f7 cffdde993a01 fa80945269f3 8b7ef6d8f162 70287db87cfc 38bcb37a6f63
Author: Len Brown <len.brown@intel.com>
Date:   Sun Mar 14 21:30:17 2010 -0400

    Merge branches 'battery-2.6.34', 'bugzilla-10805', 'bugzilla-14668', 'bugzilla-531916-power-state', 'ht-warn-2.6.34', 'pnp', 'processor-rename', 'sony-2.6.34', 'suse-bugzilla-531547', 'tz-check', 'video' and 'misc-2.6.34' into release

commit f6bb13aa1ea3bb26a4c783822347873f085b9000
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Mar 4 01:52:58 2010 +0100

    ACPI / EC / PM: Close race between EC and resume from hibernation
    
    There is a race between resume from hibernation and the EC driver
    that may result in restoring the hibernation image in the middle of
    an EC transaction in progress, which in turn may lead to
    unpredictable behavior of the platform.
    
    To remove that race condition, add a helpers for suspending and
    resuming EC transactions in a safe way to be executed by the ACPI
    platform hibernate pre-restore and restore cleanup callbacks.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=14668
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-and-tested-by: Maxim Levitsky <maximlevitsky@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 79d33d908b5a..f01f8e84fd3d 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -552,8 +552,17 @@ static void acpi_hibernation_leave(void)
 	hibernate_nvs_restore();
 }
 
-static void acpi_pm_enable_gpes(void)
+static int acpi_pm_pre_restore(void)
 {
+	acpi_disable_all_gpes();
+	acpi_os_wait_events_complete(NULL);
+	acpi_ec_suspend_transactions();
+	return 0;
+}
+
+static void acpi_pm_restore_cleanup(void)
+{
+	acpi_ec_resume_transactions();
 	acpi_enable_all_runtime_gpes();
 }
 
@@ -565,8 +574,8 @@ static struct platform_hibernation_ops acpi_hibernation_ops = {
 	.prepare = acpi_pm_prepare,
 	.enter = acpi_hibernation_enter,
 	.leave = acpi_hibernation_leave,
-	.pre_restore = acpi_pm_disable_gpes,
-	.restore_cleanup = acpi_pm_enable_gpes,
+	.pre_restore = acpi_pm_pre_restore,
+	.restore_cleanup = acpi_pm_restore_cleanup,
 };
 
 /**
@@ -618,8 +627,8 @@ static struct platform_hibernation_ops acpi_hibernation_ops_old = {
 	.prepare = acpi_pm_disable_gpes,
 	.enter = acpi_hibernation_enter,
 	.leave = acpi_hibernation_leave,
-	.pre_restore = acpi_pm_disable_gpes,
-	.restore_cleanup = acpi_pm_enable_gpes,
+	.pre_restore = acpi_pm_pre_restore,
+	.restore_cleanup = acpi_pm_restore_cleanup,
 	.recover = acpi_pm_finish,
 };
 #endif /* CONFIG_HIBERNATION */

commit 9630bdd9b15d2f489c646d8bc04b60e53eb5ec78
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 17 23:41:07 2010 +0100

    ACPI: Use GPE reference counting to support shared GPEs
    
    ACPI GPEs may map to multiple devices.  The current GPE interface
    only provides a mechanism for enabling and disabling GPEs, making
    it difficult to change the state of GPEs at runtime without extensive
    cooperation between devices.
    
    Add an API to allow devices to indicate whether or not they want
    their device's GPE to be enabled for both runtime and wakeup events.
    
    Remove the old GPE type handling entirely, which gets rid of various
    quirks, like the implicit disabling with GPE type setting. This
    requires a small amount of rework in order to ensure that non-wake
    GPEs are enabled by default to preserve existing behaviour.
    
    Based on patches from Matthew Garrett <mjg@redhat.com>.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 79d33d908b5a..3bde594a9979 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -745,9 +745,18 @@ int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
 		return -ENODEV;
 	}
 
-	error = enable ?
-		acpi_enable_wakeup_device_power(adev, acpi_target_sleep_state) :
-		acpi_disable_wakeup_device_power(adev);
+	if (enable) {
+		error = acpi_enable_wakeup_device_power(adev,
+						acpi_target_sleep_state);
+		if (!error)
+			acpi_enable_gpe(adev->wakeup.gpe_device,
+					adev->wakeup.gpe_number,
+					ACPI_GPE_TYPE_WAKE);
+	} else {
+		acpi_disable_gpe(adev->wakeup.gpe_device, adev->wakeup.gpe_number,
+				ACPI_GPE_TYPE_WAKE);
+		error = acpi_disable_wakeup_device_power(adev);
+	}
 	if (!error)
 		dev_info(dev, "wake-up capability %s by ACPI\n",
 				enable ? "enabled" : "disabled");

commit d7f0eea9e431e1b8b0742a74db1a9490730b2a25
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Wed Dec 30 15:36:42 2009 +0800

    ACPI: introduce kernel parameter acpi_sleep=sci_force_enable
    
    Introduce kernel parameter acpi_sleep=sci_force_enable
    
    some laptop requires SCI_EN being set directly on resume,
    or else they hung somewhere in the resume code path.
    
    We already have a blacklist for these laptops but we still need
    this option, especially when debugging some suspend/resume problems,
    in case there are systems that need this workaround and are not yet
    in the blacklist.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 5f2c379ab7bf..79d33d908b5a 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -80,6 +80,23 @@ static int acpi_sleep_prepare(u32 acpi_state)
 
 #ifdef CONFIG_ACPI_SLEEP
 static u32 acpi_target_sleep_state = ACPI_STATE_S0;
+/*
+ * According to the ACPI specification the BIOS should make sure that ACPI is
+ * enabled and SCI_EN bit is set on wake-up from S1 - S3 sleep states.  Still,
+ * some BIOSes don't do that and therefore we use acpi_enable() to enable ACPI
+ * on such systems during resume.  Unfortunately that doesn't help in
+ * particularly pathological cases in which SCI_EN has to be set directly on
+ * resume, although the specification states very clearly that this flag is
+ * owned by the hardware.  The set_sci_en_on_resume variable will be set in such
+ * cases.
+ */
+static bool set_sci_en_on_resume;
+
+void __init acpi_set_sci_en_on_resume(void)
+{
+	set_sci_en_on_resume = true;
+}
+
 /*
  * ACPI 1.0 wants us to execute _PTS before suspending devices, so we allow the
  * user to request that behavior by using the 'acpi_old_suspend_ordering'
@@ -170,18 +187,6 @@ static void acpi_pm_end(void)
 #endif /* CONFIG_ACPI_SLEEP */
 
 #ifdef CONFIG_SUSPEND
-/*
- * According to the ACPI specification the BIOS should make sure that ACPI is
- * enabled and SCI_EN bit is set on wake-up from S1 - S3 sleep states.  Still,
- * some BIOSes don't do that and therefore we use acpi_enable() to enable ACPI
- * on such systems during resume.  Unfortunately that doesn't help in
- * particularly pathological cases in which SCI_EN has to be set directly on
- * resume, although the specification states very clearly that this flag is
- * owned by the hardware.  The set_sci_en_on_resume variable will be set in such
- * cases.
- */
-static bool set_sci_en_on_resume;
-
 extern void do_suspend_lowlevel(void);
 
 static u32 acpi_suspend_states[] = {

commit 87c687be055e67bc04189ce476690be73d16063e
Author: Len Brown <len.brown@intel.com>
Date:   Mon Nov 23 11:44:12 2009 -0500

    ACPI: DMI init_set_sci_en_on_resume for HP-Compaq C700
    
    ...else ACPI thermal controls fail after resume.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=13745
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 4cc1b8116e76..5f2c379ab7bf 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -430,6 +430,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 	},
 	{
 	.callback = init_set_sci_en_on_resume,
+	.ident = "Hewlett-Packard Compaq Presario C700 Notebook PC",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "Compaq Presario C700 Notebook PC"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
 	.ident = "Hewlett-Packard Compaq Presario CQ40 Notebook PC",
 	.matches = {
 		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),

commit 2839d396e3ae0891c1fdd87aa1cea218e6f5c4df
Author: Vaibhav Verma <vaibhav.verma86@gmail.com>
Date:   Thu Nov 5 23:13:36 2009 -0500

    ACPI: sleep: another HP/Compaq DMI entries for init_set_sci_en_on_resume
    
    http://bugzilla.kernel.org/show_bug.cgi?id=13745
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index ed9760aa7aa2..4cc1b8116e76 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -421,6 +421,22 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		},
 	},
 	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Hewlett-Packard Pavilion dv7",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "HP Pavilion dv7"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Hewlett-Packard Compaq Presario CQ40 Notebook PC",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "Compaq Presario CQ40 Notebook PC"),
+		},
+	},
+	{
 	.callback = init_old_suspend_ordering,
 	.ident = "Panasonic CF51-2L",
 	.matches = {

commit 8a1cbf64977f89e9e9bc1d80dd01503337424f96
Author: Gustavo Maciel Dias Vieira <gustavo@sagui.org>
Date:   Mon Oct 19 09:41:53 2009 -0200

    ACPI: add DMI entry for SCI_EN resume quirk on HP dv4
    
    Fixes the missing battery on sleep problem for yet another HP laptop
    ("HP Pavilion dv4").
    
    Fixes:
            http://bugzilla.kernel.org/show_bug.cgi?id=13449
    
    Signed-off-by: Gustavo Maciel Dias Vieira <gustavo@sagui.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index a90afcc723ab..ed9760aa7aa2 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -413,6 +413,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		},
 	},
 	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Hewlett-Packard Pavilion dv4",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "HP Pavilion dv4"),
+		},
+	},
+	{
 	.callback = init_old_suspend_ordering,
 	.ident = "Panasonic CF51-2L",
 	.matches = {

commit 71fd68e7d234f6b7d8407c8f486764d24f8411f4
Merge: 8ff0e082f083 78f28b7c5553
Author: Len Brown <len.brown@intel.com>
Date:   Sat Sep 19 00:06:59 2009 -0400

    Merge branch 'linus' into release

commit 0baed8da1ed91b664759f6c7f955b3a804457389
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Sep 8 23:16:24 2009 +0200

    PCI / ACPI PM: Propagate wake-up enable for devices w/o ACPI support
    
    Some PCI devices (not PCI Express), like PCI add-on cards, can
    generate PME#, but they don't have any special platform wake-up
    support.  For this reason, even if they generate PME# to wake up the
    system from a sleep state, wake-up events are not generated by the
    platform.
    
    It turns out that, at least on some systems, PCI bridges and the PCI
    host bridge have ACPI GPEs associated with them that, if enabled to
    generate wake-up events, allow the system to wake up if one of the
    add-on devices asserts PME# while the system is in a sleep state.
    Following this observation, if a PCI device without direct ACPI
    wake-up support is prepared to wake up the system during a transition
    into a sleep state (eg. suspend to RAM), try to configure the bridges
    on the path from the device to the root bridge to wake-up the system.
    
    Reviewed-by: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index ab889becd3f3..feece693d773 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -691,7 +691,7 @@ int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
 	struct acpi_device *adev;
 	int error;
 
-	if (!device_may_wakeup(dev))
+	if (!device_can_wakeup(dev))
 		return -EINVAL;
 
 	handle = DEVICE_ACPI_HANDLE(dev);

commit df8db91fc3b543d373afa61beef35b072eea1368
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Sep 8 23:13:49 2009 +0200

    PCI / ACPI PM: Rework some debug messages
    
    Move a debug message from acpi_pci_sleep_wake() to
    acpi_pm_device_sleep_wake() and use the standard dev_*() macros
    in there.
    
    Reviewed-by: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 42159a28f433..ab889becd3f3 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -689,19 +689,25 @@ int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
 {
 	acpi_handle handle;
 	struct acpi_device *adev;
+	int error;
 
 	if (!device_may_wakeup(dev))
 		return -EINVAL;
 
 	handle = DEVICE_ACPI_HANDLE(dev);
 	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &adev))) {
-		printk(KERN_DEBUG "ACPI handle has no context!\n");
+		dev_dbg(dev, "ACPI handle has no context in %s!\n", __func__);
 		return -ENODEV;
 	}
 
-	return enable ?
+	error = enable ?
 		acpi_enable_wakeup_device_power(adev, acpi_target_sleep_state) :
 		acpi_disable_wakeup_device_power(adev);
+	if (!error)
+		dev_info(dev, "wake-up capability %s by ACPI\n",
+				enable ? "enabled" : "disabled");
+
+	return error;
 }
 #endif
 

commit eb0ca849863ecdc593ba7faa95fda5695af891c8
Author: Len Brown <len.brown@intel.com>
Date:   Sat Aug 29 22:39:06 2009 -0400

    ACPI: sleep: another HP DMI entry for init_set_sci_en_on_resume
    
    DMI_MATCH(DMI_PRODUCT_NAME, "HP Pavilion dv3 Notebook PC")
    
    http://bugzilla.kernel.org/show_bug.cgi?id=13745
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 42159a28f433..e0a74097a978 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -405,6 +405,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		},
 	},
 	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Hewlett-Packard HP Pavilion dv3 Notebook PC",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "HP Pavilion dv3 Notebook PC"),
+		},
+	},
+	{
 	.callback = init_old_suspend_ordering,
 	.ident = "Panasonic CF51-2L",
 	.matches = {

commit ec79be26875f6c1468784876cb99192b7f41c7a5
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 29 21:07:47 2009 +0200

    PM / ACPI: HP G7000 Notebook needs a SCI_EN resume quirk
    
    This fixes regression (battery "vanishing" on resume) introduced by
    commit d0c71fe7ebc180f1b7bc7da1d39a07fc19eec768 ("ACPI Suspend: Enable
    ACPI during resume if SCI_EN is not set") and also the issue with
    the "screaming" IRQ 9.
    
    Fixes http://bugzilla.kernel.org/show_bug.cgi?id=13745
    
    Reported-and-tested-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Cc: stable@kernel.org
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Acked-by: Len Brown <lenb@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 01574a066534..42159a28f433 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -397,6 +397,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		},
 	},
 	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Hewlett-Packard HP G7000 Notebook PC",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "HP G7000 Notebook PC"),
+		},
+	},
+	{
 	.callback = init_old_suspend_ordering,
 	.ident = "Panasonic CF51-2L",
 	.matches = {

commit ac0849fb6c66ca865270fda32bcbc39f6dd52de1
Merge: 09041daeea46 96f15efcea94
Author: Len Brown <len.brown@intel.com>
Date:   Fri Apr 24 01:35:24 2009 -0400

    Merge branch 'bugzilla-13041' into release

commit 6a7c7eaf71b636f197d73b381a2ab729ebdcfb2e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 19 20:08:42 2009 +0200

    PM/Suspend: Introduce two new platform callbacks to avoid breakage
    
    Commit 900af0d973856d6feb6fc088c2d0d3fde57707d3 (PM: Change suspend
    code ordering) changed the ordering of suspend code in such a way
    that the platform .prepare() callback is now executed after the
    device drivers' late suspend callbacks have run.  Unfortunately, this
    turns out to break ARM platforms that need to talk via I2C to power
    control devices during the .prepare() callback.
    
    For this reason introduce two new platform suspend callbacks,
    .prepare_late() and .wake(), that will be called just prior to
    disabling non-boot CPUs and right after bringing them back on line,
    respectively, and use them instead of .prepare() and .finish() for
    ACPI suspend.  Make the PM core execute the .prepare() and .finish()
    platform suspend callbacks where they were executed previously (that
    is, right after calling the regular suspend methods provided by
    device drivers and right before executing their regular resume
    methods, respectively).
    
    It is not necessary to make analogous changes to the hibernation
    code and data structures at the moment, because they are only used
    by ACPI platforms.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 779e4e500df4..d060e6fd7fd5 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -300,9 +300,9 @@ static int acpi_suspend_state_valid(suspend_state_t pm_state)
 static struct platform_suspend_ops acpi_suspend_ops = {
 	.valid = acpi_suspend_state_valid,
 	.begin = acpi_suspend_begin,
-	.prepare = acpi_pm_prepare,
+	.prepare_late = acpi_pm_prepare,
 	.enter = acpi_suspend_enter,
-	.finish = acpi_pm_finish,
+	.wake = acpi_pm_finish,
 	.end = acpi_pm_end,
 };
 
@@ -328,9 +328,9 @@ static int acpi_suspend_begin_old(suspend_state_t pm_state)
 static struct platform_suspend_ops acpi_suspend_ops_old = {
 	.valid = acpi_suspend_state_valid,
 	.begin = acpi_suspend_begin_old,
-	.prepare = acpi_pm_disable_gpes,
+	.prepare_late = acpi_pm_disable_gpes,
 	.enter = acpi_suspend_enter,
-	.finish = acpi_pm_finish,
+	.wake = acpi_pm_finish,
 	.end = acpi_pm_end,
 	.recover = acpi_pm_finish,
 };

commit 96f15efcea94545987715f453a8c2b8ea592d000
Author: Len Brown <len.brown@intel.com>
Date:   Fri Apr 17 23:32:20 2009 -0400

    ACPI: Disable _GTS and _BFS support by default
    
    Executing BIOS code paths not exercised by Windows
    tends to get Linux into trouble.
    
    However, if a system does benefit from _GTS or _BFS,
    acpi.gts=1 an acpi.bfs=1 are now available to enable them.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=13041
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 779e4e500df4..9042875ac942 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -713,6 +713,32 @@ static void acpi_power_off(void)
 	acpi_enter_sleep_state(ACPI_STATE_S5);
 }
 
+/*
+ * ACPI 2.0 created the optional _GTS and _BFS,
+ * but industry adoption has been neither rapid nor broad.
+ *
+ * Linux gets into trouble when it executes poorly validated
+ * paths through the BIOS, so disable _GTS and _BFS by default,
+ * but do speak up and offer the option to enable them.
+ */
+void __init acpi_gts_bfs_check(void)
+{
+	acpi_handle dummy;
+
+	if (ACPI_SUCCESS(acpi_get_handle(ACPI_ROOT_OBJECT, METHOD_NAME__GTS, &dummy)))
+	{
+		printk(KERN_NOTICE PREFIX "BIOS offers _GTS\n");
+		printk(KERN_NOTICE PREFIX "If \"acpi.gts=1\" improves suspend, "
+			"please notify linux-acpi@vger.kernel.org\n");
+	}
+	if (ACPI_SUCCESS(acpi_get_handle(ACPI_ROOT_OBJECT, METHOD_NAME__BFS, &dummy)))
+	{
+		printk(KERN_NOTICE PREFIX "BIOS offers _BFS\n");
+		printk(KERN_NOTICE PREFIX "If \"acpi.bfs=1\" improves resume, "
+			"please notify linux-acpi@vger.kernel.org\n");
+	}
+}
+
 int __init acpi_sleep_init(void)
 {
 	acpi_status status;
@@ -771,5 +797,6 @@ int __init acpi_sleep_init(void)
 	 * object can also be evaluated when the system enters S5.
 	 */
 	register_reboot_notifier(&tts_notifier);
+	acpi_gts_bfs_check();
 	return 0;
 }

commit 8a3f257c704e02aee9869decd069a806b45be3f1
Merge: 33526a53600a 15065531c1c5
Author: Len Brown <len.brown@intel.com>
Date:   Sun Apr 5 01:52:07 2009 -0400

    Merge branch 'misc' into release

commit 9a38f4eec57cc5104b6a85bc6d0a91b268fbe803
Merge: 67dc09218762 018f452e9d9d
Author: Len Brown <len.brown@intel.com>
Date:   Sun Apr 5 01:38:31 2009 -0400

    Merge branch 'bjorn-initcall-cleanup' into release

commit 2a9ef8e1a856be8e526bb9b10fb98c5012f6e3f8
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Wed Mar 18 16:36:25 2009 +0800

    ACPI: suspend: Add the Pansonic CF51 box to the dmi check table
    
    The Pansonic CF51-2L requires "acpi_sleep=old_ordering",
    so invoke it automatically via DMI.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=12561
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 00456fccfa38..31ff2a9a03d7 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -394,6 +394,15 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		DMI_MATCH(DMI_PRODUCT_NAME, "Satellite L300"),
 		},
 	},
+	{
+	.callback = init_old_suspend_ordering,
+	.ident = "Panasonic CF51-2L",
+	.matches = {
+		DMI_MATCH(DMI_BOARD_VENDOR,
+				"Matsushita Electric Industrial Co.,Ltd."),
+		DMI_MATCH(DMI_BOARD_NAME, "CF51-2L"),
+		},
+	},
 	{},
 };
 #endif /* CONFIG_SUSPEND */

commit 50ffba1bd3120b069617455545bc27bcf3cf7579
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Feb 23 15:02:07 2009 +0800

    ACPICA: Rename ACPI bit register access functions
    
    Rename acpi_get_register and acpi_set_register to clarify the
    purpose of these functions. New names are acpi_read_bit_register
    and acpi_write_bit_register.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 00456fccfa38..837ac7d5801b 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -248,7 +248,7 @@ static int acpi_suspend_enter(suspend_state_t pm_state)
 
 	/* If ACPI is not enabled by the BIOS, we need to enable it here. */
 	if (set_sci_en_on_resume)
-		acpi_set_register(ACPI_BITREG_SCI_ENABLE, 1);
+		acpi_write_bit_register(ACPI_BITREG_SCI_ENABLE, 1);
 	else
 		acpi_enable();
 

commit e60cc7a6f02598fc23c68a656fe9c263d6531ca0
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Mar 13 12:08:26 2009 -0600

    ACPI: move private declarations to internal.h
    
    A number of things that shouldn't be exposed outside the ACPI core
    were declared in include/acpi/acpi_drivers.h, where anybody can
    see them.  This patch moves those declarations to a new "internal.h"
    inside drivers/acpi.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 519266654f06..0f86cf74216b 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -21,6 +21,8 @@
 
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
+
+#include "internal.h"
 #include "sleep.h"
 
 u8 sleep_states[ACPI_S_STATE_COUNT];

commit 45e7798886af101c4a908a896bbba5a84ee5cc32
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Sun Mar 15 22:13:44 2009 -0400

    ACPI suspend: Blacklist Toshiba Satellite L300 that requires to set SCI_EN directly on resume
    
    This is a supplement of commit 65df78473ffbf3bff5e2034df1638acc4f3ddd50.
    http://bugzilla.kernel.org/show_bug.cgi?id=12798
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 3ca98686f28b..00456fccfa38 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -386,6 +386,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		DMI_MATCH(DMI_BOARD_NAME, "M2N8L"),
 		},
 	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Toshiba Satellite L300",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "Satellite L300"),
+		},
+	},
 	{},
 };
 #endif /* CONFIG_SUSPEND */

commit a140449584522c3eea1bb381f746d40939e6f62a
Author: Andy Whitcroft <apw@canonical.com>
Date:   Wed Feb 11 18:11:22 2009 +0000

    suspend: switch the Asus Pundit P1-AH2 to old ACPI sleep ordering
    
    Switch the Asus Pundit P1-AH2 (M2N8L motherboard) to the old ACPI 1.0
    sleep ordering by default.  Without this it will not suspend/resume
    correctly.
    
    Signed-off-by: Andy Whitcroft <apw@canonical.com>
    Tested-by: Dustin Kirkland <kirkland@canonical.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 519266654f06..3ca98686f28b 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -378,6 +378,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 		DMI_MATCH(DMI_PRODUCT_NAME, "Macmini1,1"),
 		},
 	},
+	{
+	.callback = init_old_suspend_ordering,
+	.ident = "Asus Pundit P1-AH2 (M2N8L motherboard)",
+	.matches = {
+		DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTek Computer INC."),
+		DMI_MATCH(DMI_BOARD_NAME, "M2N8L"),
+		},
+	},
 	{},
 };
 #endif /* CONFIG_SUSPEND */

commit 2d29c6a075787f2c1bc49b86a084d2b878f72fc4
Merge: 2b25c9f01aa5 0a3db1cec5d4 9fdd54f20672 5ec5d38a1c8a 4312495f7db6 370154bbefb6 4d9391557b68 62663ea82203
Author: Len Brown <len.brown@intel.com>
Date:   Sat Feb 7 01:34:56 2009 -0500

    Merge branches 'release', 'asus', 'bugzilla-12450', 'cpuidle', 'debug', 'ec', 'misc', 'printk' and 'processor' into release

commit 4d9391557b68475b118ec7626607c37b14ae8c16
Author: Frank Seidel <frank@f-seidel.de>
Date:   Wed Feb 4 17:03:07 2009 +0100

    ACPI: add missing KERN_* constants to printks
    
    According to kerneljanitors todo list all printk calls (beginning
    a new line) should have an according KERN_* constant.
    Those are the missing peaces here for the acpi subsystem.
    
    Signed-off-by: Frank Seidel <frank@f-seidel.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 7e3c609cbef2..dfc09c45d700 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -679,7 +679,7 @@ static void acpi_power_off_prepare(void)
 static void acpi_power_off(void)
 {
 	/* acpi_sleep_prepare(ACPI_STATE_S5) should have already been called */
-	printk("%s called\n", __func__);
+	printk(KERN_DEBUG "%s called\n", __func__);
 	local_irq_disable();
 	acpi_enable_wakeup_device(ACPI_STATE_S5);
 	acpi_enter_sleep_state(ACPI_STATE_S5);

commit 5d8b532af9e52ea89208f5ef31889f646e67ba28
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 16 23:09:14 2009 +0100

    ACPI suspend: Fix compilation warnings in drivers/acpi/sleep.c
    
    Fix two compilation warnings in drivers/acpi/sleep.c, one triggered
    by unsetting CONFIG_SUSPEND and the other triggered by unsetting
    CONFIG_HIBERNATION, by moving some code under the appropriate
    #ifdefs .
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index 7e3c609cbef2..af85f5ba1be7 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -90,31 +90,6 @@ void __init acpi_old_suspend_ordering(void)
 	old_suspend_ordering = true;
 }
 
-/*
- * According to the ACPI specification the BIOS should make sure that ACPI is
- * enabled and SCI_EN bit is set on wake-up from S1 - S3 sleep states.  Still,
- * some BIOSes don't do that and therefore we use acpi_enable() to enable ACPI
- * on such systems during resume.  Unfortunately that doesn't help in
- * particularly pathological cases in which SCI_EN has to be set directly on
- * resume, although the specification states very clearly that this flag is
- * owned by the hardware.  The set_sci_en_on_resume variable will be set in such
- * cases.
- */
-static bool set_sci_en_on_resume;
-/*
- * The ACPI specification wants us to save NVS memory regions during hibernation
- * and to restore them during the subsequent resume.  However, it is not certain
- * if this mechanism is going to work on all machines, so we allow the user to
- * disable this mechanism using the 'acpi_sleep=s4_nonvs' kernel command line
- * option.
- */
-static bool s4_no_nvs;
-
-void __init acpi_s4_no_nvs(void)
-{
-	s4_no_nvs = true;
-}
-
 /**
  *	acpi_pm_disable_gpes - Disable the GPEs.
  */
@@ -193,6 +168,18 @@ static void acpi_pm_end(void)
 #endif /* CONFIG_ACPI_SLEEP */
 
 #ifdef CONFIG_SUSPEND
+/*
+ * According to the ACPI specification the BIOS should make sure that ACPI is
+ * enabled and SCI_EN bit is set on wake-up from S1 - S3 sleep states.  Still,
+ * some BIOSes don't do that and therefore we use acpi_enable() to enable ACPI
+ * on such systems during resume.  Unfortunately that doesn't help in
+ * particularly pathological cases in which SCI_EN has to be set directly on
+ * resume, although the specification states very clearly that this flag is
+ * owned by the hardware.  The set_sci_en_on_resume variable will be set in such
+ * cases.
+ */
+static bool set_sci_en_on_resume;
+
 extern void do_suspend_lowlevel(void);
 
 static u32 acpi_suspend_states[] = {
@@ -396,6 +383,20 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 #endif /* CONFIG_SUSPEND */
 
 #ifdef CONFIG_HIBERNATION
+/*
+ * The ACPI specification wants us to save NVS memory regions during hibernation
+ * and to restore them during the subsequent resume.  However, it is not certain
+ * if this mechanism is going to work on all machines, so we allow the user to
+ * disable this mechanism using the 'acpi_sleep=s4_nonvs' kernel command line
+ * option.
+ */
+static bool s4_no_nvs;
+
+void __init acpi_s4_no_nvs(void)
+{
+	s4_no_nvs = true;
+}
+
 static unsigned long s4_hardware_signature;
 static struct acpi_table_facs *facs;
 static bool nosigcheck;

commit d08ca2ca743f324eceba59e93188f9439e966bce
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 16 13:52:03 2009 -0500

    ACPI: rename main.c to sleep.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
new file mode 100644
index 000000000000..7e3c609cbef2
--- /dev/null
+++ b/drivers/acpi/sleep.c
@@ -0,0 +1,747 @@
+/*
+ * sleep.c - ACPI sleep support.
+ *
+ * Copyright (c) 2005 Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
+ * Copyright (c) 2004 David Shaohua Li <shaohua.li@intel.com>
+ * Copyright (c) 2000-2003 Patrick Mochel
+ * Copyright (c) 2003 Open Source Development Lab
+ *
+ * This file is released under the GPLv2.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/dmi.h>
+#include <linux/device.h>
+#include <linux/suspend.h>
+#include <linux/reboot.h>
+
+#include <asm/io.h>
+
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+#include "sleep.h"
+
+u8 sleep_states[ACPI_S_STATE_COUNT];
+
+static void acpi_sleep_tts_switch(u32 acpi_state)
+{
+	union acpi_object in_arg = { ACPI_TYPE_INTEGER };
+	struct acpi_object_list arg_list = { 1, &in_arg };
+	acpi_status status = AE_OK;
+
+	in_arg.integer.value = acpi_state;
+	status = acpi_evaluate_object(NULL, "\\_TTS", &arg_list, NULL);
+	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
+		/*
+		 * OS can't evaluate the _TTS object correctly. Some warning
+		 * message will be printed. But it won't break anything.
+		 */
+		printk(KERN_NOTICE "Failure in evaluating _TTS object\n");
+	}
+}
+
+static int tts_notify_reboot(struct notifier_block *this,
+			unsigned long code, void *x)
+{
+	acpi_sleep_tts_switch(ACPI_STATE_S5);
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block tts_notifier = {
+	.notifier_call	= tts_notify_reboot,
+	.next		= NULL,
+	.priority	= 0,
+};
+
+static int acpi_sleep_prepare(u32 acpi_state)
+{
+#ifdef CONFIG_ACPI_SLEEP
+	/* do we have a wakeup address for S2 and S3? */
+	if (acpi_state == ACPI_STATE_S3) {
+		if (!acpi_wakeup_address) {
+			return -EFAULT;
+		}
+		acpi_set_firmware_waking_vector(
+				(acpi_physical_address)acpi_wakeup_address);
+
+	}
+	ACPI_FLUSH_CPU_CACHE();
+	acpi_enable_wakeup_device_prep(acpi_state);
+#endif
+	printk(KERN_INFO PREFIX "Preparing to enter system sleep state S%d\n",
+		acpi_state);
+	acpi_enter_sleep_state_prep(acpi_state);
+	return 0;
+}
+
+#ifdef CONFIG_ACPI_SLEEP
+static u32 acpi_target_sleep_state = ACPI_STATE_S0;
+/*
+ * ACPI 1.0 wants us to execute _PTS before suspending devices, so we allow the
+ * user to request that behavior by using the 'acpi_old_suspend_ordering'
+ * kernel command line option that causes the following variable to be set.
+ */
+static bool old_suspend_ordering;
+
+void __init acpi_old_suspend_ordering(void)
+{
+	old_suspend_ordering = true;
+}
+
+/*
+ * According to the ACPI specification the BIOS should make sure that ACPI is
+ * enabled and SCI_EN bit is set on wake-up from S1 - S3 sleep states.  Still,
+ * some BIOSes don't do that and therefore we use acpi_enable() to enable ACPI
+ * on such systems during resume.  Unfortunately that doesn't help in
+ * particularly pathological cases in which SCI_EN has to be set directly on
+ * resume, although the specification states very clearly that this flag is
+ * owned by the hardware.  The set_sci_en_on_resume variable will be set in such
+ * cases.
+ */
+static bool set_sci_en_on_resume;
+/*
+ * The ACPI specification wants us to save NVS memory regions during hibernation
+ * and to restore them during the subsequent resume.  However, it is not certain
+ * if this mechanism is going to work on all machines, so we allow the user to
+ * disable this mechanism using the 'acpi_sleep=s4_nonvs' kernel command line
+ * option.
+ */
+static bool s4_no_nvs;
+
+void __init acpi_s4_no_nvs(void)
+{
+	s4_no_nvs = true;
+}
+
+/**
+ *	acpi_pm_disable_gpes - Disable the GPEs.
+ */
+static int acpi_pm_disable_gpes(void)
+{
+	acpi_disable_all_gpes();
+	return 0;
+}
+
+/**
+ *	__acpi_pm_prepare - Prepare the platform to enter the target state.
+ *
+ *	If necessary, set the firmware waking vector and do arch-specific
+ *	nastiness to get the wakeup code to the waking vector.
+ */
+static int __acpi_pm_prepare(void)
+{
+	int error = acpi_sleep_prepare(acpi_target_sleep_state);
+
+	if (error)
+		acpi_target_sleep_state = ACPI_STATE_S0;
+	return error;
+}
+
+/**
+ *	acpi_pm_prepare - Prepare the platform to enter the target sleep
+ *		state and disable the GPEs.
+ */
+static int acpi_pm_prepare(void)
+{
+	int error = __acpi_pm_prepare();
+
+	if (!error)
+		acpi_disable_all_gpes();
+	return error;
+}
+
+/**
+ *	acpi_pm_finish - Instruct the platform to leave a sleep state.
+ *
+ *	This is called after we wake back up (or if entering the sleep state
+ *	failed).
+ */
+static void acpi_pm_finish(void)
+{
+	u32 acpi_state = acpi_target_sleep_state;
+
+	if (acpi_state == ACPI_STATE_S0)
+		return;
+
+	printk(KERN_INFO PREFIX "Waking up from system sleep state S%d\n",
+		acpi_state);
+	acpi_disable_wakeup_device(acpi_state);
+	acpi_leave_sleep_state(acpi_state);
+
+	/* reset firmware waking vector */
+	acpi_set_firmware_waking_vector((acpi_physical_address) 0);
+
+	acpi_target_sleep_state = ACPI_STATE_S0;
+}
+
+/**
+ *	acpi_pm_end - Finish up suspend sequence.
+ */
+static void acpi_pm_end(void)
+{
+	/*
+	 * This is necessary in case acpi_pm_finish() is not called during a
+	 * failing transition to a sleep state.
+	 */
+	acpi_target_sleep_state = ACPI_STATE_S0;
+	acpi_sleep_tts_switch(acpi_target_sleep_state);
+}
+#else /* !CONFIG_ACPI_SLEEP */
+#define acpi_target_sleep_state	ACPI_STATE_S0
+#endif /* CONFIG_ACPI_SLEEP */
+
+#ifdef CONFIG_SUSPEND
+extern void do_suspend_lowlevel(void);
+
+static u32 acpi_suspend_states[] = {
+	[PM_SUSPEND_ON] = ACPI_STATE_S0,
+	[PM_SUSPEND_STANDBY] = ACPI_STATE_S1,
+	[PM_SUSPEND_MEM] = ACPI_STATE_S3,
+	[PM_SUSPEND_MAX] = ACPI_STATE_S5
+};
+
+/**
+ *	acpi_suspend_begin - Set the target system sleep state to the state
+ *		associated with given @pm_state, if supported.
+ */
+static int acpi_suspend_begin(suspend_state_t pm_state)
+{
+	u32 acpi_state = acpi_suspend_states[pm_state];
+	int error = 0;
+
+	if (sleep_states[acpi_state]) {
+		acpi_target_sleep_state = acpi_state;
+		acpi_sleep_tts_switch(acpi_target_sleep_state);
+	} else {
+		printk(KERN_ERR "ACPI does not support this state: %d\n",
+			pm_state);
+		error = -ENOSYS;
+	}
+	return error;
+}
+
+/**
+ *	acpi_suspend_enter - Actually enter a sleep state.
+ *	@pm_state: ignored
+ *
+ *	Flush caches and go to sleep. For STR we have to call arch-specific
+ *	assembly, which in turn call acpi_enter_sleep_state().
+ *	It's unfortunate, but it works. Please fix if you're feeling frisky.
+ */
+static int acpi_suspend_enter(suspend_state_t pm_state)
+{
+	acpi_status status = AE_OK;
+	unsigned long flags = 0;
+	u32 acpi_state = acpi_target_sleep_state;
+
+	ACPI_FLUSH_CPU_CACHE();
+
+	/* Do arch specific saving of state. */
+	if (acpi_state == ACPI_STATE_S3) {
+		int error = acpi_save_state_mem();
+
+		if (error)
+			return error;
+	}
+
+	local_irq_save(flags);
+	acpi_enable_wakeup_device(acpi_state);
+	switch (acpi_state) {
+	case ACPI_STATE_S1:
+		barrier();
+		status = acpi_enter_sleep_state(acpi_state);
+		break;
+
+	case ACPI_STATE_S3:
+		do_suspend_lowlevel();
+		break;
+	}
+
+	/* If ACPI is not enabled by the BIOS, we need to enable it here. */
+	if (set_sci_en_on_resume)
+		acpi_set_register(ACPI_BITREG_SCI_ENABLE, 1);
+	else
+		acpi_enable();
+
+	/* Reprogram control registers and execute _BFS */
+	acpi_leave_sleep_state_prep(acpi_state);
+
+	/* ACPI 3.0 specs (P62) says that it's the responsibility
+	 * of the OSPM to clear the status bit [ implying that the
+	 * POWER_BUTTON event should not reach userspace ]
+	 */
+	if (ACPI_SUCCESS(status) && (acpi_state == ACPI_STATE_S3))
+		acpi_clear_event(ACPI_EVENT_POWER_BUTTON);
+
+	/*
+	 * Disable and clear GPE status before interrupt is enabled. Some GPEs
+	 * (like wakeup GPE) haven't handler, this can avoid such GPE misfire.
+	 * acpi_leave_sleep_state will reenable specific GPEs later
+	 */
+	acpi_disable_all_gpes();
+
+	local_irq_restore(flags);
+	printk(KERN_DEBUG "Back to C!\n");
+
+	/* restore processor state */
+	if (acpi_state == ACPI_STATE_S3)
+		acpi_restore_state_mem();
+
+	return ACPI_SUCCESS(status) ? 0 : -EFAULT;
+}
+
+static int acpi_suspend_state_valid(suspend_state_t pm_state)
+{
+	u32 acpi_state;
+
+	switch (pm_state) {
+	case PM_SUSPEND_ON:
+	case PM_SUSPEND_STANDBY:
+	case PM_SUSPEND_MEM:
+		acpi_state = acpi_suspend_states[pm_state];
+
+		return sleep_states[acpi_state];
+	default:
+		return 0;
+	}
+}
+
+static struct platform_suspend_ops acpi_suspend_ops = {
+	.valid = acpi_suspend_state_valid,
+	.begin = acpi_suspend_begin,
+	.prepare = acpi_pm_prepare,
+	.enter = acpi_suspend_enter,
+	.finish = acpi_pm_finish,
+	.end = acpi_pm_end,
+};
+
+/**
+ *	acpi_suspend_begin_old - Set the target system sleep state to the
+ *		state associated with given @pm_state, if supported, and
+ *		execute the _PTS control method.  This function is used if the
+ *		pre-ACPI 2.0 suspend ordering has been requested.
+ */
+static int acpi_suspend_begin_old(suspend_state_t pm_state)
+{
+	int error = acpi_suspend_begin(pm_state);
+
+	if (!error)
+		error = __acpi_pm_prepare();
+	return error;
+}
+
+/*
+ * The following callbacks are used if the pre-ACPI 2.0 suspend ordering has
+ * been requested.
+ */
+static struct platform_suspend_ops acpi_suspend_ops_old = {
+	.valid = acpi_suspend_state_valid,
+	.begin = acpi_suspend_begin_old,
+	.prepare = acpi_pm_disable_gpes,
+	.enter = acpi_suspend_enter,
+	.finish = acpi_pm_finish,
+	.end = acpi_pm_end,
+	.recover = acpi_pm_finish,
+};
+
+static int __init init_old_suspend_ordering(const struct dmi_system_id *d)
+{
+	old_suspend_ordering = true;
+	return 0;
+}
+
+static int __init init_set_sci_en_on_resume(const struct dmi_system_id *d)
+{
+	set_sci_en_on_resume = true;
+	return 0;
+}
+
+static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
+	{
+	.callback = init_old_suspend_ordering,
+	.ident = "Abit KN9 (nForce4 variant)",
+	.matches = {
+		DMI_MATCH(DMI_BOARD_VENDOR, "http://www.abit.com.tw/"),
+		DMI_MATCH(DMI_BOARD_NAME, "KN9 Series(NF-CK804)"),
+		},
+	},
+	{
+	.callback = init_old_suspend_ordering,
+	.ident = "HP xw4600 Workstation",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "HP xw4600 Workstation"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Apple MacBook 1,1",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Apple Computer, Inc."),
+		DMI_MATCH(DMI_PRODUCT_NAME, "MacBook1,1"),
+		},
+	},
+	{
+	.callback = init_set_sci_en_on_resume,
+	.ident = "Apple MacMini 1,1",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Apple Computer, Inc."),
+		DMI_MATCH(DMI_PRODUCT_NAME, "Macmini1,1"),
+		},
+	},
+	{},
+};
+#endif /* CONFIG_SUSPEND */
+
+#ifdef CONFIG_HIBERNATION
+static unsigned long s4_hardware_signature;
+static struct acpi_table_facs *facs;
+static bool nosigcheck;
+
+void __init acpi_no_s4_hw_signature(void)
+{
+	nosigcheck = true;
+}
+
+static int acpi_hibernation_begin(void)
+{
+	int error;
+
+	error = s4_no_nvs ? 0 : hibernate_nvs_alloc();
+	if (!error) {
+		acpi_target_sleep_state = ACPI_STATE_S4;
+		acpi_sleep_tts_switch(acpi_target_sleep_state);
+	}
+
+	return error;
+}
+
+static int acpi_hibernation_pre_snapshot(void)
+{
+	int error = acpi_pm_prepare();
+
+	if (!error)
+		hibernate_nvs_save();
+
+	return error;
+}
+
+static int acpi_hibernation_enter(void)
+{
+	acpi_status status = AE_OK;
+	unsigned long flags = 0;
+
+	ACPI_FLUSH_CPU_CACHE();
+
+	local_irq_save(flags);
+	acpi_enable_wakeup_device(ACPI_STATE_S4);
+	/* This shouldn't return.  If it returns, we have a problem */
+	status = acpi_enter_sleep_state(ACPI_STATE_S4);
+	/* Reprogram control registers and execute _BFS */
+	acpi_leave_sleep_state_prep(ACPI_STATE_S4);
+	local_irq_restore(flags);
+
+	return ACPI_SUCCESS(status) ? 0 : -EFAULT;
+}
+
+static void acpi_hibernation_finish(void)
+{
+	hibernate_nvs_free();
+	acpi_pm_finish();
+}
+
+static void acpi_hibernation_leave(void)
+{
+	/*
+	 * If ACPI is not enabled by the BIOS and the boot kernel, we need to
+	 * enable it here.
+	 */
+	acpi_enable();
+	/* Reprogram control registers and execute _BFS */
+	acpi_leave_sleep_state_prep(ACPI_STATE_S4);
+	/* Check the hardware signature */
+	if (facs && s4_hardware_signature != facs->hardware_signature) {
+		printk(KERN_EMERG "ACPI: Hardware changed while hibernated, "
+			"cannot resume!\n");
+		panic("ACPI S4 hardware signature mismatch");
+	}
+	/* Restore the NVS memory area */
+	hibernate_nvs_restore();
+}
+
+static void acpi_pm_enable_gpes(void)
+{
+	acpi_enable_all_runtime_gpes();
+}
+
+static struct platform_hibernation_ops acpi_hibernation_ops = {
+	.begin = acpi_hibernation_begin,
+	.end = acpi_pm_end,
+	.pre_snapshot = acpi_hibernation_pre_snapshot,
+	.finish = acpi_hibernation_finish,
+	.prepare = acpi_pm_prepare,
+	.enter = acpi_hibernation_enter,
+	.leave = acpi_hibernation_leave,
+	.pre_restore = acpi_pm_disable_gpes,
+	.restore_cleanup = acpi_pm_enable_gpes,
+};
+
+/**
+ *	acpi_hibernation_begin_old - Set the target system sleep state to
+ *		ACPI_STATE_S4 and execute the _PTS control method.  This
+ *		function is used if the pre-ACPI 2.0 suspend ordering has been
+ *		requested.
+ */
+static int acpi_hibernation_begin_old(void)
+{
+	int error;
+	/*
+	 * The _TTS object should always be evaluated before the _PTS object.
+	 * When the old_suspended_ordering is true, the _PTS object is
+	 * evaluated in the acpi_sleep_prepare.
+	 */
+	acpi_sleep_tts_switch(ACPI_STATE_S4);
+
+	error = acpi_sleep_prepare(ACPI_STATE_S4);
+
+	if (!error) {
+		if (!s4_no_nvs)
+			error = hibernate_nvs_alloc();
+		if (!error)
+			acpi_target_sleep_state = ACPI_STATE_S4;
+	}
+	return error;
+}
+
+static int acpi_hibernation_pre_snapshot_old(void)
+{
+	int error = acpi_pm_disable_gpes();
+
+	if (!error)
+		hibernate_nvs_save();
+
+	return error;
+}
+
+/*
+ * The following callbacks are used if the pre-ACPI 2.0 suspend ordering has
+ * been requested.
+ */
+static struct platform_hibernation_ops acpi_hibernation_ops_old = {
+	.begin = acpi_hibernation_begin_old,
+	.end = acpi_pm_end,
+	.pre_snapshot = acpi_hibernation_pre_snapshot_old,
+	.finish = acpi_hibernation_finish,
+	.prepare = acpi_pm_disable_gpes,
+	.enter = acpi_hibernation_enter,
+	.leave = acpi_hibernation_leave,
+	.pre_restore = acpi_pm_disable_gpes,
+	.restore_cleanup = acpi_pm_enable_gpes,
+	.recover = acpi_pm_finish,
+};
+#endif /* CONFIG_HIBERNATION */
+
+int acpi_suspend(u32 acpi_state)
+{
+	suspend_state_t states[] = {
+		[1] = PM_SUSPEND_STANDBY,
+		[3] = PM_SUSPEND_MEM,
+		[5] = PM_SUSPEND_MAX
+	};
+
+	if (acpi_state < 6 && states[acpi_state])
+		return pm_suspend(states[acpi_state]);
+	if (acpi_state == 4)
+		return hibernate();
+	return -EINVAL;
+}
+
+#ifdef CONFIG_PM_SLEEP
+/**
+ *	acpi_pm_device_sleep_state - return preferred power state of ACPI device
+ *		in the system sleep state given by %acpi_target_sleep_state
+ *	@dev: device to examine; its driver model wakeup flags control
+ *		whether it should be able to wake up the system
+ *	@d_min_p: used to store the upper limit of allowed states range
+ *	Return value: preferred power state of the device on success, -ENODEV on
+ *		failure (ie. if there's no 'struct acpi_device' for @dev)
+ *
+ *	Find the lowest power (highest number) ACPI device power state that
+ *	device @dev can be in while the system is in the sleep state represented
+ *	by %acpi_target_sleep_state.  If @wake is nonzero, the device should be
+ *	able to wake up the system from this sleep state.  If @d_min_p is set,
+ *	the highest power (lowest number) device power state of @dev allowed
+ *	in this system sleep state is stored at the location pointed to by it.
+ *
+ *	The caller must ensure that @dev is valid before using this function.
+ *	The caller is also responsible for figuring out if the device is
+ *	supposed to be able to wake up the system and passing this information
+ *	via @wake.
+ */
+
+int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p)
+{
+	acpi_handle handle = DEVICE_ACPI_HANDLE(dev);
+	struct acpi_device *adev;
+	char acpi_method[] = "_SxD";
+	unsigned long long d_min, d_max;
+
+	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &adev))) {
+		printk(KERN_DEBUG "ACPI handle has no context!\n");
+		return -ENODEV;
+	}
+
+	acpi_method[2] = '0' + acpi_target_sleep_state;
+	/*
+	 * If the sleep state is S0, we will return D3, but if the device has
+	 * _S0W, we will use the value from _S0W
+	 */
+	d_min = ACPI_STATE_D0;
+	d_max = ACPI_STATE_D3;
+
+	/*
+	 * If present, _SxD methods return the minimum D-state (highest power
+	 * state) we can use for the corresponding S-states.  Otherwise, the
+	 * minimum D-state is D0 (ACPI 3.x).
+	 *
+	 * NOTE: We rely on acpi_evaluate_integer() not clobbering the integer
+	 * provided -- that's our fault recovery, we ignore retval.
+	 */
+	if (acpi_target_sleep_state > ACPI_STATE_S0)
+		acpi_evaluate_integer(handle, acpi_method, NULL, &d_min);
+
+	/*
+	 * If _PRW says we can wake up the system from the target sleep state,
+	 * the D-state returned by _SxD is sufficient for that (we assume a
+	 * wakeup-aware driver if wake is set).  Still, if _SxW exists
+	 * (ACPI 3.x), it should return the maximum (lowest power) D-state that
+	 * can wake the system.  _S0W may be valid, too.
+	 */
+	if (acpi_target_sleep_state == ACPI_STATE_S0 ||
+	    (device_may_wakeup(dev) && adev->wakeup.state.enabled &&
+	     adev->wakeup.sleep_state <= acpi_target_sleep_state)) {
+		acpi_status status;
+
+		acpi_method[3] = 'W';
+		status = acpi_evaluate_integer(handle, acpi_method, NULL,
+						&d_max);
+		if (ACPI_FAILURE(status)) {
+			d_max = d_min;
+		} else if (d_max < d_min) {
+			/* Warn the user of the broken DSDT */
+			printk(KERN_WARNING "ACPI: Wrong value from %s\n",
+				acpi_method);
+			/* Sanitize it */
+			d_min = d_max;
+		}
+	}
+
+	if (d_min_p)
+		*d_min_p = d_min;
+	return d_max;
+}
+
+/**
+ *	acpi_pm_device_sleep_wake - enable or disable the system wake-up
+ *                                  capability of given device
+ *	@dev: device to handle
+ *	@enable: 'true' - enable, 'false' - disable the wake-up capability
+ */
+int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
+{
+	acpi_handle handle;
+	struct acpi_device *adev;
+
+	if (!device_may_wakeup(dev))
+		return -EINVAL;
+
+	handle = DEVICE_ACPI_HANDLE(dev);
+	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &adev))) {
+		printk(KERN_DEBUG "ACPI handle has no context!\n");
+		return -ENODEV;
+	}
+
+	return enable ?
+		acpi_enable_wakeup_device_power(adev, acpi_target_sleep_state) :
+		acpi_disable_wakeup_device_power(adev);
+}
+#endif
+
+static void acpi_power_off_prepare(void)
+{
+	/* Prepare to power off the system */
+	acpi_sleep_prepare(ACPI_STATE_S5);
+	acpi_disable_all_gpes();
+}
+
+static void acpi_power_off(void)
+{
+	/* acpi_sleep_prepare(ACPI_STATE_S5) should have already been called */
+	printk("%s called\n", __func__);
+	local_irq_disable();
+	acpi_enable_wakeup_device(ACPI_STATE_S5);
+	acpi_enter_sleep_state(ACPI_STATE_S5);
+}
+
+int __init acpi_sleep_init(void)
+{
+	acpi_status status;
+	u8 type_a, type_b;
+#ifdef CONFIG_SUSPEND
+	int i = 0;
+
+	dmi_check_system(acpisleep_dmi_table);
+#endif
+
+	if (acpi_disabled)
+		return 0;
+
+	sleep_states[ACPI_STATE_S0] = 1;
+	printk(KERN_INFO PREFIX "(supports S0");
+
+#ifdef CONFIG_SUSPEND
+	for (i = ACPI_STATE_S1; i < ACPI_STATE_S4; i++) {
+		status = acpi_get_sleep_type_data(i, &type_a, &type_b);
+		if (ACPI_SUCCESS(status)) {
+			sleep_states[i] = 1;
+			printk(" S%d", i);
+		}
+	}
+
+	suspend_set_ops(old_suspend_ordering ?
+		&acpi_suspend_ops_old : &acpi_suspend_ops);
+#endif
+
+#ifdef CONFIG_HIBERNATION
+	status = acpi_get_sleep_type_data(ACPI_STATE_S4, &type_a, &type_b);
+	if (ACPI_SUCCESS(status)) {
+		hibernation_set_ops(old_suspend_ordering ?
+			&acpi_hibernation_ops_old : &acpi_hibernation_ops);
+		sleep_states[ACPI_STATE_S4] = 1;
+		printk(" S4");
+		if (!nosigcheck) {
+			acpi_get_table(ACPI_SIG_FACS, 1,
+				(struct acpi_table_header **)&facs);
+			if (facs)
+				s4_hardware_signature =
+					facs->hardware_signature;
+		}
+	}
+#endif
+	status = acpi_get_sleep_type_data(ACPI_STATE_S5, &type_a, &type_b);
+	if (ACPI_SUCCESS(status)) {
+		sleep_states[ACPI_STATE_S5] = 1;
+		printk(" S5");
+		pm_power_off_prepare = acpi_power_off_prepare;
+		pm_power_off = acpi_power_off;
+	}
+	printk(")\n");
+	/*
+	 * Register the tts_notifier to reboot notifier list so that the _TTS
+	 * object can also be evaluated when the system enters S5.
+	 */
+	register_reboot_notifier(&tts_notifier);
+	return 0;
+}
