commit 23ba710a0864108910c7531dc4c73ef65eca5568
Author: Tony Luck <tony.luck@intel.com>
Date:   Fri Feb 14 14:27:17 2020 -0800

    x86/mce: Fix all mce notifiers to update the mce->kflags bitmask
    
    If the handler took any action to log or deal with the error, set a bit
    in mce->kflags so that the default handler on the end of the machine
    check chain can see what has been done.
    
    Get rid of NOTIFY_STOP returns. Make the EDAC and dev-mcelog handlers
    skip over errors already processed by CEC.
    
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Tested-by: Tony Luck <tony.luck@intel.com>
    Link: https://lkml.kernel.org/r/20200214222720.13168-5-tony.luck@intel.com

diff --git a/drivers/acpi/nfit/mce.c b/drivers/acpi/nfit/mce.c
index f0ae48515b48..ee8d9973f60b 100644
--- a/drivers/acpi/nfit/mce.c
+++ b/drivers/acpi/nfit/mce.c
@@ -76,6 +76,7 @@ static int nfit_handle_mce(struct notifier_block *nb, unsigned long val,
 			 */
 			acpi_nfit_ars_rescan(acpi_desc, 0);
 		}
+		mce->kflags |= MCE_HANDLED_NFIT;
 		break;
 	}
 

commit 5b497af42fab12cadc0e29bcb7052cf9963603f5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:18:09 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 295
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of version 2 of the gnu general public license as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 64 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141901.894819585@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/nfit/mce.c b/drivers/acpi/nfit/mce.c
index d6c1b10f6c25..f0ae48515b48 100644
--- a/drivers/acpi/nfit/mce.c
+++ b/drivers/acpi/nfit/mce.c
@@ -1,16 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * NFIT - Machine Check Handler
  *
  * Copyright(c) 2013-2016 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
  */
 #include <linux/notifier.h>
 #include <linux/acpi.h>

commit e8a308e5f47e545e0d41d0686c00f5f5217c5f61
Author: Vishal Verma <vishal.l.verma@intel.com>
Date:   Thu Oct 25 18:37:29 2018 -0600

    acpi/nfit, x86/mce: Validate a MCE's address before using it
    
    The NFIT machine check handler uses the physical address from the mce
    structure, and compares it against information in the ACPI NFIT table
    to determine whether that location lies on an NVDIMM. The mce->addr
    field however may not always be valid, and this is indicated by the
    MCI_STATUS_ADDRV bit in the status field.
    
    Export mce_usable_address() which already performs validation for the
    address, and use it in the NFIT handler.
    
    Fixes: 6839a6d96f4e ("nfit: do an ARS scrub on hitting a latent media error")
    Reported-by: Robert Elliott <elliott@hpe.com>
    Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    CC: Arnd Bergmann <arnd@arndb.de>
    Cc: Dan Williams <dan.j.williams@intel.com>
    CC: Dave Jiang <dave.jiang@intel.com>
    CC: elliott@hpe.com
    CC: "H. Peter Anvin" <hpa@zytor.com>
    CC: Ingo Molnar <mingo@redhat.com>
    CC: Len Brown <lenb@kernel.org>
    CC: linux-acpi@vger.kernel.org
    CC: linux-edac <linux-edac@vger.kernel.org>
    CC: linux-nvdimm@lists.01.org
    CC: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
    CC: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    CC: Ross Zwisler <zwisler@kernel.org>
    CC: stable <stable@vger.kernel.org>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Tony Luck <tony.luck@intel.com>
    CC: x86-ml <x86@kernel.org>
    CC: Yazen Ghannam <yazen.ghannam@amd.com>
    Link: http://lkml.kernel.org/r/20181026003729.8420-2-vishal.l.verma@intel.com

diff --git a/drivers/acpi/nfit/mce.c b/drivers/acpi/nfit/mce.c
index 7a51707f87e9..d6c1b10f6c25 100644
--- a/drivers/acpi/nfit/mce.c
+++ b/drivers/acpi/nfit/mce.c
@@ -29,6 +29,10 @@ static int nfit_handle_mce(struct notifier_block *nb, unsigned long val,
 	if (!mce_is_memory_error(mce) || mce_is_correctable(mce))
 		return NOTIFY_DONE;
 
+	/* Verify the address reported in the MCE is valid. */
+	if (!mce_usable_address(mce))
+		return NOTIFY_DONE;
+
 	/*
 	 * mce->addr contains the physical addr accessed that caused the
 	 * machine check. We need to walk through the list of NFITs, and see

commit 5d96c9342c23ee1d084802dcf064caa67ecaa45b
Author: Vishal Verma <vishal.l.verma@intel.com>
Date:   Thu Oct 25 18:37:28 2018 -0600

    acpi/nfit, x86/mce: Handle only uncorrectable machine checks
    
    The MCE handler for nfit devices is called for memory errors on a
    Non-Volatile DIMM and adds the error location to a 'badblocks' list.
    This list is used by the various NVDIMM drivers to avoid consuming known
    poison locations during IO.
    
    The MCE handler gets called for both corrected and uncorrectable errors.
    Until now, both kinds of errors have been added to the badblocks list.
    However, corrected memory errors indicate that the problem has already
    been fixed by hardware, and the resulting interrupt is merely a
    notification to Linux.
    
    As far as future accesses to that location are concerned, it is
    perfectly fine to use, and thus doesn't need to be included in the above
    badblocks list.
    
    Add a check in the nfit MCE handler to filter out corrected mce events,
    and only process uncorrectable errors.
    
    Fixes: 6839a6d96f4e ("nfit: do an ARS scrub on hitting a latent media error")
    Reported-by: Omar Avelar <omar.avelar@intel.com>
    Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    CC: Arnd Bergmann <arnd@arndb.de>
    CC: Dan Williams <dan.j.williams@intel.com>
    CC: Dave Jiang <dave.jiang@intel.com>
    CC: elliott@hpe.com
    CC: "H. Peter Anvin" <hpa@zytor.com>
    CC: Ingo Molnar <mingo@redhat.com>
    CC: Len Brown <lenb@kernel.org>
    CC: linux-acpi@vger.kernel.org
    CC: linux-edac <linux-edac@vger.kernel.org>
    CC: linux-nvdimm@lists.01.org
    CC: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
    CC: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    CC: Ross Zwisler <zwisler@kernel.org>
    CC: stable <stable@vger.kernel.org>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Tony Luck <tony.luck@intel.com>
    CC: x86-ml <x86@kernel.org>
    CC: Yazen Ghannam <yazen.ghannam@amd.com>
    Link: http://lkml.kernel.org/r/20181026003729.8420-1-vishal.l.verma@intel.com

diff --git a/drivers/acpi/nfit/mce.c b/drivers/acpi/nfit/mce.c
index e9626bf6ca29..7a51707f87e9 100644
--- a/drivers/acpi/nfit/mce.c
+++ b/drivers/acpi/nfit/mce.c
@@ -25,8 +25,8 @@ static int nfit_handle_mce(struct notifier_block *nb, unsigned long val,
 	struct acpi_nfit_desc *acpi_desc;
 	struct nfit_spa *nfit_spa;
 
-	/* We only care about memory errors */
-	if (!mce_is_memory_error(mce))
+	/* We only care about uncorrectable memory errors */
+	if (!mce_is_memory_error(mce) || mce_is_correctable(mce))
 		return NOTIFY_DONE;
 
 	/*

commit b814735f5ca477a6d4f446f00d16da4a18e33bf5
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Fri Mar 2 13:20:49 2018 +0100

    acpi, nfit: remove redundant __func__ in dev_dbg
    
    Dynamic debug can be instructed to add the function name to the debug
    output using the +f switch, so there is no need for the nfit module to
    do it again. If a user decides to add the +f switch for nfit's dynamic
    debug this results in double prints of the function name like the
    following:
    
    [ 2391.935383] acpi_nfit_ctl: nfit ACPI0012:00: acpi_nfit_ctl:nmem8 cmd: 10: func: 1 input length: 0
    
    Thus remove the stray __func__ printing.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/mce.c b/drivers/acpi/nfit/mce.c
index b92921439657..e9626bf6ca29 100644
--- a/drivers/acpi/nfit/mce.c
+++ b/drivers/acpi/nfit/mce.c
@@ -51,9 +51,8 @@ static int nfit_handle_mce(struct notifier_block *nb, unsigned long val,
 			if ((spa->address + spa->length - 1) < mce->addr)
 				continue;
 			found_match = 1;
-			dev_dbg(dev, "%s: addr in SPA %d (0x%llx, 0x%llx)\n",
-				__func__, spa->range_index, spa->address,
-				spa->length);
+			dev_dbg(dev, "addr in SPA %d (0x%llx, 0x%llx)\n",
+				spa->range_index, spa->address, spa->length);
 			/*
 			 * We can break at the first match because we're going
 			 * to rescan all the SPA ranges. There shouldn't be any

commit aa9ad44a42b4cf4387f8ecddaf8e51707fdcda5a
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed Aug 23 12:48:26 2017 -0700

    libnvdimm: move poison list functions to a new 'badrange' file
    
    nfit_test needs to use the poison list manipulation code as well. Make
    it more generic and in the process rename poison to badrange, and move
    all the related helpers to a new file.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    [vishal: Add badrange.o to nfit_test's Kbuild]
    [vishal: add a missed include in bus.c for the new badrange functions]
    [vishal: rename all instances of 'be' to 'bre']
    Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/mce.c b/drivers/acpi/nfit/mce.c
index feeb95d574fa..b92921439657 100644
--- a/drivers/acpi/nfit/mce.c
+++ b/drivers/acpi/nfit/mce.c
@@ -67,7 +67,7 @@ static int nfit_handle_mce(struct notifier_block *nb, unsigned long val,
 			continue;
 
 		/* If this fails due to an -ENOMEM, there is little we can do */
-		nvdimm_bus_add_poison(acpi_desc->nvdimm_bus,
+		nvdimm_bus_add_badrange(acpi_desc->nvdimm_bus,
 				ALIGN(mce->addr, L1_CACHE_BYTES),
 				L1_CACHE_BYTES);
 		nvdimm_region_notify(nfit_spa->nd_region,

commit 807900395efebf9276178eb6157959f2e81fe013
Author: Toshi Kani <toshi.kani@hpe.com>
Date:   Thu Jun 29 20:41:30 2017 -0600

    acpi/nfit: Issue Start ARS to retrieve existing records
    
    ACPI 6.2 defines in section 9.20.7.2 that the OSPM may call a Start
    ARS with Flags Bit [1] set upon receiving the 0x81 notification.
    
      Upon receiving the notification, the OSPM may decide to issue
      a Start ARS with Flags Bit [1] set to prepare for the retrieval
      of existing records and issue the Query ARS Status function to
      retrieve the records.
    
    Add support to call a Start ARS from acpi_nfit_uc_error_notify()
    with ND_ARS_RETURN_PREV_DATA set when HW_ERROR_SCRUB_ON is not set.
    
    Link: http://www.uefi.org/sites/default/files/resources/ACPI_6_2.pdf
    Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Vishal Verma <vishal.l.verma@intel.com>
    Cc: Linda Knippers <linda.knippers@hpe.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/mce.c b/drivers/acpi/nfit/mce.c
index fd86bec98dea..feeb95d574fa 100644
--- a/drivers/acpi/nfit/mce.c
+++ b/drivers/acpi/nfit/mce.c
@@ -79,7 +79,7 @@ static int nfit_handle_mce(struct notifier_block *nb, unsigned long val,
 			 * already in progress, just let that be the last
 			 * authoritative one
 			 */
-			acpi_nfit_ars_rescan(acpi_desc);
+			acpi_nfit_ars_rescan(acpi_desc, 0);
 		}
 		break;
 	}

commit fc08a4703a418a398bbb575ac311d36d110ac786
Author: Vishal Verma <vishal.l.verma@intel.com>
Date:   Fri May 19 11:39:10 2017 +0200

    acpi, nfit: Fix the memory error check in nfit_handle_mce()
    
    The check for an MCE being a memory error in the NFIT mce handler was
    bogus. Use the new mce_is_memory_error() helper to detect the error
    properly.
    
    Reported-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: <stable@vger.kernel.org>
    Link: http://lkml.kernel.org/r/20170519093915.15413-3-bp@alien8.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/acpi/nfit/mce.c b/drivers/acpi/nfit/mce.c
index 3ba1c3472cf9..fd86bec98dea 100644
--- a/drivers/acpi/nfit/mce.c
+++ b/drivers/acpi/nfit/mce.c
@@ -26,7 +26,7 @@ static int nfit_handle_mce(struct notifier_block *nb, unsigned long val,
 	struct nfit_spa *nfit_spa;
 
 	/* We only care about memory errors */
-	if (!(mce->status & MCACOD))
+	if (!mce_is_memory_error(mce))
 		return NOTIFY_DONE;
 
 	/*

commit 9026cc82b632ed1a859935c82ed8ad65f27f2781
Author: Borislav Petkov <bp@suse.de>
Date:   Mon Jan 23 19:35:14 2017 +0100

    x86/ras, EDAC, acpi: Assign MCE notifier handlers a priority
    
    Assign all notifiers on the MCE decode chain a priority so that they get
    called in the correct order.
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Yazen Ghannam <Yazen.Ghannam@amd.com>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Link: http://lkml.kernel.org/r/20170123183514.13356-10-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/acpi/nfit/mce.c b/drivers/acpi/nfit/mce.c
index e5ce81c38eed..3ba1c3472cf9 100644
--- a/drivers/acpi/nfit/mce.c
+++ b/drivers/acpi/nfit/mce.c
@@ -90,6 +90,7 @@ static int nfit_handle_mce(struct notifier_block *nb, unsigned long val,
 
 static struct notifier_block nfit_mce_dec = {
 	.notifier_call	= nfit_handle_mce,
+	.priority	= MCE_PRIO_NFIT,
 };
 
 void nfit_mce_register(void)

commit 178d6f4be8bf42b298bedf8ea2a00754100e0c4e
Merge: db58028ee4e3 98a29c39dc68
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Oct 7 16:46:24 2016 -0700

    Merge branch 'for-4.9/libnvdimm' into libnvdimm-for-next

commit 9ffd6350a103cb9e73e3abb4573c900cfead2f9b
Author: Vishal Verma <vishal.l.verma@intel.com>
Date:   Fri Sep 30 17:19:29 2016 -0600

    nfit: don't start a full scrub by default for an MCE
    
    Starting a full Address Range Scrub (ARS) on hitting a memory error
    machine check exception may not always be desirable. Provide a way
    through sysfs to toggle the behavior between just adding the address
    (cache line) where the MCE happened to the poison list and doing a full
    scrub. The former (selective insertion of the address) is done
    unconditionally.
    
    Cc: linux-acpi@vger.kernel.org
    Cc: Linda Knippers <linda.knippers@hpe.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/mce.c b/drivers/acpi/nfit/mce.c
index 4c745bf389fe..2e25e252945f 100644
--- a/drivers/acpi/nfit/mce.c
+++ b/drivers/acpi/nfit/mce.c
@@ -14,6 +14,7 @@
  */
 #include <linux/notifier.h>
 #include <linux/acpi.h>
+#include <linux/nd.h>
 #include <asm/mce.h>
 #include "nfit.h"
 
@@ -62,12 +63,25 @@ static int nfit_handle_mce(struct notifier_block *nb, unsigned long val,
 		}
 		mutex_unlock(&acpi_desc->init_mutex);
 
-		/*
-		 * We can ignore an -EBUSY here because if an ARS is already
-		 * in progress, just let that be the last authoritative one
-		 */
-		if (found_match)
+		if (!found_match)
+			continue;
+
+		/* If this fails due to an -ENOMEM, there is little we can do */
+		nvdimm_bus_add_poison(acpi_desc->nvdimm_bus,
+				ALIGN(mce->addr, L1_CACHE_BYTES),
+				L1_CACHE_BYTES);
+		nvdimm_region_notify(nfit_spa->nd_region,
+				NVDIMM_REVALIDATE_POISON);
+
+		if (acpi_desc->scrub_mode == HW_ERROR_SCRUB_ON) {
+			/*
+			 * We can ignore an -EBUSY here because if an ARS is
+			 * already in progress, just let that be the last
+			 * authoritative one
+			 */
 			acpi_nfit_ars_rescan(acpi_desc);
+		}
+		break;
 	}
 
 	mutex_unlock(&acpi_desc_lock);

commit 2e21807d4b131dfd4a8e5c82116a85b62f28aeec
Author: Vishal Verma <vishal.l.verma@intel.com>
Date:   Fri Sep 2 17:27:30 2016 -0600

    nfit, mce: Fix SPA matching logic in MCE handler
    
    The check for a 'pmem' type SPA in the MCE handler was inverted due to a
    merge/rebase error.
    
    Fixes: 6839a6d nfit: do an ARS scrub on hitting a latent media error
    Cc: linux-acpi@vger.kernel.org
    Cc: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/mce.c b/drivers/acpi/nfit/mce.c
index 4c745bf389fe..161f91539ae6 100644
--- a/drivers/acpi/nfit/mce.c
+++ b/drivers/acpi/nfit/mce.c
@@ -42,7 +42,7 @@ static int nfit_handle_mce(struct notifier_block *nb, unsigned long val,
 		list_for_each_entry(nfit_spa, &acpi_desc->spas, list) {
 			struct acpi_nfit_system_address *spa = nfit_spa->spa;
 
-			if (nfit_spa_type(spa) == NFIT_SPA_PM)
+			if (nfit_spa_type(spa) != NFIT_SPA_PM)
 				continue;
 			/* find the spa that covers the mce addr */
 			if (spa->address > mce->addr)

commit 6839a6d96f4ea0254266d60208c1fbbd53ade546
Author: Vishal Verma <vishal.l.verma@intel.com>
Date:   Sat Jul 23 21:51:21 2016 -0700

    nfit: do an ARS scrub on hitting a latent media error
    
    When a latent (unknown to 'badblocks') error is encountered, it will
    trigger a machine check exception. On a system with machine check
    recovery, this will only SIGBUS the process(es) which had the bad page
    mapped (as opposed to a kernel panic on platforms without machine
    check recovery features). In the former case, we want to trigger a full
    rescan of that nvdimm bus. This will allow any additional, new errors
    to be captured in the block devices' badblocks lists, and offending
    operations on them can be trapped early, avoiding machine checks.
    
    This is done by registering a callback function with the
    x86_mce_decoder_chain and calling the new ars_rescan functionality with
    the address in the mce notificatiion.
    
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/mce.c b/drivers/acpi/nfit/mce.c
new file mode 100644
index 000000000000..4c745bf389fe
--- /dev/null
+++ b/drivers/acpi/nfit/mce.c
@@ -0,0 +1,89 @@
+/*
+ * NFIT - Machine Check Handler
+ *
+ * Copyright(c) 2013-2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+#include <linux/notifier.h>
+#include <linux/acpi.h>
+#include <asm/mce.h>
+#include "nfit.h"
+
+static int nfit_handle_mce(struct notifier_block *nb, unsigned long val,
+			void *data)
+{
+	struct mce *mce = (struct mce *)data;
+	struct acpi_nfit_desc *acpi_desc;
+	struct nfit_spa *nfit_spa;
+
+	/* We only care about memory errors */
+	if (!(mce->status & MCACOD))
+		return NOTIFY_DONE;
+
+	/*
+	 * mce->addr contains the physical addr accessed that caused the
+	 * machine check. We need to walk through the list of NFITs, and see
+	 * if any of them matches that address, and only then start a scrub.
+	 */
+	mutex_lock(&acpi_desc_lock);
+	list_for_each_entry(acpi_desc, &acpi_descs, list) {
+		struct device *dev = acpi_desc->dev;
+		int found_match = 0;
+
+		mutex_lock(&acpi_desc->init_mutex);
+		list_for_each_entry(nfit_spa, &acpi_desc->spas, list) {
+			struct acpi_nfit_system_address *spa = nfit_spa->spa;
+
+			if (nfit_spa_type(spa) == NFIT_SPA_PM)
+				continue;
+			/* find the spa that covers the mce addr */
+			if (spa->address > mce->addr)
+				continue;
+			if ((spa->address + spa->length - 1) < mce->addr)
+				continue;
+			found_match = 1;
+			dev_dbg(dev, "%s: addr in SPA %d (0x%llx, 0x%llx)\n",
+				__func__, spa->range_index, spa->address,
+				spa->length);
+			/*
+			 * We can break at the first match because we're going
+			 * to rescan all the SPA ranges. There shouldn't be any
+			 * aliasing anyway.
+			 */
+			break;
+		}
+		mutex_unlock(&acpi_desc->init_mutex);
+
+		/*
+		 * We can ignore an -EBUSY here because if an ARS is already
+		 * in progress, just let that be the last authoritative one
+		 */
+		if (found_match)
+			acpi_nfit_ars_rescan(acpi_desc);
+	}
+
+	mutex_unlock(&acpi_desc_lock);
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block nfit_mce_dec = {
+	.notifier_call	= nfit_handle_mce,
+};
+
+void nfit_mce_register(void)
+{
+	mce_register_decode_chain(&nfit_mce_dec);
+}
+
+void nfit_mce_unregister(void)
+{
+	mce_unregister_decode_chain(&nfit_mce_dec);
+}
