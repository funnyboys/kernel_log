commit f6d2b802f80d0ca89ee1f51c1781b3f79cdb25d5
Merge: d3b88655c0a1 4e4ced93794a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Apr 2 19:55:17 2020 -0700

    Merge branch 'for-5.7/libnvdimm' into libnvdimm-for-next
    
    - Introduce 'zero_page_range' as a dax operation. This facilitates
      filesystem-dax operation without a block-device.
    
    - Advertise a persistence-domain for of_pmem and papr_scm. The
      persistence domain indicates where cpu-store cycles need to reach in
      the platform-memory subsystem before the platform will consider them
      power-fail protected.
    
    - Fixup some flexible-array declarations.

commit 4b566406085bc1fd5b6ba309fae70e6f6d6fa94e
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Mar 19 14:50:46 2020 -0500

    ACPI: NFIT: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Link: https://lore.kernel.org/r/20200319195046.GA452@embeddedor.com
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 24241941181c..af09143ce403 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -144,32 +144,32 @@ struct nfit_spa {
 	unsigned long ars_state;
 	u32 clear_err_unit;
 	u32 max_ars;
-	struct acpi_nfit_system_address spa[0];
+	struct acpi_nfit_system_address spa[];
 };
 
 struct nfit_dcr {
 	struct list_head list;
-	struct acpi_nfit_control_region dcr[0];
+	struct acpi_nfit_control_region dcr[];
 };
 
 struct nfit_bdw {
 	struct list_head list;
-	struct acpi_nfit_data_region bdw[0];
+	struct acpi_nfit_data_region bdw[];
 };
 
 struct nfit_idt {
 	struct list_head list;
-	struct acpi_nfit_interleave idt[0];
+	struct acpi_nfit_interleave idt[];
 };
 
 struct nfit_flush {
 	struct list_head list;
-	struct acpi_nfit_flush_address flush[0];
+	struct acpi_nfit_flush_address flush[];
 };
 
 struct nfit_memdev {
 	struct list_head list;
-	struct acpi_nfit_memory_map memdev[0];
+	struct acpi_nfit_memory_map memdev[];
 };
 
 enum nfit_mem_flags {

commit 01091c496f920e634ea84b689f480c39016752a8
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Feb 25 19:20:06 2020 +0300

    acpi/nfit: improve bounds checking for 'func'
    
    The 'func' variable can come from the user in the __nd_ioctl().  If it's
    too high then the (1 << func) shift in acpi_nfit_clear_to_send() is
    undefined.  In acpi_nfit_ctl() we pass 'func' to test_bit(func, &dsm_mask)
    which could result in an out of bounds access.
    
    To fix these issues, I introduced the NVDIMM_CMD_MAX (31) define and
    updated nfit_dsm_revid() to use that define as well instead of magic
    numbers.
    
    Fixes: 11189c1089da ("acpi/nfit: Fix command-supported detection")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Dan Williams <dan.j.williams@intel.com>
    Link: https://lore.kernel.org/r/20200225161927.hvftuq7kjn547fyj@kili.mountain
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 24241941181c..b317f4043705 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -34,6 +34,7 @@
 		| ACPI_NFIT_MEM_NOT_ARMED | ACPI_NFIT_MEM_MAP_FAILED)
 
 #define NVDIMM_FAMILY_MAX NVDIMM_FAMILY_HYPERV
+#define NVDIMM_CMD_MAX 31
 
 #define NVDIMM_STANDARD_CMDMASK \
 (1 << ND_CMD_SMART | 1 << ND_CMD_SMART_THRESHOLD | 1 << ND_CMD_DIMM_FLAGS \

commit 87a30e1f05d73a34e6d1895065541369131aaf1c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jul 17 18:08:26 2019 -0700

    driver-core, libnvdimm: Let device subsystems add local lockdep coverage
    
    For good reason, the standard device_lock() is marked
    lockdep_set_novalidate_class() because there is simply no sane way to
    describe the myriad ways the device_lock() ordered with other locks.
    However, that leaves subsystems that know their own local device_lock()
    ordering rules to find lock ordering mistakes manually. Instead,
    introduce an optional / additional lockdep-enabled lock that a subsystem
    can acquire in all the same paths that the device_lock() is acquired.
    
    A conversion of the NFIT driver and NVDIMM subsystem to a
    lockdep-validate device_lock() scheme is included. The
    debug_nvdimm_lock() implementation implements the correct lock-class and
    stacking order for the libnvdimm device topology hierarchy.
    
    Yes, this is a hack, but hopefully it is a useful hack for other
    subsystems device_lock() debug sessions. Quoting Greg:
    
        "Yeah, it feels a bit hacky but it's really up to a subsystem to mess up
         using it as much as anything else, so user beware :)
    
         I don't object to it if it makes things easier for you to debug."
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ira Weiny <ira.weiny@intel.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Dave Jiang <dave.jiang@intel.com>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Vishal Verma <vishal.l.verma@intel.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Ira Weiny <ira.weiny@intel.com>
    Link: https://lore.kernel.org/r/156341210661.292348.7014034644265455704.stgit@dwillia2-desk3.amr.corp.intel.com

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 6ee2b02af73e..24241941181c 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -312,6 +312,30 @@ static inline struct acpi_nfit_desc *to_acpi_desc(
 	return container_of(nd_desc, struct acpi_nfit_desc, nd_desc);
 }
 
+#ifdef CONFIG_PROVE_LOCKING
+static inline void nfit_device_lock(struct device *dev)
+{
+	device_lock(dev);
+	mutex_lock(&dev->lockdep_mutex);
+}
+
+static inline void nfit_device_unlock(struct device *dev)
+{
+	mutex_unlock(&dev->lockdep_mutex);
+	device_unlock(dev);
+}
+#else
+static inline void nfit_device_lock(struct device *dev)
+{
+	device_lock(dev);
+}
+
+static inline void nfit_device_unlock(struct device *dev)
+{
+	device_unlock(dev);
+}
+#endif
+
 const guid_t *to_nfit_uuid(enum nfit_uuids id);
 int acpi_nfit_init(struct acpi_nfit_desc *acpi_desc, void *nfit, acpi_size sz);
 void acpi_nfit_shutdown(void *data);

commit 5b497af42fab12cadc0e29bcb7052cf9963603f5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:18:09 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 295
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of version 2 of the gnu general public license as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 64 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141901.894819585@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 2f8cf2a11e3b..6ee2b02af73e 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -1,16 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * NVDIMM Firmware Interface Table - NFIT
  *
  * Copyright(c) 2013-2015 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
  */
 #ifndef __NFIT_H__
 #define __NFIT_H__

commit 4083014e32699af04a8e6eaa4855b08dba36a47a
Merge: 6fd96ff55796 78153dd45e7e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Mar 11 12:37:55 2019 -0700

    Merge branch 'for-5.1/nfit/ars' into libnvdimm-for-next
    
    Merge several updates to the ARS implementation. Highlights include:
    
    * Support retrieval of short-ARS results if the ARS state is "requires
      continuation", and even if the "no_init_ars" module parameter is
      specified.
    * Allow busy-polling of the kernel ARS state by allowing root to reset
      the exponential back-off timer.
    * Filter potentially stale ARS results by tracking query-ARS relative to
      the previous start-ARS.

commit 78153dd45e7e0596ba32b15d02bda08e1513111e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 13 09:28:40 2019 -0800

    nfit/ars: Avoid stale ARS results
    
    Gate ARS result consumption on whether the OS issued start-ARS since the
    previous consumption. The BIOS may only clear its result buffers after a
    successful start-ARS.
    
    Fixes: 0caeef63e6d2 ("libnvdimm: Add a poison list and export badblocks")
    Cc: <stable@vger.kernel.org>
    Reported-by: Krzysztof Rusocki <krzysztof.rusocki@intel.com>
    Reported-by: Vishal Verma <vishal.l.verma@intel.com>
    Reviewed-by: Toshi Kani <toshi.kani@hpe.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index d14bad687fb8..0cbe5009eb2c 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -213,6 +213,7 @@ struct nfit_mem {
 enum scrub_flags {
 	ARS_BUSY,
 	ARS_CANCEL,
+	ARS_VALID,
 	ARS_POLL,
 };
 

commit 5479b2757f26fe9908fc341d105b2097fe820b6f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 13 09:04:07 2019 -0800

    nfit/ars: Allow root to busy-poll the ARS state machine
    
    The ARS implementation implements exponential back-off on the poll
    interval to prevent high-frequency access to the DIMM / platform
    interface. Depending on when the ARS completes the poll interval may
    exceed the completion event by minutes. Allow root to reset the timeout
    each time it probes the status. A one-second timeout is still enforced,
    but root can otherwise can control the poll interval.
    
    Fixes: bc6ba8085842 ("nfit, address-range-scrub: rework and simplify ARS...")
    Cc: <stable@vger.kernel.org>
    Reported-by: Erwin Tsaur <erwin.tsaur@oracle.com>
    Reviewed-by: Toshi Kani <toshi.kani@hpe.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 897ce10192a0..d14bad687fb8 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -213,6 +213,7 @@ struct nfit_mem {
 enum scrub_flags {
 	ARS_BUSY,
 	ARS_CANCEL,
+	ARS_POLL,
 };
 
 struct acpi_nfit_desc {

commit e34b8252a3d2893ca55c82dbfcdaa302fa03d400
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 13 09:57:22 2019 -0800

    nfit/ars: Introduce scrub_flags
    
    In preparation for introducing new flags to gate whether ARS results are
    stale, or poll the completion state, convert the existing flags to an
    unsigned long with enumerated values. This conversion allows the flags
    to be atomically updated outside of ->init_mutex.
    
    Reviewed-by: Toshi Kani <toshi.kani@hpe.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 871fb3de3b30..897ce10192a0 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -210,6 +210,11 @@ struct nfit_mem {
 	int family;
 };
 
+enum scrub_flags {
+	ARS_BUSY,
+	ARS_CANCEL,
+};
+
 struct acpi_nfit_desc {
 	struct nvdimm_bus_descriptor nd_desc;
 	struct acpi_table_header acpi_header;
@@ -231,8 +236,7 @@ struct acpi_nfit_desc {
 	unsigned int max_ars;
 	unsigned int scrub_count;
 	unsigned int scrub_mode;
-	unsigned int scrub_busy:1;
-	unsigned int cancel:1;
+	unsigned long scrub_flags;
 	unsigned long dimm_cmd_force_en;
 	unsigned long bus_cmd_force_en;
 	unsigned long bus_nfit_cmd_force_en;

commit 317a992ab9266b86b774b9f6b0f87eb4f59879a1
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 13 09:34:00 2019 -0800

    nfit/ars: Remove ars_start_flags
    
    The ars_start_flags property of 'struct acpi_nfit_desc' is no longer
    used since ARS_REQ_SHORT and ARS_REQ_LONG were added.
    
    Reviewed-by: Toshi Kani <toshi.kani@hpe.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 33691aecfcee..871fb3de3b30 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -223,7 +223,6 @@ struct acpi_nfit_desc {
 	struct list_head idts;
 	struct nvdimm_bus *nvdimm_bus;
 	struct device *dev;
-	u8 ars_start_flags;
 	struct nd_cmd_ars_status *ars_status;
 	struct nfit_spa *scrub_spa;
 	struct delayed_work dwork;

commit 1194c4133195dfcb6c5fc0935d54bbed872a5285
Author: Dexuan Cui <decui@microsoft.com>
Date:   Tue Jan 29 00:56:17 2019 +0000

    nfit: Add Hyper-V NVDIMM DSM command set to white list
    
    Add the Hyper-V _DSM command set to the white list of NVDIMM command
    sets.
    
    This command set is documented at http://www.uefi.org/RFIC_LIST
    (see "Virtual NVDIMM 0x1901").
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 33691aecfcee..4de167b4f76f 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -34,11 +34,14 @@
 /* https://msdn.microsoft.com/library/windows/hardware/mt604741 */
 #define UUID_NFIT_DIMM_N_MSFT "1ee68b36-d4bd-4a1a-9a16-4f8e53d46e05"
 
+/* http://www.uefi.org/RFIC_LIST (see "Virtual NVDIMM 0x1901") */
+#define UUID_NFIT_DIMM_N_HYPERV "5746c5f2-a9a2-4264-ad0e-e4ddc9e09e80"
+
 #define ACPI_NFIT_MEM_FAILED_MASK (ACPI_NFIT_MEM_SAVE_FAILED \
 		| ACPI_NFIT_MEM_RESTORE_FAILED | ACPI_NFIT_MEM_FLUSH_FAILED \
 		| ACPI_NFIT_MEM_NOT_ARMED | ACPI_NFIT_MEM_MAP_FAILED)
 
-#define NVDIMM_FAMILY_MAX NVDIMM_FAMILY_MSFT
+#define NVDIMM_FAMILY_MAX NVDIMM_FAMILY_HYPERV
 
 #define NVDIMM_STANDARD_CMDMASK \
 (1 << ND_CMD_SMART | 1 << ND_CMD_SMART_THRESHOLD | 1 << ND_CMD_DIMM_FLAGS \
@@ -94,6 +97,7 @@ enum nfit_uuids {
 	NFIT_DEV_DIMM_N_HPE1 = NVDIMM_FAMILY_HPE1,
 	NFIT_DEV_DIMM_N_HPE2 = NVDIMM_FAMILY_HPE2,
 	NFIT_DEV_DIMM_N_MSFT = NVDIMM_FAMILY_MSFT,
+	NFIT_DEV_DIMM_N_HYPERV = NVDIMM_FAMILY_HYPERV,
 	NFIT_SPA_VOLATILE,
 	NFIT_SPA_PM,
 	NFIT_SPA_DCR,

commit d6548ae4d16dc231dec22860c9c472bcb991fb15
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Tue Dec 4 10:31:20 2018 -0800

    acpi/nfit, libnvdimm: Store dimm id as a member to struct nvdimm
    
    The generated dimm id is needed for the sysfs attribute as well as being
    used as the identifier/description for the security key. Since it's
    constant and should never change, store it as a member of struct nvdimm.
    
    As nvdimm_create() continues to grow parameters relative to NFIT driver
    requirements, do not require other implementations to keep pace.
    Introduce __nvdimm_create() to carry the new parameters and keep
    nvdimm_create() with the long standing default api.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index ecde13a9199d..33691aecfcee 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -183,6 +183,8 @@ enum nfit_mem_flags {
 	NFIT_MEM_DIRTY_COUNT,
 };
 
+#define NFIT_DIMM_ID_LEN	22
+
 /* assembled tables for a given dimm/memory-device */
 struct nfit_mem {
 	struct nvdimm *nvdimm;
@@ -200,6 +202,7 @@ struct nfit_mem {
 	struct list_head list;
 	struct acpi_device *adev;
 	struct acpi_nfit_desc *acpi_desc;
+	char id[NFIT_DIMM_ID_LEN+1];
 	struct resource *flush_wpq;
 	unsigned long dsm_mask;
 	unsigned long flags;

commit b3ed2ce024c36054e51cca2eb31a1cdbe4a5f11e
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Tue Dec 4 10:31:11 2018 -0800

    acpi/nfit: Add support for Intel DSM 1.8 commands
    
    Add command definition for security commands defined in Intel DSM
    specification v1.8 [1]. This includes "get security state", "set
    passphrase", "unlock unit", "freeze lock", "secure erase", "overwrite",
    "overwrite query", "master passphrase enable/disable", and "master
    erase", . Since this adds several Intel definitions, move the relevant
    bits to their own header.
    
    These commands mutate physical data, but that manipulation is not cache
    coherent. The requirement to flush and invalidate caches makes these
    commands unsuitable to be called from userspace, so extra logic is added
    to detect and block these commands from being submitted via the ioctl
    command submission path.
    
    Lastly, the commands may contain sensitive key material that should not
    be dumped in a standard debug session. Update the nvdimm-command
    payload-dump facility to move security command payloads behind a
    default-off compile time switch.
    
    [1]: http://pmem.io/documents/NVDIMM_DSM_Interface-V1.8.pdf
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index df0f6b8407e7..ecde13a9199d 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -60,14 +60,33 @@ enum nvdimm_family_cmds {
 	NVDIMM_INTEL_QUERY_FWUPDATE = 16,
 	NVDIMM_INTEL_SET_THRESHOLD = 17,
 	NVDIMM_INTEL_INJECT_ERROR = 18,
+	NVDIMM_INTEL_GET_SECURITY_STATE = 19,
+	NVDIMM_INTEL_SET_PASSPHRASE = 20,
+	NVDIMM_INTEL_DISABLE_PASSPHRASE = 21,
+	NVDIMM_INTEL_UNLOCK_UNIT = 22,
+	NVDIMM_INTEL_FREEZE_LOCK = 23,
+	NVDIMM_INTEL_SECURE_ERASE = 24,
+	NVDIMM_INTEL_OVERWRITE = 25,
+	NVDIMM_INTEL_QUERY_OVERWRITE = 26,
+	NVDIMM_INTEL_SET_MASTER_PASSPHRASE = 27,
+	NVDIMM_INTEL_MASTER_SECURE_ERASE = 28,
 };
 
+#define NVDIMM_INTEL_SECURITY_CMDMASK \
+(1 << NVDIMM_INTEL_GET_SECURITY_STATE | 1 << NVDIMM_INTEL_SET_PASSPHRASE \
+| 1 << NVDIMM_INTEL_DISABLE_PASSPHRASE | 1 << NVDIMM_INTEL_UNLOCK_UNIT \
+| 1 << NVDIMM_INTEL_FREEZE_LOCK | 1 << NVDIMM_INTEL_SECURE_ERASE \
+| 1 << NVDIMM_INTEL_OVERWRITE | 1 << NVDIMM_INTEL_QUERY_OVERWRITE \
+| 1 << NVDIMM_INTEL_SET_MASTER_PASSPHRASE \
+| 1 << NVDIMM_INTEL_MASTER_SECURE_ERASE)
+
 #define NVDIMM_INTEL_CMDMASK \
 (NVDIMM_STANDARD_CMDMASK | 1 << NVDIMM_INTEL_GET_MODES \
  | 1 << NVDIMM_INTEL_GET_FWINFO | 1 << NVDIMM_INTEL_START_FWUPDATE \
  | 1 << NVDIMM_INTEL_SEND_FWUPDATE | 1 << NVDIMM_INTEL_FINISH_FWUPDATE \
  | 1 << NVDIMM_INTEL_QUERY_FWUPDATE | 1 << NVDIMM_INTEL_SET_THRESHOLD \
- | 1 << NVDIMM_INTEL_INJECT_ERROR | 1 << NVDIMM_INTEL_LATCH_SHUTDOWN)
+ | 1 << NVDIMM_INTEL_INJECT_ERROR | 1 << NVDIMM_INTEL_LATCH_SHUTDOWN \
+ | NVDIMM_INTEL_SECURITY_CMDMASK)
 
 enum nfit_uuids {
 	/* for simplicity alias the uuid index with the family id */

commit d3abaf43bab8d5b0a3c6b982100d9e2be96de4ad
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat Oct 13 20:32:17 2018 -0700

    acpi, nfit: Fix Address Range Scrub completion tracking
    
    The Address Range Scrub implementation tried to skip running scrubs
    against ranges that were already scrubbed by the BIOS. Unfortunately
    that support also resulted in early scrub completions as evidenced by
    this debug output from nfit_test:
    
        nd_region region9: ARS: range 1 short complete
        nd_region region3: ARS: range 1 short complete
        nd_region region4: ARS: range 2 ARS start (0)
        nd_region region4: ARS: range 2 short complete
    
    ...i.e. completions without any indications that the scrub was started.
    
    This state of affairs was hard to see in the code due to the
    proliferation of state bits and mistakenly trying to track done state
    per-range when the completion is a global property of the bus.
    
    So, kill the four ARS state bits (ARS_REQ, ARS_REQ_REDO, ARS_DONE, and
    ARS_SHORT), and replace them with just 2 request flags ARS_REQ_SHORT and
    ARS_REQ_LONG. The implementation will still complete and reap the
    results of BIOS initiated ARS, but it will not attempt to use that
    information to affect the completion status of scrubbing the ranges from
    a Linux perspective.
    
    Instead, try to synchronously run a short ARS per range at init time and
    schedule a long scrub in the background. If ARS is busy with an ARS
    request, schedule both a short and a long scrub for when ARS returns to
    idle. This logic also satisfies the intent of what ARS_REQ_REDO was
    trying to achieve. The new rule is that the REQ flag stays set until the
    next successful ars_start() for that range.
    
    With the new policy that the REQ flags are not cleared until the next
    start, the implementation no longer loses requests as can be seen from
    the following log:
    
        nd_region region3: ARS: range 1 ARS start short (0)
        nd_region region9: ARS: range 1 ARS start short (0)
        nd_region region3: ARS: range 1 complete
        nd_region region4: ARS: range 2 ARS start short (0)
        nd_region region9: ARS: range 1 complete
        nd_region region9: ARS: range 1 ARS start long (0)
        nd_region region4: ARS: range 2 complete
        nd_region region3: ARS: range 1 ARS start long (0)
        nd_region region9: ARS: range 1 complete
        nd_region region3: ARS: range 1 complete
        nd_region region4: ARS: range 2 ARS start long (0)
        nd_region region4: ARS: range 2 complete
    
    ...note that the nfit_test emulated driver provides 2 buses, that is why
    some of the range indices are duplicated. Notice that each range
    now successfully completes a short and long scrub.
    
    Cc: <stable@vger.kernel.org>
    Fixes: 14c73f997a5e ("nfit, address-range-scrub: introduce nfit_spa->ars_state")
    Fixes: cc3d3458d46f ("acpi/nfit: queue issuing of ars when an uc error...")
    Reported-by: Jacek Zloch <jacek.zloch@intel.com>
    Reported-by: Krzysztof Rusocki <krzysztof.rusocki@intel.com>
    Reviewed-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index af73aec547f2..df0f6b8407e7 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -118,10 +118,8 @@ enum nfit_dimm_notifiers {
 };
 
 enum nfit_ars_state {
-	ARS_REQ,
-	ARS_REQ_REDO,
-	ARS_DONE,
-	ARS_SHORT,
+	ARS_REQ_SHORT,
+	ARS_REQ_LONG,
 	ARS_FAILED,
 };
 
@@ -205,6 +203,7 @@ struct acpi_nfit_desc {
 	struct device *dev;
 	u8 ars_start_flags;
 	struct nd_cmd_ars_status *ars_status;
+	struct nfit_spa *scrub_spa;
 	struct delayed_work dwork;
 	struct list_head list;
 	struct kernfs_node *scrub_count_state;
@@ -259,7 +258,8 @@ struct nfit_blk {
 
 extern struct list_head acpi_descs;
 extern struct mutex acpi_desc_lock;
-int acpi_nfit_ars_rescan(struct acpi_nfit_desc *acpi_desc, unsigned long flags);
+int acpi_nfit_ars_rescan(struct acpi_nfit_desc *acpi_desc,
+		enum nfit_ars_state req_type);
 
 #ifdef CONFIG_X86_MCE
 void nfit_mce_register(void);

commit 0ead11181fe0c9538b185e46a494df21dc7de23a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Sep 26 10:47:15 2018 -0700

    acpi, nfit: Collect shutdown status
    
    Some NVDIMMs, in addition to providing an indication of whether the
    previous shutdown was clean, also provide a running count of lifetime
    dirty-shutdown events for the device. In anticipation of this
    functionality appearing on more devices arrange for the nfit driver to
    retrieve / cache this data at DIMM discovery time, and export it via
    sysfs.
    
    Reviewed-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 111c3c437c80..af73aec547f2 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -162,6 +162,8 @@ struct nfit_memdev {
 enum nfit_mem_flags {
 	NFIT_MEM_LSR,
 	NFIT_MEM_LSW,
+	NFIT_MEM_DIRTY,
+	NFIT_MEM_DIRTY_COUNT,
 };
 
 /* assembled tables for a given dimm/memory-device */
@@ -184,6 +186,7 @@ struct nfit_mem {
 	struct resource *flush_wpq;
 	unsigned long dsm_mask;
 	unsigned long flags;
+	u32 dirty_shutdown;
 	int family;
 };
 

commit 6f07f86c494074a0755930473f67cc8916654221
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Sep 26 10:48:38 2018 -0700

    acpi, nfit: Introduce nfit_mem flags
    
    In preparation for adding a flag to indicate whether a DIMM publishes a
    dirty-shutdown count, convert the existing flags to a bit field.
    
    Reviewed-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index d1274ea2d251..111c3c437c80 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -159,6 +159,11 @@ struct nfit_memdev {
 	struct acpi_nfit_memory_map memdev[0];
 };
 
+enum nfit_mem_flags {
+	NFIT_MEM_LSR,
+	NFIT_MEM_LSW,
+};
+
 /* assembled tables for a given dimm/memory-device */
 struct nfit_mem {
 	struct nvdimm *nvdimm;
@@ -178,9 +183,8 @@ struct nfit_mem {
 	struct acpi_nfit_desc *acpi_desc;
 	struct resource *flush_wpq;
 	unsigned long dsm_mask;
+	unsigned long flags;
 	int family;
-	bool has_lsr;
-	bool has_lsw;
 };
 
 struct acpi_nfit_desc {

commit 828bf6e904eb8fc8969333568802689fbbf07a40
Merge: b326272010b6 286e87718103
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 25 18:13:10 2018 -0700

    Merge tag 'libnvdimm-for-4.19_misc' of gitolite.kernel.org:pub/scm/linux/kernel/git/nvdimm/nvdimm
    
    Pull libnvdimm updates from Dave Jiang:
     "Collection of misc libnvdimm patches for 4.19 submission:
    
       - Adding support to read locked nvdimm capacity.
    
       - Change test code to make DSM failure code injection an override.
    
       - Add support for calculate maximum contiguous area for namespace.
    
       - Add support for queueing a short ARS when there is on going ARS for
         nvdimm.
    
       - Allow NULL to be passed in to ->direct_access() for kaddr and pfn
         params.
    
       - Improve smart injection support for nvdimm emulation testing.
    
       - Fix test code that supports for emulating controller temperature.
    
       - Fix hang on error before devm_memremap_pages()
    
       - Fix a bug that causes user memory corruption when data returned to
         user for ars_status.
    
       - Maintainer updates for Ross Zwisler emails and adding Jan Kara to
         fsdax"
    
    * tag 'libnvdimm-for-4.19_misc' of gitolite.kernel.org:pub/scm/linux/kernel/git/nvdimm/nvdimm:
      libnvdimm: fix ars_status output length calculation
      device-dax: avoid hang on error before devm_memremap_pages()
      tools/testing/nvdimm: improve emulation of smart injection
      filesystem-dax: Do not request kaddr and pfn when not required
      md/dm-writecache: Don't request pointer dummy_addr when not required
      dax/super: Do not request a pointer kaddr when not required
      tools/testing/nvdimm: kaddr and pfn can be NULL to ->direct_access()
      s390, dcssblk: kaddr and pfn can be NULL to ->direct_access()
      libnvdimm, pmem: kaddr and pfn can be NULL to ->direct_access()
      acpi/nfit: queue issuing of ars when an uc error notification comes in
      libnvdimm: Export max available extent
      libnvdimm: Use max contiguous area for namespace size
      MAINTAINERS: Add Jan Kara for filesystem DAX
      MAINTAINERS: update Ross Zwisler's email address
      tools/testing/nvdimm: Fix support for emulating controller temperature
      tools/testing/nvdimm: Make DSM failure code injection an override
      acpi, nfit: Prefer _DSM over _LSR for namespace label reads
      libnvdimm: Introduce locked DIMM capacity support

commit cc3d3458d46f702b1d118fca8647dc9157887d9b
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Fri Jul 27 09:04:17 2018 -0700

    acpi/nfit: queue issuing of ars when an uc error notification comes in
    
    When the ACPI UC error notifier gets called and ARS_REQ bit is set
    with the passed in flag, we can receive -EBUSY if ARS_REQ bit is already
    set for the nfit_spa->ars_state. When that happens, the ARS request is
    dropped. That can potentially cause us to miss the unreported errors that
    the on going ARS request does not receive. Add an ARS_REQ_REDO state that
    will request short ARS upon ARS completion to grab any errors we missed.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Reviewed-by: Vishal Verma <vishal.l.verma@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 7d15856a739f..29466961426e 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -119,6 +119,7 @@ enum nfit_dimm_notifiers {
 
 enum nfit_ars_state {
 	ARS_REQ,
+	ARS_REQ_REDO,
 	ARS_DONE,
 	ARS_SHORT,
 	ARS_FAILED,

commit 33cc2c9667561b224215e6dfb5bf98e8fa17914e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jul 5 14:58:49 2018 -0700

    acpi, nfit: Fix scrub idle detection
    
    The notification of scrub completion happens within the scrub workqueue.
    That can clearly race someone running scrub_show() and work_busy()
    before the workqueue has a chance to flush the recently completed work.
    Add a flag to reliably indicate the idle vs busy state. Without this
    change applications using poll(2) to wait for scrub-completion may
    falsely wakeup and read ARS as being busy even though the thread is
    going idle and then hang indefinitely.
    
    Fixes: bc6ba8085842 ("nfit, address-range-scrub: rework and simplify ARS...")
    Cc: <stable@vger.kernel.org>
    Reported-by: Vishal Verma <vishal.l.verma@intel.com>
    Tested-by: Vishal Verma <vishal.l.verma@intel.com>
    Reported-by: Lukasz Dorau <lukasz.dorau@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 7d15856a739f..a97ff42fe311 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -203,6 +203,7 @@ struct acpi_nfit_desc {
 	unsigned int max_ars;
 	unsigned int scrub_count;
 	unsigned int scrub_mode;
+	unsigned int scrub_busy:1;
 	unsigned int cancel:1;
 	unsigned long dimm_cmd_force_en;
 	unsigned long bus_cmd_force_en;

commit bc6ba8085842164f2a8dc2e78e23a7167872abbe
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Apr 5 16:18:55 2018 -0700

    nfit, address-range-scrub: rework and simplify ARS state machine
    
    ARS is an operation that can take 10s to 100s of seconds to find media
    errors that should rarely be present. If the platform crashes due to
    media errors in persistent memory, the expectation is that the BIOS will
    report those known errors in a 'short' ARS request.
    
    A 'short' ARS request asks platform firmware to return an ARS payload
    with all known errors, but without issuing a 'long' scrub. At driver
    init a short request is issued to all PMEM ranges before registering
    regions. Then, in the background, a long ARS is scheduled for each
    region.
    
    The ARS implementation is simplified to centralize ARS completion work
    in the ars_complete() helper. The timeout is removed since there is no
    facility to cancel ARS, and this otherwise arranges for system init to
    never be blocked waiting for a 'long' ARS. The ars_state flags are used
    to coordinate ARS requests from driver init, ARS requests from
    userspace, and ARS requests in response to media error notifications.
    
    Given that there is no notification of ARS completion the implementation
    still needs to poll. It backs off exponentially to a maximum poll period
    of 30 minutes.
    
    Suggested-by: Toshi Kani <toshi.kani@hpe.com>
    Co-developed-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 45e7949986a8..7d15856a739f 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -197,18 +197,18 @@ struct acpi_nfit_desc {
 	struct device *dev;
 	u8 ars_start_flags;
 	struct nd_cmd_ars_status *ars_status;
-	struct work_struct work;
+	struct delayed_work dwork;
 	struct list_head list;
 	struct kernfs_node *scrub_count_state;
 	unsigned int max_ars;
 	unsigned int scrub_count;
 	unsigned int scrub_mode;
 	unsigned int cancel:1;
-	unsigned int init_complete:1;
 	unsigned long dimm_cmd_force_en;
 	unsigned long bus_cmd_force_en;
 	unsigned long bus_nfit_cmd_force_en;
 	unsigned int platform_cap;
+	unsigned int scrub_tmo;
 	int (*blk_do_io)(struct nd_blk_region *ndbr, resource_size_t dpa,
 			void *iobuf, u64 len, int rw);
 };

commit 459d0ddb079c869c986e1bb871c91564a4b8ccfe
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Apr 5 01:25:02 2018 -0700

    nfit, address-range-scrub: determine one platform max_ars value
    
    acpi_nfit_query_poison() is awkward in that it requires an nfit_spa
    argument in order to determine what max_ars value to use. Instead probe
    for the minimum max_ars across all scrub-capable ranges in the system
    and drop the nfit_spa argument.
    
    This enables a larger rework / simplification of the ARS state machine
    whereby the status can be retrieved once and then iterated over all
    address ranges to reap completions.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 2b97e5f76bdf..45e7949986a8 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -197,10 +197,10 @@ struct acpi_nfit_desc {
 	struct device *dev;
 	u8 ars_start_flags;
 	struct nd_cmd_ars_status *ars_status;
-	size_t ars_status_size;
 	struct work_struct work;
 	struct list_head list;
 	struct kernfs_node *scrub_count_state;
+	unsigned int max_ars;
 	unsigned int scrub_count;
 	unsigned int scrub_mode;
 	unsigned int cancel:1;

commit 14c73f997a5e060c6887a80c143021a58975c92a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Apr 2 15:40:30 2018 -0700

    nfit, address-range-scrub: introduce nfit_spa->ars_state
    
    In preparation for re-working the ARS implementation to better handle
    short vs long ARS runs, introduce nfit_spa->ars_state. For now this just
    replaces the nfit_spa->ars_required bit-field/flag, but going forward it
    will be used to track ARS completion and make short vs long ARS
    requests.
    
    Reviewed-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index ac9c49463731..2b97e5f76bdf 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -117,10 +117,17 @@ enum nfit_dimm_notifiers {
 	NFIT_NOTIFY_DIMM_HEALTH = 0x81,
 };
 
+enum nfit_ars_state {
+	ARS_REQ,
+	ARS_DONE,
+	ARS_SHORT,
+	ARS_FAILED,
+};
+
 struct nfit_spa {
 	struct list_head list;
 	struct nd_region *nd_region;
-	unsigned int ars_required:1;
+	unsigned long ars_state;
 	u32 clear_err_unit;
 	u32 max_ars;
 	struct acpi_nfit_system_address spa[0];
@@ -243,7 +250,7 @@ struct nfit_blk {
 
 extern struct list_head acpi_descs;
 extern struct mutex acpi_desc_lock;
-int acpi_nfit_ars_rescan(struct acpi_nfit_desc *acpi_desc, u8 flags);
+int acpi_nfit_ars_rescan(struct acpi_nfit_desc *acpi_desc, unsigned long flags);
 
 #ifdef CONFIG_X86_MCE
 void nfit_mce_register(void);

commit 466d1493ea830789a2f063f478aaed2e324f0d3d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Mar 28 10:44:50 2018 -0700

    acpi, nfit: rework NVDIMM leaf method detection
    
    Some BIOSen do not handle 0-byte transfer lengths for the _LSR and _LSW
    (label storage read/write) methods. This causes Linux to fallback to the
    deprecated _DSM path, or otherwise disable label support.
    
    Introduce acpi_nvdimm_has_method() to detect whether a method is
    available rather than calling the method, require _LSI and _LSR to be
    paired, and require read support before enabling write support.
    
    Cc: <stable@vger.kernel.org>
    Fixes: 4b27db7e26cd ("acpi, nfit: add support for the _LS...")
    Suggested-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 50d36e166d70..ac9c49463731 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -171,9 +171,8 @@ struct nfit_mem {
 	struct resource *flush_wpq;
 	unsigned long dsm_mask;
 	int family;
-	u32 has_lsi:1;
-	u32 has_lsr:1;
-	u32 has_lsw:1;
+	bool has_lsr;
+	bool has_lsw;
 };
 
 struct acpi_nfit_desc {

commit 06e8ccdab15f46dfd31292e2b75d744bc5fc2a7c
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed Jan 31 12:45:38 2018 -0700

    acpi: nfit: Add support for detect platform CPU cache flush on power loss
    
    In ACPI 6.2a the platform capability structure has been added to the NFIT
    tables. That provides software the ability to determine whether a system
    supports the auto flushing of CPU caches on power loss. If the capability
    is supported, we do not need to do dax_flush(). Plumbing the path to set the
    property on per region from the NFIT tables.
    
    This patch depends on the ACPI NFIT 6.2a platform capabilities support code
    in include/acpi/actbl1.h.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Signed-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index f0cf18b2da8b..50d36e166d70 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -202,6 +202,7 @@ struct acpi_nfit_desc {
 	unsigned long dimm_cmd_force_en;
 	unsigned long bus_cmd_force_en;
 	unsigned long bus_nfit_cmd_force_en;
+	unsigned int platform_cap;
 	int (*blk_do_io)(struct nd_blk_region *ndbr, resource_size_t dpa,
 			void *iobuf, u64 len, int rw);
 };

commit 79ab67ede21f536851a99ea68ee6fc1f5435e055
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Nov 15 10:10:48 2017 -0800

    acpi, nfit: add 'Enable Latch System Shutdown Status' command support
    
    The NVDIMM_FAMILY_INTEL 'Enable Latch System Shutdown Status' command
    indicates to the platform that system software has acknowledged the most
    recent unsafe shutdown status.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 341be9511d0e..f0cf18b2da8b 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -51,6 +51,7 @@
  * non-default DSM revision ids
  */
 enum nvdimm_family_cmds {
+	NVDIMM_INTEL_LATCH_SHUTDOWN = 10,
 	NVDIMM_INTEL_GET_MODES = 11,
 	NVDIMM_INTEL_GET_FWINFO = 12,
 	NVDIMM_INTEL_START_FWUPDATE = 13,
@@ -66,7 +67,7 @@ enum nvdimm_family_cmds {
  | 1 << NVDIMM_INTEL_GET_FWINFO | 1 << NVDIMM_INTEL_START_FWUPDATE \
  | 1 << NVDIMM_INTEL_SEND_FWUPDATE | 1 << NVDIMM_INTEL_FINISH_FWUPDATE \
  | 1 << NVDIMM_INTEL_QUERY_FWUPDATE | 1 << NVDIMM_INTEL_SET_THRESHOLD \
- | 1 << NVDIMM_INTEL_INJECT_ERROR)
+ | 1 << NVDIMM_INTEL_INJECT_ERROR | 1 << NVDIMM_INTEL_LATCH_SHUTDOWN)
 
 enum nfit_uuids {
 	/* for simplicity alias the uuid index with the family id */

commit 11e142701609546632ba1fda586252d391026a3f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Oct 20 15:39:43 2017 -0700

    acpi, nfit: add support for NVDIMM_FAMILY_INTEL v1.6 DSMs
    
    Per v1.6 of the NVDIMM_FAMILY_INTEL command set [1] some of the new
    commands require rev-id 2. In addition to enabling ND_CMD_CALL for these
    new function numbers, add a lookup table for revision-ids by family
    and function number.
    
    [1]: http://pmem.io/documents/NVDIMM_DSM_Interface-V1.6.pdf
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index b987196bf132..341be9511d0e 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -24,7 +24,7 @@
 /* ACPI 6.1 */
 #define UUID_NFIT_BUS "2f10e7a4-9e91-11e4-89d3-123b93f75cba"
 
-/* http://pmem.io/documents/NVDIMM_DSM_Interface_Example.pdf */
+/* http://pmem.io/documents/NVDIMM_DSM_Interface-V1.6.pdf */
 #define UUID_NFIT_DIMM "4309ac30-0d11-11e4-9191-0800200c9a66"
 
 /* https://github.com/HewlettPackard/hpe-nvm/blob/master/Documentation/ */
@@ -38,12 +38,36 @@
 		| ACPI_NFIT_MEM_RESTORE_FAILED | ACPI_NFIT_MEM_FLUSH_FAILED \
 		| ACPI_NFIT_MEM_NOT_ARMED | ACPI_NFIT_MEM_MAP_FAILED)
 
+#define NVDIMM_FAMILY_MAX NVDIMM_FAMILY_MSFT
+
 #define NVDIMM_STANDARD_CMDMASK \
 (1 << ND_CMD_SMART | 1 << ND_CMD_SMART_THRESHOLD | 1 << ND_CMD_DIMM_FLAGS \
  | 1 << ND_CMD_GET_CONFIG_SIZE | 1 << ND_CMD_GET_CONFIG_DATA \
  | 1 << ND_CMD_SET_CONFIG_DATA | 1 << ND_CMD_VENDOR_EFFECT_LOG_SIZE \
  | 1 << ND_CMD_VENDOR_EFFECT_LOG | 1 << ND_CMD_VENDOR)
 
+/*
+ * Command numbers that the kernel needs to know about to handle
+ * non-default DSM revision ids
+ */
+enum nvdimm_family_cmds {
+	NVDIMM_INTEL_GET_MODES = 11,
+	NVDIMM_INTEL_GET_FWINFO = 12,
+	NVDIMM_INTEL_START_FWUPDATE = 13,
+	NVDIMM_INTEL_SEND_FWUPDATE = 14,
+	NVDIMM_INTEL_FINISH_FWUPDATE = 15,
+	NVDIMM_INTEL_QUERY_FWUPDATE = 16,
+	NVDIMM_INTEL_SET_THRESHOLD = 17,
+	NVDIMM_INTEL_INJECT_ERROR = 18,
+};
+
+#define NVDIMM_INTEL_CMDMASK \
+(NVDIMM_STANDARD_CMDMASK | 1 << NVDIMM_INTEL_GET_MODES \
+ | 1 << NVDIMM_INTEL_GET_FWINFO | 1 << NVDIMM_INTEL_START_FWUPDATE \
+ | 1 << NVDIMM_INTEL_SEND_FWUPDATE | 1 << NVDIMM_INTEL_FINISH_FWUPDATE \
+ | 1 << NVDIMM_INTEL_QUERY_FWUPDATE | 1 << NVDIMM_INTEL_SET_THRESHOLD \
+ | 1 << NVDIMM_INTEL_INJECT_ERROR)
+
 enum nfit_uuids {
 	/* for simplicity alias the uuid index with the family id */
 	NFIT_DEV_DIMM = NVDIMM_FAMILY_INTEL,

commit b9b1504d3c6d6831c822cd785e095fc5fb155346
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun Oct 29 12:13:07 2017 -0700

    acpi, nfit: hide unknown commands from nmemX/commands
    
    For vendor specific commands that do not have a common kernel
    translation, hide them from nmemX/commands. For example, the following
    results from new enabling to probe for support of the new
    NVDIMM_FAMILY_INTEL DSMs specified in v1.6 of the command specification
    [1]:
    
        # cat /sys/bus/nd/devices/nmem0/commands
        smart smart_thresh flags get_size get_data set_data effect_size
        effect_log vendor cmd_call unknown unknown unknown unknown unknown
        unknown unknown unknown
    
    [1]: https://pmem.io/documents/NVDIMM_DSM_Interface-V1.6.pdf
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 3976d649f27c..b987196bf132 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -38,6 +38,12 @@
 		| ACPI_NFIT_MEM_RESTORE_FAILED | ACPI_NFIT_MEM_FLUSH_FAILED \
 		| ACPI_NFIT_MEM_NOT_ARMED | ACPI_NFIT_MEM_MAP_FAILED)
 
+#define NVDIMM_STANDARD_CMDMASK \
+(1 << ND_CMD_SMART | 1 << ND_CMD_SMART_THRESHOLD | 1 << ND_CMD_DIMM_FLAGS \
+ | 1 << ND_CMD_GET_CONFIG_SIZE | 1 << ND_CMD_GET_CONFIG_DATA \
+ | 1 << ND_CMD_SET_CONFIG_DATA | 1 << ND_CMD_VENDOR_EFFECT_LOG_SIZE \
+ | 1 << ND_CMD_VENDOR_EFFECT_LOG | 1 << ND_CMD_VENDOR)
+
 enum nfit_uuids {
 	/* for simplicity alias the uuid index with the family id */
 	NFIT_DEV_DIMM = NVDIMM_FAMILY_INTEL,

commit 4b27db7e26cdb9deb4a211e963e2993fde0110cb
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun Sep 24 09:57:34 2017 -0700

    acpi, nfit: add support for the _LSI, _LSR, and _LSW label methods
    
    ACPI 6.2 adds support for named methods to access the label storage area
    of an NVDIMM. We prefer these new methods if available and otherwise
    fallback to the NVDIMM_FAMILY_INTEL _DSMs. The kernel ioctls,
    ND_IOCTL_{GET,SET}_CONFIG_{SIZE,DATA}, remain generic and the driver
    translates the 'package' payloads into the NVDIMM_FAMILY_INTEL 'buffer'
    format to maintain compatibility with existing userspace and keep the
    output buffer parsing code in the driver common.
    
    The output payloads are mostly compatible save for the 'label area
    locked' status that moves from the 'config_size' (_LSI) command to the
    'config_read' (_LSR) command status.
    
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Cc: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index f2c6380bdbb2..3976d649f27c 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -140,6 +140,9 @@ struct nfit_mem {
 	struct resource *flush_wpq;
 	unsigned long dsm_mask;
 	int family;
+	u32 has_lsi:1;
+	u32 has_lsr:1;
+	u32 has_lsw:1;
 };
 
 struct acpi_nfit_desc {

commit b37b3fd33d034470749db55d1ccd7331bd35bdca
Author: Yasunori Goto <y-goto@jp.fujitsu.com>
Date:   Fri Sep 22 16:47:40 2017 +0900

    acpi nfit: Enable to show what feature is supported via ND_CMD_CALL for nfit_test
    
    Though nfit_test need to show what feature is supported via ND_CMD_CALL on
    device/nfit/dsm_mask, currently there is no way to tell it.
    This patch makes to enable it.
    
    Signed-off-by: Yasunori Goto <y-goto@jp.fujitsu.com>
    Reviewed-by: Vishal Verma <vishal.l.verma@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 54292db61262..f2c6380bdbb2 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -167,6 +167,7 @@ struct acpi_nfit_desc {
 	unsigned int init_complete:1;
 	unsigned long dimm_cmd_force_en;
 	unsigned long bus_cmd_force_en;
+	unsigned long bus_nfit_cmd_force_en;
 	int (*blk_do_io)(struct nd_blk_region *ndbr, resource_size_t dpa,
 			void *iobuf, u64 len, int rw);
 };

commit 807900395efebf9276178eb6157959f2e81fe013
Author: Toshi Kani <toshi.kani@hpe.com>
Date:   Thu Jun 29 20:41:30 2017 -0600

    acpi/nfit: Issue Start ARS to retrieve existing records
    
    ACPI 6.2 defines in section 9.20.7.2 that the OSPM may call a Start
    ARS with Flags Bit [1] set upon receiving the 0x81 notification.
    
      Upon receiving the notification, the OSPM may decide to issue
      a Start ARS with Flags Bit [1] set to prepare for the retrieval
      of existing records and issue the Query ARS Status function to
      retrieve the records.
    
    Add support to call a Start ARS from acpi_nfit_uc_error_notify()
    with ND_ARS_RETURN_PREV_DATA set when HW_ERROR_SCRUB_ON is not set.
    
    Link: http://www.uefi.org/sites/default/files/resources/ACPI_6_2.pdf
    Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Vishal Verma <vishal.l.verma@intel.com>
    Cc: Linda Knippers <linda.knippers@hpe.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index e3da60b2d686..54292db61262 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -155,6 +155,7 @@ struct acpi_nfit_desc {
 	struct list_head idts;
 	struct nvdimm_bus *nvdimm_bus;
 	struct device *dev;
+	u8 ars_start_flags;
 	struct nd_cmd_ars_status *ars_status;
 	size_t ars_status_size;
 	struct work_struct work;
@@ -207,7 +208,7 @@ struct nfit_blk {
 
 extern struct list_head acpi_descs;
 extern struct mutex acpi_desc_lock;
-int acpi_nfit_ars_rescan(struct acpi_nfit_desc *acpi_desc);
+int acpi_nfit_ars_rescan(struct acpi_nfit_desc *acpi_desc, u8 flags);
 
 #ifdef CONFIG_X86_MCE
 void nfit_mce_register(void);

commit 56b47fe6579234e3102f1f28e26fa91fb6c38b3d
Author: Toshi Kani <toshi.kani@hpe.com>
Date:   Thu Jun 8 12:36:57 2017 -0600

    acpi/nfit: Add support of NVDIMM memory error notification in ACPI 6.2
    
    ACPI 6.2 defines a new ACPI notification value to NVDIMM Root Device
    in Table 5-169.
    
     0x81 Unconsumed Uncorrectable Memory Error Detected
          Used to pro-actively notify OSPM of uncorrectable memory errors
          detected (for example a memory scrubbing engine that continuously
          scans the NVDIMMs memory). This is an optional notification. Only
          locations that were mapped in to SPA by the platform will generate
          a notification.
    
    Add support of this notification value by initiating an ARS scan. This
    will find new error locations and add their badblocks information.
    
    Link: http://www.uefi.org/sites/default/files/resources/ACPI_6_2.pdf
    Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Vishal Verma <vishal.l.verma@intel.com>
    Cc: Linda Knippers <linda.knippers@hpe.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 29bdd959517f..e3da60b2d686 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -79,6 +79,7 @@ enum {
 
 enum nfit_root_notifiers {
 	NFIT_NOTIFY_UPDATE = 0x80,
+	NFIT_NOTIFY_UC_MEMORY_ERROR = 0x81,
 };
 
 enum nfit_dimm_notifiers {

commit 41c8bdb3ab10c1fefcac61d081e2fd9aaf8694b8
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jun 5 19:40:42 2017 +0300

    acpi, nfit: Switch to use new generic UUID API
    
    There are new types and helpers that are supposed to be used in new code.
    
    As a preparation to get rid of legacy types and API functions do
    the conversion here.
    
    Reviewed-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 58fb7d68e04a..29bdd959517f 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -18,7 +18,6 @@
 #include <linux/libnvdimm.h>
 #include <linux/ndctl.h>
 #include <linux/types.h>
-#include <linux/uuid.h>
 #include <linux/acpi.h>
 #include <acpi/acuuid.h>
 
@@ -237,7 +236,7 @@ static inline struct acpi_nfit_desc *to_acpi_desc(
 	return container_of(nd_desc, struct acpi_nfit_desc, nd_desc);
 }
 
-const u8 *to_nfit_uuid(enum nfit_uuids id);
+const guid_t *to_nfit_uuid(enum nfit_uuids id);
 int acpi_nfit_init(struct acpi_nfit_desc *acpi_desc, void *nfit, acpi_size sz);
 void acpi_nfit_shutdown(void *data);
 void __acpi_nfit_notify(struct device *dev, acpi_handle handle, u32 event);

commit fbabd829fe76a72a6444f64361cf8b2a9848639d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Apr 18 09:56:31 2017 -0700

    acpi, nfit: fix module unload vs workqueue shutdown race
    
    The workqueue may still be running when the devres callbacks start
    firing to deallocate an acpi_nfit_desc instance. Stop and flush the
    workqueue before letting any other devres de-allocations proceed.
    
    Reported-by: Linda Knippers <linda.knippers@hpe.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index fac098bfa585..58fb7d68e04a 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -239,6 +239,7 @@ static inline struct acpi_nfit_desc *to_acpi_desc(
 
 const u8 *to_nfit_uuid(enum nfit_uuids id);
 int acpi_nfit_init(struct acpi_nfit_desc *acpi_desc, void *nfit, acpi_size sz);
+void acpi_nfit_shutdown(void *data);
 void __acpi_nfit_notify(struct device *dev, acpi_handle handle, u32 event);
 void __acpi_nvdimm_notify(struct device *dev, u32 event);
 int acpi_nfit_ctl(struct nvdimm_bus_descriptor *nd_desc, struct nvdimm *nvdimm,

commit 9ccaed4bfd4f186e8350ffc7d8f188f8d2991fd9
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Apr 13 22:48:46 2017 -0700

    acpi, nfit: limit ->flush_probe() to initialization work
    
    The nvdimm probe flushing mechanism gives userspace a sync point where
    it knows all asynchronous driver probe sequences have completed.
    However, it need not wait for other asynchronous actions, like
    on-demand address-range-scrub. Track the init work separately from other
    work in the workqueue, and only flush the former.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index aaabd2721f8e..fac098bfa585 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -163,6 +163,7 @@ struct acpi_nfit_desc {
 	unsigned int scrub_count;
 	unsigned int scrub_mode;
 	unsigned int cancel:1;
+	unsigned int init_complete:1;
 	unsigned long dimm_cmd_force_en;
 	unsigned long bus_cmd_force_en;
 	int (*blk_do_io)(struct nd_blk_region *ndbr, resource_size_t dpa,

commit 1499934dcd15a7c9aca1467025b78f6675032849
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Apr 13 19:46:36 2017 -0700

    acpi, nfit: support "map failed" dimms
    
    Stop requiring dimms be successfully mapped into a
    system-physical-address range. For provisioning and hardware remediation
    purposes the kernel should account for failed devices in sysfs. If
    possible it should still allow management commands to be sent to the
    device.
    
    Reported-by: Toshi Kani <toshi.kani@hpe.com>
    Tested-by: Toshi Kani <toshi.kani@hpe.com>
    Reported-by: Linda Knippers <linda.knippers@hpe.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index fc29c2e9832e..aaabd2721f8e 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -37,7 +37,7 @@
 
 #define ACPI_NFIT_MEM_FAILED_MASK (ACPI_NFIT_MEM_SAVE_FAILED \
 		| ACPI_NFIT_MEM_RESTORE_FAILED | ACPI_NFIT_MEM_FLUSH_FAILED \
-		| ACPI_NFIT_MEM_NOT_ARMED)
+		| ACPI_NFIT_MEM_NOT_ARMED | ACPI_NFIT_MEM_MAP_FAILED)
 
 enum nfit_uuids {
 	/* for simplicity alias the uuid index with the family id */

commit a7de92dac9f0dbf01deb56fe1d661d7baac097e1
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Dec 5 13:43:25 2016 -0800

    tools/testing/nvdimm: unit test acpi_nfit_ctl()
    
    A recent flurry of bug discoveries in the nfit driver's DSM marshalling
    routine has highlighted the fact that we do not have unit test coverage
    for this routine. Add a self-test of acpi_nfit_ctl() routine before
    probing the "nfit_test.0" device. This mocks stimulus to acpi_nfit_ctl()
    and if any of the tests fail "nfit_test.0" will be unavailable causing
    the rest of the tests to not run / fail.
    
    This unit test will also be a place to land reproductions of quirky BIOS
    behavior discovered in the field and ensure the kernel does not regress
    against implementations it has seen in practice.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 14296f5267c8..fc29c2e9832e 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -240,5 +240,7 @@ const u8 *to_nfit_uuid(enum nfit_uuids id);
 int acpi_nfit_init(struct acpi_nfit_desc *acpi_desc, void *nfit, acpi_size sz);
 void __acpi_nfit_notify(struct device *dev, acpi_handle handle, u32 event);
 void __acpi_nvdimm_notify(struct device *dev, u32 event);
+int acpi_nfit_ctl(struct nvdimm_bus_descriptor *nd_desc, struct nvdimm *nvdimm,
+		unsigned int cmd, void *buf, unsigned int buf_len, int *cmd_rc);
 void acpi_nfit_desc_init(struct acpi_nfit_desc *acpi_desc, struct device *dev);
 #endif /* __NFIT_H__ */

commit 9ffd6350a103cb9e73e3abb4573c900cfead2f9b
Author: Vishal Verma <vishal.l.verma@intel.com>
Date:   Fri Sep 30 17:19:29 2016 -0600

    nfit: don't start a full scrub by default for an MCE
    
    Starting a full Address Range Scrub (ARS) on hitting a memory error
    machine check exception may not always be desirable. Provide a way
    through sysfs to toggle the behavior between just adding the address
    (cache line) where the MCE happened to the poison list and doing a full
    scrub. The former (selective insertion of the address) is done
    unconditionally.
    
    Cc: linux-acpi@vger.kernel.org
    Cc: Linda Knippers <linda.knippers@hpe.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index bb101170cd0b..14296f5267c8 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -161,6 +161,7 @@ struct acpi_nfit_desc {
 	struct list_head list;
 	struct kernfs_node *scrub_count_state;
 	unsigned int scrub_count;
+	unsigned int scrub_mode;
 	unsigned int cancel:1;
 	unsigned long dimm_cmd_force_en;
 	unsigned long bus_cmd_force_en;
@@ -168,6 +169,11 @@ struct acpi_nfit_desc {
 			void *iobuf, u64 len, int rw);
 };
 
+enum scrub_mode {
+	HW_ERROR_SCRUB_OFF,
+	HW_ERROR_SCRUB_ON,
+};
+
 enum nd_blk_mmio_selector {
 	BDW,
 	DCR,

commit 231bf117aada289023fd6f3377461ce80792e273
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Aug 22 19:23:25 2016 -0700

    tools/testing/nvdimm: unit test for acpi_nvdimm_notify()
    
    Trigger an nmemX/nfit/flags attribute to fire an event whenever a
    smart-threshold DSM is received.
    
    Reviewed-by: Vishal Verma <vishal.l.verma@intel.com>
    Acked-by: Rafael J. Wysocki <rafael@kernel.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 13195824778c..bb101170cd0b 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -233,5 +233,6 @@ static inline struct acpi_nfit_desc *to_acpi_desc(
 const u8 *to_nfit_uuid(enum nfit_uuids id);
 int acpi_nfit_init(struct acpi_nfit_desc *acpi_desc, void *nfit, acpi_size sz);
 void __acpi_nfit_notify(struct device *dev, acpi_handle handle, u32 event);
+void __acpi_nvdimm_notify(struct device *dev, u32 event);
 void acpi_nfit_desc_init(struct acpi_nfit_desc *acpi_desc, struct device *dev);
 #endif /* __NFIT_H__ */

commit ba9c8dd3c22275e46feef429f343b85e9cf3924c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Aug 22 19:28:37 2016 -0700

    acpi, nfit: add dimm device notification support
    
    Per "ACPI 6.1 Section 9.20.3" NVDIMM devices, children of the ACPI0012
    NVDIMM Root device, can receive health event notifications.
    
    Given that these devices are precluded from registering a notification
    handler via acpi_driver.acpi_device_ops (due to no _HID), we use
    acpi_install_notify_handler() directly.  The registered handler,
    acpi_nvdimm_notify(), triggers a poll(2) event on the nmemX/nfit/flags
    sysfs attribute when a health event notification is received.
    
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Toshi Kani <toshi.kani@hpe.com>
    Reviewed-by: Vishal Verma <vishal.l.verma@intel.com>
    Acked-by: Rafael J. Wysocki <rafael@kernel.org>
    Reviewed-by: Toshi Kani <toshi.kani@hpe.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 52370347fb0e..13195824778c 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -82,6 +82,10 @@ enum nfit_root_notifiers {
 	NFIT_NOTIFY_UPDATE = 0x80,
 };
 
+enum nfit_dimm_notifiers {
+	NFIT_NOTIFY_DIMM_HEALTH = 0x81,
+};
+
 struct nfit_spa {
 	struct list_head list;
 	struct nd_region *nd_region;
@@ -128,6 +132,7 @@ struct nfit_mem {
 	struct acpi_nfit_system_address *spa_bdw;
 	struct acpi_nfit_interleave *idt_dcr;
 	struct acpi_nfit_interleave *idt_bdw;
+	struct kernfs_node *flags_attr;
 	struct nfit_flush *nfit_flush;
 	struct list_head list;
 	struct acpi_device *adev;

commit c14a868a5a14f385059f012e54291de95a538a02
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Aug 18 22:15:04 2016 -0700

    tools/testing/nvdimm: unit test for acpi_nfit_notify()
    
    We have had a couple bugs in this implementation in the past and before
    we add another ->notify() implementation for nvdimm devices, lets allow
    this routine to be exercised via nfit_test.
    
    Rewrite acpi_nfit_notify() in terms of a generic struct device and
    acpi_handle parameter, and then implement a mock acpi_evaluate_object()
    that returns a _FIT payload.
    
    Cc: Vishal Verma <vishal.l.verma@intel.com>
    Reviewed-by: Vishal Verma <vishal.l.verma@intel.com>
    Acked-by: Rafael J. Wysocki <rafael@kernel.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 51d23f130d86..52370347fb0e 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -227,5 +227,6 @@ static inline struct acpi_nfit_desc *to_acpi_desc(
 
 const u8 *to_nfit_uuid(enum nfit_uuids id);
 int acpi_nfit_init(struct acpi_nfit_desc *acpi_desc, void *nfit, acpi_size sz);
+void __acpi_nfit_notify(struct device *dev, acpi_handle handle, u32 event);
 void acpi_nfit_desc_init(struct acpi_nfit_desc *acpi_desc, struct device *dev);
 #endif /* __NFIT_H__ */

commit c09f12186d6b03b798832d95289af76495990192
Author: Vishal Verma <vishal.l.verma@intel.com>
Date:   Fri Aug 19 14:40:58 2016 -0600

    acpi, nfit: check for the correct event code in notifications
    
    Commit 209851649dc4 "acpi: nfit: Add support for hot-add" added
    support for _FIT notifications, but it neglected to verify the
    notification event code matches the one in the ACPI spec for
    "NFIT Update". Currently there is only one code in the spec, but
    once additional codes are added, older kernels (without this fix)
    will misbehave by assuming all event notifications are for an
    NFIT Update.
    
    Fixes: 209851649dc4 ("acpi: nfit: Add support for hot-add")
    Cc: <stable@vger.kernel.org>
    Cc: <linux-acpi@vger.kernel.org>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Reported-by: Linda Knippers <linda.knippers@hpe.com>
    Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index e894ded24d99..51d23f130d86 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -78,6 +78,10 @@ enum {
 	NFIT_ARS_TIMEOUT = 90,
 };
 
+enum nfit_root_notifiers {
+	NFIT_NOTIFY_UPDATE = 0x80,
+};
+
 struct nfit_spa {
 	struct list_head list;
 	struct nd_region *nd_region;

commit 0606263f24f3d64960de742c55894190b5df903b
Merge: a72255983f12 d4c5725d5732
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun Jul 24 08:05:44 2016 -0700

    Merge branch 'for-4.8/libnvdimm' into libnvdimm-for-next

commit 6839a6d96f4ea0254266d60208c1fbbd53ade546
Author: Vishal Verma <vishal.l.verma@intel.com>
Date:   Sat Jul 23 21:51:21 2016 -0700

    nfit: do an ARS scrub on hitting a latent media error
    
    When a latent (unknown to 'badblocks') error is encountered, it will
    trigger a machine check exception. On a system with machine check
    recovery, this will only SIGBUS the process(es) which had the bad page
    mapped (as opposed to a kernel panic on platforms without machine
    check recovery features). In the former case, we want to trigger a full
    rescan of that nvdimm bus. This will allow any additional, new errors
    to be captured in the block devices' badblocks lists, and offending
    operations on them can be trapped early, avoiding machine checks.
    
    This is done by registering a callback function with the
    x86_mce_decoder_chain and calling the new ars_rescan functionality with
    the address in the mce notificatiion.
    
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index 6ecf337c97aa..ba6074a06958 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -16,6 +16,7 @@
 #define __NFIT_H__
 #include <linux/workqueue.h>
 #include <linux/libnvdimm.h>
+#include <linux/ndctl.h>
 #include <linux/types.h>
 #include <linux/uuid.h>
 #include <linux/acpi.h>
@@ -148,6 +149,7 @@ struct acpi_nfit_desc {
 	struct nd_cmd_ars_status *ars_status;
 	size_t ars_status_size;
 	struct work_struct work;
+	struct list_head list;
 	struct kernfs_node *scrub_count_state;
 	unsigned int scrub_count;
 	unsigned int cancel:1;
@@ -187,6 +189,24 @@ struct nfit_blk {
 	u32 dimm_flags;
 };
 
+extern struct list_head acpi_descs;
+extern struct mutex acpi_desc_lock;
+int acpi_nfit_ars_rescan(struct acpi_nfit_desc *acpi_desc);
+
+#ifdef CONFIG_X86_MCE
+void nfit_mce_register(void);
+void nfit_mce_unregister(void);
+#else
+static inline void nfit_mce_register(void)
+{
+}
+static inline void nfit_mce_unregister(void)
+{
+}
+#endif
+
+int nfit_spa_type(struct acpi_nfit_system_address *spa);
+
 static inline struct acpi_nfit_memory_map *__to_nfit_memdev(
 		struct nfit_mem *nfit_mem)
 {

commit bdf97013ced5f263da0dc9d559f5c09e922d8423
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat Jul 23 21:24:19 2016 -0700

    nfit: move to nfit/ sub-directory
    
    With the arrival of x86-machine-check support the nfit driver will add a
    (conditionally-compiled) source file.  Prepare for this by moving all
    nfit source to drivers/acpi/nfit/.  This is pure code movement, no
    functional changes.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
new file mode 100644
index 000000000000..6ecf337c97aa
--- /dev/null
+++ b/drivers/acpi/nfit/nfit.h
@@ -0,0 +1,207 @@
+/*
+ * NVDIMM Firmware Interface Table - NFIT
+ *
+ * Copyright(c) 2013-2015 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+#ifndef __NFIT_H__
+#define __NFIT_H__
+#include <linux/workqueue.h>
+#include <linux/libnvdimm.h>
+#include <linux/types.h>
+#include <linux/uuid.h>
+#include <linux/acpi.h>
+#include <acpi/acuuid.h>
+
+/* ACPI 6.1 */
+#define UUID_NFIT_BUS "2f10e7a4-9e91-11e4-89d3-123b93f75cba"
+
+/* http://pmem.io/documents/NVDIMM_DSM_Interface_Example.pdf */
+#define UUID_NFIT_DIMM "4309ac30-0d11-11e4-9191-0800200c9a66"
+
+/* https://github.com/HewlettPackard/hpe-nvm/blob/master/Documentation/ */
+#define UUID_NFIT_DIMM_N_HPE1 "9002c334-acf3-4c0e-9642-a235f0d53bc6"
+#define UUID_NFIT_DIMM_N_HPE2 "5008664b-b758-41a0-a03c-27c2f2d04f7e"
+
+/* https://msdn.microsoft.com/library/windows/hardware/mt604741 */
+#define UUID_NFIT_DIMM_N_MSFT "1ee68b36-d4bd-4a1a-9a16-4f8e53d46e05"
+
+#define ACPI_NFIT_MEM_FAILED_MASK (ACPI_NFIT_MEM_SAVE_FAILED \
+		| ACPI_NFIT_MEM_RESTORE_FAILED | ACPI_NFIT_MEM_FLUSH_FAILED \
+		| ACPI_NFIT_MEM_NOT_ARMED)
+
+enum nfit_uuids {
+	/* for simplicity alias the uuid index with the family id */
+	NFIT_DEV_DIMM = NVDIMM_FAMILY_INTEL,
+	NFIT_DEV_DIMM_N_HPE1 = NVDIMM_FAMILY_HPE1,
+	NFIT_DEV_DIMM_N_HPE2 = NVDIMM_FAMILY_HPE2,
+	NFIT_DEV_DIMM_N_MSFT = NVDIMM_FAMILY_MSFT,
+	NFIT_SPA_VOLATILE,
+	NFIT_SPA_PM,
+	NFIT_SPA_DCR,
+	NFIT_SPA_BDW,
+	NFIT_SPA_VDISK,
+	NFIT_SPA_VCD,
+	NFIT_SPA_PDISK,
+	NFIT_SPA_PCD,
+	NFIT_DEV_BUS,
+	NFIT_UUID_MAX,
+};
+
+/*
+ * Region format interface codes are stored as an array of bytes in the
+ * NFIT DIMM Control Region structure
+ */
+#define NFIT_FIC_BYTE cpu_to_be16(0x101) /* byte-addressable energy backed */
+#define NFIT_FIC_BLK cpu_to_be16(0x201) /* block-addressable non-energy backed */
+#define NFIT_FIC_BYTEN cpu_to_be16(0x301) /* byte-addressable non-energy backed */
+
+enum {
+	NFIT_BLK_READ_FLUSH = 1,
+	NFIT_BLK_DCR_LATCH = 2,
+	NFIT_ARS_STATUS_DONE = 0,
+	NFIT_ARS_STATUS_BUSY = 1 << 16,
+	NFIT_ARS_STATUS_NONE = 2 << 16,
+	NFIT_ARS_STATUS_INTR = 3 << 16,
+	NFIT_ARS_START_BUSY = 6,
+	NFIT_ARS_CAP_NONE = 1,
+	NFIT_ARS_F_OVERFLOW = 1,
+	NFIT_ARS_TIMEOUT = 90,
+};
+
+struct nfit_spa {
+	struct list_head list;
+	struct nd_region *nd_region;
+	unsigned int ars_required:1;
+	u32 clear_err_unit;
+	u32 max_ars;
+	struct acpi_nfit_system_address spa[0];
+};
+
+struct nfit_dcr {
+	struct list_head list;
+	struct acpi_nfit_control_region dcr[0];
+};
+
+struct nfit_bdw {
+	struct list_head list;
+	struct acpi_nfit_data_region bdw[0];
+};
+
+struct nfit_idt {
+	struct list_head list;
+	struct acpi_nfit_interleave idt[0];
+};
+
+struct nfit_flush {
+	struct list_head list;
+	struct acpi_nfit_flush_address flush[0];
+};
+
+struct nfit_memdev {
+	struct list_head list;
+	struct acpi_nfit_memory_map memdev[0];
+};
+
+/* assembled tables for a given dimm/memory-device */
+struct nfit_mem {
+	struct nvdimm *nvdimm;
+	struct acpi_nfit_memory_map *memdev_dcr;
+	struct acpi_nfit_memory_map *memdev_pmem;
+	struct acpi_nfit_memory_map *memdev_bdw;
+	struct acpi_nfit_control_region *dcr;
+	struct acpi_nfit_data_region *bdw;
+	struct acpi_nfit_system_address *spa_dcr;
+	struct acpi_nfit_system_address *spa_bdw;
+	struct acpi_nfit_interleave *idt_dcr;
+	struct acpi_nfit_interleave *idt_bdw;
+	struct nfit_flush *nfit_flush;
+	struct list_head list;
+	struct acpi_device *adev;
+	struct acpi_nfit_desc *acpi_desc;
+	struct resource *flush_wpq;
+	unsigned long dsm_mask;
+	int family;
+};
+
+struct acpi_nfit_desc {
+	struct nvdimm_bus_descriptor nd_desc;
+	struct acpi_table_header acpi_header;
+	struct mutex init_mutex;
+	struct list_head memdevs;
+	struct list_head flushes;
+	struct list_head dimms;
+	struct list_head spas;
+	struct list_head dcrs;
+	struct list_head bdws;
+	struct list_head idts;
+	struct nvdimm_bus *nvdimm_bus;
+	struct device *dev;
+	struct nd_cmd_ars_status *ars_status;
+	size_t ars_status_size;
+	struct work_struct work;
+	struct kernfs_node *scrub_count_state;
+	unsigned int scrub_count;
+	unsigned int cancel:1;
+	unsigned long dimm_cmd_force_en;
+	unsigned long bus_cmd_force_en;
+	int (*blk_do_io)(struct nd_blk_region *ndbr, resource_size_t dpa,
+			void *iobuf, u64 len, int rw);
+};
+
+enum nd_blk_mmio_selector {
+	BDW,
+	DCR,
+};
+
+struct nd_blk_addr {
+	union {
+		void __iomem *base;
+		void *aperture;
+	};
+};
+
+struct nfit_blk {
+	struct nfit_blk_mmio {
+		struct nd_blk_addr addr;
+		u64 size;
+		u64 base_offset;
+		u32 line_size;
+		u32 num_lines;
+		u32 table_size;
+		struct acpi_nfit_interleave *idt;
+		struct acpi_nfit_system_address *spa;
+	} mmio[2];
+	struct nd_region *nd_region;
+	u64 bdw_offset; /* post interleave offset */
+	u64 stat_offset;
+	u64 cmd_offset;
+	u32 dimm_flags;
+};
+
+static inline struct acpi_nfit_memory_map *__to_nfit_memdev(
+		struct nfit_mem *nfit_mem)
+{
+	if (nfit_mem->memdev_dcr)
+		return nfit_mem->memdev_dcr;
+	return nfit_mem->memdev_pmem;
+}
+
+static inline struct acpi_nfit_desc *to_acpi_desc(
+		struct nvdimm_bus_descriptor *nd_desc)
+{
+	return container_of(nd_desc, struct acpi_nfit_desc, nd_desc);
+}
+
+const u8 *to_nfit_uuid(enum nfit_uuids id);
+int acpi_nfit_init(struct acpi_nfit_desc *acpi_desc, void *nfit, acpi_size sz);
+void acpi_nfit_desc_init(struct acpi_nfit_desc *acpi_desc, struct device *dev);
+#endif /* __NFIT_H__ */
