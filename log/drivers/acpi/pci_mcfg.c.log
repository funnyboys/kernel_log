commit 0b104773b4f72ccd8af98a2f1efe69b174c344d3
Author: Rob Herring <robh@kernel.org>
Date:   Thu Apr 9 17:49:21 2020 -0600

    PCI: Constify struct pci_ecam_ops
    
    struct pci_ecam_ops is typically DT match table data which is defined to
    be const. It's also best practice for ops structs to be const. Ideally,
    we'd make struct pci_ops const as well, but that becomes pretty
    invasive, so for now we just cast it where needed.
    
    Link: https://lore.kernel.org/r/20200409234923.21598-2-robh@kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Andrew Murray <amurray@thegoodpenguin.co.uk>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Jonathan Chocron <jonnyc@amazon.com>
    Cc: Zhou Wang <wangzhou1@hisilicon.com>
    Cc: Robert Richter <rrichter@marvell.com>
    Cc: Toan Le <toan@os.amperecomputing.com>
    Cc: Marc Gonzalez <marc.w.gonzalez@free.fr>
    Cc: Mans Rullgard <mans@mansr.com>
    Cc: linux-acpi@vger.kernel.org

diff --git a/drivers/acpi/pci_mcfg.c b/drivers/acpi/pci_mcfg.c
index 6b347d9920cc..54b36b7ad47d 100644
--- a/drivers/acpi/pci_mcfg.c
+++ b/drivers/acpi/pci_mcfg.c
@@ -29,7 +29,7 @@ struct mcfg_fixup {
 	u32 oem_revision;
 	u16 segment;
 	struct resource bus_range;
-	struct pci_ecam_ops *ops;
+	const struct pci_ecam_ops *ops;
 	struct resource cfgres;
 };
 
@@ -165,7 +165,7 @@ static int pci_mcfg_quirk_matches(struct mcfg_fixup *f, u16 segment,
 
 static void pci_mcfg_apply_quirks(struct acpi_pci_root *root,
 				  struct resource *cfgres,
-				  struct pci_ecam_ops **ecam_ops)
+				  const struct pci_ecam_ops **ecam_ops)
 {
 #ifdef CONFIG_PCI_QUIRKS
 	u16 segment = root->segment;
@@ -191,9 +191,9 @@ static void pci_mcfg_apply_quirks(struct acpi_pci_root *root,
 static LIST_HEAD(pci_mcfg_list);
 
 int pci_mcfg_lookup(struct acpi_pci_root *root, struct resource *cfgres,
-		    struct pci_ecam_ops **ecam_ops)
+		    const struct pci_ecam_ops **ecam_ops)
 {
-	struct pci_ecam_ops *ops = &pci_generic_ecam_ops;
+	const struct pci_ecam_ops *ops = &pci_generic_ecam_ops;
 	struct resource *bus_res = &root->secondary;
 	u16 seg = root->segment;
 	struct mcfg_entry *e;

commit cb849fc5f0c7a09e9033cad6c42efe40ce85545a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:10:52 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 459
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation the gpl this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      version 2 gplv2 for more details you should have received a copy of
      the gnu general public license version 2 gplv2 along with this
      source code
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 16 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081201.771169395@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/pci_mcfg.c b/drivers/acpi/pci_mcfg.c
index b42be067fb83..6b347d9920cc 100644
--- a/drivers/acpi/pci_mcfg.c
+++ b/drivers/acpi/pci_mcfg.c
@@ -1,20 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2016 Broadcom
  *	Author: Jayachandran C <jchandra@broadcom.com>
  * Copyright (C) 2016 Semihalf
  * 	Author: Tomasz Nowicki <tn@semihalf.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License, version 2, as
- * published by the Free Software Foundation (the "GPL").
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License version 2 (GPLv2) for more details.
- *
- * You should have received a copy of the GNU General Public License
- * version 2 (GPLv2) along with this source code.
  */
 
 #define pr_fmt(fmt) "ACPI: " fmt

commit 4166bfe53093b687a0b1b22e5d943e143b8089b2
Author: Jonathan Chocron <jonnyc@amazon.com>
Date:   Thu Mar 28 13:57:56 2019 +0200

    PCI: al: Add Amazon Annapurna Labs PCIe host controller driver
    
    Add driver for Amazon's Annapurna Labs PCIe host controller.  The
    controller is based on DesignWare's IP.
    
    The controller doesn't support accessing the Root Port's config space via
    ECAM, so we obtain its base address via an AMZN0001 device.
    
    Furthermore, the DesignWare PCIe controller doesn't filter out config
    transactions sent to devices 1 and up on its bus, so they are filtered by
    the driver.
    
    All subordinate buses do support ECAM access.
    
    Implementing specific PCI config access functions involves:
     - Adding an init function to obtain the Root Port's base address from
       an AMZN0001 device.
     - Adding a new entry in the MCFG quirk array.
    
    [bhelgaas: Note that there is no Kconfig option for this driver because it
    is only intended for use with the generic ACPI host bridge driver.  This
    driver is only needed because the DesignWare IP doesn't completely support
    ECAM access to the root bus.]
    
    Link: https://lore.kernel.org/lkml/1553774276-24675-1-git-send-email-jonnyc@amazon.com
    Co-developed-by: Vladimir Aerov <vaerov@amazon.com>
    Signed-off-by: Jonathan Chocron <jonnyc@amazon.com>
    Signed-off-by: Vladimir Aerov <vaerov@amazon.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: David Woodhouse <dwmw@amazon.co.uk>
    Reviewed-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/drivers/acpi/pci_mcfg.c b/drivers/acpi/pci_mcfg.c
index a4e8432fc2fb..b42be067fb83 100644
--- a/drivers/acpi/pci_mcfg.c
+++ b/drivers/acpi/pci_mcfg.c
@@ -52,6 +52,18 @@ struct mcfg_fixup {
 static struct mcfg_fixup mcfg_quirks[] = {
 /*	{ OEM_ID, OEM_TABLE_ID, REV, SEGMENT, BUS_RANGE, ops, cfgres }, */
 
+#define AL_ECAM(table_id, rev, seg, ops) \
+	{ "AMAZON", table_id, rev, seg, MCFG_BUS_ANY, ops }
+
+	AL_ECAM("GRAVITON", 0, 0, &al_pcie_ops),
+	AL_ECAM("GRAVITON", 0, 1, &al_pcie_ops),
+	AL_ECAM("GRAVITON", 0, 2, &al_pcie_ops),
+	AL_ECAM("GRAVITON", 0, 3, &al_pcie_ops),
+	AL_ECAM("GRAVITON", 0, 4, &al_pcie_ops),
+	AL_ECAM("GRAVITON", 0, 5, &al_pcie_ops),
+	AL_ECAM("GRAVITON", 0, 6, &al_pcie_ops),
+	AL_ECAM("GRAVITON", 0, 7, &al_pcie_ops),
+
 #define QCOM_ECAM32(seg) \
 	{ "QCOM  ", "QDF2432 ", 1, seg, MCFG_BUS_ANY, &pci_32b_ops }
 

commit cd183740480f045600aa1fa38fe70809b5498f05
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Wed Mar 29 14:16:13 2017 +0200

    PCI/ACPI: Add ThunderX pass2.x 2nd node MCFG quirk
    
    Currently SoCs pass2.x do not emulate EA headers for ACPI boot method at
    all.  However, for pass2.x some devices (like EDAC) advertise incorrect
    base addresses in their BARs which results in driver probe failure during
    resource request.  Since all problematic blocks are on 2nd NUMA node under
    domain 10 add necessary quirk entry to obtain BAR addresses correction
    using EA header emulation.
    
    Fixes: 44f22bd91e88 ("PCI: Add MCFG quirks for Cavium ThunderX pass2.x host controller")
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Robert Richter <rrichter@cavium.com>
    CC: stable@vger.kernel.org      # v4.10+

diff --git a/drivers/acpi/pci_mcfg.c b/drivers/acpi/pci_mcfg.c
index 65affd8f29c1..a4e8432fc2fb 100644
--- a/drivers/acpi/pci_mcfg.c
+++ b/drivers/acpi/pci_mcfg.c
@@ -101,6 +101,7 @@ static struct mcfg_fixup mcfg_quirks[] = {
 	/* SoC pass2.x */
 	THUNDER_PEM_QUIRK(1, 0),
 	THUNDER_PEM_QUIRK(1, 1),
+	THUNDER_ECAM_QUIRK(1, 10),
 
 	/* SoC pass1.x */
 	THUNDER_PEM_QUIRK(2, 0),	/* off-chip devices */

commit ced414a14f709fc0af60bd381ba8a566dc566869
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 21 11:42:54 2017 -0500

    PCI/ACPI: Tidy up MCFG quirk whitespace
    
    With no blank lines, it's not obvious where the macro definitions end and
    the uses begin.  Add some blank lines and reorder the ThunderX definitions.
    No functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v4.10+

diff --git a/drivers/acpi/pci_mcfg.c b/drivers/acpi/pci_mcfg.c
index 2944353253ed..65affd8f29c1 100644
--- a/drivers/acpi/pci_mcfg.c
+++ b/drivers/acpi/pci_mcfg.c
@@ -54,6 +54,7 @@ static struct mcfg_fixup mcfg_quirks[] = {
 
 #define QCOM_ECAM32(seg) \
 	{ "QCOM  ", "QDF2432 ", 1, seg, MCFG_BUS_ANY, &pci_32b_ops }
+
 	QCOM_ECAM32(0),
 	QCOM_ECAM32(1),
 	QCOM_ECAM32(2),
@@ -68,6 +69,7 @@ static struct mcfg_fixup mcfg_quirks[] = {
 	{ "HISI  ", table_id, 0, (seg) + 1, MCFG_BUS_ANY, ops }, \
 	{ "HISI  ", table_id, 0, (seg) + 2, MCFG_BUS_ANY, ops }, \
 	{ "HISI  ", table_id, 0, (seg) + 3, MCFG_BUS_ANY, ops }
+
 	HISI_QUAD_DOM("HIP05   ",  0, &hisi_pcie_ops),
 	HISI_QUAD_DOM("HIP06   ",  0, &hisi_pcie_ops),
 	HISI_QUAD_DOM("HIP07   ",  0, &hisi_pcie_ops),
@@ -77,6 +79,7 @@ static struct mcfg_fixup mcfg_quirks[] = {
 
 #define THUNDER_PEM_RES(addr, node) \
 	DEFINE_RES_MEM((addr) + ((u64) (node) << 44), 0x39 * SZ_16M)
+
 #define THUNDER_PEM_QUIRK(rev, node) \
 	{ "CAVIUM", "THUNDERX", rev, 4 + (10 * (node)), MCFG_BUS_ANY,	    \
 	  &thunder_pem_ecam_ops, THUNDER_PEM_RES(0x88001f000000UL, node) },  \
@@ -90,13 +93,15 @@ static struct mcfg_fixup mcfg_quirks[] = {
 	  &thunder_pem_ecam_ops, THUNDER_PEM_RES(0x894057000000UL, node) },  \
 	{ "CAVIUM", "THUNDERX", rev, 9 + (10 * (node)), MCFG_BUS_ANY,	    \
 	  &thunder_pem_ecam_ops, THUNDER_PEM_RES(0x89808f000000UL, node) }
-	/* SoC pass2.x */
-	THUNDER_PEM_QUIRK(1, 0),
-	THUNDER_PEM_QUIRK(1, 1),
 
 #define THUNDER_ECAM_QUIRK(rev, seg)					\
 	{ "CAVIUM", "THUNDERX", rev, seg, MCFG_BUS_ANY,			\
 	&pci_thunder_ecam_ops }
+
+	/* SoC pass2.x */
+	THUNDER_PEM_QUIRK(1, 0),
+	THUNDER_PEM_QUIRK(1, 1),
+
 	/* SoC pass1.x */
 	THUNDER_PEM_QUIRK(2, 0),	/* off-chip devices */
 	THUNDER_PEM_QUIRK(2, 1),	/* off-chip devices */
@@ -112,9 +117,11 @@ static struct mcfg_fixup mcfg_quirks[] = {
 #define XGENE_V1_ECAM_MCFG(rev, seg) \
 	{"APM   ", "XGENE   ", rev, seg, MCFG_BUS_ANY, \
 		&xgene_v1_pcie_ecam_ops }
+
 #define XGENE_V2_ECAM_MCFG(rev, seg) \
 	{"APM   ", "XGENE   ", rev, seg, MCFG_BUS_ANY, \
 		&xgene_v2_pcie_ecam_ops }
+
 	/* X-Gene SoC with v1 PCIe controller */
 	XGENE_V1_ECAM_MCFG(1, 0),
 	XGENE_V1_ECAM_MCFG(1, 1),

commit 53762ba810398c11efaf65f9a45d992125e86dcf
Author: Zhou Wang <wangzhou1@hisilicon.com>
Date:   Wed Jan 4 15:00:06 2017 +0800

    PCI/ACPI: Fix bus range comparison in pci_mcfg_lookup()
    
    The configuration data provided by an MCFG entry, i.e., PCI segment and bus
    range, may span multiple host bridges.
    
    pci_mcfg_lookup() previously required an exact match of the host bridge
    starting bus and the MCFG starting bus, which made the following
    configuration fail:
    
      MCFG region:
        segment: 0
        bus range: 0x00-0xff
    
      host bridge
        segment: 0
        bus range: 0x20-0x4f
    
    Relax the bus range check in pci_mcfg_lookup() so we can use any MCFG entry
    that contains the required bus range, as we do in pci_mmconfig_lookup().
    
    [bhelgaas: changelog]
    Signed-off-by: Zhou Wang <wangzhou1@hisilicon.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Tomasz Nowicki <tn@semihalf.com>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/drivers/acpi/pci_mcfg.c b/drivers/acpi/pci_mcfg.c
index a6a4ceaa6cc3..2944353253ed 100644
--- a/drivers/acpi/pci_mcfg.c
+++ b/drivers/acpi/pci_mcfg.c
@@ -195,11 +195,10 @@ int pci_mcfg_lookup(struct acpi_pci_root *root, struct resource *cfgres,
 		goto skip_lookup;
 
 	/*
-	 * We expect exact match, unless MCFG entry end bus covers more than
-	 * specified by caller.
+	 * We expect the range in bus_res in the coverage of MCFG bus range.
 	 */
 	list_for_each_entry(e, &pci_mcfg_list, list) {
-		if (e->segment == seg && e->bus_start == bus_res->start &&
+		if (e->segment == seg && e->bus_start <= bus_res->start &&
 		    e->bus_end >= bus_res->end) {
 			root->mcfg_addr = e->addr;
 		}

commit c5d4603961009c39de94725213d8b5420f110f9e
Author: Duc Dang <dhdang@apm.com>
Date:   Thu Dec 1 18:27:07 2016 -0800

    PCI: Add MCFG quirks for X-Gene host controller
    
    PCIe controllers in X-Gene SoCs are not ECAM compliant: software needs to
    configure additional controller's register to address device at
    bus:dev:function.
    
    Add a quirk to discover controller MMIO register space and configure
    controller registers to select and address the target secondary device.
    
    The quirk will only be applied for X-Gene PCIe MCFG table with
    OEM revison 1, 2, 3 or 4 (PCIe controller v1 and v2 on X-Gene SoCs).
    
    Tested-by: Jon Masters <jcm@redhat.com>
    Signed-off-by: Duc Dang <dhdang@apm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/pci_mcfg.c b/drivers/acpi/pci_mcfg.c
index 1cfe65d87adf..a6a4ceaa6cc3 100644
--- a/drivers/acpi/pci_mcfg.c
+++ b/drivers/acpi/pci_mcfg.c
@@ -108,6 +108,31 @@ static struct mcfg_fixup mcfg_quirks[] = {
 	THUNDER_ECAM_QUIRK(2, 11),
 	THUNDER_ECAM_QUIRK(2, 12),
 	THUNDER_ECAM_QUIRK(2, 13),
+
+#define XGENE_V1_ECAM_MCFG(rev, seg) \
+	{"APM   ", "XGENE   ", rev, seg, MCFG_BUS_ANY, \
+		&xgene_v1_pcie_ecam_ops }
+#define XGENE_V2_ECAM_MCFG(rev, seg) \
+	{"APM   ", "XGENE   ", rev, seg, MCFG_BUS_ANY, \
+		&xgene_v2_pcie_ecam_ops }
+	/* X-Gene SoC with v1 PCIe controller */
+	XGENE_V1_ECAM_MCFG(1, 0),
+	XGENE_V1_ECAM_MCFG(1, 1),
+	XGENE_V1_ECAM_MCFG(1, 2),
+	XGENE_V1_ECAM_MCFG(1, 3),
+	XGENE_V1_ECAM_MCFG(1, 4),
+	XGENE_V1_ECAM_MCFG(2, 0),
+	XGENE_V1_ECAM_MCFG(2, 1),
+	XGENE_V1_ECAM_MCFG(2, 2),
+	XGENE_V1_ECAM_MCFG(2, 3),
+	XGENE_V1_ECAM_MCFG(2, 4),
+	/* X-Gene SoC with v2.1 PCIe controller */
+	XGENE_V2_ECAM_MCFG(3, 0),
+	XGENE_V2_ECAM_MCFG(3, 1),
+	/* X-Gene SoC with v2.2 PCIe controller */
+	XGENE_V2_ECAM_MCFG(4, 0),
+	XGENE_V2_ECAM_MCFG(4, 1),
+	XGENE_V2_ECAM_MCFG(4, 2),
 };
 
 static char mcfg_oem_id[ACPI_OEM_ID_SIZE];

commit 648d93fc77da4f655cf13108417f33c91d745e2c
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Wed Nov 30 23:16:34 2016 -0600

    PCI: Add MCFG quirks for Cavium ThunderX pass1.x host controller
    
    ThunderX pass1.x requires to emulate the EA headers for on-chip devices
    hence it has to use custom pci_thunder_ecam_ops for accessing PCI config
    space (pci-thunder-ecam.c). Add new entries to MCFG quirk array where it
    can be applied while probing ACPI based PCI host controller.
    
    ThunderX pass1.x is using the same way for accessing off-chip devices
    (so-called PEM) as silicon pass-2.x so we need to add PEM quirk entries
    too.
    
    Quirk is considered for ThunderX silicon pass1.x only which is identified
    via MCFG revision 2.
    
    ThunderX pass 1.x requires the following accessors:
    
      NUMA node 0 PCI segments  0- 3: pci_thunder_ecam_ops (MCFG quirk)
      NUMA node 0 PCI segments  4- 9: thunder_pem_ecam_ops (MCFG quirk)
      NUMA node 1 PCI segments 10-13: pci_thunder_ecam_ops (MCFG quirk)
      NUMA node 1 PCI segments 14-19: thunder_pem_ecam_ops (MCFG quirk)
    
    [bhelgaas: change Makefile/ifdefs so quirk doesn't depend on
    CONFIG_PCI_HOST_THUNDER_ECAM]
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/pci_mcfg.c b/drivers/acpi/pci_mcfg.c
index 17cbb07ce16c..1cfe65d87adf 100644
--- a/drivers/acpi/pci_mcfg.c
+++ b/drivers/acpi/pci_mcfg.c
@@ -93,6 +93,21 @@ static struct mcfg_fixup mcfg_quirks[] = {
 	/* SoC pass2.x */
 	THUNDER_PEM_QUIRK(1, 0),
 	THUNDER_PEM_QUIRK(1, 1),
+
+#define THUNDER_ECAM_QUIRK(rev, seg)					\
+	{ "CAVIUM", "THUNDERX", rev, seg, MCFG_BUS_ANY,			\
+	&pci_thunder_ecam_ops }
+	/* SoC pass1.x */
+	THUNDER_PEM_QUIRK(2, 0),	/* off-chip devices */
+	THUNDER_PEM_QUIRK(2, 1),	/* off-chip devices */
+	THUNDER_ECAM_QUIRK(2,  0),
+	THUNDER_ECAM_QUIRK(2,  1),
+	THUNDER_ECAM_QUIRK(2,  2),
+	THUNDER_ECAM_QUIRK(2,  3),
+	THUNDER_ECAM_QUIRK(2, 10),
+	THUNDER_ECAM_QUIRK(2, 11),
+	THUNDER_ECAM_QUIRK(2, 12),
+	THUNDER_ECAM_QUIRK(2, 13),
 };
 
 static char mcfg_oem_id[ACPI_OEM_ID_SIZE];

commit 44f22bd91e88f9a1203a6e564a237e593f5f2f74
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Thu Dec 1 00:07:56 2016 -0600

    PCI: Add MCFG quirks for Cavium ThunderX pass2.x host controller
    
    ThunderX PCIe controller to off-chip devices (so-called PEM) is not fully
    compliant with ECAM standard. It uses non-standard configuration space
    accessors (see thunder_pem_ecam_ops) and custom configuration space
    granulation (see bus_shift = 24). In order to access configuration space
    and probe PEM as ACPI-based PCI host controller we need to add MCFG quirk
    infrastructure. This involves:
    1. A new thunder_pem_acpi_init() init function to locate PEM-specific
       register ranges using ACPI.
    2. Export PEM thunder_pem_ecam_ops structure so it is visible to MCFG quirk
       code.
    3. New quirk entries for each PEM segment. Each contains platform IDs,
       mentioned thunder_pem_ecam_ops and CFG resources.
    
    Quirk is considered for ThunderX silicon pass2.x only which is identified
    via MCFG revision 1.
    
    ThunderX pass 2.x requires the following accessors:
    
      NUMA Node 0 PCI segments  0- 3: pci_generic_ecam_ops (ECAM-compliant)
      NUMA Node 0 PCI segments  4- 9: thunder_pem_ecam_ops (MCFG quirk)
      NUMA Node 1 PCI segments 10-13: pci_generic_ecam_ops (ECAM-compliant)
      NUMA Node 1 PCI segments 14-19: thunder_pem_ecam_ops (MCFG quirk)
    
    [bhelgaas: adapt to use acpi_get_rc_resources(), update Makefile/ifdefs so
    quirk doesn't depend on CONFIG_PCI_HOST_THUNDER_PEM]
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/pci_mcfg.c b/drivers/acpi/pci_mcfg.c
index dd162248c3ee..17cbb07ce16c 100644
--- a/drivers/acpi/pci_mcfg.c
+++ b/drivers/acpi/pci_mcfg.c
@@ -74,6 +74,25 @@ static struct mcfg_fixup mcfg_quirks[] = {
 	HISI_QUAD_DOM("HIP07   ",  4, &hisi_pcie_ops),
 	HISI_QUAD_DOM("HIP07   ",  8, &hisi_pcie_ops),
 	HISI_QUAD_DOM("HIP07   ", 12, &hisi_pcie_ops),
+
+#define THUNDER_PEM_RES(addr, node) \
+	DEFINE_RES_MEM((addr) + ((u64) (node) << 44), 0x39 * SZ_16M)
+#define THUNDER_PEM_QUIRK(rev, node) \
+	{ "CAVIUM", "THUNDERX", rev, 4 + (10 * (node)), MCFG_BUS_ANY,	    \
+	  &thunder_pem_ecam_ops, THUNDER_PEM_RES(0x88001f000000UL, node) },  \
+	{ "CAVIUM", "THUNDERX", rev, 5 + (10 * (node)), MCFG_BUS_ANY,	    \
+	  &thunder_pem_ecam_ops, THUNDER_PEM_RES(0x884057000000UL, node) },  \
+	{ "CAVIUM", "THUNDERX", rev, 6 + (10 * (node)), MCFG_BUS_ANY,	    \
+	  &thunder_pem_ecam_ops, THUNDER_PEM_RES(0x88808f000000UL, node) },  \
+	{ "CAVIUM", "THUNDERX", rev, 7 + (10 * (node)), MCFG_BUS_ANY,	    \
+	  &thunder_pem_ecam_ops, THUNDER_PEM_RES(0x89001f000000UL, node) },  \
+	{ "CAVIUM", "THUNDERX", rev, 8 + (10 * (node)), MCFG_BUS_ANY,	    \
+	  &thunder_pem_ecam_ops, THUNDER_PEM_RES(0x894057000000UL, node) },  \
+	{ "CAVIUM", "THUNDERX", rev, 9 + (10 * (node)), MCFG_BUS_ANY,	    \
+	  &thunder_pem_ecam_ops, THUNDER_PEM_RES(0x89808f000000UL, node) }
+	/* SoC pass2.x */
+	THUNDER_PEM_QUIRK(1, 0),
+	THUNDER_PEM_QUIRK(1, 1),
 };
 
 static char mcfg_oem_id[ACPI_OEM_ID_SIZE];

commit 5f00f1a0178cf52928366a5e1f376a65f1f3f389
Author: Dongdong Liu <liudongdong3@huawei.com>
Date:   Thu Dec 1 00:45:35 2016 -0600

    PCI: Add MCFG quirks for HiSilicon Hip05/06/07 host controllers
    
    The PCIe controller in Hip05/Hip06/Hip07 SoCs is not completely
    ECAM-compliant.  It is non-ECAM only for the RC bus config space; for any
    other bus underneath the root bus it does support ECAM access.
    
    Add specific quirks for PCI config space accessors.  This involves:
    1. New initialization call hisi_pcie_init() to obtain RC base
    addresses from PNP0C02 at the root of the ACPI namespace (under \_SB).
    2. New entry in common quirk array.
    
    [bhelgaas: move to pcie-hisi.c and change Makefile/ifdefs so quirk doesn't
    depend on CONFIG_PCI_HISI]
    Signed-off-by: Dongdong Liu <liudongdong3@huawei.com>
    Signed-off-by: Gabriele Paoloni <gabriele.paoloni@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/pci_mcfg.c b/drivers/acpi/pci_mcfg.c
index cee33b078d3d..dd162248c3ee 100644
--- a/drivers/acpi/pci_mcfg.c
+++ b/drivers/acpi/pci_mcfg.c
@@ -62,6 +62,18 @@ static struct mcfg_fixup mcfg_quirks[] = {
 	QCOM_ECAM32(5),
 	QCOM_ECAM32(6),
 	QCOM_ECAM32(7),
+
+#define HISI_QUAD_DOM(table_id, seg, ops) \
+	{ "HISI  ", table_id, 0, (seg) + 0, MCFG_BUS_ANY, ops }, \
+	{ "HISI  ", table_id, 0, (seg) + 1, MCFG_BUS_ANY, ops }, \
+	{ "HISI  ", table_id, 0, (seg) + 2, MCFG_BUS_ANY, ops }, \
+	{ "HISI  ", table_id, 0, (seg) + 3, MCFG_BUS_ANY, ops }
+	HISI_QUAD_DOM("HIP05   ",  0, &hisi_pcie_ops),
+	HISI_QUAD_DOM("HIP06   ",  0, &hisi_pcie_ops),
+	HISI_QUAD_DOM("HIP07   ",  0, &hisi_pcie_ops),
+	HISI_QUAD_DOM("HIP07   ",  4, &hisi_pcie_ops),
+	HISI_QUAD_DOM("HIP07   ",  8, &hisi_pcie_ops),
+	HISI_QUAD_DOM("HIP07   ", 12, &hisi_pcie_ops),
 };
 
 static char mcfg_oem_id[ACPI_OEM_ID_SIZE];

commit 2ca5b8ddc6f70d77a51851ba5e5cd0d39c27dd88
Author: Christopher Covington <cov@codeaurora.org>
Date:   Wed Nov 2 11:11:27 2016 -0500

    PCI: Add MCFG quirks for Qualcomm QDF2432 host controller
    
    The Qualcomm Technologies QDF2432 SoC does not support accesses smaller
    than 32 bits to the PCI configuration space.  Register the appropriate
    quirk.
    
    [bhelgaas: add QCOM_ECAM32 macro, ifdef for ACPI and PCI_QUIRKS]
    Signed-off-by: Christopher Covington <cov@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/pci_mcfg.c b/drivers/acpi/pci_mcfg.c
index 1ef72857b710..cee33b078d3d 100644
--- a/drivers/acpi/pci_mcfg.c
+++ b/drivers/acpi/pci_mcfg.c
@@ -51,6 +51,17 @@ struct mcfg_fixup {
 
 static struct mcfg_fixup mcfg_quirks[] = {
 /*	{ OEM_ID, OEM_TABLE_ID, REV, SEGMENT, BUS_RANGE, ops, cfgres }, */
+
+#define QCOM_ECAM32(seg) \
+	{ "QCOM  ", "QDF2432 ", 1, seg, MCFG_BUS_ANY, &pci_32b_ops }
+	QCOM_ECAM32(0),
+	QCOM_ECAM32(1),
+	QCOM_ECAM32(2),
+	QCOM_ECAM32(3),
+	QCOM_ECAM32(4),
+	QCOM_ECAM32(5),
+	QCOM_ECAM32(6),
+	QCOM_ECAM32(7),
 };
 
 static char mcfg_oem_id[ACPI_OEM_ID_SIZE];

commit 5b69b85ba1ddd36be01f5c57830b37a3c8256009
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Fri Sep 9 21:24:04 2016 +0200

    PCI/ACPI: Check for platform-specific MCFG quirks
    
    The PCIe spec (r3.0, sec 7.2.2) specifies an "Enhanced Configuration Access
    Mechanism" (ECAM) for memory-mapped access to configuration space.  ECAM is
    required for PCIe systems unless there's a standard firmware interface for
    config access.
    
    In the absence of a firmware interface, we use pci_generic_ecam_ops, and on
    ACPI systems, we discover the ECAM space via the MCFG table and/or the _CBA
    method.
    
    Unfortunately some systems provide MCFG but don't implement ECAM according
    to spec, so we need a mechanism for quirks to make those systems work.
    
    Add an MCFG quirk mechanism to override the config accessor functions
    and/or the memory-mapped address space.
    
    A quirk is selected if it matches all of the following:
    
      - OEM ID
      - OEM Table ID
      - OEM Revision
      - PCI segment (from _SEG)
      - PCI bus number range (from _CRS, wildcard allowed)
    
    If the quirk specifies config accessor functions or a memory-mapped address
    range, these override the defaults.
    
    [bhelgaas: changelog, reorder quirk matching, fix oem_revision typo per
    Duc, add under #ifdef CONFIG_PCI_QUIRKS]
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Dongdong Liu <liudongdong3@huawei.com>
    Signed-off-by: Christopher Covington <cov@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/pci_mcfg.c b/drivers/acpi/pci_mcfg.c
index ffcc6513e851..1ef72857b710 100644
--- a/drivers/acpi/pci_mcfg.c
+++ b/drivers/acpi/pci_mcfg.c
@@ -33,6 +33,69 @@ struct mcfg_entry {
 	u8			bus_end;
 };
 
+#ifdef CONFIG_PCI_QUIRKS
+struct mcfg_fixup {
+	char oem_id[ACPI_OEM_ID_SIZE + 1];
+	char oem_table_id[ACPI_OEM_TABLE_ID_SIZE + 1];
+	u32 oem_revision;
+	u16 segment;
+	struct resource bus_range;
+	struct pci_ecam_ops *ops;
+	struct resource cfgres;
+};
+
+#define MCFG_BUS_RANGE(start, end)	DEFINE_RES_NAMED((start),	\
+						((end) - (start) + 1),	\
+						NULL, IORESOURCE_BUS)
+#define MCFG_BUS_ANY			MCFG_BUS_RANGE(0x0, 0xff)
+
+static struct mcfg_fixup mcfg_quirks[] = {
+/*	{ OEM_ID, OEM_TABLE_ID, REV, SEGMENT, BUS_RANGE, ops, cfgres }, */
+};
+
+static char mcfg_oem_id[ACPI_OEM_ID_SIZE];
+static char mcfg_oem_table_id[ACPI_OEM_TABLE_ID_SIZE];
+static u32 mcfg_oem_revision;
+
+static int pci_mcfg_quirk_matches(struct mcfg_fixup *f, u16 segment,
+				  struct resource *bus_range)
+{
+	if (!memcmp(f->oem_id, mcfg_oem_id, ACPI_OEM_ID_SIZE) &&
+	    !memcmp(f->oem_table_id, mcfg_oem_table_id,
+	            ACPI_OEM_TABLE_ID_SIZE) &&
+	    f->oem_revision == mcfg_oem_revision &&
+	    f->segment == segment &&
+	    resource_contains(&f->bus_range, bus_range))
+		return 1;
+
+	return 0;
+}
+#endif
+
+static void pci_mcfg_apply_quirks(struct acpi_pci_root *root,
+				  struct resource *cfgres,
+				  struct pci_ecam_ops **ecam_ops)
+{
+#ifdef CONFIG_PCI_QUIRKS
+	u16 segment = root->segment;
+	struct resource *bus_range = &root->secondary;
+	struct mcfg_fixup *f;
+	int i;
+
+	for (i = 0, f = mcfg_quirks; i < ARRAY_SIZE(mcfg_quirks); i++, f++) {
+		if (pci_mcfg_quirk_matches(f, segment, bus_range)) {
+			if (f->cfgres.start)
+				*cfgres = f->cfgres;
+			if (f->ops)
+				*ecam_ops =  f->ops;
+			dev_info(&root->device->dev, "MCFG quirk: ECAM at %pR for %pR with %ps\n",
+				 cfgres, bus_range, *ecam_ops);
+			return;
+		}
+	}
+#endif
+}
+
 /* List to save MCFG entries */
 static LIST_HEAD(pci_mcfg_list);
 
@@ -61,14 +124,24 @@ int pci_mcfg_lookup(struct acpi_pci_root *root, struct resource *cfgres,
 
 	}
 
-	if (!root->mcfg_addr)
-		return -ENXIO;
-
 skip_lookup:
 	memset(&res, 0, sizeof(res));
-	res.start = root->mcfg_addr + (bus_res->start << 20);
-	res.end = res.start + (resource_size(bus_res) << 20) - 1;
-	res.flags = IORESOURCE_MEM;
+	if (root->mcfg_addr) {
+		res.start = root->mcfg_addr + (bus_res->start << 20);
+		res.end = res.start + (resource_size(bus_res) << 20) - 1;
+		res.flags = IORESOURCE_MEM;
+	}
+
+	/*
+	 * Allow quirks to override default ECAM ops and CFG resource
+	 * range.  This may even fabricate a CFG resource range in case
+	 * MCFG does not have it.  Invalid CFG start address means MCFG
+	 * firmware bug or we need another quirk in array.
+	 */
+	pci_mcfg_apply_quirks(root, &res, &ops);
+	if (!res.start)
+		return -ENXIO;
+
 	*cfgres = res;
 	*ecam_ops = ops;
 	return 0;
@@ -101,6 +174,13 @@ static __init int pci_mcfg_parse(struct acpi_table_header *header)
 		list_add(&e->list, &pci_mcfg_list);
 	}
 
+#ifdef CONFIG_PCI_QUIRKS
+	/* Save MCFG IDs and revision for quirks matching */
+	memcpy(mcfg_oem_id, header->oem_id, ACPI_OEM_ID_SIZE);
+	memcpy(mcfg_oem_table_id, header->oem_table_id, ACPI_OEM_TABLE_ID_SIZE);
+	mcfg_oem_revision = header->oem_revision;
+#endif
+
 	pr_info("MCFG table detected, %d entries\n", n);
 	return 0;
 }

commit 13983eb89d5afaa65acd4479fad151cbd4de5509
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Fri Sep 9 21:24:03 2016 +0200

    PCI/ACPI: Extend pci_mcfg_lookup() to return ECAM config accessors
    
    pci_mcfg_lookup() is the external interface to the generic MCFG code.
    Previously it merely looked up the ECAM base address for a given domain and
    bus range.  We want a way to add MCFG quirks, some of which may require
    special config accessors and adjustments to the ECAM address range.
    
    Extend pci_mcfg_lookup() so it can return a pointer to a pci_ecam_ops
    structure and a struct resource for the ECAM address space.  For now, it
    always returns &pci_generic_ecam_ops (the standard accessor) and the
    resource described by the MCFG.
    
    No functional changes intended.
    
    [bhelgaas: changelog]
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/pci_mcfg.c b/drivers/acpi/pci_mcfg.c
index b5b376e081f5..ffcc6513e851 100644
--- a/drivers/acpi/pci_mcfg.c
+++ b/drivers/acpi/pci_mcfg.c
@@ -22,6 +22,7 @@
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <linux/pci-acpi.h>
+#include <linux/pci-ecam.h>
 
 /* Structure to hold entries from the MCFG table */
 struct mcfg_entry {
@@ -35,9 +36,18 @@ struct mcfg_entry {
 /* List to save MCFG entries */
 static LIST_HEAD(pci_mcfg_list);
 
-phys_addr_t pci_mcfg_lookup(u16 seg, struct resource *bus_res)
+int pci_mcfg_lookup(struct acpi_pci_root *root, struct resource *cfgres,
+		    struct pci_ecam_ops **ecam_ops)
 {
+	struct pci_ecam_ops *ops = &pci_generic_ecam_ops;
+	struct resource *bus_res = &root->secondary;
+	u16 seg = root->segment;
 	struct mcfg_entry *e;
+	struct resource res;
+
+	/* Use address from _CBA if present, otherwise lookup MCFG */
+	if (root->mcfg_addr)
+		goto skip_lookup;
 
 	/*
 	 * We expect exact match, unless MCFG entry end bus covers more than
@@ -45,10 +55,22 @@ phys_addr_t pci_mcfg_lookup(u16 seg, struct resource *bus_res)
 	 */
 	list_for_each_entry(e, &pci_mcfg_list, list) {
 		if (e->segment == seg && e->bus_start == bus_res->start &&
-		    e->bus_end >= bus_res->end)
-			return e->addr;
+		    e->bus_end >= bus_res->end) {
+			root->mcfg_addr = e->addr;
+		}
+
 	}
 
+	if (!root->mcfg_addr)
+		return -ENXIO;
+
+skip_lookup:
+	memset(&res, 0, sizeof(res));
+	res.start = root->mcfg_addr + (bus_res->start << 20);
+	res.end = res.start + (resource_size(bus_res) << 20) - 1;
+	res.flags = IORESOURCE_MEM;
+	*cfgres = res;
+	*ecam_ops = ops;
 	return 0;
 }
 

commit 935c760ec8101413248da23b6df45f0a7a643c62
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Fri Jun 10 21:55:13 2016 +0200

    PCI/ACPI: Add generic MCFG table handling
    
    On ACPI systems that support memory-mapped config space access, i.e., ECAM,
    the PCI Firmware Specification says the OS can learn where the ECAM space
    is from either:
    
      - the static MCFG table (for non-hotpluggable bridges), or
      - the _CBA method (for hotpluggable bridges)
    
    The current MCFG table handling code cannot be easily generalized owing to
    x86-specific quirks, which makes it hard to reuse on other architectures.
    
    Implement generic MCFG handling from scratch, including:
    
      - Simple MCFG table parsing (via pci_mmcfg_late_init() as in current x86)
      - MCFG region lookup for a (domain, bus_start, bus_end) tuple
    
    [bhelgaas: changelog]
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/drivers/acpi/pci_mcfg.c b/drivers/acpi/pci_mcfg.c
new file mode 100644
index 000000000000..b5b376e081f5
--- /dev/null
+++ b/drivers/acpi/pci_mcfg.c
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2016 Broadcom
+ *	Author: Jayachandran C <jchandra@broadcom.com>
+ * Copyright (C) 2016 Semihalf
+ * 	Author: Tomasz Nowicki <tn@semihalf.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, version 2, as
+ * published by the Free Software Foundation (the "GPL").
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License version 2 (GPLv2) for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * version 2 (GPLv2) along with this source code.
+ */
+
+#define pr_fmt(fmt) "ACPI: " fmt
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/pci-acpi.h>
+
+/* Structure to hold entries from the MCFG table */
+struct mcfg_entry {
+	struct list_head	list;
+	phys_addr_t		addr;
+	u16			segment;
+	u8			bus_start;
+	u8			bus_end;
+};
+
+/* List to save MCFG entries */
+static LIST_HEAD(pci_mcfg_list);
+
+phys_addr_t pci_mcfg_lookup(u16 seg, struct resource *bus_res)
+{
+	struct mcfg_entry *e;
+
+	/*
+	 * We expect exact match, unless MCFG entry end bus covers more than
+	 * specified by caller.
+	 */
+	list_for_each_entry(e, &pci_mcfg_list, list) {
+		if (e->segment == seg && e->bus_start == bus_res->start &&
+		    e->bus_end >= bus_res->end)
+			return e->addr;
+	}
+
+	return 0;
+}
+
+static __init int pci_mcfg_parse(struct acpi_table_header *header)
+{
+	struct acpi_table_mcfg *mcfg;
+	struct acpi_mcfg_allocation *mptr;
+	struct mcfg_entry *e, *arr;
+	int i, n;
+
+	if (header->length < sizeof(struct acpi_table_mcfg))
+		return -EINVAL;
+
+	n = (header->length - sizeof(struct acpi_table_mcfg)) /
+					sizeof(struct acpi_mcfg_allocation);
+	mcfg = (struct acpi_table_mcfg *)header;
+	mptr = (struct acpi_mcfg_allocation *) &mcfg[1];
+
+	arr = kcalloc(n, sizeof(*arr), GFP_KERNEL);
+	if (!arr)
+		return -ENOMEM;
+
+	for (i = 0, e = arr; i < n; i++, mptr++, e++) {
+		e->segment = mptr->pci_segment;
+		e->addr =  mptr->address;
+		e->bus_start = mptr->start_bus_number;
+		e->bus_end = mptr->end_bus_number;
+		list_add(&e->list, &pci_mcfg_list);
+	}
+
+	pr_info("MCFG table detected, %d entries\n", n);
+	return 0;
+}
+
+/* Interface called by ACPI - parse and save MCFG table */
+void __init pci_mmcfg_late_init(void)
+{
+	int err = acpi_table_parse(ACPI_SIG_MCFG, pci_mcfg_parse);
+	if (err)
+		pr_err("Failed to parse MCFG (%d)\n", err);
+}
