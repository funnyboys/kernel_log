commit cb0701acfa7e3fe9e919cf2aa2aa939b7fd603c2
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Aug 30 17:34:32 2019 +0300

    ACPI: platform: Unregister stale platform devices
    
    When commit 68bdb6773289 ("ACPI: add support for ACPI reconfiguration
    notifiers") introduced reconfiguration notifiers, it missed the point
    that the ACPI table, which might be loaded and then unloaded via
    ConfigFS, could contain devices that were not enumerated by their
    parents.
    
    In such cases, the stale platform device is dangling in the system
    while the rest of the devices from the same table are already gone.
    
    Introduce acpi_platform_device_remove_notify() notifier that, in
    similar way to IÂ²C or SPI buses, unregisters the platform devices
    on table removal event.
    
    Fixes: 68bdb6773289 ("ACPI: add support for ACPI reconfiguration notifiers")
    Depends-on: 00500147cbd3 ("drivers: Introduce device lookup variants by ACPI_COMPANION device")
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    [ rjw: Changelog & function rename ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 00ec4f2bf015..c05050f474cd 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -31,6 +31,44 @@ static const struct acpi_device_id forbidden_id_list[] = {
 	{"", 0},
 };
 
+static struct platform_device *acpi_platform_device_find_by_companion(struct acpi_device *adev)
+{
+	struct device *dev;
+
+	dev = bus_find_device_by_acpi_dev(&platform_bus_type, adev);
+	return dev ? to_platform_device(dev) : NULL;
+}
+
+static int acpi_platform_device_remove_notify(struct notifier_block *nb,
+					      unsigned long value, void *arg)
+{
+	struct acpi_device *adev = arg;
+	struct platform_device *pdev;
+
+	switch (value) {
+	case ACPI_RECONFIG_DEVICE_ADD:
+		/* Nothing to do here */
+		break;
+	case ACPI_RECONFIG_DEVICE_REMOVE:
+		if (!acpi_device_enumerated(adev))
+			break;
+
+		pdev = acpi_platform_device_find_by_companion(adev);
+		if (!pdev)
+			break;
+
+		platform_device_unregister(pdev);
+		put_device(&pdev->dev);
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block acpi_platform_notifier = {
+	.notifier_call = acpi_platform_device_remove_notify,
+};
+
 static void acpi_platform_fill_resource(struct acpi_device *adev,
 	const struct resource *src, struct resource *dest)
 {
@@ -130,3 +168,8 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev,
 	return pdev;
 }
 EXPORT_SYMBOL_GPL(acpi_create_platform_device);
+
+void __init acpi_platform_init(void)
+{
+	acpi_reconfig_notifier_register(&acpi_platform_notifier);
+}

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 1f32caa87686..00ec4f2bf015 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * ACPI support for platform bus type.
  *
@@ -5,10 +6,6 @@
  * Authors: Mika Westerberg <mika.westerberg@linux.intel.com>
  *          Mathias Nyman <mathias.nyman@linux.intel.com>
  *          Rafael J. Wysocki <rafael.j.wysocki@intel.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/acpi.h>

commit 2bbb5fa37475d7aa5fa62f34db1623f3da2dfdfa
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Nov 19 19:06:01 2018 +0100

    ACPI / platform: Add SMB0001 HID to forbidden_id_list
    
    Many HP AMD based laptops contain an SMB0001 device like this:
    
    Device (SMBD)
    {
        Name (_HID, "SMB0001")  // _HID: Hardware ID
        Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
        {
            IO (Decode16,
                0x0B20,             // Range Minimum
                0x0B20,             // Range Maximum
                0x20,               // Alignment
                0x20,               // Length
                )
            IRQ (Level, ActiveLow, Shared, )
                {7}
        })
    }
    
    The legacy style IRQ resource here causes acpi_dev_get_irqresource() to
    be called with legacy=true and this message to show in dmesg:
    ACPI: IRQ 7 override to edge, high
    
    This causes issues when later on the AMD0030 GPIO device gets enumerated:
    
    Device (GPIO)
    {
        Name (_HID, "AMDI0030")  // _HID: Hardware ID
        Name (_CID, "AMDI0030")  // _CID: Compatible ID
        Name (_UID, Zero)  // _UID: Unique ID
        Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
        {
            Name (RBUF, ResourceTemplate ()
            {
                Interrupt (ResourceConsumer, Level, ActiveLow, Shared, ,, )
                {
                    0x00000007,
                }
                Memory32Fixed (ReadWrite,
                    0xFED81500,         // Address Base
                    0x00000400,         // Address Length
                    )
            })
            Return (RBUF) /* \_SB_.GPIO._CRS.RBUF */
        }
    }
    
    Now acpi_dev_get_irqresource() gets called with legacy=false, but because
    of the earlier override of the trigger-type acpi_register_gsi() returns
    -EBUSY (because we try to register the same interrupt with a different
    trigger-type) and we end up setting IORESOURCE_DISABLED in the flags.
    
    The setting of IORESOURCE_DISABLED causes platform_get_irq() to call
    acpi_irq_get() which is not implemented on x86 and returns -EINVAL.
    resulting in the following in dmesg:
    
    amd_gpio AMDI0030:00: Failed to get gpio IRQ: -22
    amd_gpio: probe of AMDI0030:00 failed with error -22
    
    The SMB0001 is a "virtual" device in the sense that the only way the OS
    interacts with it is through calling a couple of methods to do SMBus
    transfers. As such it is weird that it has IO and IRQ resources at all,
    because the driver for it is not expected to ever access the hardware
    directly.
    
    The Linux driver for the SMB0001 device directly binds to the acpi_device
    through the acpi_bus, so we do not need to instantiate a platform_device
    for this ACPI device. This commit adds the SMB0001 HID to the
    forbidden_id_list, avoiding the instantiating of a platform_device for it.
    Not instantiating a platform_device means we will no longer call
    acpi_dev_get_irqresource() for the legacy IRQ resource fixing the probe of
    the AMDI0030 device failing.
    
    BugLink: https://bugzilla.redhat.com/show_bug.cgi?id=1644013
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=198715
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=199523
    Reported-by: Lukas Kahnert <openproggerfreak@gmail.com>
    Tested-by: Marc <suaefar@googlemail.com>
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index eaa60c94205a..1f32caa87686 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -30,6 +30,7 @@ static const struct acpi_device_id forbidden_id_list[] = {
 	{"PNP0200",  0},	/* AT DMA Controller */
 	{"ACPI0009", 0},	/* IOxAPIC */
 	{"ACPI000A", 0},	/* IOAPIC */
+	{"SMB0001",  0},	/* ACPI SMBUS virtual device */
 	{"", 0},
 };
 

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 88cd949003f3..eaa60c94205a 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -82,7 +82,7 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev,
 	if (count < 0) {
 		return NULL;
 	} else if (count > 0) {
-		resources = kzalloc(count * sizeof(struct resource),
+		resources = kcalloc(count, sizeof(struct resource),
 				    GFP_KERNEL);
 		if (!resources) {
 			dev_err(&adev->dev, "No memory for resources\n");

commit 79f97c3051e16b117b47e0586a368c4f54a82909
Author: Shanker Donthineni <shankerd@codeaurora.org>
Date:   Wed Mar 29 06:39:19 2017 -0500

    ACPI / platform: Update platform device NUMA node based on _PXM method
    
    The optional _PXM method evaluates to an integer that identifies the
    proximity domain of a device object. On ACPI based kernel boot, the
    field numa_node in 'struct device' is always set to -1 irrespective
    of _PXM value that is specified in the ACPI device object. But in
    case of device-tree based kernel boot the numa_node field is populated
    and reflects to a DT property that is specified in DTS according to
    the below document.
    
    https://www.kernel.org/doc/Documentation/devicetree/bindings/numa.txt
    http://lxr.free-electrons.com/source/drivers/of/device.c#L54
    
    Without this patch dev_to_node() always returns -1 for all platform
    devices. This patch adds support for the ACPI _PXM method and updates
    the platform device NUMA node id using acpi_get_node() which provides
    the PXM-to-NUMA mapping information.
    
    The individual platform device drivers should be able to use the
    NUMA-aware memory allocation functions kmalloc_node() and
    alloc_pages_node() to improve performance.
    
    Signed-off-by: Shanker Donthineni <shankerd@codeaurora.org>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Jiandi An <anjiandi@codeaurora.org>
    [ rjw: Subject / changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 03250e1f1103..88cd949003f3 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -121,11 +121,14 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev,
 	if (IS_ERR(pdev))
 		dev_err(&adev->dev, "platform device creation failed: %ld\n",
 			PTR_ERR(pdev));
-	else
+	else {
+		set_dev_node(&pdev->dev, acpi_get_node(adev->handle));
 		dev_dbg(&adev->dev, "created platform device %s\n",
 			dev_name(&pdev->dev));
+	}
 
 	kfree(resources);
+
 	return pdev;
 }
 EXPORT_SYMBOL_GPL(acpi_create_platform_device);

commit 08f63d97749185fab942a3a47ed80f5bd89b8b7d
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Mar 22 18:33:25 2017 +0100

    ACPI: Do not create a platform_device for IOAPIC/IOxAPIC
    
    No platform-device is required for IO(x)APICs, so don't even
    create them.
    
    [ rjw: This fixes a problem with leaking platform device objects
      after IOAPIC/IOxAPIC hot-removal events.]
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index b4c1a6a51da4..03250e1f1103 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -25,9 +25,11 @@
 ACPI_MODULE_NAME("platform");
 
 static const struct acpi_device_id forbidden_id_list[] = {
-	{"PNP0000", 0},	/* PIC */
-	{"PNP0100", 0},	/* Timer */
-	{"PNP0200", 0},	/* AT DMA Controller */
+	{"PNP0000",  0},	/* PIC */
+	{"PNP0100",  0},	/* Timer */
+	{"PNP0200",  0},	/* AT DMA Controller */
+	{"ACPI0009", 0},	/* IOxAPIC */
+	{"ACPI000A", 0},	/* IOAPIC */
 	{"", 0},
 };
 

commit 66f5854c6894dc028fc13345838c6f82bfcfef0c
Merge: bc33b0ca11e3 1571875beecd
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 11 23:23:02 2016 +0100

    Merge branch 'device-properties'
    
    * device-properties:
      ACPI / platform: Add support for build-in properties

commit 1571875beecd5de9657f73931449bda1b1329b6f
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Thu Nov 3 16:21:26 2016 +0200

    ACPI / platform: Add support for build-in properties
    
    We have a couple of drivers, acpi_apd.c and acpi_lpss.c,
    that need to pass extra build-in properties to the devices
    they create. Previously the drivers added those properties
    to the struct device which is member of the struct
    acpi_device, but that does not work. Those properties need
    to be assigned to the struct device of the platform device
    instead in order for them to become available to the
    drivers.
    
    To fix this, this patch changes acpi_create_platform_device
    function to take struct property_entry pointer as parameter.
    
    Fixes: 20a875e2e86e (serial: 8250_dw: Add quirk for APM X-Gene SoC)
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Tested-by: Yazen Ghannam <yazen.ghannam@amd.com>
    Tested-by: JÃ©rÃ´me de Bretagne <jerome.debretagne@gmail.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 159f7f19abce..56e70da83c6c 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -33,6 +33,7 @@ static const struct acpi_device_id forbidden_id_list[] = {
 /**
  * acpi_create_platform_device - Create platform device for ACPI device node
  * @adev: ACPI device node to create a platform device for.
+ * @properties: Optional collection of build-in properties.
  *
  * Check if the given @adev can be represented as a platform device and, if
  * that's the case, create and register a platform device, populate its common
@@ -40,7 +41,8 @@ static const struct acpi_device_id forbidden_id_list[] = {
  *
  * Name of the platform device will be the same as @adev's.
  */
-struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
+struct platform_device *acpi_create_platform_device(struct acpi_device *adev,
+					struct property_entry *properties)
 {
 	struct platform_device *pdev = NULL;
 	struct platform_device_info pdevinfo;
@@ -88,6 +90,7 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 	pdevinfo.res = resources;
 	pdevinfo.num_res = count;
 	pdevinfo.fwnode = acpi_fwnode_handle(adev);
+	pdevinfo.properties = properties;
 
 	if (acpi_dma_supported(adev))
 		pdevinfo.dma_mask = DMA_BIT_MASK(32);

commit a252d881c5585f5a25d4beeca23806b4fea116eb
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Sep 15 11:07:04 2016 +0300

    ACPI / platform: Pay attention to parent device's resources
    
    Given following simplified device hierarchy:
    
      // PCI device having BAR0 (RMEM) split between 4 GPIO devices.
      Device (P2S)
      {
          Name (_ADR, 0x000d0000)
    
          Device (GPO0)
          {
              Name (_HID, "INT3452")
              Name (_UID, 1)
              Name (_CRS, ResourceTemplate () {
                  Memory32Fixed (ReadWrite, 0, 0x4000, RMEM + 0x0000)
              })
          }
    
          Device (GPO1)
          {
              Name (_HID, "INT3452")
              Name (_UID, 2)
              Name (_CRS, ResourceTemplate () {
                  Memory32Fixed (ReadWrite, 0, 0x4000, RMEM + 0x4000)
              })
          }
    
          Device (GPO2)
          {
              Name (_HID, "INT3452")
              Name (_UID, 3)
              Name (_CRS, ResourceTemplate () {
                  Memory32Fixed (ReadWrite, 0, 0x4000, RMEM + 0x8000)
              })
          }
    
          Device (GPO3)
          {
              Name (_HID, "INT3452")
              Name (_UID, 4)
              Name (_CRS, ResourceTemplate () {
                  Memory32Fixed (ReadWrite, 0, 0x4000, RMEM + 0xc000)
              })
          }
      }
    
    The current ACPI platform enumeration code allocates resources from the
    global MMIO resource pool (/proc/iomem) for all the four GPIO devices.
    After this PCI core calls pcibios_resource_survey() to allocate resources
    for all PCI devices including the parent device for these GPIO devices
    (P2S). Since that resource range has already been reserved the allocation
    fails.
    
    The reason for this is that we never bother with parent device's resources
    when ACPI platform devices are created.
    
    Fix this by checking whether there is a parent device and in that case make
    sure we assign correct parent resource to the resources for the child ACPI
    platform device. Currently we only deal with parent devices if they are PCI
    devices but we may expand this later to cover other bus types as well.
    
    Reported-by: Aaron Durbin <adurbin@google.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 159f7f19abce..b200ae1f3c6f 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -17,6 +17,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/dma-mapping.h>
+#include <linux/pci.h>
 #include <linux/platform_device.h>
 
 #include "internal.h"
@@ -30,6 +31,22 @@ static const struct acpi_device_id forbidden_id_list[] = {
 	{"", 0},
 };
 
+static void acpi_platform_fill_resource(struct acpi_device *adev,
+	const struct resource *src, struct resource *dest)
+{
+	struct device *parent;
+
+	*dest = *src;
+
+	/*
+	 * If the device has parent we need to take its resources into
+	 * account as well because this device might consume part of those.
+	 */
+	parent = acpi_get_first_physical_node(adev->parent);
+	if (parent && dev_is_pci(parent))
+		dest->parent = pci_find_resource(to_pci_dev(parent), dest);
+}
+
 /**
  * acpi_create_platform_device - Create platform device for ACPI device node
  * @adev: ACPI device node to create a platform device for.
@@ -70,7 +87,8 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 		}
 		count = 0;
 		list_for_each_entry(rentry, &resource_list, node)
-			resources[count++] = *rentry->res;
+			acpi_platform_fill_resource(adev, rentry->res,
+						    &resources[count++]);
 
 		acpi_dev_free_resource_list(&resource_list);
 	}

commit 277edbabf6fece057b14fb6db5e3a34e00f42f42
Merge: 271ecc5253e2 0d571b62dd8e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 16 14:10:53 2016 -0700

    Merge tag 'pm+acpi-4.6-rc1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "This time the majority of changes go into cpufreq and they are
      significant.
    
      First off, the way CPU frequency updates are triggered is different
      now.  Instead of having to set up and manage a deferrable timer for
      each CPU in the system to evaluate and possibly change its frequency
      periodically, cpufreq governors set up callbacks to be invoked by the
      scheduler on a regular basis (basically on utilization updates).  The
      "old" governors, "ondemand" and "conservative", still do all of their
      work in process context (although that is triggered by the scheduler
      now), but intel_pstate does it all in the callback invoked by the
      scheduler with no need for any additional asynchronous processing.
    
      Of course, this eliminates the overhead related to the management of
      all those timers, but also it allows the cpufreq governor code to be
      simplified quite a bit.  On top of that, the common code and data
      structures used by the "ondemand" and "conservative" governors are
      cleaned up and made more straightforward and some long-standing and
      quite annoying problems are addressed.  In particular, the handling of
      governor sysfs attributes is modified and the related locking becomes
      more fine grained which allows some concurrency problems to be avoided
      (particularly deadlocks with the core cpufreq code).
    
      In principle, the new mechanism for triggering frequency updates
      allows utilization information to be passed from the scheduler to
      cpufreq.  Although the current code doesn't make use of it, in the
      works is a new cpufreq governor that will make decisions based on the
      scheduler's utilization data.  That should allow the scheduler and
      cpufreq to work more closely together in the long run.
    
      In addition to the core and governor changes, cpufreq drivers are
      updated too.  Fixes and optimizations go into intel_pstate, the
      cpufreq-dt driver is updated on top of some modification in the
      Operating Performance Points (OPP) framework and there are fixes and
      other updates in the powernv cpufreq driver.
    
      Apart from the cpufreq updates there is some new ACPICA material,
      including a fix for a problem introduced by previous ACPICA updates,
      and some less significant changes in the ACPI code, like CPPC code
      optimizations, ACPI processor driver cleanups and support for loading
      ACPI tables from initrd.
    
      Also updated are the generic power domains framework, the Intel RAPL
      power capping driver and the turbostat utility and we have a bunch of
      traditional assorted fixes and cleanups.
    
      Specifics:
    
       - Redesign of cpufreq governors and the intel_pstate driver to make
         them use callbacks invoked by the scheduler to trigger CPU
         frequency evaluation instead of using per-CPU deferrable timers for
         that purpose (Rafael Wysocki).
    
       - Reorganization and cleanup of cpufreq governor code to make it more
         straightforward and fix some concurrency problems in it (Rafael
         Wysocki, Viresh Kumar).
    
       - Cleanup and improvements of locking in the cpufreq core (Viresh
         Kumar).
    
       - Assorted cleanups in the cpufreq core (Rafael Wysocki, Viresh
         Kumar, Eric Biggers).
    
       - intel_pstate driver updates including fixes, optimizations and a
         modification to make it enable enable hardware-coordinated P-state
         selection (HWP) by default if supported by the processor (Philippe
         Longepe, Srinivas Pandruvada, Rafael Wysocki, Viresh Kumar, Felipe
         Franciosi).
    
       - Operating Performance Points (OPP) framework updates to improve its
         handling of voltage regulators and device clocks and updates of the
         cpufreq-dt driver on top of that (Viresh Kumar, Jon Hunter).
    
       - Updates of the powernv cpufreq driver to fix initialization and
         cleanup problems in it and correct its worker thread handling with
         respect to CPU offline, new powernv_throttle tracepoint (Shilpasri
         Bhat).
    
       - ACPI cpufreq driver optimization and cleanup (Rafael Wysocki).
    
       - ACPICA updates including one fix for a regression introduced by
         previos changes in the ACPICA code (Bob Moore, Lv Zheng, David Box,
         Colin Ian King).
    
       - Support for installing ACPI tables from initrd (Lv Zheng).
    
       - Optimizations of the ACPI CPPC code (Prashanth Prakash, Ashwin
         Chaugule).
    
       - Support for _HID(ACPI0010) devices (ACPI processor containers) and
         ACPI processor driver cleanups (Sudeep Holla).
    
       - Support for ACPI-based enumeration of the AMBA bus (Graeme Gregory,
         Aleksey Makarov).
    
       - Modification of the ACPI PCI IRQ management code to make it treat
         255 in the Interrupt Line register as "not connected" on x86 (as
         per the specification) and avoid attempts to use that value as a
         valid interrupt vector (Chen Fan).
    
       - ACPI APEI fixes related to resource leaks (Josh Hunt).
    
       - Removal of modularity from a few ACPI drivers (BGRT, GHES,
         intel_pmic_crc) that cannot be built as modules in practice (Paul
         Gortmaker).
    
       - PNP framework update to make it treat ACPI_RESOURCE_TYPE_SERIAL_BUS
         as a valid resource type (Harb Abdulhamid).
    
       - New device ID (future AMD I2C controller) in the ACPI driver for
         AMD SoCs (APD) and in the designware I2C driver (Xiangliang Yu).
    
       - Assorted ACPI cleanups (Colin Ian King, Kaiyen Chang, Oleg Drokin).
    
       - cpuidle menu governor optimization to avoid a square root
         computation in it (Rasmus Villemoes).
    
       - Fix for potential use-after-free in the generic device properties
         framework (Heikki Krogerus).
    
       - Updates of the generic power domains (genpd) framework including
         support for multiple power states of a domain, fixes and debugfs
         output improvements (Axel Haslam, Jon Hunter, Laurent Pinchart,
         Geert Uytterhoeven).
    
       - Intel RAPL power capping driver updates to reduce IPI overhead in
         it (Jacob Pan).
    
       - System suspend/hibernation code cleanups (Eric Biggers, Saurabh
         Sengar).
    
       - Year 2038 fix for the process freezer (Abhilash Jindal).
    
       - turbostat utility updates including new features (decoding of more
         registers and CPUID fields, sub-second intervals support, GFX MHz
         and RC6 printout, --out command line option), fixes (syscall jitter
         detection and workaround, reductioin of the number of syscalls
         made, fixes related to Xeon x200 processors, compiler warning
         fixes) and cleanups (Len Brown, Hubert Chrzaniuk, Chen Yu)"
    
    * tag 'pm+acpi-4.6-rc1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (182 commits)
      tools/power turbostat: bugfix: TDP MSRs print bits fixing
      tools/power turbostat: correct output for MSR_NHM_SNB_PKG_CST_CFG_CTL dump
      tools/power turbostat: call __cpuid() instead of __get_cpuid()
      tools/power turbostat: indicate SMX and SGX support
      tools/power turbostat: detect and work around syscall jitter
      tools/power turbostat: show GFX%rc6
      tools/power turbostat: show GFXMHz
      tools/power turbostat: show IRQs per CPU
      tools/power turbostat: make fewer systems calls
      tools/power turbostat: fix compiler warnings
      tools/power turbostat: add --out option for saving output in a file
      tools/power turbostat: re-name "%Busy" field to "Busy%"
      tools/power turbostat: Intel Xeon x200: fix turbo-ratio decoding
      tools/power turbostat: Intel Xeon x200: fix erroneous bclk value
      tools/power turbostat: allow sub-sec intervals
      ACPI / APEI: ERST: Fixed leaked resources in erst_init
      ACPI / APEI: Fix leaked resources
      intel_pstate: Do not skip samples partially
      intel_pstate: Remove freq calculation from intel_pstate_calc_busy()
      intel_pstate: Move intel_pstate_calc_busy() into get_target_pstate_use_performance()
      ...

commit 3b95bd160547f56a68aeb972c33ae9511e7a8380
Author: Aleksey Makarov <aleksey.makarov@linaro.org>
Date:   Tue Feb 16 15:52:38 2016 +0300

    ACPI: introduce a function to find the first physical device
    
    Factor out the code that finds the first physical device
    of a given ACPI device.  It is used in several places.
    
    Signed-off-by: Aleksey Makarov <aleksey.makarov@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 296b7a14893a..c3af1088bf6b 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -43,7 +43,6 @@ static const struct acpi_device_id forbidden_id_list[] = {
 struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 {
 	struct platform_device *pdev = NULL;
-	struct acpi_device *acpi_parent;
 	struct platform_device_info pdevinfo;
 	struct resource_entry *rentry;
 	struct list_head resource_list;
@@ -82,22 +81,8 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 	 * attached to it, that physical device should be the parent of the
 	 * platform device we are about to create.
 	 */
-	pdevinfo.parent = NULL;
-	acpi_parent = adev->parent;
-	if (acpi_parent) {
-		struct acpi_device_physical_node *entry;
-		struct list_head *list;
-
-		mutex_lock(&acpi_parent->physical_node_lock);
-		list = &acpi_parent->physical_node_list;
-		if (!list_empty(list)) {
-			entry = list_first_entry(list,
-					struct acpi_device_physical_node,
-					node);
-			pdevinfo.parent = entry->dev;
-		}
-		mutex_unlock(&acpi_parent->physical_node_lock);
-	}
+	pdevinfo.parent = adev->parent ?
+		acpi_get_first_physical_node(adev->parent) : NULL;
 	pdevinfo.name = dev_name(&adev->dev);
 	pdevinfo.id = -1;
 	pdevinfo.res = resources;

commit 9a975bee4b3945b271bcff18a520d4863c210f8b
Author: Toshi Kani <toshi.kani@hpe.com>
Date:   Tue Jan 26 21:57:25 2016 +0100

    drivers: Initialize resource entry to zero
    
    I/O resource descriptor, 'desc' in struct resource, needs to be
    initialized to zero by default.  Some drivers call kmalloc() to
    allocate a resource entry, but do not initialize it to zero by
    memset().  Change these drivers to call kzalloc(), instead.
    
    Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Alexandre Bounine <alexandre.bounine@idt.com>
    Acked-by: Helge Deller <deller@gmx.de>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-arch@vger.kernel.org
    Cc: linux-mm <linux-mm@kvack.org>
    Cc: linux-parisc@vger.kernel.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-sh@vger.kernel.org
    Link: http://lkml.kernel.org/r/1453841853-11383-10-git-send-email-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 296b7a14893a..b6f7fa3a1d40 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -62,7 +62,7 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 	if (count < 0) {
 		return NULL;
 	} else if (count > 0) {
-		resources = kmalloc(count * sizeof(struct resource),
+		resources = kzalloc(count * sizeof(struct resource),
 				    GFP_KERNEL);
 		if (!resources) {
 			dev_err(&adev->dev, "No memory for resources\n");

commit 1831eff876bd0bb8d64e9965a7ff47486c9a3ecd
Author: Suthikulpanit, Suravee <Suravee.Suthikulpanit@amd.com>
Date:   Wed Oct 28 15:50:50 2015 -0700

    device property: ACPI: Make use of the new DMA Attribute APIs
    
    Now that we have the new DMA attribute APIs, we can replace the older
    acpi_check_dma() and device_dma_is_coherent().
    
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 06a67d5f2846..296b7a14893a 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -103,7 +103,12 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 	pdevinfo.res = resources;
 	pdevinfo.num_res = count;
 	pdevinfo.fwnode = acpi_fwnode_handle(adev);
-	pdevinfo.dma_mask = acpi_check_dma(adev, NULL) ? DMA_BIT_MASK(32) : 0;
+
+	if (acpi_dma_supported(adev))
+		pdevinfo.dma_mask = DMA_BIT_MASK(32);
+	else
+		pdevinfo.dma_mask = 0;
+
 	pdev = platform_device_register_full(&pdevinfo);
 	if (IS_ERR(pdev))
 		dev_err(&adev->dev, "platform device creation failed: %ld\n",

commit d0562674838c08ff142c0e9a8e12634e133c4361
Author: Suthikulpanit, Suravee <Suravee.Suthikulpanit@amd.com>
Date:   Wed Jun 10 11:08:52 2015 -0500

    ACPI / scan: Parse _CCA and setup device coherency
    
    This patch implements support for ACPI _CCA object, which is introduced in
    ACPIv5.1, can be used for specifying device DMA coherency attribute.
    
    The parsing logic traverses device namespace to parse coherency
    information, and stores it in acpi_device_flags. Then uses it to call
    arch_setup_dma_ops() when creating each device enumerated in DSDT
    during ACPI scan.
    
    This patch also introduces acpi_dma_is_coherent(), which provides
    an interface for device drivers to check the coherency information
    similarly to the of_dma_is_coherent().
    
    Signed-off-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 4bf75597f732..06a67d5f2846 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -103,7 +103,7 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 	pdevinfo.res = resources;
 	pdevinfo.num_res = count;
 	pdevinfo.fwnode = acpi_fwnode_handle(adev);
-	pdevinfo.dma_mask = DMA_BIT_MASK(32);
+	pdevinfo.dma_mask = acpi_check_dma(adev, NULL) ? DMA_BIT_MASK(32) : 0;
 	pdev = platform_device_register_full(&pdevinfo);
 	if (IS_ERR(pdev))
 		dev_err(&adev->dev, "platform device creation failed: %ld\n",

commit ce793486e23e0162a732c605189c8028e0910e86
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 16 23:49:03 2015 +0100

    driver core / ACPI: Represent ACPI companions using fwnode_handle
    
    Now that we have struct fwnode_handle, we can use that to point to
    ACPI companions from struct device objects instead of pointing to
    struct acpi_device directly.
    
    There are two benefits from that.  First, the somewhat ugly and
    hackish struct acpi_dev_node can be dropped and, second, the same
    struct fwnode_handle pointer can be used in the future to point
    to other (non-ACPI) firmware device node types.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 1284138e42ab..4bf75597f732 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -102,7 +102,7 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 	pdevinfo.id = -1;
 	pdevinfo.res = resources;
 	pdevinfo.num_res = count;
-	pdevinfo.acpi_node.companion = adev;
+	pdevinfo.fwnode = acpi_fwnode_handle(adev);
 	pdevinfo.dma_mask = DMA_BIT_MASK(32);
 	pdev = platform_device_register_full(&pdevinfo);
 	if (IS_ERR(pdev))

commit 90e97820619dc912b52cc9d103272819d8b51259
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Feb 5 13:44:43 2015 +0800

    resources: Move struct resource_list_entry from ACPI into resource core
    
    Currently ACPI, PCI and pnp all implement the same resource list
    management with different data structure. We need to transfer from
    one data structure into another when passing resources from one
    subsystem into another subsystem. So move struct resource_list_entry
    from ACPI into resource core and rename it as resource_entry,
    then it could be reused by different subystems and avoid the data
    structure conversion.
    
    Introduce dedicated header file resource_ext.h instead of embedding
    it into ioport.h to avoid header file inclusion order issues.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 6ba8beb6b9d2..1284138e42ab 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -45,7 +45,7 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 	struct platform_device *pdev = NULL;
 	struct acpi_device *acpi_parent;
 	struct platform_device_info pdevinfo;
-	struct resource_list_entry *rentry;
+	struct resource_entry *rentry;
 	struct list_head resource_list;
 	struct resource *resources = NULL;
 	int count;
@@ -71,7 +71,7 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 		}
 		count = 0;
 		list_for_each_entry(rentry, &resource_list, node)
-			resources[count++] = rentry->res;
+			resources[count++] = *rentry->res;
 
 		acpi_dev_free_resource_list(&resource_list);
 	}

commit 1c45d9a920e6ef4fce38921e4fc776c2abca3197
Merge: 8264fce6de03 a91e99e27a68
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 24 11:29:31 2014 -0700

    Merge tag 'pm+acpi-3.18-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "This is material that didn't make it to my 3.18-rc1 pull request for
      various reasons, mostly related to timing and travel (LinuxCon EU /
      LPC) plus a couple of fixes for recent bugs.
    
      The only really new thing here is the PM QoS class for memory
      bandwidth, but it is simple enough and users of it will be added in
      the next cycle.  One major change in behavior is that platform devices
      enumerated by ACPI will use 32-bit DMA mask by default.  Also included
      is an ACPICA update to a new upstream release, but that's mostly
      cleanups, changes in tools and similar.  The rest is fixes and
      cleanups mostly.
    
      Specifics:
    
       - Fix for a recent PCI power management change that overlooked the
         fact that some IRQ chips might not be able to configure PCIe PME
         for system wakeup from Lucas Stach.
    
       - Fix for a bug introduced in 3.17 where acpi_device_wakeup() is
         called with a wrong ordering of arguments from Zhang Rui.
    
       - A bunch of intel_pstate driver fixes (all -stable candidates) from
         Dirk Brandewie, Gabriele Mazzotta and Pali RohÃ¡r.
    
       - Fixes for a rather long-standing problem with the OOM killer and
         the freezer that frozen processes killed by the OOM do not actually
         release any memory until they are thawed, so OOM-killing them is
         rather pointless, with a couple of cleanups on top (Michal Hocko,
         Cong Wang, Rafael J Wysocki).
    
       - ACPICA update to upstream release 20140926, inlcuding mostly
         cleanups reducing differences between the upstream ACPICA and the
         kernel code, tools changes (acpidump, acpiexec) and support for the
         _DDN object (Bob Moore, Lv Zheng).
    
       - New PM QoS class for memory bandwidth from Tomeu Vizoso.
    
       - Default 32-bit DMA mask for platform devices enumerated by ACPI
         (this change is mostly needed for some drivers development in
         progress targeted at 3.19) from Heikki Krogerus.
    
       - ACPI EC driver cleanups, mostly related to debugging, from Lv
         Zheng.
    
       - cpufreq-dt driver updates from Thomas Petazzoni.
    
       - powernv cpuidle driver update from Preeti U Murthy"
    
    * tag 'pm+acpi-3.18-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (34 commits)
      intel_pstate: Correct BYT VID values.
      intel_pstate: Fix BYT frequency reporting
      intel_pstate: Don't lose sysfs settings during cpu offline
      cpufreq: intel_pstate: Reflect current no_turbo state correctly
      cpufreq: expose scaling_cur_freq sysfs file for set_policy() drivers
      cpufreq: intel_pstate: Fix setting max_perf_pct in performance policy
      PCI / PM: handle failure to enable wakeup on PCIe PME
      ACPI: invoke acpi_device_wakeup() with correct parameters
      PM / freezer: Clean up code after recent fixes
      PM: convert do_each_thread to for_each_process_thread
      OOM, PM: OOM killed task shouldn't escape PM suspend
      freezer: remove obsolete comments in __thaw_task()
      freezer: Do not freeze tasks killed by OOM killer
      ACPI / platform: provide default DMA mask
      cpuidle: powernv: Populate cpuidle state details by querying the device-tree
      cpufreq: cpufreq-dt: adjust message related to regulators
      cpufreq: cpufreq-dt: extend with platform_data
      cpufreq: allow driver-specific data
      ACPI / EC: Cleanup coding style.
      ACPI / EC: Refine event/query debugging messages.
      ...

commit 8a2f38ddfeb526c30b3ec209468172a30a38d996
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Wed Sep 24 11:00:37 2014 +0300

    ACPI / platform: provide default DMA mask
    
    Most devices are configured for 32-bit DMA addresses.
    Setting the mask to 32-bit here removes the need for the
    drivers to do it separately.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 2bf9082f7523..8d099e636b15 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -16,6 +16,7 @@
 #include <linux/err.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/dma-mapping.h>
 #include <linux/platform_device.h>
 
 #include "internal.h"
@@ -102,6 +103,7 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 	pdevinfo.res = resources;
 	pdevinfo.num_res = count;
 	pdevinfo.acpi_node.companion = adev;
+	pdevinfo.dma_mask = DMA_BIT_MASK(32);
 	pdev = platform_device_register_full(&pdevinfo);
 	if (IS_ERR(pdev))
 		dev_err(&adev->dev, "platform device creation failed: %ld\n",

commit 083bf668cb70e47b84db64856606e94beac87f01
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri Mar 14 14:06:25 2014 +0800

    ACPI: make acpi_create_platform_device() an external API
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 2bf9082f7523..a3c89a1bcf54 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -113,3 +113,4 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 	kfree(resources);
 	return pdev;
 }
+EXPORT_SYMBOL_GPL(acpi_create_platform_device);

commit 48459340b92b00ae1a75179f168ef20d3e61f264
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Fri May 30 14:35:34 2014 +0200

    ACPI / scan: use platform bus type by default for _HID enumeration
    
    Because of the growing demand for enumerating ACPI devices to
    platform bus, change the code to enumerate ACPI device objects to
    platform bus by default.  Namely, create platform devices for the
    ACPI device objects that
     1. Have pnp.type.platform_id set (device objects with _HID currently).
     2. Do not have a scan handler attached.
     3. Are not SPI/I2C slave devices (that should be enumerated to the
        appropriate buses bus by their parent).
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    [rjw: Subject and changelog, rebase and code cleanup]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 3bb89def2292..2bf9082f7523 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -22,25 +22,11 @@
 
 ACPI_MODULE_NAME("platform");
 
-/*
- * The following ACPI IDs are known to be suitable for representing as
- * platform devices.
- */
-static const struct acpi_device_id acpi_platform_device_ids[] = {
-
-	{ "PNP0D40" },
-	{ "VPC2004" },
-	{ "BCM4752" },
-	{ "LNV4752" },
-	{ "BCM2E1A" },
-	{ "BCM2E39" },
-	{ "BCM2E3D" },
-
-	/* Intel Smart Sound Technology */
-	{ "INT33C8" },
-	{ "80860F28" },
-
-	{ }
+static const struct acpi_device_id forbidden_id_list[] = {
+	{"PNP0000", 0},	/* PIC */
+	{"PNP0100", 0},	/* Timer */
+	{"PNP0200", 0},	/* AT DMA Controller */
+	{"", 0},
 };
 
 /**
@@ -67,6 +53,9 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 	if (adev->physical_node_count)
 		return NULL;
 
+	if (!acpi_match_device_ids(adev, forbidden_id_list))
+		return ERR_PTR(-EINVAL);
+
 	INIT_LIST_HEAD(&resource_list);
 	count = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);
 	if (count < 0) {
@@ -124,20 +113,3 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 	kfree(resources);
 	return pdev;
 }
-
-static int acpi_platform_attach(struct acpi_device *adev,
-				const struct acpi_device_id *id)
-{
-	acpi_create_platform_device(adev);
-	return 1;
-}
-
-static struct acpi_scan_handler platform_handler = {
-	.ids = acpi_platform_device_ids,
-	.attach = acpi_platform_attach,
-};
-
-void __init acpi_platform_init(void)
-{
-	acpi_scan_add_handler(&platform_handler);
-}

commit 52d1d0b12beaf98b6d144d7d1b24eb96cfea60f6
Merge: c7208164e66f 3022f4de491c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 30 15:55:19 2014 +0200

    Merge branch 'acpi-lpss' into acpi-enumeration

commit 8ce62f85a81f57e86bc120ab690facc612223188
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun May 25 14:38:52 2014 +0200

    ACPI / platform / LPSS: Enable async suspend/resume of LPSS devices
    
    To seed up suspend and resume of devices included into Intel SoCs
    handled by the ACPI LPSS driver during system suspend, make
    acpi_lpss_create_device() call device_enable_async_suspend() for
    every device created by it.
    
    This requires acpi_create_platform_device() to be modified to return
    a pointer to struct platform_device instead of an int.  As a result,
    acpi_create_platform_device() cannot be pointed to by the .attach
    pointer in platform_handler directly any more, so a simple wrapper
    around it is necessary for this purpose.  That, in turn, allows the
    second unused argument of acpi_create_platform_device() to be
    dropped, which is an improvement.
    
    Tested-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index c0a39417ebe4..9f7bcfdf18ef 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -47,7 +47,6 @@ static const struct acpi_device_id acpi_platform_device_ids[] = {
 /**
  * acpi_create_platform_device - Create platform device for ACPI device node
  * @adev: ACPI device node to create a platform device for.
- * @id: ACPI device ID used to match @adev.
  *
  * Check if the given @adev can be represented as a platform device and, if
  * that's the case, create and register a platform device, populate its common
@@ -55,8 +54,7 @@ static const struct acpi_device_id acpi_platform_device_ids[] = {
  *
  * Name of the platform device will be the same as @adev's.
  */
-int acpi_create_platform_device(struct acpi_device *adev,
-				const struct acpi_device_id *id)
+struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 {
 	struct platform_device *pdev = NULL;
 	struct acpi_device *acpi_parent;
@@ -68,19 +66,19 @@ int acpi_create_platform_device(struct acpi_device *adev,
 
 	/* If the ACPI node already has a physical device attached, skip it. */
 	if (adev->physical_node_count)
-		return 0;
+		return NULL;
 
 	INIT_LIST_HEAD(&resource_list);
 	count = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);
 	if (count < 0) {
-		return 0;
+		return NULL;
 	} else if (count > 0) {
 		resources = kmalloc(count * sizeof(struct resource),
 				    GFP_KERNEL);
 		if (!resources) {
 			dev_err(&adev->dev, "No memory for resources\n");
 			acpi_dev_free_resource_list(&resource_list);
-			return -ENOMEM;
+			return ERR_PTR(-ENOMEM);
 		}
 		count = 0;
 		list_for_each_entry(rentry, &resource_list, node)
@@ -117,22 +115,27 @@ int acpi_create_platform_device(struct acpi_device *adev,
 	pdevinfo.num_res = count;
 	pdevinfo.acpi_node.companion = adev;
 	pdev = platform_device_register_full(&pdevinfo);
-	if (IS_ERR(pdev)) {
+	if (IS_ERR(pdev))
 		dev_err(&adev->dev, "platform device creation failed: %ld\n",
 			PTR_ERR(pdev));
-		pdev = NULL;
-	} else {
+	else
 		dev_dbg(&adev->dev, "created platform device %s\n",
 			dev_name(&pdev->dev));
-	}
 
 	kfree(resources);
+	return pdev;
+}
+
+static int acpi_platform_attach(struct acpi_device *adev,
+				const struct acpi_device_id *id)
+{
+	acpi_create_platform_device(adev);
 	return 1;
 }
 
 static struct acpi_scan_handler platform_handler = {
 	.ids = acpi_platform_device_ids,
-	.attach = acpi_create_platform_device,
+	.attach = acpi_platform_attach,
 };
 
 void __init acpi_platform_init(void)

commit a3cffce4fbafac072660648e028cc9e629b5b3c8
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Thu May 8 14:59:04 2014 +0300

    ACPI / platform: add IDs for Broadcom Bluetooth and GPS chips
    
    These IDs are used on Baytrail boards such as Lenovo Miix 2
    and Asus Transformer Book T100TA. On lenovo Miix 2 8",
    BCM4752 is called LNV4752. All the rest of the IDs are for
    Broadcom BCM43241 module with the ID referring to different
    revision number.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index dbfe49e5fd63..c0a39417ebe4 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -32,6 +32,10 @@ static const struct acpi_device_id acpi_platform_device_ids[] = {
 	{ "ACPI0003" },
 	{ "VPC2004" },
 	{ "BCM4752" },
+	{ "LNV4752" },
+	{ "BCM2E1A" },
+	{ "BCM2E39" },
+	{ "BCM2E3D" },
 
 	/* Intel Smart Sound Technology */
 	{ "INT33C8" },

commit 98012849e0cbf980326f8e34d571f4474866a88e
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue May 6 19:18:28 2014 -0700

    ACPI: Revert "ACPI / AC: convert ACPI ac driver to platform bus"
    
    Revert commit cc8ef5270734 (ACPI / AC: convert ACPI ac driver to
    platform bus) that is reported to break thermal management on
    MacBook Air 2013 with ArchLinux.
    
    Fixes: cc8ef5270734 (ACPI / AC: convert ACPI ac driver to platform bus)
    References: https://bugzilla.kernel.org/show_bug.cgi?id=71711
    Cc: Zhang Rui <rui.zhang@intel.com>
    Reported-and-tested-by: Manuel Krause <manuelkrause@netscape.net>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Cc: 3.13+ <stable@vger.kernel.org> # 3.13+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index dbfe49e5fd63..1d4950388fa1 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -29,7 +29,6 @@ ACPI_MODULE_NAME("platform");
 static const struct acpi_device_id acpi_platform_device_ids[] = {
 
 	{ "PNP0D40" },
-	{ "ACPI0003" },
 	{ "VPC2004" },
 	{ "BCM4752" },
 

commit 7b1998116bbb2f3e5dd6cb9a8ee6db479b0b50a9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 11 22:41:56 2013 +0100

    ACPI / driver core: Store an ACPI device pointer in struct acpi_dev_node
    
    Modify struct acpi_dev_node to contain a pointer to struct acpi_device
    associated with the given device object (that is, its ACPI companion
    device) instead of an ACPI handle corresponding to it.  Introduce two
    new macros for manipulating that pointer in a CONFIG_ACPI-safe way,
    ACPI_COMPANION() and ACPI_COMPANION_SET(), and rework the
    ACPI_HANDLE() macro to take the above changes into account.
    Drop the ACPI_HANDLE_SET() macro entirely and rework its users to
    use ACPI_COMPANION_SET() instead.  For some of them who used to
    pass the result of acpi_get_child() directly to ACPI_HANDLE_SET()
    introduce a helper routine acpi_preset_companion() doing an
    equivalent thing.
    
    The main motivation for doing this is that there are things
    represented by struct acpi_device objects that don't have valid
    ACPI handles (so called fixed ACPI hardware features, such as
    power and sleep buttons) and we would like to create platform
    device objects for them and "glue" them to their ACPI companions
    in the usual way (which currently is impossible due to the
    lack of valid ACPI handles).  However, there are more reasons
    why it may be useful.
    
    First, struct acpi_device pointers allow of much better type checking
    than void pointers which are ACPI handles, so it should be more
    difficult to write buggy code using modified struct acpi_dev_node
    and the new macros.  Second, the change should help to reduce (over
    time) the number of places in which the result of ACPI_HANDLE() is
    passed to acpi_bus_get_device() in order to obtain a pointer to the
    struct acpi_device associated with the given "physical" device,
    because now that pointer is returned by ACPI_COMPANION() directly.
    Finally, the change should make it easier to write generic code that
    will build both for CONFIG_ACPI set and unset without adding explicit
    compiler directives to it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com> # on Haswell
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com> # for ATA and SDIO part

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 8a4cfc7e71f0..dbfe49e5fd63 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -111,7 +111,7 @@ int acpi_create_platform_device(struct acpi_device *adev,
 	pdevinfo.id = -1;
 	pdevinfo.res = resources;
 	pdevinfo.num_res = count;
-	pdevinfo.acpi_node.handle = adev->handle;
+	pdevinfo.acpi_node.companion = adev;
 	pdev = platform_device_register_full(&pdevinfo);
 	if (IS_ERR(pdev)) {
 		dev_err(&adev->dev, "platform device creation failed: %ld\n",

commit 9208e3110bf0a6ba4ded56e374857d4b6609c911
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Wed Oct 16 13:15:14 2013 +0300

    ACPI / platform: add ACPI ID for a Broadcom GPS chip
    
    This adds ACPI ID for Broadcom GPS receiver BCM4752.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index aef79db906fe..8a4cfc7e71f0 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -31,6 +31,7 @@ static const struct acpi_device_id acpi_platform_device_ids[] = {
 	{ "PNP0D40" },
 	{ "ACPI0003" },
 	{ "VPC2004" },
+	{ "BCM4752" },
 
 	/* Intel Smart Sound Technology */
 	{ "INT33C8" },

commit c0ad8568c81979be9c115d22ff1c3580f5ecd0bb
Merge: e83dda062420 ab0fd674d6ce
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 16 17:04:41 2013 +0200

    Merge branch 'acpi-conversion' into acpi-assorted
    
    The following commits depend on the 'acpi-conversion' material.
    
    Conflicts:
            drivers/acpi/acpi_platform.c

commit e54968ca1eaa78749d7a7fc20227639a31dff629
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Mon Oct 7 17:12:21 2013 +0300

    ACPI / platform: Add ACPI IDs for Intel SST audio device
    
    This adds ACPI IDs for Intel Smart Sound Technology (SST) device found in
    Intel Haswell and BayTrail platforms.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 1bde12708f9e..ed0f06390245 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -30,6 +30,9 @@ static const struct acpi_device_id acpi_platform_device_ids[] = {
 
 	{ "PNP0D40" },
 
+	/* Intel Smart Sound Technology */
+	{ "INT33C8" },
+	{ "80860F28" },
 	{ }
 };
 

commit b5c37b798f2d29b9b2926e0abf008a13ce6c91fe
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Wed Sep 25 20:39:50 2013 +0800

    ideapad_laptop: convert ideapad device/driver to platform bus
    
    This patch does two things,
     1. enumerate the ideapad device node to platform bus.
     2. convert the current driver from ACPI bus to platform bus.
    
    Note, with this patch, the platform device node created by ACPI,
    with the name VPC2004:00, is used as the parent device of
    the input, backlight, rfkill sysfs class device.
    Plus the ideapad_platform private sysfs attributes,
    i.e. camera_power and fan_mode, are also moved to the new
    platform device node.
    
    The previous platform device node "ideapad" is removed.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    CC: Matthew Garrett <matthew.garrett@nebula.com>
    CC: Ike Panhc <ike.pan@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 6259bc28ef18..c20b02beec7c 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -30,7 +30,7 @@ static const struct acpi_device_id acpi_platform_device_ids[] = {
 
 	{ "PNP0D40" },
 	{ "ACPI0003" },
-
+	{ "VPC2004" },
 	{ }
 };
 

commit cc8ef52707341e67a12067d6ead991d56ea017ca
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Wed Sep 25 20:39:45 2013 +0800

    ACPI / AC: convert ACPI ac driver to platform bus
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 1bde12708f9e..6259bc28ef18 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -29,6 +29,7 @@ ACPI_MODULE_NAME("platform");
 static const struct acpi_device_id acpi_platform_device_ids[] = {
 
 	{ "PNP0D40" },
+	{ "ACPI0003" },
 
 	{ }
 };

commit d2fe7251a36012bc552a4c95246d486a8e284043
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 7 01:11:33 2013 +0200

    ACPI / scan: Drop unnecessary label from acpi_create_platform_device()
    
    The create_dev label in acpi_create_platform_device() is not
    necessary, because the if statement causing the jump to it to
    happen may be rearranged to avoid that jump.
    
    Rework the code accordingly (no functional changes should result
    drom that).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 32136b85196d..1bde12708f9e 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -61,25 +61,23 @@ int acpi_create_platform_device(struct acpi_device *adev,
 
 	INIT_LIST_HEAD(&resource_list);
 	count = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);
-	if (count < 0)
+	if (count < 0) {
 		return 0;
+	} else if (count > 0) {
+		resources = kmalloc(count * sizeof(struct resource),
+				    GFP_KERNEL);
+		if (!resources) {
+			dev_err(&adev->dev, "No memory for resources\n");
+			acpi_dev_free_resource_list(&resource_list);
+			return -ENOMEM;
+		}
+		count = 0;
+		list_for_each_entry(rentry, &resource_list, node)
+			resources[count++] = rentry->res;
 
-	if (!count)
-		goto create_dev;
-
-	resources = kmalloc(count * sizeof(struct resource), GFP_KERNEL);
-	if (!resources) {
-		dev_err(&adev->dev, "No memory for resources\n");
 		acpi_dev_free_resource_list(&resource_list);
-		return -ENOMEM;
 	}
-	count = 0;
-	list_for_each_entry(rentry, &resource_list, node)
-		resources[count++] = rentry->res;
-
-	acpi_dev_free_resource_list(&resource_list);
 
-create_dev:
 	memset(&pdevinfo, 0, sizeof(pdevinfo));
 	/*
 	 * If the ACPI node has a parent and that parent has a physical device

commit 62eb4b07f0803d0426eb695bfe6755dd6a2cafb2
Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date:   Mon Jul 22 16:51:20 2013 -0700

    ACPI / scan: Allow platform device creation without any IO resources
    
    Currently, ACPI platform device creation is aborted when there
    are no valid IO resources for the device.  This approach will not
    work if the device has only GPIO as its resource or some custom
    resources.
    
    Remove zero resource check and allow platform device creation even
    without any valid IO resources.
    
    [rjw: Changelog]
    Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index fafec5ddf17f..32136b85196d 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -52,7 +52,7 @@ int acpi_create_platform_device(struct acpi_device *adev,
 	struct platform_device_info pdevinfo;
 	struct resource_list_entry *rentry;
 	struct list_head resource_list;
-	struct resource *resources;
+	struct resource *resources = NULL;
 	int count;
 
 	/* If the ACPI node already has a physical device attached, skip it. */
@@ -61,9 +61,12 @@ int acpi_create_platform_device(struct acpi_device *adev,
 
 	INIT_LIST_HEAD(&resource_list);
 	count = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);
-	if (count <= 0)
+	if (count < 0)
 		return 0;
 
+	if (!count)
+		goto create_dev;
+
 	resources = kmalloc(count * sizeof(struct resource), GFP_KERNEL);
 	if (!resources) {
 		dev_err(&adev->dev, "No memory for resources\n");
@@ -76,6 +79,7 @@ int acpi_create_platform_device(struct acpi_device *adev,
 
 	acpi_dev_free_resource_list(&resource_list);
 
+create_dev:
 	memset(&pdevinfo, 0, sizeof(pdevinfo));
 	/*
 	 * If the ACPI node has a parent and that parent has a physical device

commit f58b082aed43400c03e53beacc50a9f9eb23ac91
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Mar 6 23:46:20 2013 +0100

    ACPI / scan: Add special handler for Intel Lynxpoint LPSS devices
    
    Devices on the Intel Lynxpoint Low Power Subsystem (LPSS) have some
    common features that aren't shared with any other platform devices,
    including the clock and LTR (Latency Tolerance Reporting) registers.
    It is better to handle those features in common code than to bother
    device drivers with doing that (I/O functionality-wise the LPSS
    devices are generally compatible with other devices that don't
    have those special registers and may be handled by the same drivers).
    
    The clock registers of the LPSS devices are now taken care of by
    the special clk-x86-lpss driver, but the MMIO mappings used for
    accessing those registers can also be used for accessing the LTR
    registers on those devices (LTR support for the Lynxpoint LPSS is
    going to be added by a subsequent patch).  Thus it is convenient
    to add a special ACPI scan handler for the Lynxpoint LPSS devices
    that will create the MMIO mappings for accessing the clock (and
    LTR in the future) registers and will register the LPSS devices'
    clocks, so the clk-x86-lpss driver will only need to take care of
    the main Lynxpoint LPSS clock.
    
    Introduce a special ACPI scan handler for Intel Lynxpoint LPSS
    devices as described above.  This also reduces overhead related to
    browsing the ACPI namespace in search of the LPSS devices before the
    registration of their clocks, removes some LPSS-specific (and
    somewhat ugly) code from acpi_platform.c and shrinks the overall code
    size slightly.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 26fce4b8a632..fafec5ddf17f 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -22,9 +22,6 @@
 
 ACPI_MODULE_NAME("platform");
 
-/* Flags for acpi_create_platform_device */
-#define ACPI_PLATFORM_CLK	BIT(0)
-
 /*
  * The following ACPI IDs are known to be suitable for representing as
  * platform devices.
@@ -33,33 +30,9 @@ static const struct acpi_device_id acpi_platform_device_ids[] = {
 
 	{ "PNP0D40" },
 
-	/* Haswell LPSS devices */
-	{ "INT33C0", ACPI_PLATFORM_CLK },
-	{ "INT33C1", ACPI_PLATFORM_CLK },
-	{ "INT33C2", ACPI_PLATFORM_CLK },
-	{ "INT33C3", ACPI_PLATFORM_CLK },
-	{ "INT33C4", ACPI_PLATFORM_CLK },
-	{ "INT33C5", ACPI_PLATFORM_CLK },
-	{ "INT33C6", ACPI_PLATFORM_CLK },
-	{ "INT33C7", ACPI_PLATFORM_CLK },
-
 	{ }
 };
 
-static int acpi_create_platform_clks(struct acpi_device *adev)
-{
-	static struct platform_device *pdev;
-
-	/* Create Lynxpoint LPSS clocks */
-	if (!pdev && !strncmp(acpi_device_hid(adev), "INT33C", 6)) {
-		pdev = platform_device_register_simple("clk-lpt", -1, NULL, 0);
-		if (IS_ERR(pdev))
-			return PTR_ERR(pdev);
-	}
-
-	return 0;
-}
-
 /**
  * acpi_create_platform_device - Create platform device for ACPI device node
  * @adev: ACPI device node to create a platform device for.
@@ -71,10 +44,9 @@ static int acpi_create_platform_clks(struct acpi_device *adev)
  *
  * Name of the platform device will be the same as @adev's.
  */
-static int acpi_create_platform_device(struct acpi_device *adev,
-				       const struct acpi_device_id *id)
+int acpi_create_platform_device(struct acpi_device *adev,
+				const struct acpi_device_id *id)
 {
-	unsigned long flags = id->driver_data;
 	struct platform_device *pdev = NULL;
 	struct acpi_device *acpi_parent;
 	struct platform_device_info pdevinfo;
@@ -83,14 +55,6 @@ static int acpi_create_platform_device(struct acpi_device *adev,
 	struct resource *resources;
 	int count;
 
-	if (flags & ACPI_PLATFORM_CLK) {
-		int ret = acpi_create_platform_clks(adev);
-		if (ret) {
-			dev_err(&adev->dev, "failed to create clocks\n");
-			return ret;
-		}
-	}
-
 	/* If the ACPI node already has a physical device attached, skip it. */
 	if (adev->physical_node_count)
 		return 0;

commit 141a297bd02e8ddc5ab625cc3a1a5926b1ff929a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 30 14:27:40 2013 +0100

    ACPI / platform: Use struct acpi_scan_handler for creating devices
    
    Currently, the ACPI namespace scanning code creates platform device
    objects for ACPI device nodes whose IDs match the contents of the
    acpi_platform_device_ids[] table.  However, this adds a superfluous
    special case into acpi_bus_device_attach() and makes it more
    difficult to follow than it has to be.  It also will make it more
    difficult to implement removal code for those platform device objects
    in the future.
    
    For the above reasons, introduce a struct acpi_scan_handler object
    for creating platform devices and move the code related to that from
    acpi_bus_device_attach() to the .attach() callback of that object.
    Also move the acpi_platform_device_ids[] table to acpi_platform.c.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 2d1fb4c21605..26fce4b8a632 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -22,6 +22,30 @@
 
 ACPI_MODULE_NAME("platform");
 
+/* Flags for acpi_create_platform_device */
+#define ACPI_PLATFORM_CLK	BIT(0)
+
+/*
+ * The following ACPI IDs are known to be suitable for representing as
+ * platform devices.
+ */
+static const struct acpi_device_id acpi_platform_device_ids[] = {
+
+	{ "PNP0D40" },
+
+	/* Haswell LPSS devices */
+	{ "INT33C0", ACPI_PLATFORM_CLK },
+	{ "INT33C1", ACPI_PLATFORM_CLK },
+	{ "INT33C2", ACPI_PLATFORM_CLK },
+	{ "INT33C3", ACPI_PLATFORM_CLK },
+	{ "INT33C4", ACPI_PLATFORM_CLK },
+	{ "INT33C5", ACPI_PLATFORM_CLK },
+	{ "INT33C6", ACPI_PLATFORM_CLK },
+	{ "INT33C7", ACPI_PLATFORM_CLK },
+
+	{ }
+};
+
 static int acpi_create_platform_clks(struct acpi_device *adev)
 {
 	static struct platform_device *pdev;
@@ -39,8 +63,7 @@ static int acpi_create_platform_clks(struct acpi_device *adev)
 /**
  * acpi_create_platform_device - Create platform device for ACPI device node
  * @adev: ACPI device node to create a platform device for.
- * @flags: ACPI_PLATFORM_* flags that affect the creation of the platform
- *	   devices.
+ * @id: ACPI device ID used to match @adev.
  *
  * Check if the given @adev can be represented as a platform device and, if
  * that's the case, create and register a platform device, populate its common
@@ -48,9 +71,10 @@ static int acpi_create_platform_clks(struct acpi_device *adev)
  *
  * Name of the platform device will be the same as @adev's.
  */
-struct platform_device *acpi_create_platform_device(struct acpi_device *adev,
-						    unsigned long flags)
+static int acpi_create_platform_device(struct acpi_device *adev,
+				       const struct acpi_device_id *id)
 {
+	unsigned long flags = id->driver_data;
 	struct platform_device *pdev = NULL;
 	struct acpi_device *acpi_parent;
 	struct platform_device_info pdevinfo;
@@ -59,25 +83,28 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev,
 	struct resource *resources;
 	int count;
 
-	if ((flags & ACPI_PLATFORM_CLK) && acpi_create_platform_clks(adev)) {
-		dev_err(&adev->dev, "failed to create clocks\n");
-		return NULL;
+	if (flags & ACPI_PLATFORM_CLK) {
+		int ret = acpi_create_platform_clks(adev);
+		if (ret) {
+			dev_err(&adev->dev, "failed to create clocks\n");
+			return ret;
+		}
 	}
 
 	/* If the ACPI node already has a physical device attached, skip it. */
 	if (adev->physical_node_count)
-		return NULL;
+		return 0;
 
 	INIT_LIST_HEAD(&resource_list);
 	count = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);
 	if (count <= 0)
-		return NULL;
+		return 0;
 
 	resources = kmalloc(count * sizeof(struct resource), GFP_KERNEL);
 	if (!resources) {
 		dev_err(&adev->dev, "No memory for resources\n");
 		acpi_dev_free_resource_list(&resource_list);
-		return NULL;
+		return -ENOMEM;
 	}
 	count = 0;
 	list_for_each_entry(rentry, &resource_list, node)
@@ -123,5 +150,15 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev,
 	}
 
 	kfree(resources);
-	return pdev;
+	return 1;
+}
+
+static struct acpi_scan_handler platform_handler = {
+	.ids = acpi_platform_device_ids,
+	.attach = acpi_create_platform_device,
+};
+
+void __init acpi_platform_init(void)
+{
+	acpi_scan_add_handler(&platform_handler);
 }

commit e375325ce55eb841ccda54a4472cf3b0139ea5f2
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Jan 18 13:46:01 2013 +0000

    ACPI / platform: create LPSS clocks if Lynxpoint devices are found during scan
    
    Intel Lynxpoint LPSS peripheral drivers depend on LPSS clock tree being
    created in order to function properly. The clock tree is exposed as a
    platform driver that binds to a device named 'clk-lpt'.
    
    To support this we modify the acpi_create_platform_device() to take one
    additional parameter called flags. This is passed from
    acpi_platform_device_ids[] array when acpi_create_platform_device() is
    called.
    
    We then introduce a new flag ACPI_PLATFORM_CLK which is used to tell
    acpi_create_platform_device() to create the platform clocks as well.
    
    Finally we set the ACPI_PLATFORM_CLK flags for all the Lynxpoint LPSS
    devices and make sure that when this flag is set we create the
    corresponding clock tree platform device.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 5554aea4bb0e..2d1fb4c21605 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -13,6 +13,7 @@
 
 #include <linux/acpi.h>
 #include <linux/device.h>
+#include <linux/err.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
@@ -21,9 +22,25 @@
 
 ACPI_MODULE_NAME("platform");
 
+static int acpi_create_platform_clks(struct acpi_device *adev)
+{
+	static struct platform_device *pdev;
+
+	/* Create Lynxpoint LPSS clocks */
+	if (!pdev && !strncmp(acpi_device_hid(adev), "INT33C", 6)) {
+		pdev = platform_device_register_simple("clk-lpt", -1, NULL, 0);
+		if (IS_ERR(pdev))
+			return PTR_ERR(pdev);
+	}
+
+	return 0;
+}
+
 /**
  * acpi_create_platform_device - Create platform device for ACPI device node
  * @adev: ACPI device node to create a platform device for.
+ * @flags: ACPI_PLATFORM_* flags that affect the creation of the platform
+ *	   devices.
  *
  * Check if the given @adev can be represented as a platform device and, if
  * that's the case, create and register a platform device, populate its common
@@ -31,7 +48,8 @@ ACPI_MODULE_NAME("platform");
  *
  * Name of the platform device will be the same as @adev's.
  */
-struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
+struct platform_device *acpi_create_platform_device(struct acpi_device *adev,
+						    unsigned long flags)
 {
 	struct platform_device *pdev = NULL;
 	struct acpi_device *acpi_parent;
@@ -41,6 +59,11 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 	struct resource *resources;
 	int count;
 
+	if ((flags & ACPI_PLATFORM_CLK) && acpi_create_platform_clks(adev)) {
+		dev_err(&adev->dev, "failed to create clocks\n");
+		return NULL;
+	}
+
 	/* If the ACPI node already has a physical device attached, skip it. */
 	if (adev->physical_node_count)
 		return NULL;

commit 7eaa2800408a32b9e21ead69ad578ad68039cae9
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Jan 18 14:09:35 2013 +0000

    ACPI / platform: fix comment about the platform device name
    
    We don't use _UID anymore, instead the name will be taken from the
    corresponding ACPI device (adev). Fix the obsolete comment.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index db129b9f52cb..5554aea4bb0e 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -29,7 +29,7 @@ ACPI_MODULE_NAME("platform");
  * that's the case, create and register a platform device, populate its common
  * resources and returns a pointer to it.  Otherwise, return %NULL.
  *
- * The platform device's name will be taken from the @adev's _HID and _UID.
+ * Name of the platform device will be the same as @adev's.
  */
 struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 {

commit 5923f986ac191a32640429d054b94af185ec73a8
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Nov 26 10:35:07 2012 +0100

    ACPI / platform: include missed header into acpi_platform.c
    
    The internal.h declares the acpi_create_platform_device(). Without
    that include we get a following warning:
    
    drivers/acpi/acpi_platform.c:133:24: warning: symbol 'acpi_create_platform_device' was not declared. Should it be static?
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index b7df9b197bcf..db129b9f52cb 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -17,6 +17,8 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 
+#include "internal.h"
+
 ACPI_MODULE_NAME("platform");
 
 /**

commit 863f9f30e6c1e30cb19a0cd17c5cf8879257dfd7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Nov 21 00:21:59 2012 +0100

    ACPI / platform: Initialize ACPI handles of platform devices in advance
    
    The current platform device creation and registration code in
    acpi_create_platform_device() is quite convoluted.  This function
    takes an ACPI device node as an argument and eventually calls
    platform_device_register_resndata() to create and register a
    platform device object on the basis of the information contained
    in that code.  However, it doesn't associate the new platform
    device with the ACPI node directly, but instead it relies on
    acpi_platform_notify(), called from within device_add(), to find
    that ACPI node again with the help of acpi_platform_find_device()
    and acpi_platform_match() and then attach the new platform device
    to it.  This causes an additional ACPI namespace walk to happen and
    is clearly suboptimal.
    
    Use the observation that it is now possible to initialize the ACPI
    handle of a device before calling device_add() for it to make this
    code more straightforward.  Namely, add a new field to struct
    platform_device_info allowing us to pass the ACPI handle of interest
    to platform_device_register_full(), which will then use it to
    initialize the new device's ACPI handle before registering it.
    This will cause acpi_platform_notify() to use the ACPI handle from
    the device structure directly instead of using the .find_device()
    routine provided by the device's bus type.  In consequence,
    acpi_platform_bus, acpi_platform_find_device(), and
    acpi_platform_match() are not necessary any more, so remove them.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 7ac20d8b8f07..b7df9b197bcf 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -33,7 +33,7 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 {
 	struct platform_device *pdev = NULL;
 	struct acpi_device *acpi_parent;
-	struct device *parent = NULL;
+	struct platform_device_info pdevinfo;
 	struct resource_list_entry *rentry;
 	struct list_head resource_list;
 	struct resource *resources;
@@ -60,11 +60,13 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 
 	acpi_dev_free_resource_list(&resource_list);
 
+	memset(&pdevinfo, 0, sizeof(pdevinfo));
 	/*
 	 * If the ACPI node has a parent and that parent has a physical device
 	 * attached to it, that physical device should be the parent of the
 	 * platform device we are about to create.
 	 */
+	pdevinfo.parent = NULL;
 	acpi_parent = adev->parent;
 	if (acpi_parent) {
 		struct acpi_device_physical_node *entry;
@@ -76,12 +78,16 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 			entry = list_first_entry(list,
 					struct acpi_device_physical_node,
 					node);
-			parent = entry->dev;
+			pdevinfo.parent = entry->dev;
 		}
 		mutex_unlock(&acpi_parent->physical_node_lock);
 	}
-	pdev = platform_device_register_resndata(parent, dev_name(&adev->dev),
-						 -1, resources, count, NULL, 0);
+	pdevinfo.name = dev_name(&adev->dev);
+	pdevinfo.id = -1;
+	pdevinfo.res = resources;
+	pdevinfo.num_res = count;
+	pdevinfo.acpi_node.handle = adev->handle;
+	pdev = platform_device_register_full(&pdevinfo);
 	if (IS_ERR(pdev)) {
 		dev_err(&adev->dev, "platform device creation failed: %ld\n",
 			PTR_ERR(pdev));
@@ -94,65 +100,3 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 	kfree(resources);
 	return pdev;
 }
-
-static acpi_status acpi_platform_match(acpi_handle handle, u32 depth,
-				       void *data, void **return_value)
-{
-	struct platform_device *pdev = data;
-	struct acpi_device *adev;
-	acpi_status status;
-
-	status = acpi_bus_get_device(handle, &adev);
-	if (ACPI_FAILURE(status))
-		return status;
-
-	/* Skip ACPI devices that have physical device attached */
-	if (adev->physical_node_count)
-		return AE_OK;
-
-	if (!strcmp(dev_name(&pdev->dev), dev_name(&adev->dev))) {
-		*(acpi_handle *)return_value = handle;
-		return AE_CTRL_TERMINATE;
-	}
-
-	return AE_OK;
-}
-
-static int acpi_platform_find_device(struct device *dev, acpi_handle *handle)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	char *name, *tmp, *hid;
-
-	/*
-	 * The platform device is named using the ACPI device name
-	 * _HID:INSTANCE so we strip the INSTANCE out in order to find the
-	 * correct device using its _HID.
-	 */
-	name = kstrdup(dev_name(dev), GFP_KERNEL);
-	if (!name)
-		return -ENOMEM;
-
-	tmp = name;
-	hid = strsep(&tmp, ":");
-	if (!hid) {
-		kfree(name);
-		return -ENODEV;
-	}
-
-	*handle = NULL;
-	acpi_get_devices(hid, acpi_platform_match, pdev, handle);
-
-	kfree(name);
-	return *handle ? 0 : -ENODEV;
-}
-
-static struct acpi_bus_type acpi_platform_bus = {
-	.bus = &platform_bus_type,
-	.find_device = acpi_platform_find_device,
-};
-
-static int __init acpi_platform_init(void)
-{
-	return register_acpi_bus_type(&acpi_platform_bus);
-}
-arch_initcall(acpi_platform_init);

commit 8e345c991c8c7a3c081199ef77deada79e37618a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 15 00:30:21 2012 +0100

    ACPI: Centralized processing of ACPI device resources
    
    Currently, whoever wants to use ACPI device resources has to call
    acpi_walk_resources() to browse the buffer returned by the _CRS
    method for the given device and create filters passed to that
    routine to apply to the individual resource items.  This generally
    is cumbersome, time-consuming and inefficient.  Moreover, it may
    be problematic if resource conflicts need to be resolved, because
    the different users of _CRS will need to do that in a consistent
    way.  However, if there are resource conflicts, the ACPI core
    should be able to resolve them centrally instead of relying on
    various users of acpi_walk_resources() to handle them correctly
    together.
    
    For this reason, introduce a new function, acpi_dev_get_resources(),
    that can be used by subsystems to obtain a list of struct resource
    objects corresponding to the ACPI device resources returned by
    _CRS and, if necessary, to apply additional preprocessing routine
    to the ACPI resources before converting them to the struct resource
    format.
    
    Make the ACPI code that creates platform device objects use
    acpi_dev_get_resources() for resource processing instead of executing
    acpi_walk_resources() twice by itself, which causes it to be much
    more straightforward and easier to follow.
    
    In the future, acpi_dev_get_resources() can be extended to meet
    the needs of the ACPI PNP subsystem and other users of _CRS in
    the kernel.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index bcbb00ce6d99..7ac20d8b8f07 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -19,61 +19,6 @@
 
 ACPI_MODULE_NAME("platform");
 
-struct resource_info {
-	struct device *dev;
-	struct resource *res;
-	size_t n, cur;
-};
-
-static acpi_status acpi_platform_count_resources(struct acpi_resource *res,
-						 void *data)
-{
-	struct acpi_resource_extended_irq *acpi_xirq;
-	struct acpi_resource_irq *acpi_irq;
-	struct resource_info *ri = data;
-
-	switch (res->type) {
-	case ACPI_RESOURCE_TYPE_IRQ:
-		acpi_irq = &res->data.irq;
-		ri->n += acpi_irq->interrupt_count;
-		break;
-	case ACPI_RESOURCE_TYPE_EXTENDED_IRQ:
-		acpi_xirq = &res->data.extended_irq;
-		ri->n += acpi_xirq->interrupt_count;
-		break;
-	default:
-		ri->n++;
-	}
-
-	return AE_OK;
-}
-
-static acpi_status acpi_platform_add_resources(struct acpi_resource *res,
-					       void *data)
-{
-	struct resource_info *ri = data;
-	struct resource *r;
-
-	r = ri->res + ri->cur;
-	if (acpi_dev_resource_memory(res, r)
-	    || acpi_dev_resource_io(res, r)
-	    || acpi_dev_resource_address_space(res, r)
-	    || acpi_dev_resource_ext_address_space(res, r)) {
-		ri->cur++;
-		return AE_OK;
-	}
-	if (acpi_dev_resource_interrupt(res, 0, r)) {
-		int i;
-
-		r++;
-		for (i = 1; acpi_dev_resource_interrupt(res, i, r); i++)
-			r++;
-
-		ri->cur += i;
-	}
-	return AE_OK;
-}
-
 /**
  * acpi_create_platform_device - Create platform device for ACPI device node
  * @adev: ACPI device node to create a platform device for.
@@ -89,35 +34,31 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 	struct platform_device *pdev = NULL;
 	struct acpi_device *acpi_parent;
 	struct device *parent = NULL;
-	struct resource_info ri;
-	acpi_status status;
+	struct resource_list_entry *rentry;
+	struct list_head resource_list;
+	struct resource *resources;
+	int count;
 
 	/* If the ACPI node already has a physical device attached, skip it. */
 	if (adev->physical_node_count)
 		return NULL;
 
-	memset(&ri, 0, sizeof(ri));
-	/* First, count the resources. */
-	status = acpi_walk_resources(adev->handle, METHOD_NAME__CRS,
-				     acpi_platform_count_resources, &ri);
-	if (ACPI_FAILURE(status) || !ri.n)
+	INIT_LIST_HEAD(&resource_list);
+	count = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);
+	if (count <= 0)
 		return NULL;
 
-	/* Next, allocate memory for all the resources and populate it. */
-	ri.dev = &adev->dev;
-	ri.res = kzalloc(ri.n * sizeof(struct resource), GFP_KERNEL);
-	if (!ri.res) {
-		dev_err(&adev->dev,
-			"failed to allocate memory for resources\n");
+	resources = kmalloc(count * sizeof(struct resource), GFP_KERNEL);
+	if (!resources) {
+		dev_err(&adev->dev, "No memory for resources\n");
+		acpi_dev_free_resource_list(&resource_list);
 		return NULL;
 	}
+	count = 0;
+	list_for_each_entry(rentry, &resource_list, node)
+		resources[count++] = rentry->res;
 
-	status = acpi_walk_resources(adev->handle, METHOD_NAME__CRS,
-				     acpi_platform_add_resources, &ri);
-	if (ACPI_FAILURE(status)) {
-		dev_err(&adev->dev, "failed to walk resources\n");
-		goto out;
-	}
+	acpi_dev_free_resource_list(&resource_list);
 
 	/*
 	 * If the ACPI node has a parent and that parent has a physical device
@@ -140,7 +81,7 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 		mutex_unlock(&acpi_parent->physical_node_lock);
 	}
 	pdev = platform_device_register_resndata(parent, dev_name(&adev->dev),
-						 -1, ri.res, ri.cur, NULL, 0);
+						 -1, resources, count, NULL, 0);
 	if (IS_ERR(pdev)) {
 		dev_err(&adev->dev, "platform device creation failed: %ld\n",
 			PTR_ERR(pdev));
@@ -150,8 +91,7 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 			dev_name(&pdev->dev));
 	}
 
- out:
-	kfree(ri.res);
+	kfree(resources);
 	return pdev;
 }
 

commit 97d69dc061e968b5e9e56f48bb223b9ab7764b48
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 15 00:30:12 2012 +0100

    ACPI / platform: Use common ACPI device resource parsing routines
    
    Use common routines in drivers/acpi/resource.c to parse ACPI device
    resources while creating platform device objects.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index dbb31d61e310..bcbb00ce6d99 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -29,21 +29,20 @@ static acpi_status acpi_platform_count_resources(struct acpi_resource *res,
 						 void *data)
 {
 	struct acpi_resource_extended_irq *acpi_xirq;
+	struct acpi_resource_irq *acpi_irq;
 	struct resource_info *ri = data;
 
 	switch (res->type) {
-	case ACPI_RESOURCE_TYPE_FIXED_MEMORY32:
 	case ACPI_RESOURCE_TYPE_IRQ:
-		ri->n++;
+		acpi_irq = &res->data.irq;
+		ri->n += acpi_irq->interrupt_count;
 		break;
 	case ACPI_RESOURCE_TYPE_EXTENDED_IRQ:
 		acpi_xirq = &res->data.extended_irq;
 		ri->n += acpi_xirq->interrupt_count;
 		break;
-	case ACPI_RESOURCE_TYPE_ADDRESS32:
-		if (res->data.address32.resource_type == ACPI_IO_RANGE)
-			ri->n++;
-		break;
+	default:
+		ri->n++;
 	}
 
 	return AE_OK;
@@ -52,71 +51,26 @@ static acpi_status acpi_platform_count_resources(struct acpi_resource *res,
 static acpi_status acpi_platform_add_resources(struct acpi_resource *res,
 					       void *data)
 {
-	struct acpi_resource_fixed_memory32 *acpi_mem;
-	struct acpi_resource_address32 *acpi_add32;
-	struct acpi_resource_extended_irq *acpi_xirq;
-	struct acpi_resource_irq *acpi_irq;
 	struct resource_info *ri = data;
 	struct resource *r;
-	int irq, i;
-
-	switch (res->type) {
-	case ACPI_RESOURCE_TYPE_FIXED_MEMORY32:
-		acpi_mem = &res->data.fixed_memory32;
-		r = &ri->res[ri->cur++];
 
-		r->start = acpi_mem->address;
-		r->end = r->start + acpi_mem->address_length - 1;
-		r->flags = IORESOURCE_MEM;
-
-		dev_dbg(ri->dev, "Memory32Fixed %pR\n", r);
-		break;
-
-	case ACPI_RESOURCE_TYPE_ADDRESS32:
-		acpi_add32 = &res->data.address32;
-
-		if (acpi_add32->resource_type == ACPI_IO_RANGE) {
-			r = &ri->res[ri->cur++];
-			r->start = acpi_add32->minimum;
-			r->end = r->start + acpi_add32->address_length - 1;
-			r->flags = IORESOURCE_IO;
-			dev_dbg(ri->dev, "Address32 %pR\n", r);
-		}
-		break;
-
-	case ACPI_RESOURCE_TYPE_IRQ:
-		acpi_irq = &res->data.irq;
-		r = &ri->res[ri->cur++];
-
-		irq = acpi_register_gsi(ri->dev,
-					acpi_irq->interrupts[0],
-					acpi_irq->triggering,
-					acpi_irq->polarity);
-
-		r->start = r->end = irq;
-		r->flags = IORESOURCE_IRQ;
-
-		dev_dbg(ri->dev, "IRQ %pR\n", r);
-		break;
-
-	case ACPI_RESOURCE_TYPE_EXTENDED_IRQ:
-		acpi_xirq = &res->data.extended_irq;
-
-		for (i = 0; i < acpi_xirq->interrupt_count; i++, ri->cur++) {
-			r = &ri->res[ri->cur];
-			irq = acpi_register_gsi(ri->dev,
-						acpi_xirq->interrupts[i],
-						acpi_xirq->triggering,
-						acpi_xirq->polarity);
+	r = ri->res + ri->cur;
+	if (acpi_dev_resource_memory(res, r)
+	    || acpi_dev_resource_io(res, r)
+	    || acpi_dev_resource_address_space(res, r)
+	    || acpi_dev_resource_ext_address_space(res, r)) {
+		ri->cur++;
+		return AE_OK;
+	}
+	if (acpi_dev_resource_interrupt(res, 0, r)) {
+		int i;
 
-			r->start = r->end = irq;
-			r->flags = IORESOURCE_IRQ;
+		r++;
+		for (i = 1; acpi_dev_resource_interrupt(res, i, r); i++)
+			r++;
 
-			dev_dbg(ri->dev, "Interrupt %pR\n", r);
-		}
-		break;
+		ri->cur += i;
 	}
-
 	return AE_OK;
 }
 
@@ -165,9 +119,6 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 		goto out;
 	}
 
-	if (WARN_ON(ri.n != ri.cur))
-		goto out;
-
 	/*
 	 * If the ACPI node has a parent and that parent has a physical device
 	 * attached to it, that physical device should be the parent of the
@@ -189,7 +140,7 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 		mutex_unlock(&acpi_parent->physical_node_lock);
 	}
 	pdev = platform_device_register_resndata(parent, dev_name(&adev->dev),
-						 -1, ri.res, ri.n, NULL, 0);
+						 -1, ri.res, ri.cur, NULL, 0);
 	if (IS_ERR(pdev)) {
 		dev_err(&adev->dev, "platform device creation failed: %ld\n",
 			PTR_ERR(pdev));

commit b4b6cae2f36d92b31788f10816709d5290a1119a
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Sat Nov 10 23:16:02 2012 +0100

    ACPI / platform: use ACPI device name instead of _HID._UID
    
    Using _UID makes the ACPI platform bus code depend on BIOS to get it
    right. If it doesn't we fail to create the platform device as the name
    should be unique.
    
    The ACPI core already makes a unique name when it first creates the ACPI
    device so we can use that same name as the platform device name instead of
    trusting that the BIOS sets the _UIDs correctly.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index a5a23462287d..dbb31d61e310 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -120,25 +120,6 @@ static acpi_status acpi_platform_add_resources(struct acpi_resource *res,
 	return AE_OK;
 }
 
-static acpi_status acpi_platform_get_device_uid(struct acpi_device *adev,
-						int *uid)
-{
-	struct acpi_device_info *info;
-	acpi_status status;
-
-	status = acpi_get_object_info(adev->handle, &info);
-	if (ACPI_FAILURE(status))
-		return status;
-
-	status = AE_NOT_EXIST;
-	if ((info->valid & ACPI_VALID_UID) &&
-	     !kstrtoint(info->unique_id.string, 0, uid))
-		status = AE_OK;
-
-	kfree(info);
-	return status;
-}
-
 /**
  * acpi_create_platform_device - Create platform device for ACPI device node
  * @adev: ACPI device node to create a platform device for.
@@ -156,19 +137,12 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 	struct device *parent = NULL;
 	struct resource_info ri;
 	acpi_status status;
-	int devid;
 
 	/* If the ACPI node already has a physical device attached, skip it. */
 	if (adev->physical_node_count)
 		return NULL;
 
-	/* Use the UID of the device as the new platform device id if found. */
-	status = acpi_platform_get_device_uid(adev, &devid);
-	if (ACPI_FAILURE(status))
-		devid = -1;
-
 	memset(&ri, 0, sizeof(ri));
-
 	/* First, count the resources. */
 	status = acpi_walk_resources(adev->handle, METHOD_NAME__CRS,
 				     acpi_platform_count_resources, &ri);
@@ -214,8 +188,8 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 		}
 		mutex_unlock(&acpi_parent->physical_node_lock);
 	}
-	pdev = platform_device_register_resndata(parent, acpi_device_hid(adev),
-						 devid, ri.res, ri.n, NULL, 0);
+	pdev = platform_device_register_resndata(parent, dev_name(&adev->dev),
+						 -1, ri.res, ri.n, NULL, 0);
 	if (IS_ERR(pdev)) {
 		dev_err(&adev->dev, "platform device creation failed: %ld\n",
 			PTR_ERR(pdev));
@@ -245,17 +219,7 @@ static acpi_status acpi_platform_match(acpi_handle handle, u32 depth,
 	if (adev->physical_node_count)
 		return AE_OK;
 
-	if (!strcmp(pdev->name, acpi_device_hid(adev))) {
-		int devid;
-
-		/* Check that both name and UID match if it exists */
-		status = acpi_platform_get_device_uid(adev, &devid);
-		if (ACPI_FAILURE(status))
-			devid = -1;
-
-		if (pdev->id != devid)
-			return AE_OK;
-
+	if (!strcmp(dev_name(&pdev->dev), dev_name(&adev->dev))) {
 		*(acpi_handle *)return_value = handle;
 		return AE_CTRL_TERMINATE;
 	}
@@ -266,10 +230,28 @@ static acpi_status acpi_platform_match(acpi_handle handle, u32 depth,
 static int acpi_platform_find_device(struct device *dev, acpi_handle *handle)
 {
 	struct platform_device *pdev = to_platform_device(dev);
+	char *name, *tmp, *hid;
+
+	/*
+	 * The platform device is named using the ACPI device name
+	 * _HID:INSTANCE so we strip the INSTANCE out in order to find the
+	 * correct device using its _HID.
+	 */
+	name = kstrdup(dev_name(dev), GFP_KERNEL);
+	if (!name)
+		return -ENOMEM;
+
+	tmp = name;
+	hid = strsep(&tmp, ":");
+	if (!hid) {
+		kfree(name);
+		return -ENODEV;
+	}
 
 	*handle = NULL;
-	acpi_get_devices(pdev->name, acpi_platform_match, pdev, handle);
+	acpi_get_devices(hid, acpi_platform_match, pdev, handle);
 
+	kfree(name);
 	return *handle ? 0 : -ENODEV;
 }
 

commit 91e5687805885f9fceb60b95e950a3d3bdcf4764
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Oct 31 22:45:02 2012 +0100

    ACPI: Add support for platform bus type
    
    With ACPI 5 it is now possible to enumerate traditional SoC
    peripherals, like serial bus controllers and slave devices behind
    them.  These devices are typically based on IP-blocks used in many
    existing SoC platforms and platform drivers for them may already
    be present in the kernel tree.
    
    To make driver "porting" more straightforward, add ACPI support to
    the platform bus type.  Instead of writing ACPI "glue" drivers for
    the existing platform drivers, register the platform bus type with
    ACPI to create platform device objects for the drivers and bind the
    corresponding ACPI handles to those platform devices.
    
    This should allow us to reuse the existing platform drivers for the
    devices in question with the minimum amount of modifications.
    
    This changeset is based on Mika Westerberg's and Mathias Nyman's
    work.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
new file mode 100644
index 000000000000..a5a23462287d
--- /dev/null
+++ b/drivers/acpi/acpi_platform.c
@@ -0,0 +1,285 @@
+/*
+ * ACPI support for platform bus type.
+ *
+ * Copyright (C) 2012, Intel Corporation
+ * Authors: Mika Westerberg <mika.westerberg@linux.intel.com>
+ *          Mathias Nyman <mathias.nyman@linux.intel.com>
+ *          Rafael J. Wysocki <rafael.j.wysocki@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/acpi.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+ACPI_MODULE_NAME("platform");
+
+struct resource_info {
+	struct device *dev;
+	struct resource *res;
+	size_t n, cur;
+};
+
+static acpi_status acpi_platform_count_resources(struct acpi_resource *res,
+						 void *data)
+{
+	struct acpi_resource_extended_irq *acpi_xirq;
+	struct resource_info *ri = data;
+
+	switch (res->type) {
+	case ACPI_RESOURCE_TYPE_FIXED_MEMORY32:
+	case ACPI_RESOURCE_TYPE_IRQ:
+		ri->n++;
+		break;
+	case ACPI_RESOURCE_TYPE_EXTENDED_IRQ:
+		acpi_xirq = &res->data.extended_irq;
+		ri->n += acpi_xirq->interrupt_count;
+		break;
+	case ACPI_RESOURCE_TYPE_ADDRESS32:
+		if (res->data.address32.resource_type == ACPI_IO_RANGE)
+			ri->n++;
+		break;
+	}
+
+	return AE_OK;
+}
+
+static acpi_status acpi_platform_add_resources(struct acpi_resource *res,
+					       void *data)
+{
+	struct acpi_resource_fixed_memory32 *acpi_mem;
+	struct acpi_resource_address32 *acpi_add32;
+	struct acpi_resource_extended_irq *acpi_xirq;
+	struct acpi_resource_irq *acpi_irq;
+	struct resource_info *ri = data;
+	struct resource *r;
+	int irq, i;
+
+	switch (res->type) {
+	case ACPI_RESOURCE_TYPE_FIXED_MEMORY32:
+		acpi_mem = &res->data.fixed_memory32;
+		r = &ri->res[ri->cur++];
+
+		r->start = acpi_mem->address;
+		r->end = r->start + acpi_mem->address_length - 1;
+		r->flags = IORESOURCE_MEM;
+
+		dev_dbg(ri->dev, "Memory32Fixed %pR\n", r);
+		break;
+
+	case ACPI_RESOURCE_TYPE_ADDRESS32:
+		acpi_add32 = &res->data.address32;
+
+		if (acpi_add32->resource_type == ACPI_IO_RANGE) {
+			r = &ri->res[ri->cur++];
+			r->start = acpi_add32->minimum;
+			r->end = r->start + acpi_add32->address_length - 1;
+			r->flags = IORESOURCE_IO;
+			dev_dbg(ri->dev, "Address32 %pR\n", r);
+		}
+		break;
+
+	case ACPI_RESOURCE_TYPE_IRQ:
+		acpi_irq = &res->data.irq;
+		r = &ri->res[ri->cur++];
+
+		irq = acpi_register_gsi(ri->dev,
+					acpi_irq->interrupts[0],
+					acpi_irq->triggering,
+					acpi_irq->polarity);
+
+		r->start = r->end = irq;
+		r->flags = IORESOURCE_IRQ;
+
+		dev_dbg(ri->dev, "IRQ %pR\n", r);
+		break;
+
+	case ACPI_RESOURCE_TYPE_EXTENDED_IRQ:
+		acpi_xirq = &res->data.extended_irq;
+
+		for (i = 0; i < acpi_xirq->interrupt_count; i++, ri->cur++) {
+			r = &ri->res[ri->cur];
+			irq = acpi_register_gsi(ri->dev,
+						acpi_xirq->interrupts[i],
+						acpi_xirq->triggering,
+						acpi_xirq->polarity);
+
+			r->start = r->end = irq;
+			r->flags = IORESOURCE_IRQ;
+
+			dev_dbg(ri->dev, "Interrupt %pR\n", r);
+		}
+		break;
+	}
+
+	return AE_OK;
+}
+
+static acpi_status acpi_platform_get_device_uid(struct acpi_device *adev,
+						int *uid)
+{
+	struct acpi_device_info *info;
+	acpi_status status;
+
+	status = acpi_get_object_info(adev->handle, &info);
+	if (ACPI_FAILURE(status))
+		return status;
+
+	status = AE_NOT_EXIST;
+	if ((info->valid & ACPI_VALID_UID) &&
+	     !kstrtoint(info->unique_id.string, 0, uid))
+		status = AE_OK;
+
+	kfree(info);
+	return status;
+}
+
+/**
+ * acpi_create_platform_device - Create platform device for ACPI device node
+ * @adev: ACPI device node to create a platform device for.
+ *
+ * Check if the given @adev can be represented as a platform device and, if
+ * that's the case, create and register a platform device, populate its common
+ * resources and returns a pointer to it.  Otherwise, return %NULL.
+ *
+ * The platform device's name will be taken from the @adev's _HID and _UID.
+ */
+struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
+{
+	struct platform_device *pdev = NULL;
+	struct acpi_device *acpi_parent;
+	struct device *parent = NULL;
+	struct resource_info ri;
+	acpi_status status;
+	int devid;
+
+	/* If the ACPI node already has a physical device attached, skip it. */
+	if (adev->physical_node_count)
+		return NULL;
+
+	/* Use the UID of the device as the new platform device id if found. */
+	status = acpi_platform_get_device_uid(adev, &devid);
+	if (ACPI_FAILURE(status))
+		devid = -1;
+
+	memset(&ri, 0, sizeof(ri));
+
+	/* First, count the resources. */
+	status = acpi_walk_resources(adev->handle, METHOD_NAME__CRS,
+				     acpi_platform_count_resources, &ri);
+	if (ACPI_FAILURE(status) || !ri.n)
+		return NULL;
+
+	/* Next, allocate memory for all the resources and populate it. */
+	ri.dev = &adev->dev;
+	ri.res = kzalloc(ri.n * sizeof(struct resource), GFP_KERNEL);
+	if (!ri.res) {
+		dev_err(&adev->dev,
+			"failed to allocate memory for resources\n");
+		return NULL;
+	}
+
+	status = acpi_walk_resources(adev->handle, METHOD_NAME__CRS,
+				     acpi_platform_add_resources, &ri);
+	if (ACPI_FAILURE(status)) {
+		dev_err(&adev->dev, "failed to walk resources\n");
+		goto out;
+	}
+
+	if (WARN_ON(ri.n != ri.cur))
+		goto out;
+
+	/*
+	 * If the ACPI node has a parent and that parent has a physical device
+	 * attached to it, that physical device should be the parent of the
+	 * platform device we are about to create.
+	 */
+	acpi_parent = adev->parent;
+	if (acpi_parent) {
+		struct acpi_device_physical_node *entry;
+		struct list_head *list;
+
+		mutex_lock(&acpi_parent->physical_node_lock);
+		list = &acpi_parent->physical_node_list;
+		if (!list_empty(list)) {
+			entry = list_first_entry(list,
+					struct acpi_device_physical_node,
+					node);
+			parent = entry->dev;
+		}
+		mutex_unlock(&acpi_parent->physical_node_lock);
+	}
+	pdev = platform_device_register_resndata(parent, acpi_device_hid(adev),
+						 devid, ri.res, ri.n, NULL, 0);
+	if (IS_ERR(pdev)) {
+		dev_err(&adev->dev, "platform device creation failed: %ld\n",
+			PTR_ERR(pdev));
+		pdev = NULL;
+	} else {
+		dev_dbg(&adev->dev, "created platform device %s\n",
+			dev_name(&pdev->dev));
+	}
+
+ out:
+	kfree(ri.res);
+	return pdev;
+}
+
+static acpi_status acpi_platform_match(acpi_handle handle, u32 depth,
+				       void *data, void **return_value)
+{
+	struct platform_device *pdev = data;
+	struct acpi_device *adev;
+	acpi_status status;
+
+	status = acpi_bus_get_device(handle, &adev);
+	if (ACPI_FAILURE(status))
+		return status;
+
+	/* Skip ACPI devices that have physical device attached */
+	if (adev->physical_node_count)
+		return AE_OK;
+
+	if (!strcmp(pdev->name, acpi_device_hid(adev))) {
+		int devid;
+
+		/* Check that both name and UID match if it exists */
+		status = acpi_platform_get_device_uid(adev, &devid);
+		if (ACPI_FAILURE(status))
+			devid = -1;
+
+		if (pdev->id != devid)
+			return AE_OK;
+
+		*(acpi_handle *)return_value = handle;
+		return AE_CTRL_TERMINATE;
+	}
+
+	return AE_OK;
+}
+
+static int acpi_platform_find_device(struct device *dev, acpi_handle *handle)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	*handle = NULL;
+	acpi_get_devices(pdev->name, acpi_platform_match, pdev, handle);
+
+	return *handle ? 0 : -ENODEV;
+}
+
+static struct acpi_bus_type acpi_platform_bus = {
+	.bus = &platform_bus_type,
+	.find_device = acpi_platform_find_device,
+};
+
+static int __init acpi_platform_init(void)
+{
+	return register_acpi_bus_type(&acpi_platform_bus);
+}
+arch_initcall(acpi_platform_init);
