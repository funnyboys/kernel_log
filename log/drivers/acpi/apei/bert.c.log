commit 3d995f88adb106fc67efe3fd6f6dfc6b884824a9
Author: Hanjun Guo <guohanjun@huawei.com>
Date:   Thu May 7 17:09:15 2020 +0800

    ACPI: APEI: Put the boot error record table after parsing
    
    The mapped boot error record table is not used after
    bert_init(), release it.
    
    Signed-off-by: Hanjun Guo <guohanjun@huawei.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/apei/bert.c b/drivers/acpi/apei/bert.c
index 1155fb9dcc3a..19e50fcbf4d6 100644
--- a/drivers/acpi/apei/bert.c
+++ b/drivers/acpi/apei/bert.c
@@ -119,7 +119,7 @@ static int __init bert_init(void)
 	rc = bert_check_table(bert_tab);
 	if (rc) {
 		pr_err(FW_BUG "table invalid.\n");
-		return rc;
+		goto out_put_bert_tab;
 	}
 
 	region_len = bert_tab->region_length;
@@ -127,7 +127,7 @@ static int __init bert_init(void)
 	rc = apei_resources_add(&bert_resources, bert_tab->address,
 				region_len, true);
 	if (rc)
-		return rc;
+		goto out_put_bert_tab;
 	rc = apei_resources_request(&bert_resources, "APEI BERT");
 	if (rc)
 		goto out_fini;
@@ -142,6 +142,8 @@ static int __init bert_init(void)
 	apei_resources_release(&bert_resources);
 out_fini:
 	apei_resources_fini(&bert_resources);
+out_put_bert_tab:
+	acpi_put_table((struct acpi_table_header *)bert_tab);
 
 	return rc;
 }

commit 82664963ee5f03b5c604f4c593a5e43f26193610
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:51 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 437
    
    Based on 1 normalized pattern(s):
    
      this file is licensed under gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 22 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190115.129548190@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/apei/bert.c b/drivers/acpi/apei/bert.c
index 0d948d0a41af..1155fb9dcc3a 100644
--- a/drivers/acpi/apei/bert.c
+++ b/drivers/acpi/apei/bert.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * APEI Boot Error Record Table (BERT) support
  *
@@ -16,9 +17,6 @@
  *
  * For more information about BERT, please refer to ACPI Specification
  * version 4.0, section 17.3.1
- *
- * This file is licensed under GPLv2.
- *
  */
 
 #include <linux/kernel.h>

commit 1c0d9b1c31d19d3aa90296a184e4624545d7d1ee
Author: Ross Lagerwall <ross.lagerwall@citrix.com>
Date:   Mon Jan 28 10:04:23 2019 +0000

    ACPI: APEI: Fix possible out-of-bounds access to BERT region
    
    Check that the length recorded in the generic error status block is
    within the region before checking the contents of the region itself.
    
    Otherwise it may result in an out-of-bounds access if the system
    firmware has generated a status block with an invalid length (larger
    than the mapped region). Also move the block_status check so that it
    only happens after the block has been verified to be within the mapped
    region.
    
    Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
    Acked-by: Borislav Petkov <bp@suse.de>
    Tested-by: Tyler Baicar <baicar.tyler@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/apei/bert.c b/drivers/acpi/apei/bert.c
index 12771fcf0417..0d948d0a41af 100644
--- a/drivers/acpi/apei/bert.c
+++ b/drivers/acpi/apei/bert.c
@@ -42,15 +42,7 @@ static void __init bert_print_all(struct acpi_bert_region *region,
 	int remain = region_len;
 	u32 estatus_len;
 
-	if (!estatus->block_status)
-		return;
-
-	while (remain > sizeof(struct acpi_bert_region)) {
-		if (cper_estatus_check(estatus)) {
-			pr_err(FW_BUG "Invalid error record.\n");
-			return;
-		}
-
+	while (remain >= sizeof(struct acpi_bert_region)) {
 		estatus_len = cper_estatus_len(estatus);
 		if (remain < estatus_len) {
 			pr_err(FW_BUG "Truncated status block (length: %u).\n",
@@ -58,6 +50,15 @@ static void __init bert_print_all(struct acpi_bert_region *region,
 			return;
 		}
 
+		/* No more error records. */
+		if (!estatus->block_status)
+			return;
+
+		if (cper_estatus_check(estatus)) {
+			pr_err(FW_BUG "Invalid error record.\n");
+			return;
+		}
+
 		pr_info_once("Error records from previous boot:\n");
 
 		cper_estatus_print(KERN_INFO HW_ERR, estatus);
@@ -70,10 +71,6 @@ static void __init bert_print_all(struct acpi_bert_region *region,
 		estatus->block_status = 0;
 
 		estatus = (void *)estatus + estatus_len;
-		/* No more error records. */
-		if (!estatus->block_status)
-			return;
-
 		remain -= estatus_len;
 	}
 }

commit 41139ac3cd76c6dff8286102a8ac62933c680463
Author: Huang Ying <ying.huang@intel.com>
Date:   Mon Feb 20 09:12:58 2017 +0800

    ACPI: APEI: Fix BERT resources conflict with ACPI NVS area
    
    It was reported that on some machines, there is overlap between ACPI
    NVS area and BERT address range.  This appears reasonable because BERT
    contents need to be non-volatile across reboot.  But this will cause
    resources conflict in current Linux kernel implementation because the
    ACPI NVS area is marked as busy.  The resource conflict is fixed via
    excluding the ACPI NVS area when requesting IO resources for BERT.
    When accessing the BERT contents, the whole BERT address range will be
    ioremapped and accessed.
    
    Reported-and-tested-by: Hans Kristian Rosbach <hansr@raskesider.no>
    Signed-off-by: Ying Huang <ying.huang@intel.com>
    Acked-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/apei/bert.c b/drivers/acpi/apei/bert.c
index a05b5c0cf181..12771fcf0417 100644
--- a/drivers/acpi/apei/bert.c
+++ b/drivers/acpi/apei/bert.c
@@ -97,6 +97,7 @@ static int __init bert_check_table(struct acpi_table_bert *bert_tab)
 
 static int __init bert_init(void)
 {
+	struct apei_resources bert_resources;
 	struct acpi_bert_region *boot_error_region;
 	struct acpi_table_bert *bert_tab;
 	unsigned int region_len;
@@ -127,13 +128,14 @@ static int __init bert_init(void)
 	}
 
 	region_len = bert_tab->region_length;
-	if (!request_mem_region(bert_tab->address, region_len, "APEI BERT")) {
-		pr_err("Can't request iomem region <%016llx-%016llx>.\n",
-		       (unsigned long long)bert_tab->address,
-		       (unsigned long long)bert_tab->address + region_len - 1);
-		return -EIO;
-	}
-
+	apei_resources_init(&bert_resources);
+	rc = apei_resources_add(&bert_resources, bert_tab->address,
+				region_len, true);
+	if (rc)
+		return rc;
+	rc = apei_resources_request(&bert_resources, "APEI BERT");
+	if (rc)
+		goto out_fini;
 	boot_error_region = ioremap_cache(bert_tab->address, region_len);
 	if (boot_error_region) {
 		bert_print_all(boot_error_region, region_len);
@@ -142,7 +144,9 @@ static int __init bert_init(void)
 		rc = -ENOMEM;
 	}
 
-	release_mem_region(bert_tab->address, region_len);
+	apei_resources_release(&bert_resources);
+out_fini:
+	apei_resources_fini(&bert_resources);
 
 	return rc;
 }

commit a3e2acc5e37b22b6808a0b8e46887c3577de9c9e
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Jun 29 13:04:29 2016 -0700

    ACPI / APEI: Add Boot Error Record Table (BERT) support
    
    ACPI/APEI is designed to verifiy/report H/W errors, like Corrected
    Error(CE) and Uncorrected Error(UC). It contains four tables: HEST,
    ERST, EINJ and BERT. The first three tables have been merged for
    a long time, but because of lacking BIOS support for BERT, the
    support for BERT is pending until now. Recently on ARM 64 platform
    it is has been supported. So here we come.
    
    Under normal circumstances, when a hardware error occurs, kernel will
    be notified via NMI, MCE or some other method, then kernel will
    process the error condition, report it, and recover it if possible.
    But sometime, the situation is so bad, so that firmware may choose to
    reset directly without notifying Linux kernel.
    
    Linux kernel can use the Boot Error Record Table (BERT) to get the
    un-notified hardware errors that occurred in a previous boot. In this
    patch, the error information is reported via printk.
    
    For more information about BERT, please refer to ACPI Specification
    version 6.0, section 18.3.1:
      http://www.uefi.org/sites/default/files/resources/ACPI_6.0.pdf
    
    The following log is a BERT record after system reboot because of hitting
    a fatal memory error:
    BERT: Error records from previous boot:
    [Hardware Error]: It has been corrected by h/w and requires no further action
    [Hardware Error]: event severity: corrected
    [Hardware Error]:  Error 0, type: recoverable
    [Hardware Error]:   section_type: memory error
    [Hardware Error]:   error_status: 0x0000000000000400
    [Hardware Error]:   physical_address: 0xffffffffffffffff
    [Hardware Error]:   card: 1 module: 2 bank: 3 row: 1 column: 2 bit_position: 5
    [Hardware Error]:   error_type: 2, single-bit ECC
    
    [Tomasz Nowicki: Clear error status at the end of error handling]
    [Tony: Applied some cleanups suggested by Fu Wei]
    [Fu Wei: delete EXPORT_SYMBOL_GPL(bert_disable), improve the code]
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Signed-off-by: Chen, Gong <gong.chen@linux.intel.com>
    Tested-by: Jonathan (Zhixiong) Zhang <zjzhang@codeaurora.org>
    Signed-off-by: Fu Wei <fu.wei@linaro.org>
    Tested-by: Tyler Baicar <tbaicar@codeaurora.org>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/apei/bert.c b/drivers/acpi/apei/bert.c
new file mode 100644
index 000000000000..a05b5c0cf181
--- /dev/null
+++ b/drivers/acpi/apei/bert.c
@@ -0,0 +1,150 @@
+/*
+ * APEI Boot Error Record Table (BERT) support
+ *
+ * Copyright 2011 Intel Corp.
+ *   Author: Huang Ying <ying.huang@intel.com>
+ *
+ * Under normal circumstances, when a hardware error occurs, the error
+ * handler receives control and processes the error. This gives OSPM a
+ * chance to process the error condition, report it, and optionally attempt
+ * recovery. In some cases, the system is unable to process an error.
+ * For example, system firmware or a management controller may choose to
+ * reset the system or the system might experience an uncontrolled crash
+ * or reset.The boot error source is used to report unhandled errors that
+ * occurred in a previous boot. This mechanism is described in the BERT
+ * table.
+ *
+ * For more information about BERT, please refer to ACPI Specification
+ * version 4.0, section 17.3.1
+ *
+ * This file is licensed under GPLv2.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/acpi.h>
+#include <linux/io.h>
+
+#include "apei-internal.h"
+
+#undef pr_fmt
+#define pr_fmt(fmt) "BERT: " fmt
+
+static int bert_disable;
+
+static void __init bert_print_all(struct acpi_bert_region *region,
+				  unsigned int region_len)
+{
+	struct acpi_hest_generic_status *estatus =
+		(struct acpi_hest_generic_status *)region;
+	int remain = region_len;
+	u32 estatus_len;
+
+	if (!estatus->block_status)
+		return;
+
+	while (remain > sizeof(struct acpi_bert_region)) {
+		if (cper_estatus_check(estatus)) {
+			pr_err(FW_BUG "Invalid error record.\n");
+			return;
+		}
+
+		estatus_len = cper_estatus_len(estatus);
+		if (remain < estatus_len) {
+			pr_err(FW_BUG "Truncated status block (length: %u).\n",
+			       estatus_len);
+			return;
+		}
+
+		pr_info_once("Error records from previous boot:\n");
+
+		cper_estatus_print(KERN_INFO HW_ERR, estatus);
+
+		/*
+		 * Because the boot error source is "one-time polled" type,
+		 * clear Block Status of current Generic Error Status Block,
+		 * once it's printed.
+		 */
+		estatus->block_status = 0;
+
+		estatus = (void *)estatus + estatus_len;
+		/* No more error records. */
+		if (!estatus->block_status)
+			return;
+
+		remain -= estatus_len;
+	}
+}
+
+static int __init setup_bert_disable(char *str)
+{
+	bert_disable = 1;
+
+	return 0;
+}
+__setup("bert_disable", setup_bert_disable);
+
+static int __init bert_check_table(struct acpi_table_bert *bert_tab)
+{
+	if (bert_tab->header.length < sizeof(struct acpi_table_bert) ||
+	    bert_tab->region_length < sizeof(struct acpi_bert_region))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int __init bert_init(void)
+{
+	struct acpi_bert_region *boot_error_region;
+	struct acpi_table_bert *bert_tab;
+	unsigned int region_len;
+	acpi_status status;
+	int rc = 0;
+
+	if (acpi_disabled)
+		return 0;
+
+	if (bert_disable) {
+		pr_info("Boot Error Record Table support is disabled.\n");
+		return 0;
+	}
+
+	status = acpi_get_table(ACPI_SIG_BERT, 0, (struct acpi_table_header **)&bert_tab);
+	if (status == AE_NOT_FOUND)
+		return 0;
+
+	if (ACPI_FAILURE(status)) {
+		pr_err("get table failed, %s.\n", acpi_format_exception(status));
+		return -EINVAL;
+	}
+
+	rc = bert_check_table(bert_tab);
+	if (rc) {
+		pr_err(FW_BUG "table invalid.\n");
+		return rc;
+	}
+
+	region_len = bert_tab->region_length;
+	if (!request_mem_region(bert_tab->address, region_len, "APEI BERT")) {
+		pr_err("Can't request iomem region <%016llx-%016llx>.\n",
+		       (unsigned long long)bert_tab->address,
+		       (unsigned long long)bert_tab->address + region_len - 1);
+		return -EIO;
+	}
+
+	boot_error_region = ioremap_cache(bert_tab->address, region_len);
+	if (boot_error_region) {
+		bert_print_all(boot_error_region, region_len);
+		iounmap(boot_error_region);
+	} else {
+		rc = -ENOMEM;
+	}
+
+	release_mem_region(bert_tab->address, region_len);
+
+	return rc;
+}
+
+late_initcall(bert_init);
