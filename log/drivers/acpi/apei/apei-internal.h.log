commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/apei/apei-internal.h b/drivers/acpi/apei/apei-internal.h
index cb4126051f62..1d6ef9654725 100644
--- a/drivers/acpi/apei/apei-internal.h
+++ b/drivers/acpi/apei/apei-internal.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * apei-internal.h - ACPI Platform Error Interface internal
  * definitions.

commit c4335fdd38227788178953c101b77180504d7ea0
Author: gengdongjiu <gengdongjiu@huawei.com>
Date:   Thu Aug 17 20:07:18 2017 +0800

    ACPI: APEI: fix the wrong iteration of generic error status block
    
    The revision 0x300 generic error data entry is different
    from the old version, but currently iterating through the
    GHES estatus blocks does not take into account this difference.
    This will lead to failure to get the right data entry if GHES
    has revision 0x300 error data entry.
    
    Update the GHES estatus iteration macro to properly increment using
    acpi_hest_get_next(), and correct the iteration termination condition
    because the status block data length only includes error data
    length.
    
    Convert the CPER estatus checking and printing iteration logic
    to use same macro.
    
    Signed-off-by: Dongjiu Geng <gengdongjiu@huawei.com>
    Tested-by: Tyler Baicar <tbaicar@codeaurora.org>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/apei/apei-internal.h b/drivers/acpi/apei/apei-internal.h
index 6e9f14c0a71b..cb4126051f62 100644
--- a/drivers/acpi/apei/apei-internal.h
+++ b/drivers/acpi/apei/apei-internal.h
@@ -120,11 +120,6 @@ int apei_exec_collect_resources(struct apei_exec_context *ctx,
 struct dentry;
 struct dentry *apei_get_debugfs_dir(void);
 
-#define apei_estatus_for_each_section(estatus, section)			\
-	for (section = (struct acpi_hest_generic_data *)(estatus + 1);	\
-	     (void *)section - (void *)estatus < estatus->data_length;	\
-	     section = (void *)(section+1) + section->error_data_length)
-
 static inline u32 cper_estatus_len(struct acpi_hest_generic_status *estatus)
 {
 	if (estatus->raw_data_length)

commit a3e2acc5e37b22b6808a0b8e46887c3577de9c9e
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Jun 29 13:04:29 2016 -0700

    ACPI / APEI: Add Boot Error Record Table (BERT) support
    
    ACPI/APEI is designed to verifiy/report H/W errors, like Corrected
    Error(CE) and Uncorrected Error(UC). It contains four tables: HEST,
    ERST, EINJ and BERT. The first three tables have been merged for
    a long time, but because of lacking BIOS support for BERT, the
    support for BERT is pending until now. Recently on ARM 64 platform
    it is has been supported. So here we come.
    
    Under normal circumstances, when a hardware error occurs, kernel will
    be notified via NMI, MCE or some other method, then kernel will
    process the error condition, report it, and recover it if possible.
    But sometime, the situation is so bad, so that firmware may choose to
    reset directly without notifying Linux kernel.
    
    Linux kernel can use the Boot Error Record Table (BERT) to get the
    un-notified hardware errors that occurred in a previous boot. In this
    patch, the error information is reported via printk.
    
    For more information about BERT, please refer to ACPI Specification
    version 6.0, section 18.3.1:
      http://www.uefi.org/sites/default/files/resources/ACPI_6.0.pdf
    
    The following log is a BERT record after system reboot because of hitting
    a fatal memory error:
    BERT: Error records from previous boot:
    [Hardware Error]: It has been corrected by h/w and requires no further action
    [Hardware Error]: event severity: corrected
    [Hardware Error]:  Error 0, type: recoverable
    [Hardware Error]:   section_type: memory error
    [Hardware Error]:   error_status: 0x0000000000000400
    [Hardware Error]:   physical_address: 0xffffffffffffffff
    [Hardware Error]:   card: 1 module: 2 bank: 3 row: 1 column: 2 bit_position: 5
    [Hardware Error]:   error_type: 2, single-bit ECC
    
    [Tomasz Nowicki: Clear error status at the end of error handling]
    [Tony: Applied some cleanups suggested by Fu Wei]
    [Fu Wei: delete EXPORT_SYMBOL_GPL(bert_disable), improve the code]
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Signed-off-by: Chen, Gong <gong.chen@linux.intel.com>
    Tested-by: Jonathan (Zhixiong) Zhang <zjzhang@codeaurora.org>
    Signed-off-by: Fu Wei <fu.wei@linaro.org>
    Tested-by: Tyler Baicar <tbaicar@codeaurora.org>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/apei/apei-internal.h b/drivers/acpi/apei/apei-internal.h
index 16129c78b489..6e9f14c0a71b 100644
--- a/drivers/acpi/apei/apei-internal.h
+++ b/drivers/acpi/apei/apei-internal.h
@@ -1,6 +1,6 @@
 /*
  * apei-internal.h - ACPI Platform Error Interface internal
- * definations.
+ * definitions.
  */
 
 #ifndef APEI_INTERNAL_H

commit 0a00fd5e20fd5dc89e976e163588d7c54edaf745
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Jun 3 16:32:53 2014 +0800

    ACPICA: Restore error table definitions to reduce code differences between Linux and ACPICA upstream.
    
    The following commit has changed ACPICA table header definitions:
    
     Commit: 88f074f4871a8c212b212b725e4dcdcdb09613c1
     Subject: ACPI, CPER: Update cper info
    
    While such definitions are currently maintained in ACPICA. As the
    modifications applying to the table definitions affect other OSPMs'
    drivers, it is very difficult for ACPICA to initiate a process to
    complete the merge. Thus this commit finally only leaves us divergences.
    
    Revert such naming modifications to reduce the source code differecnes
    between Linux and ACPICA upstream. No functional changes.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Bob Moore <robert.moore@intel.com>
    Cc: Chen, Gong <gong.chen@linux.intel.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/apei/apei-internal.h b/drivers/acpi/apei/apei-internal.h
index e5bcd919d4e6..16129c78b489 100644
--- a/drivers/acpi/apei/apei-internal.h
+++ b/drivers/acpi/apei/apei-internal.h
@@ -121,11 +121,11 @@ struct dentry;
 struct dentry *apei_get_debugfs_dir(void);
 
 #define apei_estatus_for_each_section(estatus, section)			\
-	for (section = (struct acpi_generic_data *)(estatus + 1);	\
+	for (section = (struct acpi_hest_generic_data *)(estatus + 1);	\
 	     (void *)section - (void *)estatus < estatus->data_length;	\
 	     section = (void *)(section+1) + section->error_data_length)
 
-static inline u32 cper_estatus_len(struct acpi_generic_status *estatus)
+static inline u32 cper_estatus_len(struct acpi_hest_generic_status *estatus)
 {
 	if (estatus->raw_data_length)
 		return estatus->raw_data_offset + \
@@ -135,9 +135,9 @@ static inline u32 cper_estatus_len(struct acpi_generic_status *estatus)
 }
 
 void cper_estatus_print(const char *pfx,
-			const struct acpi_generic_status *estatus);
-int cper_estatus_check_header(const struct acpi_generic_status *estatus);
-int cper_estatus_check(const struct acpi_generic_status *estatus);
+			const struct acpi_hest_generic_status *estatus);
+int cper_estatus_check_header(const struct acpi_hest_generic_status *estatus);
+int cper_estatus_check(const struct acpi_hest_generic_status *estatus);
 
 int apei_osc_setup(void);
 #endif

commit 27d50c82714f6477ac690034b37d202f76eb4f70
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Dec 6 16:52:05 2013 +0800

    ACPI / i915: Fix incorrect <acpi/acpi.h> inclusions via <linux/acpi_io.h>
    
    To avoid build problems and breaking dependencies between ACPI header
    files, <acpi/acpi.h> should not be included directly by code outside
    of the ACPI core subsystem.  However, that is possible if
    <linux/acpi_io.h> is included, because that file contains
    a direct inclusion of <acpi/acpi.h>.
    
    For this reason, remove the direct <acpi/acpi.h> inclusion from
    <linux/acpi_io.h>, move that file from include/linux/ to include/acpi/
    and make <linux/acpi.h> include it for CONFIG_ACPI set along with the
    other ACPI header files.  Accordingly, Remove the inclusions of
    <linux/acpi_io.h> from everywhere.
    
    Of course, that causes the contents of the new <acpi/acpi_io.h> file
    to be available for CONFIG_ACPI set only, so intel_opregion.o that
    depends on it should also depend on CONFIG_ACPI (and it really should
    not be compiled for CONFIG_ACPI unset anyway).
    
    References: https://01.org/linuxgraphics/sites/default/files/documentation/acpi_igd_opregion_spec.pdf
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    [rjw: Subject and changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/apei/apei-internal.h b/drivers/acpi/apei/apei-internal.h
index 21ba34a73883..e5bcd919d4e6 100644
--- a/drivers/acpi/apei/apei-internal.h
+++ b/drivers/acpi/apei/apei-internal.h
@@ -8,7 +8,6 @@
 
 #include <linux/cper.h>
 #include <linux/acpi.h>
-#include <linux/acpi_io.h>
 
 struct apei_exec_context;
 

commit 88f074f4871a8c212b212b725e4dcdcdb09613c1
Author: Chen, Gong <gong.chen@linux.intel.com>
Date:   Fri Oct 18 14:28:59 2013 -0700

    ACPI, CPER: Update cper info
    
    We have a lot of confusing names of functions and data structures in
    amongs the the error reporting code.  In particular the "apei" prefix
    has been applied to many objects that are not part of APEI.  Since we
    will be using these routines for extended error log reporting it will
    be clearer if we fix up the names first.
    
    Signed-off-by: Chen, Gong <gong.chen@linux.intel.com>
    Acked-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/drivers/acpi/apei/apei-internal.h b/drivers/acpi/apei/apei-internal.h
index f220d642136e..21ba34a73883 100644
--- a/drivers/acpi/apei/apei-internal.h
+++ b/drivers/acpi/apei/apei-internal.h
@@ -122,11 +122,11 @@ struct dentry;
 struct dentry *apei_get_debugfs_dir(void);
 
 #define apei_estatus_for_each_section(estatus, section)			\
-	for (section = (struct acpi_hest_generic_data *)(estatus + 1);	\
+	for (section = (struct acpi_generic_data *)(estatus + 1);	\
 	     (void *)section - (void *)estatus < estatus->data_length;	\
 	     section = (void *)(section+1) + section->error_data_length)
 
-static inline u32 apei_estatus_len(struct acpi_hest_generic_status *estatus)
+static inline u32 cper_estatus_len(struct acpi_generic_status *estatus)
 {
 	if (estatus->raw_data_length)
 		return estatus->raw_data_offset + \
@@ -135,10 +135,10 @@ static inline u32 apei_estatus_len(struct acpi_hest_generic_status *estatus)
 		return sizeof(*estatus) + estatus->data_length;
 }
 
-void apei_estatus_print(const char *pfx,
-			const struct acpi_hest_generic_status *estatus);
-int apei_estatus_check_header(const struct acpi_hest_generic_status *estatus);
-int apei_estatus_check(const struct acpi_hest_generic_status *estatus);
+void cper_estatus_print(const char *pfx,
+			const struct acpi_generic_status *estatus);
+int cper_estatus_check_header(const struct acpi_generic_status *estatus);
+int cper_estatus_check(const struct acpi_generic_status *estatus);
 
 int apei_osc_setup(void);
 #endif

commit 34ddeb035d704eafdcdb3cbc781894300136c3c4
Author: Huang Ying <ying.huang@intel.com>
Date:   Tue Jun 12 11:20:19 2012 +0800

    ACPI, APEI, Avoid too much error reporting in runtime
    
    This patch fixed the following bug.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=43282
    
    This is caused by a firmware bug checking (checking generic address
    register provided by firmware) in runtime.  The checking should be
    done in address mapping time instead of runtime to avoid too much
    error reporting in runtime.
    
    Reported-by: Pawel Sikora <pluto@agmk.net>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Tested-by: Jean Delvare <khali@linux-fr.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/apei/apei-internal.h b/drivers/acpi/apei/apei-internal.h
index cca240a33038..f220d642136e 100644
--- a/drivers/acpi/apei/apei-internal.h
+++ b/drivers/acpi/apei/apei-internal.h
@@ -7,6 +7,8 @@
 #define APEI_INTERNAL_H
 
 #include <linux/cper.h>
+#include <linux/acpi.h>
+#include <linux/acpi_io.h>
 
 struct apei_exec_context;
 
@@ -68,6 +70,13 @@ static inline int apei_exec_run_optional(struct apei_exec_context *ctx, u8 actio
 /* IP has been set in instruction function */
 #define APEI_EXEC_SET_IP	1
 
+int apei_map_generic_address(struct acpi_generic_address *reg);
+
+static inline void apei_unmap_generic_address(struct acpi_generic_address *reg)
+{
+	acpi_os_unmap_generic_address(reg);
+}
+
 int apei_read(u64 *val, struct acpi_generic_address *reg);
 int apei_write(u64 val, struct acpi_generic_address *reg);
 

commit 700130b41f4ee54520ac2ef2f7f1d072789711a4
Author: Myron Stowe <mstowe@redhat.com>
Date:   Mon Nov 7 16:23:41 2011 -0700

    ACPI APEI: Convert atomicio routines
    
    APEI needs memory access in interrupt context.  The obvious choice is
    acpi_read(), but originally it couldn't be used in interrupt context
    because it makes temporary mappings with ioremap().  Therefore, we added
    drivers/acpi/atomicio.c, which provides:
        acpi_pre_map_gar()     -- ioremap in process context
            acpi_atomic_read()     -- memory access in interrupt context
            acpi_post_unmap_gar()  -- iounmap
    
    Later we added acpi_os_map_generic_address() (2971852) and enhanced
    acpi_read() so it works in interrupt context as long as the address has
    been previously mapped (620242a).  Now this sequence:
        acpi_os_map_generic_address()    -- ioremap in process context
        acpi_read()/apei_read()          -- now OK in interrupt context
        acpi_os_unmap_generic_address()
    is equivalent to what atomicio.c provides.
    
    This patch introduces apei_read() and apei_write(), which currently are
    functional equivalents of acpi_read() and acpi_write().  This is mainly
    proactive, to prevent APEI breakages if acpi_read() and acpi_write()
    are ever augmented to support the 'bit_offset' field of GAS, as APEI's
    __apei_exec_write_register() precludes splitting up functionality
    related to 'bit_offset' and APEI's 'mask' (see its
    APEI_EXEC_PRESERVE_REGISTER block).
    
    With apei_read() and apei_write() in place, usages of atomicio routines
    are converted to apei_read()/apei_write() and existing calls within
    osl.c and the CA, based on the re-factoring that was done in an earlier
    patch series - http://marc.info/?l=linux-acpi&m=128769263327206&w=2:
        acpi_pre_map_gar()     -->  acpi_os_map_generic_address()
        acpi_post_unmap_gar()  -->  acpi_os_unmap_generic_address()
        acpi_atomic_read()     -->  apei_read()
        acpi_atomic_write()    -->  apei_write()
    
    Note that acpi_read() and acpi_write() currently use 'bit_width'
    for accessing GARs which seems incorrect.  'bit_width' is the size of
    the register, while 'access_width' is the size of the access the
    processor must generate on the bus.  The 'access_width' may be larger,
    for example, if the hardware only supports 32-bit or 64-bit reads.  I
    wanted to minimize any possible impacts with this patch series so I
    did *not* change this behavior.
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/apei/apei-internal.h b/drivers/acpi/apei/apei-internal.h
index d778edd34fba..cca240a33038 100644
--- a/drivers/acpi/apei/apei-internal.h
+++ b/drivers/acpi/apei/apei-internal.h
@@ -68,6 +68,9 @@ static inline int apei_exec_run_optional(struct apei_exec_context *ctx, u8 actio
 /* IP has been set in instruction function */
 #define APEI_EXEC_SET_IP	1
 
+int apei_read(u64 *val, struct acpi_generic_address *reg);
+int apei_write(u64 val, struct acpi_generic_address *reg);
+
 int __apei_exec_read_register(struct acpi_whea_header *entry, u64 *val);
 int __apei_exec_write_register(struct acpi_whea_header *entry, u64 val);
 int apei_exec_read_register(struct apei_exec_context *ctx,

commit fdea163d8c17ba08814142259a467ba3e899010d
Author: Huang Ying <ying.huang@intel.com>
Date:   Thu Dec 8 11:25:47 2011 +0800

    ACPI, APEI, EINJ, Fix resource conflict on some machine
    
    Some APEI firmware implementation will access injected address
    specified in param1 to trigger the error when injecting memory error.
    This will cause resource conflict with RAM.
    
    On one of our testing machine, if injecting at memory address
    0x10000000, the following error will be reported in dmesg:
    
      APEI: Can not request iomem region <0000000010000000-0000000010000008> for GARs.
    
    This patch removes the injecting memory address range from trigger
    table resources to avoid conflict.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Tested-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/apei/apei-internal.h b/drivers/acpi/apei/apei-internal.h
index f57050e7a5e7..d778edd34fba 100644
--- a/drivers/acpi/apei/apei-internal.h
+++ b/drivers/acpi/apei/apei-internal.h
@@ -95,6 +95,9 @@ static inline void apei_resources_init(struct apei_resources *resources)
 }
 
 void apei_resources_fini(struct apei_resources *resources);
+int apei_resources_add(struct apei_resources *resources,
+		       unsigned long start, unsigned long size,
+		       bool iomem);
 int apei_resources_sub(struct apei_resources *resources1,
 		       struct apei_resources *resources2);
 int apei_resources_request(struct apei_resources *resources,

commit 9fb0bfe1408d5506b7b83d13d1eed573fd71d67d
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Jul 13 13:14:21 2011 +0800

    ACPI, APEI, Add WHEA _OSC support
    
    APEI firmware first mode must be turned on explicitly on some
    machines, otherwise there may be no GHES hardware error record for
    hardware error notification.  APEI bit in generic _OSC call can be
    used to do that, but on some machine, a special WHEA _OSC call must be
    used.  This patch adds the support to that WHEA _OSC call.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Reviewed-by: Andi Kleen <ak@linux.intel.com>
    Reviewed-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/apei/apei-internal.h b/drivers/acpi/apei/apei-internal.h
index f286cf753f32..f57050e7a5e7 100644
--- a/drivers/acpi/apei/apei-internal.h
+++ b/drivers/acpi/apei/apei-internal.h
@@ -124,4 +124,6 @@ void apei_estatus_print(const char *pfx,
 			const struct acpi_hest_generic_status *estatus);
 int apei_estatus_check_header(const struct acpi_hest_generic_status *estatus);
 int apei_estatus_check(const struct acpi_hest_generic_status *estatus);
+
+int apei_osc_setup(void);
 #endif

commit eecf2f7124834dd1cad21807526a8ea031ba8217
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Jul 13 13:14:16 2011 +0800

    ACPI, APEI, Add apei_exec_run_optional
    
    Some actions in APEI ERST and EINJ tables are optional, for example,
    ACPI_EINJ_BEGIN_OPERATION action is used to do some preparation for
    error injection, and firmware may choose to do nothing here.  While
    some other actions are mandatory, for example, firmware must provide
    ACPI_EINJ_GET_ERROR_TYPE implementation.
    
    Original implementation treats all actions as optional (that is, can
    have no instructions), that may cause issue if firmware does not
    provide some mandatory actions.  To fix this, this patch adds
    apei_exec_run_optional, which should be used for optional actions.
    The original apei_exec_run should be used for mandatory actions.
    
    Cc: Thomas Renninger <trenn@novell.com>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/apei/apei-internal.h b/drivers/acpi/apei/apei-internal.h
index ef0581f2094d..f286cf753f32 100644
--- a/drivers/acpi/apei/apei-internal.h
+++ b/drivers/acpi/apei/apei-internal.h
@@ -50,7 +50,18 @@ static inline u64 apei_exec_ctx_get_output(struct apei_exec_context *ctx)
 	return ctx->value;
 }
 
-int apei_exec_run(struct apei_exec_context *ctx, u8 action);
+int __apei_exec_run(struct apei_exec_context *ctx, u8 action, bool optional);
+
+static inline int apei_exec_run(struct apei_exec_context *ctx, u8 action)
+{
+	return __apei_exec_run(ctx, action, 0);
+}
+
+/* It is optional whether the firmware provides the action */
+static inline int apei_exec_run_optional(struct apei_exec_context *ctx, u8 action)
+{
+	return __apei_exec_run(ctx, action, 1);
+}
 
 /* Common instruction implementation */
 

commit f59c55d04b43bd72df8efa692dd07224fe94d1ac
Author: Huang Ying <ying.huang@intel.com>
Date:   Tue Dec 7 10:22:30 2010 +0800

    ACPI, APEI, Add APEI generic error status printing support
    
    In APEI, Hardware error information reported by firmware to Linux
    kernel is in the data structure of APEI generic error status (struct
    acpi_hes_generic_status).  While now printk is used by Linux kernel to
    report hardware error information to user space.
    
    So, this patch adds printing support for the data structure, so that
    the corresponding hardware error information can be reported to user
    space via printk.
    
    PCIe AER information printing is not implemented yet.  Will refactor the
    original PCIe AER information printing code to avoid code duplicating.
    
    The output format is as follow:
    
    <error record> :=
    APEI generic hardware error status
    severity: <integer>, <severity string>
    section: <integer>, severity: <integer>, <severity string>
    flags: <integer>
    <section flags strings>
    fru_id: <uuid string>
    fru_text: <string>
    section_type: <section type string>
    <section data>
    
    <severity string>* := recoverable | fatal | corrected | info
    
    <section flags strings># :=
    [primary][, containment warning][, reset][, threshold exceeded]\
    [, resource not accessible][, latent error]
    
    <section type string> := generic processor error | memory error | \
    PCIe error | unknown, <uuid string>
    
    <section data> :=
    <generic processor section data> | <memory section data> | \
    <pcie section data> | <null>
    
    <generic processor section data> :=
    [processor_type: <integer>, <proc type string>]
    [processor_isa: <integer>, <proc isa string>]
    [error_type: <integer>
    <proc error type strings>]
    [operation: <integer>, <proc operation string>]
    [flags: <integer>
    <proc flags strings>]
    [level: <integer>]
    [version_info: <integer>]
    [processor_id: <integer>]
    [target_address: <integer>]
    [requestor_id: <integer>]
    [responder_id: <integer>]
    [IP: <integer>]
    
    <proc type string>* := IA32/X64 | IA64
    
    <proc isa string>* := IA32 | IA64 | X64
    
    <processor error type strings># :=
    [cache error][, TLB error][, bus error][, micro-architectural error]
    
    <proc operation string>* := unknown or generic | data read | data write | \
    instruction execution
    
    <proc flags strings># :=
    [restartable][, precise IP][, overflow][, corrected]
    
    <memory section data> :=
    [error_status: <integer>]
    [physical_address: <integer>]
    [physical_address_mask: <integer>]
    [node: <integer>]
    [card: <integer>]
    [module: <integer>]
    [bank: <integer>]
    [device: <integer>]
    [row: <integer>]
    [column: <integer>]
    [bit_position: <integer>]
    [requestor_id: <integer>]
    [responder_id: <integer>]
    [target_id: <integer>]
    [error_type: <integer>, <mem error type string>]
    
    <mem error type string>* :=
    unknown | no error | single-bit ECC | multi-bit ECC | \
    single-symbol chipkill ECC | multi-symbol chipkill ECC | master abort | \
    target abort | parity error | watchdog timeout | invalid address | \
    mirror Broken | memory sparing | scrub corrected error | \
    scrub uncorrected error
    
    <pcie section data> :=
    [port_type: <integer>, <pcie port type string>]
    [version: <integer>.<integer>]
    [command: <integer>, status: <integer>]
    [device_id: <integer>:<integer>:<integer>.<integer>
    slot: <integer>
    secondary_bus: <integer>
    vendor_id: <integer>, device_id: <integer>
    class_code: <integer>]
    [serial number: <integer>, <integer>]
    [bridge: secondary_status: <integer>, control: <integer>]
    
    <pcie port type string>* := PCIe end point | legacy PCI end point | \
    unknown | unknown | root port | upstream switch port | \
    downstream switch port | PCIe to PCI/PCI-X bridge | \
    PCI/PCI-X to PCIe bridge | root complex integrated endpoint device | \
    root complex event collector
    
    Where, [] designate corresponding content is optional
    
    All <field string> description with * has the following format:
    
    field: <integer>, <field string>
    
    Where value of <integer> should be the position of "string" in <field
    string> description. Otherwise, <field string> will be "unknown".
    
    All <field strings> description with # has the following format:
    
    field: <integer>
    <field strings>
    
    Where each string in <fields strings> corresponding to one set bit of
    <integer>. The bit position is the position of "string" in <field
    strings> description.
    
    For more detailed explanation of every field, please refer to UEFI
    specification version 2.3 or later, section Appendix N: Common
    Platform Error Record.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/apei/apei-internal.h b/drivers/acpi/apei/apei-internal.h
index 18df1e940276..ef0581f2094d 100644
--- a/drivers/acpi/apei/apei-internal.h
+++ b/drivers/acpi/apei/apei-internal.h
@@ -109,6 +109,8 @@ static inline u32 apei_estatus_len(struct acpi_hest_generic_status *estatus)
 		return sizeof(*estatus) + estatus->data_length;
 }
 
+void apei_estatus_print(const char *pfx,
+			const struct acpi_hest_generic_status *estatus);
 int apei_estatus_check_header(const struct acpi_hest_generic_status *estatus);
 int apei_estatus_check(const struct acpi_hest_generic_status *estatus);
 #endif

commit 06d65deade9aabba58e0518df86dcd324e86b832
Author: Huang Ying <ying.huang@intel.com>
Date:   Tue May 18 14:35:19 2010 +0800

    ACPI, APEI, UEFI Common Platform Error Record (CPER) header
    
    CPER stands for Common Platform Error Record, it is the hardware error
    record format used to describe platform hardware error by various APEI
    tables, such as ERST, BERT and HEST etc.
    
    For more information about CPER, please refer to Appendix N of UEFI
    Specification version 2.3.
    
    This patch mainly includes the data structure difinition header file
    used by other files.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/apei/apei-internal.h b/drivers/acpi/apei/apei-internal.h
index 86e041a42c44..18df1e940276 100644
--- a/drivers/acpi/apei/apei-internal.h
+++ b/drivers/acpi/apei/apei-internal.h
@@ -6,6 +6,8 @@
 #ifndef APEI_INTERNAL_H
 #define APEI_INTERNAL_H
 
+#include <linux/cper.h>
+
 struct apei_exec_context;
 
 typedef int (*apei_exec_ins_func_t)(struct apei_exec_context *ctx,
@@ -92,4 +94,21 @@ int apei_exec_collect_resources(struct apei_exec_context *ctx,
 
 struct dentry;
 struct dentry *apei_get_debugfs_dir(void);
+
+#define apei_estatus_for_each_section(estatus, section)			\
+	for (section = (struct acpi_hest_generic_data *)(estatus + 1);	\
+	     (void *)section - (void *)estatus < estatus->data_length;	\
+	     section = (void *)(section+1) + section->error_data_length)
+
+static inline u32 apei_estatus_len(struct acpi_hest_generic_status *estatus)
+{
+	if (estatus->raw_data_length)
+		return estatus->raw_data_offset + \
+			estatus->raw_data_length;
+	else
+		return sizeof(*estatus) + estatus->data_length;
+}
+
+int apei_estatus_check_header(const struct acpi_hest_generic_status *estatus);
+int apei_estatus_check(const struct acpi_hest_generic_status *estatus);
 #endif

commit a643ce207f3e70030bdb431e2a363cc111a60c1a
Author: Huang Ying <ying.huang@intel.com>
Date:   Tue May 18 14:35:12 2010 +0800

    ACPI, APEI, APEI supporting infrastructure
    
    APEI stands for ACPI Platform Error Interface, which allows to report
    errors (for example from the chipset) to the operating system. This
    improves NMI handling especially. In addition it supports error
    serialization and error injection.
    
    For more information about APEI, please refer to ACPI Specification
    version 4.0, chapter 17.
    
    This patch provides some common functions used by more than one APEI
    tables, mainly framework of interpreter for EINJ and ERST.
    
    A machine readable language is defined for EINJ and ERST for OS to
    execute, and so to drive the firmware to fulfill the corresponding
    functions. The machine language for EINJ and ERST is compatible, so a
    common framework is defined for them.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/apei/apei-internal.h b/drivers/acpi/apei/apei-internal.h
new file mode 100644
index 000000000000..86e041a42c44
--- /dev/null
+++ b/drivers/acpi/apei/apei-internal.h
@@ -0,0 +1,95 @@
+/*
+ * apei-internal.h - ACPI Platform Error Interface internal
+ * definations.
+ */
+
+#ifndef APEI_INTERNAL_H
+#define APEI_INTERNAL_H
+
+struct apei_exec_context;
+
+typedef int (*apei_exec_ins_func_t)(struct apei_exec_context *ctx,
+				    struct acpi_whea_header *entry);
+
+#define APEI_EXEC_INS_ACCESS_REGISTER	0x0001
+
+struct apei_exec_ins_type {
+	u32 flags;
+	apei_exec_ins_func_t run;
+};
+
+struct apei_exec_context {
+	u32 ip;
+	u64 value;
+	u64 var1;
+	u64 var2;
+	u64 src_base;
+	u64 dst_base;
+	struct apei_exec_ins_type *ins_table;
+	u32 instructions;
+	struct acpi_whea_header *action_table;
+	u32 entries;
+};
+
+void apei_exec_ctx_init(struct apei_exec_context *ctx,
+			struct apei_exec_ins_type *ins_table,
+			u32 instructions,
+			struct acpi_whea_header *action_table,
+			u32 entries);
+
+static inline void apei_exec_ctx_set_input(struct apei_exec_context *ctx,
+					   u64 input)
+{
+	ctx->value = input;
+}
+
+static inline u64 apei_exec_ctx_get_output(struct apei_exec_context *ctx)
+{
+	return ctx->value;
+}
+
+int apei_exec_run(struct apei_exec_context *ctx, u8 action);
+
+/* Common instruction implementation */
+
+/* IP has been set in instruction function */
+#define APEI_EXEC_SET_IP	1
+
+int __apei_exec_read_register(struct acpi_whea_header *entry, u64 *val);
+int __apei_exec_write_register(struct acpi_whea_header *entry, u64 val);
+int apei_exec_read_register(struct apei_exec_context *ctx,
+			    struct acpi_whea_header *entry);
+int apei_exec_read_register_value(struct apei_exec_context *ctx,
+				  struct acpi_whea_header *entry);
+int apei_exec_write_register(struct apei_exec_context *ctx,
+			     struct acpi_whea_header *entry);
+int apei_exec_write_register_value(struct apei_exec_context *ctx,
+				   struct acpi_whea_header *entry);
+int apei_exec_noop(struct apei_exec_context *ctx,
+		   struct acpi_whea_header *entry);
+int apei_exec_pre_map_gars(struct apei_exec_context *ctx);
+int apei_exec_post_unmap_gars(struct apei_exec_context *ctx);
+
+struct apei_resources {
+	struct list_head iomem;
+	struct list_head ioport;
+};
+
+static inline void apei_resources_init(struct apei_resources *resources)
+{
+	INIT_LIST_HEAD(&resources->iomem);
+	INIT_LIST_HEAD(&resources->ioport);
+}
+
+void apei_resources_fini(struct apei_resources *resources);
+int apei_resources_sub(struct apei_resources *resources1,
+		       struct apei_resources *resources2);
+int apei_resources_request(struct apei_resources *resources,
+			   const char *desc);
+void apei_resources_release(struct apei_resources *resources);
+int apei_exec_collect_resources(struct apei_exec_context *ctx,
+				struct apei_resources *resources);
+
+struct dentry;
+struct dentry *apei_get_debugfs_dir(void);
+#endif
