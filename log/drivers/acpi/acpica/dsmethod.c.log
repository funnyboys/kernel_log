commit 800ba7c5eaaa734e4bd66bf0441fc200bbcdca54
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 10 11:31:49 2020 -0800

    ACPICA: All acpica: Update copyrights to 2020 Including tool signons.
    
    ACPICA commit 8b9c69d0984067051ffbe8526f871448ead6a26b
    
    Link: https://github.com/acpica/acpica/commit/8b9c69d0
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Kaneda <erik.kaneda@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index f59b4d944f7f..cf67caff878a 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -3,7 +3,7 @@
  *
  * Module Name: dsmethod - Parser/Interpreter interface - control method parsing
  *
- * Copyright (C) 2000 - 2019, Intel Corp.
+ * Copyright (C) 2000 - 2020, Intel Corp.
  *
  *****************************************************************************/
 

commit 840c02ca2215af648c781ae680d93d8aecd083b7
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jan 14 09:55:25 2019 -0800

    ACPICA: All acpica: Update copyrights to 2019
    
    ACPICA commit 62f4f98e941d86e41969bf2ab5a93b8dc94dc49e
    
    The update includes userspace tool signons.
    
    Link: https://github.com/acpica/acpica/commit/62f4f98e
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index c1a4d02fafd5..f59b4d944f7f 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -3,7 +3,7 @@
  *
  * Module Name: dsmethod - Parser/Interpreter interface - control method parsing
  *
- * Copyright (C) 2000 - 2018, Intel Corp.
+ * Copyright (C) 2000 - 2019, Intel Corp.
  *
  *****************************************************************************/
 

commit 4c1379d7bb42fa664e0784539208ed74108c53f1
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Dec 13 12:30:33 2018 -0800

    ACPICA: Debug output: Add option to display method/object evaluation
    
    Adds entry/exit messages for all objects that are evaluated.
    Works for the kernel-level code as well as acpiexec. The "-eo"
    flag enables acpiexec to display these messages.
    
    The messages are very useful when debugging the flow of table
    initialization.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index dd4deb678d13..c1a4d02fafd5 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -532,6 +532,9 @@ acpi_ds_call_control_method(struct acpi_thread_state *thread,
 		goto cleanup;
 	}
 
+	next_walk_state->method_nesting_depth =
+	    this_walk_state->method_nesting_depth + 1;
+
 	/*
 	 * Delete the operands on the previous walkstate operand stack
 	 * (they were copied to new objects)
@@ -549,6 +552,17 @@ acpi_ds_call_control_method(struct acpi_thread_state *thread,
 			  "**** Begin nested execution of [%4.4s] **** WalkState=%p\n",
 			  method_node->name.ascii, next_walk_state));
 
+	this_walk_state->method_pathname =
+	    acpi_ns_get_normalized_pathname(method_node, TRUE);
+	this_walk_state->method_is_nested = TRUE;
+
+	/* Optional object evaluation log */
+
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_EVALUATION,
+			      "%-26s:  %*s%s\n", "   Nested method call",
+			      next_walk_state->method_nesting_depth * 3, " ",
+			      &this_walk_state->method_pathname[1]));
+
 	/* Invoke an internal method if necessary */
 
 	if (obj_desc->method.info_flags & ACPI_METHOD_INTERNAL_ONLY) {

commit 95857638889aeea1b10a16b55041adf3e3ab84c4
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Wed Mar 14 16:13:07 2018 -0700

    ACPICA: adding SPDX headers
    
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index b9c460c2d763..dd4deb678d13 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -1,45 +1,11 @@
+// SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
 /******************************************************************************
  *
  * Module Name: dsmethod - Parser/Interpreter interface - control method parsing
  *
- *****************************************************************************/
-
-/*
  * Copyright (C) 2000 - 2018, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
+ *
+ *****************************************************************************/
 
 #include <acpi/acpi.h>
 #include "accommon.h"

commit da6f8320d58623eae9b6fa2f09b1b4f60a772ce9
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 4 10:06:38 2018 -0800

    ACPICA: All acpica: Update copyrights to 2018
    
    including tool signons.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index d7fc36917c67..b9c460c2d763 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2017, Intel Corp.
+ * Copyright (C) 2000 - 2018, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit fd13aaa850d6db06f90687486163d0dc609f2318
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jun 5 16:42:23 2017 +0800

    ACPICA: acpiexec: enhance local signal handler
    
    ACPICA commit ffef4ae9a1b6032ebadeab2c2b806f0e585f0006
    
    Add support for SIGSEGV
    Improve/cleanup SIGINT handling
    
    Link: https://github.com/acpica/acpica/commit/ffef4ae9
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 31c9c7aec3d5..d7fc36917c67 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -212,6 +212,7 @@ acpi_status
 acpi_ds_method_error(acpi_status status, struct acpi_walk_state *walk_state)
 {
 	u32 aml_offset;
+	acpi_name name = 0;
 
 	ACPI_FUNCTION_ENTRY();
 
@@ -237,10 +238,13 @@ acpi_ds_method_error(acpi_status status, struct acpi_walk_state *walk_state)
 						walk_state->parser_state.
 						aml_start);
 
-		status = acpi_gbl_exception_handler(status,
-						    walk_state->method_node ?
-						    walk_state->method_node->
-						    name.integer : 0,
+		if (walk_state->method_node) {
+			name = walk_state->method_node->name.integer;
+		} else if (walk_state->deferred_node) {
+			name = walk_state->deferred_node->name.integer;
+		}
+
+		status = acpi_gbl_exception_handler(status, name,
 						    walk_state->opcode,
 						    aml_offset, NULL);
 		acpi_ex_enter_interpreter();

commit 7735ca0eb4ebd6d47fdad40602d0ba7593219f8c
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Feb 8 11:00:08 2017 +0800

    ACPICA: Source tree: Update copyright notices to 2017
    
    ACPICA commit 16577e5265923f4999b4d2c0addb2343b18135e1
    
    Affects all files.
    
    Link: https://github.com/acpica/acpica/commit/16577e52
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 2b3210f42a46..31c9c7aec3d5 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2016, Intel Corp.
+ * Copyright (C) 2000 - 2017, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 8633db6b027952449e155a316f4ae3a530bbe18f
Author: Lv Zheng <zetalog@gmail.com>
Date:   Wed Oct 26 15:42:01 2016 +0800

    ACPICA: Dispatcher: Fix interpreter locking around acpi_ev_initialize_region()
    
    In the code path of acpi_ev_initialize_region(), there is namespace
    modification code unlocked. This patch tunes the code to make sure
    such modification are always locked.
    
    Fixes: 74f51b80a0c4 (ACPICA: Namespace: Fix dynamic table loading issues)
    Tested-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 5997e592e5a6..2b3210f42a46 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -99,14 +99,11 @@ acpi_ds_auto_serialize_method(struct acpi_namespace_node *node,
 			  "Method auto-serialization parse [%4.4s] %p\n",
 			  acpi_ut_get_node_name(node), node));
 
-	acpi_ex_enter_interpreter();
-
 	/* Create/Init a root op for the method parse tree */
 
 	op = acpi_ps_alloc_op(AML_METHOD_OP, obj_desc->method.aml_start);
 	if (!op) {
-		status = AE_NO_MEMORY;
-		goto unlock;
+		return_ACPI_STATUS(AE_NO_MEMORY);
 	}
 
 	acpi_ps_set_name(op, node->name.integer);
@@ -118,8 +115,7 @@ acpi_ds_auto_serialize_method(struct acpi_namespace_node *node,
 	    acpi_ds_create_walk_state(node->owner_id, NULL, NULL, NULL);
 	if (!walk_state) {
 		acpi_ps_free_op(op);
-		status = AE_NO_MEMORY;
-		goto unlock;
+		return_ACPI_STATUS(AE_NO_MEMORY);
 	}
 
 	status = acpi_ds_init_aml_walk(walk_state, op, node,
@@ -128,7 +124,7 @@ acpi_ds_auto_serialize_method(struct acpi_namespace_node *node,
 	if (ACPI_FAILURE(status)) {
 		acpi_ds_delete_walk_state(walk_state);
 		acpi_ps_free_op(op);
-		goto unlock;
+		return_ACPI_STATUS(status);
 	}
 
 	walk_state->descending_callback = acpi_ds_detect_named_opcodes;
@@ -138,8 +134,6 @@ acpi_ds_auto_serialize_method(struct acpi_namespace_node *node,
 	status = acpi_ps_parse_aml(walk_state);
 
 	acpi_ps_delete_parse_tree(op);
-unlock:
-	acpi_ex_exit_interpreter();
 	return_ACPI_STATUS(status);
 }
 

commit 8121aa26e32012ca89afafa5e503b879950ac0fe
Author: Lv Zheng <zetalog@gmail.com>
Date:   Wed Oct 26 15:40:20 2016 +0800

    ACPICA: Dispatcher: Fix an unbalanced lock exit path in acpi_ds_auto_serialize_method()
    
    There is a lock unbalanced exit path in acpi_ds_initialize_method(),
    this patch corrects it.
    
    Fixes: 441ad11d078f (ACPICA: Dispatcher: Fix a mutex issue for method auto serialization)
    Tested-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index c4028a8dacd5..5997e592e5a6 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -128,7 +128,7 @@ acpi_ds_auto_serialize_method(struct acpi_namespace_node *node,
 	if (ACPI_FAILURE(status)) {
 		acpi_ds_delete_walk_state(walk_state);
 		acpi_ps_free_op(op);
-		return_ACPI_STATUS(status);
+		goto unlock;
 	}
 
 	walk_state->descending_callback = acpi_ds_detect_named_opcodes;

commit 25ccd2429fd0af5b9c2c136c8c593491aeabf162
Author: Lv Zheng <zetalog@gmail.com>
Date:   Wed Oct 26 15:40:12 2016 +0800

    ACPICA: Dispatcher: Fix order issue of method termination
    
    The last step of the method termination should be the end of the method
    serialization. Otherwise, the steps happening after it will face the race
    issues that cannot be protected by the method serialization mechanism.
    
    This patch fixes this issue by moving the per-method-object deletion code
    prior than the end of the method serialization. Otherwise, the possible
    race issues may result in AE_ALREADY_EXISTS error in a parallel
    environment.
    
    Fixes: 74f51b80a0c4 (ACPICA: Namespace: Fix dynamic table loading issues)
    Reported-and-tested-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 32e9ddc0cf2b..c4028a8dacd5 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -730,26 +730,6 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 
 		acpi_ds_method_data_delete_all(walk_state);
 
-		/*
-		 * If method is serialized, release the mutex and restore the
-		 * current sync level for this thread
-		 */
-		if (method_desc->method.mutex) {
-
-			/* Acquisition Depth handles recursive calls */
-
-			method_desc->method.mutex->mutex.acquisition_depth--;
-			if (!method_desc->method.mutex->mutex.acquisition_depth) {
-				walk_state->thread->current_sync_level =
-				    method_desc->method.mutex->mutex.
-				    original_sync_level;
-
-				acpi_os_release_mutex(method_desc->method.
-						      mutex->mutex.os_mutex);
-				method_desc->method.mutex->mutex.thread_id = 0;
-			}
-		}
-
 		/*
 		 * Delete any namespace objects created anywhere within the
 		 * namespace by the execution of this method. Unless:
@@ -786,6 +766,26 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 				    ~ACPI_METHOD_MODIFIED_NAMESPACE;
 			}
 		}
+
+		/*
+		 * If method is serialized, release the mutex and restore the
+		 * current sync level for this thread
+		 */
+		if (method_desc->method.mutex) {
+
+			/* Acquisition Depth handles recursive calls */
+
+			method_desc->method.mutex->mutex.acquisition_depth--;
+			if (!method_desc->method.mutex->mutex.acquisition_depth) {
+				walk_state->thread->current_sync_level =
+				    method_desc->method.mutex->mutex.
+				    original_sync_level;
+
+				acpi_os_release_mutex(method_desc->method.
+						      mutex->mutex.os_mutex);
+				method_desc->method.mutex->mutex.thread_id = 0;
+			}
+		}
 	}
 
 	/* Decrement the thread count on the method */

commit 441ad11d078f35093ceaf510742df423c2d89a3b
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Sep 7 14:07:16 2016 +0800

    ACPICA: Dispatcher: Fix a mutex issue for method auto serialization
    
    ACPICA commit fd305eda14f1a1e684edef4fac53f194bf00ed3f
    
    This patch fixes an issue with acpi_ds_auto_serialized_method().
    The parser will invoke acpi_ex_release_all_mutexes(), which in return
    cause mutexes held in ACPI_ERROR_METHOD() failed. Lv Zheng.
    
    Link: https://bugs.acpica.org/show_bug.cgi?id=1324
    Link: https://github.com/acpica/acpica/commit/fd305eda
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Greg White <gwhite@kupulau.com>
    Tested-by: Dutch Guy <lucht_piloot@gmx.net>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 25b387a6d8be..32e9ddc0cf2b 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -99,11 +99,14 @@ acpi_ds_auto_serialize_method(struct acpi_namespace_node *node,
 			  "Method auto-serialization parse [%4.4s] %p\n",
 			  acpi_ut_get_node_name(node), node));
 
+	acpi_ex_enter_interpreter();
+
 	/* Create/Init a root op for the method parse tree */
 
 	op = acpi_ps_alloc_op(AML_METHOD_OP, obj_desc->method.aml_start);
 	if (!op) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
+		status = AE_NO_MEMORY;
+		goto unlock;
 	}
 
 	acpi_ps_set_name(op, node->name.integer);
@@ -115,7 +118,8 @@ acpi_ds_auto_serialize_method(struct acpi_namespace_node *node,
 	    acpi_ds_create_walk_state(node->owner_id, NULL, NULL, NULL);
 	if (!walk_state) {
 		acpi_ps_free_op(op);
-		return_ACPI_STATUS(AE_NO_MEMORY);
+		status = AE_NO_MEMORY;
+		goto unlock;
 	}
 
 	status = acpi_ds_init_aml_walk(walk_state, op, node,
@@ -134,6 +138,8 @@ acpi_ds_auto_serialize_method(struct acpi_namespace_node *node,
 	status = acpi_ps_parse_aml(walk_state);
 
 	acpi_ps_delete_parse_tree(op);
+unlock:
+	acpi_ex_exit_interpreter();
 	return_ACPI_STATUS(status);
 }
 

commit 74f51b80a0c4ff84fbeb7f12ea43ce66934d29aa
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Sep 7 14:07:10 2016 +0800

    ACPICA: Namespace: Fix dynamic table loading issues
    
    ACPICA commit 767ee53354e0c4b7e8e7c57c6dd7bf569f0d52bb
    
    There are issues related to the namespace/interpreter locks, which causes
    several ACPI functionalities not specification compliant. The lock issues
    were detectec when we were trying to fix the functionalities (please see
    Link # [1] for the details).
    
    What's the lock issues? Let's first look into the namespace/interpreter
    lock usages inside of the object evaluation and the table loading which are
    the key AML interpretion code paths:
    Table loading:
    acpi_ns_load_table
            L(Namespace)
            acpi_ns_parse_table
                    acpi_ns_one_complete_parse(LOAD_PASS1/LOAD_PASS2)
                            acpi_ds_load1_begion_op
                            acpi_ds_load1_end_op
                            acpi_ds_load2_begion_op
                            acpi_ds_load2_end_op
            U(Namespace)
    Object evaluation:
    acpi_ns_evaluate
            L(Interpreter)
            acpi_ps_execute_method
                    acpi_ds_exec_begin_op
                    acpi_ds_exec_end_op
                            U(Interpreter)
                            acpi_ns_load_table
                                    L(Namespace)
                                    U(Namespace)
                            acpi_ev_initialize_region
                                    L(Namespace)
                                    U(Namespace)
                            address_space.Setup
                            address_space.Handler
                            acpi_os_wait_semaphore
                            acpi_os_acquire_mutex
                            acpi_os_sleep
                            L(Interpreter)
            U(Interpreter)
            L(Interpreter)
            acpi_ex_resolve_node_to_value
            U(Interpreter)
            acpi_ns_check_return_value
    Where:
      1. L(Interpreter) means acquire(MTX_INTERPRETER);
      2. U(Interpreter) means release(MTX_INTERPRETER);
      3. L(Namespace) means acquire(MTX_NAMESPACE);
      4. U(Namespace) means release(MTX_NAMESPACE);
    
    We can see that acpi_ns_exec_module_code() (which invokes acpi_ns_evaluate) is
    implemented in a deferred way just in order to avoid to reacquire the
    namespace lock. This is in fact the root cause of many other ACPICA issues:
    1. We now know for sure that the module code should be executed right in
       place by the Windows AML interpreter. So in the current design, if
       the region initializations/accesses or the table loadings (where the
       namespace surely should be locked again) happening during the table
       loading period, dead lock could happen because ACPICA never unlocks the
       namespace during the AML interpretion.
    2. ACPICA interpreter just ensures that all static namespace nodes (named
       objects created during the acpi_load_tables()) are created
       (acpi_ns_lookup()) with the correct lock held, but doesn't ensure that
       the named objects created by the control method are created with the
       same correct lock held. It requires the control methods to be executed
       in a serial way after "loading a table", that's why ACPICA requires
       method auto serialization.
    
    This patch fixes these software design issues by extending interpreter
    enter/exit APIs to hold both interpreter/namespace locks to ensure the lock
    order correctness, so that we can get these code paths:
    Table loading:
    acpi_ns_load_table
            E(Interpreter)
                    acpi_ns_parse_table
                            acpi_ns_one_complete_parse
                            acpi_ns_execute_table
                                    X(Interpreter)
                                    acpi_ns_load_table
                                    acpi_ev_initialize_region
                                    address_space.Setup
                                    address_space.Handler
                                    acpi_os_wait_semaphore
                                    acpi_os_acquire_mutex
                                    acpi_os_sleep
                                    E(Interpreter)
            X(Interpreter)
    Object evaluation:
    acpi_ns_evaluate
            E(Interpreter)
            acpi_ps_execute_method
                    X(Interpreter)
                    acpi_ns_load_table
                    acpi_ev_initialize_region
                    address_space.Setup
                    address_space.Handler
                    acpi_os_wait_semaphore
                    acpi_os_acquire_mutex
                    acpi_os_sleep
                    E(Interpreter)
            X(Interpreter)
    Where:
      1. E(Interpreter) means acquire(MTX_INTERPRETER, MTX_NAMESPACE);
      2. X(Interpreter) means release(MTX_NAMESPACE, MTX_INTERPRETER);
    
    After this change, we can see:
    1. All namespace nodes creations are locked by the namespace lock.
    2. All namespace nodes referencing are locked with the same lock.
    3. But we also can notice a defact that, all namespace nodes deletions
       could be affected by this change. As a consequence,
       acpi_ns_delete_namespace_subtree() may delete a static namespace node that
       is still referenced by the interpreter (for example, the parser scopes).
    Currently, we needn't worry about the last defact because in ACPICA, table
    unloading is not fully functioning, its design strictly relies on the fact
    that when the namespace deletion happens, either the AML table or the OSPMs
    should have been notified and thus either the AML table or the OSPMs
    shouldn't reference deletion-related namespace nodes during the namespace
    deletion. And this change still works with the above restrictions applied.
    While making this a-step-forward helps us to correct the wrong grammar to
    pull many things back to the correct rail. And pulling things back to the
    correct rail in return makes it possible for us to support fully
    functioning table unloading after doing many cleanups.
    
    While this patch is generated, all namespace locks are examined to ensure
    that they can meet either of the following pattens:
    1. L(Namespace)
       U(Namespace)
    2. E(Interpreter)
       X(Interpreter)
    3. E(Interpreter)
       X(Interpreter)
       L(Namespace)
       U(Namespace)
       E(Interpreter)
       X(Interpreter)
    We ensure this by adding X(Interpreter)/E(Interpreter) or removing
    U(Namespace)/L(Namespace) for those currently are executed in the following
    order:
       E(Interpreter)
       L(Namespace)
       U(Namespace)
       X(Interpreter)
    And adding E(Interpreter)/X(Interpreter) for those currently are executed
    in the following order:
       X(Interpreter)
       E(Interpreter)
    
    Originally, the interpreter lock is held for the execution AML opcodes, the
    namespace lock is held for the named object creation AML opcodes. Since
    they are actually same in MS interpreter (can all be executed during the
    table loading), we can combine the 2 locks and tune the locking code better
    in this way. Lv Zheng.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=153541 # [1]
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=121701 # [1]
    Link: https://bugs.acpica.org/show_bug.cgi?id=1323
    Link: https://github.com/acpica/acpica/commit/767ee533
    Reported-and-tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reported-and-tested-by: Greg White <gwhite@kupulau.com>
    Reported-and-tested-by: Dutch Guy <lucht_piloot@gmx.net>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 47c7b52a519c..25b387a6d8be 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -757,8 +757,10 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 
 			/* Delete any direct children of (created by) this method */
 
+			(void)acpi_ex_exit_interpreter();
 			acpi_ns_delete_namespace_subtree(walk_state->
 							 method_node);
+			(void)acpi_ex_enter_interpreter();
 
 			/*
 			 * Delete any objects that were created by this method
@@ -769,9 +771,11 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 			 */
 			if (method_desc->method.
 			    info_flags & ACPI_METHOD_MODIFIED_NAMESPACE) {
+				(void)acpi_ex_exit_interpreter();
 				acpi_ns_delete_namespace_by_owner(method_desc->
 								  method.
 								  owner_id);
+				(void)acpi_ex_enter_interpreter();
 				method_desc->method.info_flags &=
 				    ~ACPI_METHOD_MODIFIED_NAMESPACE;
 			}

commit d1ce3bb95511dacf8b9eea899c421f1b18a3ef6a
Merge: 93d68841a23a 878a872ead5d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 6 01:41:06 2016 +0200

    Merge back new ACPICA material for v4.7.

commit f5c1e1c5a652e4b43eb9b571577ef72731f3fa8b
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu May 5 12:57:53 2016 +0800

    ACPICA: Divergence: remove unwanted spaces for typedef
    
    ACPICA commit b2294cae776f5a66a7697414b21949d307e6856f
    
    This patch removes unwanted spaces for typedef. This solution doesn't cover
    function types.
    
    Note that the linuxize result of this commit is very giant and should have
    many conflicts against the current Linux upstream. Thus it is required to
    modify the linuxize result of this commit and the commits around it
    manually in order to have them merged to the Linux upstream. Since this is
    very costy, we should do this only once, and if we can't ensure to do this
    only once, we need to revert the Linux code to the wrong indentation result
    before merging the linuxize result of this commit. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/b2294cae
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 1982310e6d83..ddfec05cbb4b 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -209,7 +209,7 @@ acpi_ds_detect_named_opcodes(struct acpi_walk_state *walk_state,
  ******************************************************************************/
 
 acpi_status
-acpi_ds_method_error(acpi_status status, struct acpi_walk_state * walk_state)
+acpi_ds_method_error(acpi_status status, struct acpi_walk_state *walk_state)
 {
 	u32 aml_offset;
 

commit 93d68841a23a5779cef6fb9aa0ef32e7c5bd00da
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Wed May 4 13:48:56 2016 +0800

    ACPICA: Dispatcher: Update thread ID for recursive method calls
    
    ACPICA commit 7a3bd2d962f221809f25ddb826c9e551b916eb25
    
    Set the mutex owner thread ID.
    Original patch from: Prarit Bhargava <prarit@redhat.com>
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=115121
    Link: https://github.com/acpica/acpica/commit/7a3bd2d9
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Tested-by: Andy Lutomirski <luto@kernel.org> # On a Dell XPS 13 9350
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 1982310e6d83..da198b864107 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -428,6 +428,9 @@ acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
 				obj_desc->method.mutex->mutex.
 				    original_sync_level =
 				    obj_desc->method.mutex->mutex.sync_level;
+
+				obj_desc->method.mutex->mutex.thread_id =
+				    acpi_os_get_thread_id();
 			}
 		}
 

commit 05fb04b54f6b67f4eb901e99dd5b4604b46ffa0f
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Feb 19 14:16:42 2016 +0800

    ACPICA: Remove unnecessary arguments to ACPI_INFO
    
    ACPICA commit 181f56605a771e0b91e24b0648d2565ca70bea20
    
    This is used as a purely infomation message, without module name
    and line number information. Therefore, these arguments are
    not needed and they are unnecessary overhead.
    Arguments are removed.
    ACPICA BZ 872.
    
    Link: https://github.com/acpica/acpica/commit/181f5660
    Link: https://bugs.acpica.org/show_bug.cgi?id=872
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 6a72047aae1c..1982310e6d83 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -809,8 +809,7 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 		if (method_desc->method.
 		    info_flags & ACPI_METHOD_SERIALIZED_PENDING) {
 			if (walk_state) {
-				ACPI_INFO((AE_INFO,
-					   "Marking method %4.4s as Serialized "
+				ACPI_INFO(("Marking method %4.4s as Serialized "
 					   "because of AE_ALREADY_EXISTS error",
 					   walk_state->method_node->name.
 					   ascii));

commit c8100dc4643d80a94f074dfc8a2af3d3d327b7aa
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 15 08:17:03 2016 +0800

    ACPICA: Additional 2016 copyright changes
    
    All tool/utility signons.
    Dual-license module header.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 6585e8e37c8e..6a72047aae1c 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2015, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 1fad87385e7e82f656fb661aef0f841e42991974
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Dec 29 13:54:36 2015 +0800

    ACPICA: Core: Major update for code formatting, no functional changes
    
    ACPICA commit dfa394471f6c01b2ee9433dbc143ec70cb9bca72
    
    Mostly indentation inconsistencies across the code. Split
    some long lines, etc.
    
    Link: https://github.com/acpica/acpica/commit/dfa39447
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 49ba082ad379..6585e8e37c8e 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -118,10 +118,9 @@ acpi_ds_auto_serialize_method(struct acpi_namespace_node *node,
 		return_ACPI_STATUS(AE_NO_MEMORY);
 	}
 
-	status =
-	    acpi_ds_init_aml_walk(walk_state, op, node,
-				  obj_desc->method.aml_start,
-				  obj_desc->method.aml_length, NULL, 0);
+	status = acpi_ds_init_aml_walk(walk_state, op, node,
+				       obj_desc->method.aml_start,
+				       obj_desc->method.aml_length, NULL, 0);
 	if (ACPI_FAILURE(status)) {
 		acpi_ds_delete_walk_state(walk_state);
 		acpi_ps_free_op(op);
@@ -375,7 +374,8 @@ acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
 		    && (walk_state->thread->current_sync_level >
 			obj_desc->method.mutex->mutex.sync_level)) {
 			ACPI_ERROR((AE_INFO,
-				    "Cannot acquire Mutex for method [%4.4s], current SyncLevel is too large (%u)",
+				    "Cannot acquire Mutex for method [%4.4s]"
+				    ", current SyncLevel is too large (%u)",
 				    acpi_ut_get_node_name(method_node),
 				    walk_state->thread->current_sync_level));
 
@@ -512,16 +512,18 @@ acpi_ds_call_control_method(struct acpi_thread_state *thread,
 
 	/* Init for new method, possibly wait on method mutex */
 
-	status = acpi_ds_begin_method_execution(method_node, obj_desc,
-						this_walk_state);
+	status =
+	    acpi_ds_begin_method_execution(method_node, obj_desc,
+					   this_walk_state);
 	if (ACPI_FAILURE(status)) {
 		return_ACPI_STATUS(status);
 	}
 
 	/* Begin method parse/execution. Create a new walk state */
 
-	next_walk_state = acpi_ds_create_walk_state(obj_desc->method.owner_id,
-						    NULL, obj_desc, thread);
+	next_walk_state =
+	    acpi_ds_create_walk_state(obj_desc->method.owner_id, NULL, obj_desc,
+				      thread);
 	if (!next_walk_state) {
 		status = AE_NO_MEMORY;
 		goto cleanup;
@@ -808,7 +810,8 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 		    info_flags & ACPI_METHOD_SERIALIZED_PENDING) {
 			if (walk_state) {
 				ACPI_INFO((AE_INFO,
-					   "Marking method %4.4s as Serialized because of AE_ALREADY_EXISTS error",
+					   "Marking method %4.4s as Serialized "
+					   "because of AE_ALREADY_EXISTS error",
 					   walk_state->method_node->name.
 					   ascii));
 			}
@@ -826,6 +829,7 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 			 */
 			method_desc->method.info_flags &=
 			    ~ACPI_METHOD_SERIALIZED_PENDING;
+
 			method_desc->method.info_flags |=
 			    (ACPI_METHOD_SERIALIZED |
 			     ACPI_METHOD_IGNORE_SYNC_LEVEL);

commit 33d3a2abbd7afd51d8dcf1e35756e13e6b89f2cb
Author: David E. Box <david.e.box@linux.intel.com>
Date:   Tue Dec 29 13:53:57 2015 +0800

    ACPICA: Fix SyncLevel support interaction with method auto-serialization
    
    ACPICA commit 253e3c03efc1a495d2aa61eee09ab1d0842a3dce
    
    The control method auto-serialization can interfere with existing
    ASL code that makes use of Mutex/Method SyncLevel support. This
    change makes the auto-serialization transparent to the SyncLevel
    support and management. David Box.
    
    Link: https://github.com/acpica/acpica/commit/253e3c03
    Signed-off-by: David E. Box <david.e.box@linux.intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index bc32f3194afe..49ba082ad379 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -411,8 +411,19 @@ acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
 
 				obj_desc->method.mutex->mutex.thread_id =
 				    walk_state->thread->thread_id;
-				walk_state->thread->current_sync_level =
-				    obj_desc->method.sync_level;
+
+				/*
+				 * Update the current sync_level only if this is not an auto-
+				 * serialized method. In the auto case, we have to ignore
+				 * the sync level for the method mutex (created for the
+				 * auto-serialization) because we have no idea of what the
+				 * sync level should be. Therefore, just ignore it.
+				 */
+				if (!(obj_desc->method.info_flags &
+				      ACPI_METHOD_IGNORE_SYNC_LEVEL)) {
+					walk_state->thread->current_sync_level =
+					    obj_desc->method.sync_level;
+				}
 			} else {
 				obj_desc->method.mutex->mutex.
 				    original_sync_level =

commit fdd8d831cf43761712d28e5d1ad812eab7dc1480
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Jul 23 12:54:17 2015 +0800

    ACPICA: Debugger: Move debugger specific APIs to debugger component
    
    ACPICA commit 2164923d60429eea7cd5a4a8629b607af7325afa
    
    Some disassembler APIs should rather be debugger APIs. This patch moves
    them to the debugger folder to be ready for debugger porting.
    
    Since there is no in-kernel ACPICA debugger in the kernel source tree, this
    patch doesn't affect the Linux kernel.
    
    Link: https://github.com/acpica/acpica/commit/2164923d
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index cb53c44c9644..bc32f3194afe 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -46,11 +46,9 @@
 #include "acdispat.h"
 #include "acinterp.h"
 #include "acnamesp.h"
-#ifdef	ACPI_DISASSEMBLER
-#include "acdisasm.h"
-#endif
 #include "acparser.h"
 #include "amlcode.h"
+#include "acdebug.h"
 
 #define _COMPONENT          ACPI_DISPATCHER
 ACPI_MODULE_NAME("dsmethod")
@@ -205,7 +203,7 @@ acpi_ds_detect_named_opcodes(struct acpi_walk_state *walk_state,
  * RETURN:      Status
  *
  * DESCRIPTION: Called on method error. Invoke the global exception handler if
- *              present, dump the method data if the disassembler is configured
+ *              present, dump the method data if the debugger is configured
  *
  *              Note: Allows the exception handler to change the status code
  *
@@ -254,10 +252,10 @@ acpi_ds_method_error(acpi_status status, struct acpi_walk_state * walk_state)
 	if (ACPI_FAILURE(status)) {
 		acpi_ds_dump_method_stack(status, walk_state, walk_state->op);
 
-		/* Display method locals/args if disassembler is present */
+		/* Display method locals/args if debugger is present */
 
-#ifdef ACPI_DISASSEMBLER
-		acpi_dm_dump_method_info(status, walk_state);
+#ifdef ACPI_DEBUGGER
+		acpi_db_dump_method_info(status, walk_state);
 #endif
 	}
 

commit dc67d0fa8612ad49a8ec36040c5d22a9091bdbf6
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Jul 23 12:53:28 2015 +0800

    ACPICA: Remove extraneous check for null walk_state
    
    ACPICA commit f9fd6e8bad0f16ce2b436c5cda36ced0c2d85302
    
    Reported by Markus Elfring.
    
    Link: https://github.com/acpica/acpica/commit/f9fd6e8b
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index ea2bdde1227e..cb53c44c9644 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -582,9 +582,7 @@ acpi_ds_call_control_method(struct acpi_thread_state *thread,
 	/* On error, we must terminate the method properly */
 
 	acpi_ds_terminate_control_method(obj_desc, next_walk_state);
-	if (next_walk_state) {
-		acpi_ds_delete_walk_state(next_walk_state);
-	}
+	acpi_ds_delete_walk_state(next_walk_state);
 
 	return_ACPI_STATUS(status);
 }

commit ab6c573320768c36ac629be3db79ad62445aae64
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Jul 23 12:52:59 2015 +0800

    ACPICA: Executer: Add interpreter tracing mode for method tracing facility
    
    ACPICA commit 07fffd02607685b655ed92ee15c160e6a810b60b
    
    The acpi_debug_trace() is the mechanism known as ACPI method tracing that is
    used by Linux as ACPICA debugging message reducer. This facility can be
    controlled through Linux ACPI subsystem - /sys/module/acpi/parameters.
    This facility requires CONFIG_ACPI_DEBUG to be enabled to see ACPICA trace
    logs in the kernel dmesg output.
    
    This patch enhances acpi_debug_trace() to make it not only a message reducer,
    but a real tracer to trace AML interpreter execution. Note that in addition
    to the AML tracer enabling, this patch also updates the facility with the
    following enhancements:
    1. Allow a full path to be specified by the acpi_debug_trace() API.
    2. Allow any method rather than just the entrance of acpi_evaluate_object()
       to be traced.
    3. All interpreter ACPI_LV_TRACE_POINT messages are collected for
       ACPI_EXECUTER layer.
    
    The Makefile of drivers/acpi/acpica is also updated to include exdebug.o
    and the duplicated stubs are removed after that.
    
    Note that since this patch has enhanced the method tracing facility, Linux
    need also be updated after applying this patch. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/07fffd02
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 0fa6f19aab3a..ea2bdde1227e 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -327,7 +327,6 @@ acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
 			       struct acpi_walk_state *walk_state)
 {
 	acpi_status status = AE_OK;
-	char *pathname = NULL;
 
 	ACPI_FUNCTION_TRACE_PTR(ds_begin_method_execution, method_node);
 
@@ -335,17 +334,7 @@ acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
 		return_ACPI_STATUS(AE_NULL_ENTRY);
 	}
 
-	pathname = acpi_ns_get_normalized_pathname(method_node, TRUE);
-	if (pathname) {
-		ACPI_DEBUG_PRINT((ACPI_DB_TRACE_POINT,
-				  "Begin method [0x%p:%s] execution.\n",
-				  obj_desc->method.aml_start, pathname));
-		ACPI_FREE(pathname);
-	} else {
-		ACPI_DEBUG_PRINT((ACPI_DB_TRACE_POINT,
-				  "Begin method [0x%p] execution.\n",
-				  obj_desc->method.aml_start));
-	}
+	acpi_ex_start_trace_method(method_node, obj_desc, walk_state);
 
 	/* Prevent wraparound of thread count */
 
@@ -708,7 +697,6 @@ void
 acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 				 struct acpi_walk_state *walk_state)
 {
-	char *pathname = NULL;
 
 	ACPI_FUNCTION_TRACE_PTR(ds_terminate_control_method, walk_state);
 
@@ -846,22 +834,8 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 		}
 	}
 
-	if (method_desc->method.node) {
-		pathname = acpi_ns_get_normalized_pathname((struct
-							    acpi_namespace_node
-							    *)method_desc->
-							   method.node, TRUE);
-	}
-	if (pathname) {
-		ACPI_DEBUG_PRINT((ACPI_DB_TRACE_POINT,
-				  "End method [0x%p:%s] execution.\n",
-				  method_desc->method.aml_start, pathname));
-		ACPI_FREE(pathname);
-	} else {
-		ACPI_DEBUG_PRINT((ACPI_DB_TRACE_POINT,
-				  "End method [0x%p] execution.\n",
-				  method_desc->method.aml_start));
-	}
+	acpi_ex_stop_trace_method((struct acpi_namespace_node *)method_desc->
+				  method.node, method_desc, walk_state);
 
 	return_VOID;
 }

commit a616dc2fe50270f1fa5050fb9cd88a08531a3f25
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Jul 23 12:52:53 2015 +0800

    ACPICA: Dispatcher: Add trace support for interpreter
    
    ACPICA commit 71299ec8b49054daace0df50268e8e055654ca37
    
    This patch adds trace point at the following point:
     1. Begin/end of a control method execution;
     2. Begin/end of an opcode execution.
    
    The trace point feature can be enabled by defining ACPI_DEBUG_OUTPUT
    and specifying a debug level that includes ACPI_LV_TRACDE_POINT and the
    debug layers that include ACPI_PARSER and ACPI_DISPACTCHER.
    
    In order to make aml_op_name of union acpi_parse_object usable for tracer, it is
    enabled for ACPI_DEBUG_OUTPUT in this patch. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/71299ec8
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index e0ae8f4e9b35..0fa6f19aab3a 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -327,6 +327,7 @@ acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
 			       struct acpi_walk_state *walk_state)
 {
 	acpi_status status = AE_OK;
+	char *pathname = NULL;
 
 	ACPI_FUNCTION_TRACE_PTR(ds_begin_method_execution, method_node);
 
@@ -334,6 +335,18 @@ acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
 		return_ACPI_STATUS(AE_NULL_ENTRY);
 	}
 
+	pathname = acpi_ns_get_normalized_pathname(method_node, TRUE);
+	if (pathname) {
+		ACPI_DEBUG_PRINT((ACPI_DB_TRACE_POINT,
+				  "Begin method [0x%p:%s] execution.\n",
+				  obj_desc->method.aml_start, pathname));
+		ACPI_FREE(pathname);
+	} else {
+		ACPI_DEBUG_PRINT((ACPI_DB_TRACE_POINT,
+				  "Begin method [0x%p] execution.\n",
+				  obj_desc->method.aml_start));
+	}
+
 	/* Prevent wraparound of thread count */
 
 	if (obj_desc->method.thread_count == ACPI_UINT8_MAX) {
@@ -695,6 +708,7 @@ void
 acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 				 struct acpi_walk_state *walk_state)
 {
+	char *pathname = NULL;
 
 	ACPI_FUNCTION_TRACE_PTR(ds_terminate_control_method, walk_state);
 
@@ -832,5 +846,22 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 		}
 	}
 
+	if (method_desc->method.node) {
+		pathname = acpi_ns_get_normalized_pathname((struct
+							    acpi_namespace_node
+							    *)method_desc->
+							   method.node, TRUE);
+	}
+	if (pathname) {
+		ACPI_DEBUG_PRINT((ACPI_DB_TRACE_POINT,
+				  "End method [0x%p:%s] execution.\n",
+				  method_desc->method.aml_start, pathname));
+		ACPI_FREE(pathname);
+	} else {
+		ACPI_DEBUG_PRINT((ACPI_DB_TRACE_POINT,
+				  "End method [0x%p] execution.\n",
+				  method_desc->method.aml_start));
+	}
+
 	return_VOID;
 }

commit 0bac4295526c67e87ec24b29762140c38de7c86a
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Jul 23 12:52:46 2015 +0800

    ACPICA: Dispatcher: Move stack traversal code to dispatcher
    
    ACPICA commit c8275e243b58fd4adfc0362bd704af41ed14bc75
    
    This patch moves parts of acpi_dm_dump_method_info() to the dispatcher
    component.
    
    This patch also makes the new function dependent on ACPI_DEBUG_OUTPUT
    compile-stage definition so that it can be used by the trace facility.
    
    acpi_dm_dump_method_info() traverses method stack when an exception is
    encountered. Such traversal is needed to support method tracing for the
    exceptions. When an exception is encountered, the end indications of the
    aborted methods should be logged in order not to break the user space
    analysis tool. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/c8275e24
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 4abc2425de4b..e0ae8f4e9b35 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -251,14 +251,15 @@ acpi_ds_method_error(acpi_status status, struct acpi_walk_state * walk_state)
 
 	acpi_ds_clear_implicit_return(walk_state);
 
-#ifdef ACPI_DISASSEMBLER
 	if (ACPI_FAILURE(status)) {
+		acpi_ds_dump_method_stack(status, walk_state, walk_state->op);
 
 		/* Display method locals/args if disassembler is present */
 
-		acpi_dm_dump_method_info(status, walk_state, walk_state->op);
-	}
+#ifdef ACPI_DISASSEMBLER
+		acpi_dm_dump_method_info(status, walk_state);
 #endif
+	}
 
 	return (status);
 }

commit 62eb935b77818a5e4ff3c8d9b97036b59944f649
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Jul 23 12:52:24 2015 +0800

    ACPICA: Dispatcher: Cleanup union acpi_operand_object's AML address assignments
    
    ACPICA commit afb52611dbe7403551f93504d3798534f5c343f4
    
    This patch cleans up the code of assigning the AML address to the
    union acpi_operand_object.
    
    The idea behind this cleanup is:
    The AML address of the union acpi_operand_object should always be determined at
    the point where the object is encountered. It should be started from the
    first byte of the object. For example, the opcode of the object, the name
    string of the user_term object, or the first byte of the packaged object
    (where a pkg_length is prefixed). So it's not cleaner to have it assigned
    here and there in the entire ACPICA source tree.
    
    There are some special cases for the internal opcodes, before cleaning up
    the internal opcodes, we should also determine the rules for the AML
    addresses of the internal opcodes:
    1. INT_NAMEPATH_OP: the address of the first byte for the name_string.
    2. INT_METHODCALL_OP: the address of the first byte for the name_string.
    3. INT_BYTELIST_OP: the address of the first byte for the byte_data list.
    4. INT_EVAL_SUBTREE_OP: the address of the first byte for the
                            Region/Package/Buffer/bank_field/Field arguments.
    5. INT_NAMEDFIELD_OP: the address to the name_seg.
    6. INT_RESERVEDFIELD_OP: the address to the 0x00 prefix.
    7. INT_ACCESSFIELD_OP: the address to the 0x01 prefix.
    8. INT_CONNECTION_OP: the address to the 0x02 prefix.
    9: INT_EXTACCESSFIELD_OP: the address to the 0x03 prefix.
    10.INT_RETURN_VALUE_OP: the address of the replaced operand.
    11.computational_data: the address to the
                          Byte/Word/Dword/Qword/string_prefix.
    
    Before cleaning up the internal root scope of the aml_walk, turning it into
    the term_list, we need to remember the aml_start address as the "Aml"
    attribute for the union acpi_operand_object created by acpi_ps_create_scope_op().
    
    Finally, we can delete some redundant AML address assignment in psloop.c.
    
    Link: https://github.com/acpica/acpica/commit/afb52611
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index bf8c16e379fb..4abc2425de4b 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -103,7 +103,7 @@ acpi_ds_auto_serialize_method(struct acpi_namespace_node *node,
 
 	/* Create/Init a root op for the method parse tree */
 
-	op = acpi_ps_alloc_op(AML_METHOD_OP);
+	op = acpi_ps_alloc_op(AML_METHOD_OP, obj_desc->method.aml_start);
 	if (!op) {
 		return_ACPI_STATUS(AE_NO_MEMORY);
 	}

commit 83482f758b0d2d6a20a10be88399da44aa186aed
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Jul 23 12:52:11 2015 +0800

    ACPICA: Parser: Cleanup aml_offset in struct acpi_walk_state
    
    ACPICA commit d254405814495058276c0c2f9d96794d15a6c91c
    
    This patch converts aml_offset in struct acpi_walk_state to AML address.
    
    AML offset is actually only used by the debugger, using AML address is more
    direct and efficient during the parsing stage so that we don't need to
    calculate it during the parsing stage.
    
    On the other hand, we can see several issues in the current parser logic
    around the aml_offset:
    1. union acpi_operand_object.Common.aml_offset is redundantly assigned in
       acpi_ps_parse_loop().
    2. aml_offset is not an indication of the offset from the table header but
       the offset from the entry of a list of objects. Sometimes, it indicates
       an entry for a Method/Package/Buffer, which makes it difficult to be
       reversely calculated to a table header offset.
    3. When being used with method tracers (for example, Linux function trace),
       it's better to have AML address logged instead of the AML offset because
       the address is the only attribute that can uniquely identify the opcode.
    This patch is required to solve the above issues. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/d2544058
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 85bb951430d9..bf8c16e379fb 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -214,6 +214,8 @@ acpi_ds_detect_named_opcodes(struct acpi_walk_state *walk_state,
 acpi_status
 acpi_ds_method_error(acpi_status status, struct acpi_walk_state * walk_state)
 {
+	u32 aml_offset;
+
 	ACPI_FUNCTION_ENTRY();
 
 	/* Ignore AE_OK and control exception codes */
@@ -234,13 +236,16 @@ acpi_ds_method_error(acpi_status status, struct acpi_walk_state * walk_state)
 		 * Handler can map the exception code to anything it wants, including
 		 * AE_OK, in which case the executing method will not be aborted.
 		 */
+		aml_offset = (u32)ACPI_PTR_DIFF(walk_state->aml,
+						walk_state->parser_state.
+						aml_start);
+
 		status = acpi_gbl_exception_handler(status,
 						    walk_state->method_node ?
 						    walk_state->method_node->
 						    name.integer : 0,
 						    walk_state->opcode,
-						    walk_state->aml_offset,
-						    NULL);
+						    aml_offset, NULL);
 		acpi_ex_enter_interpreter();
 	}
 

commit c8dec7459d9fcb880e5c42929d01c308bea9f823
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu May 21 10:31:06 2015 +0800

    ACPICA: Dispatcher: Fix a resource leak issue in acpi_ds_auto_serialize_method().
    
    ACPICA commit 29d03840cbab435e8ea82e9339ff9d84535c647d
    
    This patch fixes a resource leak issue in acpi_ds_auto_serialize_method().
    It is reported by the "Coverity" tool as unsecure code. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/29d03840
    Link: https://jira01.devtools.intel.com/browse/LCK-2142
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index d72565a3c646..85bb951430d9 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -116,6 +116,7 @@ acpi_ds_auto_serialize_method(struct acpi_namespace_node *node,
 	walk_state =
 	    acpi_ds_create_walk_state(node->owner_id, NULL, NULL, NULL);
 	if (!walk_state) {
+		acpi_ps_free_op(op);
 		return_ACPI_STATUS(AE_NO_MEMORY);
 	}
 
@@ -125,6 +126,7 @@ acpi_ds_auto_serialize_method(struct acpi_namespace_node *node,
 				  obj_desc->method.aml_length, NULL, 0);
 	if (ACPI_FAILURE(status)) {
 		acpi_ds_delete_walk_state(walk_state);
+		acpi_ps_free_op(op);
 		return_ACPI_STATUS(status);
 	}
 
@@ -133,9 +135,6 @@ acpi_ds_auto_serialize_method(struct acpi_namespace_node *node,
 	/* Parse the method, scan for creation of named objects */
 
 	status = acpi_ps_parse_aml(walk_state);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
 
 	acpi_ps_delete_parse_tree(op);
 	return_ACPI_STATUS(status);

commit 82a809419429f2e6142d2c5d88d91661f8aecb87
Author: David E. Box <david.e.box@linux.intel.com>
Date:   Thu Feb 5 15:20:45 2015 +0800

    ACPICA: Update Copyright headers to 2015
    
    ACPICA commit 8990e73ab2aa15d6a0068b860ab54feff25bee36
    
    Link: https://github.com/acpica/acpica/commit/8990e73a
    Signed-off-by: David E. Box <david.e.box@linux.intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 3c7f7378b94d..d72565a3c646 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2014, Intel Corp.
+ * Copyright (C) 2000 - 2015, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit d18255795bf98b3f25dbc5334b8a615943c3dcca
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Mar 24 14:49:13 2014 +0800

    ACPICA: Ignore sync_level for methods that have been auto-serialized.
    
    Cannot use a sync_level for methods that have been serialized at load-time
    or runtime because this may interfere with any existing use of sync_levels
    within the ASL code. So, we simply ignore the sync_level for these methods,
    thus preserving any existing sync_level priorities. Note, the use of
    sync_levels is actually rather rare within BIOS ASL code.
    
    References: http://www.spinics.net/lists/linux-acpi/msg49496.html
    Reported-by: Valdis Kletnieks <valdis.kletnieks@vt.edu>
    Reported-by: Sabrina Dubroka <sd@queasysnail.net>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 73764c7d1c5d..3c7f7378b94d 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -175,8 +175,15 @@ acpi_ds_detect_named_opcodes(struct acpi_walk_state *walk_state,
 	 * At this point, we know we have a Named object opcode.
 	 * Mark the method as serialized. Later code will create a mutex for
 	 * this method to enforce serialization.
+	 *
+	 * Note, ACPI_METHOD_IGNORE_SYNC_LEVEL flag means that we will ignore the
+	 * Sync Level mechanism for this method, even though it is now serialized.
+	 * Otherwise, there can be conflicts with existing ASL code that actually
+	 * uses sync levels.
 	 */
-	walk_state->method_desc->method.info_flags |= ACPI_METHOD_SERIALIZED;
+	walk_state->method_desc->method.sync_level = 0;
+	walk_state->method_desc->method.info_flags |=
+	    (ACPI_METHOD_SERIALIZED | ACPI_METHOD_IGNORE_SYNC_LEVEL);
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  "Method serialized [%4.4s] %p - [%s] (%4.4X)\n",
@@ -349,13 +356,19 @@ acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
 		/*
 		 * The current_sync_level (per-thread) must be less than or equal to
 		 * the sync level of the method. This mechanism provides some
-		 * deadlock prevention
+		 * deadlock prevention.
+		 *
+		 * If the method was auto-serialized, we just ignore the sync level
+		 * mechanism, because auto-serialization of methods can interfere
+		 * with ASL code that actually uses sync levels.
 		 *
 		 * Top-level method invocation has no walk state at this point
 		 */
 		if (walk_state &&
-		    (walk_state->thread->current_sync_level >
-		     obj_desc->method.mutex->mutex.sync_level)) {
+		    (!(obj_desc->method.
+		       info_flags & ACPI_METHOD_IGNORE_SYNC_LEVEL))
+		    && (walk_state->thread->current_sync_level >
+			obj_desc->method.mutex->mutex.sync_level)) {
 			ACPI_ERROR((AE_INFO,
 				    "Cannot acquire Mutex for method [%4.4s], current SyncLevel is too large (%u)",
 				    acpi_ut_get_node_name(method_node),
@@ -800,7 +813,8 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 			method_desc->method.info_flags &=
 			    ~ACPI_METHOD_SERIALIZED_PENDING;
 			method_desc->method.info_flags |=
-			    ACPI_METHOD_SERIALIZED;
+			    (ACPI_METHOD_SERIALIZED |
+			     ACPI_METHOD_IGNORE_SYNC_LEVEL);
 			method_desc->method.sync_level = 0;
 		}
 

commit 21bd7e610ef75ef26387ed4667801080b5b7220a
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Mar 24 14:49:07 2014 +0800

    ACPICA: Add additional named objects for the auto-serialize method scan.
    
    This change adds some additional opcodes that are detected and will
    cause a method to be auto-serialized. These opcodes are the various
    CreateXField and the FieldUnit opcodes. Lv Zheng.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=52191
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 97ed86aee0dc..73764c7d1c5d 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -163,9 +163,11 @@ acpi_ds_detect_named_opcodes(struct acpi_walk_state *walk_state,
 
 	ACPI_FUNCTION_NAME(acpi_ds_detect_named_opcodes);
 
-	/* We are only interested in opcodes that have an associated name */
+	/* We are only interested in opcodes that create a new name */
 
-	if (!(walk_state->op_info->flags & AML_NAMED)) {
+	if (!
+	    (walk_state->op_info->
+	     flags & (AML_NAMED | AML_CREATE | AML_FIELD))) {
 		return (AE_OK);
 	}
 

commit 22b5afce6a0f29f995b0cce83a5033892dd306d8
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Mar 24 14:49:00 2014 +0800

    ACPICA: Add auto-serialization support for ill-behaved control methods.
    
    This change adds support to automatically mark a control method as
    "serialized" if the method creates any named objects. This will
    positively prevent the method from being entered by more than one
    thread and thus preventing a possible abort when an attempt is
    made to create an object twice.
    
    Implemented by parsing all non-serialize control methods at table
    load time.
    
    This feature is disabled by default and this patch also adds a new
    Linux kernel parameter "acpi_auto_serialize" to allow this feature
    to be turned on for a specific boot.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=52191
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 2c6d42c2bc01..97ed86aee0dc 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -49,14 +49,144 @@
 #ifdef	ACPI_DISASSEMBLER
 #include "acdisasm.h"
 #endif
+#include "acparser.h"
+#include "amlcode.h"
 
 #define _COMPONENT          ACPI_DISPATCHER
 ACPI_MODULE_NAME("dsmethod")
 
 /* Local prototypes */
+static acpi_status
+acpi_ds_detect_named_opcodes(struct acpi_walk_state *walk_state,
+			     union acpi_parse_object **out_op);
+
 static acpi_status
 acpi_ds_create_method_mutex(union acpi_operand_object *method_desc);
 
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_auto_serialize_method
+ *
+ * PARAMETERS:  node                        - Namespace Node of the method
+ *              obj_desc                    - Method object attached to node
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Parse a control method AML to scan for control methods that
+ *              need serialization due to the creation of named objects.
+ *
+ * NOTE: It is a bit of overkill to mark all such methods serialized, since
+ * there is only a problem if the method actually blocks during execution.
+ * A blocking operation is, for example, a Sleep() operation, or any access
+ * to an operation region. However, it is probably not possible to easily
+ * detect whether a method will block or not, so we simply mark all suspicious
+ * methods as serialized.
+ *
+ * NOTE2: This code is essentially a generic routine for parsing a single
+ * control method.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_auto_serialize_method(struct acpi_namespace_node *node,
+			      union acpi_operand_object *obj_desc)
+{
+	acpi_status status;
+	union acpi_parse_object *op = NULL;
+	struct acpi_walk_state *walk_state;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_auto_serialize_method, node);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+			  "Method auto-serialization parse [%4.4s] %p\n",
+			  acpi_ut_get_node_name(node), node));
+
+	/* Create/Init a root op for the method parse tree */
+
+	op = acpi_ps_alloc_op(AML_METHOD_OP);
+	if (!op) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	acpi_ps_set_name(op, node->name.integer);
+	op->common.node = node;
+
+	/* Create and initialize a new walk state */
+
+	walk_state =
+	    acpi_ds_create_walk_state(node->owner_id, NULL, NULL, NULL);
+	if (!walk_state) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	status =
+	    acpi_ds_init_aml_walk(walk_state, op, node,
+				  obj_desc->method.aml_start,
+				  obj_desc->method.aml_length, NULL, 0);
+	if (ACPI_FAILURE(status)) {
+		acpi_ds_delete_walk_state(walk_state);
+		return_ACPI_STATUS(status);
+	}
+
+	walk_state->descending_callback = acpi_ds_detect_named_opcodes;
+
+	/* Parse the method, scan for creation of named objects */
+
+	status = acpi_ps_parse_aml(walk_state);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	acpi_ps_delete_parse_tree(op);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_detect_named_opcodes
+ *
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
+ *              out_op          - Unused, required for parser interface
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Descending callback used during the loading of ACPI tables.
+ *              Currently used to detect methods that must be marked serialized
+ *              in order to avoid problems with the creation of named objects.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ds_detect_named_opcodes(struct acpi_walk_state *walk_state,
+			     union acpi_parse_object **out_op)
+{
+
+	ACPI_FUNCTION_NAME(acpi_ds_detect_named_opcodes);
+
+	/* We are only interested in opcodes that have an associated name */
+
+	if (!(walk_state->op_info->flags & AML_NAMED)) {
+		return (AE_OK);
+	}
+
+	/*
+	 * At this point, we know we have a Named object opcode.
+	 * Mark the method as serialized. Later code will create a mutex for
+	 * this method to enforce serialization.
+	 */
+	walk_state->method_desc->method.info_flags |= ACPI_METHOD_SERIALIZED;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "Method serialized [%4.4s] %p - [%s] (%4.4X)\n",
+			  walk_state->method_node->name.ascii,
+			  walk_state->method_node, walk_state->op_info->name,
+			  walk_state->opcode));
+
+	/* Abort the parse, no need to examine this method any further */
+
+	return (AE_CTRL_TERMINATE);
+}
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ds_method_error
@@ -74,7 +204,7 @@ acpi_ds_create_method_mutex(union acpi_operand_object *method_desc);
  ******************************************************************************/
 
 acpi_status
-acpi_ds_method_error(acpi_status status, struct acpi_walk_state *walk_state)
+acpi_ds_method_error(acpi_status status, struct acpi_walk_state * walk_state)
 {
 	ACPI_FUNCTION_ENTRY();
 

commit fbb7a2dc2be493c87399550bdc2ddaa510cdf450
Author: Bob Moore <robert.moore@intel.com>
Date:   Sat Feb 8 09:42:25 2014 +0800

    ACPICA: Update ACPICA copyrights to 2014.
    
    Update ACPICA copyrights to 2014. Includes all source headers and
    signons for the various tools.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 81a78ba84311..2c6d42c2bc01 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2013, Intel Corp.
+ * Copyright (C) 2000 - 2014, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 9187a415fd119c1d89a5ad2fd05513cd43699ebf
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Oct 31 09:30:28 2013 +0800

    ACPICA: Add new statistics interface.
    
    This patch ports new counters and statistics interface, already
    implemented in ACPICA upstream, to Linux.  That helps to reduce
    source code differences between Linux and ACPICA upstream.
    
    [rjw: Changelog]
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index df3ea125507f..81a78ba84311 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -292,6 +292,7 @@ acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
 	 * reentered one more time (even if it is the same thread)
 	 */
 	obj_desc->method.thread_count++;
+	acpi_method_count++;
 	return_ACPI_STATUS(status);
 
 cleanup:

commit 10622bf8ce432e6a53fd3c37163e99e99c9e43ee
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Oct 29 09:30:02 2013 +0800

    ACPICA: Linuxize: Change indentation of C labels.
    
    It is reported by kernel build test systems that all ACPICA source
    files in the kernel tree have incorrect label indentation.  This
    patch changes default indent option used in the release process to
    fix this bug.  Lv Zheng.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index a9ffd44c18fe..df3ea125507f 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -294,7 +294,7 @@ acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
 	obj_desc->method.thread_count++;
 	return_ACPI_STATUS(status);
 
-      cleanup:
+cleanup:
 	/* On error, must release the method mutex (if present) */
 
 	if (obj_desc->method.mutex) {
@@ -424,7 +424,7 @@ acpi_ds_call_control_method(struct acpi_thread_state *thread,
 
 	return_ACPI_STATUS(status);
 
-      cleanup:
+cleanup:
 
 	/* On error, we must terminate the method properly */
 

commit 25f044e64568dd83de34c16c837a96bbb2b0cecb
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 25 05:38:56 2013 +0000

    ACPICA: Update ACPICA copyrights to 2013
    
    Includes all source headers and signons for the various tools.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 4e5873ab4f01..a9ffd44c18fe 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2013, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 78d025e2d057a3490f918a6e3ebe2486236505cf
Author: Tim Gardner <tim.gardner@canonical.com>
Date:   Mon Dec 31 00:06:56 2012 +0000

    ACPICA: Fix possible memory leak in dispatcher error path.
    
    On error, delete mutex object created during method mutex creation.
    Reported by tim.gardner@canonical.com.
    
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 54c968ab8144..4e5873ab4f01 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -151,6 +151,7 @@ acpi_ds_create_method_mutex(union acpi_operand_object *method_desc)
 
 	status = acpi_os_create_mutex(&mutex_desc->mutex.os_mutex);
 	if (ACPI_FAILURE(status)) {
+		acpi_ut_delete_object_desc(mutex_desc);
 		return_ACPI_STATUS(status);
 	}
 

commit 227158211e8eba104a477c9a263797256811f206
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Wed Dec 19 05:37:47 2012 +0000

    ACPICA: Fix possible memory leak.
    
    Ensure cleanup after a memory allocation failure in dsmethod.c.
    Original Linux change from Jesper Juhl.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 735c05996ec6..54c968ab8144 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -378,7 +378,8 @@ acpi_ds_call_control_method(struct acpi_thread_state *thread,
 	 */
 	info = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));
 	if (!info) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
+		status = AE_NO_MEMORY;
+		goto cleanup;
 	}
 
 	info->parameters = &this_walk_state->operands[0];

commit 56324c1090ecf057c89a4d470a23a8ca61061b61
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Dec 19 05:37:03 2012 +0000

    ACPICA: Update codes under disabled build options.
    
    This is a cosmetic patch only. Comparison of the resulting binary showed
    only line number differences.
    
    This patch does not affect the generation of the Linux binary.
    This patch decreases 170 lines of 20121018 divergence.diff.
    
    This patch updates ACPICA codes surrounded by some disabled build options
    so that the source code diff between Linux and ACPICA can be reduced.
    
    Some of these build options may never be used in the kernel, so they may
    be deleted entirely in future patches.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 52eb4e01622a..735c05996ec6 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -47,7 +47,7 @@
 #include "acinterp.h"
 #include "acnamesp.h"
 #ifdef	ACPI_DISASSEMBLER
-#include <acpi/acdisasm.h>
+#include "acdisasm.h"
 #endif
 
 #define _COMPONENT          ACPI_DISPATCHER

commit 73a3090a2160fb01317f5a44af6ee5a064a29625
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Oct 31 02:26:55 2012 +0000

    ACPICA: Remove extra spaces after periods within comments
    
    This makes all comments consistent.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index aa9a5d4e4052..52eb4e01622a 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -170,7 +170,7 @@ acpi_ds_create_method_mutex(union acpi_operand_object *method_desc)
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Prepare a method for execution.  Parses the method if necessary,
+ * DESCRIPTION: Prepare a method for execution. Parses the method if necessary,
  *              increments the thread count, and waits at the method semaphore
  *              for clearance to execute.
  *
@@ -444,7 +444,7 @@ acpi_ds_call_control_method(struct acpi_thread_state *thread,
  * RETURN:      Status
  *
  * DESCRIPTION: Restart a method that was preempted by another (nested) method
- *              invocation.  Handle the return value (if any) from the callee.
+ *              invocation. Handle the return value (if any) from the callee.
  *
  ******************************************************************************/
 
@@ -530,7 +530,7 @@ acpi_ds_restart_control_method(struct acpi_walk_state *walk_state,
  *
  * RETURN:      None
  *
- * DESCRIPTION: Terminate a control method.  Delete everything that the method
+ * DESCRIPTION: Terminate a control method. Delete everything that the method
  *              created, delete all locals and arguments, and delete the parse
  *              tree if requested.
  *

commit ba494beeaa69bc0fb01eb89464ad5d57d26e3901
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jul 12 09:40:10 2012 +0800

    ACPICA: AcpiSrc: Fix some translation issues for Linux conversion
    
    Fixes issues like this:
    
    i_aSL -> iASL
    00-7_f -> 00-7F
    local_fADT -> local_FADT
    execute_oSI -> execute_OSI
    
    Also, in function headers, the parameters are now translated to
    lower case (with underscores if necessary.)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 00f5dab5bcc0..aa9a5d4e4052 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -61,7 +61,7 @@ acpi_ds_create_method_mutex(union acpi_operand_object *method_desc);
  *
  * FUNCTION:    acpi_ds_method_error
  *
- * PARAMETERS:  Status          - Execution status
+ * PARAMETERS:  status          - Execution status
  *              walk_state      - Current state
  *
  * RETURN:      Status
@@ -306,9 +306,9 @@ acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
  *
  * FUNCTION:    acpi_ds_call_control_method
  *
- * PARAMETERS:  Thread              - Info for this thread
+ * PARAMETERS:  thread              - Info for this thread
  *              this_walk_state     - Current walk state
- *              Op                  - Current Op to be walked
+ *              op                  - Current Op to be walked
  *
  * RETURN:      Status
  *

commit 77848130e53b06c22fe37a7b6acbb82bb3e9bfba
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 12 13:27:23 2012 +0800

    ACPICA: Update all copyrights to 2012
    
    Update all copyrights to 2012.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 5d797751e205..00f5dab5bcc0 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2011, Intel Corp.
+ * Copyright (C) 2000 - 2012, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit b4e104eaeb8cd4329a23e0e4ebf166681b1d182d
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jan 17 11:05:40 2011 +0800

    ACPICA: Update all ACPICA copyrights and signons to 2011
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 5a79f401a113..5d797751e205 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2010, Intel Corp.
+ * Copyright (C) 2000 - 2011, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 262948428878fb340127faca1791acb17146122e
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Wed Jan 12 09:19:43 2011 +0800

    ACPICA: Fix issues/fault with automatic "serialized" method support
    
    History: This support changes a method to "serialized" on the fly if the
    method generates an AE_ALREADY_EXISTS error, indicating the possibility
    that it cannot handle reentrancy.
    
    This fix repairs a couple of issues seen in the field, especially on
    machines with many cores.
    
    1) Delete method children only upon the exit of the last thread, so
    as to not delete objects out from under running threads.
    
    2) Set the "serialized" bit for the method only upon the exit of the
    last thread, so as to not cause deadlock when running threads attempt
    to exit.
    
    3) Cleanup the use of the AML "MethodFlags" and internal method flags
    so that there is no longer any confustion between the two.
    
    Reported-by: Dana Myers <dana.myers@oracle.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index d94dd8974b55..5a79f401a113 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -43,7 +43,6 @@
 
 #include <acpi/acpi.h>
 #include "accommon.h"
-#include "amlcode.h"
 #include "acdispat.h"
 #include "acinterp.h"
 #include "acnamesp.h"
@@ -201,7 +200,7 @@ acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
 	/*
 	 * If this method is serialized, we need to acquire the method mutex.
 	 */
-	if (obj_desc->method.method_flags & AML_METHOD_SERIALIZED) {
+	if (obj_desc->method.info_flags & ACPI_METHOD_SERIALIZED) {
 		/*
 		 * Create a mutex for the method if it is defined to be Serialized
 		 * and a mutex has not already been created. We defer the mutex creation
@@ -413,8 +412,9 @@ acpi_ds_call_control_method(struct acpi_thread_state *thread,
 
 	/* Invoke an internal method if necessary */
 
-	if (obj_desc->method.method_flags & AML_METHOD_INTERNAL_ONLY) {
-		status = obj_desc->method.extra.implementation(next_walk_state);
+	if (obj_desc->method.info_flags & ACPI_METHOD_INTERNAL_ONLY) {
+		status =
+		    obj_desc->method.dispatch.implementation(next_walk_state);
 		if (status == AE_OK) {
 			status = AE_CTRL_TERMINATE;
 		}
@@ -579,11 +579,14 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 
 		/*
 		 * Delete any namespace objects created anywhere within the
-		 * namespace by the execution of this method. Unless this method
-		 * is a module-level executable code method, in which case we
-		 * want make the objects permanent.
+		 * namespace by the execution of this method. Unless:
+		 * 1) This method is a module-level executable code method, in which
+		 *    case we want make the objects permanent.
+		 * 2) There are other threads executing the method, in which case we
+		 *    will wait until the last thread has completed.
 		 */
-		if (!(method_desc->method.flags & AOPOBJ_MODULE_LEVEL)) {
+		if (!(method_desc->method.info_flags & ACPI_METHOD_MODULE_LEVEL)
+		    && (method_desc->method.thread_count == 1)) {
 
 			/* Delete any direct children of (created by) this method */
 
@@ -593,12 +596,17 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 			/*
 			 * Delete any objects that were created by this method
 			 * elsewhere in the namespace (if any were created).
+			 * Use of the ACPI_METHOD_MODIFIED_NAMESPACE optimizes the
+			 * deletion such that we don't have to perform an entire
+			 * namespace walk for every control method execution.
 			 */
 			if (method_desc->method.
-			    flags & AOPOBJ_MODIFIED_NAMESPACE) {
+			    info_flags & ACPI_METHOD_MODIFIED_NAMESPACE) {
 				acpi_ns_delete_namespace_by_owner(method_desc->
 								  method.
 								  owner_id);
+				method_desc->method.info_flags &=
+				    ~ACPI_METHOD_MODIFIED_NAMESPACE;
 			}
 		}
 	}
@@ -629,19 +637,43 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 		 * Serialized if it appears that the method is incorrectly written and
 		 * does not support multiple thread execution. The best example of this
 		 * is if such a method creates namespace objects and blocks. A second
-		 * thread will fail with an AE_ALREADY_EXISTS exception
+		 * thread will fail with an AE_ALREADY_EXISTS exception.
 		 *
 		 * This code is here because we must wait until the last thread exits
-		 * before creating the synchronization semaphore.
+		 * before marking the method as serialized.
 		 */
-		if ((method_desc->method.method_flags & AML_METHOD_SERIALIZED)
-		    && (!method_desc->method.mutex)) {
-			(void)acpi_ds_create_method_mutex(method_desc);
+		if (method_desc->method.
+		    info_flags & ACPI_METHOD_SERIALIZED_PENDING) {
+			if (walk_state) {
+				ACPI_INFO((AE_INFO,
+					   "Marking method %4.4s as Serialized because of AE_ALREADY_EXISTS error",
+					   walk_state->method_node->name.
+					   ascii));
+			}
+
+			/*
+			 * Method tried to create an object twice and was marked as
+			 * "pending serialized". The probable cause is that the method
+			 * cannot handle reentrancy.
+			 *
+			 * The method was created as not_serialized, but it tried to create
+			 * a named object and then blocked, causing the second thread
+			 * entrance to begin and then fail. Workaround this problem by
+			 * marking the method permanently as Serialized when the last
+			 * thread exits here.
+			 */
+			method_desc->method.info_flags &=
+			    ~ACPI_METHOD_SERIALIZED_PENDING;
+			method_desc->method.info_flags |=
+			    ACPI_METHOD_SERIALIZED;
+			method_desc->method.sync_level = 0;
 		}
 
 		/* No more threads, we can free the owner_id */
 
-		if (!(method_desc->method.flags & AOPOBJ_MODULE_LEVEL)) {
+		if (!
+		    (method_desc->method.
+		     info_flags & ACPI_METHOD_MODULE_LEVEL)) {
 			acpi_ut_release_owner_id(&method_desc->method.owner_id);
 		}
 	}

commit 28eb3fcf8762a3b52f4fef5af29dce50d23c7151
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Wed Sep 15 13:55:13 2010 +0800

    ACPICA: Make acpi_thread_id no longer configurable, always u64
    
    Change definition of acpi_thread_id to always be a u64. This
    simplifies the code, especially any printf output. u64 is
    the only common data type for all thread_id types across all
    operating systems. We now force the OSL to cast the native
    thread_id type to u64 before returning the value to ACPICA
    (via acpi_os_get_thread_id).
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 64750ee96e20..d94dd8974b55 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -573,7 +573,7 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 
 				acpi_os_release_mutex(method_desc->method.
 						      mutex->mutex.os_mutex);
-				method_desc->method.mutex->mutex.thread_id = NULL;
+				method_desc->method.mutex->mutex.thread_id = 0;
 			}
 		}
 

commit a9fc03125ea0001ff18bc29da9539b587fdbd1d7
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Wed May 26 13:59:51 2010 +0800

    ACPICA: Optimization: Reduce the number of namespace walks
    
    On control method exit, only walk the namespace if the method is
    known to have created namespace objects outside of its local scope.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 00846333773e..64750ee96e20 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -584,8 +584,22 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 		 * want make the objects permanent.
 		 */
 		if (!(method_desc->method.flags & AOPOBJ_MODULE_LEVEL)) {
-			acpi_ns_delete_namespace_by_owner(method_desc->method.
-							  owner_id);
+
+			/* Delete any direct children of (created by) this method */
+
+			acpi_ns_delete_namespace_subtree(walk_state->
+							 method_node);
+
+			/*
+			 * Delete any objects that were created by this method
+			 * elsewhere in the namespace (if any were created).
+			 */
+			if (method_desc->method.
+			    flags & AOPOBJ_MODIFIED_NAMESPACE) {
+				acpi_ns_delete_namespace_by_owner(method_desc->
+								  method.
+								  owner_id);
+			}
 		}
 	}
 

commit b27d65975c252ff774edff8e01f0a9fd46d8ab62
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed May 26 11:47:13 2010 +0800

    ACPICA: Core: Replace all %d format specifiers with %u (unsigned)
    
    With only a few exceptions, ACPICA does not use signed integers.
    Therefore, %d is incorrect.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 2a9a561c2f01..00846333773e 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -605,7 +605,7 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 		 * we immediately reuse it for the next thread executing this method
 		 */
 		ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
-				  "*** Completed execution of one thread, %d threads remaining\n",
+				  "*** Completed execution of one thread, %u threads remaining\n",
 				  method_desc->method.thread_count));
 	} else {
 		/* This is the only executing thread for this method */

commit f6a22b0bc417042e83117f52ab1a03696af185ab
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Mar 5 17:56:40 2010 +0800

    ACPICA: Standardize integer output for ACPICA warnings/errors
    
    Always use 0x prefix for hex output, use %u for integer output
    (all integers are unsigned.)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 721039233aa7..2a9a561c2f01 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -225,7 +225,7 @@ acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
 		    (walk_state->thread->current_sync_level >
 		     obj_desc->method.mutex->mutex.sync_level)) {
 			ACPI_ERROR((AE_INFO,
-				    "Cannot acquire Mutex for method [%4.4s], current SyncLevel is too large (%d)",
+				    "Cannot acquire Mutex for method [%4.4s], current SyncLevel is too large (%u)",
 				    acpi_ut_get_node_name(method_node),
 				    walk_state->thread->current_sync_level));
 

commit a8357b0c95484b46944728712f8810d3b37bf588
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 22 19:07:36 2010 +0800

    ACPICA: Update all ACPICA copyrights and signons to 2010
    
    Add 2010 copyright to all module headers and signons, including
    the Linux header. This affects virtually every file in the ACPICA
    core subsystem, iASL compiler, and all utilities.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index e786f9fd767f..721039233aa7 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2008, Intel Corp.
+ * Copyright (C) 2000 - 2010, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit e31c32cfe52e98344dad28853c3331879f72c4b0
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Fri Dec 11 15:28:27 2009 +0800

    ACPICA: Module-level code: enable _REG execution in same scope
    
    This change enables the execution of _REG methods that appear
    in the same scope as the module-level code, in resonse to an
    operation region declaration within the module-level code.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 567a4899a018..e786f9fd767f 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -414,7 +414,7 @@ acpi_ds_call_control_method(struct acpi_thread_state *thread,
 	/* Invoke an internal method if necessary */
 
 	if (obj_desc->method.method_flags & AML_METHOD_INTERNAL_ONLY) {
-		status = obj_desc->method.implementation(next_walk_state);
+		status = obj_desc->method.extra.implementation(next_walk_state);
 		if (status == AE_OK) {
 			status = AE_CTRL_TERMINATE;
 		}

commit 7f0c826a437157d2b19662977e9cf3b472cf24a6
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Thu Aug 13 14:03:15 2009 +0800

    ACPICA: Add support for module-level executable AML code
    
    Add limited support for executable AML code that exists outside
    of any control method. This type of code has been illegal since
    ACPI 2.0.  The code must exist in an If/Else/While block. All AML
    tables are supported, including tables that are dynamically loaded.
    ACPICA BZ 762.
    
    http://acpica.org/bugzilla/show_bug.cgi?id=762
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 14b8b8ed8023..567a4899a018 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -578,10 +578,15 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 		}
 
 		/*
-		 * Delete any namespace objects created anywhere within
-		 * the namespace by the execution of this method
+		 * Delete any namespace objects created anywhere within the
+		 * namespace by the execution of this method. Unless this method
+		 * is a module-level executable code method, in which case we
+		 * want make the objects permanent.
 		 */
-		acpi_ns_delete_namespace_by_owner(method_desc->method.owner_id);
+		if (!(method_desc->method.flags & AOPOBJ_MODULE_LEVEL)) {
+			acpi_ns_delete_namespace_by_owner(method_desc->method.
+							  owner_id);
+		}
 	}
 
 	/* Decrement the thread count on the method */
@@ -622,7 +627,9 @@ acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
 
 		/* No more threads, we can free the owner_id */
 
-		acpi_ut_release_owner_id(&method_desc->method.owner_id);
+		if (!(method_desc->method.flags & AOPOBJ_MODULE_LEVEL)) {
+			acpi_ut_release_owner_id(&method_desc->method.owner_id);
+		}
 	}
 
 	return_VOID;

commit e2f7a7772880458edff1b1cc5a988947229fac26
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 00:30:03 2009 -0500

    ACPICA: hide private headers
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 333c8560d9f8..14b8b8ed8023 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -42,11 +42,11 @@
  */
 
 #include <acpi/acpi.h>
-#include <acpi/accommon.h>
-#include <acpi/amlcode.h>
-#include <acpi/acdispat.h>
-#include <acpi/acinterp.h>
-#include <acpi/acnamesp.h>
+#include "accommon.h"
+#include "amlcode.h"
+#include "acdispat.h"
+#include "acinterp.h"
+#include "acnamesp.h"
 #ifdef	ACPI_DISASSEMBLER
 #include <acpi/acdisasm.h>
 #endif

commit 95b482a8d31116f3f5c2a5089569393234d06385
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 00:13:17 2009 -0500

    ACPICA: create acpica/ directory
    
    also, delete sleep/ and delete ACPI_CFLAGS from Makefile
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
new file mode 100644
index 000000000000..333c8560d9f8
--- /dev/null
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -0,0 +1,629 @@
+/******************************************************************************
+ *
+ * Module Name: dsmethod - Parser/Interpreter interface - control method parsing
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2008, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include <acpi/accommon.h>
+#include <acpi/amlcode.h>
+#include <acpi/acdispat.h>
+#include <acpi/acinterp.h>
+#include <acpi/acnamesp.h>
+#ifdef	ACPI_DISASSEMBLER
+#include <acpi/acdisasm.h>
+#endif
+
+#define _COMPONENT          ACPI_DISPATCHER
+ACPI_MODULE_NAME("dsmethod")
+
+/* Local prototypes */
+static acpi_status
+acpi_ds_create_method_mutex(union acpi_operand_object *method_desc);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_method_error
+ *
+ * PARAMETERS:  Status          - Execution status
+ *              walk_state      - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Called on method error. Invoke the global exception handler if
+ *              present, dump the method data if the disassembler is configured
+ *
+ *              Note: Allows the exception handler to change the status code
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_method_error(acpi_status status, struct acpi_walk_state *walk_state)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	/* Ignore AE_OK and control exception codes */
+
+	if (ACPI_SUCCESS(status) || (status & AE_CODE_CONTROL)) {
+		return (status);
+	}
+
+	/* Invoke the global exception handler */
+
+	if (acpi_gbl_exception_handler) {
+
+		/* Exit the interpreter, allow handler to execute methods */
+
+		acpi_ex_exit_interpreter();
+
+		/*
+		 * Handler can map the exception code to anything it wants, including
+		 * AE_OK, in which case the executing method will not be aborted.
+		 */
+		status = acpi_gbl_exception_handler(status,
+						    walk_state->method_node ?
+						    walk_state->method_node->
+						    name.integer : 0,
+						    walk_state->opcode,
+						    walk_state->aml_offset,
+						    NULL);
+		acpi_ex_enter_interpreter();
+	}
+
+	acpi_ds_clear_implicit_return(walk_state);
+
+#ifdef ACPI_DISASSEMBLER
+	if (ACPI_FAILURE(status)) {
+
+		/* Display method locals/args if disassembler is present */
+
+		acpi_dm_dump_method_info(status, walk_state, walk_state->op);
+	}
+#endif
+
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_create_method_mutex
+ *
+ * PARAMETERS:  obj_desc            - The method object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a mutex object for a serialized control method
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ds_create_method_mutex(union acpi_operand_object *method_desc)
+{
+	union acpi_operand_object *mutex_desc;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ds_create_method_mutex);
+
+	/* Create the new mutex object */
+
+	mutex_desc = acpi_ut_create_internal_object(ACPI_TYPE_MUTEX);
+	if (!mutex_desc) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Create the actual OS Mutex */
+
+	status = acpi_os_create_mutex(&mutex_desc->mutex.os_mutex);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	mutex_desc->mutex.sync_level = method_desc->method.sync_level;
+	method_desc->method.mutex = mutex_desc;
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_begin_method_execution
+ *
+ * PARAMETERS:  method_node         - Node of the method
+ *              obj_desc            - The method object
+ *              walk_state          - current state, NULL if not yet executing
+ *                                    a method.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Prepare a method for execution.  Parses the method if necessary,
+ *              increments the thread count, and waits at the method semaphore
+ *              for clearance to execute.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
+			       union acpi_operand_object *obj_desc,
+			       struct acpi_walk_state *walk_state)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_begin_method_execution, method_node);
+
+	if (!method_node) {
+		return_ACPI_STATUS(AE_NULL_ENTRY);
+	}
+
+	/* Prevent wraparound of thread count */
+
+	if (obj_desc->method.thread_count == ACPI_UINT8_MAX) {
+		ACPI_ERROR((AE_INFO,
+			    "Method reached maximum reentrancy limit (255)"));
+		return_ACPI_STATUS(AE_AML_METHOD_LIMIT);
+	}
+
+	/*
+	 * If this method is serialized, we need to acquire the method mutex.
+	 */
+	if (obj_desc->method.method_flags & AML_METHOD_SERIALIZED) {
+		/*
+		 * Create a mutex for the method if it is defined to be Serialized
+		 * and a mutex has not already been created. We defer the mutex creation
+		 * until a method is actually executed, to minimize the object count
+		 */
+		if (!obj_desc->method.mutex) {
+			status = acpi_ds_create_method_mutex(obj_desc);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+		}
+
+		/*
+		 * The current_sync_level (per-thread) must be less than or equal to
+		 * the sync level of the method. This mechanism provides some
+		 * deadlock prevention
+		 *
+		 * Top-level method invocation has no walk state at this point
+		 */
+		if (walk_state &&
+		    (walk_state->thread->current_sync_level >
+		     obj_desc->method.mutex->mutex.sync_level)) {
+			ACPI_ERROR((AE_INFO,
+				    "Cannot acquire Mutex for method [%4.4s], current SyncLevel is too large (%d)",
+				    acpi_ut_get_node_name(method_node),
+				    walk_state->thread->current_sync_level));
+
+			return_ACPI_STATUS(AE_AML_MUTEX_ORDER);
+		}
+
+		/*
+		 * Obtain the method mutex if necessary. Do not acquire mutex for a
+		 * recursive call.
+		 */
+		if (!walk_state ||
+		    !obj_desc->method.mutex->mutex.thread_id ||
+		    (walk_state->thread->thread_id !=
+		     obj_desc->method.mutex->mutex.thread_id)) {
+			/*
+			 * Acquire the method mutex. This releases the interpreter if we
+			 * block (and reacquires it before it returns)
+			 */
+			status =
+			    acpi_ex_system_wait_mutex(obj_desc->method.mutex->
+						      mutex.os_mutex,
+						      ACPI_WAIT_FOREVER);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+
+			/* Update the mutex and walk info and save the original sync_level */
+
+			if (walk_state) {
+				obj_desc->method.mutex->mutex.
+				    original_sync_level =
+				    walk_state->thread->current_sync_level;
+
+				obj_desc->method.mutex->mutex.thread_id =
+				    walk_state->thread->thread_id;
+				walk_state->thread->current_sync_level =
+				    obj_desc->method.sync_level;
+			} else {
+				obj_desc->method.mutex->mutex.
+				    original_sync_level =
+				    obj_desc->method.mutex->mutex.sync_level;
+			}
+		}
+
+		/* Always increase acquisition depth */
+
+		obj_desc->method.mutex->mutex.acquisition_depth++;
+	}
+
+	/*
+	 * Allocate an Owner ID for this method, only if this is the first thread
+	 * to begin concurrent execution. We only need one owner_id, even if the
+	 * method is invoked recursively.
+	 */
+	if (!obj_desc->method.owner_id) {
+		status = acpi_ut_allocate_owner_id(&obj_desc->method.owner_id);
+		if (ACPI_FAILURE(status)) {
+			goto cleanup;
+		}
+	}
+
+	/*
+	 * Increment the method parse tree thread count since it has been
+	 * reentered one more time (even if it is the same thread)
+	 */
+	obj_desc->method.thread_count++;
+	return_ACPI_STATUS(status);
+
+      cleanup:
+	/* On error, must release the method mutex (if present) */
+
+	if (obj_desc->method.mutex) {
+		acpi_os_release_mutex(obj_desc->method.mutex->mutex.os_mutex);
+	}
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_call_control_method
+ *
+ * PARAMETERS:  Thread              - Info for this thread
+ *              this_walk_state     - Current walk state
+ *              Op                  - Current Op to be walked
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Transfer execution to a called control method
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_call_control_method(struct acpi_thread_state *thread,
+			    struct acpi_walk_state *this_walk_state,
+			    union acpi_parse_object *op)
+{
+	acpi_status status;
+	struct acpi_namespace_node *method_node;
+	struct acpi_walk_state *next_walk_state = NULL;
+	union acpi_operand_object *obj_desc;
+	struct acpi_evaluate_info *info;
+	u32 i;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_call_control_method, this_walk_state);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "Calling method %p, currentstate=%p\n",
+			  this_walk_state->prev_op, this_walk_state));
+
+	/*
+	 * Get the namespace entry for the control method we are about to call
+	 */
+	method_node = this_walk_state->method_call_node;
+	if (!method_node) {
+		return_ACPI_STATUS(AE_NULL_ENTRY);
+	}
+
+	obj_desc = acpi_ns_get_attached_object(method_node);
+	if (!obj_desc) {
+		return_ACPI_STATUS(AE_NULL_OBJECT);
+	}
+
+	/* Init for new method, possibly wait on method mutex */
+
+	status = acpi_ds_begin_method_execution(method_node, obj_desc,
+						this_walk_state);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Begin method parse/execution. Create a new walk state */
+
+	next_walk_state = acpi_ds_create_walk_state(obj_desc->method.owner_id,
+						    NULL, obj_desc, thread);
+	if (!next_walk_state) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	/*
+	 * The resolved arguments were put on the previous walk state's operand
+	 * stack. Operands on the previous walk state stack always
+	 * start at index 0. Also, null terminate the list of arguments
+	 */
+	this_walk_state->operands[this_walk_state->num_operands] = NULL;
+
+	/*
+	 * Allocate and initialize the evaluation information block
+	 * TBD: this is somewhat inefficient, should change interface to
+	 * ds_init_aml_walk. For now, keeps this struct off the CPU stack
+	 */
+	info = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));
+	if (!info) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	info->parameters = &this_walk_state->operands[0];
+
+	status = acpi_ds_init_aml_walk(next_walk_state, NULL, method_node,
+				       obj_desc->method.aml_start,
+				       obj_desc->method.aml_length, info,
+				       ACPI_IMODE_EXECUTE);
+
+	ACPI_FREE(info);
+	if (ACPI_FAILURE(status)) {
+		goto cleanup;
+	}
+
+	/*
+	 * Delete the operands on the previous walkstate operand stack
+	 * (they were copied to new objects)
+	 */
+	for (i = 0; i < obj_desc->method.param_count; i++) {
+		acpi_ut_remove_reference(this_walk_state->operands[i]);
+		this_walk_state->operands[i] = NULL;
+	}
+
+	/* Clear the operand stack */
+
+	this_walk_state->num_operands = 0;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "**** Begin nested execution of [%4.4s] **** WalkState=%p\n",
+			  method_node->name.ascii, next_walk_state));
+
+	/* Invoke an internal method if necessary */
+
+	if (obj_desc->method.method_flags & AML_METHOD_INTERNAL_ONLY) {
+		status = obj_desc->method.implementation(next_walk_state);
+		if (status == AE_OK) {
+			status = AE_CTRL_TERMINATE;
+		}
+	}
+
+	return_ACPI_STATUS(status);
+
+      cleanup:
+
+	/* On error, we must terminate the method properly */
+
+	acpi_ds_terminate_control_method(obj_desc, next_walk_state);
+	if (next_walk_state) {
+		acpi_ds_delete_walk_state(next_walk_state);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_restart_control_method
+ *
+ * PARAMETERS:  walk_state          - State for preempted method (caller)
+ *              return_desc         - Return value from the called method
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Restart a method that was preempted by another (nested) method
+ *              invocation.  Handle the return value (if any) from the callee.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_restart_control_method(struct acpi_walk_state *walk_state,
+			       union acpi_operand_object *return_desc)
+{
+	acpi_status status;
+	int same_as_implicit_return;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_restart_control_method, walk_state);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "****Restart [%4.4s] Op %p ReturnValueFromCallee %p\n",
+			  acpi_ut_get_node_name(walk_state->method_node),
+			  walk_state->method_call_op, return_desc));
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "    ReturnFromThisMethodUsed?=%X ResStack %p Walk %p\n",
+			  walk_state->return_used,
+			  walk_state->results, walk_state));
+
+	/* Did the called method return a value? */
+
+	if (return_desc) {
+
+		/* Is the implicit return object the same as the return desc? */
+
+		same_as_implicit_return =
+		    (walk_state->implicit_return_obj == return_desc);
+
+		/* Are we actually going to use the return value? */
+
+		if (walk_state->return_used) {
+
+			/* Save the return value from the previous method */
+
+			status = acpi_ds_result_push(return_desc, walk_state);
+			if (ACPI_FAILURE(status)) {
+				acpi_ut_remove_reference(return_desc);
+				return_ACPI_STATUS(status);
+			}
+
+			/*
+			 * Save as THIS method's return value in case it is returned
+			 * immediately to yet another method
+			 */
+			walk_state->return_desc = return_desc;
+		}
+
+		/*
+		 * The following code is the optional support for the so-called
+		 * "implicit return". Some AML code assumes that the last value of the
+		 * method is "implicitly" returned to the caller, in the absence of an
+		 * explicit return value.
+		 *
+		 * Just save the last result of the method as the return value.
+		 *
+		 * NOTE: this is optional because the ASL language does not actually
+		 * support this behavior.
+		 */
+		else if (!acpi_ds_do_implicit_return
+			 (return_desc, walk_state, FALSE)
+			 || same_as_implicit_return) {
+			/*
+			 * Delete the return value if it will not be used by the
+			 * calling method or remove one reference if the explicit return
+			 * is the same as the implicit return value.
+			 */
+			acpi_ut_remove_reference(return_desc);
+		}
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_terminate_control_method
+ *
+ * PARAMETERS:  method_desc         - Method object
+ *              walk_state          - State associated with the method
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Terminate a control method.  Delete everything that the method
+ *              created, delete all locals and arguments, and delete the parse
+ *              tree if requested.
+ *
+ * MUTEX:       Interpreter is locked
+ *
+ ******************************************************************************/
+
+void
+acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
+				 struct acpi_walk_state *walk_state)
+{
+
+	ACPI_FUNCTION_TRACE_PTR(ds_terminate_control_method, walk_state);
+
+	/* method_desc is required, walk_state is optional */
+
+	if (!method_desc) {
+		return_VOID;
+	}
+
+	if (walk_state) {
+
+		/* Delete all arguments and locals */
+
+		acpi_ds_method_data_delete_all(walk_state);
+
+		/*
+		 * If method is serialized, release the mutex and restore the
+		 * current sync level for this thread
+		 */
+		if (method_desc->method.mutex) {
+
+			/* Acquisition Depth handles recursive calls */
+
+			method_desc->method.mutex->mutex.acquisition_depth--;
+			if (!method_desc->method.mutex->mutex.acquisition_depth) {
+				walk_state->thread->current_sync_level =
+				    method_desc->method.mutex->mutex.
+				    original_sync_level;
+
+				acpi_os_release_mutex(method_desc->method.
+						      mutex->mutex.os_mutex);
+				method_desc->method.mutex->mutex.thread_id = NULL;
+			}
+		}
+
+		/*
+		 * Delete any namespace objects created anywhere within
+		 * the namespace by the execution of this method
+		 */
+		acpi_ns_delete_namespace_by_owner(method_desc->method.owner_id);
+	}
+
+	/* Decrement the thread count on the method */
+
+	if (method_desc->method.thread_count) {
+		method_desc->method.thread_count--;
+	} else {
+		ACPI_ERROR((AE_INFO, "Invalid zero thread count in method"));
+	}
+
+	/* Are there any other threads currently executing this method? */
+
+	if (method_desc->method.thread_count) {
+		/*
+		 * Additional threads. Do not release the owner_id in this case,
+		 * we immediately reuse it for the next thread executing this method
+		 */
+		ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+				  "*** Completed execution of one thread, %d threads remaining\n",
+				  method_desc->method.thread_count));
+	} else {
+		/* This is the only executing thread for this method */
+
+		/*
+		 * Support to dynamically change a method from not_serialized to
+		 * Serialized if it appears that the method is incorrectly written and
+		 * does not support multiple thread execution. The best example of this
+		 * is if such a method creates namespace objects and blocks. A second
+		 * thread will fail with an AE_ALREADY_EXISTS exception
+		 *
+		 * This code is here because we must wait until the last thread exits
+		 * before creating the synchronization semaphore.
+		 */
+		if ((method_desc->method.method_flags & AML_METHOD_SERIALIZED)
+		    && (!method_desc->method.mutex)) {
+			(void)acpi_ds_create_method_mutex(method_desc);
+		}
+
+		/* No more threads, we can free the owner_id */
+
+		acpi_ut_release_owner_id(&method_desc->method.owner_id);
+	}
+
+	return_VOID;
+}
