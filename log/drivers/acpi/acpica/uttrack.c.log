commit 800ba7c5eaaa734e4bd66bf0441fc200bbcdca54
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 10 11:31:49 2020 -0800

    ACPICA: All acpica: Update copyrights to 2020 Including tool signons.
    
    ACPICA commit 8b9c69d0984067051ffbe8526f871448ead6a26b
    
    Link: https://github.com/acpica/acpica/commit/8b9c69d0
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Kaneda <erik.kaneda@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 14de4d15e618..d366be431a84 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -3,7 +3,7 @@
  *
  * Module Name: uttrack - Memory allocation tracking routines (debug only)
  *
- * Copyright (C) 2000 - 2019, Intel Corp.
+ * Copyright (C) 2000 - 2020, Intel Corp.
  *
  *****************************************************************************/
 

commit edc5935ec777c23d66df5d47de53b4a2c8f16d0f
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Oct 25 14:36:49 2019 -0700

    ACPICA: Results from Clang
    
    ACPICA commit 1f08279b3eb13f17004159c28c391a390cd68feb
    
    Changes/fixes From Clang V5.0.1.  Mostly "set but never read"
    warnings.
    
    Link: https://github.com/acpica/acpica/commit/1f08279b
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 8052f7ef5025..14de4d15e618 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -660,7 +660,7 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 					case ACPI_DESC_TYPE_PARSER:
 
 						acpi_os_printf
-						    ("AmlOpcode 0x%04hX\n",
+						    ("AmlOpcode 0x%04X\n",
 						     descriptor->op.asl.
 						     aml_opcode);
 						break;

commit 840c02ca2215af648c781ae680d93d8aecd083b7
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jan 14 09:55:25 2019 -0800

    ACPICA: All acpica: Update copyrights to 2019
    
    ACPICA commit 62f4f98e941d86e41969bf2ab5a93b8dc94dc49e
    
    The update includes userspace tool signons.
    
    Link: https://github.com/acpica/acpica/commit/62f4f98e
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index f6b55e2482ee..8052f7ef5025 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -3,7 +3,7 @@
  *
  * Module Name: uttrack - Memory allocation tracking routines (debug only)
  *
- * Copyright (C) 2000 - 2018, Intel Corp.
+ * Copyright (C) 2000 - 2019, Intel Corp.
  *
  *****************************************************************************/
 

commit 894b5cc535b81d14e721b2c30fd4a238efce7f41
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jan 14 09:55:24 2019 -0800

    ACPICA: acpiexec: Add option to dump extra info for memory leaks
    
    ACPICA commit f77565e28b90ee7e06f53a474183ef72300c3574
    
    Dump entire object/buffer for any memory leaks detected by
    the object/cache tracking mechanism.
    
    Link: https://github.com/acpica/acpica/commit/f77565e2
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 016a6621cc6f..f6b55e2482ee 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -588,6 +588,18 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 					     acpi_ut_get_descriptor_name
 					     (descriptor));
 
+					/* Optional object hex dump */
+
+					if (acpi_gbl_verbose_leak_dump) {
+						acpi_os_printf("\n");
+						acpi_ut_dump_buffer((u8 *)
+								    descriptor,
+								    element->
+								    size,
+								    DB_BYTE_DISPLAY,
+								    0);
+					}
+
 					/* Validate the descriptor type using Type field and length */
 
 					descriptor_type = 0;	/* Not a valid descriptor type */

commit 95857638889aeea1b10a16b55041adf3e3ab84c4
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Wed Mar 14 16:13:07 2018 -0700

    ACPICA: adding SPDX headers
    
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 8cc70ca4e0fb..016a6621cc6f 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -1,45 +1,11 @@
+// SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
 /******************************************************************************
  *
  * Module Name: uttrack - Memory allocation tracking routines (debug only)
  *
- *****************************************************************************/
-
-/*
  * Copyright (C) 2000 - 2018, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
+ *
+ *****************************************************************************/
 
 /*
  * These procedures are used for tracking memory leaks in the subsystem, and

commit da6f8320d58623eae9b6fa2f09b1b4f60a772ce9
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 4 10:06:38 2018 -0800

    ACPICA: All acpica: Update copyrights to 2018
    
    including tool signons.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 633b4e2c669f..8cc70ca4e0fb 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2017, Intel Corp.
+ * Copyright (C) 2000 - 2018, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit ee68d4773ed36e3f79860bbcad0a4ddd8d58f393
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 4 13:41:27 2018 -0800

    ACPICA: Create and deploy safe version of strncpy
    
    ACPICA commit 64ad9c69a1bd534a466e060a33c0bbf5fc9e189c
    
    acpi_ut_safe_strncpy - copy and terminate string. Strncpy is not
    guaranteed to terminate the copied string if the input is longer
    than the length of the target.
    
    No functional change.
    
    Link: https://github.com/acpica/acpica/commit/64ad9c69
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 28a302eb2015..633b4e2c669f 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -402,8 +402,8 @@ acpi_ut_track_allocation(struct acpi_debug_mem_block *allocation,
 	allocation->component = component;
 	allocation->line = line;
 
-	strncpy(allocation->module, module, ACPI_MAX_MODULE_NAME);
-	allocation->module[ACPI_MAX_MODULE_NAME - 1] = 0;
+	acpi_ut_safe_strncpy(allocation->module, (char *)module,
+			     ACPI_MAX_MODULE_NAME);
 
 	if (!element) {
 

commit b12ebe59353c76e08d4a956a2c8a6a13b3b98839
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Fri Nov 17 15:42:20 2017 -0800

    ACPICA: ACPICA: style edits to utility function output, no functional change
    
    ACPICA commit 8070a23749f1c2eedec313f42f564b5375054137
    
    Link: https://github.com/acpica/acpica/commit/8070a237
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 3c8de88ecbd5..28a302eb2015 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -717,7 +717,7 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 	if (!num_outstanding) {
 		ACPI_INFO(("No outstanding allocations"));
 	} else {
-		ACPI_ERROR((AE_INFO, "%u(0x%X) Outstanding allocations",
+		ACPI_ERROR((AE_INFO, "%u (0x%X) Outstanding cache allocations",
 			    num_outstanding, num_outstanding));
 	}
 

commit a62a7117d91ca83d319566cbe16039f4e9f413c2
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Aug 3 14:27:22 2017 +0800

    ACPICA: Implement deferred resolution of reference package elements
    
    ACPICA commit 0c08790c56fdf0dc081ae869495a09d8c4230854
    
    This change defers the resolution of package elements that
    are named references until after the entire namespace has been
    loaded from the definition block. This allows such references
    to be in fact forward references for both module level code
    and control methods.
    
    Link: https://github.com/acpica/acpica/commit/0c08790c
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 9a07a42cae34..3c8de88ecbd5 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -591,6 +591,10 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 		return_VOID;
 	}
 
+	if (!acpi_gbl_global_list) {
+		goto exit;
+	}
+
 	element = acpi_gbl_global_list->list_head;
 	while (element) {
 		if ((element->component & component) &&
@@ -602,7 +606,7 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 
 			if (element->size <
 			    sizeof(struct acpi_common_descriptor)) {
-				acpi_os_printf("%p Length 0x%04X %9.9s-%u "
+				acpi_os_printf("%p Length 0x%04X %9.9s-%4.4u "
 					       "[Not a Descriptor - too small]\n",
 					       descriptor, element->size,
 					       element->module, element->line);
@@ -612,7 +616,7 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 				if (ACPI_GET_DESCRIPTOR_TYPE(descriptor) !=
 				    ACPI_DESC_TYPE_CACHED) {
 					acpi_os_printf
-					    ("%p Length 0x%04X %9.9s-%u [%s] ",
+					    ("%p Length 0x%04X %9.9s-%4.4u [%s] ",
 					     descriptor, element->size,
 					     element->module, element->line,
 					     acpi_ut_get_descriptor_name
@@ -705,6 +709,7 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 		element = element->next;
 	}
 
+exit:
 	(void)acpi_ut_release_mutex(ACPI_MTX_MEMORY);
 
 	/* Print summary */

commit 7735ca0eb4ebd6d47fdad40602d0ba7593219f8c
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Feb 8 11:00:08 2017 +0800

    ACPICA: Source tree: Update copyright notices to 2017
    
    ACPICA commit 16577e5265923f4999b4d2c0addb2343b18135e1
    
    Affects all files.
    
    Link: https://github.com/acpica/acpica/commit/16577e52
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index df31d71ce596..9a07a42cae34 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2016, Intel Corp.
+ * Copyright (C) 2000 - 2017, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 9556ec4ec1d3575090f1f110c558169c5f0973a9
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Aug 4 16:43:32 2016 +0800

    ACPICA: Use os_allocate_zeroed
    
    ACPICA commit 2b896c59e53243c95600f2a3f7e1fd02c044cb37
    
    Eliminates an unnecessary memset.
    
    Suggested-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Link: https://github.com/acpica/acpica/commit/2b896c59
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 0df07dfa53b6..df31d71ce596 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -95,13 +95,11 @@ acpi_ut_create_list(const char *list_name,
 {
 	struct acpi_memory_list *cache;
 
-	cache = acpi_os_allocate(sizeof(struct acpi_memory_list));
+	cache = acpi_os_allocate_zeroed(sizeof(struct acpi_memory_list));
 	if (!cache) {
 		return (AE_NO_MEMORY);
 	}
 
-	memset(cache, 0, sizeof(struct acpi_memory_list));
-
 	cache->list_name = list_name;
 	cache->object_size = object_size;
 

commit 0dfaaa3d51df011c16279bb010bff90f45b6d62c
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Mar 24 09:40:40 2016 +0800

    ACPICA: All: const keyword changes across the ACPICA source
    
    ACPICA commit a240cbb93647bddf525b3daf6e9d31b8b9bca34e
    
    Integrated most changes proposed by net_BSD.
    >From joerg@net_BSD.org (Joerg Sonnenberger)
    ACPICA BZ 732.
    
    Link: https://github.com/acpica/acpica/commit/a240cbb9
    Link: https://bugs.acpica.org/show_bug.cgi?id=732
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 60c406a8efcb..0df07dfa53b6 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -90,7 +90,7 @@ acpi_ut_remove_allocation(struct acpi_debug_mem_block *address,
  ******************************************************************************/
 
 acpi_status
-acpi_ut_create_list(char *list_name,
+acpi_ut_create_list(const char *list_name,
 		    u16 object_size, struct acpi_memory_list **return_cache)
 {
 	struct acpi_memory_list *cache;

commit 05fb04b54f6b67f4eb901e99dd5b4604b46ffa0f
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Feb 19 14:16:42 2016 +0800

    ACPICA: Remove unnecessary arguments to ACPI_INFO
    
    ACPICA commit 181f56605a771e0b91e24b0648d2565ca70bea20
    
    This is used as a purely infomation message, without module name
    and line number information. Therefore, these arguments are
    not needed and they are unnecessary overhead.
    Arguments are removed.
    ACPICA BZ 872.
    
    Link: https://github.com/acpica/acpica/commit/181f5660
    Link: https://bugs.acpica.org/show_bug.cgi?id=872
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index c7c2bb8f3559..60c406a8efcb 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -712,7 +712,7 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 	/* Print summary */
 
 	if (!num_outstanding) {
-		ACPI_INFO((AE_INFO, "No outstanding allocations"));
+		ACPI_INFO(("No outstanding allocations"));
 	} else {
 		ACPI_ERROR((AE_INFO, "%u(0x%X) Outstanding allocations",
 			    num_outstanding, num_outstanding));

commit c8100dc4643d80a94f074dfc8a2af3d3d327b7aa
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 15 08:17:03 2016 +0800

    ACPICA: Additional 2016 copyright changes
    
    All tool/utility signons.
    Dual-license module header.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index ea698e98442e..c7c2bb8f3559 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2015, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 1fad87385e7e82f656fb661aef0f841e42991974
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Dec 29 13:54:36 2015 +0800

    ACPICA: Core: Major update for code formatting, no functional changes
    
    ACPICA commit dfa394471f6c01b2ee9433dbc143ec70cb9bca72
    
    Mostly indentation inconsistencies across the code. Split
    some long lines, etc.
    
    Link: https://github.com/acpica/acpica/commit/dfa39447
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 9a7dc8196a5d..ea698e98442e 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -150,9 +150,9 @@ void *acpi_ut_allocate_and_track(acpi_size size,
 		return (NULL);
 	}
 
-	status = acpi_ut_track_allocation(allocation, size,
-					  ACPI_MEM_MALLOC, component, module,
-					  line);
+	status =
+	    acpi_ut_track_allocation(allocation, size, ACPI_MEM_MALLOC,
+				     component, module, line);
 	if (ACPI_FAILURE(status)) {
 		acpi_os_free(allocation);
 		return (NULL);
@@ -161,6 +161,7 @@ void *acpi_ut_allocate_and_track(acpi_size size,
 	acpi_gbl_global_list->total_allocated++;
 	acpi_gbl_global_list->total_size += (u32)size;
 	acpi_gbl_global_list->current_total_size += (u32)size;
+
 	if (acpi_gbl_global_list->current_total_size >
 	    acpi_gbl_global_list->max_occupied) {
 		acpi_gbl_global_list->max_occupied =
@@ -223,6 +224,7 @@ void *acpi_ut_allocate_zeroed_and_track(acpi_size size,
 	acpi_gbl_global_list->total_allocated++;
 	acpi_gbl_global_list->total_size += (u32)size;
 	acpi_gbl_global_list->current_total_size += (u32)size;
+
 	if (acpi_gbl_global_list->current_total_size >
 	    acpi_gbl_global_list->max_occupied) {
 		acpi_gbl_global_list->max_occupied =
@@ -269,8 +271,8 @@ acpi_ut_free_and_track(void *allocation,
 	acpi_gbl_global_list->total_freed++;
 	acpi_gbl_global_list->current_total_size -= debug_block->size;
 
-	status = acpi_ut_remove_allocation(debug_block,
-					   component, module, line);
+	status =
+	    acpi_ut_remove_allocation(debug_block, component, module, line);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Could not free memory"));
 	}
@@ -525,35 +527,35 @@ void acpi_ut_dump_allocation_info(void)
 
 /*
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-			  ("%30s: %4d (%3d Kb)\n", "Current allocations",
-			  mem_list->current_count,
-			  ROUND_UP_TO_1K (mem_list->current_size)));
+		("%30s: %4d (%3d Kb)\n", "Current allocations",
+		mem_list->current_count,
+		ROUND_UP_TO_1K (mem_list->current_size)));
 
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-			  ("%30s: %4d (%3d Kb)\n", "Max concurrent allocations",
-			  mem_list->max_concurrent_count,
-			  ROUND_UP_TO_1K (mem_list->max_concurrent_size)));
+		("%30s: %4d (%3d Kb)\n", "Max concurrent allocations",
+		mem_list->max_concurrent_count,
+		ROUND_UP_TO_1K (mem_list->max_concurrent_size)));
 
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-			  ("%30s: %4d (%3d Kb)\n", "Total (all) internal objects",
-			  running_object_count,
-			  ROUND_UP_TO_1K (running_object_size)));
+		("%30s: %4d (%3d Kb)\n", "Total (all) internal objects",
+		running_object_count,
+		ROUND_UP_TO_1K (running_object_size)));
 
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-			  ("%30s: %4d (%3d Kb)\n", "Total (all) allocations",
-			  running_alloc_count,
-			  ROUND_UP_TO_1K (running_alloc_size)));
+		("%30s: %4d (%3d Kb)\n", "Total (all) allocations",
+		running_alloc_count,
+		ROUND_UP_TO_1K (running_alloc_size)));
 
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-			  ("%30s: %4d (%3d Kb)\n", "Current Nodes",
-			  acpi_gbl_current_node_count,
-			  ROUND_UP_TO_1K (acpi_gbl_current_node_size)));
+		("%30s: %4d (%3d Kb)\n", "Current Nodes",
+		acpi_gbl_current_node_count,
+		ROUND_UP_TO_1K (acpi_gbl_current_node_size)));
 
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-			  ("%30s: %4d (%3d Kb)\n", "Max Nodes",
-			  acpi_gbl_max_concurrent_node_count,
-			  ROUND_UP_TO_1K ((acpi_gbl_max_concurrent_node_count *
-					 sizeof (struct acpi_namespace_node)))));
+		("%30s: %4d (%3d Kb)\n", "Max Nodes",
+		acpi_gbl_max_concurrent_node_count,
+		ROUND_UP_TO_1K ((acpi_gbl_max_concurrent_node_count *
+			sizeof (struct acpi_namespace_node)))));
 */
 	return_VOID;
 }

commit 4fa4616e279df89baeb36287bbee83ab272edaed
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Jul 1 14:45:11 2015 +0800

    ACPICA: De-macroize calls to standard C library functions
    
    ACPICA commit 3b1026e0bdd3c32eb6d5d313f3ba0b1fee7597b4
    ACPICA commit 00f0dc83f5cfca53b27a3213ae0d7719b88c2d6b
    ACPICA commit 47d22a738d0e19fd241ffe4e3e9d4e198e4afc69
    
    Across all of ACPICA. Replace C library macros such as ACPI_STRLEN with the
    standard names such as strlen. The original purpose for these macros is
    long since obsolete.
    Also cast various invocations as necessary. Bob Moore, Jung-uk Kim, Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/3b1026e0
    Link: https://github.com/acpica/acpica/commit/00f0dc83
    Link: https://github.com/acpica/acpica/commit/47d22a73
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Jung-uk Kim <jkim@FreeBSD.org>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 130dd9f96f0f..9a7dc8196a5d 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -100,7 +100,7 @@ acpi_ut_create_list(char *list_name,
 		return (AE_NO_MEMORY);
 	}
 
-	ACPI_MEMSET(cache, 0, sizeof(struct acpi_memory_list));
+	memset(cache, 0, sizeof(struct acpi_memory_list));
 
 	cache->list_name = list_name;
 	cache->object_size = object_size;
@@ -402,7 +402,7 @@ acpi_ut_track_allocation(struct acpi_debug_mem_block *allocation,
 	allocation->component = component;
 	allocation->line = line;
 
-	ACPI_STRNCPY(allocation->module, module, ACPI_MAX_MODULE_NAME);
+	strncpy(allocation->module, module, ACPI_MAX_MODULE_NAME);
 	allocation->module[ACPI_MAX_MODULE_NAME - 1] = 0;
 
 	if (!element) {
@@ -497,7 +497,7 @@ acpi_ut_remove_allocation(struct acpi_debug_mem_block *allocation,
 
 	/* Mark the segment as deleted */
 
-	ACPI_MEMSET(&allocation->user_space, 0xEA, allocation->size);
+	memset(&allocation->user_space, 0xEA, allocation->size);
 
 	status = acpi_ut_release_mutex(ACPI_MTX_MEMORY);
 	return (status);
@@ -595,7 +595,7 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 	while (element) {
 		if ((element->component & component) &&
 		    ((module == NULL)
-		     || (0 == ACPI_STRCMP(module, element->module)))) {
+		     || (0 == strcmp(module, element->module)))) {
 			descriptor =
 			    ACPI_CAST_PTR(union acpi_descriptor,
 					  &element->user_space);

commit 82a809419429f2e6142d2c5d88d91661f8aecb87
Author: David E. Box <david.e.box@linux.intel.com>
Date:   Thu Feb 5 15:20:45 2015 +0800

    ACPICA: Update Copyright headers to 2015
    
    ACPICA commit 8990e73ab2aa15d6a0068b860ab54feff25bee36
    
    Link: https://github.com/acpica/acpica/commit/8990e73a
    Signed-off-by: David E. Box <david.e.box@linux.intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 7d0ee969d781..130dd9f96f0f 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2014, Intel Corp.
+ * Copyright (C) 2000 - 2015, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit fbb7a2dc2be493c87399550bdc2ddaa510cdf450
Author: Bob Moore <robert.moore@intel.com>
Date:   Sat Feb 8 09:42:25 2014 +0800

    ACPICA: Update ACPICA copyrights to 2014.
    
    Update ACPICA copyrights to 2014. Includes all source headers and
    signons for the various tools.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 4e367387feb3..7d0ee969d781 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2013, Intel Corp.
+ * Copyright (C) 2000 - 2014, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit d72c17a8674fc143e1c7781e55fa362626353167
Author: Bob Moore <robert.moore@intel.com>
Date:   Sat Feb 8 09:42:12 2014 +0800

    ACPICA: Utilities: Load of local test tables is now optional.
    
    The utility has the capability to load some various tables to test
    features of ACPICA. However, there are enough of them that the output
    of the utility became confusing. With this change, only the required
    local tables are displayed (RSDP, XSDT, etc.) along with the actual
    tables loaded via the command line specification. This makes the
    default output simler and easier to understand. The -el command line
    option restores the original behavior for testing purposes.
    
    This patch doesn't affect kernel behavior as Linux doesn't use ACPICA
    allocation tracking implementation.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index c0027773cccb..4e367387feb3 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -276,7 +276,8 @@ acpi_ut_free_and_track(void *allocation,
 	}
 
 	acpi_os_free(debug_block);
-	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "%p freed\n", allocation));
+	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "%p freed (block %p)\n",
+			  allocation, debug_block));
 	return_VOID;
 }
 

commit 10622bf8ce432e6a53fd3c37163e99e99c9e43ee
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Oct 29 09:30:02 2013 +0800

    ACPICA: Linuxize: Change indentation of C labels.
    
    It is reported by kernel build test systems that all ACPICA source
    files in the kernel tree have incorrect label indentation.  This
    patch changes default indent option used in the release process to
    fix this bug.  Lv Zheng.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 77e3eb7d7c04..c0027773cccb 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -430,7 +430,7 @@ acpi_ut_track_allocation(struct acpi_debug_mem_block *allocation,
 		element->next = allocation;
 	}
 
-      unlock_and_exit:
+unlock_and_exit:
 	status = acpi_ut_release_mutex(ACPI_MTX_MEMORY);
 	return_ACPI_STATUS(status);
 }

commit b3c86c30efd83ebfa7010c5890e2ebf2678e49f8
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Oct 29 09:29:27 2013 +0800

    ACPICA: Cleanup memory allocation macros and configurability.
    
    In the common case, the ACPI_ALLOCATE and related macros now resolve
    directly to their respective acpi_os* OSL interfaces. Two options:
    1) The ACPI_ALLOCATE_ZEROED macro defaults to a simple local implementation
       by default, unless overridden by the USE_NATIVE_ALLOCATE_ZEROED define.
    2) For ACPI execution simulation environment (AcpiExec) which is not
       shipped with the Linux kernel, the macros can optionally be resolved to
       the local interfaces that track each allocation (used to immediately
       detect memory leaks).
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 160f13f4aab5..77e3eb7d7c04 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -130,10 +130,23 @@ void *acpi_ut_allocate_and_track(acpi_size size,
 	struct acpi_debug_mem_block *allocation;
 	acpi_status status;
 
+	/* Check for an inadvertent size of zero bytes */
+
+	if (!size) {
+		ACPI_WARNING((module, line,
+			      "Attempt to allocate zero bytes, allocating 1 byte"));
+		size = 1;
+	}
+
 	allocation =
-	    acpi_ut_allocate(size + sizeof(struct acpi_debug_mem_header),
-			     component, module, line);
+	    acpi_os_allocate(size + sizeof(struct acpi_debug_mem_header));
 	if (!allocation) {
+
+		/* Report allocation error */
+
+		ACPI_WARNING((module, line,
+			      "Could not allocate size %u", (u32)size));
+
 		return (NULL);
 	}
 
@@ -179,9 +192,17 @@ void *acpi_ut_allocate_zeroed_and_track(acpi_size size,
 	struct acpi_debug_mem_block *allocation;
 	acpi_status status;
 
+	/* Check for an inadvertent size of zero bytes */
+
+	if (!size) {
+		ACPI_WARNING((module, line,
+			      "Attempt to allocate zero bytes, allocating 1 byte"));
+		size = 1;
+	}
+
 	allocation =
-	    acpi_ut_allocate_zeroed(size + sizeof(struct acpi_debug_mem_header),
-				    component, module, line);
+	    acpi_os_allocate_zeroed(size +
+				    sizeof(struct acpi_debug_mem_header));
 	if (!allocation) {
 
 		/* Report allocation error */

commit 1d1ea1b723d9f239f736b8cf284327cbbf9d15d1
Author: Chao Guan <chao.guan@intel.com>
Date:   Sat Jun 8 00:58:14 2013 +0000

    ACPICA: Standardize all switch() blocks
    
    After many years, different formatting for switch() has crept in.
    This change makes every switch block identical. Chao Guan.
    ACPICA bugzilla 997.
    
    References: https://bugs.acpica.org/show_bug.cgi?id=997
    Signed-off-by: Chao Guan <chao.guan@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 62774c7b76a8..160f13f4aab5 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -603,6 +603,7 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 					switch (ACPI_GET_DESCRIPTOR_TYPE
 						(descriptor)) {
 					case ACPI_DESC_TYPE_OPERAND:
+
 						if (element->size ==
 						    sizeof(union
 							   acpi_operand_object))
@@ -613,6 +614,7 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 						break;
 
 					case ACPI_DESC_TYPE_PARSER:
+
 						if (element->size ==
 						    sizeof(union
 							   acpi_parse_object)) {
@@ -622,6 +624,7 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 						break;
 
 					case ACPI_DESC_TYPE_NAMED:
+
 						if (element->size ==
 						    sizeof(struct
 							   acpi_namespace_node))
@@ -632,6 +635,7 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 						break;
 
 					default:
+
 						break;
 					}
 
@@ -639,6 +643,7 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 
 					switch (descriptor_type) {
 					case ACPI_DESC_TYPE_OPERAND:
+
 						acpi_os_printf
 						    ("%12.12s RefCount 0x%04X\n",
 						     acpi_ut_get_type_name
@@ -649,6 +654,7 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 						break;
 
 					case ACPI_DESC_TYPE_PARSER:
+
 						acpi_os_printf
 						    ("AmlOpcode 0x%04hX\n",
 						     descriptor->op.asl.
@@ -656,6 +662,7 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 						break;
 
 					case ACPI_DESC_TYPE_NAMED:
+
 						acpi_os_printf("%4.4s\n",
 							       acpi_ut_get_node_name
 							       (&descriptor->
@@ -663,6 +670,7 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 						break;
 
 					default:
+
 						acpi_os_printf("\n");
 						break;
 					}

commit 25f044e64568dd83de34c16c837a96bbb2b0cecb
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 25 05:38:56 2013 +0000

    ACPICA: Update ACPICA copyrights to 2013
    
    Includes all source headers and signons for the various tools.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 866f96e14ade..62774c7b76a8 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2013, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 0e770b3263816b4445e2c855f641b172aa26291a
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Dec 19 05:37:59 2012 +0000

    ACPICA: Performance: Remove function tracing from critical allocation functions.
    
    Tracing is no longer needed for many of the low-level function.
    Removing the trace mechanism from these functions improves
    performance a small amount, also simplifies the debug trace output.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index a424a9e3fea4..866f96e14ade 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -436,10 +436,10 @@ acpi_ut_remove_allocation(struct acpi_debug_mem_block *allocation,
 	struct acpi_memory_list *mem_list;
 	acpi_status status;
 
-	ACPI_FUNCTION_TRACE(ut_remove_allocation);
+	ACPI_FUNCTION_NAME(ut_remove_allocation);
 
 	if (acpi_gbl_disable_mem_tracking) {
-		return_ACPI_STATUS(AE_OK);
+		return (AE_OK);
 	}
 
 	mem_list = acpi_gbl_global_list;
@@ -450,12 +450,12 @@ acpi_ut_remove_allocation(struct acpi_debug_mem_block *allocation,
 		ACPI_ERROR((module, line,
 			    "Empty allocation list, nothing to free!"));
 
-		return_ACPI_STATUS(AE_OK);
+		return (AE_OK);
 	}
 
 	status = acpi_ut_acquire_mutex(ACPI_MTX_MEMORY);
 	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
+		return (status);
 	}
 
 	/* Unlink */
@@ -470,15 +470,15 @@ acpi_ut_remove_allocation(struct acpi_debug_mem_block *allocation,
 		(allocation->next)->previous = allocation->previous;
 	}
 
+	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "Freeing %p, size 0%X\n",
+			  &allocation->user_space, allocation->size));
+
 	/* Mark the segment as deleted */
 
 	ACPI_MEMSET(&allocation->user_space, 0xEA, allocation->size);
 
-	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "Freeing size 0%X\n",
-			  allocation->size));
-
 	status = acpi_ut_release_mutex(ACPI_MTX_MEMORY);
-	return_ACPI_STATUS(status);
+	return (status);
 }
 
 /*******************************************************************************

commit d8da9151bb7e2d18624fdd8dbb066419186f0ec1
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Oct 31 02:27:32 2012 +0000

    ACPICA: AcpiExec: Improve algorithm for tracking memory leaks
    
    Add some intelligence to the code that maintains the global
    list of allocated memory. The list is now ordered by allocated
    memory address, significantly improving performance.  When running
    AcpiExec on the ASLTS test suite, speed improvements of 3X to 5X
    are seen, depending on the platform and/or the environment.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 79f311c3d1c4..a424a9e3fea4 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -61,7 +61,9 @@
 ACPI_MODULE_NAME("uttrack")
 
 /* Local prototypes */
-static struct acpi_debug_mem_block *acpi_ut_find_allocation(void *allocation);
+static struct acpi_debug_mem_block *acpi_ut_find_allocation(struct
+							    acpi_debug_mem_block
+							    *allocation);
 
 static acpi_status
 acpi_ut_track_allocation(struct acpi_debug_mem_block *address,
@@ -263,31 +265,61 @@ acpi_ut_free_and_track(void *allocation,
  *
  * PARAMETERS:  allocation              - Address of allocated memory
  *
- * RETURN:      A list element if found; NULL otherwise.
+ * RETURN:      Three cases:
+ *              1) List is empty, NULL is returned.
+ *              2) Element was found. Returns Allocation parameter.
+ *              3) Element was not found. Returns position where it should be
+ *                  inserted into the list.
  *
  * DESCRIPTION: Searches for an element in the global allocation tracking list.
+ *              If the element is not found, returns the location within the
+ *              list where the element should be inserted.
+ *
+ *              Note: The list is ordered by larger-to-smaller addresses.
+ *
+ *              This global list is used to detect memory leaks in ACPICA as
+ *              well as other issues such as an attempt to release the same
+ *              internal object more than once. Although expensive as far
+ *              as cpu time, this list is much more helpful for finding these
+ *              types of issues than using memory leak detectors outside of
+ *              the ACPICA code.
  *
  ******************************************************************************/
 
-static struct acpi_debug_mem_block *acpi_ut_find_allocation(void *allocation)
+static struct acpi_debug_mem_block *acpi_ut_find_allocation(struct
+							    acpi_debug_mem_block
+							    *allocation)
 {
 	struct acpi_debug_mem_block *element;
 
-	ACPI_FUNCTION_ENTRY();
-
 	element = acpi_gbl_global_list->list_head;
+	if (!element) {
+		return (NULL);
+	}
+
+	/*
+	 * Search for the address.
+	 *
+	 * Note: List is ordered by larger-to-smaller addresses, on the
+	 * assumption that a new allocation usually has a larger address
+	 * than previous allocations.
+	 */
+	while (element > allocation) {
 
-	/* Search for the address. */
+		/* Check for end-of-list */
 
-	while (element) {
-		if (element == allocation) {
+		if (!element->next) {
 			return (element);
 		}
 
 		element = element->next;
 	}
 
-	return (NULL);
+	if (element == allocation) {
+		return (element);
+	}
+
+	return (element->previous);
 }
 
 /*******************************************************************************
@@ -301,7 +333,7 @@ static struct acpi_debug_mem_block *acpi_ut_find_allocation(void *allocation)
  *              module              - Source file name of caller
  *              line                - Line number of caller
  *
- * RETURN:      None.
+ * RETURN:      Status
  *
  * DESCRIPTION: Inserts an element into the global allocation tracking list.
  *
@@ -330,22 +362,18 @@ acpi_ut_track_allocation(struct acpi_debug_mem_block *allocation,
 	}
 
 	/*
-	 * Search list for this address to make sure it is not already on the list.
-	 * This will catch several kinds of problems.
+	 * Search the global list for this address to make sure it is not
+	 * already present. This will catch several kinds of problems.
 	 */
 	element = acpi_ut_find_allocation(allocation);
-	if (element) {
+	if (element == allocation) {
 		ACPI_ERROR((AE_INFO,
-			    "UtTrackAllocation: Allocation already present in list! (%p)",
+			    "UtTrackAllocation: Allocation (%p) already present in global list!",
 			    allocation));
-
-		ACPI_ERROR((AE_INFO, "Element %p Address %p",
-			    element, allocation));
-
 		goto unlock_and_exit;
 	}
 
-	/* Fill in the instance data. */
+	/* Fill in the instance data */
 
 	allocation->size = (u32)size;
 	allocation->alloc_type = alloc_type;
@@ -355,17 +383,31 @@ acpi_ut_track_allocation(struct acpi_debug_mem_block *allocation,
 	ACPI_STRNCPY(allocation->module, module, ACPI_MAX_MODULE_NAME);
 	allocation->module[ACPI_MAX_MODULE_NAME - 1] = 0;
 
-	/* Insert at list head */
+	if (!element) {
 
-	if (mem_list->list_head) {
-		((struct acpi_debug_mem_block *)(mem_list->list_head))->
-		    previous = allocation;
-	}
+		/* Insert at list head */
+
+		if (mem_list->list_head) {
+			((struct acpi_debug_mem_block *)(mem_list->list_head))->
+			    previous = allocation;
+		}
+
+		allocation->next = mem_list->list_head;
+		allocation->previous = NULL;
 
-	allocation->next = mem_list->list_head;
-	allocation->previous = NULL;
+		mem_list->list_head = allocation;
+	} else {
+		/* Insert after element */
+
+		allocation->next = element->next;
+		allocation->previous = element;
+
+		if (element->next) {
+			(element->next)->previous = allocation;
+		}
 
-	mem_list->list_head = allocation;
+		element->next = allocation;
+	}
 
       unlock_and_exit:
 	status = acpi_ut_release_mutex(ACPI_MTX_MEMORY);
@@ -381,7 +423,7 @@ acpi_ut_track_allocation(struct acpi_debug_mem_block *allocation,
  *              module              - Source file name of caller
  *              line                - Line number of caller
  *
- * RETURN:
+ * RETURN:      Status
  *
  * DESCRIPTION: Deletes an element from the global allocation tracking list.
  *
@@ -443,7 +485,7 @@ acpi_ut_remove_allocation(struct acpi_debug_mem_block *allocation,
  *
  * FUNCTION:    acpi_ut_dump_allocation_info
  *
- * PARAMETERS:
+ * PARAMETERS:  None
  *
  * RETURN:      None
  *

commit 73a3090a2160fb01317f5a44af6ee5a064a29625
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Oct 31 02:26:55 2012 +0000

    ACPICA: Remove extra spaces after periods within comments
    
    This makes all comments consistent.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index e79c49d44d08..79f311c3d1c4 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -45,9 +45,9 @@
  * These procedures are used for tracking memory leaks in the subsystem, and
  * they get compiled out when the ACPI_DBG_TRACK_ALLOCATIONS is not set.
  *
- * Each memory allocation is tracked via a doubly linked list.  Each
+ * Each memory allocation is tracked via a doubly linked list. Each
  * element contains the caller's component, module name, function name, and
- * line number.  acpi_ut_allocate and acpi_ut_allocate_zeroed call
+ * line number. acpi_ut_allocate and acpi_ut_allocate_zeroed call
  * acpi_ut_track_allocation to add an element to the list; deletion
  * occurs in the body of acpi_ut_free.
  */
@@ -499,7 +499,7 @@ void acpi_ut_dump_allocation_info(void)
  * FUNCTION:    acpi_ut_dump_allocations
  *
  * PARAMETERS:  component           - Component(s) to dump info for.
- *              module              - Module to dump info for.  NULL means all.
+ *              module              - Module to dump info for. NULL means all.
  *
  * RETURN:      None
  *

commit 68aafc35161dcc9d365a32c2f9f077aedc61754d
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Oct 31 02:26:01 2012 +0000

    ACPICA: Audit/update for ACPICA return macros and debug depth counter
    
    1) Ensure that all functions that use the various TRACE macros
       also use the appropriate ACPICA return macros.
    2) Ensure that all normal return statements surround the return
       expression (value) with parens.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 73ca27d40f9f..e79c49d44d08 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -517,14 +517,14 @@ void acpi_ut_dump_allocations(u32 component, const char *module)
 	ACPI_FUNCTION_TRACE(ut_dump_allocations);
 
 	if (acpi_gbl_disable_mem_tracking) {
-		return;
+		return_VOID;
 	}
 
 	/*
 	 * Walk the allocation list.
 	 */
 	if (ACPI_FAILURE(acpi_ut_acquire_mutex(ACPI_MTX_MEMORY))) {
-		return;
+		return_VOID;
 	}
 
 	element = acpi_gbl_global_list->list_head;

commit 6d33b6be17dd6a0934396704f969ceb7f3206347
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Oct 31 02:25:05 2012 +0000

    ACPICA: Fix unmerged utility divergences.
    
    Utility improvements in ACPICA are partial ignored by ACPICA Linux
    release.  This will lead to divergences between Linux and ACPICA.
    This patch ports the entire "utility" into Linux and makes them
    igored in the compilation stage by "ACPI_FUTURE_USAGE".
    The following "Utility" files have been ported into the Linux:
      drivers/acpi/uttrack.c
      drivers/acpi/utcache.c
      drivers/acpi/utids.c
    
    This patch will not affect the generated vmlinx binary.
    This will decrease 274 lines of 20120913 divergence.diff.
    
    Signed-off-by: Robert Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
new file mode 100644
index 000000000000..73ca27d40f9f
--- /dev/null
+++ b/drivers/acpi/acpica/uttrack.c
@@ -0,0 +1,650 @@
+/******************************************************************************
+ *
+ * Module Name: uttrack - Memory allocation tracking routines (debug only)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+/*
+ * These procedures are used for tracking memory leaks in the subsystem, and
+ * they get compiled out when the ACPI_DBG_TRACK_ALLOCATIONS is not set.
+ *
+ * Each memory allocation is tracked via a doubly linked list.  Each
+ * element contains the caller's component, module name, function name, and
+ * line number.  acpi_ut_allocate and acpi_ut_allocate_zeroed call
+ * acpi_ut_track_allocation to add an element to the list; deletion
+ * occurs in the body of acpi_ut_free.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("uttrack")
+
+/* Local prototypes */
+static struct acpi_debug_mem_block *acpi_ut_find_allocation(void *allocation);
+
+static acpi_status
+acpi_ut_track_allocation(struct acpi_debug_mem_block *address,
+			 acpi_size size,
+			 u8 alloc_type,
+			 u32 component, const char *module, u32 line);
+
+static acpi_status
+acpi_ut_remove_allocation(struct acpi_debug_mem_block *address,
+			  u32 component, const char *module, u32 line);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_list
+ *
+ * PARAMETERS:  cache_name      - Ascii name for the cache
+ *              object_size     - Size of each cached object
+ *              return_cache    - Where the new cache object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a local memory list for tracking purposed
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_create_list(char *list_name,
+		    u16 object_size, struct acpi_memory_list **return_cache)
+{
+	struct acpi_memory_list *cache;
+
+	cache = acpi_os_allocate(sizeof(struct acpi_memory_list));
+	if (!cache) {
+		return (AE_NO_MEMORY);
+	}
+
+	ACPI_MEMSET(cache, 0, sizeof(struct acpi_memory_list));
+
+	cache->list_name = list_name;
+	cache->object_size = object_size;
+
+	*return_cache = cache;
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_allocate_and_track
+ *
+ * PARAMETERS:  size                - Size of the allocation
+ *              component           - Component type of caller
+ *              module              - Source file name of caller
+ *              line                - Line number of caller
+ *
+ * RETURN:      Address of the allocated memory on success, NULL on failure.
+ *
+ * DESCRIPTION: The subsystem's equivalent of malloc.
+ *
+ ******************************************************************************/
+
+void *acpi_ut_allocate_and_track(acpi_size size,
+				 u32 component, const char *module, u32 line)
+{
+	struct acpi_debug_mem_block *allocation;
+	acpi_status status;
+
+	allocation =
+	    acpi_ut_allocate(size + sizeof(struct acpi_debug_mem_header),
+			     component, module, line);
+	if (!allocation) {
+		return (NULL);
+	}
+
+	status = acpi_ut_track_allocation(allocation, size,
+					  ACPI_MEM_MALLOC, component, module,
+					  line);
+	if (ACPI_FAILURE(status)) {
+		acpi_os_free(allocation);
+		return (NULL);
+	}
+
+	acpi_gbl_global_list->total_allocated++;
+	acpi_gbl_global_list->total_size += (u32)size;
+	acpi_gbl_global_list->current_total_size += (u32)size;
+	if (acpi_gbl_global_list->current_total_size >
+	    acpi_gbl_global_list->max_occupied) {
+		acpi_gbl_global_list->max_occupied =
+		    acpi_gbl_global_list->current_total_size;
+	}
+
+	return ((void *)&allocation->user_space);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_allocate_zeroed_and_track
+ *
+ * PARAMETERS:  size                - Size of the allocation
+ *              component           - Component type of caller
+ *              module              - Source file name of caller
+ *              line                - Line number of caller
+ *
+ * RETURN:      Address of the allocated memory on success, NULL on failure.
+ *
+ * DESCRIPTION: Subsystem equivalent of calloc.
+ *
+ ******************************************************************************/
+
+void *acpi_ut_allocate_zeroed_and_track(acpi_size size,
+					u32 component,
+					const char *module, u32 line)
+{
+	struct acpi_debug_mem_block *allocation;
+	acpi_status status;
+
+	allocation =
+	    acpi_ut_allocate_zeroed(size + sizeof(struct acpi_debug_mem_header),
+				    component, module, line);
+	if (!allocation) {
+
+		/* Report allocation error */
+
+		ACPI_ERROR((module, line,
+			    "Could not allocate size %u", (u32)size));
+		return (NULL);
+	}
+
+	status = acpi_ut_track_allocation(allocation, size,
+					  ACPI_MEM_CALLOC, component, module,
+					  line);
+	if (ACPI_FAILURE(status)) {
+		acpi_os_free(allocation);
+		return (NULL);
+	}
+
+	acpi_gbl_global_list->total_allocated++;
+	acpi_gbl_global_list->total_size += (u32)size;
+	acpi_gbl_global_list->current_total_size += (u32)size;
+	if (acpi_gbl_global_list->current_total_size >
+	    acpi_gbl_global_list->max_occupied) {
+		acpi_gbl_global_list->max_occupied =
+		    acpi_gbl_global_list->current_total_size;
+	}
+
+	return ((void *)&allocation->user_space);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_free_and_track
+ *
+ * PARAMETERS:  allocation          - Address of the memory to deallocate
+ *              component           - Component type of caller
+ *              module              - Source file name of caller
+ *              line                - Line number of caller
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Frees the memory at Allocation
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_free_and_track(void *allocation,
+		       u32 component, const char *module, u32 line)
+{
+	struct acpi_debug_mem_block *debug_block;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_PTR(ut_free, allocation);
+
+	if (NULL == allocation) {
+		ACPI_ERROR((module, line, "Attempt to delete a NULL address"));
+
+		return_VOID;
+	}
+
+	debug_block = ACPI_CAST_PTR(struct acpi_debug_mem_block,
+				    (((char *)allocation) -
+				     sizeof(struct acpi_debug_mem_header)));
+
+	acpi_gbl_global_list->total_freed++;
+	acpi_gbl_global_list->current_total_size -= debug_block->size;
+
+	status = acpi_ut_remove_allocation(debug_block,
+					   component, module, line);
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status, "Could not free memory"));
+	}
+
+	acpi_os_free(debug_block);
+	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "%p freed\n", allocation));
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_find_allocation
+ *
+ * PARAMETERS:  allocation              - Address of allocated memory
+ *
+ * RETURN:      A list element if found; NULL otherwise.
+ *
+ * DESCRIPTION: Searches for an element in the global allocation tracking list.
+ *
+ ******************************************************************************/
+
+static struct acpi_debug_mem_block *acpi_ut_find_allocation(void *allocation)
+{
+	struct acpi_debug_mem_block *element;
+
+	ACPI_FUNCTION_ENTRY();
+
+	element = acpi_gbl_global_list->list_head;
+
+	/* Search for the address. */
+
+	while (element) {
+		if (element == allocation) {
+			return (element);
+		}
+
+		element = element->next;
+	}
+
+	return (NULL);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_track_allocation
+ *
+ * PARAMETERS:  allocation          - Address of allocated memory
+ *              size                - Size of the allocation
+ *              alloc_type          - MEM_MALLOC or MEM_CALLOC
+ *              component           - Component type of caller
+ *              module              - Source file name of caller
+ *              line                - Line number of caller
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Inserts an element into the global allocation tracking list.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_track_allocation(struct acpi_debug_mem_block *allocation,
+			 acpi_size size,
+			 u8 alloc_type,
+			 u32 component, const char *module, u32 line)
+{
+	struct acpi_memory_list *mem_list;
+	struct acpi_debug_mem_block *element;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE_PTR(ut_track_allocation, allocation);
+
+	if (acpi_gbl_disable_mem_tracking) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	mem_list = acpi_gbl_global_list;
+	status = acpi_ut_acquire_mutex(ACPI_MTX_MEMORY);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Search list for this address to make sure it is not already on the list.
+	 * This will catch several kinds of problems.
+	 */
+	element = acpi_ut_find_allocation(allocation);
+	if (element) {
+		ACPI_ERROR((AE_INFO,
+			    "UtTrackAllocation: Allocation already present in list! (%p)",
+			    allocation));
+
+		ACPI_ERROR((AE_INFO, "Element %p Address %p",
+			    element, allocation));
+
+		goto unlock_and_exit;
+	}
+
+	/* Fill in the instance data. */
+
+	allocation->size = (u32)size;
+	allocation->alloc_type = alloc_type;
+	allocation->component = component;
+	allocation->line = line;
+
+	ACPI_STRNCPY(allocation->module, module, ACPI_MAX_MODULE_NAME);
+	allocation->module[ACPI_MAX_MODULE_NAME - 1] = 0;
+
+	/* Insert at list head */
+
+	if (mem_list->list_head) {
+		((struct acpi_debug_mem_block *)(mem_list->list_head))->
+		    previous = allocation;
+	}
+
+	allocation->next = mem_list->list_head;
+	allocation->previous = NULL;
+
+	mem_list->list_head = allocation;
+
+      unlock_and_exit:
+	status = acpi_ut_release_mutex(ACPI_MTX_MEMORY);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_remove_allocation
+ *
+ * PARAMETERS:  allocation          - Address of allocated memory
+ *              component           - Component type of caller
+ *              module              - Source file name of caller
+ *              line                - Line number of caller
+ *
+ * RETURN:
+ *
+ * DESCRIPTION: Deletes an element from the global allocation tracking list.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_remove_allocation(struct acpi_debug_mem_block *allocation,
+			  u32 component, const char *module, u32 line)
+{
+	struct acpi_memory_list *mem_list;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ut_remove_allocation);
+
+	if (acpi_gbl_disable_mem_tracking) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	mem_list = acpi_gbl_global_list;
+	if (NULL == mem_list->list_head) {
+
+		/* No allocations! */
+
+		ACPI_ERROR((module, line,
+			    "Empty allocation list, nothing to free!"));
+
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_MEMORY);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Unlink */
+
+	if (allocation->previous) {
+		(allocation->previous)->next = allocation->next;
+	} else {
+		mem_list->list_head = allocation->next;
+	}
+
+	if (allocation->next) {
+		(allocation->next)->previous = allocation->previous;
+	}
+
+	/* Mark the segment as deleted */
+
+	ACPI_MEMSET(&allocation->user_space, 0xEA, allocation->size);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "Freeing size 0%X\n",
+			  allocation->size));
+
+	status = acpi_ut_release_mutex(ACPI_MTX_MEMORY);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_dump_allocation_info
+ *
+ * PARAMETERS:
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print some info about the outstanding allocations.
+ *
+ ******************************************************************************/
+
+void acpi_ut_dump_allocation_info(void)
+{
+/*
+	struct acpi_memory_list         *mem_list;
+*/
+
+	ACPI_FUNCTION_TRACE(ut_dump_allocation_info);
+
+/*
+	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
+			  ("%30s: %4d (%3d Kb)\n", "Current allocations",
+			  mem_list->current_count,
+			  ROUND_UP_TO_1K (mem_list->current_size)));
+
+	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
+			  ("%30s: %4d (%3d Kb)\n", "Max concurrent allocations",
+			  mem_list->max_concurrent_count,
+			  ROUND_UP_TO_1K (mem_list->max_concurrent_size)));
+
+	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
+			  ("%30s: %4d (%3d Kb)\n", "Total (all) internal objects",
+			  running_object_count,
+			  ROUND_UP_TO_1K (running_object_size)));
+
+	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
+			  ("%30s: %4d (%3d Kb)\n", "Total (all) allocations",
+			  running_alloc_count,
+			  ROUND_UP_TO_1K (running_alloc_size)));
+
+	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
+			  ("%30s: %4d (%3d Kb)\n", "Current Nodes",
+			  acpi_gbl_current_node_count,
+			  ROUND_UP_TO_1K (acpi_gbl_current_node_size)));
+
+	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
+			  ("%30s: %4d (%3d Kb)\n", "Max Nodes",
+			  acpi_gbl_max_concurrent_node_count,
+			  ROUND_UP_TO_1K ((acpi_gbl_max_concurrent_node_count *
+					 sizeof (struct acpi_namespace_node)))));
+*/
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_dump_allocations
+ *
+ * PARAMETERS:  component           - Component(s) to dump info for.
+ *              module              - Module to dump info for.  NULL means all.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print a list of all outstanding allocations.
+ *
+ ******************************************************************************/
+
+void acpi_ut_dump_allocations(u32 component, const char *module)
+{
+	struct acpi_debug_mem_block *element;
+	union acpi_descriptor *descriptor;
+	u32 num_outstanding = 0;
+	u8 descriptor_type;
+
+	ACPI_FUNCTION_TRACE(ut_dump_allocations);
+
+	if (acpi_gbl_disable_mem_tracking) {
+		return;
+	}
+
+	/*
+	 * Walk the allocation list.
+	 */
+	if (ACPI_FAILURE(acpi_ut_acquire_mutex(ACPI_MTX_MEMORY))) {
+		return;
+	}
+
+	element = acpi_gbl_global_list->list_head;
+	while (element) {
+		if ((element->component & component) &&
+		    ((module == NULL)
+		     || (0 == ACPI_STRCMP(module, element->module)))) {
+			descriptor =
+			    ACPI_CAST_PTR(union acpi_descriptor,
+					  &element->user_space);
+
+			if (element->size <
+			    sizeof(struct acpi_common_descriptor)) {
+				acpi_os_printf("%p Length 0x%04X %9.9s-%u "
+					       "[Not a Descriptor - too small]\n",
+					       descriptor, element->size,
+					       element->module, element->line);
+			} else {
+				/* Ignore allocated objects that are in a cache */
+
+				if (ACPI_GET_DESCRIPTOR_TYPE(descriptor) !=
+				    ACPI_DESC_TYPE_CACHED) {
+					acpi_os_printf
+					    ("%p Length 0x%04X %9.9s-%u [%s] ",
+					     descriptor, element->size,
+					     element->module, element->line,
+					     acpi_ut_get_descriptor_name
+					     (descriptor));
+
+					/* Validate the descriptor type using Type field and length */
+
+					descriptor_type = 0;	/* Not a valid descriptor type */
+
+					switch (ACPI_GET_DESCRIPTOR_TYPE
+						(descriptor)) {
+					case ACPI_DESC_TYPE_OPERAND:
+						if (element->size ==
+						    sizeof(union
+							   acpi_operand_object))
+						{
+							descriptor_type =
+							    ACPI_DESC_TYPE_OPERAND;
+						}
+						break;
+
+					case ACPI_DESC_TYPE_PARSER:
+						if (element->size ==
+						    sizeof(union
+							   acpi_parse_object)) {
+							descriptor_type =
+							    ACPI_DESC_TYPE_PARSER;
+						}
+						break;
+
+					case ACPI_DESC_TYPE_NAMED:
+						if (element->size ==
+						    sizeof(struct
+							   acpi_namespace_node))
+						{
+							descriptor_type =
+							    ACPI_DESC_TYPE_NAMED;
+						}
+						break;
+
+					default:
+						break;
+					}
+
+					/* Display additional info for the major descriptor types */
+
+					switch (descriptor_type) {
+					case ACPI_DESC_TYPE_OPERAND:
+						acpi_os_printf
+						    ("%12.12s RefCount 0x%04X\n",
+						     acpi_ut_get_type_name
+						     (descriptor->object.common.
+						      type),
+						     descriptor->object.common.
+						     reference_count);
+						break;
+
+					case ACPI_DESC_TYPE_PARSER:
+						acpi_os_printf
+						    ("AmlOpcode 0x%04hX\n",
+						     descriptor->op.asl.
+						     aml_opcode);
+						break;
+
+					case ACPI_DESC_TYPE_NAMED:
+						acpi_os_printf("%4.4s\n",
+							       acpi_ut_get_node_name
+							       (&descriptor->
+								node));
+						break;
+
+					default:
+						acpi_os_printf("\n");
+						break;
+					}
+				}
+			}
+
+			num_outstanding++;
+		}
+
+		element = element->next;
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_MEMORY);
+
+	/* Print summary */
+
+	if (!num_outstanding) {
+		ACPI_INFO((AE_INFO, "No outstanding allocations"));
+	} else {
+		ACPI_ERROR((AE_INFO, "%u(0x%X) Outstanding allocations",
+			    num_outstanding, num_outstanding));
+	}
+
+	return_VOID;
+}
+
+#endif				/* ACPI_DBG_TRACK_ALLOCATIONS */
