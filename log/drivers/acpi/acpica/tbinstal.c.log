commit 800ba7c5eaaa734e4bd66bf0441fc200bbcdca54
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 10 11:31:49 2020 -0800

    ACPICA: All acpica: Update copyrights to 2020 Including tool signons.
    
    ACPICA commit 8b9c69d0984067051ffbe8526f871448ead6a26b
    
    Link: https://github.com/acpica/acpica/commit/8b9c69d0
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Kaneda <erik.kaneda@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index ef1ffd36ab3f..0bb15add2245 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -3,7 +3,7 @@
  *
  * Module Name: tbinstal - ACPI table installation and removal
  *
- * Copyright (C) 2000 - 2019, Intel Corp.
+ * Copyright (C) 2000 - 2020, Intel Corp.
  *
  *****************************************************************************/
 

commit 5599fb69355d7a558f32206dac7539e945a1f604
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Apr 8 13:42:24 2019 -0700

    ACPICA: Rename nameseg compare macro for clarity
    
    ACPICA commit 92ec0935f27e217dff0b176fca02c2ec3d782bb5
    
    ACPI_COMPARE_NAME changed to ACPI_COMPARE_NAMESEG
    This clarifies (1) this is a compare on 4-byte namesegs, not
    a generic compare. Improves understanding of the code.
    
    Link: https://github.com/acpica/acpica/commit/92ec0935
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index be6642bf6366..ef1ffd36ab3f 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -120,7 +120,7 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 	 */
 	if (!reload &&
 	    acpi_gbl_disable_ssdt_table_install &&
-	    ACPI_COMPARE_NAME(&new_table_desc.signature, ACPI_SIG_SSDT)) {
+	    ACPI_COMPARE_NAMESEG(&new_table_desc.signature, ACPI_SIG_SSDT)) {
 		ACPI_INFO(("Ignoring installation of %4.4s at %8.8X%8.8X",
 			   new_table_desc.signature.ascii,
 			   ACPI_FORMAT_UINT64(address)));

commit 840c02ca2215af648c781ae680d93d8aecd083b7
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jan 14 09:55:25 2019 -0800

    ACPICA: All acpica: Update copyrights to 2019
    
    ACPICA commit 62f4f98e941d86e41969bf2ab5a93b8dc94dc49e
    
    The update includes userspace tool signons.
    
    Link: https://github.com/acpica/acpica/commit/62f4f98e
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 5f8e7b561c90..be6642bf6366 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -3,7 +3,7 @@
  *
  * Module Name: tbinstal - ACPI table installation and removal
  *
- * Copyright (C) 2000 - 2018, Intel Corp.
+ * Copyright (C) 2000 - 2019, Intel Corp.
  *
  *****************************************************************************/
 

commit c2fa79b8c5a272decda66ef9280e009e267aa3bd
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue May 8 14:06:08 2018 -0700

    ACPICA: Tables: Fix spelling mistake in comment
    
    The spelling of "sucessfully" should be "successfully", fix this
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index c5085b7ae8c9..5f8e7b561c90 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -88,7 +88,7 @@ acpi_tb_install_table_with_override(struct acpi_table_desc *new_table_desc,
  * DESCRIPTION: This function is called to verify and install an ACPI table.
  *              When this function is called by "Load" or "LoadTable" opcodes,
  *              or by acpi_load_table() API, the "Reload" parameter is set.
- *              After sucessfully returning from this function, table is
+ *              After successfully returning from this function, table is
  *              "INSTALLED" but not "VALIDATED".
  *
  ******************************************************************************/

commit 95857638889aeea1b10a16b55041adf3e3ab84c4
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Wed Mar 14 16:13:07 2018 -0700

    ACPICA: adding SPDX headers
    
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 95693e407372..c5085b7ae8c9 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -1,45 +1,11 @@
+// SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
 /******************************************************************************
  *
  * Module Name: tbinstal - ACPI table installation and removal
  *
- *****************************************************************************/
-
-/*
  * Copyright (C) 2000 - 2018, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
  *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
+ *****************************************************************************/
 
 #include <acpi/acpi.h>
 #include "accommon.h"

commit 0fe0bebf5fb905ae682b1ecfd0b51b3a89e45ee6
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Wed Mar 14 16:13:05 2018 -0700

    ACPICA: macros: fix ACPI_ERROR_NAMESPACE macro
    
    Fixing the ACPI_ERROR_NAMESPACE macros created an "unused variable"
    compile error when ACPI_NO_ERROR_MESSAGES was defined. This commit
    also fixes the above compilation errors by surrounding variables
    meant for debugging inside a new ACPI_ERROR_ONLY macro.
    
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 00be16da1ee2..95693e407372 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -231,11 +231,11 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 void acpi_tb_override_table(struct acpi_table_desc *old_table_desc)
 {
 	acpi_status status;
-	char *override_type;
 	struct acpi_table_desc new_table_desc;
 	struct acpi_table_header *table;
 	acpi_physical_address address;
 	u32 length;
+	ACPI_ERROR_ONLY(char *override_type);
 
 	/* (1) Attempt logical override (returns a logical address) */
 
@@ -244,7 +244,7 @@ void acpi_tb_override_table(struct acpi_table_desc *old_table_desc)
 		acpi_tb_acquire_temp_table(&new_table_desc,
 					   ACPI_PTR_TO_PHYSADDR(table),
 					   ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL);
-		override_type = "Logical";
+		ACPI_ERROR_ONLY(override_type = "Logical");
 		goto finish_override;
 	}
 
@@ -255,7 +255,7 @@ void acpi_tb_override_table(struct acpi_table_desc *old_table_desc)
 	if (ACPI_SUCCESS(status) && address && length) {
 		acpi_tb_acquire_temp_table(&new_table_desc, address,
 					   ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL);
-		override_type = "Physical";
+		ACPI_ERROR_ONLY(override_type = "Physical");
 		goto finish_override;
 	}
 

commit da6f8320d58623eae9b6fa2f09b1b4f60a772ce9
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 4 10:06:38 2018 -0800

    ACPICA: All acpica: Update copyrights to 2018
    
    including tool signons.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 0dfc0ac3c141..00be16da1ee2 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2017, Intel Corp.
+ * Copyright (C) 2000 - 2018, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit f9d472ee3214cf8fc3e4b418b376869799adaf67
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Jul 10 15:23:50 2017 +0800

    ACPICA: Tables: Combine checksum/duplication verification together
    
    ACPICA commit 182bdffc0644f568be614a6d4debd651e29ca587
    
    They are all mechanisms used to verify if a table is qualified to be
    installed and controlled by acpi_gbl_enable_table_validation, so combine them
    together. By doing so, table duplication check is applied to the statically
    loaded tables (however whether it is actually enabled is still determined
    by acpi_gbl_enable_table_validation). Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/182bdffc
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index f7bc362bd3c5..0dfc0ac3c141 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -48,54 +48,6 @@
 #define _COMPONENT          ACPI_TABLES
 ACPI_MODULE_NAME("tbinstal")
 
-/* Local prototypes */
-static u8
-acpi_tb_compare_tables(struct acpi_table_desc *table_desc, u32 table_index);
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_compare_tables
- *
- * PARAMETERS:  table_desc          - Table 1 descriptor to be compared
- *              table_index         - Index of table 2 to be compared
- *
- * RETURN:      TRUE if both tables are identical.
- *
- * DESCRIPTION: This function compares a table with another table that has
- *              already been installed in the root table list.
- *
- ******************************************************************************/
-
-static u8
-acpi_tb_compare_tables(struct acpi_table_desc *table_desc, u32 table_index)
-{
-	acpi_status status = AE_OK;
-	u8 is_identical;
-	struct acpi_table_header *table;
-	u32 table_length;
-	u8 table_flags;
-
-	status =
-	    acpi_tb_acquire_table(&acpi_gbl_root_table_list.tables[table_index],
-				  &table, &table_length, &table_flags);
-	if (ACPI_FAILURE(status)) {
-		return (FALSE);
-	}
-
-	/*
-	 * Check for a table match on the entire table length,
-	 * not just the header.
-	 */
-	is_identical = (u8)((table_desc->length != table_length ||
-			     memcmp(table_desc->pointer, table, table_length)) ?
-			    FALSE : TRUE);
-
-	/* Release the acquired table */
-
-	acpi_tb_release_table(table, table_length, table_flags);
-	return (is_identical);
-}
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_tb_install_table_with_override
@@ -112,7 +64,6 @@ acpi_tb_compare_tables(struct acpi_table_desc *table_desc, u32 table_index)
  *              table array.
  *
  ******************************************************************************/
-
 void
 acpi_tb_install_table_with_override(struct acpi_table_desc *new_table_desc,
 				    u8 override, u32 *table_index)
@@ -210,67 +161,29 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 		goto release_and_exit;
 	}
 
-	/* Validate and verify a table before installation */
-
-	status = acpi_tb_verify_temp_table(&new_table_desc, NULL);
-	if (ACPI_FAILURE(status)) {
-		goto release_and_exit;
-	}
-
 	/* Acquire the table lock */
 
 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
 
-	if (acpi_gbl_enable_table_validation) {
-
-		/* Check if table is already registered */
-
-		for (i = 0; i < acpi_gbl_root_table_list.current_table_count;
-		     ++i) {
-			/*
-			 * Check for a table match on the entire table length,
-			 * not just the header.
-			 */
-			if (!acpi_tb_compare_tables(&new_table_desc, i)) {
-				continue;
-			}
+	/* Validate and verify a table before installation */
 
+	status = acpi_tb_verify_temp_table(&new_table_desc, NULL, &i);
+	if (ACPI_FAILURE(status)) {
+		if (status == AE_CTRL_TERMINATE) {
 			/*
-			 * Note: the current mechanism does not unregister a table if it is
-			 * dynamically unloaded. The related namespace entries are deleted,
-			 * but the table remains in the root table list.
-			 *
-			 * The assumption here is that the number of different tables that
-			 * will be loaded is actually small, and there is minimal overhead
-			 * in just keeping the table in case it is needed again.
-			 *
-			 * If this assumption changes in the future (perhaps on large
-			 * machines with many table load/unload operations), tables will
-			 * need to be unregistered when they are unloaded, and slots in the
-			 * root table list should be reused when empty.
+			 * Table was unloaded, allow it to be reloaded.
+			 * As we are going to return AE_OK to the caller, we should
+			 * take the responsibility of freeing the input descriptor.
+			 * Refill the input descriptor to ensure
+			 * acpi_tb_install_table_with_override() can be called again to
+			 * indicate the re-installation.
 			 */
-			if (acpi_gbl_root_table_list.tables[i].flags &
-			    ACPI_TABLE_IS_LOADED) {
-
-				/* Table is still loaded, this is an error */
-
-				status = AE_ALREADY_EXISTS;
-				goto unlock_and_exit;
-			} else {
-				/*
-				 * Table was unloaded, allow it to be reloaded.
-				 * As we are going to return AE_OK to the caller, we should
-				 * take the responsibility of freeing the input descriptor.
-				 * Refill the input descriptor to ensure
-				 * acpi_tb_install_table_with_override() can be called again to
-				 * indicate the re-installation.
-				 */
-				acpi_tb_uninstall_table(&new_table_desc);
-				(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
-				*table_index = i;
-				return_ACPI_STATUS(AE_OK);
-			}
+			acpi_tb_uninstall_table(&new_table_desc);
+			(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+			*table_index = i;
+			return_ACPI_STATUS(AE_OK);
 		}
+		goto unlock_and_exit;
 	}
 
 	/* Add the table to the global root table list */
@@ -350,9 +263,11 @@ void acpi_tb_override_table(struct acpi_table_desc *old_table_desc)
 
 finish_override:
 
-	/* Validate and verify a table before overriding */
-
-	status = acpi_tb_verify_temp_table(&new_table_desc, NULL);
+	/*
+	 * Validate and verify a table before overriding, no nested table
+	 * duplication check as it's too complicated and unnecessary.
+	 */
+	status = acpi_tb_verify_temp_table(&new_table_desc, NULL, NULL);
 	if (ACPI_FAILURE(status)) {
 		return;
 	}

commit 023e2ee16c51da7f6a9455ac936e4fb00295f47a
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Jul 10 15:23:45 2017 +0800

    ACPICA: Tables: Change table duplication check to be related to acpi_gbl_verify_table_checksum
    
    ACPICA commit 3d837b5d4b1033942b4d91c7d3801a09c3157918
    
    acpi_gbl_verify_table_checksum is used to avoid validating (mapping) an entire
    table in OS boot stage. 2nd "Reload" check in acpi_tb_install_standard_table()
    is prepared for the same purpose. So this patch combines them together
    using a renamed acpi_gbl_enable_table_validation flag. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/3d837b5d
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 9d212967fad8..f7bc362bd3c5 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -221,7 +221,7 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 
 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
 
-	if (reload) {
+	if (acpi_gbl_enable_table_validation) {
 
 		/* Check if table is already registered */
 

commit 04ba15aa55cf16e18757faea55d62d1b7e407fe3
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Jul 10 15:23:37 2017 +0800

    ACPICA: Tables: Do not validate signature for dynamic table load
    
    ACPICA commit d3c944f2cdc8c7e847b7942b1864f285189f7bce
    
    Windows seems to allow arbitrary table signatures for Load/load_table
    opcodes:
      ACPI BIOS Error (bug): Table has invalid signature [PRAD] (0x44415250)
    So this patch removes dynamic load signature checks. However we need to
    find a way to avoid table loading against tables like MADT. This is not
    covered by this commit.
    
    This Windows behavior has been validated on link #1. An end user bug
    report can also be found on link #2.
    
    This patch also includes simple cleanup for static load signature check
    code. Reported by Ye Xiaolong, Fixed by Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/d3c944f2
    Link: https://github.com/acpica/acpica/pull/121 [#1]
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=118601 [#2]
    Reported-by: Ye Xiaolong <xiaolong.ye@intel.com>
    Reported-by: Olga Uhina <olga.uhina@gmail.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index ee745152f25b..9d212967fad8 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -222,34 +222,6 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
 
 	if (reload) {
-		/*
-		 * Validate the incoming table signature.
-		 *
-		 * 1) Originally, we checked the table signature for "SSDT" or "PSDT".
-		 * 2) We added support for OEMx tables, signature "OEM".
-		 * 3) Valid tables were encountered with a null signature, so we just
-		 *    gave up on validating the signature, (05/2008).
-		 * 4) We encountered non-AML tables such as the MADT, which caused
-		 *    interpreter errors and kernel faults. So now, we once again allow
-		 *    only "SSDT", "OEMx", and now, also a null signature. (05/2011).
-		 */
-		if ((new_table_desc.signature.ascii[0] != 0x00) &&
-		    (!ACPI_COMPARE_NAME
-		     (&new_table_desc.signature, ACPI_SIG_SSDT))
-		    && (strncmp(new_table_desc.signature.ascii, "OEM", 3))) {
-			ACPI_BIOS_ERROR((AE_INFO,
-					 "Table has invalid signature [%4.4s] (0x%8.8X), "
-					 "must be SSDT or OEMx",
-					 acpi_ut_valid_nameseg(new_table_desc.
-							       signature.
-							       ascii) ?
-					 new_table_desc.signature.
-					 ascii : "????",
-					 new_table_desc.signature.integer));
-
-			status = AE_BAD_SIGNATURE;
-			goto unlock_and_exit;
-		}
 
 		/* Check if table is already registered */
 

commit 9b019b0f67bf527d6412de0497702026ff37e8a6
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Jul 10 15:23:28 2017 +0800

    ACPICA: Tables: Cleanup table handler invokers
    
    ACPICA commit 4551f51fa8ba33a977721c3b250cb70a309e3f23
    
    Recently, we allows the table mutex to be held in both early and late stage
    APIs. This patch further cleans up the related code to reduce redundant
    code related to acpi_gbl_table_handler. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/4551f51f
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 4620f3c68c13..ee745152f25b 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -306,14 +306,10 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 	acpi_tb_install_table_with_override(&new_table_desc, override,
 					    table_index);
 
-	/* Invoke table handler if present */
+	/* Invoke table handler */
 
 	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
-	if (acpi_gbl_table_handler) {
-		(void)acpi_gbl_table_handler(ACPI_TABLE_EVENT_INSTALL,
-					     new_table_desc.pointer,
-					     acpi_gbl_table_handler_context);
-	}
+	acpi_tb_notify_table(ACPI_TABLE_EVENT_INSTALL, new_table_desc.pointer);
 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
 
 unlock_and_exit:

commit 7735ca0eb4ebd6d47fdad40602d0ba7593219f8c
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Feb 8 11:00:08 2017 +0800

    ACPICA: Source tree: Update copyright notices to 2017
    
    ACPICA commit 16577e5265923f4999b4d2c0addb2343b18135e1
    
    Affects all files.
    
    Link: https://github.com/acpica/acpica/commit/16577e52
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 01e1b3d63fc0..4620f3c68c13 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2016, Intel Corp.
+ * Copyright (C) 2000 - 2017, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 7a37052adb5e843bcfff6c98aee9b60bb087b910
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Jan 19 15:21:34 2017 +0800

    ACPICA: Tables: Fix hidden logic related to acpi_tb_install_standard_table()
    
    There is a hidden logic for acpi_tb_install_standard_table() as it can be
    invoked from the boot stage and during runtime.
    
     1. When it is invoked from the OS boot stage, the ACPICA mutex may not have
        been initialized yet and so acpi_ut_acquire_mutex()/acpi_ut_release_mutex()
        are not invoked in these code paths:
    
       acpi_initialize_tables
         acpi_tb_parse_root_table
           acpi_tb_install_standard_table (4 invocations)
       acpi_install_table
           acpi_tb_install_standard_table
    
     2. When it is invoked during the runtime, ACPICA mutex is used as
        appropriate:
    
       acpi_ex_load_op
         acpi_tb_install_and_load_table
           acpi_tb_install_standard_table
       acpi_load_table
         acpi_tb_install_and_load_table
           acpi_tb_install_standard_table
    
    The mutex is now used in acpi_tb_install_and_load_table(), while it actually
    should be in acpi_tb_install_standard_table().
    
    This introduces another problem in acpi_tb_install_standard_table() where
    acpi_gbl_table_handler is invoked from and the lock contexts are thus not
    consistent for the table handlers. This triggers a regression when
    acpi_get_table()/acpi_put_table() start to hold table mutex during runtime.
    
    The regression is noticed by LKP as new errors reported by ACPICA mutex
    debugging facility.
    
    [    2.043693] ACPI Error: Mutex [ACPI_MTX_Tables] already acquired by this thread [497483776] (20160930/utmutex-254)
    [    2.054084] ACPI Error: Mutex [0x2] is not acquired, cannot release (20160930/utmutex-326)
    
    And it triggers a deadlock:
    
    [  247.066214] INFO: task swapper/0:1 blocked for more than 120 seconds.
    ...
    [  247.091271] Call Trace:
    ...
    [  247.121523]  down_timeout+0x47/0x50
    [  247.125065]  acpi_os_wait_semaphore+0x47/0x62
    [  247.129475]  acpi_ut_acquire_mutex+0x43/0x81
    [  247.133798]  acpi_get_table+0x2d/0x84
    [  247.137513]  acpi_table_attr_init+0xcd/0x100
    [  247.146590]  acpi_sysfs_table_handler+0x5d/0xb8
    [  247.151174]  acpi_bus_table_handler+0x23/0x2a
    [  247.155583]  acpi_tb_install_standard_table+0xe0/0x213
    [  247.164489]  acpi_tb_install_and_load_table+0x3a/0x82
    [  247.169592]  acpi_ex_load_op+0x194/0x201
    ...
    [  247.200108]  acpi_ns_evaluate+0x1bb/0x247
    [  247.204170]  acpi_evaluate_object+0x178/0x274
    [  247.213249]  acpi_processor_set_pdc+0x154/0x17b
    ...
    The table mutex is held in acpi_tb_install_and_load_table() and is re-visited by
    acpi_get_table().
    
    Noticing that the early mutex requirement actually belongs to the OSL layer
    and has already been handled in acpi_os_wait_semaphore()/acpi_os_signal_semaphore(),
    the regression canbe fixed by removing this hidden logic from the ACPICA core
    to the OS-specific code.
    
    Fixes: 174cc7187e6f ("ACPICA: Tables: Back port acpi_get_table_with_size() and early_acpi_os_unmap_memory() from Linux kernel")
    Reported-and-tested-by: Tomi Sarvela <tomi.p.sarvela@intel.com>
    Reported-by: Ye Xiaolong <xiaolong.ye@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 5fdf251a9f97..01e1b3d63fc0 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -217,6 +217,10 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 		goto release_and_exit;
 	}
 
+	/* Acquire the table lock */
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+
 	if (reload) {
 		/*
 		 * Validate the incoming table signature.
@@ -244,7 +248,7 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 					 new_table_desc.signature.integer));
 
 			status = AE_BAD_SIGNATURE;
-			goto release_and_exit;
+			goto unlock_and_exit;
 		}
 
 		/* Check if table is already registered */
@@ -279,7 +283,7 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 				/* Table is still loaded, this is an error */
 
 				status = AE_ALREADY_EXISTS;
-				goto release_and_exit;
+				goto unlock_and_exit;
 			} else {
 				/*
 				 * Table was unloaded, allow it to be reloaded.
@@ -290,6 +294,7 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 				 * indicate the re-installation.
 				 */
 				acpi_tb_uninstall_table(&new_table_desc);
+				(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
 				*table_index = i;
 				return_ACPI_STATUS(AE_OK);
 			}
@@ -303,11 +308,19 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 
 	/* Invoke table handler if present */
 
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
 	if (acpi_gbl_table_handler) {
 		(void)acpi_gbl_table_handler(ACPI_TABLE_EVENT_INSTALL,
 					     new_table_desc.pointer,
 					     acpi_gbl_table_handler_context);
 	}
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+
+unlock_and_exit:
+
+	/* Release the table lock */
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
 
 release_and_exit:
 

commit bdbe5df025b712220ba8d807662d4449b2092e54
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Sep 7 14:06:32 2016 +0800

    ACPICA: Tables: Add new table events indicating table installation/uninstallation
    
    ACPICA commit ed6a5fbc694f3a27d93014391aa9a6f6fe490461
    
    This patch adds 2 new table events to indicate table
    installation/uninstallation.
    
    Currently, as ACPICA never uninstalls tables, this patch thus only adds
    table handler invocation for the table installation event. Lv Zheng.
    
    The 2 events are to be used to fix a sysfs table handling issue related to
    LoadTable opcode (see Link # [1] below). The actual sysfs fixing code is
    not included, the sysfs fixes will be sent as separate patches.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=150841 # [1]
    Link: https://github.com/acpica/acpica/commit/ed6a5fbc
    Reported-by: Jason Voelz <jason.voelz@intel.com>
    Reported-by: Francisco Leoner <francisco.j.lenoer.soto@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index d4618648ea13..5fdf251a9f97 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -301,6 +301,14 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 	acpi_tb_install_table_with_override(&new_table_desc, override,
 					    table_index);
 
+	/* Invoke table handler if present */
+
+	if (acpi_gbl_table_handler) {
+		(void)acpi_gbl_table_handler(ACPI_TABLE_EVENT_INSTALL,
+					     new_table_desc.pointer,
+					     acpi_gbl_table_handler_context);
+	}
+
 release_and_exit:
 
 	/* Release the temporary table descriptor */

commit 752db1016019a4e67d86492fdfda724215ee8d9b
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Sep 7 14:06:17 2016 +0800

    ACPICA: Tables: Remove acpi_tb_install_fixed_table()
    
    ACPICA commit 42c7b848d2faa02c7691ef2c53ea741c23cd4665
    
    acpi_tb_install_fixed_table() is now redundant as we've removed the fixed
    table indexing mechanism:
      Commit: 8ec3f459073e67e5c6d78507dec693064b3040a2
      Subject: ACPICA: Tables: Fix global table list issues by removing
               fixed table indexes
    This patch cleans up the code accordingly.
    
    No functional change. Lv Zheng.
    
    Link: https://bugs.acpica.org/show_bug.cgi?id=1320
    Link: https://github.com/acpica/acpica/commit/42c7b848
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 8b13052128fc..d4618648ea13 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -155,68 +155,6 @@ acpi_tb_install_table_with_override(struct acpi_table_desc *new_table_desc,
 	}
 }
 
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_install_fixed_table
- *
- * PARAMETERS:  address                 - Physical address of DSDT or FACS
- *              signature               - Table signature, NULL if no need to
- *                                        match
- *              table_index             - Where the table index is returned
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Install a fixed ACPI table (DSDT/FACS) into the global data
- *              structure.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_tb_install_fixed_table(acpi_physical_address address,
-			    char *signature, u32 *table_index)
-{
-	struct acpi_table_desc new_table_desc;
-	acpi_status status;
-
-	ACPI_FUNCTION_TRACE(tb_install_fixed_table);
-
-	if (!address) {
-		ACPI_ERROR((AE_INFO,
-			    "Null physical address for ACPI table [%s]",
-			    signature));
-		return (AE_NO_MEMORY);
-	}
-
-	/* Fill a table descriptor for validation */
-
-	status = acpi_tb_acquire_temp_table(&new_table_desc, address,
-					    ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL);
-	if (ACPI_FAILURE(status)) {
-		ACPI_ERROR((AE_INFO,
-			    "Could not acquire table length at %8.8X%8.8X",
-			    ACPI_FORMAT_UINT64(address)));
-		return_ACPI_STATUS(status);
-	}
-
-	/* Validate and verify a table before installation */
-
-	status = acpi_tb_verify_temp_table(&new_table_desc, signature);
-	if (ACPI_FAILURE(status)) {
-		goto release_and_exit;
-	}
-
-	/* Add the table to the global root table list */
-
-	acpi_tb_install_table_with_override(&new_table_desc, TRUE, table_index);
-
-release_and_exit:
-
-	/* Release the temporary table descriptor */
-
-	acpi_tb_release_temp_table(&new_table_desc);
-	return_ACPI_STATUS(status);
-}
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_tb_install_standard_table
@@ -230,8 +168,7 @@ acpi_tb_install_fixed_table(acpi_physical_address address,
  *
  * RETURN:      Status
  *
- * DESCRIPTION: This function is called to install an ACPI table that is
- *              neither DSDT nor FACS (a "standard" table.)
+ * DESCRIPTION: This function is called to verify and install an ACPI table.
  *              When this function is called by "Load" or "LoadTable" opcodes,
  *              or by acpi_load_table() API, the "Reload" parameter is set.
  *              After sucessfully returning from this function, table is

commit 6a0df32c22fdfc414e6613c1bc911f19f39df01b
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu May 5 13:00:36 2016 +0800

    ACPICA: Move all ASCII utilities to a common file
    
    ACPICA commit ba60e4500053010bf775d58f6f61febbdb94d817
    
    New file is utascii.c
    
    Link: https://github.com/acpica/acpica/commit/ba60e450
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 4dc6108de4ff..8b13052128fc 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -299,9 +299,9 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 			ACPI_BIOS_ERROR((AE_INFO,
 					 "Table has invalid signature [%4.4s] (0x%8.8X), "
 					 "must be SSDT or OEMx",
-					 acpi_ut_valid_acpi_name(new_table_desc.
-								 signature.
-								 ascii) ?
+					 acpi_ut_valid_nameseg(new_table_desc.
+							       signature.
+							       ascii) ?
 					 new_table_desc.signature.
 					 ascii : "????",
 					 new_table_desc.signature.integer));

commit 05fb04b54f6b67f4eb901e99dd5b4604b46ffa0f
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Feb 19 14:16:42 2016 +0800

    ACPICA: Remove unnecessary arguments to ACPI_INFO
    
    ACPICA commit 181f56605a771e0b91e24b0648d2565ca70bea20
    
    This is used as a purely infomation message, without module name
    and line number information. Therefore, these arguments are
    not needed and they are unnecessary overhead.
    Arguments are removed.
    ACPICA BZ 872.
    
    Link: https://github.com/acpica/acpica/commit/181f5660
    Link: https://bugs.acpica.org/show_bug.cgi?id=872
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index b661a1e013fb..4dc6108de4ff 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -267,8 +267,7 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 	if (!reload &&
 	    acpi_gbl_disable_ssdt_table_install &&
 	    ACPI_COMPARE_NAME(&new_table_desc.signature, ACPI_SIG_SSDT)) {
-		ACPI_INFO((AE_INFO,
-			   "Ignoring installation of %4.4s at %8.8X%8.8X",
+		ACPI_INFO(("Ignoring installation of %4.4s at %8.8X%8.8X",
 			   new_table_desc.signature.ascii,
 			   ACPI_FORMAT_UINT64(address)));
 		goto release_and_exit;
@@ -432,7 +431,7 @@ void acpi_tb_override_table(struct acpi_table_desc *old_table_desc)
 		return;
 	}
 
-	ACPI_INFO((AE_INFO, "%4.4s 0x%8.8X%8.8X"
+	ACPI_INFO(("%4.4s 0x%8.8X%8.8X"
 		   " %s table override, new table: 0x%8.8X%8.8X",
 		   old_table_desc->signature.ascii,
 		   ACPI_FORMAT_UINT64(old_table_desc->address),

commit c8100dc4643d80a94f074dfc8a2af3d3d327b7aa
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 15 08:17:03 2016 +0800

    ACPICA: Additional 2016 copyright changes
    
    All tool/utility signons.
    Dual-license module header.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index bd87801acedf..b661a1e013fb 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2015, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 1fad87385e7e82f656fb661aef0f841e42991974
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Dec 29 13:54:36 2015 +0800

    ACPICA: Core: Major update for code formatting, no functional changes
    
    ACPICA commit dfa394471f6c01b2ee9433dbc143ec70cb9bca72
    
    Mostly indentation inconsistencies across the code. Split
    some long lines, etc.
    
    Link: https://github.com/acpica/acpica/commit/dfa39447
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 6319b42420c6..bd87801acedf 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -337,8 +337,8 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 			 * need to be unregistered when they are unloaded, and slots in the
 			 * root table list should be reused when empty.
 			 */
-			if (acpi_gbl_root_table_list.tables[i].
-			    flags & ACPI_TABLE_IS_LOADED) {
+			if (acpi_gbl_root_table_list.tables[i].flags &
+			    ACPI_TABLE_IS_LOADED) {
 
 				/* Table is still loaded, this is an error */
 

commit 8ec3f459073e67e5c6d78507dec693064b3040a2
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Aug 25 10:29:01 2015 +0800

    ACPICA: Tables: Fix global table list issues by removing fixed table indexes
    
    ACPICA commit c0b38b4c3982c2336ee92a2a14716107248bd941
    
    The fixed table indexes leave holes in the global table list:
     1. One hole can be seen when there is only 1 FACS provided by the BIOS.
     2. Tow holes can be seen when it is a reduced hardware platform.
    The holes do not break OSPMs but have broken ACPI debugger "tables"
    command.
    
    Also the "fixed table indexes" mechanism may make the descriptors of the
    standard tables installed earlier than DSDT to be overwritten by the
    descriptors of the fixed tables. For example, FACP disappears from the
    global table list after DSDT is installed.
    
    This patch fixes all above issues by removing the "fixed table indexes"
    mechanism which is too complicated to be maintained in a regression safe
    manner. After removal, the table loader will determine the indexes of the
    fixed tables. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/c0b38b4c
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 15ea98e0068d..6319b42420c6 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -100,9 +100,9 @@ acpi_tb_compare_tables(struct acpi_table_desc *table_desc, u32 table_index)
  *
  * FUNCTION:    acpi_tb_install_table_with_override
  *
- * PARAMETERS:  table_index             - Index into root table array
- *              new_table_desc          - New table descriptor to install
+ * PARAMETERS:  new_table_desc          - New table descriptor to install
  *              override                - Whether override should be performed
+ *              table_index             - Where the table index is returned
  *
  * RETURN:      None
  *
@@ -114,12 +114,14 @@ acpi_tb_compare_tables(struct acpi_table_desc *table_desc, u32 table_index)
  ******************************************************************************/
 
 void
-acpi_tb_install_table_with_override(u32 table_index,
-				    struct acpi_table_desc *new_table_desc,
-				    u8 override)
+acpi_tb_install_table_with_override(struct acpi_table_desc *new_table_desc,
+				    u8 override, u32 *table_index)
 {
+	u32 i;
+	acpi_status status;
 
-	if (table_index >= acpi_gbl_root_table_list.current_table_count) {
+	status = acpi_tb_get_next_table_descriptor(&i, NULL);
+	if (ACPI_FAILURE(status)) {
 		return;
 	}
 
@@ -134,8 +136,7 @@ acpi_tb_install_table_with_override(u32 table_index,
 		acpi_tb_override_table(new_table_desc);
 	}
 
-	acpi_tb_init_table_descriptor(&acpi_gbl_root_table_list.
-				      tables[table_index],
+	acpi_tb_init_table_descriptor(&acpi_gbl_root_table_list.tables[i],
 				      new_table_desc->address,
 				      new_table_desc->flags,
 				      new_table_desc->pointer);
@@ -143,9 +144,13 @@ acpi_tb_install_table_with_override(u32 table_index,
 	acpi_tb_print_table_header(new_table_desc->address,
 				   new_table_desc->pointer);
 
+	/* This synchronizes acpi_gbl_dsdt_index */
+
+	*table_index = i;
+
 	/* Set the global integer width (based upon revision of the DSDT) */
 
-	if (table_index == ACPI_TABLE_INDEX_DSDT) {
+	if (i == acpi_gbl_dsdt_index) {
 		acpi_ut_set_integer_width(new_table_desc->pointer->revision);
 	}
 }
@@ -157,7 +162,7 @@ acpi_tb_install_table_with_override(u32 table_index,
  * PARAMETERS:  address                 - Physical address of DSDT or FACS
  *              signature               - Table signature, NULL if no need to
  *                                        match
- *              table_index             - Index into root table array
+ *              table_index             - Where the table index is returned
  *
  * RETURN:      Status
  *
@@ -168,7 +173,7 @@ acpi_tb_install_table_with_override(u32 table_index,
 
 acpi_status
 acpi_tb_install_fixed_table(acpi_physical_address address,
-			    char *signature, u32 table_index)
+			    char *signature, u32 *table_index)
 {
 	struct acpi_table_desc new_table_desc;
 	acpi_status status;
@@ -200,7 +205,9 @@ acpi_tb_install_fixed_table(acpi_physical_address address,
 		goto release_and_exit;
 	}
 
-	acpi_tb_install_table_with_override(table_index, &new_table_desc, TRUE);
+	/* Add the table to the global root table list */
+
+	acpi_tb_install_table_with_override(&new_table_desc, TRUE, table_index);
 
 release_and_exit:
 
@@ -355,13 +362,8 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 
 	/* Add the table to the global root table list */
 
-	status = acpi_tb_get_next_table_descriptor(&i, NULL);
-	if (ACPI_FAILURE(status)) {
-		goto release_and_exit;
-	}
-
-	*table_index = i;
-	acpi_tb_install_table_with_override(i, &new_table_desc, override);
+	acpi_tb_install_table_with_override(&new_table_desc, override,
+					    table_index);
 
 release_and_exit:
 

commit 4fa4616e279df89baeb36287bbee83ab272edaed
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Jul 1 14:45:11 2015 +0800

    ACPICA: De-macroize calls to standard C library functions
    
    ACPICA commit 3b1026e0bdd3c32eb6d5d313f3ba0b1fee7597b4
    ACPICA commit 00f0dc83f5cfca53b27a3213ae0d7719b88c2d6b
    ACPICA commit 47d22a738d0e19fd241ffe4e3e9d4e198e4afc69
    
    Across all of ACPICA. Replace C library macros such as ACPI_STRLEN with the
    standard names such as strlen. The original purpose for these macros is
    long since obsolete.
    Also cast various invocations as necessary. Bob Moore, Jung-uk Kim, Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/3b1026e0
    Link: https://github.com/acpica/acpica/commit/00f0dc83
    Link: https://github.com/acpica/acpica/commit/47d22a73
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Jung-uk Kim <jkim@FreeBSD.org>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 008a251780f4..15ea98e0068d 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -87,8 +87,8 @@ acpi_tb_compare_tables(struct acpi_table_desc *table_desc, u32 table_index)
 	 * not just the header.
 	 */
 	is_identical = (u8)((table_desc->length != table_length ||
-			     ACPI_MEMCMP(table_desc->pointer, table,
-					 table_length)) ? FALSE : TRUE);
+			     memcmp(table_desc->pointer, table, table_length)) ?
+			    FALSE : TRUE);
 
 	/* Release the acquired table */
 
@@ -289,8 +289,7 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 		if ((new_table_desc.signature.ascii[0] != 0x00) &&
 		    (!ACPI_COMPARE_NAME
 		     (&new_table_desc.signature, ACPI_SIG_SSDT))
-		    && (ACPI_STRNCMP(new_table_desc.signature.ascii, "OEM", 3)))
-		{
+		    && (strncmp(new_table_desc.signature.ascii, "OEM", 3))) {
 			ACPI_BIOS_ERROR((AE_INFO,
 					 "Table has invalid signature [%4.4s] (0x%8.8X), "
 					 "must be SSDT or OEMx",

commit 76cffa79bd7f139a8f16d4e7969bf7891fe6f901
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Apr 13 11:49:30 2015 +0800

    ACPICA: Tables: Move an iasl specific table function to iasl source file.
    
    ACPICA commit 6eb364d790dd103bd4990f808e0095a421c437cb
    
    acpi_tb_store_table() implements a logic that is only correct to iasl. So it
    won't be used by any other utilities except iasl. This function is
    complained by the kernel users as an unused function. The best choice to
    stop releasing it to the Linux kernel should be moving it to adisasm.c.
    
    ACPI table manager can use both struct acpi_table_desc (direct referencing)
    and table index (indirect referencing) as the descriptor to the table, so
    acpi_tb_get_next_root_index() is extended to return both of them to allow
    maximum usability from the callers. NOTE that indirect referencing is a
    design result to meet the boot stage static allocation requirement for the
    table descriptors.
    
    This is a linuxized acpi_tb_store_table() removing result, there should be
    no functional changes introduced to the Linux kernel by this patch except
    the additonal kernel unused argument for acpi_tb_get_next_root_index()
    (renamed to acpi_tb_get_next_root_index()). This argument is used in the
    ACPICA upstream.
    
    Link: https://github.com/acpica/acpica/commit/6eb364d7
    Reported-by: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 7e69bc73bd16..008a251780f4 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -356,7 +356,7 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 
 	/* Add the table to the global root table list */
 
-	status = acpi_tb_get_next_root_index(&i);
+	status = acpi_tb_get_next_table_descriptor(&i, NULL);
 	if (ACPI_FAILURE(status)) {
 		goto release_and_exit;
 	}
@@ -455,43 +455,6 @@ void acpi_tb_override_table(struct acpi_table_desc *old_table_desc)
 	acpi_tb_release_temp_table(&new_table_desc);
 }
 
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_store_table
- *
- * PARAMETERS:  address             - Table address
- *              table               - Table header
- *              length              - Table length
- *              flags               - Install flags
- *              table_index         - Where the table index is returned
- *
- * RETURN:      Status and table index.
- *
- * DESCRIPTION: Add an ACPI table to the global table list
- *
- ******************************************************************************/
-
-acpi_status
-acpi_tb_store_table(acpi_physical_address address,
-		    struct acpi_table_header * table,
-		    u32 length, u8 flags, u32 *table_index)
-{
-	acpi_status status;
-	struct acpi_table_desc *table_desc;
-
-	status = acpi_tb_get_next_root_index(table_index);
-	if (ACPI_FAILURE(status)) {
-		return (status);
-	}
-
-	/* Initialize added table */
-
-	table_desc = &acpi_gbl_root_table_list.tables[*table_index];
-	acpi_tb_init_table_descriptor(table_desc, address, flags, table);
-	table_desc->pointer = table;
-	return (AE_OK);
-}
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_tb_uninstall_table

commit 77ddc2fe08329e375505bc36a3df3233fe57317b
Author: Octavian Purdila <octavian.purdila@intel.com>
Date:   Mon Apr 13 11:49:05 2015 +0800

    ACPICA: Tables: Don't release ACPI_MTX_TABLES in acpi_tb_install_standard_table().
    
    ACPICA commit c70434d4da13e65b6163c79a5aa16b40193631c7
    
    ACPI_MTX_TABLES is acquired and released by the callers of
    acpi_tb_install_standard_table() so releasing it in the function itself is
    causing the following error in Linux kernel if the table is reloaded:
    
    ACPI Error: Mutex [0x2] is not acquired, cannot release (20141107/utmutex-321)
    Call Trace:
      [<ffffffff81b0bd48>] dump_stack+0x4f/0x7b
      [<ffffffff81546bf5>] acpi_ut_release_mutex+0x47/0x67
      [<ffffffff81544357>] acpi_load_table+0x73/0xcb
    
    Link: https://github.com/acpica/acpica/commit/c70434d4
    Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 0d184c4344e6..7e69bc73bd16 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -349,7 +349,6 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 				 */
 				acpi_tb_uninstall_table(&new_table_desc);
 				*table_index = i;
-				(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
 				return_ACPI_STATUS(AE_OK);
 			}
 		}

commit 1d0a0b2f6df2bf2643fadc990eb143361eca6ada
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Apr 13 11:48:52 2015 +0800

    ACPICA: Utilities: Cleanup to remove useless ACPI_PRINTF/FORMAT_xxx helpers.
    
    ACPICA commit b60612373a4ef63b64a57c124576d7ddb6d8efb6
    
    For physical addresses, since the address may exceed 32-bit address range
    after calculation, we should use 0x%8.8X%8.8X instead of ACPI_PRINTF_UINT
    and ACPI_FORMAT_UINT64() instead of
    ACPI_FORMAT_NATIVE_UINT()/ACPI_FORMAT_TO_UINT().
    
    This patch also removes above replaced macros as there are no users.
    
    This is a preparation to switch acpi_physical_address to 64-bit on 32-bit
    kernel builds.
    
    Link: https://github.com/acpica/acpica/commit/b6061237
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 65da4c0f13e6..0d184c4344e6 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -432,11 +432,11 @@ void acpi_tb_override_table(struct acpi_table_desc *old_table_desc)
 		return;
 	}
 
-	ACPI_INFO((AE_INFO, "%4.4s " ACPI_PRINTF_UINT
-		   " %s table override, new table: " ACPI_PRINTF_UINT,
+	ACPI_INFO((AE_INFO, "%4.4s 0x%8.8X%8.8X"
+		   " %s table override, new table: 0x%8.8X%8.8X",
 		   old_table_desc->signature.ascii,
-		   ACPI_FORMAT_TO_UINT(old_table_desc->address),
-		   override_type, ACPI_FORMAT_TO_UINT(new_table_desc.address)));
+		   ACPI_FORMAT_UINT64(old_table_desc->address),
+		   override_type, ACPI_FORMAT_UINT64(new_table_desc.address)));
 
 	/* We can now uninstall the original table */
 

commit cc2080b0e5a7c6c33ef5e9ffccbc2b8f6f861393
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Apr 13 11:48:46 2015 +0800

    ACPICA: Utilities: Cleanup to convert physical address printing formats.
    
    ACPICA commit 7f06739db43a85083a70371c14141008f20b2198
    
    For physical addresses, since the address may exceed 32-bit address range
    after calculation, we should use %8.8X%8.8X (see ACPI_FORMAT_UINT64()) to
    convert the %p formats.
    
    This is a preparation to switch acpi_physical_address to 64-bit on 32-bit
    kernel builds.
    
    Link: https://github.com/acpica/acpica/commit/7f06739d
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 201332a63140..65da4c0f13e6 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -187,8 +187,9 @@ acpi_tb_install_fixed_table(acpi_physical_address address,
 	status = acpi_tb_acquire_temp_table(&new_table_desc, address,
 					    ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL);
 	if (ACPI_FAILURE(status)) {
-		ACPI_ERROR((AE_INFO, "Could not acquire table length at %p",
-			    ACPI_PHYSADDR_TO_PTR(address)));
+		ACPI_ERROR((AE_INFO,
+			    "Could not acquire table length at %8.8X%8.8X",
+			    ACPI_FORMAT_UINT64(address)));
 		return_ACPI_STATUS(status);
 	}
 
@@ -246,8 +247,9 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 
 	status = acpi_tb_acquire_temp_table(&new_table_desc, address, flags);
 	if (ACPI_FAILURE(status)) {
-		ACPI_ERROR((AE_INFO, "Could not acquire table length at %p",
-			    ACPI_PHYSADDR_TO_PTR(address)));
+		ACPI_ERROR((AE_INFO,
+			    "Could not acquire table length at %8.8X%8.8X",
+			    ACPI_FORMAT_UINT64(address)));
 		return_ACPI_STATUS(status);
 	}
 
@@ -258,9 +260,10 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 	if (!reload &&
 	    acpi_gbl_disable_ssdt_table_install &&
 	    ACPI_COMPARE_NAME(&new_table_desc.signature, ACPI_SIG_SSDT)) {
-		ACPI_INFO((AE_INFO, "Ignoring installation of %4.4s at %p",
+		ACPI_INFO((AE_INFO,
+			   "Ignoring installation of %4.4s at %8.8X%8.8X",
 			   new_table_desc.signature.ascii,
-			   ACPI_PHYSADDR_TO_PTR(address)));
+			   ACPI_FORMAT_UINT64(address)));
 		goto release_and_exit;
 	}
 

commit 6d3fd3cc33d50e4c0d0c0bd172de02caaec3127c
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Apr 13 11:48:37 2015 +0800

    ACPICA: Utilities: Cleanup to enforce ACPI_PHYSADDR_TO_PTR()/ACPI_PTR_TO_PHYSADDR().
    
    ACPICA commit 154f6d074dd38d6ebc0467ad454454e6c5c9ecdf
    
    There are code pieces converting pointers using "(acpi_physical_address) x"
    or "ACPI_CAST_PTR (t, x)" formats, this patch cleans up them.
    
    Known issues:
    1. Cleanup of "(ACPI_PHYSICAL_ADDRRESS) x" for a table field
       For the conversions around the table fields, it is better to fix it with
       alignment also fixed. So this patch doesn't modify such code. There
       should be no functional problem by leaving them unchanged.
    
    Link: https://github.com/acpica/acpica/commit/154f6d07
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 9bad45e63a45..201332a63140 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -188,7 +188,7 @@ acpi_tb_install_fixed_table(acpi_physical_address address,
 					    ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL);
 	if (ACPI_FAILURE(status)) {
 		ACPI_ERROR((AE_INFO, "Could not acquire table length at %p",
-			    ACPI_CAST_PTR(void, address)));
+			    ACPI_PHYSADDR_TO_PTR(address)));
 		return_ACPI_STATUS(status);
 	}
 
@@ -247,7 +247,7 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 	status = acpi_tb_acquire_temp_table(&new_table_desc, address, flags);
 	if (ACPI_FAILURE(status)) {
 		ACPI_ERROR((AE_INFO, "Could not acquire table length at %p",
-			    ACPI_CAST_PTR(void, address)));
+			    ACPI_PHYSADDR_TO_PTR(address)));
 		return_ACPI_STATUS(status);
 	}
 
@@ -259,8 +259,8 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 	    acpi_gbl_disable_ssdt_table_install &&
 	    ACPI_COMPARE_NAME(&new_table_desc.signature, ACPI_SIG_SSDT)) {
 		ACPI_INFO((AE_INFO, "Ignoring installation of %4.4s at %p",
-			   new_table_desc.signature.ascii, ACPI_CAST_PTR(void,
-									 address)));
+			   new_table_desc.signature.ascii,
+			   ACPI_PHYSADDR_TO_PTR(address)));
 		goto release_and_exit;
 	}
 
@@ -517,7 +517,7 @@ void acpi_tb_uninstall_table(struct acpi_table_desc *table_desc)
 
 	if ((table_desc->flags & ACPI_TABLE_ORIGIN_MASK) ==
 	    ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL) {
-		ACPI_FREE(ACPI_CAST_PTR(void, table_desc->address));
+		ACPI_FREE(ACPI_PHYSADDR_TO_PTR(table_desc->address));
 	}
 
 	table_desc->address = ACPI_PTR_TO_PHYSADDR(NULL);

commit 82a809419429f2e6142d2c5d88d91661f8aecb87
Author: David E. Box <david.e.box@linux.intel.com>
Date:   Thu Feb 5 15:20:45 2015 +0800

    ACPICA: Update Copyright headers to 2015
    
    ACPICA commit 8990e73ab2aa15d6a0068b860ab54feff25bee36
    
    Link: https://github.com/acpica/acpica/commit/8990e73a
    Signed-off-by: David E. Box <david.e.box@linux.intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 755b90c40ddf..9bad45e63a45 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2014, Intel Corp.
+ * Copyright (C) 2000 - 2015, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 47d68c7f688c01557cb67dd80eb540e88d7913b6
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Sat May 31 08:14:44 2014 +0800

    ACPICA: Tables: Add mechanism to control early table checksum verification.
    
    It is reported that Linux x86 kernel cannot map large tables. The following
    large SSDT table on such platform fails to pass checksum verification and
    cannot be installed:
     ACPI: SSDT 0x00000000B9638018 07A0C4 (v02 INTEL  S2600CP  00004000 INTL 20100331)
    
    It sounds strange that in the 64-bit virtual memory address space, we
    cannot map a single ACPI table to do checksum verification. The root cause
    is:
     1. ACPICA doesn't split IO memory mapping and table mapping;
     2. Linux x86 OSL implements acpi_os_map_memory() using a size limited fix-map
        mechanism during early boot stage, which is more suitable for only IO
        mappings.
    
    ACPICA originally only mapped table header for signature validation, and
    this header mapping is required by OSL override mechanism. There was no
    checksum verification because we could not map the whole table using this
    OSL. While the following ACPICA commit enforces checksum verification by
    mapping the whole table during Linux boot stage and it finally triggers
    this issue on some platforms:
     Commit: 86dfc6f339886559d80ee0d4bd20fe5ee90450f0
     Subject: ACPICA: Tables: Fix table checksums verification before installation.
    
    Before doing further cleanups for the OSL table mapping and override
    implementation, this patch introduces an option for such OSPMs to
    temporarily discard the checksum verification feature. It then can be
    re-enabled easily when the ACPICA and the underlying OSL is ready.
    
    This patch also deletes a comment around the limitation of mappings because
    it is not correct. The limitation is not how many times we can map in the
    early stage, but the OSL mapping facility may not be suitable for mapping
    the ACPI tables and thus may complain us the size limitation.
    
    The acpi_tb_verify_table() is renamed to acpi_tb_verify_temp_table() due to the
    work around added, it now only applies to the table descriptor that hasn't
    been installed and cannot be used in other cases. Lv Zheng.
    
    Tested-by: Yuanhan Liu <yuanhan.liu@linux.intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index d4d6029fef44..755b90c40ddf 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -194,7 +194,7 @@ acpi_tb_install_fixed_table(acpi_physical_address address,
 
 	/* Validate and verify a table before installation */
 
-	status = acpi_tb_verify_table(&new_table_desc, signature);
+	status = acpi_tb_verify_temp_table(&new_table_desc, signature);
 	if (ACPI_FAILURE(status)) {
 		goto release_and_exit;
 	}
@@ -266,7 +266,7 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 
 	/* Validate and verify a table before installation */
 
-	status = acpi_tb_verify_table(&new_table_desc, NULL);
+	status = acpi_tb_verify_temp_table(&new_table_desc, NULL);
 	if (ACPI_FAILURE(status)) {
 		goto release_and_exit;
 	}
@@ -424,7 +424,7 @@ void acpi_tb_override_table(struct acpi_table_desc *old_table_desc)
 
 	/* Validate and verify a table before overriding */
 
-	status = acpi_tb_verify_table(&new_table_desc, NULL);
+	status = acpi_tb_verify_temp_table(&new_table_desc, NULL);
 	if (ACPI_FAILURE(status)) {
 		return;
 	}
@@ -446,7 +446,7 @@ void acpi_tb_override_table(struct acpi_table_desc *old_table_desc)
 	acpi_tb_init_table_descriptor(old_table_desc, new_table_desc.address,
 				      new_table_desc.flags,
 				      new_table_desc.pointer);
-	acpi_tb_validate_table(old_table_desc);
+	acpi_tb_validate_temp_table(old_table_desc);
 
 	/* Release the temporary table descriptor */
 

commit c418ce19030f8cd9304b4e97c8e0dd580a81ace5
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Apr 4 12:39:34 2014 +0800

    ACPICA: Table Manager: Split tbinstal.c into two files.
    
    New file is tbdata.c -- management functions for ACPICA table
    manager data structures.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 50a6f229633c..d4d6029fef44 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -43,355 +43,57 @@
 
 #include <acpi/acpi.h>
 #include "accommon.h"
-#include "acnamesp.h"
 #include "actables.h"
 
 #define _COMPONENT          ACPI_TABLES
 ACPI_MODULE_NAME("tbinstal")
 
 /* Local prototypes */
-static acpi_status
-acpi_tb_acquire_temp_table(struct acpi_table_desc *table_desc,
-			   acpi_physical_address address, u8 flags);
-
-static void acpi_tb_release_temp_table(struct acpi_table_desc *table_desc);
-
-static acpi_status acpi_tb_get_root_table_entry(u32 *table_index);
-
 static u8
-acpi_tb_is_equivalent_table(struct acpi_table_desc *table_desc,
-			    u32 table_index);
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_acquire_table
- *
- * PARAMETERS:  table_desc          - Table descriptor
- *              table_ptr           - Where table is returned
- *              table_length        - Where table length is returned
- *              table_flags         - Where table allocation flags are returned
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Acquire an ACPI table. It can be used for tables not
- *              maintained in the acpi_gbl_root_table_list.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_tb_acquire_table(struct acpi_table_desc *table_desc,
-		      struct acpi_table_header **table_ptr,
-		      u32 *table_length, u8 *table_flags)
-{
-	struct acpi_table_header *table = NULL;
-
-	switch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {
-	case ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:
-
-		table =
-		    acpi_os_map_memory(table_desc->address, table_desc->length);
-		break;
-
-	case ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:
-	case ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:
-
-		table =
-		    ACPI_CAST_PTR(struct acpi_table_header,
-				  table_desc->address);
-		break;
-
-	default:
-
-		break;
-	}
-
-	/* Table is not valid yet */
-
-	if (!table) {
-		return (AE_NO_MEMORY);
-	}
-
-	/* Fill the return values */
-
-	*table_ptr = table;
-	*table_length = table_desc->length;
-	*table_flags = table_desc->flags;
-	return (AE_OK);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_release_table
- *
- * PARAMETERS:  table               - Pointer for the table
- *              table_length        - Length for the table
- *              table_flags         - Allocation flags for the table
- *
- * RETURN:      None
- *
- * DESCRIPTION: Release a table. The inverse of acpi_tb_acquire_table().
- *
- ******************************************************************************/
-
-void
-acpi_tb_release_table(struct acpi_table_header *table,
-		      u32 table_length, u8 table_flags)
-{
-
-	switch (table_flags & ACPI_TABLE_ORIGIN_MASK) {
-	case ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:
-
-		acpi_os_unmap_memory(table, table_length);
-		break;
-
-	case ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:
-	case ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:
-	default:
-
-		break;
-	}
-}
-
-/******************************************************************************
- *
- * FUNCTION:    acpi_tb_validate_table
- *
- * PARAMETERS:  table_desc          - Table descriptor
- *
- * RETURN:      Status
- *
- * DESCRIPTION: This function is called to validate the table, the returned
- *              table descriptor is in "VALIDATED" state.
- *
- *****************************************************************************/
-
-acpi_status acpi_tb_validate_table(struct acpi_table_desc *table_desc)
-{
-	acpi_status status = AE_OK;
-
-	ACPI_FUNCTION_TRACE(tb_validate_table);
-
-	/* Validate the table if necessary */
-
-	if (!table_desc->pointer) {
-		status = acpi_tb_acquire_table(table_desc, &table_desc->pointer,
-					       &table_desc->length,
-					       &table_desc->flags);
-		if (!table_desc->pointer) {
-			status = AE_NO_MEMORY;
-		}
-	}
-
-	return_ACPI_STATUS(status);
-}
+acpi_tb_compare_tables(struct acpi_table_desc *table_desc, u32 table_index);
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_tb_invalidate_table
+ * FUNCTION:    acpi_tb_compare_tables
  *
- * PARAMETERS:  table_desc          - Table descriptor
+ * PARAMETERS:  table_desc          - Table 1 descriptor to be compared
+ *              table_index         - Index of table 2 to be compared
  *
- * RETURN:      None
+ * RETURN:      TRUE if both tables are identical.
  *
- * DESCRIPTION: Invalidate one internal ACPI table, this is the inverse of
- *              acpi_tb_validate_table().
+ * DESCRIPTION: This function compares a table with another table that has
+ *              already been installed in the root table list.
  *
  ******************************************************************************/
 
-void acpi_tb_invalidate_table(struct acpi_table_desc *table_desc)
-{
-
-	ACPI_FUNCTION_TRACE(tb_invalidate_table);
-
-	/* Table must be validated */
-
-	if (!table_desc->pointer) {
-		return_VOID;
-	}
-
-	acpi_tb_release_table(table_desc->pointer, table_desc->length,
-			      table_desc->flags);
-	table_desc->pointer = NULL;
-
-	return_VOID;
-}
-
-/******************************************************************************
- *
- * FUNCTION:    acpi_tb_verify_table
- *
- * PARAMETERS:  table_desc          - Table descriptor
- *              signature           - Table signature to verify
- *
- * RETURN:      Status
- *
- * DESCRIPTION: This function is called to validate and verify the table, the
- *              returned table descriptor is in "VALIDATED" state.
- *
- *****************************************************************************/
-
-acpi_status
-acpi_tb_verify_table(struct acpi_table_desc *table_desc, char *signature)
+static u8
+acpi_tb_compare_tables(struct acpi_table_desc *table_desc, u32 table_index)
 {
 	acpi_status status = AE_OK;
-
-	ACPI_FUNCTION_TRACE(tb_verify_table);
-
-	/* Validate the table */
-
-	status = acpi_tb_validate_table(table_desc);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	/* If a particular signature is expected (DSDT/FACS), it must match */
-
-	if (signature && !ACPI_COMPARE_NAME(&table_desc->signature, signature)) {
-		ACPI_BIOS_ERROR((AE_INFO,
-				 "Invalid signature 0x%X for ACPI table, expected [%s]",
-				 table_desc->signature.integer, signature));
-		status = AE_BAD_SIGNATURE;
-		goto invalidate_and_exit;
-	}
-
-	/* Verify the checksum */
+	u8 is_identical;
+	struct acpi_table_header *table;
+	u32 table_length;
+	u8 table_flags;
 
 	status =
-	    acpi_tb_verify_checksum(table_desc->pointer, table_desc->length);
+	    acpi_tb_acquire_table(&acpi_gbl_root_table_list.tables[table_index],
+				  &table, &table_length, &table_flags);
 	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY,
-				"%4.4s " ACPI_PRINTF_UINT
-				" Attempted table install failed",
-				acpi_ut_valid_acpi_name(table_desc->signature.
-							ascii) ? table_desc->
-				signature.ascii : "????",
-				ACPI_FORMAT_TO_UINT(table_desc->address)));
-		goto invalidate_and_exit;
+		return (FALSE);
 	}
 
-	return_ACPI_STATUS(AE_OK);
-
-invalidate_and_exit:
-	acpi_tb_invalidate_table(table_desc);
-	return_ACPI_STATUS(status);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_init_table_descriptor
- *
- * PARAMETERS:  table_desc              - Table descriptor
- *              address                 - Physical address of the table
- *              flags                   - Allocation flags of the table
- *              table                   - Pointer to the table
- *
- * RETURN:      None
- *
- * DESCRIPTION: Initialize a new table descriptor
- *
- ******************************************************************************/
-
-void
-acpi_tb_init_table_descriptor(struct acpi_table_desc *table_desc,
-			      acpi_physical_address address,
-			      u8 flags, struct acpi_table_header *table)
-{
-
 	/*
-	 * Initialize the table descriptor. Set the pointer to NULL, since the
-	 * table is not fully mapped at this time.
+	 * Check for a table match on the entire table length,
+	 * not just the header.
 	 */
-	ACPI_MEMSET(table_desc, 0, sizeof(struct acpi_table_desc));
-	table_desc->address = address;
-	table_desc->length = table->length;
-	table_desc->flags = flags;
-	ACPI_MOVE_32_TO_32(table_desc->signature.ascii, table->signature);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_acquire_temp_table
- *
- * PARAMETERS:  table_desc          - Table descriptor to be acquired
- *              address             - Address of the table
- *              flags               - Allocation flags of the table
- *
- * RETURN:      Status
- *
- * DESCRIPTION: This function validates the table header to obtain the length
- *              of a table and fills the table descriptor to make its state as
- *              "INSTALLED". Such a table descriptor is only used for verified
- *              installation.
- *
- ******************************************************************************/
-
-static acpi_status
-acpi_tb_acquire_temp_table(struct acpi_table_desc *table_desc,
-			   acpi_physical_address address, u8 flags)
-{
-	struct acpi_table_header *table_header;
-
-	switch (flags & ACPI_TABLE_ORIGIN_MASK) {
-	case ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:
-
-		/* Get the length of the full table from the header */
-
-		table_header =
-		    acpi_os_map_memory(address,
-				       sizeof(struct acpi_table_header));
-		if (!table_header) {
-			return (AE_NO_MEMORY);
-		}
-
-		acpi_tb_init_table_descriptor(table_desc, address, flags,
-					      table_header);
-		acpi_os_unmap_memory(table_header,
-				     sizeof(struct acpi_table_header));
-		return (AE_OK);
-
-	case ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:
-	case ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:
+	is_identical = (u8)((table_desc->length != table_length ||
+			     ACPI_MEMCMP(table_desc->pointer, table,
+					 table_length)) ? FALSE : TRUE);
 
-		table_header = ACPI_CAST_PTR(struct acpi_table_header, address);
-		if (!table_header) {
-			return (AE_NO_MEMORY);
-		}
-
-		acpi_tb_init_table_descriptor(table_desc, address, flags,
-					      table_header);
-		return (AE_OK);
-
-	default:
-
-		break;
-	}
-
-	/* Table is not valid yet */
-
-	return (AE_NO_MEMORY);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_release_temp_table
- *
- * PARAMETERS:  table_desc          - Table descriptor to be released
- *
- * RETURN:      Status
- *
- * DESCRIPTION: The inverse of acpi_tb_acquire_temp_table().
- *
- ******************************************************************************/
-
-static void acpi_tb_release_temp_table(struct acpi_table_desc *table_desc)
-{
+	/* Release the acquired table */
 
-	/*
-	 * Note that the .Address is maintained by the callers of
-	 * acpi_tb_acquire_temp_table(), thus do not invoke acpi_tb_uninstall_table()
-	 * where .Address will be freed.
-	 */
-	acpi_tb_invalidate_table(table_desc);
+	acpi_tb_release_table(table, table_length, table_flags);
+	return (is_identical);
 }
 
 /*******************************************************************************
@@ -507,50 +209,6 @@ acpi_tb_install_fixed_table(acpi_physical_address address,
 	return_ACPI_STATUS(status);
 }
 
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_is_equivalent_table
- *
- * PARAMETERS:  table_desc          - Table 1 descriptor to be compared
- *              table_index         - Index of table 2 to be compared
- *
- * RETURN:      TRUE if 2 tables are equivalent
- *
- * DESCRIPTION: This function is called to compare a table with what have
- *              already been installed in the root table list.
- *
- ******************************************************************************/
-
-static u8
-acpi_tb_is_equivalent_table(struct acpi_table_desc *table_desc, u32 table_index)
-{
-	acpi_status status = AE_OK;
-	u8 is_equivalent;
-	struct acpi_table_header *table;
-	u32 table_length;
-	u8 table_flags;
-
-	status =
-	    acpi_tb_acquire_table(&acpi_gbl_root_table_list.tables[table_index],
-				  &table, &table_length, &table_flags);
-	if (ACPI_FAILURE(status)) {
-		return (FALSE);
-	}
-
-	/*
-	 * Check for a table match on the entire table length,
-	 * not just the header.
-	 */
-	is_equivalent = (u8)((table_desc->length != table_length ||
-			      ACPI_MEMCMP(table_desc->pointer, table,
-					  table_length)) ? FALSE : TRUE);
-
-	/* Release the acquired table */
-
-	acpi_tb_release_table(table, table_length, table_flags);
-	return (is_equivalent);
-}
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_tb_install_standard_table
@@ -652,7 +310,7 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 			 * Check for a table match on the entire table length,
 			 * not just the header.
 			 */
-			if (!acpi_tb_is_equivalent_table(&new_table_desc, i)) {
+			if (!acpi_tb_compare_tables(&new_table_desc, i)) {
 				continue;
 			}
 
@@ -696,7 +354,7 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 
 	/* Add the table to the global root table list */
 
-	status = acpi_tb_get_root_table_entry(&i);
+	status = acpi_tb_get_next_root_index(&i);
 	if (ACPI_FAILURE(status)) {
 		goto release_and_exit;
 	}
@@ -795,101 +453,6 @@ void acpi_tb_override_table(struct acpi_table_desc *old_table_desc)
 	acpi_tb_release_temp_table(&new_table_desc);
 }
 
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_resize_root_table_list
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Expand the size of global table array
- *
- ******************************************************************************/
-
-acpi_status acpi_tb_resize_root_table_list(void)
-{
-	struct acpi_table_desc *tables;
-	u32 table_count;
-
-	ACPI_FUNCTION_TRACE(tb_resize_root_table_list);
-
-	/* allow_resize flag is a parameter to acpi_initialize_tables */
-
-	if (!(acpi_gbl_root_table_list.flags & ACPI_ROOT_ALLOW_RESIZE)) {
-		ACPI_ERROR((AE_INFO,
-			    "Resize of Root Table Array is not allowed"));
-		return_ACPI_STATUS(AE_SUPPORT);
-	}
-
-	/* Increase the Table Array size */
-
-	if (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {
-		table_count = acpi_gbl_root_table_list.max_table_count;
-	} else {
-		table_count = acpi_gbl_root_table_list.current_table_count;
-	}
-
-	tables = ACPI_ALLOCATE_ZEROED(((acpi_size) table_count +
-				       ACPI_ROOT_TABLE_SIZE_INCREMENT) *
-				      sizeof(struct acpi_table_desc));
-	if (!tables) {
-		ACPI_ERROR((AE_INFO,
-			    "Could not allocate new root table array"));
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	/* Copy and free the previous table array */
-
-	if (acpi_gbl_root_table_list.tables) {
-		ACPI_MEMCPY(tables, acpi_gbl_root_table_list.tables,
-			    (acpi_size) table_count *
-			    sizeof(struct acpi_table_desc));
-
-		if (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {
-			ACPI_FREE(acpi_gbl_root_table_list.tables);
-		}
-	}
-
-	acpi_gbl_root_table_list.tables = tables;
-	acpi_gbl_root_table_list.max_table_count =
-	    table_count + ACPI_ROOT_TABLE_SIZE_INCREMENT;
-	acpi_gbl_root_table_list.flags |= ACPI_ROOT_ORIGIN_ALLOCATED;
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_get_root_table_entry
- *
- * PARAMETERS:  table_index         - Where table index is returned
- *
- * RETURN:      Status and table index.
- *
- * DESCRIPTION: Allocate a new ACPI table entry to the global table list
- *
- ******************************************************************************/
-
-static acpi_status acpi_tb_get_root_table_entry(u32 *table_index)
-{
-	acpi_status status;
-
-	/* Ensure that there is room for the table in the Root Table List */
-
-	if (acpi_gbl_root_table_list.current_table_count >=
-	    acpi_gbl_root_table_list.max_table_count) {
-		status = acpi_tb_resize_root_table_list();
-		if (ACPI_FAILURE(status)) {
-			return (status);
-		}
-	}
-
-	*table_index = acpi_gbl_root_table_list.current_table_count;
-	acpi_gbl_root_table_list.current_table_count++;
-	return (AE_OK);
-}
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_tb_store_table
@@ -914,7 +477,7 @@ acpi_tb_store_table(acpi_physical_address address,
 	acpi_status status;
 	struct acpi_table_desc *table_desc;
 
-	status = acpi_tb_get_root_table_entry(table_index);
+	status = acpi_tb_get_next_root_index(table_index);
 	if (ACPI_FAILURE(status)) {
 		return (status);
 	}
@@ -960,250 +523,3 @@ void acpi_tb_uninstall_table(struct acpi_table_desc *table_desc)
 	table_desc->address = ACPI_PTR_TO_PHYSADDR(NULL);
 	return_VOID;
 }
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_terminate
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Delete all internal ACPI tables
- *
- ******************************************************************************/
-
-void acpi_tb_terminate(void)
-{
-	u32 i;
-
-	ACPI_FUNCTION_TRACE(tb_terminate);
-
-	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
-
-	/* Delete the individual tables */
-
-	for (i = 0; i < acpi_gbl_root_table_list.current_table_count; i++) {
-		acpi_tb_uninstall_table(&acpi_gbl_root_table_list.tables[i]);
-	}
-
-	/*
-	 * Delete the root table array if allocated locally. Array cannot be
-	 * mapped, so we don't need to check for that flag.
-	 */
-	if (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {
-		ACPI_FREE(acpi_gbl_root_table_list.tables);
-	}
-
-	acpi_gbl_root_table_list.tables = NULL;
-	acpi_gbl_root_table_list.flags = 0;
-	acpi_gbl_root_table_list.current_table_count = 0;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "ACPI Tables freed\n"));
-
-	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
-	return_VOID;
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_delete_namespace_by_owner
- *
- * PARAMETERS:  table_index         - Table index
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Delete all namespace objects created when this table was loaded.
- *
- ******************************************************************************/
-
-acpi_status acpi_tb_delete_namespace_by_owner(u32 table_index)
-{
-	acpi_owner_id owner_id;
-	acpi_status status;
-
-	ACPI_FUNCTION_TRACE(tb_delete_namespace_by_owner);
-
-	status = acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	if (table_index >= acpi_gbl_root_table_list.current_table_count) {
-
-		/* The table index does not exist */
-
-		(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
-		return_ACPI_STATUS(AE_NOT_EXIST);
-	}
-
-	/* Get the owner ID for this table, used to delete namespace nodes */
-
-	owner_id = acpi_gbl_root_table_list.tables[table_index].owner_id;
-	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
-
-	/*
-	 * Need to acquire the namespace writer lock to prevent interference
-	 * with any concurrent namespace walks. The interpreter must be
-	 * released during the deletion since the acquisition of the deletion
-	 * lock may block, and also since the execution of a namespace walk
-	 * must be allowed to use the interpreter.
-	 */
-	(void)acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);
-	status = acpi_ut_acquire_write_lock(&acpi_gbl_namespace_rw_lock);
-
-	acpi_ns_delete_namespace_by_owner(owner_id);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	acpi_ut_release_write_lock(&acpi_gbl_namespace_rw_lock);
-
-	status = acpi_ut_acquire_mutex(ACPI_MTX_INTERPRETER);
-	return_ACPI_STATUS(status);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_allocate_owner_id
- *
- * PARAMETERS:  table_index         - Table index
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Allocates owner_id in table_desc
- *
- ******************************************************************************/
-
-acpi_status acpi_tb_allocate_owner_id(u32 table_index)
-{
-	acpi_status status = AE_BAD_PARAMETER;
-
-	ACPI_FUNCTION_TRACE(tb_allocate_owner_id);
-
-	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
-	if (table_index < acpi_gbl_root_table_list.current_table_count) {
-		status =
-		    acpi_ut_allocate_owner_id(&
-					      (acpi_gbl_root_table_list.
-					       tables[table_index].owner_id));
-	}
-
-	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
-	return_ACPI_STATUS(status);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_release_owner_id
- *
- * PARAMETERS:  table_index         - Table index
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Releases owner_id in table_desc
- *
- ******************************************************************************/
-
-acpi_status acpi_tb_release_owner_id(u32 table_index)
-{
-	acpi_status status = AE_BAD_PARAMETER;
-
-	ACPI_FUNCTION_TRACE(tb_release_owner_id);
-
-	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
-	if (table_index < acpi_gbl_root_table_list.current_table_count) {
-		acpi_ut_release_owner_id(&
-					 (acpi_gbl_root_table_list.
-					  tables[table_index].owner_id));
-		status = AE_OK;
-	}
-
-	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
-	return_ACPI_STATUS(status);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_get_owner_id
- *
- * PARAMETERS:  table_index         - Table index
- *              owner_id            - Where the table owner_id is returned
- *
- * RETURN:      Status
- *
- * DESCRIPTION: returns owner_id for the ACPI table
- *
- ******************************************************************************/
-
-acpi_status acpi_tb_get_owner_id(u32 table_index, acpi_owner_id * owner_id)
-{
-	acpi_status status = AE_BAD_PARAMETER;
-
-	ACPI_FUNCTION_TRACE(tb_get_owner_id);
-
-	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
-	if (table_index < acpi_gbl_root_table_list.current_table_count) {
-		*owner_id =
-		    acpi_gbl_root_table_list.tables[table_index].owner_id;
-		status = AE_OK;
-	}
-
-	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
-	return_ACPI_STATUS(status);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_is_table_loaded
- *
- * PARAMETERS:  table_index         - Index into the root table
- *
- * RETURN:      Table Loaded Flag
- *
- ******************************************************************************/
-
-u8 acpi_tb_is_table_loaded(u32 table_index)
-{
-	u8 is_loaded = FALSE;
-
-	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
-	if (table_index < acpi_gbl_root_table_list.current_table_count) {
-		is_loaded = (u8)
-		    (acpi_gbl_root_table_list.tables[table_index].flags &
-		     ACPI_TABLE_IS_LOADED);
-	}
-
-	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
-	return (is_loaded);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_tb_set_table_loaded_flag
- *
- * PARAMETERS:  table_index         - Table index
- *              is_loaded           - TRUE if table is loaded, FALSE otherwise
- *
- * RETURN:      None
- *
- * DESCRIPTION: Sets the table loaded flag to either TRUE or FALSE.
- *
- ******************************************************************************/
-
-void acpi_tb_set_table_loaded_flag(u32 table_index, u8 is_loaded)
-{
-
-	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
-	if (table_index < acpi_gbl_root_table_list.current_table_count) {
-		if (is_loaded) {
-			acpi_gbl_root_table_list.tables[table_index].flags |=
-			    ACPI_TABLE_IS_LOADED;
-		} else {
-			acpi_gbl_root_table_list.tables[table_index].flags &=
-			    ~ACPI_TABLE_IS_LOADED;
-		}
-	}
-
-	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
-}

commit ed6f1d44dae8a4eec42a74acae95cc177ee2e1ad
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Apr 4 12:39:26 2014 +0800

    ACPICA: Table Manager: Misc cleanup and renames, no functional change.
    
    Some various cleanups and renames.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 9835213269e6..50a6f229633c 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -51,12 +51,12 @@ ACPI_MODULE_NAME("tbinstal")
 
 /* Local prototypes */
 static acpi_status
-acpi_tb_acquire_temporal_table(struct acpi_table_desc *table_desc,
-			       acpi_physical_address address, u8 flags);
+acpi_tb_acquire_temp_table(struct acpi_table_desc *table_desc,
+			   acpi_physical_address address, u8 flags);
 
-static void acpi_tb_release_temporal_table(struct acpi_table_desc *table_desc);
+static void acpi_tb_release_temp_table(struct acpi_table_desc *table_desc);
 
-static acpi_status acpi_tb_acquire_root_table_entry(u32 *table_index);
+static acpi_status acpi_tb_get_root_table_entry(u32 *table_index);
 
 static u8
 acpi_tb_is_equivalent_table(struct acpi_table_desc *table_desc,
@@ -73,8 +73,8 @@ acpi_tb_is_equivalent_table(struct acpi_table_desc *table_desc,
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Acquire a table. It can be used for tables not maintained in
- *              acpi_gbl_root_table_list.
+ * DESCRIPTION: Acquire an ACPI table. It can be used for tables not
+ *              maintained in the acpi_gbl_root_table_list.
  *
  ******************************************************************************/
 
@@ -86,14 +86,14 @@ acpi_tb_acquire_table(struct acpi_table_desc *table_desc,
 	struct acpi_table_header *table = NULL;
 
 	switch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {
-	case ACPI_TABLE_ORIGIN_INTERN_PHYSICAL:
+	case ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:
 
 		table =
 		    acpi_os_map_memory(table_desc->address, table_desc->length);
 		break;
 
-	case ACPI_TABLE_ORIGIN_INTERN_VIRTUAL:
-	case ACPI_TABLE_ORIGIN_EXTERN_VIRTUAL:
+	case ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:
+	case ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:
 
 		table =
 		    ACPI_CAST_PTR(struct acpi_table_header,
@@ -116,7 +116,6 @@ acpi_tb_acquire_table(struct acpi_table_desc *table_desc,
 	*table_ptr = table;
 	*table_length = table_desc->length;
 	*table_flags = table_desc->flags;
-
 	return (AE_OK);
 }
 
@@ -130,7 +129,7 @@ acpi_tb_acquire_table(struct acpi_table_desc *table_desc,
  *
  * RETURN:      None
  *
- * DESCRIPTION: Release a table. The reversal of acpi_tb_acquire_table().
+ * DESCRIPTION: Release a table. The inverse of acpi_tb_acquire_table().
  *
  ******************************************************************************/
 
@@ -138,14 +137,15 @@ void
 acpi_tb_release_table(struct acpi_table_header *table,
 		      u32 table_length, u8 table_flags)
 {
+
 	switch (table_flags & ACPI_TABLE_ORIGIN_MASK) {
-	case ACPI_TABLE_ORIGIN_INTERN_PHYSICAL:
+	case ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:
 
 		acpi_os_unmap_memory(table, table_length);
 		break;
 
-	case ACPI_TABLE_ORIGIN_INTERN_VIRTUAL:
-	case ACPI_TABLE_ORIGIN_EXTERN_VIRTUAL:
+	case ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:
+	case ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:
 	default:
 
 		break;
@@ -193,7 +193,7 @@ acpi_status acpi_tb_validate_table(struct acpi_table_desc *table_desc)
  *
  * RETURN:      None
  *
- * DESCRIPTION: Invalidate one internal ACPI table, this is reversal of
+ * DESCRIPTION: Invalidate one internal ACPI table, this is the inverse of
  *              acpi_tb_validate_table().
  *
  ******************************************************************************/
@@ -278,7 +278,7 @@ acpi_tb_verify_table(struct acpi_table_desc *table_desc, char *signature)
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_tb_install_table
+ * FUNCTION:    acpi_tb_init_table_descriptor
  *
  * PARAMETERS:  table_desc              - Table descriptor
  *              address                 - Physical address of the table
@@ -287,17 +287,18 @@ acpi_tb_verify_table(struct acpi_table_desc *table_desc, char *signature)
  *
  * RETURN:      None
  *
- * DESCRIPTION: Install an ACPI table into the global data structure.
+ * DESCRIPTION: Initialize a new table descriptor
  *
  ******************************************************************************/
 
 void
-acpi_tb_install_table(struct acpi_table_desc *table_desc,
-		      acpi_physical_address address,
-		      u8 flags, struct acpi_table_header *table)
+acpi_tb_init_table_descriptor(struct acpi_table_desc *table_desc,
+			      acpi_physical_address address,
+			      u8 flags, struct acpi_table_header *table)
 {
+
 	/*
-	 * Initialize the table entry. Set the pointer to NULL, since the
+	 * Initialize the table descriptor. Set the pointer to NULL, since the
 	 * table is not fully mapped at this time.
 	 */
 	ACPI_MEMSET(table_desc, 0, sizeof(struct acpi_table_desc));
@@ -309,7 +310,7 @@ acpi_tb_install_table(struct acpi_table_desc *table_desc,
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_tb_acquire_temporal_table
+ * FUNCTION:    acpi_tb_acquire_temp_table
  *
  * PARAMETERS:  table_desc          - Table descriptor to be acquired
  *              address             - Address of the table
@@ -319,21 +320,21 @@ acpi_tb_install_table(struct acpi_table_desc *table_desc,
  *
  * DESCRIPTION: This function validates the table header to obtain the length
  *              of a table and fills the table descriptor to make its state as
- *              "INSTALLED".  Such table descriptor is only used for verified
+ *              "INSTALLED". Such a table descriptor is only used for verified
  *              installation.
  *
  ******************************************************************************/
 
 static acpi_status
-acpi_tb_acquire_temporal_table(struct acpi_table_desc *table_desc,
-			       acpi_physical_address address, u8 flags)
+acpi_tb_acquire_temp_table(struct acpi_table_desc *table_desc,
+			   acpi_physical_address address, u8 flags)
 {
 	struct acpi_table_header *table_header;
 
 	switch (flags & ACPI_TABLE_ORIGIN_MASK) {
-	case ACPI_TABLE_ORIGIN_INTERN_PHYSICAL:
+	case ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:
 
-		/* Try to obtain the length of the table */
+		/* Get the length of the full table from the header */
 
 		table_header =
 		    acpi_os_map_memory(address,
@@ -341,19 +342,23 @@ acpi_tb_acquire_temporal_table(struct acpi_table_desc *table_desc,
 		if (!table_header) {
 			return (AE_NO_MEMORY);
 		}
-		acpi_tb_install_table(table_desc, address, flags, table_header);
+
+		acpi_tb_init_table_descriptor(table_desc, address, flags,
+					      table_header);
 		acpi_os_unmap_memory(table_header,
 				     sizeof(struct acpi_table_header));
 		return (AE_OK);
 
-	case ACPI_TABLE_ORIGIN_INTERN_VIRTUAL:
-	case ACPI_TABLE_ORIGIN_EXTERN_VIRTUAL:
+	case ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:
+	case ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:
 
 		table_header = ACPI_CAST_PTR(struct acpi_table_header, address);
 		if (!table_header) {
 			return (AE_NO_MEMORY);
 		}
-		acpi_tb_install_table(table_desc, address, flags, table_header);
+
+		acpi_tb_init_table_descriptor(table_desc, address, flags,
+					      table_header);
 		return (AE_OK);
 
 	default:
@@ -368,21 +373,22 @@ acpi_tb_acquire_temporal_table(struct acpi_table_desc *table_desc,
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_tb_release_temporal_table
+ * FUNCTION:    acpi_tb_release_temp_table
  *
  * PARAMETERS:  table_desc          - Table descriptor to be released
  *
  * RETURN:      Status
  *
- * DESCRIPTION: The reversal of acpi_tb_acquire_temporal_table().
+ * DESCRIPTION: The inverse of acpi_tb_acquire_temp_table().
  *
  ******************************************************************************/
 
-static void acpi_tb_release_temporal_table(struct acpi_table_desc *table_desc)
+static void acpi_tb_release_temp_table(struct acpi_table_desc *table_desc)
 {
+
 	/*
 	 * Note that the .Address is maintained by the callers of
-	 * acpi_tb_acquire_temporal_table(), thus do not invoke acpi_tb_uninstall_table()
+	 * acpi_tb_acquire_temp_table(), thus do not invoke acpi_tb_uninstall_table()
 	 * where .Address will be freed.
 	 */
 	acpi_tb_invalidate_table(table_desc);
@@ -390,7 +396,7 @@ static void acpi_tb_release_temporal_table(struct acpi_table_desc *table_desc)
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_tb_install_and_override_table
+ * FUNCTION:    acpi_tb_install_table_with_override
  *
  * PARAMETERS:  table_index             - Index into root table array
  *              new_table_desc          - New table descriptor to install
@@ -406,10 +412,11 @@ static void acpi_tb_release_temporal_table(struct acpi_table_desc *table_desc)
  ******************************************************************************/
 
 void
-acpi_tb_install_and_override_table(u32 table_index,
-				   struct acpi_table_desc *new_table_desc,
-				   u8 override)
+acpi_tb_install_table_with_override(u32 table_index,
+				    struct acpi_table_desc *new_table_desc,
+				    u8 override)
 {
+
 	if (table_index >= acpi_gbl_root_table_list.current_table_count) {
 		return;
 	}
@@ -425,9 +432,11 @@ acpi_tb_install_and_override_table(u32 table_index,
 		acpi_tb_override_table(new_table_desc);
 	}
 
-	acpi_tb_install_table(&acpi_gbl_root_table_list.tables[table_index],
-			      new_table_desc->address, new_table_desc->flags,
-			      new_table_desc->pointer);
+	acpi_tb_init_table_descriptor(&acpi_gbl_root_table_list.
+				      tables[table_index],
+				      new_table_desc->address,
+				      new_table_desc->flags,
+				      new_table_desc->pointer);
 
 	acpi_tb_print_table_header(new_table_desc->address,
 				   new_table_desc->pointer);
@@ -473,8 +482,8 @@ acpi_tb_install_fixed_table(acpi_physical_address address,
 
 	/* Fill a table descriptor for validation */
 
-	status = acpi_tb_acquire_temporal_table(&new_table_desc, address,
-						ACPI_TABLE_ORIGIN_INTERN_PHYSICAL);
+	status = acpi_tb_acquire_temp_table(&new_table_desc, address,
+					    ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL);
 	if (ACPI_FAILURE(status)) {
 		ACPI_ERROR((AE_INFO, "Could not acquire table length at %p",
 			    ACPI_CAST_PTR(void, address)));
@@ -488,13 +497,13 @@ acpi_tb_install_fixed_table(acpi_physical_address address,
 		goto release_and_exit;
 	}
 
-	acpi_tb_install_and_override_table(table_index, &new_table_desc, TRUE);
+	acpi_tb_install_table_with_override(table_index, &new_table_desc, TRUE);
 
 release_and_exit:
 
-	/* Release the temporal table descriptor */
+	/* Release the temporary table descriptor */
 
-	acpi_tb_release_temporal_table(&new_table_desc);
+	acpi_tb_release_temp_table(&new_table_desc);
 	return_ACPI_STATUS(status);
 }
 
@@ -539,13 +548,12 @@ acpi_tb_is_equivalent_table(struct acpi_table_desc *table_desc, u32 table_index)
 	/* Release the acquired table */
 
 	acpi_tb_release_table(table, table_length, table_flags);
-
 	return (is_equivalent);
 }
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_tb_install_non_fixed_table
+ * FUNCTION:    acpi_tb_install_standard_table
  *
  * PARAMETERS:  address             - Address of the table (might be a virtual
  *                                    address depending on the table_flags)
@@ -557,7 +565,7 @@ acpi_tb_is_equivalent_table(struct acpi_table_desc *table_desc, u32 table_index)
  * RETURN:      Status
  *
  * DESCRIPTION: This function is called to install an ACPI table that is
- *              neither DSDT nor FACS.
+ *              neither DSDT nor FACS (a "standard" table.)
  *              When this function is called by "Load" or "LoadTable" opcodes,
  *              or by acpi_load_table() API, the "Reload" parameter is set.
  *              After sucessfully returning from this function, table is
@@ -566,20 +574,19 @@ acpi_tb_is_equivalent_table(struct acpi_table_desc *table_desc, u32 table_index)
  ******************************************************************************/
 
 acpi_status
-acpi_tb_install_non_fixed_table(acpi_physical_address address,
-				u8 flags,
-				u8 reload, u8 override, u32 *table_index)
+acpi_tb_install_standard_table(acpi_physical_address address,
+			       u8 flags,
+			       u8 reload, u8 override, u32 *table_index)
 {
 	u32 i;
 	acpi_status status = AE_OK;
 	struct acpi_table_desc new_table_desc;
 
-	ACPI_FUNCTION_TRACE(tb_install_non_fixed_table);
+	ACPI_FUNCTION_TRACE(tb_install_standard_table);
 
-	/* Acquire a temporal table descriptor for validation */
+	/* Acquire a temporary table descriptor for validation */
 
-	status =
-	    acpi_tb_acquire_temporal_table(&new_table_desc, address, flags);
+	status = acpi_tb_acquire_temp_table(&new_table_desc, address, flags);
 	if (ACPI_FAILURE(status)) {
 		ACPI_ERROR((AE_INFO, "Could not acquire table length at %p",
 			    ACPI_CAST_PTR(void, address)));
@@ -590,7 +597,8 @@ acpi_tb_install_non_fixed_table(acpi_physical_address address,
 	 * Optionally do not load any SSDTs from the RSDT/XSDT. This can
 	 * be useful for debugging ACPI problems on some machines.
 	 */
-	if (!reload && acpi_gbl_disable_ssdt_table_install &&
+	if (!reload &&
+	    acpi_gbl_disable_ssdt_table_install &&
 	    ACPI_COMPARE_NAME(&new_table_desc.signature, ACPI_SIG_SSDT)) {
 		ACPI_INFO((AE_INFO, "Ignoring installation of %4.4s at %p",
 			   new_table_desc.signature.ascii, ACPI_CAST_PTR(void,
@@ -675,7 +683,7 @@ acpi_tb_install_non_fixed_table(acpi_physical_address address,
 				 * As we are going to return AE_OK to the caller, we should
 				 * take the responsibility of freeing the input descriptor.
 				 * Refill the input descriptor to ensure
-				 * acpi_tb_install_and_override_table() can be called again to
+				 * acpi_tb_install_table_with_override() can be called again to
 				 * indicate the re-installation.
 				 */
 				acpi_tb_uninstall_table(&new_table_desc);
@@ -688,18 +696,19 @@ acpi_tb_install_non_fixed_table(acpi_physical_address address,
 
 	/* Add the table to the global root table list */
 
-	status = acpi_tb_acquire_root_table_entry(&i);
+	status = acpi_tb_get_root_table_entry(&i);
 	if (ACPI_FAILURE(status)) {
 		goto release_and_exit;
 	}
+
 	*table_index = i;
-	acpi_tb_install_and_override_table(i, &new_table_desc, override);
+	acpi_tb_install_table_with_override(i, &new_table_desc, override);
 
 release_and_exit:
 
-	/* Release the temporal table descriptor */
+	/* Release the temporary table descriptor */
 
-	acpi_tb_release_temporal_table(&new_table_desc);
+	acpi_tb_release_temp_table(&new_table_desc);
 	return_ACPI_STATUS(status);
 }
 
@@ -733,9 +742,9 @@ void acpi_tb_override_table(struct acpi_table_desc *old_table_desc)
 
 	status = acpi_os_table_override(old_table_desc->pointer, &table);
 	if (ACPI_SUCCESS(status) && table) {
-		acpi_tb_acquire_temporal_table(&new_table_desc,
-					       ACPI_PTR_TO_PHYSADDR(table),
-					       ACPI_TABLE_ORIGIN_EXTERN_VIRTUAL);
+		acpi_tb_acquire_temp_table(&new_table_desc,
+					   ACPI_PTR_TO_PHYSADDR(table),
+					   ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL);
 		override_type = "Logical";
 		goto finish_override;
 	}
@@ -745,8 +754,8 @@ void acpi_tb_override_table(struct acpi_table_desc *old_table_desc)
 	status = acpi_os_physical_table_override(old_table_desc->pointer,
 						 &address, &length);
 	if (ACPI_SUCCESS(status) && address && length) {
-		acpi_tb_acquire_temporal_table(&new_table_desc, address,
-					       ACPI_TABLE_ORIGIN_INTERN_PHYSICAL);
+		acpi_tb_acquire_temp_table(&new_table_desc, address,
+					   ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL);
 		override_type = "Physical";
 		goto finish_override;
 	}
@@ -776,13 +785,14 @@ void acpi_tb_override_table(struct acpi_table_desc *old_table_desc)
 	 * Replace the original table descriptor and keep its state as
 	 * "VALIDATED".
 	 */
-	acpi_tb_install_table(old_table_desc, new_table_desc.address,
-			      new_table_desc.flags, new_table_desc.pointer);
+	acpi_tb_init_table_descriptor(old_table_desc, new_table_desc.address,
+				      new_table_desc.flags,
+				      new_table_desc.pointer);
 	acpi_tb_validate_table(old_table_desc);
 
-	/* Release the temporal table descriptor */
+	/* Release the temporary table descriptor */
 
-	acpi_tb_release_temporal_table(&new_table_desc);
+	acpi_tb_release_temp_table(&new_table_desc);
 }
 
 /*******************************************************************************
@@ -851,7 +861,7 @@ acpi_status acpi_tb_resize_root_table_list(void)
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_tb_acquire_root_table_entry
+ * FUNCTION:    acpi_tb_get_root_table_entry
  *
  * PARAMETERS:  table_index         - Where table index is returned
  *
@@ -861,7 +871,7 @@ acpi_status acpi_tb_resize_root_table_list(void)
  *
  ******************************************************************************/
 
-static acpi_status acpi_tb_acquire_root_table_entry(u32 *table_index)
+static acpi_status acpi_tb_get_root_table_entry(u32 *table_index)
 {
 	acpi_status status;
 
@@ -887,7 +897,8 @@ static acpi_status acpi_tb_acquire_root_table_entry(u32 *table_index)
  * PARAMETERS:  address             - Table address
  *              table               - Table header
  *              length              - Table length
- *              flags               - flags
+ *              flags               - Install flags
+ *              table_index         - Where the table index is returned
  *
  * RETURN:      Status and table index.
  *
@@ -903,7 +914,7 @@ acpi_tb_store_table(acpi_physical_address address,
 	acpi_status status;
 	struct acpi_table_desc *table_desc;
 
-	status = acpi_tb_acquire_root_table_entry(table_index);
+	status = acpi_tb_get_root_table_entry(table_index);
 	if (ACPI_FAILURE(status)) {
 		return (status);
 	}
@@ -911,9 +922,8 @@ acpi_tb_store_table(acpi_physical_address address,
 	/* Initialize added table */
 
 	table_desc = &acpi_gbl_root_table_list.tables[*table_index];
-	acpi_tb_install_table(table_desc, address, flags, table);
+	acpi_tb_init_table_descriptor(table_desc, address, flags, table);
 	table_desc->pointer = table;
-
 	return (AE_OK);
 }
 
@@ -943,12 +953,11 @@ void acpi_tb_uninstall_table(struct acpi_table_desc *table_desc)
 	acpi_tb_invalidate_table(table_desc);
 
 	if ((table_desc->flags & ACPI_TABLE_ORIGIN_MASK) ==
-	    ACPI_TABLE_ORIGIN_INTERN_VIRTUAL) {
+	    ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL) {
 		ACPI_FREE(ACPI_CAST_PTR(void, table_desc->address));
 	}
 
 	table_desc->address = ACPI_PTR_TO_PHYSADDR(NULL);
-
 	return_VOID;
 }
 
@@ -991,8 +1000,8 @@ void acpi_tb_terminate(void)
 	acpi_gbl_root_table_list.current_table_count = 0;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "ACPI Tables freed\n"));
-	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
 
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
 	return_VOID;
 }
 
@@ -1074,8 +1083,10 @@ acpi_status acpi_tb_allocate_owner_id(u32 table_index)
 
 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
 	if (table_index < acpi_gbl_root_table_list.current_table_count) {
-		status = acpi_ut_allocate_owner_id
-		    (&(acpi_gbl_root_table_list.tables[table_index].owner_id));
+		status =
+		    acpi_ut_allocate_owner_id(&
+					      (acpi_gbl_root_table_list.
+					       tables[table_index].owner_id));
 	}
 
 	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
@@ -1146,7 +1157,7 @@ acpi_status acpi_tb_get_owner_id(u32 table_index, acpi_owner_id * owner_id)
  *
  * FUNCTION:    acpi_tb_is_table_loaded
  *
- * PARAMETERS:  table_index         - Table index
+ * PARAMETERS:  table_index         - Index into the root table
  *
  * RETURN:      Table Loaded Flag
  *

commit caf4a15c5f930aae41951b4916289e3e59dda8eb
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Apr 4 12:39:18 2014 +0800

    ACPICA: Tables: Add acpi_install_table() API for early table installation.
    
    This patch adds a new API - acpi_install_table(). OSPMs can use this API
    to install tables during early boot stage.  Lv Zheng.
    
    References: https://lkml.org/lkml/2014/2/28/372
    Cc: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    [rjw: Subject]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index de10d3245d9c..9835213269e6 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -394,6 +394,7 @@ static void acpi_tb_release_temporal_table(struct acpi_table_desc *table_desc)
  *
  * PARAMETERS:  table_index             - Index into root table array
  *              new_table_desc          - New table descriptor to install
+ *              override                - Whether override should be performed
  *
  * RETURN:      None
  *
@@ -406,7 +407,8 @@ static void acpi_tb_release_temporal_table(struct acpi_table_desc *table_desc)
 
 void
 acpi_tb_install_and_override_table(u32 table_index,
-				   struct acpi_table_desc *new_table_desc)
+				   struct acpi_table_desc *new_table_desc,
+				   u8 override)
 {
 	if (table_index >= acpi_gbl_root_table_list.current_table_count) {
 		return;
@@ -419,7 +421,9 @@ acpi_tb_install_and_override_table(u32 table_index,
 	 * one if desired. Any table within the RSDT/XSDT can be replaced,
 	 * including the DSDT which is pointed to by the FADT.
 	 */
-	acpi_tb_override_table(new_table_desc);
+	if (override) {
+		acpi_tb_override_table(new_table_desc);
+	}
 
 	acpi_tb_install_table(&acpi_gbl_root_table_list.tables[table_index],
 			      new_table_desc->address, new_table_desc->flags,
@@ -484,7 +488,7 @@ acpi_tb_install_fixed_table(acpi_physical_address address,
 		goto release_and_exit;
 	}
 
-	acpi_tb_install_and_override_table(table_index, &new_table_desc);
+	acpi_tb_install_and_override_table(table_index, &new_table_desc, TRUE);
 
 release_and_exit:
 
@@ -547,6 +551,7 @@ acpi_tb_is_equivalent_table(struct acpi_table_desc *table_desc, u32 table_index)
  *                                    address depending on the table_flags)
  *              flags               - Flags for the table
  *              reload              - Whether reload should be performed
+ *              override            - Whether override should be performed
  *              table_index         - Where the table index is returned
  *
  * RETURN:      Status
@@ -562,7 +567,8 @@ acpi_tb_is_equivalent_table(struct acpi_table_desc *table_desc, u32 table_index)
 
 acpi_status
 acpi_tb_install_non_fixed_table(acpi_physical_address address,
-				u8 flags, u8 reload, u32 *table_index)
+				u8 flags,
+				u8 reload, u8 override, u32 *table_index)
 {
 	u32 i;
 	acpi_status status = AE_OK;
@@ -687,7 +693,7 @@ acpi_tb_install_non_fixed_table(acpi_physical_address address,
 		goto release_and_exit;
 	}
 	*table_index = i;
-	acpi_tb_install_and_override_table(i, &new_table_desc);
+	acpi_tb_install_and_override_table(i, &new_table_desc, override);
 
 release_and_exit:
 

commit a94e88cdd8057fe8ea84bbb6d9a89a823c7bc49b
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Apr 4 12:39:11 2014 +0800

    ACPICA: Tables: Avoid SSDT installation with acpi_gbl_disable_ssdt_table_load.
    
    It is reported that when acpi_gbl_disable_ssdt_table_load is specified, user
    still can see it installed into /sys/firmware/acpi/tables on Linux boxes.
    This is because the option only stops table "loading", but doesn't stop
    table "installing", thus it is still in the acpi_gbl_root_table_list. With
    previous cleanups, it is possible to prevent SSDT installations to make
    it not such confusing.  The global variable is also renamed.  Lv Zheng.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    [rjw: Subject]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index cf1ccc576629..de10d3245d9c 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -580,6 +580,18 @@ acpi_tb_install_non_fixed_table(acpi_physical_address address,
 		return_ACPI_STATUS(status);
 	}
 
+	/*
+	 * Optionally do not load any SSDTs from the RSDT/XSDT. This can
+	 * be useful for debugging ACPI problems on some machines.
+	 */
+	if (!reload && acpi_gbl_disable_ssdt_table_install &&
+	    ACPI_COMPARE_NAME(&new_table_desc.signature, ACPI_SIG_SSDT)) {
+		ACPI_INFO((AE_INFO, "Ignoring installation of %4.4s at %p",
+			   new_table_desc.signature.ascii, ACPI_CAST_PTR(void,
+									 address)));
+		goto release_and_exit;
+	}
+
 	/* Validate and verify a table before installation */
 
 	status = acpi_tb_verify_table(&new_table_desc, NULL);

commit 8a216d7f6aa94c3e252bbfdb2c422e2d0380084e
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Apr 4 12:39:04 2014 +0800

    ACPICA: Tables: Cleanup ACPI_TABLE_ORIGIN_xxx flags.
    
    This patch refines ACPI_TABLE_ORIGIN_xxx flags.  No functional changes.
    
    The previous commits have introduced the following internal APIs:
    1. acpi_tb_acquire_table: Acquire struct acpi_table_header according to
                           ACPI_TABLE_ORIGIN_xxx flags.
    2. acpi_tb_release_table: Release struct acpi_table_header according to
                           ACPI_TABLE_ORIGIN_xxx flags.
    3. acpi_tb_install_table: Make struct acpi_table_desc.Address not NULL according to
                           ACPI_TABLE_ORIGIN_xxx flags.
    4. acpi_tb_uninstall_table: Make struct acpi_table_desc.Address NULL according to
                             ACPI_TABLE_ORIGIN_xxx flags.
    5. acpi_tb_validate_table: Make struct acpi_table_desc.Pointer not NULL according to
                            ACPI_TABLE_ORIGIN_xxx flags.
    6. acpi_tb_invalidate_table: Make struct acpi_table_desc.Pointer NULL according to
                              ACPI_TABLE_ORIGIN_xxx flags.
    It thus detects that the ACPI_TABLE_ORIGIN_UNKNOWN is redundant to
    ACPI_TABLE_ORIGIN_OVERRIDE.
    
    The ACPI_TABLE_ORIGIN_xxTERN_VIRTUAL flags are named as VIRTUAL in order
    not to confuse with x86 logical address, this patch also renames all
    "logical override" into "virtual override".
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 099e678edcb2..cf1ccc576629 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -86,15 +86,14 @@ acpi_tb_acquire_table(struct acpi_table_desc *table_desc,
 	struct acpi_table_header *table = NULL;
 
 	switch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {
-	case ACPI_TABLE_ORIGIN_MAPPED:
+	case ACPI_TABLE_ORIGIN_INTERN_PHYSICAL:
 
 		table =
 		    acpi_os_map_memory(table_desc->address, table_desc->length);
 		break;
 
-	case ACPI_TABLE_ORIGIN_ALLOCATED:
-	case ACPI_TABLE_ORIGIN_UNKNOWN:
-	case ACPI_TABLE_ORIGIN_OVERRIDE:
+	case ACPI_TABLE_ORIGIN_INTERN_VIRTUAL:
+	case ACPI_TABLE_ORIGIN_EXTERN_VIRTUAL:
 
 		table =
 		    ACPI_CAST_PTR(struct acpi_table_header,
@@ -140,14 +139,13 @@ acpi_tb_release_table(struct acpi_table_header *table,
 		      u32 table_length, u8 table_flags)
 {
 	switch (table_flags & ACPI_TABLE_ORIGIN_MASK) {
-	case ACPI_TABLE_ORIGIN_MAPPED:
+	case ACPI_TABLE_ORIGIN_INTERN_PHYSICAL:
 
 		acpi_os_unmap_memory(table, table_length);
 		break;
 
-	case ACPI_TABLE_ORIGIN_ALLOCATED:
-	case ACPI_TABLE_ORIGIN_UNKNOWN:
-	case ACPI_TABLE_ORIGIN_OVERRIDE:
+	case ACPI_TABLE_ORIGIN_INTERN_VIRTUAL:
+	case ACPI_TABLE_ORIGIN_EXTERN_VIRTUAL:
 	default:
 
 		break;
@@ -333,7 +331,7 @@ acpi_tb_acquire_temporal_table(struct acpi_table_desc *table_desc,
 	struct acpi_table_header *table_header;
 
 	switch (flags & ACPI_TABLE_ORIGIN_MASK) {
-	case ACPI_TABLE_ORIGIN_MAPPED:
+	case ACPI_TABLE_ORIGIN_INTERN_PHYSICAL:
 
 		/* Try to obtain the length of the table */
 
@@ -348,9 +346,8 @@ acpi_tb_acquire_temporal_table(struct acpi_table_desc *table_desc,
 				     sizeof(struct acpi_table_header));
 		return (AE_OK);
 
-	case ACPI_TABLE_ORIGIN_ALLOCATED:
-	case ACPI_TABLE_ORIGIN_UNKNOWN:
-	case ACPI_TABLE_ORIGIN_OVERRIDE:
+	case ACPI_TABLE_ORIGIN_INTERN_VIRTUAL:
+	case ACPI_TABLE_ORIGIN_EXTERN_VIRTUAL:
 
 		table_header = ACPI_CAST_PTR(struct acpi_table_header, address);
 		if (!table_header) {
@@ -473,7 +470,7 @@ acpi_tb_install_fixed_table(acpi_physical_address address,
 	/* Fill a table descriptor for validation */
 
 	status = acpi_tb_acquire_temporal_table(&new_table_desc, address,
-						ACPI_TABLE_ORIGIN_MAPPED);
+						ACPI_TABLE_ORIGIN_INTERN_PHYSICAL);
 	if (ACPI_FAILURE(status)) {
 		ACPI_ERROR((AE_INFO, "Could not acquire table length at %p",
 			    ACPI_CAST_PTR(void, address)));
@@ -546,7 +543,7 @@ acpi_tb_is_equivalent_table(struct acpi_table_desc *table_desc, u32 table_index)
  *
  * FUNCTION:    acpi_tb_install_non_fixed_table
  *
- * PARAMETERS:  address             - Address of the table (might be a logical
+ * PARAMETERS:  address             - Address of the table (might be a virtual
  *                                    address depending on the table_flags)
  *              flags               - Flags for the table
  *              reload              - Whether reload should be performed
@@ -720,7 +717,7 @@ void acpi_tb_override_table(struct acpi_table_desc *old_table_desc)
 	if (ACPI_SUCCESS(status) && table) {
 		acpi_tb_acquire_temporal_table(&new_table_desc,
 					       ACPI_PTR_TO_PHYSADDR(table),
-					       ACPI_TABLE_ORIGIN_OVERRIDE);
+					       ACPI_TABLE_ORIGIN_EXTERN_VIRTUAL);
 		override_type = "Logical";
 		goto finish_override;
 	}
@@ -731,7 +728,7 @@ void acpi_tb_override_table(struct acpi_table_desc *old_table_desc)
 						 &address, &length);
 	if (ACPI_SUCCESS(status) && address && length) {
 		acpi_tb_acquire_temporal_table(&new_table_desc, address,
-					       ACPI_TABLE_ORIGIN_MAPPED);
+					       ACPI_TABLE_ORIGIN_INTERN_PHYSICAL);
 		override_type = "Physical";
 		goto finish_override;
 	}
@@ -928,7 +925,7 @@ void acpi_tb_uninstall_table(struct acpi_table_desc *table_desc)
 	acpi_tb_invalidate_table(table_desc);
 
 	if ((table_desc->flags & ACPI_TABLE_ORIGIN_MASK) ==
-	    ACPI_TABLE_ORIGIN_ALLOCATED) {
+	    ACPI_TABLE_ORIGIN_INTERN_VIRTUAL) {
 		ACPI_FREE(ACPI_CAST_PTR(void, table_desc->address));
 	}
 

commit 86dfc6f339886559d80ee0d4bd20fe5ee90450f0
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Apr 4 12:38:57 2014 +0800

    ACPICA: Tables: Fix table checksums verification before installation.
    
    The original table handling code does not always verify checksums before
    installing a table, this is because code to achieve this must be
    implemented here and there in the redundant code blocks.
    
    There are two stages during table initialization:
    1. "INSTALLED" after acpi_tb_install_table() and acpi_tb_override_table(),
       struct acpi_table_desc.Pointer is ensured to be NULL.  This can be safely used
       during OSPM's early boot stage.
    2. "VALIDATED" after acpi_tb_validate_table(), struct acpi_table_desc.Pointer is
       ensured to be not NULL.  This must not be used during OSPM's early boot
       stage.
    
    This patch changes acpi_tb_add_table() into an early boot safe API to reduce
    code redundancies by changing the table state that is returned by this
    function from "VALIDATED" to "INSTALLED".  Then the table verification
    code can be done in a single place.  Originally, the acpi_tb_add_table() can
    only be used by dynamic table loadings that are executed after early boot
    stage, it cannot be used by static table loadings that are executed in
    early boot stage as:
    1.  The address of the table is a virtual address either maintained by
        OSPMs who call acpi_load_table() or by ACPICA whenever "Load" or
        "LoadTable" opcodes are executed, while during early boot stage,
        physical address of the table should be used for table loading.
    2.  The API will ensure the state of the loaded table to be "VALIDATED"
        while during early boot stage, tables maintained by root table list
        should be kept as "INSTALLED".
    
    To achieve this:
    1. Rename acpi_tb_install_table() to acpi_tb_install_fixed_table() as it only
       applies to DSDT/FACS installation.  Rename acpi_tb_add_table() to
       acpi_tb_install_non_fixed_table() as it will be applied to the installation
       of the rest kinds of tables.
    2. Introduce acpi_tb_install_table(), acpi_tb_install_and_override_table to collect
       redudant code where their invocations actually have slight differences.
       1. acpi_tb_install_table() is used to fill an struct acpi_table_desc where the
          table length is known to the caller.
       2. acpi_tb_install_and_override_table() is used to perform necessary
          overriding before installation.
    3. Change a parameter of acpi_tb_install_non_fixed_table() from struct acpi_table_desc
       to acpi_physical_address to allow it to be invoked by static table
       loadings.  Also cleanup acpi_ex_load_op() and acpi_load_table() to accomodate
       to the parameter change.
    4. Invoke acpi_tb_install_non_fixed_table() for all table loadings other than
       DSDT/FACS in acpi_tb_parse_root_table() to improve code maintainability
       (logics are collected in the single function).  Also delete useless code
       from acpi_tb_parse_root_table().
    5. Remove all acpi_tb_validate_table() from acpi_tb_install_non_fixed_table() and
       acpi_tb_install_fixed_table() so that the table descriptor is kept in the
       state of "INSTALLED" but not "VALIDATED" after returning from these
       functions.
    6. Introduce temporary struct acpi_table_desc (new_table_desc/old_table_desc) into
       the functions to indicate a table descriptor that is not maintained by
       acpi_gbl_root_table_list. Introduce acpi_tb_acquire_temporal_table() and
       acpi_tb_release_temporal_table() to handle the use cases of such temporal
       tables.  They are only used for verified installation.
    7. Introduce acpi_tb_verify_table() to validate table and verify table
       checksum, also remove table checksum verification from
       acpi_tb_validate_table(). Invoke acpi_tb_validate_table() in the functions
       that will convert a table into "LOADED" state or invoke it from
       acpi_get_table_XXX() APIs. Invoke acpi_tb_verify_table() on temporary
       struct acpi_table_desc(s) that are going to be "INSTALLED".
    8. Change acpi_tb_override_table() logic so that a temporary struct acpi_table_desc
       will be overridden before installtion, this makes code simpler.
    
    After applying the patch, tables are always installed after being
    overridden and the table checksums are always verified before installation.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    [rjw: Subject]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index d3e1db225cb2..099e678edcb2 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -49,6 +49,19 @@
 #define _COMPONENT          ACPI_TABLES
 ACPI_MODULE_NAME("tbinstal")
 
+/* Local prototypes */
+static acpi_status
+acpi_tb_acquire_temporal_table(struct acpi_table_desc *table_desc,
+			       acpi_physical_address address, u8 flags);
+
+static void acpi_tb_release_temporal_table(struct acpi_table_desc *table_desc);
+
+static acpi_status acpi_tb_acquire_root_table_entry(u32 *table_index);
+
+static u8
+acpi_tb_is_equivalent_table(struct acpi_table_desc *table_desc,
+			    u32 table_index);
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_tb_acquire_table
@@ -64,6 +77,7 @@ ACPI_MODULE_NAME("tbinstal")
  *              acpi_gbl_root_table_list.
  *
  ******************************************************************************/
+
 acpi_status
 acpi_tb_acquire_table(struct acpi_table_desc *table_desc,
 		      struct acpi_table_header **table_ptr,
@@ -148,8 +162,8 @@ acpi_tb_release_table(struct acpi_table_header *table,
  *
  * RETURN:      Status
  *
- * DESCRIPTION: This function is called to validate (ensure Pointer is valid)
- *              and verify the table.
+ * DESCRIPTION: This function is called to validate the table, the returned
+ *              table descriptor is in "VALIDATED" state.
  *
  *****************************************************************************/
 
@@ -165,16 +179,11 @@ acpi_status acpi_tb_validate_table(struct acpi_table_desc *table_desc)
 		status = acpi_tb_acquire_table(table_desc, &table_desc->pointer,
 					       &table_desc->length,
 					       &table_desc->flags);
-		if (ACPI_FAILURE(status) || !table_desc->pointer) {
-			return_ACPI_STATUS(AE_NO_MEMORY);
+		if (!table_desc->pointer) {
+			status = AE_NO_MEMORY;
 		}
 	}
 
-	/* Always calculate checksum, ignore bad checksum if requested */
-
-	status =
-	    acpi_tb_verify_checksum(table_desc->pointer, table_desc->length);
-
 	return_ACPI_STATUS(status);
 }
 
@@ -209,157 +218,473 @@ void acpi_tb_invalidate_table(struct acpi_table_desc *table_desc)
 	return_VOID;
 }
 
-/*******************************************************************************
+/******************************************************************************
  *
- * FUNCTION:    acpi_tb_add_table
+ * FUNCTION:    acpi_tb_verify_table
  *
  * PARAMETERS:  table_desc          - Table descriptor
- *              table_index         - Where the table index is returned
+ *              signature           - Table signature to verify
  *
  * RETURN:      Status
  *
- * DESCRIPTION: This function is called to add an ACPI table. It is used to
- *              dynamically load tables via the Load and load_table AML
- *              operators.
+ * DESCRIPTION: This function is called to validate and verify the table, the
+ *              returned table descriptor is in "VALIDATED" state.
  *
- ******************************************************************************/
+ *****************************************************************************/
 
 acpi_status
-acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
+acpi_tb_verify_table(struct acpi_table_desc *table_desc, char *signature)
 {
-	u32 i;
 	acpi_status status = AE_OK;
-	struct acpi_table_header *final_table;
 
-	ACPI_FUNCTION_TRACE(tb_add_table);
+	ACPI_FUNCTION_TRACE(tb_verify_table);
 
-	if (!table_desc->pointer) {
-		status = acpi_tb_validate_table(table_desc);
-		if (ACPI_FAILURE(status) || !table_desc->pointer) {
-			acpi_tb_invalidate_table(table_desc);
-			return_ACPI_STATUS(status);
-		}
+	/* Validate the table */
+
+	status = acpi_tb_validate_table(table_desc);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
 	}
 
-	/*
-	 * Validate the incoming table signature.
-	 *
-	 * 1) Originally, we checked the table signature for "SSDT" or "PSDT".
-	 * 2) We added support for OEMx tables, signature "OEM".
-	 * 3) Valid tables were encountered with a null signature, so we just
-	 *    gave up on validating the signature, (05/2008).
-	 * 4) We encountered non-AML tables such as the MADT, which caused
-	 *    interpreter errors and kernel faults. So now, we once again allow
-	 *    only "SSDT", "OEMx", and now, also a null signature. (05/2011).
-	 */
-	if ((table_desc->pointer->signature[0] != 0x00) &&
-	    (!ACPI_COMPARE_NAME(table_desc->pointer->signature, ACPI_SIG_SSDT))
-	    && (ACPI_STRNCMP(table_desc->pointer->signature, "OEM", 3))) {
+	/* If a particular signature is expected (DSDT/FACS), it must match */
+
+	if (signature && !ACPI_COMPARE_NAME(&table_desc->signature, signature)) {
 		ACPI_BIOS_ERROR((AE_INFO,
-				 "Table has invalid signature [%4.4s] (0x%8.8X), "
-				 "must be SSDT or OEMx",
-				 acpi_ut_valid_acpi_name(table_desc->pointer->
-							 signature) ?
-				 table_desc->pointer->signature : "????",
-				 *(u32 *)table_desc->pointer->signature));
+				 "Invalid signature 0x%X for ACPI table, expected [%s]",
+				 table_desc->signature.integer, signature));
+		status = AE_BAD_SIGNATURE;
+		goto invalidate_and_exit;
+	}
+
+	/* Verify the checksum */
 
-		return_ACPI_STATUS(AE_BAD_SIGNATURE);
+	status =
+	    acpi_tb_verify_checksum(table_desc->pointer, table_desc->length);
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY,
+				"%4.4s " ACPI_PRINTF_UINT
+				" Attempted table install failed",
+				acpi_ut_valid_acpi_name(table_desc->signature.
+							ascii) ? table_desc->
+				signature.ascii : "????",
+				ACPI_FORMAT_TO_UINT(table_desc->address)));
+		goto invalidate_and_exit;
 	}
 
-	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+	return_ACPI_STATUS(AE_OK);
 
-	/* Check if table is already registered */
+invalidate_and_exit:
+	acpi_tb_invalidate_table(table_desc);
+	return_ACPI_STATUS(status);
+}
 
-	for (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {
-		if (!acpi_gbl_root_table_list.tables[i].pointer) {
-			status =
-			    acpi_tb_validate_table(&acpi_gbl_root_table_list.
-						   tables[i]);
-			if (ACPI_FAILURE(status)
-			    || !acpi_gbl_root_table_list.tables[i].pointer) {
-				continue;
-			}
-		}
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_install_table
+ *
+ * PARAMETERS:  table_desc              - Table descriptor
+ *              address                 - Physical address of the table
+ *              flags                   - Allocation flags of the table
+ *              table                   - Pointer to the table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Install an ACPI table into the global data structure.
+ *
+ ******************************************************************************/
 
-		/*
-		 * Check for a table match on the entire table length,
-		 * not just the header.
-		 */
-		if (table_desc->length !=
-		    acpi_gbl_root_table_list.tables[i].length) {
-			continue;
+void
+acpi_tb_install_table(struct acpi_table_desc *table_desc,
+		      acpi_physical_address address,
+		      u8 flags, struct acpi_table_header *table)
+{
+	/*
+	 * Initialize the table entry. Set the pointer to NULL, since the
+	 * table is not fully mapped at this time.
+	 */
+	ACPI_MEMSET(table_desc, 0, sizeof(struct acpi_table_desc));
+	table_desc->address = address;
+	table_desc->length = table->length;
+	table_desc->flags = flags;
+	ACPI_MOVE_32_TO_32(table_desc->signature.ascii, table->signature);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_acquire_temporal_table
+ *
+ * PARAMETERS:  table_desc          - Table descriptor to be acquired
+ *              address             - Address of the table
+ *              flags               - Allocation flags of the table
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function validates the table header to obtain the length
+ *              of a table and fills the table descriptor to make its state as
+ *              "INSTALLED".  Such table descriptor is only used for verified
+ *              installation.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_tb_acquire_temporal_table(struct acpi_table_desc *table_desc,
+			       acpi_physical_address address, u8 flags)
+{
+	struct acpi_table_header *table_header;
+
+	switch (flags & ACPI_TABLE_ORIGIN_MASK) {
+	case ACPI_TABLE_ORIGIN_MAPPED:
+
+		/* Try to obtain the length of the table */
+
+		table_header =
+		    acpi_os_map_memory(address,
+				       sizeof(struct acpi_table_header));
+		if (!table_header) {
+			return (AE_NO_MEMORY);
 		}
+		acpi_tb_install_table(table_desc, address, flags, table_header);
+		acpi_os_unmap_memory(table_header,
+				     sizeof(struct acpi_table_header));
+		return (AE_OK);
 
-		if (ACPI_MEMCMP(table_desc->pointer,
-				acpi_gbl_root_table_list.tables[i].pointer,
-				acpi_gbl_root_table_list.tables[i].length)) {
-			continue;
+	case ACPI_TABLE_ORIGIN_ALLOCATED:
+	case ACPI_TABLE_ORIGIN_UNKNOWN:
+	case ACPI_TABLE_ORIGIN_OVERRIDE:
+
+		table_header = ACPI_CAST_PTR(struct acpi_table_header, address);
+		if (!table_header) {
+			return (AE_NO_MEMORY);
 		}
+		acpi_tb_install_table(table_desc, address, flags, table_header);
+		return (AE_OK);
 
-		/*
-		 * Note: the current mechanism does not unregister a table if it is
-		 * dynamically unloaded. The related namespace entries are deleted,
-		 * but the table remains in the root table list.
-		 *
-		 * The assumption here is that the number of different tables that
-		 * will be loaded is actually small, and there is minimal overhead
-		 * in just keeping the table in case it is needed again.
-		 *
-		 * If this assumption changes in the future (perhaps on large
-		 * machines with many table load/unload operations), tables will
-		 * need to be unregistered when they are unloaded, and slots in the
-		 * root table list should be reused when empty.
-		 */
-		*table_index = i;
+	default:
 
-		if (acpi_gbl_root_table_list.tables[i].
-		    flags & ACPI_TABLE_IS_LOADED) {
+		break;
+	}
 
-			/* Table is still loaded, this is an error */
+	/* Table is not valid yet */
 
-			status = AE_ALREADY_EXISTS;
-			goto release;
-		} else {
-			/* Table was unloaded, allow it to be reloaded */
-
-			acpi_tb_uninstall_table(table_desc);
-			table_desc->pointer =
-			    acpi_gbl_root_table_list.tables[i].pointer;
-			table_desc->address =
-			    acpi_gbl_root_table_list.tables[i].address;
-			status = AE_OK;
-			goto print_header;
-		}
+	return (AE_NO_MEMORY);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_release_temporal_table
+ *
+ * PARAMETERS:  table_desc          - Table descriptor to be released
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: The reversal of acpi_tb_acquire_temporal_table().
+ *
+ ******************************************************************************/
+
+static void acpi_tb_release_temporal_table(struct acpi_table_desc *table_desc)
+{
+	/*
+	 * Note that the .Address is maintained by the callers of
+	 * acpi_tb_acquire_temporal_table(), thus do not invoke acpi_tb_uninstall_table()
+	 * where .Address will be freed.
+	 */
+	acpi_tb_invalidate_table(table_desc);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_install_and_override_table
+ *
+ * PARAMETERS:  table_index             - Index into root table array
+ *              new_table_desc          - New table descriptor to install
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Install an ACPI table into the global data structure. The
+ *              table override mechanism is called to allow the host
+ *              OS to replace any table before it is installed in the root
+ *              table array.
+ *
+ ******************************************************************************/
+
+void
+acpi_tb_install_and_override_table(u32 table_index,
+				   struct acpi_table_desc *new_table_desc)
+{
+	if (table_index >= acpi_gbl_root_table_list.current_table_count) {
+		return;
 	}
 
 	/*
 	 * ACPI Table Override:
-	 * Allow the host to override dynamically loaded tables.
-	 * NOTE: the table is fully mapped at this point, and the mapping will
-	 * be deleted by acpi_tb_override_table if the table is actually overridden.
+	 *
+	 * Before we install the table, let the host OS override it with a new
+	 * one if desired. Any table within the RSDT/XSDT can be replaced,
+	 * including the DSDT which is pointed to by the FADT.
 	 */
-	final_table = acpi_tb_override_table(table_desc->pointer, table_desc);
-	if (final_table) {
+	acpi_tb_override_table(new_table_desc);
+
+	acpi_tb_install_table(&acpi_gbl_root_table_list.tables[table_index],
+			      new_table_desc->address, new_table_desc->flags,
+			      new_table_desc->pointer);
 
-		/* Ensure table descriptor is in "VALIDATED" state */
+	acpi_tb_print_table_header(new_table_desc->address,
+				   new_table_desc->pointer);
 
-		table_desc->pointer = final_table;
+	/* Set the global integer width (based upon revision of the DSDT) */
+
+	if (table_index == ACPI_TABLE_INDEX_DSDT) {
+		acpi_ut_set_integer_width(new_table_desc->pointer->revision);
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_install_fixed_table
+ *
+ * PARAMETERS:  address                 - Physical address of DSDT or FACS
+ *              signature               - Table signature, NULL if no need to
+ *                                        match
+ *              table_index             - Index into root table array
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install a fixed ACPI table (DSDT/FACS) into the global data
+ *              structure.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_install_fixed_table(acpi_physical_address address,
+			    char *signature, u32 table_index)
+{
+	struct acpi_table_desc new_table_desc;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(tb_install_fixed_table);
+
+	if (!address) {
+		ACPI_ERROR((AE_INFO,
+			    "Null physical address for ACPI table [%s]",
+			    signature));
+		return (AE_NO_MEMORY);
+	}
+
+	/* Fill a table descriptor for validation */
+
+	status = acpi_tb_acquire_temporal_table(&new_table_desc, address,
+						ACPI_TABLE_ORIGIN_MAPPED);
+	if (ACPI_FAILURE(status)) {
+		ACPI_ERROR((AE_INFO, "Could not acquire table length at %p",
+			    ACPI_CAST_PTR(void, address)));
+		return_ACPI_STATUS(status);
+	}
+
+	/* Validate and verify a table before installation */
+
+	status = acpi_tb_verify_table(&new_table_desc, signature);
+	if (ACPI_FAILURE(status)) {
+		goto release_and_exit;
+	}
+
+	acpi_tb_install_and_override_table(table_index, &new_table_desc);
+
+release_and_exit:
+
+	/* Release the temporal table descriptor */
+
+	acpi_tb_release_temporal_table(&new_table_desc);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_is_equivalent_table
+ *
+ * PARAMETERS:  table_desc          - Table 1 descriptor to be compared
+ *              table_index         - Index of table 2 to be compared
+ *
+ * RETURN:      TRUE if 2 tables are equivalent
+ *
+ * DESCRIPTION: This function is called to compare a table with what have
+ *              already been installed in the root table list.
+ *
+ ******************************************************************************/
+
+static u8
+acpi_tb_is_equivalent_table(struct acpi_table_desc *table_desc, u32 table_index)
+{
+	acpi_status status = AE_OK;
+	u8 is_equivalent;
+	struct acpi_table_header *table;
+	u32 table_length;
+	u8 table_flags;
+
+	status =
+	    acpi_tb_acquire_table(&acpi_gbl_root_table_list.tables[table_index],
+				  &table, &table_length, &table_flags);
+	if (ACPI_FAILURE(status)) {
+		return (FALSE);
+	}
+
+	/*
+	 * Check for a table match on the entire table length,
+	 * not just the header.
+	 */
+	is_equivalent = (u8)((table_desc->length != table_length ||
+			      ACPI_MEMCMP(table_desc->pointer, table,
+					  table_length)) ? FALSE : TRUE);
+
+	/* Release the acquired table */
+
+	acpi_tb_release_table(table, table_length, table_flags);
+
+	return (is_equivalent);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_install_non_fixed_table
+ *
+ * PARAMETERS:  address             - Address of the table (might be a logical
+ *                                    address depending on the table_flags)
+ *              flags               - Flags for the table
+ *              reload              - Whether reload should be performed
+ *              table_index         - Where the table index is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to install an ACPI table that is
+ *              neither DSDT nor FACS.
+ *              When this function is called by "Load" or "LoadTable" opcodes,
+ *              or by acpi_load_table() API, the "Reload" parameter is set.
+ *              After sucessfully returning from this function, table is
+ *              "INSTALLED" but not "VALIDATED".
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_install_non_fixed_table(acpi_physical_address address,
+				u8 flags, u8 reload, u32 *table_index)
+{
+	u32 i;
+	acpi_status status = AE_OK;
+	struct acpi_table_desc new_table_desc;
+
+	ACPI_FUNCTION_TRACE(tb_install_non_fixed_table);
+
+	/* Acquire a temporal table descriptor for validation */
+
+	status =
+	    acpi_tb_acquire_temporal_table(&new_table_desc, address, flags);
+	if (ACPI_FAILURE(status)) {
+		ACPI_ERROR((AE_INFO, "Could not acquire table length at %p",
+			    ACPI_CAST_PTR(void, address)));
+		return_ACPI_STATUS(status);
+	}
+
+	/* Validate and verify a table before installation */
+
+	status = acpi_tb_verify_table(&new_table_desc, NULL);
+	if (ACPI_FAILURE(status)) {
+		goto release_and_exit;
+	}
+
+	if (reload) {
+		/*
+		 * Validate the incoming table signature.
+		 *
+		 * 1) Originally, we checked the table signature for "SSDT" or "PSDT".
+		 * 2) We added support for OEMx tables, signature "OEM".
+		 * 3) Valid tables were encountered with a null signature, so we just
+		 *    gave up on validating the signature, (05/2008).
+		 * 4) We encountered non-AML tables such as the MADT, which caused
+		 *    interpreter errors and kernel faults. So now, we once again allow
+		 *    only "SSDT", "OEMx", and now, also a null signature. (05/2011).
+		 */
+		if ((new_table_desc.signature.ascii[0] != 0x00) &&
+		    (!ACPI_COMPARE_NAME
+		     (&new_table_desc.signature, ACPI_SIG_SSDT))
+		    && (ACPI_STRNCMP(new_table_desc.signature.ascii, "OEM", 3)))
+		{
+			ACPI_BIOS_ERROR((AE_INFO,
+					 "Table has invalid signature [%4.4s] (0x%8.8X), "
+					 "must be SSDT or OEMx",
+					 acpi_ut_valid_acpi_name(new_table_desc.
+								 signature.
+								 ascii) ?
+					 new_table_desc.signature.
+					 ascii : "????",
+					 new_table_desc.signature.integer));
+
+			status = AE_BAD_SIGNATURE;
+			goto release_and_exit;
+		}
+
+		/* Check if table is already registered */
+
+		for (i = 0; i < acpi_gbl_root_table_list.current_table_count;
+		     ++i) {
+			/*
+			 * Check for a table match on the entire table length,
+			 * not just the header.
+			 */
+			if (!acpi_tb_is_equivalent_table(&new_table_desc, i)) {
+				continue;
+			}
+
+			/*
+			 * Note: the current mechanism does not unregister a table if it is
+			 * dynamically unloaded. The related namespace entries are deleted,
+			 * but the table remains in the root table list.
+			 *
+			 * The assumption here is that the number of different tables that
+			 * will be loaded is actually small, and there is minimal overhead
+			 * in just keeping the table in case it is needed again.
+			 *
+			 * If this assumption changes in the future (perhaps on large
+			 * machines with many table load/unload operations), tables will
+			 * need to be unregistered when they are unloaded, and slots in the
+			 * root table list should be reused when empty.
+			 */
+			if (acpi_gbl_root_table_list.tables[i].
+			    flags & ACPI_TABLE_IS_LOADED) {
+
+				/* Table is still loaded, this is an error */
+
+				status = AE_ALREADY_EXISTS;
+				goto release_and_exit;
+			} else {
+				/*
+				 * Table was unloaded, allow it to be reloaded.
+				 * As we are going to return AE_OK to the caller, we should
+				 * take the responsibility of freeing the input descriptor.
+				 * Refill the input descriptor to ensure
+				 * acpi_tb_install_and_override_table() can be called again to
+				 * indicate the re-installation.
+				 */
+				acpi_tb_uninstall_table(&new_table_desc);
+				*table_index = i;
+				(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+				return_ACPI_STATUS(AE_OK);
+			}
+		}
 	}
 
 	/* Add the table to the global root table list */
 
-	status = acpi_tb_store_table(table_desc->address, table_desc->pointer,
-				     table_desc->length, table_desc->flags,
-				     table_index);
+	status = acpi_tb_acquire_root_table_entry(&i);
 	if (ACPI_FAILURE(status)) {
-		goto release;
+		goto release_and_exit;
 	}
+	*table_index = i;
+	acpi_tb_install_and_override_table(i, &new_table_desc);
 
-print_header:
-	acpi_tb_print_table_header(table_desc->address, table_desc->pointer);
+release_and_exit:
 
-release:
-	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+	/* Release the temporal table descriptor */
+
+	acpi_tb_release_temporal_table(&new_table_desc);
 	return_ACPI_STATUS(status);
 }
 
@@ -367,97 +692,82 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
  *
  * FUNCTION:    acpi_tb_override_table
  *
- * PARAMETERS:  table_header        - Header for the original table
- *              table_desc          - Table descriptor initialized for the
- *                                    original table. May or may not be mapped.
+ * PARAMETERS:  old_table_desc      - Validated table descriptor to be
+ *                                    overridden
  *
- * RETURN:      Pointer to the entire new table. NULL if table not overridden.
- *              If overridden, installs the new table within the input table
- *              descriptor.
+ * RETURN:      None
  *
  * DESCRIPTION: Attempt table override by calling the OSL override functions.
  *              Note: If the table is overridden, then the entire new table
  *              is acquired and returned by this function.
- *              After invocation, the table descriptor is in a state that is
- *              "INSTALLED" but not "VALIDATED", thus the "Pointer" member is
- *              kept NULL.
+ *              Before/after invocation, the table descriptor is in a state
+ *              that is "VALIDATED".
  *
  ******************************************************************************/
 
-struct acpi_table_header *acpi_tb_override_table(struct acpi_table_header
-						 *table_header,
-						 struct acpi_table_desc
-						 *table_desc)
+void acpi_tb_override_table(struct acpi_table_desc *old_table_desc)
 {
 	acpi_status status;
-	struct acpi_table_header *new_table;
-	u32 new_table_length;
-	u8 new_flags;
 	char *override_type;
 	struct acpi_table_desc new_table_desc;
-
-	ACPI_MEMSET(&new_table_desc, 0, sizeof(struct acpi_table_desc));
+	struct acpi_table_header *table;
+	acpi_physical_address address;
+	u32 length;
 
 	/* (1) Attempt logical override (returns a logical address) */
 
-	status = acpi_os_table_override(table_header, &new_table_desc.pointer);
-	if (ACPI_SUCCESS(status) && new_table_desc.pointer) {
-		new_table_desc.address =
-		    ACPI_PTR_TO_PHYSADDR(new_table_desc.pointer);
-		new_table_desc.length = new_table_desc.pointer->length;
-		new_table_desc.flags = ACPI_TABLE_ORIGIN_OVERRIDE;
+	status = acpi_os_table_override(old_table_desc->pointer, &table);
+	if (ACPI_SUCCESS(status) && table) {
+		acpi_tb_acquire_temporal_table(&new_table_desc,
+					       ACPI_PTR_TO_PHYSADDR(table),
+					       ACPI_TABLE_ORIGIN_OVERRIDE);
 		override_type = "Logical";
 		goto finish_override;
 	}
 
 	/* (2) Attempt physical override (returns a physical address) */
 
-	status = acpi_os_physical_table_override(table_header,
-						 &new_table_desc.address,
-						 &new_table_desc.length);
-	if (ACPI_SUCCESS(status) && new_table_desc.address
-	    && new_table_desc.length) {
+	status = acpi_os_physical_table_override(old_table_desc->pointer,
+						 &address, &length);
+	if (ACPI_SUCCESS(status) && address && length) {
+		acpi_tb_acquire_temporal_table(&new_table_desc, address,
+					       ACPI_TABLE_ORIGIN_MAPPED);
 		override_type = "Physical";
-		new_table_desc.flags = ACPI_TABLE_ORIGIN_MAPPED;
 		goto finish_override;
 	}
 
-	return (NULL);		/* There was no override */
+	return;			/* There was no override */
 
 finish_override:
 
-	/*
-	 * Acquire the entire new table to indicate overridden.
-	 * Note that this is required by the callers of this function.
-	 */
-	status = acpi_tb_acquire_table(&new_table_desc, &new_table,
-				       &new_table_length, &new_flags);
+	/* Validate and verify a table before overriding */
+
+	status = acpi_tb_verify_table(&new_table_desc, NULL);
 	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY,
-				"%4.4s " ACPI_PRINTF_UINT
-				" Attempted table override failed",
-				table_header->signature,
-				ACPI_FORMAT_TO_UINT(table_desc->address)));
-		return (NULL);
+		return;
 	}
 
 	ACPI_INFO((AE_INFO, "%4.4s " ACPI_PRINTF_UINT
 		   " %s table override, new table: " ACPI_PRINTF_UINT,
-		   table_header->signature,
-		   ACPI_FORMAT_TO_UINT(table_desc->address),
+		   old_table_desc->signature.ascii,
+		   ACPI_FORMAT_TO_UINT(old_table_desc->address),
 		   override_type, ACPI_FORMAT_TO_UINT(new_table_desc.address)));
 
-	/* We can now uninstall the original table (if fully mapped) */
+	/* We can now uninstall the original table */
 
-	acpi_tb_uninstall_table(table_desc);
+	acpi_tb_uninstall_table(old_table_desc);
 
-	/* Install the new table */
+	/*
+	 * Replace the original table descriptor and keep its state as
+	 * "VALIDATED".
+	 */
+	acpi_tb_install_table(old_table_desc, new_table_desc.address,
+			      new_table_desc.flags, new_table_desc.pointer);
+	acpi_tb_validate_table(old_table_desc);
 
-	table_desc->address = new_table_desc.address;
-	table_desc->length = new_table_desc.length;
-	table_desc->flags = new_table_desc.flags;
+	/* Release the temporal table descriptor */
 
-	return (new_table);
+	acpi_tb_release_temporal_table(&new_table_desc);
 }
 
 /*******************************************************************************
@@ -526,26 +836,19 @@ acpi_status acpi_tb_resize_root_table_list(void)
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_tb_store_table
+ * FUNCTION:    acpi_tb_acquire_root_table_entry
  *
- * PARAMETERS:  address             - Table address
- *              table               - Table header
- *              length              - Table length
- *              flags               - flags
+ * PARAMETERS:  table_index         - Where table index is returned
  *
  * RETURN:      Status and table index.
  *
- * DESCRIPTION: Add an ACPI table to the global table list
+ * DESCRIPTION: Allocate a new ACPI table entry to the global table list
  *
  ******************************************************************************/
 
-acpi_status
-acpi_tb_store_table(acpi_physical_address address,
-		    struct acpi_table_header *table,
-		    u32 length, u8 flags, u32 *table_index)
+static acpi_status acpi_tb_acquire_root_table_entry(u32 *table_index)
 {
 	acpi_status status;
-	struct acpi_table_desc *new_table;
 
 	/* Ensure that there is room for the table in the Root Table List */
 
@@ -557,22 +860,45 @@ acpi_tb_store_table(acpi_physical_address address,
 		}
 	}
 
-	new_table =
-	    &acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.
-					     current_table_count];
+	*table_index = acpi_gbl_root_table_list.current_table_count;
+	acpi_gbl_root_table_list.current_table_count++;
+	return (AE_OK);
+}
 
-	/* Initialize added table */
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_store_table
+ *
+ * PARAMETERS:  address             - Table address
+ *              table               - Table header
+ *              length              - Table length
+ *              flags               - flags
+ *
+ * RETURN:      Status and table index.
+ *
+ * DESCRIPTION: Add an ACPI table to the global table list
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_store_table(acpi_physical_address address,
+		    struct acpi_table_header * table,
+		    u32 length, u8 flags, u32 *table_index)
+{
+	acpi_status status;
+	struct acpi_table_desc *table_desc;
+
+	status = acpi_tb_acquire_root_table_entry(table_index);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
 
-	new_table->address = address;
-	new_table->pointer = table;
-	new_table->length = length;
-	new_table->owner_id = 0;
-	new_table->flags = flags;
+	/* Initialize added table */
 
-	ACPI_MOVE_32_TO_32(&new_table->signature, table->signature);
+	table_desc = &acpi_gbl_root_table_list.tables[*table_index];
+	acpi_tb_install_table(table_desc, address, flags, table);
+	table_desc->pointer = table;
 
-	*table_index = acpi_gbl_root_table_list.current_table_count;
-	acpi_gbl_root_table_list.current_table_count++;
 	return (AE_OK);
 }
 

commit eb0c65bd2c276b4b346db545d938d4113e1a4e9c
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Apr 4 12:38:50 2014 +0800

    ACPICA: Tables: Fix unbalanced table validations.
    
    As acpi_tb_validate_table() returns failure on checksum verification without
    doing invalidatation, all its invocations that are not done to a descriptor
    stored in acpi_gbl_root_table_list are checked and balanced.
    
    But this is not a real issue as the descritors that have been passed to
    acpi_tb_add_table() are all virtual address tables and the validations are in
    fact no-op.  The cleanup can ensure that any future extensions made on
    acpi_tb_add_table() to allow it to be invoked with physical address tables
    will not trigger memory leakage regressions.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    [rjw: Subject]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 93a99ef03425..d3e1db225cb2 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -236,6 +236,7 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 	if (!table_desc->pointer) {
 		status = acpi_tb_validate_table(table_desc);
 		if (ACPI_FAILURE(status) || !table_desc->pointer) {
+			acpi_tb_invalidate_table(table_desc);
 			return_ACPI_STATUS(status);
 		}
 	}

commit 7f9fc99cde939187c1ee6dac115bdb76655cc798
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Apr 4 12:38:42 2014 +0800

    ACPICA: Tables: Clean up split INSTALLED/VALIDATED table state logics.
    
    This patch is mainly a naming cleanup to clarify hidden logics, no
    functional changes.
    
    acpi_initialize_tables() is used by Linux to install table addresses for
    early boot steps.  During this stage, table addresses are mapped by
    early_ioremap() mechanism which is different from the runtime IO mappings.
    Thus it is not safe for ACPICA to keep mapped pointers in struct acpi_table_desc
    structure during this stage.
    
    In order to support this in ACPICA, table states are divided into
    1. "INSTALLED" (where struct acpi_table_desc.Pointer is always NULL) and
    2. "VALIDATED" (where struct acpi_table_desc.Pointer is always not NULL).
    During acpi_initialize_tables(), table state are ensured to be "INSTALLED"
    but not "VALIDATED".  This logic is ensured by the original code in very
    ambigious way.  For example, currently acpi_tb_delete_table() is invoked in
    some place to perform an uninstallation while it is invoked in other place
    to perform an invalidation.  They happen to work just because no one enters
    the penalty where the 2 behaviours are not equivalent.
    
    The naming cleanups are made in this patch:
    A. For installation and validation:
       There is code setting struct acpi_table_desc.Pointer first and delete it
       immediately to keep the descriptor's state as "INSTALLED" during the
       installation.  This patch implements this in more direct way.  After
       applying it, struct acpi_table_desc.Pointer will never be set in
       acpi_tb_install_table() and acpi_tb_override_table() as they are the only
       functions invoked during acpi_initialize_tables(). This is achieved by:
    1. Rename acpi_tb_verify_table() to acpi_tb_validate_table() to clarify this
       change.
    2. Rename acpi_tb_table_override() to acpi_tb_override_table() to keep nameing
       consistencies as other APIs (verb. Table).
    3. Stops setting struct acpi_table_desc.Pointer in acpi_tb_install_table() and
       acpi_tb_table_override().
    4. Introduce acpi_tb_acquire_table() to acquire the table pointer that is not
       maintained in the struct acpi_table_desc of the global root table list and
       rewrite acpi_tb_validate_table() using this new function to reduce
       redundancies.
    5. Replace the table pointer using the overridden table pointer in
       acpi_tb_add_table(). As acpi_tb_add_table() is not invoked during early boot
       stage, tables returned from this functions should be "VALIDATED".  As
       acpi_tb_override_table() is modified by this patch to return a "INSTALLED"
       but not "VALIDATED" descriptor, to keep acpi_tb_add_table() unchanged,
       struct acpi_table_desc.Pointer is filled in acpi_tb_add_table().
    B. For invalidation and uninstallation:
       The original code invalidate table by invoking acpi_tb_delete_table() here
       and there, but actually this function should only be used to uninstall
       tables.  This can work just because its invocations are equivalent to
       invalidation in some cases.
       This patch splits acpi_tb_delete_table() into acpi_tb_invalidate_table() and
       acpi_tb_uninstall_table() and cleans up the hidden logic using the new
       APIs.  This is achieved by:
    1. Rename acpi_tb_delete_table() to acpi_tb_uninstall_table() as it is mainly
       called before resetting struct acpi_table_desc.Address.  Thus the table
       descriptor is in "not INSTALLED" state.  This patch enforces this by
       setting struct acpi_table_desc.Address to NULL in this function.
    2. Introduce acpi_tb_invalidate_table() to be the reversal of
       acpi_tb_validate_table() and invoke it in acpi_tb_uninstall_table().
    3. Introduce acpi_tb_release_table() to release the table pointer that is not
       maintained in acpi_gbl_root_table_list and rewrite acpi_tb_invalidate_table()
       using this new function to reduce redundancies.
    
    After cleaning up, the maintainability of the internal APIs are also
    improved:
    1. acpi_tb_acquire_table: Acquire struct acpi_table_header according to
                           ACPI_TABLE_ORIGIN_xxx flags.
    2. acpi_tb_release_table: Release struct acpi_table_header according to
                           ACPI_TABLE_ORIGIN_xxx flags.
    3. acpi_tb_install_table: Make struct acpi_table_desc.Address not NULL according to
                           ACPI_TABLE_ORIGIN_xxx flags.
    4. acpi_tb_uninstall_table: Make struct acpi_table_desc.Address NULL according to
                             ACPI_TABLE_ORIGIN_xxx flags.
    5. acpi_tb_validate_table: Make struct acpi_table_desc.Pointer not NULL according to
                            ACPI_TABLE_ORIGIN_xxx flags.
    6. acpi_tb_invalidate_table: Make struct acpi_table_desc.Pointer NULL according to
                              ACPI_TABLE_ORIGIN_xxx flags.
    7. acpi_tb_override_table: Replace struct acpi_table_desc.Address and
                            struct acpi_table_desc.Flags.  It only happens in
                            "INSTALLED" state.
    
    The patch has been unit tested in acpi_exec by:
    1. Initializing;
    2. Executing exc_tbl ASLTS tests;
    3. Executing "Load" command.
    So that all original acpi_tb_install_table() and acpi_tb_override_table()
    invocations are covered.
    
    Known Issues:
    1. Cleanup acpi_tb_add_table() to Kill Code Redundancies
       Current implementation in acpi_tb_add_table() is not very clean, further
       patch can rewrite acpi_tb_add_table() with ordered acpi_tb_install_table(),
       acpi_tb_override_table() and acpi_tb_validate_table(). It is not done in this
       patch so that it is easy for the reviewers to understand the changes in
       this patch.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 0040e19b6d14..93a99ef03425 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -49,49 +49,123 @@
 #define _COMPONENT          ACPI_TABLES
 ACPI_MODULE_NAME("tbinstal")
 
-/******************************************************************************
+/*******************************************************************************
  *
- * FUNCTION:    acpi_tb_verify_table
+ * FUNCTION:    acpi_tb_acquire_table
  *
- * PARAMETERS:  table_desc          - table
+ * PARAMETERS:  table_desc          - Table descriptor
+ *              table_ptr           - Where table is returned
+ *              table_length        - Where table length is returned
+ *              table_flags         - Where table allocation flags are returned
  *
  * RETURN:      Status
  *
- * DESCRIPTION: this function is called to verify and map table
+ * DESCRIPTION: Acquire a table. It can be used for tables not maintained in
+ *              acpi_gbl_root_table_list.
  *
- *****************************************************************************/
-acpi_status acpi_tb_verify_table(struct acpi_table_desc *table_desc)
+ ******************************************************************************/
+acpi_status
+acpi_tb_acquire_table(struct acpi_table_desc *table_desc,
+		      struct acpi_table_header **table_ptr,
+		      u32 *table_length, u8 *table_flags)
 {
-	acpi_status status = AE_OK;
+	struct acpi_table_header *table = NULL;
 
-	ACPI_FUNCTION_TRACE(tb_verify_table);
+	switch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {
+	case ACPI_TABLE_ORIGIN_MAPPED:
 
-	/* Map the table if necessary */
+		table =
+		    acpi_os_map_memory(table_desc->address, table_desc->length);
+		break;
 
-	if (!table_desc->pointer) {
-		switch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {
-		case ACPI_TABLE_ORIGIN_MAPPED:
+	case ACPI_TABLE_ORIGIN_ALLOCATED:
+	case ACPI_TABLE_ORIGIN_UNKNOWN:
+	case ACPI_TABLE_ORIGIN_OVERRIDE:
 
-			table_desc->pointer =
-			    acpi_os_map_memory(table_desc->address,
-					       table_desc->length);
-			break;
+		table =
+		    ACPI_CAST_PTR(struct acpi_table_header,
+				  table_desc->address);
+		break;
 
-		case ACPI_TABLE_ORIGIN_ALLOCATED:
-		case ACPI_TABLE_ORIGIN_UNKNOWN:
-		case ACPI_TABLE_ORIGIN_OVERRIDE:
+	default:
 
-			table_desc->pointer =
-			    ACPI_CAST_PTR(struct acpi_table_header,
-					  table_desc->address);
-			break;
+		break;
+	}
 
-		default:
+	/* Table is not valid yet */
 
-			break;
-		}
+	if (!table) {
+		return (AE_NO_MEMORY);
+	}
+
+	/* Fill the return values */
+
+	*table_ptr = table;
+	*table_length = table_desc->length;
+	*table_flags = table_desc->flags;
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_release_table
+ *
+ * PARAMETERS:  table               - Pointer for the table
+ *              table_length        - Length for the table
+ *              table_flags         - Allocation flags for the table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Release a table. The reversal of acpi_tb_acquire_table().
+ *
+ ******************************************************************************/
+
+void
+acpi_tb_release_table(struct acpi_table_header *table,
+		      u32 table_length, u8 table_flags)
+{
+	switch (table_flags & ACPI_TABLE_ORIGIN_MASK) {
+	case ACPI_TABLE_ORIGIN_MAPPED:
+
+		acpi_os_unmap_memory(table, table_length);
+		break;
+
+	case ACPI_TABLE_ORIGIN_ALLOCATED:
+	case ACPI_TABLE_ORIGIN_UNKNOWN:
+	case ACPI_TABLE_ORIGIN_OVERRIDE:
+	default:
+
+		break;
+	}
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_validate_table
+ *
+ * PARAMETERS:  table_desc          - Table descriptor
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to validate (ensure Pointer is valid)
+ *              and verify the table.
+ *
+ *****************************************************************************/
+
+acpi_status acpi_tb_validate_table(struct acpi_table_desc *table_desc)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(tb_validate_table);
+
+	/* Validate the table if necessary */
 
-		if (!table_desc->pointer) {
+	if (!table_desc->pointer) {
+		status = acpi_tb_acquire_table(table_desc, &table_desc->pointer,
+					       &table_desc->length,
+					       &table_desc->flags);
+		if (ACPI_FAILURE(status) || !table_desc->pointer) {
 			return_ACPI_STATUS(AE_NO_MEMORY);
 		}
 	}
@@ -104,6 +178,37 @@ acpi_status acpi_tb_verify_table(struct acpi_table_desc *table_desc)
 	return_ACPI_STATUS(status);
 }
 
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_invalidate_table
+ *
+ * PARAMETERS:  table_desc          - Table descriptor
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Invalidate one internal ACPI table, this is reversal of
+ *              acpi_tb_validate_table().
+ *
+ ******************************************************************************/
+
+void acpi_tb_invalidate_table(struct acpi_table_desc *table_desc)
+{
+
+	ACPI_FUNCTION_TRACE(tb_invalidate_table);
+
+	/* Table must be validated */
+
+	if (!table_desc->pointer) {
+		return_VOID;
+	}
+
+	acpi_tb_release_table(table_desc->pointer, table_desc->length,
+			      table_desc->flags);
+	table_desc->pointer = NULL;
+
+	return_VOID;
+}
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_tb_add_table
@@ -124,11 +229,12 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 {
 	u32 i;
 	acpi_status status = AE_OK;
+	struct acpi_table_header *final_table;
 
 	ACPI_FUNCTION_TRACE(tb_add_table);
 
 	if (!table_desc->pointer) {
-		status = acpi_tb_verify_table(table_desc);
+		status = acpi_tb_validate_table(table_desc);
 		if (ACPI_FAILURE(status) || !table_desc->pointer) {
 			return_ACPI_STATUS(status);
 		}
@@ -166,8 +272,8 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 	for (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {
 		if (!acpi_gbl_root_table_list.tables[i].pointer) {
 			status =
-			    acpi_tb_verify_table(&acpi_gbl_root_table_list.
-						 tables[i]);
+			    acpi_tb_validate_table(&acpi_gbl_root_table_list.
+						   tables[i]);
 			if (ACPI_FAILURE(status)
 			    || !acpi_gbl_root_table_list.tables[i].pointer) {
 				continue;
@@ -215,7 +321,7 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 		} else {
 			/* Table was unloaded, allow it to be reloaded */
 
-			acpi_tb_delete_table(table_desc);
+			acpi_tb_uninstall_table(table_desc);
 			table_desc->pointer =
 			    acpi_gbl_root_table_list.tables[i].pointer;
 			table_desc->address =
@@ -229,9 +335,15 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 	 * ACPI Table Override:
 	 * Allow the host to override dynamically loaded tables.
 	 * NOTE: the table is fully mapped at this point, and the mapping will
-	 * be deleted by tb_table_override if the table is actually overridden.
+	 * be deleted by acpi_tb_override_table if the table is actually overridden.
 	 */
-	(void)acpi_tb_table_override(table_desc->pointer, table_desc);
+	final_table = acpi_tb_override_table(table_desc->pointer, table_desc);
+	if (final_table) {
+
+		/* Ensure table descriptor is in "VALIDATED" state */
+
+		table_desc->pointer = final_table;
+	}
 
 	/* Add the table to the global root table list */
 
@@ -252,7 +364,7 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_tb_table_override
+ * FUNCTION:    acpi_tb_override_table
  *
  * PARAMETERS:  table_header        - Header for the original table
  *              table_desc          - Table descriptor initialized for the
@@ -264,29 +376,35 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
  *
  * DESCRIPTION: Attempt table override by calling the OSL override functions.
  *              Note: If the table is overridden, then the entire new table
- *              is mapped and returned by this function.
+ *              is acquired and returned by this function.
+ *              After invocation, the table descriptor is in a state that is
+ *              "INSTALLED" but not "VALIDATED", thus the "Pointer" member is
+ *              kept NULL.
  *
  ******************************************************************************/
 
-struct acpi_table_header *acpi_tb_table_override(struct acpi_table_header
+struct acpi_table_header *acpi_tb_override_table(struct acpi_table_header
 						 *table_header,
 						 struct acpi_table_desc
 						 *table_desc)
 {
 	acpi_status status;
-	struct acpi_table_header *new_table = NULL;
-	acpi_physical_address new_address = 0;
-	u32 new_table_length = 0;
+	struct acpi_table_header *new_table;
+	u32 new_table_length;
 	u8 new_flags;
 	char *override_type;
+	struct acpi_table_desc new_table_desc;
+
+	ACPI_MEMSET(&new_table_desc, 0, sizeof(struct acpi_table_desc));
 
 	/* (1) Attempt logical override (returns a logical address) */
 
-	status = acpi_os_table_override(table_header, &new_table);
-	if (ACPI_SUCCESS(status) && new_table) {
-		new_address = ACPI_PTR_TO_PHYSADDR(new_table);
-		new_table_length = new_table->length;
-		new_flags = ACPI_TABLE_ORIGIN_OVERRIDE;
+	status = acpi_os_table_override(table_header, &new_table_desc.pointer);
+	if (ACPI_SUCCESS(status) && new_table_desc.pointer) {
+		new_table_desc.address =
+		    ACPI_PTR_TO_PHYSADDR(new_table_desc.pointer);
+		new_table_desc.length = new_table_desc.pointer->length;
+		new_table_desc.flags = ACPI_TABLE_ORIGIN_OVERRIDE;
 		override_type = "Logical";
 		goto finish_override;
 	}
@@ -294,25 +412,12 @@ struct acpi_table_header *acpi_tb_table_override(struct acpi_table_header
 	/* (2) Attempt physical override (returns a physical address) */
 
 	status = acpi_os_physical_table_override(table_header,
-						 &new_address,
-						 &new_table_length);
-	if (ACPI_SUCCESS(status) && new_address && new_table_length) {
-
-		/* Map the entire new table */
-
-		new_table = acpi_os_map_memory(new_address, new_table_length);
-		if (!new_table) {
-			ACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY,
-					"%4.4s " ACPI_PRINTF_UINT
-					" Attempted physical table override failed",
-					table_header->signature,
-					ACPI_FORMAT_TO_UINT(table_desc->
-							    address)));
-			return (NULL);
-		}
-
+						 &new_table_desc.address,
+						 &new_table_desc.length);
+	if (ACPI_SUCCESS(status) && new_table_desc.address
+	    && new_table_desc.length) {
 		override_type = "Physical";
-		new_flags = ACPI_TABLE_ORIGIN_MAPPED;
+		new_table_desc.flags = ACPI_TABLE_ORIGIN_MAPPED;
 		goto finish_override;
 	}
 
@@ -320,22 +425,36 @@ struct acpi_table_header *acpi_tb_table_override(struct acpi_table_header
 
 finish_override:
 
+	/*
+	 * Acquire the entire new table to indicate overridden.
+	 * Note that this is required by the callers of this function.
+	 */
+	status = acpi_tb_acquire_table(&new_table_desc, &new_table,
+				       &new_table_length, &new_flags);
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY,
+				"%4.4s " ACPI_PRINTF_UINT
+				" Attempted table override failed",
+				table_header->signature,
+				ACPI_FORMAT_TO_UINT(table_desc->address)));
+		return (NULL);
+	}
+
 	ACPI_INFO((AE_INFO, "%4.4s " ACPI_PRINTF_UINT
 		   " %s table override, new table: " ACPI_PRINTF_UINT,
 		   table_header->signature,
 		   ACPI_FORMAT_TO_UINT(table_desc->address),
-		   override_type, ACPI_FORMAT_TO_UINT(new_table)));
+		   override_type, ACPI_FORMAT_TO_UINT(new_table_desc.address)));
 
-	/* We can now unmap/delete the original table (if fully mapped) */
+	/* We can now uninstall the original table (if fully mapped) */
 
-	acpi_tb_delete_table(table_desc);
+	acpi_tb_uninstall_table(table_desc);
 
-	/* Setup descriptor for the new table */
+	/* Install the new table */
 
-	table_desc->address = new_address;
-	table_desc->pointer = new_table;
-	table_desc->length = new_table_length;
-	table_desc->flags = new_flags;
+	table_desc->address = new_table_desc.address;
+	table_desc->length = new_table_desc.length;
+	table_desc->flags = new_table_desc.flags;
 
 	return (new_table);
 }
@@ -458,9 +577,9 @@ acpi_tb_store_table(acpi_physical_address address,
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_tb_delete_table
+ * FUNCTION:    acpi_tb_uninstall_table
  *
- * PARAMETERS:  table_index         - Table index
+ * PARAMETERS:  table_desc          - Table descriptor
  *
  * RETURN:      None
  *
@@ -468,35 +587,27 @@ acpi_tb_store_table(acpi_physical_address address,
  *
  ******************************************************************************/
 
-void acpi_tb_delete_table(struct acpi_table_desc *table_desc)
+void acpi_tb_uninstall_table(struct acpi_table_desc *table_desc)
 {
 
-	/* Table must be mapped or allocated */
-
-	if (!table_desc->pointer) {
-		return;
-	}
-
-	switch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {
-	case ACPI_TABLE_ORIGIN_MAPPED:
-
-		acpi_os_unmap_memory(table_desc->pointer, table_desc->length);
-		break;
-
-	case ACPI_TABLE_ORIGIN_ALLOCATED:
+	ACPI_FUNCTION_TRACE(tb_uninstall_table);
 
-		ACPI_FREE(table_desc->pointer);
-		table_desc->address = ACPI_PTR_TO_PHYSADDR(NULL);
-		break;
+	/* Table must be installed */
 
-		/* Not mapped or allocated, there is nothing we can do */
+	if (!table_desc->address) {
+		return_VOID;
+	}
 
-	default:
+	acpi_tb_invalidate_table(table_desc);
 
-		return;
+	if ((table_desc->flags & ACPI_TABLE_ORIGIN_MASK) ==
+	    ACPI_TABLE_ORIGIN_ALLOCATED) {
+		ACPI_FREE(ACPI_CAST_PTR(void, table_desc->address));
 	}
 
-	table_desc->pointer = NULL;
+	table_desc->address = ACPI_PTR_TO_PHYSADDR(NULL);
+
+	return_VOID;
 }
 
 /*******************************************************************************
@@ -522,7 +633,7 @@ void acpi_tb_terminate(void)
 	/* Delete the individual tables */
 
 	for (i = 0; i < acpi_gbl_root_table_list.current_table_count; i++) {
-		acpi_tb_delete_table(&acpi_gbl_root_table_list.tables[i]);
+		acpi_tb_uninstall_table(&acpi_gbl_root_table_list.tables[i]);
 	}
 
 	/*

commit 55df23f0d620c5194ecbd3b68ecdb2798778bf93
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Apr 4 12:38:35 2014 +0800

    ACPICA: Tables: Fix multiple ACPI_FREE()s around acpi_tb_add_table().
    
    Currently there are following issues in acpi_tb_add_table():
    Following logic is currently correct:
    1. When a table is allocated in acpi_ex_load_op(), if a reloading happens,
       the allocated memory is freed by acpi_tb_add_table() and AE_OK is
       returned to the caller to avoid the caller to free it again.
    Following logic is currently incorrect:
    1. When a table is allocated in acpi_ex_load_op() or by the
       acpi_load_table() caller, if the table is already loaded, there will be
       twice ACPI_FREE() called for the same pointer when acpi_tb_add_table()
       returns AE_ALREADY_EXISTS.
    
    This patch only fixes the above incorrect logic in acpi_tb_add_table():
    1. Only invoke acpi_tb_delete_table() if AE_OK is going to be returned.
    2. After doing so, we do not invoke ACPI_FREE() when returning AE_OK;
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    [rjw: Subject]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 144076ac21f0..0040e19b6d14 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -203,12 +203,6 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 		 * need to be unregistered when they are unloaded, and slots in the
 		 * root table list should be reused when empty.
 		 */
-
-		/*
-		 * Table is already registered.
-		 * We can delete the table that was passed as a parameter.
-		 */
-		acpi_tb_delete_table(table_desc);
 		*table_index = i;
 
 		if (acpi_gbl_root_table_list.tables[i].
@@ -221,6 +215,7 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 		} else {
 			/* Table was unloaded, allow it to be reloaded */
 
+			acpi_tb_delete_table(table_desc);
 			table_desc->pointer =
 			    acpi_gbl_root_table_list.tables[i].pointer;
 			table_desc->address =

commit dc156adf0d1b9d9ea54a86ca803ac5202ab139c7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Apr 4 12:38:26 2014 +0800

    ACPICA: Tables: Fix the issues in handling virtual addressed tables.
    
    When table is overridden or reloaded, acpi_tb_delete_table() is called where
    struct acpi_table_desc.Pointer will be NULL.  It thus is impossible for virtual
    addressed tables to obtain the .Pointer again in acpi_tb_verify_table().
    
    This patch stores virtual table addresses  (ACPI_TABLE_ORIGIN_ALLOCATED,
    ACPI_TABLE_ORIGIN_UNKNOWN, ACPI_TABLE_ORIGIN_OVERRIDE) in the
    struct acpi_table_desc.Address field and refills the struct acpi_table_desc.Pointer
    using these addresses in acpi_tb_verify_table(). Note that if a table with
    ACPI_TABLE_ORIGIN_ALLOCATED set is actually freed, the .Address field
    should be invalidated and thus must be replaced with NULL to avoid wrong
    future validations occuring in acpi_tb_verify_table().
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 73fffb0f3dd3..144076ac21f0 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -69,11 +69,26 @@ acpi_status acpi_tb_verify_table(struct acpi_table_desc *table_desc)
 	/* Map the table if necessary */
 
 	if (!table_desc->pointer) {
-		if ((table_desc->flags & ACPI_TABLE_ORIGIN_MASK) ==
-		    ACPI_TABLE_ORIGIN_MAPPED) {
+		switch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {
+		case ACPI_TABLE_ORIGIN_MAPPED:
+
 			table_desc->pointer =
 			    acpi_os_map_memory(table_desc->address,
 					       table_desc->length);
+			break;
+
+		case ACPI_TABLE_ORIGIN_ALLOCATED:
+		case ACPI_TABLE_ORIGIN_UNKNOWN:
+		case ACPI_TABLE_ORIGIN_OVERRIDE:
+
+			table_desc->pointer =
+			    ACPI_CAST_PTR(struct acpi_table_header,
+					  table_desc->address);
+			break;
+
+		default:
+
+			break;
 		}
 
 		if (!table_desc->pointer) {
@@ -476,6 +491,7 @@ void acpi_tb_delete_table(struct acpi_table_desc *table_desc)
 	case ACPI_TABLE_ORIGIN_ALLOCATED:
 
 		ACPI_FREE(table_desc->pointer);
+		table_desc->address = ACPI_PTR_TO_PHYSADDR(NULL);
 		break;
 
 		/* Not mapped or allocated, there is nothing we can do */

commit 5582982d1acefe37528a3de8b42e81a7b0a75cfb
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Apr 4 12:38:18 2014 +0800

    ACPICA: Remove indent divergences to reduce maintenance overhead.
    
    The divergences in the ACPICA files makes it difficult to maintain linuxize
    ACPICA table commits.  This patch reduces such divergences before applying
    table manager commits so that human interventions of patch rebasing can be
    reduced.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    [rjw: Subject]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index e3040947e9a0..73fffb0f3dd3 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -75,6 +75,7 @@ acpi_status acpi_tb_verify_table(struct acpi_table_desc *table_desc)
 			    acpi_os_map_memory(table_desc->address,
 					       table_desc->length);
 		}
+
 		if (!table_desc->pointer) {
 			return_ACPI_STATUS(AE_NO_MEMORY);
 		}
@@ -459,10 +460,13 @@ acpi_tb_store_table(acpi_physical_address address,
 
 void acpi_tb_delete_table(struct acpi_table_desc *table_desc)
 {
+
 	/* Table must be mapped or allocated */
+
 	if (!table_desc->pointer) {
 		return;
 	}
+
 	switch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {
 	case ACPI_TABLE_ORIGIN_MAPPED:
 
@@ -657,7 +661,7 @@ acpi_status acpi_tb_release_owner_id(u32 table_index)
  *
  ******************************************************************************/
 
-acpi_status acpi_tb_get_owner_id(u32 table_index, acpi_owner_id *owner_id)
+acpi_status acpi_tb_get_owner_id(u32 table_index, acpi_owner_id * owner_id)
 {
 	acpi_status status = AE_BAD_PARAMETER;
 

commit fbb7a2dc2be493c87399550bdc2ddaa510cdf450
Author: Bob Moore <robert.moore@intel.com>
Date:   Sat Feb 8 09:42:25 2014 +0800

    ACPICA: Update ACPICA copyrights to 2014.
    
    Update ACPICA copyrights to 2014. Includes all source headers and
    signons for the various tools.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index c1a8cf7ae0f9..e3040947e9a0 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2013, Intel Corp.
+ * Copyright (C) 2000 - 2014, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 2e19f8d02ee7acd939d60a89905c6fbc27c7cfab
Author: Bob Moore <robert.moore@intel.com>
Date:   Sat Feb 8 09:42:07 2014 +0800

    ACPICA: Deploy new 32/64 printf support for table override mechanism.
    
    Similar to the earlier tbprint.c change.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 634357d51fe9..c1a8cf7ae0f9 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -292,10 +292,11 @@ struct acpi_table_header *acpi_tb_table_override(struct acpi_table_header
 		new_table = acpi_os_map_memory(new_address, new_table_length);
 		if (!new_table) {
 			ACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY,
-					"%4.4s %p Attempted physical table override failed",
+					"%4.4s " ACPI_PRINTF_UINT
+					" Attempted physical table override failed",
 					table_header->signature,
-					ACPI_CAST_PTR(void,
-						      table_desc->address)));
+					ACPI_FORMAT_TO_UINT(table_desc->
+							    address)));
 			return (NULL);
 		}
 
@@ -308,11 +309,11 @@ struct acpi_table_header *acpi_tb_table_override(struct acpi_table_header
 
 finish_override:
 
-	ACPI_INFO((AE_INFO,
-		   "%4.4s %p %s table override, new table: %p",
+	ACPI_INFO((AE_INFO, "%4.4s " ACPI_PRINTF_UINT
+		   " %s table override, new table: " ACPI_PRINTF_UINT,
 		   table_header->signature,
-		   ACPI_CAST_PTR(void, table_desc->address),
-		   override_type, new_table));
+		   ACPI_FORMAT_TO_UINT(table_desc->address),
+		   override_type, ACPI_FORMAT_TO_UINT(new_table)));
 
 	/* We can now unmap/delete the original table (if fully mapped) */
 

commit 10622bf8ce432e6a53fd3c37163e99e99c9e43ee
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Oct 29 09:30:02 2013 +0800

    ACPICA: Linuxize: Change indentation of C labels.
    
    It is reported by kernel build test systems that all ACPICA source
    files in the kernel tree have incorrect label indentation.  This
    patch changes default indent option used in the release process to
    fix this bug.  Lv Zheng.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 9e6788f9ba0f..634357d51fe9 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -231,10 +231,10 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 		goto release;
 	}
 
-      print_header:
+print_header:
 	acpi_tb_print_table_header(table_desc->address, table_desc->pointer);
 
-      release:
+release:
 	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
 	return_ACPI_STATUS(status);
 }
@@ -306,7 +306,7 @@ struct acpi_table_header *acpi_tb_table_override(struct acpi_table_header
 
 	return (NULL);		/* There was no override */
 
-      finish_override:
+finish_override:
 
 	ACPI_INFO((AE_INFO,
 		   "%4.4s %p %s table override, new table: %p",

commit 94d4be6773e86a0d52d7e200fb3cda2b9013c862
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Mon Sep 23 09:52:29 2013 +0800

    ACPICA: Tables: Cleanup table checksum verification code.
    
    This patch reduces code redundancy by moving the FACS/S3PT checksum
    verification skip logic into acpi_tb_verify_checksum() and other
    calls of this function also get benefit from this change.  Lv Zheng.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Reviewed-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 42a13c0d7015..9e6788f9ba0f 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -80,16 +80,10 @@ acpi_status acpi_tb_verify_table(struct acpi_table_desc *table_desc)
 		}
 	}
 
-	/* FACS is the odd table, has no standard ACPI header and no checksum */
+	/* Always calculate checksum, ignore bad checksum if requested */
 
-	if (!ACPI_COMPARE_NAME(&table_desc->signature, ACPI_SIG_FACS)) {
-
-		/* Always calculate checksum, ignore bad checksum if requested */
-
-		status =
-		    acpi_tb_verify_checksum(table_desc->pointer,
-					    table_desc->length);
-	}
+	status =
+	    acpi_tb_verify_checksum(table_desc->pointer, table_desc->length);
 
 	return_ACPI_STATUS(status);
 }

commit de8e7db74a98124406b72a528f4c79766e08b410
Author: Bob Moore <robert.moore@intel.com>
Date:   Sat Jun 8 00:59:44 2013 +0000

    ACPICA: Update interface to acpi_ut_valid_acpi_name()
    
    Clean up the interface by making the input argument a char *
    string instead of a UINT32 name. This is easier to use for all
    callers and eliminates casting to *(UINT32*)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index a04e54d984d9..42a13c0d7015 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -141,8 +141,7 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 		ACPI_BIOS_ERROR((AE_INFO,
 				 "Table has invalid signature [%4.4s] (0x%8.8X), "
 				 "must be SSDT or OEMx",
-				 acpi_ut_valid_acpi_name(*(u32 *)table_desc->
-							 pointer->
+				 acpi_ut_valid_acpi_name(table_desc->pointer->
 							 signature) ?
 				 table_desc->pointer->signature : "????",
 				 *(u32 *)table_desc->pointer->signature));

commit 1d1ea1b723d9f239f736b8cf284327cbbf9d15d1
Author: Chao Guan <chao.guan@intel.com>
Date:   Sat Jun 8 00:58:14 2013 +0000

    ACPICA: Standardize all switch() blocks
    
    After many years, different formatting for switch() has crept in.
    This change makes every switch block identical. Chao Guan.
    ACPICA bugzilla 997.
    
    References: https://bugs.acpica.org/show_bug.cgi?id=997
    Signed-off-by: Chao Guan <chao.guan@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index e57cd38004e3..a04e54d984d9 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -471,15 +471,19 @@ void acpi_tb_delete_table(struct acpi_table_desc *table_desc)
 	}
 	switch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {
 	case ACPI_TABLE_ORIGIN_MAPPED:
+
 		acpi_os_unmap_memory(table_desc->pointer, table_desc->length);
 		break;
+
 	case ACPI_TABLE_ORIGIN_ALLOCATED:
+
 		ACPI_FREE(table_desc->pointer);
 		break;
 
 		/* Not mapped or allocated, there is nothing we can do */
 
 	default:
+
 		return;
 	}
 

commit 25f044e64568dd83de34c16c837a96bbb2b0cecb
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 25 05:38:56 2013 +0000

    ACPICA: Update ACPICA copyrights to 2013
    
    Includes all source headers and signons for the various tools.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index f540ae462925..e57cd38004e3 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2013, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 68aafc35161dcc9d365a32c2f9f077aedc61754d
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Oct 31 02:26:01 2012 +0000

    ACPICA: Audit/update for ACPICA return macros and debug depth counter
    
    1) Ensure that all functions that use the various TRACE macros
       also use the appropriate ACPICA return macros.
    2) Ensure that all normal return statements surround the return
       expression (value) with parens.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 70f9d787c82c..f540ae462925 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -526,6 +526,8 @@ void acpi_tb_terminate(void)
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "ACPI Tables freed\n"));
 	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+
+	return_VOID;
 }
 
 /*******************************************************************************

commit 2bc198c1527be998850ade8f91ec7d340b67fdf3
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Sep 13 09:29:06 2012 -0700

    ACPICA: Table Manager: Merge duplicate code (root table)
    
    Merge/remove duplicate code in the root table resize functions
    One function is external, the other is internal.  Lv Zheng,
    
    ACPICA BZ 846:
    https://acpica.org/bugzilla/show_bug.cgi?id=846
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 74f97d74db1c..70f9d787c82c 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -350,6 +350,7 @@ struct acpi_table_header *acpi_tb_table_override(struct acpi_table_header
 acpi_status acpi_tb_resize_root_table_list(void)
 {
 	struct acpi_table_desc *tables;
+	u32 table_count;
 
 	ACPI_FUNCTION_TRACE(tb_resize_root_table_list);
 
@@ -363,8 +364,13 @@ acpi_status acpi_tb_resize_root_table_list(void)
 
 	/* Increase the Table Array size */
 
-	tables = ACPI_ALLOCATE_ZEROED(((acpi_size) acpi_gbl_root_table_list.
-				       max_table_count +
+	if (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {
+		table_count = acpi_gbl_root_table_list.max_table_count;
+	} else {
+		table_count = acpi_gbl_root_table_list.current_table_count;
+	}
+
+	tables = ACPI_ALLOCATE_ZEROED(((acpi_size) table_count +
 				       ACPI_ROOT_TABLE_SIZE_INCREMENT) *
 				      sizeof(struct acpi_table_desc));
 	if (!tables) {
@@ -377,8 +383,8 @@ acpi_status acpi_tb_resize_root_table_list(void)
 
 	if (acpi_gbl_root_table_list.tables) {
 		ACPI_MEMCPY(tables, acpi_gbl_root_table_list.tables,
-			    (acpi_size) acpi_gbl_root_table_list.
-			    max_table_count * sizeof(struct acpi_table_desc));
+			    (acpi_size) table_count *
+			    sizeof(struct acpi_table_desc));
 
 		if (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {
 			ACPI_FREE(acpi_gbl_root_table_list.tables);
@@ -386,9 +392,9 @@ acpi_status acpi_tb_resize_root_table_list(void)
 	}
 
 	acpi_gbl_root_table_list.tables = tables;
-	acpi_gbl_root_table_list.max_table_count +=
-	    ACPI_ROOT_TABLE_SIZE_INCREMENT;
-	acpi_gbl_root_table_list.flags |= (u8)ACPI_ROOT_ORIGIN_ALLOCATED;
+	acpi_gbl_root_table_list.max_table_count =
+	    table_count + ACPI_ROOT_TABLE_SIZE_INCREMENT;
+	acpi_gbl_root_table_list.flags |= ACPI_ROOT_ORIGIN_ALLOCATED;
 
 	return_ACPI_STATUS(AE_OK);
 }

commit ba494beeaa69bc0fb01eb89464ad5d57d26e3901
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jul 12 09:40:10 2012 +0800

    ACPICA: AcpiSrc: Fix some translation issues for Linux conversion
    
    Fixes issues like this:
    
    i_aSL -> iASL
    00-7_f -> 00-7F
    local_fADT -> local_FADT
    execute_oSI -> execute_OSI
    
    Also, in function headers, the parameters are now translated to
    lower case (with underscores if necessary.)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index a265d4ab40ac..74f97d74db1c 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -397,10 +397,10 @@ acpi_status acpi_tb_resize_root_table_list(void)
  *
  * FUNCTION:    acpi_tb_store_table
  *
- * PARAMETERS:  Address             - Table address
- *              Table               - Table header
- *              Length              - Table length
- *              Flags               - flags
+ * PARAMETERS:  address             - Table address
+ *              table               - Table header
+ *              length              - Table length
+ *              flags               - flags
  *
  * RETURN:      Status and table index.
  *

commit 3b3ea7759ce484fffce387cf20a2dd39d1be3858
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jul 16 09:39:54 2012 +0800

    ACPICA: Table manager: deploy new firmware error/warning interfaces
    
    Emit firmware error/warning messages where appropriate for table
    and FADT errors.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index c03500b4cc7a..a265d4ab40ac 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -138,13 +138,14 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 	if ((table_desc->pointer->signature[0] != 0x00) &&
 	    (!ACPI_COMPARE_NAME(table_desc->pointer->signature, ACPI_SIG_SSDT))
 	    && (ACPI_STRNCMP(table_desc->pointer->signature, "OEM", 3))) {
-		ACPI_ERROR((AE_INFO,
-			    "Table has invalid signature [%4.4s] (0x%8.8X), must be SSDT or OEMx",
-			    acpi_ut_valid_acpi_name(*(u32 *)table_desc->
-						    pointer->
-						    signature) ? table_desc->
-			    pointer->signature : "????",
-			    *(u32 *)table_desc->pointer->signature));
+		ACPI_BIOS_ERROR((AE_INFO,
+				 "Table has invalid signature [%4.4s] (0x%8.8X), "
+				 "must be SSDT or OEMx",
+				 acpi_ut_valid_acpi_name(*(u32 *)table_desc->
+							 pointer->
+							 signature) ?
+				 table_desc->pointer->signature : "????",
+				 *(u32 *)table_desc->pointer->signature));
 
 		return_ACPI_STATUS(AE_BAD_SIGNATURE);
 	}

commit f7b004a17c9183f023796dea0d70284684ec000d
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Feb 14 18:31:56 2012 +0800

    ACPICA: Add acpi_os_physical_table_override interface
    
    This interface allows the host to override a table via a
    physical address, instead of the logical address required by
    acpi_os_table_override. This simplifies the host implementation.
    Initial implementation by Thomas Renninger. ACPICA implementation
    creates a single function for table overrides that attempts both
    a logical and a physical override.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 1aecf7baa4e0..c03500b4cc7a 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -114,7 +114,6 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 {
 	u32 i;
 	acpi_status status = AE_OK;
-	struct acpi_table_header *override_table = NULL;
 
 	ACPI_FUNCTION_TRACE(tb_add_table);
 
@@ -224,25 +223,10 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 	/*
 	 * ACPI Table Override:
 	 * Allow the host to override dynamically loaded tables.
+	 * NOTE: the table is fully mapped at this point, and the mapping will
+	 * be deleted by tb_table_override if the table is actually overridden.
 	 */
-	status = acpi_os_table_override(table_desc->pointer, &override_table);
-	if (ACPI_SUCCESS(status) && override_table) {
-		ACPI_INFO((AE_INFO,
-			   "%4.4s @ 0x%p Table override, replaced with:",
-			   table_desc->pointer->signature,
-			   ACPI_CAST_PTR(void, table_desc->address)));
-
-		/* We can delete the table that was passed as a parameter */
-
-		acpi_tb_delete_table(table_desc);
-
-		/* Setup descriptor for the new table */
-
-		table_desc->address = ACPI_PTR_TO_PHYSADDR(override_table);
-		table_desc->pointer = override_table;
-		table_desc->length = override_table->length;
-		table_desc->flags = ACPI_TABLE_ORIGIN_OVERRIDE;
-	}
+	(void)acpi_tb_table_override(table_desc->pointer, table_desc);
 
 	/* Add the table to the global root table list */
 
@@ -261,6 +245,95 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 	return_ACPI_STATUS(status);
 }
 
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_table_override
+ *
+ * PARAMETERS:  table_header        - Header for the original table
+ *              table_desc          - Table descriptor initialized for the
+ *                                    original table. May or may not be mapped.
+ *
+ * RETURN:      Pointer to the entire new table. NULL if table not overridden.
+ *              If overridden, installs the new table within the input table
+ *              descriptor.
+ *
+ * DESCRIPTION: Attempt table override by calling the OSL override functions.
+ *              Note: If the table is overridden, then the entire new table
+ *              is mapped and returned by this function.
+ *
+ ******************************************************************************/
+
+struct acpi_table_header *acpi_tb_table_override(struct acpi_table_header
+						 *table_header,
+						 struct acpi_table_desc
+						 *table_desc)
+{
+	acpi_status status;
+	struct acpi_table_header *new_table = NULL;
+	acpi_physical_address new_address = 0;
+	u32 new_table_length = 0;
+	u8 new_flags;
+	char *override_type;
+
+	/* (1) Attempt logical override (returns a logical address) */
+
+	status = acpi_os_table_override(table_header, &new_table);
+	if (ACPI_SUCCESS(status) && new_table) {
+		new_address = ACPI_PTR_TO_PHYSADDR(new_table);
+		new_table_length = new_table->length;
+		new_flags = ACPI_TABLE_ORIGIN_OVERRIDE;
+		override_type = "Logical";
+		goto finish_override;
+	}
+
+	/* (2) Attempt physical override (returns a physical address) */
+
+	status = acpi_os_physical_table_override(table_header,
+						 &new_address,
+						 &new_table_length);
+	if (ACPI_SUCCESS(status) && new_address && new_table_length) {
+
+		/* Map the entire new table */
+
+		new_table = acpi_os_map_memory(new_address, new_table_length);
+		if (!new_table) {
+			ACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY,
+					"%4.4s %p Attempted physical table override failed",
+					table_header->signature,
+					ACPI_CAST_PTR(void,
+						      table_desc->address)));
+			return (NULL);
+		}
+
+		override_type = "Physical";
+		new_flags = ACPI_TABLE_ORIGIN_MAPPED;
+		goto finish_override;
+	}
+
+	return (NULL);		/* There was no override */
+
+      finish_override:
+
+	ACPI_INFO((AE_INFO,
+		   "%4.4s %p %s table override, new table: %p",
+		   table_header->signature,
+		   ACPI_CAST_PTR(void, table_desc->address),
+		   override_type, new_table));
+
+	/* We can now unmap/delete the original table (if fully mapped) */
+
+	acpi_tb_delete_table(table_desc);
+
+	/* Setup descriptor for the new table */
+
+	table_desc->address = new_address;
+	table_desc->pointer = new_table;
+	table_desc->length = new_table_length;
+	table_desc->flags = new_flags;
+
+	return (new_table);
+}
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_tb_resize_root_table_list
@@ -396,7 +469,11 @@ void acpi_tb_delete_table(struct acpi_table_desc *table_desc)
 	case ACPI_TABLE_ORIGIN_ALLOCATED:
 		ACPI_FREE(table_desc->pointer);
 		break;
-	default:;
+
+		/* Not mapped or allocated, there is nothing we can do */
+
+	default:
+		return;
 	}
 
 	table_desc->pointer = NULL;

commit 77848130e53b06c22fe37a7b6acbb82bb3e9bfba
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 12 13:27:23 2012 +0800

    ACPICA: Update all copyrights to 2012
    
    Update all copyrights to 2012.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 62365f6075dd..1aecf7baa4e0 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2011, Intel Corp.
+ * Copyright (C) 2000 - 2012, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit c8cefe307d79c57b32ca1d4c9ebff528f8dd914c
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Jun 14 10:42:53 2011 +0800

    ACPICA: Load operator: re-instate most restrictions on incoming table signature
    
    Now, only allow "SSDT" "OEM", and a null signature.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 48db0944ce4a..62365f6075dd 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -126,12 +126,29 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 	}
 
 	/*
-	 * Originally, we checked the table signature for "SSDT" or "PSDT" here.
-	 * Next, we added support for OEMx tables, signature "OEM".
-	 * Valid tables were encountered with a null signature, so we've just
-	 * given up on validating the signature, since it seems to be a waste
-	 * of code. The original code was removed (05/2008).
+	 * Validate the incoming table signature.
+	 *
+	 * 1) Originally, we checked the table signature for "SSDT" or "PSDT".
+	 * 2) We added support for OEMx tables, signature "OEM".
+	 * 3) Valid tables were encountered with a null signature, so we just
+	 *    gave up on validating the signature, (05/2008).
+	 * 4) We encountered non-AML tables such as the MADT, which caused
+	 *    interpreter errors and kernel faults. So now, we once again allow
+	 *    only "SSDT", "OEMx", and now, also a null signature. (05/2011).
 	 */
+	if ((table_desc->pointer->signature[0] != 0x00) &&
+	    (!ACPI_COMPARE_NAME(table_desc->pointer->signature, ACPI_SIG_SSDT))
+	    && (ACPI_STRNCMP(table_desc->pointer->signature, "OEM", 3))) {
+		ACPI_ERROR((AE_INFO,
+			    "Table has invalid signature [%4.4s] (0x%8.8X), must be SSDT or OEMx",
+			    acpi_ut_valid_acpi_name(*(u32 *)table_desc->
+						    pointer->
+						    signature) ? table_desc->
+			    pointer->signature : "????",
+			    *(u32 *)table_desc->pointer->signature));
+
+		return_ACPI_STATUS(AE_BAD_SIGNATURE);
+	}
 
 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
 

commit b4e104eaeb8cd4329a23e0e4ebf166681b1d182d
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jan 17 11:05:40 2011 +0800

    ACPICA: Update all ACPICA copyrights and signons to 2011
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 83d7af8d0905..48db0944ce4a 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2010, Intel Corp.
+ * Copyright (C) 2000 - 2011, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit b9ee2043096b02e5da8c62f9a8a8f2e172b3606b
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Apr 27 11:16:14 2010 +0800

    ACPICA: Clarify/rename some root table descriptor fields
    
    Original fields were not very descriptive and led to maintenance
    problems.  New fields should help to understand the existing code.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 7ec02b0f69e0..83d7af8d0905 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -137,7 +137,7 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 
 	/* Check if table is already registered */
 
-	for (i = 0; i < acpi_gbl_root_table_list.count; ++i) {
+	for (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {
 		if (!acpi_gbl_root_table_list.tables[i].pointer) {
 			status =
 			    acpi_tb_verify_table(&acpi_gbl_root_table_list.
@@ -273,7 +273,7 @@ acpi_status acpi_tb_resize_root_table_list(void)
 	/* Increase the Table Array size */
 
 	tables = ACPI_ALLOCATE_ZEROED(((acpi_size) acpi_gbl_root_table_list.
-				       size +
+				       max_table_count +
 				       ACPI_ROOT_TABLE_SIZE_INCREMENT) *
 				      sizeof(struct acpi_table_desc));
 	if (!tables) {
@@ -286,8 +286,8 @@ acpi_status acpi_tb_resize_root_table_list(void)
 
 	if (acpi_gbl_root_table_list.tables) {
 		ACPI_MEMCPY(tables, acpi_gbl_root_table_list.tables,
-			    (acpi_size) acpi_gbl_root_table_list.size *
-			    sizeof(struct acpi_table_desc));
+			    (acpi_size) acpi_gbl_root_table_list.
+			    max_table_count * sizeof(struct acpi_table_desc));
 
 		if (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {
 			ACPI_FREE(acpi_gbl_root_table_list.tables);
@@ -295,8 +295,9 @@ acpi_status acpi_tb_resize_root_table_list(void)
 	}
 
 	acpi_gbl_root_table_list.tables = tables;
-	acpi_gbl_root_table_list.size += ACPI_ROOT_TABLE_SIZE_INCREMENT;
-	acpi_gbl_root_table_list.flags |= (u8) ACPI_ROOT_ORIGIN_ALLOCATED;
+	acpi_gbl_root_table_list.max_table_count +=
+	    ACPI_ROOT_TABLE_SIZE_INCREMENT;
+	acpi_gbl_root_table_list.flags |= (u8)ACPI_ROOT_ORIGIN_ALLOCATED;
 
 	return_ACPI_STATUS(AE_OK);
 }
@@ -321,38 +322,36 @@ acpi_tb_store_table(acpi_physical_address address,
 		    struct acpi_table_header *table,
 		    u32 length, u8 flags, u32 *table_index)
 {
-	acpi_status status = AE_OK;
+	acpi_status status;
+	struct acpi_table_desc *new_table;
 
 	/* Ensure that there is room for the table in the Root Table List */
 
-	if (acpi_gbl_root_table_list.count >= acpi_gbl_root_table_list.size) {
+	if (acpi_gbl_root_table_list.current_table_count >=
+	    acpi_gbl_root_table_list.max_table_count) {
 		status = acpi_tb_resize_root_table_list();
 		if (ACPI_FAILURE(status)) {
 			return (status);
 		}
 	}
 
+	new_table =
+	    &acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.
+					     current_table_count];
+
 	/* Initialize added table */
 
-	acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.count].
-	    address = address;
-	acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.count].
-	    pointer = table;
-	acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.count].length =
-	    length;
-	acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.count].
-	    owner_id = 0;
-	acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.count].flags =
-	    flags;
-
-	ACPI_MOVE_32_TO_32(&
-			   (acpi_gbl_root_table_list.
-			    tables[acpi_gbl_root_table_list.count].signature),
-			   table->signature);
-
-	*table_index = acpi_gbl_root_table_list.count;
-	acpi_gbl_root_table_list.count++;
-	return (status);
+	new_table->address = address;
+	new_table->pointer = table;
+	new_table->length = length;
+	new_table->owner_id = 0;
+	new_table->flags = flags;
+
+	ACPI_MOVE_32_TO_32(&new_table->signature, table->signature);
+
+	*table_index = acpi_gbl_root_table_list.current_table_count;
+	acpi_gbl_root_table_list.current_table_count++;
+	return (AE_OK);
 }
 
 /*******************************************************************************
@@ -408,7 +407,7 @@ void acpi_tb_terminate(void)
 
 	/* Delete the individual tables */
 
-	for (i = 0; i < acpi_gbl_root_table_list.count; ++i) {
+	for (i = 0; i < acpi_gbl_root_table_list.current_table_count; i++) {
 		acpi_tb_delete_table(&acpi_gbl_root_table_list.tables[i]);
 	}
 
@@ -422,7 +421,7 @@ void acpi_tb_terminate(void)
 
 	acpi_gbl_root_table_list.tables = NULL;
 	acpi_gbl_root_table_list.flags = 0;
-	acpi_gbl_root_table_list.count = 0;
+	acpi_gbl_root_table_list.current_table_count = 0;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "ACPI Tables freed\n"));
 	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
@@ -452,7 +451,7 @@ acpi_status acpi_tb_delete_namespace_by_owner(u32 table_index)
 		return_ACPI_STATUS(status);
 	}
 
-	if (table_index >= acpi_gbl_root_table_list.count) {
+	if (table_index >= acpi_gbl_root_table_list.current_table_count) {
 
 		/* The table index does not exist */
 
@@ -505,7 +504,7 @@ acpi_status acpi_tb_allocate_owner_id(u32 table_index)
 	ACPI_FUNCTION_TRACE(tb_allocate_owner_id);
 
 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
-	if (table_index < acpi_gbl_root_table_list.count) {
+	if (table_index < acpi_gbl_root_table_list.current_table_count) {
 		status = acpi_ut_allocate_owner_id
 		    (&(acpi_gbl_root_table_list.tables[table_index].owner_id));
 	}
@@ -533,7 +532,7 @@ acpi_status acpi_tb_release_owner_id(u32 table_index)
 	ACPI_FUNCTION_TRACE(tb_release_owner_id);
 
 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
-	if (table_index < acpi_gbl_root_table_list.count) {
+	if (table_index < acpi_gbl_root_table_list.current_table_count) {
 		acpi_ut_release_owner_id(&
 					 (acpi_gbl_root_table_list.
 					  tables[table_index].owner_id));
@@ -564,7 +563,7 @@ acpi_status acpi_tb_get_owner_id(u32 table_index, acpi_owner_id *owner_id)
 	ACPI_FUNCTION_TRACE(tb_get_owner_id);
 
 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
-	if (table_index < acpi_gbl_root_table_list.count) {
+	if (table_index < acpi_gbl_root_table_list.current_table_count) {
 		*owner_id =
 		    acpi_gbl_root_table_list.tables[table_index].owner_id;
 		status = AE_OK;
@@ -589,7 +588,7 @@ u8 acpi_tb_is_table_loaded(u32 table_index)
 	u8 is_loaded = FALSE;
 
 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
-	if (table_index < acpi_gbl_root_table_list.count) {
+	if (table_index < acpi_gbl_root_table_list.current_table_count) {
 		is_loaded = (u8)
 		    (acpi_gbl_root_table_list.tables[table_index].flags &
 		     ACPI_TABLE_IS_LOADED);
@@ -616,7 +615,7 @@ void acpi_tb_set_table_loaded_flag(u32 table_index, u8 is_loaded)
 {
 
 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
-	if (table_index < acpi_gbl_root_table_list.count) {
+	if (table_index < acpi_gbl_root_table_list.current_table_count) {
 		if (is_loaded) {
 			acpi_gbl_root_table_list.tables[table_index].flags |=
 			    ACPI_TABLE_IS_LOADED;

commit a8357b0c95484b46944728712f8810d3b37bf588
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 22 19:07:36 2010 +0800

    ACPICA: Update all ACPICA copyrights and signons to 2010
    
    Add 2010 copyright to all module headers and signons, including
    the Linux header. This affects virtually every file in the ACPICA
    core subsystem, iASL compiler, and all utilities.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 63e82329a9e8..7ec02b0f69e0 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2008, Intel Corp.
+ * Copyright (C) 2000 - 2010, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit e4c1ebfc65c125b1289144f5815715f238367683
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Apr 22 13:02:06 2009 +0800

    ACPICA: Miscellaneous lint changes
    
    Unused variables/headers, casting, etc.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index f865d5a096de..63e82329a9e8 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -472,7 +472,7 @@ acpi_status acpi_tb_delete_namespace_by_owner(u32 table_index)
 	 * lock may block, and also since the execution of a namespace walk
 	 * must be allowed to use the interpreter.
 	 */
-	acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);
+	(void)acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);
 	status = acpi_ut_acquire_write_lock(&acpi_gbl_namespace_rw_lock);
 
 	acpi_ns_delete_namespace_by_owner(owner_id);

commit 8a335a2331c72e60c6b3ef09b2dedd3ba00da1b1
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Mar 9 16:31:04 2009 +0800

    ACPICA: Fix AcpiWalkNamespace race condition with table unload
    
    Added a reader/writer locking mechanism to allow multiple
    concurrent namespace walks (readers), but a dynamic table unload
    will have exclusive access to the namespace. This fixes a problem
    where a table unload could delete the portion of the namespace that
    is currently being examined by a walk.  Adds a new file, utlock.c
    that implements the reader/writer lock mechanism. ACPICA BZ 749.
    
    http://www.acpica.org/bugzilla/show_bug.cgi?id=749
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index c37993003f2c..f865d5a096de 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -434,27 +434,56 @@ void acpi_tb_terminate(void)
  *
  * PARAMETERS:  table_index         - Table index
  *
- * RETURN:      None
+ * RETURN:      Status
  *
  * DESCRIPTION: Delete all namespace objects created when this table was loaded.
  *
  ******************************************************************************/
 
-void acpi_tb_delete_namespace_by_owner(u32 table_index)
+acpi_status acpi_tb_delete_namespace_by_owner(u32 table_index)
 {
 	acpi_owner_id owner_id;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(tb_delete_namespace_by_owner);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	if (table_index >= acpi_gbl_root_table_list.count) {
+
+		/* The table index does not exist */
 
-	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
-	if (table_index < acpi_gbl_root_table_list.count) {
-		owner_id =
-		    acpi_gbl_root_table_list.tables[table_index].owner_id;
-	} else {
 		(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
-		return;
+		return_ACPI_STATUS(AE_NOT_EXIST);
 	}
 
+	/* Get the owner ID for this table, used to delete namespace nodes */
+
+	owner_id = acpi_gbl_root_table_list.tables[table_index].owner_id;
 	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+
+	/*
+	 * Need to acquire the namespace writer lock to prevent interference
+	 * with any concurrent namespace walks. The interpreter must be
+	 * released during the deletion since the acquisition of the deletion
+	 * lock may block, and also since the execution of a namespace walk
+	 * must be allowed to use the interpreter.
+	 */
+	acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);
+	status = acpi_ut_acquire_write_lock(&acpi_gbl_namespace_rw_lock);
+
 	acpi_ns_delete_namespace_by_owner(owner_id);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	acpi_ut_release_write_lock(&acpi_gbl_namespace_rw_lock);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_INTERPRETER);
+	return_ACPI_STATUS(status);
 }
 
 /*******************************************************************************

commit ec41f193eadb6301f3c052b5e0dbc0b5636982e8
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Feb 18 15:03:30 2009 +0800

    ACPICA: Formatting update - no functional changes
    
    Split some long lines.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index ef269a297b57..c37993003f2c 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -273,8 +273,9 @@ acpi_status acpi_tb_resize_root_table_list(void)
 	/* Increase the Table Array size */
 
 	tables = ACPI_ALLOCATE_ZEROED(((acpi_size) acpi_gbl_root_table_list.
-				       size + ACPI_ROOT_TABLE_SIZE_INCREMENT)
-				      * sizeof(struct acpi_table_desc));
+				       size +
+				       ACPI_ROOT_TABLE_SIZE_INCREMENT) *
+				      sizeof(struct acpi_table_desc));
 	if (!tables) {
 		ACPI_ERROR((AE_INFO,
 			    "Could not allocate new root table array"));
@@ -561,8 +562,8 @@ u8 acpi_tb_is_table_loaded(u32 table_index)
 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
 	if (table_index < acpi_gbl_root_table_list.count) {
 		is_loaded = (u8)
-		    (acpi_gbl_root_table_list.tables[table_index].
-		     flags & ACPI_TABLE_IS_LOADED);
+		    (acpi_gbl_root_table_list.tables[table_index].flags &
+		     ACPI_TABLE_IS_LOADED);
 	}
 
 	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);

commit d3ccaff827cef5a5c5a0f3c97e1e2e6d99f618cb
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Feb 3 14:43:04 2009 +0800

    ACPICA: Add override for dynamic tables
    
    Add a call to acpi_os_table_override during the installation of a
    dynamic table (loaded via the Load or LoadTable AML operators).
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 37374b21969d..ef269a297b57 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -103,7 +103,9 @@ acpi_status acpi_tb_verify_table(struct acpi_table_desc *table_desc)
  *
  * RETURN:      Status
  *
- * DESCRIPTION: This function is called to add the ACPI table
+ * DESCRIPTION: This function is called to add an ACPI table. It is used to
+ *              dynamically load tables via the Load and load_table AML
+ *              operators.
  *
  ******************************************************************************/
 
@@ -112,6 +114,7 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 {
 	u32 i;
 	acpi_status status = AE_OK;
+	struct acpi_table_header *override_table = NULL;
 
 	ACPI_FUNCTION_TRACE(tb_add_table);
 
@@ -201,6 +204,29 @@ acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
 		}
 	}
 
+	/*
+	 * ACPI Table Override:
+	 * Allow the host to override dynamically loaded tables.
+	 */
+	status = acpi_os_table_override(table_desc->pointer, &override_table);
+	if (ACPI_SUCCESS(status) && override_table) {
+		ACPI_INFO((AE_INFO,
+			   "%4.4s @ 0x%p Table override, replaced with:",
+			   table_desc->pointer->signature,
+			   ACPI_CAST_PTR(void, table_desc->address)));
+
+		/* We can delete the table that was passed as a parameter */
+
+		acpi_tb_delete_table(table_desc);
+
+		/* Setup descriptor for the new table */
+
+		table_desc->address = ACPI_PTR_TO_PHYSADDR(override_table);
+		table_desc->pointer = override_table;
+		table_desc->length = override_table->length;
+		table_desc->flags = ACPI_TABLE_ORIGIN_OVERRIDE;
+	}
+
 	/* Add the table to the global root table list */
 
 	status = acpi_tb_store_table(table_desc->address, table_desc->pointer,

commit e2f7a7772880458edff1b1cc5a988947229fac26
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 00:30:03 2009 -0500

    ACPICA: hide private headers
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 019b0d84cbea..37374b21969d 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -42,9 +42,9 @@
  */
 
 #include <acpi/acpi.h>
-#include <acpi/accommon.h>
-#include <acpi/acnamesp.h>
-#include <acpi/actables.h>
+#include "accommon.h"
+#include "acnamesp.h"
+#include "actables.h"
 
 #define _COMPONENT          ACPI_TABLES
 ACPI_MODULE_NAME("tbinstal")

commit 95b482a8d31116f3f5c2a5089569393234d06385
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 00:13:17 2009 -0500

    ACPICA: create acpica/ directory
    
    also, delete sleep/ and delete ACPI_CFLAGS from Makefile
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
new file mode 100644
index 000000000000..019b0d84cbea
--- /dev/null
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -0,0 +1,574 @@
+/******************************************************************************
+ *
+ * Module Name: tbinstal - ACPI table installation and removal
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2008, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include <acpi/accommon.h>
+#include <acpi/acnamesp.h>
+#include <acpi/actables.h>
+
+#define _COMPONENT          ACPI_TABLES
+ACPI_MODULE_NAME("tbinstal")
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_verify_table
+ *
+ * PARAMETERS:  table_desc          - table
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: this function is called to verify and map table
+ *
+ *****************************************************************************/
+acpi_status acpi_tb_verify_table(struct acpi_table_desc *table_desc)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(tb_verify_table);
+
+	/* Map the table if necessary */
+
+	if (!table_desc->pointer) {
+		if ((table_desc->flags & ACPI_TABLE_ORIGIN_MASK) ==
+		    ACPI_TABLE_ORIGIN_MAPPED) {
+			table_desc->pointer =
+			    acpi_os_map_memory(table_desc->address,
+					       table_desc->length);
+		}
+		if (!table_desc->pointer) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+	}
+
+	/* FACS is the odd table, has no standard ACPI header and no checksum */
+
+	if (!ACPI_COMPARE_NAME(&table_desc->signature, ACPI_SIG_FACS)) {
+
+		/* Always calculate checksum, ignore bad checksum if requested */
+
+		status =
+		    acpi_tb_verify_checksum(table_desc->pointer,
+					    table_desc->length);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_add_table
+ *
+ * PARAMETERS:  table_desc          - Table descriptor
+ *              table_index         - Where the table index is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to add the ACPI table
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
+{
+	u32 i;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(tb_add_table);
+
+	if (!table_desc->pointer) {
+		status = acpi_tb_verify_table(table_desc);
+		if (ACPI_FAILURE(status) || !table_desc->pointer) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/*
+	 * Originally, we checked the table signature for "SSDT" or "PSDT" here.
+	 * Next, we added support for OEMx tables, signature "OEM".
+	 * Valid tables were encountered with a null signature, so we've just
+	 * given up on validating the signature, since it seems to be a waste
+	 * of code. The original code was removed (05/2008).
+	 */
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+
+	/* Check if table is already registered */
+
+	for (i = 0; i < acpi_gbl_root_table_list.count; ++i) {
+		if (!acpi_gbl_root_table_list.tables[i].pointer) {
+			status =
+			    acpi_tb_verify_table(&acpi_gbl_root_table_list.
+						 tables[i]);
+			if (ACPI_FAILURE(status)
+			    || !acpi_gbl_root_table_list.tables[i].pointer) {
+				continue;
+			}
+		}
+
+		/*
+		 * Check for a table match on the entire table length,
+		 * not just the header.
+		 */
+		if (table_desc->length !=
+		    acpi_gbl_root_table_list.tables[i].length) {
+			continue;
+		}
+
+		if (ACPI_MEMCMP(table_desc->pointer,
+				acpi_gbl_root_table_list.tables[i].pointer,
+				acpi_gbl_root_table_list.tables[i].length)) {
+			continue;
+		}
+
+		/*
+		 * Note: the current mechanism does not unregister a table if it is
+		 * dynamically unloaded. The related namespace entries are deleted,
+		 * but the table remains in the root table list.
+		 *
+		 * The assumption here is that the number of different tables that
+		 * will be loaded is actually small, and there is minimal overhead
+		 * in just keeping the table in case it is needed again.
+		 *
+		 * If this assumption changes in the future (perhaps on large
+		 * machines with many table load/unload operations), tables will
+		 * need to be unregistered when they are unloaded, and slots in the
+		 * root table list should be reused when empty.
+		 */
+
+		/*
+		 * Table is already registered.
+		 * We can delete the table that was passed as a parameter.
+		 */
+		acpi_tb_delete_table(table_desc);
+		*table_index = i;
+
+		if (acpi_gbl_root_table_list.tables[i].
+		    flags & ACPI_TABLE_IS_LOADED) {
+
+			/* Table is still loaded, this is an error */
+
+			status = AE_ALREADY_EXISTS;
+			goto release;
+		} else {
+			/* Table was unloaded, allow it to be reloaded */
+
+			table_desc->pointer =
+			    acpi_gbl_root_table_list.tables[i].pointer;
+			table_desc->address =
+			    acpi_gbl_root_table_list.tables[i].address;
+			status = AE_OK;
+			goto print_header;
+		}
+	}
+
+	/* Add the table to the global root table list */
+
+	status = acpi_tb_store_table(table_desc->address, table_desc->pointer,
+				     table_desc->length, table_desc->flags,
+				     table_index);
+	if (ACPI_FAILURE(status)) {
+		goto release;
+	}
+
+      print_header:
+	acpi_tb_print_table_header(table_desc->address, table_desc->pointer);
+
+      release:
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_resize_root_table_list
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Expand the size of global table array
+ *
+ ******************************************************************************/
+
+acpi_status acpi_tb_resize_root_table_list(void)
+{
+	struct acpi_table_desc *tables;
+
+	ACPI_FUNCTION_TRACE(tb_resize_root_table_list);
+
+	/* allow_resize flag is a parameter to acpi_initialize_tables */
+
+	if (!(acpi_gbl_root_table_list.flags & ACPI_ROOT_ALLOW_RESIZE)) {
+		ACPI_ERROR((AE_INFO,
+			    "Resize of Root Table Array is not allowed"));
+		return_ACPI_STATUS(AE_SUPPORT);
+	}
+
+	/* Increase the Table Array size */
+
+	tables = ACPI_ALLOCATE_ZEROED(((acpi_size) acpi_gbl_root_table_list.
+				       size + ACPI_ROOT_TABLE_SIZE_INCREMENT)
+				      * sizeof(struct acpi_table_desc));
+	if (!tables) {
+		ACPI_ERROR((AE_INFO,
+			    "Could not allocate new root table array"));
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Copy and free the previous table array */
+
+	if (acpi_gbl_root_table_list.tables) {
+		ACPI_MEMCPY(tables, acpi_gbl_root_table_list.tables,
+			    (acpi_size) acpi_gbl_root_table_list.size *
+			    sizeof(struct acpi_table_desc));
+
+		if (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {
+			ACPI_FREE(acpi_gbl_root_table_list.tables);
+		}
+	}
+
+	acpi_gbl_root_table_list.tables = tables;
+	acpi_gbl_root_table_list.size += ACPI_ROOT_TABLE_SIZE_INCREMENT;
+	acpi_gbl_root_table_list.flags |= (u8) ACPI_ROOT_ORIGIN_ALLOCATED;
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_store_table
+ *
+ * PARAMETERS:  Address             - Table address
+ *              Table               - Table header
+ *              Length              - Table length
+ *              Flags               - flags
+ *
+ * RETURN:      Status and table index.
+ *
+ * DESCRIPTION: Add an ACPI table to the global table list
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_store_table(acpi_physical_address address,
+		    struct acpi_table_header *table,
+		    u32 length, u8 flags, u32 *table_index)
+{
+	acpi_status status = AE_OK;
+
+	/* Ensure that there is room for the table in the Root Table List */
+
+	if (acpi_gbl_root_table_list.count >= acpi_gbl_root_table_list.size) {
+		status = acpi_tb_resize_root_table_list();
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+	}
+
+	/* Initialize added table */
+
+	acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.count].
+	    address = address;
+	acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.count].
+	    pointer = table;
+	acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.count].length =
+	    length;
+	acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.count].
+	    owner_id = 0;
+	acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.count].flags =
+	    flags;
+
+	ACPI_MOVE_32_TO_32(&
+			   (acpi_gbl_root_table_list.
+			    tables[acpi_gbl_root_table_list.count].signature),
+			   table->signature);
+
+	*table_index = acpi_gbl_root_table_list.count;
+	acpi_gbl_root_table_list.count++;
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_delete_table
+ *
+ * PARAMETERS:  table_index         - Table index
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Delete one internal ACPI table
+ *
+ ******************************************************************************/
+
+void acpi_tb_delete_table(struct acpi_table_desc *table_desc)
+{
+	/* Table must be mapped or allocated */
+	if (!table_desc->pointer) {
+		return;
+	}
+	switch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {
+	case ACPI_TABLE_ORIGIN_MAPPED:
+		acpi_os_unmap_memory(table_desc->pointer, table_desc->length);
+		break;
+	case ACPI_TABLE_ORIGIN_ALLOCATED:
+		ACPI_FREE(table_desc->pointer);
+		break;
+	default:;
+	}
+
+	table_desc->pointer = NULL;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_terminate
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Delete all internal ACPI tables
+ *
+ ******************************************************************************/
+
+void acpi_tb_terminate(void)
+{
+	u32 i;
+
+	ACPI_FUNCTION_TRACE(tb_terminate);
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+
+	/* Delete the individual tables */
+
+	for (i = 0; i < acpi_gbl_root_table_list.count; ++i) {
+		acpi_tb_delete_table(&acpi_gbl_root_table_list.tables[i]);
+	}
+
+	/*
+	 * Delete the root table array if allocated locally. Array cannot be
+	 * mapped, so we don't need to check for that flag.
+	 */
+	if (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {
+		ACPI_FREE(acpi_gbl_root_table_list.tables);
+	}
+
+	acpi_gbl_root_table_list.tables = NULL;
+	acpi_gbl_root_table_list.flags = 0;
+	acpi_gbl_root_table_list.count = 0;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "ACPI Tables freed\n"));
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_delete_namespace_by_owner
+ *
+ * PARAMETERS:  table_index         - Table index
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Delete all namespace objects created when this table was loaded.
+ *
+ ******************************************************************************/
+
+void acpi_tb_delete_namespace_by_owner(u32 table_index)
+{
+	acpi_owner_id owner_id;
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+	if (table_index < acpi_gbl_root_table_list.count) {
+		owner_id =
+		    acpi_gbl_root_table_list.tables[table_index].owner_id;
+	} else {
+		(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+		return;
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+	acpi_ns_delete_namespace_by_owner(owner_id);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_allocate_owner_id
+ *
+ * PARAMETERS:  table_index         - Table index
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Allocates owner_id in table_desc
+ *
+ ******************************************************************************/
+
+acpi_status acpi_tb_allocate_owner_id(u32 table_index)
+{
+	acpi_status status = AE_BAD_PARAMETER;
+
+	ACPI_FUNCTION_TRACE(tb_allocate_owner_id);
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+	if (table_index < acpi_gbl_root_table_list.count) {
+		status = acpi_ut_allocate_owner_id
+		    (&(acpi_gbl_root_table_list.tables[table_index].owner_id));
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_release_owner_id
+ *
+ * PARAMETERS:  table_index         - Table index
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Releases owner_id in table_desc
+ *
+ ******************************************************************************/
+
+acpi_status acpi_tb_release_owner_id(u32 table_index)
+{
+	acpi_status status = AE_BAD_PARAMETER;
+
+	ACPI_FUNCTION_TRACE(tb_release_owner_id);
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+	if (table_index < acpi_gbl_root_table_list.count) {
+		acpi_ut_release_owner_id(&
+					 (acpi_gbl_root_table_list.
+					  tables[table_index].owner_id));
+		status = AE_OK;
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_get_owner_id
+ *
+ * PARAMETERS:  table_index         - Table index
+ *              owner_id            - Where the table owner_id is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: returns owner_id for the ACPI table
+ *
+ ******************************************************************************/
+
+acpi_status acpi_tb_get_owner_id(u32 table_index, acpi_owner_id *owner_id)
+{
+	acpi_status status = AE_BAD_PARAMETER;
+
+	ACPI_FUNCTION_TRACE(tb_get_owner_id);
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+	if (table_index < acpi_gbl_root_table_list.count) {
+		*owner_id =
+		    acpi_gbl_root_table_list.tables[table_index].owner_id;
+		status = AE_OK;
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_is_table_loaded
+ *
+ * PARAMETERS:  table_index         - Table index
+ *
+ * RETURN:      Table Loaded Flag
+ *
+ ******************************************************************************/
+
+u8 acpi_tb_is_table_loaded(u32 table_index)
+{
+	u8 is_loaded = FALSE;
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+	if (table_index < acpi_gbl_root_table_list.count) {
+		is_loaded = (u8)
+		    (acpi_gbl_root_table_list.tables[table_index].
+		     flags & ACPI_TABLE_IS_LOADED);
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+	return (is_loaded);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_set_table_loaded_flag
+ *
+ * PARAMETERS:  table_index         - Table index
+ *              is_loaded           - TRUE if table is loaded, FALSE otherwise
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Sets the table loaded flag to either TRUE or FALSE.
+ *
+ ******************************************************************************/
+
+void acpi_tb_set_table_loaded_flag(u32 table_index, u8 is_loaded)
+{
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+	if (table_index < acpi_gbl_root_table_list.count) {
+		if (is_loaded) {
+			acpi_gbl_root_table_list.tables[table_index].flags |=
+			    ACPI_TABLE_IS_LOADED;
+		} else {
+			acpi_gbl_root_table_list.tables[table_index].flags &=
+			    ~ACPI_TABLE_IS_LOADED;
+		}
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+}
