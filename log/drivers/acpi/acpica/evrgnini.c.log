commit 800ba7c5eaaa734e4bd66bf0441fc200bbcdca54
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 10 11:31:49 2020 -0800

    ACPICA: All acpica: Update copyrights to 2020 Including tool signons.
    
    ACPICA commit 8b9c69d0984067051ffbe8526f871448ead6a26b
    
    Link: https://github.com/acpica/acpica/commit/8b9c69d0
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Kaneda <erik.kaneda@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index aee09640d710..aefc0145e583 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -3,7 +3,7 @@
  *
  * Module Name: evrgnini- ACPI address_space (op_region) init
  *
- * Copyright (C) 2000 - 2019, Intel Corp.
+ * Copyright (C) 2000 - 2020, Intel Corp.
  *
  *****************************************************************************/
 

commit edc5935ec777c23d66df5d47de53b4a2c8f16d0f
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Oct 25 14:36:49 2019 -0700

    ACPICA: Results from Clang
    
    ACPICA commit 1f08279b3eb13f17004159c28c391a390cd68feb
    
    Changes/fixes From Clang V5.0.1.  Mostly "set but never read"
    warnings.
    
    Link: https://github.com/acpica/acpica/commit/1f08279b
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 0b47bbcd2a23..aee09640d710 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -198,7 +198,6 @@ acpi_ev_pci_config_region_setup(acpi_handle handle,
 						 * root bridge. Still need to return a context object
 						 * for the new PCI_Config operation region, however.
 						 */
-						status = AE_OK;
 					} else {
 						ACPI_EXCEPTION((AE_INFO, status,
 								"Could not install PciConfig handler "

commit aa342261bde5ff177935c3a4f17f0bf2bf81babf
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Fri Feb 15 13:36:06 2019 -0800

    ACPICA: Remove legacy module-level code support
    
    ACPICA commit 47f5607c204719d9239a12b889df725225098c8f
    
    Module-level code refers to executable ASL code that runs during
    table load. This is typically used in ASL to declare named objects
    based on a condition evaluated during table load like so:
    
    definition_block(...)
    {
      opreation_region (OPR1, system_memory, ...)
      Field (OPR1)
      {
        FLD1, 8 /* Assume that FLD1's value is 0x1 */
      }
    
      /* The if statement below is referred to as module-level code */
    
      If (FLD1)
      {
        /* Declare DEV1 conditionally */
        Device (DEV1) {...}
      }
    
      Device (DEV2)
      {
        ...
      }
    }
    
    In legacy module-level code, the execution of the If statement
    was deferred after other modules were loaded. The order of
    code execution for the table above is the following:
    
    1.) Load OPR1 to the ACPI Namespace
    2.) Load FLD1 to the ACPI Namespace (not intended for drivers)
    3.) Load DEV2 to the ACPI Namespace
    4.) Execute If (FLD1) and load DEV1 if the condition is true
    
    This legacy approach can be problematic for tables that look like the
    following:
    
    definition_block(...)
    {
      opreation_region (OPR1, system_memory, ...)
      Field (OPR1)
      {
        FLD1, 8 /* Assume that FLD1's value is 0x1 */
      }
    
      /* The if statement below is referred to as module-level code */
    
      If (FLD1)
      {
        /* Declare DEV1 conditionally */
        Device (DEV1) {...}
      }
    
      Scope (DEV1)
      {
        /* Add objects DEV1's scope */
        Name (OBJ1, 0x1234)
      }
    }
    
    When loading this in the legacy approach, Scope DEV1 gets evaluated
    before the If statement. The following is the order of execution:
    
    1.) Load OPR1 to the ACPI Namespace
    2.) Load FLD1 to the ACPI Namespace (not intended for drivers)
    3.) Add OBJ1 under DEV1's scope -- ERROR. DEV1 does not exist
    4.) Execute If (FLD1) and load DEV1 if the condition is true
    
    The legacy approach can never succeed for tables like this due to the
    deferral of the module-level code. Due to this limitation, a new
    module-level code was developed. This new approach exeutes if
    statements in the order that they appear in the definition block.
    With this approach, the order of execution for the above defintion
    block is as follows:
    
    1.) Load OPR1 to the ACPI Namespace
    2.) Load FLD1 to the ACPI Namespace (not intended for drivers)
    3.) Execute If (FLD1) and load DEV1 because the condition is true
    4.) Add OBJ1 under DEV1's scope.
    
    Since DEV1 is loaded in the namespace in step 3, step 4 executes
    successfully.
    
    This change removes support for the legacy module-level code
    execution. From this point onward, the new module-level code
    execution will be the official approach.
    
    Link: https://github.com/acpica/acpica/commit/47f5607c
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 163dd4a142eb..0b47bbcd2a23 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -516,25 +516,6 @@ acpi_status acpi_ev_initialize_region(union acpi_operand_object *region_obj)
 				handler_obj = obj_desc->common_notify.handler;
 				break;
 
-			case ACPI_TYPE_METHOD:
-				/*
-				 * If we are executing module level code, the original
-				 * Node's object was replaced by this Method object and we
-				 * saved the handler in the method object.
-				 *
-				 * Note: Only used for the legacy MLC support. Will
-				 * be removed in the future.
-				 *
-				 * See acpi_ns_exec_module_code
-				 */
-				if (!acpi_gbl_execute_tables_as_methods &&
-				    obj_desc->method.
-				    info_flags & ACPI_METHOD_MODULE_LEVEL) {
-					handler_obj =
-					    obj_desc->method.dispatch.handler;
-				}
-				break;
-
 			default:
 
 				/* Ignore other objects */

commit 840c02ca2215af648c781ae680d93d8aecd083b7
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jan 14 09:55:25 2019 -0800

    ACPICA: All acpica: Update copyrights to 2019
    
    ACPICA commit 62f4f98e941d86e41969bf2ab5a93b8dc94dc49e
    
    The update includes userspace tool signons.
    
    Link: https://github.com/acpica/acpica/commit/62f4f98e
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 17df5dacd43c..163dd4a142eb 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -3,7 +3,7 @@
  *
  * Module Name: evrgnini- ACPI address_space (op_region) init
  *
- * Copyright (C) 2000 - 2018, Intel Corp.
+ * Copyright (C) 2000 - 2019, Intel Corp.
  *
  *****************************************************************************/
 

commit 8b1cafdcb4b75c5027c52f1e82b47ebe727ad7ed
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Oct 3 11:45:38 2018 -0700

    ACPICA: Never run _REG on system_memory and system_IO
    
    These address spaces are defined by the ACPI spec to be
    "always available", and thus _REG should never be run on them.
    Provides compatibility with other ACPI implementations.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 39284deedd88..17df5dacd43c 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -16,9 +16,6 @@
 #define _COMPONENT          ACPI_EVENTS
 ACPI_MODULE_NAME("evrgnini")
 
-/* Local prototypes */
-static u8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node);
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ev_system_memory_region_setup
@@ -33,7 +30,6 @@ static u8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node);
  * DESCRIPTION: Setup a system_memory operation region
  *
  ******************************************************************************/
-
 acpi_status
 acpi_ev_system_memory_region_setup(acpi_handle handle,
 				   u32 function,
@@ -313,7 +309,7 @@ acpi_ev_pci_config_region_setup(acpi_handle handle,
  *
  ******************************************************************************/
 
-static u8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node)
+u8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node)
 {
 	acpi_status status;
 	struct acpi_pnp_device_id *hid;

commit a406dea82af80a2cb069f7e34e24677fe9dd580e
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Mar 14 16:13:09 2018 -0700

    ACPICA: Cleanup/simplify module-level code support
    
    This prepares the code for eventual removal of the original
    style of deferred execution of the MLC.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index d91c317c57d7..39284deedd88 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -526,6 +526,9 @@ acpi_status acpi_ev_initialize_region(union acpi_operand_object *region_obj)
 				 * Node's object was replaced by this Method object and we
 				 * saved the handler in the method object.
 				 *
+				 * Note: Only used for the legacy MLC support. Will
+				 * be removed in the future.
+				 *
 				 * See acpi_ns_exec_module_code
 				 */
 				if (!acpi_gbl_execute_tables_as_methods &&

commit 95857638889aeea1b10a16b55041adf3e3ab84c4
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Wed Mar 14 16:13:07 2018 -0700

    ACPICA: adding SPDX headers
    
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index ade127f26b48..d91c317c57d7 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -1,45 +1,11 @@
+// SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
 /******************************************************************************
  *
  * Module Name: evrgnini- ACPI address_space (op_region) init
  *
- *****************************************************************************/
-
-/*
  * Copyright (C) 2000 - 2018, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
+ *
+ *****************************************************************************/
 
 #include <acpi/acpi.h>
 #include "accommon.h"

commit e7d970f6fca8bc7b9587f77bf8b11fa78abd9280
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Mar 14 16:13:06 2018 -0700

    ACPICA: Rename a global for clarity, no functional change
    
    Was acpi_gbl_parse_table_as_term_list, changed to:
    acpi_gbl_execute_tables_as_methods.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 4187f563fede..ade127f26b48 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -562,7 +562,7 @@ acpi_status acpi_ev_initialize_region(union acpi_operand_object *region_obj)
 				 *
 				 * See acpi_ns_exec_module_code
 				 */
-				if (!acpi_gbl_parse_table_as_term_list &&
+				if (!acpi_gbl_execute_tables_as_methods &&
 				    obj_desc->method.
 				    info_flags & ACPI_METHOD_MODULE_LEVEL) {
 					handler_obj =

commit da6f8320d58623eae9b6fa2f09b1b4f60a772ce9
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 4 10:06:38 2018 -0800

    ACPICA: All acpica: Update copyrights to 2018
    
    including tool signons.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 93ec528bcd9a..4187f563fede 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2017, Intel Corp.
+ * Copyright (C) 2000 - 2018, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 7735ca0eb4ebd6d47fdad40602d0ba7593219f8c
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Feb 8 11:00:08 2017 +0800

    ACPICA: Source tree: Update copyright notices to 2017
    
    ACPICA commit 16577e5265923f4999b4d2c0addb2343b18135e1
    
    Affects all files.
    
    Link: https://github.com/acpica/acpica/commit/16577e52
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index a9092251ce80..93ec528bcd9a 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2016, Intel Corp.
+ * Copyright (C) 2000 - 2017, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 760235cd6ca8ae0d7509055d75a0f1d8b3c60668
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Nov 30 15:21:12 2016 +0800

    ACPICA: Events: Fix acpi_ev_initialize_region() return value
    
    ACPICA commit 543342ab7a676f4eb0c9f100d349388a84dff0e8
    
    This patch changes acpi_ev_initialize_region(), stop returning AE_NOT_EXIST
    from it so that, not only in acpi_ds_load2_end_op(), but all places invoking
    this function won't emit exceptions. The exception can be seen in
    acpi_ds_initialize_objects() when certain table loading mode is chosen.
    
    This patch also removes useless acpi_ns_locked from acpi_ev_initialize_region()
    as this function will always be invoked with interpreter lock held now, and
    the lock granularity has been tuned to lock around _REG execution, thus it
    is now handled by acpi_ex_exit_interpreter(). Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/543342ab
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 75ddd160a716..a9092251ce80 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -479,7 +479,6 @@ acpi_ev_default_region_setup(acpi_handle handle,
  * FUNCTION:    acpi_ev_initialize_region
  *
  * PARAMETERS:  region_obj      - Region we are initializing
- *              acpi_ns_locked  - Is namespace locked?
  *
  * RETURN:      Status
  *
@@ -497,19 +496,28 @@ acpi_ev_default_region_setup(acpi_handle handle,
  * MUTEX:       Interpreter should be unlocked, because we may run the _REG
  *              method for this region.
  *
+ * NOTE:        Possible incompliance:
+ *              There is a behavior conflict in automatic _REG execution:
+ *              1. When the interpreter is evaluating a method, we can only
+ *                 automatically run _REG for the following case:
+ *                   operation_region (OPR1, 0x80, 0x1000010, 0x4)
+ *              2. When the interpreter is loading a table, we can also
+ *                 automatically run _REG for the following case:
+ *                   operation_region (OPR1, 0x80, 0x1000010, 0x4)
+ *              Though this may not be compliant to the de-facto standard, the
+ *              logic is kept in order not to trigger regressions. And keeping
+ *              this logic should be taken care by the caller of this function.
+ *
  ******************************************************************************/
 
-acpi_status
-acpi_ev_initialize_region(union acpi_operand_object *region_obj,
-			  u8 acpi_ns_locked)
+acpi_status acpi_ev_initialize_region(union acpi_operand_object *region_obj)
 {
 	union acpi_operand_object *handler_obj;
 	union acpi_operand_object *obj_desc;
 	acpi_adr_space_type space_id;
 	struct acpi_namespace_node *node;
-	acpi_status status;
 
-	ACPI_FUNCTION_TRACE_U32(ev_initialize_region, acpi_ns_locked);
+	ACPI_FUNCTION_TRACE(ev_initialize_region);
 
 	if (!region_obj) {
 		return_ACPI_STATUS(AE_BAD_PARAMETER);
@@ -580,39 +588,17 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 						  handler_obj, region_obj,
 						  obj_desc));
 
-				status =
-				    acpi_ev_attach_region(handler_obj,
-							  region_obj,
-							  acpi_ns_locked);
+				(void)acpi_ev_attach_region(handler_obj,
+							    region_obj, FALSE);
 
 				/*
 				 * Tell all users that this region is usable by
 				 * running the _REG method
 				 */
-				if (acpi_ns_locked) {
-					status =
-					    acpi_ut_release_mutex
-					    (ACPI_MTX_NAMESPACE);
-					if (ACPI_FAILURE(status)) {
-						return_ACPI_STATUS(status);
-					}
-				}
-
 				acpi_ex_exit_interpreter();
-				status =
-				    acpi_ev_execute_reg_method(region_obj,
-							       ACPI_REG_CONNECT);
+				(void)acpi_ev_execute_reg_method(region_obj,
+								 ACPI_REG_CONNECT);
 				acpi_ex_enter_interpreter();
-
-				if (acpi_ns_locked) {
-					status =
-					    acpi_ut_acquire_mutex
-					    (ACPI_MTX_NAMESPACE);
-					if (ACPI_FAILURE(status)) {
-						return_ACPI_STATUS(status);
-					}
-				}
-
 				return_ACPI_STATUS(AE_OK);
 			}
 		}
@@ -622,12 +608,15 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 		node = node->parent;
 	}
 
-	/* If we get here, there is no handler for this region */
-
+	/*
+	 * If we get here, there is no handler for this region. This is not
+	 * fatal because many regions get created before a handler is installed
+	 * for said region.
+	 */
 	ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
 			  "No handler for RegionType %s(%X) (RegionObj %p)\n",
 			  acpi_ut_get_region_name(space_id), space_id,
 			  region_obj));
 
-	return_ACPI_STATUS(AE_NOT_EXIST);
+	return_ACPI_STATUS(AE_OK);
 }

commit 8633db6b027952449e155a316f4ae3a530bbe18f
Author: Lv Zheng <zetalog@gmail.com>
Date:   Wed Oct 26 15:42:01 2016 +0800

    ACPICA: Dispatcher: Fix interpreter locking around acpi_ev_initialize_region()
    
    In the code path of acpi_ev_initialize_region(), there is namespace
    modification code unlocked. This patch tunes the code to make sure
    such modification are always locked.
    
    Fixes: 74f51b80a0c4 (ACPICA: Namespace: Fix dynamic table loading issues)
    Tested-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 3843f1fc5dbb..75ddd160a716 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -45,6 +45,7 @@
 #include "accommon.h"
 #include "acevents.h"
 #include "acnamesp.h"
+#include "acinterp.h"
 
 #define _COMPONENT          ACPI_EVENTS
 ACPI_MODULE_NAME("evrgnini")
@@ -597,9 +598,11 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 					}
 				}
 
+				acpi_ex_exit_interpreter();
 				status =
 				    acpi_ev_execute_reg_method(region_obj,
 							       ACPI_REG_CONNECT);
+				acpi_ex_enter_interpreter();
 
 				if (acpi_ns_locked) {
 					status =

commit de56ba95e8d6d760910711744a548b50b3a4262d
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Sep 7 14:06:54 2016 +0800

    ACPICA: Interpreter: Fix MLC issues by switching to new term_list grammar for table loading
    
    ACPICA commit 0e24fb67cde08d7df7671d7d7b183490dc79707e
    
    The MLC (Module Level Code) is an ACPICA terminology describing the AML
    code out of any control method, its support is an indication of the
    interpreter behavior during the table loading.
    
    The original implementation of MLC in ACPICA had several issues:
    1. Out of any control method, besides of the object creating opcodes, only
       the code blocks wrapped by "If/Else/While" opcodes were supported.
    2. The supported MLC code blocks were executed after loading the table
       rather than being executed right in place.
       ============================================================
       The demo of this order issue is as follows:
         Name (OBJ1, 1)
         If (CND1 == 1)
         {
           Name (OBJ2, 2)
         }
         Name (OBJ3, 3)
       The original MLC support created OBJ2 after OBJ3's creation.
       ============================================================
    Other than these limitations, MLC support in ACPICA looks correct. And
    supporting this should be easy/natural for ACPICA, but enabling of this was
    blocked by some ACPICA internal and OSPM specific initialization order
    issues we've fixed recently. The wrong support started from the following
    false bug fixing commit:
      Commit: 7f0c826a437157d2b19662977e9cf3b472cf24a6
      Subject: ACPICA: Add support for module-level executable AML code
      Commit: 9a884ab64a4d092b4c3bf24fd9a30f7fbd4591e7
      Subject: ACPICA: Add additional module-level code support
      ...
    
    We can confirm Windows interpreter behavior via reverse engineering means.
    It can be proven that not only If/Else/While wrapped code blocks, all
    opcodes can be executed at the module level, including operation region
    accesses. And it can be proven that the MLC should be executed right in
    place, not in such a deferred way executed after loading the table.
    
    And the above facts indeed reflect the spec words around ACPI definition
    block tables (DSDT/SSDT/...), the entire table and the Scope object is
    defined by the AML specification in BNF style as:
      AMLCode := def_block_header term_list
      def_scope := scope_op pkg_length name_string term_list
    The bodies of the scope opening terms (AMLCode/Scope) are all term_list,
    thus the table loading should be no difference than the control method
    evaluations as the body of the Method is also defined by the AML
    specification as term_list:
      def_method := method_op pkg_length name_string method_flags term_list
    The only difference is: after evaluating control method, created named
    objects may be freed due to no reference, while named objects created by
    the table loading should only be freed after unloading the table.
    
    So this patch follows the spec and the de-facto standard behavior, enables
    the new grammar (term_list) for the table loading.
    
    By doing so, beyond the fixes to the above issues, we can see additional
    differences comparing to the old grammar based table loading:
    1. Originally, beyond the scope opening terms (AMLCode/Scope),
       If/Else/While wrapped code blocks under the scope creating terms
       (Device/power_resource/Processor/thermal_zone) are also supported as
       deferred MLC, which violates the spec defined grammar where object_list
       is enforced. With MLC support improved as non-deferred, the interpreter
       parses such scope creating terms as term_list rather object_list like the
       scope opening terms.
       After probing the Windows behavior and proving that it also parses these
       terms as term_list, we submitted an ECR (Engineering Change Request) to
       the ASWG (ACPI Specification Working Group) to clarify this. The ECR is
       titled as "ASL Grammar Clarification for Executable AML Opcodes" and has
       been accepted by the ASWG. The new grammar will appear in ACPI
       specification 6.2.
    2. Originally, Buffer/Package/operation_region/create_XXXField/bank_field
       arguments are evaluated in a deferred way after loading the table. With
       MLC support improved, they are also parsed right in place during the
       table loading.
       This is also Windows compliant and the only difference is the removal
       of the debugging messages implemented before acpi_ds_execute_arguments(),
       see Link # [1] for the details. A previous commit should have ensured
       that acpi_check_address_range() won't regress.
    
    Note that enabling this feature may cause regressions due to long term
    Linux ACPI support on top of the wrong grammar. So this patch also prepares
    a global option to be used to roll back to the old grammar during the
    period between a regression is reported and the regression is
    root-cause-fixed. Lv Zheng.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=112911 # [1]
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=117671 # [1]
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=153541 # [1]
    Link: https://github.com/acpica/acpica/issues/122
    Link: https://bugs.acpica.org/show_bug.cgi?id=963
    Link: https://github.com/acpica/acpica/commit/0e24fb67
    Reported-and-tested-by: Chris Bainbridge <chris.bainbridge@gmail.com>
    Reported-by: Ehsan <dashesy@gmail.com>
    Reported-and-tested-by: Dutch Guy <lucht_piloot@gmx.net>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index b6ea9c0d0d8c..3843f1fc5dbb 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -553,7 +553,8 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 				 *
 				 * See acpi_ns_exec_module_code
 				 */
-				if (obj_desc->method.
+				if (!acpi_gbl_parse_table_as_term_list &&
+				    obj_desc->method.
 				    info_flags & ACPI_METHOD_MODULE_LEVEL) {
 					handler_obj =
 					    obj_desc->method.dispatch.handler;

commit f5c1e1c5a652e4b43eb9b571577ef72731f3fa8b
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu May 5 12:57:53 2016 +0800

    ACPICA: Divergence: remove unwanted spaces for typedef
    
    ACPICA commit b2294cae776f5a66a7697414b21949d307e6856f
    
    This patch removes unwanted spaces for typedef. This solution doesn't cover
    function types.
    
    Note that the linuxize result of this commit is very giant and should have
    many conflicts against the current Linux upstream. Thus it is required to
    modify the linuxize result of this commit and the commits around it
    manually in order to have them merged to the Linux upstream. Since this is
    very costy, we should do this only once, and if we can't ensure to do this
    only once, we need to revert the Linux code to the wrong indentation result
    before merging the linuxize result of this commit. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/b2294cae
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 6972ab4ddb66..b6ea9c0d0d8c 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -227,7 +227,7 @@ acpi_ev_pci_config_region_setup(acpi_handle handle,
 
 				/* Install a handler for this PCI root bridge */
 
-				status = acpi_install_address_space_handler((acpi_handle) pci_root_node, ACPI_ADR_SPACE_PCI_CONFIG, ACPI_DEFAULT_HANDLER, NULL, NULL);
+				status = acpi_install_address_space_handler((acpi_handle)pci_root_node, ACPI_ADR_SPACE_PCI_CONFIG, ACPI_DEFAULT_HANDLER, NULL, NULL);
 				if (ACPI_FAILURE(status)) {
 					if (status == AE_SAME_HANDLER) {
 						/*

commit d1461a1b506e4a2df9f703c5f39f765b65c9672e
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Mar 24 09:41:47 2016 +0800

    ACPICA: Events: Fix an issue that _REG association can happen before namespace is initialized
    
    ACPICA commit c508f8592efaa0d8197f26d7fee6382c5ac8e383
    
    Current code flow cannot ensure _REG association can happen after the
    namespace is initialized, so we move _REG association to where _REG was
    about to run to fix this issue.
    
    This issue is detected when acpi_ev_initialize_region() is invoked during
    the table loading. And this is one of the most important the root cause why
    ACPICA table loading is split into 2 load passes. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/c508f859
    Link: https://bugs.acpica.org/show_bug.cgi?id=1252
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index fda869c9ad0b..6972ab4ddb66 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -518,7 +518,6 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 		return_ACPI_STATUS(AE_OK);
 	}
 
-	acpi_ev_associate_reg_method(region_obj);
 	region_obj->common.flags |= AOPOBJ_OBJECT_INITIALIZED;
 
 	node = region_obj->region.node->parent;

commit c8100dc4643d80a94f074dfc8a2af3d3d327b7aa
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 15 08:17:03 2016 +0800

    ACPICA: Additional 2016 copyright changes
    
    All tool/utility signons.
    Dual-license module header.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index bb2e529249c7..fda869c9ad0b 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2015, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 849c25719ac6acc7420515c7b6324f4248a13790
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 29 14:02:58 2015 +0800

    ACPICA: Events: Split acpi_ev_associate_reg_method() from region initialization code
    
    ACPICA commit 87c85610250ff7141a84507f68dbc1e00f2936db
    
    This patch introduces a new region initialization function
    acpi_ev_associate_reg_method(), which is invoked to associate the _REG method
    to its related region object.
    
    Region object's default value assignments are also sorted by cleaning up
    the code using this new function. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/87c85610
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 024689dadcd2..bb2e529249c7 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -507,9 +507,6 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 	acpi_adr_space_type space_id;
 	struct acpi_namespace_node *node;
 	acpi_status status;
-	struct acpi_namespace_node *method_node;
-	acpi_name *reg_name_ptr = (acpi_name *) METHOD_NAME__REG;
-	union acpi_operand_object *region_obj2;
 
 	ACPI_FUNCTION_TRACE_U32(ev_initialize_region, acpi_ns_locked);
 
@@ -521,35 +518,12 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 		return_ACPI_STATUS(AE_OK);
 	}
 
-	region_obj2 = acpi_ns_get_secondary_object(region_obj);
-	if (!region_obj2) {
-		return_ACPI_STATUS(AE_NOT_EXIST);
-	}
+	acpi_ev_associate_reg_method(region_obj);
+	region_obj->common.flags |= AOPOBJ_OBJECT_INITIALIZED;
 
 	node = region_obj->region.node->parent;
 	space_id = region_obj->region.space_id;
 
-	/* Setup defaults */
-
-	region_obj->region.handler = NULL;
-	region_obj2->extra.method_REG = NULL;
-	region_obj->common.flags &= ~(AOPOBJ_SETUP_COMPLETE);
-	region_obj->common.flags |= AOPOBJ_OBJECT_INITIALIZED;
-
-	/* Find any "_REG" method associated with this region definition */
-
-	status =
-	    acpi_ns_search_one_scope(*reg_name_ptr, node, ACPI_TYPE_METHOD,
-				     &method_node);
-	if (ACPI_SUCCESS(status)) {
-		/*
-		 * The _REG method is optional and there can be only one per region
-		 * definition. This will be executed when the handler is attached
-		 * or removed
-		 */
-		region_obj2->extra.method_REG = method_node;
-	}
-
 	/*
 	 * The following loop depends upon the root Node having no parent
 	 * ie: acpi_gbl_root_node->Parent being set to NULL

commit aa6abd2be1cc7fa2593c8377f78420dec0a5d7a5
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 29 14:02:08 2015 +0800

    ACPICA: Events: Uses common_notify for address space handlers
    
    ACPICA commit 5ea0fb75fdf1aa7c0aba067dfa4d5dc3a9279461
    
    The address space handlers can be attached to not only Device but also
    Processor/thermal_zone objects, so it is better to use their common
    class 'CommonNotify' instead. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/5ea0fb75
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 4df81b5a1751..024689dadcd2 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -566,18 +566,10 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 
 			switch (node->type) {
 			case ACPI_TYPE_DEVICE:
-
-				handler_obj = obj_desc->device.handler;
-				break;
-
 			case ACPI_TYPE_PROCESSOR:
-
-				handler_obj = obj_desc->processor.handler;
-				break;
-
 			case ACPI_TYPE_THERMAL:
 
-				handler_obj = obj_desc->thermal_zone.handler;
+				handler_obj = obj_desc->common_notify.handler;
 				break;
 
 			case ACPI_TYPE_METHOD:

commit f31a99cefd05f798eee8b592e22175ff3fe1876b
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 29 14:02:00 2015 +0800

    ACPICA: Events: Deploys acpi_ev_find_region_handler()
    
    ACPICA commit b916a0a0ae9e81db1a85523c63ec6aa32d5c70c8
    
    There are code fragments that can be substituted by
    acpi_ev_find_region_handler().
    
    This patch cleans up these code fragments. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/b916a0a0
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 6181f5a2af4f..4df81b5a1751 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -602,60 +602,49 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 				break;
 			}
 
-			while (handler_obj) {
+			handler_obj =
+			    acpi_ev_find_region_handler(space_id, handler_obj);
+			if (handler_obj) {
 
-				/* Is this handler of the correct type? */
+				/* Found correct handler */
 
-				if (handler_obj->address_space.space_id ==
-				    space_id) {
+				ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+						  "Found handler %p for region %p in obj %p\n",
+						  handler_obj, region_obj,
+						  obj_desc));
 
-					/* Found correct handler */
-
-					ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
-							  "Found handler %p for region %p in obj %p\n",
-							  handler_obj,
+				status =
+				    acpi_ev_attach_region(handler_obj,
 							  region_obj,
-							  obj_desc));
+							  acpi_ns_locked);
 
+				/*
+				 * Tell all users that this region is usable by
+				 * running the _REG method
+				 */
+				if (acpi_ns_locked) {
 					status =
-					    acpi_ev_attach_region(handler_obj,
-								  region_obj,
-								  acpi_ns_locked);
-
-					/*
-					 * Tell all users that this region is usable by
-					 * running the _REG method
-					 */
-					if (acpi_ns_locked) {
-						status =
-						    acpi_ut_release_mutex
-						    (ACPI_MTX_NAMESPACE);
-						if (ACPI_FAILURE(status)) {
-							return_ACPI_STATUS
-							    (status);
-						}
+					    acpi_ut_release_mutex
+					    (ACPI_MTX_NAMESPACE);
+					if (ACPI_FAILURE(status)) {
+						return_ACPI_STATUS(status);
 					}
+				}
 
+				status =
+				    acpi_ev_execute_reg_method(region_obj,
+							       ACPI_REG_CONNECT);
+
+				if (acpi_ns_locked) {
 					status =
-					    acpi_ev_execute_reg_method
-					    (region_obj, ACPI_REG_CONNECT);
-
-					if (acpi_ns_locked) {
-						status =
-						    acpi_ut_acquire_mutex
-						    (ACPI_MTX_NAMESPACE);
-						if (ACPI_FAILURE(status)) {
-							return_ACPI_STATUS
-							    (status);
-						}
+					    acpi_ut_acquire_mutex
+					    (ACPI_MTX_NAMESPACE);
+					if (ACPI_FAILURE(status)) {
+						return_ACPI_STATUS(status);
 					}
-
-					return_ACPI_STATUS(AE_OK);
 				}
 
-				/* Try next handler in the list */
-
-				handler_obj = handler_obj->address_space.next;
+				return_ACPI_STATUS(AE_OK);
 			}
 		}
 

commit 7b73806485ada16059ecc1851793dbe865181c53
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Dec 29 14:01:53 2015 +0800

    ACPICA: Cleanup code related to the per-table module level improvement
    
    ACPICA commit 071eff738c59eda1792ac24b3b688b61691d7e7c
    
    This patch collects cleanups from per-table module level improvement. By
    splitting this patch from that commit, we can make per-table module level
    improvement clearer for the revewers. This is a no-op change.
    
    Link: https://github.com/acpica/acpica/commit/071eff73
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index da323390bb70..6181f5a2af4f 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -552,7 +552,7 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 
 	/*
 	 * The following loop depends upon the root Node having no parent
-	 * ie: acpi_gbl_root_node->parent_entry being set to NULL
+	 * ie: acpi_gbl_root_node->Parent being set to NULL
 	 */
 	while (node) {
 

commit 82a809419429f2e6142d2c5d88d91661f8aecb87
Author: David E. Box <david.e.box@linux.intel.com>
Date:   Thu Feb 5 15:20:45 2015 +0800

    ACPICA: Update Copyright headers to 2015
    
    ACPICA commit 8990e73ab2aa15d6a0068b860ab54feff25bee36
    
    Link: https://github.com/acpica/acpica/commit/8990e73a
    Signed-off-by: David E. Box <david.e.box@linux.intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 1b148a440d67..da323390bb70 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2014, Intel Corp.
+ * Copyright (C) 2000 - 2015, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit fbb7a2dc2be493c87399550bdc2ddaa510cdf450
Author: Bob Moore <robert.moore@intel.com>
Date:   Sat Feb 8 09:42:25 2014 +0800

    ACPICA: Update ACPICA copyrights to 2014.
    
    Update ACPICA copyrights to 2014. Includes all source headers and
    signons for the various tools.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 8354c4f7f10c..1b148a440d67 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2013, Intel Corp.
+ * Copyright (C) 2000 - 2014, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 1d1ea1b723d9f239f736b8cf284327cbbf9d15d1
Author: Chao Guan <chao.guan@intel.com>
Date:   Sat Jun 8 00:58:14 2013 +0000

    ACPICA: Standardize all switch() blocks
    
    After many years, different formatting for switch() has crept in.
    This change makes every switch block identical. Chao Guan.
    ACPICA bugzilla 997.
    
    References: https://bugs.acpica.org/show_bug.cgi?id=997
    Signed-off-by: Chao Guan <chao.guan@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 3bb616794b3b..8354c4f7f10c 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -596,7 +596,9 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 				break;
 
 			default:
+
 				/* Ignore other objects */
+
 				break;
 			}
 

commit 25f044e64568dd83de34c16c837a96bbb2b0cecb
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 25 05:38:56 2013 +0000

    ACPICA: Update ACPICA copyrights to 2013
    
    Includes all source headers and signons for the various tools.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 1474241bfc7e..3bb616794b3b 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2013, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 1f86e8c1c9f129d450fd75e42d25ddba69a522ac
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Oct 31 02:25:45 2012 +0000

    ACPICA: Fix indent caused divergences.
    
    New version of "indent" program will generate different outputs that
    will lead to the divergences between the Linux and the ACPICA.
    This patch fixes such divergences caused by the "indent" program.
    The version of the "indent" used for this patch is "GNU indent 2.2.11".
    
    This patch will not affect the generated vmlinux binary.
    This will decrease 581 lines of 20120913 divergence.diff.
    
    Signed-off-by: Robert Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 6786f00042cd..1474241bfc7e 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -227,8 +227,7 @@ acpi_ev_pci_config_region_setup(acpi_handle handle,
 
 				/* Install a handler for this PCI root bridge */
 
-				status =
-				    acpi_install_address_space_handler((acpi_handle) pci_root_node, ACPI_ADR_SPACE_PCI_CONFIG, ACPI_DEFAULT_HANDLER, NULL, NULL);
+				status = acpi_install_address_space_handler((acpi_handle) pci_root_node, ACPI_ADR_SPACE_PCI_CONFIG, ACPI_DEFAULT_HANDLER, NULL, NULL);
 				if (ACPI_FAILURE(status)) {
 					if (status == AE_SAME_HANDLER) {
 						/*

commit 78e25fef2751434f38c7f711ecbf8762f79f7318
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Oct 31 02:25:24 2012 +0000

    ACPICA: Fix divergences of definition conflicts.
    
    There are conflicts in the "acpi_device_id*" definitions between the
    Linux and the ACPICA.  The definitions of acpi_device_id* in ACPICA
    have been changed to the "acpi_pnp_device_id*".  This patch changes
    the corresponding "acpica_device_id*" definitiions in the Linux.
    
    This patch will not affect the generated vmlinx binary.
    This will decrease 298 lines of 20120913 divergence.diff.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 4c1c8261166f..6786f00042cd 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -350,8 +350,8 @@ acpi_ev_pci_config_region_setup(acpi_handle handle,
 static u8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node)
 {
 	acpi_status status;
-	struct acpica_device_id *hid;
-	struct acpica_device_id_list *cid;
+	struct acpi_pnp_device_id *hid;
+	struct acpi_pnp_device_id_list *cid;
 	u32 i;
 	u8 match;
 

commit ba494beeaa69bc0fb01eb89464ad5d57d26e3901
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jul 12 09:40:10 2012 +0800

    ACPICA: AcpiSrc: Fix some translation issues for Linux conversion
    
    Fixes issues like this:
    
    i_aSL -> iASL
    00-7_f -> 00-7F
    local_fADT -> local_FADT
    execute_oSI -> execute_OSI
    
    Also, in function headers, the parameters are now translated to
    lower case (with underscores if necessary.)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 819c17f5897a..4c1c8261166f 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -56,8 +56,8 @@ static u8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node);
  *
  * FUNCTION:    acpi_ev_system_memory_region_setup
  *
- * PARAMETERS:  Handle              - Region we are interested in
- *              Function            - Start or stop
+ * PARAMETERS:  handle              - Region we are interested in
+ *              function            - Start or stop
  *              handler_context     - Address space handler context
  *              region_context      - Region specific context
  *
@@ -118,8 +118,8 @@ acpi_ev_system_memory_region_setup(acpi_handle handle,
  *
  * FUNCTION:    acpi_ev_io_space_region_setup
  *
- * PARAMETERS:  Handle              - Region we are interested in
- *              Function            - Start or stop
+ * PARAMETERS:  handle              - Region we are interested in
+ *              function            - Start or stop
  *              handler_context     - Address space handler context
  *              region_context      - Region specific context
  *
@@ -149,8 +149,8 @@ acpi_ev_io_space_region_setup(acpi_handle handle,
  *
  * FUNCTION:    acpi_ev_pci_config_region_setup
  *
- * PARAMETERS:  Handle              - Region we are interested in
- *              Function            - Start or stop
+ * PARAMETERS:  handle              - Region we are interested in
+ *              function            - Start or stop
  *              handler_context     - Address space handler context
  *              region_context      - Region specific context
  *
@@ -338,7 +338,7 @@ acpi_ev_pci_config_region_setup(acpi_handle handle,
  *
  * FUNCTION:    acpi_ev_is_pci_root_bridge
  *
- * PARAMETERS:  Node            - Device node being examined
+ * PARAMETERS:  node            - Device node being examined
  *
  * RETURN:      TRUE if device is a PCI/PCI-Express Root Bridge
  *
@@ -393,14 +393,14 @@ static u8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node)
  *
  * FUNCTION:    acpi_ev_pci_bar_region_setup
  *
- * PARAMETERS:  Handle              - Region we are interested in
- *              Function            - Start or stop
+ * PARAMETERS:  handle              - Region we are interested in
+ *              function            - Start or stop
  *              handler_context     - Address space handler context
  *              region_context      - Region specific context
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Setup a pci_bAR operation region
+ * DESCRIPTION: Setup a pci_BAR operation region
  *
  * MUTEX:       Assumes namespace is not locked
  *
@@ -420,8 +420,8 @@ acpi_ev_pci_bar_region_setup(acpi_handle handle,
  *
  * FUNCTION:    acpi_ev_cmos_region_setup
  *
- * PARAMETERS:  Handle              - Region we are interested in
- *              Function            - Start or stop
+ * PARAMETERS:  handle              - Region we are interested in
+ *              function            - Start or stop
  *              handler_context     - Address space handler context
  *              region_context      - Region specific context
  *
@@ -447,8 +447,8 @@ acpi_ev_cmos_region_setup(acpi_handle handle,
  *
  * FUNCTION:    acpi_ev_default_region_setup
  *
- * PARAMETERS:  Handle              - Region we are interested in
- *              Function            - Start or stop
+ * PARAMETERS:  handle              - Region we are interested in
+ *              function            - Start or stop
  *              handler_context     - Address space handler context
  *              region_context      - Region specific context
  *

commit 77848130e53b06c22fe37a7b6acbb82bb3e9bfba
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 12 13:27:23 2012 +0800

    ACPICA: Update all copyrights to 2012
    
    Update all copyrights to 2012.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 55a5d35ef34a..819c17f5897a 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2011, Intel Corp.
+ * Copyright (C) 2000 - 2012, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit e2066ca1b211ff08325c98be9fb8ad95affbaba8
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Apr 13 13:22:04 2011 +0800

    ACPICA: Execute an orphan _REG method under the EC device
    
    This change will force the execution of a _REG method underneath
    the EC device even if there is no corresponding operation region
    of type EmbeddedControl. Fixes a problem seen on some machines
    and apparently is compatible with Windows behavior.
    
    http://www.acpica.org/bugzilla/show_bug.cgi?id=875
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 9659cee6093e..55a5d35ef34a 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -637,7 +637,7 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 
 					status =
 					    acpi_ev_execute_reg_method
-					    (region_obj, 1);
+					    (region_obj, ACPI_REG_CONNECT);
 
 					if (acpi_ns_locked) {
 						status =

commit b4e104eaeb8cd4329a23e0e4ebf166681b1d182d
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jan 17 11:05:40 2011 +0800

    ACPICA: Update all ACPICA copyrights and signons to 2011
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 2ef32e952559..9659cee6093e 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2010, Intel Corp.
+ * Copyright (C) 2000 - 2011, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 262948428878fb340127faca1791acb17146122e
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Wed Jan 12 09:19:43 2011 +0800

    ACPICA: Fix issues/fault with automatic "serialized" method support
    
    History: This support changes a method to "serialized" on the fly if the
    method generates an AE_ALREADY_EXISTS error, indicating the possibility
    that it cannot handle reentrancy.
    
    This fix repairs a couple of issues seen in the field, especially on
    machines with many cores.
    
    1) Delete method children only upon the exit of the last thread, so
    as to not delete objects out from under running threads.
    
    2) Set the "serialized" bit for the method only upon the exit of the
    last thread, so as to not cause deadlock when running threads attempt
    to exit.
    
    3) Cleanup the use of the AML "MethodFlags" and internal method flags
    so that there is no longer any confustion between the two.
    
    Reported-by: Dana Myers <dana.myers@oracle.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 0b47a6dc9290..2ef32e952559 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -590,9 +590,9 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 				 * See acpi_ns_exec_module_code
 				 */
 				if (obj_desc->method.
-				    flags & AOPOBJ_MODULE_LEVEL) {
+				    info_flags & ACPI_METHOD_MODULE_LEVEL) {
 					handler_obj =
-					    obj_desc->method.extra.handler;
+					    obj_desc->method.dispatch.handler;
 				}
 				break;
 

commit 95abccb576c44bc593e05fa1245d0ad26ce6107b
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Sep 15 13:22:46 2010 +0800

    ACPICA: Obsolete the acpi_os_derive_pci_id OSL interface
    
    This function is not OS-dependent and has been replaced by
    acpi_hw_derive_pci_id, which is now in the ACPICA core code.  Local
    implementations of acpi_os_derive_pci_id are no longer necessary and
    are removed. ACPICA BZ 857.
    
    http://www.acpica.org/bugzilla/show_bug.cgi?id=857
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index f40d271bf568..0b47a6dc9290 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -289,8 +289,8 @@ acpi_ev_pci_config_region_setup(acpi_handle handle,
 	}
 
 	/*
-	 * Get the PCI device and function numbers from the _ADR object contained
-	 * in the parent's scope.
+	 * Get the PCI device and function numbers from the _ADR object
+	 * contained in the parent's scope.
 	 */
 	status = acpi_ut_evaluate_numeric_object(METHOD_NAME__ADR,
 						 pci_device_node, &pci_value);
@@ -320,9 +320,15 @@ acpi_ev_pci_config_region_setup(acpi_handle handle,
 		pci_id->bus = ACPI_LOWORD(pci_value);
 	}
 
-	/* Complete this device's pci_id */
+	/* Complete/update the PCI ID for this device */
 
-	acpi_os_derive_pci_id(pci_root_node, region_obj->region.node, &pci_id);
+	status =
+	    acpi_hw_derive_pci_id(pci_id, pci_root_node,
+				  region_obj->region.node);
+	if (ACPI_FAILURE(status)) {
+		ACPI_FREE(pci_id);
+		return_ACPI_STATUS(status);
+	}
 
 	*region_context = pci_id;
 	return_ACPI_STATUS(AE_OK);

commit c45b5c097001480e66d4c523eb715ad317a4ef77
Author: Alexey Starikovskiy <astarikovskiy@suse.de>
Date:   Wed May 26 11:53:07 2010 +0800

    ACPICA: Performance enhancement for namespace search and access
    
    This change enhances the performance of namespace searches and
    walks by adding a backpointer to the parent in each namespace
    node. On large namespaces, this change can improve overall ACPI
    performance by up to 9X.  Adding a pointer to each namespace node
    increases the overall size of the internal namespace by about 5%,
    since each namespace entry usually consists of both a namespace
    node and an ACPI operand object.
    
    Signed-off-by: Alexey Starikovskiy <astarikovskiy@suse.de>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 2e3b0334072f..f40d271bf568 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -199,7 +199,7 @@ acpi_ev_pci_config_region_setup(acpi_handle handle,
 		return_ACPI_STATUS(status);
 	}
 
-	parent_node = acpi_ns_get_parent_node(region_obj->region.node);
+	parent_node = region_obj->region.node->parent;
 
 	/*
 	 * Get the _SEG and _BBN values from the device upon which the handler
@@ -248,7 +248,7 @@ acpi_ev_pci_config_region_setup(acpi_handle handle,
 				break;
 			}
 
-			pci_root_node = acpi_ns_get_parent_node(pci_root_node);
+			pci_root_node = pci_root_node->parent;
 		}
 
 		/* PCI root bridge not found, use namespace root node */
@@ -280,7 +280,7 @@ acpi_ev_pci_config_region_setup(acpi_handle handle,
 	 */
 	pci_device_node = region_obj->region.node;
 	while (pci_device_node && (pci_device_node->type != ACPI_TYPE_DEVICE)) {
-		pci_device_node = acpi_ns_get_parent_node(pci_device_node);
+		pci_device_node = pci_device_node->parent;
 	}
 
 	if (!pci_device_node) {
@@ -521,7 +521,7 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 		return_ACPI_STATUS(AE_NOT_EXIST);
 	}
 
-	node = acpi_ns_get_parent_node(region_obj->region.node);
+	node = region_obj->region.node->parent;
 	space_id = region_obj->region.space_id;
 
 	/* Setup defaults */
@@ -654,7 +654,7 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 
 		/* This node does not have the handler we need; Pop up one level */
 
-		node = acpi_ns_get_parent_node(node);
+		node = node->parent;
 	}
 
 	/* If we get here, there is no handler for this region */

commit 5df7e6cb42da36c7d878239bebc81907b15f3943
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 21 10:06:32 2010 +0800

    ACPICA: Remove obsolete ACPI_INTEGER (acpi_integer) type
    
    This type was introduced as the code was migrated from ACPI 1.0
    (with 32-bit AML integers) to ACPI 2.0 (with 64-bit integers). It
    is now obsolete and this change removes it from the ACPICA code
    base, replaced by u64.  The original typedef has been retained
    for now for compatibility with existing device driver code.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 86bd5a7f40d0..2e3b0334072f 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -168,7 +168,7 @@ acpi_ev_pci_config_region_setup(acpi_handle handle,
 				void *handler_context, void **region_context)
 {
 	acpi_status status = AE_OK;
-	acpi_integer pci_value;
+	u64 pci_value;
 	struct acpi_pci_id *pci_id = *region_context;
 	union acpi_operand_object *handler_obj;
 	struct acpi_namespace_node *parent_node;

commit a8357b0c95484b46944728712f8810d3b37bf588
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 22 19:07:36 2010 +0800

    ACPICA: Update all ACPICA copyrights and signons to 2010
    
    Add 2010 copyright to all module headers and signons, including
    the Linux header. This affects virtually every file in the ACPICA
    core subsystem, iASL compiler, and all utilities.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index ff168052a332..86bd5a7f40d0 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2008, Intel Corp.
+ * Copyright (C) 2000 - 2010, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit e31c32cfe52e98344dad28853c3331879f72c4b0
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Fri Dec 11 15:28:27 2009 +0800

    ACPICA: Module-level code: enable _REG execution in same scope
    
    This change enables the execution of _REG methods that appear
    in the same scope as the module-level code, in resonse to an
    operation region declaration within the module-level code.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index cf29c4953028..ff168052a332 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -575,6 +575,21 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 				handler_obj = obj_desc->thermal_zone.handler;
 				break;
 
+			case ACPI_TYPE_METHOD:
+				/*
+				 * If we are executing module level code, the original
+				 * Node's object was replaced by this Method object and we
+				 * saved the handler in the method object.
+				 *
+				 * See acpi_ns_exec_module_code
+				 */
+				if (obj_desc->method.
+				    flags & AOPOBJ_MODULE_LEVEL) {
+					handler_obj =
+					    obj_desc->method.extra.handler;
+				}
+				break;
+
 			default:
 				/* Ignore other objects */
 				break;

commit 15b8dd53f5ffaf8e2d9095c423f713423f576c0f
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jun 29 13:39:29 2009 +0800

    ACPICA: Major update for acpi_get_object_info external interface
    
    Completed a major update for the acpi_get_object_info external interface.
    Changes include:
     - Support for variable, unlimited length HID, UID, and CID strings
     - Support Processor objects the same as Devices (HID,UID,CID,ADR,STA, etc.)
     - Call the _SxW power methods on behalf of a device object
     - Determine if a device is a PCI root bridge
     - Change the ACPI_BUFFER parameter to ACPI_DEVICE_INFO.
    These changes will require an update to all callers of this interface.
    See the ACPICA Programmer Reference for details.
    
    Also, update all invocations of acpi_get_object_info interface
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 284a7becbe96..cf29c4953028 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -50,8 +50,6 @@
 ACPI_MODULE_NAME("evrgnini")
 
 /* Local prototypes */
-static u8 acpi_ev_match_pci_root_bridge(char *id);
-
 static u8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node);
 
 /*******************************************************************************
@@ -330,37 +328,6 @@ acpi_ev_pci_config_region_setup(acpi_handle handle,
 	return_ACPI_STATUS(AE_OK);
 }
 
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ev_match_pci_root_bridge
- *
- * PARAMETERS:  Id              - The HID/CID in string format
- *
- * RETURN:      TRUE if the Id is a match for a PCI/PCI-Express Root Bridge
- *
- * DESCRIPTION: Determine if the input ID is a PCI Root Bridge ID.
- *
- ******************************************************************************/
-
-static u8 acpi_ev_match_pci_root_bridge(char *id)
-{
-
-	/*
-	 * Check if this is a PCI root.
-	 * ACPI 3.0+: check for a PCI Express root also.
-	 */
-	if (!(ACPI_STRNCMP(id,
-			   PCI_ROOT_HID_STRING,
-			   sizeof(PCI_ROOT_HID_STRING))) ||
-	    !(ACPI_STRNCMP(id,
-			   PCI_EXPRESS_ROOT_HID_STRING,
-			   sizeof(PCI_EXPRESS_ROOT_HID_STRING)))) {
-		return (TRUE);
-	}
-
-	return (FALSE);
-}
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ev_is_pci_root_bridge
@@ -377,9 +344,10 @@ static u8 acpi_ev_match_pci_root_bridge(char *id)
 static u8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node)
 {
 	acpi_status status;
-	struct acpica_device_id hid;
-	struct acpi_compatible_id_list *cid;
+	struct acpica_device_id *hid;
+	struct acpica_device_id_list *cid;
 	u32 i;
+	u8 match;
 
 	/* Get the _HID and check for a PCI Root Bridge */
 
@@ -388,7 +356,10 @@ static u8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node)
 		return (FALSE);
 	}
 
-	if (acpi_ev_match_pci_root_bridge(hid.value)) {
+	match = acpi_ut_is_pci_root_bridge(hid->string);
+	ACPI_FREE(hid);
+
+	if (match) {
 		return (TRUE);
 	}
 
@@ -402,7 +373,7 @@ static u8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node)
 	/* Check all _CIDs in the returned list */
 
 	for (i = 0; i < cid->count; i++) {
-		if (acpi_ev_match_pci_root_bridge(cid->id[i].value)) {
+		if (acpi_ut_is_pci_root_bridge(cid->ids[i].string)) {
 			ACPI_FREE(cid);
 			return (TRUE);
 		}

commit d4913dc6d0c680aa106d1d80b5ad2a9325367afd
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Mar 6 10:05:18 2009 +0800

    ACPICA: Formatting update - no functional changes
    
    Split long lines, update comments.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index f3f1fb45c3dc..284a7becbe96 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -241,7 +241,8 @@ acpi_ev_pci_config_region_setup(acpi_handle handle,
 						status = AE_OK;
 					} else {
 						ACPI_EXCEPTION((AE_INFO, status,
-								"Could not install PciConfig handler for Root Bridge %4.4s",
+								"Could not install PciConfig handler "
+								"for Root Bridge %4.4s",
 								acpi_ut_get_node_name
 								(pci_root_node)));
 					}
@@ -293,9 +294,8 @@ acpi_ev_pci_config_region_setup(acpi_handle handle,
 	 * Get the PCI device and function numbers from the _ADR object contained
 	 * in the parent's scope.
 	 */
-	status =
-	    acpi_ut_evaluate_numeric_object(METHOD_NAME__ADR, pci_device_node,
-					    &pci_value);
+	status = acpi_ut_evaluate_numeric_object(METHOD_NAME__ADR,
+						 pci_device_node, &pci_value);
 
 	/*
 	 * The default is zero, and since the allocation above zeroed the data,
@@ -308,18 +308,16 @@ acpi_ev_pci_config_region_setup(acpi_handle handle,
 
 	/* The PCI segment number comes from the _SEG method */
 
-	status =
-	    acpi_ut_evaluate_numeric_object(METHOD_NAME__SEG, pci_root_node,
-					    &pci_value);
+	status = acpi_ut_evaluate_numeric_object(METHOD_NAME__SEG,
+						 pci_root_node, &pci_value);
 	if (ACPI_SUCCESS(status)) {
 		pci_id->segment = ACPI_LOWORD(pci_value);
 	}
 
 	/* The PCI bus number comes from the _BBN method */
 
-	status =
-	    acpi_ut_evaluate_numeric_object(METHOD_NAME__BBN, pci_root_node,
-					    &pci_value);
+	status = acpi_ut_evaluate_numeric_object(METHOD_NAME__BBN,
+						 pci_root_node, &pci_value);
 	if (ACPI_SUCCESS(status)) {
 		pci_id->bus = ACPI_LOWORD(pci_value);
 	}
@@ -632,8 +630,8 @@ acpi_ev_initialize_region(union acpi_operand_object *region_obj,
 								  acpi_ns_locked);
 
 					/*
-					 * Tell all users that this region is usable by running the _REG
-					 * method
+					 * Tell all users that this region is usable by
+					 * running the _REG method
 					 */
 					if (acpi_ns_locked) {
 						status =

commit e2f7a7772880458edff1b1cc5a988947229fac26
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 00:30:03 2009 -0500

    ACPICA: hide private headers
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
index 1b7f9fdbef15..f3f1fb45c3dc 100644
--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -42,9 +42,9 @@
  */
 
 #include <acpi/acpi.h>
-#include <acpi/accommon.h>
-#include <acpi/acevents.h>
-#include <acpi/acnamesp.h>
+#include "accommon.h"
+#include "acevents.h"
+#include "acnamesp.h"
 
 #define _COMPONENT          ACPI_EVENTS
 ACPI_MODULE_NAME("evrgnini")

commit 95b482a8d31116f3f5c2a5089569393234d06385
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 00:13:17 2009 -0500

    ACPICA: create acpica/ directory
    
    also, delete sleep/ and delete ACPI_CFLAGS from Makefile
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evrgnini.c b/drivers/acpi/acpica/evrgnini.c
new file mode 100644
index 000000000000..1b7f9fdbef15
--- /dev/null
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -0,0 +1,684 @@
+/******************************************************************************
+ *
+ * Module Name: evrgnini- ACPI address_space (op_region) init
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2008, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include <acpi/accommon.h>
+#include <acpi/acevents.h>
+#include <acpi/acnamesp.h>
+
+#define _COMPONENT          ACPI_EVENTS
+ACPI_MODULE_NAME("evrgnini")
+
+/* Local prototypes */
+static u8 acpi_ev_match_pci_root_bridge(char *id);
+
+static u8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_system_memory_region_setup
+ *
+ * PARAMETERS:  Handle              - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Setup a system_memory operation region
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_system_memory_region_setup(acpi_handle handle,
+				   u32 function,
+				   void *handler_context, void **region_context)
+{
+	union acpi_operand_object *region_desc =
+	    (union acpi_operand_object *)handle;
+	struct acpi_mem_space_context *local_region_context;
+
+	ACPI_FUNCTION_TRACE(ev_system_memory_region_setup);
+
+	if (function == ACPI_REGION_DEACTIVATE) {
+		if (*region_context) {
+			local_region_context =
+			    (struct acpi_mem_space_context *)*region_context;
+
+			/* Delete a cached mapping if present */
+
+			if (local_region_context->mapped_length) {
+				acpi_os_unmap_memory(local_region_context->
+						     mapped_logical_address,
+						     local_region_context->
+						     mapped_length);
+			}
+			ACPI_FREE(local_region_context);
+			*region_context = NULL;
+		}
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Create a new context */
+
+	local_region_context =
+	    ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_mem_space_context));
+	if (!(local_region_context)) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Save the region length and address for use in the handler */
+
+	local_region_context->length = region_desc->region.length;
+	local_region_context->address = region_desc->region.address;
+
+	*region_context = local_region_context;
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_io_space_region_setup
+ *
+ * PARAMETERS:  Handle              - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Setup a IO operation region
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_io_space_region_setup(acpi_handle handle,
+			      u32 function,
+			      void *handler_context, void **region_context)
+{
+	ACPI_FUNCTION_TRACE(ev_io_space_region_setup);
+
+	if (function == ACPI_REGION_DEACTIVATE) {
+		*region_context = NULL;
+	} else {
+		*region_context = handler_context;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_pci_config_region_setup
+ *
+ * PARAMETERS:  Handle              - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Setup a PCI_Config operation region
+ *
+ * MUTEX:       Assumes namespace is not locked
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_pci_config_region_setup(acpi_handle handle,
+				u32 function,
+				void *handler_context, void **region_context)
+{
+	acpi_status status = AE_OK;
+	acpi_integer pci_value;
+	struct acpi_pci_id *pci_id = *region_context;
+	union acpi_operand_object *handler_obj;
+	struct acpi_namespace_node *parent_node;
+	struct acpi_namespace_node *pci_root_node;
+	struct acpi_namespace_node *pci_device_node;
+	union acpi_operand_object *region_obj =
+	    (union acpi_operand_object *)handle;
+
+	ACPI_FUNCTION_TRACE(ev_pci_config_region_setup);
+
+	handler_obj = region_obj->region.handler;
+	if (!handler_obj) {
+		/*
+		 * No installed handler. This shouldn't happen because the dispatch
+		 * routine checks before we get here, but we check again just in case.
+		 */
+		ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+				  "Attempting to init a region %p, with no handler\n",
+				  region_obj));
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	*region_context = NULL;
+	if (function == ACPI_REGION_DEACTIVATE) {
+		if (pci_id) {
+			ACPI_FREE(pci_id);
+		}
+		return_ACPI_STATUS(status);
+	}
+
+	parent_node = acpi_ns_get_parent_node(region_obj->region.node);
+
+	/*
+	 * Get the _SEG and _BBN values from the device upon which the handler
+	 * is installed.
+	 *
+	 * We need to get the _SEG and _BBN objects relative to the PCI BUS device.
+	 * This is the device the handler has been registered to handle.
+	 */
+
+	/*
+	 * If the address_space.Node is still pointing to the root, we need
+	 * to scan upward for a PCI Root bridge and re-associate the op_region
+	 * handlers with that device.
+	 */
+	if (handler_obj->address_space.node == acpi_gbl_root_node) {
+
+		/* Start search from the parent object */
+
+		pci_root_node = parent_node;
+		while (pci_root_node != acpi_gbl_root_node) {
+
+			/* Get the _HID/_CID in order to detect a root_bridge */
+
+			if (acpi_ev_is_pci_root_bridge(pci_root_node)) {
+
+				/* Install a handler for this PCI root bridge */
+
+				status =
+				    acpi_install_address_space_handler((acpi_handle) pci_root_node, ACPI_ADR_SPACE_PCI_CONFIG, ACPI_DEFAULT_HANDLER, NULL, NULL);
+				if (ACPI_FAILURE(status)) {
+					if (status == AE_SAME_HANDLER) {
+						/*
+						 * It is OK if the handler is already installed on the
+						 * root bridge. Still need to return a context object
+						 * for the new PCI_Config operation region, however.
+						 */
+						status = AE_OK;
+					} else {
+						ACPI_EXCEPTION((AE_INFO, status,
+								"Could not install PciConfig handler for Root Bridge %4.4s",
+								acpi_ut_get_node_name
+								(pci_root_node)));
+					}
+				}
+				break;
+			}
+
+			pci_root_node = acpi_ns_get_parent_node(pci_root_node);
+		}
+
+		/* PCI root bridge not found, use namespace root node */
+	} else {
+		pci_root_node = handler_obj->address_space.node;
+	}
+
+	/*
+	 * If this region is now initialized, we are done.
+	 * (install_address_space_handler could have initialized it)
+	 */
+	if (region_obj->region.flags & AOPOBJ_SETUP_COMPLETE) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Region is still not initialized. Create a new context */
+
+	pci_id = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_pci_id));
+	if (!pci_id) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/*
+	 * For PCI_Config space access, we need the segment, bus, device and
+	 * function numbers. Acquire them here.
+	 *
+	 * Find the parent device object. (This allows the operation region to be
+	 * within a subscope under the device, such as a control method.)
+	 */
+	pci_device_node = region_obj->region.node;
+	while (pci_device_node && (pci_device_node->type != ACPI_TYPE_DEVICE)) {
+		pci_device_node = acpi_ns_get_parent_node(pci_device_node);
+	}
+
+	if (!pci_device_node) {
+		ACPI_FREE(pci_id);
+		return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+	}
+
+	/*
+	 * Get the PCI device and function numbers from the _ADR object contained
+	 * in the parent's scope.
+	 */
+	status =
+	    acpi_ut_evaluate_numeric_object(METHOD_NAME__ADR, pci_device_node,
+					    &pci_value);
+
+	/*
+	 * The default is zero, and since the allocation above zeroed the data,
+	 * just do nothing on failure.
+	 */
+	if (ACPI_SUCCESS(status)) {
+		pci_id->device = ACPI_HIWORD(ACPI_LODWORD(pci_value));
+		pci_id->function = ACPI_LOWORD(ACPI_LODWORD(pci_value));
+	}
+
+	/* The PCI segment number comes from the _SEG method */
+
+	status =
+	    acpi_ut_evaluate_numeric_object(METHOD_NAME__SEG, pci_root_node,
+					    &pci_value);
+	if (ACPI_SUCCESS(status)) {
+		pci_id->segment = ACPI_LOWORD(pci_value);
+	}
+
+	/* The PCI bus number comes from the _BBN method */
+
+	status =
+	    acpi_ut_evaluate_numeric_object(METHOD_NAME__BBN, pci_root_node,
+					    &pci_value);
+	if (ACPI_SUCCESS(status)) {
+		pci_id->bus = ACPI_LOWORD(pci_value);
+	}
+
+	/* Complete this device's pci_id */
+
+	acpi_os_derive_pci_id(pci_root_node, region_obj->region.node, &pci_id);
+
+	*region_context = pci_id;
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_match_pci_root_bridge
+ *
+ * PARAMETERS:  Id              - The HID/CID in string format
+ *
+ * RETURN:      TRUE if the Id is a match for a PCI/PCI-Express Root Bridge
+ *
+ * DESCRIPTION: Determine if the input ID is a PCI Root Bridge ID.
+ *
+ ******************************************************************************/
+
+static u8 acpi_ev_match_pci_root_bridge(char *id)
+{
+
+	/*
+	 * Check if this is a PCI root.
+	 * ACPI 3.0+: check for a PCI Express root also.
+	 */
+	if (!(ACPI_STRNCMP(id,
+			   PCI_ROOT_HID_STRING,
+			   sizeof(PCI_ROOT_HID_STRING))) ||
+	    !(ACPI_STRNCMP(id,
+			   PCI_EXPRESS_ROOT_HID_STRING,
+			   sizeof(PCI_EXPRESS_ROOT_HID_STRING)))) {
+		return (TRUE);
+	}
+
+	return (FALSE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_is_pci_root_bridge
+ *
+ * PARAMETERS:  Node            - Device node being examined
+ *
+ * RETURN:      TRUE if device is a PCI/PCI-Express Root Bridge
+ *
+ * DESCRIPTION: Determine if the input device represents a PCI Root Bridge by
+ *              examining the _HID and _CID for the device.
+ *
+ ******************************************************************************/
+
+static u8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node)
+{
+	acpi_status status;
+	struct acpica_device_id hid;
+	struct acpi_compatible_id_list *cid;
+	u32 i;
+
+	/* Get the _HID and check for a PCI Root Bridge */
+
+	status = acpi_ut_execute_HID(node, &hid);
+	if (ACPI_FAILURE(status)) {
+		return (FALSE);
+	}
+
+	if (acpi_ev_match_pci_root_bridge(hid.value)) {
+		return (TRUE);
+	}
+
+	/* The _HID did not match. Get the _CID and check for a PCI Root Bridge */
+
+	status = acpi_ut_execute_CID(node, &cid);
+	if (ACPI_FAILURE(status)) {
+		return (FALSE);
+	}
+
+	/* Check all _CIDs in the returned list */
+
+	for (i = 0; i < cid->count; i++) {
+		if (acpi_ev_match_pci_root_bridge(cid->id[i].value)) {
+			ACPI_FREE(cid);
+			return (TRUE);
+		}
+	}
+
+	ACPI_FREE(cid);
+	return (FALSE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_pci_bar_region_setup
+ *
+ * PARAMETERS:  Handle              - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Setup a pci_bAR operation region
+ *
+ * MUTEX:       Assumes namespace is not locked
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_pci_bar_region_setup(acpi_handle handle,
+			     u32 function,
+			     void *handler_context, void **region_context)
+{
+	ACPI_FUNCTION_TRACE(ev_pci_bar_region_setup);
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_cmos_region_setup
+ *
+ * PARAMETERS:  Handle              - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Setup a CMOS operation region
+ *
+ * MUTEX:       Assumes namespace is not locked
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_cmos_region_setup(acpi_handle handle,
+			  u32 function,
+			  void *handler_context, void **region_context)
+{
+	ACPI_FUNCTION_TRACE(ev_cmos_region_setup);
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_default_region_setup
+ *
+ * PARAMETERS:  Handle              - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Default region initialization
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_default_region_setup(acpi_handle handle,
+			     u32 function,
+			     void *handler_context, void **region_context)
+{
+	ACPI_FUNCTION_TRACE(ev_default_region_setup);
+
+	if (function == ACPI_REGION_DEACTIVATE) {
+		*region_context = NULL;
+	} else {
+		*region_context = handler_context;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_initialize_region
+ *
+ * PARAMETERS:  region_obj      - Region we are initializing
+ *              acpi_ns_locked  - Is namespace locked?
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initializes the region, finds any _REG methods and saves them
+ *              for execution at a later time
+ *
+ *              Get the appropriate address space handler for a newly
+ *              created region.
+ *
+ *              This also performs address space specific initialization. For
+ *              example, PCI regions must have an _ADR object that contains
+ *              a PCI address in the scope of the definition. This address is
+ *              required to perform an access to PCI config space.
+ *
+ * MUTEX:       Interpreter should be unlocked, because we may run the _REG
+ *              method for this region.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_initialize_region(union acpi_operand_object *region_obj,
+			  u8 acpi_ns_locked)
+{
+	union acpi_operand_object *handler_obj;
+	union acpi_operand_object *obj_desc;
+	acpi_adr_space_type space_id;
+	struct acpi_namespace_node *node;
+	acpi_status status;
+	struct acpi_namespace_node *method_node;
+	acpi_name *reg_name_ptr = (acpi_name *) METHOD_NAME__REG;
+	union acpi_operand_object *region_obj2;
+
+	ACPI_FUNCTION_TRACE_U32(ev_initialize_region, acpi_ns_locked);
+
+	if (!region_obj) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (region_obj->common.flags & AOPOBJ_OBJECT_INITIALIZED) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	region_obj2 = acpi_ns_get_secondary_object(region_obj);
+	if (!region_obj2) {
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	node = acpi_ns_get_parent_node(region_obj->region.node);
+	space_id = region_obj->region.space_id;
+
+	/* Setup defaults */
+
+	region_obj->region.handler = NULL;
+	region_obj2->extra.method_REG = NULL;
+	region_obj->common.flags &= ~(AOPOBJ_SETUP_COMPLETE);
+	region_obj->common.flags |= AOPOBJ_OBJECT_INITIALIZED;
+
+	/* Find any "_REG" method associated with this region definition */
+
+	status =
+	    acpi_ns_search_one_scope(*reg_name_ptr, node, ACPI_TYPE_METHOD,
+				     &method_node);
+	if (ACPI_SUCCESS(status)) {
+		/*
+		 * The _REG method is optional and there can be only one per region
+		 * definition. This will be executed when the handler is attached
+		 * or removed
+		 */
+		region_obj2->extra.method_REG = method_node;
+	}
+
+	/*
+	 * The following loop depends upon the root Node having no parent
+	 * ie: acpi_gbl_root_node->parent_entry being set to NULL
+	 */
+	while (node) {
+
+		/* Check to see if a handler exists */
+
+		handler_obj = NULL;
+		obj_desc = acpi_ns_get_attached_object(node);
+		if (obj_desc) {
+
+			/* Can only be a handler if the object exists */
+
+			switch (node->type) {
+			case ACPI_TYPE_DEVICE:
+
+				handler_obj = obj_desc->device.handler;
+				break;
+
+			case ACPI_TYPE_PROCESSOR:
+
+				handler_obj = obj_desc->processor.handler;
+				break;
+
+			case ACPI_TYPE_THERMAL:
+
+				handler_obj = obj_desc->thermal_zone.handler;
+				break;
+
+			default:
+				/* Ignore other objects */
+				break;
+			}
+
+			while (handler_obj) {
+
+				/* Is this handler of the correct type? */
+
+				if (handler_obj->address_space.space_id ==
+				    space_id) {
+
+					/* Found correct handler */
+
+					ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+							  "Found handler %p for region %p in obj %p\n",
+							  handler_obj,
+							  region_obj,
+							  obj_desc));
+
+					status =
+					    acpi_ev_attach_region(handler_obj,
+								  region_obj,
+								  acpi_ns_locked);
+
+					/*
+					 * Tell all users that this region is usable by running the _REG
+					 * method
+					 */
+					if (acpi_ns_locked) {
+						status =
+						    acpi_ut_release_mutex
+						    (ACPI_MTX_NAMESPACE);
+						if (ACPI_FAILURE(status)) {
+							return_ACPI_STATUS
+							    (status);
+						}
+					}
+
+					status =
+					    acpi_ev_execute_reg_method
+					    (region_obj, 1);
+
+					if (acpi_ns_locked) {
+						status =
+						    acpi_ut_acquire_mutex
+						    (ACPI_MTX_NAMESPACE);
+						if (ACPI_FAILURE(status)) {
+							return_ACPI_STATUS
+							    (status);
+						}
+					}
+
+					return_ACPI_STATUS(AE_OK);
+				}
+
+				/* Try next handler in the list */
+
+				handler_obj = handler_obj->address_space.next;
+			}
+		}
+
+		/* This node does not have the handler we need; Pop up one level */
+
+		node = acpi_ns_get_parent_node(node);
+	}
+
+	/* If we get here, there is no handler for this region */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+			  "No handler for RegionType %s(%X) (RegionObj %p)\n",
+			  acpi_ut_get_region_name(space_id), space_id,
+			  region_obj));
+
+	return_ACPI_STATUS(AE_NOT_EXIST);
+}
