commit 800ba7c5eaaa734e4bd66bf0441fc200bbcdca54
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 10 11:31:49 2020 -0800

    ACPICA: All acpica: Update copyrights to 2020 Including tool signons.
    
    ACPICA commit 8b9c69d0984067051ffbe8526f871448ead6a26b
    
    Link: https://github.com/acpica/acpica/commit/8b9c69d0
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Kaneda <erik.kaneda@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index e62c7897fdf1..3b40db4ad9f3 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -3,7 +3,7 @@
  *
  * Module Name: psargs - Parse AML opcode arguments
  *
- * Copyright (C) 2000 - 2019, Intel Corp.
+ * Copyright (C) 2000 - 2020, Intel Corp.
  *
  *****************************************************************************/
 

commit 3278675567dfb901d831d46849c386a4f932905e
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Apr 8 13:42:25 2019 -0700

    ACPICA: Rename nameseg length macro/define for clarity
    
    ACPICA commit 24870bd9e73d71e2a1ff0a1e94519f8f8409e57d
    
    ACPI_NAME_SIZE changed to ACPI_NAMESEG_SIZE
    This clarifies that this is the length of an individual
    nameseg, not the length of a generic namestring/namepath.
    Improves understanding of the code.
    
    Link: https://github.com/acpica/acpica/commit/24870bd9
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 9d9d442cd999..e62c7897fdf1 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -150,21 +150,21 @@ char *acpi_ps_get_next_namestring(struct acpi_parse_state *parser_state)
 
 		/* Two name segments */
 
-		end += 1 + (2 * ACPI_NAME_SIZE);
+		end += 1 + (2 * ACPI_NAMESEG_SIZE);
 		break;
 
 	case AML_MULTI_NAME_PREFIX:
 
 		/* Multiple name segments, 4 chars each, count in next byte */
 
-		end += 2 + (*(end + 1) * ACPI_NAME_SIZE);
+		end += 2 + (*(end + 1) * ACPI_NAMESEG_SIZE);
 		break;
 
 	default:
 
 		/* Single name segment */
 
-		end += ACPI_NAME_SIZE;
+		end += ACPI_NAMESEG_SIZE;
 		break;
 	}
 
@@ -522,7 +522,7 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 
 		ACPI_MOVE_32_TO_32(&name, parser_state->aml);
 		acpi_ps_set_name(field, name);
-		parser_state->aml += ACPI_NAME_SIZE;
+		parser_state->aml += ACPI_NAMESEG_SIZE;
 
 		ASL_CV_CAPTURE_COMMENTS_ONLY(parser_state);
 

commit 840c02ca2215af648c781ae680d93d8aecd083b7
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jan 14 09:55:25 2019 -0800

    ACPICA: All acpica: Update copyrights to 2019
    
    ACPICA commit 62f4f98e941d86e41969bf2ab5a93b8dc94dc49e
    
    The update includes userspace tool signons.
    
    Link: https://github.com/acpica/acpica/commit/62f4f98e
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 176d28d60125..9d9d442cd999 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -3,7 +3,7 @@
  *
  * Module Name: psargs - Parse AML opcode arguments
  *
- * Copyright (C) 2000 - 2018, Intel Corp.
+ * Copyright (C) 2000 - 2019, Intel Corp.
  *
  *****************************************************************************/
 

commit 95857638889aeea1b10a16b55041adf3e3ab84c4
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Wed Mar 14 16:13:07 2018 -0700

    ACPICA: adding SPDX headers
    
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 5ca895da3b10..176d28d60125 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -1,45 +1,11 @@
+// SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
 /******************************************************************************
  *
  * Module Name: psargs - Parse AML opcode arguments
  *
- *****************************************************************************/
-
-/*
  * Copyright (C) 2000 - 2018, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
+ *
+ *****************************************************************************/
 
 #include <acpi/acpi.h>
 #include "accommon.h"

commit 1c29c372b2d1d2415601041532745ce859f24126
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Mar 14 16:13:01 2018 -0700

    ACPICA: Fix memory leak on unusual memory leak
    
    Fixes a single-object memory leak on a store-to-reference method
    invocation. ACPICA BZ 1439.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index dbc51bc5fdd6..5ca895da3b10 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -890,6 +890,10 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 						      ACPI_POSSIBLE_METHOD_CALL);
 
 			if (arg->common.aml_opcode == AML_INT_METHODCALL_OP) {
+
+				/* Free method call op and corresponding namestring sub-ob */
+
+				acpi_ps_free_op(arg->common.value.arg);
 				acpi_ps_free_op(arg);
 				arg = NULL;
 				walk_state->arg_count = 1;

commit da6f8320d58623eae9b6fa2f09b1b4f60a772ce9
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 4 10:06:38 2018 -0800

    ACPICA: All acpica: Update copyrights to 2018
    
    including tool signons.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 171e2faa7c50..dbc51bc5fdd6 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2017, Intel Corp.
+ * Copyright (C) 2000 - 2018, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 16ccf829201cef23edaa5524f3f91e05861c4455
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Nov 17 15:42:22 2017 -0800

    ACPICA: Enhance error messages from namespace create/lookup operations
    
    ACPICA commit b09c8d7bdc8c5a3db0a8d38bfd6182c023885e12
    
    1) Emit the full pathname (scope+name) instead of just the name
    2) For AE_ALREADY_EXISTS and AE_NOT_FOUND, use the "firmware error"
    string to point to the true problem.
    
    Link: https://github.com/acpica/acpica/commit/b09c8d7b
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index eb9dfaca555f..171e2faa7c50 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -361,7 +361,7 @@ acpi_ps_get_next_namepath(struct acpi_walk_state *walk_state,
 	/* Final exception check (may have been changed from code above) */
 
 	if (ACPI_FAILURE(status)) {
-		ACPI_ERROR_NAMESPACE(path, status);
+		ACPI_ERROR_NAMESPACE(walk_state->scope_info, path, status);
 
 		if ((walk_state->parse_flags & ACPI_PARSE_MODE_MASK) ==
 		    ACPI_PARSE_EXECUTE) {

commit 9cf7adeca1f307b578021f227119495eecb1a510
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Apr 28 08:53:22 2017 +0800

    ACPICA: iasl: add ASL conversion tool
    
    ACPICA commit c04d310039d3e0ed1cb62876fe7e596fbc75ab01
    ACPICA commit a65c1df7e6b4bad8e37df822018c40c6c446add9
    
    The key feature of this utility is that the original comments within
    the input ASL files are preserved during the conversion process, and
    included within the converted ASL+ file -- thus creating a transparent
    conversion of existing ASL files to ASL+ (ASL 2.0)
    
    This patch is an automatic generation of the ASL converter commit,
    Linux kernel isn't affected by the functionality provided in this
    commit, but requires the linuxized changes to support future ACPICA
    release automation.
    
    Link: https://github.com/acpica/acpica/commit/c04d3100
    Link: https://github.com/acpica/acpica/commit/a65c1df7
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Jung-uk Kim <jkim@FreeBSD.org>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index cda1e151dbc7..eb9dfaca555f 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -47,6 +47,7 @@
 #include "amlcode.h"
 #include "acnamesp.h"
 #include "acdispat.h"
+#include "acconvert.h"
 
 #define _COMPONENT          ACPI_PARSER
 ACPI_MODULE_NAME("psargs")
@@ -502,6 +503,7 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 
 	ACPI_FUNCTION_TRACE(ps_get_next_field);
 
+	ASL_CV_CAPTURE_COMMENTS_ONLY(parser_state);
 	aml = parser_state->aml;
 
 	/* Determine field type */
@@ -546,6 +548,7 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 
 	/* Decode the field type */
 
+	ASL_CV_CAPTURE_COMMENTS_ONLY(parser_state);
 	switch (opcode) {
 	case AML_INT_NAMEDFIELD_OP:
 
@@ -555,6 +558,22 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 		acpi_ps_set_name(field, name);
 		parser_state->aml += ACPI_NAME_SIZE;
 
+		ASL_CV_CAPTURE_COMMENTS_ONLY(parser_state);
+
+#ifdef ACPI_ASL_COMPILER
+		/*
+		 * Because the package length isn't represented as a parse tree object,
+		 * take comments surrounding this and add to the previously created
+		 * parse node.
+		 */
+		if (field->common.inline_comment) {
+			field->common.name_comment =
+			    field->common.inline_comment;
+		}
+		field->common.inline_comment = acpi_gbl_current_inline_comment;
+		acpi_gbl_current_inline_comment = NULL;
+#endif
+
 		/* Get the length which is encoded as a package length */
 
 		field->common.value.size =
@@ -609,11 +628,13 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 		if (ACPI_GET8(parser_state->aml) == AML_BUFFER_OP) {
 			parser_state->aml++;
 
+			ASL_CV_CAPTURE_COMMENTS_ONLY(parser_state);
 			pkg_end = parser_state->aml;
 			pkg_length =
 			    acpi_ps_get_next_package_length(parser_state);
 			pkg_end += pkg_length;
 
+			ASL_CV_CAPTURE_COMMENTS_ONLY(parser_state);
 			if (parser_state->aml < pkg_end) {
 
 				/* Non-empty list */
@@ -630,6 +651,7 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 				opcode = ACPI_GET8(parser_state->aml);
 				parser_state->aml++;
 
+				ASL_CV_CAPTURE_COMMENTS_ONLY(parser_state);
 				switch (opcode) {
 				case AML_BYTE_OP:	/* AML_BYTEDATA_ARG */
 
@@ -660,6 +682,7 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 
 				/* Fill in bytelist data */
 
+				ASL_CV_CAPTURE_COMMENTS_ONLY(parser_state);
 				arg->named.value.size = buffer_length;
 				arg->named.data = parser_state->aml;
 			}

commit 9ff5a21a50301ef16aeb2e3937867de7eb0af030
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Apr 26 16:18:40 2017 +0800

    ACPICA: Cleanup AML opcode definitions, no functional change
    
    ACPICA commit ec969d38fef3be95358e65f0dd071b5f2c045b6b
    
    This change is a cleanup and further standardization of the AML
    opcode defines in amlcode.h
    
    Improves the readability and maintainability of the source code.
    
    Link: https://github.com/acpica/acpica/commit/ec969d38
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 05b62ad44c3e..cda1e151dbc7 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -186,7 +186,7 @@ char *acpi_ps_get_next_namestring(struct acpi_parse_state *parser_state)
 		end += 1 + (2 * ACPI_NAME_SIZE);
 		break;
 
-	case AML_MULTI_NAME_PREFIX_OP:
+	case AML_MULTI_NAME_PREFIX:
 
 		/* Multiple name segments, 4 chars each, count in next byte */
 
@@ -339,7 +339,7 @@ acpi_ps_get_next_namepath(struct acpi_walk_state *walk_state,
 		/* 2) not_found during a cond_ref_of(x) is ok by definition */
 
 		else if (walk_state->op->common.aml_opcode ==
-			 AML_COND_REF_OF_OP) {
+			 AML_CONDITIONAL_REF_OF_OP) {
 			status = AE_OK;
 		}
 
@@ -352,7 +352,7 @@ acpi_ps_get_next_namepath(struct acpi_walk_state *walk_state,
 			 ((arg->common.parent->common.aml_opcode ==
 			   AML_PACKAGE_OP)
 			  || (arg->common.parent->common.aml_opcode ==
-			      AML_VAR_PACKAGE_OP))) {
+			      AML_VARIABLE_PACKAGE_OP))) {
 			status = AE_OK;
 		}
 	}

commit 7735ca0eb4ebd6d47fdad40602d0ba7593219f8c
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Feb 8 11:00:08 2017 +0800

    ACPICA: Source tree: Update copyright notices to 2017
    
    ACPICA commit 16577e5265923f4999b4d2c0addb2343b18135e1
    
    Affects all files.
    
    Link: https://github.com/acpica/acpica/commit/16577e52
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index b0e55a7d4bdf..05b62ad44c3e 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2016, Intel Corp.
+ * Copyright (C) 2000 - 2017, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 9a947291374dbf377c4110f2387f3386d88cf5b0
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Dec 28 15:29:49 2016 +0800

    ACPICA: Fix a problem with recent extra support for control method invocations
    
    ACPICA commit b7dae343fbb8c392999a66f5e08be5744a5d07e2
    
    This change fixes a problem with the recent support that enables
    control method invocations as Target operands to many ASL
    operators. Eliminates errors similar to:
    
    Needed type [Reference], found [Processor]
    
    Link: https://github.com/acpica/acpica/commit/b7dae343
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 4e1065e84da8..b0e55a7d4bdf 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -269,6 +269,20 @@ acpi_ps_get_next_namepath(struct acpi_walk_state *walk_state,
 	 */
 	if (ACPI_SUCCESS(status) &&
 	    possible_method_call && (node->type == ACPI_TYPE_METHOD)) {
+		if ((GET_CURRENT_ARG_TYPE(walk_state->arg_types) ==
+		     ARGP_SUPERNAME)
+		    || (GET_CURRENT_ARG_TYPE(walk_state->arg_types) ==
+			ARGP_TARGET)) {
+			/*
+			 * acpi_ps_get_next_namestring has increased the AML pointer past
+			 * the method invocation namestring, so we need to restore the
+			 * saved AML pointer back to the original method invocation
+			 * namestring.
+			 */
+			walk_state->parser_state.aml = start;
+			walk_state->arg_count = 1;
+			acpi_ps_init_op(arg, AML_INT_METHODCALL_OP);
+		}
 
 		/* This name is actually a control method invocation */
 
@@ -833,7 +847,10 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 				  arg_type));
 
 		subop = acpi_ps_peek_opcode(parser_state);
-		if (subop == 0) {
+		if (subop == 0 ||
+		    acpi_ps_is_leading_char(subop) ||
+		    ACPI_IS_ROOT_PREFIX(subop) ||
+		    ACPI_IS_PARENT_PREFIX(subop)) {
 
 			/* NULL target (zero). Convert to a NULL namepath */
 
@@ -848,6 +865,12 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 			    acpi_ps_get_next_namepath(walk_state, parser_state,
 						      arg,
 						      ACPI_POSSIBLE_METHOD_CALL);
+
+			if (arg->common.aml_opcode == AML_INT_METHODCALL_OP) {
+				acpi_ps_free_op(arg);
+				arg = NULL;
+				walk_state->arg_count = 1;
+			}
 		} else {
 			/* Single complex argument, nothing returned */
 

commit ce87e09dd88c61f9088768a7708828423549725c
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Dec 28 15:29:43 2016 +0800

    ACPICA: Parser: Allow method invocations as target operands
    
    ACPICA commit a6cca7a4786cdbfd29cea67e84b5b01a8ae6ff1c
    
    Method invocations as target operands are allowed as target
    operands in the ASL grammar. This change implements support
    for this. Method must return a reference for this to work
    properly at runtime, however.
    
    Link: https://github.com/acpica/acpica/commit/a6cca7a4
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index c29c930ffa08..4e1065e84da8 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -269,23 +269,13 @@ acpi_ps_get_next_namepath(struct acpi_walk_state *walk_state,
 	 */
 	if (ACPI_SUCCESS(status) &&
 	    possible_method_call && (node->type == ACPI_TYPE_METHOD)) {
-		if (walk_state->opcode == AML_UNLOAD_OP) {
-			/*
-			 * acpi_ps_get_next_namestring has increased the AML pointer,
-			 * so we need to restore the saved AML pointer for method call.
-			 */
-			walk_state->parser_state.aml = start;
-			walk_state->arg_count = 1;
-			acpi_ps_init_op(arg, AML_INT_METHODCALL_OP);
-			return_ACPI_STATUS(AE_OK);
-		}
 
 		/* This name is actually a control method invocation */
 
 		method_desc = acpi_ns_get_attached_object(node);
 		ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
-				  "Control Method - %p Desc %p Path=%p\n", node,
-				  method_desc, path));
+				  "Control Method invocation %4.4s - %p Desc %p Path=%p\n",
+				  node->name.ascii, node, method_desc, path));
 
 		name_op = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP, start);
 		if (!name_op) {
@@ -719,6 +709,10 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 
 	ACPI_FUNCTION_TRACE_PTR(ps_get_next_arg, parser_state);
 
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+			  "Expected argument type ARGP: %s (%2.2X)\n",
+			  acpi_ut_get_argument_type_name(arg_type), arg_type));
+
 	switch (arg_type) {
 	case ARGP_BYTEDATA:
 	case ARGP_WORDDATA:
@@ -796,11 +790,14 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 		}
 		break;
 
-	case ARGP_TARGET:
-	case ARGP_SUPERNAME:
 	case ARGP_SIMPLENAME:
 	case ARGP_NAME_OR_REF:
 
+		ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+				  "**** SimpleName/NameOrRef: %s (%2.2X)\n",
+				  acpi_ut_get_argument_type_name(arg_type),
+				  arg_type));
+
 		subop = acpi_ps_peek_opcode(parser_state);
 		if (subop == 0 ||
 		    acpi_ps_is_leading_char(subop) ||
@@ -816,29 +813,41 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 				return_ACPI_STATUS(AE_NO_MEMORY);
 			}
 
-			/* To support super_name arg of Unload */
-
-			if (walk_state->opcode == AML_UNLOAD_OP) {
-				status =
-				    acpi_ps_get_next_namepath(walk_state,
-							      parser_state, arg,
-							      ACPI_POSSIBLE_METHOD_CALL);
-
-				/*
-				 * If the super_name argument is a method call, we have
-				 * already restored the AML pointer, just free this Arg
-				 */
-				if (arg->common.aml_opcode ==
-				    AML_INT_METHODCALL_OP) {
-					acpi_ps_free_op(arg);
-					arg = NULL;
-				}
-			} else {
-				status =
-				    acpi_ps_get_next_namepath(walk_state,
-							      parser_state, arg,
-							      ACPI_NOT_METHOD_CALL);
+			status =
+			    acpi_ps_get_next_namepath(walk_state, parser_state,
+						      arg,
+						      ACPI_NOT_METHOD_CALL);
+		} else {
+			/* Single complex argument, nothing returned */
+
+			walk_state->arg_count = 1;
+		}
+		break;
+
+	case ARGP_TARGET:
+	case ARGP_SUPERNAME:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+				  "**** Target/Supername: %s (%2.2X)\n",
+				  acpi_ut_get_argument_type_name(arg_type),
+				  arg_type));
+
+		subop = acpi_ps_peek_opcode(parser_state);
+		if (subop == 0) {
+
+			/* NULL target (zero). Convert to a NULL namepath */
+
+			arg =
+			    acpi_ps_alloc_op(AML_INT_NAMEPATH_OP,
+					     parser_state->aml);
+			if (!arg) {
+				return_ACPI_STATUS(AE_NO_MEMORY);
 			}
+
+			status =
+			    acpi_ps_get_next_namepath(walk_state, parser_state,
+						      arg,
+						      ACPI_POSSIBLE_METHOD_CALL);
 		} else {
 			/* Single complex argument, nothing returned */
 
@@ -849,6 +858,11 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 	case ARGP_DATAOBJ:
 	case ARGP_TERMARG:
 
+		ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+				  "**** TermArg/DataObj: %s (%2.2X)\n",
+				  acpi_ut_get_argument_type_name(arg_type),
+				  arg_type));
+
 		/* Single complex argument, nothing returned */
 
 		walk_state->arg_count = 1;

commit f5c1e1c5a652e4b43eb9b571577ef72731f3fa8b
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu May 5 12:57:53 2016 +0800

    ACPICA: Divergence: remove unwanted spaces for typedef
    
    ACPICA commit b2294cae776f5a66a7697414b21949d307e6856f
    
    This patch removes unwanted spaces for typedef. This solution doesn't cover
    function types.
    
    Note that the linuxize result of this commit is very giant and should have
    many conflicts against the current Linux upstream. Thus it is required to
    modify the linuxize result of this commit and the commits around it
    manually in order to have them merged to the Linux upstream. Since this is
    very costy, we should do this only once, and if we can't ensure to do this
    only once, we need to revert the Linux code to the wrong indentation result
    before merging the linuxize result of this commit. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/b2294cae
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index d48cbed342c1..c29c930ffa08 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -87,7 +87,7 @@ acpi_ps_get_next_package_length(struct acpi_parse_state *parser_state)
 	 * used to encode the package length, either 0,1,2, or 3
 	 */
 	byte_count = (aml[0] >> 6);
-	parser_state->aml += ((acpi_size) byte_count + 1);
+	parser_state->aml += ((acpi_size)byte_count + 1);
 
 	/* Get bytes 3, 2, 1 as needed */
 

commit 0dda8851a88d6c9d6389f1caf69627154c39aceb
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Feb 19 14:17:36 2016 +0800

    ACPICA: Revert "Parser: Fix for SuperName method invocation"
    
    ACPICA commit eade8f78f2aa21e8eabc3380a5728db47273bcf1
    
    Revert commit ae90fbf562d7 (ACPICA: Parser: Fix for SuperName method
    invocation).
    
    Support for method invocations as part of super_name will be
    removed from the ACPI specification, since no AML interpreter
    supports it.
    
    Fixes: ae90fbf562d7 (ACPICA: Parser: Fix for SuperName method invocation)
    Link: https://github.com/acpica/acpica/commit/eade8f78
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 305218539df2..d48cbed342c1 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -269,8 +269,7 @@ acpi_ps_get_next_namepath(struct acpi_walk_state *walk_state,
 	 */
 	if (ACPI_SUCCESS(status) &&
 	    possible_method_call && (node->type == ACPI_TYPE_METHOD)) {
-		if (GET_CURRENT_ARG_TYPE(walk_state->arg_types) ==
-		    ARGP_SUPERNAME) {
+		if (walk_state->opcode == AML_UNLOAD_OP) {
 			/*
 			 * acpi_ps_get_next_namestring has increased the AML pointer,
 			 * so we need to restore the saved AML pointer for method call.
@@ -697,7 +696,7 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
  *
  * PARAMETERS:  walk_state          - Current state
  *              parser_state        - Current parser state object
- *              arg_type            - The parser argument type (ARGP_*)
+ *              arg_type            - The argument type (AML_*_ARG)
  *              return_arg          - Where the next arg is returned
  *
  * RETURN:      Status, and an op object containing the next argument.
@@ -817,9 +816,9 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 				return_ACPI_STATUS(AE_NO_MEMORY);
 			}
 
-			/* super_name allows argument to be a method call */
+			/* To support super_name arg of Unload */
 
-			if (arg_type == ARGP_SUPERNAME) {
+			if (walk_state->opcode == AML_UNLOAD_OP) {
 				status =
 				    acpi_ps_get_next_namepath(walk_state,
 							      parser_state, arg,

commit c8100dc4643d80a94f074dfc8a2af3d3d327b7aa
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 15 08:17:03 2016 +0800

    ACPICA: Additional 2016 copyright changes
    
    All tool/utility signons.
    Dual-license module header.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index f3bcfa20b0ae..305218539df2 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2015, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit cca7a6ea0bcf20548369e73817eeb83118bc5604
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Dec 29 14:00:21 2015 +0800

    ACPICA: Update parameter type for ObjectType operator
    
    ACPICA commit 67953304a34944548f2fa53a4b0786a5db0ca2ea
    
    The grammar for this operator changed in ACPI 5.0A, but it was
    not necessary to update the interpreter/parser until now.
    
    The UserTerm (method invocation) element was removed. Previously
    a SuperName, the lone argument now requires a new ARGP_ type.
    
    Link: https://github.com/acpica/acpica/commit/67953304
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index f84e54661ba7..f3bcfa20b0ae 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -800,6 +800,7 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 	case ARGP_TARGET:
 	case ARGP_SUPERNAME:
 	case ARGP_SIMPLENAME:
+	case ARGP_NAME_OR_REF:
 
 		subop = acpi_ps_peek_opcode(parser_state);
 		if (subop == 0 ||
@@ -825,8 +826,8 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 							      ACPI_POSSIBLE_METHOD_CALL);
 
 				/*
-				 * If the super_name arg of Unload is a method call,
-				 * we have restored the AML pointer, just free this Arg
+				 * If the super_name argument is a method call, we have
+				 * already restored the AML pointer, just free this Arg
 				 */
 				if (arg->common.aml_opcode ==
 				    AML_INT_METHODCALL_OP) {

commit ae90fbf562d733a392c7a0ffefe1e09b5a31c99c
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Dec 29 14:00:14 2015 +0800

    ACPICA: Parser: Fix for SuperName method invocation
    
    ACPICA commit 4b86d1046d06e462dae83ebcd5a66cc132a08f8f
    
    SuperName parameters that are in fact control method invocations were
    not handled correctly by the parser. This change fixes the problem
    by identifying these properly as method invocations. This affects
    about 14 different ASL operators that contain SuperName parameters.
    ACPICA BZ 1002.
    
    Link: https://github.com/acpica/acpica/commit/4b86d104
    Link: https://bugs.acpica.org/show_bug.cgi?id=1002
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 0fdb7fc4824a..f84e54661ba7 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -269,7 +269,8 @@ acpi_ps_get_next_namepath(struct acpi_walk_state *walk_state,
 	 */
 	if (ACPI_SUCCESS(status) &&
 	    possible_method_call && (node->type == ACPI_TYPE_METHOD)) {
-		if (walk_state->opcode == AML_UNLOAD_OP) {
+		if (GET_CURRENT_ARG_TYPE(walk_state->arg_types) ==
+		    ARGP_SUPERNAME) {
 			/*
 			 * acpi_ps_get_next_namestring has increased the AML pointer,
 			 * so we need to restore the saved AML pointer for method call.
@@ -696,7 +697,7 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
  *
  * PARAMETERS:  walk_state          - Current state
  *              parser_state        - Current parser state object
- *              arg_type            - The argument type (AML_*_ARG)
+ *              arg_type            - The parser argument type (ARGP_*)
  *              return_arg          - Where the next arg is returned
  *
  * RETURN:      Status, and an op object containing the next argument.
@@ -815,9 +816,9 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 				return_ACPI_STATUS(AE_NO_MEMORY);
 			}
 
-			/* To support super_name arg of Unload */
+			/* super_name allows argument to be a method call */
 
-			if (walk_state->opcode == AML_UNLOAD_OP) {
+			if (arg_type == ARGP_SUPERNAME) {
 				status =
 				    acpi_ps_get_next_namepath(walk_state,
 							      parser_state, arg,

commit 89438f96f2c6d31e1d7594714475c582afe03329
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Dec 29 14:00:07 2015 +0800

    ACPICA: Parser: Add constants for internal namepath function
    
    ACPICA commit b216e39fe85feee955d29fe0a7190dd811e181ea
    
    Add true/false constants for the "PossibleMethodCall" parameter
    for acpi_ps_get_next_namepath.
    
    Link: https://github.com/acpica/acpica/commit/b216e39f
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 3f0ffeef4137..0fdb7fc4824a 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -821,7 +821,7 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 				status =
 				    acpi_ps_get_next_namepath(walk_state,
 							      parser_state, arg,
-							      1);
+							      ACPI_POSSIBLE_METHOD_CALL);
 
 				/*
 				 * If the super_name arg of Unload is a method call,
@@ -836,7 +836,7 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 				status =
 				    acpi_ps_get_next_namepath(walk_state,
 							      parser_state, arg,
-							      0);
+							      ACPI_NOT_METHOD_CALL);
 			}
 		} else {
 			/* Single complex argument, nothing returned */

commit 1fad87385e7e82f656fb661aef0f841e42991974
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Dec 29 13:54:36 2015 +0800

    ACPICA: Core: Major update for code formatting, no functional changes
    
    ACPICA commit dfa394471f6c01b2ee9433dbc143ec70cb9bca72
    
    Mostly indentation inconsistencies across the code. Split
    some long lines, etc.
    
    Link: https://github.com/acpica/acpica/commit/dfa39447
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 29d8b7b01dca..3f0ffeef4137 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -733,6 +733,7 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 		if (!arg) {
 			return_ACPI_STATUS(AE_NO_MEMORY);
 		}
+
 		acpi_ps_get_next_simple_arg(parser_state, arg_type, arg);
 		break;
 

commit 62eb935b77818a5e4ff3c8d9b97036b59944f649
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Jul 23 12:52:24 2015 +0800

    ACPICA: Dispatcher: Cleanup union acpi_operand_object's AML address assignments
    
    ACPICA commit afb52611dbe7403551f93504d3798534f5c343f4
    
    This patch cleans up the code of assigning the AML address to the
    union acpi_operand_object.
    
    The idea behind this cleanup is:
    The AML address of the union acpi_operand_object should always be determined at
    the point where the object is encountered. It should be started from the
    first byte of the object. For example, the opcode of the object, the name
    string of the user_term object, or the first byte of the packaged object
    (where a pkg_length is prefixed). So it's not cleaner to have it assigned
    here and there in the entire ACPICA source tree.
    
    There are some special cases for the internal opcodes, before cleaning up
    the internal opcodes, we should also determine the rules for the AML
    addresses of the internal opcodes:
    1. INT_NAMEPATH_OP: the address of the first byte for the name_string.
    2. INT_METHODCALL_OP: the address of the first byte for the name_string.
    3. INT_BYTELIST_OP: the address of the first byte for the byte_data list.
    4. INT_EVAL_SUBTREE_OP: the address of the first byte for the
                            Region/Package/Buffer/bank_field/Field arguments.
    5. INT_NAMEDFIELD_OP: the address to the name_seg.
    6. INT_RESERVEDFIELD_OP: the address to the 0x00 prefix.
    7. INT_ACCESSFIELD_OP: the address to the 0x01 prefix.
    8. INT_CONNECTION_OP: the address to the 0x02 prefix.
    9: INT_EXTACCESSFIELD_OP: the address to the 0x03 prefix.
    10.INT_RETURN_VALUE_OP: the address of the replaced operand.
    11.computational_data: the address to the
                          Byte/Word/Dword/Qword/string_prefix.
    
    Before cleaning up the internal root scope of the aml_walk, turning it into
    the term_list, we need to remember the aml_start address as the "Aml"
    attribute for the union acpi_operand_object created by acpi_ps_create_scope_op().
    
    Finally, we can delete some redundant AML address assignment in psloop.c.
    
    Link: https://github.com/acpica/acpica/commit/afb52611
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 0bee9466d149..29d8b7b01dca 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -287,7 +287,7 @@ acpi_ps_get_next_namepath(struct acpi_walk_state *walk_state,
 				  "Control Method - %p Desc %p Path=%p\n", node,
 				  method_desc, path));
 
-		name_op = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP);
+		name_op = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP, start);
 		if (!name_op) {
 			return_ACPI_STATUS(AE_NO_MEMORY);
 		}
@@ -535,13 +535,11 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 
 	/* Allocate a new field op */
 
-	field = acpi_ps_alloc_op(opcode);
+	field = acpi_ps_alloc_op(opcode, aml);
 	if (!field) {
 		return_PTR(NULL);
 	}
 
-	field->common.aml = aml;
-
 	/* Decode the field type */
 
 	switch (opcode) {
@@ -603,6 +601,7 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 		 * Argument for Connection operator can be either a Buffer
 		 * (resource descriptor), or a name_string.
 		 */
+		aml = parser_state->aml;
 		if (ACPI_GET8(parser_state->aml) == AML_BUFFER_OP) {
 			parser_state->aml++;
 
@@ -615,7 +614,8 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 
 				/* Non-empty list */
 
-				arg = acpi_ps_alloc_op(AML_INT_BYTELIST_OP);
+				arg =
+				    acpi_ps_alloc_op(AML_INT_BYTELIST_OP, aml);
 				if (!arg) {
 					acpi_ps_free_op(field);
 					return_PTR(NULL);
@@ -664,7 +664,7 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 
 			parser_state->aml = pkg_end;
 		} else {
-			arg = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP);
+			arg = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP, aml);
 			if (!arg) {
 				acpi_ps_free_op(field);
 				return_PTR(NULL);
@@ -729,7 +729,7 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 
 		/* Constants, strings, and namestrings are all the same size */
 
-		arg = acpi_ps_alloc_op(AML_BYTE_OP);
+		arg = acpi_ps_alloc_op(AML_BYTE_OP, parser_state->aml);
 		if (!arg) {
 			return_ACPI_STATUS(AE_NO_MEMORY);
 		}
@@ -776,7 +776,8 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 
 			/* Non-empty list */
 
-			arg = acpi_ps_alloc_op(AML_INT_BYTELIST_OP);
+			arg = acpi_ps_alloc_op(AML_INT_BYTELIST_OP,
+					       parser_state->aml);
 			if (!arg) {
 				return_ACPI_STATUS(AE_NO_MEMORY);
 			}
@@ -806,7 +807,9 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 
 			/* null_name or name_string */
 
-			arg = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP);
+			arg =
+			    acpi_ps_alloc_op(AML_INT_NAMEPATH_OP,
+					     parser_state->aml);
 			if (!arg) {
 				return_ACPI_STATUS(AE_NO_MEMORY);
 			}

commit 950a429cd21638b0c076d135ed279518b21f452b
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Jul 23 12:52:18 2015 +0800

    ACPICA: Parser: Cleanup aml_offset in union acpi_operand_object
    
    ACPICA commit 61b360074fde2bb8282722579410f5d1fb12f84d
    
    This patch converts aml_offset in union acpi_operand_object to AML address.
    
    AML offset is actually only used by the debugger, using AML address is more
    direct and efficient during the parsing stage so that we don't need to
    calculate the offset during the parsing stage and will not have
    difficulities in converting it into other offset attributes.
    
    Sometimes, aml_offset is not an indication of the offset from the table
    header but the offset from the entry of a list of terms, which requires
    additional efforts to convert it into an offset from the table header. By
    using AML address directly, there is no such difficulty.
    Thus this patch also deletes a logic in disassembler that is trying to
    convert the aml_offset from
      "offset from the start address of Method/Package/Buffer"
    into the
      "offset from the start address of the ACPI table"
    (Sample code deletion can be seen in acpi_dm_deferred_parse(), but the
    function is not in the Linux kernel). Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/61b36007
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 6d038770577b..0bee9466d149 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -484,7 +484,7 @@ acpi_ps_get_next_simple_arg(struct acpi_parse_state *parser_state,
 static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 						       *parser_state)
 {
-	u32 aml_offset;
+	u8 *aml;
 	union acpi_parse_object *field;
 	union acpi_parse_object *arg = NULL;
 	u16 opcode;
@@ -498,8 +498,7 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 
 	ACPI_FUNCTION_TRACE(ps_get_next_field);
 
-	aml_offset =
-	    (u32)ACPI_PTR_DIFF(parser_state->aml, parser_state->aml_start);
+	aml = parser_state->aml;
 
 	/* Determine field type */
 
@@ -541,7 +540,7 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 		return_PTR(NULL);
 	}
 
-	field->common.aml_offset = aml_offset;
+	field->common.aml = aml;
 
 	/* Decode the field type */
 

commit 82a809419429f2e6142d2c5d88d91661f8aecb87
Author: David E. Box <david.e.box@linux.intel.com>
Date:   Thu Feb 5 15:20:45 2015 +0800

    ACPICA: Update Copyright headers to 2015
    
    ACPICA commit 8990e73ab2aa15d6a0068b860ab54feff25bee36
    
    Link: https://github.com/acpica/acpica/commit/8990e73a
    Signed-off-by: David E. Box <david.e.box@linux.intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 314d314340ae..6d038770577b 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2014, Intel Corp.
+ * Copyright (C) 2000 - 2015, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit fbb7a2dc2be493c87399550bdc2ddaa510cdf450
Author: Bob Moore <robert.moore@intel.com>
Date:   Sat Feb 8 09:42:25 2014 +0800

    ACPICA: Update ACPICA copyrights to 2014.
    
    Update ACPICA copyrights to 2014. Includes all source headers and
    signons for the various tools.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 91a5a69db80c..314d314340ae 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2013, Intel Corp.
+ * Copyright (C) 2000 - 2014, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 1d1ea1b723d9f239f736b8cf284327cbbf9d15d1
Author: Chao Guan <chao.guan@intel.com>
Date:   Sat Jun 8 00:58:14 2013 +0000

    ACPICA: Standardize all switch() blocks
    
    After many years, different formatting for switch() has crept in.
    This change makes every switch block identical. Chao Guan.
    ACPICA bugzilla 997.
    
    References: https://bugs.acpica.org/show_bug.cgi?id=997
    Signed-off-by: Chao Guan <chao.guan@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 9f25a3d4e992..91a5a69db80c 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -629,24 +629,28 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 
 				switch (opcode) {
 				case AML_BYTE_OP:	/* AML_BYTEDATA_ARG */
+
 					buffer_length =
 					    ACPI_GET8(parser_state->aml);
 					parser_state->aml += 1;
 					break;
 
 				case AML_WORD_OP:	/* AML_WORDDATA_ARG */
+
 					buffer_length =
 					    ACPI_GET16(parser_state->aml);
 					parser_state->aml += 2;
 					break;
 
 				case AML_DWORD_OP:	/* AML_DWORDATA_ARG */
+
 					buffer_length =
 					    ACPI_GET32(parser_state->aml);
 					parser_state->aml += 4;
 					break;
 
 				default:
+
 					buffer_length = 0;
 					break;
 				}

commit fd1af7126fb62688cfcf4b563c73b2909ac30f74
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Mar 8 09:22:23 2013 +0000

    ACPICA: Regression fix: reinstate safe exit macros
    
    Removal caused a regression on at least FreeBSD. This fix
    reinstates the macros.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index f51308cdbc65..9f25a3d4e992 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -108,7 +108,7 @@ acpi_ps_get_next_package_length(struct acpi_parse_state *parser_state)
 	/* Byte 0 is a special case, either bits [0:3] or [0:5] are used */
 
 	package_length |= (aml[0] & byte_zero_mask);
-	return_VALUE(package_length);
+	return_UINT32(package_length);
 }
 
 /*******************************************************************************

commit 25f044e64568dd83de34c16c837a96bbb2b0cecb
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 25 05:38:56 2013 +0000

    ACPICA: Update ACPICA copyrights to 2013
    
    Includes all source headers and signons for the various tools.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 92565131cdda..f51308cdbc65 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2013, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 7b891693091166123307f6e3023533c8d1d46f99
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Dec 31 00:06:16 2012 +0000

    ACPICA: Eliminate superfluous return_UINT8 and return_UINT32 macros.
    
    These macros were implemented the same as return_VALUE and thus
    they were not needed.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 9f3189395f3a..92565131cdda 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -108,7 +108,7 @@ acpi_ps_get_next_package_length(struct acpi_parse_state *parser_state)
 	/* Byte 0 is a special case, either bits [0:3] or [0:5] are used */
 
 	package_length |= (aml[0] & byte_zero_mask);
-	return_UINT32(package_length);
+	return_VALUE(package_length);
 }
 
 /*******************************************************************************

commit 04a81dce13c672757637b759039de216ed29a536
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Dec 31 00:05:17 2012 +0000

    ACPICA: Eliminate some small unnecessary pathname functions.
    
    Removed several small pathname functions to increase efficiency.
    Essentially, they replace a function call with a single compare.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index cb79e2d4d743..9f3189395f3a 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -162,7 +162,7 @@ char *acpi_ps_get_next_namestring(struct acpi_parse_state *parser_state)
 
 	/* Point past any namestring prefix characters (backslash or carat) */
 
-	while (acpi_ps_is_prefix_char(*end)) {
+	while (ACPI_IS_ROOT_PREFIX(*end) || ACPI_IS_PARENT_PREFIX(*end)) {
 		end++;
 	}
 
@@ -798,7 +798,8 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 		subop = acpi_ps_peek_opcode(parser_state);
 		if (subop == 0 ||
 		    acpi_ps_is_leading_char(subop) ||
-		    acpi_ps_is_prefix_char(subop)) {
+		    ACPI_IS_ROOT_PREFIX(subop) ||
+		    ACPI_IS_PARENT_PREFIX(subop)) {
 
 			/* null_name or name_string */
 

commit 73a3090a2160fb01317f5a44af6ee5a064a29625
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Oct 31 02:26:55 2012 +0000

    ACPICA: Remove extra spaces after periods within comments
    
    This makes all comments consistent.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 844464c4f901..cb79e2d4d743 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -120,7 +120,7 @@ acpi_ps_get_next_package_length(struct acpi_parse_state *parser_state)
  * RETURN:      Pointer to end-of-package +1
  *
  * DESCRIPTION: Get next package length and return a pointer past the end of
- *              the package.  Consumes the package length field
+ *              the package. Consumes the package length field
  *
  ******************************************************************************/
 
@@ -147,8 +147,8 @@ u8 *acpi_ps_get_next_package_end(struct acpi_parse_state *parser_state)
  * RETURN:      Pointer to the start of the name string (pointer points into
  *              the AML.
  *
- * DESCRIPTION: Get next raw namestring within the AML stream.  Handles all name
- *              prefix characters.  Set parser state to point past the string.
+ * DESCRIPTION: Get next raw namestring within the AML stream. Handles all name
+ *              prefix characters. Set parser state to point past the string.
  *              (Name is consumed from the AML.)
  *
  ******************************************************************************/
@@ -220,7 +220,7 @@ char *acpi_ps_get_next_namestring(struct acpi_parse_state *parser_state)
  *
  * DESCRIPTION: Get next name (if method call, return # of required args).
  *              Names are looked up in the internal namespace to determine
- *              if the name represents a control method.  If a method
+ *              if the name represents a control method. If a method
  *              is found, the number of arguments to the method is returned.
  *              This information is critical for parsing to continue correctly.
  *

commit ba494beeaa69bc0fb01eb89464ad5d57d26e3901
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jul 12 09:40:10 2012 +0800

    ACPICA: AcpiSrc: Fix some translation issues for Linux conversion
    
    Fixes issues like this:
    
    i_aSL -> iASL
    00-7_f -> 00-7F
    local_fADT -> local_FADT
    execute_oSI -> execute_OSI
    
    Also, in function headers, the parameters are now translated to
    lower case (with underscores if necessary.)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index a683d6606e2e..844464c4f901 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -210,7 +210,7 @@ char *acpi_ps_get_next_namestring(struct acpi_parse_state *parser_state)
  * FUNCTION:    acpi_ps_get_next_namepath
  *
  * PARAMETERS:  parser_state        - Current parser state object
- *              Arg                 - Where the namepath will be stored
+ *              arg                 - Where the namepath will be stored
  *              arg_count           - If the namepath points to a control method
  *                                    the method's argument is returned here.
  *              possible_method_call - Whether the namepath can possibly be the
@@ -379,7 +379,7 @@ acpi_ps_get_next_namepath(struct acpi_walk_state *walk_state,
  *
  * PARAMETERS:  parser_state        - Current parser state object
  *              arg_type            - The argument type (AML_*_ARG)
- *              Arg                 - Where the argument is returned
+ *              arg                 - Where the argument is returned
  *
  * RETURN:      None
  *

commit 6af1c4fc5227af65092ebc848989693562bfa3e8
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Thu May 3 09:38:10 2012 +0800

    ACPICA: AML Parser: Fix two possible memory leaks in error path
    
    Fixes a couple of memory leaks in the error recovery path.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 5ac36aba507c..a683d6606e2e 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -618,6 +618,7 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 
 				arg = acpi_ps_alloc_op(AML_INT_BYTELIST_OP);
 				if (!arg) {
+					acpi_ps_free_op(field);
 					return_PTR(NULL);
 				}
 
@@ -662,6 +663,7 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 		} else {
 			arg = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP);
 			if (!arg) {
+				acpi_ps_free_op(field);
 				return_PTR(NULL);
 			}
 

commit 77848130e53b06c22fe37a7b6acbb82bb3e9bfba
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 12 13:27:23 2012 +0800

    ACPICA: Update all copyrights to 2012
    
    Update all copyrights to 2012.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 4037f9032481..5ac36aba507c 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2011, Intel Corp.
+ * Copyright (C) 2000 - 2012, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 9ce81784c9c0396a6a6be05248928a71134fe60b
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Nov 16 13:39:07 2011 +0800

    ACPI 5.0: Implement Connection() and AccessAs() changes
    
    Support within the interpreter and operation region dispatch.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index e1fad0ee0136..4037f9032481 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -484,34 +484,54 @@ acpi_ps_get_next_simple_arg(struct acpi_parse_state *parser_state,
 static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 						       *parser_state)
 {
-	u32 aml_offset = (u32)
-	    ACPI_PTR_DIFF(parser_state->aml,
-			  parser_state->aml_start);
+	u32 aml_offset;
 	union acpi_parse_object *field;
+	union acpi_parse_object *arg = NULL;
 	u16 opcode;
 	u32 name;
+	u8 access_type;
+	u8 access_attribute;
+	u8 access_length;
+	u32 pkg_length;
+	u8 *pkg_end;
+	u32 buffer_length;
 
 	ACPI_FUNCTION_TRACE(ps_get_next_field);
 
+	aml_offset =
+	    (u32)ACPI_PTR_DIFF(parser_state->aml, parser_state->aml_start);
+
 	/* Determine field type */
 
 	switch (ACPI_GET8(parser_state->aml)) {
-	default:
+	case AML_FIELD_OFFSET_OP:
 
-		opcode = AML_INT_NAMEDFIELD_OP;
+		opcode = AML_INT_RESERVEDFIELD_OP;
+		parser_state->aml++;
 		break;
 
-	case 0x00:
+	case AML_FIELD_ACCESS_OP:
 
-		opcode = AML_INT_RESERVEDFIELD_OP;
+		opcode = AML_INT_ACCESSFIELD_OP;
 		parser_state->aml++;
 		break;
 
-	case 0x01:
+	case AML_FIELD_CONNECTION_OP:
 
-		opcode = AML_INT_ACCESSFIELD_OP;
+		opcode = AML_INT_CONNECTION_OP;
+		parser_state->aml++;
+		break;
+
+	case AML_FIELD_EXT_ACCESS_OP:
+
+		opcode = AML_INT_EXTACCESSFIELD_OP;
 		parser_state->aml++;
 		break;
+
+	default:
+
+		opcode = AML_INT_NAMEDFIELD_OP;
+		break;
 	}
 
 	/* Allocate a new field op */
@@ -549,16 +569,111 @@ static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
 		break;
 
 	case AML_INT_ACCESSFIELD_OP:
+	case AML_INT_EXTACCESSFIELD_OP:
 
 		/*
 		 * Get access_type and access_attrib and merge into the field Op
-		 * access_type is first operand, access_attribute is second
+		 * access_type is first operand, access_attribute is second. stuff
+		 * these bytes into the node integer value for convenience.
 		 */
-		field->common.value.integer =
-		    (((u32) ACPI_GET8(parser_state->aml) << 8));
+
+		/* Get the two bytes (Type/Attribute) */
+
+		access_type = ACPI_GET8(parser_state->aml);
 		parser_state->aml++;
-		field->common.value.integer |= ACPI_GET8(parser_state->aml);
+		access_attribute = ACPI_GET8(parser_state->aml);
 		parser_state->aml++;
+
+		field->common.value.integer = (u8)access_type;
+		field->common.value.integer |= (u16)(access_attribute << 8);
+
+		/* This opcode has a third byte, access_length */
+
+		if (opcode == AML_INT_EXTACCESSFIELD_OP) {
+			access_length = ACPI_GET8(parser_state->aml);
+			parser_state->aml++;
+
+			field->common.value.integer |=
+			    (u32)(access_length << 16);
+		}
+		break;
+
+	case AML_INT_CONNECTION_OP:
+
+		/*
+		 * Argument for Connection operator can be either a Buffer
+		 * (resource descriptor), or a name_string.
+		 */
+		if (ACPI_GET8(parser_state->aml) == AML_BUFFER_OP) {
+			parser_state->aml++;
+
+			pkg_end = parser_state->aml;
+			pkg_length =
+			    acpi_ps_get_next_package_length(parser_state);
+			pkg_end += pkg_length;
+
+			if (parser_state->aml < pkg_end) {
+
+				/* Non-empty list */
+
+				arg = acpi_ps_alloc_op(AML_INT_BYTELIST_OP);
+				if (!arg) {
+					return_PTR(NULL);
+				}
+
+				/* Get the actual buffer length argument */
+
+				opcode = ACPI_GET8(parser_state->aml);
+				parser_state->aml++;
+
+				switch (opcode) {
+				case AML_BYTE_OP:	/* AML_BYTEDATA_ARG */
+					buffer_length =
+					    ACPI_GET8(parser_state->aml);
+					parser_state->aml += 1;
+					break;
+
+				case AML_WORD_OP:	/* AML_WORDDATA_ARG */
+					buffer_length =
+					    ACPI_GET16(parser_state->aml);
+					parser_state->aml += 2;
+					break;
+
+				case AML_DWORD_OP:	/* AML_DWORDATA_ARG */
+					buffer_length =
+					    ACPI_GET32(parser_state->aml);
+					parser_state->aml += 4;
+					break;
+
+				default:
+					buffer_length = 0;
+					break;
+				}
+
+				/* Fill in bytelist data */
+
+				arg->named.value.size = buffer_length;
+				arg->named.data = parser_state->aml;
+			}
+
+			/* Skip to End of byte data */
+
+			parser_state->aml = pkg_end;
+		} else {
+			arg = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP);
+			if (!arg) {
+				return_PTR(NULL);
+			}
+
+			/* Get the Namestring argument */
+
+			arg->common.value.name =
+			    acpi_ps_get_next_namestring(parser_state);
+		}
+
+		/* Link the buffer/namestring to parent (CONNECTION_OP) */
+
+		acpi_ps_append_arg(field, arg);
 		break;
 
 	default:

commit b4e104eaeb8cd4329a23e0e4ebf166681b1d182d
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jan 17 11:05:40 2011 +0800

    ACPICA: Update all ACPICA copyrights and signons to 2011
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 7df1a4c95274..e1fad0ee0136 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2010, Intel Corp.
+ * Copyright (C) 2000 - 2011, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit f6a22b0bc417042e83117f52ab1a03696af185ab
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Mar 5 17:56:40 2010 +0800

    ACPICA: Standardize integer output for ACPICA warnings/errors
    
    Always use 0x prefix for hex output, use %u for integer output
    (all integers are unsigned.)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 00493e108a01..7df1a4c95274 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -460,7 +460,7 @@ acpi_ps_get_next_simple_arg(struct acpi_parse_state *parser_state,
 
 	default:
 
-		ACPI_ERROR((AE_INFO, "Invalid ArgType %X", arg_type));
+		ACPI_ERROR((AE_INFO, "Invalid ArgType 0x%X", arg_type));
 		return_VOID;
 	}
 
@@ -742,7 +742,7 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 
 	default:
 
-		ACPI_ERROR((AE_INFO, "Invalid ArgType: %X", arg_type));
+		ACPI_ERROR((AE_INFO, "Invalid ArgType: 0x%X", arg_type));
 		status = AE_AML_OPERAND_TYPE;
 		break;
 	}

commit 5df7e6cb42da36c7d878239bebc81907b15f3943
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 21 10:06:32 2010 +0800

    ACPICA: Remove obsolete ACPI_INTEGER (acpi_integer) type
    
    This type was introduced as the code was migrated from ACPI 1.0
    (with 32-bit AML integers) to ACPI 2.0 (with 64-bit integers). It
    is now obsolete and this change removes it from the ACPICA code
    base, replaced by u64.  The original typedef has been retained
    for now for compatibility with existing device driver code.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 6aa6a1a4d918..00493e108a01 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -403,7 +403,7 @@ acpi_ps_get_next_simple_arg(struct acpi_parse_state *parser_state,
 		/* Get 1 byte from the AML stream */
 
 		opcode = AML_BYTE_OP;
-		arg->common.value.integer = (acpi_integer) * aml;
+		arg->common.value.integer = (u64) *aml;
 		length = 1;
 		break;
 

commit a8357b0c95484b46944728712f8810d3b37bf588
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 22 19:07:36 2010 +0800

    ACPICA: Update all ACPICA copyrights and signons to 2010
    
    Add 2010 copyright to all module headers and signons, including
    the Linux header. This affects virtually every file in the ACPICA
    core subsystem, iASL compiler, and all utilities.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index b161f3544b51..6aa6a1a4d918 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2008, Intel Corp.
+ * Copyright (C) 2000 - 2010, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit e2f7a7772880458edff1b1cc5a988947229fac26
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 00:30:03 2009 -0500

    ACPICA: hide private headers
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 852f3a83b2e6..b161f3544b51 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -42,11 +42,11 @@
  */
 
 #include <acpi/acpi.h>
-#include <acpi/accommon.h>
-#include <acpi/acparser.h>
-#include <acpi/amlcode.h>
-#include <acpi/acnamesp.h>
-#include <acpi/acdispat.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "amlcode.h"
+#include "acnamesp.h"
+#include "acdispat.h"
 
 #define _COMPONENT          ACPI_PARSER
 ACPI_MODULE_NAME("psargs")

commit 95b482a8d31116f3f5c2a5089569393234d06385
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 00:13:17 2009 -0500

    ACPICA: create acpica/ directory
    
    also, delete sleep/ and delete ACPI_CFLAGS from Makefile
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
new file mode 100644
index 000000000000..852f3a83b2e6
--- /dev/null
+++ b/drivers/acpi/acpica/psargs.c
@@ -0,0 +1,752 @@
+/******************************************************************************
+ *
+ * Module Name: psargs - Parse AML opcode arguments
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2008, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include <acpi/accommon.h>
+#include <acpi/acparser.h>
+#include <acpi/amlcode.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acdispat.h>
+
+#define _COMPONENT          ACPI_PARSER
+ACPI_MODULE_NAME("psargs")
+
+/* Local prototypes */
+static u32
+acpi_ps_get_next_package_length(struct acpi_parse_state *parser_state);
+
+static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
+						       *parser_state);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_next_package_length
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *
+ * RETURN:      Decoded package length. On completion, the AML pointer points
+ *              past the length byte or bytes.
+ *
+ * DESCRIPTION: Decode and return a package length field.
+ *              Note: Largest package length is 28 bits, from ACPI specification
+ *
+ ******************************************************************************/
+
+static u32
+acpi_ps_get_next_package_length(struct acpi_parse_state *parser_state)
+{
+	u8 *aml = parser_state->aml;
+	u32 package_length = 0;
+	u32 byte_count;
+	u8 byte_zero_mask = 0x3F;	/* Default [0:5] */
+
+	ACPI_FUNCTION_TRACE(ps_get_next_package_length);
+
+	/*
+	 * Byte 0 bits [6:7] contain the number of additional bytes
+	 * used to encode the package length, either 0,1,2, or 3
+	 */
+	byte_count = (aml[0] >> 6);
+	parser_state->aml += ((acpi_size) byte_count + 1);
+
+	/* Get bytes 3, 2, 1 as needed */
+
+	while (byte_count) {
+		/*
+		 * Final bit positions for the package length bytes:
+		 *      Byte3->[20:27]
+		 *      Byte2->[12:19]
+		 *      Byte1->[04:11]
+		 *      Byte0->[00:03]
+		 */
+		package_length |= (aml[byte_count] << ((byte_count << 3) - 4));
+
+		byte_zero_mask = 0x0F;	/* Use bits [0:3] of byte 0 */
+		byte_count--;
+	}
+
+	/* Byte 0 is a special case, either bits [0:3] or [0:5] are used */
+
+	package_length |= (aml[0] & byte_zero_mask);
+	return_UINT32(package_length);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_next_package_end
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *
+ * RETURN:      Pointer to end-of-package +1
+ *
+ * DESCRIPTION: Get next package length and return a pointer past the end of
+ *              the package.  Consumes the package length field
+ *
+ ******************************************************************************/
+
+u8 *acpi_ps_get_next_package_end(struct acpi_parse_state *parser_state)
+{
+	u8 *start = parser_state->aml;
+	u32 package_length;
+
+	ACPI_FUNCTION_TRACE(ps_get_next_package_end);
+
+	/* Function below updates parser_state->Aml */
+
+	package_length = acpi_ps_get_next_package_length(parser_state);
+
+	return_PTR(start + package_length);	/* end of package */
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_next_namestring
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *
+ * RETURN:      Pointer to the start of the name string (pointer points into
+ *              the AML.
+ *
+ * DESCRIPTION: Get next raw namestring within the AML stream.  Handles all name
+ *              prefix characters.  Set parser state to point past the string.
+ *              (Name is consumed from the AML.)
+ *
+ ******************************************************************************/
+
+char *acpi_ps_get_next_namestring(struct acpi_parse_state *parser_state)
+{
+	u8 *start = parser_state->aml;
+	u8 *end = parser_state->aml;
+
+	ACPI_FUNCTION_TRACE(ps_get_next_namestring);
+
+	/* Point past any namestring prefix characters (backslash or carat) */
+
+	while (acpi_ps_is_prefix_char(*end)) {
+		end++;
+	}
+
+	/* Decode the path prefix character */
+
+	switch (*end) {
+	case 0:
+
+		/* null_name */
+
+		if (end == start) {
+			start = NULL;
+		}
+		end++;
+		break;
+
+	case AML_DUAL_NAME_PREFIX:
+
+		/* Two name segments */
+
+		end += 1 + (2 * ACPI_NAME_SIZE);
+		break;
+
+	case AML_MULTI_NAME_PREFIX_OP:
+
+		/* Multiple name segments, 4 chars each, count in next byte */
+
+		end += 2 + (*(end + 1) * ACPI_NAME_SIZE);
+		break;
+
+	default:
+
+		/* Single name segment */
+
+		end += ACPI_NAME_SIZE;
+		break;
+	}
+
+	parser_state->aml = end;
+	return_PTR((char *)start);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_next_namepath
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *              Arg                 - Where the namepath will be stored
+ *              arg_count           - If the namepath points to a control method
+ *                                    the method's argument is returned here.
+ *              possible_method_call - Whether the namepath can possibly be the
+ *                                    start of a method call
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get next name (if method call, return # of required args).
+ *              Names are looked up in the internal namespace to determine
+ *              if the name represents a control method.  If a method
+ *              is found, the number of arguments to the method is returned.
+ *              This information is critical for parsing to continue correctly.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ps_get_next_namepath(struct acpi_walk_state *walk_state,
+			  struct acpi_parse_state *parser_state,
+			  union acpi_parse_object *arg, u8 possible_method_call)
+{
+	acpi_status status;
+	char *path;
+	union acpi_parse_object *name_op;
+	union acpi_operand_object *method_desc;
+	struct acpi_namespace_node *node;
+	u8 *start = parser_state->aml;
+
+	ACPI_FUNCTION_TRACE(ps_get_next_namepath);
+
+	path = acpi_ps_get_next_namestring(parser_state);
+	acpi_ps_init_op(arg, AML_INT_NAMEPATH_OP);
+
+	/* Null path case is allowed, just exit */
+
+	if (!path) {
+		arg->common.value.name = path;
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * Lookup the name in the internal namespace, starting with the current
+	 * scope. We don't want to add anything new to the namespace here,
+	 * however, so we use MODE_EXECUTE.
+	 * Allow searching of the parent tree, but don't open a new scope -
+	 * we just want to lookup the object (must be mode EXECUTE to perform
+	 * the upsearch)
+	 */
+	status = acpi_ns_lookup(walk_state->scope_info, path,
+				ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+				ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
+				NULL, &node);
+
+	/*
+	 * If this name is a control method invocation, we must
+	 * setup the method call
+	 */
+	if (ACPI_SUCCESS(status) &&
+	    possible_method_call && (node->type == ACPI_TYPE_METHOD)) {
+		if (walk_state->opcode == AML_UNLOAD_OP) {
+			/*
+			 * acpi_ps_get_next_namestring has increased the AML pointer,
+			 * so we need to restore the saved AML pointer for method call.
+			 */
+			walk_state->parser_state.aml = start;
+			walk_state->arg_count = 1;
+			acpi_ps_init_op(arg, AML_INT_METHODCALL_OP);
+			return_ACPI_STATUS(AE_OK);
+		}
+
+		/* This name is actually a control method invocation */
+
+		method_desc = acpi_ns_get_attached_object(node);
+		ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+				  "Control Method - %p Desc %p Path=%p\n", node,
+				  method_desc, path));
+
+		name_op = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP);
+		if (!name_op) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		/* Change Arg into a METHOD CALL and attach name to it */
+
+		acpi_ps_init_op(arg, AML_INT_METHODCALL_OP);
+		name_op->common.value.name = path;
+
+		/* Point METHODCALL/NAME to the METHOD Node */
+
+		name_op->common.node = node;
+		acpi_ps_append_arg(arg, name_op);
+
+		if (!method_desc) {
+			ACPI_ERROR((AE_INFO,
+				    "Control Method %p has no attached object",
+				    node));
+			return_ACPI_STATUS(AE_AML_INTERNAL);
+		}
+
+		ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+				  "Control Method - %p Args %X\n",
+				  node, method_desc->method.param_count));
+
+		/* Get the number of arguments to expect */
+
+		walk_state->arg_count = method_desc->method.param_count;
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * Special handling if the name was not found during the lookup -
+	 * some not_found cases are allowed
+	 */
+	if (status == AE_NOT_FOUND) {
+
+		/* 1) not_found is ok during load pass 1/2 (allow forward references) */
+
+		if ((walk_state->parse_flags & ACPI_PARSE_MODE_MASK) !=
+		    ACPI_PARSE_EXECUTE) {
+			status = AE_OK;
+		}
+
+		/* 2) not_found during a cond_ref_of(x) is ok by definition */
+
+		else if (walk_state->op->common.aml_opcode ==
+			 AML_COND_REF_OF_OP) {
+			status = AE_OK;
+		}
+
+		/*
+		 * 3) not_found while building a Package is ok at this point, we
+		 * may flag as an error later if slack mode is not enabled.
+		 * (Some ASL code depends on allowing this behavior)
+		 */
+		else if ((arg->common.parent) &&
+			 ((arg->common.parent->common.aml_opcode ==
+			   AML_PACKAGE_OP)
+			  || (arg->common.parent->common.aml_opcode ==
+			      AML_VAR_PACKAGE_OP))) {
+			status = AE_OK;
+		}
+	}
+
+	/* Final exception check (may have been changed from code above) */
+
+	if (ACPI_FAILURE(status)) {
+		ACPI_ERROR_NAMESPACE(path, status);
+
+		if ((walk_state->parse_flags & ACPI_PARSE_MODE_MASK) ==
+		    ACPI_PARSE_EXECUTE) {
+
+			/* Report a control method execution error */
+
+			status = acpi_ds_method_error(status, walk_state);
+		}
+	}
+
+	/* Save the namepath */
+
+	arg->common.value.name = path;
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_next_simple_arg
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *              arg_type            - The argument type (AML_*_ARG)
+ *              Arg                 - Where the argument is returned
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Get the next simple argument (constant, string, or namestring)
+ *
+ ******************************************************************************/
+
+void
+acpi_ps_get_next_simple_arg(struct acpi_parse_state *parser_state,
+			    u32 arg_type, union acpi_parse_object *arg)
+{
+	u32 length;
+	u16 opcode;
+	u8 *aml = parser_state->aml;
+
+	ACPI_FUNCTION_TRACE_U32(ps_get_next_simple_arg, arg_type);
+
+	switch (arg_type) {
+	case ARGP_BYTEDATA:
+
+		/* Get 1 byte from the AML stream */
+
+		opcode = AML_BYTE_OP;
+		arg->common.value.integer = (acpi_integer) * aml;
+		length = 1;
+		break;
+
+	case ARGP_WORDDATA:
+
+		/* Get 2 bytes from the AML stream */
+
+		opcode = AML_WORD_OP;
+		ACPI_MOVE_16_TO_64(&arg->common.value.integer, aml);
+		length = 2;
+		break;
+
+	case ARGP_DWORDDATA:
+
+		/* Get 4 bytes from the AML stream */
+
+		opcode = AML_DWORD_OP;
+		ACPI_MOVE_32_TO_64(&arg->common.value.integer, aml);
+		length = 4;
+		break;
+
+	case ARGP_QWORDDATA:
+
+		/* Get 8 bytes from the AML stream */
+
+		opcode = AML_QWORD_OP;
+		ACPI_MOVE_64_TO_64(&arg->common.value.integer, aml);
+		length = 8;
+		break;
+
+	case ARGP_CHARLIST:
+
+		/* Get a pointer to the string, point past the string */
+
+		opcode = AML_STRING_OP;
+		arg->common.value.string = ACPI_CAST_PTR(char, aml);
+
+		/* Find the null terminator */
+
+		length = 0;
+		while (aml[length]) {
+			length++;
+		}
+		length++;
+		break;
+
+	case ARGP_NAME:
+	case ARGP_NAMESTRING:
+
+		acpi_ps_init_op(arg, AML_INT_NAMEPATH_OP);
+		arg->common.value.name =
+		    acpi_ps_get_next_namestring(parser_state);
+		return_VOID;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Invalid ArgType %X", arg_type));
+		return_VOID;
+	}
+
+	acpi_ps_init_op(arg, opcode);
+	parser_state->aml += length;
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_next_field
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *
+ * RETURN:      A newly allocated FIELD op
+ *
+ * DESCRIPTION: Get next field (named_field, reserved_field, or access_field)
+ *
+ ******************************************************************************/
+
+static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
+						       *parser_state)
+{
+	u32 aml_offset = (u32)
+	    ACPI_PTR_DIFF(parser_state->aml,
+			  parser_state->aml_start);
+	union acpi_parse_object *field;
+	u16 opcode;
+	u32 name;
+
+	ACPI_FUNCTION_TRACE(ps_get_next_field);
+
+	/* Determine field type */
+
+	switch (ACPI_GET8(parser_state->aml)) {
+	default:
+
+		opcode = AML_INT_NAMEDFIELD_OP;
+		break;
+
+	case 0x00:
+
+		opcode = AML_INT_RESERVEDFIELD_OP;
+		parser_state->aml++;
+		break;
+
+	case 0x01:
+
+		opcode = AML_INT_ACCESSFIELD_OP;
+		parser_state->aml++;
+		break;
+	}
+
+	/* Allocate a new field op */
+
+	field = acpi_ps_alloc_op(opcode);
+	if (!field) {
+		return_PTR(NULL);
+	}
+
+	field->common.aml_offset = aml_offset;
+
+	/* Decode the field type */
+
+	switch (opcode) {
+	case AML_INT_NAMEDFIELD_OP:
+
+		/* Get the 4-character name */
+
+		ACPI_MOVE_32_TO_32(&name, parser_state->aml);
+		acpi_ps_set_name(field, name);
+		parser_state->aml += ACPI_NAME_SIZE;
+
+		/* Get the length which is encoded as a package length */
+
+		field->common.value.size =
+		    acpi_ps_get_next_package_length(parser_state);
+		break;
+
+	case AML_INT_RESERVEDFIELD_OP:
+
+		/* Get the length which is encoded as a package length */
+
+		field->common.value.size =
+		    acpi_ps_get_next_package_length(parser_state);
+		break;
+
+	case AML_INT_ACCESSFIELD_OP:
+
+		/*
+		 * Get access_type and access_attrib and merge into the field Op
+		 * access_type is first operand, access_attribute is second
+		 */
+		field->common.value.integer =
+		    (((u32) ACPI_GET8(parser_state->aml) << 8));
+		parser_state->aml++;
+		field->common.value.integer |= ACPI_GET8(parser_state->aml);
+		parser_state->aml++;
+		break;
+
+	default:
+
+		/* Opcode was set in previous switch */
+		break;
+	}
+
+	return_PTR(field);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_next_arg
+ *
+ * PARAMETERS:  walk_state          - Current state
+ *              parser_state        - Current parser state object
+ *              arg_type            - The argument type (AML_*_ARG)
+ *              return_arg          - Where the next arg is returned
+ *
+ * RETURN:      Status, and an op object containing the next argument.
+ *
+ * DESCRIPTION: Get next argument (including complex list arguments that require
+ *              pushing the parser stack)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
+		     struct acpi_parse_state *parser_state,
+		     u32 arg_type, union acpi_parse_object **return_arg)
+{
+	union acpi_parse_object *arg = NULL;
+	union acpi_parse_object *prev = NULL;
+	union acpi_parse_object *field;
+	u32 subop;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE_PTR(ps_get_next_arg, parser_state);
+
+	switch (arg_type) {
+	case ARGP_BYTEDATA:
+	case ARGP_WORDDATA:
+	case ARGP_DWORDDATA:
+	case ARGP_CHARLIST:
+	case ARGP_NAME:
+	case ARGP_NAMESTRING:
+
+		/* Constants, strings, and namestrings are all the same size */
+
+		arg = acpi_ps_alloc_op(AML_BYTE_OP);
+		if (!arg) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+		acpi_ps_get_next_simple_arg(parser_state, arg_type, arg);
+		break;
+
+	case ARGP_PKGLENGTH:
+
+		/* Package length, nothing returned */
+
+		parser_state->pkg_end =
+		    acpi_ps_get_next_package_end(parser_state);
+		break;
+
+	case ARGP_FIELDLIST:
+
+		if (parser_state->aml < parser_state->pkg_end) {
+
+			/* Non-empty list */
+
+			while (parser_state->aml < parser_state->pkg_end) {
+				field = acpi_ps_get_next_field(parser_state);
+				if (!field) {
+					return_ACPI_STATUS(AE_NO_MEMORY);
+				}
+
+				if (prev) {
+					prev->common.next = field;
+				} else {
+					arg = field;
+				}
+				prev = field;
+			}
+
+			/* Skip to End of byte data */
+
+			parser_state->aml = parser_state->pkg_end;
+		}
+		break;
+
+	case ARGP_BYTELIST:
+
+		if (parser_state->aml < parser_state->pkg_end) {
+
+			/* Non-empty list */
+
+			arg = acpi_ps_alloc_op(AML_INT_BYTELIST_OP);
+			if (!arg) {
+				return_ACPI_STATUS(AE_NO_MEMORY);
+			}
+
+			/* Fill in bytelist data */
+
+			arg->common.value.size = (u32)
+			    ACPI_PTR_DIFF(parser_state->pkg_end,
+					  parser_state->aml);
+			arg->named.data = parser_state->aml;
+
+			/* Skip to End of byte data */
+
+			parser_state->aml = parser_state->pkg_end;
+		}
+		break;
+
+	case ARGP_TARGET:
+	case ARGP_SUPERNAME:
+	case ARGP_SIMPLENAME:
+
+		subop = acpi_ps_peek_opcode(parser_state);
+		if (subop == 0 ||
+		    acpi_ps_is_leading_char(subop) ||
+		    acpi_ps_is_prefix_char(subop)) {
+
+			/* null_name or name_string */
+
+			arg = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP);
+			if (!arg) {
+				return_ACPI_STATUS(AE_NO_MEMORY);
+			}
+
+			/* To support super_name arg of Unload */
+
+			if (walk_state->opcode == AML_UNLOAD_OP) {
+				status =
+				    acpi_ps_get_next_namepath(walk_state,
+							      parser_state, arg,
+							      1);
+
+				/*
+				 * If the super_name arg of Unload is a method call,
+				 * we have restored the AML pointer, just free this Arg
+				 */
+				if (arg->common.aml_opcode ==
+				    AML_INT_METHODCALL_OP) {
+					acpi_ps_free_op(arg);
+					arg = NULL;
+				}
+			} else {
+				status =
+				    acpi_ps_get_next_namepath(walk_state,
+							      parser_state, arg,
+							      0);
+			}
+		} else {
+			/* Single complex argument, nothing returned */
+
+			walk_state->arg_count = 1;
+		}
+		break;
+
+	case ARGP_DATAOBJ:
+	case ARGP_TERMARG:
+
+		/* Single complex argument, nothing returned */
+
+		walk_state->arg_count = 1;
+		break;
+
+	case ARGP_DATAOBJLIST:
+	case ARGP_TERMLIST:
+	case ARGP_OBJLIST:
+
+		if (parser_state->aml < parser_state->pkg_end) {
+
+			/* Non-empty list of variable arguments, nothing returned */
+
+			walk_state->arg_count = ACPI_VAR_ARGS;
+		}
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Invalid ArgType: %X", arg_type));
+		status = AE_AML_OPERAND_TYPE;
+		break;
+	}
+
+	*return_arg = arg;
+	return_ACPI_STATUS(status);
+}
