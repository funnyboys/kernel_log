commit 089b2bec97bbddb519e849a58b1ba8cc9880a4e5
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Fri Aug 10 14:42:57 2018 -0700

    ACPICA: Utilities: split hex detection into smaller functions
    
    acpi_ut_implicit_strtoul64() called acpi_ut_detect_hex_prefix() and
    ignored the return value. Instead, use acpi_ut_remove_hex_prefix().
    
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utstrsuppt.c b/drivers/acpi/acpica/utstrsuppt.c
index 954f8e3e35cd..05ff20049b87 100644
--- a/drivers/acpi/acpica/utstrsuppt.c
+++ b/drivers/acpi/acpica/utstrsuppt.c
@@ -231,14 +231,34 @@ char acpi_ut_remove_whitespace(char **string)
 
 u8 acpi_ut_detect_hex_prefix(char **string)
 {
+	char *initial_position = *string;
 
+	acpi_ut_remove_hex_prefix(string);
+	if (*string != initial_position) {
+		return (TRUE);	/* String is past leading 0x */
+	}
+
+	return (FALSE);		/* Not a hex string */
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_remove_hex_prefix
+ *
+ * PARAMETERS:  string                  - Pointer to input ASCII string
+ *
+ * RETURN:      none
+ *
+ * DESCRIPTION: Remove a hex "0x" prefix
+ *
+ ******************************************************************************/
+
+void acpi_ut_remove_hex_prefix(char **string)
+{
 	if ((**string == ACPI_ASCII_ZERO) &&
 	    (tolower((int)*(*string + 1)) == 'x')) {
 		*string += 2;	/* Go past the leading 0x */
-		return (TRUE);
 	}
-
-	return (FALSE);		/* Not a hex string */
 }
 
 /*******************************************************************************

commit 95857638889aeea1b10a16b55041adf3e3ab84c4
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Wed Mar 14 16:13:07 2018 -0700

    ACPICA: adding SPDX headers
    
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utstrsuppt.c b/drivers/acpi/acpica/utstrsuppt.c
index 6fc76f0b60e9..954f8e3e35cd 100644
--- a/drivers/acpi/acpica/utstrsuppt.c
+++ b/drivers/acpi/acpica/utstrsuppt.c
@@ -1,46 +1,10 @@
+// SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
 /*******************************************************************************
  *
  * Module Name: utstrsuppt - Support functions for string-to-integer conversion
  *
  ******************************************************************************/
 
-/*
- * Copyright (C) 2000 - 2018, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
 #include <acpi/acpi.h>
 #include "accommon.h"
 

commit da6f8320d58623eae9b6fa2f09b1b4f60a772ce9
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 4 10:06:38 2018 -0800

    ACPICA: All acpica: Update copyrights to 2018
    
    including tool signons.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utstrsuppt.c b/drivers/acpi/acpica/utstrsuppt.c
index 97f48d71f9e6..6fc76f0b60e9 100644
--- a/drivers/acpi/acpica/utstrsuppt.c
+++ b/drivers/acpi/acpica/utstrsuppt.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2017, Intel Corp.
+ * Copyright (C) 2000 - 2018, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 4b688b1c48dbbc6b1c939899f992985e2b03150c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 1 15:26:06 2017 +0100

    ACPICA: Rename variable to match upstream
    
    There is a variable name mismatch in acpi_ut_strtoul_multiply64()
    between the ACPICA code in the kernel and the corresponding upstream
    code which may be problematic if changes to this particular piece of
    code are made upstream and ported to Linux, so rename the variable
    in question to match its name in the upstream code.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utstrsuppt.c b/drivers/acpi/acpica/utstrsuppt.c
index b2fc371c402e..97f48d71f9e6 100644
--- a/drivers/acpi/acpica/utstrsuppt.c
+++ b/drivers/acpi/acpica/utstrsuppt.c
@@ -370,7 +370,7 @@ acpi_ut_insert_digit(u64 *accumulated_value, u32 base, int ascii_digit)
 static acpi_status
 acpi_ut_strtoul_multiply64(u64 multiplicand, u32 base, u64 *out_product)
 {
-	u64 val;
+	u64 product;
 	u64 quotient;
 
 	/* Exit if either operand is zero */
@@ -393,15 +393,15 @@ acpi_ut_strtoul_multiply64(u64 multiplicand, u32 base, u64 *out_product)
 		return (AE_NUMERIC_OVERFLOW);
 	}
 
-	val = multiplicand * base;
+	product = multiplicand * base;
 
 	/* Check for 32-bit overflow if necessary */
 
-	if ((acpi_gbl_integer_bit_width == 32) && (val > ACPI_UINT32_MAX)) {
+	if ((acpi_gbl_integer_bit_width == 32) && (product > ACPI_UINT32_MAX)) {
 		return (AE_NUMERIC_OVERFLOW);
 	}
 
-	*out_product = val;
+	*out_product = product;
 	return (AE_OK);
 }
 

commit db53f7f0eba56a7d8e45d6b26042899fccc43755
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Nov 17 15:42:16 2017 -0800

    ACPICA: Use local 64-bit divide support for string conversions
    
    ACPICA commit f230f4df26d07b97ef00be39156ecee64250447d
    
    On 32-bit platforms, 64-bit divide often requires a library
    function which may not be present in the build.
    
    Link: https://github.com/acpica/acpica/commit/f230f4df
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utstrsuppt.c b/drivers/acpi/acpica/utstrsuppt.c
index 965fb5cec94f..b2fc371c402e 100644
--- a/drivers/acpi/acpica/utstrsuppt.c
+++ b/drivers/acpi/acpica/utstrsuppt.c
@@ -52,10 +52,9 @@ static acpi_status
 acpi_ut_insert_digit(u64 *accumulated_value, u32 base, int ascii_digit);
 
 static acpi_status
-acpi_ut_strtoul_multiply64(u64 multiplicand, u64 multiplier, u64 *out_product);
+acpi_ut_strtoul_multiply64(u64 multiplicand, u32 base, u64 *out_product);
 
-static acpi_status
-acpi_ut_strtoul_add64(u64 addend1, u64 addend2, u64 *out_sum);
+static acpi_status acpi_ut_strtoul_add64(u64 addend1, u32 digit, u64 *out_sum);
 
 /*******************************************************************************
  *
@@ -357,7 +356,7 @@ acpi_ut_insert_digit(u64 *accumulated_value, u32 base, int ascii_digit)
  * FUNCTION:    acpi_ut_strtoul_multiply64
  *
  * PARAMETERS:  multiplicand            - Current accumulated converted integer
- *              multiplier              - Base/Radix
+ *              base                    - Base/Radix
  *              out_product             - Where the product is returned
  *
  * RETURN:      Status and 64-bit product
@@ -369,25 +368,32 @@ acpi_ut_insert_digit(u64 *accumulated_value, u32 base, int ascii_digit)
  ******************************************************************************/
 
 static acpi_status
-acpi_ut_strtoul_multiply64(u64 multiplicand, u64 multiplier, u64 *out_product)
+acpi_ut_strtoul_multiply64(u64 multiplicand, u32 base, u64 *out_product)
 {
 	u64 val;
+	u64 quotient;
 
 	/* Exit if either operand is zero */
 
 	*out_product = 0;
-	if (!multiplicand || !multiplier) {
+	if (!multiplicand || !base) {
 		return (AE_OK);
 	}
 
-	/* Check for 64-bit overflow before the actual multiplication */
-
-	acpi_ut_short_divide(ACPI_UINT64_MAX, (u32)multiplier, &val, NULL);
-	if (multiplicand > val) {
+	/*
+	 * Check for 64-bit overflow before the actual multiplication.
+	 *
+	 * Notes: 64-bit division is often not supported on 32-bit platforms
+	 * (it requires a library function), Therefore ACPICA has a local
+	 * 64-bit divide function. Also, Multiplier is currently only used
+	 * as the radix (8/10/16), to the 64/32 divide will always work.
+	 */
+	acpi_ut_short_divide(ACPI_UINT64_MAX, base, &quotient, NULL);
+	if (multiplicand > quotient) {
 		return (AE_NUMERIC_OVERFLOW);
 	}
 
-	val = multiplicand * multiplier;
+	val = multiplicand * base;
 
 	/* Check for 32-bit overflow if necessary */
 
@@ -404,7 +410,7 @@ acpi_ut_strtoul_multiply64(u64 multiplicand, u64 multiplier, u64 *out_product)
  * FUNCTION:    acpi_ut_strtoul_add64
  *
  * PARAMETERS:  addend1                 - Current accumulated converted integer
- *              addend2                 - New hex value/char
+ *              digit                   - New hex value/char
  *              out_sum                 - Where sum is returned (Accumulator)
  *
  * RETURN:      Status and 64-bit sum
@@ -415,17 +421,17 @@ acpi_ut_strtoul_multiply64(u64 multiplicand, u64 multiplier, u64 *out_product)
  *
  ******************************************************************************/
 
-static acpi_status acpi_ut_strtoul_add64(u64 addend1, u64 addend2, u64 *out_sum)
+static acpi_status acpi_ut_strtoul_add64(u64 addend1, u32 digit, u64 *out_sum)
 {
 	u64 sum;
 
 	/* Check for 64-bit overflow before the actual addition */
 
-	if ((addend1 > 0) && (addend2 > (ACPI_UINT64_MAX - addend1))) {
+	if ((addend1 > 0) && (digit > (ACPI_UINT64_MAX - addend1))) {
 		return (AE_NUMERIC_OVERFLOW);
 	}
 
-	sum = addend1 + addend2;
+	sum = addend1 + digit;
 
 	/* Check for 32-bit overflow if necessary */
 

commit c2e56e54b2b426fdce62e1a08a77ce8e6f4b915c
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Sep 20 10:00:49 2017 +0800

    ACPICA: String conversions: Update to add new behaviors
    
    ACPICA commit e3574138af82a25d76324559848689946982dbd0
    
    1) Allow whitespace in string before the constant
    2) ut_strtoul64 now always creates a 64-bit integer; iASL will
    truncate this to the lower 32-bits if the table being compiled
    is a 32-bit table (DSDT revision less than 2).
    
    Link: https://github.com/acpica/acpica/commit/e3574138af82
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utstrsuppt.c b/drivers/acpi/acpica/utstrsuppt.c
index 2526ba3b4f12..965fb5cec94f 100644
--- a/drivers/acpi/acpica/utstrsuppt.c
+++ b/drivers/acpi/acpica/utstrsuppt.c
@@ -229,6 +229,31 @@ char acpi_ut_remove_leading_zeros(char **string)
 	return (**string);
 }
 
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_remove_whitespace
+ *
+ * PARAMETERS:  string                  - Pointer to input ASCII string
+ *
+ * RETURN:      Next character after any whitespace. This character may be
+ *              used by the caller to detect end-of-string.
+ *
+ * DESCRIPTION: Remove any leading whitespace in the input string. Return the
+ *              next character after the final ASCII zero to enable the caller
+ *              to check for the end of the string (NULL terminator).
+ *
+ ******************************************************************************/
+
+char acpi_ut_remove_whitespace(char **string)
+{
+
+	while (isspace((u8)**string)) {
+		*string += 1;
+	}
+
+	return (**string);
+}
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ut_detect_hex_prefix

commit 72a2935502cc0f23567df649ebc644038d24abcf
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Sep 20 10:00:43 2017 +0800

    ACPICA: String conversions: Cleanup/format comments. No functional changes
    
    ACPICA commit 33e38cd2406709b13fa0a7821e588505b3771163
    
    Cleanup some of the language used in the large comments, especially
    the ones that reference the rules in the ACPI spec.
    Fixed some typos.
    
    Link: https://github.com/acpica/acpica/commit/33e38cd24067
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utstrsuppt.c b/drivers/acpi/acpica/utstrsuppt.c
index ca41f037fd9a..2526ba3b4f12 100644
--- a/drivers/acpi/acpica/utstrsuppt.c
+++ b/drivers/acpi/acpica/utstrsuppt.c
@@ -1,6 +1,6 @@
 /*******************************************************************************
  *
- * Module Name: utstrsuppt - string-to-integer conversion support functions
+ * Module Name: utstrsuppt - Support functions for string-to-integer conversion
  *
  ******************************************************************************/
 
@@ -83,7 +83,7 @@ acpi_status acpi_ut_convert_octal_string(char *string, u64 *return_value_ptr)
 
 	while (*string) {
 
-		/* Must be ASCII 0-7, otherwise terminate with no error */
+		/* Character must be ASCII 0-7, otherwise terminate with no error */
 
 		if (!(ACPI_IS_OCTAL_DIGIT(*string))) {
 			break;
@@ -132,7 +132,7 @@ acpi_status acpi_ut_convert_decimal_string(char *string, u64 *return_value_ptr)
 
 	while (*string) {
 
-		/* Must be ASCII 0-9, otherwise terminate with no error */
+		/* Character must be ASCII 0-9, otherwise terminate with no error */
 
 		if (!isdigit(*string)) {
 			break;
@@ -210,18 +210,17 @@ acpi_status acpi_ut_convert_hex_string(char *string, u64 *return_value_ptr)
  *
  * PARAMETERS:  string                  - Pointer to input ASCII string
  *
- * RETURN:      Next character after the leading zeros. This behavior may be
- *              Used by the caller to detect end-of-string.
+ * RETURN:      Next character after any leading zeros. This character may be
+ *              used by the caller to detect end-of-string.
  *
- * DESCRIPTION: Remove all leading zeros in the input string. Return the
- *              next character after the final zero to check for the end
- *              of the string (NULL terminator).
+ * DESCRIPTION: Remove any leading zeros in the input string. Return the
+ *              next character after the final ASCII zero to enable the caller
+ *              to check for the end of the string (NULL terminator).
  *
  ******************************************************************************/
 
 char acpi_ut_remove_leading_zeros(char **string)
 {
-	/* Skip all leading zeros */
 
 	while (**string == ACPI_ASCII_ZERO) {
 		*string += 1;
@@ -236,9 +235,9 @@ char acpi_ut_remove_leading_zeros(char **string)
  *
  * PARAMETERS:  string                  - Pointer to input ASCII string
  *
- * RETURN:      TRUE if a 0x prefix was found
+ * RETURN:      TRUE if a "0x" prefix was found at the start of the string
  *
- * DESCRIPTION: Detect and remove a hex 0x prefix
+ * DESCRIPTION: Detect and remove a hex "0x" prefix
  *
  ******************************************************************************/
 
@@ -260,7 +259,8 @@ u8 acpi_ut_detect_hex_prefix(char **string)
  *
  * PARAMETERS:  string                  - Pointer to input ASCII string
  *
- * RETURN:      True if an octal 0 prefix was found
+ * RETURN:      True if an octal "0" prefix was found at the start of the
+ *              string
  *
  * DESCRIPTION: Detect and remove an octal prefix (zero)
  *
@@ -282,23 +282,22 @@ u8 acpi_ut_detect_octal_prefix(char **string)
  * FUNCTION:    acpi_ut_insert_digit
  *
  * PARAMETERS:  accumulated_value       - Current value of the integer value
- *                                        accumulator. The New value is
+ *                                        accumulator. The new value is
  *                                        returned here.
- *              base                    - Radix, either 8/10/16 supported
+ *              base                    - Radix, either 8/10/16
  *              ascii_digit             - ASCII single digit to be inserted
  *
- * RETURN:      Status and result of convert/insert operation. The only
- *              exception is numeric overflow of either the multiply or the
- *              add operations.
+ * RETURN:      Status and result of the convert/insert operation. The only
+ *              possible returned exception code is numeric overflow of
+ *              either the multiply or add conversion operations.
  *
  * DESCRIPTION: Generic conversion and insertion function for all bases:
  *
- *              1) Multiply the current accumulated converted value by the
+ *              1) Multiply the current accumulated/converted value by the
  *              base in order to make room for the new character.
  *
- *              2) Add the current accumulated/converted value the new
- *              character (after the character has been converted to a binary
- *              value).
+ *              2) Convert the new character to binary and add it to the
+ *              current accumulated value.
  *
  *              Note: The only possible exception indicates an integer
  *              overflow (AE_NUMERIC_OVERFLOW)
@@ -318,17 +317,14 @@ acpi_ut_insert_digit(u64 *accumulated_value, u32 base, int ascii_digit)
 		return (status);
 	}
 
-	/* Add in the new digit, and store to the caller's accumulated value */
+	/* Add in the new digit, and store the sum to the accumulated value */
 
 	status =
 	    acpi_ut_strtoul_add64(product,
 				  acpi_ut_ascii_char_to_hex(ascii_digit),
 				  accumulated_value);
-	if (ACPI_FAILURE(status)) {
-		return (status);
-	}
 
-	return (AE_OK);
+	return (status);
 }
 
 /*******************************************************************************

commit fe97d28704147ba72f7d7859909f80b4bb5a17d4
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Sep 20 10:00:36 2017 +0800

    ACPICA: Restructure/cleanup all string-to-integer conversion functions
    
    ACPICA commit 610046d444ad781cc36673bf1f030abe50cbc61f
    
    Improve adherence to ACPI spec for implicit and explicit conversions
    Adds octal support for constants in ASL code
    Adds integer overflow errors for constants during ASL compilation
    Eliminates most of the existing complex flags parameters
    Simplify support for implicit/explicit runtime conversions
    Adds one new file, utilities/utstrsuppt.c
    
    Link: https://github.com/acpica/acpica/commit/610046d444ad
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utstrsuppt.c b/drivers/acpi/acpica/utstrsuppt.c
new file mode 100644
index 000000000000..ca41f037fd9a
--- /dev/null
+++ b/drivers/acpi/acpica/utstrsuppt.c
@@ -0,0 +1,417 @@
+/*******************************************************************************
+ *
+ * Module Name: utstrsuppt - string-to-integer conversion support functions
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2017, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utstrsuppt")
+
+/* Local prototypes */
+static acpi_status
+acpi_ut_insert_digit(u64 *accumulated_value, u32 base, int ascii_digit);
+
+static acpi_status
+acpi_ut_strtoul_multiply64(u64 multiplicand, u64 multiplier, u64 *out_product);
+
+static acpi_status
+acpi_ut_strtoul_add64(u64 addend1, u64 addend2, u64 *out_sum);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_convert_octal_string
+ *
+ * PARAMETERS:  string                  - Null terminated input string
+ *              return_value_ptr        - Where the converted value is returned
+ *
+ * RETURN:      Status and 64-bit converted integer
+ *
+ * DESCRIPTION: Performs a base 8 conversion of the input string to an
+ *              integer value, either 32 or 64 bits.
+ *
+ * NOTE:        Maximum 64-bit unsigned octal value is 01777777777777777777777
+ *              Maximum 32-bit unsigned octal value is 037777777777
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_convert_octal_string(char *string, u64 *return_value_ptr)
+{
+	u64 accumulated_value = 0;
+	acpi_status status = AE_OK;
+
+	/* Convert each ASCII byte in the input string */
+
+	while (*string) {
+
+		/* Must be ASCII 0-7, otherwise terminate with no error */
+
+		if (!(ACPI_IS_OCTAL_DIGIT(*string))) {
+			break;
+		}
+
+		/* Convert and insert this octal digit into the accumulator */
+
+		status = acpi_ut_insert_digit(&accumulated_value, 8, *string);
+		if (ACPI_FAILURE(status)) {
+			status = AE_OCTAL_OVERFLOW;
+			break;
+		}
+
+		string++;
+	}
+
+	/* Always return the value that has been accumulated */
+
+	*return_value_ptr = accumulated_value;
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_convert_decimal_string
+ *
+ * PARAMETERS:  string                  - Null terminated input string
+ *              return_value_ptr        - Where the converted value is returned
+ *
+ * RETURN:      Status and 64-bit converted integer
+ *
+ * DESCRIPTION: Performs a base 10 conversion of the input string to an
+ *              integer value, either 32 or 64 bits.
+ *
+ * NOTE:        Maximum 64-bit unsigned decimal value is 18446744073709551615
+ *              Maximum 32-bit unsigned decimal value is 4294967295
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_convert_decimal_string(char *string, u64 *return_value_ptr)
+{
+	u64 accumulated_value = 0;
+	acpi_status status = AE_OK;
+
+	/* Convert each ASCII byte in the input string */
+
+	while (*string) {
+
+		/* Must be ASCII 0-9, otherwise terminate with no error */
+
+		if (!isdigit(*string)) {
+			break;
+		}
+
+		/* Convert and insert this decimal digit into the accumulator */
+
+		status = acpi_ut_insert_digit(&accumulated_value, 10, *string);
+		if (ACPI_FAILURE(status)) {
+			status = AE_DECIMAL_OVERFLOW;
+			break;
+		}
+
+		string++;
+	}
+
+	/* Always return the value that has been accumulated */
+
+	*return_value_ptr = accumulated_value;
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_convert_hex_string
+ *
+ * PARAMETERS:  string                  - Null terminated input string
+ *              return_value_ptr        - Where the converted value is returned
+ *
+ * RETURN:      Status and 64-bit converted integer
+ *
+ * DESCRIPTION: Performs a base 16 conversion of the input string to an
+ *              integer value, either 32 or 64 bits.
+ *
+ * NOTE:        Maximum 64-bit unsigned hex value is 0xFFFFFFFFFFFFFFFF
+ *              Maximum 32-bit unsigned hex value is 0xFFFFFFFF
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_convert_hex_string(char *string, u64 *return_value_ptr)
+{
+	u64 accumulated_value = 0;
+	acpi_status status = AE_OK;
+
+	/* Convert each ASCII byte in the input string */
+
+	while (*string) {
+
+		/* Must be ASCII A-F, a-f, or 0-9, otherwise terminate with no error */
+
+		if (!isxdigit(*string)) {
+			break;
+		}
+
+		/* Convert and insert this hex digit into the accumulator */
+
+		status = acpi_ut_insert_digit(&accumulated_value, 16, *string);
+		if (ACPI_FAILURE(status)) {
+			status = AE_HEX_OVERFLOW;
+			break;
+		}
+
+		string++;
+	}
+
+	/* Always return the value that has been accumulated */
+
+	*return_value_ptr = accumulated_value;
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_remove_leading_zeros
+ *
+ * PARAMETERS:  string                  - Pointer to input ASCII string
+ *
+ * RETURN:      Next character after the leading zeros. This behavior may be
+ *              Used by the caller to detect end-of-string.
+ *
+ * DESCRIPTION: Remove all leading zeros in the input string. Return the
+ *              next character after the final zero to check for the end
+ *              of the string (NULL terminator).
+ *
+ ******************************************************************************/
+
+char acpi_ut_remove_leading_zeros(char **string)
+{
+	/* Skip all leading zeros */
+
+	while (**string == ACPI_ASCII_ZERO) {
+		*string += 1;
+	}
+
+	return (**string);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_detect_hex_prefix
+ *
+ * PARAMETERS:  string                  - Pointer to input ASCII string
+ *
+ * RETURN:      TRUE if a 0x prefix was found
+ *
+ * DESCRIPTION: Detect and remove a hex 0x prefix
+ *
+ ******************************************************************************/
+
+u8 acpi_ut_detect_hex_prefix(char **string)
+{
+
+	if ((**string == ACPI_ASCII_ZERO) &&
+	    (tolower((int)*(*string + 1)) == 'x')) {
+		*string += 2;	/* Go past the leading 0x */
+		return (TRUE);
+	}
+
+	return (FALSE);		/* Not a hex string */
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_detect_octal_prefix
+ *
+ * PARAMETERS:  string                  - Pointer to input ASCII string
+ *
+ * RETURN:      True if an octal 0 prefix was found
+ *
+ * DESCRIPTION: Detect and remove an octal prefix (zero)
+ *
+ ******************************************************************************/
+
+u8 acpi_ut_detect_octal_prefix(char **string)
+{
+
+	if (**string == ACPI_ASCII_ZERO) {
+		*string += 1;	/* Go past the leading 0 */
+		return (TRUE);
+	}
+
+	return (FALSE);		/* Not an octal string */
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_insert_digit
+ *
+ * PARAMETERS:  accumulated_value       - Current value of the integer value
+ *                                        accumulator. The New value is
+ *                                        returned here.
+ *              base                    - Radix, either 8/10/16 supported
+ *              ascii_digit             - ASCII single digit to be inserted
+ *
+ * RETURN:      Status and result of convert/insert operation. The only
+ *              exception is numeric overflow of either the multiply or the
+ *              add operations.
+ *
+ * DESCRIPTION: Generic conversion and insertion function for all bases:
+ *
+ *              1) Multiply the current accumulated converted value by the
+ *              base in order to make room for the new character.
+ *
+ *              2) Add the current accumulated/converted value the new
+ *              character (after the character has been converted to a binary
+ *              value).
+ *
+ *              Note: The only possible exception indicates an integer
+ *              overflow (AE_NUMERIC_OVERFLOW)
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_insert_digit(u64 *accumulated_value, u32 base, int ascii_digit)
+{
+	acpi_status status;
+	u64 product;
+
+	/* Make room in the accumulated value for the incoming digit */
+
+	status = acpi_ut_strtoul_multiply64(*accumulated_value, base, &product);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Add in the new digit, and store to the caller's accumulated value */
+
+	status =
+	    acpi_ut_strtoul_add64(product,
+				  acpi_ut_ascii_char_to_hex(ascii_digit),
+				  accumulated_value);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strtoul_multiply64
+ *
+ * PARAMETERS:  multiplicand            - Current accumulated converted integer
+ *              multiplier              - Base/Radix
+ *              out_product             - Where the product is returned
+ *
+ * RETURN:      Status and 64-bit product
+ *
+ * DESCRIPTION: Multiply two 64-bit values, with checking for 64-bit overflow as
+ *              well as 32-bit overflow if necessary (if the current global
+ *              integer width is 32).
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_strtoul_multiply64(u64 multiplicand, u64 multiplier, u64 *out_product)
+{
+	u64 val;
+
+	/* Exit if either operand is zero */
+
+	*out_product = 0;
+	if (!multiplicand || !multiplier) {
+		return (AE_OK);
+	}
+
+	/* Check for 64-bit overflow before the actual multiplication */
+
+	acpi_ut_short_divide(ACPI_UINT64_MAX, (u32)multiplier, &val, NULL);
+	if (multiplicand > val) {
+		return (AE_NUMERIC_OVERFLOW);
+	}
+
+	val = multiplicand * multiplier;
+
+	/* Check for 32-bit overflow if necessary */
+
+	if ((acpi_gbl_integer_bit_width == 32) && (val > ACPI_UINT32_MAX)) {
+		return (AE_NUMERIC_OVERFLOW);
+	}
+
+	*out_product = val;
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strtoul_add64
+ *
+ * PARAMETERS:  addend1                 - Current accumulated converted integer
+ *              addend2                 - New hex value/char
+ *              out_sum                 - Where sum is returned (Accumulator)
+ *
+ * RETURN:      Status and 64-bit sum
+ *
+ * DESCRIPTION: Add two 64-bit values, with checking for 64-bit overflow as
+ *              well as 32-bit overflow if necessary (if the current global
+ *              integer width is 32).
+ *
+ ******************************************************************************/
+
+static acpi_status acpi_ut_strtoul_add64(u64 addend1, u64 addend2, u64 *out_sum)
+{
+	u64 sum;
+
+	/* Check for 64-bit overflow before the actual addition */
+
+	if ((addend1 > 0) && (addend2 > (ACPI_UINT64_MAX - addend1))) {
+		return (AE_NUMERIC_OVERFLOW);
+	}
+
+	sum = addend1 + addend2;
+
+	/* Check for 32-bit overflow if necessary */
+
+	if ((acpi_gbl_integer_bit_width == 32) && (sum > ACPI_UINT32_MAX)) {
+		return (AE_NUMERIC_OVERFLOW);
+	}
+
+	*out_sum = sum;
+	return (AE_OK);
+}
