commit 800ba7c5eaaa734e4bd66bf0441fc200bbcdca54
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 10 11:31:49 2020 -0800

    ACPICA: All acpica: Update copyrights to 2020 Including tool signons.
    
    ACPICA commit 8b9c69d0984067051ffbe8526f871448ead6a26b
    
    Link: https://github.com/acpica/acpica/commit/8b9c69d0
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Kaneda <erik.kaneda@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index f16cf5e4742c..7e74a765e785 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -3,7 +3,7 @@
  *
  * Module Name: nsparse - namespace interface to AML parser
  *
- * Copyright (C) 2000 - 2019, Intel Corp.
+ * Copyright (C) 2000 - 2020, Intel Corp.
  *
  *****************************************************************************/
 

commit 5599fb69355d7a558f32206dac7539e945a1f604
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Apr 8 13:42:24 2019 -0700

    ACPICA: Rename nameseg compare macro for clarity
    
    ACPICA commit 92ec0935f27e217dff0b176fca02c2ec3d782bb5
    
    ACPI_COMPARE_NAME changed to ACPI_COMPARE_NAMESEG
    This clarifies (1) this is a compare on 4-byte namesegs, not
    a generic compare. Improves understanding of the code.
    
    Link: https://github.com/acpica/acpica/commit/92ec0935
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index c0b4f7bedfab..f16cf5e4742c 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -203,7 +203,7 @@ acpi_ns_one_complete_parse(u32 pass_number,
 
 	/* Found OSDT table, enable the namespace override feature */
 
-	if (ACPI_COMPARE_NAME(table->signature, ACPI_SIG_OSDT) &&
+	if (ACPI_COMPARE_NAMESEG(table->signature, ACPI_SIG_OSDT) &&
 	    pass_number == ACPI_IMODE_LOAD_PASS1) {
 		walk_state->namespace_override = TRUE;
 	}

commit aa342261bde5ff177935c3a4f17f0bf2bf81babf
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Fri Feb 15 13:36:06 2019 -0800

    ACPICA: Remove legacy module-level code support
    
    ACPICA commit 47f5607c204719d9239a12b889df725225098c8f
    
    Module-level code refers to executable ASL code that runs during
    table load. This is typically used in ASL to declare named objects
    based on a condition evaluated during table load like so:
    
    definition_block(...)
    {
      opreation_region (OPR1, system_memory, ...)
      Field (OPR1)
      {
        FLD1, 8 /* Assume that FLD1's value is 0x1 */
      }
    
      /* The if statement below is referred to as module-level code */
    
      If (FLD1)
      {
        /* Declare DEV1 conditionally */
        Device (DEV1) {...}
      }
    
      Device (DEV2)
      {
        ...
      }
    }
    
    In legacy module-level code, the execution of the If statement
    was deferred after other modules were loaded. The order of
    code execution for the table above is the following:
    
    1.) Load OPR1 to the ACPI Namespace
    2.) Load FLD1 to the ACPI Namespace (not intended for drivers)
    3.) Load DEV2 to the ACPI Namespace
    4.) Execute If (FLD1) and load DEV1 if the condition is true
    
    This legacy approach can be problematic for tables that look like the
    following:
    
    definition_block(...)
    {
      opreation_region (OPR1, system_memory, ...)
      Field (OPR1)
      {
        FLD1, 8 /* Assume that FLD1's value is 0x1 */
      }
    
      /* The if statement below is referred to as module-level code */
    
      If (FLD1)
      {
        /* Declare DEV1 conditionally */
        Device (DEV1) {...}
      }
    
      Scope (DEV1)
      {
        /* Add objects DEV1's scope */
        Name (OBJ1, 0x1234)
      }
    }
    
    When loading this in the legacy approach, Scope DEV1 gets evaluated
    before the If statement. The following is the order of execution:
    
    1.) Load OPR1 to the ACPI Namespace
    2.) Load FLD1 to the ACPI Namespace (not intended for drivers)
    3.) Add OBJ1 under DEV1's scope -- ERROR. DEV1 does not exist
    4.) Execute If (FLD1) and load DEV1 if the condition is true
    
    The legacy approach can never succeed for tables like this due to the
    deferral of the module-level code. Due to this limitation, a new
    module-level code was developed. This new approach exeutes if
    statements in the order that they appear in the definition block.
    With this approach, the order of execution for the above defintion
    block is as follows:
    
    1.) Load OPR1 to the ACPI Namespace
    2.) Load FLD1 to the ACPI Namespace (not intended for drivers)
    3.) Execute If (FLD1) and load DEV1 because the condition is true
    4.) Add OBJ1 under DEV1's scope.
    
    Since DEV1 is loaded in the namespace in step 3, step 4 executes
    successfully.
    
    This change removes support for the legacy module-level code
    execution. From this point onward, the new module-level code
    execution will be the official approach.
    
    Link: https://github.com/acpica/acpica/commit/47f5607c
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index bfa408f7fd39..c0b4f7bedfab 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -253,61 +253,19 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 
 	ACPI_FUNCTION_TRACE(ns_parse_table);
 
-	if (acpi_gbl_execute_tables_as_methods) {
-		/*
-		 * This case executes the AML table as one large control method.
-		 * The point of this is to execute any module-level code in-place
-		 * as the table is parsed. Some AML code depends on this behavior.
-		 *
-		 * It is a run-time option at this time, but will eventually become
-		 * the default.
-		 *
-		 * Note: This causes the table to only have a single-pass parse.
-		 * However, this is compatible with other ACPI implementations.
-		 */
-		ACPI_DEBUG_PRINT_RAW((ACPI_DB_PARSE,
-				      "%s: **** Start table execution pass\n",
-				      ACPI_GET_FUNCTION_NAME));
-
-		status = acpi_ns_execute_table(table_index, start_node);
-		if (ACPI_FAILURE(status)) {
-			return_ACPI_STATUS(status);
-		}
-	} else {
-		/*
-		 * AML Parse, pass 1
-		 *
-		 * In this pass, we load most of the namespace. Control methods
-		 * are not parsed until later. A parse tree is not created.
-		 * Instead, each Parser Op subtree is deleted when it is finished.
-		 * This saves a great deal of memory, and allows a small cache of
-		 * parse objects to service the entire parse. The second pass of
-		 * the parse then performs another complete parse of the AML.
-		 */
-		ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start pass 1\n"));
-
-		status = acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS1,
-						    table_index, start_node);
-		if (ACPI_FAILURE(status)) {
-			return_ACPI_STATUS(status);
-		}
+	/*
+	 * Executes the AML table as one large control method.
+	 * The point of this is to execute any module-level code in-place
+	 * as the table is parsed. Some AML code depends on this behavior.
+	 *
+	 * Note: This causes the table to only have a single-pass parse.
+	 * However, this is compatible with other ACPI implementations.
+	 */
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_PARSE,
+			      "%s: **** Start table execution pass\n",
+			      ACPI_GET_FUNCTION_NAME));
 
-		/*
-		 * AML Parse, pass 2
-		 *
-		 * In this pass, we resolve forward references and other things
-		 * that could not be completed during the first pass.
-		 * Another complete parse of the AML is performed, but the
-		 * overhead of this is compensated for by the fact that the
-		 * parse objects are all cached.
-		 */
-		ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start pass 2\n"));
-		status = acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS2,
-						    table_index, start_node);
-		if (ACPI_FAILURE(status)) {
-			return_ACPI_STATUS(status);
-		}
-	}
+	status = acpi_ns_execute_table(table_index, start_node);
 
 	return_ACPI_STATUS(status);
 }

commit 840c02ca2215af648c781ae680d93d8aecd083b7
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jan 14 09:55:25 2019 -0800

    ACPICA: All acpica: Update copyrights to 2019
    
    ACPICA commit 62f4f98e941d86e41969bf2ab5a93b8dc94dc49e
    
    The update includes userspace tool signons.
    
    Link: https://github.com/acpica/acpica/commit/62f4f98e
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 488ff39d86f7..bfa408f7fd39 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -3,7 +3,7 @@
  *
  * Module Name: nsparse - namespace interface to AML parser
  *
- * Copyright (C) 2000 - 2018, Intel Corp.
+ * Copyright (C) 2000 - 2019, Intel Corp.
  *
  *****************************************************************************/
 

commit 4c1379d7bb42fa664e0784539208ed74108c53f1
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Dec 13 12:30:33 2018 -0800

    ACPICA: Debug output: Add option to display method/object evaluation
    
    Adds entry/exit messages for all objects that are evaluated.
    Works for the kernel-level code as well as acpiexec. The "-eo"
    flag enables acpiexec to display these messages.
    
    The messages are very useful when debugging the flow of table
    initialization.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index c9ef4949869f..488ff39d86f7 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -107,8 +107,20 @@ acpi_ns_execute_table(u32 table_index, struct acpi_namespace_node *start_node)
 		goto cleanup;
 	}
 
+	/* Optional object evaluation log */
+
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_EVALUATION,
+			      "%-26s:  (Definition Block level)\n",
+			      "Module-level evaluation"));
+
 	status = acpi_ps_execute_table(info);
 
+	/* Optional object evaluation log */
+
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_EVALUATION,
+			      "%-26s:  (Definition Block level)\n",
+			      "Module-level complete"));
+
 cleanup:
 	if (info) {
 		ACPI_FREE(info->full_pathname);

commit a406dea82af80a2cb069f7e34e24677fe9dd580e
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Mar 14 16:13:09 2018 -0700

    ACPICA: Cleanup/simplify module-level code support
    
    This prepares the code for eventual removal of the original
    style of deferred execution of the MLC.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index ba1a50da09d0..c9ef4949869f 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -27,8 +27,17 @@ ACPI_MODULE_NAME("nsparse")
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Load ACPI/AML table by executing the entire table as a
- *              term_list.
+ * DESCRIPTION: Load ACPI/AML table by executing the entire table as a single
+ *              large control method.
+ *
+ * NOTE: The point of this is to execute any module-level code in-place
+ * as the table is parsed. Some AML code depends on this behavior.
+ *
+ * It is a run-time option at this time, but will eventually become
+ * the default.
+ *
+ * Note: This causes the table to only have a single-pass parse.
+ * However, this is compatible with other ACPI implementations.
  *
  ******************************************************************************/
 acpi_status
@@ -233,6 +242,17 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 	ACPI_FUNCTION_TRACE(ns_parse_table);
 
 	if (acpi_gbl_execute_tables_as_methods) {
+		/*
+		 * This case executes the AML table as one large control method.
+		 * The point of this is to execute any module-level code in-place
+		 * as the table is parsed. Some AML code depends on this behavior.
+		 *
+		 * It is a run-time option at this time, but will eventually become
+		 * the default.
+		 *
+		 * Note: This causes the table to only have a single-pass parse.
+		 * However, this is compatible with other ACPI implementations.
+		 */
 		ACPI_DEBUG_PRINT_RAW((ACPI_DB_PARSE,
 				      "%s: **** Start table execution pass\n",
 				      ACPI_GET_FUNCTION_NAME));

commit 95857638889aeea1b10a16b55041adf3e3ab84c4
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Wed Mar 14 16:13:07 2018 -0700

    ACPICA: adding SPDX headers
    
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 0036cec4e982..ba1a50da09d0 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -1,45 +1,11 @@
+// SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
 /******************************************************************************
  *
  * Module Name: nsparse - namespace interface to AML parser
  *
- *****************************************************************************/
-
-/*
  * Copyright (C) 2000 - 2018, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
  *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
+ *****************************************************************************/
 
 #include <acpi/acpi.h>
 #include "accommon.h"

commit e7d970f6fca8bc7b9587f77bf8b11fa78abd9280
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Mar 14 16:13:06 2018 -0700

    ACPICA: Rename a global for clarity, no functional change
    
    Was acpi_gbl_parse_table_as_term_list, changed to:
    acpi_gbl_execute_tables_as_methods.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index acb1aede720e..0036cec4e982 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -266,7 +266,7 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 
 	ACPI_FUNCTION_TRACE(ns_parse_table);
 
-	if (acpi_gbl_parse_table_as_term_list) {
+	if (acpi_gbl_execute_tables_as_methods) {
 		ACPI_DEBUG_PRINT_RAW((ACPI_DB_PARSE,
 				      "%s: **** Start table execution pass\n",
 				      ACPI_GET_FUNCTION_NAME));

commit 5a8361f7ecceaed64b4064000d16cb703462be49
Author: Schmauss, Erik <erik.schmauss@intel.com>
Date:   Thu Feb 15 13:09:30 2018 -0800

    ACPICA: Integrate package handling with module-level code
    
    ACPICA commit 8faf6fca445eb7219963d80543fb802302a7a8c7
    
    This change completes the integration of the recent changes to
    package object handling with the module-level code support.
    
    For acpi_exec, the -ep flag is removed.
    
    This change allows table load to behave as if it were a method
    invocation. Before this, the definition block definition below would
    have loaded all named objects at the root scope. After loading, it
    would execute the if statements at the root scope.
    
    DefinitionBlock (...)
    {
      Name(OBJ1, 0)
    
      if (1)
      {
        Device (DEV1)
        {
          Name (_HID,0x0)
        }
      }
      Scope (DEV1)
      {
        Name (OBJ2)
      }
    }
    
    The above code would load OBJ1 to the namespace, defer the execution
    of the if statement and attempt to add OBJ2 within the scope of DEV1.
    Since DEV1 is not in scope, this would incur an AE_NOT_FOUND error.
    After this error is emitted, the if block is invoked and DEV1 and its
    _HID is added to the namespace.
    
    This commit changes the behavior to execute the if block in place
    rather than deferring it until all tables are loaded. The new
    behavior is as follows: insert OBJ1 in the namespace, invoke the if
    statement and add DEV1 and its _HID to the namespace, add OBJ2 to the
    scope of DEV1.
    
    Bug report links:
    Link: https://bugs.acpica.org/show_bug.cgi?id=963
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=153541
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=196165
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=192621
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=197207
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=198051
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=198515
    
    ACPICA repo:
    Link: https://github.com/acpica/acpica/commit/8faf6fca
    
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 6ac2d26a2cfb..acb1aede720e 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -267,8 +267,9 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 	ACPI_FUNCTION_TRACE(ns_parse_table);
 
 	if (acpi_gbl_parse_table_as_term_list) {
-		ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
-				  "**** Start table execution pass\n"));
+		ACPI_DEBUG_PRINT_RAW((ACPI_DB_PARSE,
+				      "%s: **** Start table execution pass\n",
+				      ACPI_GET_FUNCTION_NAME));
 
 		status = acpi_ns_execute_table(table_index, start_node);
 		if (ACPI_FAILURE(status)) {

commit 1ef6323148174798b55024d5442a02fea416ce21
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Feb 15 13:09:28 2018 -0800

    ACPICA: Update for some debug output. No functional change
    
    ACPICA commit 3a08436fe3bff297a6de162252964e955946c7d3
    
    Improve/simplify some of the debug messages.
    
    Link: https://github.com/acpica/acpica/commit/3a08436f
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index c5b22ea5b369..6ac2d26a2cfb 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -112,8 +112,10 @@ acpi_ns_execute_table(u32 table_index, struct acpi_namespace_node *start_node)
 		goto cleanup;
 	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
-			  "Create table code block: %p\n", method_obj));
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_PARSE,
+			      "%s: Create table pseudo-method for [%4.4s] @%p, method %p\n",
+			      ACPI_GET_FUNCTION_NAME, table->signature, table,
+			      method_obj));
 
 	method_obj->method.aml_start = aml_start;
 	method_obj->method.aml_length = aml_length;
@@ -265,7 +267,8 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 	ACPI_FUNCTION_TRACE(ns_parse_table);
 
 	if (acpi_gbl_parse_table_as_term_list) {
-		ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start load pass\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+				  "**** Start table execution pass\n"));
 
 		status = acpi_ns_execute_table(table_index, start_node);
 		if (ACPI_FAILURE(status)) {

commit da6f8320d58623eae9b6fa2f09b1b4f60a772ce9
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 4 10:06:38 2018 -0800

    ACPICA: All acpica: Update copyrights to 2018
    
    including tool signons.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 2fc33a5203f4..c5b22ea5b369 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2017, Intel Corp.
+ * Copyright (C) 2000 - 2018, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 7735ca0eb4ebd6d47fdad40602d0ba7593219f8c
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Feb 8 11:00:08 2017 +0800

    ACPICA: Source tree: Update copyright notices to 2017
    
    ACPICA commit 16577e5265923f4999b4d2c0addb2343b18135e1
    
    Affects all files.
    
    Link: https://github.com/acpica/acpica/commit/16577e52
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 4f14e9205bff..2fc33a5203f4 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2016, Intel Corp.
+ * Copyright (C) 2000 - 2017, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 74f51b80a0c4ff84fbeb7f12ea43ce66934d29aa
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Sep 7 14:07:10 2016 +0800

    ACPICA: Namespace: Fix dynamic table loading issues
    
    ACPICA commit 767ee53354e0c4b7e8e7c57c6dd7bf569f0d52bb
    
    There are issues related to the namespace/interpreter locks, which causes
    several ACPI functionalities not specification compliant. The lock issues
    were detectec when we were trying to fix the functionalities (please see
    Link # [1] for the details).
    
    What's the lock issues? Let's first look into the namespace/interpreter
    lock usages inside of the object evaluation and the table loading which are
    the key AML interpretion code paths:
    Table loading:
    acpi_ns_load_table
            L(Namespace)
            acpi_ns_parse_table
                    acpi_ns_one_complete_parse(LOAD_PASS1/LOAD_PASS2)
                            acpi_ds_load1_begion_op
                            acpi_ds_load1_end_op
                            acpi_ds_load2_begion_op
                            acpi_ds_load2_end_op
            U(Namespace)
    Object evaluation:
    acpi_ns_evaluate
            L(Interpreter)
            acpi_ps_execute_method
                    acpi_ds_exec_begin_op
                    acpi_ds_exec_end_op
                            U(Interpreter)
                            acpi_ns_load_table
                                    L(Namespace)
                                    U(Namespace)
                            acpi_ev_initialize_region
                                    L(Namespace)
                                    U(Namespace)
                            address_space.Setup
                            address_space.Handler
                            acpi_os_wait_semaphore
                            acpi_os_acquire_mutex
                            acpi_os_sleep
                            L(Interpreter)
            U(Interpreter)
            L(Interpreter)
            acpi_ex_resolve_node_to_value
            U(Interpreter)
            acpi_ns_check_return_value
    Where:
      1. L(Interpreter) means acquire(MTX_INTERPRETER);
      2. U(Interpreter) means release(MTX_INTERPRETER);
      3. L(Namespace) means acquire(MTX_NAMESPACE);
      4. U(Namespace) means release(MTX_NAMESPACE);
    
    We can see that acpi_ns_exec_module_code() (which invokes acpi_ns_evaluate) is
    implemented in a deferred way just in order to avoid to reacquire the
    namespace lock. This is in fact the root cause of many other ACPICA issues:
    1. We now know for sure that the module code should be executed right in
       place by the Windows AML interpreter. So in the current design, if
       the region initializations/accesses or the table loadings (where the
       namespace surely should be locked again) happening during the table
       loading period, dead lock could happen because ACPICA never unlocks the
       namespace during the AML interpretion.
    2. ACPICA interpreter just ensures that all static namespace nodes (named
       objects created during the acpi_load_tables()) are created
       (acpi_ns_lookup()) with the correct lock held, but doesn't ensure that
       the named objects created by the control method are created with the
       same correct lock held. It requires the control methods to be executed
       in a serial way after "loading a table", that's why ACPICA requires
       method auto serialization.
    
    This patch fixes these software design issues by extending interpreter
    enter/exit APIs to hold both interpreter/namespace locks to ensure the lock
    order correctness, so that we can get these code paths:
    Table loading:
    acpi_ns_load_table
            E(Interpreter)
                    acpi_ns_parse_table
                            acpi_ns_one_complete_parse
                            acpi_ns_execute_table
                                    X(Interpreter)
                                    acpi_ns_load_table
                                    acpi_ev_initialize_region
                                    address_space.Setup
                                    address_space.Handler
                                    acpi_os_wait_semaphore
                                    acpi_os_acquire_mutex
                                    acpi_os_sleep
                                    E(Interpreter)
            X(Interpreter)
    Object evaluation:
    acpi_ns_evaluate
            E(Interpreter)
            acpi_ps_execute_method
                    X(Interpreter)
                    acpi_ns_load_table
                    acpi_ev_initialize_region
                    address_space.Setup
                    address_space.Handler
                    acpi_os_wait_semaphore
                    acpi_os_acquire_mutex
                    acpi_os_sleep
                    E(Interpreter)
            X(Interpreter)
    Where:
      1. E(Interpreter) means acquire(MTX_INTERPRETER, MTX_NAMESPACE);
      2. X(Interpreter) means release(MTX_NAMESPACE, MTX_INTERPRETER);
    
    After this change, we can see:
    1. All namespace nodes creations are locked by the namespace lock.
    2. All namespace nodes referencing are locked with the same lock.
    3. But we also can notice a defact that, all namespace nodes deletions
       could be affected by this change. As a consequence,
       acpi_ns_delete_namespace_subtree() may delete a static namespace node that
       is still referenced by the interpreter (for example, the parser scopes).
    Currently, we needn't worry about the last defact because in ACPICA, table
    unloading is not fully functioning, its design strictly relies on the fact
    that when the namespace deletion happens, either the AML table or the OSPMs
    should have been notified and thus either the AML table or the OSPMs
    shouldn't reference deletion-related namespace nodes during the namespace
    deletion. And this change still works with the above restrictions applied.
    While making this a-step-forward helps us to correct the wrong grammar to
    pull many things back to the correct rail. And pulling things back to the
    correct rail in return makes it possible for us to support fully
    functioning table unloading after doing many cleanups.
    
    While this patch is generated, all namespace locks are examined to ensure
    that they can meet either of the following pattens:
    1. L(Namespace)
       U(Namespace)
    2. E(Interpreter)
       X(Interpreter)
    3. E(Interpreter)
       X(Interpreter)
       L(Namespace)
       U(Namespace)
       E(Interpreter)
       X(Interpreter)
    We ensure this by adding X(Interpreter)/E(Interpreter) or removing
    U(Namespace)/L(Namespace) for those currently are executed in the following
    order:
       E(Interpreter)
       L(Namespace)
       U(Namespace)
       X(Interpreter)
    And adding E(Interpreter)/X(Interpreter) for those currently are executed
    in the following order:
       X(Interpreter)
       E(Interpreter)
    
    Originally, the interpreter lock is held for the execution AML opcodes, the
    namespace lock is held for the named object creation AML opcodes. Since
    they are actually same in MS interpreter (can all be executed during the
    table loading), we can combine the 2 locks and tune the locking code better
    in this way. Lv Zheng.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=153541 # [1]
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=121701 # [1]
    Link: https://bugs.acpica.org/show_bug.cgi?id=1323
    Link: https://github.com/acpica/acpica/commit/767ee533
    Reported-and-tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reported-and-tested-by: Greg White <gwhite@kupulau.com>
    Reported-and-tested-by: Dutch Guy <lucht_piloot@gmx.net>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index e51012b90118..4f14e9205bff 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -47,6 +47,7 @@
 #include "acparser.h"
 #include "acdispat.h"
 #include "actables.h"
+#include "acinterp.h"
 
 #define _COMPONENT          ACPI_NAMESPACE
 ACPI_MODULE_NAME("nsparse")
@@ -234,7 +235,9 @@ acpi_ns_one_complete_parse(u32 pass_number,
 
 	ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
 			  "*PARSE* pass %u parse\n", pass_number));
+	acpi_ex_enter_interpreter();
 	status = acpi_ps_parse_aml(walk_state);
+	acpi_ex_exit_interpreter();
 
 cleanup:
 	acpi_ps_delete_parse_tree(parse_root);

commit de56ba95e8d6d760910711744a548b50b3a4262d
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Sep 7 14:06:54 2016 +0800

    ACPICA: Interpreter: Fix MLC issues by switching to new term_list grammar for table loading
    
    ACPICA commit 0e24fb67cde08d7df7671d7d7b183490dc79707e
    
    The MLC (Module Level Code) is an ACPICA terminology describing the AML
    code out of any control method, its support is an indication of the
    interpreter behavior during the table loading.
    
    The original implementation of MLC in ACPICA had several issues:
    1. Out of any control method, besides of the object creating opcodes, only
       the code blocks wrapped by "If/Else/While" opcodes were supported.
    2. The supported MLC code blocks were executed after loading the table
       rather than being executed right in place.
       ============================================================
       The demo of this order issue is as follows:
         Name (OBJ1, 1)
         If (CND1 == 1)
         {
           Name (OBJ2, 2)
         }
         Name (OBJ3, 3)
       The original MLC support created OBJ2 after OBJ3's creation.
       ============================================================
    Other than these limitations, MLC support in ACPICA looks correct. And
    supporting this should be easy/natural for ACPICA, but enabling of this was
    blocked by some ACPICA internal and OSPM specific initialization order
    issues we've fixed recently. The wrong support started from the following
    false bug fixing commit:
      Commit: 7f0c826a437157d2b19662977e9cf3b472cf24a6
      Subject: ACPICA: Add support for module-level executable AML code
      Commit: 9a884ab64a4d092b4c3bf24fd9a30f7fbd4591e7
      Subject: ACPICA: Add additional module-level code support
      ...
    
    We can confirm Windows interpreter behavior via reverse engineering means.
    It can be proven that not only If/Else/While wrapped code blocks, all
    opcodes can be executed at the module level, including operation region
    accesses. And it can be proven that the MLC should be executed right in
    place, not in such a deferred way executed after loading the table.
    
    And the above facts indeed reflect the spec words around ACPI definition
    block tables (DSDT/SSDT/...), the entire table and the Scope object is
    defined by the AML specification in BNF style as:
      AMLCode := def_block_header term_list
      def_scope := scope_op pkg_length name_string term_list
    The bodies of the scope opening terms (AMLCode/Scope) are all term_list,
    thus the table loading should be no difference than the control method
    evaluations as the body of the Method is also defined by the AML
    specification as term_list:
      def_method := method_op pkg_length name_string method_flags term_list
    The only difference is: after evaluating control method, created named
    objects may be freed due to no reference, while named objects created by
    the table loading should only be freed after unloading the table.
    
    So this patch follows the spec and the de-facto standard behavior, enables
    the new grammar (term_list) for the table loading.
    
    By doing so, beyond the fixes to the above issues, we can see additional
    differences comparing to the old grammar based table loading:
    1. Originally, beyond the scope opening terms (AMLCode/Scope),
       If/Else/While wrapped code blocks under the scope creating terms
       (Device/power_resource/Processor/thermal_zone) are also supported as
       deferred MLC, which violates the spec defined grammar where object_list
       is enforced. With MLC support improved as non-deferred, the interpreter
       parses such scope creating terms as term_list rather object_list like the
       scope opening terms.
       After probing the Windows behavior and proving that it also parses these
       terms as term_list, we submitted an ECR (Engineering Change Request) to
       the ASWG (ACPI Specification Working Group) to clarify this. The ECR is
       titled as "ASL Grammar Clarification for Executable AML Opcodes" and has
       been accepted by the ASWG. The new grammar will appear in ACPI
       specification 6.2.
    2. Originally, Buffer/Package/operation_region/create_XXXField/bank_field
       arguments are evaluated in a deferred way after loading the table. With
       MLC support improved, they are also parsed right in place during the
       table loading.
       This is also Windows compliant and the only difference is the removal
       of the debugging messages implemented before acpi_ds_execute_arguments(),
       see Link # [1] for the details. A previous commit should have ensured
       that acpi_check_address_range() won't regress.
    
    Note that enabling this feature may cause regressions due to long term
    Linux ACPI support on top of the wrong grammar. So this patch also prepares
    a global option to be used to roll back to the old grammar during the
    period between a regression is reported and the regression is
    root-cause-fixed. Lv Zheng.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=112911 # [1]
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=117671 # [1]
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=153541 # [1]
    Link: https://github.com/acpica/acpica/issues/122
    Link: https://bugs.acpica.org/show_bug.cgi?id=963
    Link: https://github.com/acpica/acpica/commit/0e24fb67
    Reported-and-tested-by: Chris Bainbridge <chris.bainbridge@gmail.com>
    Reported-by: Ehsan <dashesy@gmail.com>
    Reported-and-tested-by: Dutch Guy <lucht_piloot@gmx.net>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index f631a47724f0..e51012b90118 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -51,6 +51,96 @@
 #define _COMPONENT          ACPI_NAMESPACE
 ACPI_MODULE_NAME("nsparse")
 
+/*******************************************************************************
+ *
+ * FUNCTION:    ns_execute_table
+ *
+ * PARAMETERS:  table_desc      - An ACPI table descriptor for table to parse
+ *              start_node      - Where to enter the table into the namespace
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Load ACPI/AML table by executing the entire table as a
+ *              term_list.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ns_execute_table(u32 table_index, struct acpi_namespace_node *start_node)
+{
+	acpi_status status;
+	struct acpi_table_header *table;
+	acpi_owner_id owner_id;
+	struct acpi_evaluate_info *info = NULL;
+	u32 aml_length;
+	u8 *aml_start;
+	union acpi_operand_object *method_obj = NULL;
+
+	ACPI_FUNCTION_TRACE(ns_execute_table);
+
+	status = acpi_get_table_by_index(table_index, &table);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Table must consist of at least a complete header */
+
+	if (table->length < sizeof(struct acpi_table_header)) {
+		return_ACPI_STATUS(AE_BAD_HEADER);
+	}
+
+	aml_start = (u8 *)table + sizeof(struct acpi_table_header);
+	aml_length = table->length - sizeof(struct acpi_table_header);
+
+	status = acpi_tb_get_owner_id(table_index, &owner_id);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Create, initialize, and link a new temporary method object */
+
+	method_obj = acpi_ut_create_internal_object(ACPI_TYPE_METHOD);
+	if (!method_obj) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Allocate the evaluation information block */
+
+	info = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));
+	if (!info) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+			  "Create table code block: %p\n", method_obj));
+
+	method_obj->method.aml_start = aml_start;
+	method_obj->method.aml_length = aml_length;
+	method_obj->method.owner_id = owner_id;
+	method_obj->method.info_flags |= ACPI_METHOD_MODULE_LEVEL;
+
+	info->pass_number = ACPI_IMODE_EXECUTE;
+	info->node = start_node;
+	info->obj_desc = method_obj;
+	info->node_flags = info->node->flags;
+	info->full_pathname = acpi_ns_get_normalized_pathname(info->node, TRUE);
+	if (!info->full_pathname) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	status = acpi_ps_execute_table(info);
+
+cleanup:
+	if (info) {
+		ACPI_FREE(info->full_pathname);
+		info->full_pathname = NULL;
+	}
+	ACPI_FREE(info);
+	acpi_ut_remove_reference(method_obj);
+	return_ACPI_STATUS(status);
+}
+
 /*******************************************************************************
  *
  * FUNCTION:    ns_one_complete_parse
@@ -63,6 +153,7 @@ ACPI_MODULE_NAME("nsparse")
  * DESCRIPTION: Perform one complete parse of an ACPI/AML table.
  *
  ******************************************************************************/
+
 acpi_status
 acpi_ns_one_complete_parse(u32 pass_number,
 			   u32 table_index,
@@ -170,38 +261,47 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 
 	ACPI_FUNCTION_TRACE(ns_parse_table);
 
-	/*
-	 * AML Parse, pass 1
-	 *
-	 * In this pass, we load most of the namespace. Control methods
-	 * are not parsed until later. A parse tree is not created. Instead,
-	 * each Parser Op subtree is deleted when it is finished. This saves
-	 * a great deal of memory, and allows a small cache of parse objects
-	 * to service the entire parse. The second pass of the parse then
-	 * performs another complete parse of the AML.
-	 */
-	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start pass 1\n"));
-
-	status = acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS1,
-					    table_index, start_node);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
+	if (acpi_gbl_parse_table_as_term_list) {
+		ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start load pass\n"));
 
-	/*
-	 * AML Parse, pass 2
-	 *
-	 * In this pass, we resolve forward references and other things
-	 * that could not be completed during the first pass.
-	 * Another complete parse of the AML is performed, but the
-	 * overhead of this is compensated for by the fact that the
-	 * parse objects are all cached.
-	 */
-	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start pass 2\n"));
-	status = acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS2,
-					    table_index, start_node);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
+		status = acpi_ns_execute_table(table_index, start_node);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	} else {
+		/*
+		 * AML Parse, pass 1
+		 *
+		 * In this pass, we load most of the namespace. Control methods
+		 * are not parsed until later. A parse tree is not created.
+		 * Instead, each Parser Op subtree is deleted when it is finished.
+		 * This saves a great deal of memory, and allows a small cache of
+		 * parse objects to service the entire parse. The second pass of
+		 * the parse then performs another complete parse of the AML.
+		 */
+		ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start pass 1\n"));
+
+		status = acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS1,
+						    table_index, start_node);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		/*
+		 * AML Parse, pass 2
+		 *
+		 * In this pass, we resolve forward references and other things
+		 * that could not be completed during the first pass.
+		 * Another complete parse of the AML is performed, but the
+		 * overhead of this is compensated for by the fact that the
+		 * parse objects are all cached.
+		 */
+		ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start pass 2\n"));
+		status = acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS2,
+						    table_index, start_node);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
 	}
 
 	return_ACPI_STATUS(status);

commit 45209046c47b93fadf26dc59a9da724f387b9cf2
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Jul 5 13:53:12 2016 +0800

    ACPICA: Namespace: Fix namespace/interpreter lock ordering
    
    There is a lock order issue in acpi_load_tables(). The namespace lock
    is held before holding the interpreter lock.
    
    With ACPI_MUTEX_DEBUG enabled in the kernel, this is printed to the
    log during boot:
    
      [    0.885699] ACPI Error: Invalid acquire order: Thread 405884224 owns [ACPI_MTX_Namespace], wants [ACPI_MTX_Interpreter] (20160422/utmutex-263)
      [    0.885881] ACPI Error: Could not acquire AML Interpreter mutex (20160422/exutils-95)
      [    0.893846] ACPI Error: Mutex [0x0] is not acquired, cannot release (20160422/utmutex-326)
      [    0.894019] ACPI Error: Could not release AML Interpreter mutex (20160422/exutils-133)
    
    The issue has been introduced by the following commit:
    
      Commit: 2f38b1b16d9280689e5cfa47a4c50956bf437f0d
      ACPICA Commit: bfe03ffcde8ed56a7eae38ea0b188aeb12f9c52e
      Subject: ACPICA: Namespace: Fix a regression that MLC support triggers
               dead lock in dynamic table loading
    
    Which fixed a deadlock issue for acpi_ns_load_table() in
    acpi_ex_add_table() but didn't take care of the lock order in
    acpi_ns_load_table() correctly.
    
    Originally (before the above commit), ACPICA used the
    namespace/interpreter locks in the following 2 key code
    paths:
    
     1. Table loading:
     acpi_ns_load_table
            L(Namespace)
                    acpi_ns_parse_table
                            acpi_ns_one_complete_parse
            U(Namespace)
     2. Object evaluation:
     acpi_ns_evaluate
            L(Interpreter)
            acpi_ps_execute_method
                    U(Interpreter)
                    acpi_ns_load_table
                            L(Namespace)
                            U(Namespace)
                    acpi_ev_initialize_region
                            L(Namespace)
                            U(Namespace)
                    address_space.setup
                            L(Namespace)
                            U(Namespace)
                    address_space.handler
                            L(Namespace)
                            U(Namespace)
                    acpi_os_wait_semaphore
                    acpi_os_acquire_mutex
                    acpi_os_sleep
                    L(Interpreter)
            U(Interpreter)
    
    During runtime, while acpi_ns_evaluate is called, the lock order is
    always Interpreter -> Namespace.
    
    In turn, the problematic commit acquires the locks in the following
    order:
    
     3. Table loading:
     acpi_ns_load_table
            L(Namespace)
                    acpi_ns_parse_table
                    L(Interpreter)
                            acpi_ns_one_complete_parse
                    U(Interpreter)
            U(Namespace)
    
    To fix the lock order issue, move the interpreter lock to
    acpi_ns_load_table() to ensure the lock order correctness:
    
     4. Table loading:
     acpi_ns_load_table
            L(Interpreter)
            L(Namespace)
                    acpi_ns_parse_table
                            acpi_ns_one_complete_parse
            U(Namespace)
            U(Interpreter)
    
    However, this doesn't fix the current design issues related to the
    namespace lock. For example, we can notice that in acpi_ns_evaluate(),
    outside of acpi_ns_load_table(), the namespace objects may be created
    by the named object creation control methods. And the creation of
    the method-owned namespace objects are not locked by the namespace
    lock. This patch doesn't try to fix such kind of existing issues.
    
    Fixes: 2f38b1b16d92 (ACPICA: Namespace: Fix a regression that MLC support triggers dead lock in dynamic table loading)
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 1783cd7e1446..f631a47724f0 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -47,7 +47,6 @@
 #include "acparser.h"
 #include "acdispat.h"
 #include "actables.h"
-#include "acinterp.h"
 
 #define _COMPONENT          ACPI_NAMESPACE
 ACPI_MODULE_NAME("nsparse")
@@ -171,8 +170,6 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 
 	ACPI_FUNCTION_TRACE(ns_parse_table);
 
-	acpi_ex_enter_interpreter();
-
 	/*
 	 * AML Parse, pass 1
 	 *
@@ -188,7 +185,7 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 	status = acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS1,
 					    table_index, start_node);
 	if (ACPI_FAILURE(status)) {
-		goto error_exit;
+		return_ACPI_STATUS(status);
 	}
 
 	/*
@@ -204,10 +201,8 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 	status = acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS2,
 					    table_index, start_node);
 	if (ACPI_FAILURE(status)) {
-		goto error_exit;
+		return_ACPI_STATUS(status);
 	}
 
-error_exit:
-	acpi_ex_exit_interpreter();
 	return_ACPI_STATUS(status);
 }

commit 2f38b1b16d9280689e5cfa47a4c50956bf437f0d
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Jun 21 12:34:15 2016 +0800

    ACPICA: Namespace: Fix deadlock triggered by MLC support in dynamic table loading
    
    The new module-level code (MLC) approach invokes MLC on the per-table
    basis, but the dynamic loading support of this is incorrect because
    of the lock order:
    
     acpi_ns_evaluate
       acpi_ex_enter_intperter
         acpi_ns_load_table (triggered by Load opcode)
           acpi_ns_exec_module_code_list
             acpi_ex_enter_intperter
    
    The regression is introduced by the following commit:
    
      Commit: 2785ce8d0da1cac9d8f78615e116cf929e9a9123
      ACPICA Commit: 071eff738c59eda1792ac24b3b688b61691d7e7c
      Subject: ACPICA: Add per-table execution of module-level code
    
    This patch fixes this regression by unlocking the interpreter lock
    before invoking MLC.  However, the unlocking is done to the
    acpi_ns_load_table(), in which the interpreter lock should be locked
    by acpi_ns_parse_table() but it wasn't.
    
    Fixes: 2785ce8d0da1 (ACPICA: Add per-table execution of module-level code)
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: 4.5+ <stable@vger.kernel.org> # 4.5+
    [ rjw : Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index f631a47724f0..1783cd7e1446 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -47,6 +47,7 @@
 #include "acparser.h"
 #include "acdispat.h"
 #include "actables.h"
+#include "acinterp.h"
 
 #define _COMPONENT          ACPI_NAMESPACE
 ACPI_MODULE_NAME("nsparse")
@@ -170,6 +171,8 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 
 	ACPI_FUNCTION_TRACE(ns_parse_table);
 
+	acpi_ex_enter_interpreter();
+
 	/*
 	 * AML Parse, pass 1
 	 *
@@ -185,7 +188,7 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 	status = acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS1,
 					    table_index, start_node);
 	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
+		goto error_exit;
 	}
 
 	/*
@@ -201,8 +204,10 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 	status = acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS2,
 					    table_index, start_node);
 	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
+		goto error_exit;
 	}
 
+error_exit:
+	acpi_ex_exit_interpreter();
 	return_ACPI_STATUS(status);
 }

commit c8100dc4643d80a94f074dfc8a2af3d3d327b7aa
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 15 08:17:03 2016 +0800

    ACPICA: Additional 2016 copyright changes
    
    All tool/utility signons.
    Dual-license module header.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 43b45a8c2fe4..f631a47724f0 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2015, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 1fad87385e7e82f656fb661aef0f841e42991974
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Dec 29 13:54:36 2015 +0800

    ACPICA: Core: Major update for code formatting, no functional changes
    
    ACPICA commit dfa394471f6c01b2ee9433dbc143ec70cb9bca72
    
    Mostly indentation inconsistencies across the code. Split
    some long lines, etc.
    
    Link: https://github.com/acpica/acpica/commit/dfa39447
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 3736d43b18b9..43b45a8c2fe4 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -141,8 +141,8 @@ acpi_ns_one_complete_parse(u32 pass_number,
 
 	/* Parse the AML */
 
-	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "*PARSE* pass %u parse\n",
-			  pass_number));
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+			  "*PARSE* pass %u parse\n", pass_number));
 	status = acpi_ps_parse_aml(walk_state);
 
 cleanup:
@@ -181,6 +181,7 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 	 * performs another complete parse of the AML.
 	 */
 	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start pass 1\n"));
+
 	status = acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS1,
 					    table_index, start_node);
 	if (ACPI_FAILURE(status)) {

commit 62eb935b77818a5e4ff3c8d9b97036b59944f649
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Jul 23 12:52:24 2015 +0800

    ACPICA: Dispatcher: Cleanup union acpi_operand_object's AML address assignments
    
    ACPICA commit afb52611dbe7403551f93504d3798534f5c343f4
    
    This patch cleans up the code of assigning the AML address to the
    union acpi_operand_object.
    
    The idea behind this cleanup is:
    The AML address of the union acpi_operand_object should always be determined at
    the point where the object is encountered. It should be started from the
    first byte of the object. For example, the opcode of the object, the name
    string of the user_term object, or the first byte of the packaged object
    (where a pkg_length is prefixed). So it's not cleaner to have it assigned
    here and there in the entire ACPICA source tree.
    
    There are some special cases for the internal opcodes, before cleaning up
    the internal opcodes, we should also determine the rules for the AML
    addresses of the internal opcodes:
    1. INT_NAMEPATH_OP: the address of the first byte for the name_string.
    2. INT_METHODCALL_OP: the address of the first byte for the name_string.
    3. INT_BYTELIST_OP: the address of the first byte for the byte_data list.
    4. INT_EVAL_SUBTREE_OP: the address of the first byte for the
                            Region/Package/Buffer/bank_field/Field arguments.
    5. INT_NAMEDFIELD_OP: the address to the name_seg.
    6. INT_RESERVEDFIELD_OP: the address to the 0x00 prefix.
    7. INT_ACCESSFIELD_OP: the address to the 0x01 prefix.
    8. INT_CONNECTION_OP: the address to the 0x02 prefix.
    9: INT_EXTACCESSFIELD_OP: the address to the 0x03 prefix.
    10.INT_RETURN_VALUE_OP: the address of the replaced operand.
    11.computational_data: the address to the
                          Byte/Word/Dword/Qword/string_prefix.
    
    Before cleaning up the internal root scope of the aml_walk, turning it into
    the term_list, we need to remember the aml_start address as the "Aml"
    attribute for the union acpi_operand_object created by acpi_ps_create_scope_op().
    
    Finally, we can delete some redundant AML address assignment in psloop.c.
    
    Link: https://github.com/acpica/acpica/commit/afb52611
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 9926a67ca6d7..3736d43b18b9 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -78,6 +78,20 @@ acpi_ns_one_complete_parse(u32 pass_number,
 
 	ACPI_FUNCTION_TRACE(ns_one_complete_parse);
 
+	status = acpi_get_table_by_index(table_index, &table);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Table must consist of at least a complete header */
+
+	if (table->length < sizeof(struct acpi_table_header)) {
+		return_ACPI_STATUS(AE_BAD_HEADER);
+	}
+
+	aml_start = (u8 *)table + sizeof(struct acpi_table_header);
+	aml_length = table->length - sizeof(struct acpi_table_header);
+
 	status = acpi_tb_get_owner_id(table_index, &owner_id);
 	if (ACPI_FAILURE(status)) {
 		return_ACPI_STATUS(status);
@@ -85,7 +99,7 @@ acpi_ns_one_complete_parse(u32 pass_number,
 
 	/* Create and init a Root Node */
 
-	parse_root = acpi_ps_create_scope_op();
+	parse_root = acpi_ps_create_scope_op(aml_start);
 	if (!parse_root) {
 		return_ACPI_STATUS(AE_NO_MEMORY);
 	}
@@ -98,23 +112,12 @@ acpi_ns_one_complete_parse(u32 pass_number,
 		return_ACPI_STATUS(AE_NO_MEMORY);
 	}
 
-	status = acpi_get_table_by_index(table_index, &table);
+	status = acpi_ds_init_aml_walk(walk_state, parse_root, NULL,
+				       aml_start, aml_length, NULL,
+				       (u8)pass_number);
 	if (ACPI_FAILURE(status)) {
 		acpi_ds_delete_walk_state(walk_state);
-		acpi_ps_free_op(parse_root);
-		return_ACPI_STATUS(status);
-	}
-
-	/* Table must consist of at least a complete header */
-
-	if (table->length < sizeof(struct acpi_table_header)) {
-		status = AE_BAD_HEADER;
-	} else {
-		aml_start = (u8 *)table + sizeof(struct acpi_table_header);
-		aml_length = table->length - sizeof(struct acpi_table_header);
-		status = acpi_ds_init_aml_walk(walk_state, parse_root, NULL,
-					       aml_start, aml_length, NULL,
-					       (u8)pass_number);
+		goto cleanup;
 	}
 
 	/* Found OSDT table, enable the namespace override feature */
@@ -124,11 +127,6 @@ acpi_ns_one_complete_parse(u32 pass_number,
 		walk_state->namespace_override = TRUE;
 	}
 
-	if (ACPI_FAILURE(status)) {
-		acpi_ds_delete_walk_state(walk_state);
-		goto cleanup;
-	}
-
 	/* start_node is the default location to load the table */
 
 	if (start_node && start_node != acpi_gbl_root_node) {

commit eb87a05223293a915dc97e6966cbbb1baa43cd5f
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Jul 23 12:52:05 2015 +0800

    ACPICA: Parser: Reduce parser/namespace divergences for tracer support
    
    This patch reduces divergences in parser/namespace components so that the
    follow-up linuxized ACPICA upstream commits can be directly merged.
    Including the fix to an indent issue reported and fixed by Zhouyi Zhou.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Zhouyi Zhou <yizhouzhou@ict.ac.cn>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 57a4cfe547e4..9926a67ca6d7 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -70,7 +70,7 @@ acpi_ns_one_complete_parse(u32 pass_number,
 {
 	union acpi_parse_object *parse_root;
 	acpi_status status;
-       u32 aml_length;
+	u32 aml_length;
 	u8 *aml_start;
 	struct acpi_walk_state *walk_state;
 	struct acpi_table_header *table;
@@ -110,11 +110,11 @@ acpi_ns_one_complete_parse(u32 pass_number,
 	if (table->length < sizeof(struct acpi_table_header)) {
 		status = AE_BAD_HEADER;
 	} else {
-		aml_start = (u8 *) table + sizeof(struct acpi_table_header);
+		aml_start = (u8 *)table + sizeof(struct acpi_table_header);
 		aml_length = table->length - sizeof(struct acpi_table_header);
 		status = acpi_ds_init_aml_walk(walk_state, parse_root, NULL,
 					       aml_start, aml_length, NULL,
-					       (u8) pass_number);
+					       (u8)pass_number);
 	}
 
 	/* Found OSDT table, enable the namespace override feature */

commit fe536995f2fe26fff111a9a06bf3f71e179c92cf
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Jul 1 14:44:23 2015 +0800

    ACPICA: Namespace: Add support of OSDT table
    
    ACPICA commit 27415c82fcecf467446f66d1007a0691cc5f3709
    
    This patch adds OSDT (Override System Definition Table) support.
    When OSDT is loaded, conflict namespace objects will be overridden
    by the AML interpreter. Bob Moore, Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/27415c82
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index c95a119767b5..57a4cfe547e4 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -117,6 +117,13 @@ acpi_ns_one_complete_parse(u32 pass_number,
 					       (u8) pass_number);
 	}
 
+	/* Found OSDT table, enable the namespace override feature */
+
+	if (ACPI_COMPARE_NAME(table->signature, ACPI_SIG_OSDT) &&
+	    pass_number == ACPI_IMODE_LOAD_PASS1) {
+		walk_state->namespace_override = TRUE;
+	}
+
 	if (ACPI_FAILURE(status)) {
 		acpi_ds_delete_walk_state(walk_state);
 		goto cleanup;

commit 82a809419429f2e6142d2c5d88d91661f8aecb87
Author: David E. Box <david.e.box@linux.intel.com>
Date:   Thu Feb 5 15:20:45 2015 +0800

    ACPICA: Update Copyright headers to 2015
    
    ACPICA commit 8990e73ab2aa15d6a0068b860ab54feff25bee36
    
    Link: https://github.com/acpica/acpica/commit/8990e73a
    Signed-off-by: David E. Box <david.e.box@linux.intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index e83cff31754b..c95a119767b5 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2014, Intel Corp.
+ * Copyright (C) 2000 - 2015, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit fbb7a2dc2be493c87399550bdc2ddaa510cdf450
Author: Bob Moore <robert.moore@intel.com>
Date:   Sat Feb 8 09:42:25 2014 +0800

    ACPICA: Update ACPICA copyrights to 2014.
    
    Update ACPICA copyrights to 2014. Includes all source headers and
    signons for the various tools.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 177857340271..e83cff31754b 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2013, Intel Corp.
+ * Copyright (C) 2000 - 2014, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 10622bf8ce432e6a53fd3c37163e99e99c9e43ee
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Oct 29 09:30:02 2013 +0800

    ACPICA: Linuxize: Change indentation of C labels.
    
    It is reported by kernel build test systems that all ACPICA source
    files in the kernel tree have incorrect label indentation.  This
    patch changes default indent option used in the release process to
    fix this bug.  Lv Zheng.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 35dde8151c0d..177857340271 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -140,7 +140,7 @@ acpi_ns_one_complete_parse(u32 pass_number,
 			  pass_number));
 	status = acpi_ps_parse_aml(walk_state);
 
-      cleanup:
+cleanup:
 	acpi_ps_delete_parse_tree(parse_root);
 	return_ACPI_STATUS(status);
 }

commit 25f044e64568dd83de34c16c837a96bbb2b0cecb
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 25 05:38:56 2013 +0000

    ACPICA: Update ACPICA copyrights to 2013
    
    Includes all source headers and signons for the various tools.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 233f756d5cfa..35dde8151c0d 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2013, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 73a3090a2160fb01317f5a44af6ee5a064a29625
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Oct 31 02:26:55 2012 +0000

    ACPICA: Remove extra spaces after periods within comments
    
    This makes all comments consistent.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index ec7ba2d3463c..233f756d5cfa 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -168,11 +168,11 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 	/*
 	 * AML Parse, pass 1
 	 *
-	 * In this pass, we load most of the namespace.  Control methods
-	 * are not parsed until later.  A parse tree is not created.  Instead,
-	 * each Parser Op subtree is deleted when it is finished.  This saves
+	 * In this pass, we load most of the namespace. Control methods
+	 * are not parsed until later. A parse tree is not created. Instead,
+	 * each Parser Op subtree is deleted when it is finished. This saves
 	 * a great deal of memory, and allows a small cache of parse objects
-	 * to service the entire parse.  The second pass of the parse then
+	 * to service the entire parse. The second pass of the parse then
 	 * performs another complete parse of the AML.
 	 */
 	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start pass 1\n"));

commit 77848130e53b06c22fe37a7b6acbb82bb3e9bfba
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 12 13:27:23 2012 +0800

    ACPICA: Update all copyrights to 2012
    
    Update all copyrights to 2012.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index b3234fa795b8..ec7ba2d3463c 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2011, Intel Corp.
+ * Copyright (C) 2000 - 2012, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit b4e104eaeb8cd4329a23e0e4ebf166681b1d182d
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jan 17 11:05:40 2011 +0800

    ACPICA: Update all ACPICA copyrights and signons to 2011
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 5808c89e9fac..b3234fa795b8 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2010, Intel Corp.
+ * Copyright (C) 2000 - 2011, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit b27d65975c252ff774edff8e01f0a9fd46d8ab62
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed May 26 11:47:13 2010 +0800

    ACPICA: Core: Replace all %d format specifiers with %u (unsigned)
    
    With only a few exceptions, ACPICA does not use signed integers.
    Therefore, %d is incorrect.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 27cda52c76bc..5808c89e9fac 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -136,8 +136,8 @@ acpi_ns_one_complete_parse(u32 pass_number,
 
 	/* Parse the AML */
 
-	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "*PARSE* pass %d parse\n",
-			  (unsigned)pass_number));
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "*PARSE* pass %u parse\n",
+			  pass_number));
 	status = acpi_ps_parse_aml(walk_state);
 
       cleanup:

commit a8357b0c95484b46944728712f8810d3b37bf588
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 22 19:07:36 2010 +0800

    ACPICA: Update all ACPICA copyrights and signons to 2010
    
    Add 2010 copyright to all module headers and signons, including
    the Linux header. This affects virtually every file in the ACPICA
    core subsystem, iASL compiler, and all utilities.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 662a4bd5b621..27cda52c76bc 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2008, Intel Corp.
+ * Copyright (C) 2000 - 2010, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit d4913dc6d0c680aa106d1d80b5ad2a9325367afd
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Mar 6 10:05:18 2009 +0800

    ACPICA: Formatting update - no functional changes
    
    Split long lines, update comments.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index b9e8d0070b6f..662a4bd5b621 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -176,9 +176,8 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 	 * performs another complete parse of the AML.
 	 */
 	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start pass 1\n"));
-	status =
-	    acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS1, table_index,
-				       start_node);
+	status = acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS1,
+					    table_index, start_node);
 	if (ACPI_FAILURE(status)) {
 		return_ACPI_STATUS(status);
 	}
@@ -193,9 +192,8 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 	 * parse objects are all cached.
 	 */
 	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start pass 2\n"));
-	status =
-	    acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS2, table_index,
-				       start_node);
+	status = acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS2,
+					    table_index, start_node);
 	if (ACPI_FAILURE(status)) {
 		return_ACPI_STATUS(status);
 	}

commit e2f7a7772880458edff1b1cc5a988947229fac26
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 00:30:03 2009 -0500

    ACPICA: hide private headers
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index bcfcf427c909..b9e8d0070b6f 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -42,11 +42,11 @@
  */
 
 #include <acpi/acpi.h>
-#include <acpi/accommon.h>
-#include <acpi/acnamesp.h>
-#include <acpi/acparser.h>
-#include <acpi/acdispat.h>
-#include <acpi/actables.h>
+#include "accommon.h"
+#include "acnamesp.h"
+#include "acparser.h"
+#include "acdispat.h"
+#include "actables.h"
 
 #define _COMPONENT          ACPI_NAMESPACE
 ACPI_MODULE_NAME("nsparse")

commit 95b482a8d31116f3f5c2a5089569393234d06385
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 00:13:17 2009 -0500

    ACPICA: create acpica/ directory
    
    also, delete sleep/ and delete ACPI_CFLAGS from Makefile
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
new file mode 100644
index 000000000000..bcfcf427c909
--- /dev/null
+++ b/drivers/acpi/acpica/nsparse.c
@@ -0,0 +1,204 @@
+/******************************************************************************
+ *
+ * Module Name: nsparse - namespace interface to AML parser
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2008, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include <acpi/accommon.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acparser.h>
+#include <acpi/acdispat.h>
+#include <acpi/actables.h>
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nsparse")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ns_one_complete_parse
+ *
+ * PARAMETERS:  pass_number             - 1 or 2
+ *              table_desc              - The table to be parsed.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Perform one complete parse of an ACPI/AML table.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ns_one_complete_parse(u32 pass_number,
+			   u32 table_index,
+			   struct acpi_namespace_node *start_node)
+{
+	union acpi_parse_object *parse_root;
+	acpi_status status;
+       u32 aml_length;
+	u8 *aml_start;
+	struct acpi_walk_state *walk_state;
+	struct acpi_table_header *table;
+	acpi_owner_id owner_id;
+
+	ACPI_FUNCTION_TRACE(ns_one_complete_parse);
+
+	status = acpi_tb_get_owner_id(table_index, &owner_id);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Create and init a Root Node */
+
+	parse_root = acpi_ps_create_scope_op();
+	if (!parse_root) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Create and initialize a new walk state */
+
+	walk_state = acpi_ds_create_walk_state(owner_id, NULL, NULL, NULL);
+	if (!walk_state) {
+		acpi_ps_free_op(parse_root);
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	status = acpi_get_table_by_index(table_index, &table);
+	if (ACPI_FAILURE(status)) {
+		acpi_ds_delete_walk_state(walk_state);
+		acpi_ps_free_op(parse_root);
+		return_ACPI_STATUS(status);
+	}
+
+	/* Table must consist of at least a complete header */
+
+	if (table->length < sizeof(struct acpi_table_header)) {
+		status = AE_BAD_HEADER;
+	} else {
+		aml_start = (u8 *) table + sizeof(struct acpi_table_header);
+		aml_length = table->length - sizeof(struct acpi_table_header);
+		status = acpi_ds_init_aml_walk(walk_state, parse_root, NULL,
+					       aml_start, aml_length, NULL,
+					       (u8) pass_number);
+	}
+
+	if (ACPI_FAILURE(status)) {
+		acpi_ds_delete_walk_state(walk_state);
+		goto cleanup;
+	}
+
+	/* start_node is the default location to load the table */
+
+	if (start_node && start_node != acpi_gbl_root_node) {
+		status =
+		    acpi_ds_scope_stack_push(start_node, ACPI_TYPE_METHOD,
+					     walk_state);
+		if (ACPI_FAILURE(status)) {
+			acpi_ds_delete_walk_state(walk_state);
+			goto cleanup;
+		}
+	}
+
+	/* Parse the AML */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "*PARSE* pass %d parse\n",
+			  (unsigned)pass_number));
+	status = acpi_ps_parse_aml(walk_state);
+
+      cleanup:
+	acpi_ps_delete_parse_tree(parse_root);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_parse_table
+ *
+ * PARAMETERS:  table_desc      - An ACPI table descriptor for table to parse
+ *              start_node      - Where to enter the table into the namespace
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Parse AML within an ACPI table and return a tree of ops
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ns_parse_table);
+
+	/*
+	 * AML Parse, pass 1
+	 *
+	 * In this pass, we load most of the namespace.  Control methods
+	 * are not parsed until later.  A parse tree is not created.  Instead,
+	 * each Parser Op subtree is deleted when it is finished.  This saves
+	 * a great deal of memory, and allows a small cache of parse objects
+	 * to service the entire parse.  The second pass of the parse then
+	 * performs another complete parse of the AML.
+	 */
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start pass 1\n"));
+	status =
+	    acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS1, table_index,
+				       start_node);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * AML Parse, pass 2
+	 *
+	 * In this pass, we resolve forward references and other things
+	 * that could not be completed during the first pass.
+	 * Another complete parse of the AML is performed, but the
+	 * overhead of this is compensated for by the fact that the
+	 * parse objects are all cached.
+	 */
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start pass 2\n"));
+	status =
+	    acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS2, table_index,
+				       start_node);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	return_ACPI_STATUS(status);
+}
