commit 9a1ae80412dcaa67a29eecf19de44f32b5f1c357
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Mar 27 15:21:09 2020 -0700

    ACPICA: Fixes for acpiExec namespace init file
    
    This is the result of squashing the following ACPICA commit ID's:
    6803997e5b4f3635cea6610b51ff69e29d251de3
    f31cdf8bfda22fe265c1a176d0e33d311c82a7f7
    
    This change fixes several problems with the support for the
    acpi_exec namespace init file (-fi option). Specifically, it
    fixes AE_ALREADY_EXISTS errors, as well as various seg faults.
    
    Link: https://github.com/acpica/acpica/commit/f31cdf8b
    Link: https://github.com/acpica/acpica/commit/6803997e
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Kaneda <erik.kaneda@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index eee263cb7beb..c365faf4e6cd 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -452,13 +452,13 @@ acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
  *
  * FUNCTION:    acpi_ut_update_object_reference
  *
- * PARAMETERS:  object              - Increment ref count for this object
- *                                    and all sub-objects
+ * PARAMETERS:  object              - Increment or decrement the ref count for
+ *                                    this object and all sub-objects
  *              action              - Either REF_INCREMENT or REF_DECREMENT
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Increment the object reference count
+ * DESCRIPTION: Increment or decrement the object reference count
  *
  * Object references are incremented when:
  * 1) An object is attached to a Node (namespace object)
@@ -492,7 +492,7 @@ acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
 		}
 
 		/*
-		 * All sub-objects must have their reference count incremented
+		 * All sub-objects must have their reference count updated
 		 * also. Different object types have different subobjects.
 		 */
 		switch (object->common.type) {
@@ -559,6 +559,7 @@ acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
 					break;
 				}
 			}
+
 			next_object = NULL;
 			break;
 

commit aa6ec56b574d16180d56d18256ded7d49c7212a0
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Fri Feb 22 16:06:25 2019 -0800

    ACPICA: ACPI 6.3: add PCC operation region support for AML interpreter
    
    ACPICA commit a4849944e80f97970e99843f4975850753584a4e
    
    This change adds PCC operation region support in the AML interpreter
    and a default handler for acpiexec. According to the specification,
    the PCC operation region performs a transaction when the COMD field
    is written. This allows ASL to write data to other fields before
    sending the data.
    
    In order to accommodate this protocol, a temorary buffer is added
    to the regionfield object to accumulate writes. If any offset that
    spans COMD is written, the temporary buffer is sent to the PCC
    operation region handler to be processed.
    
    This change also renames the PCC keyword to platform_comm_channel.
    
    Link: https://github.com/acpica/acpica/commit/a4849944
    Reviewed-by: Kyle Pelton <kyle.d.pelton@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 8cc4392c61f3..eee263cb7beb 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -257,6 +257,10 @@ static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)
 
 			acpi_ut_delete_object_desc(second_desc);
 		}
+		if (object->field.internal_pcc_buffer) {
+			ACPI_FREE(object->field.internal_pcc_buffer);
+		}
+
 		break;
 
 	case ACPI_TYPE_BUFFER_FIELD:

commit ff5340f8ac94d65609424675d587c030da951a53
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Fri Aug 10 14:43:01 2018 -0700

    ACPICA: Reference count: add additional debugging details
    
    Make reference counting diagnostics provide more information on
    what has happened.
    
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 118f3ff1fbb5..8cc4392c61f3 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -355,6 +355,7 @@ acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
 	u16 original_count;
 	u16 new_count = 0;
 	acpi_cpu_flags lock_flags;
+	char *message;
 
 	ACPI_FUNCTION_NAME(ut_update_ref_count);
 
@@ -391,6 +392,7 @@ acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
 				  object, object->common.type,
 				  acpi_ut_get_object_type_name(object),
 				  new_count));
+		message = "Incremement";
 		break;
 
 	case REF_DECREMENT:
@@ -420,6 +422,7 @@ acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
 		if (new_count == 0) {
 			acpi_ut_delete_internal_obj(object);
 		}
+		message = "Decrement";
 		break;
 
 	default:
@@ -436,8 +439,8 @@ acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
 	 */
 	if (new_count > ACPI_MAX_REFERENCE_COUNT) {
 		ACPI_WARNING((AE_INFO,
-			      "Large Reference Count (0x%X) in object %p, Type=0x%.2X",
-			      new_count, object, object->common.type));
+			      "Large Reference Count (0x%X) in object %p, Type=0x%.2X Operation=%s",
+			      new_count, object, object->common.type, message));
 	}
 }
 

commit 95857638889aeea1b10a16b55041adf3e3ab84c4
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Wed Mar 14 16:13:07 2018 -0700

    ACPICA: adding SPDX headers
    
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index db98f0d991f7..118f3ff1fbb5 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -1,46 +1,10 @@
+// SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
 /*******************************************************************************
  *
  * Module Name: utdelete - object deletion and reference count utilities
  *
  ******************************************************************************/
 
-/*
- * Copyright (C) 2000 - 2018, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
 #include <acpi/acpi.h>
 #include "accommon.h"
 #include "acinterp.h"

commit 1ef6323148174798b55024d5442a02fea416ce21
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Feb 15 13:09:28 2018 -0800

    ACPICA: Update for some debug output. No functional change
    
    ACPICA commit 3a08436fe3bff297a6de162252964e955946c7d3
    
    Improve/simplify some of the debug messages.
    
    Link: https://github.com/acpica/acpica/commit/3a08436f
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 7d8d0208f0a3..db98f0d991f7 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -332,8 +332,10 @@ static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)
 
 	/* Now the object can be safely deleted */
 
-	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "Deleting Object %p [%s]\n",
-			  object, acpi_ut_get_object_type_name(object)));
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_ALLOCATIONS,
+			      "%s: Deleting Object %p [%s]\n",
+			      ACPI_GET_FUNCTION_NAME, object,
+			      acpi_ut_get_object_type_name(object)));
 
 	acpi_ut_delete_object_desc(object);
 	return_VOID;
@@ -444,9 +446,10 @@ acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
 				      object));
 		}
 
-		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
-				  "Obj %p Type %.2X Refs %.2X [Decremented]\n",
-				  object, object->common.type, new_count));
+		ACPI_DEBUG_PRINT_RAW((ACPI_DB_ALLOCATIONS,
+				      "%s: Obj %p Type %.2X Refs %.2X [Decremented]\n",
+				      ACPI_GET_FUNCTION_NAME, object,
+				      object->common.type, new_count));
 
 		/* Actually delete the object on a reference count of zero */
 
@@ -747,9 +750,10 @@ void acpi_ut_remove_reference(union acpi_operand_object *object)
 		return;
 	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
-			  "Obj %p Current Refs=%X [To Be Decremented]\n",
-			  object, object->common.reference_count));
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_ALLOCATIONS,
+			      "%s: Obj %p Current Refs=%X [To Be Decremented]\n",
+			      ACPI_GET_FUNCTION_NAME, object,
+			      object->common.reference_count));
 
 	/*
 	 * Decrement the reference count, and only actually delete the object

commit da6f8320d58623eae9b6fa2f09b1b4f60a772ce9
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 4 10:06:38 2018 -0800

    ACPICA: All acpica: Update copyrights to 2018
    
    including tool signons.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index c6eb9fae70f9..7d8d0208f0a3 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2017, Intel Corp.
+ * Copyright (C) 2000 - 2018, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 7735ca0eb4ebd6d47fdad40602d0ba7593219f8c
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Feb 8 11:00:08 2017 +0800

    ACPICA: Source tree: Update copyright notices to 2017
    
    ACPICA commit 16577e5265923f4999b4d2c0addb2343b18135e1
    
    Affects all files.
    
    Link: https://github.com/acpica/acpica/commit/16577e52
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 5cdd707040e2..c6eb9fae70f9 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2016, Intel Corp.
+ * Copyright (C) 2000 - 2017, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 7225d0467c59e55566df396d6ecd5baf26ef3d9b
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Dec 28 15:29:22 2016 +0800

    ACPICA: Utilities: Update debug output
    
    ACPICA commit 082b5b3ee31f74735e166858eeda025288604a5a
    
    Enhancement of miscellaneous debug output.
    
    Link: https://github.com/acpica/acpica/commit/082b5b3e
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 529d6c38ea7c..5cdd707040e2 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -421,8 +421,10 @@ acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
 		}
 
 		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
-				  "Obj %p Type %.2X Refs %.2X [Incremented]\n",
-				  object, object->common.type, new_count));
+				  "Obj %p Type %.2X [%s] Refs %.2X [Incremented]\n",
+				  object, object->common.type,
+				  acpi_ut_get_object_type_name(object),
+				  new_count));
 		break;
 
 	case REF_DECREMENT:

commit c8100dc4643d80a94f074dfc8a2af3d3d327b7aa
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 15 08:17:03 2016 +0800

    ACPICA: Additional 2016 copyright changes
    
    All tool/utility signons.
    Dual-license module header.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 1afd7427a90c..529d6c38ea7c 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2015, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 1fad87385e7e82f656fb661aef0f841e42991974
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Dec 29 13:54:36 2015 +0800

    ACPICA: Core: Major update for code formatting, no functional changes
    
    ACPICA commit dfa394471f6c01b2ee9433dbc143ec70cb9bca72
    
    Mostly indentation inconsistencies across the code. Split
    some long lines, etc.
    
    Link: https://github.com/acpica/acpica/commit/dfa39447
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 1638312e3d8f..1afd7427a90c 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -209,6 +209,7 @@ static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)
 			acpi_ut_delete_object_desc(object->method.mutex);
 			object->method.mutex = NULL;
 		}
+
 		if (object->method.node) {
 			object->method.node = NULL;
 		}
@@ -515,8 +516,8 @@ acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
 		}
 
 		/*
-		 * All sub-objects must have their reference count incremented also.
-		 * Different object types have different subobjects.
+		 * All sub-objects must have their reference count incremented
+		 * also. Different object types have different subobjects.
 		 */
 		switch (object->common.type) {
 		case ACPI_TYPE_DEVICE:

commit 07b9c91225055afeb2d75942fc36dd51c5553d90
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Jul 23 12:52:31 2015 +0800

    ACPICA: Executer: Add back pointing reference of method operand
    
    ACPICA commit 9dcd124e914e87495fbd1786d9484b962e0823e0
    
    This patch adds back pointing reference of the namespace node for a method
    operand. The namespace node then can be used in
    acpi_ds_terminate_control_method() to obtain method full path to be used by
    tracing facilities. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/9dcd124e
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 71fce389fd48..1638312e3d8f 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -209,6 +209,9 @@ static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)
 			acpi_ut_delete_object_desc(object->method.mutex);
 			object->method.mutex = NULL;
 		}
+		if (object->method.node) {
+			object->method.node = NULL;
+		}
 		break;
 
 	case ACPI_TYPE_REGION:

commit 82a809419429f2e6142d2c5d88d91661f8aecb87
Author: David E. Box <david.e.box@linux.intel.com>
Date:   Thu Feb 5 15:20:45 2015 +0800

    ACPICA: Update Copyright headers to 2015
    
    ACPICA commit 8990e73ab2aa15d6a0068b860ab54feff25bee36
    
    Link: https://github.com/acpica/acpica/commit/8990e73a
    Signed-off-by: David E. Box <david.e.box@linux.intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index a3516de213fa..71fce389fd48 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2014, Intel Corp.
+ * Copyright (C) 2000 - 2015, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit f953529f3b659a72c0982c2cf195158db96361f1
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Feb 26 10:33:47 2014 +0800

    ACPICA: Prevent infinite loops when traversing corrupted lists.
    
    This change hardens the ACPICA code to detect circular linked object
    lists and prevent an infinite loop if such corruption exists.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index ed4cb8683310..a3516de213fa 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -75,6 +75,7 @@ static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)
 	union acpi_operand_object *handler_desc;
 	union acpi_operand_object *second_desc;
 	union acpi_operand_object *next_desc;
+	union acpi_operand_object *start_desc;
 	union acpi_operand_object **last_obj_ptr;
 
 	ACPI_FUNCTION_TRACE_PTR(ut_delete_internal_obj, object);
@@ -235,10 +236,11 @@ static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)
 			if (handler_desc) {
 				next_desc =
 				    handler_desc->address_space.region_list;
+				start_desc = next_desc;
 				last_obj_ptr =
 				    &handler_desc->address_space.region_list;
 
-				/* Remove the region object from the handler's list */
+				/* Remove the region object from the handler list */
 
 				while (next_desc) {
 					if (next_desc == object) {
@@ -247,10 +249,19 @@ static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)
 						break;
 					}
 
-					/* Walk the linked list of handler */
+					/* Walk the linked list of handlers */
 
 					last_obj_ptr = &next_desc->region.next;
 					next_desc = next_desc->region.next;
+
+					/* Prevent infinite loop if list is corrupted */
+
+					if (next_desc == start_desc) {
+						ACPI_ERROR((AE_INFO,
+							    "Circular region list in address handler object %p",
+							    handler_desc));
+						return_VOID;
+					}
 				}
 
 				if (handler_desc->address_space.handler_flags &

commit fbb7a2dc2be493c87399550bdc2ddaa510cdf450
Author: Bob Moore <robert.moore@intel.com>
Date:   Sat Feb 8 09:42:25 2014 +0800

    ACPICA: Update ACPICA copyrights to 2014.
    
    Update ACPICA copyrights to 2014. Includes all source headers and
    signons for the various tools.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index c07d2227ea42..ed4cb8683310 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2013, Intel Corp.
+ * Copyright (C) 2000 - 2014, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 10622bf8ce432e6a53fd3c37163e99e99c9e43ee
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Oct 29 09:30:02 2013 +0800

    ACPICA: Linuxize: Change indentation of C labels.
    
    It is reported by kernel build test systems that all ACPICA source
    files in the kernel tree have incorrect label indentation.  This
    patch changes default indent option used in the release process to
    fix this bug.  Lv Zheng.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index d6b33f29d327..c07d2227ea42 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -649,7 +649,7 @@ acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
 
 	return (AE_OK);
 
-      error_exit:
+error_exit:
 
 	ACPI_EXCEPTION((AE_INFO, status,
 			"Could not update object reference count"));

commit 1d1ea1b723d9f239f736b8cf284327cbbf9d15d1
Author: Chao Guan <chao.guan@intel.com>
Date:   Sat Jun 8 00:58:14 2013 +0000

    ACPICA: Standardize all switch() blocks
    
    After many years, different formatting for switch() has crept in.
    This change makes every switch block identical. Chao Guan.
    ACPICA bugzilla 997.
    
    References: https://bugs.acpica.org/show_bug.cgi?id=997
    Signed-off-by: Chao Guan <chao.guan@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 29b930250b6f..d6b33f29d327 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -303,6 +303,7 @@ static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)
 		break;
 
 	default:
+
 		break;
 	}
 
@@ -508,7 +509,6 @@ acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
 		case ACPI_TYPE_PROCESSOR:
 		case ACPI_TYPE_POWER:
 		case ACPI_TYPE_THERMAL:
-
 			/*
 			 * Update the notify objects for these types (if present)
 			 * Two lists, system and device notify handlers.
@@ -623,6 +623,7 @@ acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
 
 		case ACPI_TYPE_REGION:
 		default:
+
 			break;	/* No subobjects for all other types */
 		}
 

commit 58892c962a0f8b7187b036e787223365864bde3f
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Apr 12 00:25:41 2013 +0000

    ACPICA: Add a lock to the internal object reference count mechanism
    
    Certain external interfaces need to update object references
    without holding the interpreter or namespace mutex objects. To
    prevent race conditions, add a spinlock around the increment
    and decrement of the reference counts for internal ACPI
    objects. Reported by Andriy Gapon (avg@FreeBSD.org).
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Andriy Gapon <avg@FreeBSD.org>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index fc11ad12747d..29b930250b6f 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -359,19 +359,20 @@ void acpi_ut_delete_internal_object_list(union acpi_operand_object **obj_list)
  * FUNCTION:    acpi_ut_update_ref_count
  *
  * PARAMETERS:  object          - Object whose ref count is to be updated
- *              action          - What to do
+ *              action          - What to do (REF_INCREMENT or REF_DECREMENT)
  *
- * RETURN:      New ref count
+ * RETURN:      None. Sets new reference count within the object
  *
- * DESCRIPTION: Modify the ref count and return it.
+ * DESCRIPTION: Modify the reference count for an internal acpi object
  *
  ******************************************************************************/
 
 static void
 acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
 {
-	u16 count;
-	u16 new_count;
+	u16 original_count;
+	u16 new_count = 0;
+	acpi_cpu_flags lock_flags;
 
 	ACPI_FUNCTION_NAME(ut_update_ref_count);
 
@@ -379,46 +380,58 @@ acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
 		return;
 	}
 
-	count = object->common.reference_count;
-	new_count = count;
-
 	/*
-	 * Perform the reference count action (increment, decrement, force delete)
+	 * Always get the reference count lock. Note: Interpreter and/or
+	 * Namespace is not always locked when this function is called.
 	 */
+	lock_flags = acpi_os_acquire_lock(acpi_gbl_reference_count_lock);
+	original_count = object->common.reference_count;
+
+	/* Perform the reference count action (increment, decrement) */
+
 	switch (action) {
 	case REF_INCREMENT:
 
-		new_count++;
+		new_count = original_count + 1;
 		object->common.reference_count = new_count;
+		acpi_os_release_lock(acpi_gbl_reference_count_lock, lock_flags);
+
+		/* The current reference count should never be zero here */
+
+		if (!original_count) {
+			ACPI_WARNING((AE_INFO,
+				      "Obj %p, Reference Count was zero before increment\n",
+				      object));
+		}
 
 		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
-				  "Obj %p Refs=%X, [Incremented]\n",
-				  object, new_count));
+				  "Obj %p Type %.2X Refs %.2X [Incremented]\n",
+				  object, object->common.type, new_count));
 		break;
 
 	case REF_DECREMENT:
 
-		if (count < 1) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
-					  "Obj %p Refs=%X, can't decrement! (Set to 0)\n",
-					  object, new_count));
-
-			new_count = 0;
-		} else {
-			new_count--;
+		/* The current reference count must be non-zero */
 
-			ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
-					  "Obj %p Refs=%X, [Decremented]\n",
-					  object, new_count));
+		if (original_count) {
+			new_count = original_count - 1;
+			object->common.reference_count = new_count;
 		}
 
-		if (object->common.type == ACPI_TYPE_METHOD) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
-					  "Method Obj %p Refs=%X, [Decremented]\n",
-					  object, new_count));
+		acpi_os_release_lock(acpi_gbl_reference_count_lock, lock_flags);
+
+		if (!original_count) {
+			ACPI_WARNING((AE_INFO,
+				      "Obj %p, Reference Count is already zero, cannot decrement\n",
+				      object));
 		}
 
-		object->common.reference_count = new_count;
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "Obj %p Type %.2X Refs %.2X [Decremented]\n",
+				  object, object->common.type, new_count));
+
+		/* Actually delete the object on a reference count of zero */
+
 		if (new_count == 0) {
 			acpi_ut_delete_internal_obj(object);
 		}
@@ -426,18 +439,20 @@ acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
 
 	default:
 
-		ACPI_ERROR((AE_INFO, "Unknown action (0x%X)", action));
-		break;
+		acpi_os_release_lock(acpi_gbl_reference_count_lock, lock_flags);
+		ACPI_ERROR((AE_INFO, "Unknown Reference Count action (0x%X)",
+			    action));
+		return;
 	}
 
 	/*
 	 * Sanity check the reference count, for debug purposes only.
 	 * (A deleted object will have a huge reference count)
 	 */
-	if (count > ACPI_MAX_REFERENCE_COUNT) {
+	if (new_count > ACPI_MAX_REFERENCE_COUNT) {
 		ACPI_WARNING((AE_INFO,
-			      "Large Reference Count (0x%X) in object %p",
-			      count, object));
+			      "Large Reference Count (0x%X) in object %p, Type=0x%.2X",
+			      new_count, object, object->common.type));
 	}
 }
 
@@ -702,7 +717,6 @@ void acpi_ut_remove_reference(union acpi_operand_object *object)
 	/*
 	 * Allow a NULL pointer to be passed in, just ignore it. This saves
 	 * each caller from having to check. Also, ignore NS nodes.
-	 *
 	 */
 	if (!object ||
 	    (ACPI_GET_DESCRIPTOR_TYPE(object) == ACPI_DESC_TYPE_NAMED)) {

commit 60f3deb54f413404f3aa1190e48b154481413a39
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Apr 12 00:25:29 2013 +0000

    ACPICA: Remove FORCE_DELETE option for global reference count mechanism
    
    This option is not used and is obsolete.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 2541de420249..fc11ad12747d 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -424,17 +424,6 @@ acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
 		}
 		break;
 
-	case REF_FORCE_DELETE:
-
-		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
-				  "Obj %p Refs=%X, Force delete! (Set to 0)\n",
-				  object, count));
-
-		new_count = 0;
-		object->common.reference_count = new_count;
-		acpi_ut_delete_internal_obj(object);
-		break;
-
 	default:
 
 		ACPI_ERROR((AE_INFO, "Unknown action (0x%X)", action));
@@ -458,8 +447,7 @@ acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
  *
  * PARAMETERS:  object              - Increment ref count for this object
  *                                    and all sub-objects
- *              action              - Either REF_INCREMENT or REF_DECREMENT or
- *                                    REF_FORCE_DELETE
+ *              action              - Either REF_INCREMENT or REF_DECREMENT
  *
  * RETURN:      Status
  *

commit 25f044e64568dd83de34c16c837a96bbb2b0cecb
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 25 05:38:56 2013 +0000

    ACPICA: Update ACPICA copyrights to 2013
    
    Includes all source headers and signons for the various tools.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index c8bf44f522dd..2541de420249 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2013, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit c8d586f8ed0146d81186131df66cdbb19c41acda
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Dec 31 00:05:39 2012 +0000

    ACPICA: Lint changes, no functional change.
    
    Some changes from lint.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 53e6af801661..c8bf44f522dd 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -340,7 +340,7 @@ void acpi_ut_delete_internal_object_list(union acpi_operand_object **obj_list)
 {
 	union acpi_operand_object **internal_obj;
 
-	ACPI_FUNCTION_NAME(ut_delete_internal_object_list);
+	ACPI_FUNCTION_ENTRY();
 
 	/* Walk the null-terminated internal list */
 

commit 0e770b3263816b4445e2c855f641b172aa26291a
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Dec 19 05:37:59 2012 +0000

    ACPICA: Performance: Remove function tracing from critical allocation functions.
    
    Tracing is no longer needed for many of the low-level function.
    Removing the trace mechanism from these functions improves
    performance a small amount, also simplifies the debug trace output.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index e806fb02187b..53e6af801661 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -340,7 +340,7 @@ void acpi_ut_delete_internal_object_list(union acpi_operand_object **obj_list)
 {
 	union acpi_operand_object **internal_obj;
 
-	ACPI_FUNCTION_TRACE(ut_delete_internal_object_list);
+	ACPI_FUNCTION_NAME(ut_delete_internal_object_list);
 
 	/* Walk the null-terminated internal list */
 
@@ -351,7 +351,7 @@ void acpi_ut_delete_internal_object_list(union acpi_operand_object **obj_list)
 	/* Free the combined parameter pointer list and object array */
 
 	ACPI_FREE(obj_list);
-	return_VOID;
+	return;
 }
 
 /*******************************************************************************
@@ -484,7 +484,7 @@ acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
 	union acpi_generic_state *state;
 	u32 i;
 
-	ACPI_FUNCTION_TRACE_PTR(ut_update_object_reference, object);
+	ACPI_FUNCTION_NAME(ut_update_object_reference);
 
 	while (object) {
 
@@ -493,7 +493,7 @@ acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
 		if (ACPI_GET_DESCRIPTOR_TYPE(object) == ACPI_DESC_TYPE_NAMED) {
 			ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
 					  "Object %p is NS handle\n", object));
-			return_ACPI_STATUS(AE_OK);
+			return (AE_OK);
 		}
 
 		/*
@@ -643,7 +643,7 @@ acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
 		}
 	}
 
-	return_ACPI_STATUS(AE_OK);
+	return (AE_OK);
 
       error_exit:
 
@@ -657,7 +657,7 @@ acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
 		acpi_ut_delete_generic_state(state);
 	}
 
-	return_ACPI_STATUS(status);
+	return (status);
 }
 
 /*******************************************************************************
@@ -676,12 +676,12 @@ acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
 void acpi_ut_add_reference(union acpi_operand_object *object)
 {
 
-	ACPI_FUNCTION_TRACE_PTR(ut_add_reference, object);
+	ACPI_FUNCTION_NAME(ut_add_reference);
 
 	/* Ensure that we have a valid object */
 
 	if (!acpi_ut_valid_internal_object(object)) {
-		return_VOID;
+		return;
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
@@ -691,7 +691,7 @@ void acpi_ut_add_reference(union acpi_operand_object *object)
 	/* Increment the reference count */
 
 	(void)acpi_ut_update_object_reference(object, REF_INCREMENT);
-	return_VOID;
+	return;
 }
 
 /*******************************************************************************
@@ -709,7 +709,7 @@ void acpi_ut_add_reference(union acpi_operand_object *object)
 void acpi_ut_remove_reference(union acpi_operand_object *object)
 {
 
-	ACPI_FUNCTION_TRACE_PTR(ut_remove_reference, object);
+	ACPI_FUNCTION_NAME(ut_remove_reference);
 
 	/*
 	 * Allow a NULL pointer to be passed in, just ignore it. This saves
@@ -718,13 +718,13 @@ void acpi_ut_remove_reference(union acpi_operand_object *object)
 	 */
 	if (!object ||
 	    (ACPI_GET_DESCRIPTOR_TYPE(object) == ACPI_DESC_TYPE_NAMED)) {
-		return_VOID;
+		return;
 	}
 
 	/* Ensure that we have a valid object */
 
 	if (!acpi_ut_valid_internal_object(object)) {
-		return_VOID;
+		return;
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
@@ -737,5 +737,5 @@ void acpi_ut_remove_reference(union acpi_operand_object *object)
 	 * of all subobjects!)
 	 */
 	(void)acpi_ut_update_object_reference(object, REF_DECREMENT);
-	return_VOID;
+	return;
 }

commit 53938551c827d2016912ae5a431a7dad76c2426a
Author: Chao Guan <chao.guan@intel.com>
Date:   Wed Dec 19 05:37:53 2012 +0000

    ACPICA: Performance enhancement for ACPI package objects.
    
    This change greatly increases the performance of package objects
    within the interpreter. It changes the processing of reference
    counts for packages by optimizing for the most common case where
    the package subobjects are either integers, strings, or buffers.
    Increases the performance of the ASLTS test suite by 1.5X.
    Chao Guan. ACPICA BZ 943.
    https://www.acpica.org/bugzilla/show_bug.cgi?id=943
    
    Signed-off-by: Chao Guan <chao.guan@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 798105443d0f..e806fb02187b 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -530,18 +530,42 @@ acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
 			 */
 			for (i = 0; i < object->package.count; i++) {
 				/*
-				 * Push each element onto the stack for later processing.
-				 * Note: There can be null elements within the package,
-				 * these are simply ignored
+				 * Null package elements are legal and can be simply
+				 * ignored.
 				 */
-				status =
-				    acpi_ut_create_update_state_and_push
-				    (object->package.elements[i], action,
-				     &state_list);
-				if (ACPI_FAILURE(status)) {
-					goto error_exit;
+				next_object = object->package.elements[i];
+				if (!next_object) {
+					continue;
+				}
+
+				switch (next_object->common.type) {
+				case ACPI_TYPE_INTEGER:
+				case ACPI_TYPE_STRING:
+				case ACPI_TYPE_BUFFER:
+					/*
+					 * For these very simple sub-objects, we can just
+					 * update the reference count here and continue.
+					 * Greatly increases performance of this operation.
+					 */
+					acpi_ut_update_ref_count(next_object,
+								 action);
+					break;
+
+				default:
+					/*
+					 * For complex sub-objects, push them onto the stack
+					 * for later processing (this eliminates recursion.)
+					 */
+					status =
+					    acpi_ut_create_update_state_and_push
+					    (next_object, action, &state_list);
+					if (ACPI_FAILURE(status)) {
+						goto error_exit;
+					}
+					break;
 				}
 			}
+			next_object = NULL;
 			break;
 
 		case ACPI_TYPE_BUFFER_FIELD:

commit ba494beeaa69bc0fb01eb89464ad5d57d26e3901
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jul 12 09:40:10 2012 +0800

    ACPICA: AcpiSrc: Fix some translation issues for Linux conversion
    
    Fixes issues like this:
    
    i_aSL -> iASL
    00-7_f -> 00-7F
    local_fADT -> local_FADT
    execute_oSI -> execute_OSI
    
    Also, in function headers, the parameters are now translated to
    lower case (with underscores if necessary.)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 0d50f2c6bac2..798105443d0f 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -60,7 +60,7 @@ acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action);
  *
  * FUNCTION:    acpi_ut_delete_internal_obj
  *
- * PARAMETERS:  Object         - Object to be deleted
+ * PARAMETERS:  object         - Object to be deleted
  *
  * RETURN:      None
  *
@@ -358,8 +358,8 @@ void acpi_ut_delete_internal_object_list(union acpi_operand_object **obj_list)
  *
  * FUNCTION:    acpi_ut_update_ref_count
  *
- * PARAMETERS:  Object          - Object whose ref count is to be updated
- *              Action          - What to do
+ * PARAMETERS:  object          - Object whose ref count is to be updated
+ *              action          - What to do
  *
  * RETURN:      New ref count
  *
@@ -456,9 +456,9 @@ acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
  *
  * FUNCTION:    acpi_ut_update_object_reference
  *
- * PARAMETERS:  Object              - Increment ref count for this object
+ * PARAMETERS:  object              - Increment ref count for this object
  *                                    and all sub-objects
- *              Action              - Either REF_INCREMENT or REF_DECREMENT or
+ *              action              - Either REF_INCREMENT or REF_DECREMENT or
  *                                    REF_FORCE_DELETE
  *
  * RETURN:      Status
@@ -640,7 +640,7 @@ acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
  *
  * FUNCTION:    acpi_ut_add_reference
  *
- * PARAMETERS:  Object          - Object whose reference count is to be
+ * PARAMETERS:  object          - Object whose reference count is to be
  *                                incremented
  *
  * RETURN:      None
@@ -674,7 +674,7 @@ void acpi_ut_add_reference(union acpi_operand_object *object)
  *
  * FUNCTION:    acpi_ut_remove_reference
  *
- * PARAMETERS:  Object         - Object whose ref count will be decremented
+ * PARAMETERS:  object         - Object whose ref count will be decremented
  *
  * RETURN:      None
  *

commit 86ed4bc83abf530cf2019044b74f89a39dfd6425
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu May 3 11:08:19 2012 +0800

    ACPICA: Add support for multiple notify handlers
    
    This change adds support to allow multiple notify handlers on
    Device, ThermalZone, and Processor objects. Also re-worked
    and restructured the entire notify support code for handler
    installation, handler removal, notify event queuing, and notify
    dispatch to handler.
    
    Extends and updates original commit 3f0be67("ACPI / ACPICA: Multiple
    system notify handlers per device") by Rafael Wysocki.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 2a6c3e183697..0d50f2c6bac2 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -152,7 +152,7 @@ static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)
 	case ACPI_TYPE_PROCESSOR:
 	case ACPI_TYPE_THERMAL:
 
-		/* Walk the notify handler list for this object */
+		/* Walk the address handler list for this object */
 
 		handler_desc = object->common_notify.handler;
 		while (handler_desc) {
@@ -480,6 +480,7 @@ acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
 	acpi_status status = AE_OK;
 	union acpi_generic_state *state_list = NULL;
 	union acpi_operand_object *next_object = NULL;
+	union acpi_operand_object *prev_object;
 	union acpi_generic_state *state;
 	u32 i;
 
@@ -505,12 +506,21 @@ acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
 		case ACPI_TYPE_POWER:
 		case ACPI_TYPE_THERMAL:
 
-			/* Update the notify objects for these types (if present) */
-
-			acpi_ut_update_ref_count(object->common_notify.
-						 system_notify, action);
-			acpi_ut_update_ref_count(object->common_notify.
-						 device_notify, action);
+			/*
+			 * Update the notify objects for these types (if present)
+			 * Two lists, system and device notify handlers.
+			 */
+			for (i = 0; i < ACPI_NUM_NOTIFY_TYPES; i++) {
+				prev_object =
+				    object->common_notify.notify_list[i];
+				while (prev_object) {
+					next_object =
+					    prev_object->notify.next[i];
+					acpi_ut_update_ref_count(prev_object,
+								 action);
+					prev_object = next_object;
+				}
+			}
 			break;
 
 		case ACPI_TYPE_PACKAGE:

commit 77848130e53b06c22fe37a7b6acbb82bb3e9bfba
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 12 13:27:23 2012 +0800

    ACPICA: Update all copyrights to 2012
    
    Update all copyrights to 2012.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 93ec06b0fe25..2a6c3e183697 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2011, Intel Corp.
+ * Copyright (C) 2000 - 2012, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit f654c0fefa8c16d439185b61442710fadc167e78
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Thu Jan 12 13:10:32 2012 +0800

    ACPICA: Add support for region address conflict checking
    
    Allows drivers to determine if any memory or I/O addresses
    will conflict with addresses used by ACPI operation regions.
    Introduces a new interface, acpi_check_address_range.
    
    http://marc.info/?t=132251388700002&r=1&w=2
    
    Reported-and-tested-by: Luca Tettamanti <kronos.it@gmail.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 31f5a7832ef1..93ec06b0fe25 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -215,11 +215,14 @@ static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)
 		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
 				  "***** Region %p\n", object));
 
-		/* Invalidate the region address/length via the host OS */
-
-		acpi_os_invalidate_address(object->region.space_id,
-					  object->region.address,
-					  (acpi_size) object->region.length);
+		/*
+		 * Update address_range list. However, only permanent regions
+		 * are installed in this list. (Not created within a method)
+		 */
+		if (!(object->region.node->flags & ANOBJ_TEMPORARY)) {
+			acpi_ut_remove_address_range(object->region.space_id,
+						     object->region.node);
+		}
 
 		second_desc = acpi_ns_get_secondary_object(object);
 		if (second_desc) {

commit b4e104eaeb8cd4329a23e0e4ebf166681b1d182d
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jan 17 11:05:40 2011 +0800

    ACPICA: Update all ACPICA copyrights and signons to 2011
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index ed794cd033ea..31f5a7832ef1 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2010, Intel Corp.
+ * Copyright (C) 2000 - 2011, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit f6a22b0bc417042e83117f52ab1a03696af185ab
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Mar 5 17:56:40 2010 +0800

    ACPICA: Standardize integer output for ACPICA warnings/errors
    
    Always use 0x prefix for hex output, use %u for integer output
    (all integers are unsigned.)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 16b51c69606a..ed794cd033ea 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -434,7 +434,7 @@ acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
 
 	default:
 
-		ACPI_ERROR((AE_INFO, "Unknown action (%X)", action));
+		ACPI_ERROR((AE_INFO, "Unknown action (0x%X)", action));
 		break;
 	}
 
@@ -444,8 +444,8 @@ acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
 	 */
 	if (count > ACPI_MAX_REFERENCE_COUNT) {
 		ACPI_WARNING((AE_INFO,
-			      "Large Reference Count (%X) in object %p", count,
-			      object));
+			      "Large Reference Count (0x%X) in object %p",
+			      count, object));
 	}
 }
 

commit a8357b0c95484b46944728712f8810d3b37bf588
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 22 19:07:36 2010 +0800

    ACPICA: Update all ACPICA copyrights and signons to 2010
    
    Add 2010 copyright to all module headers and signons, including
    the Linux header. This affects virtually every file in the ACPICA
    core subsystem, iASL compiler, and all utilities.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 96e26e70c63d..16b51c69606a 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2008, Intel Corp.
+ * Copyright (C) 2000 - 2010, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit a5fe1a03f7720b8da8364a1737e1e5a357904e99
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Thu Aug 13 10:43:27 2009 +0800

    ACPICA: fix leak of acpi_os_validate_address
    
    http://bugzilla.kernel.org/show_bug.cgi?id=13620
    
    If the dynamic region is created and added to resource list over and over again,
    it has the potential to be a memory leak by growing the list every time.
    
    This patch fixes the memory leak, as below
    
    1) add a new field "count" to struct acpi_res_list.
    
       When inserting, if the region(addr, len) is already in the resource
       list, we just increase "count", otherwise, the region is inserted
       with count=1.
    
       When deleting, the "count" is decreased, if it's decreased to 0,
       the region is deleted from the resource list.
    
       With "count", the region with same address and length can only be
       inserted to the resource list once, so prevent potential memory leak.
    
    2) add a new function acpi_os_invalidate_address, which is called when
       region is deleted.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index bc1710315088..96e26e70c63d 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -215,6 +215,12 @@ static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)
 		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
 				  "***** Region %p\n", object));
 
+		/* Invalidate the region address/length via the host OS */
+
+		acpi_os_invalidate_address(object->region.space_id,
+					  object->region.address,
+					  (acpi_size) object->region.length);
+
 		second_desc = acpi_ns_get_secondary_object(object);
 		if (second_desc) {
 			/*

commit 3362a6badb4fe75e198885b125b21ccf846861b4
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Thu May 21 11:03:29 2009 +0800

    ACPICA: Region deletion: Ensure region object is removed from handler list
    
    Prevents a possible fault when a dynamic operation region is
    deleted. ACPICA BZ 507.
    
    http://acpica.org/bugzilla/show_bug.cgi?id=507
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index a5ee23bc4f55..bc1710315088 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -75,6 +75,7 @@ static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)
 	union acpi_operand_object *handler_desc;
 	union acpi_operand_object *second_desc;
 	union acpi_operand_object *next_desc;
+	union acpi_operand_object **last_obj_ptr;
 
 	ACPI_FUNCTION_TRACE_PTR(ut_delete_internal_obj, object);
 
@@ -223,6 +224,26 @@ static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)
 			 */
 			handler_desc = object->region.handler;
 			if (handler_desc) {
+				next_desc =
+				    handler_desc->address_space.region_list;
+				last_obj_ptr =
+				    &handler_desc->address_space.region_list;
+
+				/* Remove the region object from the handler's list */
+
+				while (next_desc) {
+					if (next_desc == object) {
+						*last_obj_ptr =
+						    next_desc->region.next;
+						break;
+					}
+
+					/* Walk the linked list of handler */
+
+					last_obj_ptr = &next_desc->region.next;
+					next_desc = next_desc->region.next;
+				}
+
 				if (handler_desc->address_space.handler_flags &
 				    ACPI_ADDR_HANDLER_DEFAULT_INSTALLED) {
 

commit 3371c19c294a4cb3649aa4e84606be8a1d999e61
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Feb 18 14:44:03 2009 +0800

    ACPICA: Remove ACPI_GET_OBJECT_TYPE macro
    
    Remove all instances of this obsolete macro, since it is now a
    simple reference to ->common.type. There were about 150 invocations
    of the macro across 41 files. ACPICA BZ 755.
    
    http://www.acpica.org/bugzilla/show_bug.cgi?id=755
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index a0be9e39531e..a5ee23bc4f55 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -86,7 +86,7 @@ static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)
 	 * Must delete or free any pointers within the object that are not
 	 * actual ACPI objects (for example, a raw buffer pointer).
 	 */
-	switch (ACPI_GET_OBJECT_TYPE(object)) {
+	switch (object->common.type) {
 	case ACPI_TYPE_STRING:
 
 		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
@@ -382,7 +382,7 @@ acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
 					  object, new_count));
 		}
 
-		if (ACPI_GET_OBJECT_TYPE(object) == ACPI_TYPE_METHOD) {
+		if (object->common.type == ACPI_TYPE_METHOD) {
 			ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
 					  "Method Obj %p Refs=%X, [Decremented]\n",
 					  object, new_count));
@@ -469,7 +469,7 @@ acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
 		 * All sub-objects must have their reference count incremented also.
 		 * Different object types have different subobjects.
 		 */
-		switch (ACPI_GET_OBJECT_TYPE(object)) {
+		switch (object->common.type) {
 		case ACPI_TYPE_DEVICE:
 		case ACPI_TYPE_PROCESSOR:
 		case ACPI_TYPE_POWER:

commit e2f7a7772880458edff1b1cc5a988947229fac26
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 00:30:03 2009 -0500

    ACPICA: hide private headers
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
index 5b4e3b1a7523..a0be9e39531e 100644
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@ -42,10 +42,10 @@
  */
 
 #include <acpi/acpi.h>
-#include <acpi/accommon.h>
-#include <acpi/acinterp.h>
-#include <acpi/acnamesp.h>
-#include <acpi/acevents.h>
+#include "accommon.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+#include "acevents.h"
 
 #define _COMPONENT          ACPI_UTILITIES
 ACPI_MODULE_NAME("utdelete")

commit 95b482a8d31116f3f5c2a5089569393234d06385
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 00:13:17 2009 -0500

    ACPICA: create acpica/ directory
    
    also, delete sleep/ and delete ACPI_CFLAGS from Makefile
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/utdelete.c b/drivers/acpi/acpica/utdelete.c
new file mode 100644
index 000000000000..5b4e3b1a7523
--- /dev/null
+++ b/drivers/acpi/acpica/utdelete.c
@@ -0,0 +1,677 @@
+/*******************************************************************************
+ *
+ * Module Name: utdelete - object deletion and reference count utilities
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2008, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include <acpi/accommon.h>
+#include <acpi/acinterp.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acevents.h>
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utdelete")
+
+/* Local prototypes */
+static void acpi_ut_delete_internal_obj(union acpi_operand_object *object);
+
+static void
+acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_delete_internal_obj
+ *
+ * PARAMETERS:  Object         - Object to be deleted
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Low level object deletion, after reference counts have been
+ *              updated (All reference counts, including sub-objects!)
+ *
+ ******************************************************************************/
+
+static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)
+{
+	void *obj_pointer = NULL;
+	union acpi_operand_object *handler_desc;
+	union acpi_operand_object *second_desc;
+	union acpi_operand_object *next_desc;
+
+	ACPI_FUNCTION_TRACE_PTR(ut_delete_internal_obj, object);
+
+	if (!object) {
+		return_VOID;
+	}
+
+	/*
+	 * Must delete or free any pointers within the object that are not
+	 * actual ACPI objects (for example, a raw buffer pointer).
+	 */
+	switch (ACPI_GET_OBJECT_TYPE(object)) {
+	case ACPI_TYPE_STRING:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "**** String %p, ptr %p\n", object,
+				  object->string.pointer));
+
+		/* Free the actual string buffer */
+
+		if (!(object->common.flags & AOPOBJ_STATIC_POINTER)) {
+
+			/* But only if it is NOT a pointer into an ACPI table */
+
+			obj_pointer = object->string.pointer;
+		}
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "**** Buffer %p, ptr %p\n", object,
+				  object->buffer.pointer));
+
+		/* Free the actual buffer */
+
+		if (!(object->common.flags & AOPOBJ_STATIC_POINTER)) {
+
+			/* But only if it is NOT a pointer into an ACPI table */
+
+			obj_pointer = object->buffer.pointer;
+		}
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  " **** Package of count %X\n",
+				  object->package.count));
+
+		/*
+		 * Elements of the package are not handled here, they are deleted
+		 * separately
+		 */
+
+		/* Free the (variable length) element pointer array */
+
+		obj_pointer = object->package.elements;
+		break;
+
+		/*
+		 * These objects have a possible list of notify handlers.
+		 * Device object also may have a GPE block.
+		 */
+	case ACPI_TYPE_DEVICE:
+
+		if (object->device.gpe_block) {
+			(void)acpi_ev_delete_gpe_block(object->device.
+						       gpe_block);
+		}
+
+		/*lint -fallthrough */
+
+	case ACPI_TYPE_PROCESSOR:
+	case ACPI_TYPE_THERMAL:
+
+		/* Walk the notify handler list for this object */
+
+		handler_desc = object->common_notify.handler;
+		while (handler_desc) {
+			next_desc = handler_desc->address_space.next;
+			acpi_ut_remove_reference(handler_desc);
+			handler_desc = next_desc;
+		}
+		break;
+
+	case ACPI_TYPE_MUTEX:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "***** Mutex %p, OS Mutex %p\n",
+				  object, object->mutex.os_mutex));
+
+		if (object == acpi_gbl_global_lock_mutex) {
+
+			/* Global Lock has extra semaphore */
+
+			(void)
+			    acpi_os_delete_semaphore
+			    (acpi_gbl_global_lock_semaphore);
+			acpi_gbl_global_lock_semaphore = NULL;
+
+			acpi_os_delete_mutex(object->mutex.os_mutex);
+			acpi_gbl_global_lock_mutex = NULL;
+		} else {
+			acpi_ex_unlink_mutex(object);
+			acpi_os_delete_mutex(object->mutex.os_mutex);
+		}
+		break;
+
+	case ACPI_TYPE_EVENT:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "***** Event %p, OS Semaphore %p\n",
+				  object, object->event.os_semaphore));
+
+		(void)acpi_os_delete_semaphore(object->event.os_semaphore);
+		object->event.os_semaphore = NULL;
+		break;
+
+	case ACPI_TYPE_METHOD:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "***** Method %p\n", object));
+
+		/* Delete the method mutex if it exists */
+
+		if (object->method.mutex) {
+			acpi_os_delete_mutex(object->method.mutex->mutex.
+					     os_mutex);
+			acpi_ut_delete_object_desc(object->method.mutex);
+			object->method.mutex = NULL;
+		}
+		break;
+
+	case ACPI_TYPE_REGION:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "***** Region %p\n", object));
+
+		second_desc = acpi_ns_get_secondary_object(object);
+		if (second_desc) {
+			/*
+			 * Free the region_context if and only if the handler is one of the
+			 * default handlers -- and therefore, we created the context object
+			 * locally, it was not created by an external caller.
+			 */
+			handler_desc = object->region.handler;
+			if (handler_desc) {
+				if (handler_desc->address_space.handler_flags &
+				    ACPI_ADDR_HANDLER_DEFAULT_INSTALLED) {
+
+					/* Deactivate region and free region context */
+
+					if (handler_desc->address_space.setup) {
+						(void)handler_desc->
+						    address_space.setup(object,
+									ACPI_REGION_DEACTIVATE,
+									handler_desc->
+									address_space.
+									context,
+									&second_desc->
+									extra.
+									region_context);
+					}
+				}
+
+				acpi_ut_remove_reference(handler_desc);
+			}
+
+			/* Now we can free the Extra object */
+
+			acpi_ut_delete_object_desc(second_desc);
+		}
+		break;
+
+	case ACPI_TYPE_BUFFER_FIELD:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "***** Buffer Field %p\n", object));
+
+		second_desc = acpi_ns_get_secondary_object(object);
+		if (second_desc) {
+			acpi_ut_delete_object_desc(second_desc);
+		}
+		break;
+
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "***** Bank Field %p\n", object));
+
+		second_desc = acpi_ns_get_secondary_object(object);
+		if (second_desc) {
+			acpi_ut_delete_object_desc(second_desc);
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	/* Free any allocated memory (pointer within the object) found above */
+
+	if (obj_pointer) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "Deleting Object Subptr %p\n", obj_pointer));
+		ACPI_FREE(obj_pointer);
+	}
+
+	/* Now the object can be safely deleted */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "Deleting Object %p [%s]\n",
+			  object, acpi_ut_get_object_type_name(object)));
+
+	acpi_ut_delete_object_desc(object);
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_delete_internal_object_list
+ *
+ * PARAMETERS:  obj_list        - Pointer to the list to be deleted
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: This function deletes an internal object list, including both
+ *              simple objects and package objects
+ *
+ ******************************************************************************/
+
+void acpi_ut_delete_internal_object_list(union acpi_operand_object **obj_list)
+{
+	union acpi_operand_object **internal_obj;
+
+	ACPI_FUNCTION_TRACE(ut_delete_internal_object_list);
+
+	/* Walk the null-terminated internal list */
+
+	for (internal_obj = obj_list; *internal_obj; internal_obj++) {
+		acpi_ut_remove_reference(*internal_obj);
+	}
+
+	/* Free the combined parameter pointer list and object array */
+
+	ACPI_FREE(obj_list);
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_update_ref_count
+ *
+ * PARAMETERS:  Object          - Object whose ref count is to be updated
+ *              Action          - What to do
+ *
+ * RETURN:      New ref count
+ *
+ * DESCRIPTION: Modify the ref count and return it.
+ *
+ ******************************************************************************/
+
+static void
+acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
+{
+	u16 count;
+	u16 new_count;
+
+	ACPI_FUNCTION_NAME(ut_update_ref_count);
+
+	if (!object) {
+		return;
+	}
+
+	count = object->common.reference_count;
+	new_count = count;
+
+	/*
+	 * Perform the reference count action (increment, decrement, force delete)
+	 */
+	switch (action) {
+	case REF_INCREMENT:
+
+		new_count++;
+		object->common.reference_count = new_count;
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "Obj %p Refs=%X, [Incremented]\n",
+				  object, new_count));
+		break;
+
+	case REF_DECREMENT:
+
+		if (count < 1) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+					  "Obj %p Refs=%X, can't decrement! (Set to 0)\n",
+					  object, new_count));
+
+			new_count = 0;
+		} else {
+			new_count--;
+
+			ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+					  "Obj %p Refs=%X, [Decremented]\n",
+					  object, new_count));
+		}
+
+		if (ACPI_GET_OBJECT_TYPE(object) == ACPI_TYPE_METHOD) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+					  "Method Obj %p Refs=%X, [Decremented]\n",
+					  object, new_count));
+		}
+
+		object->common.reference_count = new_count;
+		if (new_count == 0) {
+			acpi_ut_delete_internal_obj(object);
+		}
+		break;
+
+	case REF_FORCE_DELETE:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "Obj %p Refs=%X, Force delete! (Set to 0)\n",
+				  object, count));
+
+		new_count = 0;
+		object->common.reference_count = new_count;
+		acpi_ut_delete_internal_obj(object);
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Unknown action (%X)", action));
+		break;
+	}
+
+	/*
+	 * Sanity check the reference count, for debug purposes only.
+	 * (A deleted object will have a huge reference count)
+	 */
+	if (count > ACPI_MAX_REFERENCE_COUNT) {
+		ACPI_WARNING((AE_INFO,
+			      "Large Reference Count (%X) in object %p", count,
+			      object));
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_update_object_reference
+ *
+ * PARAMETERS:  Object              - Increment ref count for this object
+ *                                    and all sub-objects
+ *              Action              - Either REF_INCREMENT or REF_DECREMENT or
+ *                                    REF_FORCE_DELETE
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Increment the object reference count
+ *
+ * Object references are incremented when:
+ * 1) An object is attached to a Node (namespace object)
+ * 2) An object is copied (all subobjects must be incremented)
+ *
+ * Object references are decremented when:
+ * 1) An object is detached from an Node
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
+{
+	acpi_status status = AE_OK;
+	union acpi_generic_state *state_list = NULL;
+	union acpi_operand_object *next_object = NULL;
+	union acpi_generic_state *state;
+	u32 i;
+
+	ACPI_FUNCTION_TRACE_PTR(ut_update_object_reference, object);
+
+	while (object) {
+
+		/* Make sure that this isn't a namespace handle */
+
+		if (ACPI_GET_DESCRIPTOR_TYPE(object) == ACPI_DESC_TYPE_NAMED) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+					  "Object %p is NS handle\n", object));
+			return_ACPI_STATUS(AE_OK);
+		}
+
+		/*
+		 * All sub-objects must have their reference count incremented also.
+		 * Different object types have different subobjects.
+		 */
+		switch (ACPI_GET_OBJECT_TYPE(object)) {
+		case ACPI_TYPE_DEVICE:
+		case ACPI_TYPE_PROCESSOR:
+		case ACPI_TYPE_POWER:
+		case ACPI_TYPE_THERMAL:
+
+			/* Update the notify objects for these types (if present) */
+
+			acpi_ut_update_ref_count(object->common_notify.
+						 system_notify, action);
+			acpi_ut_update_ref_count(object->common_notify.
+						 device_notify, action);
+			break;
+
+		case ACPI_TYPE_PACKAGE:
+			/*
+			 * We must update all the sub-objects of the package,
+			 * each of whom may have their own sub-objects.
+			 */
+			for (i = 0; i < object->package.count; i++) {
+				/*
+				 * Push each element onto the stack for later processing.
+				 * Note: There can be null elements within the package,
+				 * these are simply ignored
+				 */
+				status =
+				    acpi_ut_create_update_state_and_push
+				    (object->package.elements[i], action,
+				     &state_list);
+				if (ACPI_FAILURE(status)) {
+					goto error_exit;
+				}
+			}
+			break;
+
+		case ACPI_TYPE_BUFFER_FIELD:
+
+			next_object = object->buffer_field.buffer_obj;
+			break;
+
+		case ACPI_TYPE_LOCAL_REGION_FIELD:
+
+			next_object = object->field.region_obj;
+			break;
+
+		case ACPI_TYPE_LOCAL_BANK_FIELD:
+
+			next_object = object->bank_field.bank_obj;
+			status =
+			    acpi_ut_create_update_state_and_push(object->
+								 bank_field.
+								 region_obj,
+								 action,
+								 &state_list);
+			if (ACPI_FAILURE(status)) {
+				goto error_exit;
+			}
+			break;
+
+		case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+			next_object = object->index_field.index_obj;
+			status =
+			    acpi_ut_create_update_state_and_push(object->
+								 index_field.
+								 data_obj,
+								 action,
+								 &state_list);
+			if (ACPI_FAILURE(status)) {
+				goto error_exit;
+			}
+			break;
+
+		case ACPI_TYPE_LOCAL_REFERENCE:
+			/*
+			 * The target of an Index (a package, string, or buffer) or a named
+			 * reference must track changes to the ref count of the index or
+			 * target object.
+			 */
+			if ((object->reference.class == ACPI_REFCLASS_INDEX) ||
+			    (object->reference.class == ACPI_REFCLASS_NAME)) {
+				next_object = object->reference.object;
+			}
+			break;
+
+		case ACPI_TYPE_REGION:
+		default:
+			break;	/* No subobjects for all other types */
+		}
+
+		/*
+		 * Now we can update the count in the main object. This can only
+		 * happen after we update the sub-objects in case this causes the
+		 * main object to be deleted.
+		 */
+		acpi_ut_update_ref_count(object, action);
+		object = NULL;
+
+		/* Move on to the next object to be updated */
+
+		if (next_object) {
+			object = next_object;
+			next_object = NULL;
+		} else if (state_list) {
+			state = acpi_ut_pop_generic_state(&state_list);
+			object = state->update.object;
+			acpi_ut_delete_generic_state(state);
+		}
+	}
+
+	return_ACPI_STATUS(AE_OK);
+
+      error_exit:
+
+	ACPI_EXCEPTION((AE_INFO, status,
+			"Could not update object reference count"));
+
+	/* Free any stacked Update State objects */
+
+	while (state_list) {
+		state = acpi_ut_pop_generic_state(&state_list);
+		acpi_ut_delete_generic_state(state);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_add_reference
+ *
+ * PARAMETERS:  Object          - Object whose reference count is to be
+ *                                incremented
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Add one reference to an ACPI object
+ *
+ ******************************************************************************/
+
+void acpi_ut_add_reference(union acpi_operand_object *object)
+{
+
+	ACPI_FUNCTION_TRACE_PTR(ut_add_reference, object);
+
+	/* Ensure that we have a valid object */
+
+	if (!acpi_ut_valid_internal_object(object)) {
+		return_VOID;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+			  "Obj %p Current Refs=%X [To Be Incremented]\n",
+			  object, object->common.reference_count));
+
+	/* Increment the reference count */
+
+	(void)acpi_ut_update_object_reference(object, REF_INCREMENT);
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_remove_reference
+ *
+ * PARAMETERS:  Object         - Object whose ref count will be decremented
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Decrement the reference count of an ACPI internal object
+ *
+ ******************************************************************************/
+
+void acpi_ut_remove_reference(union acpi_operand_object *object)
+{
+
+	ACPI_FUNCTION_TRACE_PTR(ut_remove_reference, object);
+
+	/*
+	 * Allow a NULL pointer to be passed in, just ignore it. This saves
+	 * each caller from having to check. Also, ignore NS nodes.
+	 *
+	 */
+	if (!object ||
+	    (ACPI_GET_DESCRIPTOR_TYPE(object) == ACPI_DESC_TYPE_NAMED)) {
+		return_VOID;
+	}
+
+	/* Ensure that we have a valid object */
+
+	if (!acpi_ut_valid_internal_object(object)) {
+		return_VOID;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+			  "Obj %p Current Refs=%X [To Be Decremented]\n",
+			  object, object->common.reference_count));
+
+	/*
+	 * Decrement the reference count, and only actually delete the object
+	 * if the reference count becomes 0. (Must also decrement the ref count
+	 * of all subobjects!)
+	 */
+	(void)acpi_ut_update_object_reference(object, REF_DECREMENT);
+	return_VOID;
+}
