commit 800ba7c5eaaa734e4bd66bf0441fc200bbcdca54
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 10 11:31:49 2020 -0800

    ACPICA: All acpica: Update copyrights to 2020 Including tool signons.
    
    ACPICA commit 8b9c69d0984067051ffbe8526f871448ead6a26b
    
    Link: https://github.com/acpica/acpica/commit/8b9c69d0
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Kaneda <erik.kaneda@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 9c7adaa7b582..132adff1e131 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -3,7 +3,7 @@
  *
  * Module Name: evgpeblk - GPE block creation and initialization.
  *
- * Copyright (C) 2000 - 2019, Intel Corp.
+ * Copyright (C) 2000 - 2020, Intel Corp.
  *
  *****************************************************************************/
 

commit edc5935ec777c23d66df5d47de53b4a2c8f16d0f
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Oct 25 14:36:49 2019 -0700

    ACPICA: Results from Clang
    
    ACPICA commit 1f08279b3eb13f17004159c28c391a390cd68feb
    
    Changes/fixes From Clang V5.0.1.  Mostly "set but never read"
    warnings.
    
    Link: https://github.com/acpica/acpica/commit/1f08279b
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index fb15e9e2373b..9c7adaa7b582 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -110,6 +110,9 @@ acpi_status acpi_ev_delete_gpe_block(struct acpi_gpe_block_info *gpe_block)
 
 	status =
 	    acpi_hw_disable_gpe_block(gpe_block->xrupt_block, gpe_block, NULL);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
 
 	if (!gpe_block->previous && !gpe_block->next) {
 
@@ -359,10 +362,10 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 	walk_info.gpe_device = gpe_device;
 	walk_info.execute_by_owner_id = FALSE;
 
-	status = acpi_ns_walk_namespace(ACPI_TYPE_METHOD, gpe_device,
-					ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,
-					acpi_ev_match_gpe_method, NULL,
-					&walk_info, NULL);
+	(void)acpi_ns_walk_namespace(ACPI_TYPE_METHOD, gpe_device,
+				     ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,
+				     acpi_ev_match_gpe_method, NULL, &walk_info,
+				     NULL);
 
 	/* Return the new block */
 

commit 44758bafa53602f2581a6857bb20b55d4d8ad5b2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 17 13:31:45 2019 +0200

    ACPICA: Clear status of GPEs on first direct enable
    
    ACPI GPEs (other than the EC one) can be enabled in two situations.
    First, the GPEs with existing _Lxx and _Exx methods are enabled
    implicitly by ACPICA during system initialization.  Second, the
    GPEs without these methods (like GPEs listed by _PRW objects for
    wakeup devices) need to be enabled directly by the code that is
    going to use them (e.g. ACPI power management or device drivers).
    
    In the former case, if the status of a given GPE is set to start
    with, its handler method (either _Lxx or _Exx) needs to be invoked
    to take care of the events (possibly) signaled before the GPE was
    enabled.  In the latter case, however, the first caller of
    acpi_enable_gpe() for a given GPE should not be expected to care
    about any events that might be signaled through it earlier.  In
    that case, it is better to clear the status of the GPE before
    enabling it, to prevent stale events from triggering unwanted
    actions (like spurious system resume, for example).
    
    For this reason, modify acpi_ev_add_gpe_reference() to take an
    additional boolean argument indicating whether or not the GPE
    status needs to be cleared when its reference counter changes from
    zero to one and make acpi_enable_gpe() pass TRUE to it through
    that new argument.
    
    Fixes: 18996f2db918 ("ACPICA: Events: Stop unconditionally clearing ACPI IRQs during suspend/resume")
    Reported-by: Furquan Shaikh <furquan@google.com>
    Tested-by: Furquan Shaikh <furquan@google.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 328d1d6123ad..fb15e9e2373b 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -453,7 +453,7 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 				continue;
 			}
 
-			status = acpi_ev_add_gpe_reference(gpe_event_info);
+			status = acpi_ev_add_gpe_reference(gpe_event_info, FALSE);
 			if (ACPI_FAILURE(status)) {
 				ACPI_EXCEPTION((AE_INFO, status,
 					"Could not enable GPE 0x%02X",

commit 840c02ca2215af648c781ae680d93d8aecd083b7
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jan 14 09:55:25 2019 -0800

    ACPICA: All acpica: Update copyrights to 2019
    
    ACPICA commit 62f4f98e941d86e41969bf2ab5a93b8dc94dc49e
    
    The update includes userspace tool signons.
    
    Link: https://github.com/acpica/acpica/commit/62f4f98e
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index b253063b09d3..328d1d6123ad 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -3,7 +3,7 @@
  *
  * Module Name: evgpeblk - GPE block creation and initialization.
  *
- * Copyright (C) 2000 - 2018, Intel Corp.
+ * Copyright (C) 2000 - 2019, Intel Corp.
  *
  *****************************************************************************/
 

commit 95857638889aeea1b10a16b55041adf3e3ab84c4
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Wed Mar 14 16:13:07 2018 -0700

    ACPICA: adding SPDX headers
    
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index b9139ca1360e..b253063b09d3 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -1,45 +1,11 @@
+// SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
 /******************************************************************************
  *
  * Module Name: evgpeblk - GPE block creation and initialization.
  *
- *****************************************************************************/
-
-/*
  * Copyright (C) 2000 - 2018, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
  *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
+ *****************************************************************************/
 
 #include <acpi/acpi.h>
 #include "accommon.h"

commit 0fe0bebf5fb905ae682b1ecfd0b51b3a89e45ee6
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Wed Mar 14 16:13:05 2018 -0700

    ACPICA: macros: fix ACPI_ERROR_NAMESPACE macro
    
    Fixing the ACPI_ERROR_NAMESPACE macros created an "unused variable"
    compile error when ACPI_NO_ERROR_MESSAGES was defined. This commit
    also fixes the above compilation errors by surrounding variables
    meant for debugging inside a new ACPI_ERROR_ONLY macro.
    
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 107f3ec5dee6..b9139ca1360e 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -443,10 +443,10 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 	struct acpi_gpe_event_info *gpe_event_info;
 	u32 gpe_enabled_count;
 	u32 gpe_index;
-	u32 gpe_number;
 	u32 i;
 	u32 j;
 	u8 *is_polling_needed = context;
+	ACPI_ERROR_ONLY(u32 gpe_number);
 
 	ACPI_FUNCTION_TRACE(ev_initialize_gpe_block);
 
@@ -472,7 +472,9 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 
 			gpe_index = (i * ACPI_GPE_REGISTER_WIDTH) + j;
 			gpe_event_info = &gpe_block->event_info[gpe_index];
-			gpe_number = gpe_block->block_base_number + gpe_index;
+			ACPI_ERROR_ONLY(gpe_number =
+					gpe_block->block_base_number +
+					gpe_index);
 			gpe_event_info->flags |= ACPI_GPE_INITIALIZED;
 
 			/*

commit 87cd826b5979d91d4f2ba189e0652820f2da417f
Author: Erik Schmauss <erik.schmauss@intel.com>
Date:   Wed Mar 14 16:12:59 2018 -0700

    ACPICA: Events: Dispatch GPEs after enabling for the first time
    
    After being enabled for the first time, the GPEs may have STS bits already
    set. Setting EN bits is not sufficient to trigger the GPEs again, so this
    patch polls GPEs after enabling them for the first time.
    This is a cleaner version on top of the "GPE clear" fix generated according
    to Mika's report and Rafael's original Linux based fix. Based on Linux
    commit originated from Rafael J. Wysocki, fixed by Lv Zheng.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 7ce756cc28ab..107f3ec5dee6 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -437,16 +437,16 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 acpi_status
 acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 			     struct acpi_gpe_block_info *gpe_block,
-			     void *ignored)
+			     void *context)
 {
 	acpi_status status;
-	acpi_event_status event_status;
 	struct acpi_gpe_event_info *gpe_event_info;
 	u32 gpe_enabled_count;
 	u32 gpe_index;
 	u32 gpe_number;
 	u32 i;
 	u32 j;
+	u8 *is_polling_needed = context;
 
 	ACPI_FUNCTION_TRACE(ev_initialize_gpe_block);
 
@@ -473,6 +473,7 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 			gpe_index = (i * ACPI_GPE_REGISTER_WIDTH) + j;
 			gpe_event_info = &gpe_block->event_info[gpe_index];
 			gpe_number = gpe_block->block_base_number + gpe_index;
+			gpe_event_info->flags |= ACPI_GPE_INITIALIZED;
 
 			/*
 			 * Ignore GPEs that have no corresponding _Lxx/_Exx method
@@ -484,10 +485,6 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 				continue;
 			}
 
-			event_status = 0;
-			(void)acpi_hw_get_gpe_status(gpe_event_info,
-						     &event_status);
-
 			status = acpi_ev_add_gpe_reference(gpe_event_info);
 			if (ACPI_FAILURE(status)) {
 				ACPI_EXCEPTION((AE_INFO, status,
@@ -498,12 +495,9 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 
 			gpe_event_info->flags |= ACPI_GPE_AUTO_ENABLED;
 
-			if (event_status & ACPI_EVENT_FLAG_STATUS_SET) {
-				ACPI_INFO(("GPE 0x%02X active on init",
-					   gpe_number));
-				(void)acpi_ev_gpe_dispatch(gpe_block->node,
-							   gpe_event_info,
-							   gpe_number);
+			if (is_polling_needed &&
+			    ACPI_GPE_IS_POLLING_NEEDED(gpe_event_info)) {
+				*is_polling_needed = TRUE;
 			}
 
 			gpe_enabled_count++;

commit da6f8320d58623eae9b6fa2f09b1b4f60a772ce9
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 4 10:06:38 2018 -0800

    ACPICA: All acpica: Update copyrights to 2018
    
    including tool signons.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 3a3cb8624f41..7ce756cc28ab 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2017, Intel Corp.
+ * Copyright (C) 2000 - 2018, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 1312b7e0caca44e7ff312bc2eaa888943384e3e1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 10 00:31:58 2017 +0200

    ACPICA: Make it possible to enable runtime GPEs earlier
    
    Runtime GPEs have corresponding _Lxx/_Exx methods and are enabled
    automatically during the initialization of the ACPI subsystem through
    acpi_update_all_gpes() with the assumption that acpi_setup_gpe_for_wake()
    will be called in advance for all of the GPEs pointed to by _PRW
    objects in the namespace that may be affected by acpi_update_all_gpes().
    That is, acpi_ev_initialize_gpe_block() can only be called for a GPE
    block after acpi_setup_gpe_for_wake() has been called for all of the
    _PRW (wakeup) GPEs in it.
    
    The platform firmware on some systems, however, expects GPEs to be
    enabled before the enumeration of devices which is when
    acpi_setup_gpe_for_wake() is called and that goes against the above
    assumption.
    
    For this reason, introduce a new flag to be set by
    acpi_ev_initialize_gpe_block() when automatically enabling a GPE
    to indicate to acpi_setup_gpe_for_wake() that it needs to drop the
    reference to the GPE coming from acpi_ev_initialize_gpe_block()
    and modify acpi_setup_gpe_for_wake() accordingly.  These changes
    allow acpi_setup_gpe_for_wake() and acpi_ev_initialize_gpe_block()
    to be invoked in any order.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index c27386cca493..3a3cb8624f41 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -496,6 +496,8 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 				continue;
 			}
 
+			gpe_event_info->flags |= ACPI_GPE_AUTO_ENABLED;
+
 			if (event_status & ACPI_EVENT_FLAG_STATUS_SET) {
 				ACPI_INFO(("GPE 0x%02X active on init",
 					   gpe_number));

commit ecc1165b8b743fd1503b9c799ae3a9933b89877b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 10 00:30:09 2017 +0200

    ACPICA: Dispatch active GPEs at init time
    
    In some cases GPEs are already active when they are enabled by
    acpi_ev_initialize_gpe_block() and whatever happens next may depend
    on the result of handling the events signaled by them, so the
    events should not be discarded (which is what happens currently) and
    they should be handled as soon as reasonably possible.
    
    For this reason, modify acpi_ev_initialize_gpe_block() to
    dispatch GPEs with the status flag set in-band right after
    enabling them.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 9c941947a063..c27386cca493 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -440,9 +440,11 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 			     void *ignored)
 {
 	acpi_status status;
+	acpi_event_status event_status;
 	struct acpi_gpe_event_info *gpe_event_info;
 	u32 gpe_enabled_count;
 	u32 gpe_index;
+	u32 gpe_number;
 	u32 i;
 	u32 j;
 
@@ -470,30 +472,38 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 
 			gpe_index = (i * ACPI_GPE_REGISTER_WIDTH) + j;
 			gpe_event_info = &gpe_block->event_info[gpe_index];
+			gpe_number = gpe_block->block_base_number + gpe_index;
 
 			/*
 			 * Ignore GPEs that have no corresponding _Lxx/_Exx method
-			 * and GPEs that are used to wake the system
+			 * and GPEs that are used for wakeup
 			 */
-			if ((ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==
-			     ACPI_GPE_DISPATCH_NONE)
-			    || (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==
-				ACPI_GPE_DISPATCH_HANDLER)
-			    || (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==
-				ACPI_GPE_DISPATCH_RAW_HANDLER)
+			if ((ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) !=
+			     ACPI_GPE_DISPATCH_METHOD)
 			    || (gpe_event_info->flags & ACPI_GPE_CAN_WAKE)) {
 				continue;
 			}
 
+			event_status = 0;
+			(void)acpi_hw_get_gpe_status(gpe_event_info,
+						     &event_status);
+
 			status = acpi_ev_add_gpe_reference(gpe_event_info);
 			if (ACPI_FAILURE(status)) {
 				ACPI_EXCEPTION((AE_INFO, status,
 					"Could not enable GPE 0x%02X",
-					gpe_index +
-					gpe_block->block_base_number));
+					gpe_number));
 				continue;
 			}
 
+			if (event_status & ACPI_EVENT_FLAG_STATUS_SET) {
+				ACPI_INFO(("GPE 0x%02X active on init",
+					   gpe_number));
+				(void)acpi_ev_gpe_dispatch(gpe_block->node,
+							   gpe_event_info,
+							   gpe_number);
+			}
+
 			gpe_enabled_count++;
 		}
 	}

commit 7735ca0eb4ebd6d47fdad40602d0ba7593219f8c
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Feb 8 11:00:08 2017 +0800

    ACPICA: Source tree: Update copyright notices to 2017
    
    ACPICA commit 16577e5265923f4999b4d2c0addb2343b18135e1
    
    Affects all files.
    
    Link: https://github.com/acpica/acpica/commit/16577e52
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index d54014cab01d..9c941947a063 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2016, Intel Corp.
+ * Copyright (C) 2000 - 2017, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit f5c1e1c5a652e4b43eb9b571577ef72731f3fa8b
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu May 5 12:57:53 2016 +0800

    ACPICA: Divergence: remove unwanted spaces for typedef
    
    ACPICA commit b2294cae776f5a66a7697414b21949d307e6856f
    
    This patch removes unwanted spaces for typedef. This solution doesn't cover
    function types.
    
    Note that the linuxize result of this commit is very giant and should have
    many conflicts against the current Linux upstream. Thus it is required to
    modify the linuxize result of this commit and the commits around it
    manually in order to have them merged to the Linux upstream. Since this is
    very costy, we should do this only once, and if we can't ensure to do this
    only once, we need to revert the Linux code to the wrong indentation result
    before merging the linuxize result of this commit. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/b2294cae
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 447fa1cac64f..d54014cab01d 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -211,7 +211,7 @@ acpi_ev_create_gpe_info_blocks(struct acpi_gpe_block_info *gpe_block)
 
 	/* Allocate the GPE register information block */
 
-	gpe_register_info = ACPI_ALLOCATE_ZEROED((acpi_size) gpe_block->
+	gpe_register_info = ACPI_ALLOCATE_ZEROED((acpi_size)gpe_block->
 						 register_count *
 						 sizeof(struct
 							acpi_gpe_register_info));
@@ -225,7 +225,7 @@ acpi_ev_create_gpe_info_blocks(struct acpi_gpe_block_info *gpe_block)
 	 * Allocate the GPE event_info block. There are eight distinct GPEs
 	 * per register. Initialization to zeros is sufficient.
 	 */
-	gpe_event_info = ACPI_ALLOCATE_ZEROED((acpi_size) gpe_block->gpe_count *
+	gpe_event_info = ACPI_ALLOCATE_ZEROED((acpi_size)gpe_block->gpe_count *
 					      sizeof(struct
 						     acpi_gpe_event_info));
 	if (!gpe_event_info) {

commit 05fb04b54f6b67f4eb901e99dd5b4604b46ffa0f
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Feb 19 14:16:42 2016 +0800

    ACPICA: Remove unnecessary arguments to ACPI_INFO
    
    ACPICA commit 181f56605a771e0b91e24b0648d2565ca70bea20
    
    This is used as a purely infomation message, without module name
    and line number information. Therefore, these arguments are
    not needed and they are unnecessary overhead.
    Arguments are removed.
    ACPICA BZ 872.
    
    Link: https://github.com/acpica/acpica/commit/181f5660
    Link: https://bugs.acpica.org/show_bug.cgi?id=872
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 9275e626ed8d..447fa1cac64f 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -499,8 +499,7 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 	}
 
 	if (gpe_enabled_count) {
-		ACPI_INFO((AE_INFO,
-			   "Enabled %u GPEs in block %02X to %02X",
+		ACPI_INFO(("Enabled %u GPEs in block %02X to %02X",
 			   gpe_enabled_count, (u32)gpe_block->block_base_number,
 			   (u32)(gpe_block->block_base_number +
 				 (gpe_block->gpe_count - 1))));

commit c8100dc4643d80a94f074dfc8a2af3d3d327b7aa
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 15 08:17:03 2016 +0800

    ACPICA: Additional 2016 copyright changes
    
    All tool/utility signons.
    Dual-license module header.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index c00a9f2f82d5..9275e626ed8d 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2015, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 1fad87385e7e82f656fb661aef0f841e42991974
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Dec 29 13:54:36 2015 +0800

    ACPICA: Core: Major update for code formatting, no functional changes
    
    ACPICA commit dfa394471f6c01b2ee9433dbc143ec70cb9bca72
    
    Mostly indentation inconsistencies across the code. Split
    some long lines, etc.
    
    Link: https://github.com/acpica/acpica/commit/dfa39447
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index e0f24c504513..c00a9f2f82d5 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -167,6 +167,7 @@ acpi_status acpi_ev_delete_gpe_block(struct acpi_gpe_block_info *gpe_block)
 		if (gpe_block->next) {
 			gpe_block->next->previous = gpe_block->previous;
 		}
+
 		acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
 	}
 

commit 0d0988af81ac809b30f818f0c0f065327ff6423b
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Feb 5 16:27:03 2015 +0800

    ACPICA: Events: Introduce ACPI_GPE_DISPATCH_RAW_HANDLER to fix 2 issues for the current GPE APIs
    
    ACPICA commit 199cad16530a45aea2bec98e528866e20c5927e1
    
    Since whether the GPE should be disabled/enabled/cleared should only be
    determined by the GPE driver's state machine:
    1. GPE should be disabled if the driver wants to switch to the GPE polling
       mode when a GPE storm condition is indicated and should be enabled if
       the driver wants to switch back to the GPE interrupt mode when all of
       the storm conditions are cleared. The conditions should be protected by
       the driver's specific lock.
    2. GPE should be enabled if the driver has accepted more than one request
       and should be disabled if the driver has completed all of the requests.
       The request count should be protected by the driver's specific lock.
    3. GPE should be cleared either when the driver is about to handle an edge
       triggered GPE or when the driver has completed to handle a level
       triggered GPE. The handling code should be protected by the driver's
       specific lock.
    Thus the GPE enabling/disabling/clearing operations are likely to be
    performed with the driver's specific lock held while we currently cannot do
    this. This is because:
    1. We have the acpi_gbl_gpe_lock held before invoking the GPE driver's
       handler. Driver's specific lock is likely to be held inside of the
       handler, thus we can see some dead lock issues due to the reversed
       locking order or recursive locking. In order to solve such dead lock
       issues, we need to unlock the acpi_gbl_gpe_lock before invoking the
       handler. BZ 1100.
    2. Since GPE disabling/enabling/clearing should be determined by the GPE
       driver's state machine, we shouldn't perform such operations inside of
       ACPICA for a GPE handler to mess up the driver's state machine. BZ 1101.
    
    Originally this patch includes a logic to flush GPE handlers, it is dropped
    due to the following reasons:
    1. This is a different issue;
    2. Linux OSL has fixed this by flushing SCI in acpi_os_wait_events_complete().
    We will pick up this topic when the Linux OSL fix turns out to be not
    sufficient.
    
    Note that currently the internal operations and the acpi_gbl_gpe_lock are
    also used by ACPI_GPE_DISPATCH_METHOD and ACPI_GPE_DISPATCH_NOTIFY. In
    order not to introduce regressions, we add one
    ACPI_GPE_DISPATCH_RAW_HANDLER type to be distiguished from
    ACPI_GPE_DISPATCH_HANDLER. For which the acpi_gbl_gpe_lock is unlocked before
    invoking the GPE handler and the internal enabling/disabling operations are
    bypassed to allow drivers to perform them at a proper position using the
    GPE APIs and ACPI_GPE_DISPATCH_RAW_HANDLER users should invoke acpi_set_gpe()
    instead of acpi_enable_gpe()/acpi_disable_gpe() to bypass the internal GPE
    clearing code in acpi_enable_gpe(). Lv Zheng.
    
    Known issues:
    1. Edge-triggered GPE lost for frequent enablings
       On some buggy silicon platforms, GPE enable line may not be directly
       wired to the GPE trigger line. In that case, when GPE enabling is
       frequently performed for edge-triggered GPEs, GPE status may stay set
       without being triggered.
       This patch may maginify this problem as it allows GPE enabling to be
       parallel performed during the process the GPEs are handled.
       This is an existing issue, because:
       1. For task context:
          Current ACPI_GPE_DISPATCH_METHOD practices have proven that this
          isn't a real issue - we can re-enable edge-triggered GPE in a work
          queue where the GPE status bit might already be set.
       2. For IRQ context:
          This can even happen when the GPE enabling occurs before returning
          from the GPE handler and after unlocking the GPE lock.
       Thus currently no code is included to protect this.
    
    Link: https://github.com/acpica/acpica/commit/199cad16
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index ce2a7cf3a23f..e0f24c504513 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -478,6 +478,8 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 			     ACPI_GPE_DISPATCH_NONE)
 			    || (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==
 				ACPI_GPE_DISPATCH_HANDLER)
+			    || (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==
+				ACPI_GPE_DISPATCH_RAW_HANDLER)
 			    || (gpe_event_info->flags & ACPI_GPE_CAN_WAKE)) {
 				continue;
 			}

commit 82a809419429f2e6142d2c5d88d91661f8aecb87
Author: David E. Box <david.e.box@linux.intel.com>
Date:   Thu Feb 5 15:20:45 2015 +0800

    ACPICA: Update Copyright headers to 2015
    
    ACPICA commit 8990e73ab2aa15d6a0068b860ab54feff25bee36
    
    Link: https://github.com/acpica/acpica/commit/8990e73a
    Signed-off-by: David E. Box <david.e.box@linux.intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index d0a6024ae628..ce2a7cf3a23f 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2014, Intel Corp.
+ * Copyright (C) 2000 - 2015, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 7c43312af8b363b679d1e7840858ff8d204a4d91
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Thu Feb 5 15:20:29 2015 +0800

    ACPICA: Events: Cleanup GPE dispatcher type obtaining code
    
    ACPICA commit 7926d5ca9452c87f866938dcea8f12e1efb58f89
    
    There is an issue in acpi_install_gpe_handler() and acpi_remove_gpe_handler().
    The code to obtain the GPE dispatcher type from the Handler->original_flags
    is wrong:
        if (((Handler->original_flags & ACPI_GPE_DISPATCH_METHOD) ||
             (Handler->original_flags & ACPI_GPE_DISPATCH_NOTIFY)) &&
    ACPI_GPE_DISPATCH_NOTIFY is 0x03 and ACPI_GPE_DISPATCH_METHOD is 0x02, thus
    this statement is TRUE for the following dispatcher types:
        0x01 (ACPI_GPE_DISPATCH_HANDLER): not expected
        0x02 (ACPI_GPE_DISPATCH_METHOD): expected
        0x03 (ACPI_GPE_DISPATCH_NOTIFY): expected
    
    There is no functional issue due to this because Handler->original_flags is
    only set in acpi_install_gpe_handler(), and an earlier checker has excluded
    the ACPI_GPE_DISPATCH_HANDLER:
        if ((gpe_event_info->Flags & ACPI_GPE_DISPATCH_MASK) ==
                ACPI_GPE_DISPATCH_HANDLER)
        {
            Status = AE_ALREADY_EXISTS;
            goto free_and_exit;
        }
        ...
        Handler->original_flags = (u8) (gpe_event_info->Flags &
            (ACPI_GPE_XRUPT_TYPE_MASK | ACPI_GPE_DISPATCH_MASK));
    
    We need to clean this up before modifying the GPE dispatcher type values.
    
    In order to prevent such issue from happening in the future, this patch
    introduces ACPI_GPE_DISPATCH_TYPE() macro to be used to obtain the GPE
    dispatcher types. Lv Zheng.
    
    Link: https://github.com/acpica/acpica/commit/7926d5ca
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: David E. Box <david.e.box@linux.intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index d86699eea33c..d0a6024ae628 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -474,10 +474,10 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 			 * Ignore GPEs that have no corresponding _Lxx/_Exx method
 			 * and GPEs that are used to wake the system
 			 */
-			if (((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
+			if ((ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==
 			     ACPI_GPE_DISPATCH_NONE)
-			    || ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK)
-				== ACPI_GPE_DISPATCH_HANDLER)
+			    || (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==
+				ACPI_GPE_DISPATCH_HANDLER)
 			    || (gpe_event_info->flags & ACPI_GPE_CAN_WAKE)) {
 				continue;
 			}

commit 7505da4c3f90dd61302e825b005d08144c5de050
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Apr 30 10:06:15 2014 +0800

    ACPICA: Events: Update GPE handling and initialization code.
    
    1) Eliminate most use of GAS structs, since they are not needed
    for GPEs.
    2) Allow raw GPE numbers > 255.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index caaed3c673fd..d86699eea33c 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -252,21 +252,17 @@ acpi_ev_create_gpe_info_blocks(struct acpi_gpe_block_info *gpe_block)
 
 		/* Init the register_info for this GPE register (8 GPEs) */
 
-		this_register->base_gpe_number =
-		    (u8) (gpe_block->block_base_number +
-			  (i * ACPI_GPE_REGISTER_WIDTH));
+		this_register->base_gpe_number = (u16)
+		    (gpe_block->block_base_number +
+		     (i * ACPI_GPE_REGISTER_WIDTH));
 
-		this_register->status_address.address =
-		    gpe_block->block_address.address + i;
+		this_register->status_address.address = gpe_block->address + i;
 
 		this_register->enable_address.address =
-		    gpe_block->block_address.address + i +
-		    gpe_block->register_count;
+		    gpe_block->address + i + gpe_block->register_count;
 
-		this_register->status_address.space_id =
-		    gpe_block->block_address.space_id;
-		this_register->enable_address.space_id =
-		    gpe_block->block_address.space_id;
+		this_register->status_address.space_id = gpe_block->space_id;
+		this_register->enable_address.space_id = gpe_block->space_id;
 		this_register->status_address.bit_width =
 		    ACPI_GPE_REGISTER_WIDTH;
 		this_register->enable_address.bit_width =
@@ -334,9 +330,10 @@ acpi_ev_create_gpe_info_blocks(struct acpi_gpe_block_info *gpe_block)
 
 acpi_status
 acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
-			 struct acpi_generic_address *gpe_block_address,
+			 u64 address,
+			 u8 space_id,
 			 u32 register_count,
-			 u8 gpe_block_base_number,
+			 u16 gpe_block_base_number,
 			 u32 interrupt_number,
 			 struct acpi_gpe_block_info **return_gpe_block)
 {
@@ -359,15 +356,14 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 
 	/* Initialize the new GPE block */
 
+	gpe_block->address = address;
+	gpe_block->space_id = space_id;
 	gpe_block->node = gpe_device;
 	gpe_block->gpe_count = (u16)(register_count * ACPI_GPE_REGISTER_WIDTH);
 	gpe_block->initialized = FALSE;
 	gpe_block->register_count = register_count;
 	gpe_block->block_base_number = gpe_block_base_number;
 
-	ACPI_MEMCPY(&gpe_block->block_address, gpe_block_address,
-		    sizeof(struct acpi_generic_address));
-
 	/*
 	 * Create the register_info and event_info sub-structures
 	 * Note: disables and clears all GPEs in the block
@@ -408,12 +404,14 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 	}
 
 	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,
-			      "    Initialized GPE %02X to %02X [%4.4s] %u regs on interrupt 0x%X\n",
+			      "    Initialized GPE %02X to %02X [%4.4s] %u regs on interrupt 0x%X%s\n",
 			      (u32)gpe_block->block_base_number,
 			      (u32)(gpe_block->block_base_number +
 				    (gpe_block->gpe_count - 1)),
 			      gpe_device->name.ascii, gpe_block->register_count,
-			      interrupt_number));
+			      interrupt_number,
+			      interrupt_number ==
+			      acpi_gbl_FADT.sci_interrupt ? " (SCI)" : ""));
 
 	/* Update global count of currently available GPEs */
 

commit fbb7a2dc2be493c87399550bdc2ddaa510cdf450
Author: Bob Moore <robert.moore@intel.com>
Date:   Sat Feb 8 09:42:25 2014 +0800

    ACPICA: Update ACPICA copyrights to 2014.
    
    Update ACPICA copyrights to 2014. Includes all source headers and
    signons for the various tools.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index a31e549e64cc..caaed3c673fd 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2013, Intel Corp.
+ * Copyright (C) 2000 - 2014, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 4bec3d80a0c596cbde846cfb424058e1374ad6ff
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Jan 8 13:44:10 2014 +0800

    ACPICA: Improve exception handling for GPE block installation.
    
    1) Return an actual status value from acpi_ev_get_gpe_xrupt_block.
    2) Don't clobber the status when exiting acpi_ev_install_gpe_block.
    
    References: https://bugs.acpica.org/show_bug.cgi?id=1019
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index a9e76bc4ad97..a31e549e64cc 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -87,9 +87,9 @@ acpi_ev_install_gpe_block(struct acpi_gpe_block_info *gpe_block,
 		return_ACPI_STATUS(status);
 	}
 
-	gpe_xrupt_block = acpi_ev_get_gpe_xrupt_block(interrupt_number);
-	if (!gpe_xrupt_block) {
-		status = AE_NO_MEMORY;
+	status =
+	    acpi_ev_get_gpe_xrupt_block(interrupt_number, &gpe_xrupt_block);
+	if (ACPI_FAILURE(status)) {
 		goto unlock_and_exit;
 	}
 
@@ -112,7 +112,7 @@ acpi_ev_install_gpe_block(struct acpi_gpe_block_info *gpe_block,
 	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
 
 unlock_and_exit:
-	status = acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);
 	return_ACPI_STATUS(status);
 }
 

commit 10622bf8ce432e6a53fd3c37163e99e99c9e43ee
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Oct 29 09:30:02 2013 +0800

    ACPICA: Linuxize: Change indentation of C labels.
    
    It is reported by kernel build test systems that all ACPICA source
    files in the kernel tree have incorrect label indentation.  This
    patch changes default indent option used in the release process to
    fix this bug.  Lv Zheng.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index c1aa1eda26c3..a9e76bc4ad97 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -111,7 +111,7 @@ acpi_ev_install_gpe_block(struct acpi_gpe_block_info *gpe_block,
 	gpe_block->xrupt_block = gpe_xrupt_block;
 	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
 
-      unlock_and_exit:
+unlock_and_exit:
 	status = acpi_ut_release_mutex(ACPI_MTX_EVENTS);
 	return_ACPI_STATUS(status);
 }
@@ -178,7 +178,7 @@ acpi_status acpi_ev_delete_gpe_block(struct acpi_gpe_block_info *gpe_block)
 	ACPI_FREE(gpe_block->event_info);
 	ACPI_FREE(gpe_block);
 
-      unlock_and_exit:
+unlock_and_exit:
 	status = acpi_ut_release_mutex(ACPI_MTX_EVENTS);
 	return_ACPI_STATUS(status);
 }
@@ -302,7 +302,7 @@ acpi_ev_create_gpe_info_blocks(struct acpi_gpe_block_info *gpe_block)
 
 	return_ACPI_STATUS(AE_OK);
 
-      error_exit:
+error_exit:
 	if (gpe_register_info) {
 		ACPI_FREE(gpe_register_info);
 	}

commit b739f106cb6385b83bac41e1f417c4e9347171a4
Author: Tomasz Nowicki <tomasz.nowicki@linaro.org>
Date:   Sat Jun 8 01:00:07 2013 +0000

    ACPICA: Fix possible memory leak in GPE init error path
    
    Some GPE blocks were not deleted.  ACPICA BZ 1018. Tomasz Nowicki
    <tomasz.nowicki@linaro.org>
    
    References: https://bugs.acpica.org/show_bug.cgi?id=1018
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Reviewed-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index a2d688bbac02..c1aa1eda26c3 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -382,6 +382,8 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 
 	status = acpi_ev_install_gpe_block(gpe_block, interrupt_number);
 	if (ACPI_FAILURE(status)) {
+		ACPI_FREE(gpe_block->register_info);
+		ACPI_FREE(gpe_block->event_info);
 		ACPI_FREE(gpe_block);
 		return_ACPI_STATUS(status);
 	}

commit 25f044e64568dd83de34c16c837a96bbb2b0cecb
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 25 05:38:56 2013 +0000

    ACPICA: Update ACPICA copyrights to 2013
    
    Includes all source headers and signons for the various tools.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 78db9f5bb1e1..a2d688bbac02 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2013, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 3e5621a750e2cfb26748c34acbb67c691845494a
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Dec 31 00:07:13 2012 +0000

    ACPICA: Update ACPICA initialization messages.
    
    Clarify messages, indent if appropriate. Change a couple
    appropriate messages to ACPI_INFO so they will appear even if
    debug output is disabled.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 1571a61a7833..78db9f5bb1e1 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -405,13 +405,13 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 		(*return_gpe_block) = gpe_block;
 	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INIT,
-			  "GPE %02X to %02X [%4.4s] %u regs on int 0x%X\n",
-			  (u32) gpe_block->block_base_number,
-			  (u32) (gpe_block->block_base_number +
-				(gpe_block->gpe_count - 1)),
-			  gpe_device->name.ascii, gpe_block->register_count,
-			  interrupt_number));
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,
+			      "    Initialized GPE %02X to %02X [%4.4s] %u regs on interrupt 0x%X\n",
+			      (u32)gpe_block->block_base_number,
+			      (u32)(gpe_block->block_base_number +
+				    (gpe_block->gpe_count - 1)),
+			      gpe_device->name.ascii, gpe_block->register_count,
+			      interrupt_number));
 
 	/* Update global count of currently available GPEs */
 
@@ -496,9 +496,11 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 	}
 
 	if (gpe_enabled_count) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INIT,
-				  "Enabled %u GPEs in this block\n",
-				  gpe_enabled_count));
+		ACPI_INFO((AE_INFO,
+			   "Enabled %u GPEs in block %02X to %02X",
+			   gpe_enabled_count, (u32)gpe_block->block_base_number,
+			   (u32)(gpe_block->block_base_number +
+				 (gpe_block->gpe_count - 1))));
 	}
 
 	gpe_block->initialized = TRUE;

commit 1f86e8c1c9f129d450fd75e42d25ddba69a522ac
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Wed Oct 31 02:25:45 2012 +0000

    ACPICA: Fix indent caused divergences.
    
    New version of "indent" program will generate different outputs that
    will lead to the divergences between the Linux and the ACPICA.
    This patch fixes such divergences caused by the "indent" program.
    The version of the "indent" used for this patch is "GNU indent 2.2.11".
    
    This patch will not affect the generated vmlinux binary.
    This will decrease 581 lines of 20120913 divergence.diff.
    
    Signed-off-by: Robert Moore <robert.moore@intel.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 8cf4c104c7b7..1571a61a7833 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -486,7 +486,8 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 			if (ACPI_FAILURE(status)) {
 				ACPI_EXCEPTION((AE_INFO, status,
 					"Could not enable GPE 0x%02X",
-					gpe_index + gpe_block->block_base_number));
+					gpe_index +
+					gpe_block->block_base_number));
 				continue;
 			}
 

commit ba494beeaa69bc0fb01eb89464ad5d57d26e3901
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jul 12 09:40:10 2012 +0800

    ACPICA: AcpiSrc: Fix some translation issues for Linux conversion
    
    Fixes issues like this:
    
    i_aSL -> iASL
    00-7_f -> 00-7F
    local_fADT -> local_FADT
    execute_oSI -> execute_OSI
    
    Also, in function headers, the parameters are now translated to
    lower case (with underscores if necessary.)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 23a3ca86b2eb..8cf4c104c7b7 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -318,7 +318,7 @@ acpi_ev_create_gpe_info_blocks(struct acpi_gpe_block_info *gpe_block)
  * FUNCTION:    acpi_ev_create_gpe_block
  *
  * PARAMETERS:  gpe_device          - Handle to the parent GPE block
- *              gpe_block_address   - Address and space_iD
+ *              gpe_block_address   - Address and space_ID
  *              register_count      - Number of GPE register pairs in the block
  *              gpe_block_base_number - Starting GPE number for the block
  *              interrupt_number    - H/W interrupt for the block

commit 33620c5419e8a11814dd11e02a80e6ef77a43407
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Feb 14 18:14:27 2012 +0800

    ACPICA: Support for custom ACPICA build for ACPI 5 reduced hardware
    
    Add ACPI_REDUCED_HARDWARE flag that removes all hardware-related
    code (about 10% code, 5% static data).
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index be75339cd5dd..23a3ca86b2eb 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -48,7 +48,7 @@
 
 #define _COMPONENT          ACPI_EVENTS
 ACPI_MODULE_NAME("evgpeblk")
-
+#if (!ACPI_REDUCED_HARDWARE)	/* Entire module */
 /* Local prototypes */
 static acpi_status
 acpi_ev_install_gpe_block(struct acpi_gpe_block_info *gpe_block,
@@ -504,3 +504,5 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 
 	return_ACPI_STATUS(AE_OK);
 }
+
+#endif				/* !ACPI_REDUCED_HARDWARE */

commit 77848130e53b06c22fe37a7b6acbb82bb3e9bfba
Author: Bob Moore <robert.moore@intel.com>
Date:   Thu Jan 12 13:27:23 2012 +0800

    ACPICA: Update all copyrights to 2012
    
    Update all copyrights to 2012.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index ca2c41a53311..be75339cd5dd 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2011, Intel Corp.
+ * Copyright (C) 2000 - 2012, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit b4e104eaeb8cd4329a23e0e4ebf166681b1d182d
Author: Bob Moore <robert.moore@intel.com>
Date:   Mon Jan 17 11:05:40 2011 +0800

    ACPICA: Update all ACPICA copyrights and signons to 2011
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 9acb86958c09..ca2c41a53311 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2010, Intel Corp.
+ * Copyright (C) 2000 - 2011, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit da50337373c90c15c6db6ed4239e87c5a3806f9a
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Dec 13 13:39:37 2010 +0800

    ACPICA: Misc comments to minimize code divergence
    
    Modify/add some comments to minimize ACPICA/linux GPE code divergence.
    
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index e2e8164bb811..9acb86958c09 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -361,9 +361,9 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 
 	gpe_block->node = gpe_device;
 	gpe_block->gpe_count = (u16)(register_count * ACPI_GPE_REGISTER_WIDTH);
+	gpe_block->initialized = FALSE;
 	gpe_block->register_count = register_count;
 	gpe_block->block_base_number = gpe_block_base_number;
-	gpe_block->initialized = FALSE;
 
 	ACPI_MEMCPY(&gpe_block->block_address, gpe_block_address,
 		    sizeof(struct acpi_generic_address));
@@ -423,14 +423,12 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
  *
  * FUNCTION:    acpi_ev_initialize_gpe_block
  *
- * PARAMETERS:  gpe_device          - Handle to the parent GPE block
- *              gpe_block           - Gpe Block info
+ * PARAMETERS:  acpi_gpe_callback
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Initialize and enable a GPE block. First find and run any
- *              _PRT methods associated with the block, then enable the
- *              appropriate GPEs.
+ * DESCRIPTION: Initialize and enable a GPE block. Enable GPEs that have
+ *              associated methods.
  *              Note: Assumes namespace is locked.
  *
  ******************************************************************************/
@@ -450,8 +448,8 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 	ACPI_FUNCTION_TRACE(ev_initialize_gpe_block);
 
 	/*
-	 * Ignore a null GPE block (e.g., if no GPE block 1 exists) and
-	 * GPE blocks that have been initialized already.
+	 * Ignore a null GPE block (e.g., if no GPE block 1 exists), and
+	 * any GPE blocks that have been initialized already.
 	 */
 	if (!gpe_block || gpe_block->initialized) {
 		return_ACPI_STATUS(AE_OK);
@@ -459,8 +457,8 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 
 	/*
 	 * Enable all GPEs that have a corresponding method and have the
-	 * ACPI_GPE_CAN_WAKE flag unset.  Any other GPEs within this block must
-	 * be enabled via the acpi_enable_gpe() interface.
+	 * ACPI_GPE_CAN_WAKE flag unset. Any other GPEs within this block
+	 * must be enabled via the acpi_enable_gpe() interface.
 	 */
 	gpe_enabled_count = 0;
 

commit bba63a296ffab20e08d9e8252d2f0d99050ac859
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Dec 13 13:39:17 2010 +0800

    ACPICA: Implicit notify support
    
    This feature provides an automatic device notification for wake devices
    when a wakeup GPE occurs and there is no corresponding GPE method or
    handler. Rather than ignoring such a GPE, an implicit AML Notify
    operation is performed on the parent device object.
    This feature is not part of the ACPI specification and is provided for
    Windows compatibility only.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 2a445dfcfdb4..e2e8164bb811 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -472,9 +472,14 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 			gpe_index = (i * ACPI_GPE_REGISTER_WIDTH) + j;
 			gpe_event_info = &gpe_block->event_info[gpe_index];
 
-			/* Ignore GPEs that have no corresponding _Lxx/_Exx method */
-
-			if (!(gpe_event_info->flags & ACPI_GPE_DISPATCH_METHOD)
+			/*
+			 * Ignore GPEs that have no corresponding _Lxx/_Exx method
+			 * and GPEs that are used to wake the system
+			 */
+			if (((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
+			     ACPI_GPE_DISPATCH_NONE)
+			    || ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK)
+				== ACPI_GPE_DISPATCH_HANDLER)
 			    || (gpe_event_info->flags & ACPI_GPE_CAN_WAKE)) {
 				continue;
 			}

commit 3a37898d507794cfc68a092303e02651d3f01308
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Dec 13 13:36:15 2010 +0800

    ACPICA: Rename some function and variable names
    
    Some function and variable names are renamed to be consistent with
    ACPICA code base.
    
    acpi_raw_enable_gpe -> acpi_ev_add_gpe_reference
    acpi_raw_disable_gpe -> acpi_ev_remove_gpe_reference
    acpi_gpe_can_wake -> acpi_setup_gpe_for_wake
    acpi_gpe_wakeup -> acpi_set_gpe_wake_mask
    acpi_update_gpes -> acpi_update_all_gpes
    acpi_all_gpes_initialized -> acpi_gbl_all_gpes_initialized
    acpi_handler_info -> acpi_gpe_handler_info
    ...
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 020add3eee1c..2a445dfcfdb4 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -386,7 +386,7 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 		return_ACPI_STATUS(status);
 	}
 
-	acpi_all_gpes_initialized = FALSE;
+	acpi_gbl_all_gpes_initialized = FALSE;
 
 	/* Find all GPE methods (_Lxx or_Exx) for this block */
 
@@ -479,7 +479,7 @@ acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 				continue;
 			}
 
-			status = acpi_raw_enable_gpe(gpe_event_info);
+			status = acpi_ev_add_gpe_reference(gpe_event_info);
 			if (ACPI_FAILURE(status)) {
 				ACPI_EXCEPTION((AE_INFO, status,
 					"Could not enable GPE 0x%02X",

commit a210080195c95ebca2a517ee3057d71607aa65e0
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Sep 16 00:30:43 2010 +0200

    ACPI / ACPICA: Defer enabling of runtime GPEs (v3)
    
    The current ACPI GPEs initialization code has a problem that it
    enables some GPEs pointed to by device _PRW methods, generally
    intended for signaling wakeup events (system or device wakeup).
    These GPEs are then almost immediately disabled by the ACPI namespace
    scanning code with the help of acpi_gpe_can_wake(), but it would be
    better not to enable them at all until really necessary.
    
    Modify the initialization of GPEs so that the ones that have
    associated _Lxx or _Exx methods and are not pointed to by any _PRW
    methods will be enabled after the namespace scan is complete.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 85445fb5844e..020add3eee1c 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -363,6 +363,7 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 	gpe_block->gpe_count = (u16)(register_count * ACPI_GPE_REGISTER_WIDTH);
 	gpe_block->register_count = register_count;
 	gpe_block->block_base_number = gpe_block_base_number;
+	gpe_block->initialized = FALSE;
 
 	ACPI_MEMCPY(&gpe_block->block_address, gpe_block_address,
 		    sizeof(struct acpi_generic_address));
@@ -385,11 +386,12 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 		return_ACPI_STATUS(status);
 	}
 
+	acpi_all_gpes_initialized = FALSE;
+
 	/* Find all GPE methods (_Lxx or_Exx) for this block */
 
 	walk_info.gpe_block = gpe_block;
 	walk_info.gpe_device = gpe_device;
-	walk_info.enable_this_gpe = FALSE;
 	walk_info.execute_by_owner_id = FALSE;
 
 	status = acpi_ns_walk_namespace(ACPI_TYPE_METHOD, gpe_device,
@@ -434,35 +436,34 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
  ******************************************************************************/
 
 acpi_status
-acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
-			     struct acpi_gpe_block_info *gpe_block)
+acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
+			     struct acpi_gpe_block_info *gpe_block,
+			     void *ignored)
 {
 	acpi_status status;
 	struct acpi_gpe_event_info *gpe_event_info;
 	u32 gpe_enabled_count;
 	u32 gpe_index;
-	u32 gpe_number;
 	u32 i;
 	u32 j;
 
 	ACPI_FUNCTION_TRACE(ev_initialize_gpe_block);
 
-	/* Ignore a null GPE block (e.g., if no GPE block 1 exists) */
-
-	if (!gpe_block) {
+	/*
+	 * Ignore a null GPE block (e.g., if no GPE block 1 exists) and
+	 * GPE blocks that have been initialized already.
+	 */
+	if (!gpe_block || gpe_block->initialized) {
 		return_ACPI_STATUS(AE_OK);
 	}
 
 	/*
-	 * Enable all GPEs that have a corresponding method.  Any other GPEs
-	 * within this block must be enabled via the acpi_enable_gpe interface.
+	 * Enable all GPEs that have a corresponding method and have the
+	 * ACPI_GPE_CAN_WAKE flag unset.  Any other GPEs within this block must
+	 * be enabled via the acpi_enable_gpe() interface.
 	 */
 	gpe_enabled_count = 0;
 
-	if (gpe_device == acpi_gbl_fadt_gpe_device) {
-		gpe_device = NULL;
-	}
-
 	for (i = 0; i < gpe_block->register_count; i++) {
 		for (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {
 
@@ -470,27 +471,19 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 
 			gpe_index = (i * ACPI_GPE_REGISTER_WIDTH) + j;
 			gpe_event_info = &gpe_block->event_info[gpe_index];
-			gpe_number = gpe_index + gpe_block->block_base_number;
 
 			/* Ignore GPEs that have no corresponding _Lxx/_Exx method */
 
-			if (!(gpe_event_info->flags & ACPI_GPE_DISPATCH_METHOD)) {
+			if (!(gpe_event_info->flags & ACPI_GPE_DISPATCH_METHOD)
+			    || (gpe_event_info->flags & ACPI_GPE_CAN_WAKE)) {
 				continue;
 			}
 
-			/*
-			 * If the GPE has already been enabled for runtime
-			 * signaling, make sure it remains enabled, but do not
-			 * increment its reference counter.
-			 */
-			status = gpe_event_info->runtime_count ?
-				acpi_ev_enable_gpe(gpe_event_info) :
-				acpi_enable_gpe(gpe_device, gpe_number);
-
+			status = acpi_raw_enable_gpe(gpe_event_info);
 			if (ACPI_FAILURE(status)) {
 				ACPI_EXCEPTION((AE_INFO, status,
-						"Could not enable GPE 0x%02X",
-						gpe_number));
+					"Could not enable GPE 0x%02X",
+					gpe_index + gpe_block->block_base_number));
 				continue;
 			}
 
@@ -504,5 +497,7 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 				  gpe_enabled_count));
 	}
 
+	gpe_block->initialized = TRUE;
+
 	return_ACPI_STATUS(AE_OK);
 }

commit a0d468718b9049f7396d101075a129a2d683ad66
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 8 00:44:42 2010 +0200

    ACPI / ACPICA: Simplify acpi_ev_initialize_gpe_block()
    
    Simplify the main loop in acpi_ev_initialize_gpe_block() by
    rearranging code and removing the "enabled" label that is not
    necessary any more.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 12ca1bc5f1fd..85445fb5844e 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -472,26 +472,21 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 			gpe_event_info = &gpe_block->event_info[gpe_index];
 			gpe_number = gpe_index + gpe_block->block_base_number;
 
-			/*
-			 * If the GPE has already been enabled for runtime
-			 * signaling, make sure it remains enabled, but do not
-			 * increment its reference counter.
-			 */
-			if (gpe_event_info->runtime_count) {
-				status = acpi_ev_enable_gpe(gpe_event_info);
-				goto enabled;
-			}
-
 			/* Ignore GPEs that have no corresponding _Lxx/_Exx method */
 
 			if (!(gpe_event_info->flags & ACPI_GPE_DISPATCH_METHOD)) {
 				continue;
 			}
 
-			/* Enable this GPE */
+			/*
+			 * If the GPE has already been enabled for runtime
+			 * signaling, make sure it remains enabled, but do not
+			 * increment its reference counter.
+			 */
+			status = gpe_event_info->runtime_count ?
+				acpi_ev_enable_gpe(gpe_event_info) :
+				acpi_enable_gpe(gpe_device, gpe_number);
 
-			status = acpi_enable_gpe(gpe_device, gpe_number);
-		      enabled:
 			if (ACPI_FAILURE(status)) {
 				ACPI_EXCEPTION((AE_INFO, status,
 						"Could not enable GPE 0x%02X",

commit 9874647ba1bdf3e1af25e079070a00676f60f2f0
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 8 00:43:36 2010 +0200

    ACPI / ACPICA: Do not execute _PRW methods during initialization
    
    Currently, during initialization ACPICA walks the entire ACPI
    namespace in search of any device objects with assciated _PRW
    methods.  All of the _PRW methods found are executed in the process
    to extract the GPE information returned by them, so that the GPEs in
    question can be marked as "able to wakeup" (more precisely, the
    ACPI_GPE_CAN_WAKE flag is set for them).  The only purpose of this
    exercise is to avoid enabling the CAN_WAKE GPEs automatically, even
    if there are _Lxx/_Exx methods associated with them.  However, it is
    both costly and unnecessary, because the host OS has to execute the
    _PRW methods anyway to check which devices can wake up the system
    from sleep states.  Moreover, it then uses full information
    returned by _PRW, including the GPE information, so it can take care
    of disabling the GPEs if necessary.
    
    Remove the code that walks the namespace and executes _PRW from
    ACPICA and modify comments to reflect that change.  Make
    acpi_bus_set_run_wake_flags() disable GPEs for wakeup devices
    so that they don't cause spurious wakeup events to be signaled.
    This not only reduces the complexity of the ACPICA initialization
    code, but in some cases it should reduce the kernel boot time as
    well.
    
    Unfortunately, for this purpose we need a new ACPICA function,
    acpi_gpe_can_wake(), to be called by the host OS in order to disable
    the GPEs that can wake up the system and were previously enabled by
    acpi_ev_initialize_gpe_block() or acpi_ev_update_gpes() (such a GPE
    should be disabled only once, because the initialization code enables
    it only once, but it may be pointed to by _PRW for multiple devices
    and that's why the additional function is necessary).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 0c6f3f878eb5..12ca1bc5f1fd 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -439,8 +439,6 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 {
 	acpi_status status;
 	struct acpi_gpe_event_info *gpe_event_info;
-	struct acpi_gpe_walk_info walk_info;
-	u32 wake_gpe_count;
 	u32 gpe_enabled_count;
 	u32 gpe_index;
 	u32 gpe_number;
@@ -456,37 +454,9 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 	}
 
 	/*
-	 * Runtime option: Should wake GPEs be enabled at runtime?  The default
-	 * is no, they should only be enabled just as the machine goes to sleep.
+	 * Enable all GPEs that have a corresponding method.  Any other GPEs
+	 * within this block must be enabled via the acpi_enable_gpe interface.
 	 */
-	if (acpi_gbl_leave_wake_gpes_disabled) {
-		/*
-		 * Differentiate runtime vs wake GPEs, via the _PRW control methods.
-		 * Each GPE that has one or more _PRWs that reference it is by
-		 * definition a wake GPE and will not be enabled while the machine
-		 * is running.
-		 */
-		walk_info.gpe_block = gpe_block;
-		walk_info.gpe_device = gpe_device;
-		walk_info.execute_by_owner_id = FALSE;
-
-		status =
-		    acpi_ns_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
-					   ACPI_UINT32_MAX, ACPI_NS_WALK_UNLOCK,
-					   acpi_ev_match_prw_and_gpe, NULL,
-					   &walk_info, NULL);
-		if (ACPI_FAILURE(status)) {
-			ACPI_EXCEPTION((AE_INFO, status,
-					"While executing _PRW methods"));
-		}
-	}
-
-	/*
-	 * Enable all GPEs that have a corresponding method and are not
-	 * capable of generating wakeups. Any other GPEs within this block
-	 * must be enabled via the acpi_enable_gpe interface.
-	 */
-	wake_gpe_count = 0;
 	gpe_enabled_count = 0;
 
 	if (gpe_device == acpi_gbl_fadt_gpe_device) {
@@ -512,13 +482,6 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 				goto enabled;
 			}
 
-			if (gpe_event_info->flags & ACPI_GPE_CAN_WAKE) {
-				wake_gpe_count++;
-				if (acpi_gbl_leave_wake_gpes_disabled) {
-					continue;
-				}
-			}
-
 			/* Ignore GPEs that have no corresponding _Lxx/_Exx method */
 
 			if (!(gpe_event_info->flags & ACPI_GPE_DISPATCH_METHOD)) {
@@ -540,10 +503,10 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 		}
 	}
 
-	if (gpe_enabled_count || wake_gpe_count) {
+	if (gpe_enabled_count) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INIT,
-				  "Enabled %u Runtime GPEs, added %u Wake GPEs in this block\n",
-				  gpe_enabled_count, wake_gpe_count));
+				  "Enabled %u GPEs in this block\n",
+				  gpe_enabled_count));
 	}
 
 	return_ACPI_STATUS(AE_OK);

commit 3bd741bd0dfcc1845ae6892baa5192c91addc84c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 1 11:01:12 2010 +0800

    ACPICA: Use low-level GPE enable during GPE block initialization
    
    The GPE block initialization code in acpi_ev_initialize_gpe_block()
    uses acpi_set_gpe() to make sure that the GPEs with nonzero
    runtime counter will remain enabled, but since it already has
    a struct acpi_gpe_event_info object for each GPE, it might use
    the low-level GPE enabling function, acpi_clear_and_enable_gpe(),
    for this purpose.
    
    To make that happen, move acpi_clear_and_enable_gpe() to
    drivers/acpi/acpica/evgpe.c and rename it to acpi_ev_enable_gpe(),
    modify the two existing users of it accordingly and modify
    acpi_ev_initialize_gpe_block() to use it instead of acpi_set_gpe()
    and to check its return value.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 77e8630043f8..0c6f3f878eb5 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -508,10 +508,8 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 			 * increment its reference counter.
 			 */
 			if (gpe_event_info->runtime_count) {
-				acpi_set_gpe(gpe_device, gpe_number,
-						ACPI_GPE_ENABLE);
-				gpe_enabled_count++;
-				continue;
+				status = acpi_ev_enable_gpe(gpe_event_info);
+				goto enabled;
 			}
 
 			if (gpe_event_info->flags & ACPI_GPE_CAN_WAKE) {
@@ -530,6 +528,7 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 			/* Enable this GPE */
 
 			status = acpi_enable_gpe(gpe_device, gpe_number);
+		      enabled:
 			if (ACPI_FAILURE(status)) {
 				ACPI_EXCEPTION((AE_INFO, status,
 						"Could not enable GPE 0x%02X",

commit a44061aa8b5d58b2729faca4c155a94a5bea2a09
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 1 10:11:45 2010 +0800

    ACPICA: Remove wakeup GPE reference counting which is not used
    
    After the previous patch that introduced acpi_gpe_wakeup() and
    modified the ACPI suspend and wakeup code to use it, the third
    argument of acpi_{enable|disable}_gpe() and the GPE wakeup
    reference counter are not necessary any more.  Remove them and
    modify all of the users of acpi_{enable|disable}_gpe()
    accordingly.  Also drop GPE type constants that aren't used
    any more.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 341a38ce8aa6..77e8630043f8 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -529,8 +529,7 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 
 			/* Enable this GPE */
 
-			status = acpi_enable_gpe(gpe_device, gpe_number,
-						 ACPI_GPE_TYPE_RUNTIME);
+			status = acpi_enable_gpe(gpe_device, gpe_number);
 			if (ACPI_FAILURE(status)) {
 				ACPI_EXCEPTION((AE_INFO, status,
 						"Could not enable GPE 0x%02X",

commit 92634825571d86417941855a8e3189c07aa3c706
Merge: 7e27d6e778cd 9d3c752de65d
Author: Len Brown <len.brown@intel.com>
Date:   Sat Jun 12 00:51:49 2010 -0400

    Merge branch 'gpe-regression-fixes' into release

commit ce43ace02320a3fb9614ddb27edc3a8700d68b26
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jun 8 10:50:20 2010 +0200

    ACPI / ACPICA: Fix GPE initialization
    
    While developing the GPE reference counting code we overlooked the
    fact that acpi_ev_update_gpes() could have enabled GPEs before
    acpi_ev_initialize_gpe_block() was called.  As a result, some GPEs
    are enabled twice during the initialization.
    
    To fix this issue avoid calling acpi_enable_gpe() from
    acpi_ev_initialize_gpe_block() for the GPEs that have nonzero
    runtime reference counters.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 85ded1f2540d..79048de0aded 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -1024,6 +1024,19 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 
 			gpe_index = (i * ACPI_GPE_REGISTER_WIDTH) + j;
 			gpe_event_info = &gpe_block->event_info[gpe_index];
+			gpe_number = gpe_index + gpe_block->block_base_number;
+
+			/*
+			 * If the GPE has already been enabled for runtime
+			 * signaling, make sure it remains enabled, but do not
+			 * increment its reference counter.
+			 */
+			if (gpe_event_info->runtime_count) {
+				acpi_set_gpe(gpe_device, gpe_number,
+						ACPI_GPE_ENABLE);
+				gpe_enabled_count++;
+				continue;
+			}
 
 			if (gpe_event_info->flags & ACPI_GPE_CAN_WAKE) {
 				wake_gpe_count++;
@@ -1040,7 +1053,6 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 
 			/* Enable this GPE */
 
-			gpe_number = gpe_index + gpe_block->block_base_number;
 			status = acpi_enable_gpe(gpe_device, gpe_number,
 						 ACPI_GPE_TYPE_RUNTIME);
 			if (ACPI_FAILURE(status)) {

commit 3fe50208b29b2463eb6c181c1433dd1beb39f282
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Apr 27 11:41:19 2010 +0800

    ACPICA: Split large file, evgpeblk
    
    Create two new files, evgpeinit.c and evgpeutil.c. Updated
    unix and linux makefiles.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 3341d1dfe78a..7c28f2d9fd35 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -45,26 +45,11 @@
 #include "accommon.h"
 #include "acevents.h"
 #include "acnamesp.h"
-#include "acinterp.h"
 
 #define _COMPONENT          ACPI_EVENTS
 ACPI_MODULE_NAME("evgpeblk")
 
 /* Local prototypes */
-static acpi_status
-acpi_ev_match_gpe_method(acpi_handle obj_handle,
-			 u32 level, void *obj_desc, void **return_value);
-
-static acpi_status
-acpi_ev_match_prw_and_gpe(acpi_handle obj_handle,
-			  u32 level, void *info, void **return_value);
-
-static struct acpi_gpe_xrupt_info *acpi_ev_get_gpe_xrupt_block(u32
-							       interrupt_number);
-
-static acpi_status
-acpi_ev_delete_gpe_xrupt(struct acpi_gpe_xrupt_info *gpe_xrupt);
-
 static acpi_status
 acpi_ev_install_gpe_block(struct acpi_gpe_block_info *gpe_block,
 			  u32 interrupt_number);
@@ -72,632 +57,6 @@ acpi_ev_install_gpe_block(struct acpi_gpe_block_info *gpe_block,
 static acpi_status
 acpi_ev_create_gpe_info_blocks(struct acpi_gpe_block_info *gpe_block);
 
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ev_valid_gpe_event
- *
- * PARAMETERS:  gpe_event_info              - Info for this GPE
- *
- * RETURN:      TRUE if the gpe_event is valid
- *
- * DESCRIPTION: Validate a GPE event. DO NOT CALL FROM INTERRUPT LEVEL.
- *              Should be called only when the GPE lists are semaphore locked
- *              and not subject to change.
- *
- ******************************************************************************/
-
-u8 acpi_ev_valid_gpe_event(struct acpi_gpe_event_info *gpe_event_info)
-{
-	struct acpi_gpe_xrupt_info *gpe_xrupt_block;
-	struct acpi_gpe_block_info *gpe_block;
-
-	ACPI_FUNCTION_ENTRY();
-
-	/* No need for spin lock since we are not changing any list elements */
-
-	/* Walk the GPE interrupt levels */
-
-	gpe_xrupt_block = acpi_gbl_gpe_xrupt_list_head;
-	while (gpe_xrupt_block) {
-		gpe_block = gpe_xrupt_block->gpe_block_list_head;
-
-		/* Walk the GPE blocks on this interrupt level */
-
-		while (gpe_block) {
-			if ((&gpe_block->event_info[0] <= gpe_event_info) &&
-			    (&gpe_block->event_info[gpe_block->gpe_count] >
-			     gpe_event_info)) {
-				return (TRUE);
-			}
-
-			gpe_block = gpe_block->next;
-		}
-
-		gpe_xrupt_block = gpe_xrupt_block->next;
-	}
-
-	return (FALSE);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ev_walk_gpe_list
- *
- * PARAMETERS:  gpe_walk_callback   - Routine called for each GPE block
- *              Context             - Value passed to callback
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Walk the GPE lists.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ev_walk_gpe_list(acpi_gpe_callback gpe_walk_callback, void *context)
-{
-	struct acpi_gpe_block_info *gpe_block;
-	struct acpi_gpe_xrupt_info *gpe_xrupt_info;
-	acpi_status status = AE_OK;
-	acpi_cpu_flags flags;
-
-	ACPI_FUNCTION_TRACE(ev_walk_gpe_list);
-
-	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
-
-	/* Walk the interrupt level descriptor list */
-
-	gpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;
-	while (gpe_xrupt_info) {
-
-		/* Walk all Gpe Blocks attached to this interrupt level */
-
-		gpe_block = gpe_xrupt_info->gpe_block_list_head;
-		while (gpe_block) {
-
-			/* One callback per GPE block */
-
-			status =
-			    gpe_walk_callback(gpe_xrupt_info, gpe_block,
-					      context);
-			if (ACPI_FAILURE(status)) {
-				if (status == AE_CTRL_END) {	/* Callback abort */
-					status = AE_OK;
-				}
-				goto unlock_and_exit;
-			}
-
-			gpe_block = gpe_block->next;
-		}
-
-		gpe_xrupt_info = gpe_xrupt_info->next;
-	}
-
-      unlock_and_exit:
-	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
-	return_ACPI_STATUS(status);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ev_delete_gpe_handlers
- *
- * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info
- *              gpe_block           - Gpe Block info
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Delete all Handler objects found in the GPE data structs.
- *              Used only prior to termination.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ev_delete_gpe_handlers(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
-			    struct acpi_gpe_block_info *gpe_block,
-			    void *context)
-{
-	struct acpi_gpe_event_info *gpe_event_info;
-	u32 i;
-	u32 j;
-
-	ACPI_FUNCTION_TRACE(ev_delete_gpe_handlers);
-
-	/* Examine each GPE Register within the block */
-
-	for (i = 0; i < gpe_block->register_count; i++) {
-
-		/* Now look at the individual GPEs in this byte register */
-
-		for (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {
-			gpe_event_info = &gpe_block->event_info[((acpi_size) i *
-								 ACPI_GPE_REGISTER_WIDTH)
-								+ j];
-
-			if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
-			    ACPI_GPE_DISPATCH_HANDLER) {
-				ACPI_FREE(gpe_event_info->dispatch.handler);
-				gpe_event_info->dispatch.handler = NULL;
-				gpe_event_info->flags &=
-				    ~ACPI_GPE_DISPATCH_MASK;
-			}
-		}
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ev_match_gpe_method
- *
- * PARAMETERS:  Callback from walk_namespace
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Called from acpi_walk_namespace. Expects each object to be a
- *              control method under the _GPE portion of the namespace.
- *              Extract the name and GPE type from the object, saving this
- *              information for quick lookup during GPE dispatch. Allows a
- *              per-owner_id evaluation if execute_by_owner_id is TRUE in the
- *              walk_info parameter block.
- *
- *              The name of each GPE control method is of the form:
- *              "_Lxx" or "_Exx", where:
- *                  L      - means that the GPE is level triggered
- *                  E      - means that the GPE is edge triggered
- *                  xx     - is the GPE number [in HEX]
- *
- * If walk_info->execute_by_owner_id is TRUE, we only execute examine GPE methods
- *    with that owner.
- * If walk_info->enable_this_gpe is TRUE, the GPE that is referred to by a GPE
- *    method is immediately enabled (Used for Load/load_table operators)
- *
- ******************************************************************************/
-
-static acpi_status
-acpi_ev_match_gpe_method(acpi_handle obj_handle,
-			 u32 level, void *context, void **return_value)
-{
-	struct acpi_namespace_node *method_node =
-	    ACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);
-	struct acpi_gpe_walk_info *walk_info =
-	    ACPI_CAST_PTR(struct acpi_gpe_walk_info, context);
-	struct acpi_gpe_event_info *gpe_event_info;
-	struct acpi_namespace_node *gpe_device;
-	acpi_status status;
-	u32 gpe_number;
-	char name[ACPI_NAME_SIZE + 1];
-	u8 type;
-
-	ACPI_FUNCTION_TRACE(ev_match_gpe_method);
-
-	/* Check if requested owner_id matches this owner_id */
-
-	if ((walk_info->execute_by_owner_id) &&
-	    (method_node->owner_id != walk_info->owner_id)) {
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	/*
-	 * Match and decode the _Lxx and _Exx GPE method names
-	 *
-	 * 1) Extract the method name and null terminate it
-	 */
-	ACPI_MOVE_32_TO_32(name, &method_node->name.integer);
-	name[ACPI_NAME_SIZE] = 0;
-
-	/* 2) Name must begin with an underscore */
-
-	if (name[0] != '_') {
-		return_ACPI_STATUS(AE_OK);	/* Ignore this method */
-	}
-
-	/*
-	 * 3) Edge/Level determination is based on the 2nd character
-	 *    of the method name
-	 *
-	 * NOTE: Default GPE type is RUNTIME only. Later, if a _PRW object is
-	 * found that points to this GPE, the ACPI_GPE_CAN_WAKE flag is set.
-	 */
-	switch (name[1]) {
-	case 'L':
-		type = ACPI_GPE_LEVEL_TRIGGERED;
-		break;
-
-	case 'E':
-		type = ACPI_GPE_EDGE_TRIGGERED;
-		break;
-
-	default:
-		/* Unknown method type, just ignore it */
-
-		ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
-				  "Ignoring unknown GPE method type: %s "
-				  "(name not of form _Lxx or _Exx)", name));
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	/* 4) The last two characters of the name are the hex GPE Number */
-
-	gpe_number = ACPI_STRTOUL(&name[2], NULL, 16);
-	if (gpe_number == ACPI_UINT32_MAX) {
-
-		/* Conversion failed; invalid method, just ignore it */
-
-		ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
-				  "Could not extract GPE number from name: %s "
-				  "(name is not of form _Lxx or _Exx)", name));
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	/* Ensure that we have a valid GPE number for this GPE block */
-
-	gpe_event_info =
-	    acpi_ev_low_get_gpe_info(gpe_number, walk_info->gpe_block);
-	if (!gpe_event_info) {
-		/*
-		 * This gpe_number is not valid for this GPE block, just ignore it.
-		 * However, it may be valid for a different GPE block, since GPE0
-		 * and GPE1 methods both appear under \_GPE.
-		 */
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
-	    ACPI_GPE_DISPATCH_HANDLER) {
-
-		/* If there is already a handler, ignore this GPE method */
-
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
-	    ACPI_GPE_DISPATCH_METHOD) {
-		/*
-		 * If there is already a method, ignore this method. But check
-		 * for a type mismatch (if both the _Lxx AND _Exx exist)
-		 */
-		if (type != (gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK)) {
-			ACPI_ERROR((AE_INFO,
-				    "For GPE 0x%.2X, found both _L%2.2X and _E%2.2X methods",
-				    gpe_number, gpe_number, gpe_number));
-		}
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	/*
-	 * Add the GPE information from above to the gpe_event_info block for
-	 * use during dispatch of this GPE.
-	 */
-	gpe_event_info->flags |= (u8)(type | ACPI_GPE_DISPATCH_METHOD);
-	gpe_event_info->dispatch.method_node = method_node;
-
-	/*
-	 * Enable this GPE if requested. This only happens when during the
-	 * execution of a Load or load_table operator. We have found a new
-	 * GPE method and want to immediately enable the GPE if it is a
-	 * runtime GPE.
-	 */
-	if (walk_info->enable_this_gpe) {
-
-		/* Ignore GPEs that can wake the system */
-
-		if (!(gpe_event_info->flags & ACPI_GPE_CAN_WAKE) ||
-		    !acpi_gbl_leave_wake_gpes_disabled) {
-			walk_info->count++;
-			gpe_device = walk_info->gpe_device;
-
-			if (gpe_device == acpi_gbl_fadt_gpe_device) {
-				gpe_device = NULL;
-			}
-
-			status = acpi_enable_gpe(gpe_device, gpe_number,
-						 ACPI_GPE_TYPE_RUNTIME);
-			if (ACPI_FAILURE(status)) {
-				ACPI_EXCEPTION((AE_INFO, status,
-						"Could not enable GPE 0x%02X",
-						gpe_number));
-			}
-		}
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
-			  "Registered GPE method %s as GPE number 0x%.2X\n",
-			  name, gpe_number));
-	return_ACPI_STATUS(AE_OK);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ev_match_prw_and_gpe
- *
- * PARAMETERS:  Callback from walk_namespace
- *
- * RETURN:      Status. NOTE: We ignore errors so that the _PRW walk is
- *              not aborted on a single _PRW failure.
- *
- * DESCRIPTION: Called from acpi_walk_namespace. Expects each object to be a
- *              Device. Run the _PRW method. If present, extract the GPE
- *              number and mark the GPE as a CAN_WAKE GPE. Allows a
- *              per-owner_id execution if execute_by_owner_id is TRUE in the
- *              walk_info parameter block.
- *
- * If walk_info->execute_by_owner_id is TRUE, we only execute _PRWs with that
- *    owner.
- * If walk_info->gpe_device is NULL, we execute every _PRW found. Otherwise,
- *    we only execute _PRWs that refer to the input gpe_device.
- *
- ******************************************************************************/
-
-static acpi_status
-acpi_ev_match_prw_and_gpe(acpi_handle obj_handle,
-			  u32 level, void *context, void **return_value)
-{
-	struct acpi_gpe_walk_info *walk_info =
-	    ACPI_CAST_PTR(struct acpi_gpe_walk_info, context);
-	struct acpi_namespace_node *gpe_device;
-	struct acpi_gpe_block_info *gpe_block;
-	struct acpi_namespace_node *target_gpe_device;
-	struct acpi_namespace_node *prw_node;
-	struct acpi_gpe_event_info *gpe_event_info;
-	union acpi_operand_object *pkg_desc;
-	union acpi_operand_object *obj_desc;
-	u32 gpe_number;
-	acpi_status status;
-
-	ACPI_FUNCTION_TRACE(ev_match_prw_and_gpe);
-
-	/* Check for a _PRW method under this device */
-
-	status = acpi_ns_get_node(obj_handle, METHOD_NAME__PRW,
-				  ACPI_NS_NO_UPSEARCH, &prw_node);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	/* Check if requested owner_id matches this owner_id */
-
-	if ((walk_info->execute_by_owner_id) &&
-	    (prw_node->owner_id != walk_info->owner_id)) {
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	/* Execute the _PRW */
-
-	status = acpi_ut_evaluate_object(prw_node, NULL,
-					 ACPI_BTYPE_PACKAGE, &pkg_desc);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	/* The returned _PRW package must have at least two elements */
-
-	if (pkg_desc->package.count < 2) {
-		goto cleanup;
-	}
-
-	/* Extract pointers from the input context */
-
-	gpe_device = walk_info->gpe_device;
-	gpe_block = walk_info->gpe_block;
-
-	/*
-	 * The _PRW object must return a package, we are only interested
-	 * in the first element
-	 */
-	obj_desc = pkg_desc->package.elements[0];
-
-	if (obj_desc->common.type == ACPI_TYPE_INTEGER) {
-
-		/* Use FADT-defined GPE device (from definition of _PRW) */
-
-		target_gpe_device = NULL;
-		if (gpe_device) {
-			target_gpe_device = acpi_gbl_fadt_gpe_device;
-		}
-
-		/* Integer is the GPE number in the FADT described GPE blocks */
-
-		gpe_number = (u32) obj_desc->integer.value;
-	} else if (obj_desc->common.type == ACPI_TYPE_PACKAGE) {
-
-		/* Package contains a GPE reference and GPE number within a GPE block */
-
-		if ((obj_desc->package.count < 2) ||
-		    ((obj_desc->package.elements[0])->common.type !=
-		     ACPI_TYPE_LOCAL_REFERENCE) ||
-		    ((obj_desc->package.elements[1])->common.type !=
-		     ACPI_TYPE_INTEGER)) {
-			goto cleanup;
-		}
-
-		/* Get GPE block reference and decode */
-
-		target_gpe_device =
-		    obj_desc->package.elements[0]->reference.node;
-		gpe_number = (u32) obj_desc->package.elements[1]->integer.value;
-	} else {
-		/* Unknown type, just ignore it */
-
-		goto cleanup;
-	}
-
-	/* Get the gpe_event_info for this GPE */
-
-	if (gpe_device) {
-		/*
-		 * Is this GPE within this block?
-		 *
-		 * TRUE if and only if these conditions are true:
-		 *     1) The GPE devices match.
-		 *     2) The GPE index(number) is within the range of the Gpe Block
-		 *          associated with the GPE device.
-		 */
-		if (gpe_device != target_gpe_device) {
-			goto cleanup;
-		}
-
-		gpe_event_info =
-		    acpi_ev_low_get_gpe_info(gpe_number, gpe_block);
-	} else {
-		/* gpe_device is NULL, just match the target_device and gpe_number */
-
-		gpe_event_info =
-		    acpi_ev_get_gpe_event_info(target_gpe_device, gpe_number);
-	}
-
-	if (gpe_event_info) {
-		if (!(gpe_event_info->flags & ACPI_GPE_CAN_WAKE)) {
-
-			/* This GPE can wake the system */
-
-			gpe_event_info->flags |= ACPI_GPE_CAN_WAKE;
-			walk_info->count++;
-		}
-	}
-
-      cleanup:
-	acpi_ut_remove_reference(pkg_desc);
-	return_ACPI_STATUS(AE_OK);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ev_get_gpe_xrupt_block
- *
- * PARAMETERS:  interrupt_number     - Interrupt for a GPE block
- *
- * RETURN:      A GPE interrupt block
- *
- * DESCRIPTION: Get or Create a GPE interrupt block. There is one interrupt
- *              block per unique interrupt level used for GPEs. Should be
- *              called only when the GPE lists are semaphore locked and not
- *              subject to change.
- *
- ******************************************************************************/
-
-static struct acpi_gpe_xrupt_info *acpi_ev_get_gpe_xrupt_block(u32
-							       interrupt_number)
-{
-	struct acpi_gpe_xrupt_info *next_gpe_xrupt;
-	struct acpi_gpe_xrupt_info *gpe_xrupt;
-	acpi_status status;
-	acpi_cpu_flags flags;
-
-	ACPI_FUNCTION_TRACE(ev_get_gpe_xrupt_block);
-
-	/* No need for lock since we are not changing any list elements here */
-
-	next_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;
-	while (next_gpe_xrupt) {
-		if (next_gpe_xrupt->interrupt_number == interrupt_number) {
-			return_PTR(next_gpe_xrupt);
-		}
-
-		next_gpe_xrupt = next_gpe_xrupt->next;
-	}
-
-	/* Not found, must allocate a new xrupt descriptor */
-
-	gpe_xrupt = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_gpe_xrupt_info));
-	if (!gpe_xrupt) {
-		return_PTR(NULL);
-	}
-
-	gpe_xrupt->interrupt_number = interrupt_number;
-
-	/* Install new interrupt descriptor with spin lock */
-
-	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
-	if (acpi_gbl_gpe_xrupt_list_head) {
-		next_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;
-		while (next_gpe_xrupt->next) {
-			next_gpe_xrupt = next_gpe_xrupt->next;
-		}
-
-		next_gpe_xrupt->next = gpe_xrupt;
-		gpe_xrupt->previous = next_gpe_xrupt;
-	} else {
-		acpi_gbl_gpe_xrupt_list_head = gpe_xrupt;
-	}
-	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
-
-	/* Install new interrupt handler if not SCI_INT */
-
-	if (interrupt_number != acpi_gbl_FADT.sci_interrupt) {
-		status = acpi_os_install_interrupt_handler(interrupt_number,
-							   acpi_ev_gpe_xrupt_handler,
-							   gpe_xrupt);
-		if (ACPI_FAILURE(status)) {
-			ACPI_ERROR((AE_INFO,
-				    "Could not install GPE interrupt handler at level 0x%X",
-				    interrupt_number));
-			return_PTR(NULL);
-		}
-	}
-
-	return_PTR(gpe_xrupt);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ev_delete_gpe_xrupt
- *
- * PARAMETERS:  gpe_xrupt       - A GPE interrupt info block
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Remove and free a gpe_xrupt block. Remove an associated
- *              interrupt handler if not the SCI interrupt.
- *
- ******************************************************************************/
-
-static acpi_status
-acpi_ev_delete_gpe_xrupt(struct acpi_gpe_xrupt_info *gpe_xrupt)
-{
-	acpi_status status;
-	acpi_cpu_flags flags;
-
-	ACPI_FUNCTION_TRACE(ev_delete_gpe_xrupt);
-
-	/* We never want to remove the SCI interrupt handler */
-
-	if (gpe_xrupt->interrupt_number == acpi_gbl_FADT.sci_interrupt) {
-		gpe_xrupt->gpe_block_list_head = NULL;
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	/* Disable this interrupt */
-
-	status =
-	    acpi_os_remove_interrupt_handler(gpe_xrupt->interrupt_number,
-					     acpi_ev_gpe_xrupt_handler);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/* Unlink the interrupt block with lock */
-
-	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
-	if (gpe_xrupt->previous) {
-		gpe_xrupt->previous->next = gpe_xrupt->next;
-	} else {
-		/* No previous, update list head */
-
-		acpi_gbl_gpe_xrupt_list_head = gpe_xrupt->next;
-	}
-
-	if (gpe_xrupt->next) {
-		gpe_xrupt->next->previous = gpe_xrupt->previous;
-	}
-	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
-
-	/* Free the block */
-
-	ACPI_FREE(gpe_xrupt);
-	return_ACPI_STATUS(AE_OK);
-}
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ev_install_gpe_block
@@ -1058,123 +417,6 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 	return_ACPI_STATUS(AE_OK);
 }
 
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ev_update_gpes
- *
- * PARAMETERS:  table_owner_id      - ID of the newly-loaded ACPI table
- *
- * RETURN:      None
- *
- * DESCRIPTION: Check for new GPE methods (_Lxx/_Exx) made available as a
- *              result of a Load() or load_table() operation. If new GPE
- *              methods have been installed, register the new methods and
- *              enable and runtime GPEs that are associated with them. Also,
- *              run any newly loaded _PRW methods in order to discover any
- *              new CAN_WAKE GPEs.
- *
- ******************************************************************************/
-
-void acpi_ev_update_gpes(acpi_owner_id table_owner_id)
-{
-	struct acpi_gpe_xrupt_info *gpe_xrupt_info;
-	struct acpi_gpe_block_info *gpe_block;
-	struct acpi_gpe_walk_info walk_info;
-	acpi_status status = AE_OK;
-	u32 new_wake_gpe_count = 0;
-
-	/* We will examine only _PRW/_Lxx/_Exx methods owned by this table */
-
-	walk_info.owner_id = table_owner_id;
-	walk_info.execute_by_owner_id = TRUE;
-	walk_info.count = 0;
-
-	if (acpi_gbl_leave_wake_gpes_disabled) {
-		/*
-		 * 1) Run any newly-loaded _PRW methods to find any GPEs that
-		 * can now be marked as CAN_WAKE GPEs. Note: We must run the
-		 * _PRW methods before we process the _Lxx/_Exx methods because
-		 * we will enable all runtime GPEs associated with the new
-		 * _Lxx/_Exx methods at the time we process those methods.
-		 *
-		 * Unlock interpreter so that we can run the _PRW methods.
-		 */
-		walk_info.gpe_block = NULL;
-		walk_info.gpe_device = NULL;
-
-		acpi_ex_exit_interpreter();
-
-		status =
-		    acpi_ns_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
-					   ACPI_UINT32_MAX,
-					   ACPI_NS_WALK_NO_UNLOCK,
-					   acpi_ev_match_prw_and_gpe, NULL,
-					   &walk_info, NULL);
-		if (ACPI_FAILURE(status)) {
-			ACPI_EXCEPTION((AE_INFO, status,
-					"While executing _PRW methods"));
-		}
-
-		acpi_ex_enter_interpreter();
-		new_wake_gpe_count = walk_info.count;
-	}
-
-	/*
-	 * 2) Find any _Lxx/_Exx GPE methods that have just been loaded.
-	 *
-	 * Any GPEs that correspond to new _Lxx/_Exx methods and are not
-	 * marked as CAN_WAKE are immediately enabled.
-	 *
-	 * Examine the namespace underneath each gpe_device within the
-	 * gpe_block lists.
-	 */
-	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
-	if (ACPI_FAILURE(status)) {
-		return;
-	}
-
-	walk_info.count = 0;
-	walk_info.enable_this_gpe = TRUE;
-
-	/* Walk the interrupt level descriptor list */
-
-	gpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;
-	while (gpe_xrupt_info) {
-
-		/* Walk all Gpe Blocks attached to this interrupt level */
-
-		gpe_block = gpe_xrupt_info->gpe_block_list_head;
-		while (gpe_block) {
-			walk_info.gpe_block = gpe_block;
-			walk_info.gpe_device = gpe_block->node;
-
-			status = acpi_ns_walk_namespace(ACPI_TYPE_METHOD,
-							walk_info.gpe_device,
-							ACPI_UINT32_MAX,
-							ACPI_NS_WALK_NO_UNLOCK,
-							acpi_ev_match_gpe_method,
-							NULL, &walk_info, NULL);
-			if (ACPI_FAILURE(status)) {
-				ACPI_EXCEPTION((AE_INFO, status,
-						"While decoding _Lxx/_Exx methods"));
-			}
-
-			gpe_block = gpe_block->next;
-		}
-
-		gpe_xrupt_info = gpe_xrupt_info->next;
-	}
-
-	if (walk_info.count || new_wake_gpe_count) {
-		ACPI_INFO((AE_INFO,
-			   "Enabled %u new runtime GPEs, added %u new wakeup GPEs",
-			   walk_info.count, new_wake_gpe_count));
-	}
-
-	(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);
-	return;
-}
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ev_initialize_gpe_block
@@ -1296,154 +538,3 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 
 	return_ACPI_STATUS(AE_OK);
 }
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ev_gpe_initialize
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Initialize the GPE data structures
- *
- ******************************************************************************/
-
-acpi_status acpi_ev_gpe_initialize(void)
-{
-	u32 register_count0 = 0;
-	u32 register_count1 = 0;
-	u32 gpe_number_max = 0;
-	acpi_status status;
-
-	ACPI_FUNCTION_TRACE(ev_gpe_initialize);
-
-	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Initialize the GPE Block(s) defined in the FADT
-	 *
-	 * Why the GPE register block lengths are divided by 2:  From the ACPI
-	 * Spec, section "General-Purpose Event Registers", we have:
-	 *
-	 * "Each register block contains two registers of equal length
-	 *  GPEx_STS and GPEx_EN (where x is 0 or 1). The length of the
-	 *  GPE0_STS and GPE0_EN registers is equal to half the GPE0_LEN
-	 *  The length of the GPE1_STS and GPE1_EN registers is equal to
-	 *  half the GPE1_LEN. If a generic register block is not supported
-	 *  then its respective block pointer and block length values in the
-	 *  FADT table contain zeros. The GPE0_LEN and GPE1_LEN do not need
-	 *  to be the same size."
-	 */
-
-	/*
-	 * Determine the maximum GPE number for this machine.
-	 *
-	 * Note: both GPE0 and GPE1 are optional, and either can exist without
-	 * the other.
-	 *
-	 * If EITHER the register length OR the block address are zero, then that
-	 * particular block is not supported.
-	 */
-	if (acpi_gbl_FADT.gpe0_block_length &&
-	    acpi_gbl_FADT.xgpe0_block.address) {
-
-		/* GPE block 0 exists (has both length and address > 0) */
-
-		register_count0 = (u16) (acpi_gbl_FADT.gpe0_block_length / 2);
-
-		gpe_number_max =
-		    (register_count0 * ACPI_GPE_REGISTER_WIDTH) - 1;
-
-		/* Install GPE Block 0 */
-
-		status = acpi_ev_create_gpe_block(acpi_gbl_fadt_gpe_device,
-						  &acpi_gbl_FADT.xgpe0_block,
-						  register_count0, 0,
-						  acpi_gbl_FADT.sci_interrupt,
-						  &acpi_gbl_gpe_fadt_blocks[0]);
-
-		if (ACPI_FAILURE(status)) {
-			ACPI_EXCEPTION((AE_INFO, status,
-					"Could not create GPE Block 0"));
-		}
-	}
-
-	if (acpi_gbl_FADT.gpe1_block_length &&
-	    acpi_gbl_FADT.xgpe1_block.address) {
-
-		/* GPE block 1 exists (has both length and address > 0) */
-
-		register_count1 = (u16) (acpi_gbl_FADT.gpe1_block_length / 2);
-
-		/* Check for GPE0/GPE1 overlap (if both banks exist) */
-
-		if ((register_count0) &&
-		    (gpe_number_max >= acpi_gbl_FADT.gpe1_base)) {
-			ACPI_ERROR((AE_INFO,
-				    "GPE0 block (GPE 0 to %u) overlaps the GPE1 block "
-				    "(GPE %u to %u) - Ignoring GPE1",
-				    gpe_number_max, acpi_gbl_FADT.gpe1_base,
-				    acpi_gbl_FADT.gpe1_base +
-				    ((register_count1 *
-				      ACPI_GPE_REGISTER_WIDTH) - 1)));
-
-			/* Ignore GPE1 block by setting the register count to zero */
-
-			register_count1 = 0;
-		} else {
-			/* Install GPE Block 1 */
-
-			status =
-			    acpi_ev_create_gpe_block(acpi_gbl_fadt_gpe_device,
-						     &acpi_gbl_FADT.xgpe1_block,
-						     register_count1,
-						     acpi_gbl_FADT.gpe1_base,
-						     acpi_gbl_FADT.
-						     sci_interrupt,
-						     &acpi_gbl_gpe_fadt_blocks
-						     [1]);
-
-			if (ACPI_FAILURE(status)) {
-				ACPI_EXCEPTION((AE_INFO, status,
-						"Could not create GPE Block 1"));
-			}
-
-			/*
-			 * GPE0 and GPE1 do not have to be contiguous in the GPE number
-			 * space. However, GPE0 always starts at GPE number zero.
-			 */
-			gpe_number_max = acpi_gbl_FADT.gpe1_base +
-			    ((register_count1 * ACPI_GPE_REGISTER_WIDTH) - 1);
-		}
-	}
-
-	/* Exit if there are no GPE registers */
-
-	if ((register_count0 + register_count1) == 0) {
-
-		/* GPEs are not required by ACPI, this is OK */
-
-		ACPI_DEBUG_PRINT((ACPI_DB_INIT,
-				  "There are no GPE blocks defined in the FADT\n"));
-		status = AE_OK;
-		goto cleanup;
-	}
-
-	/* Check for Max GPE number out-of-range */
-
-	if (gpe_number_max > ACPI_GPE_MAX) {
-		ACPI_ERROR((AE_INFO,
-			    "Maximum GPE number from FADT is too large: 0x%X",
-			    gpe_number_max));
-		status = AE_BAD_VALUE;
-		goto cleanup;
-	}
-
-      cleanup:
-	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
-	return_ACPI_STATUS(AE_OK);
-}

commit 186c307f008d2a53961cd970aaf7cb9c33e79cb1
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Apr 27 11:32:28 2010 +0800

    ACPICA: Add GPE support for dynamically loaded ACPI tables
    
    For all GPEs, including FADT-based and GPE Block Devices, execute
    any _PRW methods in the new table, and process any _Lxx/_Exx GPE
    methods in the new table. Any runtime GPE that is referred to
    by an _Lxx/_Exx method in the new table is immediately enabled.
    ACPICA BZ 833.
    
    http://www.acpica.org/bugzilla/show_bug.cgi?id=833
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 85ded1f2540d..3341d1dfe78a 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -45,6 +45,7 @@
 #include "accommon.h"
 #include "acevents.h"
 #include "acnamesp.h"
+#include "acinterp.h"
 
 #define _COMPONENT          ACPI_EVENTS
 ACPI_MODULE_NAME("evgpeblk")
@@ -236,7 +237,9 @@ acpi_ev_delete_gpe_handlers(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
  * DESCRIPTION: Called from acpi_walk_namespace. Expects each object to be a
  *              control method under the _GPE portion of the namespace.
  *              Extract the name and GPE type from the object, saving this
- *              information for quick lookup during GPE dispatch
+ *              information for quick lookup during GPE dispatch. Allows a
+ *              per-owner_id evaluation if execute_by_owner_id is TRUE in the
+ *              walk_info parameter block.
  *
  *              The name of each GPE control method is of the form:
  *              "_Lxx" or "_Exx", where:
@@ -244,21 +247,36 @@ acpi_ev_delete_gpe_handlers(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
  *                  E      - means that the GPE is edge triggered
  *                  xx     - is the GPE number [in HEX]
  *
+ * If walk_info->execute_by_owner_id is TRUE, we only execute examine GPE methods
+ *    with that owner.
+ * If walk_info->enable_this_gpe is TRUE, the GPE that is referred to by a GPE
+ *    method is immediately enabled (Used for Load/load_table operators)
+ *
  ******************************************************************************/
 
 static acpi_status
 acpi_ev_match_gpe_method(acpi_handle obj_handle,
-			 u32 level, void *obj_desc, void **return_value)
+			 u32 level, void *context, void **return_value)
 {
 	struct acpi_namespace_node *method_node =
 	    ACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);
-	struct acpi_gpe_block_info *gpe_block = (void *)obj_desc;
+	struct acpi_gpe_walk_info *walk_info =
+	    ACPI_CAST_PTR(struct acpi_gpe_walk_info, context);
 	struct acpi_gpe_event_info *gpe_event_info;
+	struct acpi_namespace_node *gpe_device;
+	acpi_status status;
 	u32 gpe_number;
 	char name[ACPI_NAME_SIZE + 1];
 	u8 type;
 
-	ACPI_FUNCTION_TRACE(ev_save_method_info);
+	ACPI_FUNCTION_TRACE(ev_match_gpe_method);
+
+	/* Check if requested owner_id matches this owner_id */
+
+	if ((walk_info->execute_by_owner_id) &&
+	    (method_node->owner_id != walk_info->owner_id)) {
+		return_ACPI_STATUS(AE_OK);
+	}
 
 	/*
 	 * Match and decode the _Lxx and _Exx GPE method names
@@ -314,7 +332,8 @@ acpi_ev_match_gpe_method(acpi_handle obj_handle,
 
 	/* Ensure that we have a valid GPE number for this GPE block */
 
-	gpe_event_info = acpi_ev_low_get_gpe_info(gpe_number, gpe_block);
+	gpe_event_info =
+	    acpi_ev_low_get_gpe_info(gpe_number, walk_info->gpe_block);
 	if (!gpe_event_info) {
 		/*
 		 * This gpe_number is not valid for this GPE block, just ignore it.
@@ -324,13 +343,64 @@ acpi_ev_match_gpe_method(acpi_handle obj_handle,
 		return_ACPI_STATUS(AE_OK);
 	}
 
+	if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
+	    ACPI_GPE_DISPATCH_HANDLER) {
+
+		/* If there is already a handler, ignore this GPE method */
+
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
+	    ACPI_GPE_DISPATCH_METHOD) {
+		/*
+		 * If there is already a method, ignore this method. But check
+		 * for a type mismatch (if both the _Lxx AND _Exx exist)
+		 */
+		if (type != (gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK)) {
+			ACPI_ERROR((AE_INFO,
+				    "For GPE 0x%.2X, found both _L%2.2X and _E%2.2X methods",
+				    gpe_number, gpe_number, gpe_number));
+		}
+		return_ACPI_STATUS(AE_OK);
+	}
+
 	/*
 	 * Add the GPE information from above to the gpe_event_info block for
 	 * use during dispatch of this GPE.
 	 */
-	gpe_event_info->flags = (u8)(type | ACPI_GPE_DISPATCH_METHOD);
+	gpe_event_info->flags |= (u8)(type | ACPI_GPE_DISPATCH_METHOD);
 	gpe_event_info->dispatch.method_node = method_node;
 
+	/*
+	 * Enable this GPE if requested. This only happens when during the
+	 * execution of a Load or load_table operator. We have found a new
+	 * GPE method and want to immediately enable the GPE if it is a
+	 * runtime GPE.
+	 */
+	if (walk_info->enable_this_gpe) {
+
+		/* Ignore GPEs that can wake the system */
+
+		if (!(gpe_event_info->flags & ACPI_GPE_CAN_WAKE) ||
+		    !acpi_gbl_leave_wake_gpes_disabled) {
+			walk_info->count++;
+			gpe_device = walk_info->gpe_device;
+
+			if (gpe_device == acpi_gbl_fadt_gpe_device) {
+				gpe_device = NULL;
+			}
+
+			status = acpi_enable_gpe(gpe_device, gpe_number,
+						 ACPI_GPE_TYPE_RUNTIME);
+			if (ACPI_FAILURE(status)) {
+				ACPI_EXCEPTION((AE_INFO, status,
+						"Could not enable GPE 0x%02X",
+						gpe_number));
+			}
+		}
+	}
+
 	ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
 			  "Registered GPE method %s as GPE number 0x%.2X\n",
 			  name, gpe_number));
@@ -348,18 +418,27 @@ acpi_ev_match_gpe_method(acpi_handle obj_handle,
  *
  * DESCRIPTION: Called from acpi_walk_namespace. Expects each object to be a
  *              Device. Run the _PRW method. If present, extract the GPE
- *              number and mark the GPE as a CAN_WAKE GPE.
+ *              number and mark the GPE as a CAN_WAKE GPE. Allows a
+ *              per-owner_id execution if execute_by_owner_id is TRUE in the
+ *              walk_info parameter block.
+ *
+ * If walk_info->execute_by_owner_id is TRUE, we only execute _PRWs with that
+ *    owner.
+ * If walk_info->gpe_device is NULL, we execute every _PRW found. Otherwise,
+ *    we only execute _PRWs that refer to the input gpe_device.
  *
  ******************************************************************************/
 
 static acpi_status
 acpi_ev_match_prw_and_gpe(acpi_handle obj_handle,
-			  u32 level, void *info, void **return_value)
+			  u32 level, void *context, void **return_value)
 {
-	struct acpi_gpe_walk_info *gpe_info = (void *)info;
+	struct acpi_gpe_walk_info *walk_info =
+	    ACPI_CAST_PTR(struct acpi_gpe_walk_info, context);
 	struct acpi_namespace_node *gpe_device;
 	struct acpi_gpe_block_info *gpe_block;
 	struct acpi_namespace_node *target_gpe_device;
+	struct acpi_namespace_node *prw_node;
 	struct acpi_gpe_event_info *gpe_event_info;
 	union acpi_operand_object *pkg_desc;
 	union acpi_operand_object *obj_desc;
@@ -370,12 +449,24 @@ acpi_ev_match_prw_and_gpe(acpi_handle obj_handle,
 
 	/* Check for a _PRW method under this device */
 
-	status = acpi_ut_evaluate_object(obj_handle, METHOD_NAME__PRW,
-					 ACPI_BTYPE_PACKAGE, &pkg_desc);
+	status = acpi_ns_get_node(obj_handle, METHOD_NAME__PRW,
+				  ACPI_NS_NO_UPSEARCH, &prw_node);
 	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(AE_OK);
+	}
 
-		/* Ignore all errors from _PRW, we don't want to abort the walk */
+	/* Check if requested owner_id matches this owner_id */
 
+	if ((walk_info->execute_by_owner_id) &&
+	    (prw_node->owner_id != walk_info->owner_id)) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Execute the _PRW */
+
+	status = acpi_ut_evaluate_object(prw_node, NULL,
+					 ACPI_BTYPE_PACKAGE, &pkg_desc);
+	if (ACPI_FAILURE(status)) {
 		return_ACPI_STATUS(AE_OK);
 	}
 
@@ -387,12 +478,12 @@ acpi_ev_match_prw_and_gpe(acpi_handle obj_handle,
 
 	/* Extract pointers from the input context */
 
-	gpe_device = gpe_info->gpe_device;
-	gpe_block = gpe_info->gpe_block;
+	gpe_device = walk_info->gpe_device;
+	gpe_block = walk_info->gpe_block;
 
 	/*
-	 * The _PRW object must return a package, we are only interested in the
-	 * first element
+	 * The _PRW object must return a package, we are only interested
+	 * in the first element
 	 */
 	obj_desc = pkg_desc->package.elements[0];
 
@@ -400,7 +491,10 @@ acpi_ev_match_prw_and_gpe(acpi_handle obj_handle,
 
 		/* Use FADT-defined GPE device (from definition of _PRW) */
 
-		target_gpe_device = acpi_gbl_fadt_gpe_device;
+		target_gpe_device = NULL;
+		if (gpe_device) {
+			target_gpe_device = acpi_gbl_fadt_gpe_device;
+		}
 
 		/* Integer is the GPE number in the FADT described GPE blocks */
 
@@ -428,23 +522,38 @@ acpi_ev_match_prw_and_gpe(acpi_handle obj_handle,
 		goto cleanup;
 	}
 
-	/*
-	 * Is this GPE within this block?
-	 *
-	 * TRUE if and only if these conditions are true:
-	 *     1) The GPE devices match.
-	 *     2) The GPE index(number) is within the range of the Gpe Block
-	 *          associated with the GPE device.
-	 */
-	if (gpe_device != target_gpe_device) {
-		goto cleanup;
+	/* Get the gpe_event_info for this GPE */
+
+	if (gpe_device) {
+		/*
+		 * Is this GPE within this block?
+		 *
+		 * TRUE if and only if these conditions are true:
+		 *     1) The GPE devices match.
+		 *     2) The GPE index(number) is within the range of the Gpe Block
+		 *          associated with the GPE device.
+		 */
+		if (gpe_device != target_gpe_device) {
+			goto cleanup;
+		}
+
+		gpe_event_info =
+		    acpi_ev_low_get_gpe_info(gpe_number, gpe_block);
+	} else {
+		/* gpe_device is NULL, just match the target_device and gpe_number */
+
+		gpe_event_info =
+		    acpi_ev_get_gpe_event_info(target_gpe_device, gpe_number);
 	}
 
-	gpe_event_info = acpi_ev_low_get_gpe_info(gpe_number, gpe_block);
 	if (gpe_event_info) {
-		/* This GPE can wake the system */
+		if (!(gpe_event_info->flags & ACPI_GPE_CAN_WAKE)) {
+
+			/* This GPE can wake the system */
 
-		gpe_event_info->flags |= ACPI_GPE_CAN_WAKE;
+			gpe_event_info->flags |= ACPI_GPE_CAN_WAKE;
+			walk_info->count++;
+		}
 	}
 
       cleanup:
@@ -874,6 +983,7 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 {
 	acpi_status status;
 	struct acpi_gpe_block_info *gpe_block;
+	struct acpi_gpe_walk_info walk_info;
 
 	ACPI_FUNCTION_TRACE(ev_create_gpe_block);
 
@@ -916,12 +1026,17 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 		return_ACPI_STATUS(status);
 	}
 
-	/* Find all GPE methods (_Lxx, _Exx) for this block */
+	/* Find all GPE methods (_Lxx or_Exx) for this block */
+
+	walk_info.gpe_block = gpe_block;
+	walk_info.gpe_device = gpe_device;
+	walk_info.enable_this_gpe = FALSE;
+	walk_info.execute_by_owner_id = FALSE;
 
 	status = acpi_ns_walk_namespace(ACPI_TYPE_METHOD, gpe_device,
 					ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,
 					acpi_ev_match_gpe_method, NULL,
-					gpe_block, NULL);
+					&walk_info, NULL);
 
 	/* Return the new block */
 
@@ -943,6 +1058,123 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 	return_ACPI_STATUS(AE_OK);
 }
 
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_update_gpes
+ *
+ * PARAMETERS:  table_owner_id      - ID of the newly-loaded ACPI table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check for new GPE methods (_Lxx/_Exx) made available as a
+ *              result of a Load() or load_table() operation. If new GPE
+ *              methods have been installed, register the new methods and
+ *              enable and runtime GPEs that are associated with them. Also,
+ *              run any newly loaded _PRW methods in order to discover any
+ *              new CAN_WAKE GPEs.
+ *
+ ******************************************************************************/
+
+void acpi_ev_update_gpes(acpi_owner_id table_owner_id)
+{
+	struct acpi_gpe_xrupt_info *gpe_xrupt_info;
+	struct acpi_gpe_block_info *gpe_block;
+	struct acpi_gpe_walk_info walk_info;
+	acpi_status status = AE_OK;
+	u32 new_wake_gpe_count = 0;
+
+	/* We will examine only _PRW/_Lxx/_Exx methods owned by this table */
+
+	walk_info.owner_id = table_owner_id;
+	walk_info.execute_by_owner_id = TRUE;
+	walk_info.count = 0;
+
+	if (acpi_gbl_leave_wake_gpes_disabled) {
+		/*
+		 * 1) Run any newly-loaded _PRW methods to find any GPEs that
+		 * can now be marked as CAN_WAKE GPEs. Note: We must run the
+		 * _PRW methods before we process the _Lxx/_Exx methods because
+		 * we will enable all runtime GPEs associated with the new
+		 * _Lxx/_Exx methods at the time we process those methods.
+		 *
+		 * Unlock interpreter so that we can run the _PRW methods.
+		 */
+		walk_info.gpe_block = NULL;
+		walk_info.gpe_device = NULL;
+
+		acpi_ex_exit_interpreter();
+
+		status =
+		    acpi_ns_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
+					   ACPI_UINT32_MAX,
+					   ACPI_NS_WALK_NO_UNLOCK,
+					   acpi_ev_match_prw_and_gpe, NULL,
+					   &walk_info, NULL);
+		if (ACPI_FAILURE(status)) {
+			ACPI_EXCEPTION((AE_INFO, status,
+					"While executing _PRW methods"));
+		}
+
+		acpi_ex_enter_interpreter();
+		new_wake_gpe_count = walk_info.count;
+	}
+
+	/*
+	 * 2) Find any _Lxx/_Exx GPE methods that have just been loaded.
+	 *
+	 * Any GPEs that correspond to new _Lxx/_Exx methods and are not
+	 * marked as CAN_WAKE are immediately enabled.
+	 *
+	 * Examine the namespace underneath each gpe_device within the
+	 * gpe_block lists.
+	 */
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return;
+	}
+
+	walk_info.count = 0;
+	walk_info.enable_this_gpe = TRUE;
+
+	/* Walk the interrupt level descriptor list */
+
+	gpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;
+	while (gpe_xrupt_info) {
+
+		/* Walk all Gpe Blocks attached to this interrupt level */
+
+		gpe_block = gpe_xrupt_info->gpe_block_list_head;
+		while (gpe_block) {
+			walk_info.gpe_block = gpe_block;
+			walk_info.gpe_device = gpe_block->node;
+
+			status = acpi_ns_walk_namespace(ACPI_TYPE_METHOD,
+							walk_info.gpe_device,
+							ACPI_UINT32_MAX,
+							ACPI_NS_WALK_NO_UNLOCK,
+							acpi_ev_match_gpe_method,
+							NULL, &walk_info, NULL);
+			if (ACPI_FAILURE(status)) {
+				ACPI_EXCEPTION((AE_INFO, status,
+						"While decoding _Lxx/_Exx methods"));
+			}
+
+			gpe_block = gpe_block->next;
+		}
+
+		gpe_xrupt_info = gpe_xrupt_info->next;
+	}
+
+	if (walk_info.count || new_wake_gpe_count) {
+		ACPI_INFO((AE_INFO,
+			   "Enabled %u new runtime GPEs, added %u new wakeup GPEs",
+			   walk_info.count, new_wake_gpe_count));
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	return;
+}
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ev_initialize_gpe_block
@@ -965,7 +1197,7 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 {
 	acpi_status status;
 	struct acpi_gpe_event_info *gpe_event_info;
-	struct acpi_gpe_walk_info gpe_info;
+	struct acpi_gpe_walk_info walk_info;
 	u32 wake_gpe_count;
 	u32 gpe_enabled_count;
 	u32 gpe_index;
@@ -992,13 +1224,15 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 		 * definition a wake GPE and will not be enabled while the machine
 		 * is running.
 		 */
-		gpe_info.gpe_block = gpe_block;
-		gpe_info.gpe_device = gpe_device;
+		walk_info.gpe_block = gpe_block;
+		walk_info.gpe_device = gpe_device;
+		walk_info.execute_by_owner_id = FALSE;
 
-		status = acpi_ns_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
+		status =
+		    acpi_ns_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
 					   ACPI_UINT32_MAX, ACPI_NS_WALK_UNLOCK,
 					   acpi_ev_match_prw_and_gpe, NULL,
-					   &gpe_info, NULL);
+					   &walk_info, NULL);
 		if (ACPI_FAILURE(status)) {
 			ACPI_EXCEPTION((AE_INFO, status,
 					"While executing _PRW methods"));
@@ -1054,9 +1288,11 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 		}
 	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INIT,
-			  "Found %u Wake, Enabled %u Runtime GPEs in this block\n",
-			  wake_gpe_count, gpe_enabled_count));
+	if (gpe_enabled_count || wake_gpe_count) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INIT,
+				  "Enabled %u Runtime GPEs, added %u Wake GPEs in this block\n",
+				  gpe_enabled_count, wake_gpe_count));
+	}
 
 	return_ACPI_STATUS(AE_OK);
 }

commit 0f849d2cc6863c7874889ea60a871fb71399dd3f
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Tue Apr 6 14:52:37 2010 +0800

    ACPICA: Minimize the differences between linux GPE code and ACPICA code base
    
    We have ported Rafael's major GPE changes
    (ACPI: Use GPE reference counting to support shared GPEs) into ACPICA code base.
    But the port and Rafael's original patch have some differences, so we made
    below patch to make linux GPE code consistent with ACPICA code base.
    
    Most changes are about comments and coding styles.
    Other noticeable changes are based on:
    
    Rafael: Reduce code duplication related to GPE lookup
    https://patchwork.kernel.org/patch/86237/
    
    Rafael: Always use the same lock for GPE locking
    https://patchwork.kernel.org/patch/90471/
    
    A new field gpe_count in struct acpi_gpe_block_info to record the number
    of individual GPEs in block.
    
    Rename acpi_ev_save_method_info to acpi_ev_match_gpe_method.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Robert Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index fa47e3522abe..85ded1f2540d 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -51,7 +51,7 @@ ACPI_MODULE_NAME("evgpeblk")
 
 /* Local prototypes */
 static acpi_status
-acpi_ev_save_method_info(acpi_handle obj_handle,
+acpi_ev_match_gpe_method(acpi_handle obj_handle,
 			 u32 level, void *obj_desc, void **return_value);
 
 static acpi_status
@@ -104,9 +104,7 @@ u8 acpi_ev_valid_gpe_event(struct acpi_gpe_event_info *gpe_event_info)
 
 		while (gpe_block) {
 			if ((&gpe_block->event_info[0] <= gpe_event_info) &&
-			    (&gpe_block->event_info[((acpi_size)
-						     gpe_block->
-						     register_count) * 8] >
+			    (&gpe_block->event_info[gpe_block->gpe_count] >
 			     gpe_event_info)) {
 				return (TRUE);
 			}
@@ -229,7 +227,7 @@ acpi_ev_delete_gpe_handlers(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_ev_save_method_info
+ * FUNCTION:    acpi_ev_match_gpe_method
  *
  * PARAMETERS:  Callback from walk_namespace
  *
@@ -241,8 +239,7 @@ acpi_ev_delete_gpe_handlers(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
  *              information for quick lookup during GPE dispatch
  *
  *              The name of each GPE control method is of the form:
- *              "_Lxx" or "_Exx"
- *              Where:
+ *              "_Lxx" or "_Exx", where:
  *                  L      - means that the GPE is level triggered
  *                  E      - means that the GPE is edge triggered
  *                  xx     - is the GPE number [in HEX]
@@ -250,9 +247,11 @@ acpi_ev_delete_gpe_handlers(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
  ******************************************************************************/
 
 static acpi_status
-acpi_ev_save_method_info(acpi_handle obj_handle,
+acpi_ev_match_gpe_method(acpi_handle obj_handle,
 			 u32 level, void *obj_desc, void **return_value)
 {
+	struct acpi_namespace_node *method_node =
+	    ACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);
 	struct acpi_gpe_block_info *gpe_block = (void *)obj_desc;
 	struct acpi_gpe_event_info *gpe_event_info;
 	u32 gpe_number;
@@ -262,21 +261,25 @@ acpi_ev_save_method_info(acpi_handle obj_handle,
 	ACPI_FUNCTION_TRACE(ev_save_method_info);
 
 	/*
-	 * _Lxx and _Exx GPE method support
+	 * Match and decode the _Lxx and _Exx GPE method names
 	 *
-	 * 1) Extract the name from the object and convert to a string
+	 * 1) Extract the method name and null terminate it
 	 */
-	ACPI_MOVE_32_TO_32(name,
-			   &((struct acpi_namespace_node *)obj_handle)->name.
-			   integer);
+	ACPI_MOVE_32_TO_32(name, &method_node->name.integer);
 	name[ACPI_NAME_SIZE] = 0;
 
+	/* 2) Name must begin with an underscore */
+
+	if (name[0] != '_') {
+		return_ACPI_STATUS(AE_OK);	/* Ignore this method */
+	}
+
 	/*
-	 * 2) Edge/Level determination is based on the 2nd character
+	 * 3) Edge/Level determination is based on the 2nd character
 	 *    of the method name
 	 *
-	 * NOTE: Default GPE type is RUNTIME. May be changed later to WAKE
-	 * if a _PRW object is found that points to this GPE.
+	 * NOTE: Default GPE type is RUNTIME only. Later, if a _PRW object is
+	 * found that points to this GPE, the ACPI_GPE_CAN_WAKE flag is set.
 	 */
 	switch (name[1]) {
 	case 'L':
@@ -288,7 +291,7 @@ acpi_ev_save_method_info(acpi_handle obj_handle,
 		break;
 
 	default:
-		/* Unknown method type, just ignore it! */
+		/* Unknown method type, just ignore it */
 
 		ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
 				  "Ignoring unknown GPE method type: %s "
@@ -296,7 +299,7 @@ acpi_ev_save_method_info(acpi_handle obj_handle,
 		return_ACPI_STATUS(AE_OK);
 	}
 
-	/* Convert the last two characters of the name to the GPE Number */
+	/* 4) The last two characters of the name are the hex GPE Number */
 
 	gpe_number = ACPI_STRTOUL(&name[2], NULL, 16);
 	if (gpe_number == ACPI_UINT32_MAX) {
@@ -311,28 +314,22 @@ acpi_ev_save_method_info(acpi_handle obj_handle,
 
 	/* Ensure that we have a valid GPE number for this GPE block */
 
-	if ((gpe_number < gpe_block->block_base_number) ||
-	    (gpe_number >= (gpe_block->block_base_number +
-			    (gpe_block->register_count * 8)))) {
+	gpe_event_info = acpi_ev_low_get_gpe_info(gpe_number, gpe_block);
+	if (!gpe_event_info) {
 		/*
-		 * Not valid for this GPE block, just ignore it. However, it may be
-		 * valid for a different GPE block, since GPE0 and GPE1 methods both
-		 * appear under \_GPE.
+		 * This gpe_number is not valid for this GPE block, just ignore it.
+		 * However, it may be valid for a different GPE block, since GPE0
+		 * and GPE1 methods both appear under \_GPE.
 		 */
 		return_ACPI_STATUS(AE_OK);
 	}
 
 	/*
-	 * Now we can add this information to the gpe_event_info block for use
-	 * during dispatch of this GPE.
+	 * Add the GPE information from above to the gpe_event_info block for
+	 * use during dispatch of this GPE.
 	 */
-	gpe_event_info =
-	    &gpe_block->event_info[gpe_number - gpe_block->block_base_number];
-
-	gpe_event_info->flags = (u8) (type | ACPI_GPE_DISPATCH_METHOD);
-
-	gpe_event_info->dispatch.method_node =
-	    (struct acpi_namespace_node *)obj_handle;
+	gpe_event_info->flags = (u8)(type | ACPI_GPE_DISPATCH_METHOD);
+	gpe_event_info->dispatch.method_node = method_node;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
 			  "Registered GPE method %s as GPE number 0x%.2X\n",
@@ -351,7 +348,7 @@ acpi_ev_save_method_info(acpi_handle obj_handle,
  *
  * DESCRIPTION: Called from acpi_walk_namespace. Expects each object to be a
  *              Device. Run the _PRW method. If present, extract the GPE
- *              number and mark the GPE as a WAKE GPE.
+ *              number and mark the GPE as a CAN_WAKE GPE.
  *
  ******************************************************************************/
 
@@ -377,7 +374,7 @@ acpi_ev_match_prw_and_gpe(acpi_handle obj_handle,
 					 ACPI_BTYPE_PACKAGE, &pkg_desc);
 	if (ACPI_FAILURE(status)) {
 
-		/* Ignore all errors from _PRW, we don't want to abort the subsystem */
+		/* Ignore all errors from _PRW, we don't want to abort the walk */
 
 		return_ACPI_STATUS(AE_OK);
 	}
@@ -439,13 +436,13 @@ acpi_ev_match_prw_and_gpe(acpi_handle obj_handle,
 	 *     2) The GPE index(number) is within the range of the Gpe Block
 	 *          associated with the GPE device.
 	 */
-	if ((gpe_device == target_gpe_device) &&
-	    (gpe_number >= gpe_block->block_base_number) &&
-	    (gpe_number < gpe_block->block_base_number +
-	     (gpe_block->register_count * 8))) {
-		gpe_event_info = &gpe_block->event_info[gpe_number -
-							gpe_block->
-							block_base_number];
+	if (gpe_device != target_gpe_device) {
+		goto cleanup;
+	}
+
+	gpe_event_info = acpi_ev_low_get_gpe_info(gpe_number, gpe_block);
+	if (gpe_event_info) {
+		/* This GPE can wake the system */
 
 		gpe_event_info->flags |= ACPI_GPE_CAN_WAKE;
 	}
@@ -705,8 +702,7 @@ acpi_status acpi_ev_delete_gpe_block(struct acpi_gpe_block_info *gpe_block)
 		acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
 	}
 
-	acpi_current_gpe_count -=
-	    gpe_block->register_count * ACPI_GPE_REGISTER_WIDTH;
+	acpi_current_gpe_count -= gpe_block->gpe_count;
 
 	/* Free the gpe_block */
 
@@ -760,9 +756,7 @@ acpi_ev_create_gpe_info_blocks(struct acpi_gpe_block_info *gpe_block)
 	 * Allocate the GPE event_info block. There are eight distinct GPEs
 	 * per register. Initialization to zeros is sufficient.
 	 */
-	gpe_event_info = ACPI_ALLOCATE_ZEROED(((acpi_size) gpe_block->
-					       register_count *
-					       ACPI_GPE_REGISTER_WIDTH) *
+	gpe_event_info = ACPI_ALLOCATE_ZEROED((acpi_size) gpe_block->gpe_count *
 					      sizeof(struct
 						     acpi_gpe_event_info));
 	if (!gpe_event_info) {
@@ -897,6 +891,7 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 	/* Initialize the new GPE block */
 
 	gpe_block->node = gpe_device;
+	gpe_block->gpe_count = (u16)(register_count * ACPI_GPE_REGISTER_WIDTH);
 	gpe_block->register_count = register_count;
 	gpe_block->block_base_number = gpe_block_base_number;
 
@@ -925,7 +920,7 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 
 	status = acpi_ns_walk_namespace(ACPI_TYPE_METHOD, gpe_device,
 					ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,
-					acpi_ev_save_method_info, NULL,
+					acpi_ev_match_gpe_method, NULL,
 					gpe_block, NULL);
 
 	/* Return the new block */
@@ -938,14 +933,13 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 			  "GPE %02X to %02X [%4.4s] %u regs on int 0x%X\n",
 			  (u32) gpe_block->block_base_number,
 			  (u32) (gpe_block->block_base_number +
-				 ((gpe_block->register_count *
-				   ACPI_GPE_REGISTER_WIDTH) - 1)),
+				(gpe_block->gpe_count - 1)),
 			  gpe_device->name.ascii, gpe_block->register_count,
 			  interrupt_number));
 
 	/* Update global count of currently available GPEs */
 
-	acpi_current_gpe_count += register_count * ACPI_GPE_REGISTER_WIDTH;
+	acpi_current_gpe_count += gpe_block->gpe_count;
 	return_ACPI_STATUS(AE_OK);
 }
 
@@ -969,10 +963,13 @@ acpi_status
 acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 			     struct acpi_gpe_block_info *gpe_block)
 {
+	acpi_status status;
 	struct acpi_gpe_event_info *gpe_event_info;
 	struct acpi_gpe_walk_info gpe_info;
 	u32 wake_gpe_count;
 	u32 gpe_enabled_count;
+	u32 gpe_index;
+	u32 gpe_number;
 	u32 i;
 	u32 j;
 
@@ -998,50 +995,62 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 		gpe_info.gpe_block = gpe_block;
 		gpe_info.gpe_device = gpe_device;
 
-		acpi_ns_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
+		status = acpi_ns_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
 					   ACPI_UINT32_MAX, ACPI_NS_WALK_UNLOCK,
 					   acpi_ev_match_prw_and_gpe, NULL,
 					   &gpe_info, NULL);
+		if (ACPI_FAILURE(status)) {
+			ACPI_EXCEPTION((AE_INFO, status,
+					"While executing _PRW methods"));
+		}
 	}
 
 	/*
-	 * Enable all GPEs that have a corresponding method and aren't
+	 * Enable all GPEs that have a corresponding method and are not
 	 * capable of generating wakeups. Any other GPEs within this block
-	 * must be enabled via the acpi_enable_gpe() interface.
+	 * must be enabled via the acpi_enable_gpe interface.
 	 */
 	wake_gpe_count = 0;
 	gpe_enabled_count = 0;
-	if (gpe_device == acpi_gbl_fadt_gpe_device)
+
+	if (gpe_device == acpi_gbl_fadt_gpe_device) {
 		gpe_device = NULL;
+	}
 
 	for (i = 0; i < gpe_block->register_count; i++) {
 		for (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {
-			acpi_status status;
-			acpi_size gpe_index;
-			int gpe_number;
 
 			/* Get the info block for this particular GPE */
-			gpe_index = (acpi_size)i * ACPI_GPE_REGISTER_WIDTH + j;
+
+			gpe_index = (i * ACPI_GPE_REGISTER_WIDTH) + j;
 			gpe_event_info = &gpe_block->event_info[gpe_index];
 
 			if (gpe_event_info->flags & ACPI_GPE_CAN_WAKE) {
 				wake_gpe_count++;
-				if (acpi_gbl_leave_wake_gpes_disabled)
+				if (acpi_gbl_leave_wake_gpes_disabled) {
 					continue;
+				}
 			}
 
-			if (!(gpe_event_info->flags & ACPI_GPE_DISPATCH_METHOD))
+			/* Ignore GPEs that have no corresponding _Lxx/_Exx method */
+
+			if (!(gpe_event_info->flags & ACPI_GPE_DISPATCH_METHOD)) {
 				continue;
+			}
+
+			/* Enable this GPE */
 
 			gpe_number = gpe_index + gpe_block->block_base_number;
 			status = acpi_enable_gpe(gpe_device, gpe_number,
-						ACPI_GPE_TYPE_RUNTIME);
-			if (ACPI_FAILURE(status))
-				ACPI_ERROR((AE_INFO,
-						"Failed to enable GPE %02X\n",
+						 ACPI_GPE_TYPE_RUNTIME);
+			if (ACPI_FAILURE(status)) {
+				ACPI_EXCEPTION((AE_INFO, status,
+						"Could not enable GPE 0x%02X",
 						gpe_number));
-			else
-				gpe_enabled_count++;
+				continue;
+			}
+
+			gpe_enabled_count++;
 		}
 	}
 

commit f6a22b0bc417042e83117f52ab1a03696af185ab
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Mar 5 17:56:40 2010 +0800

    ACPICA: Standardize integer output for ACPICA warnings/errors
    
    Always use 0x prefix for hex output, use %u for integer output
    (all integers are unsigned.)
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index fef721917eaf..fa47e3522abe 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -1139,8 +1139,8 @@ acpi_status acpi_ev_gpe_initialize(void)
 		if ((register_count0) &&
 		    (gpe_number_max >= acpi_gbl_FADT.gpe1_base)) {
 			ACPI_ERROR((AE_INFO,
-				    "GPE0 block (GPE 0 to %d) overlaps the GPE1 block "
-				    "(GPE %d to %d) - Ignoring GPE1",
+				    "GPE0 block (GPE 0 to %u) overlaps the GPE1 block "
+				    "(GPE %u to %u) - Ignoring GPE1",
 				    gpe_number_max, acpi_gbl_FADT.gpe1_base,
 				    acpi_gbl_FADT.gpe1_base +
 				    ((register_count1 *

commit bc535154137601400ffe44c2a7be047ca041fe06
Merge: d03ab7ff335b 439913fffd39
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 1 10:36:22 2010 -0800

    Merge branch 'acpica' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'acpica' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6:
      ACPI: replace acpi_integer by u64
      ACPICA: Update version to 20100121.
      ACPICA: Remove unused uint32_struct type
      ACPICA: Disassembler: Remove obsolete "Integer64" field in parse object
      ACPICA: Remove obsolete ACPI_INTEGER (acpi_integer) type
      ACPICA: Predefined name repair: fix NULL package elements
      ACPICA: AcpiGetDevices: Eliminate unnecessary _STA calls
      ACPICA: Update all ACPICA copyrights and signons to 2010
      ACPICA: Update for new gcc-4 warning options

commit 9630bdd9b15d2f489c646d8bc04b60e53eb5ec78
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 17 23:41:07 2010 +0100

    ACPI: Use GPE reference counting to support shared GPEs
    
    ACPI GPEs may map to multiple devices.  The current GPE interface
    only provides a mechanism for enabling and disabling GPEs, making
    it difficult to change the state of GPEs at runtime without extensive
    cooperation between devices.
    
    Add an API to allow devices to indicate whether or not they want
    their device's GPE to be enabled for both runtime and wakeup events.
    
    Remove the old GPE type handling entirely, which gets rid of various
    quirks, like the implicit disabling with GPE type setting. This
    requires a small amount of rework in order to ensure that non-wake
    GPEs are enabled by default to preserve existing behaviour.
    
    Based on patches from Matthew Garrett <mjg@redhat.com>.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 247920900187..3d4c4aca11cd 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -258,7 +258,6 @@ acpi_ev_save_method_info(acpi_handle obj_handle,
 	u32 gpe_number;
 	char name[ACPI_NAME_SIZE + 1];
 	u8 type;
-	acpi_status status;
 
 	ACPI_FUNCTION_TRACE(ev_save_method_info);
 
@@ -325,26 +324,20 @@ acpi_ev_save_method_info(acpi_handle obj_handle,
 
 	/*
 	 * Now we can add this information to the gpe_event_info block for use
-	 * during dispatch of this GPE. Default type is RUNTIME, although this may
-	 * change when the _PRW methods are executed later.
+	 * during dispatch of this GPE.
 	 */
 	gpe_event_info =
 	    &gpe_block->event_info[gpe_number - gpe_block->block_base_number];
 
-	gpe_event_info->flags = (u8)
-	    (type | ACPI_GPE_DISPATCH_METHOD | ACPI_GPE_TYPE_RUNTIME);
+	gpe_event_info->flags = (u8) (type | ACPI_GPE_DISPATCH_METHOD);
 
 	gpe_event_info->dispatch.method_node =
 	    (struct acpi_namespace_node *)obj_handle;
 
-	/* Update enable mask, but don't enable the HW GPE as of yet */
-
-	status = acpi_ev_enable_gpe(gpe_event_info, FALSE);
-
 	ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
 			  "Registered GPE method %s as GPE number 0x%.2X\n",
 			  name, gpe_number));
-	return_ACPI_STATUS(status);
+	return_ACPI_STATUS(AE_OK);
 }
 
 /*******************************************************************************
@@ -454,20 +447,7 @@ acpi_ev_match_prw_and_gpe(acpi_handle obj_handle,
 							gpe_block->
 							block_base_number];
 
-		/* Mark GPE for WAKE-ONLY but WAKE_DISABLED */
-
-		gpe_event_info->flags &=
-		    ~(ACPI_GPE_WAKE_ENABLED | ACPI_GPE_RUN_ENABLED);
-
-		status =
-		    acpi_ev_set_gpe_type(gpe_event_info, ACPI_GPE_TYPE_WAKE);
-		if (ACPI_FAILURE(status)) {
-			goto cleanup;
-		}
-
-		status =
-		    acpi_ev_update_gpe_enable_masks(gpe_event_info,
-						    ACPI_GPE_DISABLE);
+		gpe_event_info->flags |= ACPI_GPE_CAN_WAKE;
 	}
 
       cleanup:
@@ -989,7 +969,6 @@ acpi_status
 acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 			     struct acpi_gpe_block_info *gpe_block)
 {
-	acpi_status status;
 	struct acpi_gpe_event_info *gpe_event_info;
 	struct acpi_gpe_walk_info gpe_info;
 	u32 wake_gpe_count;
@@ -1019,42 +998,50 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 		gpe_info.gpe_block = gpe_block;
 		gpe_info.gpe_device = gpe_device;
 
-		status =
-		    acpi_ns_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
+		acpi_ns_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
 					   ACPI_UINT32_MAX, ACPI_NS_WALK_UNLOCK,
 					   acpi_ev_match_prw_and_gpe, NULL,
 					   &gpe_info, NULL);
 	}
 
 	/*
-	 * Enable all GPEs in this block that have these attributes:
-	 * 1) are "runtime" or "run/wake" GPEs, and
-	 * 2) have a corresponding _Lxx or _Exx method
-	 *
-	 * Any other GPEs within this block must be enabled via the
-	 * acpi_enable_gpe() external interface.
+	 * Enable all GPEs that have a corresponding method and aren't
+	 * capable of generating wakeups. Any other GPEs within this block
+	 * must be enabled via the acpi_enable_gpe() interface.
 	 */
 	wake_gpe_count = 0;
 	gpe_enabled_count = 0;
+	if (gpe_device == acpi_gbl_fadt_gpe_device)
+		gpe_device = NULL;
 
 	for (i = 0; i < gpe_block->register_count; i++) {
-		for (j = 0; j < 8; j++) {
+		for (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {
+			acpi_status status;
+			acpi_size gpe_index;
+			int gpe_number;
 
 			/* Get the info block for this particular GPE */
+			gpe_index = (acpi_size)i * ACPI_GPE_REGISTER_WIDTH + j;
+			gpe_event_info = &gpe_block->event_info[gpe_index];
 
-			gpe_event_info = &gpe_block->event_info[((acpi_size) i *
-								 ACPI_GPE_REGISTER_WIDTH)
-								+ j];
-
-			if (((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
-			     ACPI_GPE_DISPATCH_METHOD) &&
-			    (gpe_event_info->flags & ACPI_GPE_TYPE_RUNTIME)) {
-				gpe_enabled_count++;
-			}
-
-			if (gpe_event_info->flags & ACPI_GPE_TYPE_WAKE) {
+			if (gpe_event_info->flags & ACPI_GPE_CAN_WAKE) {
 				wake_gpe_count++;
+				if (acpi_gbl_leave_wake_gpes_disabled)
+					continue;
 			}
+
+			if (!(gpe_event_info->flags & ACPI_GPE_DISPATCH_METHOD))
+				continue;
+
+			gpe_number = gpe_index + gpe_block->block_base_number;
+			status = acpi_enable_gpe(gpe_device, gpe_number,
+						ACPI_GPE_TYPE_RUNTIME);
+			if (ACPI_FAILURE(status))
+				ACPI_ERROR((AE_INFO,
+						"Failed to enable GPE %02X\n",
+						gpe_number));
+			else
+				gpe_enabled_count++;
 		}
 	}
 
@@ -1062,15 +1049,7 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 			  "Found %u Wake, Enabled %u Runtime GPEs in this block\n",
 			  wake_gpe_count, gpe_enabled_count));
 
-	/* Enable all valid runtime GPEs found above */
-
-	status = acpi_hw_enable_runtime_gpe_block(NULL, gpe_block, NULL);
-	if (ACPI_FAILURE(status)) {
-		ACPI_ERROR((AE_INFO, "Could not enable GPEs in GpeBlock %p",
-			    gpe_block));
-	}
-
-	return_ACPI_STATUS(status);
+	return_ACPI_STATUS(AE_OK);
 }
 
 /*******************************************************************************

commit a8357b0c95484b46944728712f8810d3b37bf588
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Jan 22 19:07:36 2010 +0800

    ACPICA: Update all ACPICA copyrights and signons to 2010
    
    Add 2010 copyright to all module headers and signons, including
    the Linux header. This affects virtually every file in the ACPICA
    core subsystem, iASL compiler, and all utilities.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 247920900187..77670e04812d 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2008, Intel Corp.
+ * Copyright (C) 2000 - 2010, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 2263576cfc6e8f6ab038126c3254404b9fcb1c33
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Fri Nov 13 10:06:08 2009 +0800

    ACPICA: Add post-order callback to acpi_walk_namespace
    
    The existing interface only has a pre-order callback. This change
    adds an additional parameter for a post-order callback which will
    be more useful for bus scans. ACPICA BZ 779.
    
    Also update the external calls to acpi_walk_namespace.
    
    http://www.acpica.org/bugzilla/show_bug.cgi?id=779
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index a60aaa7635f3..247920900187 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -945,8 +945,8 @@ acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
 
 	status = acpi_ns_walk_namespace(ACPI_TYPE_METHOD, gpe_device,
 					ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,
-					acpi_ev_save_method_info, gpe_block,
-					NULL);
+					acpi_ev_save_method_info, NULL,
+					gpe_block, NULL);
 
 	/* Return the new block */
 
@@ -1022,8 +1022,8 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 		status =
 		    acpi_ns_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
 					   ACPI_UINT32_MAX, ACPI_NS_WALK_UNLOCK,
-					   acpi_ev_match_prw_and_gpe, &gpe_info,
-					   NULL);
+					   acpi_ev_match_prw_and_gpe, NULL,
+					   &gpe_info, NULL);
 	}
 
 	/*

commit c6b5774caafa4c12b6019366e2fdaaff117e95a4
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Jun 24 09:44:06 2009 +0800

    ACPICA: Add 64-bit support to acpi_read and acpi_write
    
    Needed by drivers for new ACPi tables.  Internal versions of
    these functions still use 32-bit max transfers, in order to
    minimize disruption and stack use for the standard ACPI registers
    (FADT-based).
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 7b3463639422..a60aaa7635f3 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -843,14 +843,14 @@ acpi_ev_create_gpe_info_blocks(struct acpi_gpe_block_info *gpe_block)
 
 		/* Disable all GPEs within this register */
 
-		status = acpi_write(0x00, &this_register->enable_address);
+		status = acpi_hw_write(0x00, &this_register->enable_address);
 		if (ACPI_FAILURE(status)) {
 			goto error_exit;
 		}
 
 		/* Clear any pending GPE events within this register */
 
-		status = acpi_write(0xFF, &this_register->status_address);
+		status = acpi_hw_write(0xFF, &this_register->status_address);
 		if (ACPI_FAILURE(status)) {
 			goto error_exit;
 		}

commit d4913dc6d0c680aa106d1d80b5ad2a9325367afd
Author: Bob Moore <robert.moore@intel.com>
Date:   Fri Mar 6 10:05:18 2009 +0800

    ACPICA: Formatting update - no functional changes
    
    Split long lines, update comments.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index f7b3d2af9401..7b3463639422 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -104,9 +104,9 @@ u8 acpi_ev_valid_gpe_event(struct acpi_gpe_event_info *gpe_event_info)
 
 		while (gpe_block) {
 			if ((&gpe_block->event_info[0] <= gpe_event_info) &&
-			    (&gpe_block->
-			     event_info[((acpi_size) gpe_block->
-					 register_count) * 8] >
+			    (&gpe_block->event_info[((acpi_size)
+						     gpe_block->
+						     register_count) * 8] >
 			     gpe_event_info)) {
 				return (TRUE);
 			}
@@ -210,10 +210,9 @@ acpi_ev_delete_gpe_handlers(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 		/* Now look at the individual GPEs in this byte register */
 
 		for (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {
-			gpe_event_info =
-			    &gpe_block->
-			    event_info[((acpi_size) i *
-					ACPI_GPE_REGISTER_WIDTH) + j];
+			gpe_event_info = &gpe_block->event_info[((acpi_size) i *
+								 ACPI_GPE_REGISTER_WIDTH)
+								+ j];
 
 			if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
 			    ACPI_GPE_DISPATCH_HANDLER) {
@@ -293,8 +292,8 @@ acpi_ev_save_method_info(acpi_handle obj_handle,
 		/* Unknown method type, just ignore it! */
 
 		ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
-				  "Ignoring unknown GPE method type: %s (name not of form _Lxx or _Exx)",
-				  name));
+				  "Ignoring unknown GPE method type: %s "
+				  "(name not of form _Lxx or _Exx)", name));
 		return_ACPI_STATUS(AE_OK);
 	}
 
@@ -306,17 +305,16 @@ acpi_ev_save_method_info(acpi_handle obj_handle,
 		/* Conversion failed; invalid method, just ignore it */
 
 		ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
-				  "Could not extract GPE number from name: %s (name is not of form _Lxx or _Exx)",
-				  name));
+				  "Could not extract GPE number from name: %s "
+				  "(name is not of form _Lxx or _Exx)", name));
 		return_ACPI_STATUS(AE_OK);
 	}
 
 	/* Ensure that we have a valid GPE number for this GPE block */
 
 	if ((gpe_number < gpe_block->block_base_number) ||
-	    (gpe_number >=
-	     (gpe_block->block_base_number +
-	      (gpe_block->register_count * 8)))) {
+	    (gpe_number >= (gpe_block->block_base_number +
+			    (gpe_block->register_count * 8)))) {
 		/*
 		 * Not valid for this GPE block, just ignore it. However, it may be
 		 * valid for a different GPE block, since GPE0 and GPE1 methods both
@@ -423,9 +421,9 @@ acpi_ev_match_prw_and_gpe(acpi_handle obj_handle,
 
 		if ((obj_desc->package.count < 2) ||
 		    ((obj_desc->package.elements[0])->common.type !=
-		     ACPI_TYPE_LOCAL_REFERENCE)
-		    || ((obj_desc->package.elements[1])->common.type !=
-			ACPI_TYPE_INTEGER)) {
+		     ACPI_TYPE_LOCAL_REFERENCE) ||
+		    ((obj_desc->package.elements[1])->common.type !=
+		     ACPI_TYPE_INTEGER)) {
 			goto cleanup;
 		}
 
@@ -450,11 +448,11 @@ acpi_ev_match_prw_and_gpe(acpi_handle obj_handle,
 	 */
 	if ((gpe_device == target_gpe_device) &&
 	    (gpe_number >= gpe_block->block_base_number) &&
-	    (gpe_number <
-	     gpe_block->block_base_number + (gpe_block->register_count * 8))) {
-		gpe_event_info =
-		    &gpe_block->event_info[gpe_number -
-					   gpe_block->block_base_number];
+	    (gpe_number < gpe_block->block_base_number +
+	     (gpe_block->register_count * 8))) {
+		gpe_event_info = &gpe_block->event_info[gpe_number -
+							gpe_block->
+							block_base_number];
 
 		/* Mark GPE for WAKE-ONLY but WAKE_DISABLED */
 
@@ -1033,8 +1031,8 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 	 * 1) are "runtime" or "run/wake" GPEs, and
 	 * 2) have a corresponding _Lxx or _Exx method
 	 *
-	 * Any other GPEs within this block must be enabled via the acpi_enable_gpe()
-	 * external interface.
+	 * Any other GPEs within this block must be enabled via the
+	 * acpi_enable_gpe() external interface.
 	 */
 	wake_gpe_count = 0;
 	gpe_enabled_count = 0;
@@ -1044,14 +1042,13 @@ acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
 
 			/* Get the info block for this particular GPE */
 
-			gpe_event_info =
-			    &gpe_block->
-			    event_info[((acpi_size) i *
-					ACPI_GPE_REGISTER_WIDTH) + j];
+			gpe_event_info = &gpe_block->event_info[((acpi_size) i *
+								 ACPI_GPE_REGISTER_WIDTH)
+								+ j];
 
 			if (((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
-			     ACPI_GPE_DISPATCH_METHOD)
-			    && (gpe_event_info->flags & ACPI_GPE_TYPE_RUNTIME)) {
+			     ACPI_GPE_DISPATCH_METHOD) &&
+			    (gpe_event_info->flags & ACPI_GPE_TYPE_RUNTIME)) {
 				gpe_enabled_count++;
 			}
 
@@ -1105,8 +1102,8 @@ acpi_status acpi_ev_gpe_initialize(void)
 	/*
 	 * Initialize the GPE Block(s) defined in the FADT
 	 *
-	 * Why the GPE register block lengths are divided by 2:  From the ACPI Spec,
-	 * section "General-Purpose Event Registers", we have:
+	 * Why the GPE register block lengths are divided by 2:  From the ACPI
+	 * Spec, section "General-Purpose Event Registers", we have:
 	 *
 	 * "Each register block contains two registers of equal length
 	 *  GPEx_STS and GPEx_EN (where x is 0 or 1). The length of the
@@ -1163,7 +1160,8 @@ acpi_status acpi_ev_gpe_initialize(void)
 		if ((register_count0) &&
 		    (gpe_number_max >= acpi_gbl_FADT.gpe1_base)) {
 			ACPI_ERROR((AE_INFO,
-				    "GPE0 block (GPE 0 to %d) overlaps the GPE1 block (GPE %d to %d) - Ignoring GPE1",
+				    "GPE0 block (GPE 0 to %d) overlaps the GPE1 block "
+				    "(GPE %d to %d) - Ignoring GPE1",
 				    gpe_number_max, acpi_gbl_FADT.gpe1_base,
 				    acpi_gbl_FADT.gpe1_base +
 				    ((register_count1 *

commit 3371c19c294a4cb3649aa4e84606be8a1d999e61
Author: Bob Moore <robert.moore@intel.com>
Date:   Wed Feb 18 14:44:03 2009 +0800

    ACPICA: Remove ACPI_GET_OBJECT_TYPE macro
    
    Remove all instances of this obsolete macro, since it is now a
    simple reference to ->common.type. There were about 150 invocations
    of the macro across 41 files. ACPICA BZ 755.
    
    http://www.acpica.org/bugzilla/show_bug.cgi?id=755
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 484cc0565d5b..f7b3d2af9401 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -408,7 +408,7 @@ acpi_ev_match_prw_and_gpe(acpi_handle obj_handle,
 	 */
 	obj_desc = pkg_desc->package.elements[0];
 
-	if (ACPI_GET_OBJECT_TYPE(obj_desc) == ACPI_TYPE_INTEGER) {
+	if (obj_desc->common.type == ACPI_TYPE_INTEGER) {
 
 		/* Use FADT-defined GPE device (from definition of _PRW) */
 
@@ -417,14 +417,14 @@ acpi_ev_match_prw_and_gpe(acpi_handle obj_handle,
 		/* Integer is the GPE number in the FADT described GPE blocks */
 
 		gpe_number = (u32) obj_desc->integer.value;
-	} else if (ACPI_GET_OBJECT_TYPE(obj_desc) == ACPI_TYPE_PACKAGE) {
+	} else if (obj_desc->common.type == ACPI_TYPE_PACKAGE) {
 
 		/* Package contains a GPE reference and GPE number within a GPE block */
 
 		if ((obj_desc->package.count < 2) ||
-		    (ACPI_GET_OBJECT_TYPE(obj_desc->package.elements[0]) !=
+		    ((obj_desc->package.elements[0])->common.type !=
 		     ACPI_TYPE_LOCAL_REFERENCE)
-		    || (ACPI_GET_OBJECT_TYPE(obj_desc->package.elements[1]) !=
+		    || ((obj_desc->package.elements[1])->common.type !=
 			ACPI_TYPE_INTEGER)) {
 			goto cleanup;
 		}

commit e2f7a7772880458edff1b1cc5a988947229fac26
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 00:30:03 2009 -0500

    ACPICA: hide private headers
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index 2a8d1856038f..484cc0565d5b 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -42,9 +42,9 @@
  */
 
 #include <acpi/acpi.h>
-#include <acpi/accommon.h>
-#include <acpi/acevents.h>
-#include <acpi/acnamesp.h>
+#include "accommon.h"
+#include "acevents.h"
+#include "acnamesp.h"
 
 #define _COMPONENT          ACPI_EVENTS
 ACPI_MODULE_NAME("evgpeblk")

commit 95b482a8d31116f3f5c2a5089569393234d06385
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 00:13:17 2009 -0500

    ACPICA: create acpica/ directory
    
    also, delete sleep/ and delete ACPI_CFLAGS from Makefile
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
new file mode 100644
index 000000000000..2a8d1856038f
--- /dev/null
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -0,0 +1,1227 @@
+/******************************************************************************
+ *
+ * Module Name: evgpeblk - GPE block creation and initialization.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2008, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include <acpi/accommon.h>
+#include <acpi/acevents.h>
+#include <acpi/acnamesp.h>
+
+#define _COMPONENT          ACPI_EVENTS
+ACPI_MODULE_NAME("evgpeblk")
+
+/* Local prototypes */
+static acpi_status
+acpi_ev_save_method_info(acpi_handle obj_handle,
+			 u32 level, void *obj_desc, void **return_value);
+
+static acpi_status
+acpi_ev_match_prw_and_gpe(acpi_handle obj_handle,
+			  u32 level, void *info, void **return_value);
+
+static struct acpi_gpe_xrupt_info *acpi_ev_get_gpe_xrupt_block(u32
+							       interrupt_number);
+
+static acpi_status
+acpi_ev_delete_gpe_xrupt(struct acpi_gpe_xrupt_info *gpe_xrupt);
+
+static acpi_status
+acpi_ev_install_gpe_block(struct acpi_gpe_block_info *gpe_block,
+			  u32 interrupt_number);
+
+static acpi_status
+acpi_ev_create_gpe_info_blocks(struct acpi_gpe_block_info *gpe_block);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_valid_gpe_event
+ *
+ * PARAMETERS:  gpe_event_info              - Info for this GPE
+ *
+ * RETURN:      TRUE if the gpe_event is valid
+ *
+ * DESCRIPTION: Validate a GPE event. DO NOT CALL FROM INTERRUPT LEVEL.
+ *              Should be called only when the GPE lists are semaphore locked
+ *              and not subject to change.
+ *
+ ******************************************************************************/
+
+u8 acpi_ev_valid_gpe_event(struct acpi_gpe_event_info *gpe_event_info)
+{
+	struct acpi_gpe_xrupt_info *gpe_xrupt_block;
+	struct acpi_gpe_block_info *gpe_block;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* No need for spin lock since we are not changing any list elements */
+
+	/* Walk the GPE interrupt levels */
+
+	gpe_xrupt_block = acpi_gbl_gpe_xrupt_list_head;
+	while (gpe_xrupt_block) {
+		gpe_block = gpe_xrupt_block->gpe_block_list_head;
+
+		/* Walk the GPE blocks on this interrupt level */
+
+		while (gpe_block) {
+			if ((&gpe_block->event_info[0] <= gpe_event_info) &&
+			    (&gpe_block->
+			     event_info[((acpi_size) gpe_block->
+					 register_count) * 8] >
+			     gpe_event_info)) {
+				return (TRUE);
+			}
+
+			gpe_block = gpe_block->next;
+		}
+
+		gpe_xrupt_block = gpe_xrupt_block->next;
+	}
+
+	return (FALSE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_walk_gpe_list
+ *
+ * PARAMETERS:  gpe_walk_callback   - Routine called for each GPE block
+ *              Context             - Value passed to callback
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Walk the GPE lists.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_walk_gpe_list(acpi_gpe_callback gpe_walk_callback, void *context)
+{
+	struct acpi_gpe_block_info *gpe_block;
+	struct acpi_gpe_xrupt_info *gpe_xrupt_info;
+	acpi_status status = AE_OK;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(ev_walk_gpe_list);
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+
+	/* Walk the interrupt level descriptor list */
+
+	gpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;
+	while (gpe_xrupt_info) {
+
+		/* Walk all Gpe Blocks attached to this interrupt level */
+
+		gpe_block = gpe_xrupt_info->gpe_block_list_head;
+		while (gpe_block) {
+
+			/* One callback per GPE block */
+
+			status =
+			    gpe_walk_callback(gpe_xrupt_info, gpe_block,
+					      context);
+			if (ACPI_FAILURE(status)) {
+				if (status == AE_CTRL_END) {	/* Callback abort */
+					status = AE_OK;
+				}
+				goto unlock_and_exit;
+			}
+
+			gpe_block = gpe_block->next;
+		}
+
+		gpe_xrupt_info = gpe_xrupt_info->next;
+	}
+
+      unlock_and_exit:
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_delete_gpe_handlers
+ *
+ * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info
+ *              gpe_block           - Gpe Block info
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Delete all Handler objects found in the GPE data structs.
+ *              Used only prior to termination.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_delete_gpe_handlers(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
+			    struct acpi_gpe_block_info *gpe_block,
+			    void *context)
+{
+	struct acpi_gpe_event_info *gpe_event_info;
+	u32 i;
+	u32 j;
+
+	ACPI_FUNCTION_TRACE(ev_delete_gpe_handlers);
+
+	/* Examine each GPE Register within the block */
+
+	for (i = 0; i < gpe_block->register_count; i++) {
+
+		/* Now look at the individual GPEs in this byte register */
+
+		for (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {
+			gpe_event_info =
+			    &gpe_block->
+			    event_info[((acpi_size) i *
+					ACPI_GPE_REGISTER_WIDTH) + j];
+
+			if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
+			    ACPI_GPE_DISPATCH_HANDLER) {
+				ACPI_FREE(gpe_event_info->dispatch.handler);
+				gpe_event_info->dispatch.handler = NULL;
+				gpe_event_info->flags &=
+				    ~ACPI_GPE_DISPATCH_MASK;
+			}
+		}
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_save_method_info
+ *
+ * PARAMETERS:  Callback from walk_namespace
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Called from acpi_walk_namespace. Expects each object to be a
+ *              control method under the _GPE portion of the namespace.
+ *              Extract the name and GPE type from the object, saving this
+ *              information for quick lookup during GPE dispatch
+ *
+ *              The name of each GPE control method is of the form:
+ *              "_Lxx" or "_Exx"
+ *              Where:
+ *                  L      - means that the GPE is level triggered
+ *                  E      - means that the GPE is edge triggered
+ *                  xx     - is the GPE number [in HEX]
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ev_save_method_info(acpi_handle obj_handle,
+			 u32 level, void *obj_desc, void **return_value)
+{
+	struct acpi_gpe_block_info *gpe_block = (void *)obj_desc;
+	struct acpi_gpe_event_info *gpe_event_info;
+	u32 gpe_number;
+	char name[ACPI_NAME_SIZE + 1];
+	u8 type;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ev_save_method_info);
+
+	/*
+	 * _Lxx and _Exx GPE method support
+	 *
+	 * 1) Extract the name from the object and convert to a string
+	 */
+	ACPI_MOVE_32_TO_32(name,
+			   &((struct acpi_namespace_node *)obj_handle)->name.
+			   integer);
+	name[ACPI_NAME_SIZE] = 0;
+
+	/*
+	 * 2) Edge/Level determination is based on the 2nd character
+	 *    of the method name
+	 *
+	 * NOTE: Default GPE type is RUNTIME. May be changed later to WAKE
+	 * if a _PRW object is found that points to this GPE.
+	 */
+	switch (name[1]) {
+	case 'L':
+		type = ACPI_GPE_LEVEL_TRIGGERED;
+		break;
+
+	case 'E':
+		type = ACPI_GPE_EDGE_TRIGGERED;
+		break;
+
+	default:
+		/* Unknown method type, just ignore it! */
+
+		ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
+				  "Ignoring unknown GPE method type: %s (name not of form _Lxx or _Exx)",
+				  name));
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Convert the last two characters of the name to the GPE Number */
+
+	gpe_number = ACPI_STRTOUL(&name[2], NULL, 16);
+	if (gpe_number == ACPI_UINT32_MAX) {
+
+		/* Conversion failed; invalid method, just ignore it */
+
+		ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
+				  "Could not extract GPE number from name: %s (name is not of form _Lxx or _Exx)",
+				  name));
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Ensure that we have a valid GPE number for this GPE block */
+
+	if ((gpe_number < gpe_block->block_base_number) ||
+	    (gpe_number >=
+	     (gpe_block->block_base_number +
+	      (gpe_block->register_count * 8)))) {
+		/*
+		 * Not valid for this GPE block, just ignore it. However, it may be
+		 * valid for a different GPE block, since GPE0 and GPE1 methods both
+		 * appear under \_GPE.
+		 */
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * Now we can add this information to the gpe_event_info block for use
+	 * during dispatch of this GPE. Default type is RUNTIME, although this may
+	 * change when the _PRW methods are executed later.
+	 */
+	gpe_event_info =
+	    &gpe_block->event_info[gpe_number - gpe_block->block_base_number];
+
+	gpe_event_info->flags = (u8)
+	    (type | ACPI_GPE_DISPATCH_METHOD | ACPI_GPE_TYPE_RUNTIME);
+
+	gpe_event_info->dispatch.method_node =
+	    (struct acpi_namespace_node *)obj_handle;
+
+	/* Update enable mask, but don't enable the HW GPE as of yet */
+
+	status = acpi_ev_enable_gpe(gpe_event_info, FALSE);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
+			  "Registered GPE method %s as GPE number 0x%.2X\n",
+			  name, gpe_number));
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_match_prw_and_gpe
+ *
+ * PARAMETERS:  Callback from walk_namespace
+ *
+ * RETURN:      Status. NOTE: We ignore errors so that the _PRW walk is
+ *              not aborted on a single _PRW failure.
+ *
+ * DESCRIPTION: Called from acpi_walk_namespace. Expects each object to be a
+ *              Device. Run the _PRW method. If present, extract the GPE
+ *              number and mark the GPE as a WAKE GPE.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ev_match_prw_and_gpe(acpi_handle obj_handle,
+			  u32 level, void *info, void **return_value)
+{
+	struct acpi_gpe_walk_info *gpe_info = (void *)info;
+	struct acpi_namespace_node *gpe_device;
+	struct acpi_gpe_block_info *gpe_block;
+	struct acpi_namespace_node *target_gpe_device;
+	struct acpi_gpe_event_info *gpe_event_info;
+	union acpi_operand_object *pkg_desc;
+	union acpi_operand_object *obj_desc;
+	u32 gpe_number;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ev_match_prw_and_gpe);
+
+	/* Check for a _PRW method under this device */
+
+	status = acpi_ut_evaluate_object(obj_handle, METHOD_NAME__PRW,
+					 ACPI_BTYPE_PACKAGE, &pkg_desc);
+	if (ACPI_FAILURE(status)) {
+
+		/* Ignore all errors from _PRW, we don't want to abort the subsystem */
+
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* The returned _PRW package must have at least two elements */
+
+	if (pkg_desc->package.count < 2) {
+		goto cleanup;
+	}
+
+	/* Extract pointers from the input context */
+
+	gpe_device = gpe_info->gpe_device;
+	gpe_block = gpe_info->gpe_block;
+
+	/*
+	 * The _PRW object must return a package, we are only interested in the
+	 * first element
+	 */
+	obj_desc = pkg_desc->package.elements[0];
+
+	if (ACPI_GET_OBJECT_TYPE(obj_desc) == ACPI_TYPE_INTEGER) {
+
+		/* Use FADT-defined GPE device (from definition of _PRW) */
+
+		target_gpe_device = acpi_gbl_fadt_gpe_device;
+
+		/* Integer is the GPE number in the FADT described GPE blocks */
+
+		gpe_number = (u32) obj_desc->integer.value;
+	} else if (ACPI_GET_OBJECT_TYPE(obj_desc) == ACPI_TYPE_PACKAGE) {
+
+		/* Package contains a GPE reference and GPE number within a GPE block */
+
+		if ((obj_desc->package.count < 2) ||
+		    (ACPI_GET_OBJECT_TYPE(obj_desc->package.elements[0]) !=
+		     ACPI_TYPE_LOCAL_REFERENCE)
+		    || (ACPI_GET_OBJECT_TYPE(obj_desc->package.elements[1]) !=
+			ACPI_TYPE_INTEGER)) {
+			goto cleanup;
+		}
+
+		/* Get GPE block reference and decode */
+
+		target_gpe_device =
+		    obj_desc->package.elements[0]->reference.node;
+		gpe_number = (u32) obj_desc->package.elements[1]->integer.value;
+	} else {
+		/* Unknown type, just ignore it */
+
+		goto cleanup;
+	}
+
+	/*
+	 * Is this GPE within this block?
+	 *
+	 * TRUE if and only if these conditions are true:
+	 *     1) The GPE devices match.
+	 *     2) The GPE index(number) is within the range of the Gpe Block
+	 *          associated with the GPE device.
+	 */
+	if ((gpe_device == target_gpe_device) &&
+	    (gpe_number >= gpe_block->block_base_number) &&
+	    (gpe_number <
+	     gpe_block->block_base_number + (gpe_block->register_count * 8))) {
+		gpe_event_info =
+		    &gpe_block->event_info[gpe_number -
+					   gpe_block->block_base_number];
+
+		/* Mark GPE for WAKE-ONLY but WAKE_DISABLED */
+
+		gpe_event_info->flags &=
+		    ~(ACPI_GPE_WAKE_ENABLED | ACPI_GPE_RUN_ENABLED);
+
+		status =
+		    acpi_ev_set_gpe_type(gpe_event_info, ACPI_GPE_TYPE_WAKE);
+		if (ACPI_FAILURE(status)) {
+			goto cleanup;
+		}
+
+		status =
+		    acpi_ev_update_gpe_enable_masks(gpe_event_info,
+						    ACPI_GPE_DISABLE);
+	}
+
+      cleanup:
+	acpi_ut_remove_reference(pkg_desc);
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_get_gpe_xrupt_block
+ *
+ * PARAMETERS:  interrupt_number     - Interrupt for a GPE block
+ *
+ * RETURN:      A GPE interrupt block
+ *
+ * DESCRIPTION: Get or Create a GPE interrupt block. There is one interrupt
+ *              block per unique interrupt level used for GPEs. Should be
+ *              called only when the GPE lists are semaphore locked and not
+ *              subject to change.
+ *
+ ******************************************************************************/
+
+static struct acpi_gpe_xrupt_info *acpi_ev_get_gpe_xrupt_block(u32
+							       interrupt_number)
+{
+	struct acpi_gpe_xrupt_info *next_gpe_xrupt;
+	struct acpi_gpe_xrupt_info *gpe_xrupt;
+	acpi_status status;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(ev_get_gpe_xrupt_block);
+
+	/* No need for lock since we are not changing any list elements here */
+
+	next_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;
+	while (next_gpe_xrupt) {
+		if (next_gpe_xrupt->interrupt_number == interrupt_number) {
+			return_PTR(next_gpe_xrupt);
+		}
+
+		next_gpe_xrupt = next_gpe_xrupt->next;
+	}
+
+	/* Not found, must allocate a new xrupt descriptor */
+
+	gpe_xrupt = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_gpe_xrupt_info));
+	if (!gpe_xrupt) {
+		return_PTR(NULL);
+	}
+
+	gpe_xrupt->interrupt_number = interrupt_number;
+
+	/* Install new interrupt descriptor with spin lock */
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+	if (acpi_gbl_gpe_xrupt_list_head) {
+		next_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;
+		while (next_gpe_xrupt->next) {
+			next_gpe_xrupt = next_gpe_xrupt->next;
+		}
+
+		next_gpe_xrupt->next = gpe_xrupt;
+		gpe_xrupt->previous = next_gpe_xrupt;
+	} else {
+		acpi_gbl_gpe_xrupt_list_head = gpe_xrupt;
+	}
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+
+	/* Install new interrupt handler if not SCI_INT */
+
+	if (interrupt_number != acpi_gbl_FADT.sci_interrupt) {
+		status = acpi_os_install_interrupt_handler(interrupt_number,
+							   acpi_ev_gpe_xrupt_handler,
+							   gpe_xrupt);
+		if (ACPI_FAILURE(status)) {
+			ACPI_ERROR((AE_INFO,
+				    "Could not install GPE interrupt handler at level 0x%X",
+				    interrupt_number));
+			return_PTR(NULL);
+		}
+	}
+
+	return_PTR(gpe_xrupt);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_delete_gpe_xrupt
+ *
+ * PARAMETERS:  gpe_xrupt       - A GPE interrupt info block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove and free a gpe_xrupt block. Remove an associated
+ *              interrupt handler if not the SCI interrupt.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ev_delete_gpe_xrupt(struct acpi_gpe_xrupt_info *gpe_xrupt)
+{
+	acpi_status status;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(ev_delete_gpe_xrupt);
+
+	/* We never want to remove the SCI interrupt handler */
+
+	if (gpe_xrupt->interrupt_number == acpi_gbl_FADT.sci_interrupt) {
+		gpe_xrupt->gpe_block_list_head = NULL;
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Disable this interrupt */
+
+	status =
+	    acpi_os_remove_interrupt_handler(gpe_xrupt->interrupt_number,
+					     acpi_ev_gpe_xrupt_handler);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Unlink the interrupt block with lock */
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+	if (gpe_xrupt->previous) {
+		gpe_xrupt->previous->next = gpe_xrupt->next;
+	} else {
+		/* No previous, update list head */
+
+		acpi_gbl_gpe_xrupt_list_head = gpe_xrupt->next;
+	}
+
+	if (gpe_xrupt->next) {
+		gpe_xrupt->next->previous = gpe_xrupt->previous;
+	}
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+
+	/* Free the block */
+
+	ACPI_FREE(gpe_xrupt);
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_install_gpe_block
+ *
+ * PARAMETERS:  gpe_block               - New GPE block
+ *              interrupt_number        - Xrupt to be associated with this
+ *                                        GPE block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install new GPE block with mutex support
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ev_install_gpe_block(struct acpi_gpe_block_info *gpe_block,
+			  u32 interrupt_number)
+{
+	struct acpi_gpe_block_info *next_gpe_block;
+	struct acpi_gpe_xrupt_info *gpe_xrupt_block;
+	acpi_status status;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(ev_install_gpe_block);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	gpe_xrupt_block = acpi_ev_get_gpe_xrupt_block(interrupt_number);
+	if (!gpe_xrupt_block) {
+		status = AE_NO_MEMORY;
+		goto unlock_and_exit;
+	}
+
+	/* Install the new block at the end of the list with lock */
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+	if (gpe_xrupt_block->gpe_block_list_head) {
+		next_gpe_block = gpe_xrupt_block->gpe_block_list_head;
+		while (next_gpe_block->next) {
+			next_gpe_block = next_gpe_block->next;
+		}
+
+		next_gpe_block->next = gpe_block;
+		gpe_block->previous = next_gpe_block;
+	} else {
+		gpe_xrupt_block->gpe_block_list_head = gpe_block;
+	}
+
+	gpe_block->xrupt_block = gpe_xrupt_block;
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+
+      unlock_and_exit:
+	status = acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_delete_gpe_block
+ *
+ * PARAMETERS:  gpe_block           - Existing GPE block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove a GPE block
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ev_delete_gpe_block(struct acpi_gpe_block_info *gpe_block)
+{
+	acpi_status status;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(ev_install_gpe_block);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Disable all GPEs in this block */
+
+	status =
+	    acpi_hw_disable_gpe_block(gpe_block->xrupt_block, gpe_block, NULL);
+
+	if (!gpe_block->previous && !gpe_block->next) {
+
+		/* This is the last gpe_block on this interrupt */
+
+		status = acpi_ev_delete_gpe_xrupt(gpe_block->xrupt_block);
+		if (ACPI_FAILURE(status)) {
+			goto unlock_and_exit;
+		}
+	} else {
+		/* Remove the block on this interrupt with lock */
+
+		flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+		if (gpe_block->previous) {
+			gpe_block->previous->next = gpe_block->next;
+		} else {
+			gpe_block->xrupt_block->gpe_block_list_head =
+			    gpe_block->next;
+		}
+
+		if (gpe_block->next) {
+			gpe_block->next->previous = gpe_block->previous;
+		}
+		acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+	}
+
+	acpi_current_gpe_count -=
+	    gpe_block->register_count * ACPI_GPE_REGISTER_WIDTH;
+
+	/* Free the gpe_block */
+
+	ACPI_FREE(gpe_block->register_info);
+	ACPI_FREE(gpe_block->event_info);
+	ACPI_FREE(gpe_block);
+
+      unlock_and_exit:
+	status = acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_create_gpe_info_blocks
+ *
+ * PARAMETERS:  gpe_block   - New GPE block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create the register_info and event_info blocks for this GPE block
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ev_create_gpe_info_blocks(struct acpi_gpe_block_info *gpe_block)
+{
+	struct acpi_gpe_register_info *gpe_register_info = NULL;
+	struct acpi_gpe_event_info *gpe_event_info = NULL;
+	struct acpi_gpe_event_info *this_event;
+	struct acpi_gpe_register_info *this_register;
+	u32 i;
+	u32 j;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ev_create_gpe_info_blocks);
+
+	/* Allocate the GPE register information block */
+
+	gpe_register_info = ACPI_ALLOCATE_ZEROED((acpi_size) gpe_block->
+						 register_count *
+						 sizeof(struct
+							acpi_gpe_register_info));
+	if (!gpe_register_info) {
+		ACPI_ERROR((AE_INFO,
+			    "Could not allocate the GpeRegisterInfo table"));
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/*
+	 * Allocate the GPE event_info block. There are eight distinct GPEs
+	 * per register. Initialization to zeros is sufficient.
+	 */
+	gpe_event_info = ACPI_ALLOCATE_ZEROED(((acpi_size) gpe_block->
+					       register_count *
+					       ACPI_GPE_REGISTER_WIDTH) *
+					      sizeof(struct
+						     acpi_gpe_event_info));
+	if (!gpe_event_info) {
+		ACPI_ERROR((AE_INFO,
+			    "Could not allocate the GpeEventInfo table"));
+		status = AE_NO_MEMORY;
+		goto error_exit;
+	}
+
+	/* Save the new Info arrays in the GPE block */
+
+	gpe_block->register_info = gpe_register_info;
+	gpe_block->event_info = gpe_event_info;
+
+	/*
+	 * Initialize the GPE Register and Event structures. A goal of these
+	 * tables is to hide the fact that there are two separate GPE register
+	 * sets in a given GPE hardware block, the status registers occupy the
+	 * first half, and the enable registers occupy the second half.
+	 */
+	this_register = gpe_register_info;
+	this_event = gpe_event_info;
+
+	for (i = 0; i < gpe_block->register_count; i++) {
+
+		/* Init the register_info for this GPE register (8 GPEs) */
+
+		this_register->base_gpe_number =
+		    (u8) (gpe_block->block_base_number +
+			  (i * ACPI_GPE_REGISTER_WIDTH));
+
+		this_register->status_address.address =
+		    gpe_block->block_address.address + i;
+
+		this_register->enable_address.address =
+		    gpe_block->block_address.address + i +
+		    gpe_block->register_count;
+
+		this_register->status_address.space_id =
+		    gpe_block->block_address.space_id;
+		this_register->enable_address.space_id =
+		    gpe_block->block_address.space_id;
+		this_register->status_address.bit_width =
+		    ACPI_GPE_REGISTER_WIDTH;
+		this_register->enable_address.bit_width =
+		    ACPI_GPE_REGISTER_WIDTH;
+		this_register->status_address.bit_offset = 0;
+		this_register->enable_address.bit_offset = 0;
+
+		/* Init the event_info for each GPE within this register */
+
+		for (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {
+			this_event->gpe_number =
+			    (u8) (this_register->base_gpe_number + j);
+			this_event->register_info = this_register;
+			this_event++;
+		}
+
+		/* Disable all GPEs within this register */
+
+		status = acpi_write(0x00, &this_register->enable_address);
+		if (ACPI_FAILURE(status)) {
+			goto error_exit;
+		}
+
+		/* Clear any pending GPE events within this register */
+
+		status = acpi_write(0xFF, &this_register->status_address);
+		if (ACPI_FAILURE(status)) {
+			goto error_exit;
+		}
+
+		this_register++;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+
+      error_exit:
+	if (gpe_register_info) {
+		ACPI_FREE(gpe_register_info);
+	}
+	if (gpe_event_info) {
+		ACPI_FREE(gpe_event_info);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_create_gpe_block
+ *
+ * PARAMETERS:  gpe_device          - Handle to the parent GPE block
+ *              gpe_block_address   - Address and space_iD
+ *              register_count      - Number of GPE register pairs in the block
+ *              gpe_block_base_number - Starting GPE number for the block
+ *              interrupt_number    - H/W interrupt for the block
+ *              return_gpe_block    - Where the new block descriptor is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create and Install a block of GPE registers. All GPEs within
+ *              the block are disabled at exit.
+ *              Note: Assumes namespace is locked.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
+			 struct acpi_generic_address *gpe_block_address,
+			 u32 register_count,
+			 u8 gpe_block_base_number,
+			 u32 interrupt_number,
+			 struct acpi_gpe_block_info **return_gpe_block)
+{
+	acpi_status status;
+	struct acpi_gpe_block_info *gpe_block;
+
+	ACPI_FUNCTION_TRACE(ev_create_gpe_block);
+
+	if (!register_count) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Allocate a new GPE block */
+
+	gpe_block = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_gpe_block_info));
+	if (!gpe_block) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Initialize the new GPE block */
+
+	gpe_block->node = gpe_device;
+	gpe_block->register_count = register_count;
+	gpe_block->block_base_number = gpe_block_base_number;
+
+	ACPI_MEMCPY(&gpe_block->block_address, gpe_block_address,
+		    sizeof(struct acpi_generic_address));
+
+	/*
+	 * Create the register_info and event_info sub-structures
+	 * Note: disables and clears all GPEs in the block
+	 */
+	status = acpi_ev_create_gpe_info_blocks(gpe_block);
+	if (ACPI_FAILURE(status)) {
+		ACPI_FREE(gpe_block);
+		return_ACPI_STATUS(status);
+	}
+
+	/* Install the new block in the global lists */
+
+	status = acpi_ev_install_gpe_block(gpe_block, interrupt_number);
+	if (ACPI_FAILURE(status)) {
+		ACPI_FREE(gpe_block);
+		return_ACPI_STATUS(status);
+	}
+
+	/* Find all GPE methods (_Lxx, _Exx) for this block */
+
+	status = acpi_ns_walk_namespace(ACPI_TYPE_METHOD, gpe_device,
+					ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,
+					acpi_ev_save_method_info, gpe_block,
+					NULL);
+
+	/* Return the new block */
+
+	if (return_gpe_block) {
+		(*return_gpe_block) = gpe_block;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INIT,
+			  "GPE %02X to %02X [%4.4s] %u regs on int 0x%X\n",
+			  (u32) gpe_block->block_base_number,
+			  (u32) (gpe_block->block_base_number +
+				 ((gpe_block->register_count *
+				   ACPI_GPE_REGISTER_WIDTH) - 1)),
+			  gpe_device->name.ascii, gpe_block->register_count,
+			  interrupt_number));
+
+	/* Update global count of currently available GPEs */
+
+	acpi_current_gpe_count += register_count * ACPI_GPE_REGISTER_WIDTH;
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_initialize_gpe_block
+ *
+ * PARAMETERS:  gpe_device          - Handle to the parent GPE block
+ *              gpe_block           - Gpe Block info
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initialize and enable a GPE block. First find and run any
+ *              _PRT methods associated with the block, then enable the
+ *              appropriate GPEs.
+ *              Note: Assumes namespace is locked.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_initialize_gpe_block(struct acpi_namespace_node *gpe_device,
+			     struct acpi_gpe_block_info *gpe_block)
+{
+	acpi_status status;
+	struct acpi_gpe_event_info *gpe_event_info;
+	struct acpi_gpe_walk_info gpe_info;
+	u32 wake_gpe_count;
+	u32 gpe_enabled_count;
+	u32 i;
+	u32 j;
+
+	ACPI_FUNCTION_TRACE(ev_initialize_gpe_block);
+
+	/* Ignore a null GPE block (e.g., if no GPE block 1 exists) */
+
+	if (!gpe_block) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * Runtime option: Should wake GPEs be enabled at runtime?  The default
+	 * is no, they should only be enabled just as the machine goes to sleep.
+	 */
+	if (acpi_gbl_leave_wake_gpes_disabled) {
+		/*
+		 * Differentiate runtime vs wake GPEs, via the _PRW control methods.
+		 * Each GPE that has one or more _PRWs that reference it is by
+		 * definition a wake GPE and will not be enabled while the machine
+		 * is running.
+		 */
+		gpe_info.gpe_block = gpe_block;
+		gpe_info.gpe_device = gpe_device;
+
+		status =
+		    acpi_ns_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
+					   ACPI_UINT32_MAX, ACPI_NS_WALK_UNLOCK,
+					   acpi_ev_match_prw_and_gpe, &gpe_info,
+					   NULL);
+	}
+
+	/*
+	 * Enable all GPEs in this block that have these attributes:
+	 * 1) are "runtime" or "run/wake" GPEs, and
+	 * 2) have a corresponding _Lxx or _Exx method
+	 *
+	 * Any other GPEs within this block must be enabled via the acpi_enable_gpe()
+	 * external interface.
+	 */
+	wake_gpe_count = 0;
+	gpe_enabled_count = 0;
+
+	for (i = 0; i < gpe_block->register_count; i++) {
+		for (j = 0; j < 8; j++) {
+
+			/* Get the info block for this particular GPE */
+
+			gpe_event_info =
+			    &gpe_block->
+			    event_info[((acpi_size) i *
+					ACPI_GPE_REGISTER_WIDTH) + j];
+
+			if (((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
+			     ACPI_GPE_DISPATCH_METHOD)
+			    && (gpe_event_info->flags & ACPI_GPE_TYPE_RUNTIME)) {
+				gpe_enabled_count++;
+			}
+
+			if (gpe_event_info->flags & ACPI_GPE_TYPE_WAKE) {
+				wake_gpe_count++;
+			}
+		}
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INIT,
+			  "Found %u Wake, Enabled %u Runtime GPEs in this block\n",
+			  wake_gpe_count, gpe_enabled_count));
+
+	/* Enable all valid runtime GPEs found above */
+
+	status = acpi_hw_enable_runtime_gpe_block(NULL, gpe_block, NULL);
+	if (ACPI_FAILURE(status)) {
+		ACPI_ERROR((AE_INFO, "Could not enable GPEs in GpeBlock %p",
+			    gpe_block));
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_gpe_initialize
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initialize the GPE data structures
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ev_gpe_initialize(void)
+{
+	u32 register_count0 = 0;
+	u32 register_count1 = 0;
+	u32 gpe_number_max = 0;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ev_gpe_initialize);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Initialize the GPE Block(s) defined in the FADT
+	 *
+	 * Why the GPE register block lengths are divided by 2:  From the ACPI Spec,
+	 * section "General-Purpose Event Registers", we have:
+	 *
+	 * "Each register block contains two registers of equal length
+	 *  GPEx_STS and GPEx_EN (where x is 0 or 1). The length of the
+	 *  GPE0_STS and GPE0_EN registers is equal to half the GPE0_LEN
+	 *  The length of the GPE1_STS and GPE1_EN registers is equal to
+	 *  half the GPE1_LEN. If a generic register block is not supported
+	 *  then its respective block pointer and block length values in the
+	 *  FADT table contain zeros. The GPE0_LEN and GPE1_LEN do not need
+	 *  to be the same size."
+	 */
+
+	/*
+	 * Determine the maximum GPE number for this machine.
+	 *
+	 * Note: both GPE0 and GPE1 are optional, and either can exist without
+	 * the other.
+	 *
+	 * If EITHER the register length OR the block address are zero, then that
+	 * particular block is not supported.
+	 */
+	if (acpi_gbl_FADT.gpe0_block_length &&
+	    acpi_gbl_FADT.xgpe0_block.address) {
+
+		/* GPE block 0 exists (has both length and address > 0) */
+
+		register_count0 = (u16) (acpi_gbl_FADT.gpe0_block_length / 2);
+
+		gpe_number_max =
+		    (register_count0 * ACPI_GPE_REGISTER_WIDTH) - 1;
+
+		/* Install GPE Block 0 */
+
+		status = acpi_ev_create_gpe_block(acpi_gbl_fadt_gpe_device,
+						  &acpi_gbl_FADT.xgpe0_block,
+						  register_count0, 0,
+						  acpi_gbl_FADT.sci_interrupt,
+						  &acpi_gbl_gpe_fadt_blocks[0]);
+
+		if (ACPI_FAILURE(status)) {
+			ACPI_EXCEPTION((AE_INFO, status,
+					"Could not create GPE Block 0"));
+		}
+	}
+
+	if (acpi_gbl_FADT.gpe1_block_length &&
+	    acpi_gbl_FADT.xgpe1_block.address) {
+
+		/* GPE block 1 exists (has both length and address > 0) */
+
+		register_count1 = (u16) (acpi_gbl_FADT.gpe1_block_length / 2);
+
+		/* Check for GPE0/GPE1 overlap (if both banks exist) */
+
+		if ((register_count0) &&
+		    (gpe_number_max >= acpi_gbl_FADT.gpe1_base)) {
+			ACPI_ERROR((AE_INFO,
+				    "GPE0 block (GPE 0 to %d) overlaps the GPE1 block (GPE %d to %d) - Ignoring GPE1",
+				    gpe_number_max, acpi_gbl_FADT.gpe1_base,
+				    acpi_gbl_FADT.gpe1_base +
+				    ((register_count1 *
+				      ACPI_GPE_REGISTER_WIDTH) - 1)));
+
+			/* Ignore GPE1 block by setting the register count to zero */
+
+			register_count1 = 0;
+		} else {
+			/* Install GPE Block 1 */
+
+			status =
+			    acpi_ev_create_gpe_block(acpi_gbl_fadt_gpe_device,
+						     &acpi_gbl_FADT.xgpe1_block,
+						     register_count1,
+						     acpi_gbl_FADT.gpe1_base,
+						     acpi_gbl_FADT.
+						     sci_interrupt,
+						     &acpi_gbl_gpe_fadt_blocks
+						     [1]);
+
+			if (ACPI_FAILURE(status)) {
+				ACPI_EXCEPTION((AE_INFO, status,
+						"Could not create GPE Block 1"));
+			}
+
+			/*
+			 * GPE0 and GPE1 do not have to be contiguous in the GPE number
+			 * space. However, GPE0 always starts at GPE number zero.
+			 */
+			gpe_number_max = acpi_gbl_FADT.gpe1_base +
+			    ((register_count1 * ACPI_GPE_REGISTER_WIDTH) - 1);
+		}
+	}
+
+	/* Exit if there are no GPE registers */
+
+	if ((register_count0 + register_count1) == 0) {
+
+		/* GPEs are not required by ACPI, this is OK */
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INIT,
+				  "There are no GPE blocks defined in the FADT\n"));
+		status = AE_OK;
+		goto cleanup;
+	}
+
+	/* Check for Max GPE number out-of-range */
+
+	if (gpe_number_max > ACPI_GPE_MAX) {
+		ACPI_ERROR((AE_INFO,
+			    "Maximum GPE number from FADT is too large: 0x%X",
+			    gpe_number_max));
+		status = AE_BAD_VALUE;
+		goto cleanup;
+	}
+
+      cleanup:
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return_ACPI_STATUS(AE_OK);
+}
