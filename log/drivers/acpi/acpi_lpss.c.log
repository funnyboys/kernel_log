commit fa2bfead910322e44e7e0bb74364ac198a2abd32
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:52:48 2020 +0200

    PM: sleep: core: Rename dev_pm_smart_suspend_and_suspended()
    
    Because all callers of dev_pm_smart_suspend_and_suspended use it only
    for checking whether or not to skip driver suspend callbacks for a
    device, rename it to dev_pm_skip_suspend() in analogy with
    dev_pm_skip_resume().
    
    No functional impact.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 7632df1a5be3..5e2bfbcf526f 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -1041,7 +1041,7 @@ static int acpi_lpss_do_suspend_late(struct device *dev)
 {
 	int ret;
 
-	if (dev_pm_smart_suspend_and_suspended(dev))
+	if (dev_pm_skip_suspend(dev))
 		return 0;
 
 	ret = pm_generic_suspend_late(dev);
@@ -1169,7 +1169,7 @@ static int acpi_lpss_poweroff_late(struct device *dev)
 {
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
 
-	if (dev_pm_smart_suspend_and_suspended(dev))
+	if (dev_pm_skip_suspend(dev))
 		return 0;
 
 	if (pdata->dev_desc->resume_from_noirq)
@@ -1182,7 +1182,7 @@ static int acpi_lpss_poweroff_noirq(struct device *dev)
 {
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
 
-	if (dev_pm_smart_suspend_and_suspended(dev))
+	if (dev_pm_skip_suspend(dev))
 		return 0;
 
 	if (pdata->dev_desc->resume_from_noirq) {

commit 76c70cb58ce30264af4b714109ee756da25d830a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:52:30 2020 +0200

    PM: sleep: core: Rename dev_pm_may_skip_resume()
    
    The name of dev_pm_may_skip_resume() may be easily confused with the
    power.may_skip_resume flag which is not checked by that function, so
    rename the former as dev_pm_skip_resume().
    
    No functional impact.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index c4a84df6cc98..7632df1a5be3 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -1093,7 +1093,7 @@ static int acpi_lpss_resume_early(struct device *dev)
 	if (pdata->dev_desc->resume_from_noirq)
 		return 0;
 
-	if (dev_pm_may_skip_resume(dev))
+	if (dev_pm_skip_resume(dev))
 		return 0;
 
 	return acpi_lpss_do_resume_early(dev);
@@ -1105,7 +1105,7 @@ static int acpi_lpss_resume_noirq(struct device *dev)
 	int ret;
 
 	/* Follow acpi_subsys_resume_noirq(). */
-	if (dev_pm_may_skip_resume(dev))
+	if (dev_pm_skip_resume(dev))
 		return 0;
 
 	ret = pm_generic_resume_noirq(dev);

commit 6e176bf8d46194353163c2cb660808bc633b45d9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:52:08 2020 +0200

    PM: sleep: core: Do not skip callbacks in the resume phase
    
    The current code in device_resume_noirq() causes the entire early
    resume and resume phases of device suspend to be skipped for
    devices for which the noirq resume phase have been skipped (due
    to the LEAVE_SUSPENDED flag being set) on the premise that those
    devices should stay in runtime-suspend after system-wide resume.
    
    However, that may not be correct in two situations.  First, the
    middle layer (subsystem) noirq resume callback may be missing for
    a given device, but its early resume callback may be present and it
    may need to do something even if it decides to skip the driver
    callback.  Second, if the device's wakeup settings were adjusted
    in the suspend phase without resuming the device (that was in
    runtime suspend at that time), they most likely need to be
    adjusted again in the resume phase and so the driver callback
    in that phase needs to be run.
    
    For the above reason, modify the core to allow the middle layer
    ->resume_late callback to run even if its ->resume_noirq callback
    is missing (and the core has skipped the driver-level callback
    in that phase) and to allow all device callbacks to run in the
    resume phase.  Also make the core set the PM-runtime status of
    devices with SMART_SUSPEND set whose resume callbacks are not
    skipped to "active" in the "noirq" resume phase and update the
    affected subsystems (PCI and ACPI) accordingly.
    
    After this change, middle-layer (subsystem) callbacks will always
    be invoked in all phases of system suspend and resume and driver
    callbacks will always run in the prepare, suspend, resume, and
    complete phases for all devices.
    
    For devices with SMART_SUSPEND set, driver callbacks will be
    skipped in the late and noirq phases of system suspend if those
    devices remain in runtime suspend in __device_suspend_late().
    Driver callbacks will also be skipped for them during the
    noirq and early phases of the "thaw" transition related to
    hibernation in that case.
    
    Setting LEAVE_SUSPENDED means that the driver allows its callbacks
    to be skipped in the noirq and early phases of system resume, but
    some additional conditions need to be met for that to happen (among
    other things, the power.may_skip_resume flag needs to be set for the
    device during system suspend for the driver callbacks to be skipped
    during the subsequent resume transition).
    
    For all devices with SMART_SUSPEND set whose driver callbacks are
    invoked during system resume, the PM-runtime status will be set to
    "active" (by the core).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index dee999938213..c4a84df6cc98 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -1093,6 +1093,9 @@ static int acpi_lpss_resume_early(struct device *dev)
 	if (pdata->dev_desc->resume_from_noirq)
 		return 0;
 
+	if (dev_pm_may_skip_resume(dev))
+		return 0;
+
 	return acpi_lpss_do_resume_early(dev);
 }
 
@@ -1105,9 +1108,6 @@ static int acpi_lpss_resume_noirq(struct device *dev)
 	if (dev_pm_may_skip_resume(dev))
 		return 0;
 
-	if (dev_pm_smart_suspend_and_suspended(dev))
-		pm_runtime_set_active(dev);
-
 	ret = pm_generic_resume_noirq(dev);
 	if (ret)
 		return ret;

commit e36cf2f768467cff824e7da87aedc4e99e4c8396
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 20 14:13:53 2020 +0100

    ACPI: Convert to new X86 CPU match macros
    
    The new macro set has a consistent namespace and uses C99 initializers
    instead of the grufty C89 ones.
    
    Rename the local macro wrapper to X86_MATCH for consistency. It stays for
    readability sake.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lkml.kernel.org/r/20200320131509.467730627@linutronix.de

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index db18df6cb330..dee999938213 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -306,11 +306,9 @@ static const struct lpss_device_desc bsw_spi_dev_desc = {
 	.setup = lpss_deassert_reset,
 };
 
-#define ICPU(model)	{ X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, }
-
 static const struct x86_cpu_id lpss_cpu_ids[] = {
-	ICPU(INTEL_FAM6_ATOM_SILVERMONT),	/* Valleyview, Bay Trail */
-	ICPU(INTEL_FAM6_ATOM_AIRMONT),	/* Braswell, Cherry Trail */
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT,	NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT,	NULL),
 	{}
 };
 

commit b2147a3a4fc6ddbff7f72984837b4137d088793b
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Dec 16 21:29:04 2019 +0100

    ACPI / LPSS: Rename pwm_backlight pwm-lookup to pwm_soc_backlight
    
    At least Bay Trail (BYT) and Cherry Trail (CHT) devices can use 1 of 2
    different PWM controllers for controlling the LCD's backlight brightness.
    Either the one integrated into the PMIC or the one integrated into the
    SoC (the 1st LPSS PWM controller).
    
    So far in the LPSS code on BYT we have skipped registering the LPSS PWM
    controller "pwm_backlight" lookup entry when a Crystal Cove PMIC is
    present, assuming that in this case the PMIC PWM controller will be used.
    
    On CHT we have been relying on only 1 of the 2 PWM controllers being
    enabled in the DSDT at the same time; and always registered the lookup.
    
    So far this has been working, but the correct way to determine which PWM
    controller needs to be used is by checking a bit in the VBT table and
    recently I've learned about 2 different BYT devices:
    Point of View MOBII TAB-P800W
    Acer Switch 10 SW5-012
    
    Which use a Crystal Cove PMIC, yet the LCD is connected to the SoC/LPSS
    PWM controller (and the VBT correctly indicates this), so here our old
    heuristics fail.
    
    Since only the i915 driver has access to the VBT, this commit renames
    the "pwm_backlight" lookup entries for the 1st BYT/CHT LPSS PWM controller
    to "pwm_soc_backlight" so that the i915 driver can do a pwm_get() for
    the right controller depending on the VBT bit, instead of the i915 driver
    relying on a "pwm_backlight" lookup getting registered which magically
    points to the right controller.
    
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191216202906.1662893-2-hdegoede@redhat.com

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 70f740b09684..db18df6cb330 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -69,10 +69,6 @@ ACPI_MODULE_NAME("acpi_lpss");
 #define LPSS_SAVE_CTX			BIT(4)
 #define LPSS_NO_D3_DELAY		BIT(5)
 
-/* Crystal Cove PMIC shares same ACPI ID between different platforms */
-#define BYT_CRC_HRV			2
-#define CHT_CRC_HRV			3
-
 struct lpss_private_data;
 
 struct lpss_device_desc {
@@ -158,7 +154,7 @@ static void lpss_deassert_reset(struct lpss_private_data *pdata)
  */
 static struct pwm_lookup byt_pwm_lookup[] = {
 	PWM_LOOKUP_WITH_MODULE("80860F09:00", 0, "0000:00:02.0",
-			       "pwm_backlight", 0, PWM_POLARITY_NORMAL,
+			       "pwm_soc_backlight", 0, PWM_POLARITY_NORMAL,
 			       "pwm-lpss-platform"),
 };
 
@@ -170,8 +166,7 @@ static void byt_pwm_setup(struct lpss_private_data *pdata)
 	if (!adev->pnp.unique_id || strcmp(adev->pnp.unique_id, "1"))
 		return;
 
-	if (!acpi_dev_present("INT33FD", NULL, BYT_CRC_HRV))
-		pwm_add_table(byt_pwm_lookup, ARRAY_SIZE(byt_pwm_lookup));
+	pwm_add_table(byt_pwm_lookup, ARRAY_SIZE(byt_pwm_lookup));
 }
 
 #define LPSS_I2C_ENABLE			0x6c
@@ -204,7 +199,7 @@ static void byt_i2c_setup(struct lpss_private_data *pdata)
 /* BSW PWM used for backlight control by the i915 driver */
 static struct pwm_lookup bsw_pwm_lookup[] = {
 	PWM_LOOKUP_WITH_MODULE("80862288:00", 0, "0000:00:02.0",
-			       "pwm_backlight", 0, PWM_POLARITY_NORMAL,
+			       "pwm_soc_backlight", 0, PWM_POLARITY_NORMAL,
 			       "pwm-lpss-platform"),
 };
 

commit 995e2ef08280dab8de6c517acd836613678fe2a3
Merge: 1fca7e0e6fe6 ae5e6c6439c3 cb0701acfa7e b5b42b24d783 2e127203d116
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Nov 26 10:30:49 2019 +0100

    Merge branches 'acpi-utils', 'acpi-platform', 'acpi-video' and 'acpi-doc'
    
    * acpi-utils:
      iommu/amd: Switch to use acpi_dev_hid_uid_match()
      mmc: sdhci-acpi: Switch to use acpi_dev_hid_uid_match()
      ACPI / LPSS: Switch to use acpi_dev_hid_uid_match()
      ACPI / utils: Introduce acpi_dev_hid_uid_match() helper
      ACPI / utils: Move acpi_dev_get_first_match_dev() under CONFIG_ACPI
      ACPI / utils: Describe function parameters in kernel-doc
    
    * acpi-platform:
      ACPI: platform: Unregister stale platform devices
      ACPI: Always build evged in
    
    * acpi-video:
      ACPI: video: update doc for acpi_video_bus_DOS()
    
    * acpi-doc:
      ACPI: Documentation: Minor spelling fix in namespace.rst

commit 6025e2fae3dde3c3d789d08f8ceacbdd9f90d471
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Oct 24 23:57:23 2019 +0200

    ACPI: LPSS: Add dmi quirk for skipping _DEP check for some device-links
    
    The iGPU / GFX0 device's _PS0 method on the ASUS T200TA depends on the
    I2C1 controller (which is connected to the embedded controller). But unlike
    in the T100TA/T100CHI this dependency is not listed in the _DEP of the GFX0
    device.
    
    This results in the dev_WARN_ONCE(..., "Transfer while suspended\n") call
    in i2c-designware-master.c triggering and the AML code not working as it
    should.
    
    This commit fixes this by adding a dmi based quirk mechanism for devices
    which miss a _DEP, and adding a quirk for the LNXVIDEO depending on the
    I2C1 device on the Asus T200TA.
    
    Fixes: 2d71ee0ce72f ("ACPI / LPSS: Add a device link from the GPU to the BYT I2C5 controller")
    Tested-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: 4.20+ <stable@vger.kernel.org> # 4.20+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index cd8cf3333f04..751ed38f2a10 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -10,6 +10,7 @@
 #include <linux/acpi.h>
 #include <linux/clkdev.h>
 #include <linux/clk-provider.h>
+#include <linux/dmi.h>
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/mutex.h>
@@ -463,6 +464,18 @@ struct lpss_device_links {
 	const char *consumer_hid;
 	const char *consumer_uid;
 	u32 flags;
+	const struct dmi_system_id *dep_missing_ids;
+};
+
+/* Please keep this list sorted alphabetically by vendor and model */
+static const struct dmi_system_id i2c1_dep_missing_dmi_ids[] = {
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "T200TA"),
+		},
+	},
+	{}
 };
 
 /*
@@ -478,7 +491,8 @@ static const struct lpss_device_links lpss_device_links[] = {
 	/* CHT iGPU depends on PMIC I2C controller */
 	{"808622C1", "7", "LNXVIDEO", NULL, DL_FLAG_PM_RUNTIME},
 	/* BYT iGPU depends on the Embedded Controller I2C controller (UID 1) */
-	{"80860F41", "1", "LNXVIDEO", NULL, DL_FLAG_PM_RUNTIME},
+	{"80860F41", "1", "LNXVIDEO", NULL, DL_FLAG_PM_RUNTIME,
+	 i2c1_dep_missing_dmi_ids},
 	/* BYT CR iGPU depends on PMIC I2C controller (UID 5 on CR) */
 	{"80860F41", "5", "LNXVIDEO", NULL, DL_FLAG_PM_RUNTIME},
 	/* BYT iGPU depends on PMIC I2C controller (UID 7 on non CR) */
@@ -577,7 +591,8 @@ static void acpi_lpss_link_consumer(struct device *dev1,
 	if (!dev2)
 		return;
 
-	if (acpi_lpss_dep(ACPI_COMPANION(dev2), ACPI_HANDLE(dev1)))
+	if ((link->dep_missing_ids && dmi_check_system(link->dep_missing_ids))
+	    || acpi_lpss_dep(ACPI_COMPANION(dev2), ACPI_HANDLE(dev1)))
 		device_link_add(dev2, dev1, link->flags);
 
 	put_device(dev2);
@@ -592,7 +607,8 @@ static void acpi_lpss_link_supplier(struct device *dev1,
 	if (!dev2)
 		return;
 
-	if (acpi_lpss_dep(ACPI_COMPANION(dev1), ACPI_HANDLE(dev2)))
+	if ((link->dep_missing_ids && dmi_check_system(link->dep_missing_ids))
+	    || acpi_lpss_dep(ACPI_COMPANION(dev1), ACPI_HANDLE(dev2)))
 		device_link_add(dev1, dev2, link->flags);
 
 	put_device(dev2);

commit b3b3519c04bdff91651d0a6deb79dbd4516b5d7b
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Oct 24 23:57:22 2019 +0200

    ACPI: LPSS: Add LNXVIDEO -> BYT I2C1 to lpss_device_links
    
    Various Asus Bay Trail devices (T100TA, T100CHI, T200TA) have an embedded
    controller connected to I2C1 and the iGPU (LNXVIDEO) _PS0/_PS3 methods
    access it, so we need to add a consumer link from LNXVIDEO to I2C1 on
    these devices to avoid suspend/resume ordering problems.
    
    Fixes: 2d71ee0ce72f ("ACPI / LPSS: Add a device link from the GPU to the BYT I2C5 controller")
    Tested-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: 4.20+ <stable@vger.kernel.org> # 4.20+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index e7a4504f0fbf..cd8cf3333f04 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -477,6 +477,8 @@ static const struct lpss_device_links lpss_device_links[] = {
 	{"808622C1", "7", "80860F14", "3", DL_FLAG_PM_RUNTIME},
 	/* CHT iGPU depends on PMIC I2C controller */
 	{"808622C1", "7", "LNXVIDEO", NULL, DL_FLAG_PM_RUNTIME},
+	/* BYT iGPU depends on the Embedded Controller I2C controller (UID 1) */
+	{"80860F41", "1", "LNXVIDEO", NULL, DL_FLAG_PM_RUNTIME},
 	/* BYT CR iGPU depends on PMIC I2C controller (UID 5 on CR) */
 	{"80860F41", "5", "LNXVIDEO", NULL, DL_FLAG_PM_RUNTIME},
 	/* BYT iGPU depends on PMIC I2C controller (UID 7 on non CR) */

commit cc18735f208565343a9824adeca5305026598550
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Oct 24 23:57:21 2019 +0200

    ACPI: LPSS: Add LNXVIDEO -> BYT I2C7 to lpss_device_links
    
    So far on Bay Trail (BYT) we only have been adding a device_link adding
    the iGPU (LNXVIDEO) device as consumer for the I2C controller for the
    PMIC for I2C5, but the PMIC only uses I2C5 on BYT CR (cost reduced) on
    regular BYT platforms I2C7 is used and we were not adding the device_link
    sometimes causing resume ordering issues.
    
    This commit adds LNXVIDEO -> BYT I2C7 to the lpss_device_links table,
    fixing this.
    
    Fixes: 2d71ee0ce72f ("ACPI / LPSS: Add a device link from the GPU to the BYT I2C5 controller")
    Tested-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: 4.20+ <stable@vger.kernel.org> # 4.20+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 60bbc5090abe..e7a4504f0fbf 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -473,9 +473,14 @@ struct lpss_device_links {
  * the supplier is not enumerated until after the consumer is probed.
  */
 static const struct lpss_device_links lpss_device_links[] = {
+	/* CHT External sdcard slot controller depends on PMIC I2C ctrl */
 	{"808622C1", "7", "80860F14", "3", DL_FLAG_PM_RUNTIME},
+	/* CHT iGPU depends on PMIC I2C controller */
 	{"808622C1", "7", "LNXVIDEO", NULL, DL_FLAG_PM_RUNTIME},
+	/* BYT CR iGPU depends on PMIC I2C controller (UID 5 on CR) */
 	{"80860F41", "5", "LNXVIDEO", NULL, DL_FLAG_PM_RUNTIME},
+	/* BYT iGPU depends on PMIC I2C controller (UID 7 on non CR) */
+	{"80860F41", "7", "LNXVIDEO", NULL, DL_FLAG_PM_RUNTIME},
 };
 
 static bool hid_uid_match(struct acpi_device *adev,

commit 7e70c8acf2bfea90f8bcf46bb6fc51e26723e480
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Oct 1 17:27:23 2019 +0300

    ACPI / LPSS: Switch to use acpi_dev_hid_uid_match()
    
    Since we have a generic helper, drop custom implementation in the driver.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 60bbc5090abe..1e520ea16042 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -478,31 +478,16 @@ static const struct lpss_device_links lpss_device_links[] = {
 	{"80860F41", "5", "LNXVIDEO", NULL, DL_FLAG_PM_RUNTIME},
 };
 
-static bool hid_uid_match(struct acpi_device *adev,
-			  const char *hid2, const char *uid2)
-{
-	const char *hid1 = acpi_device_hid(adev);
-	const char *uid1 = acpi_device_uid(adev);
-
-	if (strcmp(hid1, hid2))
-		return false;
-
-	if (!uid2)
-		return true;
-
-	return uid1 && !strcmp(uid1, uid2);
-}
-
 static bool acpi_lpss_is_supplier(struct acpi_device *adev,
 				  const struct lpss_device_links *link)
 {
-	return hid_uid_match(adev, link->supplier_hid, link->supplier_uid);
+	return acpi_dev_hid_uid_match(adev, link->supplier_hid, link->supplier_uid);
 }
 
 static bool acpi_lpss_is_consumer(struct acpi_device *adev,
 				  const struct lpss_device_links *link)
 {
-	return hid_uid_match(adev, link->consumer_hid, link->consumer_uid);
+	return acpi_dev_hid_uid_match(adev, link->consumer_hid, link->consumer_uid);
 }
 
 struct hid_uid {
@@ -518,7 +503,7 @@ static int match_hid_uid(struct device *dev, const void *data)
 	if (!adev)
 		return 0;
 
-	return hid_uid_match(adev, id->hid, id->uid);
+	return acpi_dev_hid_uid_match(adev, id->hid, id->uid);
 }
 
 static struct device *acpi_lpss_find_device(const char *hid, const char *uid)

commit 57b3006492a4c11b2d4a772b5b2905d544a32037
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Thu Aug 22 11:32:00 2019 +0300

    ACPI / LPSS: Save/restore LPSS private registers also on Lynxpoint
    
    My assumption in commit b53548f9d9e4 ("spi: pxa2xx: Remove LPSS private
    register restoring during resume") that Intel Lynxpoint and compatible
    based chipsets may not need LPSS private registers saving and restoring
    over suspend/resume cycle turned out to be false on Intel Broadwell.
    
    Curtis Malainey sent a patch bringing above change back and reported the
    LPSS SPI Chip Select control was lost over suspend/resume cycle on
    Broadwell machine.
    
    Instead of reverting above commit lets add LPSS private register
    saving/restoring also for all LPSS SPI, I2C and UART controllers on
    Lynxpoint and compatible chipset to make sure context is not lost in
    case nothing else preserves it like firmware or if LPSS is always on.
    
    Fixes: b53548f9d9e4 ("spi: pxa2xx: Remove LPSS private register restoring during resume")
    Reported-by: Curtis Malainey <cujomalainey@chromium.org>
    Tested-by: Curtis Malainey <cujomalainey@chromium.org>
    Cc: 5.0+ <stable@vger.kernel.org> # 5.0+
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index d696f165a50e..60bbc5090abe 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -219,12 +219,13 @@ static void bsw_pwm_setup(struct lpss_private_data *pdata)
 }
 
 static const struct lpss_device_desc lpt_dev_desc = {
-	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_LTR,
+	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_LTR
+			| LPSS_SAVE_CTX,
 	.prv_offset = 0x800,
 };
 
 static const struct lpss_device_desc lpt_i2c_dev_desc = {
-	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_LTR,
+	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_LTR | LPSS_SAVE_CTX,
 	.prv_offset = 0x800,
 };
 
@@ -236,7 +237,8 @@ static struct property_entry uart_properties[] = {
 };
 
 static const struct lpss_device_desc lpt_uart_dev_desc = {
-	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_LTR,
+	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_LTR
+			| LPSS_SAVE_CTX,
 	.clk_con_id = "baudclk",
 	.prv_offset = 0x800,
 	.setup = lpss_uart_setup,

commit f632a8170a6b667ee4e3f552087588f0fe13c4bb
Merge: ef8f3d48afd6 c33d442328f5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 12 12:24:03 2019 -0700

    Merge tag 'driver-core-5.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core and debugfs updates from Greg KH:
     "Here is the "big" driver core and debugfs changes for 5.3-rc1
    
      It's a lot of different patches, all across the tree due to some api
      changes and lots of debugfs cleanups.
    
      Other than the debugfs cleanups, in this set of changes we have:
    
       - bus iteration function cleanups
    
       - scripts/get_abi.pl tool to display and parse Documentation/ABI
         entries in a simple way
    
       - cleanups to Documenatation/ABI/ entries to make them parse easier
         due to typos and other minor things
    
       - default_attrs use for some ktype users
    
       - driver model documentation file conversions to .rst
    
       - compressed firmware file loading
    
       - deferred probe fixes
    
      All of these have been in linux-next for a while, with a bunch of
      merge issues that Stephen has been patient with me for"
    
    * tag 'driver-core-5.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (102 commits)
      debugfs: make error message a bit more verbose
      orangefs: fix build warning from debugfs cleanup patch
      ubifs: fix build warning after debugfs cleanup patch
      driver: core: Allow subsystems to continue deferring probe
      drivers: base: cacheinfo: Ensure cpu hotplug work is done before Intel RDT
      arch_topology: Remove error messages on out-of-memory conditions
      lib: notifier-error-inject: no need to check return value of debugfs_create functions
      swiotlb: no need to check return value of debugfs_create functions
      ceph: no need to check return value of debugfs_create functions
      sunrpc: no need to check return value of debugfs_create functions
      ubifs: no need to check return value of debugfs_create functions
      orangefs: no need to check return value of debugfs_create functions
      nfsd: no need to check return value of debugfs_create functions
      lib: 842: no need to check return value of debugfs_create functions
      debugfs: provide pr_fmt() macro
      debugfs: log errors when something goes wrong
      drivers: s390/cio: Fix compilation warning about const qualifiers
      drivers: Add generic helper to match by of_node
      driver_find_device: Unify the match function with class_find_device()
      bus_find_device: Unify the match callback with class_find_device
      ...

commit 3dbeb448543efc01f04cadd6d358b9f33dd20d31
Merge: 50e163d43ab1 02bd45a28bf3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 8 10:51:25 2019 +0200

    Merge branch 'pm-sleep'
    
    * pm-sleep:
      PM: sleep: Drop dev_pm_skip_next_resume_phases()
      ACPI: PM: Drop unused function and function header
      ACPI: PM: Introduce "poweroff" callbacks for ACPI PM domain and LPSS
      ACPI: PM: Simplify and fix PM domain hibernation callbacks
      PCI: PM: Simplify bus-level hibernation callbacks
      PM: ACPI/PCI: Resume all devices during hibernation
      kernel: power: swap: use kzalloc() instead of kmalloc() followed by memset()
      PM: sleep: Update struct wakeup_source documentation
      drivers: base: power: remove wakeup_sources_stats_dentry variable
      PM: suspend: Rename pm_suspend_via_s2idle()
      PM: sleep: Show how long dpm_suspend_start() and dpm_suspend_end() take
      PM: hibernate: powerpc: Expose pfn_is_nosave() prototype

commit c95b7595f85c688d5c569ddbbd6ab6a4bdae2f36
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 1 12:54:29 2019 +0200

    ACPI: PM: Introduce "poweroff" callbacks for ACPI PM domain and LPSS
    
    In general, it is not correct to call pm_generic_suspend(),
    pm_generic_suspend_late() and pm_generic_suspend_noirq() during the
    hibernation's "poweroff" transition, because device drivers may
    provide special callbacks to be invoked then and the wrappers in
    question cause system suspend callbacks to be run.  Unfortunately,
    that happens in the ACPI PM domain and ACPI LPSS.
    
    To address this potential issue, introduce "poweroff" callbacks
    for the ACPI PM and LPSS that will use pm_generic_poweroff(),
    pm_generic_poweroff_late() and pm_generic_poweroff_noirq() as
    appropriate.
    
    Fixes: 05087360fd7a (ACPI / PM: Take SMART_SUSPEND driver flag into account)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 8ea836857691..a7396e18f168 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -1064,6 +1064,13 @@ static int acpi_lpss_suspend_noirq(struct device *dev)
 	int ret;
 
 	if (pdata->dev_desc->resume_from_noirq) {
+		/*
+		 * The driver's ->suspend_late callback will be invoked by
+		 * acpi_lpss_do_suspend_late(), with the assumption that the
+		 * driver really wanted to run that code in ->suspend_noirq, but
+		 * it could not run after acpi_dev_suspend() and the driver
+		 * expected the latter to be called in the "late" phase.
+		 */
 		ret = acpi_lpss_do_suspend_late(dev);
 		if (ret)
 			return ret;
@@ -1150,6 +1157,43 @@ static int acpi_lpss_restore_noirq(struct device *dev)
 	/* This is analogous to what happens in acpi_lpss_resume_noirq(). */
 	return acpi_lpss_do_restore_early(dev);
 }
+
+static int acpi_lpss_do_poweroff_late(struct device *dev)
+{
+	int ret = pm_generic_poweroff_late(dev);
+
+	return ret ? ret : acpi_lpss_suspend(dev, device_may_wakeup(dev));
+}
+
+static int acpi_lpss_poweroff_late(struct device *dev)
+{
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		return 0;
+
+	if (pdata->dev_desc->resume_from_noirq)
+		return 0;
+
+	return acpi_lpss_do_poweroff_late(dev);
+}
+
+static int acpi_lpss_poweroff_noirq(struct device *dev)
+{
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		return 0;
+
+	if (pdata->dev_desc->resume_from_noirq) {
+		/* This is analogous to the acpi_lpss_suspend_noirq() case. */
+		int ret = acpi_lpss_do_poweroff_late(dev);
+		if (ret)
+			return ret;
+	}
+
+	return pm_generic_poweroff_noirq(dev);
+}
 #endif /* CONFIG_PM_SLEEP */
 
 static int acpi_lpss_runtime_suspend(struct device *dev)
@@ -1183,9 +1227,9 @@ static struct dev_pm_domain acpi_lpss_pm_domain = {
 		.resume_noirq = acpi_lpss_resume_noirq,
 		.resume_early = acpi_lpss_resume_early,
 		.freeze = acpi_subsys_freeze,
-		.poweroff = acpi_subsys_suspend,
-		.poweroff_late = acpi_lpss_suspend_late,
-		.poweroff_noirq = acpi_lpss_suspend_noirq,
+		.poweroff = acpi_subsys_poweroff,
+		.poweroff_late = acpi_lpss_poweroff_late,
+		.poweroff_noirq = acpi_lpss_poweroff_noirq,
 		.restore_noirq = acpi_lpss_restore_noirq,
 		.restore_early = acpi_lpss_restore_early,
 #endif

commit 3cd7957e85e67120bb9f6bfb75d81dcc19af282b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 1 12:54:10 2019 +0200

    ACPI: PM: Simplify and fix PM domain hibernation callbacks
    
    First, after a previous change causing all runtime-suspended devices
    in the ACPI PM domain (and ACPI LPSS devices) to be resumed before
    creating a snapshot image of memory during hibernation, it is not
    necessary to worry about the case in which them might be left in
    runtime-suspend any more, so get rid of the code related to that from
    ACPI PM domain and ACPI LPSS hibernation callbacks.
    
    Second, it is not correct to use pm_generic_resume_early() and
    acpi_subsys_resume_noirq() in hibernation "restore" callbacks (which
    currently happens in the ACPI PM domain and ACPI LPSS), so introduce
    proper _restore_late and _restore_noirq callbacks for the ACPI PM
    domain and ACPI LPSS.
    
    Fixes: 05087360fd7a (ACPI / PM: Take SMART_SUSPEND driver flag into account)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index cf768608437e..8ea836857691 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -1094,16 +1094,62 @@ static int acpi_lpss_resume_noirq(struct device *dev)
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
 	int ret;
 
-	ret = acpi_subsys_resume_noirq(dev);
+	/* Follow acpi_subsys_resume_noirq(). */
+	if (dev_pm_may_skip_resume(dev))
+		return 0;
+
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		pm_runtime_set_active(dev);
+
+	ret = pm_generic_resume_noirq(dev);
 	if (ret)
 		return ret;
 
-	if (!dev_pm_may_skip_resume(dev) && pdata->dev_desc->resume_from_noirq)
-		ret = acpi_lpss_do_resume_early(dev);
+	if (!pdata->dev_desc->resume_from_noirq)
+		return 0;
 
-	return ret;
+	/*
+	 * The driver's ->resume_early callback will be invoked by
+	 * acpi_lpss_do_resume_early(), with the assumption that the driver
+	 * really wanted to run that code in ->resume_noirq, but it could not
+	 * run before acpi_dev_resume() and the driver expected the latter to be
+	 * called in the "early" phase.
+	 */
+	return acpi_lpss_do_resume_early(dev);
+}
+
+static int acpi_lpss_do_restore_early(struct device *dev)
+{
+	int ret = acpi_lpss_resume(dev);
+
+	return ret ? ret : pm_generic_restore_early(dev);
+}
+
+static int acpi_lpss_restore_early(struct device *dev)
+{
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+
+	if (pdata->dev_desc->resume_from_noirq)
+		return 0;
+
+	return acpi_lpss_do_restore_early(dev);
 }
 
+static int acpi_lpss_restore_noirq(struct device *dev)
+{
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+	int ret;
+
+	ret = pm_generic_restore_noirq(dev);
+	if (ret)
+		return ret;
+
+	if (!pdata->dev_desc->resume_from_noirq)
+		return 0;
+
+	/* This is analogous to what happens in acpi_lpss_resume_noirq(). */
+	return acpi_lpss_do_restore_early(dev);
+}
 #endif /* CONFIG_PM_SLEEP */
 
 static int acpi_lpss_runtime_suspend(struct device *dev)
@@ -1137,14 +1183,11 @@ static struct dev_pm_domain acpi_lpss_pm_domain = {
 		.resume_noirq = acpi_lpss_resume_noirq,
 		.resume_early = acpi_lpss_resume_early,
 		.freeze = acpi_subsys_freeze,
-		.freeze_late = acpi_subsys_freeze_late,
-		.freeze_noirq = acpi_subsys_freeze_noirq,
-		.thaw_noirq = acpi_subsys_thaw_noirq,
 		.poweroff = acpi_subsys_suspend,
 		.poweroff_late = acpi_lpss_suspend_late,
 		.poweroff_noirq = acpi_lpss_suspend_noirq,
-		.restore_noirq = acpi_lpss_resume_noirq,
-		.restore_early = acpi_lpss_resume_early,
+		.restore_noirq = acpi_lpss_restore_noirq,
+		.restore_early = acpi_lpss_restore_early,
 #endif
 		.runtime_suspend = acpi_lpss_runtime_suspend,
 		.runtime_resume = acpi_lpss_runtime_resume,

commit 418e3ea157efb0eb2c6dd412a8d5f052477c7f5a
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Fri Jun 14 18:53:59 2019 +0100

    bus_find_device: Unify the match callback with class_find_device
    
    There is an arbitrary difference between the prototypes of
    bus_find_device() and class_find_device() preventing their callers
    from passing the same pair of data and match() arguments to both of
    them, which is the const qualifier used in the prototype of
    class_find_device().  If that qualifier is also used in the
    bus_find_device() prototype, it will be possible to pass the same
    match() callback function to both bus_find_device() and
    class_find_device(), which will allow some optimizations to be made in
    order to avoid code duplication going forward.  Also with that, constify
    the "data" parameter as it is passed as a const to the match function.
    
    For this reason, change the prototype of bus_find_device() to match
    the prototype of class_find_device() and adjust its callers to use the
    const qualifier in accordance with the new prototype of it.
    
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Andreas Noever <andreas.noever@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Corey Minyard <minyard@acm.org>
    Cc: Christian Borntraeger <borntraeger@de.ibm.com>
    Cc: David Kershner <david.kershner@unisys.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Felipe Balbi <balbi@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Harald Freudenberger <freude@linux.ibm.com>
    Cc: Hartmut Knaack <knaack.h@gmx.de>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Jason Gunthorpe <jgg@ziepe.ca>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Cc: "James E.J. Bottomley" <jejb@linux.ibm.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michael Jamet <michael.jamet@intel.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Peter Oberparleiter <oberpar@linux.ibm.com>
    Cc: Sebastian Ott <sebott@linux.ibm.com>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Cc: Yehezkel Bernat <YehezkelShB@gmail.com>
    Cc: rafael@kernel.org
    Acked-by: Corey Minyard <minyard@acm.org>
    Acked-by: David Kershner <david.kershner@unisys.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de> # for the I2C parts
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index cf768608437e..dc2ca78748a2 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -511,10 +511,10 @@ struct hid_uid {
 	const char *uid;
 };
 
-static int match_hid_uid(struct device *dev, void *data)
+static int match_hid_uid(struct device *dev, const void *data)
 {
 	struct acpi_device *adev = ACPI_COMPANION(dev);
-	struct hid_uid *id = data;
+	const struct hid_uid *id = data;
 
 	if (!adev)
 		return 0;

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index cf768608437e..23484aa877b6 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -1,13 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * ACPI support for Intel Lynxpoint LPSS.
  *
  * Copyright (C) 2013, Intel Corporation
  * Authors: Mika Westerberg <mika.westerberg@linux.intel.com>
  *          Rafael J. Wysocki <rafael.j.wysocki@intel.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/acpi.h>

commit c8afd03486c26accdda4846e5561aa3f8e862a9d
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Apr 18 13:39:33 2019 +0200

    ACPI / LPSS: Use acpi_lpss_* instead of acpi_subsys_* functions for hibernate
    
    Commit 48402cee6889 ("ACPI / LPSS: Resume BYT/CHT I2C controllers from
    resume_noirq") makes acpi_lpss_{suspend_late,resume_early}() bail early
    on BYT/CHT as resume_from_noirq is set.
    
    This means that on resume from hibernate dw_i2c_plat_resume() doesn't get
    called by the restore_early callback, acpi_lpss_resume_early(). Instead it
    should be called by the restore_noirq callback matching how things are done
    when resume_from_noirq is set and we are doing a regular resume.
    
    Change the restore_noirq callback to acpi_lpss_resume_noirq so that
    dw_i2c_plat_resume() gets properly called when resume_from_noirq is set
    and we are resuming from hibernate.
    
    Likewise also change the poweroff_noirq callback so that
    dw_i2c_plat_suspend gets called properly.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=202139
    Fixes: 48402cee6889 ("ACPI / LPSS: Resume BYT/CHT I2C controllers from resume_noirq")
    Reported-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Cc: 4.20+ <stable@vger.kernel.org> # 4.20+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 1e2a10a06b9d..cf768608437e 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -1142,8 +1142,8 @@ static struct dev_pm_domain acpi_lpss_pm_domain = {
 		.thaw_noirq = acpi_subsys_thaw_noirq,
 		.poweroff = acpi_subsys_suspend,
 		.poweroff_late = acpi_lpss_suspend_late,
-		.poweroff_noirq = acpi_subsys_suspend_noirq,
-		.restore_noirq = acpi_subsys_resume_noirq,
+		.poweroff_noirq = acpi_lpss_suspend_noirq,
+		.restore_noirq = acpi_lpss_resume_noirq,
 		.restore_early = acpi_lpss_resume_early,
 #endif
 		.runtime_suspend = acpi_lpss_runtime_suspend,

commit a9443a63283ae7eb78f735341da22bc3a69a464d
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Feb 18 22:34:15 2019 +0300

    clk: x86: Move clk-lpss.h to platform_data/x86
    
    clk-lpss.h is solely x86 related header. Move it to correct folder.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 5f94c35d165f..1e2a10a06b9d 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -18,7 +18,7 @@
 #include <linux/mutex.h>
 #include <linux/pci.h>
 #include <linux/platform_device.h>
-#include <linux/platform_data/clk-lpss.h>
+#include <linux/platform_data/x86/clk-lpss.h>
 #include <linux/platform_data/x86/pmc_atom.h>
 #include <linux/pm_domain.h>
 #include <linux/pm_runtime.h>

commit 1a2fa02f7489dc4d746f2a15fb77b3ce1affade8
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Dec 8 13:59:24 2018 +0100

    ACPI / LPSS: Ignore acpi_device_fix_up_power() return value
    
    Ignore acpi_device_fix_up_power() return value. If we return an error
    we end up with acpi_default_enumeration() still creating a platform-
    device for the device and we end up with the device still being used
    but without the special LPSS related handling which is not useful.
    
    Specicifically ignoring the error fixes the touchscreen no longer
    working after a suspend/resume on a Prowise PT301 tablet.
    
    This tablet has a broken _PS0 method on the touchscreen's I2C controller,
    causing acpi_device_fix_up_power() to fail, causing fallback to standard
    platform-dev handling and specifically causing acpi_lpss_save/restore_ctx
    to not run.
    
    The I2C controllers _PS0 method does actually turn on the device, but then
    does some more nonsense which fails when run during early boot trying to
    use I2C opregion handling on another not-yet registered I2C controller.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index b9bda06d344d..5f94c35d165f 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -673,12 +673,7 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 	 * have _PS0 and _PS3 without _PSC (and no power resources), so
 	 * acpi_bus_init_power() will assume that the BIOS has put them into D0.
 	 */
-	ret = acpi_device_fix_up_power(adev);
-	if (ret) {
-		/* Skip the device, but continue the namespace scan. */
-		ret = 0;
-		goto err_out;
-	}
+	acpi_device_fix_up_power(adev);
 
 	adev->driver_data = pdata;
 	pdev = acpi_create_platform_device(adev, dev_desc->properties);

commit c05f3642f4304dd081876e77a68555b6aba4483f
Merge: 0200fbdd4315 dda93b45389f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 23 13:32:18 2018 +0100

    Merge branch 'perf-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull perf updates from Ingo Molnar:
     "The main updates in this cycle were:
    
       - Lots of perf tooling changes too voluminous to list (big perf trace
         and perf stat improvements, lots of libtraceevent reorganization,
         etc.), so I'll list the authors and refer to the changelog for
         details:
    
           Benjamin Peterson, Jérémie Galarneau, Kim Phillips, Peter
           Zijlstra, Ravi Bangoria, Sangwon Hong, Sean V Kelley, Steven
           Rostedt, Thomas Gleixner, Ding Xiang, Eduardo Habkost, Thomas
           Richter, Andi Kleen, Sanskriti Sharma, Adrian Hunter, Tzvetomir
           Stoyanov, Arnaldo Carvalho de Melo, Jiri Olsa.
    
         ... with the bulk of the changes written by Jiri Olsa, Tzvetomir
         Stoyanov and Arnaldo Carvalho de Melo.
    
       - Continued intel_rdt work with a focus on playing well with perf
         events. This also imported some non-perf RDT work due to
         dependencies. (Reinette Chatre)
    
       - Implement counter freezing for Arch Perfmon v4 (Skylake and newer).
         This allows to speed up the PMI handler by avoiding unnecessary MSR
         writes and make it more accurate. (Andi Kleen)
    
       - kprobes cleanups and simplification (Masami Hiramatsu)
    
       - Intel Goldmont PMU updates (Kan Liang)
    
       - ... plus misc other fixes and updates"
    
    * 'perf-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (155 commits)
      kprobes/x86: Use preempt_enable() in optimized_callback()
      x86/intel_rdt: Prevent pseudo-locking from using stale pointers
      kprobes, x86/ptrace.h: Make regs_get_kernel_stack_nth() not fault on bad stack
      perf/x86/intel: Export mem events only if there's PEBS support
      x86/cpu: Drop pointless static qualifier in punit_dev_state_show()
      x86/intel_rdt: Fix initial allocation to consider CDP
      x86/intel_rdt: CBM overlap should also check for overlap with CDP peer
      x86/intel_rdt: Introduce utility to obtain CDP peer
      tools lib traceevent, perf tools: Move struct tep_handler definition in a local header file
      tools lib traceevent: Separate out tep_strerror() for strerror_r() issues
      perf python: More portable way to make CFLAGS work with clang
      perf python: Make clang_has_option() work on Python 3
      perf tools: Free temporary 'sys' string in read_event_files()
      perf tools: Avoid double free in read_event_file()
      perf tools: Free 'printk' string in parse_ftrace_printk()
      perf tools: Cleanup trace-event-info 'tdata' leak
      perf strbuf: Match va_{add,copy} with va_end
      perf test: S390 does not support watchpoints in test 22
      perf auxtrace: Include missing asm/bitsperlong.h to get BITS_PER_LONG
      tools include: Adopt linux/bits.h
      ...

commit f2c4db1bd80720cd8cb2a5aa220d9bc9f374f04e
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Tue Aug 7 10:17:27 2018 -0700

    x86/cpu: Sanitize FAM6_ATOM naming
    
    Going primarily by:
    
      https://en.wikipedia.org/wiki/List_of_Intel_Atom_microprocessors
    
    with additional information gleaned from other related pages; notably:
    
     - Bonnell shrink was called Saltwell
     - Moorefield is the Merriefield refresh which makes it Airmont
    
    The general naming scheme is: FAM6_ATOM_UARCH_SOCTYPE
    
      for i in `git grep -l FAM6_ATOM` ; do
            sed -i  -e 's/ATOM_PINEVIEW/ATOM_BONNELL/g'             \
                    -e 's/ATOM_LINCROFT/ATOM_BONNELL_MID/'          \
                    -e 's/ATOM_PENWELL/ATOM_SALTWELL_MID/g'         \
                    -e 's/ATOM_CLOVERVIEW/ATOM_SALTWELL_TABLET/g'   \
                    -e 's/ATOM_CEDARVIEW/ATOM_SALTWELL/g'           \
                    -e 's/ATOM_SILVERMONT1/ATOM_SILVERMONT/g'       \
                    -e 's/ATOM_SILVERMONT2/ATOM_SILVERMONT_X/g'     \
                    -e 's/ATOM_MERRIFIELD/ATOM_SILVERMONT_MID/g'    \
                    -e 's/ATOM_MOOREFIELD/ATOM_AIRMONT_MID/g'       \
                    -e 's/ATOM_DENVERTON/ATOM_GOLDMONT_X/g'         \
                    -e 's/ATOM_GEMINI_LAKE/ATOM_GOLDMONT_PLUS/g' ${i}
      done
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vince Weaver <vincent.weaver@maine.edu>
    Cc: dave.hansen@linux.intel.com
    Cc: len.brown@intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index bf64cfa30feb..9efa3a588620 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -292,7 +292,7 @@ static const struct lpss_device_desc bsw_spi_dev_desc = {
 #define ICPU(model)	{ X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, }
 
 static const struct x86_cpu_id lpss_cpu_ids[] = {
-	ICPU(INTEL_FAM6_ATOM_SILVERMONT1),	/* Valleyview, Bay Trail */
+	ICPU(INTEL_FAM6_ATOM_SILVERMONT),	/* Valleyview, Bay Trail */
 	ICPU(INTEL_FAM6_ATOM_AIRMONT),	/* Braswell, Cherry Trail */
 	{}
 };

commit 48402cee6889fb3fce58e95fea1471626286dc63
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Sep 23 15:58:11 2018 +0200

    ACPI / LPSS: Resume BYT/CHT I2C controllers from resume_noirq
    
    On some Cherry Trail systems the GPU ACPI fwnode has power-resources which
    point to the PMIC, which is connected over a LPSS I2C controller.
    
    We add a device-link to make sure that the I2C controller is resumed before
    the GPU is. But the pci-core changes the power-state of PCI devices from
    D3 to D0 at noirq time (to restore the PCI config registers) and before
    this commit we were bringing up the I2C controllers from a resume_early
    handler which runs later. More specifically the pm-core will first run
    all resume_noirq handlers in order and then all resume_early handlers.
    
    So we must not only make sure that the handlers are run in the right order,
    but also that the resume of the I2C controller is done at noirq time.
    
    The behavior before this commit, resuming the I2C controller from a
    resume_early handler leads to the following errors:
    
     i2c_designware 808622C1:06: controller timed out
     ACPI Error: AE_ERROR, Returned by Handler for [UserDefinedRegion]
     ACPI Error: Method parse/execution failed \_SB.P18W._ON, AE_ERROR
     video LNXVIDEO:00: Failed to change power state to D0
    
    This commit changes the acpi_lpss.c code to resume the BYT/CHT I2C
    controllers at resume_noirq time fixing this.
    
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 75672004db87..10adb8cb3a3f 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -84,6 +84,7 @@ struct lpss_device_desc {
 	size_t prv_size_override;
 	struct property_entry *properties;
 	void (*setup)(struct lpss_private_data *pdata);
+	bool resume_from_noirq;
 };
 
 static const struct lpss_device_desc lpss_dma_desc = {
@@ -293,12 +294,14 @@ static const struct lpss_device_desc byt_i2c_dev_desc = {
 	.flags = LPSS_CLK | LPSS_SAVE_CTX,
 	.prv_offset = 0x800,
 	.setup = byt_i2c_setup,
+	.resume_from_noirq = true,
 };
 
 static const struct lpss_device_desc bsw_i2c_dev_desc = {
 	.flags = LPSS_CLK | LPSS_SAVE_CTX | LPSS_NO_D3_DELAY,
 	.prv_offset = 0x800,
 	.setup = byt_i2c_setup,
+	.resume_from_noirq = true,
 };
 
 static const struct lpss_device_desc bsw_spi_dev_desc = {
@@ -1039,7 +1042,7 @@ static int acpi_lpss_resume(struct device *dev)
 }
 
 #ifdef CONFIG_PM_SLEEP
-static int acpi_lpss_suspend_late(struct device *dev)
+static int acpi_lpss_do_suspend_late(struct device *dev)
 {
 	int ret;
 
@@ -1050,12 +1053,62 @@ static int acpi_lpss_suspend_late(struct device *dev)
 	return ret ? ret : acpi_lpss_suspend(dev, device_may_wakeup(dev));
 }
 
-static int acpi_lpss_resume_early(struct device *dev)
+static int acpi_lpss_suspend_late(struct device *dev)
+{
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+
+	if (pdata->dev_desc->resume_from_noirq)
+		return 0;
+
+	return acpi_lpss_do_suspend_late(dev);
+}
+
+static int acpi_lpss_suspend_noirq(struct device *dev)
+{
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+	int ret;
+
+	if (pdata->dev_desc->resume_from_noirq) {
+		ret = acpi_lpss_do_suspend_late(dev);
+		if (ret)
+			return ret;
+	}
+
+	return acpi_subsys_suspend_noirq(dev);
+}
+
+static int acpi_lpss_do_resume_early(struct device *dev)
 {
 	int ret = acpi_lpss_resume(dev);
 
 	return ret ? ret : pm_generic_resume_early(dev);
 }
+
+static int acpi_lpss_resume_early(struct device *dev)
+{
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+
+	if (pdata->dev_desc->resume_from_noirq)
+		return 0;
+
+	return acpi_lpss_do_resume_early(dev);
+}
+
+static int acpi_lpss_resume_noirq(struct device *dev)
+{
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+	int ret;
+
+	ret = acpi_subsys_resume_noirq(dev);
+	if (ret)
+		return ret;
+
+	if (!dev_pm_may_skip_resume(dev) && pdata->dev_desc->resume_from_noirq)
+		ret = acpi_lpss_do_resume_early(dev);
+
+	return ret;
+}
+
 #endif /* CONFIG_PM_SLEEP */
 
 static int acpi_lpss_runtime_suspend(struct device *dev)
@@ -1085,8 +1138,8 @@ static struct dev_pm_domain acpi_lpss_pm_domain = {
 		.complete = acpi_subsys_complete,
 		.suspend = acpi_subsys_suspend,
 		.suspend_late = acpi_lpss_suspend_late,
-		.suspend_noirq = acpi_subsys_suspend_noirq,
-		.resume_noirq = acpi_subsys_resume_noirq,
+		.suspend_noirq = acpi_lpss_suspend_noirq,
+		.resume_noirq = acpi_lpss_resume_noirq,
 		.resume_early = acpi_lpss_resume_early,
 		.freeze = acpi_subsys_freeze,
 		.freeze_late = acpi_subsys_freeze_late,

commit 2d71ee0ce72f2597962fb2e66153f94d692142ba
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Sep 23 15:58:10 2018 +0200

    ACPI / LPSS: Add a device link from the GPU to the BYT I2C5 controller
    
    On some Bay Trail systems the GPU ACPI fwnode has power-resources which
    point to the PMIC, which is connected over the LPSS I2C5 controller.
    
    This one was quite nasty to debug, unlike on CHT where the same problem
    leads to errors like these:
    
         i2c_designware 808622C1:06: controller timed out
         ACPI Error: AE_ERROR, Returned by Handler for [UserDefinedRegion]
         ACPI Error: Method parse/execution failed \_SB.P18W._ON, AE_ERROR
         video LNXVIDEO:00: Failed to change power state to D0
    
    On BYT the read-modify-write done by drivers/acpi/pmic/intel_pmic_xpower.c
    on the AXP288 PMIC register to change the power-resource state *seems* to
    succeed.
    
    But in reality, because the I2C controller has not been resumed yet, the
    read silently fails and returns the wrong value, where as the write does
    succeed, writing back the wrong value for all the other power-resources
    in the same register, turning off a bunch of them. Which of course does
    not end well.
    
    This commit adds a RPM consumer link from the GPU (which has a LNXVIDEO
    HID) to the BYT LPSS I2C5 controller, so that the I2C controller gets
    resumed before the GPU is resumed and thus before we try to change the
    power-resource.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index fe37fd67331d..75672004db87 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -473,6 +473,7 @@ struct lpss_device_links {
 static const struct lpss_device_links lpss_device_links[] = {
 	{"808622C1", "7", "80860F14", "3", DL_FLAG_PM_RUNTIME},
 	{"808622C1", "7", "LNXVIDEO", NULL, DL_FLAG_PM_RUNTIME},
+	{"80860F41", "5", "LNXVIDEO", NULL, DL_FLAG_PM_RUNTIME},
 };
 
 static bool hid_uid_match(struct acpi_device *adev,

commit bd0f4e342e006366a7f4e77f8d01e42c2e8ca992
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Sep 23 15:58:09 2018 +0200

    ACPI / LPSS: Add a device link from the GPU to the CHT I2C7 controller
    
    On some Cherry Trail systems the GPU ACPI fwnode has power-resources which
    point to the PMIC, which is connected over the LPSS I2C7 controller.
    
    Due to probe ordering currently we resume the GPU and thus try to access
    the ACPI power-resources before the I2C controller has been resumed. This
    leads to the following errors:
    
     i2c_designware 808622C1:06: controller timed out
     ACPI Error: AE_ERROR, Returned by Handler for [UserDefinedRegion]
     ACPI Error: Method parse/execution failed \_SB.P18W._ON, AE_ERROR
     video LNXVIDEO:00: Failed to change power state to D0
    
    This commit adds a RPM consumer link from the GPU (which has a LNXVIDEO
    HID) to the CHT LPSS I2C7 controller, so that the I2C controller gets
    resumed before the GPU is resumed.
    
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 859b5b3dcdbf..fe37fd67331d 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -472,6 +472,7 @@ struct lpss_device_links {
  */
 static const struct lpss_device_links lpss_device_links[] = {
 	{"808622C1", "7", "80860F14", "3", DL_FLAG_PM_RUNTIME},
+	{"808622C1", "7", "LNXVIDEO", NULL, DL_FLAG_PM_RUNTIME},
 };
 
 static bool hid_uid_match(struct acpi_device *adev,

commit 1e30124ac60abc41d74793900f8b4034f29bcb3d
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Sep 23 15:58:08 2018 +0200

    ACPI / LPSS: Make acpi_lpss_find_device() also find PCI devices
    
    On some Cherry Trail systems the GPU ACPI fwnode has power-resources which
    point to the PMIC, which is connected over one of the LPSS I2C controllers.
    
    To get the suspend/resume ordering correct for this we need to be able to
    add device-links between the GPU and the I2c controller. The GPU is a PCI
    device, so this requires acpi_lpss_find_device() to also work on PCI devs.
    
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 73ae43627d60..859b5b3dcdbf 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -16,6 +16,7 @@
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/mutex.h>
+#include <linux/pci.h>
 #include <linux/platform_device.h>
 #include <linux/platform_data/clk-lpss.h>
 #include <linux/platform_data/x86/pmc_atom.h>
@@ -518,12 +519,18 @@ static int match_hid_uid(struct device *dev, void *data)
 
 static struct device *acpi_lpss_find_device(const char *hid, const char *uid)
 {
+	struct device *dev;
+
 	struct hid_uid data = {
 		.hid = hid,
 		.uid = uid,
 	};
 
-	return bus_find_device(&platform_bus_type, NULL, &data, match_hid_uid);
+	dev = bus_find_device(&platform_bus_type, NULL, &data, match_hid_uid);
+	if (dev)
+		return dev;
+
+	return bus_find_device(&pci_bus_type, NULL, &data, match_hid_uid);
 }
 
 static bool acpi_lpss_dep(struct acpi_device *adev, acpi_handle handle)

commit a92a5563e3f4189b363de72527efdfaf4789167f
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Sep 23 15:58:07 2018 +0200

    ACPI / LPSS: Make hid_uid_match helper accept a NULL uid argument
    
    Make hid_uid_match helper accept a NULL uid argument, so that we can also
    check for matches against devices with are not expected to have a uid such
    as the LNXVIDEO device.
    
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 125ef7db86ff..73ae43627d60 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -479,7 +479,13 @@ static bool hid_uid_match(struct acpi_device *adev,
 	const char *hid1 = acpi_device_hid(adev);
 	const char *uid1 = acpi_device_uid(adev);
 
-	return !strcmp(hid1, hid2) && uid1 && uid2 && !strcmp(uid1, uid2);
+	if (strcmp(hid1, hid2))
+		return false;
+
+	if (!uid2)
+		return true;
+
+	return uid1 && !strcmp(uid1, uid2);
 }
 
 static bool acpi_lpss_is_supplier(struct acpi_device *adev,

commit ea625ce133176d7eeccd692967dce5622cbb61ee
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Sep 23 15:58:06 2018 +0200

    ACPI / LPSS: Make hid_uid_match helper take an acpi_device as first argument
    
    The hid_uid_match() helper is only used to check if a given acpi_device
    matches a certain hid + uid combination. Make the first argument the
    acpi_device to check to make this more clear.
    
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 83875305b1d4..125ef7db86ff 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -473,24 +473,25 @@ static const struct lpss_device_links lpss_device_links[] = {
 	{"808622C1", "7", "80860F14", "3", DL_FLAG_PM_RUNTIME},
 };
 
-static bool hid_uid_match(const char *hid1, const char *uid1,
+static bool hid_uid_match(struct acpi_device *adev,
 			  const char *hid2, const char *uid2)
 {
+	const char *hid1 = acpi_device_hid(adev);
+	const char *uid1 = acpi_device_uid(adev);
+
 	return !strcmp(hid1, hid2) && uid1 && uid2 && !strcmp(uid1, uid2);
 }
 
 static bool acpi_lpss_is_supplier(struct acpi_device *adev,
 				  const struct lpss_device_links *link)
 {
-	return hid_uid_match(acpi_device_hid(adev), acpi_device_uid(adev),
-			     link->supplier_hid, link->supplier_uid);
+	return hid_uid_match(adev, link->supplier_hid, link->supplier_uid);
 }
 
 static bool acpi_lpss_is_consumer(struct acpi_device *adev,
 				  const struct lpss_device_links *link)
 {
-	return hid_uid_match(acpi_device_hid(adev), acpi_device_uid(adev),
-			     link->consumer_hid, link->consumer_uid);
+	return hid_uid_match(adev, link->consumer_hid, link->consumer_uid);
 }
 
 struct hid_uid {
@@ -506,8 +507,7 @@ static int match_hid_uid(struct device *dev, void *data)
 	if (!adev)
 		return 0;
 
-	return hid_uid_match(acpi_device_hid(adev), acpi_device_uid(adev),
-			     id->hid, id->uid);
+	return hid_uid_match(adev, id->hid, id->uid);
 }
 
 static struct device *acpi_lpss_find_device(const char *hid, const char *uid)

commit 86b62e5cd8965d3056f9e9ccdec51631c37add81
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Sep 8 20:08:13 2018 +0200

    ACPI / LPSS: Exclude I2C busses shared with PUNIT from pmc_atom_d3_mask
    
    lpss_iosf_enter_d3_state() checks if all hw-blocks using the DMA
    controllers are in d3 before powering down the DMA controllers.
    
    But on devices, where the I2C bus connected to the PMIC is shared by
    the PUNIT, the controller for that bus will never reach d3 since it has
    an effectively empty _PS3 method. Instead it appears to automatically
    power-down during S0i3 and we never see it as being in d3.
    
    This causes the DMA controllers to never be powered-down on these devices,
    causing them to never reach S0i3. This commit uses the ACPI _SEM method
    to detect if an I2C bus is shared with the PUNIT and if it is, it removes
    it from the mask of devices which lpss_iosf_enter_d3_state() checks for.
    
    This fixes these devices never reaching any S0ix states.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 969bf8d515c0..83875305b1d4 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -99,6 +99,9 @@ struct lpss_private_data {
 	u32 prv_reg_ctx[LPSS_PRV_REG_COUNT];
 };
 
+/* Devices which need to be in D3 before lpss_iosf_enter_d3_state() proceeds */
+static u32 pmc_atom_d3_mask = 0xfe000ffe;
+
 /* LPSS run time quirks */
 static unsigned int lpss_quirks;
 
@@ -175,6 +178,21 @@ static void byt_pwm_setup(struct lpss_private_data *pdata)
 
 static void byt_i2c_setup(struct lpss_private_data *pdata)
 {
+	const char *uid_str = acpi_device_uid(pdata->adev);
+	acpi_handle handle = pdata->adev->handle;
+	unsigned long long shared_host = 0;
+	acpi_status status;
+	long uid = 0;
+
+	/* Expected to always be true, but better safe then sorry */
+	if (uid_str)
+		uid = simple_strtol(uid_str, NULL, 10);
+
+	/* Detect I2C bus shared with PUNIT and ignore its d3 status */
+	status = acpi_evaluate_integer(handle, "_SEM", NULL, &shared_host);
+	if (ACPI_SUCCESS(status) && shared_host && uid)
+		pmc_atom_d3_mask &= ~(BIT_LPSS2_F1_I2C1 << (uid - 1));
+
 	lpss_deassert_reset(pdata);
 
 	if (readl(pdata->mmio_base + pdata->dev_desc->prv_offset))
@@ -894,7 +912,7 @@ static void lpss_iosf_enter_d3_state(void)
 	 * Here we read the values related to LPSS power island, i.e. LPSS
 	 * devices, excluding both LPSS DMA controllers, along with SCC domain.
 	 */
-	u32 func_dis, d3_sts_0, pmc_status, pmc_mask = 0xfe000ffe;
+	u32 func_dis, d3_sts_0, pmc_status;
 	int ret;
 
 	ret = pmc_atom_read(PMC_FUNC_DIS, &func_dis);
@@ -912,7 +930,7 @@ static void lpss_iosf_enter_d3_state(void)
 	 * Shutdown both LPSS DMA controllers if and only if all other devices
 	 * are already in D3hot.
 	 */
-	pmc_status = (~(d3_sts_0 | func_dis)) & pmc_mask;
+	pmc_status = (~(d3_sts_0 | func_dis)) & pmc_atom_d3_mask;
 	if (pmc_status)
 		goto exit;
 

commit 240714061c58e6b1abfb3322398a7634151c06cb
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Aug 27 09:45:44 2018 +0200

    ACPI / LPSS: Add alternative ACPI HIDs for Cherry Trail DMA controllers
    
    Bay and Cherry Trail DSTDs represent a different set of devices depending
    on which OS the device think it is booting. One set of decices for Windows
    and another set of devices for Android which targets the Android-x86 Linux
    kernel fork (which e.g. used to have its own display driver instead of
    using the i915 driver).
    
    Which set of devices we are actually going to get is out of our control,
    this is controlled by the ACPI OSID variable, which gets either set through
    an EFI setup option, or sometimes is autodetected. So we need to support
    both.
    
    This commit adds support for the 80862286 and 808622C0 ACPI HIDs which we
    get for the first resp. second DMA controller on Cherry Trail devices when
    OSID is set to Android.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index bf64cfa30feb..969bf8d515c0 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -327,9 +327,11 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	{ "INT33FC", },
 
 	/* Braswell LPSS devices */
+	{ "80862286", LPSS_ADDR(lpss_dma_desc) },
 	{ "80862288", LPSS_ADDR(bsw_pwm_dev_desc) },
 	{ "8086228A", LPSS_ADDR(bsw_uart_dev_desc) },
 	{ "8086228E", LPSS_ADDR(bsw_spi_dev_desc) },
+	{ "808622C0", LPSS_ADDR(lpss_dma_desc) },
 	{ "808622C1", LPSS_ADDR(bsw_i2c_dev_desc) },
 
 	/* Broadwell LPSS devices */

commit f11fc4bc669b8622510c1039499f5a9d24248fec
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Mon Sep 3 10:00:07 2018 +0800

    ACPI / LPSS: Force LPSS quirks on boot
    
    Commit 12864ff8545f (ACPI / LPSS: Avoid PM quirks on suspend and resume
    from hibernation) bypasses lpss quirks for S3 and S4, by setting a flag
    for S3/S4 in acpi_lpss_suspend(), and check that flag in
    acpi_lpss_resume().
    
    But this overlooks the boot case where acpi_lpss_resume() may get called
    without a corresponding acpi_lpss_suspend() having been called.
    
    Thus force setting the flag during boot.
    
    Fixes: 12864ff8545f (ACPI / LPSS: Avoid PM quirks on suspend and resume from hibernation)
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=200989
    Reported-and-tested-by: William Lieurance <william.lieurance@namikoda.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Cc: 4.15+ <stable@vger.kernel.org> # 4.15+: 12864ff8545f (ACPI / LPSS: Avoid ...)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 9706613eecf9..bf64cfa30feb 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -879,7 +879,7 @@ static void acpi_lpss_dismiss(struct device *dev)
 #define LPSS_GPIODEF0_DMA_LLP		BIT(13)
 
 static DEFINE_MUTEX(lpss_iosf_mutex);
-static bool lpss_iosf_d3_entered;
+static bool lpss_iosf_d3_entered = true;
 
 static void lpss_iosf_enter_d3_state(void)
 {

commit 12864ff8545f6b8144fdf1bb89b5663357f29ec4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jul 26 10:58:20 2018 +0200

    ACPI / LPSS: Avoid PM quirks on suspend and resume from hibernation
    
    Commit a09c59130688 (ACPI / LPSS: Avoid PM quirks on suspend and
    resume from S3) modified the ACPI driver for Intel SoCs (LPSS) to
    avoid applying PM quirks on suspend and resume from S3 to address
    system-wide suspend and resume problems on some systems, but it is
    reported that the same issue also affects hibernation, so extend
    the approach used by that commit to cover hibernation as well.
    
    Fixes: a09c59130688 (ACPI / LPSS: Avoid PM quirks on suspend and resume from S3)
    Link: https://bugs.launchpad.net/bugs/1774950
    Reported-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Cc: 4.15+ <stable@vger.kernel.org> # 4.15+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index f8fecfec5df9..9706613eecf9 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -879,6 +879,7 @@ static void acpi_lpss_dismiss(struct device *dev)
 #define LPSS_GPIODEF0_DMA_LLP		BIT(13)
 
 static DEFINE_MUTEX(lpss_iosf_mutex);
+static bool lpss_iosf_d3_entered;
 
 static void lpss_iosf_enter_d3_state(void)
 {
@@ -921,6 +922,9 @@ static void lpss_iosf_enter_d3_state(void)
 
 	iosf_mbi_modify(LPSS_IOSF_UNIT_LPIOEP, MBI_CR_WRITE,
 			LPSS_IOSF_GPIODEF0, value1, mask1);
+
+	lpss_iosf_d3_entered = true;
+
 exit:
 	mutex_unlock(&lpss_iosf_mutex);
 }
@@ -935,6 +939,11 @@ static void lpss_iosf_exit_d3_state(void)
 
 	mutex_lock(&lpss_iosf_mutex);
 
+	if (!lpss_iosf_d3_entered)
+		goto exit;
+
+	lpss_iosf_d3_entered = false;
+
 	iosf_mbi_modify(LPSS_IOSF_UNIT_LPIOEP, MBI_CR_WRITE,
 			LPSS_IOSF_GPIODEF0, value1, mask1);
 
@@ -944,13 +953,13 @@ static void lpss_iosf_exit_d3_state(void)
 	iosf_mbi_modify(LPSS_IOSF_UNIT_LPIO1, MBI_CFG_WRITE,
 			LPSS_IOSF_PMCSR, value2, mask2);
 
+exit:
 	mutex_unlock(&lpss_iosf_mutex);
 }
 
-static int acpi_lpss_suspend(struct device *dev, bool runtime)
+static int acpi_lpss_suspend(struct device *dev, bool wakeup)
 {
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
-	bool wakeup = runtime || device_may_wakeup(dev);
 	int ret;
 
 	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
@@ -963,14 +972,14 @@ static int acpi_lpss_suspend(struct device *dev, bool runtime)
 	 * wrong status for devices being about to be powered off. See
 	 * lpss_iosf_enter_d3_state() for further information.
 	 */
-	if ((runtime || !pm_suspend_via_firmware()) &&
+	if (acpi_target_system_state() == ACPI_STATE_S0 &&
 	    lpss_quirks & LPSS_QUIRK_ALWAYS_POWER_ON && iosf_mbi_available())
 		lpss_iosf_enter_d3_state();
 
 	return ret;
 }
 
-static int acpi_lpss_resume(struct device *dev, bool runtime)
+static int acpi_lpss_resume(struct device *dev)
 {
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
 	int ret;
@@ -979,8 +988,7 @@ static int acpi_lpss_resume(struct device *dev, bool runtime)
 	 * This call is kept first to be in symmetry with
 	 * acpi_lpss_runtime_suspend() one.
 	 */
-	if ((runtime || !pm_resume_via_firmware()) &&
-	    lpss_quirks & LPSS_QUIRK_ALWAYS_POWER_ON && iosf_mbi_available())
+	if (lpss_quirks & LPSS_QUIRK_ALWAYS_POWER_ON && iosf_mbi_available())
 		lpss_iosf_exit_d3_state();
 
 	ret = acpi_dev_resume(dev);
@@ -1004,12 +1012,12 @@ static int acpi_lpss_suspend_late(struct device *dev)
 		return 0;
 
 	ret = pm_generic_suspend_late(dev);
-	return ret ? ret : acpi_lpss_suspend(dev, false);
+	return ret ? ret : acpi_lpss_suspend(dev, device_may_wakeup(dev));
 }
 
 static int acpi_lpss_resume_early(struct device *dev)
 {
-	int ret = acpi_lpss_resume(dev, false);
+	int ret = acpi_lpss_resume(dev);
 
 	return ret ? ret : pm_generic_resume_early(dev);
 }
@@ -1024,7 +1032,7 @@ static int acpi_lpss_runtime_suspend(struct device *dev)
 
 static int acpi_lpss_runtime_resume(struct device *dev)
 {
-	int ret = acpi_lpss_resume(dev, true);
+	int ret = acpi_lpss_resume(dev);
 
 	return ret ? ret : pm_generic_runtime_resume(dev);
 }

commit e50f182c9094f95ecfd52a7f33e7e7320e85eb49
Merge: 8195a655e5ce a09c59130688 a507a3065c09
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jun 21 14:19:08 2018 +0200

    Merge branches 'acpi-soc' and 'acpi-processor'
    
    These are a stable-candidate suspend/resume fix of the ACPI driver for
    Intel SoCs (LPSS) and an inline stub fix for the ACPI processor driver.
    
    * acpi-soc:
      ACPI / LPSS: Avoid PM quirks on suspend and resume from S3
    
    * acpi-processor:
      ACPI / processor: Finish making acpi_processor_ppc_has_changed() void

commit a09c591306881dfb04387c6ee7b7e2e4683fa531
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 13 13:17:26 2018 +0200

    ACPI / LPSS: Avoid PM quirks on suspend and resume from S3
    
    It is reported that commit a192aa923b66a (ACPI / LPSS: Consolidate
    runtime PM and system sleep handling) introduced a system suspend
    regression on some machines, but the only functional change made by
    it was to cause the PM quirks in the LPSS to also be used during
    system suspend and resume.  While that should always work for
    suspend-to-idle, it turns out to be problematic for S3
    (suspend-to-RAM).
    
    To address that issue restore the previous S3 suspend and resume
    behavior of the LPSS to avoid applying PM quirks then.
    
    Fixes: a192aa923b66a (ACPI / LPSS: Consolidate runtime PM and system sleep handling)
    Link: https://bugs.launchpad.net/bugs/1774950
    Reported-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: 4.15+ <stable@vger.kernel.org> # 4.15+

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index cb6ac5c65c2e..55e4577b504c 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -22,6 +22,7 @@
 #include <linux/pm_domain.h>
 #include <linux/pm_runtime.h>
 #include <linux/pwm.h>
+#include <linux/suspend.h>
 #include <linux/delay.h>
 
 #include "internal.h"
@@ -944,9 +945,10 @@ static void lpss_iosf_exit_d3_state(void)
 	mutex_unlock(&lpss_iosf_mutex);
 }
 
-static int acpi_lpss_suspend(struct device *dev, bool wakeup)
+static int acpi_lpss_suspend(struct device *dev, bool runtime)
 {
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+	bool wakeup = runtime || device_may_wakeup(dev);
 	int ret;
 
 	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
@@ -959,13 +961,14 @@ static int acpi_lpss_suspend(struct device *dev, bool wakeup)
 	 * wrong status for devices being about to be powered off. See
 	 * lpss_iosf_enter_d3_state() for further information.
 	 */
-	if (lpss_quirks & LPSS_QUIRK_ALWAYS_POWER_ON && iosf_mbi_available())
+	if ((runtime || !pm_suspend_via_firmware()) &&
+	    lpss_quirks & LPSS_QUIRK_ALWAYS_POWER_ON && iosf_mbi_available())
 		lpss_iosf_enter_d3_state();
 
 	return ret;
 }
 
-static int acpi_lpss_resume(struct device *dev)
+static int acpi_lpss_resume(struct device *dev, bool runtime)
 {
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
 	int ret;
@@ -974,7 +977,8 @@ static int acpi_lpss_resume(struct device *dev)
 	 * This call is kept first to be in symmetry with
 	 * acpi_lpss_runtime_suspend() one.
 	 */
-	if (lpss_quirks & LPSS_QUIRK_ALWAYS_POWER_ON && iosf_mbi_available())
+	if ((runtime || !pm_resume_via_firmware()) &&
+	    lpss_quirks & LPSS_QUIRK_ALWAYS_POWER_ON && iosf_mbi_available())
 		lpss_iosf_exit_d3_state();
 
 	ret = acpi_dev_resume(dev);
@@ -998,12 +1002,12 @@ static int acpi_lpss_suspend_late(struct device *dev)
 		return 0;
 
 	ret = pm_generic_suspend_late(dev);
-	return ret ? ret : acpi_lpss_suspend(dev, device_may_wakeup(dev));
+	return ret ? ret : acpi_lpss_suspend(dev, false);
 }
 
 static int acpi_lpss_resume_early(struct device *dev)
 {
-	int ret = acpi_lpss_resume(dev);
+	int ret = acpi_lpss_resume(dev, false);
 
 	return ret ? ret : pm_generic_resume_early(dev);
 }
@@ -1018,7 +1022,7 @@ static int acpi_lpss_runtime_suspend(struct device *dev)
 
 static int acpi_lpss_runtime_resume(struct device *dev)
 {
-	int ret = acpi_lpss_resume(dev);
+	int ret = acpi_lpss_resume(dev, true);
 
 	return ret ? ret : pm_generic_runtime_resume(dev);
 }

commit 4b4bb99b6246007eccbc0731eae0b6742c24efa5
Merge: 9bca19a01d50 414c52b7899a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 14 16:25:43 2018 +0900

    Merge tag 'pwm/for-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/thierry.reding/linux-pwm
    
    Pull pwm updates from Thierry Reding:
     "This contains a couple of fixes and cleanups for the Meson and
      ACPI/LPSS drivers as well as capture support for STM32.
    
      Note that given the cross- subsystem changes, the STM32 patches were
      merged through the MFD and PWM trees, both sharing an immutable
      branch"
    
    * tag 'pwm/for-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/thierry.reding/linux-pwm:
      pwm: stm32: Fix build warning with CONFIG_DMA_ENGINE disabled
      pwm: stm32: Enforce dependency on CONFIG_MFD_STM32_TIMERS
      ACPI / LPSS: Add missing prv_offset setting for byt/cht PWM devices
      pwm: lpss: platform: Save/restore the ctrl register over a suspend/resume
      dt-bindings: mfd: stm32-timers: Add support for dmas
      pwm: simplify getting .drvdata
      pwm: meson: Fix allocation of PWM channel array

commit fdcb613d49321b5bf5d5a1bd0fba8e7c241dcc70
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Apr 26 14:10:24 2018 +0200

    ACPI / LPSS: Add missing prv_offset setting for byt/cht PWM devices
    
    The LPSS PWM device on on Bay Trail and Cherry Trail devices has a set
    of private registers at offset 0x800, the current lpss_device_desc for
    them already sets the LPSS_SAVE_CTX flag to have these saved/restored
    over device-suspend, but the current lpss_device_desc was not setting
    the prv_offset field, leading to the regular device registers getting
    saved/restored instead.
    
    This is causing the PWM controller to no longer work, resulting in a black
    screen,  after a suspend/resume on systems where the firmware clears the
    APB clock and reset bits at offset 0x804.
    
    This commit fixes this by properly setting prv_offset to 0x800 for
    the PWM devices.
    
    Cc: stable@vger.kernel.org
    Fixes: e1c748179754 ("ACPI / LPSS: Add Intel BayTrail ACPI mode PWM")
    Fixes: 1bfbd8eb8a7f ("ACPI / LPSS: Add ACPI IDs for Intel Braswell")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Rafael J . Wysocki <rjw@rjwysocki.net>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 2bcffec8dbf0..c4ba9164e582 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -229,11 +229,13 @@ static const struct lpss_device_desc lpt_sdio_dev_desc = {
 
 static const struct lpss_device_desc byt_pwm_dev_desc = {
 	.flags = LPSS_SAVE_CTX,
+	.prv_offset = 0x800,
 	.setup = byt_pwm_setup,
 };
 
 static const struct lpss_device_desc bsw_pwm_dev_desc = {
 	.flags = LPSS_SAVE_CTX | LPSS_NO_D3_DELAY,
+	.prv_offset = 0x800,
 	.setup = bsw_pwm_setup,
 };
 

commit c975e472ec12392a0c34de1350e634310f8a1dea
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Apr 13 14:54:17 2018 +0200

    ACPI / LPSS: Only call pwm_add_table() for Bay Trail PWM if PMIC HRV is 2
    
    The Point of View mobii wintab p800w Bay Trail tablet comes with a Crystal
    Cove PMIC, yet uses the LPSS PWM for backlight control, rather then the
    Crystal Cove's PWM, so we need to call pwm_add_table() to add a
    pwm_backlight mapping for the LPSS pwm despite there being an INT33FD
    ACPI device present.
    
    On all Bay Trail devices the _HRV object of the INT33FD ACPI device
    will normally return 2, to indicate the Bay Trail variant of the CRC
    PMIC is present, except on this tablet where _HRV is 0xffff. I guess this
    is a hack to make the windows Crystal Cove PWM driver not bind.
    
    Out of the 44 DSTDs with an INT33FD device in there which I have (from
    different model devices) only the pov mobii wintab p800w uses 0xffff for
    the HRV.
    
    The byt_pwm_setup code calls acpi_dev_present to check for the presence
    of a INT33FD ACPI device which indicates that a CRC PMIC is present and
    if the INT33FD ACPI device is present then byt_pwm_setup will not add
    a pwm_backlight mapping for the LPSS pwm, so that the CRC PWM will get
    used instead.
    
    acpi_dev_present has a hrv parameter, this commit make us pass 2 instead
    of -1, so that things still match on normal tablets, but on this special
    case with its _HRV of 0xffff, the check will now fail so that the
    pwm_backlight mapping for the LPSS pwm gets added fixing backlight
    brightness control on this device.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 2bcffec8dbf0..cb6ac5c65c2e 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -69,6 +69,10 @@ ACPI_MODULE_NAME("acpi_lpss");
 #define LPSS_SAVE_CTX			BIT(4)
 #define LPSS_NO_D3_DELAY		BIT(5)
 
+/* Crystal Cove PMIC shares same ACPI ID between different platforms */
+#define BYT_CRC_HRV			2
+#define CHT_CRC_HRV			3
+
 struct lpss_private_data;
 
 struct lpss_device_desc {
@@ -162,7 +166,7 @@ static void byt_pwm_setup(struct lpss_private_data *pdata)
 	if (!adev->pnp.unique_id || strcmp(adev->pnp.unique_id, "1"))
 		return;
 
-	if (!acpi_dev_present("INT33FD", NULL, -1))
+	if (!acpi_dev_present("INT33FD", NULL, BYT_CRC_HRV))
 		pwm_add_table(byt_pwm_lookup, ARRAY_SIZE(byt_pwm_lookup));
 }
 

commit e1681599345b8466786b6e54a2db2a00a068a3f3
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Jan 14 21:01:48 2018 +0100

    ACPI / LPSS: Do not instiate platform_dev for devs without MMIO resources
    
    acpi_lpss_create_device() skips handling LPSS devices which do not have
    a mmio resources in their resource list (typically these devices are
    disabled by the firmware). But since the LPSS code does not bind to the
    device, acpi_bus_attach() ends up still creating a platform device for
    it and the regular platform_driver for the ACPI HID still tries to bind
    to it.
    
    This happens e.g. on some boards which do not use the pwm-controller
    and have an empty or invalid resource-table for it. Currently this causes
    these error messages to get logged:
    
    [    3.281966] pwm-lpss 80862288:00: invalid resource
    [    3.287098] pwm-lpss: probe of 80862288:00 failed with error -22
    
    This commit stops the undesirable creation of a platform_device for
    disabled LPSS devices by setting pnp.type.platform_id to 0. Note that
    acpi_scan_attach_handler() also sets pnp.type.platform_id to 0 when there
    is a matching handler for the device and that handler has no attach
    callback, so we simply behave as a handler without an attach function
    in this case.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index d78c57a95b86..2bcffec8dbf0 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -601,6 +601,8 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 	acpi_dev_free_resource_list(&resource_list);
 
 	if (!pdata->mmio_base) {
+		/* Avoid acpi_bus_attach() instantiating a pdev for this dev. */
+		adev->pnp.type.platform_id = 0;
 		/* Skip the device, but continue the namespace scan. */
 		ret = 0;
 		goto err_out;

commit e6ce0ce34f657795fef6536edd24df81d6f2ba81
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Dec 15 14:48:47 2017 +0200

    ACPI / LPSS: Add device link for CHT SD card dependency on I2C
    
    Some Cherry Trail boards have a dependency between the SDHCI host
    controller used for SD cards and an external PMIC accessed via I2C. Add a
    device link between the SDHCI host controller (consumer) and the I2C
    adapter (supplier).
    
    This patch depends on a fix to devices links, namely commit 0ff26c662d5f
    ("driver core: Fix device link deferred probe"). And also either,
    commit 126dbc6b49c8 ("PM: i2c-designware-platdrv: Clean up PM handling in
    probe"), or patch "PM / runtime: Fix handling of suppliers with disabled
    runtime PM".
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 7f2b02cc8ea1..d78c57a95b86 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -427,6 +427,142 @@ static int register_device_clock(struct acpi_device *adev,
 	return 0;
 }
 
+struct lpss_device_links {
+	const char *supplier_hid;
+	const char *supplier_uid;
+	const char *consumer_hid;
+	const char *consumer_uid;
+	u32 flags;
+};
+
+/*
+ * The _DEP method is used to identify dependencies but instead of creating
+ * device links for every handle in _DEP, only links in the following list are
+ * created. That is necessary because, in the general case, _DEP can refer to
+ * devices that might not have drivers, or that are on different buses, or where
+ * the supplier is not enumerated until after the consumer is probed.
+ */
+static const struct lpss_device_links lpss_device_links[] = {
+	{"808622C1", "7", "80860F14", "3", DL_FLAG_PM_RUNTIME},
+};
+
+static bool hid_uid_match(const char *hid1, const char *uid1,
+			  const char *hid2, const char *uid2)
+{
+	return !strcmp(hid1, hid2) && uid1 && uid2 && !strcmp(uid1, uid2);
+}
+
+static bool acpi_lpss_is_supplier(struct acpi_device *adev,
+				  const struct lpss_device_links *link)
+{
+	return hid_uid_match(acpi_device_hid(adev), acpi_device_uid(adev),
+			     link->supplier_hid, link->supplier_uid);
+}
+
+static bool acpi_lpss_is_consumer(struct acpi_device *adev,
+				  const struct lpss_device_links *link)
+{
+	return hid_uid_match(acpi_device_hid(adev), acpi_device_uid(adev),
+			     link->consumer_hid, link->consumer_uid);
+}
+
+struct hid_uid {
+	const char *hid;
+	const char *uid;
+};
+
+static int match_hid_uid(struct device *dev, void *data)
+{
+	struct acpi_device *adev = ACPI_COMPANION(dev);
+	struct hid_uid *id = data;
+
+	if (!adev)
+		return 0;
+
+	return hid_uid_match(acpi_device_hid(adev), acpi_device_uid(adev),
+			     id->hid, id->uid);
+}
+
+static struct device *acpi_lpss_find_device(const char *hid, const char *uid)
+{
+	struct hid_uid data = {
+		.hid = hid,
+		.uid = uid,
+	};
+
+	return bus_find_device(&platform_bus_type, NULL, &data, match_hid_uid);
+}
+
+static bool acpi_lpss_dep(struct acpi_device *adev, acpi_handle handle)
+{
+	struct acpi_handle_list dep_devices;
+	acpi_status status;
+	int i;
+
+	if (!acpi_has_method(adev->handle, "_DEP"))
+		return false;
+
+	status = acpi_evaluate_reference(adev->handle, "_DEP", NULL,
+					 &dep_devices);
+	if (ACPI_FAILURE(status)) {
+		dev_dbg(&adev->dev, "Failed to evaluate _DEP.\n");
+		return false;
+	}
+
+	for (i = 0; i < dep_devices.count; i++) {
+		if (dep_devices.handles[i] == handle)
+			return true;
+	}
+
+	return false;
+}
+
+static void acpi_lpss_link_consumer(struct device *dev1,
+				    const struct lpss_device_links *link)
+{
+	struct device *dev2;
+
+	dev2 = acpi_lpss_find_device(link->consumer_hid, link->consumer_uid);
+	if (!dev2)
+		return;
+
+	if (acpi_lpss_dep(ACPI_COMPANION(dev2), ACPI_HANDLE(dev1)))
+		device_link_add(dev2, dev1, link->flags);
+
+	put_device(dev2);
+}
+
+static void acpi_lpss_link_supplier(struct device *dev1,
+				    const struct lpss_device_links *link)
+{
+	struct device *dev2;
+
+	dev2 = acpi_lpss_find_device(link->supplier_hid, link->supplier_uid);
+	if (!dev2)
+		return;
+
+	if (acpi_lpss_dep(ACPI_COMPANION(dev1), ACPI_HANDLE(dev2)))
+		device_link_add(dev1, dev2, link->flags);
+
+	put_device(dev2);
+}
+
+static void acpi_lpss_create_device_links(struct acpi_device *adev,
+					  struct platform_device *pdev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(lpss_device_links); i++) {
+		const struct lpss_device_links *link = &lpss_device_links[i];
+
+		if (acpi_lpss_is_supplier(adev, link))
+			acpi_lpss_link_consumer(&pdev->dev, link);
+
+		if (acpi_lpss_is_consumer(adev, link))
+			acpi_lpss_link_supplier(&pdev->dev, link);
+	}
+}
+
 static int acpi_lpss_create_device(struct acpi_device *adev,
 				   const struct acpi_device_id *id)
 {
@@ -500,6 +636,7 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 	adev->driver_data = pdata;
 	pdev = acpi_create_platform_device(adev, dev_desc->properties);
 	if (!IS_ERR_OR_NULL(pdev)) {
+		acpi_lpss_create_device_links(adev, pdev);
 		return 1;
 	}
 

commit 04ed510988f278a69872b4cdb426e565e3236215
Merge: bd2cd7d5a8f8 eb5fcc3134b5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 20:08:22 2017 -0800

    Merge tag 'acpi-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI updates from Rafael Wysocki:
     "These update ACPICA to upstream revision 20170831, fix APEI to use the
      fixmap instead of ioremap_page_range(), add an operation region driver
      for TI PMIC TPS68470, add support for PCC subspace IDs to the ACPI
      CPPC driver, fix a few assorted issues and clean up some code.
    
      Specifics:
    
       - Update the ACPICA code to upstream revision 20170831 including
          * PDTT table header support (Bob Moore).
          * Cleanup and extension of internal string-to-integer conversion
            functions (Bob Moore).
          * Support for 64-bit hardware accesses (Lv Zheng).
          * ACPI PM Timer code adjustment to deal with 64-bit return values
            of acpi_hw_read() (Bob Moore).
          * Support for deferred table verification in acpiexec (Lv Zheng).
    
       - Fix APEI to use the fixmap instead of ioremap_page_range() which
         cannot work correctly the way the code in there attempted to use it
         and drop some code that's not necessary any more after that change
         (James Morse).
    
       - Clean up the APEI support code and make it use 64-bit timestamps
         (Arnd Bergmann, Dongjiu Geng, Jan Beulich).
    
       - Add operation region driver for TI PMIC TPS68470 (Rajmohan Mani).
    
       - Add support for PCC subspace IDs to the ACPI CPPC driver (George
         Cherian).
    
       - Fix an ACPI EC driver regression related to the handling of EC
         events during the "noirq" phases of system suspend/resume (Lv
         Zheng).
    
       - Delay the initialization of the lid state in the ACPI button driver
         to fix issues appearing on some systems (Hans de Goede).
    
       - Extend the KIOX000A "device always present" quirk to cover all
         affected BIOS versions (Hans de Goede).
    
       - Clean up some code in the ACPI core and drivers (Colin Ian King,
         Gustavo Silva)"
    
    * tag 'acpi-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (24 commits)
      ACPI: Mark expected switch fall-throughs
      ACPI / LPSS: Remove redundant initialization of clk
      ACPI / CPPC: Make CPPC ACPI driver aware of PCC subspace IDs
      mailbox: PCC: Move the MAX_PCC_SUBSPACES definition to header file
      ACPI / sysfs: Make function param_set_trace_method_name() static
      ACPI / button: Delay acpi_lid_initialize_state() until first user space open
      ACPI / EC: Fix regression related to triggering source of EC event handling
      APEI / ERST: use 64-bit timestamps
      ACPI / APEI: Remove arch_apei_flush_tlb_one()
      arm64: mm: Remove arch_apei_flush_tlb_one()
      ACPI / APEI: Remove ghes_ioremap_area
      ACPI / APEI: Replace ioremap_page_range() with fixmap
      ACPI / APEI: remove the unused dead-code for SEA/NMI notification type
      ACPI / x86: Extend KIOX000A quirk to cover all affected BIOS versions
      ACPI / APEI: adjust a local variable type in ghes_ioremap_pfn_irq()
      ACPICA: Update version to 20170831
      ACPICA: Update acpi_get_timer for 64-bit interface to acpi_hw_read
      ACPICA: String conversions: Update to add new behaviors
      ACPICA: String conversions: Cleanup/format comments. No functional changes
      ACPICA: Restructure/cleanup all string-to-integer conversion functions
      ...

commit 71c50dbe1f4e5b964786e3680f4b92df9ccc630b
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sun Oct 15 12:50:34 2017 +0100

    ACPI / LPSS: Remove redundant initialization of clk
    
    The pointer clk is being initialized to ERR_PTR(-ENODEV) however
    this value is never read before it is set to clk_data->clk. Thus
    the initialization is redundant and can be mored.
    
    Cleans up clang warning:
    Value stored to 'clk' during its initialization is never read
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 032ae44710e5..6633bc8e5846 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -362,7 +362,7 @@ static int register_device_clock(struct acpi_device *adev,
 {
 	const struct lpss_device_desc *dev_desc = pdata->dev_desc;
 	const char *devname = dev_name(&adev->dev);
-	struct clk *clk = ERR_PTR(-ENODEV);
+	struct clk *clk;
 	struct lpss_clk_data *clk_data;
 	const char *parent, *clk_name;
 	void __iomem *prv_base;

commit 05087360fd7acf2cc9b7bbb243c12765c44c7693
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Oct 27 10:10:16 2017 +0200

    ACPI / PM: Take SMART_SUSPEND driver flag into account
    
    Make the ACPI PM domain take DPM_FLAG_SMART_SUSPEND into account in
    its system suspend callbacks.
    
    [Note that the pm_runtime_suspended() check in acpi_dev_needs_resume()
    is an optimization, because if is not passed, all of the subsequent
    checks may be skipped and some of them are much more overhead in
    general.]
    
    Also use the observation that if the device is in runtime suspend
    at the beginning of the "late" phase of a system-wide suspend-like
    transition, its state cannot change going forward (runtime PM is
    disabled for it at that time) until the transition is over and the
    subsequent system-wide PM callbacks should be skipped for it (as
    they generally assume the device to not be suspended), so add
    checks for that in acpi_subsys_suspend_late/noirq() and
    acpi_subsys_freeze_late/noirq().
    
    Moreover, if acpi_subsys_resume_noirq() is called during the
    subsequent system-wide resume transition and if the device was left
    in runtime suspend previously, its runtime PM status needs to be
    changed to "active" as it is going to be put into the full-power
    state going forward, so add a check for that too in there.
    
    In turn, if acpi_subsys_thaw_noirq() runs after the device has been
    left in runtime suspend, the subsequent "thaw" callbacks need
    to be skipped for it (as they may not work correctly with a
    suspended device), so set the power.direct_complete flag for the
    device then to make the PM core skip those callbacks.
    
    On top of the above, make the analogous changes in the acpi_lpss
    driver that uses the ACPI PM domain callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 04d32bdb5a95..de7385b824e1 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -849,8 +849,12 @@ static int acpi_lpss_resume(struct device *dev)
 #ifdef CONFIG_PM_SLEEP
 static int acpi_lpss_suspend_late(struct device *dev)
 {
-	int ret = pm_generic_suspend_late(dev);
+	int ret;
+
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		return 0;
 
+	ret = pm_generic_suspend_late(dev);
 	return ret ? ret : acpi_lpss_suspend(dev, device_may_wakeup(dev));
 }
 
@@ -889,10 +893,17 @@ static struct dev_pm_domain acpi_lpss_pm_domain = {
 		.complete = acpi_subsys_complete,
 		.suspend = acpi_subsys_suspend,
 		.suspend_late = acpi_lpss_suspend_late,
+		.suspend_noirq = acpi_subsys_suspend_noirq,
+		.resume_noirq = acpi_subsys_resume_noirq,
 		.resume_early = acpi_lpss_resume_early,
 		.freeze = acpi_subsys_freeze,
+		.freeze_late = acpi_subsys_freeze_late,
+		.freeze_noirq = acpi_subsys_freeze_noirq,
+		.thaw_noirq = acpi_subsys_thaw_noirq,
 		.poweroff = acpi_subsys_suspend,
 		.poweroff_late = acpi_lpss_suspend_late,
+		.poweroff_noirq = acpi_subsys_suspend_noirq,
+		.restore_noirq = acpi_subsys_resume_noirq,
 		.restore_early = acpi_lpss_resume_early,
 #endif
 		.runtime_suspend = acpi_lpss_runtime_suspend,

commit a192aa923b66a435aae56983c4912ee150bc9b32
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Oct 16 03:29:55 2017 +0200

    ACPI / LPSS: Consolidate runtime PM and system sleep handling
    
    Move the LPSS-specific code from acpi_lpss_runtime_suspend()
    and acpi_lpss_runtime_resume() into separate functions,
    acpi_lpss_suspend() and acpi_lpss_resume(), respectively, and
    make acpi_lpss_suspend_late() and acpi_lpss_resume_early() use
    them too in order to unify the runtime PM and system sleep
    handling in the LPSS driver.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 8ec19e7c7b61..04d32bdb5a95 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -716,40 +716,6 @@ static void acpi_lpss_dismiss(struct device *dev)
 	acpi_dev_suspend(dev, false);
 }
 
-#ifdef CONFIG_PM_SLEEP
-static int acpi_lpss_suspend_late(struct device *dev)
-{
-	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
-	int ret;
-
-	ret = pm_generic_suspend_late(dev);
-	if (ret)
-		return ret;
-
-	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
-		acpi_lpss_save_ctx(dev, pdata);
-
-	return acpi_dev_suspend(dev, device_may_wakeup(dev));
-}
-
-static int acpi_lpss_resume_early(struct device *dev)
-{
-	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
-	int ret;
-
-	ret = acpi_dev_resume(dev);
-	if (ret)
-		return ret;
-
-	acpi_lpss_d3_to_d0_delay(pdata);
-
-	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
-		acpi_lpss_restore_ctx(dev, pdata);
-
-	return pm_generic_resume_early(dev);
-}
-#endif /* CONFIG_PM_SLEEP */
-
 /* IOSF SB for LPSS island */
 #define LPSS_IOSF_UNIT_LPIOEP		0xA0
 #define LPSS_IOSF_UNIT_LPIO1		0xAB
@@ -835,19 +801,15 @@ static void lpss_iosf_exit_d3_state(void)
 	mutex_unlock(&lpss_iosf_mutex);
 }
 
-static int acpi_lpss_runtime_suspend(struct device *dev)
+static int acpi_lpss_suspend(struct device *dev, bool wakeup)
 {
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
 	int ret;
 
-	ret = pm_generic_runtime_suspend(dev);
-	if (ret)
-		return ret;
-
 	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
 		acpi_lpss_save_ctx(dev, pdata);
 
-	ret = acpi_dev_suspend(dev, true);
+	ret = acpi_dev_suspend(dev, wakeup);
 
 	/*
 	 * This call must be last in the sequence, otherwise PMC will return
@@ -860,7 +822,7 @@ static int acpi_lpss_runtime_suspend(struct device *dev)
 	return ret;
 }
 
-static int acpi_lpss_runtime_resume(struct device *dev)
+static int acpi_lpss_resume(struct device *dev)
 {
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
 	int ret;
@@ -881,7 +843,37 @@ static int acpi_lpss_runtime_resume(struct device *dev)
 	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
 		acpi_lpss_restore_ctx(dev, pdata);
 
-	return pm_generic_runtime_resume(dev);
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int acpi_lpss_suspend_late(struct device *dev)
+{
+	int ret = pm_generic_suspend_late(dev);
+
+	return ret ? ret : acpi_lpss_suspend(dev, device_may_wakeup(dev));
+}
+
+static int acpi_lpss_resume_early(struct device *dev)
+{
+	int ret = acpi_lpss_resume(dev);
+
+	return ret ? ret : pm_generic_resume_early(dev);
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static int acpi_lpss_runtime_suspend(struct device *dev)
+{
+	int ret = pm_generic_runtime_suspend(dev);
+
+	return ret ? ret : acpi_lpss_suspend(dev, true);
+}
+
+static int acpi_lpss_runtime_resume(struct device *dev)
+{
+	int ret = acpi_lpss_resume(dev);
+
+	return ret ? ret : pm_generic_runtime_resume(dev);
 }
 #endif /* CONFIG_PM */
 

commit cbe25ce37d6c2623b5ac09128987e98848a54c6c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Oct 14 17:43:15 2017 +0200

    ACPI / PM: Combine device suspend routines
    
    On top of a previous change getting rid of the PM QoS flag
    PM_QOS_FLAG_REMOTE_WAKEUP, combine two ACPI device suspend routines,
    acpi_dev_runtime_suspend() and acpi_dev_suspend_late(), into one,
    acpi_dev_suspend(), to eliminate some code duplication.
    
    It also avoids enabling wakeup for devices handled by the ACPI
    LPSS middle layer on driver removal.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 97b753dd2e6e..8ec19e7c7b61 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -713,7 +713,7 @@ static int acpi_lpss_activate(struct device *dev)
 
 static void acpi_lpss_dismiss(struct device *dev)
 {
-	acpi_dev_runtime_suspend(dev);
+	acpi_dev_suspend(dev, false);
 }
 
 #ifdef CONFIG_PM_SLEEP
@@ -729,7 +729,7 @@ static int acpi_lpss_suspend_late(struct device *dev)
 	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
 		acpi_lpss_save_ctx(dev, pdata);
 
-	return acpi_dev_suspend_late(dev);
+	return acpi_dev_suspend(dev, device_may_wakeup(dev));
 }
 
 static int acpi_lpss_resume_early(struct device *dev)
@@ -847,7 +847,7 @@ static int acpi_lpss_runtime_suspend(struct device *dev)
 	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
 		acpi_lpss_save_ctx(dev, pdata);
 
-	ret = acpi_dev_runtime_suspend(dev);
+	ret = acpi_dev_suspend(dev, true);
 
 	/*
 	 * This call must be last in the sequence, otherwise PMC will return

commit e4da817d2acbd05217adc0dc821bc8361e86ee30
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Oct 3 09:11:06 2017 +0200

    ACPI / PM: Restore acpi_subsys_complete()
    
    Commit 58a1fbbb2ee8 (PM / PCI / ACPI: Kick devices that might have
    been reset by firmware), made PCI's and ACPI's ->complete() callbacks
    to be assigned to a new API called pm_complete_with_resume_check(),
    which was introduced in the same change.
    
    Later it turned out that using pm_complete_with_resume_check() wasn't
    good enough for PCI, as it needed additional PCI specific checks,
    before deciding whether runtime resuming the device is needed when
    running the ->complete() callback.
    
    This leaves ACPI as the only user of pm_complete_with_resume_check().
    Therefore let's restore ACPI's acpi_subsys_complete(), which was
    dropped in commit 58a1fbbb2ee8 (PM / PCI / ACPI: Kick devices that
    might have been reset by firmware).
    
    This enables us to remove the pm_complete_with_resume_check() API in
    a following change, but it also enables ACPI to add more ACPI
    specific checks in acpi_subsys_complete() if that turns out to be
    necessary.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 81b6096c4177..97b753dd2e6e 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -894,7 +894,7 @@ static struct dev_pm_domain acpi_lpss_pm_domain = {
 #ifdef CONFIG_PM
 #ifdef CONFIG_PM_SLEEP
 		.prepare = acpi_subsys_prepare,
-		.complete = pm_complete_with_resume_check,
+		.complete = acpi_subsys_complete,
 		.suspend = acpi_subsys_suspend,
 		.suspend_late = acpi_lpss_suspend_late,
 		.resume_early = acpi_lpss_resume_early,

commit 63705c406a8adbd6f26691148b09d466dd4d8d2f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Oct 10 18:49:22 2017 +0200

    ACPI / PM: Combine two identical device resume routines
    
    Notice that acpi_dev_runtime_resume() and acpi_dev_resume_early() are
    actually literally identical after some more-or-less recent changes,
    so rename acpi_dev_runtime_resume() to acpi_dev_resume(), use it
    everywhere instead of acpi_dev_resume_early() and drop the latter.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 032ae44710e5..81b6096c4177 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -693,7 +693,7 @@ static int acpi_lpss_activate(struct device *dev)
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
 	int ret;
 
-	ret = acpi_dev_runtime_resume(dev);
+	ret = acpi_dev_resume(dev);
 	if (ret)
 		return ret;
 
@@ -737,7 +737,7 @@ static int acpi_lpss_resume_early(struct device *dev)
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
 	int ret;
 
-	ret = acpi_dev_resume_early(dev);
+	ret = acpi_dev_resume(dev);
 	if (ret)
 		return ret;
 
@@ -872,7 +872,7 @@ static int acpi_lpss_runtime_resume(struct device *dev)
 	if (lpss_quirks & LPSS_QUIRK_ALWAYS_POWER_ON && iosf_mbi_available())
 		lpss_iosf_exit_d3_state();
 
-	ret = acpi_dev_runtime_resume(dev);
+	ret = acpi_dev_resume(dev);
 	if (ret)
 		return ret;
 

commit a4bb2b4933557a8afdfe7a930cd68bd31e34a078
Author: Ronald Tschalär <ronald@innovation.ch>
Date:   Wed Aug 9 01:15:42 2017 -0700

    ACPI / LPSS: Don't abort ACPI scan on missing mem resource
    
    The keyboard and touchpad on MacBook's from 2015 onwards are connected
    via an SPI bus. On MacBook8's (2015) the ACPI device for the SPI master
    for this bus has _CID "INT33C1", and hence the acpi-lpss handler here is
    triggered for it. However, the DSDT lists no memory resources for this
    device, resulting in an error being returned by the attach callback and
    therefore the SPI master device being ignored. This prevents us from
    being able to register the keyboard and touchpad driver.
    
    Furthermore, the controller (a Wildcat Point-LP controller) does not
    appear to need the functionality provided by the apci-lpss handler.
    Therefore we now just skip the handler if no memory resources are found
    and let the ACPI scan complete successfully for this device.
    
    All of this is not an issue on later MacBook(Pro)'s because their ACPI
    SPI devices don't have any _CID and therefore no attempt is made to attach
    this handler.
    
    Returning an error was introduced in commit d3e13ff3c1aa - this restores
    the original behaviour.
    
    Link: https://github.com/cb22/macbook12-spi-driver
    Signed-off-by: Ronald Tschalär <ronald@innovation.ch>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index f88caf5aab76..032ae44710e5 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -465,7 +465,8 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 	acpi_dev_free_resource_list(&resource_list);
 
 	if (!pdata->mmio_base) {
-		ret = -ENOMEM;
+		/* Skip the device, but continue the namespace scan. */
+		ret = 0;
 		goto err_out;
 	}
 

commit 3de559d4df546442e28fab91e1c9cab3f19ca24f
Merge: 16f73eb02d7e f7f3dd5b4cbb 31e86cb99a3a ecfc1599ef87
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 3 20:30:18 2017 +0200

    Merge branches 'acpi-soc', 'acpi-wdat' and 'acpi-cppc'
    
    * acpi-soc:
      ACPI: APD: Fix HID for Hisilicon Hip07/08
      ACPI / LPSS: Only call pwm_add_table() for the first PWM controller
    
    * acpi-wdat:
      ACPI / watchdog: Fix init failure with overlapping register regions
    
    * acpi-cppc:
      mailbox: pcc: Fix crash when request PCC channel 0

commit dd242a080d178c36442a0bb28b6acf6f126d0569
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Jul 6 18:49:27 2017 +0200

    ACPI / LPSS: Only call pwm_add_table() for the first PWM controller
    
    At least on the UP board SBC both PWMs are enabled leading to us
    trying to add the same pwm_lookup twice, which leads to the following:
    
    [    0.902224] list_add double add: new=ffffffffb8efd400,
                   prev=ffffffffb8efd400, next=ffffffffb8eeede0.
    [    0.912466] ------------[ cut here ]------------
    [    0.917624] kernel BUG at lib/list_debug.c:31!
    [    0.922588] invalid opcode: 0000 [#1] SMP
    ...
    [    1.027450] Call Trace:
    [    1.030185]  pwm_add_table+0x4c/0x90
    [    1.034181]  bsw_pwm_setup+0x1a/0x20
    [    1.038175]  acpi_lpss_create_device+0xfe/0x420
    ...
    
    This commit fixes this by only calling pwm_add_table() for the first
    PWM controller (which is the one used for the backlight).
    
    Link: https://bugzilla.redhat.com/show_bug.cgi?id=1458599
    Fixes: bf7696a12071 (acpi: lpss: call pwm_add_table() for BSW...)
    Fixes: 04434ab5120a (ACPI / LPSS: Call pwm_add_table() for Bay Trail...)
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: 4.11+ <stable@vger.kernel.org> # 4.11+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 10347e3d73ad..5bd58bd4ab05 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -85,6 +85,7 @@ static const struct lpss_device_desc lpss_dma_desc = {
 };
 
 struct lpss_private_data {
+	struct acpi_device *adev;
 	void __iomem *mmio_base;
 	resource_size_t mmio_size;
 	unsigned int fixed_clk_rate;
@@ -155,6 +156,12 @@ static struct pwm_lookup byt_pwm_lookup[] = {
 
 static void byt_pwm_setup(struct lpss_private_data *pdata)
 {
+	struct acpi_device *adev = pdata->adev;
+
+	/* Only call pwm_add_table for the first PWM controller */
+	if (!adev->pnp.unique_id || strcmp(adev->pnp.unique_id, "1"))
+		return;
+
 	if (!acpi_dev_present("INT33FD", NULL, -1))
 		pwm_add_table(byt_pwm_lookup, ARRAY_SIZE(byt_pwm_lookup));
 }
@@ -180,6 +187,12 @@ static struct pwm_lookup bsw_pwm_lookup[] = {
 
 static void bsw_pwm_setup(struct lpss_private_data *pdata)
 {
+	struct acpi_device *adev = pdata->adev;
+
+	/* Only call pwm_add_table for the first PWM controller */
+	if (!adev->pnp.unique_id || strcmp(adev->pnp.unique_id, "1"))
+		return;
+
 	pwm_add_table(bsw_pwm_lookup, ARRAY_SIZE(bsw_pwm_lookup));
 }
 
@@ -456,6 +469,7 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 		goto err_out;
 	}
 
+	pdata->adev = adev;
 	pdata->dev_desc = dev_desc;
 
 	if (dev_desc->setup)

commit 31945d0eb400f793feff61423db71cb6d866715a
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Jun 30 18:23:50 2017 +0530

    ACPI / LPSS: constify attribute_group structures
    
    attribute_groups are not supposed to change at runtime. All functions
    working with attribute_groups provided by <linux/sysfs.h> work with const
    attribute_group. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 10347e3d73ad..e51a1e98e62f 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -576,7 +576,7 @@ static struct attribute *lpss_attrs[] = {
 	NULL,
 };
 
-static struct attribute_group lpss_attr_group = {
+static const struct attribute_group lpss_attr_group = {
 	.attrs = lpss_attrs,
 	.name = "lpss_ltr",
 };

commit 04434ab5120a362c11ae6e6cf196fc6a98c3365d
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Apr 21 09:35:07 2017 +0200

    ACPI / LPSS: Call pwm_add_table() for Bay Trail PWM device
    
    On Bay Trail systems with a Crystal Cove PMIC the Crystal Cove's PWM is
    used to control the backlight brightness. On systems without one, the
    Crystal Cove SoC's PWM is used and we need to call pwm_add_table() so
    that the i915 driver can find the pwm for controlling the backlight.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 5edfd9c49044..10347e3d73ad 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -143,6 +143,22 @@ static void lpss_deassert_reset(struct lpss_private_data *pdata)
 	writel(val, pdata->mmio_base + offset);
 }
 
+/*
+ * BYT PWM used for backlight control by the i915 driver on systems without
+ * the Crystal Cove PMIC.
+ */
+static struct pwm_lookup byt_pwm_lookup[] = {
+	PWM_LOOKUP_WITH_MODULE("80860F09:00", 0, "0000:00:02.0",
+			       "pwm_backlight", 0, PWM_POLARITY_NORMAL,
+			       "pwm-lpss-platform"),
+};
+
+static void byt_pwm_setup(struct lpss_private_data *pdata)
+{
+	if (!acpi_dev_present("INT33FD", NULL, -1))
+		pwm_add_table(byt_pwm_lookup, ARRAY_SIZE(byt_pwm_lookup));
+}
+
 #define LPSS_I2C_ENABLE			0x6c
 
 static void byt_i2c_setup(struct lpss_private_data *pdata)
@@ -200,6 +216,7 @@ static const struct lpss_device_desc lpt_sdio_dev_desc = {
 
 static const struct lpss_device_desc byt_pwm_dev_desc = {
 	.flags = LPSS_SAVE_CTX,
+	.setup = byt_pwm_setup,
 };
 
 static const struct lpss_device_desc bsw_pwm_dev_desc = {

commit 545b2820c4a48245412d97030134cc1d38918726
Merge: 3437f9f0a69c 38b0a526ec33
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 1 09:46:02 2017 -0800

    Merge tag 'pwm/for-4.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/thierry.reding/linux-pwm
    
    Pull pwm updates from Thierry Reding:
     "This set contains mostly fixes to existing drivers as well as cleanup
      of code that's not been in active use for a while"
    
    * tag 'pwm/for-4.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/thierry.reding/linux-pwm: (27 commits)
      acpi: lpss: call pwm_add_table() for BSW PWM device
      pwm: Try to load modules during pwm_get()
      pwm: Don't hold pwm_lookup_lock longer than necessary
      pwm: Make the PWM_POLARITY flag in DTB optional
      pwm: Print error messages with pr_err() instead of pr_debug()
      pwm: imx: Add polarity inversion support to i.MX's PWMv2
      pwm: imx: doc: Update imx-pwm.txt documentation entry
      pwm: imx: Remove redundant i.MX PWMv2 code
      pwm: imx: Provide atomic PWM support for i.MX PWMv2
      pwm: imx: Move PWMv2 wait for fifo slot code to a separate function
      pwm: imx: Move PWMv2 software reset code to a separate function
      pwm: imx: Rewrite v1 code to facilitate switch to atomic PWM
      pwm: imx: Add separate set of PWM ops for v1 and v2
      pwm: imx: Remove ipg clock and enable per clock when required
      pwm: lpss: Add Intel Gemini Lake PCI ID
      pwm: lpss: Do not export board infos for different PWM types
      pwm: lpss: Avoid reconfiguring while UPDATE bit is still enabled
      pwm: lpss: Switch to new atomic API
      pwm: lpss: Allow duty cycle to be 0
      pwm: lpss: Avoid potential overflow of base_unit
      ...

commit bf7696a12071afaca0139d7b8b9eadfc77252876
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Jan 22 17:14:09 2017 +0100

    acpi: lpss: call pwm_add_table() for BSW PWM device
    
    On x86 we do not have devicetree to link the PWM controller and
    the display controller together. So someone needs to call
    pwm_add_table() to create the link, so that the i915 driver's
    pwm_get(dev, "pwm_backlight") call returns the lpss' pwm0.
    
    The PWM subsystem does not want to have pwm_add_table() calls
    directly in PWM drivers (this leads to probe ordering issues),
    so lets do it here since the acpi-lpss code is always builtin.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 8ea836c046f8..cd5d2b6c9ed1 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -20,6 +20,7 @@
 #include <linux/platform_data/clk-lpss.h>
 #include <linux/pm_domain.h>
 #include <linux/pm_runtime.h>
+#include <linux/pwm.h>
 #include <linux/delay.h>
 
 #include "internal.h"
@@ -154,6 +155,18 @@ static void byt_i2c_setup(struct lpss_private_data *pdata)
 	writel(0, pdata->mmio_base + LPSS_I2C_ENABLE);
 }
 
+/* BSW PWM used for backlight control by the i915 driver */
+static struct pwm_lookup bsw_pwm_lookup[] = {
+	PWM_LOOKUP_WITH_MODULE("80862288:00", 0, "0000:00:02.0",
+			       "pwm_backlight", 0, PWM_POLARITY_NORMAL,
+			       "pwm-lpss-platform"),
+};
+
+static void bsw_pwm_setup(struct lpss_private_data *pdata)
+{
+	pwm_add_table(bsw_pwm_lookup, ARRAY_SIZE(bsw_pwm_lookup));
+}
+
 static const struct lpss_device_desc lpt_dev_desc = {
 	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_LTR,
 	.prv_offset = 0x800,
@@ -191,6 +204,7 @@ static const struct lpss_device_desc byt_pwm_dev_desc = {
 
 static const struct lpss_device_desc bsw_pwm_dev_desc = {
 	.flags = LPSS_SAVE_CTX | LPSS_NO_D3_DELAY,
+	.setup = bsw_pwm_setup,
 };
 
 static const struct lpss_device_desc byt_uart_dev_desc = {

commit 80a7581f38c0b2e83dc883a2125340b90b5635ec
Author: Irina Tirdea <irina.tirdea@intel.com>
Date:   Mon Jan 23 12:07:43 2017 -0600

    arch/x86/platform/atom: Move pmc_atom to drivers/platform/x86
    
    The pmc_atom driver does not contain any architecture specific
    code. It only enables the SoC Power Management Controller driver
    for BayTrail and CherryTrail platforms.
    
    Move the pmc_atom driver from arch/x86/platform/atom to
    drivers/platform/x86. Also clean-up and reorder include files by
    alphabetical order in pmc_atom.h
    
    Signed-off-by: Irina Tirdea <irina.tirdea@intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 8ea836c046f8..90d112a3063a 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -18,6 +18,7 @@
 #include <linux/mutex.h>
 #include <linux/platform_device.h>
 #include <linux/platform_data/clk-lpss.h>
+#include <linux/platform_data/x86/pmc_atom.h>
 #include <linux/pm_domain.h>
 #include <linux/pm_runtime.h>
 #include <linux/delay.h>
@@ -31,7 +32,6 @@ ACPI_MODULE_NAME("acpi_lpss");
 #include <asm/cpu_device_id.h>
 #include <asm/intel-family.h>
 #include <asm/iosf_mbi.h>
-#include <asm/pmc_atom.h>
 
 #define LPSS_ADDR(desc) ((unsigned long)&desc)
 

commit d2c2ba690180da366bdc5ca037c2d4f077bd5ffd
Merge: 3e16164e1509 d132d6d53e0c 2d09af4a88d9 6276e53fa8c0 501634759d55 9f9a35a7b654
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Dec 12 20:48:01 2016 +0100

    Merge branches 'acpi-soc', 'acpi-battery', 'acpi-video', 'acpi-cppc' and 'acpi-apei'
    
    * acpi-soc:
      ACPI / LPSS: enable hard LLP for DMA
      ACPI / APD: Add clock frequency for future AMD I2C controller
    
    * acpi-battery:
      ACPI / battery: If _BIX fails, retry with _BIF
    
    * acpi-video:
      ACPI / video: Add force_native quirk for HP Pavilion dv6
      ACPI / video: Add force_native quirk for Dell XPS 17 L702X
      ACPI / video: Move ACPI_VIDEO_NOTIFY_* defines to acpi/video.h
    
    * acpi-cppc:
      ACPI / CPPC: set an error code on probe error path
    
    * acpi-apei:
      ACPI / APEI / ARM64: APEI initial support for ARM64
      ACPI / APEI: Fix NMI notification handling

commit d132d6d53e0cde244d07966832f9f7f3f41a1439
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Nov 17 16:30:06 2016 +0200

    ACPI / LPSS: enable hard LLP for DMA
    
    Right now the DMA support of hard LLP (*) is fused. Enable it via specific
    message sent to SoC at run time.
    
    (*) Hard LLP stands for the multi-block transfer feature of DMA controller
    supported by hardware.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 552010288135..c4712395020c 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -724,13 +724,14 @@ static int acpi_lpss_resume_early(struct device *dev)
 #define LPSS_GPIODEF0_DMA1_D3		BIT(2)
 #define LPSS_GPIODEF0_DMA2_D3		BIT(3)
 #define LPSS_GPIODEF0_DMA_D3_MASK	GENMASK(3, 2)
+#define LPSS_GPIODEF0_DMA_LLP		BIT(13)
 
 static DEFINE_MUTEX(lpss_iosf_mutex);
 
 static void lpss_iosf_enter_d3_state(void)
 {
 	u32 value1 = 0;
-	u32 mask1 = LPSS_GPIODEF0_DMA_D3_MASK;
+	u32 mask1 = LPSS_GPIODEF0_DMA_D3_MASK | LPSS_GPIODEF0_DMA_LLP;
 	u32 value2 = LPSS_PMCSR_D3hot;
 	u32 mask2 = LPSS_PMCSR_Dx_MASK;
 	/*
@@ -774,8 +775,9 @@ static void lpss_iosf_enter_d3_state(void)
 
 static void lpss_iosf_exit_d3_state(void)
 {
-	u32 value1 = LPSS_GPIODEF0_DMA1_D3 | LPSS_GPIODEF0_DMA2_D3;
-	u32 mask1 = LPSS_GPIODEF0_DMA_D3_MASK;
+	u32 value1 = LPSS_GPIODEF0_DMA1_D3 | LPSS_GPIODEF0_DMA2_D3 |
+		     LPSS_GPIODEF0_DMA_LLP;
+	u32 mask1 = LPSS_GPIODEF0_DMA_D3_MASK | LPSS_GPIODEF0_DMA_LLP;
 	u32 value2 = LPSS_PMCSR_D0;
 	u32 mask2 = LPSS_PMCSR_Dx_MASK;
 

commit 1571875beecd5de9657f73931449bda1b1329b6f
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Thu Nov 3 16:21:26 2016 +0200

    ACPI / platform: Add support for build-in properties
    
    We have a couple of drivers, acpi_apd.c and acpi_lpss.c,
    that need to pass extra build-in properties to the devices
    they create. Previously the drivers added those properties
    to the struct device which is member of the struct
    acpi_device, but that does not work. Those properties need
    to be assigned to the struct device of the platform device
    instead in order for them to become available to the
    drivers.
    
    To fix this, this patch changes acpi_create_platform_device
    function to take struct property_entry pointer as parameter.
    
    Fixes: 20a875e2e86e (serial: 8250_dw: Add quirk for APM X-Gene SoC)
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Tested-by: Yazen Ghannam <yazen.ghannam@amd.com>
    Tested-by: Jérôme de Bretagne <jerome.debretagne@gmail.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 552010288135..373657f7e35a 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -395,7 +395,7 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 
 	dev_desc = (const struct lpss_device_desc *)id->driver_data;
 	if (!dev_desc) {
-		pdev = acpi_create_platform_device(adev);
+		pdev = acpi_create_platform_device(adev, NULL);
 		return IS_ERR_OR_NULL(pdev) ? PTR_ERR(pdev) : 1;
 	}
 	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
@@ -451,14 +451,8 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 		goto err_out;
 	}
 
-	if (dev_desc->properties) {
-		ret = device_add_properties(&adev->dev, dev_desc->properties);
-		if (ret)
-			goto err_out;
-	}
-
 	adev->driver_data = pdata;
-	pdev = acpi_create_platform_device(adev);
+	pdev = acpi_create_platform_device(adev, dev_desc->properties);
 	if (!IS_ERR_OR_NULL(pdev)) {
 		return 1;
 	}

commit a5565cf238daa6b1d5a260d844f857176d280886
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Tue Aug 23 11:33:27 2016 +0300

    ACPI / LPSS: Provide build-in properties of the UART
    
    The UART driver, dw8250.c, needs some details regarding the
    Designware UART. For ACPI enumerated devices the values are
    hard-coded, but since the driver also reads the values from
    device properties, providing them with build-in properties.
    This allows us to later remove the hard-coded values from
    the driver.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 357a0b8f860b..552010288135 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -75,6 +75,7 @@ struct lpss_device_desc {
 	const char *clk_con_id;
 	unsigned int prv_offset;
 	size_t prv_size_override;
+	struct property_entry *properties;
 	void (*setup)(struct lpss_private_data *pdata);
 };
 
@@ -163,11 +164,19 @@ static const struct lpss_device_desc lpt_i2c_dev_desc = {
 	.prv_offset = 0x800,
 };
 
+static struct property_entry uart_properties[] = {
+	PROPERTY_ENTRY_U32("reg-io-width", 4),
+	PROPERTY_ENTRY_U32("reg-shift", 2),
+	PROPERTY_ENTRY_BOOL("snps,uart-16550-compatible"),
+	{ },
+};
+
 static const struct lpss_device_desc lpt_uart_dev_desc = {
 	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_LTR,
 	.clk_con_id = "baudclk",
 	.prv_offset = 0x800,
 	.setup = lpss_uart_setup,
+	.properties = uart_properties,
 };
 
 static const struct lpss_device_desc lpt_sdio_dev_desc = {
@@ -189,6 +198,7 @@ static const struct lpss_device_desc byt_uart_dev_desc = {
 	.clk_con_id = "baudclk",
 	.prv_offset = 0x800,
 	.setup = lpss_uart_setup,
+	.properties = uart_properties,
 };
 
 static const struct lpss_device_desc bsw_uart_dev_desc = {
@@ -197,6 +207,7 @@ static const struct lpss_device_desc bsw_uart_dev_desc = {
 	.clk_con_id = "baudclk",
 	.prv_offset = 0x800,
 	.setup = lpss_uart_setup,
+	.properties = uart_properties,
 };
 
 static const struct lpss_device_desc byt_spi_dev_desc = {
@@ -440,6 +451,12 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 		goto err_out;
 	}
 
+	if (dev_desc->properties) {
+		ret = device_add_properties(&adev->dev, dev_desc->properties);
+		if (ret)
+			goto err_out;
+	}
+
 	adev->driver_data = pdata;
 	pdev = acpi_create_platform_device(adev);
 	if (!IS_ERR_OR_NULL(pdev)) {

commit 4626d840a1e0044e6f23d226ea8a5b96bd167636
Author: Dave Hansen <dave.hansen@linux.intel.com>
Date:   Thu Jun 2 17:19:46 2016 -0700

    x86/acpi/lss: Use Intel family name macros for the acpi_lpss driver
    
    Another straightforward replacement of magic numbers.
    
    Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dave Hansen <dave@sr71.net>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: jacob.jun.pan@intel.com
    Cc: linux-acpi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20160603001946.264CE704@viggo.jf.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 0872d5fecb82..357a0b8f860b 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -29,6 +29,7 @@ ACPI_MODULE_NAME("acpi_lpss");
 #ifdef CONFIG_X86_INTEL_LPSS
 
 #include <asm/cpu_device_id.h>
+#include <asm/intel-family.h>
 #include <asm/iosf_mbi.h>
 #include <asm/pmc_atom.h>
 
@@ -229,8 +230,8 @@ static const struct lpss_device_desc bsw_spi_dev_desc = {
 #define ICPU(model)	{ X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, }
 
 static const struct x86_cpu_id lpss_cpu_ids[] = {
-	ICPU(0x37),	/* Valleyview, Bay Trail */
-	ICPU(0x4c),	/* Braswell, Cherry Trail */
+	ICPU(INTEL_FAM6_ATOM_SILVERMONT1),	/* Valleyview, Bay Trail */
+	ICPU(INTEL_FAM6_ATOM_AIRMONT),	/* Braswell, Cherry Trail */
 	{}
 };
 

commit 5be6ada39f3f11a14fae9c6c328bcc78cf476e2e
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Feb 1 16:17:38 2016 +0200

    ACPI / LPSS: set PM domain via helper setter
    
    The commit 989561de9b51 ("PM / Domains: add setter for dev.pm_domain") changed
    acpi_lpss.c module to use PM domain setter, though it missed one assignment.
    Add it here.
    
    Fixes: 989561de9b51 (PM / Domains: add setter for dev.pm_domain)
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index c570b1d9f094..0872d5fecb82 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -880,7 +880,7 @@ static int acpi_lpss_platform_notify(struct notifier_block *nb,
 		break;
 	case BUS_NOTIFY_DRIVER_NOT_BOUND:
 	case BUS_NOTIFY_UNBOUND_DRIVER:
-		pdev->dev.pm_domain = NULL;
+		dev_pm_domain_set(&pdev->dev, NULL);
 		break;
 	case BUS_NOTIFY_ADD_DEVICE:
 		dev_pm_domain_set(&pdev->dev, &acpi_lpss_pm_domain);

commit 989561de9b5112999475b406557d9c7e9e59c041
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Thu Jan 7 16:46:13 2016 +0100

    PM / Domains: add setter for dev.pm_domain
    
    Adds a function that sets the pointer to dev_pm_domain in struct device
    and that warns if the device has already finished probing. The reason
    why we want to enforce that is because in the general case that can
    cause problems and also that we can simplify code quite a bit if we can
    always assume that.
    
    This patch also changes all current code that directly sets the
    dev.pm_domain pointer.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 047281a6ae11..c570b1d9f094 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -18,6 +18,7 @@
 #include <linux/mutex.h>
 #include <linux/platform_device.h>
 #include <linux/platform_data/clk-lpss.h>
+#include <linux/pm_domain.h>
 #include <linux/pm_runtime.h>
 #include <linux/delay.h>
 
@@ -875,13 +876,14 @@ static int acpi_lpss_platform_notify(struct notifier_block *nb,
 
 	switch (action) {
 	case BUS_NOTIFY_BIND_DRIVER:
-		pdev->dev.pm_domain = &acpi_lpss_pm_domain;
+		dev_pm_domain_set(&pdev->dev, &acpi_lpss_pm_domain);
 		break;
 	case BUS_NOTIFY_DRIVER_NOT_BOUND:
 	case BUS_NOTIFY_UNBOUND_DRIVER:
 		pdev->dev.pm_domain = NULL;
 		break;
 	case BUS_NOTIFY_ADD_DEVICE:
+		dev_pm_domain_set(&pdev->dev, &acpi_lpss_pm_domain);
 		if (pdata->dev_desc->flags & LPSS_LTR)
 			return sysfs_create_group(&pdev->dev.kobj,
 						  &lpss_attr_group);
@@ -889,6 +891,7 @@ static int acpi_lpss_platform_notify(struct notifier_block *nb,
 	case BUS_NOTIFY_DEL_DEVICE:
 		if (pdata->dev_desc->flags & LPSS_LTR)
 			sysfs_remove_group(&pdev->dev.kobj, &lpss_attr_group);
+		dev_pm_domain_set(&pdev->dev, NULL);
 		break;
 	default:
 		break;

commit fa9e93b11c6716b115f485f03930fa5a5c529e14
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Dec 21 22:31:09 2015 +0200

    ACPI / LPSS: change 'does not have' to 'has' in comment
    
    The LPSS DMA device has neither _PS0 nor _PS3 method. Fix the wording in
    the comment line.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 84d3d90557d1..047281a6ae11 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -95,7 +95,7 @@ static unsigned int lpss_quirks;
 /*
  * LPSS_QUIRK_ALWAYS_POWER_ON: override power state for LPSS DMA device.
  *
- * The LPSS DMA controller does not have neither _PS0 nor _PS3 method. Moreover
+ * The LPSS DMA controller has neither _PS0 nor _PS3 method. Moreover
  * it can be powered off automatically whenever the last LPSS device goes down.
  * In case of no power any access to the DMA controller will hang the system.
  * The behaviour is reproduced on some HP laptops based on Intel BayTrail as

commit eebb3e8d8aaf28f4bcaf12fd3645350bfd2f0b36
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Sat Dec 12 02:45:06 2015 +0100

    ACPI / LPSS: override power state for LPSS DMA device
    
    This is a third approach to workaround long standing issue with LPSS on
    BayTrail. First one [1] was reverted since it didn't resolve the issue
    comprehensively. Second one [2] was rejected by internal review.
    
    The LPSS DMA controller does not have neither _PS0 nor _PS3 method. Moreover it
    can be powered off automatically whenever the last LPSS device goes down. In
    case of no power any access to the DMA controller will hang the system. The
    behaviour is reproduced on some HP laptops based on Intel BayTrail [3,4] as
    well as on ASuS T100TA transformer.
    
    Power on the LPSS island through the registers accessible in a specific way.
    
    [1] http://www.spinics.net/lists/linux-acpi/msg53963.html
    [2] https://bugzilla.redhat.com/attachment.cgi?id=1066779&action=diff
    [3] https://bugzilla.redhat.com/show_bug.cgi?id=1184273
    [4] http://www.spinics.net/lists/dmaengine/msg01514.html
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index a10c2d665ec2..84d3d90557d1 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -15,6 +15,7 @@
 #include <linux/clk-provider.h>
 #include <linux/err.h>
 #include <linux/io.h>
+#include <linux/mutex.h>
 #include <linux/platform_device.h>
 #include <linux/platform_data/clk-lpss.h>
 #include <linux/pm_runtime.h>
@@ -26,6 +27,10 @@ ACPI_MODULE_NAME("acpi_lpss");
 
 #ifdef CONFIG_X86_INTEL_LPSS
 
+#include <asm/cpu_device_id.h>
+#include <asm/iosf_mbi.h>
+#include <asm/pmc_atom.h>
+
 #define LPSS_ADDR(desc) ((unsigned long)&desc)
 
 #define LPSS_CLK_SIZE	0x04
@@ -71,7 +76,7 @@ struct lpss_device_desc {
 	void (*setup)(struct lpss_private_data *pdata);
 };
 
-static struct lpss_device_desc lpss_dma_desc = {
+static const struct lpss_device_desc lpss_dma_desc = {
 	.flags = LPSS_CLK,
 };
 
@@ -84,6 +89,23 @@ struct lpss_private_data {
 	u32 prv_reg_ctx[LPSS_PRV_REG_COUNT];
 };
 
+/* LPSS run time quirks */
+static unsigned int lpss_quirks;
+
+/*
+ * LPSS_QUIRK_ALWAYS_POWER_ON: override power state for LPSS DMA device.
+ *
+ * The LPSS DMA controller does not have neither _PS0 nor _PS3 method. Moreover
+ * it can be powered off automatically whenever the last LPSS device goes down.
+ * In case of no power any access to the DMA controller will hang the system.
+ * The behaviour is reproduced on some HP laptops based on Intel BayTrail as
+ * well as on ASuS T100TA transformer.
+ *
+ * This quirk overrides power state of entire LPSS island to keep DMA powered
+ * on whenever we have at least one other device in use.
+ */
+#define LPSS_QUIRK_ALWAYS_POWER_ON	BIT(0)
+
 /* UART Component Parameter Register */
 #define LPSS_UART_CPR			0xF4
 #define LPSS_UART_CPR_AFCE		BIT(4)
@@ -196,13 +218,21 @@ static const struct lpss_device_desc bsw_i2c_dev_desc = {
 	.setup = byt_i2c_setup,
 };
 
-static struct lpss_device_desc bsw_spi_dev_desc = {
+static const struct lpss_device_desc bsw_spi_dev_desc = {
 	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX
 			| LPSS_NO_D3_DELAY,
 	.prv_offset = 0x400,
 	.setup = lpss_deassert_reset,
 };
 
+#define ICPU(model)	{ X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, }
+
+static const struct x86_cpu_id lpss_cpu_ids[] = {
+	ICPU(0x37),	/* Valleyview, Bay Trail */
+	ICPU(0x4c),	/* Braswell, Cherry Trail */
+	{}
+};
+
 #else
 
 #define LPSS_ADDR(desc) (0UL)
@@ -661,6 +691,89 @@ static int acpi_lpss_resume_early(struct device *dev)
 }
 #endif /* CONFIG_PM_SLEEP */
 
+/* IOSF SB for LPSS island */
+#define LPSS_IOSF_UNIT_LPIOEP		0xA0
+#define LPSS_IOSF_UNIT_LPIO1		0xAB
+#define LPSS_IOSF_UNIT_LPIO2		0xAC
+
+#define LPSS_IOSF_PMCSR			0x84
+#define LPSS_PMCSR_D0			0
+#define LPSS_PMCSR_D3hot		3
+#define LPSS_PMCSR_Dx_MASK		GENMASK(1, 0)
+
+#define LPSS_IOSF_GPIODEF0		0x154
+#define LPSS_GPIODEF0_DMA1_D3		BIT(2)
+#define LPSS_GPIODEF0_DMA2_D3		BIT(3)
+#define LPSS_GPIODEF0_DMA_D3_MASK	GENMASK(3, 2)
+
+static DEFINE_MUTEX(lpss_iosf_mutex);
+
+static void lpss_iosf_enter_d3_state(void)
+{
+	u32 value1 = 0;
+	u32 mask1 = LPSS_GPIODEF0_DMA_D3_MASK;
+	u32 value2 = LPSS_PMCSR_D3hot;
+	u32 mask2 = LPSS_PMCSR_Dx_MASK;
+	/*
+	 * PMC provides an information about actual status of the LPSS devices.
+	 * Here we read the values related to LPSS power island, i.e. LPSS
+	 * devices, excluding both LPSS DMA controllers, along with SCC domain.
+	 */
+	u32 func_dis, d3_sts_0, pmc_status, pmc_mask = 0xfe000ffe;
+	int ret;
+
+	ret = pmc_atom_read(PMC_FUNC_DIS, &func_dis);
+	if (ret)
+		return;
+
+	mutex_lock(&lpss_iosf_mutex);
+
+	ret = pmc_atom_read(PMC_D3_STS_0, &d3_sts_0);
+	if (ret)
+		goto exit;
+
+	/*
+	 * Get the status of entire LPSS power island per device basis.
+	 * Shutdown both LPSS DMA controllers if and only if all other devices
+	 * are already in D3hot.
+	 */
+	pmc_status = (~(d3_sts_0 | func_dis)) & pmc_mask;
+	if (pmc_status)
+		goto exit;
+
+	iosf_mbi_modify(LPSS_IOSF_UNIT_LPIO1, MBI_CFG_WRITE,
+			LPSS_IOSF_PMCSR, value2, mask2);
+
+	iosf_mbi_modify(LPSS_IOSF_UNIT_LPIO2, MBI_CFG_WRITE,
+			LPSS_IOSF_PMCSR, value2, mask2);
+
+	iosf_mbi_modify(LPSS_IOSF_UNIT_LPIOEP, MBI_CR_WRITE,
+			LPSS_IOSF_GPIODEF0, value1, mask1);
+exit:
+	mutex_unlock(&lpss_iosf_mutex);
+}
+
+static void lpss_iosf_exit_d3_state(void)
+{
+	u32 value1 = LPSS_GPIODEF0_DMA1_D3 | LPSS_GPIODEF0_DMA2_D3;
+	u32 mask1 = LPSS_GPIODEF0_DMA_D3_MASK;
+	u32 value2 = LPSS_PMCSR_D0;
+	u32 mask2 = LPSS_PMCSR_Dx_MASK;
+
+	mutex_lock(&lpss_iosf_mutex);
+
+	iosf_mbi_modify(LPSS_IOSF_UNIT_LPIOEP, MBI_CR_WRITE,
+			LPSS_IOSF_GPIODEF0, value1, mask1);
+
+	iosf_mbi_modify(LPSS_IOSF_UNIT_LPIO2, MBI_CFG_WRITE,
+			LPSS_IOSF_PMCSR, value2, mask2);
+
+	iosf_mbi_modify(LPSS_IOSF_UNIT_LPIO1, MBI_CFG_WRITE,
+			LPSS_IOSF_PMCSR, value2, mask2);
+
+	mutex_unlock(&lpss_iosf_mutex);
+}
+
 static int acpi_lpss_runtime_suspend(struct device *dev)
 {
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
@@ -673,7 +786,17 @@ static int acpi_lpss_runtime_suspend(struct device *dev)
 	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
 		acpi_lpss_save_ctx(dev, pdata);
 
-	return acpi_dev_runtime_suspend(dev);
+	ret = acpi_dev_runtime_suspend(dev);
+
+	/*
+	 * This call must be last in the sequence, otherwise PMC will return
+	 * wrong status for devices being about to be powered off. See
+	 * lpss_iosf_enter_d3_state() for further information.
+	 */
+	if (lpss_quirks & LPSS_QUIRK_ALWAYS_POWER_ON && iosf_mbi_available())
+		lpss_iosf_enter_d3_state();
+
+	return ret;
 }
 
 static int acpi_lpss_runtime_resume(struct device *dev)
@@ -681,6 +804,13 @@ static int acpi_lpss_runtime_resume(struct device *dev)
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
 	int ret;
 
+	/*
+	 * This call is kept first to be in symmetry with
+	 * acpi_lpss_runtime_suspend() one.
+	 */
+	if (lpss_quirks & LPSS_QUIRK_ALWAYS_POWER_ON && iosf_mbi_available())
+		lpss_iosf_exit_d3_state();
+
 	ret = acpi_dev_runtime_resume(dev);
 	if (ret)
 		return ret;
@@ -798,10 +928,19 @@ static struct acpi_scan_handler lpss_handler = {
 
 void __init acpi_lpss_init(void)
 {
-	if (!lpt_clk_init()) {
-		bus_register_notifier(&platform_bus_type, &acpi_lpss_nb);
-		acpi_scan_add_handler(&lpss_handler);
-	}
+	const struct x86_cpu_id *id;
+	int ret;
+
+	ret = lpt_clk_init();
+	if (ret)
+		return;
+
+	id = x86_match_cpu(lpss_cpu_ids);
+	if (id)
+		lpss_quirks |= LPSS_QUIRK_ALWAYS_POWER_ON;
+
+	bus_register_notifier(&platform_bus_type, &acpi_lpss_nb);
+	acpi_scan_add_handler(&lpss_handler);
 }
 
 #else

commit c3a49cf35ead83829e54fc771a3acc1b1aa6dfd8
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Dec 4 23:49:20 2015 +0200

    ACPI / LPSS: power on when probe() and otherwise when remove()
    
    When LPSS drivers are compiled as a module, which is usually the case, the
    second probe of that driver may fail because the driver is written in an
    assumption that device is powered on. That is not the case for all drivers.
    Moreover we would like not drain power in vain.
    
    Implement ->activate() and ->dismiss() callbacks in the ACPI LPSS custom power
    domain.
    
    -------- 8< -------- 8< -------- 8< -------- 8< -------- 8< --------
    
    Case 1: The I2C probe() repeat.
    
    /sys/bus/platform/devices/808622C1:00 \_SB_.PCI0.I2C1 [D3hot]
    /sys/bus/platform/devices/808622C1:01 \_SB_.PCI0.I2C2 [D3hot]
    /sys/bus/platform/devices/808622C1:02 \_SB_.PCI0.I2C3 [D3hot]
    /sys/bus/platform/devices/808622C1:03 \_SB_.PCI0.I2C4 [D3hot]
    /sys/bus/platform/devices/808622C1:05 \_SB_.PCI0.I2C6 [D3hot]
    /sys/bus/platform/devices/808622C1:06 \_SB_.PCI0.I2C7 [D3hot]
    
    % modprobe i2c-designware-platform
        i2c_designware 808622C1:00: Unknown Synopsys component type: 0xffffffff
        i2c_designware 808622C1:01: Unknown Synopsys component type: 0xffffffff
        i2c_designware 808622C1:02: Unknown Synopsys component type: 0xffffffff
        i2c_designware 808622C1:03: Unknown Synopsys component type: 0xffffffff
        i2c_designware 808622C1:05: Unknown Synopsys component type: 0xffffffff
        i2c_designware 808622C1:06: Unknown Synopsys component type: 0xffffffff
    
    Case 2: The power drain in case of SDHCI.
    
    /sys/bus/platform/devices/80860F14:00 \_SB_.PCI0.SDHA [D3hot]
    /sys/bus/platform/devices/80860F14:01 \_SB_.PCI0.SDHC [D3hot]
    
    % modprobe -r sdhci-acpi
        mmc0: card 0001 removed
    
    /sys/bus/platform/devices/80860F14:00 \_SB_.PCI0.SDHA [D0]
    /sys/bus/platform/devices/80860F14:01 \_SB_.PCI0.SDHC [D0]
    
    -------- 8< -------- 8< -------- 8< -------- 8< -------- 8< --------
    
    Patch fixes above problems.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index bd3e84a59863..a10c2d665ec2 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -599,6 +599,34 @@ static void acpi_lpss_d3_to_d0_delay(struct lpss_private_data *pdata)
 	msleep(delay);
 }
 
+static int acpi_lpss_activate(struct device *dev)
+{
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+	int ret;
+
+	ret = acpi_dev_runtime_resume(dev);
+	if (ret)
+		return ret;
+
+	acpi_lpss_d3_to_d0_delay(pdata);
+
+	/*
+	 * This is called only on ->probe() stage where a device is either in
+	 * known state defined by BIOS or most likely powered off. Due to this
+	 * we have to deassert reset line to be sure that ->probe() will
+	 * recognize the device.
+	 */
+	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
+		lpss_deassert_reset(pdata);
+
+	return 0;
+}
+
+static void acpi_lpss_dismiss(struct device *dev)
+{
+	acpi_dev_runtime_suspend(dev);
+}
+
 #ifdef CONFIG_PM_SLEEP
 static int acpi_lpss_suspend_late(struct device *dev)
 {
@@ -667,6 +695,10 @@ static int acpi_lpss_runtime_resume(struct device *dev)
 #endif /* CONFIG_PM */
 
 static struct dev_pm_domain acpi_lpss_pm_domain = {
+#ifdef CONFIG_PM
+	.activate = acpi_lpss_activate,
+	.dismiss = acpi_lpss_dismiss,
+#endif
 	.ops = {
 #ifdef CONFIG_PM
 #ifdef CONFIG_PM_SLEEP

commit 02b98540433e6018806df539071c495a63cc0da4
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Dec 4 23:49:21 2015 +0200

    ACPI / LPSS: do delay for all LPSS devices when D3->D0
    
    The LPSS DMA device has no context to save, though it requires the same delay
    like the rest of LPSS devices when power state is changed from D3 to D0.
    
    Do delay for the DMA device as well.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 6263939c4c5f..bd3e84a59863 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -574,6 +574,17 @@ static void acpi_lpss_restore_ctx(struct device *dev,
 {
 	unsigned int i;
 
+	for (i = 0; i < LPSS_PRV_REG_COUNT; i++) {
+		unsigned long offset = i * sizeof(u32);
+
+		__lpss_reg_write(pdata->prv_reg_ctx[i], pdata, offset);
+		dev_dbg(dev, "restoring 0x%08x to LPSS reg at offset 0x%02lx\n",
+			pdata->prv_reg_ctx[i], offset);
+	}
+}
+
+static void acpi_lpss_d3_to_d0_delay(struct lpss_private_data *pdata)
+{
 	/*
 	 * The following delay is needed or the subsequent write operations may
 	 * fail. The LPSS devices are actually PCI devices and the PCI spec
@@ -586,14 +597,6 @@ static void acpi_lpss_restore_ctx(struct device *dev,
 		delay = 0;
 
 	msleep(delay);
-
-	for (i = 0; i < LPSS_PRV_REG_COUNT; i++) {
-		unsigned long offset = i * sizeof(u32);
-
-		__lpss_reg_write(pdata->prv_reg_ctx[i], pdata, offset);
-		dev_dbg(dev, "restoring 0x%08x to LPSS reg at offset 0x%02lx\n",
-			pdata->prv_reg_ctx[i], offset);
-	}
 }
 
 #ifdef CONFIG_PM_SLEEP
@@ -621,6 +624,8 @@ static int acpi_lpss_resume_early(struct device *dev)
 	if (ret)
 		return ret;
 
+	acpi_lpss_d3_to_d0_delay(pdata);
+
 	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
 		acpi_lpss_restore_ctx(dev, pdata);
 
@@ -652,6 +657,8 @@ static int acpi_lpss_runtime_resume(struct device *dev)
 	if (ret)
 		return ret;
 
+	acpi_lpss_d3_to_d0_delay(pdata);
+
 	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
 		acpi_lpss_restore_ctx(dev, pdata);
 

commit de16d55206c5ce82ad44590b01718fbe2323853c
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Dec 4 23:49:19 2015 +0200

    ACPI / LPSS: allow to use specific PM domain during ->probe()
    
    This is an amendment to previously pushed commit 01ac170ba29a (ACPI / LPSS:
    allow to use specific PM domain during ->probe()). We can't assign anything to
    the platform device on ADD_DEVICE stage since it might be changed during
    unbound / bind cycle.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index da0e276d2c04..6263939c4c5f 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -705,9 +705,10 @@ static int acpi_lpss_platform_notify(struct notifier_block *nb,
 	}
 
 	switch (action) {
-	case BUS_NOTIFY_BOUND_DRIVER:
+	case BUS_NOTIFY_BIND_DRIVER:
 		pdev->dev.pm_domain = &acpi_lpss_pm_domain;
 		break;
+	case BUS_NOTIFY_DRIVER_NOT_BOUND:
 	case BUS_NOTIFY_UNBOUND_DRIVER:
 		pdev->dev.pm_domain = NULL;
 		break;

commit b5f88dd1d6efc472e35ca1b21a44e662c5422088
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Dec 4 23:49:18 2015 +0200

    Revert "ACPI / LPSS: allow to use specific PM domain during ->probe()"
    
    The specific power domain can't be used in a way provided by the commit
    01ac170ba29a, i.e. pointer to platform device is a subject to change during
    unbound / bind cycle.
    
    This reverts commit 01ac170ba29a9903ee590e1ef2d8e6b27b49a16c.
    
    Fixes: 3df2da968744 (Revert "ACPI / LPSS: introduce a 'proxy' device to power on LPSS for DMA")
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index f9e0d09f7c66..da0e276d2c04 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -705,8 +705,13 @@ static int acpi_lpss_platform_notify(struct notifier_block *nb,
 	}
 
 	switch (action) {
-	case BUS_NOTIFY_ADD_DEVICE:
+	case BUS_NOTIFY_BOUND_DRIVER:
 		pdev->dev.pm_domain = &acpi_lpss_pm_domain;
+		break;
+	case BUS_NOTIFY_UNBOUND_DRIVER:
+		pdev->dev.pm_domain = NULL;
+		break;
+	case BUS_NOTIFY_ADD_DEVICE:
 		if (pdata->dev_desc->flags & LPSS_LTR)
 			return sysfs_create_group(&pdev->dev.kobj,
 						  &lpss_attr_group);
@@ -714,7 +719,6 @@ static int acpi_lpss_platform_notify(struct notifier_block *nb,
 	case BUS_NOTIFY_DEL_DEVICE:
 		if (pdata->dev_desc->flags & LPSS_LTR)
 			sysfs_remove_group(&pdev->dev.kobj, &lpss_attr_group);
-		pdev->dev.pm_domain = NULL;
 		break;
 	default:
 		break;

commit 58a1fbbb2ee873dd1fe327e80bc7b08e80866269
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 7 00:50:24 2015 +0200

    PM / PCI / ACPI: Kick devices that might have been reset by firmware
    
    There is a concern that if the platform firmware was involved in
    the system resume that's being completed,  some devices might have
    been reset by it and if those devices had the power.direct_complete
    flag set during the preceding suspend transition, they may stay
    in a reset-power-on state indefinitely (until they are runtime-resumed
    and then suspended again).  That may not be a big deal from the
    individual device's perspective, but if the system is an SoC, it may
    be prevented from entering deep SoC-wide low-power states on idle
    because of that.
    
    The devices that are most likely to be affected by this issue are
    PCI devices and ACPI-enumerated devices using the general ACPI PM
    domain, so to prevent it from happening for those devices, force a
    runtime resume for them if they have their power.direct_complete
    flags set and the platform firmware was involved in the resume
    transition currently in progress.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index f51bd0d0bc17..f9e0d09f7c66 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -664,7 +664,7 @@ static struct dev_pm_domain acpi_lpss_pm_domain = {
 #ifdef CONFIG_PM
 #ifdef CONFIG_PM_SLEEP
 		.prepare = acpi_subsys_prepare,
-		.complete = acpi_subsys_complete,
+		.complete = pm_complete_with_resume_check,
 		.suspend = acpi_subsys_suspend,
 		.suspend_late = acpi_lpss_suspend_late,
 		.resume_early = acpi_lpss_resume_early,

commit ae982073095a44f004d7ffb9f271077abef9dbcf
Merge: f1a3c0b933e7 e625ccec1fa6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 1 19:45:46 2015 -0700

    Merge tag 'pm+acpi-4.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "From the number of commits perspective, the biggest items are ACPICA
      and cpufreq changes with the latter taking the lead (over 50 commits).
    
      On the cpufreq front, there are many cleanups and minor fixes in the
      core and governors, driver updates etc.  We also have a new cpufreq
      driver for Mediatek MT8173 chips.
    
      ACPICA mostly updates its debug infrastructure and adds a number of
      fixes and cleanups for a good measure.
    
      The Operating Performance Points (OPP) framework is updated with new
      DT bindings and support for them among other things.
    
      We have a few updates of the generic power domains framework and a
      reorganization of the ACPI device enumeration code and bus type
      operations.
    
      And a lot of fixes and cleanups all over.
    
      Included is one branch from the MFD tree as it contains some
      PM-related driver core and ACPI PM changes a few other commits are
      based on.
    
      Specifics:
    
       - ACPICA update to upstream revision 20150818 including method
         tracing extensions to allow more in-depth AML debugging in the
         kernel and a number of assorted fixes and cleanups (Bob Moore, Lv
         Zheng, Markus Elfring).
    
       - ACPI sysfs code updates and a documentation update related to AML
         method tracing (Lv Zheng).
    
       - ACPI EC driver fix related to serialized evaluations of _Qxx
         methods and ACPI tools updates allowing the EC userspace tool to be
         built from the kernel source (Lv Zheng).
    
       - ACPI processor driver updates preparing it for future introduction
         of CPPC support and ACPI PCC mailbox driver updates (Ashwin
         Chaugule).
    
       - ACPI interrupts enumeration fix for a regression related to the
         handling of IRQ attribute conflicts between MADT and the ACPI
         namespace (Jiang Liu).
    
       - Fixes related to ACPI device PM (Mika Westerberg, Srinidhi
         Kasagar).
    
       - ACPI device registration code reorganization to separate the
         sysfs-related code and bus type operations from the rest (Rafael J
         Wysocki).
    
       - Assorted cleanups in the ACPI core (Jarkko Nikula, Mathias Krause,
         Andy Shevchenko, Rafael J Wysocki, Nicolas Iooss).
    
       - ACPI cpufreq driver and ia64 cpufreq driver fixes and cleanups (Pan
         Xinhui, Rafael J Wysocki).
    
       - cpufreq core cleanups on top of the previous changes allowing it to
         preseve its sysfs directories over system suspend/resume (Viresh
         Kumar, Rafael J Wysocki, Sebastian Andrzej Siewior).
    
       - cpufreq fixes and cleanups related to governors (Viresh Kumar).
    
       - cpufreq updates (core and the cpufreq-dt driver) related to the
         turbo/boost mode support (Viresh Kumar, Bartlomiej Zolnierkiewicz).
    
       - New DT bindings for Operating Performance Points (OPP), support for
         them in the OPP framework and in the cpufreq-dt driver plus related
         OPP framework fixes and cleanups (Viresh Kumar).
    
       - cpufreq powernv driver updates (Shilpasri G Bhat).
    
       - New cpufreq driver for Mediatek MT8173 (Pi-Cheng Chen).
    
       - Assorted cpufreq driver (speedstep-lib, sfi, integrator) cleanups
         and fixes (Abhilash Jindal, Andrzej Hajda, Cristian Ardelean).
    
       - intel_pstate driver updates including Skylake-S support, support
         for enabling HW P-states per CPU and an additional vendor bypass
         list entry (Kristen Carlson Accardi, Chen Yu, Ethan Zhao).
    
       - cpuidle core fixes related to the handling of coupled idle states
         (Xunlei Pang).
    
       - intel_idle driver updates including Skylake Client support and
         support for freeze-mode-specific idle states (Len Brown).
    
       - Driver core updates related to power management (Andy Shevchenko,
         Rafael J Wysocki).
    
       - Generic power domains framework fixes and cleanups (Jon Hunter,
         Geert Uytterhoeven, Rajendra Nayak, Ulf Hansson).
    
       - Device PM QoS framework update to allow the latency tolerance
         setting to be exposed to user space via sysfs (Mika Westerberg).
    
       - devfreq support for PPMUv2 in Exynos5433 and a fix for an incorrect
         exynos-ppmu DT binding (Chanwoo Choi, Javier Martinez Canillas).
    
       - System sleep support updates (Alan Stern, Len Brown, SungEun Kim).
    
       - rockchip-io AVS support updates (Heiko Stuebner).
    
       - PM core clocks support fixup (Colin Ian King).
    
       - Power capping RAPL driver update including support for Skylake H/S
         and Broadwell-H (Radivoje Jovanovic, Seiichi Ikarashi).
    
       - Generic device properties framework fixes related to the handling
         of static (driver-provided) property sets (Andy Shevchenko).
    
       - turbostat and cpupower updates (Len Brown, Shilpasri G Bhat,
         Shreyas B Prabhu)"
    
    * tag 'pm+acpi-4.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (180 commits)
      cpufreq: speedstep-lib: Use monotonic clock
      cpufreq: powernv: Increase the verbosity of OCC console messages
      cpufreq: sfi: use kmemdup rather than duplicating its implementation
      cpufreq: drop !cpufreq_driver check from cpufreq_parse_governor()
      cpufreq: rename cpufreq_real_policy as cpufreq_user_policy
      cpufreq: remove redundant 'policy' field from user_policy
      cpufreq: remove redundant 'governor' field from user_policy
      cpufreq: update user_policy.* on success
      cpufreq: use memcpy() to copy policy
      cpufreq: remove redundant CPUFREQ_INCOMPATIBLE notifier event
      cpufreq: mediatek: Add MT8173 cpufreq driver
      dt-bindings: mediatek: Add MT8173 CPU DVFS clock bindings
      PM / Domains: Fix typo in description of genpd_dev_pm_detach()
      PM / Domains: Remove unusable governor dummies
      PM / Domains: Make pm_genpd_init() available to modules
      PM / domains: Align column headers and data in pm_genpd_summary output
      powercap / RAPL: disable the 2nd power limit properly
      tools: cpupower: Fix error when running cpupower monitor
      PM / OPP: Drop unlikely before IS_ERR(_OR_NULL)
      PM / OPP: Fix static checker warning (broken 64bit big endian systems)
      ...

commit f36fc04e4cdda9e4c72ee504e7dc638f9a168863
Merge: 26f8b7edc9ea ba3001157733
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 31 17:26:48 2015 -0700

    Merge tag 'clk-for-linus-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux
    
    Pull clk updates from Michael Turquette:
     "The clk framework changes for 4.3 are mostly updates to existing
      drivers and the addition of new clock drivers.  Stephen Boyd has also
      done a lot of subsystem-wide driver clean-ups (thanks!).  There are
      also fixes to the framework core and changes to better split clock
      provider drivers from clock consumer drivers"
    
    * tag 'clk-for-linus-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux: (227 commits)
      clk: s5pv210: add missing call to samsung_clk_of_add_provider()
      clk: pistachio: correct critical clock list
      clk: pistachio: Fix PLL rate calculation in integer mode
      clk: pistachio: Fix override of clk-pll settings from boot loader
      clk: pistachio: Fix 32bit integer overflows
      clk: tegra: Fix some static checker problems
      clk: qcom: Fix MSM8916 prng clock enable bit
      clk: Add missing header for 'bool' definition to clk-conf.h
      drivers/clk: appropriate __init annotation for const data
      clk: rockchip: register pll mux before pll itself
      clk: add bindings for the Ux500 clocks
      clk/ARM: move Ux500 PRCC bases to the device tree
      clk: remove duplicated code with __clk_set_parent_after
      clk: Convert __clk_get_name(hw->clk) to clk_hw_get_name(hw)
      clk: Constify clk_hw argument to provider APIs
      clk: Hi6220: add stub clock driver
      dt-bindings: clk: Hi6220: Document stub clock driver
      dt-bindings: arm: Hi6220: add doc for SRAM controller
      clk: atlas7: fix pll missed divide NR in fraction mode
      clk: atlas7: fix bit field and its root clk for coresight_tpiu
      ...

commit b00855aecbb166428c67b26e1bfeb675463a0212
Author: Srinidhi Kasagar <srinidhi.kasagar@intel.com>
Date:   Thu Aug 27 21:30:55 2015 +0530

    ACPI / LPSS: Ignore 10ms delay for Braswell
    
    LPSS devices in Braswell does not need the default 10ms
    d3_delay imposed by PCI specification. Removing this
    unnecessary delay significantly reduces the resume time
    approximately upto 200ms on this platform.
    
    Signed-off-by: Srinidhi Kasagar <srinidhi.kasagar@intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 46b58abb08c5..10020e04f574 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -60,6 +60,7 @@ ACPI_MODULE_NAME("acpi_lpss");
 #define LPSS_CLK_DIVIDER		BIT(2)
 #define LPSS_LTR			BIT(3)
 #define LPSS_SAVE_CTX			BIT(4)
+#define LPSS_NO_D3_DELAY		BIT(5)
 
 struct lpss_private_data;
 
@@ -156,6 +157,10 @@ static const struct lpss_device_desc byt_pwm_dev_desc = {
 	.flags = LPSS_SAVE_CTX,
 };
 
+static const struct lpss_device_desc bsw_pwm_dev_desc = {
+	.flags = LPSS_SAVE_CTX | LPSS_NO_D3_DELAY,
+};
+
 static const struct lpss_device_desc byt_uart_dev_desc = {
 	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX,
 	.clk_con_id = "baudclk",
@@ -163,6 +168,14 @@ static const struct lpss_device_desc byt_uart_dev_desc = {
 	.setup = lpss_uart_setup,
 };
 
+static const struct lpss_device_desc bsw_uart_dev_desc = {
+	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX
+			| LPSS_NO_D3_DELAY,
+	.clk_con_id = "baudclk",
+	.prv_offset = 0x800,
+	.setup = lpss_uart_setup,
+};
+
 static const struct lpss_device_desc byt_spi_dev_desc = {
 	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX,
 	.prv_offset = 0x400,
@@ -178,8 +191,15 @@ static const struct lpss_device_desc byt_i2c_dev_desc = {
 	.setup = byt_i2c_setup,
 };
 
+static const struct lpss_device_desc bsw_i2c_dev_desc = {
+	.flags = LPSS_CLK | LPSS_SAVE_CTX | LPSS_NO_D3_DELAY,
+	.prv_offset = 0x800,
+	.setup = byt_i2c_setup,
+};
+
 static struct lpss_device_desc bsw_spi_dev_desc = {
-	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX,
+	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX
+			| LPSS_NO_D3_DELAY,
 	.prv_offset = 0x400,
 	.setup = lpss_deassert_reset,
 };
@@ -214,11 +234,12 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	{ "INT33FC", },
 
 	/* Braswell LPSS devices */
-	{ "80862288", LPSS_ADDR(byt_pwm_dev_desc) },
-	{ "8086228A", LPSS_ADDR(byt_uart_dev_desc) },
+	{ "80862288", LPSS_ADDR(bsw_pwm_dev_desc) },
+	{ "8086228A", LPSS_ADDR(bsw_uart_dev_desc) },
 	{ "8086228E", LPSS_ADDR(bsw_spi_dev_desc) },
-	{ "808622C1", LPSS_ADDR(byt_i2c_dev_desc) },
+	{ "808622C1", LPSS_ADDR(bsw_i2c_dev_desc) },
 
+	/* Broadwell LPSS devices */
 	{ "INT3430", LPSS_ADDR(lpt_dev_desc) },
 	{ "INT3431", LPSS_ADDR(lpt_dev_desc) },
 	{ "INT3432", LPSS_ADDR(lpt_i2c_dev_desc) },
@@ -558,9 +579,14 @@ static void acpi_lpss_restore_ctx(struct device *dev,
 	 * The following delay is needed or the subsequent write operations may
 	 * fail. The LPSS devices are actually PCI devices and the PCI spec
 	 * expects 10ms delay before the device can be accessed after D3 to D0
-	 * transition.
+	 * transition. However some platforms like BSW does not need this delay.
 	 */
-	msleep(10);
+	unsigned int delay = 10;	/* default 10ms delay */
+
+	if (pdata->dev_desc->flags & LPSS_NO_D3_DELAY)
+		delay = 0;
+
+	msleep(delay);
 
 	for (i = 0; i < LPSS_PRV_REG_COUNT; i++) {
 		unsigned long offset = i * sizeof(u32);

commit 887e5a91ac17927f68455d059da2f175b6fbf9d3
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jun 19 15:00:46 2015 -0700

    ACPI: Remove clk.h include
    
    Clock provider drivers generally shouldn't include clk.h because
    it's the consumer API. Remove the includes here because these are
    a provider drivers.
    
    Cc: Ken Xue <Ken.Xue@amd.com>
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 569ee090343f..6817b18ed722 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -11,7 +11,6 @@
  */
 
 #include <linux/acpi.h>
-#include <linux/clk.h>
 #include <linux/clkdev.h>
 #include <linux/clk-provider.h>
 #include <linux/err.h>

commit d3e13ff3c1aa2403d9a5f371baac088daeb8f56d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 7 00:31:47 2015 +0200

    ACPI / LPSS: Fix up acpi_lpss_create_device()
    
    Fix a return value (which should be a negative error code) and a
    memory leak (the list allocated by acpi_dev_get_resources() needs
    to be freed on ioremap() errors too) in acpi_lpss_create_device()
    introduced by commit 4483d59e29fe 'ACPI / LPSS: check the result
    of ioremap()'.
    
    Fixes: 4483d59e29fe 'ACPI / LPSS: check the result of ioremap()'
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: 4.0+ <stable@vger.kernel.org> # 4.0+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 569ee090343f..46b58abb08c5 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -352,13 +352,16 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 				pdata->mmio_size = resource_size(rentry->res);
 			pdata->mmio_base = ioremap(rentry->res->start,
 						   pdata->mmio_size);
-			if (!pdata->mmio_base)
-				goto err_out;
 			break;
 		}
 
 	acpi_dev_free_resource_list(&resource_list);
 
+	if (!pdata->mmio_base) {
+		ret = -ENOMEM;
+		goto err_out;
+	}
+
 	pdata->dev_desc = dev_desc;
 
 	if (dev_desc->setup)

commit b2687cd7d5fd7394254ebc2b6a553ed9a3dcd5f1
Author: Mathias Krause <minipli@googlemail.com>
Date:   Sat Jun 13 14:26:50 2015 +0200

    ACPI / LPSS: constify device descriptors
    
    The device descriptors are never written to -- even pointed to as
    'const' from struct lpss_private_data. Make them r/o for real.
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 37fb19047603..569ee090343f 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -129,50 +129,50 @@ static void byt_i2c_setup(struct lpss_private_data *pdata)
 	writel(0, pdata->mmio_base + LPSS_I2C_ENABLE);
 }
 
-static struct lpss_device_desc lpt_dev_desc = {
+static const struct lpss_device_desc lpt_dev_desc = {
 	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_LTR,
 	.prv_offset = 0x800,
 };
 
-static struct lpss_device_desc lpt_i2c_dev_desc = {
+static const struct lpss_device_desc lpt_i2c_dev_desc = {
 	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_LTR,
 	.prv_offset = 0x800,
 };
 
-static struct lpss_device_desc lpt_uart_dev_desc = {
+static const struct lpss_device_desc lpt_uart_dev_desc = {
 	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_LTR,
 	.clk_con_id = "baudclk",
 	.prv_offset = 0x800,
 	.setup = lpss_uart_setup,
 };
 
-static struct lpss_device_desc lpt_sdio_dev_desc = {
+static const struct lpss_device_desc lpt_sdio_dev_desc = {
 	.flags = LPSS_LTR,
 	.prv_offset = 0x1000,
 	.prv_size_override = 0x1018,
 };
 
-static struct lpss_device_desc byt_pwm_dev_desc = {
+static const struct lpss_device_desc byt_pwm_dev_desc = {
 	.flags = LPSS_SAVE_CTX,
 };
 
-static struct lpss_device_desc byt_uart_dev_desc = {
+static const struct lpss_device_desc byt_uart_dev_desc = {
 	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX,
 	.clk_con_id = "baudclk",
 	.prv_offset = 0x800,
 	.setup = lpss_uart_setup,
 };
 
-static struct lpss_device_desc byt_spi_dev_desc = {
+static const struct lpss_device_desc byt_spi_dev_desc = {
 	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX,
 	.prv_offset = 0x400,
 };
 
-static struct lpss_device_desc byt_sdio_dev_desc = {
+static const struct lpss_device_desc byt_sdio_dev_desc = {
 	.flags = LPSS_CLK,
 };
 
-static struct lpss_device_desc byt_i2c_dev_desc = {
+static const struct lpss_device_desc byt_i2c_dev_desc = {
 	.flags = LPSS_CLK | LPSS_SAVE_CTX,
 	.prv_offset = 0x800,
 	.setup = byt_i2c_setup,
@@ -323,14 +323,14 @@ static int register_device_clock(struct acpi_device *adev,
 static int acpi_lpss_create_device(struct acpi_device *adev,
 				   const struct acpi_device_id *id)
 {
-	struct lpss_device_desc *dev_desc;
+	const struct lpss_device_desc *dev_desc;
 	struct lpss_private_data *pdata;
 	struct resource_entry *rentry;
 	struct list_head resource_list;
 	struct platform_device *pdev;
 	int ret;
 
-	dev_desc = (struct lpss_device_desc *)id->driver_data;
+	dev_desc = (const struct lpss_device_desc *)id->driver_data;
 	if (!dev_desc) {
 		pdev = acpi_create_platform_device(adev);
 		return IS_ERR_OR_NULL(pdev) ? PTR_ERR(pdev) : 1;

commit fcf0789a96777d79d20290e08bf43943a5619387
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Fri Mar 6 15:48:38 2015 +0200

    ACPI / LPSS: provide con_id for the clkdev
    
    Commit 7d78cbefaa (serial: 8250_dw: add ability to handle
    the peripheral clock) introduces handling for a second clk
    to 8250_dw.c which is the driver also for LPSS UART. The
    second clk forces us to provide identifier (con_id) for the
    clkdev we create.
    
    This fixes an issue where 8250_dw.c is getting the same
    handler for both clocks.
    
    Fixes: 7d78cbefaa (serial: 8250_dw: add ability to handle the peripheral clock)
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Cc: 3.17+ <stable@vger.kernel.org> # 3.17+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 657964e8ab7e..37fb19047603 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -65,6 +65,7 @@ struct lpss_private_data;
 
 struct lpss_device_desc {
 	unsigned int flags;
+	const char *clk_con_id;
 	unsigned int prv_offset;
 	size_t prv_size_override;
 	void (*setup)(struct lpss_private_data *pdata);
@@ -140,6 +141,7 @@ static struct lpss_device_desc lpt_i2c_dev_desc = {
 
 static struct lpss_device_desc lpt_uart_dev_desc = {
 	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_LTR,
+	.clk_con_id = "baudclk",
 	.prv_offset = 0x800,
 	.setup = lpss_uart_setup,
 };
@@ -156,6 +158,7 @@ static struct lpss_device_desc byt_pwm_dev_desc = {
 
 static struct lpss_device_desc byt_uart_dev_desc = {
 	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX,
+	.clk_con_id = "baudclk",
 	.prv_offset = 0x800,
 	.setup = lpss_uart_setup,
 };
@@ -313,7 +316,7 @@ static int register_device_clock(struct acpi_device *adev,
 		return PTR_ERR(clk);
 
 	pdata->clk = clk;
-	clk_register_clkdev(clk, NULL, devname);
+	clk_register_clkdev(clk, dev_desc->clk_con_id, devname);
 	return 0;
 }
 

commit 9d0de5a63a4a22abfd2bd70694a610d18350cf87
Merge: 99fa0ad92c4f 92e4b1bcd656 3095794ae972 3120d03cf64d 6a239af2a369
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Feb 21 04:28:56 2015 +0100

    Merge branches 'acpi-ec', 'acpi-soc', 'acpi-video' and 'acpi-resources'
    
    * acpi-ec:
      ACPI / EC: Remove non-standard log emphasis
    
    * acpi-soc:
      ACPI / LPSS: Deassert resets for SPI host controllers on Braswell
      ACPI / LPSS: Always disable I2C host controllers
      Revert "ACPI / LPSS: Remove non-existing clock control from Intel Lynxpoint I2C"
    
    * acpi-video:
      ACPI / video: Disable native backlight on Samsung Series 9 laptops
    
    * acpi-resources:
      ACPI / resources: Change pr_info() to pr_debug() for debug information

commit 3095794ae972bc6fc76af6cb3b864d6686b96094
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Feb 18 13:50:17 2015 +0200

    ACPI / LPSS: Deassert resets for SPI host controllers on Braswell
    
    On some Braswell systems BIOS leaves resets for SPI host controllers
    active. This prevents the SPI driver from transferring messages on wire.
    
    Fix this in similar way that we do for I2C already by deasserting resets
    for the SPI host controllers.
    
    Reported-by: Yang A Fang <yang.a.fang@intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: 3.17+ <stable@vger.kernel.org> # 3.17+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index cb84efe7fc5d..6bb8d3574ec6 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -105,9 +105,7 @@ static void lpss_uart_setup(struct lpss_private_data *pdata)
 	}
 }
 
-#define LPSS_I2C_ENABLE			0x6c
-
-static void byt_i2c_setup(struct lpss_private_data *pdata)
+static void lpss_deassert_reset(struct lpss_private_data *pdata)
 {
 	unsigned int offset;
 	u32 val;
@@ -116,6 +114,13 @@ static void byt_i2c_setup(struct lpss_private_data *pdata)
 	val = readl(pdata->mmio_base + offset);
 	val |= LPSS_RESETS_RESET_APB | LPSS_RESETS_RESET_FUNC;
 	writel(val, pdata->mmio_base + offset);
+}
+
+#define LPSS_I2C_ENABLE			0x6c
+
+static void byt_i2c_setup(struct lpss_private_data *pdata)
+{
+	lpss_deassert_reset(pdata);
 
 	if (readl(pdata->mmio_base + pdata->dev_desc->prv_offset))
 		pdata->fixed_clk_rate = 133000000;
@@ -170,6 +175,12 @@ static struct lpss_device_desc byt_i2c_dev_desc = {
 	.setup = byt_i2c_setup,
 };
 
+static struct lpss_device_desc bsw_spi_dev_desc = {
+	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX,
+	.prv_offset = 0x400,
+	.setup = lpss_deassert_reset,
+};
+
 #else
 
 #define LPSS_ADDR(desc) (0UL)
@@ -202,7 +213,7 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	/* Braswell LPSS devices */
 	{ "80862288", LPSS_ADDR(byt_pwm_dev_desc) },
 	{ "8086228A", LPSS_ADDR(byt_uart_dev_desc) },
-	{ "8086228E", LPSS_ADDR(byt_spi_dev_desc) },
+	{ "8086228E", LPSS_ADDR(bsw_spi_dev_desc) },
 	{ "808622C1", LPSS_ADDR(byt_i2c_dev_desc) },
 
 	{ "INT3430", LPSS_ADDR(lpt_dev_desc) },

commit 3293c7b8ec213a640f5ea2e5efeaa2b7559b1e19
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Feb 18 13:50:16 2015 +0200

    ACPI / LPSS: Always disable I2C host controllers
    
    On Baytrail and Braswell the BIOS might leave the I2C host controllers
    enabled, probably because it uses them for its own purposes. This is fine
    in normal cases because the I2C driver will disable the hardware when it
    is probed anyway.
    
    However, in case of suspend to disk it is different story. If the driver
    happens to be compiled as a module the boot kernel never loads the driver
    thus leaving host controllers enabled upon loading the hibernation image.
    
    The I2C host controller interrupt mask register has default value of 0x8ff,
    in other words it has most of the interrupts unmasked. When combined with
    the fact that the host controller is enabled, the driver immediately starts
    getting interrupts even before its resume hook is called (once IO-APIC is
    resumed). Since the driver is not prepared for this it will crash the
    kernel due to NULL pointer derefence because dev->msgs is NULL.
    
    Unfortunately we were not able to get full backtrace to from the console
    which could be reproduced here.
    
    In order to fix this even when the driver is compiled as module, we disable
    the I2C host controllers in byt_i2c_setup() before devices are created.
    
    Reported-by: Yu Chen <yu.c.chen@intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: 3.17+ <stable@vger.kernel.org> # 3.17+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index a7ee533c1cef..cb84efe7fc5d 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -105,6 +105,8 @@ static void lpss_uart_setup(struct lpss_private_data *pdata)
 	}
 }
 
+#define LPSS_I2C_ENABLE			0x6c
+
 static void byt_i2c_setup(struct lpss_private_data *pdata)
 {
 	unsigned int offset;
@@ -117,6 +119,8 @@ static void byt_i2c_setup(struct lpss_private_data *pdata)
 
 	if (readl(pdata->mmio_base + pdata->dev_desc->prv_offset))
 		pdata->fixed_clk_rate = 133000000;
+
+	writel(0, pdata->mmio_base + LPSS_I2C_ENABLE);
 }
 
 static struct lpss_device_desc lpt_dev_desc = {

commit f8f87c03627c464cbb14651c37da86f4f9f92059
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Mon Feb 16 10:26:28 2015 +0200

    Revert "ACPI / LPSS: Remove non-existing clock control from Intel Lynxpoint I2C"
    
    Revert commit b893e80e3147 ("ACPI / LPSS: Remove non-existing clock control
    from Intel Lynxpoint I2C") because it causes touchpad to not load on Dell
    XPS13.
    
    Regression is a clear indication that not only some early prototype version
    of Lynxpoint I2C but also newer versions can be doing clock gating even
    documentation does not state it.
    
    Therefore it is best to revert since this clock gating haven't caused known
    issues on those Lynxpoint version which don't do clock gating.
    
    Reported-by-and-tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 08fbff507dc4..a7ee533c1cef 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -125,7 +125,7 @@ static struct lpss_device_desc lpt_dev_desc = {
 };
 
 static struct lpss_device_desc lpt_i2c_dev_desc = {
-	.flags = LPSS_CLK | LPSS_LTR,
+	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_LTR,
 	.prv_offset = 0x800,
 };
 

commit 8fbcf5ecb336eb6da560f08d60e95b51d318795c
Merge: d23209680291 5c493df25a0d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 10 16:05:16 2015 +0100

    Merge branch 'acpi-resources'
    
    * acpi-resources: (23 commits)
      Merge branch 'pci/host-generic' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci into acpi-resources
      x86/irq, ACPI: Implement ACPI driver to support IOAPIC hotplug
      ACPI: Add interfaces to parse IOAPIC ID for IOAPIC hotplug
      x86/PCI: Refine the way to release PCI IRQ resources
      x86/PCI/ACPI: Use common ACPI resource interfaces to simplify implementation
      x86/PCI: Fix the range check for IO resources
      PCI: Use common resource list management code instead of private implementation
      resources: Move struct resource_list_entry from ACPI into resource core
      ACPI: Introduce helper function acpi_dev_filter_resource_type()
      ACPI: Add field offset to struct resource_list_entry
      ACPI: Translate resource into master side address for bridge window resources
      ACPI: Return translation offset when parsing ACPI address space resources
      ACPI: Enforce stricter checks for address space descriptors
      ACPI: Set flag IORESOURCE_UNSET for unassigned resources
      ACPI: Normalize return value of resource parser functions
      ACPI: Fix a bug in parsing ACPI Memory24 resource
      ACPI: Add prefetch decoding to the address space parser
      ACPI: Move the window flag logic to the combined parser
      ACPI: Unify the parsing of address_space and ext_address_space
      ACPI: Let the parser return false for disabled resources
      ...

commit 02c09177d56ef6a0a75ebc681f7667a34edda384
Merge: 3df2da968744 b893e80e3147
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 6 15:39:04 2015 +0100

    Merge back earlier 'acpi-lpss' material for v3.20

commit 90e97820619dc912b52cc9d103272819d8b51259
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Feb 5 13:44:43 2015 +0800

    resources: Move struct resource_list_entry from ACPI into resource core
    
    Currently ACPI, PCI and pnp all implement the same resource list
    management with different data structure. We need to transfer from
    one data structure into another when passing resources from one
    subsystem into another subsystem. So move struct resource_list_entry
    from ACPI into resource core and rename it as resource_entry,
    then it could be reused by different subystems and avoid the data
    structure conversion.
    
    Introduce dedicated header file resource_ext.h instead of embedding
    it into ioport.h to avoid header file inclusion order issues.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 4f3febf8a589..dfd1b8095dad 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -313,7 +313,7 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 {
 	struct lpss_device_desc *dev_desc;
 	struct lpss_private_data *pdata;
-	struct resource_list_entry *rentry;
+	struct resource_entry *rentry;
 	struct list_head resource_list;
 	struct platform_device *pdev;
 	int ret;
@@ -333,12 +333,12 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 		goto err_out;
 
 	list_for_each_entry(rentry, &resource_list, node)
-		if (resource_type(&rentry->res) == IORESOURCE_MEM) {
+		if (resource_type(rentry->res) == IORESOURCE_MEM) {
 			if (dev_desc->prv_size_override)
 				pdata->mmio_size = dev_desc->prv_size_override;
 			else
-				pdata->mmio_size = resource_size(&rentry->res);
-			pdata->mmio_base = ioremap(rentry->res.start,
+				pdata->mmio_size = resource_size(rentry->res);
+			pdata->mmio_base = ioremap(rentry->res->start,
 						   pdata->mmio_size);
 			break;
 		}

commit 3df2da96874402722d760e5d4eb2968737e5bb01
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 3 14:29:43 2015 +0100

    Revert "ACPI / LPSS: introduce a 'proxy' device to power on LPSS for DMA"
    
    Revert commit 6c17ee44d524 (ACPI / LPSS: introduce a 'proxy' device
    to power on LPSS for DMA), as it introduced registration and probe
    ordering problems between devices on the LPSS that may lead to full
    hard system hang on boot in some cases.

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 4f3febf8a589..e75737fd7eef 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -1,7 +1,7 @@
 /*
  * ACPI support for Intel Lynxpoint LPSS.
  *
- * Copyright (C) 2013, 2014, Intel Corporation
+ * Copyright (C) 2013, Intel Corporation
  * Authors: Mika Westerberg <mika.westerberg@linux.intel.com>
  *          Rafael J. Wysocki <rafael.j.wysocki@intel.com>
  *
@@ -60,8 +60,6 @@ ACPI_MODULE_NAME("acpi_lpss");
 #define LPSS_CLK_DIVIDER		BIT(2)
 #define LPSS_LTR			BIT(3)
 #define LPSS_SAVE_CTX			BIT(4)
-#define LPSS_DEV_PROXY			BIT(5)
-#define LPSS_PROXY_REQ			BIT(6)
 
 struct lpss_private_data;
 
@@ -72,10 +70,8 @@ struct lpss_device_desc {
 	void (*setup)(struct lpss_private_data *pdata);
 };
 
-static struct device *proxy_device;
-
 static struct lpss_device_desc lpss_dma_desc = {
-	.flags = LPSS_CLK | LPSS_PROXY_REQ,
+	.flags = LPSS_CLK,
 };
 
 struct lpss_private_data {
@@ -150,24 +146,22 @@ static struct lpss_device_desc byt_pwm_dev_desc = {
 };
 
 static struct lpss_device_desc byt_uart_dev_desc = {
-	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX |
-		 LPSS_DEV_PROXY,
+	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX,
 	.prv_offset = 0x800,
 	.setup = lpss_uart_setup,
 };
 
 static struct lpss_device_desc byt_spi_dev_desc = {
-	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX |
-		 LPSS_DEV_PROXY,
+	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX,
 	.prv_offset = 0x400,
 };
 
 static struct lpss_device_desc byt_sdio_dev_desc = {
-	.flags = LPSS_CLK | LPSS_DEV_PROXY,
+	.flags = LPSS_CLK,
 };
 
 static struct lpss_device_desc byt_i2c_dev_desc = {
-	.flags = LPSS_CLK | LPSS_SAVE_CTX | LPSS_DEV_PROXY,
+	.flags = LPSS_CLK | LPSS_SAVE_CTX,
 	.prv_offset = 0x800,
 	.setup = byt_i2c_setup,
 };
@@ -374,8 +368,6 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 	adev->driver_data = pdata;
 	pdev = acpi_create_platform_device(adev);
 	if (!IS_ERR_OR_NULL(pdev)) {
-		if (!proxy_device && dev_desc->flags & LPSS_DEV_PROXY)
-			proxy_device = &pdev->dev;
 		return 1;
 	}
 
@@ -600,14 +592,7 @@ static int acpi_lpss_runtime_suspend(struct device *dev)
 	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
 		acpi_lpss_save_ctx(dev, pdata);
 
-	ret = acpi_dev_runtime_suspend(dev);
-	if (ret)
-		return ret;
-
-	if (pdata->dev_desc->flags & LPSS_PROXY_REQ && proxy_device)
-		return pm_runtime_put_sync_suspend(proxy_device);
-
-	return 0;
+	return acpi_dev_runtime_suspend(dev);
 }
 
 static int acpi_lpss_runtime_resume(struct device *dev)
@@ -615,12 +600,6 @@ static int acpi_lpss_runtime_resume(struct device *dev)
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
 	int ret;
 
-	if (pdata->dev_desc->flags & LPSS_PROXY_REQ && proxy_device) {
-		ret = pm_runtime_get_sync(proxy_device);
-		if (ret)
-			return ret;
-	}
-
 	ret = acpi_dev_runtime_resume(dev);
 	if (ret)
 		return ret;

commit b893e80e314749bce4597a262b7d04e929016e51
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Jan 23 09:42:39 2015 +0200

    ACPI / LPSS: Remove non-existing clock control from Intel Lynxpoint I2C
    
    Intel Lynxpoint I2C does not have clock parameter register like SPI and UART
    do have. Therefore remove LPSS_CLK_GATE flag from the Lynxpoint I2C device
    description in order to not needlessly toggle clock enable bit in
    non-existing register.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index d12f98abf836..794cf3e13619 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -129,7 +129,7 @@ static struct lpss_device_desc lpt_dev_desc = {
 };
 
 static struct lpss_device_desc lpt_i2c_dev_desc = {
-	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_LTR,
+	.flags = LPSS_CLK | LPSS_LTR,
 	.prv_offset = 0x800,
 };
 

commit 4483d59e29fea65ef428be92a866aed50e28c795
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Thu Jan 8 09:57:25 2015 +0200

    ACPI / LPSS: check the result of ioremap()
    
    If it fails we have to skip the device.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 4f3febf8a589..d12f98abf836 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -340,6 +340,8 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 				pdata->mmio_size = resource_size(&rentry->res);
 			pdata->mmio_base = ioremap(rentry->res.start,
 						   pdata->mmio_size);
+			if (!pdata->mmio_base)
+				goto err_out;
 			break;
 		}
 

commit 5de21bb998b8e816e6a1df1f2c04d95fb6e27a5d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 27 22:38:23 2014 +0100

    ACPI / PM: Drop CONFIG_PM_RUNTIME from the ACPI core
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so quite a few
    depend on CONFIG_PM.
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM in the ACPI core code.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index d1dd0ada14b7..4f3febf8a589 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -588,7 +588,6 @@ static int acpi_lpss_resume_early(struct device *dev)
 }
 #endif /* CONFIG_PM_SLEEP */
 
-#ifdef CONFIG_PM_RUNTIME
 static int acpi_lpss_runtime_suspend(struct device *dev)
 {
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
@@ -631,11 +630,11 @@ static int acpi_lpss_runtime_resume(struct device *dev)
 
 	return pm_generic_runtime_resume(dev);
 }
-#endif /* CONFIG_PM_RUNTIME */
 #endif /* CONFIG_PM */
 
 static struct dev_pm_domain acpi_lpss_pm_domain = {
 	.ops = {
+#ifdef CONFIG_PM
 #ifdef CONFIG_PM_SLEEP
 		.prepare = acpi_subsys_prepare,
 		.complete = acpi_subsys_complete,
@@ -647,7 +646,6 @@ static struct dev_pm_domain acpi_lpss_pm_domain = {
 		.poweroff_late = acpi_lpss_suspend_late,
 		.restore_early = acpi_lpss_resume_early,
 #endif
-#ifdef CONFIG_PM_RUNTIME
 		.runtime_suspend = acpi_lpss_runtime_suspend,
 		.runtime_resume = acpi_lpss_runtime_resume,
 #endif

commit 6c17ee44d5240a247daef3cdc51a0c62d2b77d75
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Nov 5 18:34:47 2014 +0200

    ACPI / LPSS: introduce a 'proxy' device to power on LPSS for DMA
    
    The LPSS DMA controller does not have _PS0 and _PS3 methods. Moreover it can be
    powered off automatically whenever the last LPSS device goes down. In case of
    no power any access to the DMA controller will hang the system. The behaviour
    is reproduced on some HP laptops based on Intel Bay Trail [1] as well as on
    Asus T100 transformer.
    
    This patch introduces a so called 'proxy' device that has the knobs to handle a
    power of the LPSS island. When the system needs to program the DMA controller
    it calls to the ACPI LPSS power domain callbacks that wake or suspend the
    'proxy' device.
    
    [1] http://www.spinics.net/lists/dmaengine/msg01514.html
    
    Suggested-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Scott Ashcroft <scott.ashcroft@talk21.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 4804ae31b057..d1dd0ada14b7 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -1,7 +1,7 @@
 /*
  * ACPI support for Intel Lynxpoint LPSS.
  *
- * Copyright (C) 2013, Intel Corporation
+ * Copyright (C) 2013, 2014, Intel Corporation
  * Authors: Mika Westerberg <mika.westerberg@linux.intel.com>
  *          Rafael J. Wysocki <rafael.j.wysocki@intel.com>
  *
@@ -60,6 +60,8 @@ ACPI_MODULE_NAME("acpi_lpss");
 #define LPSS_CLK_DIVIDER		BIT(2)
 #define LPSS_LTR			BIT(3)
 #define LPSS_SAVE_CTX			BIT(4)
+#define LPSS_DEV_PROXY			BIT(5)
+#define LPSS_PROXY_REQ			BIT(6)
 
 struct lpss_private_data;
 
@@ -70,8 +72,10 @@ struct lpss_device_desc {
 	void (*setup)(struct lpss_private_data *pdata);
 };
 
+static struct device *proxy_device;
+
 static struct lpss_device_desc lpss_dma_desc = {
-	.flags = LPSS_CLK,
+	.flags = LPSS_CLK | LPSS_PROXY_REQ,
 };
 
 struct lpss_private_data {
@@ -146,22 +150,24 @@ static struct lpss_device_desc byt_pwm_dev_desc = {
 };
 
 static struct lpss_device_desc byt_uart_dev_desc = {
-	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX,
+	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX |
+		 LPSS_DEV_PROXY,
 	.prv_offset = 0x800,
 	.setup = lpss_uart_setup,
 };
 
 static struct lpss_device_desc byt_spi_dev_desc = {
-	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX,
+	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX |
+		 LPSS_DEV_PROXY,
 	.prv_offset = 0x400,
 };
 
 static struct lpss_device_desc byt_sdio_dev_desc = {
-	.flags = LPSS_CLK,
+	.flags = LPSS_CLK | LPSS_DEV_PROXY,
 };
 
 static struct lpss_device_desc byt_i2c_dev_desc = {
-	.flags = LPSS_CLK | LPSS_SAVE_CTX,
+	.flags = LPSS_CLK | LPSS_SAVE_CTX | LPSS_DEV_PROXY,
 	.prv_offset = 0x800,
 	.setup = byt_i2c_setup,
 };
@@ -368,6 +374,8 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 	adev->driver_data = pdata;
 	pdev = acpi_create_platform_device(adev);
 	if (!IS_ERR_OR_NULL(pdev)) {
+		if (!proxy_device && dev_desc->flags & LPSS_DEV_PROXY)
+			proxy_device = &pdev->dev;
 		return 1;
 	}
 
@@ -593,7 +601,14 @@ static int acpi_lpss_runtime_suspend(struct device *dev)
 	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
 		acpi_lpss_save_ctx(dev, pdata);
 
-	return acpi_dev_runtime_suspend(dev);
+	ret = acpi_dev_runtime_suspend(dev);
+	if (ret)
+		return ret;
+
+	if (pdata->dev_desc->flags & LPSS_PROXY_REQ && proxy_device)
+		return pm_runtime_put_sync_suspend(proxy_device);
+
+	return 0;
 }
 
 static int acpi_lpss_runtime_resume(struct device *dev)
@@ -601,6 +616,12 @@ static int acpi_lpss_runtime_resume(struct device *dev)
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
 	int ret;
 
+	if (pdata->dev_desc->flags & LPSS_PROXY_REQ && proxy_device) {
+		ret = pm_runtime_get_sync(proxy_device);
+		if (ret)
+			return ret;
+	}
+
 	ret = acpi_dev_runtime_resume(dev);
 	if (ret)
 		return ret;

commit 01ac170ba29a9903ee590e1ef2d8e6b27b49a16c
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Nov 5 18:34:46 2014 +0200

    ACPI / LPSS: allow to use specific PM domain during ->probe()
    
    The LPSS DMA controller would like to use the specific PM domain callbacks
    during early stage, namely in ->probe(). This patch moves the specific PM
    domain assignment early to be accessible during a whole life time of the device
    in the system.
    
    Suggested-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Scott Ashcroft <scott.ashcroft@talk21.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index f6b71afb80ea..4804ae31b057 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -659,19 +659,17 @@ static int acpi_lpss_platform_notify(struct notifier_block *nb,
 	}
 
 	switch (action) {
-	case BUS_NOTIFY_BOUND_DRIVER:
-		pdev->dev.pm_domain = &acpi_lpss_pm_domain;
-		break;
-	case BUS_NOTIFY_UNBOUND_DRIVER:
-		pdev->dev.pm_domain = NULL;
-		break;
 	case BUS_NOTIFY_ADD_DEVICE:
+		pdev->dev.pm_domain = &acpi_lpss_pm_domain;
 		if (pdata->dev_desc->flags & LPSS_LTR)
 			return sysfs_create_group(&pdev->dev.kobj,
 						  &lpss_attr_group);
+		break;
 	case BUS_NOTIFY_DEL_DEVICE:
 		if (pdata->dev_desc->flags & LPSS_LTR)
 			sysfs_remove_group(&pdev->dev.kobj, &lpss_attr_group);
+		pdev->dev.pm_domain = NULL;
+		break;
 	default:
 		break;
 	}

commit cb39dcdd4ef6a31028ecd663768b99e6230d3ee6
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Nov 5 18:34:45 2014 +0200

    ACPI / LPSS: add all LPSS devices to the specific power domain
    
    Currently the LPSS devices are located in the different power domains depends
    on LPSS_SAVE_CTX flag. We would like to use the specific power domain for all
    LPSS devices.
    
    The LPSS DMA controller has no knobs to control its power state. The specific
    power domain implementation will handle this case. The patch does a preparation
    for that.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Scott Ashcroft <scott.ashcroft@talk21.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 93d160661f4c..f6b71afb80ea 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -499,14 +499,15 @@ static void acpi_lpss_set_ltr(struct device *dev, s32 val)
 /**
  * acpi_lpss_save_ctx() - Save the private registers of LPSS device
  * @dev: LPSS device
+ * @pdata: pointer to the private data of the LPSS device
  *
  * Most LPSS devices have private registers which may loose their context when
  * the device is powered down. acpi_lpss_save_ctx() saves those registers into
  * prv_reg_ctx array.
  */
-static void acpi_lpss_save_ctx(struct device *dev)
+static void acpi_lpss_save_ctx(struct device *dev,
+			       struct lpss_private_data *pdata)
 {
-	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
 	unsigned int i;
 
 	for (i = 0; i < LPSS_PRV_REG_COUNT; i++) {
@@ -521,12 +522,13 @@ static void acpi_lpss_save_ctx(struct device *dev)
 /**
  * acpi_lpss_restore_ctx() - Restore the private registers of LPSS device
  * @dev: LPSS device
+ * @pdata: pointer to the private data of the LPSS device
  *
  * Restores the registers that were previously stored with acpi_lpss_save_ctx().
  */
-static void acpi_lpss_restore_ctx(struct device *dev)
+static void acpi_lpss_restore_ctx(struct device *dev,
+				  struct lpss_private_data *pdata)
 {
-	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
 	unsigned int i;
 
 	/*
@@ -549,23 +551,31 @@ static void acpi_lpss_restore_ctx(struct device *dev)
 #ifdef CONFIG_PM_SLEEP
 static int acpi_lpss_suspend_late(struct device *dev)
 {
-	int ret = pm_generic_suspend_late(dev);
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+	int ret;
 
+	ret = pm_generic_suspend_late(dev);
 	if (ret)
 		return ret;
 
-	acpi_lpss_save_ctx(dev);
+	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
+		acpi_lpss_save_ctx(dev, pdata);
+
 	return acpi_dev_suspend_late(dev);
 }
 
 static int acpi_lpss_resume_early(struct device *dev)
 {
-	int ret = acpi_dev_resume_early(dev);
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+	int ret;
 
+	ret = acpi_dev_resume_early(dev);
 	if (ret)
 		return ret;
 
-	acpi_lpss_restore_ctx(dev);
+	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
+		acpi_lpss_restore_ctx(dev, pdata);
+
 	return pm_generic_resume_early(dev);
 }
 #endif /* CONFIG_PM_SLEEP */
@@ -573,23 +583,31 @@ static int acpi_lpss_resume_early(struct device *dev)
 #ifdef CONFIG_PM_RUNTIME
 static int acpi_lpss_runtime_suspend(struct device *dev)
 {
-	int ret = pm_generic_runtime_suspend(dev);
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+	int ret;
 
+	ret = pm_generic_runtime_suspend(dev);
 	if (ret)
 		return ret;
 
-	acpi_lpss_save_ctx(dev);
+	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
+		acpi_lpss_save_ctx(dev, pdata);
+
 	return acpi_dev_runtime_suspend(dev);
 }
 
 static int acpi_lpss_runtime_resume(struct device *dev)
 {
-	int ret = acpi_dev_runtime_resume(dev);
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+	int ret;
 
+	ret = acpi_dev_runtime_resume(dev);
 	if (ret)
 		return ret;
 
-	acpi_lpss_restore_ctx(dev);
+	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
+		acpi_lpss_restore_ctx(dev, pdata);
+
 	return pm_generic_runtime_resume(dev);
 }
 #endif /* CONFIG_PM_RUNTIME */
@@ -631,22 +649,21 @@ static int acpi_lpss_platform_notify(struct notifier_block *nb,
 		return 0;
 
 	pdata = acpi_driver_data(adev);
-	if (!pdata || !pdata->mmio_base)
+	if (!pdata)
 		return 0;
 
-	if (pdata->mmio_size < pdata->dev_desc->prv_offset + LPSS_LTR_SIZE) {
+	if (pdata->mmio_base &&
+	    pdata->mmio_size < pdata->dev_desc->prv_offset + LPSS_LTR_SIZE) {
 		dev_err(&pdev->dev, "MMIO size insufficient to access LTR\n");
 		return 0;
 	}
 
 	switch (action) {
 	case BUS_NOTIFY_BOUND_DRIVER:
-		if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
-			pdev->dev.pm_domain = &acpi_lpss_pm_domain;
+		pdev->dev.pm_domain = &acpi_lpss_pm_domain;
 		break;
 	case BUS_NOTIFY_UNBOUND_DRIVER:
-		if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
-			pdev->dev.pm_domain = NULL;
+		pdev->dev.pm_domain = NULL;
 		break;
 	case BUS_NOTIFY_ADD_DEVICE:
 		if (pdata->dev_desc->flags & LPSS_LTR)

commit 3f9ae3790e68588cce60dc49b9691116662e8f31
Merge: fe82dcec6442 1f47a77c4e49
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Sep 29 15:29:18 2014 +0200

    Merge back earlier 'acpi-lpss' material for v3.18.

commit 1f47a77c4e4951f141bf20fe7f7c5d9438ea1663
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Thu Sep 11 15:19:33 2014 +0300

    ACPI / LPSS: not using UART RTS override with Auto Flow Control
    
    Adding a check for UART Auto Flow Control feature and only
    enabling the RTS override when it's not supported. RTS
    override is not needed when Auto Flow Control is used and
    they shouldn't be used together.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 1951b5967aa9..76cc698055cd 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -83,18 +83,26 @@ struct lpss_private_data {
 	u32 prv_reg_ctx[LPSS_PRV_REG_COUNT];
 };
 
+/* UART Component Parameter Register */
+#define LPSS_UART_CPR			0xF4
+#define LPSS_UART_CPR_AFCE		BIT(4)
+
 static void lpss_uart_setup(struct lpss_private_data *pdata)
 {
 	unsigned int offset;
-	u32 reg;
+	u32 val;
 
 	offset = pdata->dev_desc->prv_offset + LPSS_TX_INT;
-	reg = readl(pdata->mmio_base + offset);
-	writel(reg | LPSS_TX_INT_MASK, pdata->mmio_base + offset);
-
-	offset = pdata->dev_desc->prv_offset + LPSS_GENERAL;
-	reg = readl(pdata->mmio_base + offset);
-	writel(reg | LPSS_GENERAL_UART_RTS_OVRD, pdata->mmio_base + offset);
+	val = readl(pdata->mmio_base + offset);
+	writel(val | LPSS_TX_INT_MASK, pdata->mmio_base + offset);
+
+	val = readl(pdata->mmio_base + LPSS_UART_CPR);
+	if (!(val & LPSS_UART_CPR_AFCE)) {
+		offset = pdata->dev_desc->prv_offset + LPSS_GENERAL;
+		val = readl(pdata->mmio_base + offset);
+		val |= LPSS_GENERAL_UART_RTS_OVRD;
+		writel(val, pdata->mmio_base + offset);
+	}
 }
 
 static void byt_i2c_setup(struct lpss_private_data *pdata)

commit 457920817e645a7dee42c2a75c81c5ed8e12ee1c
Author: Fu Zhonghui <zhonghui.fu@linux.intel.com>
Date:   Wed Sep 24 22:42:26 2014 +0200

    ACPI / platform / LPSS: disable async suspend/resume of LPSS devices
    
    On some systems (Asus T100 in particular) there are strict ordering
    dependencies between LPSS devices with respect to power management
    that break if they suspend/resume asynchronously.
    
    In theory it should be possible to follow those dependencies in the
    async suspend/resume case too (the ACPI tables tell as that the
    dependencies are there), but since we're missing infrastructure
    for that at the moment, disable async suspend/resume for all of
    the LPSS devices for the time being.
    
    Link: http://marc.info/?l=linux-acpi&m=141158962321905&w=2
    Fixes: 8ce62f85a81f (ACPI / platform / LPSS: Enable async suspend/resume of LPSS devices)
    Signed-off-by: Li Aubrey <aubrey.li@linux.intel.com>
    Signed-off-by: Fu Zhonghui <zhonghui.fu@linux.intel.com>
    Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index fddc1e86f9d0..b0ea767c8696 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -419,7 +419,6 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 	adev->driver_data = pdata;
 	pdev = acpi_create_platform_device(adev);
 	if (!IS_ERR_OR_NULL(pdev)) {
-		device_enable_async_suspend(&pdev->dev);
 		return 1;
 	}
 

commit 871dd05c0520c2e4caf5516455fb08abc86cd703
Merge: 9e82bf014195 3f56bf3e939f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Sep 21 01:15:34 2014 +0200

    Merge back earlier 'acpi-lpss' material for 3.18-rc1

commit f4168b617ac09986c4333accaff5d8ba5a9db7bf
Author: Fu Zhonghui <zhonghui.fu@linux.intel.com>
Date:   Tue Sep 9 16:30:06 2014 +0200

    ACPI / LPSS: complete PM entries for LPSS power domain
    
    PM entries of LPSS power domain were not implemented correctly
    in commit c78b0830667a "ACPI / LPSS: custom power domain for LPSS".
    
    This patch fixes and completes these PM entries.
    
    Fixes: c78b0830667a (ACPI / LPSS: custom power domain for LPSS)
    Signed-off-by: Li Aubrey <aubrey.li@linux.intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Fu Zhonghui <zhonghui.fu@linux.intel.com>
    Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 9dfec48dd4e5..fddc1e86f9d0 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -610,7 +610,7 @@ static int acpi_lpss_suspend_late(struct device *dev)
 	return acpi_dev_suspend_late(dev);
 }
 
-static int acpi_lpss_restore_early(struct device *dev)
+static int acpi_lpss_resume_early(struct device *dev)
 {
 	int ret = acpi_dev_resume_early(dev);
 
@@ -650,15 +650,15 @@ static int acpi_lpss_runtime_resume(struct device *dev)
 static struct dev_pm_domain acpi_lpss_pm_domain = {
 	.ops = {
 #ifdef CONFIG_PM_SLEEP
-		.suspend_late = acpi_lpss_suspend_late,
-		.restore_early = acpi_lpss_restore_early,
 		.prepare = acpi_subsys_prepare,
 		.complete = acpi_subsys_complete,
 		.suspend = acpi_subsys_suspend,
-		.resume_early = acpi_subsys_resume_early,
+		.suspend_late = acpi_lpss_suspend_late,
+		.resume_early = acpi_lpss_resume_early,
 		.freeze = acpi_subsys_freeze,
 		.poweroff = acpi_subsys_suspend,
-		.poweroff_late = acpi_subsys_suspend_late,
+		.poweroff_late = acpi_lpss_suspend_late,
+		.restore_early = acpi_lpss_resume_early,
 #endif
 #ifdef CONFIG_PM_RUNTIME
 		.runtime_suspend = acpi_lpss_runtime_suspend,

commit 3f56bf3e939f0344febf92c41fbc0c26a21593c4
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Tue Sep 2 10:55:10 2014 +0300

    ACPI / LPSS: remove struct lpss_shared_clock
    
    Nothing requires it anymore. The PWM driver no longer
    uses clk framework to get the rate.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index b693098f2160..bcbdbd224c10 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -61,19 +61,12 @@ ACPI_MODULE_NAME("acpi_lpss");
 #define LPSS_LTR			BIT(3)
 #define LPSS_SAVE_CTX			BIT(4)
 
-struct lpss_shared_clock {
-	const char *name;
-	unsigned long rate;
-	struct clk *clk;
-};
-
 struct lpss_private_data;
 
 struct lpss_device_desc {
 	unsigned int flags;
 	unsigned int prv_offset;
 	size_t prv_size_override;
-	struct lpss_shared_clock *shared_clock;
 	void (*setup)(struct lpss_private_data *pdata);
 };
 
@@ -140,14 +133,8 @@ static struct lpss_device_desc lpt_sdio_dev_desc = {
 	.prv_size_override = 0x1018,
 };
 
-static struct lpss_shared_clock pwm_clock = {
-	.name = "pwm_clk",
-	.rate = 25000000,
-};
-
 static struct lpss_device_desc byt_pwm_dev_desc = {
-	.flags = LPSS_CLK | LPSS_SAVE_CTX,
-	.shared_clock = &pwm_clock,
+	.flags = LPSS_SAVE_CTX,
 };
 
 static struct lpss_device_desc byt_uart_dev_desc = {
@@ -171,16 +158,6 @@ static struct lpss_device_desc byt_i2c_dev_desc = {
 	.setup = byt_i2c_setup,
 };
 
-static struct lpss_shared_clock bsw_pwm_clock = {
-	.name = "pwm_clk",
-	.rate = 19200000,
-};
-
-static struct lpss_device_desc bsw_pwm_dev_desc = {
-	.flags = LPSS_CLK | LPSS_SAVE_CTX,
-	.shared_clock = &bsw_pwm_clock,
-};
-
 #else
 
 #define LPSS_ADDR(desc) (0UL)
@@ -211,7 +188,7 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	{ "INT33FC", },
 
 	/* Braswell LPSS devices */
-	{ "80862288", LPSS_ADDR(bsw_pwm_dev_desc) },
+	{ "80862288", LPSS_ADDR(byt_pwm_dev_desc) },
 	{ "8086228A", LPSS_ADDR(byt_uart_dev_desc) },
 	{ "8086228E", LPSS_ADDR(byt_spi_dev_desc) },
 	{ "808622C1", LPSS_ADDR(byt_i2c_dev_desc) },
@@ -251,7 +228,6 @@ static int register_device_clock(struct acpi_device *adev,
 				 struct lpss_private_data *pdata)
 {
 	const struct lpss_device_desc *dev_desc = pdata->dev_desc;
-	struct lpss_shared_clock *shared_clock = dev_desc->shared_clock;
 	const char *devname = dev_name(&adev->dev);
 	struct clk *clk = ERR_PTR(-ENODEV);
 	struct lpss_clk_data *clk_data;
@@ -273,17 +249,6 @@ static int register_device_clock(struct acpi_device *adev,
 	parent = clk_data->name;
 	prv_base = pdata->mmio_base + dev_desc->prv_offset;
 
-	if (shared_clock) {
-		clk = shared_clock->clk;
-		if (!clk) {
-			clk = clk_register_fixed_rate(NULL, shared_clock->name,
-						      "lpss_clk", 0,
-						      shared_clock->rate);
-			shared_clock->clk = clk;
-		}
-		parent = shared_clock->name;
-	}
-
 	if (pdata->fixed_clk_rate) {
 		clk = clk_register_fixed_rate(NULL, devname, parent, 0,
 					      pdata->fixed_clk_rate);

commit 03f09f73bbd805f918fdc76888a1a83cdc28f28b
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Tue Sep 2 10:55:09 2014 +0300

    ACPI / LPSS: support for 133MHz I2C source clock on Baytrail
    
    The I2C controllers on Baytrail can get the clock from
    100MHz or 133MHz source clock. The first bits in the private
    clock parameter register indicates which one is being used.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index db3498bc4c2a..b693098f2160 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -84,6 +84,7 @@ static struct lpss_device_desc lpss_dma_desc = {
 struct lpss_private_data {
 	void __iomem *mmio_base;
 	resource_size_t mmio_size;
+	unsigned int fixed_clk_rate;
 	struct clk *clk;
 	const struct lpss_device_desc *dev_desc;
 	u32 prv_reg_ctx[LPSS_PRV_REG_COUNT];
@@ -103,7 +104,7 @@ static void lpss_uart_setup(struct lpss_private_data *pdata)
 	writel(reg | LPSS_GENERAL_UART_RTS_OVRD, pdata->mmio_base + offset);
 }
 
-static void lpss_i2c_setup(struct lpss_private_data *pdata)
+static void byt_i2c_setup(struct lpss_private_data *pdata)
 {
 	unsigned int offset;
 	u32 val;
@@ -112,6 +113,9 @@ static void lpss_i2c_setup(struct lpss_private_data *pdata)
 	val = readl(pdata->mmio_base + offset);
 	val |= LPSS_RESETS_RESET_APB | LPSS_RESETS_RESET_FUNC;
 	writel(val, pdata->mmio_base + offset);
+
+	if (readl(pdata->mmio_base + pdata->dev_desc->prv_offset))
+		pdata->fixed_clk_rate = 133000000;
 }
 
 static struct lpss_device_desc lpt_dev_desc = {
@@ -161,16 +165,10 @@ static struct lpss_device_desc byt_sdio_dev_desc = {
 	.flags = LPSS_CLK,
 };
 
-static struct lpss_shared_clock i2c_clock = {
-	.name = "i2c_clk",
-	.rate = 100000000,
-};
-
 static struct lpss_device_desc byt_i2c_dev_desc = {
 	.flags = LPSS_CLK | LPSS_SAVE_CTX,
 	.prv_offset = 0x800,
-	.shared_clock = &i2c_clock,
-	.setup = lpss_i2c_setup,
+	.setup = byt_i2c_setup,
 };
 
 static struct lpss_shared_clock bsw_pwm_clock = {
@@ -286,6 +284,12 @@ static int register_device_clock(struct acpi_device *adev,
 		parent = shared_clock->name;
 	}
 
+	if (pdata->fixed_clk_rate) {
+		clk = clk_register_fixed_rate(NULL, devname, parent, 0,
+					      pdata->fixed_clk_rate);
+		goto out;
+	}
+
 	if (dev_desc->flags & LPSS_CLK_GATE) {
 		clk = clk_register_gate(NULL, devname, parent, 0,
 					prv_base, 0, 0, NULL);
@@ -316,7 +320,7 @@ static int register_device_clock(struct acpi_device *adev,
 		kfree(parent);
 		kfree(clk_name);
 	}
-
+out:
 	if (IS_ERR(clk))
 		return PTR_ERR(clk);
 
@@ -364,6 +368,9 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 
 	pdata->dev_desc = dev_desc;
 
+	if (dev_desc->setup)
+		dev_desc->setup(pdata);
+
 	if (dev_desc->flags & LPSS_CLK) {
 		ret = register_device_clock(adev, pdata);
 		if (ret) {
@@ -385,9 +392,6 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 		goto err_out;
 	}
 
-	if (dev_desc->setup)
-		dev_desc->setup(pdata);
-
 	adev->driver_data = pdata;
 	pdev = acpi_create_platform_device(adev);
 	if (!IS_ERR_OR_NULL(pdev)) {

commit b0d00f8bd526dab6878913dfd5690eee5d4be10e
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Tue Sep 2 10:55:08 2014 +0300

    ACPI / LPSS: drop clkdev_name member from lpss_device_desc
    
    It was used to provide the correct con_id for the dma
    driver, but it's not needed. Even if the driver requests a
    clock with the con_id, it still gets the correct clock. The
    device name is enough to match a single clock.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 4723a0e8335a..db3498bc4c2a 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -70,7 +70,6 @@ struct lpss_shared_clock {
 struct lpss_private_data;
 
 struct lpss_device_desc {
-	const char *clkdev_name;
 	unsigned int flags;
 	unsigned int prv_offset;
 	size_t prv_size_override;
@@ -79,7 +78,6 @@ struct lpss_device_desc {
 };
 
 static struct lpss_device_desc lpss_dma_desc = {
-	.clkdev_name = "hclk",
 	.flags = LPSS_CLK,
 };
 
@@ -268,12 +266,7 @@ static int register_device_clock(struct acpi_device *adev,
 	clk_data = platform_get_drvdata(lpss_clk_dev);
 	if (!clk_data)
 		return -ENODEV;
-
-	if (dev_desc->clkdev_name) {
-		clk_register_clkdev(clk_data->clk, dev_desc->clkdev_name,
-				    devname);
-		return 0;
-	}
+	clk = clk_data->clk;
 
 	if (!pdata->mmio_base
 	    || pdata->mmio_size < dev_desc->prv_offset + LPSS_CLK_SIZE)

commit ff8c1af5e7ebfdf2da5d2063ee34e16a8d05643c
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Tue Sep 2 10:55:07 2014 +0300

    ACPI / LPSS: introduce flags
    
    Replace the booleans with a single flags member variable.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 9dfec48dd4e5..4723a0e8335a 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -54,6 +54,13 @@ ACPI_MODULE_NAME("acpi_lpss");
 
 #define LPSS_PRV_REG_COUNT		9
 
+/* LPSS Flags */
+#define LPSS_CLK			BIT(0)
+#define LPSS_CLK_GATE			BIT(1)
+#define LPSS_CLK_DIVIDER		BIT(2)
+#define LPSS_LTR			BIT(3)
+#define LPSS_SAVE_CTX			BIT(4)
+
 struct lpss_shared_clock {
 	const char *name;
 	unsigned long rate;
@@ -63,21 +70,17 @@ struct lpss_shared_clock {
 struct lpss_private_data;
 
 struct lpss_device_desc {
-	bool clk_required;
 	const char *clkdev_name;
-	bool ltr_required;
+	unsigned int flags;
 	unsigned int prv_offset;
 	size_t prv_size_override;
-	bool clk_divider;
-	bool clk_gate;
-	bool save_ctx;
 	struct lpss_shared_clock *shared_clock;
 	void (*setup)(struct lpss_private_data *pdata);
 };
 
 static struct lpss_device_desc lpss_dma_desc = {
-	.clk_required = true,
 	.clkdev_name = "hclk",
+	.flags = LPSS_CLK,
 };
 
 struct lpss_private_data {
@@ -113,42 +116,26 @@ static void lpss_i2c_setup(struct lpss_private_data *pdata)
 	writel(val, pdata->mmio_base + offset);
 }
 
-static struct lpss_device_desc wpt_dev_desc = {
-	.clk_required = true,
-	.prv_offset = 0x800,
-	.ltr_required = true,
-	.clk_divider = true,
-	.clk_gate = true,
-};
-
 static struct lpss_device_desc lpt_dev_desc = {
-	.clk_required = true,
+	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_LTR,
 	.prv_offset = 0x800,
-	.ltr_required = true,
-	.clk_divider = true,
-	.clk_gate = true,
 };
 
 static struct lpss_device_desc lpt_i2c_dev_desc = {
-	.clk_required = true,
+	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_LTR,
 	.prv_offset = 0x800,
-	.ltr_required = true,
-	.clk_gate = true,
 };
 
 static struct lpss_device_desc lpt_uart_dev_desc = {
-	.clk_required = true,
+	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_LTR,
 	.prv_offset = 0x800,
-	.ltr_required = true,
-	.clk_divider = true,
-	.clk_gate = true,
 	.setup = lpss_uart_setup,
 };
 
 static struct lpss_device_desc lpt_sdio_dev_desc = {
+	.flags = LPSS_LTR,
 	.prv_offset = 0x1000,
 	.prv_size_override = 0x1018,
-	.ltr_required = true,
 };
 
 static struct lpss_shared_clock pwm_clock = {
@@ -157,30 +144,23 @@ static struct lpss_shared_clock pwm_clock = {
 };
 
 static struct lpss_device_desc byt_pwm_dev_desc = {
-	.clk_required = true,
-	.save_ctx = true,
+	.flags = LPSS_CLK | LPSS_SAVE_CTX,
 	.shared_clock = &pwm_clock,
 };
 
 static struct lpss_device_desc byt_uart_dev_desc = {
-	.clk_required = true,
+	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX,
 	.prv_offset = 0x800,
-	.clk_divider = true,
-	.clk_gate = true,
-	.save_ctx = true,
 	.setup = lpss_uart_setup,
 };
 
 static struct lpss_device_desc byt_spi_dev_desc = {
-	.clk_required = true,
+	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX,
 	.prv_offset = 0x400,
-	.clk_divider = true,
-	.clk_gate = true,
-	.save_ctx = true,
 };
 
 static struct lpss_device_desc byt_sdio_dev_desc = {
-	.clk_required = true,
+	.flags = LPSS_CLK,
 };
 
 static struct lpss_shared_clock i2c_clock = {
@@ -189,9 +169,8 @@ static struct lpss_shared_clock i2c_clock = {
 };
 
 static struct lpss_device_desc byt_i2c_dev_desc = {
-	.clk_required = true,
+	.flags = LPSS_CLK | LPSS_SAVE_CTX,
 	.prv_offset = 0x800,
-	.save_ctx = true,
 	.shared_clock = &i2c_clock,
 	.setup = lpss_i2c_setup,
 };
@@ -202,8 +181,7 @@ static struct lpss_shared_clock bsw_pwm_clock = {
 };
 
 static struct lpss_device_desc bsw_pwm_dev_desc = {
-	.clk_required = true,
-	.save_ctx = true,
+	.flags = LPSS_CLK | LPSS_SAVE_CTX,
 	.shared_clock = &bsw_pwm_clock,
 };
 
@@ -251,7 +229,8 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	{ "INT3436", LPSS_ADDR(lpt_sdio_dev_desc) },
 	{ "INT3437", },
 
-	{ "INT3438", LPSS_ADDR(wpt_dev_desc) },
+	/* Wildcat Point LPSS devices */
+	{ "INT3438", LPSS_ADDR(lpt_dev_desc) },
 
 	{ }
 };
@@ -314,13 +293,13 @@ static int register_device_clock(struct acpi_device *adev,
 		parent = shared_clock->name;
 	}
 
-	if (dev_desc->clk_gate) {
+	if (dev_desc->flags & LPSS_CLK_GATE) {
 		clk = clk_register_gate(NULL, devname, parent, 0,
 					prv_base, 0, 0, NULL);
 		parent = devname;
 	}
 
-	if (dev_desc->clk_divider) {
+	if (dev_desc->flags & LPSS_CLK_DIVIDER) {
 		/* Prevent division by zero */
 		if (!readl(prv_base))
 			writel(LPSS_CLK_DIVIDER_DEF_MASK, prv_base);
@@ -392,7 +371,7 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 
 	pdata->dev_desc = dev_desc;
 
-	if (dev_desc->clk_required) {
+	if (dev_desc->flags & LPSS_CLK) {
 		ret = register_device_clock(adev, pdata);
 		if (ret) {
 			/* Skip the device, but continue the namespace scan. */
@@ -693,19 +672,19 @@ static int acpi_lpss_platform_notify(struct notifier_block *nb,
 
 	switch (action) {
 	case BUS_NOTIFY_BOUND_DRIVER:
-		if (pdata->dev_desc->save_ctx)
+		if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
 			pdev->dev.pm_domain = &acpi_lpss_pm_domain;
 		break;
 	case BUS_NOTIFY_UNBOUND_DRIVER:
-		if (pdata->dev_desc->save_ctx)
+		if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
 			pdev->dev.pm_domain = NULL;
 		break;
 	case BUS_NOTIFY_ADD_DEVICE:
-		if (pdata->dev_desc->ltr_required)
+		if (pdata->dev_desc->flags & LPSS_LTR)
 			return sysfs_create_group(&pdev->dev.kobj,
 						  &lpss_attr_group);
 	case BUS_NOTIFY_DEL_DEVICE:
-		if (pdata->dev_desc->ltr_required)
+		if (pdata->dev_desc->flags & LPSS_LTR)
 			sysfs_remove_group(&pdev->dev.kobj, &lpss_attr_group);
 	default:
 		break;
@@ -722,7 +701,7 @@ static void acpi_lpss_bind(struct device *dev)
 {
 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
 
-	if (!pdata || !pdata->mmio_base || !pdata->dev_desc->ltr_required)
+	if (!pdata || !pdata->mmio_base || !(pdata->dev_desc->flags & LPSS_LTR))
 		return;
 
 	if (pdata->mmio_size >= pdata->dev_desc->prv_offset + LPSS_LTR_SIZE)

commit 1bfbd8eb8a7f6f1eb573ccdfae5c86395abc79cb
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Aug 19 15:55:22 2014 +0300

    ACPI / LPSS: Add ACPI IDs for Intel Braswell
    
    Enable more identifiers for the existing devices for Intel Braswell and
    Cherryview.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index ce06149088c5..9dfec48dd4e5 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -196,6 +196,17 @@ static struct lpss_device_desc byt_i2c_dev_desc = {
 	.setup = lpss_i2c_setup,
 };
 
+static struct lpss_shared_clock bsw_pwm_clock = {
+	.name = "pwm_clk",
+	.rate = 19200000,
+};
+
+static struct lpss_device_desc bsw_pwm_dev_desc = {
+	.clk_required = true,
+	.save_ctx = true,
+	.shared_clock = &bsw_pwm_clock,
+};
+
 #else
 
 #define LPSS_ADDR(desc) (0UL)
@@ -225,6 +236,12 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	{ "INT33B2", },
 	{ "INT33FC", },
 
+	/* Braswell LPSS devices */
+	{ "80862288", LPSS_ADDR(bsw_pwm_dev_desc) },
+	{ "8086228A", LPSS_ADDR(byt_uart_dev_desc) },
+	{ "8086228E", LPSS_ADDR(byt_spi_dev_desc) },
+	{ "808622C1", LPSS_ADDR(byt_i2c_dev_desc) },
+
 	{ "INT3430", LPSS_ADDR(lpt_dev_desc) },
 	{ "INT3431", LPSS_ADDR(lpt_dev_desc) },
 	{ "INT3432", LPSS_ADDR(lpt_i2c_dev_desc) },

commit 43218a1b3ba7c8e39d88b5c0a43841f0e3e17470
Author: Jie Yang <yang.jie@intel.com>
Date:   Fri Aug 1 09:06:35 2014 +0800

    ACPI / LPSS: add LPSS device for Wildcat Point PCH
    
    INT3438 is the ADSP device on Wildcat Point platform
    with 2 DW DMA engines built In. The DMA engines are
    used for DSP FW loading and audio data transferring.
    These DMA engine probing need the clock, without it,
    probing may failed and can't go forward.
    
    Add LPSS device "INT3438" for Wildcat Point PCH, to
    provide clock for its ADSP DMA engine probing.
    
    Signed-off-by: Jie Yang <yang.jie@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 9cb65b0e7597..ce06149088c5 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -113,6 +113,14 @@ static void lpss_i2c_setup(struct lpss_private_data *pdata)
 	writel(val, pdata->mmio_base + offset);
 }
 
+static struct lpss_device_desc wpt_dev_desc = {
+	.clk_required = true,
+	.prv_offset = 0x800,
+	.ltr_required = true,
+	.clk_divider = true,
+	.clk_gate = true,
+};
+
 static struct lpss_device_desc lpt_dev_desc = {
 	.clk_required = true,
 	.prv_offset = 0x800,
@@ -226,6 +234,8 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	{ "INT3436", LPSS_ADDR(lpt_sdio_dev_desc) },
 	{ "INT3437", },
 
+	{ "INT3438", LPSS_ADDR(wpt_dev_desc) },
+
 	{ }
 };
 

commit 765bdd4e51674c1ae3a61ceb12a05706bf6b691b
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Jun 17 14:33:39 2014 +0300

    ACPI / LPSS: Take I2C host controllers out of reset
    
    On Intel Baytrail, some I2C host controllers are held in reset when the OS
    gets control. This causes the driver to fail to detect the hardware
    properly.
    
    Fix this so that we make sure that the I2C host controller is not in reset
    when the driver gets probe'd.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 63407d264885..9cb65b0e7597 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -34,6 +34,9 @@ ACPI_MODULE_NAME("acpi_lpss");
 
 /* Offsets relative to LPSS_PRIVATE_OFFSET */
 #define LPSS_CLK_DIVIDER_DEF_MASK	(BIT(1) | BIT(16))
+#define LPSS_RESETS			0x04
+#define LPSS_RESETS_RESET_FUNC		BIT(0)
+#define LPSS_RESETS_RESET_APB		BIT(1)
 #define LPSS_GENERAL			0x08
 #define LPSS_GENERAL_LTR_MODE_SW	BIT(2)
 #define LPSS_GENERAL_UART_RTS_OVRD	BIT(3)
@@ -99,6 +102,17 @@ static void lpss_uart_setup(struct lpss_private_data *pdata)
 	writel(reg | LPSS_GENERAL_UART_RTS_OVRD, pdata->mmio_base + offset);
 }
 
+static void lpss_i2c_setup(struct lpss_private_data *pdata)
+{
+	unsigned int offset;
+	u32 val;
+
+	offset = pdata->dev_desc->prv_offset + LPSS_RESETS;
+	val = readl(pdata->mmio_base + offset);
+	val |= LPSS_RESETS_RESET_APB | LPSS_RESETS_RESET_FUNC;
+	writel(val, pdata->mmio_base + offset);
+}
+
 static struct lpss_device_desc lpt_dev_desc = {
 	.clk_required = true,
 	.prv_offset = 0x800,
@@ -171,6 +185,7 @@ static struct lpss_device_desc byt_i2c_dev_desc = {
 	.prv_offset = 0x800,
 	.save_ctx = true,
 	.shared_clock = &i2c_clock,
+	.setup = lpss_i2c_setup,
 };
 
 #else

commit 4dc4226f994db264c844a5fcf556935c66f963a5
Merge: d6b92c2c373e 2e30baad2286
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 4 08:57:16 2014 -0700

    Merge tag 'pm+acpi-3.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm into next
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "ACPICA is the leader this time (63 commits), followed by cpufreq (28
      commits), devfreq (15 commits), system suspend/hibernation (12
      commits), ACPI video and ACPI device enumeration (10 commits each).
    
      We have no major new features this time, but there are a few
      significant changes of how things work.  The most visible one will
      probably be that we are now going to create platform devices rather
      than PNP devices by default for ACPI device objects with _HID.  That
      was long overdue and will be really necessary to be able to use the
      same drivers for the same hardware blocks on ACPI and DT-based systems
      going forward.  We're not expecting fallout from this one (as usual),
      but it's something to watch nevertheless.
    
      The second change having a chance to be visible is that ACPI video
      will now default to using native backlight rather than the ACPI
      backlight interface which should generally help systems with broken
      Win8 BIOSes.  We're hoping that all problems with the native backlight
      handling that we had previously have been addressed and we are in a
      good enough shape to flip the default, but this change should be easy
      enough to revert if need be.
    
      In addition to that, the system suspend core has a new mechanism to
      allow runtime-suspended devices to stay suspended throughout system
      suspend/resume transitions if some extra conditions are met
      (generally, they are related to coordination within device hierarchy).
      However, enabling this feature requires cooperation from the bus type
      layer and for now it has only been implemented for the ACPI PM domain
      (used by ACPI-enumerated platform devices mostly today).
    
      Also, the acpidump utility that was previously shipped as a separate
      tool will now be provided by the upstream ACPICA along with the rest
      of ACPICA code, which will allow it to be more up to date and better
      supported, and we have one new cpuidle driver (ARM clps711x).
    
      The rest is improvements related to certain specific use cases,
      cleanups and fixes all over the place.
    
      Specifics:
    
       - ACPICA update to upstream version 20140424.  That includes a number
         of fixes and improvements related to things like GPE handling,
         table loading, headers, memory mapping and unmapping, DSDT/SSDT
         overriding, and the Unload() operator.  The acpidump utility from
         upstream ACPICA is included too.  From Bob Moore, Lv Zheng, David
         Box, David Binderman, and Colin Ian King.
    
       - Fixes and cleanups related to ACPI video and backlight interfaces
         from Hans de Goede.  That includes blacklist entries for some new
         machines and using native backlight by default.
    
       - ACPI device enumeration changes to create platform devices rather
         than PNP devices for ACPI device objects with _HID by default.  PNP
         devices will still be created for the ACPI device object with
         device IDs corresponding to real PNP devices, so that change should
         not break things left and right, and we're expecting to see more
         and more ACPI-enumerated platform devices in the future.  From
         Zhang Rui and Rafael J Wysocki.
    
       - Updates for the ACPI LPSS (Low-Power Subsystem) driver allowing it
         to handle system suspend/resume on Asus T100 correctly.  From
         Heikki Krogerus and Rafael J Wysocki.
    
       - PM core update introducing a mechanism to allow runtime-suspended
         devices to stay suspended over system suspend/resume transitions if
         certain additional conditions related to coordination within device
         hierarchy are met.  Related PM documentation update and ACPI PM
         domain support for the new feature.  From Rafael J Wysocki.
    
       - Fixes and improvements related to the "freeze" sleep state.  They
         affect several places including cpuidle, PM core, ACPI core, and
         the ACPI battery driver.  From Rafael J Wysocki and Zhang Rui.
    
       - Miscellaneous fixes and updates of the ACPI core from Aaron Lu,
         Bjørn Mork, Hanjun Guo, Lan Tianyu, and Rafael J Wysocki.
    
       - Fixes and cleanups for the ACPI processor and ACPI PAD (Processor
         Aggregator Device) drivers from Baoquan He, Manuel Schölling, Tony
         Camuso, and Toshi Kani.
    
       - System suspend/resume optimization in the ACPI battery driver from
         Lan Tianyu.
    
       - OPP (Operating Performance Points) subsystem updates from Chander
         Kashyap, Mark Brown, and Nishanth Menon.
    
       - cpufreq core fixes, updates and cleanups from Srivatsa S Bhat,
         Stratos Karafotis, and Viresh Kumar.
    
       - Updates, fixes and cleanups for the Tegra, powernow-k8, imx6q,
         s5pv210, nforce2, and powernv cpufreq drivers from Brian Norris,
         Jingoo Han, Paul Bolle, Philipp Zabel, Stratos Karafotis, and
         Viresh Kumar.
    
       - intel_pstate driver fixes and cleanups from Dirk Brandewie, Doug
         Smythies, and Stratos Karafotis.
    
       - Enabling the big.LITTLE cpufreq driver on arm64 from Mark Brown.
    
       - Fix for the cpuidle menu governor from Chander Kashyap.
    
       - New ARM clps711x cpuidle driver from Alexander Shiyan.
    
       - Hibernate core fixes and cleanups from Chen Gang, Dan Carpenter,
         Fabian Frederick, Pali Rohár, and Sebastian Capella.
    
       - Intel RAPL (Running Average Power Limit) driver updates from Jacob
         Pan.
    
       - PNP subsystem updates from Bjorn Helgaas and Fabian Frederick.
    
       - devfreq core updates from Chanwoo Choi and Paul Bolle.
    
       - devfreq updates for exynos4 and exynos5 from Chanwoo Choi and
         Bartlomiej Zolnierkiewicz.
    
       - turbostat tool fix from Jean Delvare.
    
       - cpupower tool updates from Prarit Bhargava, Ramkumar Ramachandra
         and Thomas Renninger.
    
       - New ACPI ec_access.c tool for poking at the EC in a safe way from
         Thomas Renninger"
    
    * tag 'pm+acpi-3.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (187 commits)
      ACPICA: Namespace: Remove _PRP method support.
      intel_pstate: Improve initial busy calculation
      intel_pstate: add sample time scaling
      intel_pstate: Correct rounding in busy calculation
      intel_pstate: Remove C0 tracking
      PM / hibernate: fixed typo in comment
      ACPI: Fix x86 regression related to early mapping size limitation
      ACPICA: Tables: Add mechanism to control early table checksum verification.
      ACPI / scan: use platform bus type by default for _HID enumeration
      ACPI / scan: always register ACPI LPSS scan handler
      ACPI / scan: always register memory hotplug scan handler
      ACPI / scan: always register container scan handler
      ACPI / scan: Change the meaning of missing .attach() in scan handlers
      ACPI / scan: introduce platform_id device PNP type flag
      ACPI / scan: drop unsupported serial IDs from PNP ACPI scan handler ID list
      ACPI / scan: drop IDs that do not comply with the ACPI PNP ID rule
      ACPI / PNP: use device ID list for PNPACPI device enumeration
      ACPI / scan: .match() callback for ACPI scan handlers
      ACPI / battery: wakeup the system only when necessary
      power_supply: allow power supply devices registered w/o wakeup source
      ...

commit d6ddaaac8f5c37ad84db3e6e019981f392389cf0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 30 14:34:05 2014 +0200

    ACPI / scan: always register ACPI LPSS scan handler
    
    Prevent platform devices from being created for ACPI LPSS devices
    if CONFIG_X86_INTEL_LPSS is unset by compiling out the LPSS scan
    handler's callbacks only in that case and still compiling its device
    ID list in and registering the scan handler in either case.
    
    This change is based on a prototype from Zhang Rui.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index db362a96c38e..51069b260518 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -25,6 +25,10 @@
 
 ACPI_MODULE_NAME("acpi_lpss");
 
+#ifdef CONFIG_X86_INTEL_LPSS
+
+#define LPSS_ADDR(desc) ((unsigned long)&desc)
+
 #define LPSS_CLK_SIZE	0x04
 #define LPSS_LTR_SIZE	0x18
 
@@ -169,40 +173,48 @@ static struct lpss_device_desc byt_i2c_dev_desc = {
 	.shared_clock = &i2c_clock,
 };
 
+#else
+
+#define LPSS_ADDR(desc) (0UL)
+
+#endif /* CONFIG_X86_INTEL_LPSS */
+
 static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	/* Generic LPSS devices */
-	{ "INTL9C60", (unsigned long)&lpss_dma_desc },
+	{ "INTL9C60", LPSS_ADDR(lpss_dma_desc) },
 
 	/* Lynxpoint LPSS devices */
-	{ "INT33C0", (unsigned long)&lpt_dev_desc },
-	{ "INT33C1", (unsigned long)&lpt_dev_desc },
-	{ "INT33C2", (unsigned long)&lpt_i2c_dev_desc },
-	{ "INT33C3", (unsigned long)&lpt_i2c_dev_desc },
-	{ "INT33C4", (unsigned long)&lpt_uart_dev_desc },
-	{ "INT33C5", (unsigned long)&lpt_uart_dev_desc },
-	{ "INT33C6", (unsigned long)&lpt_sdio_dev_desc },
+	{ "INT33C0", LPSS_ADDR(lpt_dev_desc) },
+	{ "INT33C1", LPSS_ADDR(lpt_dev_desc) },
+	{ "INT33C2", LPSS_ADDR(lpt_i2c_dev_desc) },
+	{ "INT33C3", LPSS_ADDR(lpt_i2c_dev_desc) },
+	{ "INT33C4", LPSS_ADDR(lpt_uart_dev_desc) },
+	{ "INT33C5", LPSS_ADDR(lpt_uart_dev_desc) },
+	{ "INT33C6", LPSS_ADDR(lpt_sdio_dev_desc) },
 	{ "INT33C7", },
 
 	/* BayTrail LPSS devices */
-	{ "80860F09", (unsigned long)&byt_pwm_dev_desc },
-	{ "80860F0A", (unsigned long)&byt_uart_dev_desc },
-	{ "80860F0E", (unsigned long)&byt_spi_dev_desc },
-	{ "80860F14", (unsigned long)&byt_sdio_dev_desc },
-	{ "80860F41", (unsigned long)&byt_i2c_dev_desc },
+	{ "80860F09", LPSS_ADDR(byt_pwm_dev_desc) },
+	{ "80860F0A", LPSS_ADDR(byt_uart_dev_desc) },
+	{ "80860F0E", LPSS_ADDR(byt_spi_dev_desc) },
+	{ "80860F14", LPSS_ADDR(byt_sdio_dev_desc) },
+	{ "80860F41", LPSS_ADDR(byt_i2c_dev_desc) },
 	{ "INT33B2", },
 
-	{ "INT3430", (unsigned long)&lpt_dev_desc },
-	{ "INT3431", (unsigned long)&lpt_dev_desc },
-	{ "INT3432", (unsigned long)&lpt_i2c_dev_desc },
-	{ "INT3433", (unsigned long)&lpt_i2c_dev_desc },
-	{ "INT3434", (unsigned long)&lpt_uart_dev_desc },
-	{ "INT3435", (unsigned long)&lpt_uart_dev_desc },
-	{ "INT3436", (unsigned long)&lpt_sdio_dev_desc },
+	{ "INT3430", LPSS_ADDR(lpt_dev_desc) },
+	{ "INT3431", LPSS_ADDR(lpt_dev_desc) },
+	{ "INT3432", LPSS_ADDR(lpt_i2c_dev_desc) },
+	{ "INT3433", LPSS_ADDR(lpt_i2c_dev_desc) },
+	{ "INT3434", LPSS_ADDR(lpt_uart_dev_desc) },
+	{ "INT3435", LPSS_ADDR(lpt_uart_dev_desc) },
+	{ "INT3436", LPSS_ADDR(lpt_sdio_dev_desc) },
 	{ "INT3437", },
 
 	{ }
 };
 
+#ifdef CONFIG_X86_INTEL_LPSS
+
 static int is_memory(struct acpi_resource *res, void *not_used)
 {
 	struct resource r;
@@ -695,3 +707,16 @@ void __init acpi_lpss_init(void)
 		acpi_scan_add_handler(&lpss_handler);
 	}
 }
+
+#else
+
+static struct acpi_scan_handler lpss_handler = {
+	.ids = acpi_lpss_device_ids,
+};
+
+void __init acpi_lpss_init(void)
+{
+	acpi_scan_add_handler(&lpss_handler);
+}
+
+#endif /* CONFIG_X86_INTEL_LPSS */

commit 3022f4de491c096650d55ae9d562a9c811830724
Merge: ed3a872e2ef6 8ce62f85a81f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun May 25 14:41:02 2014 +0200

    Merge branch 'acpi-platform' into acpi-lpss

commit ed3a872e2ef62bde06e2f579d8d1458766ced078
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon May 19 14:42:07 2014 +0300

    ACPI / LPSS: support for fractional divider clock
    
    This creates fractional divider type clock for the ones that
    have it. It is needed by the UART driver as the clock rate must
    accommodate to the requested baud rate.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index a01d4d1343dd..d1c9b04e29a3 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -29,6 +29,7 @@ ACPI_MODULE_NAME("acpi_lpss");
 #define LPSS_LTR_SIZE	0x18
 
 /* Offsets relative to LPSS_PRIVATE_OFFSET */
+#define LPSS_CLK_DIVIDER_DEF_MASK	(BIT(1) | BIT(16))
 #define LPSS_GENERAL			0x08
 #define LPSS_GENERAL_LTR_MODE_SW	BIT(2)
 #define LPSS_GENERAL_UART_RTS_OVRD	BIT(3)
@@ -60,6 +61,7 @@ struct lpss_device_desc {
 	bool ltr_required;
 	unsigned int prv_offset;
 	size_t prv_size_override;
+	bool clk_divider;
 	bool clk_gate;
 	bool save_ctx;
 	struct lpss_shared_clock *shared_clock;
@@ -94,6 +96,14 @@ static void lpss_uart_setup(struct lpss_private_data *pdata)
 }
 
 static struct lpss_device_desc lpt_dev_desc = {
+	.clk_required = true,
+	.prv_offset = 0x800,
+	.ltr_required = true,
+	.clk_divider = true,
+	.clk_gate = true,
+};
+
+static struct lpss_device_desc lpt_i2c_dev_desc = {
 	.clk_required = true,
 	.prv_offset = 0x800,
 	.ltr_required = true,
@@ -104,6 +114,7 @@ static struct lpss_device_desc lpt_uart_dev_desc = {
 	.clk_required = true,
 	.prv_offset = 0x800,
 	.ltr_required = true,
+	.clk_divider = true,
 	.clk_gate = true,
 	.setup = lpss_uart_setup,
 };
@@ -125,31 +136,21 @@ static struct lpss_device_desc byt_pwm_dev_desc = {
 	.shared_clock = &pwm_clock,
 };
 
-static struct lpss_shared_clock uart_clock = {
-	.name = "uart_clk",
-	.rate = 44236800,
-};
-
 static struct lpss_device_desc byt_uart_dev_desc = {
 	.clk_required = true,
 	.prv_offset = 0x800,
+	.clk_divider = true,
 	.clk_gate = true,
 	.save_ctx = true,
-	.shared_clock = &uart_clock,
 	.setup = lpss_uart_setup,
 };
 
-static struct lpss_shared_clock spi_clock = {
-	.name = "spi_clk",
-	.rate = 50000000,
-};
-
 static struct lpss_device_desc byt_spi_dev_desc = {
 	.clk_required = true,
 	.prv_offset = 0x400,
+	.clk_divider = true,
 	.clk_gate = true,
 	.save_ctx = true,
-	.shared_clock = &spi_clock,
 };
 
 static struct lpss_device_desc byt_sdio_dev_desc = {
@@ -175,8 +176,8 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	/* Lynxpoint LPSS devices */
 	{ "INT33C0", (unsigned long)&lpt_dev_desc },
 	{ "INT33C1", (unsigned long)&lpt_dev_desc },
-	{ "INT33C2", (unsigned long)&lpt_dev_desc },
-	{ "INT33C3", (unsigned long)&lpt_dev_desc },
+	{ "INT33C2", (unsigned long)&lpt_i2c_dev_desc },
+	{ "INT33C3", (unsigned long)&lpt_i2c_dev_desc },
 	{ "INT33C4", (unsigned long)&lpt_uart_dev_desc },
 	{ "INT33C5", (unsigned long)&lpt_uart_dev_desc },
 	{ "INT33C6", (unsigned long)&lpt_sdio_dev_desc },
@@ -192,8 +193,8 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 
 	{ "INT3430", (unsigned long)&lpt_dev_desc },
 	{ "INT3431", (unsigned long)&lpt_dev_desc },
-	{ "INT3432", (unsigned long)&lpt_dev_desc },
-	{ "INT3433", (unsigned long)&lpt_dev_desc },
+	{ "INT3432", (unsigned long)&lpt_i2c_dev_desc },
+	{ "INT3433", (unsigned long)&lpt_i2c_dev_desc },
 	{ "INT3434", (unsigned long)&lpt_uart_dev_desc },
 	{ "INT3435", (unsigned long)&lpt_uart_dev_desc },
 	{ "INT3436", (unsigned long)&lpt_sdio_dev_desc },
@@ -221,9 +222,11 @@ static int register_device_clock(struct acpi_device *adev,
 {
 	const struct lpss_device_desc *dev_desc = pdata->dev_desc;
 	struct lpss_shared_clock *shared_clock = dev_desc->shared_clock;
+	const char *devname = dev_name(&adev->dev);
 	struct clk *clk = ERR_PTR(-ENODEV);
 	struct lpss_clk_data *clk_data;
-	const char *parent;
+	const char *parent, *clk_name;
+	void __iomem *prv_base;
 
 	if (!lpss_clk_dev)
 		lpt_register_clock_device();
@@ -234,7 +237,7 @@ static int register_device_clock(struct acpi_device *adev,
 
 	if (dev_desc->clkdev_name) {
 		clk_register_clkdev(clk_data->clk, dev_desc->clkdev_name,
-				    dev_name(&adev->dev));
+				    devname);
 		return 0;
 	}
 
@@ -243,6 +246,7 @@ static int register_device_clock(struct acpi_device *adev,
 		return -ENODATA;
 
 	parent = clk_data->name;
+	prv_base = pdata->mmio_base + dev_desc->prv_offset;
 
 	if (shared_clock) {
 		clk = shared_clock->clk;
@@ -256,16 +260,41 @@ static int register_device_clock(struct acpi_device *adev,
 	}
 
 	if (dev_desc->clk_gate) {
-		clk = clk_register_gate(NULL, dev_name(&adev->dev), parent, 0,
-					pdata->mmio_base + dev_desc->prv_offset,
-					0, 0, NULL);
-		pdata->clk = clk;
+		clk = clk_register_gate(NULL, devname, parent, 0,
+					prv_base, 0, 0, NULL);
+		parent = devname;
+	}
+
+	if (dev_desc->clk_divider) {
+		/* Prevent division by zero */
+		if (!readl(prv_base))
+			writel(LPSS_CLK_DIVIDER_DEF_MASK, prv_base);
+
+		clk_name = kasprintf(GFP_KERNEL, "%s-div", devname);
+		if (!clk_name)
+			return -ENOMEM;
+		clk = clk_register_fractional_divider(NULL, clk_name, parent,
+						      0, prv_base,
+						      1, 15, 16, 15, 0, NULL);
+		parent = clk_name;
+
+		clk_name = kasprintf(GFP_KERNEL, "%s-update", devname);
+		if (!clk_name) {
+			kfree(parent);
+			return -ENOMEM;
+		}
+		clk = clk_register_gate(NULL, clk_name, parent,
+					CLK_SET_RATE_PARENT | CLK_SET_RATE_GATE,
+					prv_base, 31, 0, NULL);
+		kfree(parent);
+		kfree(clk_name);
 	}
 
 	if (IS_ERR(clk))
 		return PTR_ERR(clk);
 
-	clk_register_clkdev(clk, NULL, dev_name(&adev->dev));
+	pdata->clk = clk;
+	clk_register_clkdev(clk, NULL, devname);
 	return 0;
 }
 

commit c78b0830667a7e7c1f0ca65b76b33166a84806b3
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Fri May 23 16:15:09 2014 +0300

    ACPI / LPSS: custom power domain for LPSS
    
    A power domain where we save the context of the additional
    LPSS registers. We need to do this or all LPSS devices are
    left in reset state when resuming from D3 on some Baytrails.
    The devices with the fractional clock divider also have
    zeros for N and M values after resuming unless they are
    reset.
    
    Li Aubrey found the root cause for the issue. The idea of
    using power domain for LPSS came from Mika Westerberg.
    
    Reported-by: Jin Yao <yao.jin@linux.intel.com>
    Suggested-by: Li Aubrey <aubrey.li@linux.intel.com>
    Suggested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    [rjw: Added the .complete() callback to the PM domain, fixed build
     warning on 32-bit.]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 69e29f409d4c..a01d4d1343dd 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -19,6 +19,7 @@
 #include <linux/platform_device.h>
 #include <linux/platform_data/clk-lpss.h>
 #include <linux/pm_runtime.h>
+#include <linux/delay.h>
 
 #include "internal.h"
 
@@ -43,6 +44,8 @@ ACPI_MODULE_NAME("acpi_lpss");
 #define LPSS_TX_INT			0x20
 #define LPSS_TX_INT_MASK		BIT(1)
 
+#define LPSS_PRV_REG_COUNT		9
+
 struct lpss_shared_clock {
 	const char *name;
 	unsigned long rate;
@@ -58,6 +61,7 @@ struct lpss_device_desc {
 	unsigned int prv_offset;
 	size_t prv_size_override;
 	bool clk_gate;
+	bool save_ctx;
 	struct lpss_shared_clock *shared_clock;
 	void (*setup)(struct lpss_private_data *pdata);
 };
@@ -72,6 +76,7 @@ struct lpss_private_data {
 	resource_size_t mmio_size;
 	struct clk *clk;
 	const struct lpss_device_desc *dev_desc;
+	u32 prv_reg_ctx[LPSS_PRV_REG_COUNT];
 };
 
 static void lpss_uart_setup(struct lpss_private_data *pdata)
@@ -116,6 +121,7 @@ static struct lpss_shared_clock pwm_clock = {
 
 static struct lpss_device_desc byt_pwm_dev_desc = {
 	.clk_required = true,
+	.save_ctx = true,
 	.shared_clock = &pwm_clock,
 };
 
@@ -128,6 +134,7 @@ static struct lpss_device_desc byt_uart_dev_desc = {
 	.clk_required = true,
 	.prv_offset = 0x800,
 	.clk_gate = true,
+	.save_ctx = true,
 	.shared_clock = &uart_clock,
 	.setup = lpss_uart_setup,
 };
@@ -141,6 +148,7 @@ static struct lpss_device_desc byt_spi_dev_desc = {
 	.clk_required = true,
 	.prv_offset = 0x400,
 	.clk_gate = true,
+	.save_ctx = true,
 	.shared_clock = &spi_clock,
 };
 
@@ -156,6 +164,7 @@ static struct lpss_shared_clock i2c_clock = {
 static struct lpss_device_desc byt_i2c_dev_desc = {
 	.clk_required = true,
 	.prv_offset = 0x800,
+	.save_ctx = true,
 	.shared_clock = &i2c_clock,
 };
 
@@ -449,6 +458,126 @@ static void acpi_lpss_set_ltr(struct device *dev, s32 val)
 	}
 }
 
+#ifdef CONFIG_PM
+/**
+ * acpi_lpss_save_ctx() - Save the private registers of LPSS device
+ * @dev: LPSS device
+ *
+ * Most LPSS devices have private registers which may loose their context when
+ * the device is powered down. acpi_lpss_save_ctx() saves those registers into
+ * prv_reg_ctx array.
+ */
+static void acpi_lpss_save_ctx(struct device *dev)
+{
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+	unsigned int i;
+
+	for (i = 0; i < LPSS_PRV_REG_COUNT; i++) {
+		unsigned long offset = i * sizeof(u32);
+
+		pdata->prv_reg_ctx[i] = __lpss_reg_read(pdata, offset);
+		dev_dbg(dev, "saving 0x%08x from LPSS reg at offset 0x%02lx\n",
+			pdata->prv_reg_ctx[i], offset);
+	}
+}
+
+/**
+ * acpi_lpss_restore_ctx() - Restore the private registers of LPSS device
+ * @dev: LPSS device
+ *
+ * Restores the registers that were previously stored with acpi_lpss_save_ctx().
+ */
+static void acpi_lpss_restore_ctx(struct device *dev)
+{
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+	unsigned int i;
+
+	/*
+	 * The following delay is needed or the subsequent write operations may
+	 * fail. The LPSS devices are actually PCI devices and the PCI spec
+	 * expects 10ms delay before the device can be accessed after D3 to D0
+	 * transition.
+	 */
+	msleep(10);
+
+	for (i = 0; i < LPSS_PRV_REG_COUNT; i++) {
+		unsigned long offset = i * sizeof(u32);
+
+		__lpss_reg_write(pdata->prv_reg_ctx[i], pdata, offset);
+		dev_dbg(dev, "restoring 0x%08x to LPSS reg at offset 0x%02lx\n",
+			pdata->prv_reg_ctx[i], offset);
+	}
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int acpi_lpss_suspend_late(struct device *dev)
+{
+	int ret = pm_generic_suspend_late(dev);
+
+	if (ret)
+		return ret;
+
+	acpi_lpss_save_ctx(dev);
+	return acpi_dev_suspend_late(dev);
+}
+
+static int acpi_lpss_restore_early(struct device *dev)
+{
+	int ret = acpi_dev_resume_early(dev);
+
+	if (ret)
+		return ret;
+
+	acpi_lpss_restore_ctx(dev);
+	return pm_generic_resume_early(dev);
+}
+#endif /* CONFIG_PM_SLEEP */
+
+#ifdef CONFIG_PM_RUNTIME
+static int acpi_lpss_runtime_suspend(struct device *dev)
+{
+	int ret = pm_generic_runtime_suspend(dev);
+
+	if (ret)
+		return ret;
+
+	acpi_lpss_save_ctx(dev);
+	return acpi_dev_runtime_suspend(dev);
+}
+
+static int acpi_lpss_runtime_resume(struct device *dev)
+{
+	int ret = acpi_dev_runtime_resume(dev);
+
+	if (ret)
+		return ret;
+
+	acpi_lpss_restore_ctx(dev);
+	return pm_generic_runtime_resume(dev);
+}
+#endif /* CONFIG_PM_RUNTIME */
+#endif /* CONFIG_PM */
+
+static struct dev_pm_domain acpi_lpss_pm_domain = {
+	.ops = {
+#ifdef CONFIG_PM_SLEEP
+		.suspend_late = acpi_lpss_suspend_late,
+		.restore_early = acpi_lpss_restore_early,
+		.prepare = acpi_subsys_prepare,
+		.complete = acpi_subsys_complete,
+		.suspend = acpi_subsys_suspend,
+		.resume_early = acpi_subsys_resume_early,
+		.freeze = acpi_subsys_freeze,
+		.poweroff = acpi_subsys_suspend,
+		.poweroff_late = acpi_subsys_suspend_late,
+#endif
+#ifdef CONFIG_PM_RUNTIME
+		.runtime_suspend = acpi_lpss_runtime_suspend,
+		.runtime_resume = acpi_lpss_runtime_resume,
+#endif
+	},
+};
+
 static int acpi_lpss_platform_notify(struct notifier_block *nb,
 				     unsigned long action, void *data)
 {
@@ -456,7 +585,6 @@ static int acpi_lpss_platform_notify(struct notifier_block *nb,
 	struct lpss_private_data *pdata;
 	struct acpi_device *adev;
 	const struct acpi_device_id *id;
-	int ret = 0;
 
 	id = acpi_match_device(acpi_lpss_device_ids, &pdev->dev);
 	if (!id || !id->driver_data)
@@ -466,7 +594,7 @@ static int acpi_lpss_platform_notify(struct notifier_block *nb,
 		return 0;
 
 	pdata = acpi_driver_data(adev);
-	if (!pdata || !pdata->mmio_base || !pdata->dev_desc->ltr_required)
+	if (!pdata || !pdata->mmio_base)
 		return 0;
 
 	if (pdata->mmio_size < pdata->dev_desc->prv_offset + LPSS_LTR_SIZE) {
@@ -474,12 +602,27 @@ static int acpi_lpss_platform_notify(struct notifier_block *nb,
 		return 0;
 	}
 
-	if (action == BUS_NOTIFY_ADD_DEVICE)
-		ret = sysfs_create_group(&pdev->dev.kobj, &lpss_attr_group);
-	else if (action == BUS_NOTIFY_DEL_DEVICE)
-		sysfs_remove_group(&pdev->dev.kobj, &lpss_attr_group);
+	switch (action) {
+	case BUS_NOTIFY_BOUND_DRIVER:
+		if (pdata->dev_desc->save_ctx)
+			pdev->dev.pm_domain = &acpi_lpss_pm_domain;
+		break;
+	case BUS_NOTIFY_UNBOUND_DRIVER:
+		if (pdata->dev_desc->save_ctx)
+			pdev->dev.pm_domain = NULL;
+		break;
+	case BUS_NOTIFY_ADD_DEVICE:
+		if (pdata->dev_desc->ltr_required)
+			return sysfs_create_group(&pdev->dev.kobj,
+						  &lpss_attr_group);
+	case BUS_NOTIFY_DEL_DEVICE:
+		if (pdata->dev_desc->ltr_required)
+			sysfs_remove_group(&pdev->dev.kobj, &lpss_attr_group);
+	default:
+		break;
+	}
 
-	return ret;
+	return 0;
 }
 
 static struct notifier_block acpi_lpss_nb = {

commit 8ce62f85a81f57e86bc120ab690facc612223188
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun May 25 14:38:52 2014 +0200

    ACPI / platform / LPSS: Enable async suspend/resume of LPSS devices
    
    To seed up suspend and resume of devices included into Intel SoCs
    handled by the ACPI LPSS driver during system suspend, make
    acpi_lpss_create_device() call device_enable_async_suspend() for
    every device created by it.
    
    This requires acpi_create_platform_device() to be modified to return
    a pointer to struct platform_device instead of an int.  As a result,
    acpi_create_platform_device() cannot be pointed to by the .attach
    pointer in platform_handler directly any more, so a simple wrapper
    around it is necessary for this purpose.  That, in turn, allows the
    second unused argument of acpi_create_platform_device() to be
    dropped, which is an improvement.
    
    Tested-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 69e29f409d4c..0e9c0d38b85c 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -267,12 +267,14 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 	struct lpss_private_data *pdata;
 	struct resource_list_entry *rentry;
 	struct list_head resource_list;
+	struct platform_device *pdev;
 	int ret;
 
 	dev_desc = (struct lpss_device_desc *)id->driver_data;
-	if (!dev_desc)
-		return acpi_create_platform_device(adev, id);
-
+	if (!dev_desc) {
+		pdev = acpi_create_platform_device(adev);
+		return IS_ERR_OR_NULL(pdev) ? PTR_ERR(pdev) : 1;
+	}
 	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
 	if (!pdata)
 		return -ENOMEM;
@@ -322,10 +324,13 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 		dev_desc->setup(pdata);
 
 	adev->driver_data = pdata;
-	ret = acpi_create_platform_device(adev, id);
-	if (ret > 0)
-		return ret;
+	pdev = acpi_create_platform_device(adev);
+	if (!IS_ERR_OR_NULL(pdev)) {
+		device_enable_async_suspend(&pdev->dev);
+		return 1;
+	}
 
+	ret = PTR_ERR(pdev);
 	adev->driver_data = NULL;
 
  err_out:

commit 20482d3279226d2d2802647ffa3ce82e511b74d7
Author: Jin Yao <yao.jin@intel.com>
Date:   Thu May 15 18:28:46 2014 +0300

    pinctrl: baytrail: Add back Baytrail-T ACPI ID
    
    Now that the x86 dynamic IRQ allocation problem has been resolved with
    commmit 62a08ae2a576 (genirq: x86: Ensure that dynamic irq allocation does
    not conflict), we can add back Baytrail-T ACPI ID to the pinctrl driver.
    
    This makes the driver to work on Asus T100 where it is needed for several
    things like ACPI GPIO events and SD card detection.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=68291
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Jin Yao <yao.jin@intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 69e29f409d4c..d79c6d7f598e 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -180,6 +180,7 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	{ "80860F14", (unsigned long)&byt_sdio_dev_desc },
 	{ "80860F41", (unsigned long)&byt_i2c_dev_desc },
 	{ "INT33B2", },
+	{ "INT33FC", },
 
 	{ "INT3430", (unsigned long)&lpt_dev_desc },
 	{ "INT3431", (unsigned long)&lpt_dev_desc },

commit 165f5fd04aa898fa7dbe4fbe2819cf80453d3bb9
Merge: cb97def86446 71d821fdaec0 7d1af287320b 37f204164dfb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Mar 20 13:25:36 2014 +0100

    Merge branches 'pm-qos', 'pm-domains' and 'pm-drivers'
    
    * pm-qos:
      PM / QoS: Add type to dev_pm_qos_add_ancestor_request() arguments
      ACPI / LPSS: Support for device latency tolerance PM QoS
      ACPI / scan: Add bind/unbind callbacks to struct acpi_scan_handler
      PM / QoS: Introcuce latency tolerance device PM QoS type
      PM / QoS: Add no_constraints_value field to struct pm_qos_constraints
      PM / QoS: Rename device resume latency QoS items
    
    * pm-domains:
      PM / domains: Turn latency warning into debug message
    
    * pm-drivers:
      PM: Add pm_runtime_suspend|resume_force functions
      PM / runtime: Fetch runtime PM callbacks using a macro

commit e1c7481797542f4d2039d5a458ef80603298ad78
Author: Chew, Chiau Ee <chiau.ee.chew@intel.com>
Date:   Wed Feb 19 02:24:29 2014 +0800

    ACPI / LPSS: Add Intel BayTrail ACPI mode PWM
    
    Intel BayTrail LPSS consists of two PWM controllers which can
    be enumerated from ACPI namespace. This change will cause
    platform device objects to be created for Intel BayTrail PWM
    controllers which will allow the pwm-lpss driver to bind to them
    and handle those devices.
    
    Signed-off-by: Chew, Chiau Ee <chiau.ee.chew@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 6745fe137b9e..8c2bae980faf 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -102,6 +102,16 @@ static struct lpss_device_desc lpt_sdio_dev_desc = {
 	.ltr_required = true,
 };
 
+static struct lpss_shared_clock pwm_clock = {
+	.name = "pwm_clk",
+	.rate = 25000000,
+};
+
+static struct lpss_device_desc byt_pwm_dev_desc = {
+	.clk_required = true,
+	.shared_clock = &pwm_clock,
+};
+
 static struct lpss_shared_clock uart_clock = {
 	.name = "uart_clk",
 	.rate = 44236800,
@@ -157,6 +167,7 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	{ "INT33C7", },
 
 	/* BayTrail LPSS devices */
+	{ "80860F09", (unsigned long)&byt_pwm_dev_desc },
 	{ "80860F0A", (unsigned long)&byt_uart_dev_desc },
 	{ "80860F0E", (unsigned long)&byt_spi_dev_desc },
 	{ "80860F14", (unsigned long)&byt_sdio_dev_desc },

commit 1a8f83515c1646e134163f0ab310362fae49fcca
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 11 00:35:53 2014 +0100

    ACPI / LPSS: Support for device latency tolerance PM QoS
    
    Add a new routine, acpi_lpss_set_ltr(), for setting latency tolerance
    values for LPSS devices having LTR (Latency Tolerance Reporting)
    registers.  Add .bind()/.unbind() callbacks to lpss_handler to set
    the LPSS devices' power.set_latency_tolerance callback pointers to
    acpi_lpss_set_ltr() during device addition and to clear them on
    device removal, respectively.
    
    That will cause the device latency tolerance PM QoS to work for
    the devices in question as documented.
    
    This changeset includes a fix from Mika Westerberg.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 6745fe137b9e..0a68fc6b5800 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -33,6 +33,13 @@ ACPI_MODULE_NAME("acpi_lpss");
 #define LPSS_GENERAL_UART_RTS_OVRD	BIT(3)
 #define LPSS_SW_LTR			0x10
 #define LPSS_AUTO_LTR			0x14
+#define LPSS_LTR_SNOOP_REQ		BIT(15)
+#define LPSS_LTR_SNOOP_MASK		0x0000FFFF
+#define LPSS_LTR_SNOOP_LAT_1US		0x800
+#define LPSS_LTR_SNOOP_LAT_32US		0xC00
+#define LPSS_LTR_SNOOP_LAT_SHIFT	5
+#define LPSS_LTR_SNOOP_LAT_CUTOFF	3000
+#define LPSS_LTR_MAX_VAL		0x3FF
 #define LPSS_TX_INT			0x20
 #define LPSS_TX_INT_MASK		BIT(1)
 
@@ -315,6 +322,17 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 	return ret;
 }
 
+static u32 __lpss_reg_read(struct lpss_private_data *pdata, unsigned int reg)
+{
+	return readl(pdata->mmio_base + pdata->dev_desc->prv_offset + reg);
+}
+
+static void __lpss_reg_write(u32 val, struct lpss_private_data *pdata,
+			     unsigned int reg)
+{
+	writel(val, pdata->mmio_base + pdata->dev_desc->prv_offset + reg);
+}
+
 static int lpss_reg_read(struct device *dev, unsigned int reg, u32 *val)
 {
 	struct acpi_device *adev;
@@ -336,7 +354,7 @@ static int lpss_reg_read(struct device *dev, unsigned int reg, u32 *val)
 		ret = -ENODEV;
 		goto out;
 	}
-	*val = readl(pdata->mmio_base + pdata->dev_desc->prv_offset + reg);
+	*val = __lpss_reg_read(pdata, reg);
 
  out:
 	spin_unlock_irqrestore(&dev->power.lock, flags);
@@ -389,6 +407,37 @@ static struct attribute_group lpss_attr_group = {
 	.name = "lpss_ltr",
 };
 
+static void acpi_lpss_set_ltr(struct device *dev, s32 val)
+{
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+	u32 ltr_mode, ltr_val;
+
+	ltr_mode = __lpss_reg_read(pdata, LPSS_GENERAL);
+	if (val < 0) {
+		if (ltr_mode & LPSS_GENERAL_LTR_MODE_SW) {
+			ltr_mode &= ~LPSS_GENERAL_LTR_MODE_SW;
+			__lpss_reg_write(ltr_mode, pdata, LPSS_GENERAL);
+		}
+		return;
+	}
+	ltr_val = __lpss_reg_read(pdata, LPSS_SW_LTR) & ~LPSS_LTR_SNOOP_MASK;
+	if (val >= LPSS_LTR_SNOOP_LAT_CUTOFF) {
+		ltr_val |= LPSS_LTR_SNOOP_LAT_32US;
+		val = LPSS_LTR_MAX_VAL;
+	} else if (val > LPSS_LTR_MAX_VAL) {
+		ltr_val |= LPSS_LTR_SNOOP_LAT_32US | LPSS_LTR_SNOOP_REQ;
+		val >>= LPSS_LTR_SNOOP_LAT_SHIFT;
+	} else {
+		ltr_val |= LPSS_LTR_SNOOP_LAT_1US | LPSS_LTR_SNOOP_REQ;
+	}
+	ltr_val |= val;
+	__lpss_reg_write(ltr_val, pdata, LPSS_SW_LTR);
+	if (!(ltr_mode & LPSS_GENERAL_LTR_MODE_SW)) {
+		ltr_mode |= LPSS_GENERAL_LTR_MODE_SW;
+		__lpss_reg_write(ltr_mode, pdata, LPSS_GENERAL);
+	}
+}
+
 static int acpi_lpss_platform_notify(struct notifier_block *nb,
 				     unsigned long action, void *data)
 {
@@ -426,9 +475,29 @@ static struct notifier_block acpi_lpss_nb = {
 	.notifier_call = acpi_lpss_platform_notify,
 };
 
+static void acpi_lpss_bind(struct device *dev)
+{
+	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+
+	if (!pdata || !pdata->mmio_base || !pdata->dev_desc->ltr_required)
+		return;
+
+	if (pdata->mmio_size >= pdata->dev_desc->prv_offset + LPSS_LTR_SIZE)
+		dev->power.set_latency_tolerance = acpi_lpss_set_ltr;
+	else
+		dev_err(dev, "MMIO size insufficient to access LTR\n");
+}
+
+static void acpi_lpss_unbind(struct device *dev)
+{
+	dev->power.set_latency_tolerance = NULL;
+}
+
 static struct acpi_scan_handler lpss_handler = {
 	.ids = acpi_lpss_device_ids,
 	.attach = acpi_lpss_create_device,
+	.bind = acpi_lpss_bind,
+	.unbind = acpi_lpss_unbind,
 };
 
 void __init acpi_lpss_init(void)

commit 2b844ba79f4a114bd228ad6fee040ffd99a0963d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 17 14:23:29 2014 +0100

    Revert "ACPI: Add BayTrail SoC GPIO and LPSS ACPI IDs"
    
    This reverts commit f6308b36c411 (ACPI: Add BayTrail SoC GPIO and LPSS
    ACPI IDs), because it causes the Alan Cox' ASUS T100TA to "crash and
    burn" during boot if the Baytrail pinctrl driver is compiled in.
    
    Fixes: f6308b36c411 (ACPI: Add BayTrail SoC GPIO and LPSS ACPI IDs)
    Reported-by: One Thousand Gnomes <gnomes@lxorguk.ukuu.org.uk>
    Requested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index e60390597372..6745fe137b9e 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -162,7 +162,6 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	{ "80860F14", (unsigned long)&byt_sdio_dev_desc },
 	{ "80860F41", (unsigned long)&byt_i2c_dev_desc },
 	{ "INT33B2", },
-	{ "INT33FC", },
 
 	{ "INT3430", (unsigned long)&lpt_dev_desc },
 	{ "INT3431", (unsigned long)&lpt_dev_desc },

commit f6308b36c411dc5afd6a6f73e6454722bfde57b7
Author: Paul Drews <paul.drews@intel.com>
Date:   Mon Nov 25 14:15:55 2013 -0800

    ACPI: Add BayTrail SoC GPIO and LPSS ACPI IDs
    
    This adds the new ACPI ID (INT33FC) for the BayTrail GPIO
    banks as seen on a BayTrail M System-On-Chip platform.  This
    ACPI ID is used by the BayTrail GPIO (pinctrl) driver to
    manage the Low Power Subsystem (LPSS).
    
    Signed-off-by: Paul Drews <paul.drews@intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 6745fe137b9e..e60390597372 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -162,6 +162,7 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	{ "80860F14", (unsigned long)&byt_sdio_dev_desc },
 	{ "80860F41", (unsigned long)&byt_i2c_dev_desc },
 	{ "INT33B2", },
+	{ "INT33FC", },
 
 	{ "INT3430", (unsigned long)&lpt_dev_desc },
 	{ "INT3431", (unsigned long)&lpt_dev_desc },

commit f86e7bc9683ee6dbde56d4bd4fda65f085b814d0
Merge: eb64821243cd a4d97536a1a2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Nov 16 15:45:13 2013 +0100

    Merge branch 'acpi-lpss'
    
    * acpi-lpss:
      ACPI / LPSS: add ACPI IDs for newer Intel PCHs

commit a4d97536a1a20a70a65ded5d445013a3904d5a8d
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Nov 12 11:48:19 2013 +0200

    ACPI / LPSS: add ACPI IDs for newer Intel PCHs
    
    Some recent Intel PCHs with LPSS have different ACPI IDs for the LPSS
    devices, so add these to the list as well.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index fb78bb9ad8f6..242885715331 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -157,6 +157,15 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	{ "80860F41", (unsigned long)&byt_i2c_dev_desc },
 	{ "INT33B2", },
 
+	{ "INT3430", (unsigned long)&lpt_dev_desc },
+	{ "INT3431", (unsigned long)&lpt_dev_desc },
+	{ "INT3432", (unsigned long)&lpt_dev_desc },
+	{ "INT3433", (unsigned long)&lpt_dev_desc },
+	{ "INT3434", (unsigned long)&lpt_uart_dev_desc },
+	{ "INT3435", (unsigned long)&lpt_uart_dev_desc },
+	{ "INT3436", (unsigned long)&lpt_sdio_dev_desc },
+	{ "INT3437", },
+
 	{ }
 };
 

commit 088f1fd267c7f43b5d87850a0fa0c7e851ecae97
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Wed Oct 9 09:49:20 2013 +0300

    ACPI / LPSS: fix UART Auto Flow Control
    
    There is an additional bit in the GENERAL register on newer
    silicon that needs to be set or UART's RTS pin fails to
    reflect the flow control settings in the Modem Control
    Register.
    
    This will fix an issue where the RTS pin of the UART stays
    always at 1.8V, regardless of the register settings.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index fb78bb9ad8f6..d3961014aad7 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -30,6 +30,7 @@ ACPI_MODULE_NAME("acpi_lpss");
 /* Offsets relative to LPSS_PRIVATE_OFFSET */
 #define LPSS_GENERAL			0x08
 #define LPSS_GENERAL_LTR_MODE_SW	BIT(2)
+#define LPSS_GENERAL_UART_RTS_OVRD	BIT(3)
 #define LPSS_SW_LTR			0x10
 #define LPSS_AUTO_LTR			0x14
 #define LPSS_TX_INT			0x20
@@ -68,11 +69,16 @@ struct lpss_private_data {
 
 static void lpss_uart_setup(struct lpss_private_data *pdata)
 {
-	unsigned int tx_int_offset = pdata->dev_desc->prv_offset + LPSS_TX_INT;
+	unsigned int offset;
 	u32 reg;
 
-	reg = readl(pdata->mmio_base + tx_int_offset);
-	writel(reg | LPSS_TX_INT_MASK, pdata->mmio_base + tx_int_offset);
+	offset = pdata->dev_desc->prv_offset + LPSS_TX_INT;
+	reg = readl(pdata->mmio_base + offset);
+	writel(reg | LPSS_TX_INT_MASK, pdata->mmio_base + offset);
+
+	offset = pdata->dev_desc->prv_offset + LPSS_GENERAL;
+	reg = readl(pdata->mmio_base + offset);
+	writel(reg | LPSS_GENERAL_UART_RTS_OVRD, pdata->mmio_base + offset);
 }
 
 static struct lpss_device_desc lpt_dev_desc = {

commit af65cfe9aeae03e0682bebdf4db94582d75562dd
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Sep 2 13:30:25 2013 +0300

    ACPI / LPSS: don't crash if a device has no MMIO resources
    
    Intel LPSS devices that are enumerated from ACPI have both MMIO and IRQ
    resources returned in their _CRS method. However, Apple Macbook Air with
    Haswell has LPSS devices enumerated from PCI bus instead and _CRS method
    returns only an interrupt number (but the device has _HID set that causes
    the scan handler to match it).
    
    The current ACPI / LPSS code sets pdata->dev_desc only when MMIO resource
    is found for the device and in case of Macbook Air it is never found. That
    leads to a NULL pointer dereference in register_device_clock().
    
    Correct this by always setting the pdata->dev_desc.
    
    Reported-and-tested-by: Imre Kaloz <kaloz@openwrt.org>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: 3.10+ <stable@vger.kernel.org> # 3.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 6a382188fa20..fb78bb9ad8f6 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -257,12 +257,13 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 				pdata->mmio_size = resource_size(&rentry->res);
 			pdata->mmio_base = ioremap(rentry->res.start,
 						   pdata->mmio_size);
-			pdata->dev_desc = dev_desc;
 			break;
 		}
 
 	acpi_dev_free_resource_list(&resource_list);
 
+	pdata->dev_desc = dev_desc;
+
 	if (dev_desc->clk_required) {
 		ret = register_device_clock(adev, pdata);
 		if (ret) {

commit f4c9f402389977dc852ef4848c7615926306735d
Merge: 3b4550e0e0cd 958c4eb2aa32
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 28 12:59:02 2013 +0200

    Merge branch 'acpi-lpss'
    
    * acpi-lpss:
      ACPI / LPSS: override SDIO private register space size from ACPI tables
      ACPI / LPSS: mask the UART TX completion interrupt
      ACPI / LPSS: add support for Intel BayTrail
    
    Conflicts:
            drivers/acpi/acpi_lpss.c (with commit b9e95fc)

commit b9e95fc65ededbec083aa91b4faa58ad992c0891
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 19 00:45:34 2013 +0200

    ACPI / LPSS: Power up LPSS devices during enumeration
    
    Commit 7cd8407 (ACPI / PM: Do not execute _PS0 for devices without
    _PSC during initialization) introduced a regression on some systems
    with Intel Lynxpoint Low-Power Subsystem (LPSS) where some devices
    need to be powered up during initialization, but their device objects
    in the ACPI namespace have _PS0 and _PS3 only (without _PSC or power
    resources).
    
    To work around this problem, make the ACPI LPSS driver power up
    devices it knows about by using a new helper function
    acpi_device_fix_up_power() that does all of the necessary
    sanity checks and calls acpi_dev_pm_explicit_set() to put the
    device into D0.
    
    Reported-and-tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 652fd5ce303c..cab13f2fc28e 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -164,15 +164,24 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 	if (dev_desc->clk_required) {
 		ret = register_device_clock(adev, pdata);
 		if (ret) {
-			/*
-			 * Skip the device, but don't terminate the namespace
-			 * scan.
-			 */
-			kfree(pdata);
-			return 0;
+			/* Skip the device, but continue the namespace scan. */
+			ret = 0;
+			goto err_out;
 		}
 	}
 
+	/*
+	 * This works around a known issue in ACPI tables where LPSS devices
+	 * have _PS0 and _PS3 without _PSC (and no power resources), so
+	 * acpi_bus_init_power() will assume that the BIOS has put them into D0.
+	 */
+	ret = acpi_device_fix_up_power(adev);
+	if (ret) {
+		/* Skip the device, but continue the namespace scan. */
+		ret = 0;
+		goto err_out;
+	}
+
 	adev->driver_data = pdata;
 	ret = acpi_create_platform_device(adev, id);
 	if (ret > 0)

commit 958c4eb2aa325099ea1f54c7354e381e3d79f3ae
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Jun 18 16:51:35 2013 +0300

    ACPI / LPSS: override SDIO private register space size from ACPI tables
    
    The SDIO device in Lynxpoint has its LTR registers reserved for a
    WiFi device (a child of the SDIO device) in the ACPI namespace even
    though those registers physically belong to the SDIO device itself.
    In order to be able to access the SDIO LTR registers from the ACPI
    LPSS driver for diagnostic purposes we need to use a size override
    for the SDIO private register space.
    
    Add a possibility to override the size of the private register space
    of an LPSS device provided by the ACPI tables in the ACPI LPSS driver
    and set the correct size for the SDIO device in there.
    
    [rjw: Changelog]
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index bd9867f592b7..a4e8c0337a59 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -48,6 +48,7 @@ struct lpss_device_desc {
 	const char *clkdev_name;
 	bool ltr_required;
 	unsigned int prv_offset;
+	size_t prv_size_override;
 	bool clk_gate;
 	struct lpss_shared_clock *shared_clock;
 	void (*setup)(struct lpss_private_data *pdata);
@@ -91,6 +92,7 @@ static struct lpss_device_desc lpt_uart_dev_desc = {
 
 static struct lpss_device_desc lpt_sdio_dev_desc = {
 	.prv_offset = 0x1000,
+	.prv_size_override = 0x1018,
 	.ltr_required = true,
 };
 
@@ -249,7 +251,10 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 
 	list_for_each_entry(rentry, &resource_list, node)
 		if (resource_type(&rentry->res) == IORESOURCE_MEM) {
-			pdata->mmio_size = resource_size(&rentry->res);
+			if (dev_desc->prv_size_override)
+				pdata->mmio_size = dev_desc->prv_size_override;
+			else
+				pdata->mmio_size = resource_size(&rentry->res);
 			pdata->mmio_base = ioremap(rentry->res.start,
 						   pdata->mmio_size);
 			pdata->dev_desc = dev_desc;

commit 06d8641504726322fca54400bbac982bd44f9a27
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Jun 17 13:25:46 2013 +0300

    ACPI / LPSS: mask the UART TX completion interrupt
    
    Intel LPSS provides an extra TX byte counter and an extra TX
    completion interrupt for some of its bus controllers.  However,
    there is no use for the extra UART interrupt and it has to be
    masked out during initialization.
    
    Otherwise, if the firmware does not mask the interrupt and
    the driver does not clear it, it may cause an interrupt flood
    freezing the board to happen.
    
    Add code masking that problematic interrupt to the ACPI LPSS driver.
    
    [rjw: Changelog]
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index f6d760581faa..bd9867f592b7 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -32,6 +32,8 @@ ACPI_MODULE_NAME("acpi_lpss");
 #define LPSS_GENERAL_LTR_MODE_SW	BIT(2)
 #define LPSS_SW_LTR			0x10
 #define LPSS_AUTO_LTR			0x14
+#define LPSS_TX_INT			0x20
+#define LPSS_TX_INT_MASK		BIT(1)
 
 struct lpss_shared_clock {
 	const char *name;
@@ -39,6 +41,8 @@ struct lpss_shared_clock {
 	struct clk *clk;
 };
 
+struct lpss_private_data;
+
 struct lpss_device_desc {
 	bool clk_required;
 	const char *clkdev_name;
@@ -46,6 +50,7 @@ struct lpss_device_desc {
 	unsigned int prv_offset;
 	bool clk_gate;
 	struct lpss_shared_clock *shared_clock;
+	void (*setup)(struct lpss_private_data *pdata);
 };
 
 static struct lpss_device_desc lpss_dma_desc = {
@@ -60,6 +65,15 @@ struct lpss_private_data {
 	const struct lpss_device_desc *dev_desc;
 };
 
+static void lpss_uart_setup(struct lpss_private_data *pdata)
+{
+	unsigned int tx_int_offset = pdata->dev_desc->prv_offset + LPSS_TX_INT;
+	u32 reg;
+
+	reg = readl(pdata->mmio_base + tx_int_offset);
+	writel(reg | LPSS_TX_INT_MASK, pdata->mmio_base + tx_int_offset);
+}
+
 static struct lpss_device_desc lpt_dev_desc = {
 	.clk_required = true,
 	.prv_offset = 0x800,
@@ -67,6 +81,14 @@ static struct lpss_device_desc lpt_dev_desc = {
 	.clk_gate = true,
 };
 
+static struct lpss_device_desc lpt_uart_dev_desc = {
+	.clk_required = true,
+	.prv_offset = 0x800,
+	.ltr_required = true,
+	.clk_gate = true,
+	.setup = lpss_uart_setup,
+};
+
 static struct lpss_device_desc lpt_sdio_dev_desc = {
 	.prv_offset = 0x1000,
 	.ltr_required = true,
@@ -82,6 +104,7 @@ static struct lpss_device_desc byt_uart_dev_desc = {
 	.prv_offset = 0x800,
 	.clk_gate = true,
 	.shared_clock = &uart_clock,
+	.setup = lpss_uart_setup,
 };
 
 static struct lpss_shared_clock spi_clock = {
@@ -120,8 +143,8 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	{ "INT33C1", (unsigned long)&lpt_dev_desc },
 	{ "INT33C2", (unsigned long)&lpt_dev_desc },
 	{ "INT33C3", (unsigned long)&lpt_dev_desc },
-	{ "INT33C4", (unsigned long)&lpt_dev_desc },
-	{ "INT33C5", (unsigned long)&lpt_dev_desc },
+	{ "INT33C4", (unsigned long)&lpt_uart_dev_desc },
+	{ "INT33C5", (unsigned long)&lpt_uart_dev_desc },
 	{ "INT33C6", (unsigned long)&lpt_sdio_dev_desc },
 	{ "INT33C7", },
 
@@ -247,6 +270,9 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 		}
 	}
 
+	if (dev_desc->setup)
+		dev_desc->setup(pdata);
+
 	adev->driver_data = pdata;
 	ret = acpi_create_platform_device(adev, id);
 	if (ret > 0)

commit f627217064dbef1eef53ceb01edb9c94203991e0
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon May 13 12:42:44 2013 +0000

    ACPI / LPSS: add support for Intel BayTrail
    
    Intel BayTrail has almost the same Low Power Subsystem than Lynxpoint with
    few differences. Peripherals are clocked with different speeds (typically
    lower) and the clock is not always gated. To support this we add
    possibility to share a common fixed rate clock and make clock gating
    optional.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Mike Turquette <mturquette@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 652fd5ce303c..f6d760581faa 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -33,11 +33,19 @@ ACPI_MODULE_NAME("acpi_lpss");
 #define LPSS_SW_LTR			0x10
 #define LPSS_AUTO_LTR			0x14
 
+struct lpss_shared_clock {
+	const char *name;
+	unsigned long rate;
+	struct clk *clk;
+};
+
 struct lpss_device_desc {
 	bool clk_required;
 	const char *clkdev_name;
 	bool ltr_required;
 	unsigned int prv_offset;
+	bool clk_gate;
+	struct lpss_shared_clock *shared_clock;
 };
 
 static struct lpss_device_desc lpss_dma_desc = {
@@ -56,6 +64,7 @@ static struct lpss_device_desc lpt_dev_desc = {
 	.clk_required = true,
 	.prv_offset = 0x800,
 	.ltr_required = true,
+	.clk_gate = true,
 };
 
 static struct lpss_device_desc lpt_sdio_dev_desc = {
@@ -63,6 +72,45 @@ static struct lpss_device_desc lpt_sdio_dev_desc = {
 	.ltr_required = true,
 };
 
+static struct lpss_shared_clock uart_clock = {
+	.name = "uart_clk",
+	.rate = 44236800,
+};
+
+static struct lpss_device_desc byt_uart_dev_desc = {
+	.clk_required = true,
+	.prv_offset = 0x800,
+	.clk_gate = true,
+	.shared_clock = &uart_clock,
+};
+
+static struct lpss_shared_clock spi_clock = {
+	.name = "spi_clk",
+	.rate = 50000000,
+};
+
+static struct lpss_device_desc byt_spi_dev_desc = {
+	.clk_required = true,
+	.prv_offset = 0x400,
+	.clk_gate = true,
+	.shared_clock = &spi_clock,
+};
+
+static struct lpss_device_desc byt_sdio_dev_desc = {
+	.clk_required = true,
+};
+
+static struct lpss_shared_clock i2c_clock = {
+	.name = "i2c_clk",
+	.rate = 100000000,
+};
+
+static struct lpss_device_desc byt_i2c_dev_desc = {
+	.clk_required = true,
+	.prv_offset = 0x800,
+	.shared_clock = &i2c_clock,
+};
+
 static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	/* Generic LPSS devices */
 	{ "INTL9C60", (unsigned long)&lpss_dma_desc },
@@ -77,6 +125,13 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	{ "INT33C6", (unsigned long)&lpt_sdio_dev_desc },
 	{ "INT33C7", },
 
+	/* BayTrail LPSS devices */
+	{ "80860F0A", (unsigned long)&byt_uart_dev_desc },
+	{ "80860F0E", (unsigned long)&byt_spi_dev_desc },
+	{ "80860F14", (unsigned long)&byt_sdio_dev_desc },
+	{ "80860F41", (unsigned long)&byt_i2c_dev_desc },
+	{ "INT33B2", },
+
 	{ }
 };
 
@@ -98,7 +153,10 @@ static int register_device_clock(struct acpi_device *adev,
 				 struct lpss_private_data *pdata)
 {
 	const struct lpss_device_desc *dev_desc = pdata->dev_desc;
+	struct lpss_shared_clock *shared_clock = dev_desc->shared_clock;
+	struct clk *clk = ERR_PTR(-ENODEV);
 	struct lpss_clk_data *clk_data;
+	const char *parent;
 
 	if (!lpss_clk_dev)
 		lpt_register_clock_device();
@@ -117,14 +175,30 @@ static int register_device_clock(struct acpi_device *adev,
 	    || pdata->mmio_size < dev_desc->prv_offset + LPSS_CLK_SIZE)
 		return -ENODATA;
 
-	pdata->clk = clk_register_gate(NULL, dev_name(&adev->dev),
-				       clk_data->name, 0,
-				       pdata->mmio_base + dev_desc->prv_offset,
-				       0, 0, NULL);
-	if (IS_ERR(pdata->clk))
-		return PTR_ERR(pdata->clk);
+	parent = clk_data->name;
+
+	if (shared_clock) {
+		clk = shared_clock->clk;
+		if (!clk) {
+			clk = clk_register_fixed_rate(NULL, shared_clock->name,
+						      "lpss_clk", 0,
+						      shared_clock->rate);
+			shared_clock->clk = clk;
+		}
+		parent = shared_clock->name;
+	}
+
+	if (dev_desc->clk_gate) {
+		clk = clk_register_gate(NULL, dev_name(&adev->dev), parent, 0,
+					pdata->mmio_base + dev_desc->prv_offset,
+					0, 0, NULL);
+		pdata->clk = clk;
+	}
+
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
 
-	clk_register_clkdev(pdata->clk, NULL, dev_name(&adev->dev));
+	clk_register_clkdev(clk, NULL, dev_name(&adev->dev));
 	return 0;
 }
 

commit b59cc200ac025aca597fb21862c1c9e667f2eff2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed May 8 11:55:49 2013 +0300

    ACPI / LPSS: register clock device for Lynxpoint DMA properly
    
    The DMA controller in Lynxpoint is enumerated as a regular ACPI device now. To
    work properly it is using the LPSS root clock as a functional clock. That's why
    we have to register the clock device accordingly to the ACPI ID of the DMA
    controller. The acpi_lpss.c module is responsible to do the job.
    
    This patch also removes hardcoded name of the DMA device in clk-lpt.c and the
    name of the root clock in acpi_lpss.c.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index b1c95422ce74..652fd5ce303c 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -35,11 +35,16 @@ ACPI_MODULE_NAME("acpi_lpss");
 
 struct lpss_device_desc {
 	bool clk_required;
-	const char *clk_parent;
+	const char *clkdev_name;
 	bool ltr_required;
 	unsigned int prv_offset;
 };
 
+static struct lpss_device_desc lpss_dma_desc = {
+	.clk_required = true,
+	.clkdev_name = "hclk",
+};
+
 struct lpss_private_data {
 	void __iomem *mmio_base;
 	resource_size_t mmio_size;
@@ -49,7 +54,6 @@ struct lpss_private_data {
 
 static struct lpss_device_desc lpt_dev_desc = {
 	.clk_required = true,
-	.clk_parent = "lpss_clk",
 	.prv_offset = 0x800,
 	.ltr_required = true,
 };
@@ -60,6 +64,9 @@ static struct lpss_device_desc lpt_sdio_dev_desc = {
 };
 
 static const struct acpi_device_id acpi_lpss_device_ids[] = {
+	/* Generic LPSS devices */
+	{ "INTL9C60", (unsigned long)&lpss_dma_desc },
+
 	/* Lynxpoint LPSS devices */
 	{ "INT33C0", (unsigned long)&lpt_dev_desc },
 	{ "INT33C1", (unsigned long)&lpt_dev_desc },
@@ -91,16 +98,27 @@ static int register_device_clock(struct acpi_device *adev,
 				 struct lpss_private_data *pdata)
 {
 	const struct lpss_device_desc *dev_desc = pdata->dev_desc;
+	struct lpss_clk_data *clk_data;
 
 	if (!lpss_clk_dev)
 		lpt_register_clock_device();
 
-	if (!dev_desc->clk_parent || !pdata->mmio_base
+	clk_data = platform_get_drvdata(lpss_clk_dev);
+	if (!clk_data)
+		return -ENODEV;
+
+	if (dev_desc->clkdev_name) {
+		clk_register_clkdev(clk_data->clk, dev_desc->clkdev_name,
+				    dev_name(&adev->dev));
+		return 0;
+	}
+
+	if (!pdata->mmio_base
 	    || pdata->mmio_size < dev_desc->prv_offset + LPSS_CLK_SIZE)
 		return -ENODATA;
 
 	pdata->clk = clk_register_gate(NULL, dev_name(&adev->dev),
-				       dev_desc->clk_parent, 0,
+				       clk_data->name, 0,
 				       pdata->mmio_base + dev_desc->prv_offset,
 				       0, 0, NULL);
 	if (IS_ERR(pdata->clk))

commit cf8df962aa830d05be1a8d5a9c7d2a67b2837b45
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Mar 20 12:14:30 2013 +0000

    ACPI / LPSS: make code less confusing for reader
    
    The excerpt like this:
    
            if (err) {
                    err = 0;
                    goto error_out;
            }
    
    makes a reader confused even if it's commented. Let's do necessary actions and
    return no error explicitly.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index c87db0e47d09..b1c95422ce74 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -150,8 +150,8 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 			 * Skip the device, but don't terminate the namespace
 			 * scan.
 			 */
-			ret = 0;
-			goto err_out;
+			kfree(pdata);
+			return 0;
 		}
 	}
 

commit 2e0f8822d1a6d839e66786e99ce1043e4ad1cd72
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Mar 6 23:46:28 2013 +0100

    ACPI / LPSS: Add support for exposing LTR registers to user space
    
    Devices on the Intel Lynxpoint Low Power Subsystem (LPSS) have
    registers providing access to LTR (Latency Tolerance Reporting)
    functionality that allows software to monitor and possibly influence
    the aggressiveness of the platform's active-state power management.
    
    For each LPSS device, there are two modes of operation related to LTR,
    the auto mode and the software mode.  In the auto mode the LTR is
    set up by the platform firmware and managed by hardware.  Software
    can only read the LTR register values to monitor the platform's
    behavior.  In the software mode it is possible to use LTR to control
    the extent to which the platform will use its built-in power
    management features.
    
    This changeset adds support for reading the LPSS devices' LTR
    registers and exposing their values to user space for monitoring and
    diagnostics purposes.  It re-uses the MMIO mappings created to access
    the LPSS devices' clock registers for reading the values of the LTR
    registers and exposes them to user space through sysfs device
    attributes.  Namely, a new atrribute group, lpss_ltr, is created for
    each LPSS device.  It contains three new attributes: ltr_mode,
    auto_ltr, sw_ltr.  The value of the ltr_mode attribute reflects the
    LTR mode being used at the moment (software vs auto) and the other
    two contain the actual register values (raw) whose meaning depends
    on the LTR mode.  All of these attributes are read-only.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
index 823df46a3deb..c87db0e47d09 100644
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@ -18,17 +18,26 @@
 #include <linux/io.h>
 #include <linux/platform_device.h>
 #include <linux/platform_data/clk-lpss.h>
+#include <linux/pm_runtime.h>
 
 #include "internal.h"
 
 ACPI_MODULE_NAME("acpi_lpss");
 
-#define LPSS_CLK_OFFSET 0x800
 #define LPSS_CLK_SIZE	0x04
+#define LPSS_LTR_SIZE	0x18
+
+/* Offsets relative to LPSS_PRIVATE_OFFSET */
+#define LPSS_GENERAL			0x08
+#define LPSS_GENERAL_LTR_MODE_SW	BIT(2)
+#define LPSS_SW_LTR			0x10
+#define LPSS_AUTO_LTR			0x14
 
 struct lpss_device_desc {
 	bool clk_required;
 	const char *clk_parent;
+	bool ltr_required;
+	unsigned int prv_offset;
 };
 
 struct lpss_private_data {
@@ -41,6 +50,13 @@ struct lpss_private_data {
 static struct lpss_device_desc lpt_dev_desc = {
 	.clk_required = true,
 	.clk_parent = "lpss_clk",
+	.prv_offset = 0x800,
+	.ltr_required = true,
+};
+
+static struct lpss_device_desc lpt_sdio_dev_desc = {
+	.prv_offset = 0x1000,
+	.ltr_required = true,
 };
 
 static const struct acpi_device_id acpi_lpss_device_ids[] = {
@@ -51,7 +67,7 @@ static const struct acpi_device_id acpi_lpss_device_ids[] = {
 	{ "INT33C3", (unsigned long)&lpt_dev_desc },
 	{ "INT33C4", (unsigned long)&lpt_dev_desc },
 	{ "INT33C5", (unsigned long)&lpt_dev_desc },
-	{ "INT33C6", },
+	{ "INT33C6", (unsigned long)&lpt_sdio_dev_desc },
 	{ "INT33C7", },
 
 	{ }
@@ -80,12 +96,12 @@ static int register_device_clock(struct acpi_device *adev,
 		lpt_register_clock_device();
 
 	if (!dev_desc->clk_parent || !pdata->mmio_base
-	    || pdata->mmio_size < LPSS_CLK_OFFSET + LPSS_CLK_SIZE)
+	    || pdata->mmio_size < dev_desc->prv_offset + LPSS_CLK_SIZE)
 		return -ENODATA;
 
 	pdata->clk = clk_register_gate(NULL, dev_name(&adev->dev),
 				       dev_desc->clk_parent, 0,
-				       pdata->mmio_base + LPSS_CLK_OFFSET,
+				       pdata->mmio_base + dev_desc->prv_offset,
 				       0, 0, NULL);
 	if (IS_ERR(pdata->clk))
 		return PTR_ERR(pdata->clk);
@@ -151,6 +167,117 @@ static int acpi_lpss_create_device(struct acpi_device *adev,
 	return ret;
 }
 
+static int lpss_reg_read(struct device *dev, unsigned int reg, u32 *val)
+{
+	struct acpi_device *adev;
+	struct lpss_private_data *pdata;
+	unsigned long flags;
+	int ret;
+
+	ret = acpi_bus_get_device(ACPI_HANDLE(dev), &adev);
+	if (WARN_ON(ret))
+		return ret;
+
+	spin_lock_irqsave(&dev->power.lock, flags);
+	if (pm_runtime_suspended(dev)) {
+		ret = -EAGAIN;
+		goto out;
+	}
+	pdata = acpi_driver_data(adev);
+	if (WARN_ON(!pdata || !pdata->mmio_base)) {
+		ret = -ENODEV;
+		goto out;
+	}
+	*val = readl(pdata->mmio_base + pdata->dev_desc->prv_offset + reg);
+
+ out:
+	spin_unlock_irqrestore(&dev->power.lock, flags);
+	return ret;
+}
+
+static ssize_t lpss_ltr_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	u32 ltr_value = 0;
+	unsigned int reg;
+	int ret;
+
+	reg = strcmp(attr->attr.name, "auto_ltr") ? LPSS_SW_LTR : LPSS_AUTO_LTR;
+	ret = lpss_reg_read(dev, reg, &ltr_value);
+	if (ret)
+		return ret;
+
+	return snprintf(buf, PAGE_SIZE, "%08x\n", ltr_value);
+}
+
+static ssize_t lpss_ltr_mode_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	u32 ltr_mode = 0;
+	char *outstr;
+	int ret;
+
+	ret = lpss_reg_read(dev, LPSS_GENERAL, &ltr_mode);
+	if (ret)
+		return ret;
+
+	outstr = (ltr_mode & LPSS_GENERAL_LTR_MODE_SW) ? "sw" : "auto";
+	return sprintf(buf, "%s\n", outstr);
+}
+
+static DEVICE_ATTR(auto_ltr, S_IRUSR, lpss_ltr_show, NULL);
+static DEVICE_ATTR(sw_ltr, S_IRUSR, lpss_ltr_show, NULL);
+static DEVICE_ATTR(ltr_mode, S_IRUSR, lpss_ltr_mode_show, NULL);
+
+static struct attribute *lpss_attrs[] = {
+	&dev_attr_auto_ltr.attr,
+	&dev_attr_sw_ltr.attr,
+	&dev_attr_ltr_mode.attr,
+	NULL,
+};
+
+static struct attribute_group lpss_attr_group = {
+	.attrs = lpss_attrs,
+	.name = "lpss_ltr",
+};
+
+static int acpi_lpss_platform_notify(struct notifier_block *nb,
+				     unsigned long action, void *data)
+{
+	struct platform_device *pdev = to_platform_device(data);
+	struct lpss_private_data *pdata;
+	struct acpi_device *adev;
+	const struct acpi_device_id *id;
+	int ret = 0;
+
+	id = acpi_match_device(acpi_lpss_device_ids, &pdev->dev);
+	if (!id || !id->driver_data)
+		return 0;
+
+	if (acpi_bus_get_device(ACPI_HANDLE(&pdev->dev), &adev))
+		return 0;
+
+	pdata = acpi_driver_data(adev);
+	if (!pdata || !pdata->mmio_base || !pdata->dev_desc->ltr_required)
+		return 0;
+
+	if (pdata->mmio_size < pdata->dev_desc->prv_offset + LPSS_LTR_SIZE) {
+		dev_err(&pdev->dev, "MMIO size insufficient to access LTR\n");
+		return 0;
+	}
+
+	if (action == BUS_NOTIFY_ADD_DEVICE)
+		ret = sysfs_create_group(&pdev->dev.kobj, &lpss_attr_group);
+	else if (action == BUS_NOTIFY_DEL_DEVICE)
+		sysfs_remove_group(&pdev->dev.kobj, &lpss_attr_group);
+
+	return ret;
+}
+
+static struct notifier_block acpi_lpss_nb = {
+	.notifier_call = acpi_lpss_platform_notify,
+};
+
 static struct acpi_scan_handler lpss_handler = {
 	.ids = acpi_lpss_device_ids,
 	.attach = acpi_lpss_create_device,
@@ -158,6 +285,8 @@ static struct acpi_scan_handler lpss_handler = {
 
 void __init acpi_lpss_init(void)
 {
-	if (!lpt_clk_init())
+	if (!lpt_clk_init()) {
+		bus_register_notifier(&platform_bus_type, &acpi_lpss_nb);
 		acpi_scan_add_handler(&lpss_handler);
+	}
 }

commit f58b082aed43400c03e53beacc50a9f9eb23ac91
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Mar 6 23:46:20 2013 +0100

    ACPI / scan: Add special handler for Intel Lynxpoint LPSS devices
    
    Devices on the Intel Lynxpoint Low Power Subsystem (LPSS) have some
    common features that aren't shared with any other platform devices,
    including the clock and LTR (Latency Tolerance Reporting) registers.
    It is better to handle those features in common code than to bother
    device drivers with doing that (I/O functionality-wise the LPSS
    devices are generally compatible with other devices that don't
    have those special registers and may be handled by the same drivers).
    
    The clock registers of the LPSS devices are now taken care of by
    the special clk-x86-lpss driver, but the MMIO mappings used for
    accessing those registers can also be used for accessing the LTR
    registers on those devices (LTR support for the Lynxpoint LPSS is
    going to be added by a subsequent patch).  Thus it is convenient
    to add a special ACPI scan handler for the Lynxpoint LPSS devices
    that will create the MMIO mappings for accessing the clock (and
    LTR in the future) registers and will register the LPSS devices'
    clocks, so the clk-x86-lpss driver will only need to take care of
    the main Lynxpoint LPSS clock.
    
    Introduce a special ACPI scan handler for Intel Lynxpoint LPSS
    devices as described above.  This also reduces overhead related to
    browsing the ACPI namespace in search of the LPSS devices before the
    registration of their clocks, removes some LPSS-specific (and
    somewhat ugly) code from acpi_platform.c and shrinks the overall code
    size slightly.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c
new file mode 100644
index 000000000000..823df46a3deb
--- /dev/null
+++ b/drivers/acpi/acpi_lpss.c
@@ -0,0 +1,163 @@
+/*
+ * ACPI support for Intel Lynxpoint LPSS.
+ *
+ * Copyright (C) 2013, Intel Corporation
+ * Authors: Mika Westerberg <mika.westerberg@linux.intel.com>
+ *          Rafael J. Wysocki <rafael.j.wysocki@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/acpi.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/platform_data/clk-lpss.h>
+
+#include "internal.h"
+
+ACPI_MODULE_NAME("acpi_lpss");
+
+#define LPSS_CLK_OFFSET 0x800
+#define LPSS_CLK_SIZE	0x04
+
+struct lpss_device_desc {
+	bool clk_required;
+	const char *clk_parent;
+};
+
+struct lpss_private_data {
+	void __iomem *mmio_base;
+	resource_size_t mmio_size;
+	struct clk *clk;
+	const struct lpss_device_desc *dev_desc;
+};
+
+static struct lpss_device_desc lpt_dev_desc = {
+	.clk_required = true,
+	.clk_parent = "lpss_clk",
+};
+
+static const struct acpi_device_id acpi_lpss_device_ids[] = {
+	/* Lynxpoint LPSS devices */
+	{ "INT33C0", (unsigned long)&lpt_dev_desc },
+	{ "INT33C1", (unsigned long)&lpt_dev_desc },
+	{ "INT33C2", (unsigned long)&lpt_dev_desc },
+	{ "INT33C3", (unsigned long)&lpt_dev_desc },
+	{ "INT33C4", (unsigned long)&lpt_dev_desc },
+	{ "INT33C5", (unsigned long)&lpt_dev_desc },
+	{ "INT33C6", },
+	{ "INT33C7", },
+
+	{ }
+};
+
+static int is_memory(struct acpi_resource *res, void *not_used)
+{
+	struct resource r;
+	return !acpi_dev_resource_memory(res, &r);
+}
+
+/* LPSS main clock device. */
+static struct platform_device *lpss_clk_dev;
+
+static inline void lpt_register_clock_device(void)
+{
+	lpss_clk_dev = platform_device_register_simple("clk-lpt", -1, NULL, 0);
+}
+
+static int register_device_clock(struct acpi_device *adev,
+				 struct lpss_private_data *pdata)
+{
+	const struct lpss_device_desc *dev_desc = pdata->dev_desc;
+
+	if (!lpss_clk_dev)
+		lpt_register_clock_device();
+
+	if (!dev_desc->clk_parent || !pdata->mmio_base
+	    || pdata->mmio_size < LPSS_CLK_OFFSET + LPSS_CLK_SIZE)
+		return -ENODATA;
+
+	pdata->clk = clk_register_gate(NULL, dev_name(&adev->dev),
+				       dev_desc->clk_parent, 0,
+				       pdata->mmio_base + LPSS_CLK_OFFSET,
+				       0, 0, NULL);
+	if (IS_ERR(pdata->clk))
+		return PTR_ERR(pdata->clk);
+
+	clk_register_clkdev(pdata->clk, NULL, dev_name(&adev->dev));
+	return 0;
+}
+
+static int acpi_lpss_create_device(struct acpi_device *adev,
+				   const struct acpi_device_id *id)
+{
+	struct lpss_device_desc *dev_desc;
+	struct lpss_private_data *pdata;
+	struct resource_list_entry *rentry;
+	struct list_head resource_list;
+	int ret;
+
+	dev_desc = (struct lpss_device_desc *)id->driver_data;
+	if (!dev_desc)
+		return acpi_create_platform_device(adev, id);
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&resource_list);
+	ret = acpi_dev_get_resources(adev, &resource_list, is_memory, NULL);
+	if (ret < 0)
+		goto err_out;
+
+	list_for_each_entry(rentry, &resource_list, node)
+		if (resource_type(&rentry->res) == IORESOURCE_MEM) {
+			pdata->mmio_size = resource_size(&rentry->res);
+			pdata->mmio_base = ioremap(rentry->res.start,
+						   pdata->mmio_size);
+			pdata->dev_desc = dev_desc;
+			break;
+		}
+
+	acpi_dev_free_resource_list(&resource_list);
+
+	if (dev_desc->clk_required) {
+		ret = register_device_clock(adev, pdata);
+		if (ret) {
+			/*
+			 * Skip the device, but don't terminate the namespace
+			 * scan.
+			 */
+			ret = 0;
+			goto err_out;
+		}
+	}
+
+	adev->driver_data = pdata;
+	ret = acpi_create_platform_device(adev, id);
+	if (ret > 0)
+		return ret;
+
+	adev->driver_data = NULL;
+
+ err_out:
+	kfree(pdata);
+	return ret;
+}
+
+static struct acpi_scan_handler lpss_handler = {
+	.ids = acpi_lpss_device_ids,
+	.attach = acpi_lpss_create_device,
+};
+
+void __init acpi_lpss_init(void)
+{
+	if (!lpt_clk_init())
+		acpi_scan_add_handler(&lpss_handler);
+}
