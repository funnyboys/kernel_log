commit 55716d26439f5c4008b0bcb7f17d1f7c0d8fbcfc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:42 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 428
    
    Based on 1 normalized pattern(s):
    
      this file is released under the gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 68 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190114.292346262@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/nvs.c b/drivers/acpi/nvs.c
index 85287b8fe3aa..9f8712a557b3 100644
--- a/drivers/acpi/nvs.c
+++ b/drivers/acpi/nvs.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * nvs.c - Routines for saving and restoring ACPI NVS memory region
  *
  * Copyright (C) 2008-2011 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.
- *
- * This file is released under the GPLv2.
  */
 
 #include <linux/io.h>

commit a238317ce8185519ed083e81e84260907fbbcf7f
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue May 20 15:39:41 2014 +0800

    ACPI: Clean up acpi_os_map/unmap_memory() to eliminate __iomem.
    
    ACPICA doesn't include protections around address space checking, Linux
    build tests always complain increased sparse warnings around ACPICA
    internal acpi_os_map/unmap_memory() invocations.  This patch tries to fix
    this issue permanently.
    
    There are 2 choices left for us to solve this issue:
     1. Add __iomem address space awareness into ACPICA.
     2. Remove sparse checker of __iomem from ACPICA source code.
    
    This patch chooses solution 2, because:
     1.  Most of the acpi_os_map/unmap_memory() invocations are used for ACPICA.
         table mappings, which in fact are not IO addresses.
     2.  The only IO addresses usage is for "system memory space" mapping code in:
          drivers/acpi/acpica/exregion.c
          drivers/acpi/acpica/evrgnini.c
          drivers/acpi/acpica/exregion.c
        The mapped address is accessed in the handler of "system memory space"
        - acpi_ex_system_memory_space_handler().  This function in fact can be
        changed to invoke acpi_os_read/write_memory() so that __iomem can
        always be type-casted in the OSL layer.
    
    According to the above investigation, we drew the following conclusion:
    It is not a good idea to introduce __iomem address space awareness into
    ACPICA mostly in order to protect non-IO addresses.
    
    We can simply remove __iomem for acpi_os_map/unmap_memory() to remove
    __iomem checker for ACPICA code. Then we need to enforce external usages
    to invoke other APIs that are aware of __iomem address space.
    The external usages are:
     drivers/acpi/apei/einj.c
     drivers/acpi/acpi_extlog.c
     drivers/char/tpm/tpm_acpi.c
     drivers/acpi/nvs.c
    
    This patch thus performs cleanups in this way:
     1. Add acpi_os_map/unmap_iomem() to be invoked by non-ACPICA code.
     2. Remove __iomem from acpi_os_map/unmap_memory().
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/nvs.c b/drivers/acpi/nvs.c
index de4fe03873c5..85287b8fe3aa 100644
--- a/drivers/acpi/nvs.c
+++ b/drivers/acpi/nvs.c
@@ -139,8 +139,8 @@ void suspend_nvs_free(void)
 					iounmap(entry->kaddr);
 					entry->unmap = false;
 				} else {
-					acpi_os_unmap_memory(entry->kaddr,
-							     entry->size);
+					acpi_os_unmap_iomem(entry->kaddr,
+							    entry->size);
 				}
 				entry->kaddr = NULL;
 			}

commit 679c581b4a399f519155bf1d976f05d14b5717c3
Author: Rashika <rashika.kheria@gmail.com>
Date:   Tue Dec 17 14:45:00 2013 +0530

    ACPI / NVS: Include appropriate header file in nvs.c
    
    Include header file internal.h in nvs.c because functions
    suspend_nvs_free(), suspend_nvs_alloc(), suspend_nvs_save() and
    suspend_nvs_restore() have their prototype declaration in internal.h.
    
    This eliminates the following warnings in nvs.c:
    drivers/acpi/nvs.c:128:6: warning: no previous prototype for ‘suspend_nvs_free’ [-Wmissing-prototypes]
    drivers/acpi/nvs.c:152:5: warning: no previous prototype for ‘suspend_nvs_alloc’ [-Wmissing-prototypes]
    drivers/acpi/nvs.c:169:5: warning: no previous prototype for ‘suspend_nvs_save’ [-Wmissing-prototypes]
    drivers/acpi/nvs.c:201:6: warning: no previous prototype for ‘suspend_nvs_restore’ [-Wmissing-prototypes]
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/nvs.c b/drivers/acpi/nvs.c
index ef28613d5192..de4fe03873c5 100644
--- a/drivers/acpi/nvs.c
+++ b/drivers/acpi/nvs.c
@@ -13,6 +13,8 @@
 #include <linux/slab.h>
 #include <linux/acpi.h>
 
+#include "internal.h"
+
 /* ACPI NVS regions, APEI may use it */
 
 struct nvs_region {

commit 27d50c82714f6477ac690034b37d202f76eb4f70
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Dec 6 16:52:05 2013 +0800

    ACPI / i915: Fix incorrect <acpi/acpi.h> inclusions via <linux/acpi_io.h>
    
    To avoid build problems and breaking dependencies between ACPI header
    files, <acpi/acpi.h> should not be included directly by code outside
    of the ACPI core subsystem.  However, that is possible if
    <linux/acpi_io.h> is included, because that file contains
    a direct inclusion of <acpi/acpi.h>.
    
    For this reason, remove the direct <acpi/acpi.h> inclusion from
    <linux/acpi_io.h>, move that file from include/linux/ to include/acpi/
    and make <linux/acpi.h> include it for CONFIG_ACPI set along with the
    other ACPI header files.  Accordingly, Remove the inclusions of
    <linux/acpi_io.h> from everywhere.
    
    Of course, that causes the contents of the new <acpi/acpi_io.h> file
    to be available for CONFIG_ACPI set only, so intel_opregion.o that
    depends on it should also depend on CONFIG_ACPI (and it really should
    not be compiled for CONFIG_ACPI unset anyway).
    
    References: https://01.org/linuxgraphics/sites/default/files/documentation/acpi_igd_opregion_spec.pdf
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    [rjw: Subject and changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/nvs.c b/drivers/acpi/nvs.c
index 386a9fe497b4..ef28613d5192 100644
--- a/drivers/acpi/nvs.c
+++ b/drivers/acpi/nvs.c
@@ -12,7 +12,6 @@
 #include <linux/mm.h>
 #include <linux/slab.h>
 #include <linux/acpi.h>
-#include <linux/acpi_io.h>
 
 /* ACPI NVS regions, APEI may use it */
 

commit fe5e49cb5ac57f984a44287cf123fbbc712d7bec
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Fri Dec 6 16:51:46 2013 +0800

    ACPI: Clean up incorrect inclusion of an ACPICA header
    
    Since drivers/acpi/nvs.c includes <linux/acpi.h> and is only compiled
    for CONFIG_ACPI set, it doesn't need to include <acpi/acpiosxf.h>
    directly, which is formally incorrect.  Remove the <acpi/acpiosxf.h>
    inclusion from that file.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    [rjw: Subject and changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/nvs.c b/drivers/acpi/nvs.c
index 266bc58ce0ce..386a9fe497b4 100644
--- a/drivers/acpi/nvs.c
+++ b/drivers/acpi/nvs.c
@@ -13,7 +13,6 @@
 #include <linux/slab.h>
 #include <linux/acpi.h>
 #include <linux/acpi_io.h>
-#include <acpi/acpiosxf.h>
 
 /* ACPI NVS regions, APEI may use it */
 

commit c6436f5a395d346e9f4892d7aeed4c3f99261f0f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Feb 13 17:04:43 2012 -0700

    ACPI / PM: print physical addresses consistently with other parts of kernel
    
    Print physical address info in a style consistent with the %pR style used
    elsewhere in the kernel.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/nvs.c b/drivers/acpi/nvs.c
index 7a2035fa8c71..266bc58ce0ce 100644
--- a/drivers/acpi/nvs.c
+++ b/drivers/acpi/nvs.c
@@ -95,8 +95,8 @@ static int suspend_nvs_register(unsigned long start, unsigned long size)
 {
 	struct nvs_page *entry, *next;
 
-	pr_info("PM: Registering ACPI NVS region at %lx (%ld bytes)\n",
-		start, size);
+	pr_info("PM: Registering ACPI NVS region [mem %#010lx-%#010lx] (%ld bytes)\n",
+		start, start + size - 1, size);
 
 	while (size > 0) {
 		unsigned int nr_bytes;

commit b54ac6d2a25084667da781c7ca2cebef52a2bcdd
Author: Huang Ying <ying.huang@intel.com>
Date:   Thu Dec 8 11:25:49 2011 +0800

    ACPI, Record ACPI NVS regions
    
    Some firmware will access memory in ACPI NVS region via APEI.  That
    is, instructions in APEI ERST/EINJ table will read/write ACPI NVS
    region.  The original resource conflict checking in APEI code will
    check memory/ioport accessed by APEI via general resource management
    mechanism.  But ACPI NVS region is marked as busy already, so that the
    false resource conflict will prevent APEI ERST/EINJ to work.
    
    To fix this, this patch record ACPI NVS regions, so that we can avoid
    request resources for memory region inside it.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/nvs.c b/drivers/acpi/nvs.c
index 096787b43c96..7a2035fa8c71 100644
--- a/drivers/acpi/nvs.c
+++ b/drivers/acpi/nvs.c
@@ -15,6 +15,56 @@
 #include <linux/acpi_io.h>
 #include <acpi/acpiosxf.h>
 
+/* ACPI NVS regions, APEI may use it */
+
+struct nvs_region {
+	__u64 phys_start;
+	__u64 size;
+	struct list_head node;
+};
+
+static LIST_HEAD(nvs_region_list);
+
+#ifdef CONFIG_ACPI_SLEEP
+static int suspend_nvs_register(unsigned long start, unsigned long size);
+#else
+static inline int suspend_nvs_register(unsigned long a, unsigned long b)
+{
+	return 0;
+}
+#endif
+
+int acpi_nvs_register(__u64 start, __u64 size)
+{
+	struct nvs_region *region;
+
+	region = kmalloc(sizeof(*region), GFP_KERNEL);
+	if (!region)
+		return -ENOMEM;
+	region->phys_start = start;
+	region->size = size;
+	list_add_tail(&region->node, &nvs_region_list);
+
+	return suspend_nvs_register(start, size);
+}
+
+int acpi_nvs_for_each_region(int (*func)(__u64 start, __u64 size, void *data),
+			     void *data)
+{
+	int rc;
+	struct nvs_region *region;
+
+	list_for_each_entry(region, &nvs_region_list, node) {
+		rc = func(region->phys_start, region->size, data);
+		if (rc)
+			return rc;
+	}
+
+	return 0;
+}
+
+
+#ifdef CONFIG_ACPI_SLEEP
 /*
  * Platforms, like ACPI, may want us to save some memory used by them during
  * suspend and to restore the contents of this memory during the subsequent
@@ -41,7 +91,7 @@ static LIST_HEAD(nvs_list);
  *	things so that the data from page-aligned addresses in this region will
  *	be copied into separate RAM pages.
  */
-int suspend_nvs_register(unsigned long start, unsigned long size)
+static int suspend_nvs_register(unsigned long start, unsigned long size)
 {
 	struct nvs_page *entry, *next;
 
@@ -159,3 +209,4 @@ void suspend_nvs_restore(void)
 		if (entry->data)
 			memcpy(entry->kaddr, entry->data, entry->size);
 }
+#endif

commit bb45e394e21eb2abc710ad43d98ebac1069bf355
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:38:38 2011 +0100

    ACPI / PM: Use existing ACPI iomaps for NVS save/restore (v2)
    
    Modify the NVS save/restore code to use acpi_os_get_iomem() and
    acpi_os_unmap_memory() to acquire and release references to ACPI
    iomaps, respectively.  If there's no ACPI iomap corresponding to the
    given NVS page, acpi_os_ioremap() is used to map that page and
    iounmap() is used to unmap it during resume.  [If the page is not
    present in the ACPI iomaps already, it doesn't make sense to add its
    mapping to the list of ACPI iomaps, because it's going to be thrown
    away during the subsequent resume anyway.]
    
    Testing on my HP nx6325 shows that approx. 90% of the NVS pages
    have already been mapped by ACPI before suspend and are present in
    the ACPI iomaps, so this change appears to be the right thing to do
    in general.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/acpi/nvs.c b/drivers/acpi/nvs.c
index fa5a1df42b79..096787b43c96 100644
--- a/drivers/acpi/nvs.c
+++ b/drivers/acpi/nvs.c
@@ -26,6 +26,7 @@ struct nvs_page {
 	unsigned int size;
 	void *kaddr;
 	void *data;
+	bool unmap;
 	struct list_head node;
 };
 
@@ -44,6 +45,9 @@ int suspend_nvs_register(unsigned long start, unsigned long size)
 {
 	struct nvs_page *entry, *next;
 
+	pr_info("PM: Registering ACPI NVS region at %lx (%ld bytes)\n",
+		start, size);
+
 	while (size > 0) {
 		unsigned int nr_bytes;
 
@@ -81,7 +85,13 @@ void suspend_nvs_free(void)
 			free_page((unsigned long)entry->data);
 			entry->data = NULL;
 			if (entry->kaddr) {
-				iounmap(entry->kaddr);
+				if (entry->unmap) {
+					iounmap(entry->kaddr);
+					entry->unmap = false;
+				} else {
+					acpi_os_unmap_memory(entry->kaddr,
+							     entry->size);
+				}
 				entry->kaddr = NULL;
 			}
 		}
@@ -115,8 +125,14 @@ int suspend_nvs_save(void)
 
 	list_for_each_entry(entry, &nvs_list, node)
 		if (entry->data) {
-			entry->kaddr = acpi_os_ioremap(entry->phys_start,
-						    entry->size);
+			unsigned long phys = entry->phys_start;
+			unsigned int size = entry->size;
+
+			entry->kaddr = acpi_os_get_iomem(phys, size);
+			if (!entry->kaddr) {
+				entry->kaddr = acpi_os_ioremap(phys, size);
+				entry->unmap = !!entry->kaddr;
+			}
 			if (!entry->kaddr) {
 				suspend_nvs_free();
 				return -ENOMEM;

commit 2d6d9fd3a54a28c6f67f26eb6c74803307a1b11e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jan 19 22:27:14 2011 +0100

    ACPI: Introduce acpi_os_ioremap()
    
    Commit ca9b600be38c ("ACPI / PM: Make suspend_nvs_save() use
    acpi_os_map_memory()") attempted to prevent the code in osl.c and nvs.c
    from using different ioremap() variants by making the latter use
    acpi_os_map_memory() for mapping the NVS pages.  However, that also
    requires acpi_os_unmap_memory() to be used for unmapping them, which
    causes synchronize_rcu() to be executed many times in a row
    unnecessarily and introduces substantial delays during resume on some
    systems.
    
    Instead of using acpi_os_map_memory() for mapping the NVS pages in nvs.c
    introduce acpi_os_ioremap() calling ioremap_cache() and make the code in
    both osl.c and nvs.c use it.
    
    Reported-by: Jeff Chua <jeff.chua.linux@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/acpi/nvs.c b/drivers/acpi/nvs.c
index 54b6ab8040a6..fa5a1df42b79 100644
--- a/drivers/acpi/nvs.c
+++ b/drivers/acpi/nvs.c
@@ -12,6 +12,7 @@
 #include <linux/mm.h>
 #include <linux/slab.h>
 #include <linux/acpi.h>
+#include <linux/acpi_io.h>
 #include <acpi/acpiosxf.h>
 
 /*
@@ -80,7 +81,7 @@ void suspend_nvs_free(void)
 			free_page((unsigned long)entry->data);
 			entry->data = NULL;
 			if (entry->kaddr) {
-				acpi_os_unmap_memory(entry->kaddr, entry->size);
+				iounmap(entry->kaddr);
 				entry->kaddr = NULL;
 			}
 		}
@@ -114,8 +115,8 @@ int suspend_nvs_save(void)
 
 	list_for_each_entry(entry, &nvs_list, node)
 		if (entry->data) {
-			entry->kaddr = acpi_os_map_memory(entry->phys_start,
-							  entry->size);
+			entry->kaddr = acpi_os_ioremap(entry->phys_start,
+						    entry->size);
 			if (!entry->kaddr) {
 				suspend_nvs_free();
 				return -ENOMEM;

commit ca9b600be38c73b7d25acfb8b7e4e9a9e941d881
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 7 01:45:58 2011 +0100

    ACPI / PM: Make suspend_nvs_save() use acpi_os_map_memory()
    
    It turns out that the NVS memory region that suspend_nvs_save()
    attempts to map has been already mapped by acpi_os_map_memory(), so
    suspend_nvs_save() should better use acpi_os_map_memory() for mapping
    memory to avoid conflicts.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/nvs.c b/drivers/acpi/nvs.c
index 7d648092427e..54b6ab8040a6 100644
--- a/drivers/acpi/nvs.c
+++ b/drivers/acpi/nvs.c
@@ -12,6 +12,7 @@
 #include <linux/mm.h>
 #include <linux/slab.h>
 #include <linux/acpi.h>
+#include <acpi/acpiosxf.h>
 
 /*
  * Platforms, like ACPI, may want us to save some memory used by them during
@@ -79,7 +80,7 @@ void suspend_nvs_free(void)
 			free_page((unsigned long)entry->data);
 			entry->data = NULL;
 			if (entry->kaddr) {
-				iounmap(entry->kaddr);
+				acpi_os_unmap_memory(entry->kaddr, entry->size);
 				entry->kaddr = NULL;
 			}
 		}
@@ -113,7 +114,8 @@ int suspend_nvs_save(void)
 
 	list_for_each_entry(entry, &nvs_list, node)
 		if (entry->data) {
-			entry->kaddr = ioremap(entry->phys_start, entry->size);
+			entry->kaddr = acpi_os_map_memory(entry->phys_start,
+							  entry->size);
 			if (!entry->kaddr) {
 				suspend_nvs_free();
 				return -ENOMEM;

commit d146df18c13d16e321efa8ef9b57c95c3bec1722
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 7 01:44:28 2011 +0100

    ACPI / PM: Update file information and the list of includes in nvs.c
    
    The file information and the list of include in drivers/acpi/nvs.c
    are outdated, so update them.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/nvs.c b/drivers/acpi/nvs.c
index 57c6fabbb6b6..7d648092427e 100644
--- a/drivers/acpi/nvs.c
+++ b/drivers/acpi/nvs.c
@@ -1,7 +1,7 @@
 /*
- * linux/kernel/power/hibernate_nvs.c - Routines for handling NVS memory
+ * nvs.c - Routines for saving and restoring ACPI NVS memory region
  *
- * Copyright (C) 2008,2009 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.
+ * Copyright (C) 2008-2011 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.
  *
  * This file is released under the GPLv2.
  */
@@ -11,7 +11,7 @@
 #include <linux/list.h>
 #include <linux/mm.h>
 #include <linux/slab.h>
-#include <linux/suspend.h>
+#include <linux/acpi.h>
 
 /*
  * Platforms, like ACPI, may want us to save some memory used by them during

commit 976513dbfc1547c7b1822566923058655f0c32fd
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 7 01:43:44 2011 +0100

    PM / ACPI: Move NVS saving and restoring code to drivers/acpi
    
    The saving of the ACPI NVS area during hibernation and suspend and
    restoring it during the subsequent resume is entirely specific to
    ACPI, so move it to drivers/acpi and drop the CONFIG_SUSPEND_NVS
    configuration option which is redundant.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/nvs.c b/drivers/acpi/nvs.c
new file mode 100644
index 000000000000..57c6fabbb6b6
--- /dev/null
+++ b/drivers/acpi/nvs.c
@@ -0,0 +1,142 @@
+/*
+ * linux/kernel/power/hibernate_nvs.c - Routines for handling NVS memory
+ *
+ * Copyright (C) 2008,2009 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.
+ *
+ * This file is released under the GPLv2.
+ */
+
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/suspend.h>
+
+/*
+ * Platforms, like ACPI, may want us to save some memory used by them during
+ * suspend and to restore the contents of this memory during the subsequent
+ * resume.  The code below implements a mechanism allowing us to do that.
+ */
+
+struct nvs_page {
+	unsigned long phys_start;
+	unsigned int size;
+	void *kaddr;
+	void *data;
+	struct list_head node;
+};
+
+static LIST_HEAD(nvs_list);
+
+/**
+ *	suspend_nvs_register - register platform NVS memory region to save
+ *	@start - physical address of the region
+ *	@size - size of the region
+ *
+ *	The NVS region need not be page-aligned (both ends) and we arrange
+ *	things so that the data from page-aligned addresses in this region will
+ *	be copied into separate RAM pages.
+ */
+int suspend_nvs_register(unsigned long start, unsigned long size)
+{
+	struct nvs_page *entry, *next;
+
+	while (size > 0) {
+		unsigned int nr_bytes;
+
+		entry = kzalloc(sizeof(struct nvs_page), GFP_KERNEL);
+		if (!entry)
+			goto Error;
+
+		list_add_tail(&entry->node, &nvs_list);
+		entry->phys_start = start;
+		nr_bytes = PAGE_SIZE - (start & ~PAGE_MASK);
+		entry->size = (size < nr_bytes) ? size : nr_bytes;
+
+		start += entry->size;
+		size -= entry->size;
+	}
+	return 0;
+
+ Error:
+	list_for_each_entry_safe(entry, next, &nvs_list, node) {
+		list_del(&entry->node);
+		kfree(entry);
+	}
+	return -ENOMEM;
+}
+
+/**
+ *	suspend_nvs_free - free data pages allocated for saving NVS regions
+ */
+void suspend_nvs_free(void)
+{
+	struct nvs_page *entry;
+
+	list_for_each_entry(entry, &nvs_list, node)
+		if (entry->data) {
+			free_page((unsigned long)entry->data);
+			entry->data = NULL;
+			if (entry->kaddr) {
+				iounmap(entry->kaddr);
+				entry->kaddr = NULL;
+			}
+		}
+}
+
+/**
+ *	suspend_nvs_alloc - allocate memory necessary for saving NVS regions
+ */
+int suspend_nvs_alloc(void)
+{
+	struct nvs_page *entry;
+
+	list_for_each_entry(entry, &nvs_list, node) {
+		entry->data = (void *)__get_free_page(GFP_KERNEL);
+		if (!entry->data) {
+			suspend_nvs_free();
+			return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
+/**
+ *	suspend_nvs_save - save NVS memory regions
+ */
+int suspend_nvs_save(void)
+{
+	struct nvs_page *entry;
+
+	printk(KERN_INFO "PM: Saving platform NVS memory\n");
+
+	list_for_each_entry(entry, &nvs_list, node)
+		if (entry->data) {
+			entry->kaddr = ioremap(entry->phys_start, entry->size);
+			if (!entry->kaddr) {
+				suspend_nvs_free();
+				return -ENOMEM;
+			}
+			memcpy(entry->data, entry->kaddr, entry->size);
+		}
+
+	return 0;
+}
+
+/**
+ *	suspend_nvs_restore - restore NVS memory regions
+ *
+ *	This function is going to be called with interrupts disabled, so it
+ *	cannot iounmap the virtual addresses used to access the NVS region.
+ */
+void suspend_nvs_restore(void)
+{
+	struct nvs_page *entry;
+
+	printk(KERN_INFO "PM: Restoring platform NVS memory\n");
+
+	list_for_each_entry(entry, &nvs_list, node)
+		if (entry->data)
+			memcpy(entry->kaddr, entry->data, entry->size);
+}
