commit 50dd154ed7b17a8b3a1983fc32a8e41d4cc4211a
Merge: 4c277e2f8596 54e74df5d76d 956ad9d98b73
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 10 17:10:40 2020 +0200

    Merge branches 'pm-cpufreq' and 'pm-acpi'
    
    * pm-cpufreq:
      cpufreq: CPPC: add SW BOOST support
      cpufreq: change '.set_boost' to act on one policy
      cpufreq: tegra186: add CPUFREQ_NEED_INITIAL_FREQ_CHECK flag
    
    * pm-acpi:
      ACPI: PM: Avoid using power resources if there are none for D0

commit 956ad9d98b73f59e442cc119c98ba1e04e94fe6d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jun 4 19:22:26 2020 +0200

    ACPI: PM: Avoid using power resources if there are none for D0
    
    As recently reported, some platforms provide a list of power
    resources for device power state D3hot, through the _PR3 object,
    but they do not provide a list of power resources for device power
    state D0.
    
    Among other things, this causes acpi_device_get_power() to return
    D3hot as the current state of the device in question if all of the
    D3hot power resources are "on", because it sees the power_resources
    flag set and calls acpi_power_get_inferred_state() which finds that
    D3hot is the shallowest power state with all of the associated power
    resources turned "on", so that's what it returns.  Moreover, that
    value takes precedence over the acpi_dev_pm_explicit_get() return
    value, because it means a deeper power state.  The device may very
    well be in D0 physically at that point, however.
    
    Moreover, the presence of _PR3 without _PR0 for a given device
    means that only one D3-level power state can be supported by it.
    Namely, because there are no power resources to turn "off" when
    transitioning the device from D0 into D3cold (which should be
    supported since _PR3 is present), the evaluation of _PS3 should
    be sufficient to put it straight into D3cold, but this means that
    the effect of turning "on" the _PR3 power resources is unclear,
    so it is better to avoid doing that altogether.  Consequently,
    there is no practical way do distinguish D3cold from D3hot for
    the device in question and the power states of it can be labeled
    so that D3hot is the deepest supported one (and Linux assumes
    that putting a device into D3hot via ACPI may cause power to be
    removed from it anyway, for legacy reasons).
    
    To work around the problem described above modify the ACPI
    enumeration of devices so that power resources are only used
    for device power management if the list of D0 power resources
    is not empty and make it mart D3cold as supported only if that
    is the case and the D3hot list of power resources is not empty
    too.
    
    Fixes: ef85bdbec444 ("ACPI / scan: Consolidate extraction of power resources lists")
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=205057
    Link: https://lore.kernel.org/linux-acpi/20200603194659.185757-1-hdegoede@redhat.com/
    Reported-by: Hans de Goede <hdegoede@redhat.com>
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Tested-by: youling257@gmail.com
    Cc: 3.10+ <stable@vger.kernel.org> # 3.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 5832bc10aca8..95e200b618bd 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -186,7 +186,7 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 		 * possibly drop references to the power resources in use.
 		 */
 		state = ACPI_STATE_D3_HOT;
-		/* If _PR3 is not available, use D3hot as the target state. */
+		/* If D3cold is not supported, use D3hot as the target state. */
 		if (!device->power.states[ACPI_STATE_D3_COLD].flags.valid)
 			target_state = state;
 	} else if (!device->power.states[state].flags.valid) {

commit be6018a44c2479d22fef40eb6f5a3442627b8bcb
Merge: 5fcd73590192 9a7875461fd0 ad1e4f74c072
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 1 15:19:08 2020 +0200

    Merge branches 'pm-core' and 'pm-sleep'
    
    * pm-core:
      PM: runtime: Replace pm_runtime_callbacks_present()
      PM: runtime: clk: Fix clk_pm_runtime_get() error path
      PM: runtime: Make clear what we do when conditions are wrong in rpm_suspend()
    
    * pm-sleep:
      PM: hibernate: Restrict writes to the resume device
      PM: hibernate: Split off snapshot dev option
      PM: hibernate: Incorporate concurrency handling
      PM: sleep: Helpful edits for devices.rst documentation
      Documentation: PM: sleep: Update driver flags documentation
      PM: sleep: core: Rename DPM_FLAG_LEAVE_SUSPENDED
      PM: sleep: core: Rename DPM_FLAG_NEVER_SKIP
      PM: sleep: core: Rename dev_pm_smart_suspend_and_suspended()
      PM: sleep: core: Rename dev_pm_may_skip_resume()
      PM: sleep: core: Rework the power.may_skip_resume handling
      PM: sleep: core: Do not skip callbacks in the resume phase
      PM: sleep: core: Fold functions into their callers
      PM: sleep: core: Simplify the SMART_SUSPEND flag handling

commit a9b760b0266f563b4784f695bbd0e717610dc10a
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Tue Apr 21 15:55:16 2020 +0800

    PM: ACPI: Output correct message on target power state
    
    Transitioned power state logged at the end of setting ACPI power.
    
    However, D3cold won't be in the message because state can only be
    D3hot at most.
    
    Use target_state to corretly report when power state is D3cold.
    
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index b2263ec67b43..5832bc10aca8 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -273,13 +273,13 @@ int acpi_device_set_power(struct acpi_device *device, int state)
  end:
 	if (result) {
 		dev_warn(&device->dev, "Failed to change power state to %s\n",
-			 acpi_power_state_string(state));
+			 acpi_power_state_string(target_state));
 	} else {
 		device->power.state = target_state;
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Device [%s] transitioned to %s\n",
 				  device->pnp.bus_id,
-				  acpi_power_state_string(state)));
+				  acpi_power_state_string(target_state)));
 	}
 
 	return result;

commit fa2bfead910322e44e7e0bb74364ac198a2abd32
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:52:48 2020 +0200

    PM: sleep: core: Rename dev_pm_smart_suspend_and_suspended()
    
    Because all callers of dev_pm_smart_suspend_and_suspended use it only
    for checking whether or not to skip driver suspend callbacks for a
    device, rename it to dev_pm_skip_suspend() in analogy with
    dev_pm_skip_resume().
    
    No functional impact.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 8c2a091728a9..ae234d731d42 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1084,7 +1084,7 @@ int acpi_subsys_suspend_late(struct device *dev)
 {
 	int ret;
 
-	if (dev_pm_smart_suspend_and_suspended(dev))
+	if (dev_pm_skip_suspend(dev))
 		return 0;
 
 	ret = pm_generic_suspend_late(dev);
@@ -1100,7 +1100,7 @@ int acpi_subsys_suspend_noirq(struct device *dev)
 {
 	int ret;
 
-	if (dev_pm_smart_suspend_and_suspended(dev))
+	if (dev_pm_skip_suspend(dev))
 		return 0;
 
 	ret = pm_generic_suspend_noirq(dev);
@@ -1213,7 +1213,7 @@ static int acpi_subsys_poweroff_late(struct device *dev)
 {
 	int ret;
 
-	if (dev_pm_smart_suspend_and_suspended(dev))
+	if (dev_pm_skip_suspend(dev))
 		return 0;
 
 	ret = pm_generic_poweroff_late(dev);
@@ -1229,7 +1229,7 @@ static int acpi_subsys_poweroff_late(struct device *dev)
  */
 static int acpi_subsys_poweroff_noirq(struct device *dev)
 {
-	if (dev_pm_smart_suspend_and_suspended(dev))
+	if (dev_pm_skip_suspend(dev))
 		return 0;
 
 	return pm_generic_poweroff_noirq(dev);

commit 76c70cb58ce30264af4b714109ee756da25d830a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:52:30 2020 +0200

    PM: sleep: core: Rename dev_pm_may_skip_resume()
    
    The name of dev_pm_may_skip_resume() may be easily confused with the
    power.may_skip_resume flag which is not checked by that function, so
    rename the former as dev_pm_skip_resume().
    
    No functional impact.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 1b02d7dc7d34..8c2a091728a9 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1127,7 +1127,7 @@ EXPORT_SYMBOL_GPL(acpi_subsys_suspend_noirq);
  */
 static int acpi_subsys_resume_noirq(struct device *dev)
 {
-	if (dev_pm_may_skip_resume(dev))
+	if (dev_pm_skip_resume(dev))
 		return 0;
 
 	return pm_generic_resume_noirq(dev);
@@ -1145,7 +1145,7 @@ static int acpi_subsys_resume_early(struct device *dev)
 {
 	int ret;
 
-	if (dev_pm_may_skip_resume(dev))
+	if (dev_pm_skip_resume(dev))
 		return 0;
 
 	ret = acpi_dev_resume(dev);

commit 0fe8a1be599ab97f840ba22d98cb8f24a9f9e872
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:52:19 2020 +0200

    PM: sleep: core: Rework the power.may_skip_resume handling
    
    Because the power.may_skip_resume device status bit is taken
    into account in combination with the DPM_FLAG_LEAVE_SUSPENDED
    driver flag, it can be set to 'true' for all devices in the
    "suspend" phase of a suspend-resume cycle, so do that.
    
    Then, neither the PM core nor the middle-layer (sybsystem) code
    handling it needs to set it to 'true' any more and it just has
    to be cleared if there is a reason to avoid skipping the "noirq"
    and "early" resume callbacks provided by the driver, so update
    the code in question accordingly.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 399684085f85..1b02d7dc7d34 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1100,10 +1100,8 @@ int acpi_subsys_suspend_noirq(struct device *dev)
 {
 	int ret;
 
-	if (dev_pm_smart_suspend_and_suspended(dev)) {
-		dev->power.may_skip_resume = true;
+	if (dev_pm_smart_suspend_and_suspended(dev))
 		return 0;
-	}
 
 	ret = pm_generic_suspend_noirq(dev);
 	if (ret)
@@ -1116,8 +1114,8 @@ int acpi_subsys_suspend_noirq(struct device *dev)
 	 * acpi_subsys_complete() to take care of fixing up the device's state
 	 * anyway, if need be.
 	 */
-	dev->power.may_skip_resume = device_may_wakeup(dev) ||
-					!device_can_wakeup(dev);
+	if (device_can_wakeup(dev) && !device_may_wakeup(dev))
+		dev->power.may_skip_resume = false;
 
 	return 0;
 }

commit 6e176bf8d46194353163c2cb660808bc633b45d9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:52:08 2020 +0200

    PM: sleep: core: Do not skip callbacks in the resume phase
    
    The current code in device_resume_noirq() causes the entire early
    resume and resume phases of device suspend to be skipped for
    devices for which the noirq resume phase have been skipped (due
    to the LEAVE_SUSPENDED flag being set) on the premise that those
    devices should stay in runtime-suspend after system-wide resume.
    
    However, that may not be correct in two situations.  First, the
    middle layer (subsystem) noirq resume callback may be missing for
    a given device, but its early resume callback may be present and it
    may need to do something even if it decides to skip the driver
    callback.  Second, if the device's wakeup settings were adjusted
    in the suspend phase without resuming the device (that was in
    runtime suspend at that time), they most likely need to be
    adjusted again in the resume phase and so the driver callback
    in that phase needs to be run.
    
    For the above reason, modify the core to allow the middle layer
    ->resume_late callback to run even if its ->resume_noirq callback
    is missing (and the core has skipped the driver-level callback
    in that phase) and to allow all device callbacks to run in the
    resume phase.  Also make the core set the PM-runtime status of
    devices with SMART_SUSPEND set whose resume callbacks are not
    skipped to "active" in the "noirq" resume phase and update the
    affected subsystems (PCI and ACPI) accordingly.
    
    After this change, middle-layer (subsystem) callbacks will always
    be invoked in all phases of system suspend and resume and driver
    callbacks will always run in the prepare, suspend, resume, and
    complete phases for all devices.
    
    For devices with SMART_SUSPEND set, driver callbacks will be
    skipped in the late and noirq phases of system suspend if those
    devices remain in runtime suspend in __device_suspend_late().
    Driver callbacks will also be skipped for them during the
    noirq and early phases of the "thaw" transition related to
    hibernation in that case.
    
    Setting LEAVE_SUSPENDED means that the driver allows its callbacks
    to be skipped in the noirq and early phases of system resume, but
    some additional conditions need to be met for that to happen (among
    other things, the power.may_skip_resume flag needs to be set for the
    device during system suspend for the driver callbacks to be skipped
    during the subsequent resume transition).
    
    For all devices with SMART_SUSPEND set whose driver callbacks are
    invoked during system resume, the PM-runtime status will be set to
    "active" (by the core).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index b2263ec67b43..399684085f85 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1132,14 +1132,6 @@ static int acpi_subsys_resume_noirq(struct device *dev)
 	if (dev_pm_may_skip_resume(dev))
 		return 0;
 
-	/*
-	 * Devices with DPM_FLAG_SMART_SUSPEND may be left in runtime suspend
-	 * during system suspend, so update their runtime PM status to "active"
-	 * as they will be put into D0 going forward.
-	 */
-	if (dev_pm_smart_suspend_and_suspended(dev))
-		pm_runtime_set_active(dev);
-
 	return pm_generic_resume_noirq(dev);
 }
 
@@ -1153,7 +1145,12 @@ static int acpi_subsys_resume_noirq(struct device *dev)
  */
 static int acpi_subsys_resume_early(struct device *dev)
 {
-	int ret = acpi_dev_resume(dev);
+	int ret;
+
+	if (dev_pm_may_skip_resume(dev))
+		return 0;
+
+	ret = acpi_dev_resume(dev);
 	return ret ? ret : pm_generic_resume_early(dev);
 }
 

commit b62c770fee699a137359e1f1da9bf14a7f348567
Author: Gayatri Kammela <gayatri.kammela@intel.com>
Date:   Fri Mar 27 14:28:19 2020 -0700

    ACPI: Update Tiger Lake ACPI device IDs
    
    Tiger Lake's new unique ACPI device IDs for DPTF and fan drivers are not
    valid as the IDs are missing 'C'. Fix the IDs by updating them.
    
    After the update, the new IDs should now look like
    INT1047 --> INTC1047
    INT1040 --> INTC1040
    INT1043 --> INTC1043
    INT1044 --> INTC1044
    
    Fixes: 55cfe6a5c582 ("ACPI: DPTF: Add Tiger Lake ACPI device IDs")
    Fixes: c248dfe7e0ca ("ACPI: fan: Add Tiger Lake ACPI device ID")
    Suggested-by: Srinivas Pandruvada <srinivas.pandruvada@intel.com>
    Signed-off-by: Gayatri Kammela <gayatri.kammela@intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index b64c62bfcea5..b2263ec67b43 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1321,8 +1321,8 @@ int acpi_dev_pm_attach(struct device *dev, bool power_on)
 	 */
 	static const struct acpi_device_id special_pm_ids[] = {
 		{"PNP0C0B", }, /* Generic ACPI fan */
-		{"INT1044", }, /* Fan for Tiger Lake generation */
 		{"INT3404", }, /* Fan */
+		{"INTC1044", }, /* Fan for Tiger Lake generation */
 		{}
 	};
 	struct acpi_device *adev = ACPI_COMPANION(dev);

commit c248dfe7e0caa86e1cdfceddcf96649746dd171a
Author: Gayatri Kammela <gayatri.kammela@intel.com>
Date:   Mon Dec 16 10:31:49 2019 -0800

    ACPI: fan: Add Tiger Lake ACPI device ID
    
    Tiger Lake has a new unique ACPI device ID for the ACPI fan that
    needs to be added to the fan driver and to the blacklist in
    acpi_dev_pm_attach() to support it.
    
    Signed-off-by: Gayatri Kammela <gayatri.kammela@intel.com>
    [ rjw: Subject & changelog, fold in another patch ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 5e4a8860a9c0..b64c62bfcea5 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1321,6 +1321,7 @@ int acpi_dev_pm_attach(struct device *dev, bool power_on)
 	 */
 	static const struct acpi_device_id special_pm_ids[] = {
 		{"PNP0C0B", }, /* Generic ACPI fan */
+		{"INT1044", }, /* Fan for Tiger Lake generation */
 		{"INT3404", }, /* Fan */
 		{}
 	};

commit b9ea0bae260f6aae546db224daa6ac1bd9d94b91
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Dec 4 02:54:27 2019 +0100

    ACPI: PM: Avoid attaching ACPI PM domain to certain devices
    
    Certain ACPI-enumerated devices represented as platform devices in
    Linux, like fans, require special low-level power management handling
    implemented by their drivers that is not in agreement with the ACPI
    PM domain behavior.  That leads to problems with managing ACPI fans
    during system-wide suspend and resume.
    
    For this reason, make acpi_dev_pm_attach() skip the affected devices
    by adding a list of device IDs to avoid to it and putting the IDs of
    the affected devices into that list.
    
    Fixes: e5cc8ef31267 (ACPI / PM: Provide ACPI PM callback routines for subsystems)
    Reported-by: Zhang Rui <rui.zhang@intel.com>
    Tested-by: Todd Brandt <todd.e.brandt@linux.intel.com>
    Cc: 3.10+ <stable@vger.kernel.org> # 3.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 08bb9f2f2d23..5e4a8860a9c0 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1314,9 +1314,19 @@ static void acpi_dev_pm_detach(struct device *dev, bool power_off)
  */
 int acpi_dev_pm_attach(struct device *dev, bool power_on)
 {
+	/*
+	 * Skip devices whose ACPI companions match the device IDs below,
+	 * because they require special power management handling incompatible
+	 * with the generic ACPI PM domain.
+	 */
+	static const struct acpi_device_id special_pm_ids[] = {
+		{"PNP0C0B", }, /* Generic ACPI fan */
+		{"INT3404", }, /* Fan */
+		{}
+	};
 	struct acpi_device *adev = ACPI_COMPANION(dev);
 
-	if (!adev)
+	if (!adev || !acpi_match_device_ids(adev, special_pm_ids))
 		return 0;
 
 	/*

commit fc6763a2d7e0a7f49ccec97a46e92e9fb1f3f9dd
Merge: 031f469ecf7c e47bc756ad03 c3082a674f46 ee8193ee96c7 3ea4ca9267cf e3e2ffdc0c13
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 17 09:49:19 2019 +0200

    Merge branches 'pm-opp', 'pm-qos', 'acpi-pm', 'pm-domains' and 'pm-tools'
    
    * pm-opp:
      PM / OPP: Correct Documentation about library location
      opp: of: Support multiple suspend OPPs defined in DT
      dt-bindings: opp: Support multiple opp-suspend properties
      opp: core: add regulators enable and disable
      opp: Don't decrement uninitialized list_kref
    
    * pm-qos:
      PM: QoS: Get rid of unused flags
    
    * acpi-pm:
      ACPI: PM: Print debug messages on device power state changes
    
    * pm-domains:
      PM / Domains: Verify PM domain type in dev_pm_genpd_set_performance_state()
      PM / Domains: Simplify genpd_lookup_dev()
      PM / Domains: Align in-parameter names for some genpd functions
    
    * pm-tools:
      pm-graph: make setVal unbuffered again for python2 and python3
      cpupower: update German translation
      tools/power/cpupower: fix 64bit detection when cross-compiling
      cpupower: Add missing newline at end of file
      pm-graph v5.5

commit c8377adfa78103be5380200eb9dab764d7ca890e
Author: Tri Vo <trong@android.com>
Date:   Tue Aug 6 18:48:46 2019 -0700

    PM / wakeup: Show wakeup sources stats in sysfs
    
    Add an ID and a device pointer to 'struct wakeup_source'. Use them to to
    expose wakeup sources statistics in sysfs under
    /sys/class/wakeup/wakeup<ID>/*.
    
    Co-developed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Co-developed-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Tri Vo <trong@android.com>
    Tested-by: Kalesh Singh <kaleshsingh@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index f616b16c1f0b..3f8958007a93 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -497,7 +497,8 @@ acpi_status acpi_add_pm_notifier(struct acpi_device *adev, struct device *dev,
 		goto out;
 
 	mutex_lock(&acpi_pm_notifier_lock);
-	adev->wakeup.ws = wakeup_source_register(dev_name(&adev->dev));
+	adev->wakeup.ws = wakeup_source_register(&adev->dev,
+						 dev_name(&adev->dev));
 	adev->wakeup.context.dev = dev;
 	adev->wakeup.context.func = func;
 	adev->wakeup.flags.notifier_present = true;

commit ee8193ee96c7802b5ba766243c4c950059a43323
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Aug 2 12:26:02 2019 +0200

    ACPI: PM: Print debug messages on device power state changes
    
    Add an acpi_handle_debug() statement to acpi_device_set_power() to
    allow ACPI device power state changes to be tracked.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index f616b16c1f0b..4cb93d4f2ab6 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -166,6 +166,10 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 	    || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3_COLD))
 		return -EINVAL;
 
+	acpi_handle_debug(device->handle, "Power state change: %s -> %s\n",
+			  acpi_power_state_string(device->power.state),
+			  acpi_power_state_string(state));
+
 	/* Make sure this is a valid target state */
 
 	/* There is a special case for D0 addressed below. */

commit 42787ed79638dc7f0f8d5c164caba1e87bfab50f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 1 01:31:08 2019 +0200

    ACPI: PM: Fix regression in acpi_device_set_power()
    
    Commit f850a48a0799 ("ACPI: PM: Allow transitions to D0 to occur in
    special cases") overlooked the fact that acpi_power_transition() may
    change the power.state value for the target device and if that
    happens, it may confuse acpi_device_set_power() and cause it to
    omit the _PS0 evaluation which on some systems is necessary to
    change power states of devices from low-power to D0.
    
    Fix that by saving the current value of power.state for the
    target device before passing it to acpi_power_transition() and
    using the saved value in a subsequent check.
    
    Fixes: f850a48a0799 ("ACPI: PM: Allow transitions to D0 to occur in special cases")
    Reported-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Reported-by: Mario Limonciello <mario.limonciello@dell.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Tested-by: Mario Limonciello <mario.limonciello@dell.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 28cffaaf9d82..f616b16c1f0b 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -232,13 +232,15 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 		if (device->power.flags.power_resources)
 			result = acpi_power_transition(device, target_state);
 	} else {
+		int cur_state = device->power.state;
+
 		if (device->power.flags.power_resources) {
 			result = acpi_power_transition(device, ACPI_STATE_D0);
 			if (result)
 				goto end;
 		}
 
-		if (device->power.state == ACPI_STATE_D0) {
+		if (cur_state == ACPI_STATE_D0) {
 			int psc;
 
 			/* Nothing to do here if _PSC is not present. */

commit 3dbeb448543efc01f04cadd6d358b9f33dd20d31
Merge: 50e163d43ab1 02bd45a28bf3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 8 10:51:25 2019 +0200

    Merge branch 'pm-sleep'
    
    * pm-sleep:
      PM: sleep: Drop dev_pm_skip_next_resume_phases()
      ACPI: PM: Drop unused function and function header
      ACPI: PM: Introduce "poweroff" callbacks for ACPI PM domain and LPSS
      ACPI: PM: Simplify and fix PM domain hibernation callbacks
      PCI: PM: Simplify bus-level hibernation callbacks
      PM: ACPI/PCI: Resume all devices during hibernation
      kernel: power: swap: use kzalloc() instead of kmalloc() followed by memset()
      PM: sleep: Update struct wakeup_source documentation
      drivers: base: power: remove wakeup_sources_stats_dentry variable
      PM: suspend: Rename pm_suspend_via_s2idle()
      PM: sleep: Show how long dpm_suspend_start() and dpm_suspend_end() take
      PM: hibernate: powerpc: Expose pfn_is_nosave() prototype

commit 50e163d43ab123193a7f381528a7485881f730e9
Merge: 5004efbb3611 ad5a449b707b 9ed411c06dd1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 8 10:49:36 2019 +0200

    Merge branches 'acpi-pm' and 'pm-pci'
    
    * acpi-pm:
      ACPI: PM: Make acpi_sleep_state_supported() non-static
      ACPI: PM: Allow transitions to D0 to occur in special cases
      ACPI: PM: Avoid evaluating _PS3 on transitions from D3hot to D3cold
      ACPI / sleep: Switch to use acpi_dev_get_first_match_dev()
      ACPI / LPIT: Correct LPIT end address for lpit_process()
    
    * pm-pci:
      ACPI: PM: Unexport acpi_device_get_power()
      PCI: PM/ACPI: Refresh all stale power state data in pci_pm_complete()
      PCI / ACPI: Add _PR0 dependent devices
      ACPI / PM: Introduce concept of a _PR0 dependent device
      PCI / ACPI: Use cached ACPI device state to get PCI device power state
      PCI: Do not poll for PME if the device is in D3cold
      PCI: Add missing link delays required by the PCIe spec
      PCI: PM: Replace pci_dev_keep_suspended() with two functions
      PCI: PM: Avoid resuming devices in D3hot during system suspend

commit 9ed411c06dd1cdf6171b992f68c37bc2d66054f9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jul 4 01:02:49 2019 +0200

    ACPI: PM: Unexport acpi_device_get_power()
    
    Using acpi_device_get_power() outside of ACPI device initialization
    and ACPI sysfs is problematic due to the way in which power resources
    are handled by it, so unexport it and add a paragraph explaining the
    pitfalls to its kerneldoc comment.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index e54956ae93d3..81eb15a0cc42 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -53,6 +53,11 @@ const char *acpi_power_state_string(int state)
  * This function does not update the device's power.state field, but it may
  * update its parent's power.state field (when the parent's power state is
  * unknown and the device's power state turns out to be D0).
+ *
+ * Also, it does not update power resource reference counters to ensure that
+ * the power state returned by it will be persistent and it may return a power
+ * state shallower than previously set by acpi_device_set_power() for @device
+ * (if that power state depends on any power resources).
  */
 int acpi_device_get_power(struct acpi_device *device, int *state)
 {
@@ -118,7 +123,6 @@ int acpi_device_get_power(struct acpi_device *device, int *state)
 
 	return 0;
 }
-EXPORT_SYMBOL(acpi_device_get_power);
 
 static int acpi_dev_pm_explicit_set(struct acpi_device *adev, int state)
 {

commit c95b7595f85c688d5c569ddbbd6ab6a4bdae2f36
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 1 12:54:29 2019 +0200

    ACPI: PM: Introduce "poweroff" callbacks for ACPI PM domain and LPSS
    
    In general, it is not correct to call pm_generic_suspend(),
    pm_generic_suspend_late() and pm_generic_suspend_noirq() during the
    hibernation's "poweroff" transition, because device drivers may
    provide special callbacks to be invoked then and the wrappers in
    question cause system suspend callbacks to be run.  Unfortunately,
    that happens in the ACPI PM domain and ACPI LPSS.
    
    To address this potential issue, introduce "poweroff" callbacks
    for the ACPI PM and LPSS that will use pm_generic_poweroff(),
    pm_generic_poweroff_late() and pm_generic_poweroff_noirq() as
    appropriate.
    
    Fixes: 05087360fd7a (ACPI / PM: Take SMART_SUSPEND driver flag into account)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 52fc9042a107..6a9d41c44b70 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1133,6 +1133,58 @@ int acpi_subsys_restore_early(struct device *dev)
 	return ret ? ret : pm_generic_restore_early(dev);
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_restore_early);
+
+/**
+ * acpi_subsys_poweroff - Run the device driver's poweroff callback.
+ * @dev: Device to handle.
+ *
+ * Follow PCI and resume devices from runtime suspend before running their
+ * system poweroff callbacks, unless the driver can cope with runtime-suspended
+ * devices during system suspend and there are no ACPI-specific reasons for
+ * resuming them.
+ */
+int acpi_subsys_poweroff(struct device *dev)
+{
+	if (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND) ||
+	    acpi_dev_needs_resume(dev, ACPI_COMPANION(dev)))
+		pm_runtime_resume(dev);
+
+	return pm_generic_poweroff(dev);
+}
+EXPORT_SYMBOL_GPL(acpi_subsys_poweroff);
+
+/**
+ * acpi_subsys_poweroff_late - Run the device driver's poweroff callback.
+ * @dev: Device to handle.
+ *
+ * Carry out the generic late poweroff procedure for @dev and use ACPI to put
+ * it into a low-power state during system transition into a sleep state.
+ */
+static int acpi_subsys_poweroff_late(struct device *dev)
+{
+	int ret;
+
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		return 0;
+
+	ret = pm_generic_poweroff_late(dev);
+	if (ret)
+		return ret;
+
+	return acpi_dev_suspend(dev, device_may_wakeup(dev));
+}
+
+/**
+ * acpi_subsys_poweroff_noirq - Run the driver's "noirq" poweroff callback.
+ * @dev: Device to suspend.
+ */
+static int acpi_subsys_poweroff_noirq(struct device *dev)
+{
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		return 0;
+
+	return pm_generic_poweroff_noirq(dev);
+}
 #endif /* CONFIG_PM_SLEEP */
 
 static struct dev_pm_domain acpi_general_pm_domain = {
@@ -1148,9 +1200,9 @@ static struct dev_pm_domain acpi_general_pm_domain = {
 		.resume_noirq = acpi_subsys_resume_noirq,
 		.resume_early = acpi_subsys_resume_early,
 		.freeze = acpi_subsys_freeze,
-		.poweroff = acpi_subsys_suspend,
-		.poweroff_late = acpi_subsys_suspend_late,
-		.poweroff_noirq = acpi_subsys_suspend_noirq,
+		.poweroff = acpi_subsys_poweroff,
+		.poweroff_late = acpi_subsys_poweroff_late,
+		.poweroff_noirq = acpi_subsys_poweroff_noirq,
 		.restore_early = acpi_subsys_restore_early,
 #endif
 	},

commit 3cd7957e85e67120bb9f6bfb75d81dcc19af282b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 1 12:54:10 2019 +0200

    ACPI: PM: Simplify and fix PM domain hibernation callbacks
    
    First, after a previous change causing all runtime-suspended devices
    in the ACPI PM domain (and ACPI LPSS devices) to be resumed before
    creating a snapshot image of memory during hibernation, it is not
    necessary to worry about the case in which them might be left in
    runtime-suspend any more, so get rid of the code related to that from
    ACPI PM domain and ACPI LPSS hibernation callbacks.
    
    Second, it is not correct to use pm_generic_resume_early() and
    acpi_subsys_resume_noirq() in hibernation "restore" callbacks (which
    currently happens in the ACPI PM domain and ACPI LPSS), so introduce
    proper _restore_late and _restore_noirq callbacks for the ACPI PM
    domain and ACPI LPSS.
    
    Fixes: 05087360fd7a (ACPI / PM: Take SMART_SUSPEND driver flag into account)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 44172eb18d6e..52fc9042a107 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1073,7 +1073,7 @@ EXPORT_SYMBOL_GPL(acpi_subsys_suspend_noirq);
  * acpi_subsys_resume_noirq - Run the device driver's "noirq" resume callback.
  * @dev: Device to handle.
  */
-int acpi_subsys_resume_noirq(struct device *dev)
+static int acpi_subsys_resume_noirq(struct device *dev)
 {
 	if (dev_pm_may_skip_resume(dev))
 		return 0;
@@ -1088,7 +1088,6 @@ int acpi_subsys_resume_noirq(struct device *dev)
 
 	return pm_generic_resume_noirq(dev);
 }
-EXPORT_SYMBOL_GPL(acpi_subsys_resume_noirq);
 
 /**
  * acpi_subsys_resume_early - Resume device using ACPI.
@@ -1098,12 +1097,11 @@ EXPORT_SYMBOL_GPL(acpi_subsys_resume_noirq);
  * generic early resume procedure for it during system transition into the
  * working state.
  */
-int acpi_subsys_resume_early(struct device *dev)
+static int acpi_subsys_resume_early(struct device *dev)
 {
 	int ret = acpi_dev_resume(dev);
 	return ret ? ret : pm_generic_resume_early(dev);
 }
-EXPORT_SYMBOL_GPL(acpi_subsys_resume_early);
 
 /**
  * acpi_subsys_freeze - Run the device driver's freeze callback.
@@ -1126,52 +1124,15 @@ int acpi_subsys_freeze(struct device *dev)
 EXPORT_SYMBOL_GPL(acpi_subsys_freeze);
 
 /**
- * acpi_subsys_freeze_late - Run the device driver's "late" freeze callback.
- * @dev: Device to handle.
- */
-int acpi_subsys_freeze_late(struct device *dev)
-{
-
-	if (dev_pm_smart_suspend_and_suspended(dev))
-		return 0;
-
-	return pm_generic_freeze_late(dev);
-}
-EXPORT_SYMBOL_GPL(acpi_subsys_freeze_late);
-
-/**
- * acpi_subsys_freeze_noirq - Run the device driver's "noirq" freeze callback.
- * @dev: Device to handle.
- */
-int acpi_subsys_freeze_noirq(struct device *dev)
-{
-
-	if (dev_pm_smart_suspend_and_suspended(dev))
-		return 0;
-
-	return pm_generic_freeze_noirq(dev);
-}
-EXPORT_SYMBOL_GPL(acpi_subsys_freeze_noirq);
-
-/**
- * acpi_subsys_thaw_noirq - Run the device driver's "noirq" thaw callback.
- * @dev: Device to handle.
+ * acpi_subsys_restore_early - Restore device using ACPI.
+ * @dev: Device to restore.
  */
-int acpi_subsys_thaw_noirq(struct device *dev)
+int acpi_subsys_restore_early(struct device *dev)
 {
-	/*
-	 * If the device is in runtime suspend, the "thaw" code may not work
-	 * correctly with it, so skip the driver callback and make the PM core
-	 * skip all of the subsequent "thaw" callbacks for the device.
-	 */
-	if (dev_pm_smart_suspend_and_suspended(dev)) {
-		dev_pm_skip_next_resume_phases(dev);
-		return 0;
-	}
-
-	return pm_generic_thaw_noirq(dev);
+	int ret = acpi_dev_resume(dev);
+	return ret ? ret : pm_generic_restore_early(dev);
 }
-EXPORT_SYMBOL_GPL(acpi_subsys_thaw_noirq);
+EXPORT_SYMBOL_GPL(acpi_subsys_restore_early);
 #endif /* CONFIG_PM_SLEEP */
 
 static struct dev_pm_domain acpi_general_pm_domain = {
@@ -1187,14 +1148,10 @@ static struct dev_pm_domain acpi_general_pm_domain = {
 		.resume_noirq = acpi_subsys_resume_noirq,
 		.resume_early = acpi_subsys_resume_early,
 		.freeze = acpi_subsys_freeze,
-		.freeze_late = acpi_subsys_freeze_late,
-		.freeze_noirq = acpi_subsys_freeze_noirq,
-		.thaw_noirq = acpi_subsys_thaw_noirq,
 		.poweroff = acpi_subsys_suspend,
 		.poweroff_late = acpi_subsys_suspend_late,
 		.poweroff_noirq = acpi_subsys_suspend_noirq,
-		.restore_noirq = acpi_subsys_resume_noirq,
-		.restore_early = acpi_subsys_resume_early,
+		.restore_early = acpi_subsys_restore_early,
 #endif
 	},
 };

commit 501debd4aa5edc755037c39ea5a8fba23b41e580
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 1 12:44:25 2019 +0200

    PM: ACPI/PCI: Resume all devices during hibernation
    
    Both the PCI bus type and the ACPI PM domain avoid resuming
    runtime-suspended devices with DPM_FLAG_SMART_SUSPEND set during
    hibernation (before creating the snapshot image of system memory),
    but that turns out to be a mistake.  It leads to functional issues
    and adds complexity that's hard to justify.
    
    For this reason, resume all runtime-suspended PCI devices and all
    devices in the ACPI PM domains before creating a snapshot image of
    system memory during hibernation.
    
    Fixes: 05087360fd7a (ACPI / PM: Take SMART_SUSPEND driver flag into account)
    Fixes: c4b65157aeef (PCI / PM: Take SMART_SUSPEND driver flag into account)
    Link: https://lore.kernel.org/linux-acpi/917d4399-2e22-67b1-9d54-808561f9083f@uwyo.edu/T/#maf065fe6e4974f2a9d79f332ab99dfaba635f64c
    Reported-by: Robert R. Howell <RHowell@uwyo.edu>
    Tested-by: Robert R. Howell <RHowell@uwyo.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index e54956ae93d3..44172eb18d6e 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1112,13 +1112,14 @@ EXPORT_SYMBOL_GPL(acpi_subsys_resume_early);
 int acpi_subsys_freeze(struct device *dev)
 {
 	/*
-	 * This used to be done in acpi_subsys_prepare() for all devices and
-	 * some drivers may depend on it, so do it here.  Ideally, however,
-	 * runtime-suspended devices should not be touched during freeze/thaw
-	 * transitions.
+	 * Resume all runtime-suspended devices before creating a snapshot
+	 * image of system memory, because the restore kernel generally cannot
+	 * be expected to always handle them consistently and they need to be
+	 * put into the runtime-active metastate during system resume anyway,
+	 * so it is better to ensure that the state saved in the image will be
+	 * always consistent with that.
 	 */
-	if (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND))
-		pm_runtime_resume(dev);
+	pm_runtime_resume(dev);
 
 	return pm_generic_freeze(dev);
 }

commit f850a48a07996bfd7bd1b2e52f57b5ee55125482
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jun 25 14:06:13 2019 +0200

    ACPI: PM: Allow transitions to D0 to occur in special cases
    
    If a device with ACPI PM is left in D0 during a system-wide
    transition to the S3 (suspend-to-RAM) or S4 (hibernation) sleep
    state, the actual state of the device need not be D0 during resume
    from it, although its power.state value will still reflect D0 (that
    is, the power state from before the system-wide transition).
    
    In that case, the acpi_device_set_power() call made to ensure that
    the power state of the device will be D0 going forward has no effect,
    because the new state (D0) is equal to the one reflected by the
    device's power.state value.  That does not affect power resources,
    which are taken care of by acpi_resume_power_resources() called from
    acpi_pm_finish() during resume from system-wide sleep states, but it
    still may be necessary to invoke _PS0 for the device on top of that
    in order to finalize its transition to D0.
    
    For this reason, modify acpi_device_set_power() to allow transitions
    to D0 to occur even if D0 is the current power state of the device
    according to its power.state value.
    
    That will not affect power resources, which are assumed to be in
    the right configuration already (as reflected by the current values
    of their reference counters), but it may cause _PS0 to be evaluated
    for the device.  However, evaluating _PS0 for a device already in D0
    may lead to confusion in general, so invoke _PSC (if present) to
    check the device's current power state upfront and only evaluate
    _PS0 for it if _PSC has returned a power state different from D0.
    [If _PSC is not present or the evaluation of it fails, the power
    state of the device is assumed to be D0 at this point.]
    
    Fixes: 20dacb71ad28 (ACPI / PM: Rework device power management to follow ACPI 6)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 3269a4e8b902..94194c7e8a07 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -53,6 +53,19 @@ const char *acpi_power_state_string(int state)
 	}
 }
 
+static int acpi_dev_pm_explicit_get(struct acpi_device *device, int *state)
+{
+	unsigned long long psc;
+	acpi_status status;
+
+	status = acpi_evaluate_integer(device->handle, "_PSC", NULL, &psc);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	*state = psc;
+	return 0;
+}
+
 /**
  * acpi_device_get_power - Get power state of an ACPI device.
  * @device: Device to get the power state of.
@@ -65,6 +78,7 @@ const char *acpi_power_state_string(int state)
 int acpi_device_get_power(struct acpi_device *device, int *state)
 {
 	int result = ACPI_STATE_UNKNOWN;
+	int error;
 
 	if (!device || !state)
 		return -EINVAL;
@@ -81,18 +95,16 @@ int acpi_device_get_power(struct acpi_device *device, int *state)
 	 * if available.
 	 */
 	if (device->power.flags.power_resources) {
-		int error = acpi_power_get_inferred_state(device, &result);
+		error = acpi_power_get_inferred_state(device, &result);
 		if (error)
 			return error;
 	}
 	if (device->power.flags.explicit_get) {
-		acpi_handle handle = device->handle;
-		unsigned long long psc;
-		acpi_status status;
+		int psc;
 
-		status = acpi_evaluate_integer(handle, "_PSC", NULL, &psc);
-		if (ACPI_FAILURE(status))
-			return -ENODEV;
+		error = acpi_dev_pm_explicit_get(device, &psc);
+		if (error)
+			return error;
 
 		/*
 		 * The power resources settings may indicate a power state
@@ -160,7 +172,8 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 
 	/* Make sure this is a valid target state */
 
-	if (state == device->power.state) {
+	/* There is a special case for D0 addressed below. */
+	if (state > ACPI_STATE_D0 && state == device->power.state) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] already in %s\n",
 				  device->pnp.bus_id,
 				  acpi_power_state_string(state)));
@@ -228,6 +241,30 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 			if (result)
 				goto end;
 		}
+
+		if (device->power.state == ACPI_STATE_D0) {
+			int psc;
+
+			/* Nothing to do here if _PSC is not present. */
+			if (!device->power.flags.explicit_get)
+				return 0;
+
+			/*
+			 * The power state of the device was set to D0 last
+			 * time, but that might have happened before a
+			 * system-wide transition involving the platform
+			 * firmware, so it may be necessary to evaluate _PS0
+			 * for the device here.  However, use extra care here
+			 * and evaluate _PSC to check the device's current power
+			 * state, and only invoke _PS0 if the evaluation of _PSC
+			 * is successful and it returns a power state different
+			 * from D0.
+			 */
+			result = acpi_dev_pm_explicit_get(device, &psc);
+			if (result || psc == ACPI_STATE_D0)
+				return 0;
+		}
+
 		result = acpi_dev_pm_explicit_set(device, ACPI_STATE_D0);
 	}
 

commit 21ba237926227121dacccaf5d7863b0cb50f3eda
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jun 25 14:04:45 2019 +0200

    ACPI: PM: Avoid evaluating _PS3 on transitions from D3hot to D3cold
    
    If the power state of a device with ACPI PM is changed from D3hot to
    D3cold, it merely is a matter of dropping references to additional
    power resources (specifically, those in the list returned by _PR3),
    and the _PS3 method should not be invoked for the device then (as
    it has already been evaluated during the previous transition to
    D3hot).
    
    Fixes: 20dacb71ad28 (ACPI / PM: Rework device power management to follow ACPI 6)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index b859d75eaf9f..3269a4e8b902 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -210,9 +210,15 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 			return -ENODEV;
 		}
 
-		result = acpi_dev_pm_explicit_set(device, state);
-		if (result)
-			goto end;
+		/*
+		 * If the device goes from D3hot to D3cold, _PS3 has been
+		 * evaluated for it already, so skip it in that case.
+		 */
+		if (device->power.state < ACPI_STATE_D3_HOT) {
+			result = acpi_dev_pm_explicit_set(device, state);
+			if (result)
+				goto end;
+		}
 
 		if (device->power.flags.power_resources)
 			result = acpi_power_transition(device, target_state);

commit 702c31e8564c386dd5e304e46cf22fcaa40b1a66
Merge: 72cea7ac5f14 d491f2b75237
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 31 10:38:35 2019 -0700

    Merge tag 'pm-5.2-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management fixes from Rafael Wysocki:
     "These fix three issues in the system-wide suspend and hibernation area
      related to PCI device PM handling by suspend-to-idle, device wakeup
      optimizations and arbitrary differences between suspend and
      hiberantion.
    
      Specifics:
    
       - Modify the PCI bus type's PM code to avoid putting devices left by
         their drivers in D0 on purpose during suspend to idle into
         low-power states as doing that may confuse the system resume
         callbacks of the drivers in question (Rafael Wysocki).
    
       - Avoid checking ACPI wakeup configuration during system-wide suspend
         for suspended devices that do not use ACPI-based wakeup to allow
         them to stay in suspend more often (Rafael Wysocki).
    
       - The last phase of hibernation is analogous to system-wide suspend
         also because on platforms with ACPI it passes control to the
         platform firmware to complete the transision, so make it indicate
         that by calling pm_set_suspend_via_firmware() to allow the drivers
         that care about this to do the right thing (Rafael Wysocki)"
    
    * tag 'pm-5.2-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      PCI: PM: Avoid possible suspend-to-idle issue
      ACPI: PM: Call pm_set_suspend_via_firmware() during hibernation
      ACPI/PCI: PM: Add missing wakeup.flags.valid checks

commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index b859d75eaf9f..adc8979b02b6 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * drivers/acpi/device_pm.c - ACPI device power management routines.
  *
@@ -6,15 +7,6 @@
  *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as published
- *  by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 

commit 9a51c6b1f9e0239a9435db036b212498a2a3b75c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 16 12:42:20 2019 +0200

    ACPI/PCI: PM: Add missing wakeup.flags.valid checks
    
    Both acpi_pci_need_resume() and acpi_dev_needs_resume() check if the
    current ACPI wakeup configuration of the device matches what is
    expected as far as system wakeup from sleep states is concerned, as
    reflected by the device_may_wakeup() return value for the device.
    
    However, they only should do that if wakeup.flags.valid is set for
    the device's ACPI companion, because otherwise the wakeup.prepare_count
    value for it is meaningless.
    
    Add the missing wakeup.flags.valid checks to these functions.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index b859d75eaf9f..1f9058b86908 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -952,8 +952,8 @@ static bool acpi_dev_needs_resume(struct device *dev, struct acpi_device *adev)
 	u32 sys_target = acpi_target_system_state();
 	int ret, state;
 
-	if (!pm_runtime_suspended(dev) || !adev ||
-	    device_may_wakeup(dev) != !!adev->wakeup.prepare_count)
+	if (!pm_runtime_suspended(dev) || !adev || (adev->wakeup.flags.valid &&
+	    device_may_wakeup(dev) != !!adev->wakeup.prepare_count))
 		return true;
 
 	if (sys_target == ACPI_STATE_S0)

commit 0968621917add2e0d60c8fbc4e24c670cb14319c
Merge: 573de2a6e844 0f46c78391e1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 09:18:12 2019 -0700

    Merge tag 'printk-for-5.2' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk updates from Petr Mladek:
    
     - Allow state reset of printk_once() calls.
    
     - Prevent crashes when dereferencing invalid pointers in vsprintf().
       Only the first byte is checked for simplicity.
    
     - Make vsprintf warnings consistent and inlined.
    
     - Treewide conversion of obsolete %pf, %pF to %ps, %pF printf
       modifiers.
    
     - Some clean up of vsprintf and test_printf code.
    
    * tag 'printk-for-5.2' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk:
      lib/vsprintf: Make function pointer_string static
      vsprintf: Limit the length of inlined error messages
      vsprintf: Avoid confusion between invalid address and value
      vsprintf: Prevent crash when dereferencing invalid pointers
      vsprintf: Consolidate handling of unknown pointer specifiers
      vsprintf: Factor out %pO handler as kobject_string()
      vsprintf: Factor out %pV handler as va_format()
      vsprintf: Factor out %p[iI] handler as ip_addr_string()
      vsprintf: Do not check address of well-known strings
      vsprintf: Consistent %pK handling for kptr_restrict == 0
      vsprintf: Shuffle restricted_pointer()
      printk: Tie printk_once / printk_deferred_once into .data.once for reset
      treewide: Switch printk users from %pf and %pF to %ps and %pS, respectively
      lib/test_printf: Switch to bitmap_zalloc()

commit d75f773c86a2b8b7278e2c33343b46a4024bc002
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Mon Mar 25 21:32:28 2019 +0200

    treewide: Switch printk users from %pf and %pF to %ps and %pS, respectively
    
    %pF and %pf are functionally equivalent to %pS and %ps conversion
    specifiers. The former are deprecated, therefore switch the current users
    to use the preferred variant.
    
    The changes have been produced by the following command:
    
            git grep -l '%p[fF]' | grep -v '^\(tools\|Documentation\)/' | \
            while read i; do perl -i -pe 's/%pf/%ps/g; s/%pF/%pS/g;' $i; done
    
    And verifying the result.
    
    Link: http://lkml.kernel.org/r/20190325193229.23390-1-sakari.ailus@linux.intel.com
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: sparclinux@vger.kernel.org
    Cc: linux-um@lists.infradead.org
    Cc: xen-devel@lists.xenproject.org
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-pm@vger.kernel.org
    Cc: drbd-dev@lists.linbit.com
    Cc: linux-block@vger.kernel.org
    Cc: linux-mmc@vger.kernel.org
    Cc: linux-nvdimm@lists.01.org
    Cc: linux-pci@vger.kernel.org
    Cc: linux-scsi@vger.kernel.org
    Cc: linux-btrfs@vger.kernel.org
    Cc: linux-f2fs-devel@lists.sourceforge.net
    Cc: linux-mm@kvack.org
    Cc: ceph-devel@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: David Sterba <dsterba@suse.com> (for btrfs)
    Acked-by: Mike Rapoport <rppt@linux.ibm.com> (for mm/memblock.c)
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (for drivers/pci)
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 824ae985ad93..1aa0d014dc34 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -414,7 +414,7 @@ static void acpi_pm_notify_handler(acpi_handle handle, u32 val, void *not_used)
 	if (adev->wakeup.flags.notifier_present) {
 		pm_wakeup_ws_event(adev->wakeup.ws, 0, acpi_s2idle_wakeup());
 		if (adev->wakeup.context.func) {
-			acpi_handle_debug(handle, "Running %pF for %s\n",
+			acpi_handle_debug(handle, "Running %pS for %s\n",
 					  adev->wakeup.context.func,
 					  dev_name(adev->wakeup.context.dev));
 			adev->wakeup.context.func(&adev->wakeup.context);

commit fbc9418f099d457b91bf14aef8c4bfc498bb2437
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Apr 3 23:58:01 2019 +0200

    ACPI: PM: Print debug messages when enabling GPEs for wakeup
    
    In sufficiently complicated GPE configurations it is hard to
    determine which GPE could be the source of system wakeup from a sleep
    state, so make __acpi_device_wakeup_enable() print that information
    to the kernel log if debugging is enabled.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 824ae985ad93..5b50f884712c 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -728,6 +728,9 @@ static int __acpi_device_wakeup_enable(struct acpi_device *adev,
 		goto out;
 	}
 
+	acpi_handle_debug(adev->handle, "GPE%2X enabled for wakeup\n",
+			  (unsigned int)wakeup->gpe_number);
+
 inc:
 	wakeup->enable_count++;
 

commit fe650c8ba7c9dde2816d09e335b0be37757e49df
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Oct 12 12:12:24 2018 +0200

    ACPI / PM: Export acpi_device_get_power() for use by modular build drivers
    
    Export acpi_device_get_power() for use by modular build drivers.
    
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index a7c2673ffd36..824ae985ad93 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -126,6 +126,7 @@ int acpi_device_get_power(struct acpi_device *device, int *state)
 
 	return 0;
 }
+EXPORT_SYMBOL(acpi_device_get_power);
 
 static int acpi_dev_pm_explicit_set(struct acpi_device *adev, int state)
 {

commit 919b7308fcc452cd4e282bab389c33384a9f3790
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed May 9 12:17:52 2018 +0200

    PM / Domains: Allow a better error handling of dev_pm_domain_attach()
    
    The callers of dev_pm_domain_attach() currently checks the returned error
    code for -EPROBE_DEFER and needs to ignore other error codes. This is an
    unnecessary limitation, which also leads to a rather strange behaviour in
    the error path.
    
    Address this limitation, by changing the return codes from
    acpi_dev_pm_attach() and genpd_dev_pm_attach(). More precisely, let them
    return 0, when no PM domain is needed for the device and then return 1, in
    case the device was successfully attached to its PM domain. In this way,
    dev_pm_domain_attach(), gets a better understanding of what happens in the
    attach attempts and also allowing its caller to better act on real errors
    codes.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index d00630016176..a7c2673ffd36 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1257,7 +1257,7 @@ int acpi_dev_pm_attach(struct device *dev, bool power_on)
 	struct acpi_device *adev = ACPI_COMPANION(dev);
 
 	if (!adev)
-		return -ENODEV;
+		return 0;
 
 	/*
 	 * Only attach the power domain to the first device if the
@@ -1265,7 +1265,7 @@ int acpi_dev_pm_attach(struct device *dev, bool power_on)
 	 * management twice.
 	 */
 	if (!acpi_device_is_first_physical_node(adev, dev))
-		return -EBUSY;
+		return 0;
 
 	acpi_add_pm_notifier(adev, dev, acpi_pm_notify_work_func);
 	dev_pm_domain_set(dev, &acpi_general_pm_domain);
@@ -1275,7 +1275,7 @@ int acpi_dev_pm_attach(struct device *dev, bool power_on)
 	}
 
 	dev->pm_domain->detach = acpi_dev_pm_detach;
-	return 0;
+	return 1;
 }
 EXPORT_SYMBOL_GPL(acpi_dev_pm_attach);
 #endif /* CONFIG_PM */

commit 4f688748c958deb947759773be6dffe6b44d084d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 26 10:53:03 2018 +0200

    PM / Domains: Check for existing PM domain in dev_pm_domain_attach()
    
    Instead of checking if an existing PM domain pointer has been assigned in
    genpd_dev_pm_attach() and acpi_dev_pm_attach(), move the check to the
    common path in dev_pm_domain_attach(), thus potentially avoid one
    unnecessary check.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 3d96e4da2d98..d00630016176 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1259,9 +1259,6 @@ int acpi_dev_pm_attach(struct device *dev, bool power_on)
 	if (!adev)
 		return -ENODEV;
 
-	if (dev->pm_domain)
-		return -EEXIST;
-
 	/*
 	 * Only attach the power domain to the first device if the
 	 * companion is shared by multiple. This is to prevent doing power

commit bf8c6184e0c3d4d5e005e085e9f96f478a267b20
Author: Daniel Drake <drake@endlessm.com>
Date:   Tue Mar 20 12:07:35 2018 +0800

    ACPI / PM: Allow deeper wakeup power states with no _SxD nor _SxW
    
    acpi_dev_pm_get_state() is used to determine the range of allowable
    device power states when going into S3 suspend. This is implemented
    by executing the _S3D and _S3W ACPI methods.
    
    Linux follows the ACPI spec behaviour in that when _S3D is implemented
    and _S3W is not, Linux will not go into a power state deeper than the one
    returned by _S3D for a wakeup-enabled device.
    
    However, this same logic is being applied to the case when neither
    _S3D nor _S3W are present, and the result is that this function
    decides that the device must stay in D0 (fully on) state.
    
    This is breaking USB wakeups on Asus V222GA and Acer XC-830. _S3D and
    _S3W are not present, so the USB controller is left in the D0 running
    state during S3, and hence it is unable to generate a PME# wake event.
    
    The ACPI spec is unclear on which power states are permissable for
    wakeup-enabled devices when both _S3D and _S3W are missing.
    However, USB wakeups work fine on these platforms under Windows, where
    device manager shows that they are using D3 device state for the USB
    controller in S3.
    
    I assume that the "max = min" clamping done by the code here is
    specifically written for the _S3D but no _S3W case. By making the
    code true to those conditions, avoiding them on these platforms,
    the controller will be put into D3 state and USB wakeups start working.
    
    Additionally I feel that this change makes the code more directly
    mirror the wording of the ACPI spec and it's associated lack of clarity.
    
    Thanks to Mathias Nyman for pointing us in the right direction.
    
    Signed-off-by: Daniel Drake <drake@endlessm.com>
    Link: http://lkml.kernel.org/r/CAB4CAwf_k-WsF3zL4epm9TKAOu0h=Bv1XhXV_gY3bziOo_NPKA@mail.gmail.com
    
    https://phabricator.endlessm.com/T21410
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index c4d0a1c912f0..3d96e4da2d98 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -543,6 +543,7 @@ static int acpi_dev_pm_get_state(struct device *dev, struct acpi_device *adev,
 	unsigned long long ret;
 	int d_min, d_max;
 	bool wakeup = false;
+	bool has_sxd = false;
 	acpi_status status;
 
 	/*
@@ -581,6 +582,10 @@ static int acpi_dev_pm_get_state(struct device *dev, struct acpi_device *adev,
 			else
 				return -ENODATA;
 		}
+
+		if (status == AE_OK)
+			has_sxd = true;
+
 		d_min = ret;
 		wakeup = device_may_wakeup(dev) && adev->wakeup.flags.valid
 			&& adev->wakeup.sleep_state >= target_state;
@@ -599,7 +604,11 @@ static int acpi_dev_pm_get_state(struct device *dev, struct acpi_device *adev,
 		method[3] = 'W';
 		status = acpi_evaluate_integer(handle, method, NULL, &ret);
 		if (status == AE_NOT_FOUND) {
-			if (target_state > ACPI_STATE_S0)
+			/* No _SxW. In this case, the ACPI spec says that we
+			 * must not go into any power state deeper than the
+			 * value returned from _SxD.
+			 */
+			if (has_sxd && target_state > ACPI_STATE_S0)
 				d_max = d_min;
 		} else if (ACPI_SUCCESS(status) && ret <= ACPI_STATE_D3_COLD) {
 			/* Fall back to D3cold if ret is not a valid state. */

commit c51a024e3913e9dbaf4dfcb9aaba825668a89ace
Merge: 3487972d7fa6 34fb8f0ba9ce
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Dec 16 02:05:48 2017 +0100

    Merge back PM core material for v4.16.

commit 3487972d7fa6c5143951436ada5933dcf0ec659d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Dec 7 02:41:18 2017 +0100

    PM / sleep: Avoid excess pm_runtime_enable() calls in device_resume()
    
    Middle-layer code doing suspend-time optimizations for devices with
    the DPM_FLAG_SMART_SUSPEND flag set (currently, the PCI bus type and
    the ACPI PM domain) needs to make the core skip ->thaw_early and
    ->thaw callbacks for those devices in some cases and it sets the
    power.direct_complete flag for them for this purpose.
    
    However, it turns out that setting power.direct_complete outside of
    the PM core is a bad idea as it triggers an excess invocation of
    pm_runtime_enable() in device_resume().
    
    For this reason, provide a helper to clear power.is_late_suspended
    and power.is_suspended to be invoked by the middle-layer code in
    question instead of setting power.direct_complete and make that code
    call the new helper.
    
    Fixes: c4b65157aeef (PCI / PM: Take SMART_SUSPEND driver flag into account)
    Fixes: 05087360fd7a (ACPI / PM: Take SMART_SUSPEND driver flag into account)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index e4ffaeec9ec2..a4c8ad98560d 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1138,7 +1138,7 @@ int acpi_subsys_thaw_noirq(struct device *dev)
 	 * skip all of the subsequent "thaw" callbacks for the device.
 	 */
 	if (dev_pm_smart_suspend_and_suspended(dev)) {
-		dev->power.direct_complete = true;
+		dev_pm_skip_next_resume_phases(dev);
 		return 0;
 	}
 

commit db68daff90ef79761cc0bba16f775b6027ea3a83
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Nov 18 15:35:00 2017 +0100

    ACPI / PM: Support for LEAVE_SUSPENDED driver flag in ACPI PM domain
    
    Add support for DPM_FLAG_LEAVE_SUSPENDED to the ACPI PM domain by
    making it (a) set the power.may_skip_resume status bit for devices
    that, from its perspective, may be left in suspend after system
    wakeup from sleep and (b) return early from acpi_subsys_resume_noirq()
    for devices whose remaining resume callbacks during the transition
    under way are going to be skipped by the PM core.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index e4ffaeec9ec2..5cfe794c36bd 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -990,7 +990,7 @@ void acpi_subsys_complete(struct device *dev)
 	 * the sleep state it is going out of and it has never been resumed till
 	 * now, resume it in case the firmware powered it up.
 	 */
-	if (dev->power.direct_complete && pm_resume_via_firmware())
+	if (pm_runtime_suspended(dev) && pm_resume_via_firmware())
 		pm_request_resume(dev);
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_complete);
@@ -1039,10 +1039,28 @@ EXPORT_SYMBOL_GPL(acpi_subsys_suspend_late);
  */
 int acpi_subsys_suspend_noirq(struct device *dev)
 {
-	if (dev_pm_smart_suspend_and_suspended(dev))
+	int ret;
+
+	if (dev_pm_smart_suspend_and_suspended(dev)) {
+		dev->power.may_skip_resume = true;
 		return 0;
+	}
+
+	ret = pm_generic_suspend_noirq(dev);
+	if (ret)
+		return ret;
+
+	/*
+	 * If the target system sleep state is suspend-to-idle, it is sufficient
+	 * to check whether or not the device's wakeup settings are good for
+	 * runtime PM.  Otherwise, the pm_resume_via_firmware() check will cause
+	 * acpi_subsys_complete() to take care of fixing up the device's state
+	 * anyway, if need be.
+	 */
+	dev->power.may_skip_resume = device_may_wakeup(dev) ||
+					!device_can_wakeup(dev);
 
-	return pm_generic_suspend_noirq(dev);
+	return 0;
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_suspend_noirq);
 
@@ -1052,6 +1070,9 @@ EXPORT_SYMBOL_GPL(acpi_subsys_suspend_noirq);
  */
 int acpi_subsys_resume_noirq(struct device *dev)
 {
+	if (dev_pm_may_skip_resume(dev))
+		return 0;
+
 	/*
 	 * Devices with DPM_FLAG_SMART_SUSPEND may be left in runtime suspend
 	 * during system suspend, so update their runtime PM status to "active"

commit 1efef68262dc567f0c09da9d11924e8287cd3a8b
Merge: 05d658b5b572 05087360fd7a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 13 01:41:26 2017 +0100

    Merge branch 'pm-core'
    
    * pm-core:
      ACPI / PM: Take SMART_SUSPEND driver flag into account
      PCI / PM: Take SMART_SUSPEND driver flag into account
      PCI / PM: Drop unnecessary invocations of pcibios_pm_ops callbacks
      PM / core: Add SMART_SUSPEND driver flag
      PCI / PM: Use the NEVER_SKIP driver flag
      PM / core: Add NEVER_SKIP and SMART_PREPARE driver flags
      PM / core: Convert timers to use timer_setup()
      PM / core: Fix kerneldoc comments of four functions
      PM / core: Drop legacy class suspend/resume operations

commit ff1656790b3a4caca94505c52fd0250f981ea187
Author: Ville Syrjl <ville.syrjala@linux.intel.com>
Date:   Tue Nov 7 23:08:10 2017 +0200

    ACPI / PM: Fix acpi_pm_notifier_lock vs flush_workqueue() deadlock
    
    acpi_remove_pm_notifier() ends up calling flush_workqueue() while
    holding acpi_pm_notifier_lock, and that same lock is taken by
    by the work via acpi_pm_notify_handler(). This can deadlock.
    
    To fix the problem let's split the single lock into two: one to
    protect the dev->wakeup between the work vs. add/remove, and
    another one to handle notifier installation vs. removal.
    
    After commit a1d14934ea4b "workqueue/lockdep: 'Fix' flush_work()
    annotation" I was able to kill the machine (Intel Braswell)
    very easily with 'powertop --auto-tune', runtime suspending i915,
    and trying to wake it up via the USB keyboard. The cases when
    it didn't die are presumably explained by lockdep getting disabled
    by something else (cpu hotplug locking issues usually).
    
    Fortunately I still got a lockdep report over netconsole
    (trickling in very slowly), even though the machine was
    otherwise practically dead:
    
    [  112.179806] ======================================================
    [  114.670858] WARNING: possible circular locking dependency detected
    [  117.155663] 4.13.0-rc6-bsw-bisect-00169-ga1d14934ea4b #119 Not tainted
    [  119.658101] ------------------------------------------------------
    [  121.310242] xhci_hcd 0000:00:14.0: xHCI host not responding to stop endpoint command.
    [  121.313294] xhci_hcd 0000:00:14.0: xHCI host controller not responding, assume dead
    [  121.313346] xhci_hcd 0000:00:14.0: HC died; cleaning up
    [  121.313485] usb 1-6: USB disconnect, device number 3
    [  121.313501] usb 1-6.2: USB disconnect, device number 4
    [  134.747383] kworker/0:2/47 is trying to acquire lock:
    [  137.220790]  (acpi_pm_notifier_lock){+.+.}, at: [<ffffffff813cafdf>] acpi_pm_notify_handler+0x2f/0x80
    [  139.721524]
    [  139.721524] but task is already holding lock:
    [  144.672922]  ((&dpc->work)){+.+.}, at: [<ffffffff8109ce90>] process_one_work+0x160/0x720
    [  147.184450]
    [  147.184450] which lock already depends on the new lock.
    [  147.184450]
    [  154.604711]
    [  154.604711] the existing dependency chain (in reverse order) is:
    [  159.447888]
    [  159.447888] -> #2 ((&dpc->work)){+.+.}:
    [  164.183486]        __lock_acquire+0x1255/0x13f0
    [  166.504313]        lock_acquire+0xb5/0x210
    [  168.778973]        process_one_work+0x1b9/0x720
    [  171.030316]        worker_thread+0x4c/0x440
    [  173.257184]        kthread+0x154/0x190
    [  175.456143]        ret_from_fork+0x27/0x40
    [  177.624348]
    [  177.624348] -> #1 ("kacpi_notify"){+.+.}:
    [  181.850351]        __lock_acquire+0x1255/0x13f0
    [  183.941695]        lock_acquire+0xb5/0x210
    [  186.046115]        flush_workqueue+0xdd/0x510
    [  190.408153]        acpi_os_wait_events_complete+0x31/0x40
    [  192.625303]        acpi_remove_notify_handler+0x133/0x188
    [  194.820829]        acpi_remove_pm_notifier+0x56/0x90
    [  196.989068]        acpi_dev_pm_detach+0x5f/0xa0
    [  199.145866]        dev_pm_domain_detach+0x27/0x30
    [  201.285614]        i2c_device_probe+0x100/0x210
    [  203.411118]        driver_probe_device+0x23e/0x310
    [  205.522425]        __driver_attach+0xa3/0xb0
    [  207.634268]        bus_for_each_dev+0x69/0xa0
    [  209.714797]        driver_attach+0x1e/0x20
    [  211.778258]        bus_add_driver+0x1bc/0x230
    [  213.837162]        driver_register+0x60/0xe0
    [  215.868162]        i2c_register_driver+0x42/0x70
    [  217.869551]        0xffffffffa0172017
    [  219.863009]        do_one_initcall+0x45/0x170
    [  221.843863]        do_init_module+0x5f/0x204
    [  223.817915]        load_module+0x225b/0x29b0
    [  225.757234]        SyS_finit_module+0xc6/0xd0
    [  227.661851]        do_syscall_64+0x5c/0x120
    [  229.536819]        return_from_SYSCALL_64+0x0/0x7a
    [  231.392444]
    [  231.392444] -> #0 (acpi_pm_notifier_lock){+.+.}:
    [  235.124914]        check_prev_add+0x44e/0x8a0
    [  237.024795]        __lock_acquire+0x1255/0x13f0
    [  238.937351]        lock_acquire+0xb5/0x210
    [  240.840799]        __mutex_lock+0x75/0x940
    [  242.709517]        mutex_lock_nested+0x1c/0x20
    [  244.551478]        acpi_pm_notify_handler+0x2f/0x80
    [  246.382052]        acpi_ev_notify_dispatch+0x44/0x5c
    [  248.194412]        acpi_os_execute_deferred+0x14/0x30
    [  250.003925]        process_one_work+0x1ec/0x720
    [  251.803191]        worker_thread+0x4c/0x440
    [  253.605307]        kthread+0x154/0x190
    [  255.387498]        ret_from_fork+0x27/0x40
    [  257.153175]
    [  257.153175] other info that might help us debug this:
    [  257.153175]
    [  262.324392] Chain exists of:
    [  262.324392]   acpi_pm_notifier_lock --> "kacpi_notify" --> (&dpc->work)
    [  262.324392]
    [  267.391997]  Possible unsafe locking scenario:
    [  267.391997]
    [  270.758262]        CPU0                    CPU1
    [  272.431713]        ----                    ----
    [  274.060756]   lock((&dpc->work));
    [  275.646532]                                lock("kacpi_notify");
    [  277.260772]                                lock((&dpc->work));
    [  278.839146]   lock(acpi_pm_notifier_lock);
    [  280.391902]
    [  280.391902]  *** DEADLOCK ***
    [  280.391902]
    [  284.986385] 2 locks held by kworker/0:2/47:
    [  286.524895]  #0:  ("kacpi_notify"){+.+.}, at: [<ffffffff8109ce90>] process_one_work+0x160/0x720
    [  288.112927]  #1:  ((&dpc->work)){+.+.}, at: [<ffffffff8109ce90>] process_one_work+0x160/0x720
    [  289.727725]
    
    Fixes: c072530f391e (ACPI / PM: Revork the handling of ACPI device wakeup notifications)
    Signed-off-by: Ville Syrjl <ville.syrjala@linux.intel.com>
    Cc: 3.17+ <stable@vger.kernel.org> # 3.17+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 17e8eb93a76c..69ffd1dc1de7 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -387,6 +387,7 @@ EXPORT_SYMBOL(acpi_bus_power_manageable);
 
 #ifdef CONFIG_PM
 static DEFINE_MUTEX(acpi_pm_notifier_lock);
+static DEFINE_MUTEX(acpi_pm_notifier_install_lock);
 
 void acpi_pm_wakeup_event(struct device *dev)
 {
@@ -443,24 +444,25 @@ acpi_status acpi_add_pm_notifier(struct acpi_device *adev, struct device *dev,
 	if (!dev && !func)
 		return AE_BAD_PARAMETER;
 
-	mutex_lock(&acpi_pm_notifier_lock);
+	mutex_lock(&acpi_pm_notifier_install_lock);
 
 	if (adev->wakeup.flags.notifier_present)
 		goto out;
 
-	adev->wakeup.ws = wakeup_source_register(dev_name(&adev->dev));
-	adev->wakeup.context.dev = dev;
-	adev->wakeup.context.func = func;
-
 	status = acpi_install_notify_handler(adev->handle, ACPI_SYSTEM_NOTIFY,
 					     acpi_pm_notify_handler, NULL);
 	if (ACPI_FAILURE(status))
 		goto out;
 
+	mutex_lock(&acpi_pm_notifier_lock);
+	adev->wakeup.ws = wakeup_source_register(dev_name(&adev->dev));
+	adev->wakeup.context.dev = dev;
+	adev->wakeup.context.func = func;
 	adev->wakeup.flags.notifier_present = true;
+	mutex_unlock(&acpi_pm_notifier_lock);
 
  out:
-	mutex_unlock(&acpi_pm_notifier_lock);
+	mutex_unlock(&acpi_pm_notifier_install_lock);
 	return status;
 }
 
@@ -472,7 +474,7 @@ acpi_status acpi_remove_pm_notifier(struct acpi_device *adev)
 {
 	acpi_status status = AE_BAD_PARAMETER;
 
-	mutex_lock(&acpi_pm_notifier_lock);
+	mutex_lock(&acpi_pm_notifier_install_lock);
 
 	if (!adev->wakeup.flags.notifier_present)
 		goto out;
@@ -483,14 +485,15 @@ acpi_status acpi_remove_pm_notifier(struct acpi_device *adev)
 	if (ACPI_FAILURE(status))
 		goto out;
 
+	mutex_lock(&acpi_pm_notifier_lock);
 	adev->wakeup.context.func = NULL;
 	adev->wakeup.context.dev = NULL;
 	wakeup_source_unregister(adev->wakeup.ws);
-
 	adev->wakeup.flags.notifier_present = false;
+	mutex_unlock(&acpi_pm_notifier_lock);
 
  out:
-	mutex_unlock(&acpi_pm_notifier_lock);
+	mutex_unlock(&acpi_pm_notifier_install_lock);
 	return status;
 }
 

commit 05087360fd7acf2cc9b7bbb243c12765c44c7693
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Oct 27 10:10:16 2017 +0200

    ACPI / PM: Take SMART_SUSPEND driver flag into account
    
    Make the ACPI PM domain take DPM_FLAG_SMART_SUSPEND into account in
    its system suspend callbacks.
    
    [Note that the pm_runtime_suspended() check in acpi_dev_needs_resume()
    is an optimization, because if is not passed, all of the subsequent
    checks may be skipped and some of them are much more overhead in
    general.]
    
    Also use the observation that if the device is in runtime suspend
    at the beginning of the "late" phase of a system-wide suspend-like
    transition, its state cannot change going forward (runtime PM is
    disabled for it at that time) until the transition is over and the
    subsequent system-wide PM callbacks should be skipped for it (as
    they generally assume the device to not be suspended), so add
    checks for that in acpi_subsys_suspend_late/noirq() and
    acpi_subsys_freeze_late/noirq().
    
    Moreover, if acpi_subsys_resume_noirq() is called during the
    subsequent system-wide resume transition and if the device was left
    in runtime suspend previously, its runtime PM status needs to be
    changed to "active" as it is going to be put into the full-power
    state going forward, so add a check for that too in there.
    
    In turn, if acpi_subsys_thaw_noirq() runs after the device has been
    left in runtime suspend, the subsequent "thaw" callbacks need
    to be skipped for it (as they may not work correctly with a
    suspended device), so set the power.direct_complete flag for the
    device then to make the PM core skip those callbacks.
    
    On top of the above, make the analogous changes in the acpi_lpss
    driver that uses the ACPI PM domain callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index b4dcc6144e6b..3d6ec51d2bbc 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -936,7 +936,8 @@ static bool acpi_dev_needs_resume(struct device *dev, struct acpi_device *adev)
 	u32 sys_target = acpi_target_system_state();
 	int ret, state;
 
-	if (device_may_wakeup(dev) != !!adev->wakeup.prepare_count)
+	if (!pm_runtime_suspended(dev) || !adev ||
+	    device_may_wakeup(dev) != !!adev->wakeup.prepare_count)
 		return true;
 
 	if (sys_target == ACPI_STATE_S0)
@@ -970,9 +971,6 @@ int acpi_subsys_prepare(struct device *dev)
 			return 0;
 	}
 
-	if (!adev || !pm_runtime_suspended(dev))
-		return 0;
-
 	return !acpi_dev_needs_resume(dev, adev);
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_prepare);
@@ -998,12 +996,17 @@ EXPORT_SYMBOL_GPL(acpi_subsys_complete);
  * acpi_subsys_suspend - Run the device driver's suspend callback.
  * @dev: Device to handle.
  *
- * Follow PCI and resume devices suspended at run time before running their
- * system suspend callbacks.
+ * Follow PCI and resume devices from runtime suspend before running their
+ * system suspend callbacks, unless the driver can cope with runtime-suspended
+ * devices during system suspend and there are no ACPI-specific reasons for
+ * resuming them.
  */
 int acpi_subsys_suspend(struct device *dev)
 {
-	pm_runtime_resume(dev);
+	if (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND) ||
+	    acpi_dev_needs_resume(dev, ACPI_COMPANION(dev)))
+		pm_runtime_resume(dev);
+
 	return pm_generic_suspend(dev);
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_suspend);
@@ -1017,11 +1020,47 @@ EXPORT_SYMBOL_GPL(acpi_subsys_suspend);
  */
 int acpi_subsys_suspend_late(struct device *dev)
 {
-	int ret = pm_generic_suspend_late(dev);
+	int ret;
+
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		return 0;
+
+	ret = pm_generic_suspend_late(dev);
 	return ret ? ret : acpi_dev_suspend(dev, device_may_wakeup(dev));
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_suspend_late);
 
+/**
+ * acpi_subsys_suspend_noirq - Run the device driver's "noirq" suspend callback.
+ * @dev: Device to suspend.
+ */
+int acpi_subsys_suspend_noirq(struct device *dev)
+{
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		return 0;
+
+	return pm_generic_suspend_noirq(dev);
+}
+EXPORT_SYMBOL_GPL(acpi_subsys_suspend_noirq);
+
+/**
+ * acpi_subsys_resume_noirq - Run the device driver's "noirq" resume callback.
+ * @dev: Device to handle.
+ */
+int acpi_subsys_resume_noirq(struct device *dev)
+{
+	/*
+	 * Devices with DPM_FLAG_SMART_SUSPEND may be left in runtime suspend
+	 * during system suspend, so update their runtime PM status to "active"
+	 * as they will be put into D0 going forward.
+	 */
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		pm_runtime_set_active(dev);
+
+	return pm_generic_resume_noirq(dev);
+}
+EXPORT_SYMBOL_GPL(acpi_subsys_resume_noirq);
+
 /**
  * acpi_subsys_resume_early - Resume device using ACPI.
  * @dev: Device to Resume.
@@ -1049,11 +1088,60 @@ int acpi_subsys_freeze(struct device *dev)
 	 * runtime-suspended devices should not be touched during freeze/thaw
 	 * transitions.
 	 */
-	pm_runtime_resume(dev);
+	if (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND))
+		pm_runtime_resume(dev);
+
 	return pm_generic_freeze(dev);
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_freeze);
 
+/**
+ * acpi_subsys_freeze_late - Run the device driver's "late" freeze callback.
+ * @dev: Device to handle.
+ */
+int acpi_subsys_freeze_late(struct device *dev)
+{
+
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		return 0;
+
+	return pm_generic_freeze_late(dev);
+}
+EXPORT_SYMBOL_GPL(acpi_subsys_freeze_late);
+
+/**
+ * acpi_subsys_freeze_noirq - Run the device driver's "noirq" freeze callback.
+ * @dev: Device to handle.
+ */
+int acpi_subsys_freeze_noirq(struct device *dev)
+{
+
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		return 0;
+
+	return pm_generic_freeze_noirq(dev);
+}
+EXPORT_SYMBOL_GPL(acpi_subsys_freeze_noirq);
+
+/**
+ * acpi_subsys_thaw_noirq - Run the device driver's "noirq" thaw callback.
+ * @dev: Device to handle.
+ */
+int acpi_subsys_thaw_noirq(struct device *dev)
+{
+	/*
+	 * If the device is in runtime suspend, the "thaw" code may not work
+	 * correctly with it, so skip the driver callback and make the PM core
+	 * skip all of the subsequent "thaw" callbacks for the device.
+	 */
+	if (dev_pm_smart_suspend_and_suspended(dev)) {
+		dev->power.direct_complete = true;
+		return 0;
+	}
+
+	return pm_generic_thaw_noirq(dev);
+}
+EXPORT_SYMBOL_GPL(acpi_subsys_thaw_noirq);
 #endif /* CONFIG_PM_SLEEP */
 
 static struct dev_pm_domain acpi_general_pm_domain = {
@@ -1065,10 +1153,17 @@ static struct dev_pm_domain acpi_general_pm_domain = {
 		.complete = acpi_subsys_complete,
 		.suspend = acpi_subsys_suspend,
 		.suspend_late = acpi_subsys_suspend_late,
+		.suspend_noirq = acpi_subsys_suspend_noirq,
+		.resume_noirq = acpi_subsys_resume_noirq,
 		.resume_early = acpi_subsys_resume_early,
 		.freeze = acpi_subsys_freeze,
+		.freeze_late = acpi_subsys_freeze_late,
+		.freeze_noirq = acpi_subsys_freeze_noirq,
+		.thaw_noirq = acpi_subsys_thaw_noirq,
 		.poweroff = acpi_subsys_suspend,
 		.poweroff_late = acpi_subsys_suspend_late,
+		.poweroff_noirq = acpi_subsys_suspend_noirq,
+		.restore_noirq = acpi_subsys_resume_noirq,
 		.restore_early = acpi_subsys_resume_early,
 #endif
 	},

commit 08810a4119aaebf6318f209ec5dd9828e969cba4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 25 14:12:29 2017 +0200

    PM / core: Add NEVER_SKIP and SMART_PREPARE driver flags
    
    The motivation for this change is to provide a way to work around
    a problem with the direct-complete mechanism used for avoiding
    system suspend/resume handling for devices in runtime suspend.
    
    The problem is that some middle layer code (the PCI bus type and
    the ACPI PM domain in particular) returns positive values from its
    system suspend ->prepare callbacks regardless of whether the driver's
    ->prepare returns a positive value or 0, which effectively prevents
    drivers from being able to control the direct-complete feature.
    Some drivers need that control, however, and the PCI bus type has
    grown its own flag to deal with this issue, but since it is not
    limited to PCI, it is better to address it by adding driver flags at
    the core level.
    
    To that end, add a driver_flags field to struct dev_pm_info for flags
    that can be set by device drivers at the probe time to inform the PM
    core and/or bus types, PM domains and so on on the capabilities and/or
    preferences of device drivers.  Also add two static inline helpers
    for setting that field and testing it against a given set of flags
    and make the driver core clear it automatically on driver remove
    and probe failures.
    
    Define and document two PM driver flags related to the direct-
    complete feature: NEVER_SKIP and SMART_PREPARE that can be used,
    respectively, to indicate to the PM core that the direct-complete
    mechanism should never be used for the device and to inform the
    middle layer code (bus types, PM domains etc) that it can only
    request the PM core to use the direct-complete mechanism for
    the device (by returning a positive value from its ->prepare
    callback) if it also has been requested by the driver.
    
    While at it, make the core check pm_runtime_suspended() when
    setting power.direct_complete so that it doesn't need to be
    checked by ->prepare callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 17e8eb93a76c..b4dcc6144e6b 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -959,11 +959,16 @@ static bool acpi_dev_needs_resume(struct device *dev, struct acpi_device *adev)
 int acpi_subsys_prepare(struct device *dev)
 {
 	struct acpi_device *adev = ACPI_COMPANION(dev);
-	int ret;
 
-	ret = pm_generic_prepare(dev);
-	if (ret < 0)
-		return ret;
+	if (dev->driver && dev->driver->pm && dev->driver->pm->prepare) {
+		int ret = dev->driver->pm->prepare(dev);
+
+		if (ret < 0)
+			return ret;
+
+		if (!ret && dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_PREPARE))
+			return 0;
+	}
 
 	if (!adev || !pm_runtime_suspended(dev))
 		return 0;

commit cbe25ce37d6c2623b5ac09128987e98848a54c6c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Oct 14 17:43:15 2017 +0200

    ACPI / PM: Combine device suspend routines
    
    On top of a previous change getting rid of the PM QoS flag
    PM_QOS_FLAG_REMOTE_WAKEUP, combine two ACPI device suspend routines,
    acpi_dev_runtime_suspend() and acpi_dev_suspend_late(), into one,
    acpi_dev_suspend(), to eliminate some code duplication.
    
    It also avoids enabling wakeup for devices handled by the ACPI
    LPSS middle layer on driver removal.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index d74000acb658..17e8eb93a76c 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -847,37 +847,39 @@ static int acpi_dev_pm_full_power(struct acpi_device *adev)
 }
 
 /**
- * acpi_dev_runtime_suspend - Put device into a low-power state using ACPI.
+ * acpi_dev_suspend - Put device into a low-power state using ACPI.
  * @dev: Device to put into a low-power state.
+ * @wakeup: Whether or not to enable wakeup for the device.
  *
- * Put the given device into a runtime low-power state using the standard ACPI
+ * Put the given device into a low-power state using the standard ACPI
  * mechanism.  Set up remote wakeup if desired, choose the state to put the
  * device into (this checks if remote wakeup is expected to work too), and set
  * the power state of the device.
  */
-int acpi_dev_runtime_suspend(struct device *dev)
+int acpi_dev_suspend(struct device *dev, bool wakeup)
 {
 	struct acpi_device *adev = ACPI_COMPANION(dev);
-	bool remote_wakeup;
+	u32 target_state = acpi_target_system_state();
 	int error;
 
 	if (!adev)
 		return 0;
 
-	remote_wakeup = acpi_device_can_wakeup(adev);
-	if (remote_wakeup) {
-		error = acpi_device_wakeup_enable(adev, ACPI_STATE_S0);
+	if (wakeup && acpi_device_can_wakeup(adev)) {
+		error = acpi_device_wakeup_enable(adev, target_state);
 		if (error)
 			return -EAGAIN;
+	} else {
+		wakeup = false;
 	}
 
-	error = acpi_dev_pm_low_power(dev, adev, ACPI_STATE_S0);
-	if (error && remote_wakeup)
+	error = acpi_dev_pm_low_power(dev, adev, target_state);
+	if (error && wakeup)
 		acpi_device_wakeup_disable(adev);
 
 	return error;
 }
-EXPORT_SYMBOL_GPL(acpi_dev_runtime_suspend);
+EXPORT_SYMBOL_GPL(acpi_dev_suspend);
 
 /**
  * acpi_dev_resume - Put device into the full-power state using ACPI.
@@ -910,7 +912,7 @@ EXPORT_SYMBOL_GPL(acpi_dev_resume);
 int acpi_subsys_runtime_suspend(struct device *dev)
 {
 	int ret = pm_generic_runtime_suspend(dev);
-	return ret ? ret : acpi_dev_runtime_suspend(dev);
+	return ret ? ret : acpi_dev_suspend(dev, true);
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_runtime_suspend);
 
@@ -929,41 +931,6 @@ int acpi_subsys_runtime_resume(struct device *dev)
 EXPORT_SYMBOL_GPL(acpi_subsys_runtime_resume);
 
 #ifdef CONFIG_PM_SLEEP
-/**
- * acpi_dev_suspend_late - Put device into a low-power state using ACPI.
- * @dev: Device to put into a low-power state.
- *
- * Put the given device into a low-power state during system transition to a
- * sleep state using the standard ACPI mechanism.  Set up system wakeup if
- * desired, choose the state to put the device into (this checks if system
- * wakeup is expected to work too), and set the power state of the device.
- */
-int acpi_dev_suspend_late(struct device *dev)
-{
-	struct acpi_device *adev = ACPI_COMPANION(dev);
-	u32 target_state;
-	bool wakeup;
-	int error;
-
-	if (!adev)
-		return 0;
-
-	target_state = acpi_target_system_state();
-	wakeup = device_may_wakeup(dev) && acpi_device_can_wakeup(adev);
-	if (wakeup) {
-		error = acpi_device_wakeup_enable(adev, target_state);
-		if (error)
-			return error;
-	}
-
-	error = acpi_dev_pm_low_power(dev, adev, target_state);
-	if (error && wakeup)
-		acpi_device_wakeup_disable(adev);
-
-	return error;
-}
-EXPORT_SYMBOL_GPL(acpi_dev_suspend_late);
-
 static bool acpi_dev_needs_resume(struct device *dev, struct acpi_device *adev)
 {
 	u32 sys_target = acpi_target_system_state();
@@ -1046,7 +1013,7 @@ EXPORT_SYMBOL_GPL(acpi_subsys_suspend);
 int acpi_subsys_suspend_late(struct device *dev)
 {
 	int ret = pm_generic_suspend_late(dev);
-	return ret ? ret : acpi_dev_suspend_late(dev);
+	return ret ? ret : acpi_dev_suspend(dev, device_may_wakeup(dev));
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_suspend_late);
 

commit 048f35ff26a6c1b7297b43ec4376d9fa1872b4a9
Merge: eeb2d80d502a 20f97caf1120
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Oct 17 00:29:58 2017 +0200

    Merge branch 'pm-qos' into acpi-pm

commit 20f97caf1120bd02e8ff4adbad3b44b63626feb5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Oct 13 15:27:24 2017 +0200

    PM / QoS: Drop PM_QOS_FLAG_REMOTE_WAKEUP
    
    The PM QoS flag PM_QOS_FLAG_REMOTE_WAKEUP is not used consistently
    and the vast majority of code simply assumes that remote wakeup
    should be enabled for devices in runtime suspend if they can
    generate wakeup signals, so drop it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index fbcc73f7a099..e8c820129797 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -581,8 +581,7 @@ static int acpi_dev_pm_get_state(struct device *dev, struct acpi_device *adev,
 		d_min = ret;
 		wakeup = device_may_wakeup(dev) && adev->wakeup.flags.valid
 			&& adev->wakeup.sleep_state >= target_state;
-	} else if (dev_pm_qos_flags(dev, PM_QOS_FLAG_REMOTE_WAKEUP) !=
-			PM_QOS_FLAGS_NONE) {
+	} else {
 		wakeup = adev->wakeup.flags.valid;
 	}
 
@@ -865,8 +864,7 @@ int acpi_dev_runtime_suspend(struct device *dev)
 	if (!adev)
 		return 0;
 
-	remote_wakeup = dev_pm_qos_flags(dev, PM_QOS_FLAG_REMOTE_WAKEUP) >
-				PM_QOS_FLAGS_NONE;
+	remote_wakeup = acpi_device_can_wakeup(adev);
 	if (remote_wakeup) {
 		error = acpi_device_wakeup_enable(adev, ACPI_STATE_S0);
 		if (error)

commit c2ebf788f927dcca72beead19fab5f5aba79a098
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Oct 3 09:11:08 2017 +0200

    ACPI / PM: Split code validating need for runtime resume in ->prepare()
    
    Move the code dealing with validation of whether runtime resuming the
    device is needed during system suspend.
    
    In this way it becomes more clear for what circumstances ACPI is prevented
    from trying the direct_complete path.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index d17fac453a30..764b8dfa04aa 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -966,6 +966,27 @@ int acpi_dev_suspend_late(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(acpi_dev_suspend_late);
 
+static bool acpi_dev_needs_resume(struct device *dev, struct acpi_device *adev)
+{
+	u32 sys_target = acpi_target_system_state();
+	int ret, state;
+
+	if (device_may_wakeup(dev) != !!adev->wakeup.prepare_count)
+		return true;
+
+	if (sys_target == ACPI_STATE_S0)
+		return false;
+
+	if (adev->power.flags.dsw_present)
+		return true;
+
+	ret = acpi_dev_pm_get_state(dev, adev, sys_target, NULL, &state);
+	if (ret)
+		return true;
+
+	return state != adev->power.state;
+}
+
 /**
  * acpi_subsys_prepare - Prepare device for system transition to a sleep state.
  * @dev: Device to prepare.
@@ -973,26 +994,16 @@ EXPORT_SYMBOL_GPL(acpi_dev_suspend_late);
 int acpi_subsys_prepare(struct device *dev)
 {
 	struct acpi_device *adev = ACPI_COMPANION(dev);
-	u32 sys_target;
-	int ret, state;
+	int ret;
 
 	ret = pm_generic_prepare(dev);
 	if (ret < 0)
 		return ret;
 
-	if (!adev || !pm_runtime_suspended(dev)
-	    || device_may_wakeup(dev) != !!adev->wakeup.prepare_count)
-		return 0;
-
-	sys_target = acpi_target_system_state();
-	if (sys_target == ACPI_STATE_S0)
-		return 1;
-
-	if (adev->power.flags.dsw_present)
+	if (!adev || !pm_runtime_suspended(dev))
 		return 0;
 
-	ret = acpi_dev_pm_get_state(dev, adev, sys_target, NULL, &state);
-	return !ret && state == adev->power.state;
+	return !acpi_dev_needs_resume(dev, adev);
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_prepare);
 

commit e4da817d2acbd05217adc0dc821bc8361e86ee30
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Oct 3 09:11:06 2017 +0200

    ACPI / PM: Restore acpi_subsys_complete()
    
    Commit 58a1fbbb2ee8 (PM / PCI / ACPI: Kick devices that might have
    been reset by firmware), made PCI's and ACPI's ->complete() callbacks
    to be assigned to a new API called pm_complete_with_resume_check(),
    which was introduced in the same change.
    
    Later it turned out that using pm_complete_with_resume_check() wasn't
    good enough for PCI, as it needed additional PCI specific checks,
    before deciding whether runtime resuming the device is needed when
    running the ->complete() callback.
    
    This leaves ACPI as the only user of pm_complete_with_resume_check().
    Therefore let's restore ACPI's acpi_subsys_complete(), which was
    dropped in commit 58a1fbbb2ee8 (PM / PCI / ACPI: Kick devices that
    might have been reset by firmware).
    
    This enables us to remove the pm_complete_with_resume_check() API in
    a following change, but it also enables ACPI to add more ACPI
    specific checks in acpi_subsys_complete() if that turns out to be
    necessary.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 6eb51145dcf7..d17fac453a30 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -996,6 +996,23 @@ int acpi_subsys_prepare(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_prepare);
 
+/**
+ * acpi_subsys_complete - Finalize device's resume during system resume.
+ * @dev: Device to handle.
+ */
+void acpi_subsys_complete(struct device *dev)
+{
+	pm_generic_complete(dev);
+	/*
+	 * If the device had been runtime-suspended before the system went into
+	 * the sleep state it is going out of and it has never been resumed till
+	 * now, resume it in case the firmware powered it up.
+	 */
+	if (dev->power.direct_complete && pm_resume_via_firmware())
+		pm_request_resume(dev);
+}
+EXPORT_SYMBOL_GPL(acpi_subsys_complete);
+
 /**
  * acpi_subsys_suspend - Run the device driver's suspend callback.
  * @dev: Device to handle.
@@ -1064,7 +1081,7 @@ static struct dev_pm_domain acpi_general_pm_domain = {
 		.runtime_resume = acpi_subsys_runtime_resume,
 #ifdef CONFIG_PM_SLEEP
 		.prepare = acpi_subsys_prepare,
-		.complete = pm_complete_with_resume_check,
+		.complete = acpi_subsys_complete,
 		.suspend = acpi_subsys_suspend,
 		.suspend_late = acpi_subsys_suspend_late,
 		.resume_early = acpi_subsys_resume_early,

commit 63705c406a8adbd6f26691148b09d466dd4d8d2f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Oct 10 18:49:22 2017 +0200

    ACPI / PM: Combine two identical device resume routines
    
    Notice that acpi_dev_runtime_resume() and acpi_dev_resume_early() are
    actually literally identical after some more-or-less recent changes,
    so rename acpi_dev_runtime_resume() to acpi_dev_resume(), use it
    everywhere instead of acpi_dev_resume_early() and drop the latter.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index fbcc73f7a099..6eb51145dcf7 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -882,14 +882,13 @@ int acpi_dev_runtime_suspend(struct device *dev)
 EXPORT_SYMBOL_GPL(acpi_dev_runtime_suspend);
 
 /**
- * acpi_dev_runtime_resume - Put device into the full-power state using ACPI.
+ * acpi_dev_resume - Put device into the full-power state using ACPI.
  * @dev: Device to put into the full-power state.
  *
  * Put the given device into the full-power state using the standard ACPI
- * mechanism at run time.  Set the power state of the device to ACPI D0 and
- * disable remote wakeup.
+ * mechanism.  Set the power state of the device to ACPI D0 and disable wakeup.
  */
-int acpi_dev_runtime_resume(struct device *dev)
+int acpi_dev_resume(struct device *dev)
 {
 	struct acpi_device *adev = ACPI_COMPANION(dev);
 	int error;
@@ -901,7 +900,7 @@ int acpi_dev_runtime_resume(struct device *dev)
 	acpi_device_wakeup_disable(adev);
 	return error;
 }
-EXPORT_SYMBOL_GPL(acpi_dev_runtime_resume);
+EXPORT_SYMBOL_GPL(acpi_dev_resume);
 
 /**
  * acpi_subsys_runtime_suspend - Suspend device using ACPI.
@@ -926,7 +925,7 @@ EXPORT_SYMBOL_GPL(acpi_subsys_runtime_suspend);
  */
 int acpi_subsys_runtime_resume(struct device *dev)
 {
-	int ret = acpi_dev_runtime_resume(dev);
+	int ret = acpi_dev_resume(dev);
 	return ret ? ret : pm_generic_runtime_resume(dev);
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_runtime_resume);
@@ -967,28 +966,6 @@ int acpi_dev_suspend_late(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(acpi_dev_suspend_late);
 
-/**
- * acpi_dev_resume_early - Put device into the full-power state using ACPI.
- * @dev: Device to put into the full-power state.
- *
- * Put the given device into the full-power state using the standard ACPI
- * mechanism during system transition to the working state.  Set the power
- * state of the device to ACPI D0 and disable remote wakeup.
- */
-int acpi_dev_resume_early(struct device *dev)
-{
-	struct acpi_device *adev = ACPI_COMPANION(dev);
-	int error;
-
-	if (!adev)
-		return 0;
-
-	error = acpi_dev_pm_full_power(adev);
-	acpi_device_wakeup_disable(adev);
-	return error;
-}
-EXPORT_SYMBOL_GPL(acpi_dev_resume_early);
-
 /**
  * acpi_subsys_prepare - Prepare device for system transition to a sleep state.
  * @dev: Device to prepare.
@@ -1057,7 +1034,7 @@ EXPORT_SYMBOL_GPL(acpi_subsys_suspend_late);
  */
 int acpi_subsys_resume_early(struct device *dev)
 {
-	int ret = acpi_dev_resume_early(dev);
+	int ret = acpi_dev_resume(dev);
 	return ret ? ret : pm_generic_resume_early(dev);
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_resume_early);

commit 020a63756707d3074fd00507c3bfd461e1cdf3eb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Aug 11 01:32:40 2017 +0200

    ACPI / PM: Add debug statements to acpi_pm_notify_handler()
    
    Add statements to trace invocations of the ACPI PM notify handler
    and the work functions called by it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 112fd6c55c2c..fbcc73f7a099 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -401,6 +401,8 @@ static void acpi_pm_notify_handler(acpi_handle handle, u32 val, void *not_used)
 	if (val != ACPI_NOTIFY_DEVICE_WAKE)
 		return;
 
+	acpi_handle_debug(handle, "Wake notify\n");
+
 	adev = acpi_bus_get_acpi_device(handle);
 	if (!adev)
 		return;
@@ -409,8 +411,12 @@ static void acpi_pm_notify_handler(acpi_handle handle, u32 val, void *not_used)
 
 	if (adev->wakeup.flags.notifier_present) {
 		pm_wakeup_ws_event(adev->wakeup.ws, 0, acpi_s2idle_wakeup());
-		if (adev->wakeup.context.func)
+		if (adev->wakeup.context.func) {
+			acpi_handle_debug(handle, "Running %pF for %s\n",
+					  adev->wakeup.context.func,
+					  dev_name(adev->wakeup.context.dev));
 			adev->wakeup.context.func(&adev->wakeup.context);
+		}
 	}
 
 	mutex_unlock(&acpi_pm_notifier_lock);

commit 1ba51a7c1496fd8f6d5bdd58dafcb1894275b7f0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 1 02:56:18 2017 +0200

    ACPI / PCI / PM: Rework acpi_pci_propagate_wakeup()
    
    The acpi_pci_propagate_wakeup() routine is there to handle cases in
    which PCI bridges (or PCIe ports) are expected to signal wakeup
    for devices below them, but currently it doesn't do that correctly.
    
    The problem is that acpi_pci_propagate_wakeup() uses
    acpi_pm_set_device_wakeup() for bridges and if that routine is
    called for multiple times to disable wakeup for the same device,
    it will disable it on the first invocation and the next calls
    will have no effect (it works analogously when called to enable
    wakeup, but that is not a problem).
    
    Now, say acpi_pci_propagate_wakeup() has been called for two
    different devices under the same bridge and it has called
    acpi_pm_set_device_wakeup() for that bridge each time.  The
    bridge is now enabled to generate wakeup signals.  Next,
    suppose that one of the devices below it resumes and
    acpi_pci_propagate_wakeup() is called to disable wakeup for that
    device.  It will then call acpi_pm_set_device_wakeup() for the bridge
    and that will effectively disable remote wakeup for all devices under
    it even though some of them may still be suspended and remote wakeup
    may be expected to work for them.
    
    To address this (arguably theoretical) issue, allow
    wakeup.enable_count under struct acpi_device to grow beyond 1 in
    certain situations.  In particular, allow that to happen in
    acpi_pci_propagate_wakeup() when wakeup is enabled or disabled
    for PCI bridges, so that wakeup is actually disabled for the
    bridge when all devices under it resume and not when just one
    of them does that.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 4cd4bdab053d..112fd6c55c2c 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -684,19 +684,8 @@ static void acpi_pm_notify_work_func(struct acpi_device_wakeup_context *context)
 
 static DEFINE_MUTEX(acpi_wakeup_lock);
 
-/**
- * acpi_device_wakeup_enable - Enable wakeup functionality for device.
- * @adev: ACPI device to enable wakeup functionality for.
- * @target_state: State the system is transitioning into.
- *
- * Enable the GPE associated with @adev so that it can generate wakeup signals
- * for the device in response to external (remote) events and enable wakeup
- * power for it.
- *
- * Callers must ensure that @adev is a valid ACPI device node before executing
- * this function.
- */
-static int acpi_device_wakeup_enable(struct acpi_device *adev, u32 target_state)
+static int __acpi_device_wakeup_enable(struct acpi_device *adev,
+				       u32 target_state, int max_count)
 {
 	struct acpi_device_wakeup *wakeup = &adev->wakeup;
 	acpi_status status;
@@ -704,9 +693,12 @@ static int acpi_device_wakeup_enable(struct acpi_device *adev, u32 target_state)
 
 	mutex_lock(&acpi_wakeup_lock);
 
-	if (wakeup->enable_count > 0)
+	if (wakeup->enable_count >= max_count)
 		goto out;
 
+	if (wakeup->enable_count > 0)
+		goto inc;
+
 	error = acpi_enable_wakeup_device_power(adev, target_state);
 	if (error)
 		goto out;
@@ -718,6 +710,7 @@ static int acpi_device_wakeup_enable(struct acpi_device *adev, u32 target_state)
 		goto out;
 	}
 
+inc:
 	wakeup->enable_count++;
 
 out:
@@ -725,6 +718,23 @@ static int acpi_device_wakeup_enable(struct acpi_device *adev, u32 target_state)
 	return error;
 }
 
+/**
+ * acpi_device_wakeup_enable - Enable wakeup functionality for device.
+ * @adev: ACPI device to enable wakeup functionality for.
+ * @target_state: State the system is transitioning into.
+ *
+ * Enable the GPE associated with @adev so that it can generate wakeup signals
+ * for the device in response to external (remote) events and enable wakeup
+ * power for it.
+ *
+ * Callers must ensure that @adev is a valid ACPI device node before executing
+ * this function.
+ */
+static int acpi_device_wakeup_enable(struct acpi_device *adev, u32 target_state)
+{
+	return __acpi_device_wakeup_enable(adev, target_state, 1);
+}
+
 /**
  * acpi_device_wakeup_disable - Disable wakeup functionality for device.
  * @adev: ACPI device to disable wakeup functionality for.
@@ -752,12 +762,8 @@ static void acpi_device_wakeup_disable(struct acpi_device *adev)
 	mutex_unlock(&acpi_wakeup_lock);
 }
 
-/**
- * acpi_pm_set_device_wakeup - Enable/disable remote wakeup for given device.
- * @dev: Device to enable/disable to generate wakeup events.
- * @enable: Whether to enable or disable the wakeup functionality.
- */
-int acpi_pm_set_device_wakeup(struct device *dev, bool enable)
+static int __acpi_pm_set_device_wakeup(struct device *dev, bool enable,
+				       int max_count)
 {
 	struct acpi_device *adev;
 	int error;
@@ -777,13 +783,35 @@ int acpi_pm_set_device_wakeup(struct device *dev, bool enable)
 		return 0;
 	}
 
-	error = acpi_device_wakeup_enable(adev, acpi_target_system_state());
+	error = __acpi_device_wakeup_enable(adev, acpi_target_system_state(),
+					    max_count);
 	if (!error)
 		dev_dbg(dev, "Wakeup enabled by ACPI\n");
 
 	return error;
 }
-EXPORT_SYMBOL(acpi_pm_set_device_wakeup);
+
+/**
+ * acpi_pm_set_device_wakeup - Enable/disable remote wakeup for given device.
+ * @dev: Device to enable/disable to generate wakeup events.
+ * @enable: Whether to enable or disable the wakeup functionality.
+ */
+int acpi_pm_set_device_wakeup(struct device *dev, bool enable)
+{
+	return __acpi_pm_set_device_wakeup(dev, enable, 1);
+}
+EXPORT_SYMBOL_GPL(acpi_pm_set_device_wakeup);
+
+/**
+ * acpi_pm_set_bridge_wakeup - Enable/disable remote wakeup for given bridge.
+ * @dev: Bridge device to enable/disable to generate wakeup events.
+ * @enable: Whether to enable or disable the wakeup functionality.
+ */
+int acpi_pm_set_bridge_wakeup(struct device *dev, bool enable)
+{
+	return __acpi_pm_set_device_wakeup(dev, enable, INT_MAX);
+}
+EXPORT_SYMBOL_GPL(acpi_pm_set_bridge_wakeup);
 
 /**
  * acpi_dev_pm_low_power - Put ACPI device into a low-power state.

commit 99d8845e756cb91e2865f430401d084cd6a8ccc9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 21 14:40:49 2017 +0200

    ACPI / PM: Split acpi_device_wakeup()
    
    To prepare for a subsequent change and make the code somewhat easier
    to follow, do the following in the ACPI device wakeup handling code:
    
     * Replace wakeup.flags.enabled under struct acpi_device with
       wakeup.enable_count as that will be necessary going forward.
    
       For now, wakeup.enable_count is not allowed to grow beyond 1,
       so the current behavior is retained.
    
     * Split acpi_device_wakeup() into acpi_device_wakeup_enable()
       and acpi_device_wakeup_disable() and modify the callers of
       it accordingly.
    
     * Introduce a new acpi_wakeup_lock mutex to protect the wakeup
       enabling/disabling code from races in case it is executed
       more than once in parallel for the same device (which may
       happen for bridges theoretically).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 2ed6935d4483..4cd4bdab053d 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -682,47 +682,74 @@ static void acpi_pm_notify_work_func(struct acpi_device_wakeup_context *context)
 	}
 }
 
+static DEFINE_MUTEX(acpi_wakeup_lock);
+
 /**
- * acpi_device_wakeup - Enable/disable wakeup functionality for device.
- * @adev: ACPI device to enable/disable wakeup functionality for.
+ * acpi_device_wakeup_enable - Enable wakeup functionality for device.
+ * @adev: ACPI device to enable wakeup functionality for.
  * @target_state: State the system is transitioning into.
- * @enable: Whether to enable or disable the wakeup functionality.
  *
- * Enable/disable the GPE associated with @adev so that it can generate
- * wakeup signals for the device in response to external (remote) events and
- * enable/disable device wakeup power.
+ * Enable the GPE associated with @adev so that it can generate wakeup signals
+ * for the device in response to external (remote) events and enable wakeup
+ * power for it.
  *
  * Callers must ensure that @adev is a valid ACPI device node before executing
  * this function.
  */
-static int acpi_device_wakeup(struct acpi_device *adev, u32 target_state,
-			      bool enable)
+static int acpi_device_wakeup_enable(struct acpi_device *adev, u32 target_state)
 {
 	struct acpi_device_wakeup *wakeup = &adev->wakeup;
+	acpi_status status;
+	int error = 0;
 
-	if (enable) {
-		acpi_status res;
-		int error;
+	mutex_lock(&acpi_wakeup_lock);
 
-		if (adev->wakeup.flags.enabled)
-			return 0;
+	if (wakeup->enable_count > 0)
+		goto out;
 
-		error = acpi_enable_wakeup_device_power(adev, target_state);
-		if (error)
-			return error;
+	error = acpi_enable_wakeup_device_power(adev, target_state);
+	if (error)
+		goto out;
 
-		res = acpi_enable_gpe(wakeup->gpe_device, wakeup->gpe_number);
-		if (ACPI_FAILURE(res)) {
-			acpi_disable_wakeup_device_power(adev);
-			return -EIO;
-		}
-		adev->wakeup.flags.enabled = 1;
-	} else if (adev->wakeup.flags.enabled) {
-		acpi_disable_gpe(wakeup->gpe_device, wakeup->gpe_number);
+	status = acpi_enable_gpe(wakeup->gpe_device, wakeup->gpe_number);
+	if (ACPI_FAILURE(status)) {
 		acpi_disable_wakeup_device_power(adev);
-		adev->wakeup.flags.enabled = 0;
+		error = -EIO;
+		goto out;
 	}
-	return 0;
+
+	wakeup->enable_count++;
+
+out:
+	mutex_unlock(&acpi_wakeup_lock);
+	return error;
+}
+
+/**
+ * acpi_device_wakeup_disable - Disable wakeup functionality for device.
+ * @adev: ACPI device to disable wakeup functionality for.
+ *
+ * Disable the GPE associated with @adev and disable wakeup power for it.
+ *
+ * Callers must ensure that @adev is a valid ACPI device node before executing
+ * this function.
+ */
+static void acpi_device_wakeup_disable(struct acpi_device *adev)
+{
+	struct acpi_device_wakeup *wakeup = &adev->wakeup;
+
+	mutex_lock(&acpi_wakeup_lock);
+
+	if (!wakeup->enable_count)
+		goto out;
+
+	acpi_disable_gpe(wakeup->gpe_device, wakeup->gpe_number);
+	acpi_disable_wakeup_device_power(adev);
+
+	wakeup->enable_count--;
+
+out:
+	mutex_unlock(&acpi_wakeup_lock);
 }
 
 /**
@@ -744,9 +771,15 @@ int acpi_pm_set_device_wakeup(struct device *dev, bool enable)
 	if (!acpi_device_can_wakeup(adev))
 		return -EINVAL;
 
-	error = acpi_device_wakeup(adev, acpi_target_system_state(), enable);
+	if (!enable) {
+		acpi_device_wakeup_disable(adev);
+		dev_dbg(dev, "Wakeup disabled by ACPI\n");
+		return 0;
+	}
+
+	error = acpi_device_wakeup_enable(adev, acpi_target_system_state());
 	if (!error)
-		dev_dbg(dev, "Wakeup %s by ACPI\n", enable ? "enabled" : "disabled");
+		dev_dbg(dev, "Wakeup enabled by ACPI\n");
 
 	return error;
 }
@@ -800,13 +833,15 @@ int acpi_dev_runtime_suspend(struct device *dev)
 
 	remote_wakeup = dev_pm_qos_flags(dev, PM_QOS_FLAG_REMOTE_WAKEUP) >
 				PM_QOS_FLAGS_NONE;
-	error = acpi_device_wakeup(adev, ACPI_STATE_S0, remote_wakeup);
-	if (remote_wakeup && error)
-		return -EAGAIN;
+	if (remote_wakeup) {
+		error = acpi_device_wakeup_enable(adev, ACPI_STATE_S0);
+		if (error)
+			return -EAGAIN;
+	}
 
 	error = acpi_dev_pm_low_power(dev, adev, ACPI_STATE_S0);
-	if (error)
-		acpi_device_wakeup(adev, ACPI_STATE_S0, false);
+	if (error && remote_wakeup)
+		acpi_device_wakeup_disable(adev);
 
 	return error;
 }
@@ -829,7 +864,7 @@ int acpi_dev_runtime_resume(struct device *dev)
 		return 0;
 
 	error = acpi_dev_pm_full_power(adev);
-	acpi_device_wakeup(adev, ACPI_STATE_S0, false);
+	acpi_device_wakeup_disable(adev);
 	return error;
 }
 EXPORT_SYMBOL_GPL(acpi_dev_runtime_resume);
@@ -884,13 +919,15 @@ int acpi_dev_suspend_late(struct device *dev)
 
 	target_state = acpi_target_system_state();
 	wakeup = device_may_wakeup(dev) && acpi_device_can_wakeup(adev);
-	error = acpi_device_wakeup(adev, target_state, wakeup);
-	if (wakeup && error)
-		return error;
+	if (wakeup) {
+		error = acpi_device_wakeup_enable(adev, target_state);
+		if (error)
+			return error;
+	}
 
 	error = acpi_dev_pm_low_power(dev, adev, target_state);
-	if (error)
-		acpi_device_wakeup(adev, ACPI_STATE_UNKNOWN, false);
+	if (error && wakeup)
+		acpi_device_wakeup_disable(adev);
 
 	return error;
 }
@@ -913,7 +950,7 @@ int acpi_dev_resume_early(struct device *dev)
 		return 0;
 
 	error = acpi_dev_pm_full_power(adev);
-	acpi_device_wakeup(adev, ACPI_STATE_UNKNOWN, false);
+	acpi_device_wakeup_disable(adev);
 	return error;
 }
 EXPORT_SYMBOL_GPL(acpi_dev_resume_early);
@@ -1056,7 +1093,7 @@ static void acpi_dev_pm_detach(struct device *dev, bool power_off)
 			 */
 			dev_pm_qos_hide_latency_limit(dev);
 			dev_pm_qos_hide_flags(dev);
-			acpi_device_wakeup(adev, ACPI_STATE_S0, false);
+			acpi_device_wakeup_disable(adev);
 			acpi_dev_pm_low_power(dev, adev, ACPI_STATE_S0);
 		}
 	}
@@ -1100,7 +1137,7 @@ int acpi_dev_pm_attach(struct device *dev, bool power_on)
 	dev_pm_domain_set(dev, &acpi_general_pm_domain);
 	if (power_on) {
 		acpi_dev_pm_full_power(adev);
-		acpi_device_wakeup(adev, ACPI_STATE_S0, false);
+		acpi_device_wakeup_disable(adev);
 	}
 
 	dev->pm_domain->detach = acpi_dev_pm_detach;

commit 548aa0e3c516d906dae5edb1fc9a1ad2e490120a
Merge: 322618684353 6a71d8d77795
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 10 15:23:45 2017 -0700

    Merge tag 'devprop-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull device properties framework updates from Rafael Wysocki:
     "These mostly rearrange the device properties core code and add a few
      helper functions to it as a foundation for future work.
    
      Specifics:
    
       - Rearrange the core device properties code by moving the code
         specific to each supported platform configuration framework (ACPI,
         DT and build-in) into a separate file (Sakari Ailus).
    
       - Add helper functions for accessing device properties in a
         firmware-agnostic way (Sakari Ailus, Kieran Bingham)"
    
    * tag 'devprop-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      device property: Add fwnode_graph_get_port_parent
      device property: Add FW type agnostic fwnode_graph_get_remote_node
      device property: Introduce fwnode_device_is_available()
      device property: Move fwnode graph ops to firmware specific locations
      device property: Move FW type specific functionality to FW specific files
      ACPI: Constify argument to acpi_device_is_present()

commit 8370c2dc4c7b91be7e1231130f0ae08b5aebecf4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 24 01:56:13 2017 +0200

    PCI / PM: Drop pme_interrupt flag from struct pci_dev
    
    The pme_interrupt flag in struct pci_dev is set when PMEs generated
    by the device are going to be signaled via root port PME interrupts.
    
    Ironically enough, that information is only used by the code setting
    up device wakeup through ACPI which returns as soon as it sees the
    pme_interrupt flag set while setting up "remote runtime wakeup".
    That is questionable, however, because in theory there may be PCIe
    devices using out-of-band PME signaling under root ports handled
    by the native PME code or devices requiring wakeup power setup to be
    carried out by AML.  For such devices, ACPI wakeup should be invoked
    regardless of whether or not native PME signaling is used in general.
    
    For this reason, drop the pme_interrupt flag and rework the code
    using it which then allows the ACPI-based device wakeup handling
    in PCI to be consolidated to use one code path for both "runtime
    remote wakeup" and system wakeup (from sleep states).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index d2e985a4bac2..28938b5a334e 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -496,6 +496,13 @@ bool acpi_bus_can_wakeup(acpi_handle handle)
 }
 EXPORT_SYMBOL(acpi_bus_can_wakeup);
 
+bool acpi_pm_device_can_wakeup(struct device *dev)
+{
+	struct acpi_device *adev = ACPI_COMPANION(dev);
+
+	return adev ? acpi_device_can_wakeup(adev) : false;
+}
+
 /**
  * acpi_dev_pm_get_state - Get preferred power state of ACPI device.
  * @dev: Device whose preferred target power state to return.
@@ -737,8 +744,7 @@ int acpi_pm_set_device_wakeup(struct device *dev, bool enable)
 
 	error = acpi_device_wakeup(adev, acpi_target_system_state(), enable);
 	if (!error)
-		dev_dbg(dev, "Wakeup %s by ACPI\n",
-			enable ? "enabled" : "disabled");
+		dev_dbg(dev, "Wakeup %s by ACPI\n", enable ? "enabled" : "disabled");
 
 	return error;
 }

commit 4d183d04195318c8ee8bce048f3f9a89c0e2056d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 24 01:54:39 2017 +0200

    ACPI / PM: Consolidate device wakeup settings code
    
    Currently, there are two separate ways of handling device wakeup
    settings in the ACPI core, depending on whether this is runtime
    wakeup or system wakeup (from sleep states).  However, after the
    previous commit eliminating the run_wake ACPI device wakeup flag,
    there is no difference between the two any more at the ACPI level,
    so they can be combined.
    
    For this reason, introduce acpi_pm_set_device_wakeup() to replace both
    acpi_pm_device_run_wake() and acpi_pm_device_sleep_wake() and make it
    check the ACPI device object's wakeup.valid flag to determine whether
    or not the device can be set up to generate wakeup signals.
    
    Also notice that zpodd_enable/disable_run_wake() only call
    device_set_run_wake() because acpi_pm_device_run_wake() called
    device_run_wake(), which is not done by acpi_pm_set_device_wakeup(),
    so drop the now redundant device_set_run_wake() calls from there.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index ca0210213773..d2e985a4bac2 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -717,55 +717,32 @@ static int acpi_device_wakeup(struct acpi_device *adev, u32 target_state,
 }
 
 /**
- * acpi_pm_device_run_wake - Enable/disable remote wakeup for given device.
- * @dev: Device to enable/disable the platform to wake up.
+ * acpi_pm_set_device_wakeup - Enable/disable remote wakeup for given device.
+ * @dev: Device to enable/disable to generate wakeup events.
  * @enable: Whether to enable or disable the wakeup functionality.
  */
-int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
-{
-	struct acpi_device *adev;
-
-	if (!device_run_wake(phys_dev))
-		return -EINVAL;
-
-	adev = ACPI_COMPANION(phys_dev);
-	if (!adev) {
-		dev_dbg(phys_dev, "ACPI companion missing in %s!\n", __func__);
-		return -ENODEV;
-	}
-
-	return acpi_device_wakeup(adev, ACPI_STATE_S0, enable);
-}
-EXPORT_SYMBOL(acpi_pm_device_run_wake);
-
-#ifdef CONFIG_PM_SLEEP
-/**
- * acpi_pm_device_sleep_wake - Enable or disable device to wake up the system.
- * @dev: Device to enable/desible to wake up the system from sleep states.
- * @enable: Whether to enable or disable @dev to wake up the system.
- */
-int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
+int acpi_pm_set_device_wakeup(struct device *dev, bool enable)
 {
 	struct acpi_device *adev;
 	int error;
 
-	if (!device_can_wakeup(dev))
-		return -EINVAL;
-
 	adev = ACPI_COMPANION(dev);
 	if (!adev) {
 		dev_dbg(dev, "ACPI companion missing in %s!\n", __func__);
 		return -ENODEV;
 	}
 
+	if (!acpi_device_can_wakeup(adev))
+		return -EINVAL;
+
 	error = acpi_device_wakeup(adev, acpi_target_system_state(), enable);
 	if (!error)
-		dev_dbg(dev, "System wakeup %s by ACPI\n",
+		dev_dbg(dev, "Wakeup %s by ACPI\n",
 			enable ? "enabled" : "disabled");
 
 	return error;
 }
-#endif /* CONFIG_PM_SLEEP */
+EXPORT_SYMBOL(acpi_pm_set_device_wakeup);
 
 /**
  * acpi_dev_pm_low_power - Put ACPI device into a low-power state.

commit cde1f95f407a593ad6baf1b7b01daa2c6cbd34fd
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Jun 6 12:37:36 2017 +0300

    ACPI: Constify argument to acpi_device_is_present()
    
    This will be needed in constifying the fwnode API.
    
    The side effects the function had have been moved to the callers.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 993fd31394c8..e565ed329f11 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -261,8 +261,10 @@ int acpi_bus_init_power(struct acpi_device *device)
 		return -EINVAL;
 
 	device->power.state = ACPI_STATE_UNKNOWN;
-	if (!acpi_device_is_present(device))
+	if (!acpi_device_is_present(device)) {
+		device->flags.initialized = false;
 		return -ENXIO;
+	}
 
 	result = acpi_device_get_power(device, &state);
 	if (result)

commit 33e4f80ee69b5168badf37edbfed796eb48434b9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 12 22:56:34 2017 +0200

    ACPI / PM: Ignore spurious SCI wakeups from suspend-to-idle
    
    The ACPI SCI (System Control Interrupt) is set up as a wakeup IRQ
    during suspend-to-idle transitions and, consequently, any events
    signaled through it wake up the system from that state.  However,
    on some systems some of the events signaled via the ACPI SCI while
    suspended to idle should not cause the system to wake up.  In fact,
    quite often they should just be discarded.
    
    Arguably, systems should not resume entirely on such events, but in
    order to decide which events really should cause the system to resume
    and which are spurious, it is necessary to resume up to the point
    when ACPI SCIs are actually handled and processed, which is after
    executing dpm_resume_noirq() in the system resume path.
    
    For this reasons, add a loop around freeze_enter() in which the
    platforms can process events signaled via multiplexed IRQ lines
    like the ACPI SCI and add suspend-to-idle hooks that can be
    used for this purpose to struct platform_freeze_ops.
    
    In the ACPI case, the ->wake hook is used for checking if the SCI
    has triggered while suspended and deferring the interrupt-induced
    system wakeup until the events signaled through it are actually
    processed sufficiently to decide whether or not the system should
    resume.  In turn, the ->sync hook allows all of the relevant event
    queues to be flushed so as to prevent events from being missed due
    to race conditions.
    
    In addition to that, some ACPI code processing wakeup events needs
    to be modified to use the "hard" version of wakeup triggers, so that
    it will cause a system resume to happen on device-induced wakeup
    events even if the "soft" mechanism to prevent the system from
    suspending is not enabled.  However, to preserve the existing
    behavior with respect to suspend-to-RAM, this only is done in
    the suspend-to-idle case and only if an SCI has occurred while
    suspended.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index f13c62c4b117..ca0210213773 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -24,6 +24,7 @@
 #include <linux/pm_qos.h>
 #include <linux/pm_domain.h>
 #include <linux/pm_runtime.h>
+#include <linux/suspend.h>
 
 #include "internal.h"
 
@@ -385,6 +386,12 @@ EXPORT_SYMBOL(acpi_bus_power_manageable);
 #ifdef CONFIG_PM
 static DEFINE_MUTEX(acpi_pm_notifier_lock);
 
+void acpi_pm_wakeup_event(struct device *dev)
+{
+	pm_wakeup_dev_event(dev, 0, acpi_s2idle_wakeup());
+}
+EXPORT_SYMBOL_GPL(acpi_pm_wakeup_event);
+
 static void acpi_pm_notify_handler(acpi_handle handle, u32 val, void *not_used)
 {
 	struct acpi_device *adev;
@@ -399,7 +406,7 @@ static void acpi_pm_notify_handler(acpi_handle handle, u32 val, void *not_used)
 	mutex_lock(&acpi_pm_notifier_lock);
 
 	if (adev->wakeup.flags.notifier_present) {
-		__pm_wakeup_event(adev->wakeup.ws, 0);
+		pm_wakeup_ws_event(adev->wakeup.ws, 0, acpi_s2idle_wakeup());
 		if (adev->wakeup.context.func)
 			adev->wakeup.context.func(&adev->wakeup.context);
 	}

commit 235d81a630ca2d39818da96f0c14bc960ffbaeb5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 12 22:51:07 2017 +0200

    ACPI / PM: Clean up device wakeup enable/disable code
    
    The wakeup.flags.enabled flag in struct acpi_device is not used
    consistently, as there is no reason why it should only apply
    to the enabling/disabling of the wakeup GPE, so put the invocation
    of acpi_enable_wakeup_device_power() under it too.
    
    Moreover, it is not necessary to call
    acpi_enable_wakeup_devices() and acpi_disable_wakeup_devices() for
    suspend-to-idle, so don't do that.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index fa7405286d71..f13c62c4b117 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -688,26 +688,23 @@ static int acpi_device_wakeup(struct acpi_device *adev, u32 target_state,
 		acpi_status res;
 		int error;
 
+		if (adev->wakeup.flags.enabled)
+			return 0;
+
 		error = acpi_enable_wakeup_device_power(adev, target_state);
 		if (error)
 			return error;
 
-		if (adev->wakeup.flags.enabled)
-			return 0;
-
 		res = acpi_enable_gpe(wakeup->gpe_device, wakeup->gpe_number);
-		if (ACPI_SUCCESS(res)) {
-			adev->wakeup.flags.enabled = 1;
-		} else {
+		if (ACPI_FAILURE(res)) {
 			acpi_disable_wakeup_device_power(adev);
 			return -EIO;
 		}
-	} else {
-		if (adev->wakeup.flags.enabled) {
-			acpi_disable_gpe(wakeup->gpe_device, wakeup->gpe_number);
-			adev->wakeup.flags.enabled = 0;
-		}
+		adev->wakeup.flags.enabled = 1;
+	} else if (adev->wakeup.flags.enabled) {
+		acpi_disable_gpe(wakeup->gpe_device, wakeup->gpe_number);
 		acpi_disable_wakeup_device_power(adev);
+		adev->wakeup.flags.enabled = 0;
 	}
 	return 0;
 }

commit 190cab84711a3f453e2100d0c9238f42261cf426
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 12 22:50:24 2017 +0200

    ACPI / PM: Change log level of wakeup-related message
    
    Change the log level of the "System wakeup enabled/disabled by ACPI"
    message in acpi_pm_device_sleep_wake() to "debug" to reduce to log
    noise level.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index a199983390b6..fa7405286d71 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -756,8 +756,8 @@ int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
 
 	error = acpi_device_wakeup(adev, acpi_target_system_state(), enable);
 	if (!error)
-		dev_info(dev, "System wakeup %s by ACPI\n",
-				enable ? "enabled" : "disabled");
+		dev_dbg(dev, "System wakeup %s by ACPI\n",
+			enable ? "enabled" : "disabled");
 
 	return error;
 }

commit 64fd1c7040880292710e6592ddc88d0d73cfb6fb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 12 22:48:41 2017 +0200

    ACPI / PM: Run wakeup notify handlers synchronously
    
    The work functions provided by the users of acpi_add_pm_notifier()
    should be run synchronously before re-enabling the wakeup GPE in
    case they are used to clear the status and/or disable the wakeup
    signaling at the source.  Otherwise, which is the case currently in
    the PCI bus type code, the same wakeup event may be signaled for
    multiple times while the execution of the work function in response
    to it has already been queued up.
    
    Fortunately, acpi_add_pm_notifier() is only used by PCI and by
    ACPI device PM code internally, so the change is relatively
    straightforward to make.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 993fd31394c8..a199983390b6 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -400,8 +400,8 @@ static void acpi_pm_notify_handler(acpi_handle handle, u32 val, void *not_used)
 
 	if (adev->wakeup.flags.notifier_present) {
 		__pm_wakeup_event(adev->wakeup.ws, 0);
-		if (adev->wakeup.context.work.func)
-			queue_pm_work(&adev->wakeup.context.work);
+		if (adev->wakeup.context.func)
+			adev->wakeup.context.func(&adev->wakeup.context);
 	}
 
 	mutex_unlock(&acpi_pm_notifier_lock);
@@ -413,7 +413,7 @@ static void acpi_pm_notify_handler(acpi_handle handle, u32 val, void *not_used)
  * acpi_add_pm_notifier - Register PM notify handler for given ACPI device.
  * @adev: ACPI device to add the notify handler for.
  * @dev: Device to generate a wakeup event for while handling the notification.
- * @work_func: Work function to execute when handling the notification.
+ * @func: Work function to execute when handling the notification.
  *
  * NOTE: @adev need not be a run-wake or wakeup device to be a valid source of
  * PM wakeup events.  For example, wakeup events may be generated for bridges
@@ -421,11 +421,11 @@ static void acpi_pm_notify_handler(acpi_handle handle, u32 val, void *not_used)
  * bridge itself doesn't have a wakeup GPE associated with it.
  */
 acpi_status acpi_add_pm_notifier(struct acpi_device *adev, struct device *dev,
-				 void (*work_func)(struct work_struct *work))
+			void (*func)(struct acpi_device_wakeup_context *context))
 {
 	acpi_status status = AE_ALREADY_EXISTS;
 
-	if (!dev && !work_func)
+	if (!dev && !func)
 		return AE_BAD_PARAMETER;
 
 	mutex_lock(&acpi_pm_notifier_lock);
@@ -435,8 +435,7 @@ acpi_status acpi_add_pm_notifier(struct acpi_device *adev, struct device *dev,
 
 	adev->wakeup.ws = wakeup_source_register(dev_name(&adev->dev));
 	adev->wakeup.context.dev = dev;
-	if (work_func)
-		INIT_WORK(&adev->wakeup.context.work, work_func);
+	adev->wakeup.context.func = func;
 
 	status = acpi_install_notify_handler(adev->handle, ACPI_SYSTEM_NOTIFY,
 					     acpi_pm_notify_handler, NULL);
@@ -469,10 +468,7 @@ acpi_status acpi_remove_pm_notifier(struct acpi_device *adev)
 	if (ACPI_FAILURE(status))
 		goto out;
 
-	if (adev->wakeup.context.work.func) {
-		cancel_work_sync(&adev->wakeup.context.work);
-		adev->wakeup.context.work.func = NULL;
-	}
+	adev->wakeup.context.func = NULL;
 	adev->wakeup.context.dev = NULL;
 	wakeup_source_unregister(adev->wakeup.ws);
 
@@ -658,16 +654,15 @@ EXPORT_SYMBOL(acpi_pm_device_sleep_state);
 
 /**
  * acpi_pm_notify_work_func - ACPI devices wakeup notification work function.
- * @work: Work item to handle.
+ * @context: Device wakeup context.
  */
-static void acpi_pm_notify_work_func(struct work_struct *work)
+static void acpi_pm_notify_work_func(struct acpi_device_wakeup_context *context)
 {
-	struct device *dev;
+	struct device *dev = context->dev;
 
-	dev = container_of(work, struct acpi_device_wakeup_context, work)->dev;
 	if (dev) {
 		pm_wakeup_event(dev, 0);
-		pm_runtime_resume(dev);
+		pm_request_resume(dev);
 	}
 }
 

commit f3b7eaae1b35eb8077610eb7c7db042c9b0645e1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 7 00:57:37 2017 +0200

    Revert "ACPI / sleep: Ignore spurious SCI wakeups from suspend-to-idle"
    
    Revert commit eed4d47efe95 (ACPI / sleep: Ignore spurious SCI wakeups
    from suspend-to-idle) as it turned out to be premature and triggered
    a number of different issues on various systems.
    
    That includes, but is not limited to, premature suspend-to-RAM aborts
    on Dell XPS 13 (9343) reported by Dominik.
    
    The issue the commit in question attempted to address is real and
    will need to be taken care of going forward, but evidently more work
    is needed for this purpose.
    
    Reported-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 798d5003a039..993fd31394c8 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -24,7 +24,6 @@
 #include <linux/pm_qos.h>
 #include <linux/pm_domain.h>
 #include <linux/pm_runtime.h>
-#include <linux/suspend.h>
 
 #include "internal.h"
 
@@ -400,7 +399,7 @@ static void acpi_pm_notify_handler(acpi_handle handle, u32 val, void *not_used)
 	mutex_lock(&acpi_pm_notifier_lock);
 
 	if (adev->wakeup.flags.notifier_present) {
-		pm_wakeup_ws_event(adev->wakeup.ws, 0, true);
+		__pm_wakeup_event(adev->wakeup.ws, 0);
 		if (adev->wakeup.context.work.func)
 			queue_pm_work(&adev->wakeup.context.work);
 	}

commit eed4d47efe9508b855b09754cf6de4325d8a2f0d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Apr 26 23:23:03 2017 +0200

    ACPI / sleep: Ignore spurious SCI wakeups from suspend-to-idle
    
    The ACPI SCI (System Control Interrupt) is set up as a wakeup IRQ
    during suspend-to-idle transitions and, consequently, any events
    signaled through it wake up the system from that state.  However,
    on some systems some of the events signaled via the ACPI SCI while
    suspended to idle should not cause the system to wake up.  In fact,
    quite often they should just be discarded.
    
    Arguably, systems should not resume entirely on such events, but in
    order to decide which events really should cause the system to resume
    and which are spurious, it is necessary to resume up to the point
    when ACPI SCIs are actually handled and processed, which is after
    executing dpm_resume_noirq() in the system resume path.
    
    For this reasons, add a loop around freeze_enter() in which the
    platforms can process events signaled via multiplexed IRQ lines
    like the ACPI SCI and add suspend-to-idle hooks that can be
    used for this purpose to struct platform_freeze_ops.
    
    In the ACPI case, the ->wake hook is used for checking if the SCI
    has triggered while suspended and deferring the interrupt-induced
    system wakeup until the events signaled through it are actually
    processed sufficiently to decide whether or not the system should
    resume.  In turn, the ->sync hook allows all of the relevant event
    queues to be flushed so as to prevent events from being missed due
    to race conditions.
    
    In addition to that, some ACPI code processing wakeup events needs
    to be modified to use the "hard" version of wakeup triggers, so that
    it will cause a system resume to happen on device-induced wakeup
    events even if the "soft" mechanism to prevent the system from
    suspending is not enabled (that also helps to catch device-induced
    wakeup events occurring during suspend transitions in progress).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 993fd31394c8..798d5003a039 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -24,6 +24,7 @@
 #include <linux/pm_qos.h>
 #include <linux/pm_domain.h>
 #include <linux/pm_runtime.h>
+#include <linux/suspend.h>
 
 #include "internal.h"
 
@@ -399,7 +400,7 @@ static void acpi_pm_notify_handler(acpi_handle handle, u32 val, void *not_used)
 	mutex_lock(&acpi_pm_notifier_lock);
 
 	if (adev->wakeup.flags.notifier_present) {
-		__pm_wakeup_event(adev->wakeup.ws, 0);
+		pm_wakeup_ws_event(adev->wakeup.ws, 0, true);
 		if (adev->wakeup.context.work.func)
 			queue_pm_work(&adev->wakeup.context.work);
 	}

commit 78a898d0e39513469858de990de83210fee28ee9
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu May 19 15:25:41 2016 +0200

    ACPI / PM: Export acpi_device_fix_up_power()
    
    Drivers that needs acpi_device_fix_up_power(), allow them to be built as
    modules by exporting this function.
    
    Cc: <stable@vger.kernel.org> # 4.5+
    Tested-by: Laszlo Fiat <laszlo.fiat@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index cd2c3d6d40e0..993fd31394c8 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -319,6 +319,7 @@ int acpi_device_fix_up_power(struct acpi_device *device)
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(acpi_device_fix_up_power);
 
 int acpi_device_update_power(struct acpi_device *device, int *state_p)
 {

commit 989561de9b5112999475b406557d9c7e9e59c041
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Thu Jan 7 16:46:13 2016 +0100

    PM / Domains: add setter for dev.pm_domain
    
    Adds a function that sets the pointer to dev_pm_domain in struct device
    and that warns if the device has already finished probing. The reason
    why we want to enforce that is because in the general case that can
    cause problems and also that we can simplify code quite a bit if we can
    always assume that.
    
    This patch also changes all current code that directly sets the
    dev.pm_domain pointer.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 08a02cdc737c..cd2c3d6d40e0 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -22,6 +22,7 @@
 #include <linux/export.h>
 #include <linux/mutex.h>
 #include <linux/pm_qos.h>
+#include <linux/pm_domain.h>
 #include <linux/pm_runtime.h>
 
 #include "internal.h"
@@ -1059,7 +1060,7 @@ static void acpi_dev_pm_detach(struct device *dev, bool power_off)
 	struct acpi_device *adev = ACPI_COMPANION(dev);
 
 	if (adev && dev->pm_domain == &acpi_general_pm_domain) {
-		dev->pm_domain = NULL;
+		dev_pm_domain_set(dev, NULL);
 		acpi_remove_pm_notifier(adev);
 		if (power_off) {
 			/*
@@ -1111,7 +1112,7 @@ int acpi_dev_pm_attach(struct device *dev, bool power_on)
 		return -EBUSY;
 
 	acpi_add_pm_notifier(adev, dev, acpi_pm_notify_work_func);
-	dev->pm_domain = &acpi_general_pm_domain;
+	dev_pm_domain_set(dev, &acpi_general_pm_domain);
 	if (power_on) {
 		acpi_dev_pm_full_power(adev);
 		acpi_device_wakeup(adev, ACPI_STATE_S0, false);

commit 58a1fbbb2ee873dd1fe327e80bc7b08e80866269
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 7 00:50:24 2015 +0200

    PM / PCI / ACPI: Kick devices that might have been reset by firmware
    
    There is a concern that if the platform firmware was involved in
    the system resume that's being completed,  some devices might have
    been reset by it and if those devices had the power.direct_complete
    flag set during the preceding suspend transition, they may stay
    in a reset-power-on state indefinitely (until they are runtime-resumed
    and then suspended again).  That may not be a big deal from the
    individual device's perspective, but if the system is an SoC, it may
    be prevented from entering deep SoC-wide low-power states on idle
    because of that.
    
    The devices that are most likely to be affected by this issue are
    PCI devices and ACPI-enumerated devices using the general ACPI PM
    domain, so to prevent it from happening for those devices, force a
    runtime resume for them if they have their power.direct_complete
    flags set and the platform firmware was involved in the resume
    transition currently in progress.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 4806b7f856c4..08a02cdc737c 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -962,23 +962,6 @@ int acpi_subsys_prepare(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_prepare);
 
-/**
- * acpi_subsys_complete - Finalize device's resume during system resume.
- * @dev: Device to handle.
- */
-void acpi_subsys_complete(struct device *dev)
-{
-	pm_generic_complete(dev);
-	/*
-	 * If the device had been runtime-suspended before the system went into
-	 * the sleep state it is going out of and it has never been resumed till
-	 * now, resume it in case the firmware powered it up.
-	 */
-	if (dev->power.direct_complete)
-		pm_request_resume(dev);
-}
-EXPORT_SYMBOL_GPL(acpi_subsys_complete);
-
 /**
  * acpi_subsys_suspend - Run the device driver's suspend callback.
  * @dev: Device to handle.
@@ -1047,7 +1030,7 @@ static struct dev_pm_domain acpi_general_pm_domain = {
 		.runtime_resume = acpi_subsys_runtime_resume,
 #ifdef CONFIG_PM_SLEEP
 		.prepare = acpi_subsys_prepare,
-		.complete = acpi_subsys_complete,
+		.complete = pm_complete_with_resume_check,
 		.suspend = acpi_subsys_suspend,
 		.suspend_late = acpi_subsys_suspend_late,
 		.resume_early = acpi_subsys_resume_early,

commit ef5f5de069bd9081a7ddf6998269b58fc65e27ef
Merge: 73990fc810bf e91a398c31ce
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 1 03:38:43 2015 +0200

    Merge branch 'acpi-pm'
    
    * acpi-pm:
      ACPI / bus: Move duplicate code to a separate new function
      mfd: Add support for Intel Sunrisepoint LPSS devices
      dmaengine: add a driver for Intel integrated DMA 64-bit
      mfd: make mfd_remove_devices() iterate in reverse order
      driver core: implement device_for_each_child_reverse()
      klist: implement klist_prev()
      Driver core: wakeup the parent device before trying probe
      ACPI / PM: Attach ACPI power domain only once
      PM / QoS: Make it possible to expose device latency tolerance to userspace
      ACPI / PM: Update the copyright notice and description of power.c

commit 73990fc810bf84c5338d9596f8af8d70fe90ac72
Merge: 94f2bb9b599f 1dcc3d3362b0 b6fc6072b126 10742619ac63
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 1 03:38:22 2015 +0200

    Merge branches 'acpi-scan', 'acpi-processor' and 'acpi-assorted'
    
    * acpi-scan:
      ACPI / bus: Move ACPI bus type registration
      ACPI / scan: Move bus operations and notification routines to bus.c
      ACPI / scan: Move device matching code to bus.c
      ACPI / scan: Move sysfs-related device code to a separate file
    
    * acpi-processor:
      PCC: Disable compilation by default
      ACPI: Decouple ACPI idle and ACPI processor drivers
      ACPI: Split out ACPI PSS from ACPI Processor driver
      PCC: Initialize PCC Mailbox earlier at boot
      ACPI / processor: remove leftover __refdata annotations
    
    * acpi-assorted:
      ACPI: fix acpi_debugfs_init prototype
      ACPI: Remove FSF mailing addresses

commit 50ba22479c324c0d9dc8134d519dcba92d83a8a7
Merge: 71b65445f0ed 3431e490b503
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 31 21:40:03 2015 +0200

    Merge back earlier ACPI PM material for v4.3.

commit 71b65445f0ed04c2afe3660f829779fddb2890c1
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Jul 28 13:51:21 2015 +0300

    ACPI / PM: Use target_state to set the device power state
    
    Commit 20dacb71ad28 ("ACPI / PM: Rework device power management to follow
    ACPI 6") changed the device power management to use D3hot if the device
    in question does not have _PR3 method even if D3cold was requested by the
    caller.
    
    However, if the device has _PR3 device->power.state is also set to D3hot
    instead of D3Cold after power resources have been turned off because
    device->power.state will be assigned from "state" instead of
    "target_state".
    
    Next time the device is transitioned to D0, acpi_power_transition() will
    find that the current power state of the device is D3hot instead of D3cold
    which causes it to power down all resources required for the current
    (wrong) state D3hot.
    
    Below is a simplified ASL example of a real touch panel device which
    triggers the problem:
    
      Scope (TPL1)
      {
          Name (_PR0, Package (1) { \_SB.PCI0.I2C1.PXTC })
          Name (_PR3, Package (1) { \_SB.PCI0.I2C1.PXTC })
          ...
      }
    
    In both D0 and D3hot the same power resource is required. However, when
    acpi_power_transition() turns off power resources required for D3hot (as
    the device is transitioned to D0) it powers down PXTC which then makes the
    device to lose its power.
    
    Fix this by assigning "target_state" to the device power state instead of
    "state" that is always D3hot even for devices with valid _PR3.
    
    Fixes: 20dacb71ad28 (ACPI / PM: Rework device power management to follow ACPI 6)
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 717afcdb5f4a..88dbbb115285 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -231,7 +231,7 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 		dev_warn(&device->dev, "Failed to change power state to %s\n",
 			 acpi_power_state_string(state));
 	} else {
-		device->power.state = state;
+		device->power.state = target_state;
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Device [%s] transitioned to %s\n",
 				  device->pnp.bus_id,

commit 712e960f0ee9337f3473ba3de2bcfc7e87b7c5a4
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Jul 27 18:03:57 2015 +0300

    ACPI / PM: Attach ACPI power domain only once
    
    Some devices, like MFD subdevices, share a single ACPI companion device so
    that they are able to access their resources and children. However,
    currently all these subdevices are attached to the ACPI power domain and
    this might cause that the power methods for the companion device get called
    more than once.
    
    In order to solve this we attach the ACPI power domain only to the first
    physical device that is bound to the ACPI companion device. In case of MFD
    devices, this is the parent MFD device itself.
    
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 717afcdb5f4a..08dc3ec7e892 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1123,6 +1123,14 @@ int acpi_dev_pm_attach(struct device *dev, bool power_on)
 	if (dev->pm_domain)
 		return -EEXIST;
 
+	/*
+	 * Only attach the power domain to the first device if the
+	 * companion is shared by multiple. This is to prevent doing power
+	 * management twice.
+	 */
+	if (!acpi_device_is_first_physical_node(adev, dev))
+		return -EBUSY;
+
 	acpi_add_pm_notifier(adev, dev, acpi_pm_notify_work_func);
 	dev->pm_domain = &acpi_general_pm_domain;
 	if (power_on) {

commit 4c62dbbce902cf2afa88cac89ec67c828160f431
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Jun 26 11:27:41 2015 +0300

    ACPI: Remove FSF mailing addresses
    
    There is no need to carry potentially outdated Free Software Foundation
    mailing address in file headers since the COPYING file includes it.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 717afcdb5f4a..d06cd59b5906 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -15,10 +15,6 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  *  General Public License for more details.
  *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 

commit 3d56402d3fa8d10749eeb36293dd1992bd5ad0c3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 10 01:32:38 2015 +0200

    ACPI / PM: Add missing pm_generic_complete() invocation
    
    Add missing invocation of pm_generic_complete() to
    acpi_subsys_complete() to allow ->complete callbacks provided
    by the drivers of devices using the ACPI PM domain to be executed
    during system resume.
    
    Fixes: f25c0ae2b4c4 (ACPI / PM: Avoid resuming devices in ACPI PM domain during system suspend)
    Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 87c16a5af748..717afcdb5f4a 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -972,6 +972,7 @@ EXPORT_SYMBOL_GPL(acpi_subsys_prepare);
  */
 void acpi_subsys_complete(struct device *dev)
 {
+	pm_generic_complete(dev);
 	/*
 	 * If the device had been runtime-suspended before the system went into
 	 * the sleep state it is going out of and it has never been resumed till

commit 20dacb71ad283b9506ee7e01286a424999fb8309
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat May 16 01:55:35 2015 +0200

    ACPI / PM: Rework device power management to follow ACPI 6
    
    The ACPI 6 specification has made some changes in the device power
    management area.  In particular:
    
     * The D3hot power state is now supposed to be always available
       (instead of D3cold) and D3cold is only regarded as valid if the
       _PR3 object is present for the given device.
    
     * The required ordering of transitions into power states deeper than
       D0 is now such that for a transition into state Dx the _PSx method
       is supposed to be executed first, if present, and the states of
       the power resources the device depends on are supposed to be
       changed after that.
    
     * It is now explicitly forbidden to transition devices from
       lower-power (deeper) into higher-power (shallower) power states
       other than D0.
    
    Those changes have been made so the specification reflects the
    Windows' device power management code that the vast majority of
    systems using ACPI is validated against.
    
    To avoid artificial differences in ACPI device power management
    between Windows and Linux, modify the ACPI device power management
    code to follow the new specification.  Add comments explaining the
    code flow in some unclear places.
    
    This only may affect some real corner cases in which the OS behavior
    expected by the firmware is different from the Windows one, but that's
    quite unlikely.  The transition ordering change affects transitions
    to D1 and D2 which are rarely used (if at all) and into D3hot and
    D3cold for devices actually having _PR3, but those are likely to
    be validated against Windows anyway.  The other changes may affect
    code calling acpi_device_get_power() or acpi_device_update_power()
    where ACPI_STATE_D3_HOT may be returned instead of ACPI_STATE_D3_COLD
    (that's why the ACPI fan driver needs to be updated too) and since
    transitions into ACPI_STATE_D3_HOT may remove power now, it is better
    to avoid this one in acpi_pm_device_sleep_state() if the "no power
    off" PM QoS flag is set.
    
    The only existing user of acpi_device_can_poweroff() really cares
    about the case when _PR3 is present, so the change in that function
    should not cause any problems to happen too.
    
    A plus is that PCI_D3hot can be mapped to ACPI_STATE_D3_HOT
    now and the compatibility with older systems should be covered
    automatically.
    
    In any case, if any real problems result from this, it still will
    be better to follow the Windows' behavior (which now is reflected
    by the specification too) in general and handle the cases when it
    doesn't work via quirks.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 735db11a9b00..87c16a5af748 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -98,17 +98,16 @@ int acpi_device_get_power(struct acpi_device *device, int *state)
 
 		/*
 		 * The power resources settings may indicate a power state
-		 * shallower than the actual power state of the device.
+		 * shallower than the actual power state of the device, because
+		 * the same power resources may be referenced by other devices.
 		 *
-		 * Moreover, on systems predating ACPI 4.0, if the device
-		 * doesn't depend on any power resources and _PSC returns 3,
-		 * that means "power off".  We need to maintain compatibility
-		 * with those systems.
+		 * For systems predating ACPI 4.0 we assume that D3hot is the
+		 * deepest state that can be supported.
 		 */
 		if (psc > result && psc < ACPI_STATE_D3_COLD)
 			result = psc;
 		else if (result == ACPI_STATE_UNKNOWN)
-			result = psc > ACPI_STATE_D2 ? ACPI_STATE_D3_COLD : psc;
+			result = psc > ACPI_STATE_D2 ? ACPI_STATE_D3_HOT : psc;
 	}
 
 	/*
@@ -153,8 +152,8 @@ static int acpi_dev_pm_explicit_set(struct acpi_device *adev, int state)
  */
 int acpi_device_set_power(struct acpi_device *device, int state)
 {
+	int target_state = state;
 	int result = 0;
-	bool cut_power = false;
 
 	if (!device || !device->flags.power_manageable
 	    || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3_COLD))
@@ -169,11 +168,21 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 		return 0;
 	}
 
-	if (!device->power.states[state].flags.valid) {
+	if (state == ACPI_STATE_D3_COLD) {
+		/*
+		 * For transitions to D3cold we need to execute _PS3 and then
+		 * possibly drop references to the power resources in use.
+		 */
+		state = ACPI_STATE_D3_HOT;
+		/* If _PR3 is not available, use D3hot as the target state. */
+		if (!device->power.states[ACPI_STATE_D3_COLD].flags.valid)
+			target_state = state;
+	} else if (!device->power.states[state].flags.valid) {
 		dev_warn(&device->dev, "Power state %s not supported\n",
 			 acpi_power_state_string(state));
 		return -ENODEV;
 	}
+
 	if (!device->power.flags.ignore_parent &&
 	    device->parent && (state < device->parent->power.state)) {
 		dev_warn(&device->dev,
@@ -183,39 +192,38 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 		return -ENODEV;
 	}
 
-	/* For D3cold we should first transition into D3hot. */
-	if (state == ACPI_STATE_D3_COLD
-	    && device->power.states[ACPI_STATE_D3_COLD].flags.os_accessible) {
-		state = ACPI_STATE_D3_HOT;
-		cut_power = true;
-	}
-
-	if (state < device->power.state && state != ACPI_STATE_D0
-	    && device->power.state >= ACPI_STATE_D3_HOT) {
-		dev_warn(&device->dev,
-			 "Cannot transition to non-D0 state from D3\n");
-		return -ENODEV;
-	}
-
 	/*
 	 * Transition Power
 	 * ----------------
-	 * In accordance with the ACPI specification first apply power (via
-	 * power resources) and then evaluate _PSx.
+	 * In accordance with ACPI 6, _PSx is executed before manipulating power
+	 * resources, unless the target state is D0, in which case _PS0 is
+	 * supposed to be executed after turning the power resources on.
 	 */
-	if (device->power.flags.power_resources) {
-		result = acpi_power_transition(device, state);
+	if (state > ACPI_STATE_D0) {
+		/*
+		 * According to ACPI 6, devices cannot go from lower-power
+		 * (deeper) states to higher-power (shallower) states.
+		 */
+		if (state < device->power.state) {
+			dev_warn(&device->dev, "Cannot transition from %s to %s\n",
+				 acpi_power_state_string(device->power.state),
+				 acpi_power_state_string(state));
+			return -ENODEV;
+		}
+
+		result = acpi_dev_pm_explicit_set(device, state);
 		if (result)
 			goto end;
-	}
-	result = acpi_dev_pm_explicit_set(device, state);
-	if (result)
-		goto end;
 
-	if (cut_power) {
-		device->power.state = state;
-		state = ACPI_STATE_D3_COLD;
-		result = acpi_power_transition(device, state);
+		if (device->power.flags.power_resources)
+			result = acpi_power_transition(device, target_state);
+	} else {
+		if (device->power.flags.power_resources) {
+			result = acpi_power_transition(device, ACPI_STATE_D0);
+			if (result)
+				goto end;
+		}
+		result = acpi_dev_pm_explicit_set(device, ACPI_STATE_D0);
 	}
 
  end:
@@ -264,13 +272,24 @@ int acpi_bus_init_power(struct acpi_device *device)
 		return result;
 
 	if (state < ACPI_STATE_D3_COLD && device->power.flags.power_resources) {
+		/* Reference count the power resources. */
 		result = acpi_power_on_resources(device, state);
 		if (result)
 			return result;
 
-		result = acpi_dev_pm_explicit_set(device, state);
-		if (result)
-			return result;
+		if (state == ACPI_STATE_D0) {
+			/*
+			 * If _PSC is not present and the state inferred from
+			 * power resources appears to be D0, it still may be
+			 * necessary to execute _PS0 at this point, because
+			 * another device using the same power resources may
+			 * have been put into D0 previously and that's why we
+			 * see D0 here.
+			 */
+			result = acpi_dev_pm_explicit_set(device, state);
+			if (result)
+				return result;
+		}
 	} else if (state == ACPI_STATE_UNKNOWN) {
 		/*
 		 * No power resources and missing _PSC?  Cross fingers and make
@@ -603,12 +622,12 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 	if (d_max_in < ACPI_STATE_D0 || d_max_in > ACPI_STATE_D3_COLD)
 		return -EINVAL;
 
-	if (d_max_in > ACPI_STATE_D3_HOT) {
+	if (d_max_in > ACPI_STATE_D2) {
 		enum pm_qos_flags_status stat;
 
 		stat = dev_pm_qos_flags(dev, PM_QOS_FLAG_NO_POWER_OFF);
 		if (stat == PM_QOS_FLAGS_ALL)
-			d_max_in = ACPI_STATE_D3_HOT;
+			d_max_in = ACPI_STATE_D2;
 	}
 
 	adev = ACPI_COMPANION(dev);

commit 8dcb52cbcadf7cbee62a7723f8a588a31281eccd
Author: Andreas Ruprecht <rupran@einserver.de>
Date:   Sun Feb 8 14:12:59 2015 +0100

    ACPI / PM: Remove unneeded nested #ifdef
    
    In commit 5de21bb998b8 ("ACPI / PM: Drop CONFIG_PM_RUNTIME from the
    ACPI core"), all occurrences of CONFIG_PM_RUNTIME were replaced with
    CONFIG_PM. This created the following structure of #ifdef blocks in
    the code:
    
     [...]
     #ifdef CONFIG_PM
     #ifdef CONFIG_PM
     /* always on / undead */
     #ifdef CONFIG_PM_SLEEP
     [...]
     #endif
     #endif
     [...]
     #endif
    
    This patch removes the inner "#ifdef CONFIG_PM" block as it will
    always be enabled when the outer block is enabled. This inconsistency
    was found using the undertaker-checkpatch tool.
    
    Signed-off-by: Andreas Ruprecht <rupran@einserver.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index c0d44d394ca3..735db11a9b00 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1027,7 +1027,6 @@ EXPORT_SYMBOL_GPL(acpi_subsys_freeze);
 
 static struct dev_pm_domain acpi_general_pm_domain = {
 	.ops = {
-#ifdef CONFIG_PM
 		.runtime_suspend = acpi_subsys_runtime_suspend,
 		.runtime_resume = acpi_subsys_runtime_resume,
 #ifdef CONFIG_PM_SLEEP
@@ -1040,7 +1039,6 @@ static struct dev_pm_domain acpi_general_pm_domain = {
 		.poweroff = acpi_subsys_suspend,
 		.poweroff_late = acpi_subsys_suspend_late,
 		.restore_early = acpi_subsys_resume_early,
-#endif
 #endif
 	},
 };

commit 1b1f3e1699a9886f1070f94171097ab4ccdbfc95
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 1 23:38:28 2015 +0100

    ACPI / PM: Fix PM initialization for devices that are not present
    
    If an ACPI device object whose _STA returns 0 (not present and not
    functional) has _PR0 or _PS0, its power_manageable flag will be set
    and acpi_bus_init_power() will return 0 for it.  Consequently, if
    such a device object is passed to the ACPI device PM functions, they
    will attempt to carry out the requested operation on the device,
    although they should not do that for devices that are not present.
    
    To fix that problem make acpi_bus_init_power() return an error code
    for devices that are not present which will cause power_manageable to
    be cleared for them as appropriate in acpi_bus_get_power_flags().
    However, the lists of power resources should not be freed for the
    device in that case, so modify acpi_bus_get_power_flags() to keep
    those lists even if acpi_bus_init_power() returns an error.
    Accordingly, when deciding whether or not the lists of power
    resources need to be freed, acpi_free_power_resources_lists()
    should check the power.flags.power_resources flag instead of
    flags.power_manageable, so make that change too.
    
    Furthermore, if acpi_bus_attach() sees that flags.initialized is
    unset for the given device, it should reset the power management
    settings of the device and re-initialize them from scratch instead
    of relying on the previous settings (the device may have appeared
    after being not present previously, for example), so make it use
    the 'valid' flag of the D0 power state as the initial value of
    flags.power_manageable for it and call acpi_bus_init_power() to
    discover its current power state.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: 3.10+ <stable@vger.kernel.org> # 3.10+

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index c2daa85fc9f7..c0d44d394ca3 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -257,7 +257,7 @@ int acpi_bus_init_power(struct acpi_device *device)
 
 	device->power.state = ACPI_STATE_UNKNOWN;
 	if (!acpi_device_is_present(device))
-		return 0;
+		return -ENXIO;
 
 	result = acpi_device_get_power(device, &state);
 	if (result)

commit be10f60d29433f712bf0887431efb80975e64438
Merge: ae5056e8573c 80167a24a274 c48cf1b9dd8f 175f8e2650f7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Dec 18 18:42:56 2014 +0100

    Merge branches 'acpi-scan', 'acpi-utils' and 'acpi-pm'
    
    * acpi-scan:
      ACPI / scan: Change the level of _DEP-related messages to KERN_DEBUG
    
    * acpi-utils:
      ACPI / utils: Drop error messages from acpi_evaluate_reference()
    
    * acpi-pm:
      ACPI / PM: Do not disable wakeup GPEs that have not been enabled

commit 175f8e2650f7ca6b33d338be3ccc1c00e89594ea
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 12 22:51:58 2014 +0100

    ACPI / PM: Do not disable wakeup GPEs that have not been enabled
    
    In some cases acpi_device_wakeup() may be called to ensure wakeup
    power to be off for a given device even though that device's wakeup
    GPE has not been enabled so far.  It calls acpi_disable_gpe() on a
    GPE that's not enabled and this causes ACPICA to return the AE_LIMIT
    status code from that call which then is reported as an error by the
    ACPICA's debug facilities (if enabled).  This may lead to a fair
    amount of confusion, so introduce a new ACPI device wakeup flag
    to store the wakeup GPE status and avoid disabling wakeup GPEs
    that have not been enabled.
    
    Reported-and-tested-by: Venkat Raghavulu <venkat.raghavulu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 076af8149566..e6ff33ecd784 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -680,13 +680,21 @@ static int acpi_device_wakeup(struct acpi_device *adev, u32 target_state,
 		if (error)
 			return error;
 
+		if (adev->wakeup.flags.enabled)
+			return 0;
+
 		res = acpi_enable_gpe(wakeup->gpe_device, wakeup->gpe_number);
-		if (ACPI_FAILURE(res)) {
+		if (ACPI_SUCCESS(res)) {
+			adev->wakeup.flags.enabled = 1;
+		} else {
 			acpi_disable_wakeup_device_power(adev);
 			return -EIO;
 		}
 	} else {
-		acpi_disable_gpe(wakeup->gpe_device, wakeup->gpe_number);
+		if (adev->wakeup.flags.enabled) {
+			acpi_disable_gpe(wakeup->gpe_device, wakeup->gpe_number);
+			adev->wakeup.flags.enabled = 0;
+		}
 		acpi_disable_wakeup_device_power(adev);
 	}
 	return 0;

commit e3d857e1ae787a5e268bc89425aadae09c8e95a4
Merge: cfc75ed68ba7 2713775bf570
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Dec 8 20:00:44 2014 +0100

    Merge branch 'pm-runtime'
    
    * pm-runtime: (25 commits)
      i2c-omap / PM: Drop CONFIG_PM_RUNTIME from i2c-omap.c
      dmaengine / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      drivers: sh / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      e1000e / igb / PM: Eliminate CONFIG_PM_RUNTIME
      MMC / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      MFD / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      misc / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      media / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      input / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      iio / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      hsi / OMAP / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      i2c-hid / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      drm / exynos / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      gpio / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      hwrandom / exynos / PM: Use CONFIG_PM in #ifdef
      block / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      USB / PM: Drop CONFIG_PM_RUNTIME from the USB core
      PM: Merge the SET*_RUNTIME_PM_OPS() macros
      PM / Kconfig: Do not select PM directly from Kconfig files
      PCI / PM: Drop CONFIG_PM_RUNTIME from the PCI core
      ...

commit 5de21bb998b8e816e6a1df1f2c04d95fb6e27a5d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 27 22:38:23 2014 +0100

    ACPI / PM: Drop CONFIG_PM_RUNTIME from the ACPI core
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so quite a few
    depend on CONFIG_PM.
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM in the ACPI core code.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 7db193160766..20c0a670c75a 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -692,7 +692,6 @@ static int acpi_device_wakeup(struct acpi_device *adev, u32 target_state,
 	return 0;
 }
 
-#ifdef CONFIG_PM_RUNTIME
 /**
  * acpi_pm_device_run_wake - Enable/disable remote wakeup for given device.
  * @dev: Device to enable/disable the platform to wake up.
@@ -714,7 +713,6 @@ int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
 	return acpi_device_wakeup(adev, ACPI_STATE_S0, enable);
 }
 EXPORT_SYMBOL(acpi_pm_device_run_wake);
-#endif /* CONFIG_PM_RUNTIME */
 
 #ifdef CONFIG_PM_SLEEP
 /**
@@ -773,7 +771,6 @@ static int acpi_dev_pm_full_power(struct acpi_device *adev)
 		acpi_device_set_power(adev, ACPI_STATE_D0) : 0;
 }
 
-#ifdef CONFIG_PM_RUNTIME
 /**
  * acpi_dev_runtime_suspend - Put device into a low-power state using ACPI.
  * @dev: Device to put into a low-power state.
@@ -855,7 +852,6 @@ int acpi_subsys_runtime_resume(struct device *dev)
 	return ret ? ret : pm_generic_runtime_resume(dev);
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_runtime_resume);
-#endif /* CONFIG_PM_RUNTIME */
 
 #ifdef CONFIG_PM_SLEEP
 /**
@@ -1023,10 +1019,9 @@ EXPORT_SYMBOL_GPL(acpi_subsys_freeze);
 
 static struct dev_pm_domain acpi_general_pm_domain = {
 	.ops = {
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 		.runtime_suspend = acpi_subsys_runtime_suspend,
 		.runtime_resume = acpi_subsys_runtime_resume,
-#endif
 #ifdef CONFIG_PM_SLEEP
 		.prepare = acpi_subsys_prepare,
 		.complete = acpi_subsys_complete,
@@ -1037,6 +1032,7 @@ static struct dev_pm_domain acpi_general_pm_domain = {
 		.poweroff = acpi_subsys_suspend,
 		.poweroff_late = acpi_subsys_suspend_late,
 		.restore_early = acpi_subsys_resume_early,
+#endif
 #endif
 	},
 };

commit 75f9c2939a157c77d8342c53d3d4f016d3b067a3
Author: Huang Rui <ray.huang@amd.com>
Date:   Mon Nov 24 19:56:38 2014 +0800

    ACPI / PM: Fixed a typo in a comment
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 7db193160766..076af8149566 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -201,7 +201,7 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 	 * Transition Power
 	 * ----------------
 	 * In accordance with the ACPI specification first apply power (via
-	 * power resources) and then evalute _PSx.
+	 * power resources) and then evaluate _PSx.
 	 */
 	if (device->power.flags.power_resources) {
 		result = acpi_power_transition(device, state);

commit 78579b7c7eb45f0e7ec5e9437087ed21749f9a9c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Nov 19 01:44:11 2014 +0100

    ACPI / PM: Ignore wakeup setting if the ACPI companion can't wake up
    
    As reported by Dmitry, on some Chromebooks there are devices with
    corresponding ACPI objects and with unusual system wakeup
    configuration.  Namely, they technically are wakeup-capable, but the
    wakeup is handled via a platform-specific out-of-band mechanism and
    the ACPI PM layer has no information on the wakeup capability.  As
    a result, device_may_wakeup(dev) called from acpi_dev_suspend_late()
    returns 'true' for those devices, but the wakeup.flags.valid flag is
    unset for the corresponding ACPI device objects, so acpi_device_wakeup()
    reproducibly fails for them causing acpi_dev_suspend_late() to return
    an error code.  The entire system suspend is then aborted and the
    machines in question cannot suspend at all.
    
    Address the problem by ignoring the device_may_wakeup(dev) return
    value in acpi_dev_suspend_late() if the ACPI companion of the device
    being handled has wakeup.flags.valid unset (in which case it is clear
    that the wakeup is supposed to be handled by other means).
    
    This fixes a regression introduced by commit a76e9bd89ae7 (i2c:
    attach/detach I2C client device to the ACPI power domain) as the
    affected systems could suspend and resume successfully before that
    commit.
    
    Fixes: a76e9bd89ae7 (i2c: attach/detach I2C client device to the ACPI power domain)
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Reviewed-by: Dmitry Torokhov <dtor@chromium.org>
    Cc: 3.13+ <stable@vger.kernel.org> # 3.13+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 143ec6ea1468..7db193160766 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -878,7 +878,7 @@ int acpi_dev_suspend_late(struct device *dev)
 		return 0;
 
 	target_state = acpi_target_system_state();
-	wakeup = device_may_wakeup(dev);
+	wakeup = device_may_wakeup(dev) && acpi_device_can_wakeup(adev);
 	error = acpi_device_wakeup(adev, target_state, wakeup);
 	if (wakeup && error)
 		return error;

commit 1c45d9a920e6ef4fce38921e4fc776c2abca3197
Merge: 8264fce6de03 a91e99e27a68
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 24 11:29:31 2014 -0700

    Merge tag 'pm+acpi-3.18-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "This is material that didn't make it to my 3.18-rc1 pull request for
      various reasons, mostly related to timing and travel (LinuxCon EU /
      LPC) plus a couple of fixes for recent bugs.
    
      The only really new thing here is the PM QoS class for memory
      bandwidth, but it is simple enough and users of it will be added in
      the next cycle.  One major change in behavior is that platform devices
      enumerated by ACPI will use 32-bit DMA mask by default.  Also included
      is an ACPICA update to a new upstream release, but that's mostly
      cleanups, changes in tools and similar.  The rest is fixes and
      cleanups mostly.
    
      Specifics:
    
       - Fix for a recent PCI power management change that overlooked the
         fact that some IRQ chips might not be able to configure PCIe PME
         for system wakeup from Lucas Stach.
    
       - Fix for a bug introduced in 3.17 where acpi_device_wakeup() is
         called with a wrong ordering of arguments from Zhang Rui.
    
       - A bunch of intel_pstate driver fixes (all -stable candidates) from
         Dirk Brandewie, Gabriele Mazzotta and Pali Rohr.
    
       - Fixes for a rather long-standing problem with the OOM killer and
         the freezer that frozen processes killed by the OOM do not actually
         release any memory until they are thawed, so OOM-killing them is
         rather pointless, with a couple of cleanups on top (Michal Hocko,
         Cong Wang, Rafael J Wysocki).
    
       - ACPICA update to upstream release 20140926, inlcuding mostly
         cleanups reducing differences between the upstream ACPICA and the
         kernel code, tools changes (acpidump, acpiexec) and support for the
         _DDN object (Bob Moore, Lv Zheng).
    
       - New PM QoS class for memory bandwidth from Tomeu Vizoso.
    
       - Default 32-bit DMA mask for platform devices enumerated by ACPI
         (this change is mostly needed for some drivers development in
         progress targeted at 3.19) from Heikki Krogerus.
    
       - ACPI EC driver cleanups, mostly related to debugging, from Lv
         Zheng.
    
       - cpufreq-dt driver updates from Thomas Petazzoni.
    
       - powernv cpuidle driver update from Preeti U Murthy"
    
    * tag 'pm+acpi-3.18-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (34 commits)
      intel_pstate: Correct BYT VID values.
      intel_pstate: Fix BYT frequency reporting
      intel_pstate: Don't lose sysfs settings during cpu offline
      cpufreq: intel_pstate: Reflect current no_turbo state correctly
      cpufreq: expose scaling_cur_freq sysfs file for set_policy() drivers
      cpufreq: intel_pstate: Fix setting max_perf_pct in performance policy
      PCI / PM: handle failure to enable wakeup on PCIe PME
      ACPI: invoke acpi_device_wakeup() with correct parameters
      PM / freezer: Clean up code after recent fixes
      PM: convert do_each_thread to for_each_process_thread
      OOM, PM: OOM killed task shouldn't escape PM suspend
      freezer: remove obsolete comments in __thaw_task()
      freezer: Do not freeze tasks killed by OOM killer
      ACPI / platform: provide default DMA mask
      cpuidle: powernv: Populate cpuidle state details by querying the device-tree
      cpufreq: cpufreq-dt: adjust message related to regulators
      cpufreq: cpufreq-dt: extend with platform_data
      cpufreq: allow driver-specific data
      ACPI / EC: Cleanup coding style.
      ACPI / EC: Refine event/query debugging messages.
      ...

commit 8264fce6de03f3915e2301f52f181a982718a8cb
Merge: 816fb4175c29 6ceaf58abe25
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 24 11:21:43 2014 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux
    
    Pull thermal management updates from Zhang Rui:
     "Sorry that I missed the merge window as there is a bug found in the
      last minute, and I have to fix it and wait for the code to be tested
      in linux-next tree for a few days.  Now the buggy patch has been
      dropped entirely from my next branch.  Thus I hope those changes can
      still be merged in 3.18-rc2 as most of them are platform thermal
      driver changes.
    
      Specifics:
    
       - introduce ACPI INT340X thermal drivers.
    
         Newer laptops and tablets may have thermal sensors and other
         devices with thermal control capabilities that are exposed for the
         OS to use via the ACPI INT340x device objects.  Several drivers are
         introduced to expose the temperature information and cooling
         ability from these objects to user-space via the normal thermal
         framework.
    
         From: Lu Aaron, Lan Tianyu, Jacob Pan and Zhang Rui.
    
       - introduce a new thermal governor, which just uses a hysteresis to
         switch abruptly on/off a cooling device.  This governor can be used
         to control certain fan devices that can not be throttled but just
         switched on or off.  From: Peter Feuerer.
    
       - introduce support for some new thermal interrupt functions on
         i.MX6SX, in IMX thermal driver.  From: Anson, Huang.
    
       - introduce tracing support on thermal framework.  From: Punit
         Agrawal.
    
       - small fixes in OF thermal and thermal step_wise governor"
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux: (25 commits)
      Thermal: int340x thermal: select ACPI fan driver
      Thermal: int3400_thermal: use acpi_thermal_rel parsing APIs
      Thermal: int340x_thermal: expose acpi thermal relationship tables
      Thermal: introduce int3403 thermal driver
      Thermal: introduce INT3402 thermal driver
      Thermal: move the KELVIN_TO_MILLICELSIUS macro to thermal.h
      ACPI / Fan: support INT3404 thermal device
      ACPI / Fan: add ACPI 4.0 style fan support
      ACPI / fan: convert to platform driver
      ACPI / fan: use acpi_device_xxx_power instead of acpi_bus equivelant
      ACPI / fan: remove no need check for device pointer
      ACPI / fan: remove unused macro
      Thermal: int3400 thermal: register to thermal framework
      Thermal: int3400 thermal: add capability to detect supporting UUIDs
      Thermal: introduce int3400 thermal driver
      ACPI: add ACPI_TYPE_LOCAL_REFERENCE support to acpi_extract_package()
      ACPI: make acpi_create_platform_device() an external API
      thermal: step_wise: fix: Prevent from binary overflow when trend is dropping
      ACPI: introduce ACPI int340x thermal scan handler
      thermal: Added Bang-bang thermal governor
      ...

commit 49fe0353689901b937ff21047a14d315bbbf78f3
Merge: 96ed753235c6 67598a1d3140 5dfd7f9f88ba
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 23 23:02:58 2014 +0200

    Merge branches 'acpi-pm' and 'pm-genirq'
    
    * acpi-pm:
      ACPI: invoke acpi_device_wakeup() with correct parameters
    
    * pm-genirq:
      PCI / PM: handle failure to enable wakeup on PCIe PME

commit 67598a1d3140a66f57aa6bcb8d22c4c2b7e910f5
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Thu Oct 23 20:20:00 2014 +0800

    ACPI: invoke acpi_device_wakeup() with correct parameters
    
    Fix a bug that invokes acpi_device_wakeup() with wrong parameters.
    
    Fixes: f35cec255557 (ACPI / PM: Always enable wakeup GPEs when enabling device wakeup)
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Cc: 3.17+ <stable@vger.kernel.org> # 3.17+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 67075f800e34..5e9cbd664286 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -710,7 +710,7 @@ int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
 		return -ENODEV;
 	}
 
-	return acpi_device_wakeup(adev, enable, ACPI_STATE_S0);
+	return acpi_device_wakeup(adev, ACPI_STATE_S0, enable);
 }
 EXPORT_SYMBOL(acpi_pm_device_run_wake);
 #endif /* CONFIG_PM_RUNTIME */

commit 2bb3a2bf9939f3361e25045f4ef7b136b864c3b8
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Tue Nov 19 15:43:52 2013 +0800

    ACPI / fan: use acpi_device_xxx_power instead of acpi_bus equivelant
    
    When we have the acpi_device pointer, there is no need to pass the
    device's handle to the acpi_bus_xxx_power functions to get/set/update
    the device's power state, instead, use the acpi_device_xxx_power
    functions directly.
    
    To make this happen for fan module, export acpi_device_update_power.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 67075f800e34..91775475e367 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -343,6 +343,7 @@ int acpi_device_update_power(struct acpi_device *device, int *state_p)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(acpi_device_update_power);
 
 int acpi_bus_update_power(acpi_handle handle, int *state_p)
 {

commit 91d66cd27f5fd8a3bca4621a3505c9067925478d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 19 20:27:44 2014 +0200

    ACPI / PM: Convert acpi_dev_pm_detach() into a static function
    
    The ->detach() callback for the PM domain has now been fully adopted,
    thus there no users left of the acpi_dev_pm_detach() API. This allow us
    to convert it into a static function.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index eec5ed5be949..bea6896be122 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1040,6 +1040,40 @@ static struct dev_pm_domain acpi_general_pm_domain = {
 	},
 };
 
+/**
+ * acpi_dev_pm_detach - Remove ACPI power management from the device.
+ * @dev: Device to take care of.
+ * @power_off: Whether or not to try to remove power from the device.
+ *
+ * Remove the device from the general ACPI PM domain and remove its wakeup
+ * notifier.  If @power_off is set, additionally remove power from the device if
+ * possible.
+ *
+ * Callers must ensure proper synchronization of this function with power
+ * management callbacks.
+ */
+static void acpi_dev_pm_detach(struct device *dev, bool power_off)
+{
+	struct acpi_device *adev = ACPI_COMPANION(dev);
+
+	if (adev && dev->pm_domain == &acpi_general_pm_domain) {
+		dev->pm_domain = NULL;
+		acpi_remove_pm_notifier(adev);
+		if (power_off) {
+			/*
+			 * If the device's PM QoS resume latency limit or flags
+			 * have been exposed to user space, they have to be
+			 * hidden at this point, so that they don't affect the
+			 * choice of the low-power state to put the device into.
+			 */
+			dev_pm_qos_hide_latency_limit(dev);
+			dev_pm_qos_hide_flags(dev);
+			acpi_device_wakeup(adev, ACPI_STATE_S0, false);
+			acpi_dev_pm_low_power(dev, adev, ACPI_STATE_S0);
+		}
+	}
+}
+
 /**
  * acpi_dev_pm_attach - Prepare device for ACPI power management.
  * @dev: Device to prepare.
@@ -1077,39 +1111,4 @@ int acpi_dev_pm_attach(struct device *dev, bool power_on)
 	return 0;
 }
 EXPORT_SYMBOL_GPL(acpi_dev_pm_attach);
-
-/**
- * acpi_dev_pm_detach - Remove ACPI power management from the device.
- * @dev: Device to take care of.
- * @power_off: Whether or not to try to remove power from the device.
- *
- * Remove the device from the general ACPI PM domain and remove its wakeup
- * notifier.  If @power_off is set, additionally remove power from the device if
- * possible.
- *
- * Callers must ensure proper synchronization of this function with power
- * management callbacks.
- */
-void acpi_dev_pm_detach(struct device *dev, bool power_off)
-{
-	struct acpi_device *adev = ACPI_COMPANION(dev);
-
-	if (adev && dev->pm_domain == &acpi_general_pm_domain) {
-		dev->pm_domain = NULL;
-		acpi_remove_pm_notifier(adev);
-		if (power_off) {
-			/*
-			 * If the device's PM QoS resume latency limit or flags
-			 * have been exposed to user space, they have to be
-			 * hidden at this point, so that they don't affect the
-			 * choice of the low-power state to put the device into.
-			 */
-			dev_pm_qos_hide_latency_limit(dev);
-			dev_pm_qos_hide_flags(dev);
-			acpi_device_wakeup(adev, ACPI_STATE_S0, false);
-			acpi_dev_pm_low_power(dev, adev, ACPI_STATE_S0);
-		}
-	}
-}
-EXPORT_SYMBOL_GPL(acpi_dev_pm_detach);
 #endif /* CONFIG_PM */

commit 86f1e15f5646b4855bd77025c950239650c4843e
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 19 20:27:35 2014 +0200

    ACPI / PM: Assign the ->detach() callback when attaching the PM domain
    
    As as preparation to simplify the detachment of devices from their PM
    domains, we assign the ->detach() callback to genpd_dev_pm_detach().
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 67075f800e34..eec5ed5be949 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1072,6 +1072,8 @@ int acpi_dev_pm_attach(struct device *dev, bool power_on)
 		acpi_dev_pm_full_power(adev);
 		acpi_device_wakeup(adev, ACPI_STATE_S0, false);
 	}
+
+	dev->pm_domain->detach = acpi_dev_pm_detach;
 	return 0;
 }
 EXPORT_SYMBOL_GPL(acpi_dev_pm_attach);

commit 17653a3e098dc20ae1db7459344a81c386625696
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 23 01:01:41 2014 +0200

    ACPI / PM: Use ACPI_COMPANION() instead of ACPI_HANDLE()
    
    The ACPI_HANDLE() macro evaluates ACPI_COMPANION() internally to
    return the handle of the device's ACPI companion, so it is much
    more straightforward and efficient to use ACPI_COMPANION()
    directly to obtain the device's ACPI companion object instead of
    using ACPI_HANDLE() and acpi_bus_get_device() on the returned
    handle for the same thing.
    
    Do that in three places in the ACPI device PM code.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index ad2810900799..67075f800e34 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -596,7 +596,6 @@ static int acpi_dev_pm_get_state(struct device *dev, struct acpi_device *adev,
  */
 int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 {
-	acpi_handle handle = ACPI_HANDLE(dev);
 	struct acpi_device *adev;
 	int ret, d_min, d_max;
 
@@ -611,8 +610,9 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 			d_max_in = ACPI_STATE_D3_HOT;
 	}
 
-	if (!handle || acpi_bus_get_device(handle, &adev)) {
-		dev_dbg(dev, "ACPI handle without context in %s!\n", __func__);
+	adev = ACPI_COMPANION(dev);
+	if (!adev) {
+		dev_dbg(dev, "ACPI companion missing in %s!\n", __func__);
 		return -ENODEV;
 	}
 
@@ -700,15 +700,13 @@ static int acpi_device_wakeup(struct acpi_device *adev, u32 target_state,
 int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
 {
 	struct acpi_device *adev;
-	acpi_handle handle;
 
 	if (!device_run_wake(phys_dev))
 		return -EINVAL;
 
-	handle = ACPI_HANDLE(phys_dev);
-	if (!handle || acpi_bus_get_device(handle, &adev)) {
-		dev_dbg(phys_dev, "ACPI handle without context in %s!\n",
-			__func__);
+	adev = ACPI_COMPANION(phys_dev);
+	if (!adev) {
+		dev_dbg(phys_dev, "ACPI companion missing in %s!\n", __func__);
 		return -ENODEV;
 	}
 
@@ -725,16 +723,15 @@ EXPORT_SYMBOL(acpi_pm_device_run_wake);
  */
 int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
 {
-	acpi_handle handle;
 	struct acpi_device *adev;
 	int error;
 
 	if (!device_can_wakeup(dev))
 		return -EINVAL;
 
-	handle = ACPI_HANDLE(dev);
-	if (!handle || acpi_bus_get_device(handle, &adev)) {
-		dev_dbg(dev, "ACPI handle without context in %s!\n", __func__);
+	adev = ACPI_COMPANION(dev);
+	if (!adev) {
+		dev_dbg(dev, "ACPI companion missing in %s!\n", __func__);
 		return -ENODEV;
 	}
 

commit f35cec255557d1037ff0d772edfd6e7b1e92cdc0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 23 01:00:53 2014 +0200

    ACPI / PM: Always enable wakeup GPEs when enabling device wakeup
    
    Wakeup GPEs are currently only enabled when setting up devices for
    remote wakeup at run time.  During system-wide transitions they are
    enabled by ACPICA at the very last stage of suspend (before asking
    the BIOS to take over).  Of course, that only works for system
    sleep states supported by ACPI, so in particular it doesn't work
    for the "freeze" sleep state.
    
    For this reason, modify the ACPI core device PM code to enable wakeup
    GPEs for devices when setting them up for wakeup regardless of whether
    that is remote wakeup at runtime or system wakeup.  That allows the
    same device wakeup setup routine to be used for both runtime PM and
    system-wide PM and makes it possible to reduce code size quite a bit.
    
    This make ACPI-based PCI Wake-on-LAN work with the "freeze" sleep
    state on my venerable Toshiba Portege R500 and should help other
    systems too.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 366de0b0c39b..ad2810900799 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -638,7 +638,6 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 }
 EXPORT_SYMBOL(acpi_pm_device_sleep_state);
 
-#ifdef CONFIG_PM_RUNTIME
 /**
  * acpi_pm_notify_work_func - ACPI devices wakeup notification work function.
  * @work: Work item to handle.
@@ -655,8 +654,9 @@ static void acpi_pm_notify_work_func(struct work_struct *work)
 }
 
 /**
- * __acpi_device_run_wake - Enable/disable runtime remote wakeup for device.
- * @adev: ACPI device to enable/disable the remote wakeup for.
+ * acpi_device_wakeup - Enable/disable wakeup functionality for device.
+ * @adev: ACPI device to enable/disable wakeup functionality for.
+ * @target_state: State the system is transitioning into.
  * @enable: Whether to enable or disable the wakeup functionality.
  *
  * Enable/disable the GPE associated with @adev so that it can generate
@@ -666,7 +666,8 @@ static void acpi_pm_notify_work_func(struct work_struct *work)
  * Callers must ensure that @adev is a valid ACPI device node before executing
  * this function.
  */
-int __acpi_device_run_wake(struct acpi_device *adev, bool enable)
+static int acpi_device_wakeup(struct acpi_device *adev, u32 target_state,
+			      bool enable)
 {
 	struct acpi_device_wakeup *wakeup = &adev->wakeup;
 
@@ -674,7 +675,7 @@ int __acpi_device_run_wake(struct acpi_device *adev, bool enable)
 		acpi_status res;
 		int error;
 
-		error = acpi_enable_wakeup_device_power(adev, ACPI_STATE_S0);
+		error = acpi_enable_wakeup_device_power(adev, target_state);
 		if (error)
 			return error;
 
@@ -690,6 +691,7 @@ int __acpi_device_run_wake(struct acpi_device *adev, bool enable)
 	return 0;
 }
 
+#ifdef CONFIG_PM_RUNTIME
 /**
  * acpi_pm_device_run_wake - Enable/disable remote wakeup for given device.
  * @dev: Device to enable/disable the platform to wake up.
@@ -710,28 +712,12 @@ int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
 		return -ENODEV;
 	}
 
-	return __acpi_device_run_wake(adev, enable);
+	return acpi_device_wakeup(adev, enable, ACPI_STATE_S0);
 }
 EXPORT_SYMBOL(acpi_pm_device_run_wake);
-#else
-static inline void acpi_pm_notify_work_func(struct work_struct *work) {}
 #endif /* CONFIG_PM_RUNTIME */
 
 #ifdef CONFIG_PM_SLEEP
-/**
- * __acpi_device_sleep_wake - Enable or disable device to wake up the system.
- * @dev: Device to enable/desible to wake up the system.
- * @target_state: System state the device is supposed to wake up from.
- * @enable: Whether to enable or disable @dev to wake up the system.
- */
-int __acpi_device_sleep_wake(struct acpi_device *adev, u32 target_state,
-			     bool enable)
-{
-	return enable ?
-		acpi_enable_wakeup_device_power(adev, target_state) :
-		acpi_disable_wakeup_device_power(adev);
-}
-
 /**
  * acpi_pm_device_sleep_wake - Enable or disable device to wake up the system.
  * @dev: Device to enable/desible to wake up the system from sleep states.
@@ -752,8 +738,7 @@ int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
 		return -ENODEV;
 	}
 
-	error = __acpi_device_sleep_wake(adev, acpi_target_system_state(),
-					 enable);
+	error = acpi_device_wakeup(adev, acpi_target_system_state(), enable);
 	if (!error)
 		dev_info(dev, "System wakeup %s by ACPI\n",
 				enable ? "enabled" : "disabled");
@@ -811,13 +796,13 @@ int acpi_dev_runtime_suspend(struct device *dev)
 
 	remote_wakeup = dev_pm_qos_flags(dev, PM_QOS_FLAG_REMOTE_WAKEUP) >
 				PM_QOS_FLAGS_NONE;
-	error = __acpi_device_run_wake(adev, remote_wakeup);
+	error = acpi_device_wakeup(adev, ACPI_STATE_S0, remote_wakeup);
 	if (remote_wakeup && error)
 		return -EAGAIN;
 
 	error = acpi_dev_pm_low_power(dev, adev, ACPI_STATE_S0);
 	if (error)
-		__acpi_device_run_wake(adev, false);
+		acpi_device_wakeup(adev, ACPI_STATE_S0, false);
 
 	return error;
 }
@@ -840,7 +825,7 @@ int acpi_dev_runtime_resume(struct device *dev)
 		return 0;
 
 	error = acpi_dev_pm_full_power(adev);
-	__acpi_device_run_wake(adev, false);
+	acpi_device_wakeup(adev, ACPI_STATE_S0, false);
 	return error;
 }
 EXPORT_SYMBOL_GPL(acpi_dev_runtime_resume);
@@ -896,13 +881,13 @@ int acpi_dev_suspend_late(struct device *dev)
 
 	target_state = acpi_target_system_state();
 	wakeup = device_may_wakeup(dev);
-	error = __acpi_device_sleep_wake(adev, target_state, wakeup);
+	error = acpi_device_wakeup(adev, target_state, wakeup);
 	if (wakeup && error)
 		return error;
 
 	error = acpi_dev_pm_low_power(dev, adev, target_state);
 	if (error)
-		__acpi_device_sleep_wake(adev, ACPI_STATE_UNKNOWN, false);
+		acpi_device_wakeup(adev, ACPI_STATE_UNKNOWN, false);
 
 	return error;
 }
@@ -925,7 +910,7 @@ int acpi_dev_resume_early(struct device *dev)
 		return 0;
 
 	error = acpi_dev_pm_full_power(adev);
-	__acpi_device_sleep_wake(adev, ACPI_STATE_UNKNOWN, false);
+	acpi_device_wakeup(adev, ACPI_STATE_UNKNOWN, false);
 	return error;
 }
 EXPORT_SYMBOL_GPL(acpi_dev_resume_early);
@@ -1088,7 +1073,7 @@ int acpi_dev_pm_attach(struct device *dev, bool power_on)
 	dev->pm_domain = &acpi_general_pm_domain;
 	if (power_on) {
 		acpi_dev_pm_full_power(adev);
-		__acpi_device_run_wake(adev, false);
+		acpi_device_wakeup(adev, ACPI_STATE_S0, false);
 	}
 	return 0;
 }
@@ -1122,7 +1107,7 @@ void acpi_dev_pm_detach(struct device *dev, bool power_off)
 			 */
 			dev_pm_qos_hide_latency_limit(dev);
 			dev_pm_qos_hide_flags(dev);
-			__acpi_device_run_wake(adev, false);
+			acpi_device_wakeup(adev, ACPI_STATE_S0, false);
 			acpi_dev_pm_low_power(dev, adev, ACPI_STATE_S0);
 		}
 	}

commit c072530f391e33bd22ed0638c08f07528f154493
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 23 01:00:45 2014 +0200

    ACPI / PM: Revork the handling of ACPI device wakeup notifications
    
    Since ACPI wakeup GPEs are going to be enabled during system suspend
    as well as for runtime wakeup by a subsequent patch and the same
    notify handlers will be used in both cases, rework the ACPI device
    wakeup notification framework so that the part specific to physical
    devices is always run asynchronously from the PM workqueue.  This
    prevents runtime resume callbacks for those devices from being
    run during system suspend and resume which may not be appropriate,
    among other things.
    
    Also make ACPI device wakeup notification handling a bit more robust
    agaist subsequent removal of ACPI device objects, whould that ever
    happen, and create a wakeup source object for each ACPI device
    configured for wakeup so that wakeup notifications for those
    devices can wake up the system from the "freeze" sleep state.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 49a51277f81d..366de0b0c39b 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -367,29 +367,61 @@ EXPORT_SYMBOL(acpi_bus_power_manageable);
 #ifdef CONFIG_PM
 static DEFINE_MUTEX(acpi_pm_notifier_lock);
 
+static void acpi_pm_notify_handler(acpi_handle handle, u32 val, void *not_used)
+{
+	struct acpi_device *adev;
+
+	if (val != ACPI_NOTIFY_DEVICE_WAKE)
+		return;
+
+	adev = acpi_bus_get_acpi_device(handle);
+	if (!adev)
+		return;
+
+	mutex_lock(&acpi_pm_notifier_lock);
+
+	if (adev->wakeup.flags.notifier_present) {
+		__pm_wakeup_event(adev->wakeup.ws, 0);
+		if (adev->wakeup.context.work.func)
+			queue_pm_work(&adev->wakeup.context.work);
+	}
+
+	mutex_unlock(&acpi_pm_notifier_lock);
+
+	acpi_bus_put_acpi_device(adev);
+}
+
 /**
- * acpi_add_pm_notifier - Register PM notifier for given ACPI device.
- * @adev: ACPI device to add the notifier for.
- * @context: Context information to pass to the notifier routine.
+ * acpi_add_pm_notifier - Register PM notify handler for given ACPI device.
+ * @adev: ACPI device to add the notify handler for.
+ * @dev: Device to generate a wakeup event for while handling the notification.
+ * @work_func: Work function to execute when handling the notification.
  *
  * NOTE: @adev need not be a run-wake or wakeup device to be a valid source of
  * PM wakeup events.  For example, wakeup events may be generated for bridges
  * if one of the devices below the bridge is signaling wakeup, even if the
  * bridge itself doesn't have a wakeup GPE associated with it.
  */
-acpi_status acpi_add_pm_notifier(struct acpi_device *adev,
-				 acpi_notify_handler handler, void *context)
+acpi_status acpi_add_pm_notifier(struct acpi_device *adev, struct device *dev,
+				 void (*work_func)(struct work_struct *work))
 {
 	acpi_status status = AE_ALREADY_EXISTS;
 
+	if (!dev && !work_func)
+		return AE_BAD_PARAMETER;
+
 	mutex_lock(&acpi_pm_notifier_lock);
 
 	if (adev->wakeup.flags.notifier_present)
 		goto out;
 
-	status = acpi_install_notify_handler(adev->handle,
-					     ACPI_SYSTEM_NOTIFY,
-					     handler, context);
+	adev->wakeup.ws = wakeup_source_register(dev_name(&adev->dev));
+	adev->wakeup.context.dev = dev;
+	if (work_func)
+		INIT_WORK(&adev->wakeup.context.work, work_func);
+
+	status = acpi_install_notify_handler(adev->handle, ACPI_SYSTEM_NOTIFY,
+					     acpi_pm_notify_handler, NULL);
 	if (ACPI_FAILURE(status))
 		goto out;
 
@@ -404,8 +436,7 @@ acpi_status acpi_add_pm_notifier(struct acpi_device *adev,
  * acpi_remove_pm_notifier - Unregister PM notifier from given ACPI device.
  * @adev: ACPI device to remove the notifier from.
  */
-acpi_status acpi_remove_pm_notifier(struct acpi_device *adev,
-				    acpi_notify_handler handler)
+acpi_status acpi_remove_pm_notifier(struct acpi_device *adev)
 {
 	acpi_status status = AE_BAD_PARAMETER;
 
@@ -416,10 +447,17 @@ acpi_status acpi_remove_pm_notifier(struct acpi_device *adev,
 
 	status = acpi_remove_notify_handler(adev->handle,
 					    ACPI_SYSTEM_NOTIFY,
-					    handler);
+					    acpi_pm_notify_handler);
 	if (ACPI_FAILURE(status))
 		goto out;
 
+	if (adev->wakeup.context.work.func) {
+		cancel_work_sync(&adev->wakeup.context.work);
+		adev->wakeup.context.work.func = NULL;
+	}
+	adev->wakeup.context.dev = NULL;
+	wakeup_source_unregister(adev->wakeup.ws);
+
 	adev->wakeup.flags.notifier_present = false;
 
  out:
@@ -602,16 +640,15 @@ EXPORT_SYMBOL(acpi_pm_device_sleep_state);
 
 #ifdef CONFIG_PM_RUNTIME
 /**
- * acpi_wakeup_device - Wakeup notification handler for ACPI devices.
- * @handle: ACPI handle of the device the notification is for.
- * @event: Type of the signaled event.
- * @context: Device corresponding to @handle.
+ * acpi_pm_notify_work_func - ACPI devices wakeup notification work function.
+ * @work: Work item to handle.
  */
-static void acpi_wakeup_device(acpi_handle handle, u32 event, void *context)
+static void acpi_pm_notify_work_func(struct work_struct *work)
 {
-	struct device *dev = context;
+	struct device *dev;
 
-	if (event == ACPI_NOTIFY_DEVICE_WAKE && dev) {
+	dev = container_of(work, struct acpi_device_wakeup_context, work)->dev;
+	if (dev) {
 		pm_wakeup_event(dev, 0);
 		pm_runtime_resume(dev);
 	}
@@ -677,8 +714,7 @@ int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
 }
 EXPORT_SYMBOL(acpi_pm_device_run_wake);
 #else
-static inline void acpi_wakeup_device(acpi_handle handle, u32 event,
-				      void *context) {}
+static inline void acpi_pm_notify_work_func(struct work_struct *work) {}
 #endif /* CONFIG_PM_RUNTIME */
 
 #ifdef CONFIG_PM_SLEEP
@@ -1048,7 +1084,7 @@ int acpi_dev_pm_attach(struct device *dev, bool power_on)
 	if (dev->pm_domain)
 		return -EEXIST;
 
-	acpi_add_pm_notifier(adev, acpi_wakeup_device, dev);
+	acpi_add_pm_notifier(adev, dev, acpi_pm_notify_work_func);
 	dev->pm_domain = &acpi_general_pm_domain;
 	if (power_on) {
 		acpi_dev_pm_full_power(adev);
@@ -1076,7 +1112,7 @@ void acpi_dev_pm_detach(struct device *dev, bool power_off)
 
 	if (adev && dev->pm_domain == &acpi_general_pm_domain) {
 		dev->pm_domain = NULL;
-		acpi_remove_pm_notifier(adev, acpi_wakeup_device);
+		acpi_remove_pm_notifier(adev);
 		if (power_off) {
 			/*
 			 * If the device's PM QoS resume latency limit or flags

commit 4cf563c5d97c83d4b2fb3a778dd7d5e362cc3e34
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Thu May 15 16:40:23 2014 +0300

    ACPI / PM: Export rest of the subsys PM callbacks
    
    No reason for excluding the remaining ones.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    [rjw: Rebased and exported the new acpi_subsys_complete() too.]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 9e5fd9c440b7..49a51277f81d 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -928,7 +928,7 @@ EXPORT_SYMBOL_GPL(acpi_subsys_prepare);
  * acpi_subsys_complete - Finalize device's resume during system resume.
  * @dev: Device to handle.
  */
-static void acpi_subsys_complete(struct device *dev)
+void acpi_subsys_complete(struct device *dev)
 {
 	/*
 	 * If the device had been runtime-suspended before the system went into
@@ -938,6 +938,7 @@ static void acpi_subsys_complete(struct device *dev)
 	if (dev->power.direct_complete)
 		pm_request_resume(dev);
 }
+EXPORT_SYMBOL_GPL(acpi_subsys_complete);
 
 /**
  * acpi_subsys_suspend - Run the device driver's suspend callback.
@@ -951,6 +952,7 @@ int acpi_subsys_suspend(struct device *dev)
 	pm_runtime_resume(dev);
 	return pm_generic_suspend(dev);
 }
+EXPORT_SYMBOL_GPL(acpi_subsys_suspend);
 
 /**
  * acpi_subsys_suspend_late - Suspend device using ACPI.
@@ -996,6 +998,7 @@ int acpi_subsys_freeze(struct device *dev)
 	pm_runtime_resume(dev);
 	return pm_generic_freeze(dev);
 }
+EXPORT_SYMBOL_GPL(acpi_subsys_freeze);
 
 #endif /* CONFIG_PM_SLEEP */
 

commit f25c0ae2b4c41996c1a6b609132c1788a6eea080
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat May 17 00:18:13 2014 +0200

    ACPI / PM: Avoid resuming devices in ACPI PM domain during system suspend
    
    Rework the ACPI PM domain's PM callbacks to avoid resuming devices
    during system suspend (in order to modify their wakeup settings etc.)
    if that isn't necessary.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index d047739f3380..9e5fd9c440b7 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -900,17 +900,45 @@ EXPORT_SYMBOL_GPL(acpi_dev_resume_early);
  */
 int acpi_subsys_prepare(struct device *dev)
 {
-	/*
-	 * Devices having power.ignore_children set may still be necessary for
-	 * suspending their children in the next phase of device suspend.
-	 */
-	if (dev->power.ignore_children)
-		pm_runtime_resume(dev);
+	struct acpi_device *adev = ACPI_COMPANION(dev);
+	u32 sys_target;
+	int ret, state;
+
+	ret = pm_generic_prepare(dev);
+	if (ret < 0)
+		return ret;
+
+	if (!adev || !pm_runtime_suspended(dev)
+	    || device_may_wakeup(dev) != !!adev->wakeup.prepare_count)
+		return 0;
+
+	sys_target = acpi_target_system_state();
+	if (sys_target == ACPI_STATE_S0)
+		return 1;
 
-	return pm_generic_prepare(dev);
+	if (adev->power.flags.dsw_present)
+		return 0;
+
+	ret = acpi_dev_pm_get_state(dev, adev, sys_target, NULL, &state);
+	return !ret && state == adev->power.state;
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_prepare);
 
+/**
+ * acpi_subsys_complete - Finalize device's resume during system resume.
+ * @dev: Device to handle.
+ */
+static void acpi_subsys_complete(struct device *dev)
+{
+	/*
+	 * If the device had been runtime-suspended before the system went into
+	 * the sleep state it is going out of and it has never been resumed till
+	 * now, resume it in case the firmware powered it up.
+	 */
+	if (dev->power.direct_complete)
+		pm_request_resume(dev);
+}
+
 /**
  * acpi_subsys_suspend - Run the device driver's suspend callback.
  * @dev: Device to handle.
@@ -979,6 +1007,7 @@ static struct dev_pm_domain acpi_general_pm_domain = {
 #endif
 #ifdef CONFIG_PM_SLEEP
 		.prepare = acpi_subsys_prepare,
+		.complete = acpi_subsys_complete,
 		.suspend = acpi_subsys_suspend,
 		.suspend_late = acpi_subsys_suspend_late,
 		.resume_early = acpi_subsys_resume_early,

commit 92858c476ec4e99cf0425f05dee109b6a55eb6f8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 26 01:00:19 2014 +0100

    ACPI / PM: Resume runtime-suspended devices later during system suspend
    
    Runtime-suspended devices are resumed during system suspend by
    acpi_subsys_prepare() for two reasons: First, because they may need
    to be reprogrammed in order to change their wakeup settings and,
    second, because they may need to be operatonal for their children
    to be successfully suspended.  That is a problem, though, if there
    are many runtime-suspended devices that need to be resumed this
    way during system suspend, because the .prepare() PM callbacks of
    devices are executed sequentially and the times taken by them
    accumulate, which may increase the total system suspend time quite
    a bit.
    
    For this reason, move the resume of runtime-suspended devices up
    to the next phase of device suspend (during system suspend), except
    for the ones that have power.ignore_children set.  The exception is
    made, because the devices with power.ignore_children set may still
    be necessary for their children to be successfully suspended (during
    system suspend) and they won't be resumed automatically as a result
    of the runtime resume of their children.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index c14a00d3dca6..d047739f3380 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -901,14 +901,29 @@ EXPORT_SYMBOL_GPL(acpi_dev_resume_early);
 int acpi_subsys_prepare(struct device *dev)
 {
 	/*
-	 * Follow PCI and resume devices suspended at run time before running
-	 * their system suspend callbacks.
+	 * Devices having power.ignore_children set may still be necessary for
+	 * suspending their children in the next phase of device suspend.
 	 */
-	pm_runtime_resume(dev);
+	if (dev->power.ignore_children)
+		pm_runtime_resume(dev);
+
 	return pm_generic_prepare(dev);
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_prepare);
 
+/**
+ * acpi_subsys_suspend - Run the device driver's suspend callback.
+ * @dev: Device to handle.
+ *
+ * Follow PCI and resume devices suspended at run time before running their
+ * system suspend callbacks.
+ */
+int acpi_subsys_suspend(struct device *dev)
+{
+	pm_runtime_resume(dev);
+	return pm_generic_suspend(dev);
+}
+
 /**
  * acpi_subsys_suspend_late - Suspend device using ACPI.
  * @dev: Device to suspend.
@@ -937,6 +952,23 @@ int acpi_subsys_resume_early(struct device *dev)
 	return ret ? ret : pm_generic_resume_early(dev);
 }
 EXPORT_SYMBOL_GPL(acpi_subsys_resume_early);
+
+/**
+ * acpi_subsys_freeze - Run the device driver's freeze callback.
+ * @dev: Device to handle.
+ */
+int acpi_subsys_freeze(struct device *dev)
+{
+	/*
+	 * This used to be done in acpi_subsys_prepare() for all devices and
+	 * some drivers may depend on it, so do it here.  Ideally, however,
+	 * runtime-suspended devices should not be touched during freeze/thaw
+	 * transitions.
+	 */
+	pm_runtime_resume(dev);
+	return pm_generic_freeze(dev);
+}
+
 #endif /* CONFIG_PM_SLEEP */
 
 static struct dev_pm_domain acpi_general_pm_domain = {
@@ -947,8 +979,11 @@ static struct dev_pm_domain acpi_general_pm_domain = {
 #endif
 #ifdef CONFIG_PM_SLEEP
 		.prepare = acpi_subsys_prepare,
+		.suspend = acpi_subsys_suspend,
 		.suspend_late = acpi_subsys_suspend_late,
 		.resume_early = acpi_subsys_resume_early,
+		.freeze = acpi_subsys_freeze,
+		.poweroff = acpi_subsys_suspend,
 		.poweroff_late = acpi_subsys_suspend_late,
 		.restore_early = acpi_subsys_resume_early,
 #endif

commit 82e180598b54873553fb1d285fb0c90fc54f8f23
Merge: 09da8dfa9868 f778d1218f10 a951c773bc39 49a12877d277 79c0373f3e84 481c13814a4e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 29 11:47:18 2014 +0100

    Merge branches 'acpi-processor', 'acpi-hotplug', 'acpi-init', 'acpi-pm' and 'acpica'
    
    * acpi-processor:
      ACPI / scan: reduce log level of "ACPI: \_PR_.CPU4: failed to get CPU APIC ID"
      ACPI / processor: Return specific error value when mapping lapic id
    
    * acpi-hotplug:
      ACPI / scan: Clear match_driver flag in acpi_bus_trim()
    
    * acpi-init:
      ACPI / init: Flag use of ACPI and ACPI idioms for power supplies to regulator API
    
    * acpi-pm:
      ACPI / PM: Use ACPI_COMPANION() to get ACPI companions of devices
    
    * acpica:
      ACPICA: Remove bool usage from ACPICA.

commit 79c0373f3e847309f4f33d23f2bf088ee3b1ac34
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jan 27 23:10:24 2014 +0100

    ACPI / PM: Use ACPI_COMPANION() to get ACPI companions of devices
    
    The ACPI device PM code in device_pm.c uses a special function,
    acpi_dev_pm_get_node(), to obtain an ACPI companion object of a given
    device.  However, that is not necessary any more after recent changes
    that introduced the ACPI_COMPANION() macro serving exactly the same
    purpose, but working in a much more straightforward way.  For this
    reason, drop acpi_dev_pm_get_node() and use ACPI_COMPANION() instead
    of it everywhere.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index b3480cf7db1a..c14aa9a8a1b9 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -712,18 +712,6 @@ int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
 }
 #endif /* CONFIG_PM_SLEEP */
 
-/**
- * acpi_dev_pm_get_node - Get ACPI device node for the given physical device.
- * @dev: Device to get the ACPI node for.
- */
-struct acpi_device *acpi_dev_pm_get_node(struct device *dev)
-{
-	acpi_handle handle = ACPI_HANDLE(dev);
-	struct acpi_device *adev;
-
-	return handle && !acpi_bus_get_device(handle, &adev) ? adev : NULL;
-}
-
 /**
  * acpi_dev_pm_low_power - Put ACPI device into a low-power state.
  * @dev: Device to put into a low-power state.
@@ -764,7 +752,7 @@ static int acpi_dev_pm_full_power(struct acpi_device *adev)
  */
 int acpi_dev_runtime_suspend(struct device *dev)
 {
-	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
+	struct acpi_device *adev = ACPI_COMPANION(dev);
 	bool remote_wakeup;
 	int error;
 
@@ -795,7 +783,7 @@ EXPORT_SYMBOL_GPL(acpi_dev_runtime_suspend);
  */
 int acpi_dev_runtime_resume(struct device *dev)
 {
-	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
+	struct acpi_device *adev = ACPI_COMPANION(dev);
 	int error;
 
 	if (!adev)
@@ -848,7 +836,7 @@ EXPORT_SYMBOL_GPL(acpi_subsys_runtime_resume);
  */
 int acpi_dev_suspend_late(struct device *dev)
 {
-	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
+	struct acpi_device *adev = ACPI_COMPANION(dev);
 	u32 target_state;
 	bool wakeup;
 	int error;
@@ -880,7 +868,7 @@ EXPORT_SYMBOL_GPL(acpi_dev_suspend_late);
  */
 int acpi_dev_resume_early(struct device *dev)
 {
-	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
+	struct acpi_device *adev = ACPI_COMPANION(dev);
 	int error;
 
 	if (!adev)
@@ -971,7 +959,7 @@ static struct dev_pm_domain acpi_general_pm_domain = {
  */
 int acpi_dev_pm_attach(struct device *dev, bool power_on)
 {
-	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
+	struct acpi_device *adev = ACPI_COMPANION(dev);
 
 	if (!adev)
 		return -ENODEV;
@@ -1003,7 +991,7 @@ EXPORT_SYMBOL_GPL(acpi_dev_pm_attach);
  */
 void acpi_dev_pm_detach(struct device *dev, bool power_off)
 {
-	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
+	struct acpi_device *adev = ACPI_COMPANION(dev);
 
 	if (adev && dev->pm_domain == &acpi_general_pm_domain) {
 		dev->pm_domain = NULL;

commit 202317a573b20d77a9abb7c16a3fd5b40cef3d9d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 22 21:54:37 2013 +0100

    ACPI / scan: Add acpi_device objects for all device nodes in the namespace
    
    Modify the ACPI namespace scanning code to register a struct
    acpi_device object for every namespace node representing a device,
    processor and so on, even if the device represented by that namespace
    node is reported to be not present and not functional by _STA.
    
    There are multiple reasons to do that.  First of all, it avoids
    quite a lot of overhead when struct acpi_device objects are
    deleted every time acpi_bus_trim() is run and then added again
    by a subsequent acpi_bus_scan() for the same scope, although the
    namespace objects they correspond to stay in memory all the time
    (which always is the case on a vast majority of systems).
    
    Second, it will allow user space to see that there are namespace
    nodes representing devices that are not present at the moment and may
    be added to the system.  It will also allow user space to evaluate
    _SUN for those nodes to check what physical slots the "missing"
    devices may be put into and it will make sense to add a sysfs
    attribute for _STA evaluation after this change (that will be
    useful for thermal management on some systems).
    
    Next, it will help to consolidate the ACPI hotplug handling among
    subsystems by making it possible to store hotplug-related information
    in struct acpi_device objects in a standard common way.
    
    Finally, it will help to avoid a race condition related to the
    deletion of ACPI namespace nodes.  Namely, namespace nodes may be
    deleted as a result of a table unload triggered by _EJ0 or _DCK.
    If a hotplug notification for one of those nodes is triggered
    right before the deletion and it executes a hotplug callback
    via acpi_hotplug_execute(), the ACPI handle passed to that
    callback may be stale when the callback actually runs.  One way
    to work around that is to always pass struct acpi_device pointers
    to hotplug callbacks after doing a get_device() on the objects in
    question which eliminates the use-after-free possibility (the ACPI
    handles in those objects are invalidated by acpi_scan_drop_device(),
    so they will trigger ACPICA errors on attempts to use them).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index b3480cf7db1a..d49f1e464703 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -256,6 +256,8 @@ int acpi_bus_init_power(struct acpi_device *device)
 		return -EINVAL;
 
 	device->power.state = ACPI_STATE_UNKNOWN;
+	if (!acpi_device_is_present(device))
+		return 0;
 
 	result = acpi_device_get_power(device, &state);
 	if (result)
@@ -302,15 +304,18 @@ int acpi_device_fix_up_power(struct acpi_device *device)
 	return ret;
 }
 
-int acpi_bus_update_power(acpi_handle handle, int *state_p)
+int acpi_device_update_power(struct acpi_device *device, int *state_p)
 {
-	struct acpi_device *device;
 	int state;
 	int result;
 
-	result = acpi_bus_get_device(handle, &device);
-	if (result)
+	if (device->power.state == ACPI_STATE_UNKNOWN) {
+		result = acpi_bus_init_power(device);
+		if (!result && state_p)
+			*state_p = device->power.state;
+
 		return result;
+	}
 
 	result = acpi_device_get_power(device, &state);
 	if (result)
@@ -338,6 +343,15 @@ int acpi_bus_update_power(acpi_handle handle, int *state_p)
 
 	return 0;
 }
+
+int acpi_bus_update_power(acpi_handle handle, int *state_p)
+{
+	struct acpi_device *device;
+	int result;
+
+	result = acpi_bus_get_device(handle, &device);
+	return result ? result : acpi_device_update_power(device, state_p);
+}
 EXPORT_SYMBOL_GPL(acpi_bus_update_power);
 
 bool acpi_bus_power_manageable(acpi_handle handle)

commit 3a83f992490f8235661b768e53bd5f14915420ac
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 14 23:17:21 2013 +0100

    ACPI: Eliminate the DEVICE_ACPI_HANDLE() macro
    
    Since DEVICE_ACPI_HANDLE() is now literally identical to
    ACPI_HANDLE(), replace it with the latter everywhere and drop its
    definition from include/acpi.h.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 119afda0968c..b3480cf7db1a 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -544,7 +544,7 @@ static int acpi_dev_pm_get_state(struct device *dev, struct acpi_device *adev,
  */
 int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 {
-	acpi_handle handle = DEVICE_ACPI_HANDLE(dev);
+	acpi_handle handle = ACPI_HANDLE(dev);
 	struct acpi_device *adev;
 	int ret, d_min, d_max;
 
@@ -652,7 +652,7 @@ int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
 	if (!device_run_wake(phys_dev))
 		return -EINVAL;
 
-	handle = DEVICE_ACPI_HANDLE(phys_dev);
+	handle = ACPI_HANDLE(phys_dev);
 	if (!handle || acpi_bus_get_device(handle, &adev)) {
 		dev_dbg(phys_dev, "ACPI handle without context in %s!\n",
 			__func__);
@@ -696,7 +696,7 @@ int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
 	if (!device_can_wakeup(dev))
 		return -EINVAL;
 
-	handle = DEVICE_ACPI_HANDLE(dev);
+	handle = ACPI_HANDLE(dev);
 	if (!handle || acpi_bus_get_device(handle, &adev)) {
 		dev_dbg(dev, "ACPI handle without context in %s!\n", __func__);
 		return -ENODEV;
@@ -718,7 +718,7 @@ int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
  */
 struct acpi_device *acpi_dev_pm_get_node(struct device *dev)
 {
-	acpi_handle handle = DEVICE_ACPI_HANDLE(dev);
+	acpi_handle handle = ACPI_HANDLE(dev);
 	struct acpi_device *adev;
 
 	return handle && !acpi_bus_get_device(handle, &adev) ? adev : NULL;

commit 7b1998116bbb2f3e5dd6cb9a8ee6db479b0b50a9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 11 22:41:56 2013 +0100

    ACPI / driver core: Store an ACPI device pointer in struct acpi_dev_node
    
    Modify struct acpi_dev_node to contain a pointer to struct acpi_device
    associated with the given device object (that is, its ACPI companion
    device) instead of an ACPI handle corresponding to it.  Introduce two
    new macros for manipulating that pointer in a CONFIG_ACPI-safe way,
    ACPI_COMPANION() and ACPI_COMPANION_SET(), and rework the
    ACPI_HANDLE() macro to take the above changes into account.
    Drop the ACPI_HANDLE_SET() macro entirely and rework its users to
    use ACPI_COMPANION_SET() instead.  For some of them who used to
    pass the result of acpi_get_child() directly to ACPI_HANDLE_SET()
    introduce a helper routine acpi_preset_companion() doing an
    equivalent thing.
    
    The main motivation for doing this is that there are things
    represented by struct acpi_device objects that don't have valid
    ACPI handles (so called fixed ACPI hardware features, such as
    power and sleep buttons) and we would like to create platform
    device objects for them and "glue" them to their ACPI companions
    in the usual way (which currently is impossible due to the
    lack of valid ACPI handles).  However, there are more reasons
    why it may be useful.
    
    First, struct acpi_device pointers allow of much better type checking
    than void pointers which are ACPI handles, so it should be more
    difficult to write buggy code using modified struct acpi_dev_node
    and the new macros.  Second, the change should help to reduce (over
    time) the number of places in which the result of ACPI_HANDLE() is
    passed to acpi_bus_get_device() in order to obtain a pointer to the
    struct acpi_device associated with the given "physical" device,
    because now that pointer is returned by ACPI_COMPANION() directly.
    Finally, the change should make it easier to write generic code that
    will build both for CONFIG_ACPI set and unset without adding explicit
    compiler directives to it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com> # on Haswell
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com> # for ATA and SDIO part

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index d42b2fb5a7e9..119afda0968c 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -22,16 +22,12 @@
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 
-#include <linux/device.h>
+#include <linux/acpi.h>
 #include <linux/export.h>
 #include <linux/mutex.h>
 #include <linux/pm_qos.h>
 #include <linux/pm_runtime.h>
 
-#include <acpi/acpi.h>
-#include <acpi/acpi_bus.h>
-#include <acpi/acpi_drivers.h>
-
 #include "internal.h"
 
 #define _COMPONENT	ACPI_POWER_COMPONENT

commit dd6c26be3bb3e98d4811780f831bbc246dae54c8
Merge: c0ced86d38f4 33cf00e57082
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Oct 28 01:17:49 2013 +0100

    Merge branch 'acpi-pm'
    
    * acpi-pm:
      spi: attach/detach SPI device to the ACPI power domain
      i2c: attach/detach I2C client device to the ACPI power domain
      ACPI / PM: allow child devices to ignore parent power state

commit 2421ad48f4aed63bc890e8f3c53ed581a542fb66
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 17 15:44:48 2013 +0200

    ACPI / PM: Drop two functions that are not used any more
    
    Two functions defined in device_pm.c, acpi_dev_pm_add_dependent()
    and acpi_dev_pm_remove_dependent(), have no callers and may be
    dropped, so drop them.
    
    Moreover, they are the only functions adding entries to and removing
    entries from the power_dependent list in struct acpi_device, so drop
    that list too.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 59d3202f6b36..a94383d1f350 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -1025,60 +1025,4 @@ void acpi_dev_pm_detach(struct device *dev, bool power_off)
 	}
 }
 EXPORT_SYMBOL_GPL(acpi_dev_pm_detach);
-
-/**
- * acpi_dev_pm_add_dependent - Add physical device depending for PM.
- * @handle: Handle of ACPI device node.
- * @depdev: Device depending on that node for PM.
- */
-void acpi_dev_pm_add_dependent(acpi_handle handle, struct device *depdev)
-{
-	struct acpi_device_physical_node *dep;
-	struct acpi_device *adev;
-
-	if (!depdev || acpi_bus_get_device(handle, &adev))
-		return;
-
-	mutex_lock(&adev->physical_node_lock);
-
-	list_for_each_entry(dep, &adev->power_dependent, node)
-		if (dep->dev == depdev)
-			goto out;
-
-	dep = kzalloc(sizeof(*dep), GFP_KERNEL);
-	if (dep) {
-		dep->dev = depdev;
-		list_add_tail(&dep->node, &adev->power_dependent);
-	}
-
- out:
-	mutex_unlock(&adev->physical_node_lock);
-}
-EXPORT_SYMBOL_GPL(acpi_dev_pm_add_dependent);
-
-/**
- * acpi_dev_pm_remove_dependent - Remove physical device depending for PM.
- * @handle: Handle of ACPI device node.
- * @depdev: Device depending on that node for PM.
- */
-void acpi_dev_pm_remove_dependent(acpi_handle handle, struct device *depdev)
-{
-	struct acpi_device_physical_node *dep;
-	struct acpi_device *adev;
-
-	if (!depdev || acpi_bus_get_device(handle, &adev))
-		return;
-
-	mutex_lock(&adev->physical_node_lock);
-
-	list_for_each_entry(dep, &adev->power_dependent, node)
-		if (dep->dev == depdev) {
-			list_del(&dep->node);
-			kfree(dep);
-			break;
-		}
-
-	mutex_unlock(&adev->physical_node_lock);
-}
-EXPORT_SYMBOL_GPL(acpi_dev_pm_remove_dependent);
 #endif /* CONFIG_PM */

commit 644f17ad7fc12768cd619532383343e514eab2ac
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Oct 10 13:28:46 2013 +0300

    ACPI / PM: allow child devices to ignore parent power state
    
    Some serial buses like I2C and SPI don't require that the parent device is
    in D0 before any of its children transitions to D0, but instead the parent
    device can control its own power independently from the children.
    
    This does not follow the ACPI specification as it requires the parent to be
    powered on before its children. However, Windows seems to ignore this
    requirement so I think we can do the same in Linux.
    
    Implement this by adding a new power flag 'ignore_parent' to struct
    acpi_device.  If this flag is set the ACPI core ignores checking of the
    parent device power state when the device is powered on/off.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 59d3202f6b36..ca723a4c120a 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -118,9 +118,10 @@ int acpi_device_get_power(struct acpi_device *device, int *state)
 	/*
 	 * If we were unsure about the device parent's power state up to this
 	 * point, the fact that the device is in D0 implies that the parent has
-	 * to be in D0 too.
+	 * to be in D0 too, except if ignore_parent is set.
 	 */
-	if (device->parent && device->parent->power.state == ACPI_STATE_UNKNOWN
+	if (!device->power.flags.ignore_parent && device->parent
+	    && device->parent->power.state == ACPI_STATE_UNKNOWN
 	    && result == ACPI_STATE_D0)
 		device->parent->power.state = ACPI_STATE_D0;
 
@@ -177,7 +178,8 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 			 acpi_power_state_string(state));
 		return -ENODEV;
 	}
-	if (device->parent && (state < device->parent->power.state)) {
+	if (!device->power.flags.ignore_parent &&
+	    device->parent && (state < device->parent->power.state)) {
 		dev_warn(&device->dev,
 			 "Cannot transition to power state %s for parent in %s\n",
 			 acpi_power_state_string(state),

commit 593298e68a3a53bd2fe942244250dfef4d68d477
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Sat Aug 3 21:13:22 2013 +0200

    ACPI / PM: Add state information to error message in acpi_device_set_power()
    
    The state information can be useful to know what the problem is when
    an error message about a device can not being set to a higher power
    state than its parent appeared, so this patch adds such state
    information for both the target state of the device and the current
    state of its parent.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index beb9625e8458..59d3202f6b36 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -179,7 +179,9 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 	}
 	if (device->parent && (state < device->parent->power.state)) {
 		dev_warn(&device->dev,
-			 "Cannot transition to a higher-powered state than parent\n");
+			 "Cannot transition to power state %s for parent in %s\n",
+			 acpi_power_state_string(state),
+			 acpi_power_state_string(device->parent->power.state));
 		return -ENODEV;
 	}
 

commit 7b4e0c4ac1809eab6fcfe6818ec8b70be79b41bc
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Wed Jul 31 14:07:15 2013 +0200

    ACPI / PM: Remove redundant power manageable check from acpi_bus_set_power()
    
    Now that acpi_device_set_power() checks whether or not the given
    device is power manageable, it is not necessary to do this check in
    acpi_bus_set_power() any more, so remove it.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 8234e1f8c79d..beb9625e8458 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -243,13 +243,6 @@ int acpi_bus_set_power(acpi_handle handle, int state)
 	if (result)
 		return result;
 
-	if (!device->flags.power_manageable) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				"Device [%s] is not power manageable\n",
-				dev_name(&device->dev)));
-		return -ENODEV;
-	}
-
 	return acpi_device_set_power(device, state);
 }
 EXPORT_SYMBOL(acpi_bus_set_power);

commit b69137a74b7a9451b3da504d1ef9ead7cb393922
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 30 14:34:55 2013 +0200

    ACPI / PM: Make messages in acpi_device_set_power() print device names
    
    Modify acpi_device_set_power() so that diagnostic messages printed by
    it to the kernel log always contain the name of the device concerned
    to make it possible to identify the device that triggered the message
    if need be.
    
    Also replace printk(KERN_WARNING ) with dev_warn() everywhere in that
    function.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 63324b873636..8234e1f8c79d 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -166,20 +166,20 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 	/* Make sure this is a valid target state */
 
 	if (state == device->power.state) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at %s\n",
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] already in %s\n",
+				  device->pnp.bus_id,
 				  acpi_power_state_string(state)));
 		return 0;
 	}
 
 	if (!device->power.states[state].flags.valid) {
-		printk(KERN_WARNING PREFIX "Device does not support %s\n",
-		       acpi_power_state_string(state));
+		dev_warn(&device->dev, "Power state %s not supported\n",
+			 acpi_power_state_string(state));
 		return -ENODEV;
 	}
 	if (device->parent && (state < device->parent->power.state)) {
-		printk(KERN_WARNING PREFIX
-			      "Cannot set device to a higher-powered"
-			      " state than parent\n");
+		dev_warn(&device->dev,
+			 "Cannot transition to a higher-powered state than parent\n");
 		return -ENODEV;
 	}
 
@@ -192,8 +192,8 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 
 	if (state < device->power.state && state != ACPI_STATE_D0
 	    && device->power.state >= ACPI_STATE_D3_HOT) {
-		printk(KERN_WARNING PREFIX
-			"Cannot transition to non-D0 state from D3\n");
+		dev_warn(&device->dev,
+			 "Cannot transition to non-D0 state from D3\n");
 		return -ENODEV;
 	}
 
@@ -220,10 +220,8 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 
  end:
 	if (result) {
-		printk(KERN_WARNING PREFIX
-			      "Device [%s] failed to transition to %s\n",
-			      device->pnp.bus_id,
-			      acpi_power_state_string(state));
+		dev_warn(&device->dev, "Failed to change power state to %s\n",
+			 acpi_power_state_string(state));
 	} else {
 		device->power.state = state;
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,

commit 2c7d132a589077b31493b3ea82ac83b1f72c93e1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 30 14:34:00 2013 +0200

    ACPI / PM: Only set power states of devices that are power manageable
    
    Make acpi_device_set_power() check if the given device is power
    manageable before checking if the given power state is valid for that
    device.  Otherwise it will print that "Device does not support" that
    power state into the kernel log, which may not make sense for some
    power states (D0 and D3cold are supported by all devices by
    definition).
    
    Tested-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 4ab807dc8518..63324b873636 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -159,7 +159,8 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 	int result = 0;
 	bool cut_power = false;
 
-	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3_COLD))
+	if (!device || !device->flags.power_manageable
+	    || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3_COLD))
 		return -EINVAL;
 
 	/* Make sure this is a valid target state */

commit 91bdad0b6237c25a7bf8fd4604d0cc64a2005a23
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jul 4 13:22:11 2013 +0200

    ACPI / PM: Fix corner case in acpi_bus_update_power()
    
    The role of acpi_bus_update_power() is to update the given ACPI
    device object's power.state field to reflect the current physical
    state of the device (as inferred from the configuration of power
    resources and _PSC, if available).  For this purpose it calls
    acpi_device_set_power() that should update the power resources'
    reference counters and set power.state as appropriate.  However,
    that doesn't work if the "new" state is D1, D2 or D3hot and the
    the current value of power.state means D3cold, because in that
    case acpi_device_set_power() will refuse to transition the device
    from D3cold to non-D0.
    
    To address this problem, make acpi_bus_update_power() call
    acpi_power_transition() directly to update the power resources'
    reference counters and only use acpi_device_set_power() to put
    the device into D0 if the current physical state of it cannot
    be determined.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: 3.9+ <stable@vger.kernel.org>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index e9e8bb24785b..4ab807dc8518 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -324,14 +324,27 @@ int acpi_bus_update_power(acpi_handle handle, int *state_p)
 	if (result)
 		return result;
 
-	if (state == ACPI_STATE_UNKNOWN)
+	if (state == ACPI_STATE_UNKNOWN) {
 		state = ACPI_STATE_D0;
-
-	result = acpi_device_set_power(device, state);
-	if (!result && state_p)
+		result = acpi_device_set_power(device, state);
+		if (result)
+			return result;
+	} else {
+		if (device->power.flags.power_resources) {
+			/*
+			 * We don't need to really switch the state, bu we need
+			 * to update the power resources' reference counters.
+			 */
+			result = acpi_power_transition(device, state);
+			if (result)
+				return result;
+		}
+		device->power.state = state;
+	}
+	if (state_p)
 		*state_p = state;
 
-	return result;
+	return 0;
 }
 EXPORT_SYMBOL_GPL(acpi_bus_update_power);
 

commit d5ba5b141dae17155d12b897f2eedeaf6800db7c
Merge: 996e2569dab5 9b5c7a5a977a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 29 15:03:38 2013 +0200

    Merge branch 'acpi-pm'
    
    * acpi-pm:
      ACPI / PM: Fix possible NULL pointer deref in acpi_pm_device_sleep_state()

commit e52cff8bdd4a30c40a7f65c7ea8f1f425f8a15eb
Merge: 405a1086bdd0 f5ce15721090
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 28 13:01:40 2013 +0200

    Merge branch 'pm-assorted'
    
    * pm-assorted:
      PM / QoS: Add pm_qos and dev_pm_qos to events-power.txt
      PM / QoS: Add dev_pm_qos_request tracepoints
      PM / QoS: Add pm_qos_request tracepoints
      PM / QoS: Add pm_qos_update_target/flags tracepoints
      PM / QoS: Update Documentation/power/pm_qos_interface.txt
      PM / Sleep: Print last wakeup source on failed wakeup_count write
      PM / QoS: correct the valid range of pm_qos_class
      PM / wakeup: Adjust messaging for wake events during suspend
      PM / Runtime: Update .runtime_idle() callback documentation
      PM / Runtime: Rework the "runtime idle" helper routine
      PM / Hibernate: print physical addresses consistently with other parts of kernel

commit 3b4550e0e0cd24d8073dc571cecb0d4aa4ca3542
Merge: 8e9914d5efe4 fa1675b56537
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 28 12:58:30 2013 +0200

    Merge branch 'acpi-pm'
    
    * acpi-pm:
      ACPI / PM: Rework and clean up acpi_dev_pm_get_state()
      ACPI / PM: Replace ACPI_STATE_D3 with ACPI_STATE_D3_COLD in device_pm.c
      ACPI / PM: Rename function acpi_device_power_state() and make it static
      ACPI / PM: acpi_processor_suspend() can be static
      xen / ACPI / sleep: Register an acpi_suspend_lowlevel callback.
      x86 / ACPI / sleep: Provide registration for acpi_suspend_lowlevel.

commit 9b5c7a5a977a330ffaf83c4d383ba247c74c800f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jun 27 14:01:02 2013 +0200

    ACPI / PM: Fix possible NULL pointer deref in acpi_pm_device_sleep_state()
    
    After commit fa1675b (ACPI / PM: Rework and clean up
    acpi_dev_pm_get_state()) a NULL pointer dereference will take place
    if NULL is passed to acpi_pm_device_sleep_state() as the second
    argument.
    
    Fix that by avoiding to use the pointer that may be NULL until
    it's necessary to store a return value at the location pointed to
    by it (if not NULL).
    
    Reported-and-tested-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index fd363b57a596..4c56dc830ebc 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -521,7 +521,7 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 {
 	acpi_handle handle = DEVICE_ACPI_HANDLE(dev);
 	struct acpi_device *adev;
-	int ret, d_max;
+	int ret, d_min, d_max;
 
 	if (d_max_in < ACPI_STATE_D0 || d_max_in > ACPI_STATE_D3_COLD)
 		return -EINVAL;
@@ -540,19 +540,23 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 	}
 
 	ret = acpi_dev_pm_get_state(dev, adev, acpi_target_system_state(),
-				    d_min_p, &d_max);
+				    &d_min, &d_max);
 	if (ret)
 		return ret;
 
-	if (d_max_in < *d_min_p)
+	if (d_max_in < d_min)
 		return -EINVAL;
 
 	if (d_max > d_max_in) {
-		for (d_max = d_max_in; d_max > *d_min_p; d_max--) {
+		for (d_max = d_max_in; d_max > d_min; d_max--) {
 			if (adev->power.states[d_max].flags.valid)
 				break;
 		}
 	}
+
+	if (d_min_p)
+		*d_min_p = d_min;
+
 	return d_max;
 }
 EXPORT_SYMBOL(acpi_pm_device_sleep_state);

commit b9e95fc65ededbec083aa91b4faa58ad992c0891
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 19 00:45:34 2013 +0200

    ACPI / LPSS: Power up LPSS devices during enumeration
    
    Commit 7cd8407 (ACPI / PM: Do not execute _PS0 for devices without
    _PSC during initialization) introduced a regression on some systems
    with Intel Lynxpoint Low-Power Subsystem (LPSS) where some devices
    need to be powered up during initialization, but their device objects
    in the ACPI namespace have _PS0 and _PS3 only (without _PSC or power
    resources).
    
    To work around this problem, make the ACPI LPSS driver power up
    devices it knows about by using a new helper function
    acpi_device_fix_up_power() that does all of the necessary
    sanity checks and calls acpi_dev_pm_explicit_set() to put the
    device into D0.
    
    Reported-and-tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 318fa32a141e..31c217a42839 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -290,6 +290,26 @@ int acpi_bus_init_power(struct acpi_device *device)
 	return 0;
 }
 
+/**
+ * acpi_device_fix_up_power - Force device with missing _PSC into D0.
+ * @device: Device object whose power state is to be fixed up.
+ *
+ * Devices without power resources and _PSC, but having _PS0 and _PS3 defined,
+ * are assumed to be put into D0 by the BIOS.  However, in some cases that may
+ * not be the case and this function should be used then.
+ */
+int acpi_device_fix_up_power(struct acpi_device *device)
+{
+	int ret = 0;
+
+	if (!device->power.flags.power_resources
+	    && !device->power.flags.explicit_get
+	    && device->power.state == ACPI_STATE_D0)
+		ret = acpi_dev_pm_explicit_set(device, ACPI_STATE_D0);
+
+	return ret;
+}
+
 int acpi_bus_update_power(acpi_handle handle, int *state_p)
 {
 	struct acpi_device *device;

commit fa1675b56537651270e79967b7f1ee4202c83bf6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jun 16 00:37:59 2013 +0200

    ACPI / PM: Rework and clean up acpi_dev_pm_get_state()
    
    The acpi_dev_pm_get_state() function defined in device_pm.c is quite
    convoluted, which isn't really necessary, and it doesn't validate the
    values returned by the ACPI methods executed by it appropriately.
    
    To address these shortcomings modify it in the following way.
    
     (1) Make its return value only mean whether or not it succeeded and
         pass the device power states determined by it through pointers.
    
     (2) Drop the d_max_in argument, used by only one of its callers,
         from it, and move the code related to d_max_in into that caller,
         acpi_pm_device_sleep_state().
    
     (3) Make it always check the return value of acpi_evaluate_integer()
         and handle failures as appropriate.  Moreover, make it check if
         the values returned by the executed ACPI methods are not out of
         range.
    
     (4) Make it check if the values returned by the executed ACPI
         methods represent valid power states of the given device and
         handle situations in which that's not the case gracefully.
    
    Also update the kerneldoc comments of acpi_dev_pm_get_state() and
    acpi_pm_device_sleep_state() to reflect the code changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index afc808e93855..fd363b57a596 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -403,44 +403,37 @@ EXPORT_SYMBOL(acpi_bus_can_wakeup);
  * @dev: Device whose preferred target power state to return.
  * @adev: ACPI device node corresponding to @dev.
  * @target_state: System state to match the resultant device state.
- * @d_max_in: Deepest low-power state to take into consideration.
- * @d_min_p: Location to store the upper limit of the allowed states range.
- * Return value: Preferred power state of the device on success, -ENODEV
- * (if there's no 'struct acpi_device' for @dev) or -EINVAL on failure
+ * @d_min_p: Location to store the highest power state available to the device.
+ * @d_max_p: Location to store the lowest power state available to the device.
  *
- * Find the lowest power (highest number) ACPI device power state that the
- * device can be in while the system is in the state represented by
- * @target_state.  If @d_min_p is set, the highest power (lowest number) device
- * power state that @dev can be in for the given system sleep state is stored
- * at the location pointed to by it.
+ * Find the lowest power (highest number) and highest power (lowest number) ACPI
+ * device power states that the device can be in while the system is in the
+ * state represented by @target_state.  Store the integer numbers representing
+ * those stats in the memory locations pointed to by @d_max_p and @d_min_p,
+ * respectively.
  *
  * Callers must ensure that @dev and @adev are valid pointers and that @adev
  * actually corresponds to @dev before using this function.
+ *
+ * Returns 0 on success or -ENODATA when one of the ACPI methods fails or
+ * returns a value that doesn't make sense.  The memory locations pointed to by
+ * @d_max_p and @d_min_p are only modified on success.
  */
 static int acpi_dev_pm_get_state(struct device *dev, struct acpi_device *adev,
-				 u32 target_state, int d_max_in, int *d_min_p)
+				 u32 target_state, int *d_min_p, int *d_max_p)
 {
-	char acpi_method[] = "_SxD";
-	unsigned long long d_min, d_max;
+	char method[] = { '_', 'S', '0' + target_state, 'D', '\0' };
+	acpi_handle handle = adev->handle;
+	unsigned long long ret;
+	int d_min, d_max;
 	bool wakeup = false;
+	acpi_status status;
 
-	if (d_max_in < ACPI_STATE_D0 || d_max_in > ACPI_STATE_D3_COLD)
-		return -EINVAL;
-
-	if (d_max_in > ACPI_STATE_D3_HOT) {
-		enum pm_qos_flags_status stat;
-
-		stat = dev_pm_qos_flags(dev, PM_QOS_FLAG_NO_POWER_OFF);
-		if (stat == PM_QOS_FLAGS_ALL)
-			d_max_in = ACPI_STATE_D3_HOT;
-	}
-
-	acpi_method[2] = '0' + target_state;
 	/*
-	 * If the sleep state is S0, the lowest limit from ACPI is D3,
-	 * but if the device has _S0W, we will use the value from _S0W
-	 * as the lowest limit from ACPI.  Finally, we will constrain
-	 * the lowest limit with the specified one.
+	 * If the system state is S0, the lowest power state the device can be
+	 * in is D3cold, unless the device has _S0W and is supposed to signal
+	 * wakeup, in which case the return value of _S0W has to be used as the
+	 * lowest power state available to the device.
 	 */
 	d_min = ACPI_STATE_D0;
 	d_max = ACPI_STATE_D3_COLD;
@@ -449,12 +442,30 @@ static int acpi_dev_pm_get_state(struct device *dev, struct acpi_device *adev,
 	 * If present, _SxD methods return the minimum D-state (highest power
 	 * state) we can use for the corresponding S-states.  Otherwise, the
 	 * minimum D-state is D0 (ACPI 3.x).
-	 *
-	 * NOTE: We rely on acpi_evaluate_integer() not clobbering the integer
-	 * provided -- that's our fault recovery, we ignore retval.
 	 */
 	if (target_state > ACPI_STATE_S0) {
-		acpi_evaluate_integer(adev->handle, acpi_method, NULL, &d_min);
+		/*
+		 * We rely on acpi_evaluate_integer() not clobbering the integer
+		 * provided if AE_NOT_FOUND is returned.
+		 */
+		ret = d_min;
+		status = acpi_evaluate_integer(handle, method, NULL, &ret);
+		if ((ACPI_FAILURE(status) && status != AE_NOT_FOUND)
+		    || ret > ACPI_STATE_D3_COLD)
+			return -ENODATA;
+
+		/*
+		 * We need to handle legacy systems where D3hot and D3cold are
+		 * the same and 3 is returned in both cases, so fall back to
+		 * D3cold if D3hot is not a valid state.
+		 */
+		if (!adev->power.states[ret].flags.valid) {
+			if (ret == ACPI_STATE_D3_HOT)
+				ret = ACPI_STATE_D3_COLD;
+			else
+				return -ENODATA;
+		}
+		d_min = ret;
 		wakeup = device_may_wakeup(dev) && adev->wakeup.flags.valid
 			&& adev->wakeup.sleep_state >= target_state;
 	} else if (dev_pm_qos_flags(dev, PM_QOS_FLAG_REMOTE_WAKEUP) !=
@@ -470,36 +481,29 @@ static int acpi_dev_pm_get_state(struct device *dev, struct acpi_device *adev,
 	 * can wake the system.  _S0W may be valid, too.
 	 */
 	if (wakeup) {
-		acpi_status status;
-
-		acpi_method[3] = 'W';
-		status = acpi_evaluate_integer(adev->handle, acpi_method, NULL,
-						&d_max);
-		if (ACPI_FAILURE(status)) {
-			if (target_state != ACPI_STATE_S0 ||
-			    status != AE_NOT_FOUND)
+		method[3] = 'W';
+		status = acpi_evaluate_integer(handle, method, NULL, &ret);
+		if (status == AE_NOT_FOUND) {
+			if (target_state > ACPI_STATE_S0)
 				d_max = d_min;
-		} else if (d_max < d_min) {
-			/* Warn the user of the broken DSDT */
-			printk(KERN_WARNING "ACPI: Wrong value from %s\n",
-				acpi_method);
-			/* Sanitize it */
-			d_min = d_max;
+		} else if (ACPI_SUCCESS(status) && ret <= ACPI_STATE_D3_COLD) {
+			/* Fall back to D3cold if ret is not a valid state. */
+			if (!adev->power.states[ret].flags.valid)
+				ret = ACPI_STATE_D3_COLD;
+
+			d_max = ret > d_min ? ret : d_min;
+		} else {
+			return -ENODATA;
 		}
 	}
 
-	if (d_max_in < d_min)
-		return -EINVAL;
 	if (d_min_p)
 		*d_min_p = d_min;
-	/* constrain d_max with specified lowest limit (max number) */
-	if (d_max > d_max_in) {
-		for (d_max = d_max_in; d_max > d_min; d_max--) {
-			if (adev->power.states[d_max].flags.valid)
-				break;
-		}
-	}
-	return d_max;
+
+	if (d_max_p)
+		*d_max_p = d_max;
+
+	return 0;
 }
 
 /**
@@ -508,7 +512,8 @@ static int acpi_dev_pm_get_state(struct device *dev, struct acpi_device *adev,
  * @d_min_p: Location to store the upper limit of the allowed states range.
  * @d_max_in: Deepest low-power state to take into consideration.
  * Return value: Preferred power state of the device on success, -ENODEV
- * (if there's no 'struct acpi_device' for @dev) or -EINVAL on failure
+ * if there's no 'struct acpi_device' for @dev, -EINVAL if @d_max_in is
+ * incorrect, or -ENODATA on ACPI method failure.
  *
  * The caller must ensure that @dev is valid before using this function.
  */
@@ -516,14 +521,39 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 {
 	acpi_handle handle = DEVICE_ACPI_HANDLE(dev);
 	struct acpi_device *adev;
+	int ret, d_max;
+
+	if (d_max_in < ACPI_STATE_D0 || d_max_in > ACPI_STATE_D3_COLD)
+		return -EINVAL;
+
+	if (d_max_in > ACPI_STATE_D3_HOT) {
+		enum pm_qos_flags_status stat;
+
+		stat = dev_pm_qos_flags(dev, PM_QOS_FLAG_NO_POWER_OFF);
+		if (stat == PM_QOS_FLAGS_ALL)
+			d_max_in = ACPI_STATE_D3_HOT;
+	}
 
 	if (!handle || acpi_bus_get_device(handle, &adev)) {
 		dev_dbg(dev, "ACPI handle without context in %s!\n", __func__);
 		return -ENODEV;
 	}
 
-	return acpi_dev_pm_get_state(dev, adev, acpi_target_system_state(),
-				     d_max_in, d_min_p);
+	ret = acpi_dev_pm_get_state(dev, adev, acpi_target_system_state(),
+				    d_min_p, &d_max);
+	if (ret)
+		return ret;
+
+	if (d_max_in < *d_min_p)
+		return -EINVAL;
+
+	if (d_max > d_max_in) {
+		for (d_max = d_max_in; d_max > *d_min_p; d_max--) {
+			if (adev->power.states[d_max].flags.valid)
+				break;
+		}
+	}
+	return d_max;
 }
 EXPORT_SYMBOL(acpi_pm_device_sleep_state);
 
@@ -674,17 +704,13 @@ struct acpi_device *acpi_dev_pm_get_node(struct device *dev)
 static int acpi_dev_pm_low_power(struct device *dev, struct acpi_device *adev,
 				 u32 system_state)
 {
-	int power_state;
+	int ret, state;
 
 	if (!acpi_device_power_manageable(adev))
 		return 0;
 
-	power_state = acpi_dev_pm_get_state(dev, adev, system_state,
-					    ACPI_STATE_D3_COLD, NULL);
-	if (power_state < ACPI_STATE_D0 || power_state > ACPI_STATE_D3_COLD)
-		return -EIO;
-
-	return acpi_device_set_power(adev, power_state);
+	ret = acpi_dev_pm_get_state(dev, adev, system_state, NULL, &state);
+	return ret ? ret : acpi_device_set_power(adev, state);
 }
 
 /**

commit 4c164ae7d8a7ee1f39b773d97794535c2c193b12
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jun 16 00:37:50 2013 +0200

    ACPI / PM: Replace ACPI_STATE_D3 with ACPI_STATE_D3_COLD in device_pm.c
    
    The two symbols ACPI_STATE_D3 and ACPI_STATE_D3_COLD actually
    represent the same number (4), but ACPI_STATE_D3 is slightly
    ambigugous, because it may not be clear that it really means D3cold
    and not D3hot at first sight.
    
    Remove that ambiguity from drivers/acpi/device_pm.c by making it
    use ACPI_STATE_D3_COLD everywhere instead of ACPI_STATE_D3.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 26d3fd718a04..afc808e93855 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -424,7 +424,7 @@ static int acpi_dev_pm_get_state(struct device *dev, struct acpi_device *adev,
 	unsigned long long d_min, d_max;
 	bool wakeup = false;
 
-	if (d_max_in < ACPI_STATE_D0 || d_max_in > ACPI_STATE_D3)
+	if (d_max_in < ACPI_STATE_D0 || d_max_in > ACPI_STATE_D3_COLD)
 		return -EINVAL;
 
 	if (d_max_in > ACPI_STATE_D3_HOT) {
@@ -443,7 +443,7 @@ static int acpi_dev_pm_get_state(struct device *dev, struct acpi_device *adev,
 	 * the lowest limit with the specified one.
 	 */
 	d_min = ACPI_STATE_D0;
-	d_max = ACPI_STATE_D3;
+	d_max = ACPI_STATE_D3_COLD;
 
 	/*
 	 * If present, _SxD methods return the minimum D-state (highest power
@@ -680,8 +680,8 @@ static int acpi_dev_pm_low_power(struct device *dev, struct acpi_device *adev,
 		return 0;
 
 	power_state = acpi_dev_pm_get_state(dev, adev, system_state,
-					    ACPI_STATE_D3, NULL);
-	if (power_state < ACPI_STATE_D0 || power_state > ACPI_STATE_D3)
+					    ACPI_STATE_D3_COLD, NULL);
+	if (power_state < ACPI_STATE_D0 || power_state > ACPI_STATE_D3_COLD)
 		return -EIO;
 
 	return acpi_device_set_power(adev, power_state);

commit b25c77efa71178f8281401e492e5c63cf7c34900
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jun 16 00:37:42 2013 +0200

    ACPI / PM: Rename function acpi_device_power_state() and make it static
    
    There is a name clash between function acpi_device_power_state()
    defined in drivers/acpi/device_pm.c and structure type
    acpi_device_power_state defined in include/acpi/acpi_bus.h, which
    may be resolved by renaming the function.  Additionally, that
    funtion may be made static, because it is not used anywhere outside
    of the file it is defined in.
    
    Rename acpi_device_power_state() to acpi_dev_pm_get_state(), which
    better reflects its purpose, and make it static.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 318fa32a141e..26d3fd718a04 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -399,7 +399,7 @@ bool acpi_bus_can_wakeup(acpi_handle handle)
 EXPORT_SYMBOL(acpi_bus_can_wakeup);
 
 /**
- * acpi_device_power_state - Get preferred power state of ACPI device.
+ * acpi_dev_pm_get_state - Get preferred power state of ACPI device.
  * @dev: Device whose preferred target power state to return.
  * @adev: ACPI device node corresponding to @dev.
  * @target_state: System state to match the resultant device state.
@@ -417,8 +417,8 @@ EXPORT_SYMBOL(acpi_bus_can_wakeup);
  * Callers must ensure that @dev and @adev are valid pointers and that @adev
  * actually corresponds to @dev before using this function.
  */
-int acpi_device_power_state(struct device *dev, struct acpi_device *adev,
-			    u32 target_state, int d_max_in, int *d_min_p)
+static int acpi_dev_pm_get_state(struct device *dev, struct acpi_device *adev,
+				 u32 target_state, int d_max_in, int *d_min_p)
 {
 	char acpi_method[] = "_SxD";
 	unsigned long long d_min, d_max;
@@ -501,7 +501,6 @@ int acpi_device_power_state(struct device *dev, struct acpi_device *adev,
 	}
 	return d_max;
 }
-EXPORT_SYMBOL_GPL(acpi_device_power_state);
 
 /**
  * acpi_pm_device_sleep_state - Get preferred power state of ACPI device.
@@ -523,8 +522,8 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 		return -ENODEV;
 	}
 
-	return acpi_device_power_state(dev, adev, acpi_target_system_state(),
-				       d_max_in, d_min_p);
+	return acpi_dev_pm_get_state(dev, adev, acpi_target_system_state(),
+				     d_max_in, d_min_p);
 }
 EXPORT_SYMBOL(acpi_pm_device_sleep_state);
 
@@ -680,8 +679,8 @@ static int acpi_dev_pm_low_power(struct device *dev, struct acpi_device *adev,
 	if (!acpi_device_power_manageable(adev))
 		return 0;
 
-	power_state = acpi_device_power_state(dev, adev, system_state,
-					      ACPI_STATE_D3, NULL);
+	power_state = acpi_dev_pm_get_state(dev, adev, system_state,
+					    ACPI_STATE_D3, NULL);
 	if (power_state < ACPI_STATE_D0 || power_state > ACPI_STATE_D3)
 		return -EIO;
 

commit 7cd8407d53ef5fb0280fcbe34f42311472f90feb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 5 14:01:19 2013 +0200

    ACPI / PM: Do not execute _PS0 for devices without _PSC during initialization
    
    Commit b378549 (ACPI / PM: Do not power manage devices in unknown
    initial states) added code to force devices without _PSC, but having
    _PS0 defined in the ACPI namespace, into ACPI power state D0 by
    executing _PS0 for them.  That turned out to break Toshiba P870-303,
    however, so revert that code.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=58201
    Reported-and-tested-by: Jerome Cantenot <jerome.cantenot@gmail.com>
    Tracked-down-by: Lan Tianyu <tianyu.lan@intel.com>
    Cc: 3.9+ <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index bc493aa3af19..318fa32a141e 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -278,11 +278,13 @@ int acpi_bus_init_power(struct acpi_device *device)
 		if (result)
 			return result;
 	} else if (state == ACPI_STATE_UNKNOWN) {
-		/* No power resources and missing _PSC? Try to force D0. */
+		/*
+		 * No power resources and missing _PSC?  Cross fingers and make
+		 * it D0 in hope that this is what the BIOS put the device into.
+		 * [We tried to force D0 here by executing _PS0, but that broke
+		 * Toshiba P870-303 in a nasty way.]
+		 */
 		state = ACPI_STATE_D0;
-		result = acpi_dev_pm_explicit_set(device, state);
-		if (result)
-			return result;
 	}
 	device->power.state = state;
 	return 0;

commit 45f0a85c8258741d11bda25c0a5669c06267204a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 3 21:49:52 2013 +0200

    PM / Runtime: Rework the "runtime idle" helper routine
    
    The "runtime idle" helper routine, rpm_idle(), currently ignores
    return values from .runtime_idle() callbacks executed by it.
    However, it turns out that many subsystems use
    pm_generic_runtime_idle() which checks the return value of the
    driver's callback and executes pm_runtime_suspend() for the device
    unless that value is not 0.  If that logic is moved to rpm_idle()
    instead, pm_generic_runtime_idle() can be dropped and its users
    will not need any .runtime_idle() callbacks any more.
    
    Moreover, the PCI, SCSI, and SATA subsystems' .runtime_idle()
    routines, pci_pm_runtime_idle(), scsi_runtime_idle(), and
    ata_port_runtime_idle(), respectively, as well as a few drivers'
    ones may be simplified if rpm_idle() calls rpm_suspend() after 0 has
    been returned by the .runtime_idle() callback executed by it.
    
    To reduce overall code bloat, make the changes described above.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index bc493aa3af19..1eb8b6258786 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -886,7 +886,6 @@ static struct dev_pm_domain acpi_general_pm_domain = {
 #ifdef CONFIG_PM_RUNTIME
 		.runtime_suspend = acpi_subsys_runtime_suspend,
 		.runtime_resume = acpi_subsys_runtime_resume,
-		.runtime_idle = pm_generic_runtime_idle,
 #endif
 #ifdef CONFIG_PM_SLEEP
 		.prepare = acpi_subsys_prepare,

commit ec4602a9588a196fa1a9af46bfdd37cbf5792db4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 16 22:29:28 2013 +0200

    ACPI / PM: Allow device power states to be used for CONFIG_PM unset
    
    Currently, drivers/acpi/device_pm.c depends on CONFIG_PM and all of
    the functions defined in there are replaced with static inline stubs
    if that option is unset.  However, CONFIG_PM means, roughly, "runtime
    PM or suspend/hibernation support" and some of those functions are
    useful regardless of that.  For example, they are used by the ACPI
    fan driver for controlling fans and acpi_device_set_power() is called
    during device removal.  Moreover, device initialization may depend on
    setting device power states properly.
    
    For these reasons, make the routines manipulating ACPI device power
    states defined in drivers/acpi/device_pm.c available for CONFIG_PM
    unset too.
    
    Reported-by: Zhang Rui <rui.zhang@intel.com>
    Reported-and-tested-by: Michel Lespinasse <walken@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: 3.9+ <stable@vger.kernel.org>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 96de787e6104..bc493aa3af19 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -37,68 +37,6 @@
 #define _COMPONENT	ACPI_POWER_COMPONENT
 ACPI_MODULE_NAME("device_pm");
 
-static DEFINE_MUTEX(acpi_pm_notifier_lock);
-
-/**
- * acpi_add_pm_notifier - Register PM notifier for given ACPI device.
- * @adev: ACPI device to add the notifier for.
- * @context: Context information to pass to the notifier routine.
- *
- * NOTE: @adev need not be a run-wake or wakeup device to be a valid source of
- * PM wakeup events.  For example, wakeup events may be generated for bridges
- * if one of the devices below the bridge is signaling wakeup, even if the
- * bridge itself doesn't have a wakeup GPE associated with it.
- */
-acpi_status acpi_add_pm_notifier(struct acpi_device *adev,
-				 acpi_notify_handler handler, void *context)
-{
-	acpi_status status = AE_ALREADY_EXISTS;
-
-	mutex_lock(&acpi_pm_notifier_lock);
-
-	if (adev->wakeup.flags.notifier_present)
-		goto out;
-
-	status = acpi_install_notify_handler(adev->handle,
-					     ACPI_SYSTEM_NOTIFY,
-					     handler, context);
-	if (ACPI_FAILURE(status))
-		goto out;
-
-	adev->wakeup.flags.notifier_present = true;
-
- out:
-	mutex_unlock(&acpi_pm_notifier_lock);
-	return status;
-}
-
-/**
- * acpi_remove_pm_notifier - Unregister PM notifier from given ACPI device.
- * @adev: ACPI device to remove the notifier from.
- */
-acpi_status acpi_remove_pm_notifier(struct acpi_device *adev,
-				    acpi_notify_handler handler)
-{
-	acpi_status status = AE_BAD_PARAMETER;
-
-	mutex_lock(&acpi_pm_notifier_lock);
-
-	if (!adev->wakeup.flags.notifier_present)
-		goto out;
-
-	status = acpi_remove_notify_handler(adev->handle,
-					    ACPI_SYSTEM_NOTIFY,
-					    handler);
-	if (ACPI_FAILURE(status))
-		goto out;
-
-	adev->wakeup.flags.notifier_present = false;
-
- out:
-	mutex_unlock(&acpi_pm_notifier_lock);
-	return status;
-}
-
 /**
  * acpi_power_state_string - String representation of ACPI device power state.
  * @state: ACPI device power state to return the string representation of.
@@ -385,6 +323,69 @@ bool acpi_bus_power_manageable(acpi_handle handle)
 }
 EXPORT_SYMBOL(acpi_bus_power_manageable);
 
+#ifdef CONFIG_PM
+static DEFINE_MUTEX(acpi_pm_notifier_lock);
+
+/**
+ * acpi_add_pm_notifier - Register PM notifier for given ACPI device.
+ * @adev: ACPI device to add the notifier for.
+ * @context: Context information to pass to the notifier routine.
+ *
+ * NOTE: @adev need not be a run-wake or wakeup device to be a valid source of
+ * PM wakeup events.  For example, wakeup events may be generated for bridges
+ * if one of the devices below the bridge is signaling wakeup, even if the
+ * bridge itself doesn't have a wakeup GPE associated with it.
+ */
+acpi_status acpi_add_pm_notifier(struct acpi_device *adev,
+				 acpi_notify_handler handler, void *context)
+{
+	acpi_status status = AE_ALREADY_EXISTS;
+
+	mutex_lock(&acpi_pm_notifier_lock);
+
+	if (adev->wakeup.flags.notifier_present)
+		goto out;
+
+	status = acpi_install_notify_handler(adev->handle,
+					     ACPI_SYSTEM_NOTIFY,
+					     handler, context);
+	if (ACPI_FAILURE(status))
+		goto out;
+
+	adev->wakeup.flags.notifier_present = true;
+
+ out:
+	mutex_unlock(&acpi_pm_notifier_lock);
+	return status;
+}
+
+/**
+ * acpi_remove_pm_notifier - Unregister PM notifier from given ACPI device.
+ * @adev: ACPI device to remove the notifier from.
+ */
+acpi_status acpi_remove_pm_notifier(struct acpi_device *adev,
+				    acpi_notify_handler handler)
+{
+	acpi_status status = AE_BAD_PARAMETER;
+
+	mutex_lock(&acpi_pm_notifier_lock);
+
+	if (!adev->wakeup.flags.notifier_present)
+		goto out;
+
+	status = acpi_remove_notify_handler(adev->handle,
+					    ACPI_SYSTEM_NOTIFY,
+					    handler);
+	if (ACPI_FAILURE(status))
+		goto out;
+
+	adev->wakeup.flags.notifier_present = false;
+
+ out:
+	mutex_unlock(&acpi_pm_notifier_lock);
+	return status;
+}
+
 bool acpi_bus_can_wakeup(acpi_handle handle)
 {
 	struct acpi_device *device;
@@ -1023,3 +1024,4 @@ void acpi_dev_pm_remove_dependent(acpi_handle handle, struct device *depdev)
 	mutex_unlock(&adev->physical_node_lock);
 }
 EXPORT_SYMBOL_GPL(acpi_dev_pm_remove_dependent);
+#endif /* CONFIG_PM */

commit 75eb2d13acca49c3c4f1c96fb04d6c9fd6013e78
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Mar 24 22:54:40 2013 +0100

    ACPI / PM: Fix potential problem in acpi_device_get_power()
    
    Theoretically, in some situations acpi_device_get_power() may return
    an incorrect result, because the settings of the power resources
    depended on by the device may indicate a power state shallower than
    the actual power state of the device.
    
    Say that two devices, A and B, depend on two power resources, X and
    Y, in such a way that _PR0 for both A and B list both X and Y and
    _PR3 for both A and B list power resource Y alone.  Also suppose
    that _PS0 and _PS3 are present for both A and B.  Then, if devices
    A and B are initially in D0, power resources X and Y are initially
    "on" and their reference counters are equal to 2.  To put device A
    into power state D3hot the kernel will decrement the reference
    counter of power resource X, but that power resource won't be turned
    off, because it is still in use by device B (its reference counter is
    equal to 1).  Next, _PS3 will be executed for device A.  Afterward
    the configuration of the power resources will indicate that device
    A is in power state D0 (both X and Y are "on"), but in fact it is
    in D3hot (because _PS3 has been executed for it).
    
    In that situation, if acpi_device_get_power() is called to get the
    power state of device A, it will first execute _PSC for it which
    should return 3.  That will cause acpi_device_get_power() to run
    acpi_power_get_inferred_state() for device A and the resultant power
    state will be D0, which is incorrect.
    
    To fix that change acpi_device_get_power() to first execute
    acpi_power_get_inferred_state() for the given device (if it
    depends on power resources) and to evaluate _PSC for it subsequently,
    so that the result inferred from the power resources configuration
    can be amended by the _PSC return value.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index dd314ef9bff1..96de787e6104 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -145,27 +145,36 @@ int acpi_device_get_power(struct acpi_device *device, int *state)
 	}
 
 	/*
-	 * Get the device's power state either directly (via _PSC) or
-	 * indirectly (via power resources).
+	 * Get the device's power state from power resources settings and _PSC,
+	 * if available.
 	 */
+	if (device->power.flags.power_resources) {
+		int error = acpi_power_get_inferred_state(device, &result);
+		if (error)
+			return error;
+	}
 	if (device->power.flags.explicit_get) {
+		acpi_handle handle = device->handle;
 		unsigned long long psc;
-		acpi_status status = acpi_evaluate_integer(device->handle,
-							   "_PSC", NULL, &psc);
+		acpi_status status;
+
+		status = acpi_evaluate_integer(handle, "_PSC", NULL, &psc);
 		if (ACPI_FAILURE(status))
 			return -ENODEV;
 
-		result = psc;
-	}
-	/* The test below covers ACPI_STATE_UNKNOWN too. */
-	if (result <= ACPI_STATE_D2) {
-	  ; /* Do nothing. */
-	} else if (device->power.flags.power_resources) {
-		int error = acpi_power_get_inferred_state(device, &result);
-		if (error)
-			return error;
-	} else if (result == ACPI_STATE_D3_HOT) {
-		result = ACPI_STATE_D3;
+		/*
+		 * The power resources settings may indicate a power state
+		 * shallower than the actual power state of the device.
+		 *
+		 * Moreover, on systems predating ACPI 4.0, if the device
+		 * doesn't depend on any power resources and _PSC returns 3,
+		 * that means "power off".  We need to maintain compatibility
+		 * with those systems.
+		 */
+		if (psc > result && psc < ACPI_STATE_D3_COLD)
+			result = psc;
+		else if (result == ACPI_STATE_UNKNOWN)
+			result = psc > ACPI_STATE_D2 ? ACPI_STATE_D3_COLD : psc;
 	}
 
 	/*

commit 511d5c4212948fe55035b8fed61ac0e125af5a05
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Feb 3 14:57:32 2013 +0100

    ACPI / PM: Handle missing _PSC in acpi_bus_update_power()
    
    If _PS0 is defined for an ACPI device node, but _PSC isn't and
    the device node doesn't use power resources for power management,
    acpi_bus_update_power() will fail to update the power state of it,
    because acpi_device_get_power() returns ACPI_STATE_UNKNOWN in that
    case.
    
    To handle that situation make acpi_bus_update_power() follow
    acpi_bus_init_power() and try to force the given device node into
    power state D0.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 164d609d7c9e..dd314ef9bff1 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -355,6 +355,9 @@ int acpi_bus_update_power(acpi_handle handle, int *state_p)
 	if (result)
 		return result;
 
+	if (state == ACPI_STATE_UNKNOWN)
+		state = ACPI_STATE_D0;
+
 	result = acpi_device_set_power(device, state);
 	if (!result && state_p)
 		*state_p = state;

commit b3785492268f9f3cdaa9722facb84b266dcf8bf6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 1 23:43:02 2013 +0100

    ACPI / PM: Do not power manage devices in unknown initial states
    
    In general, for ACPI device power management to work, the initial
    power states of devices must be known (otherwise, we wouldn't be able
    to keep track of power resources, for example).  Hence, if it is
    impossible to determine the initial ACPI power states of some
    devices, they can't be regarded as power-manageable using ACPI.
    
    For this reason, modify acpi_bus_get_power_flags() to clear the
    power_manageable flag if acpi_bus_init_power() fails and add some
    extra fallback code to acpi_bus_init_power() to cover broken
    BIOSes that provide _PS0/_PS3 without _PSC for some devices.
    
    Verified to work on my HP nx6325 that has this problem.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Peter Wu <lekensteyn@gmail.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 3ef075b71870..164d609d7c9e 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -330,6 +330,12 @@ int acpi_bus_init_power(struct acpi_device *device)
 		result = acpi_dev_pm_explicit_set(device, state);
 		if (result)
 			return result;
+	} else if (state == ACPI_STATE_UNKNOWN) {
+		/* No power resources and missing _PSC? Try to force D0. */
+		state = ACPI_STATE_D0;
+		result = acpi_dev_pm_explicit_set(device, state);
+		if (result)
+			return result;
 	}
 	device->power.state = state;
 	return 0;

commit dde3bb4159dfd872a755922b6a22e005e78389b6
Author: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
Date:   Thu Jan 31 03:22:14 2013 +0000

    ACPI / PM: Fix acpi_bus_get_device() check in drivers/acpi/device_pm.c
    
    acpi_bus_get_device() returns int not acpi_status.
    
    The patch change not to apply ACPI_FAILURE() to the return value of
    acpi_bus_get_device().
    
    Signed-off-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 4cbc9505b365..3ef075b71870 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -497,7 +497,7 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 	acpi_handle handle = DEVICE_ACPI_HANDLE(dev);
 	struct acpi_device *adev;
 
-	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &adev))) {
+	if (!handle || acpi_bus_get_device(handle, &adev)) {
 		dev_dbg(dev, "ACPI handle without context in %s!\n", __func__);
 		return -ENODEV;
 	}
@@ -574,7 +574,7 @@ int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
 		return -EINVAL;
 
 	handle = DEVICE_ACPI_HANDLE(phys_dev);
-	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &adev))) {
+	if (!handle || acpi_bus_get_device(handle, &adev)) {
 		dev_dbg(phys_dev, "ACPI handle without context in %s!\n",
 			__func__);
 		return -ENODEV;
@@ -618,7 +618,7 @@ int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
 		return -EINVAL;
 
 	handle = DEVICE_ACPI_HANDLE(dev);
-	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &adev))) {
+	if (!handle || acpi_bus_get_device(handle, &adev)) {
 		dev_dbg(dev, "ACPI handle without context in %s!\n", __func__);
 		return -ENODEV;
 	}

commit e5656271b0221a53e9f74856385112fdcec0dd60
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 22 12:56:35 2013 +0100

    ACPI / PM: Fix device power state value after transitions to D3cold
    
    When a transition to the D3cold power state is requested,
    acpi_device_set_power() first carries out a transition to D3hot and
    then turns off the device's power resources.  However, it fails to
    update the device's power.state field appropriately and D3hot is
    stored in it as a result.
    
    Fix this, but make sure that the device's power state will be
    D3hot if its power resources cannot be turned off in the final
    step.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 61ae99b09f1c..4cbc9505b365 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -264,8 +264,11 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 	if (result)
 		goto end;
 
-	if (cut_power)
-		result = acpi_power_transition(device, ACPI_STATE_D3_COLD);
+	if (cut_power) {
+		device->power.state = state;
+		state = ACPI_STATE_D3_COLD;
+		result = acpi_power_transition(device, state);
+	}
 
  end:
 	if (result) {

commit 898fee4f6ed52b5b5dd159b221d2ad7ce40ae2dd
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 22 12:56:26 2013 +0100

    ACPI / PM: Use string "D3cold" to represent ACPI_STATE_D3_COLD
    
    Make acpi_power_state_string() return "D3cold" as the string
    representation of ACPI power state D3cold instead of "D3" returned
    currently, which is confusing.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 2ce07cee0434..61ae99b09f1c 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -115,7 +115,7 @@ const char *acpi_power_state_string(int state)
 	case ACPI_STATE_D3_HOT:
 		return "D3hot";
 	case ACPI_STATE_D3_COLD:
-		return "D3";
+		return "D3cold";
 	default:
 		return "(unknown)";
 	}

commit e78adb7595a9d585c60a7497345cb6eaeaaacefb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 22 12:56:04 2013 +0100

    ACPI / PM: Always evaluate _PSn after setting power resources
    
    The ACPI specitication (ACPI 5, Sections 7.2.8 - 7.2.11) requires
    that the _PSn (n = 0..3) method, if present, be executed after the
    power resources for the given device power state have been set
    appropriately.  However, acpi_device_set_power() does that only
    if the new power state is going to be higher-power (lower-number)
    than the power state the device is in already.  Otherwise, the
    ordering is reverse to protect against situations in which _PSn
    might access device registers unavailable after configuring the
    power resources for power state Dn (D3 meaning D3hot).
    
    Such situations are very unlikely to happen, though, and _PSn may
    actually be implemented with the assumption that power resources
    have been configured for power state Dn in advance, so change the
    code to follow the specification literally.
    
    This change was previously porposed in a different form by Lv Zheng.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index d7f3908c2e88..2ce07cee0434 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -242,50 +242,38 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 		cut_power = true;
 	}
 
+	if (state < device->power.state && state != ACPI_STATE_D0
+	    && device->power.state >= ACPI_STATE_D3_HOT) {
+		printk(KERN_WARNING PREFIX
+			"Cannot transition to non-D0 state from D3\n");
+		return -ENODEV;
+	}
+
 	/*
 	 * Transition Power
 	 * ----------------
-	 * On transitions to a high-powered state we first apply power (via
-	 * power resources) then evalute _PSx.  Conversly for transitions to
-	 * a lower-powered state.
+	 * In accordance with the ACPI specification first apply power (via
+	 * power resources) and then evalute _PSx.
 	 */
-	if (state < device->power.state) {
-		if (device->power.state >= ACPI_STATE_D3_HOT &&
-		    state != ACPI_STATE_D0) {
-			printk(KERN_WARNING PREFIX
-			      "Cannot transition to non-D0 state from D3\n");
-			return -ENODEV;
-		}
-		if (device->power.flags.power_resources) {
-			result = acpi_power_transition(device, state);
-			if (result)
-				goto end;
-		}
-		result = acpi_dev_pm_explicit_set(device, state);
+	if (device->power.flags.power_resources) {
+		result = acpi_power_transition(device, state);
 		if (result)
 			goto end;
-	} else {
-		result = acpi_dev_pm_explicit_set(device, state);
-		if (result)
-			goto end;
-
-		if (device->power.flags.power_resources) {
-			result = acpi_power_transition(device, state);
-			if (result)
-				goto end;
-		}
 	}
+	result = acpi_dev_pm_explicit_set(device, state);
+	if (result)
+		goto end;
 
 	if (cut_power)
 		result = acpi_power_transition(device, ACPI_STATE_D3_COLD);
 
-      end:
-	if (result)
+ end:
+	if (result) {
 		printk(KERN_WARNING PREFIX
 			      "Device [%s] failed to transition to %s\n",
 			      device->pnp.bus_id,
 			      acpi_power_state_string(state));
-	else {
+	} else {
 		device->power.state = state;
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Device [%s] transitioned to %s\n",

commit 9c0f45e388fb9f9003ea22f98b84ffbab65ba554
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 22 12:55:52 2013 +0100

    ACPI / PM: Introduce helper for executing _PSn methods
    
    To reduce code duplication between acpi_device_set_power() and
    acpi_bus_init_power(), introduce a new helper function for executing
    ACPI devices' _PSn (n = 0..3) methods, acpi_dev_pm_explicit_set().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index c87853f583d8..d7f3908c2e88 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -186,6 +186,19 @@ int acpi_device_get_power(struct acpi_device *device, int *state)
 	return 0;
 }
 
+static int acpi_dev_pm_explicit_set(struct acpi_device *adev, int state)
+{
+	if (adev->power.states[state].flags.explicit_set) {
+		char method[5] = { '_', 'P', 'S', '0' + state, '\0' };
+		acpi_status status;
+
+		status = acpi_evaluate_object(adev->handle, method, NULL, NULL);
+		if (ACPI_FAILURE(status))
+			return -ENODEV;
+	}
+	return 0;
+}
+
 /**
  * acpi_device_set_power - Set power state of an ACPI device.
  * @device: Device to set the power state of.
@@ -197,8 +210,6 @@ int acpi_device_get_power(struct acpi_device *device, int *state)
 int acpi_device_set_power(struct acpi_device *device, int state)
 {
 	int result = 0;
-	acpi_status status = AE_OK;
-	char object_name[5] = { '_', 'P', 'S', '0' + state, '\0' };
 	bool cut_power = false;
 
 	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3_COLD))
@@ -228,7 +239,6 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 	if (state == ACPI_STATE_D3_COLD
 	    && device->power.states[ACPI_STATE_D3_COLD].flags.os_accessible) {
 		state = ACPI_STATE_D3_HOT;
-		object_name[3] = '3';
 		cut_power = true;
 	}
 
@@ -251,23 +261,14 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 			if (result)
 				goto end;
 		}
-		if (device->power.states[state].flags.explicit_set) {
-			status = acpi_evaluate_object(device->handle,
-						      object_name, NULL, NULL);
-			if (ACPI_FAILURE(status)) {
-				result = -ENODEV;
-				goto end;
-			}
-		}
+		result = acpi_dev_pm_explicit_set(device, state);
+		if (result)
+			goto end;
 	} else {
-		if (device->power.states[state].flags.explicit_set) {
-			status = acpi_evaluate_object(device->handle,
-						      object_name, NULL, NULL);
-			if (ACPI_FAILURE(status)) {
-				result = -ENODEV;
-				goto end;
-			}
-		}
+		result = acpi_dev_pm_explicit_set(device, state);
+		if (result)
+			goto end;
+
 		if (device->power.flags.power_resources) {
 			result = acpi_power_transition(device, state);
 			if (result)
@@ -335,15 +336,9 @@ int acpi_bus_init_power(struct acpi_device *device)
 		if (result)
 			return result;
 
-		if (device->power.states[state].flags.explicit_set) {
-			char method[5] = { '_', 'P', 'S', '0' + state, '\0' };
-			acpi_status status;
-
-			status = acpi_evaluate_object(device->handle, method,
-						      NULL, NULL);
-			if (ACPI_FAILURE(status))
-				return -ENODEV;
-		}
+		result = acpi_dev_pm_explicit_set(device, state);
+		if (result)
+			return result;
 	}
 	device->power.state = state;
 	return 0;

commit a2367807b8d2c0aca5afb92fead2537dcd3d10b0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 22 12:54:38 2013 +0100

    ACPI / PM: Make acpi_bus_init_power() more robust
    
    The ACPI specification requires the _PSC method to be present under
    a device object if its power state cannot be inferred from the states
    of power resources used by it (ACPI 5, Section 7.6.2).  However, it
    also requires that (for power states D0-D2 and D3hot) if the _PSn
    (n = 0, 1, 2, 3) method is present under the device object, it also
    must be executed after the power resources have been set
    appropriately for the device to go into power state Dn (D3 means
    D3hot in this case).  Thus it is not clear from the specification
    whether or not the _PSn method should be executed if the initial
    configuraion of power resources used by the device indicates power
    state Dn and the _PSC method is not present.
    
    The current implementation of acpi_bus_init_power() is based on the
    assumption that it should not be necessary to execute _PSn in the
    above situation, but experience shows that in fact that assumption
    need not be satisfied.  For this reason, make acpi_bus_init_power()
    always execute _PSn if the initial configuration of device power
    resources indicates power state Dn.
    
    Reported-and-tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 43116cdbabf9..c87853f583d8 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -330,13 +330,23 @@ int acpi_bus_init_power(struct acpi_device *device)
 	if (result)
 		return result;
 
-	if (device->power.flags.power_resources)
+	if (state < ACPI_STATE_D3_COLD && device->power.flags.power_resources) {
 		result = acpi_power_on_resources(device, state);
+		if (result)
+			return result;
 
-	if (!result)
-		device->power.state = state;
+		if (device->power.states[state].flags.explicit_set) {
+			char method[5] = { '_', 'P', 'S', '0' + state, '\0' };
+			acpi_status status;
 
-	return result;
+			status = acpi_evaluate_object(device->handle, method,
+						      NULL, NULL);
+			if (ACPI_FAILURE(status))
+				return -ENODEV;
+		}
+	}
+	device->power.state = state;
+	return 0;
 }
 
 int acpi_bus_update_power(acpi_handle handle, int *state_p)

commit 4d56410b955c3f4f7651a088e1c7a19a0d5d4e4c
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Jan 14 20:13:37 2013 +0000

    ACPI / PM: remove leading whitespace from #ifdef
    
    It is there probably due to an accident, get rid of it so that the format
    is consistent across the file.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 8bca7465c78d..43116cdbabf9 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -592,7 +592,7 @@ static inline void acpi_wakeup_device(acpi_handle handle, u32 event,
 				      void *context) {}
 #endif /* CONFIG_PM_RUNTIME */
 
- #ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM_SLEEP
 /**
  * __acpi_device_sleep_wake - Enable or disable device to wake up the system.
  * @dev: Device to enable/desible to wake up the system.

commit 9ce4e607111764673f7a59d7bc87a16ade5c7bba
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:08 2013 +0100

    ACPI / PM: Move device power management functions to device_pm.c
    
    Move ACPI device power management functions from drivers/acpi/bus.c
    to drivers/acpi/device_pm.c.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 8be4b29e38aa..8bca7465c78d 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -30,6 +30,12 @@
 
 #include <acpi/acpi.h>
 #include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+#include "internal.h"
+
+#define _COMPONENT	ACPI_POWER_COMPONENT
+ACPI_MODULE_NAME("device_pm");
 
 static DEFINE_MUTEX(acpi_pm_notifier_lock);
 
@@ -93,6 +99,288 @@ acpi_status acpi_remove_pm_notifier(struct acpi_device *adev,
 	return status;
 }
 
+/**
+ * acpi_power_state_string - String representation of ACPI device power state.
+ * @state: ACPI device power state to return the string representation of.
+ */
+const char *acpi_power_state_string(int state)
+{
+	switch (state) {
+	case ACPI_STATE_D0:
+		return "D0";
+	case ACPI_STATE_D1:
+		return "D1";
+	case ACPI_STATE_D2:
+		return "D2";
+	case ACPI_STATE_D3_HOT:
+		return "D3hot";
+	case ACPI_STATE_D3_COLD:
+		return "D3";
+	default:
+		return "(unknown)";
+	}
+}
+
+/**
+ * acpi_device_get_power - Get power state of an ACPI device.
+ * @device: Device to get the power state of.
+ * @state: Place to store the power state of the device.
+ *
+ * This function does not update the device's power.state field, but it may
+ * update its parent's power.state field (when the parent's power state is
+ * unknown and the device's power state turns out to be D0).
+ */
+int acpi_device_get_power(struct acpi_device *device, int *state)
+{
+	int result = ACPI_STATE_UNKNOWN;
+
+	if (!device || !state)
+		return -EINVAL;
+
+	if (!device->flags.power_manageable) {
+		/* TBD: Non-recursive algorithm for walking up hierarchy. */
+		*state = device->parent ?
+			device->parent->power.state : ACPI_STATE_D0;
+		goto out;
+	}
+
+	/*
+	 * Get the device's power state either directly (via _PSC) or
+	 * indirectly (via power resources).
+	 */
+	if (device->power.flags.explicit_get) {
+		unsigned long long psc;
+		acpi_status status = acpi_evaluate_integer(device->handle,
+							   "_PSC", NULL, &psc);
+		if (ACPI_FAILURE(status))
+			return -ENODEV;
+
+		result = psc;
+	}
+	/* The test below covers ACPI_STATE_UNKNOWN too. */
+	if (result <= ACPI_STATE_D2) {
+	  ; /* Do nothing. */
+	} else if (device->power.flags.power_resources) {
+		int error = acpi_power_get_inferred_state(device, &result);
+		if (error)
+			return error;
+	} else if (result == ACPI_STATE_D3_HOT) {
+		result = ACPI_STATE_D3;
+	}
+
+	/*
+	 * If we were unsure about the device parent's power state up to this
+	 * point, the fact that the device is in D0 implies that the parent has
+	 * to be in D0 too.
+	 */
+	if (device->parent && device->parent->power.state == ACPI_STATE_UNKNOWN
+	    && result == ACPI_STATE_D0)
+		device->parent->power.state = ACPI_STATE_D0;
+
+	*state = result;
+
+ out:
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] power state is %s\n",
+			  device->pnp.bus_id, acpi_power_state_string(*state)));
+
+	return 0;
+}
+
+/**
+ * acpi_device_set_power - Set power state of an ACPI device.
+ * @device: Device to set the power state of.
+ * @state: New power state to set.
+ *
+ * Callers must ensure that the device is power manageable before using this
+ * function.
+ */
+int acpi_device_set_power(struct acpi_device *device, int state)
+{
+	int result = 0;
+	acpi_status status = AE_OK;
+	char object_name[5] = { '_', 'P', 'S', '0' + state, '\0' };
+	bool cut_power = false;
+
+	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3_COLD))
+		return -EINVAL;
+
+	/* Make sure this is a valid target state */
+
+	if (state == device->power.state) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at %s\n",
+				  acpi_power_state_string(state)));
+		return 0;
+	}
+
+	if (!device->power.states[state].flags.valid) {
+		printk(KERN_WARNING PREFIX "Device does not support %s\n",
+		       acpi_power_state_string(state));
+		return -ENODEV;
+	}
+	if (device->parent && (state < device->parent->power.state)) {
+		printk(KERN_WARNING PREFIX
+			      "Cannot set device to a higher-powered"
+			      " state than parent\n");
+		return -ENODEV;
+	}
+
+	/* For D3cold we should first transition into D3hot. */
+	if (state == ACPI_STATE_D3_COLD
+	    && device->power.states[ACPI_STATE_D3_COLD].flags.os_accessible) {
+		state = ACPI_STATE_D3_HOT;
+		object_name[3] = '3';
+		cut_power = true;
+	}
+
+	/*
+	 * Transition Power
+	 * ----------------
+	 * On transitions to a high-powered state we first apply power (via
+	 * power resources) then evalute _PSx.  Conversly for transitions to
+	 * a lower-powered state.
+	 */
+	if (state < device->power.state) {
+		if (device->power.state >= ACPI_STATE_D3_HOT &&
+		    state != ACPI_STATE_D0) {
+			printk(KERN_WARNING PREFIX
+			      "Cannot transition to non-D0 state from D3\n");
+			return -ENODEV;
+		}
+		if (device->power.flags.power_resources) {
+			result = acpi_power_transition(device, state);
+			if (result)
+				goto end;
+		}
+		if (device->power.states[state].flags.explicit_set) {
+			status = acpi_evaluate_object(device->handle,
+						      object_name, NULL, NULL);
+			if (ACPI_FAILURE(status)) {
+				result = -ENODEV;
+				goto end;
+			}
+		}
+	} else {
+		if (device->power.states[state].flags.explicit_set) {
+			status = acpi_evaluate_object(device->handle,
+						      object_name, NULL, NULL);
+			if (ACPI_FAILURE(status)) {
+				result = -ENODEV;
+				goto end;
+			}
+		}
+		if (device->power.flags.power_resources) {
+			result = acpi_power_transition(device, state);
+			if (result)
+				goto end;
+		}
+	}
+
+	if (cut_power)
+		result = acpi_power_transition(device, ACPI_STATE_D3_COLD);
+
+      end:
+	if (result)
+		printk(KERN_WARNING PREFIX
+			      "Device [%s] failed to transition to %s\n",
+			      device->pnp.bus_id,
+			      acpi_power_state_string(state));
+	else {
+		device->power.state = state;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Device [%s] transitioned to %s\n",
+				  device->pnp.bus_id,
+				  acpi_power_state_string(state)));
+	}
+
+	return result;
+}
+EXPORT_SYMBOL(acpi_device_set_power);
+
+int acpi_bus_set_power(acpi_handle handle, int state)
+{
+	struct acpi_device *device;
+	int result;
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result)
+		return result;
+
+	if (!device->flags.power_manageable) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				"Device [%s] is not power manageable\n",
+				dev_name(&device->dev)));
+		return -ENODEV;
+	}
+
+	return acpi_device_set_power(device, state);
+}
+EXPORT_SYMBOL(acpi_bus_set_power);
+
+int acpi_bus_init_power(struct acpi_device *device)
+{
+	int state;
+	int result;
+
+	if (!device)
+		return -EINVAL;
+
+	device->power.state = ACPI_STATE_UNKNOWN;
+
+	result = acpi_device_get_power(device, &state);
+	if (result)
+		return result;
+
+	if (device->power.flags.power_resources)
+		result = acpi_power_on_resources(device, state);
+
+	if (!result)
+		device->power.state = state;
+
+	return result;
+}
+
+int acpi_bus_update_power(acpi_handle handle, int *state_p)
+{
+	struct acpi_device *device;
+	int state;
+	int result;
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result)
+		return result;
+
+	result = acpi_device_get_power(device, &state);
+	if (result)
+		return result;
+
+	result = acpi_device_set_power(device, state);
+	if (!result && state_p)
+		*state_p = state;
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(acpi_bus_update_power);
+
+bool acpi_bus_power_manageable(acpi_handle handle)
+{
+	struct acpi_device *device;
+	int result;
+
+	result = acpi_bus_get_device(handle, &device);
+	return result ? false : device->flags.power_manageable;
+}
+EXPORT_SYMBOL(acpi_bus_power_manageable);
+
+bool acpi_bus_can_wakeup(acpi_handle handle)
+{
+	struct acpi_device *device;
+	int result;
+
+	result = acpi_bus_get_device(handle, &device);
+	return result ? false : device->wakeup.flags.valid;
+}
+EXPORT_SYMBOL(acpi_bus_can_wakeup);
+
 /**
  * acpi_device_power_state - Get preferred power state of ACPI device.
  * @dev: Device whose preferred target power state to return.

commit bc9b6407bd6df3ab7189e5622816bbc11ae9d2d8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:05 2013 +0100

    ACPI / PM: Rework the handling of devices depending on power resources
    
    Commit 0090def6 (ACPI: Add interface to register/unregister device
    to/from power resources) made it possible to indicate to the ACPI
    core that if the given device depends on any power resources, then
    it should be resumed as soon as all of the power resources required
    by it to transition to the D0 power state have been turned on.
    
    Unfortunately, however, this was a mistake, because all devices
    depending on power resources should be treated this way (i.e. they
    should be resumed when all power resources required by their D0
    state have been turned on) and for the majority of those devices
    the ACPI core can figure out by itself which (physical) devices
    depend on what power resources.
    
    For this reason, replace the code added by commit 0090def6 with a
    new, much more straightforward, mechanism that will be used
    internally by the ACPI core and remove all references to that code
    from kernel subsystems using ACPI.
    
    For the cases when there are (physical) devices that should be
    resumed whenever a not directly related ACPI device node goes into
    D0 as a result of power resources configuration changes, like in
    the SATA case, add two new routines, acpi_dev_pm_add_dependent()
    and acpi_dev_pm_remove_dependent(), allowing subsystems to manage
    such dependencies.  Convert the SATA subsystem to use the new
    functions accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 995019063f64..8be4b29e38aa 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -665,3 +665,59 @@ void acpi_dev_pm_detach(struct device *dev, bool power_off)
 	}
 }
 EXPORT_SYMBOL_GPL(acpi_dev_pm_detach);
+
+/**
+ * acpi_dev_pm_add_dependent - Add physical device depending for PM.
+ * @handle: Handle of ACPI device node.
+ * @depdev: Device depending on that node for PM.
+ */
+void acpi_dev_pm_add_dependent(acpi_handle handle, struct device *depdev)
+{
+	struct acpi_device_physical_node *dep;
+	struct acpi_device *adev;
+
+	if (!depdev || acpi_bus_get_device(handle, &adev))
+		return;
+
+	mutex_lock(&adev->physical_node_lock);
+
+	list_for_each_entry(dep, &adev->power_dependent, node)
+		if (dep->dev == depdev)
+			goto out;
+
+	dep = kzalloc(sizeof(*dep), GFP_KERNEL);
+	if (dep) {
+		dep->dev = depdev;
+		list_add_tail(&dep->node, &adev->power_dependent);
+	}
+
+ out:
+	mutex_unlock(&adev->physical_node_lock);
+}
+EXPORT_SYMBOL_GPL(acpi_dev_pm_add_dependent);
+
+/**
+ * acpi_dev_pm_remove_dependent - Remove physical device depending for PM.
+ * @handle: Handle of ACPI device node.
+ * @depdev: Device depending on that node for PM.
+ */
+void acpi_dev_pm_remove_dependent(acpi_handle handle, struct device *depdev)
+{
+	struct acpi_device_physical_node *dep;
+	struct acpi_device *adev;
+
+	if (!depdev || acpi_bus_get_device(handle, &adev))
+		return;
+
+	mutex_lock(&adev->physical_node_lock);
+
+	list_for_each_entry(dep, &adev->power_dependent, node)
+		if (dep->dev == depdev) {
+			list_del(&dep->node);
+			kfree(dep);
+			break;
+		}
+
+	mutex_unlock(&adev->physical_node_lock);
+}
+EXPORT_SYMBOL_GPL(acpi_dev_pm_remove_dependent);

commit 6a8dd80821c215bc49bf6b108e85c1738c82bf43
Merge: 9931faca02c6 5993c4670ea2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:10:27 2013 +0100

    Merge branch 'acpi-scan' into acpi-pm
    
    The following commits depend on the 'acpi-scan' material.

commit 5cc36c724eb60b5e5457807f3230e5bb5454e4d0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 16 23:28:53 2012 +0100

    ACPI / PM: Do not apply ACPI_SUCCESS() to acpi_bus_get_device() result
    
    Since the return value of acpi_bus_get_device() is not of type
    acpi_status, ACPI_SUCCESS() should not be used for checking its
    return value.  Fix that.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index f09dc987cf17..c6ff606c6d5b 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -358,8 +358,7 @@ static struct acpi_device *acpi_dev_pm_get_node(struct device *dev)
 	acpi_handle handle = DEVICE_ACPI_HANDLE(dev);
 	struct acpi_device *adev;
 
-	return handle && ACPI_SUCCESS(acpi_bus_get_device(handle, &adev)) ?
-		adev : NULL;
+	return handle && !acpi_bus_get_device(handle, &adev) ? adev : NULL;
 }
 
 /**

commit d2e5f0c16ad60a7208fd371233e63b73c990ece2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 23 00:02:44 2012 +0100

    ACPI / PCI: Rework the setup and cleanup of device wakeup
    
    Currently, the ACPI wakeup capability of PCI devices is set up
    in two different places, partially in acpi_pci_bind() where
    runtime wakeup is initialized and partially in
    platform_pci_wakeup_init(), where system wakeup is initialized.
    The cleanup is only done in acpi_pci_unbind() and it only covers
    runtime wakeup.
    
    Use the new .setup() and .cleanup() callbacks in struct acpi_bus_type
    to consolidate that code and do the setup and the cleanup each in one
    place.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index f09dc987cf17..e4f6ac95595c 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -353,7 +353,7 @@ int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
  * acpi_dev_pm_get_node - Get ACPI device node for the given physical device.
  * @dev: Device to get the ACPI node for.
  */
-static struct acpi_device *acpi_dev_pm_get_node(struct device *dev)
+struct acpi_device *acpi_dev_pm_get_node(struct device *dev)
 {
 	acpi_handle handle = DEVICE_ACPI_HANDLE(dev);
 	struct acpi_device *adev;

commit b88ce2a41562d1a9554f209e0f31a32d9f473794
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 26 10:03:06 2012 +0100

    ACPI / PM: Allow attach/detach routines to change device power states
    
    Make it possible to ask the routines used for adding/removing devices
    to/from the general ACPI PM domain, acpi_dev_pm_attach() and
    acpi_dev_pm_detach(), respectively, to change the power states of
    devices so that they are put into the full-power state automatically
    by acpi_dev_pm_attach() and into the lowest-power state available
    automatically by acpi_dev_pm_detach().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index a8e059f69d50..f09dc987cf17 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -599,10 +599,12 @@ static struct dev_pm_domain acpi_general_pm_domain = {
 /**
  * acpi_dev_pm_attach - Prepare device for ACPI power management.
  * @dev: Device to prepare.
+ * @power_on: Whether or not to power on the device.
  *
  * If @dev has a valid ACPI handle that has a valid struct acpi_device object
  * attached to it, install a wakeup notification handler for the device and
- * add it to the general ACPI PM domain.
+ * add it to the general ACPI PM domain.  If @power_on is set, the device will
+ * be put into the ACPI D0 state before the function returns.
  *
  * This assumes that the @dev's bus type uses generic power management callbacks
  * (or doesn't use any power management callbacks at all).
@@ -610,7 +612,7 @@ static struct dev_pm_domain acpi_general_pm_domain = {
  * Callers must ensure proper synchronization of this function with power
  * management callbacks.
  */
-int acpi_dev_pm_attach(struct device *dev)
+int acpi_dev_pm_attach(struct device *dev, bool power_on)
 {
 	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
 
@@ -622,6 +624,10 @@ int acpi_dev_pm_attach(struct device *dev)
 
 	acpi_add_pm_notifier(adev, acpi_wakeup_device, dev);
 	dev->pm_domain = &acpi_general_pm_domain;
+	if (power_on) {
+		acpi_dev_pm_full_power(adev);
+		__acpi_device_run_wake(adev, false);
+	}
 	return 0;
 }
 EXPORT_SYMBOL_GPL(acpi_dev_pm_attach);
@@ -629,20 +635,34 @@ EXPORT_SYMBOL_GPL(acpi_dev_pm_attach);
 /**
  * acpi_dev_pm_detach - Remove ACPI power management from the device.
  * @dev: Device to take care of.
+ * @power_off: Whether or not to try to remove power from the device.
  *
  * Remove the device from the general ACPI PM domain and remove its wakeup
- * notifier.
+ * notifier.  If @power_off is set, additionally remove power from the device if
+ * possible.
  *
  * Callers must ensure proper synchronization of this function with power
  * management callbacks.
  */
-void acpi_dev_pm_detach(struct device *dev)
+void acpi_dev_pm_detach(struct device *dev, bool power_off)
 {
 	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
 
 	if (adev && dev->pm_domain == &acpi_general_pm_domain) {
 		dev->pm_domain = NULL;
 		acpi_remove_pm_notifier(adev, acpi_wakeup_device);
+		if (power_off) {
+			/*
+			 * If the device's PM QoS resume latency limit or flags
+			 * have been exposed to user space, they have to be
+			 * hidden at this point, so that they don't affect the
+			 * choice of the low-power state to put the device into.
+			 */
+			dev_pm_qos_hide_latency_limit(dev);
+			dev_pm_qos_hide_flags(dev);
+			__acpi_device_run_wake(adev, false);
+			acpi_dev_pm_low_power(dev, adev, ACPI_STATE_S0);
+		}
 	}
 }
 EXPORT_SYMBOL_GPL(acpi_dev_pm_detach);

commit e5cc8ef31267317f3e177415c84e3f3602e5bfc9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 2 01:41:01 2012 +0100

    ACPI / PM: Provide ACPI PM callback routines for subsystems
    
    Some bus types don't support power management natively, but generally
    there may be device nodes in ACPI tables corresponding to the devices
    whose bus types they are (under ACPI 5 those bus types may be SPI,
    I2C and platform).  If that is the case, standard ACPI power
    management may be applied to those devices, although currently the
    kernel has no means for that.
    
    For this reason, provide a set of routines that may be used as power
    management callbacks for such devices.  This may be done in three
    different ways.
    
     (1) Device drivers handling the devices in question may run
         acpi_dev_pm_attach() in their .probe() routines, which (on
         success) will cause the devices to be added to the general ACPI
         PM domain and ACPI power management will be used for them going
         forward.  Then, acpi_dev_pm_detach() may be used to remove the
         devices from the general ACPI PM domain if ACPI power management
         is not necessary for them any more.
    
     (2) The devices' subsystems may use acpi_subsys_runtime_suspend(),
         acpi_subsys_runtime_resume(), acpi_subsys_prepare(),
         acpi_subsys_suspend_late(), acpi_subsys_resume_early() as their
         power management callbacks in the same way as the general ACPI
         PM domain does that.
    
     (3) The devices' drivers may execute acpi_dev_suspend_late(),
         acpi_dev_resume_early(), acpi_dev_runtime_suspend(),
         acpi_dev_runtime_resume() from their power management callbacks
         as appropriate, if that's absolutely necessary, but it is not
         recommended to do that, because such drivers may not work
         without ACPI support as a result.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 7ddd93463a2e..a8e059f69d50 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -224,6 +224,22 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 EXPORT_SYMBOL(acpi_pm_device_sleep_state);
 
 #ifdef CONFIG_PM_RUNTIME
+/**
+ * acpi_wakeup_device - Wakeup notification handler for ACPI devices.
+ * @handle: ACPI handle of the device the notification is for.
+ * @event: Type of the signaled event.
+ * @context: Device corresponding to @handle.
+ */
+static void acpi_wakeup_device(acpi_handle handle, u32 event, void *context)
+{
+	struct device *dev = context;
+
+	if (event == ACPI_NOTIFY_DEVICE_WAKE && dev) {
+		pm_wakeup_event(dev, 0);
+		pm_runtime_resume(dev);
+	}
+}
+
 /**
  * __acpi_device_run_wake - Enable/disable runtime remote wakeup for device.
  * @adev: ACPI device to enable/disable the remote wakeup for.
@@ -283,6 +299,9 @@ int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
 	return __acpi_device_run_wake(adev, enable);
 }
 EXPORT_SYMBOL(acpi_pm_device_run_wake);
+#else
+static inline void acpi_wakeup_device(acpi_handle handle, u32 event,
+				      void *context) {}
 #endif /* CONFIG_PM_RUNTIME */
 
  #ifdef CONFIG_PM_SLEEP
@@ -329,3 +348,301 @@ int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
 	return error;
 }
 #endif /* CONFIG_PM_SLEEP */
+
+/**
+ * acpi_dev_pm_get_node - Get ACPI device node for the given physical device.
+ * @dev: Device to get the ACPI node for.
+ */
+static struct acpi_device *acpi_dev_pm_get_node(struct device *dev)
+{
+	acpi_handle handle = DEVICE_ACPI_HANDLE(dev);
+	struct acpi_device *adev;
+
+	return handle && ACPI_SUCCESS(acpi_bus_get_device(handle, &adev)) ?
+		adev : NULL;
+}
+
+/**
+ * acpi_dev_pm_low_power - Put ACPI device into a low-power state.
+ * @dev: Device to put into a low-power state.
+ * @adev: ACPI device node corresponding to @dev.
+ * @system_state: System state to choose the device state for.
+ */
+static int acpi_dev_pm_low_power(struct device *dev, struct acpi_device *adev,
+				 u32 system_state)
+{
+	int power_state;
+
+	if (!acpi_device_power_manageable(adev))
+		return 0;
+
+	power_state = acpi_device_power_state(dev, adev, system_state,
+					      ACPI_STATE_D3, NULL);
+	if (power_state < ACPI_STATE_D0 || power_state > ACPI_STATE_D3)
+		return -EIO;
+
+	return acpi_device_set_power(adev, power_state);
+}
+
+/**
+ * acpi_dev_pm_full_power - Put ACPI device into the full-power state.
+ * @adev: ACPI device node to put into the full-power state.
+ */
+static int acpi_dev_pm_full_power(struct acpi_device *adev)
+{
+	return acpi_device_power_manageable(adev) ?
+		acpi_device_set_power(adev, ACPI_STATE_D0) : 0;
+}
+
+#ifdef CONFIG_PM_RUNTIME
+/**
+ * acpi_dev_runtime_suspend - Put device into a low-power state using ACPI.
+ * @dev: Device to put into a low-power state.
+ *
+ * Put the given device into a runtime low-power state using the standard ACPI
+ * mechanism.  Set up remote wakeup if desired, choose the state to put the
+ * device into (this checks if remote wakeup is expected to work too), and set
+ * the power state of the device.
+ */
+int acpi_dev_runtime_suspend(struct device *dev)
+{
+	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
+	bool remote_wakeup;
+	int error;
+
+	if (!adev)
+		return 0;
+
+	remote_wakeup = dev_pm_qos_flags(dev, PM_QOS_FLAG_REMOTE_WAKEUP) >
+				PM_QOS_FLAGS_NONE;
+	error = __acpi_device_run_wake(adev, remote_wakeup);
+	if (remote_wakeup && error)
+		return -EAGAIN;
+
+	error = acpi_dev_pm_low_power(dev, adev, ACPI_STATE_S0);
+	if (error)
+		__acpi_device_run_wake(adev, false);
+
+	return error;
+}
+EXPORT_SYMBOL_GPL(acpi_dev_runtime_suspend);
+
+/**
+ * acpi_dev_runtime_resume - Put device into the full-power state using ACPI.
+ * @dev: Device to put into the full-power state.
+ *
+ * Put the given device into the full-power state using the standard ACPI
+ * mechanism at run time.  Set the power state of the device to ACPI D0 and
+ * disable remote wakeup.
+ */
+int acpi_dev_runtime_resume(struct device *dev)
+{
+	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
+	int error;
+
+	if (!adev)
+		return 0;
+
+	error = acpi_dev_pm_full_power(adev);
+	__acpi_device_run_wake(adev, false);
+	return error;
+}
+EXPORT_SYMBOL_GPL(acpi_dev_runtime_resume);
+
+/**
+ * acpi_subsys_runtime_suspend - Suspend device using ACPI.
+ * @dev: Device to suspend.
+ *
+ * Carry out the generic runtime suspend procedure for @dev and use ACPI to put
+ * it into a runtime low-power state.
+ */
+int acpi_subsys_runtime_suspend(struct device *dev)
+{
+	int ret = pm_generic_runtime_suspend(dev);
+	return ret ? ret : acpi_dev_runtime_suspend(dev);
+}
+EXPORT_SYMBOL_GPL(acpi_subsys_runtime_suspend);
+
+/**
+ * acpi_subsys_runtime_resume - Resume device using ACPI.
+ * @dev: Device to Resume.
+ *
+ * Use ACPI to put the given device into the full-power state and carry out the
+ * generic runtime resume procedure for it.
+ */
+int acpi_subsys_runtime_resume(struct device *dev)
+{
+	int ret = acpi_dev_runtime_resume(dev);
+	return ret ? ret : pm_generic_runtime_resume(dev);
+}
+EXPORT_SYMBOL_GPL(acpi_subsys_runtime_resume);
+#endif /* CONFIG_PM_RUNTIME */
+
+#ifdef CONFIG_PM_SLEEP
+/**
+ * acpi_dev_suspend_late - Put device into a low-power state using ACPI.
+ * @dev: Device to put into a low-power state.
+ *
+ * Put the given device into a low-power state during system transition to a
+ * sleep state using the standard ACPI mechanism.  Set up system wakeup if
+ * desired, choose the state to put the device into (this checks if system
+ * wakeup is expected to work too), and set the power state of the device.
+ */
+int acpi_dev_suspend_late(struct device *dev)
+{
+	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
+	u32 target_state;
+	bool wakeup;
+	int error;
+
+	if (!adev)
+		return 0;
+
+	target_state = acpi_target_system_state();
+	wakeup = device_may_wakeup(dev);
+	error = __acpi_device_sleep_wake(adev, target_state, wakeup);
+	if (wakeup && error)
+		return error;
+
+	error = acpi_dev_pm_low_power(dev, adev, target_state);
+	if (error)
+		__acpi_device_sleep_wake(adev, ACPI_STATE_UNKNOWN, false);
+
+	return error;
+}
+EXPORT_SYMBOL_GPL(acpi_dev_suspend_late);
+
+/**
+ * acpi_dev_resume_early - Put device into the full-power state using ACPI.
+ * @dev: Device to put into the full-power state.
+ *
+ * Put the given device into the full-power state using the standard ACPI
+ * mechanism during system transition to the working state.  Set the power
+ * state of the device to ACPI D0 and disable remote wakeup.
+ */
+int acpi_dev_resume_early(struct device *dev)
+{
+	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
+	int error;
+
+	if (!adev)
+		return 0;
+
+	error = acpi_dev_pm_full_power(adev);
+	__acpi_device_sleep_wake(adev, ACPI_STATE_UNKNOWN, false);
+	return error;
+}
+EXPORT_SYMBOL_GPL(acpi_dev_resume_early);
+
+/**
+ * acpi_subsys_prepare - Prepare device for system transition to a sleep state.
+ * @dev: Device to prepare.
+ */
+int acpi_subsys_prepare(struct device *dev)
+{
+	/*
+	 * Follow PCI and resume devices suspended at run time before running
+	 * their system suspend callbacks.
+	 */
+	pm_runtime_resume(dev);
+	return pm_generic_prepare(dev);
+}
+EXPORT_SYMBOL_GPL(acpi_subsys_prepare);
+
+/**
+ * acpi_subsys_suspend_late - Suspend device using ACPI.
+ * @dev: Device to suspend.
+ *
+ * Carry out the generic late suspend procedure for @dev and use ACPI to put
+ * it into a low-power state during system transition into a sleep state.
+ */
+int acpi_subsys_suspend_late(struct device *dev)
+{
+	int ret = pm_generic_suspend_late(dev);
+	return ret ? ret : acpi_dev_suspend_late(dev);
+}
+EXPORT_SYMBOL_GPL(acpi_subsys_suspend_late);
+
+/**
+ * acpi_subsys_resume_early - Resume device using ACPI.
+ * @dev: Device to Resume.
+ *
+ * Use ACPI to put the given device into the full-power state and carry out the
+ * generic early resume procedure for it during system transition into the
+ * working state.
+ */
+int acpi_subsys_resume_early(struct device *dev)
+{
+	int ret = acpi_dev_resume_early(dev);
+	return ret ? ret : pm_generic_resume_early(dev);
+}
+EXPORT_SYMBOL_GPL(acpi_subsys_resume_early);
+#endif /* CONFIG_PM_SLEEP */
+
+static struct dev_pm_domain acpi_general_pm_domain = {
+	.ops = {
+#ifdef CONFIG_PM_RUNTIME
+		.runtime_suspend = acpi_subsys_runtime_suspend,
+		.runtime_resume = acpi_subsys_runtime_resume,
+		.runtime_idle = pm_generic_runtime_idle,
+#endif
+#ifdef CONFIG_PM_SLEEP
+		.prepare = acpi_subsys_prepare,
+		.suspend_late = acpi_subsys_suspend_late,
+		.resume_early = acpi_subsys_resume_early,
+		.poweroff_late = acpi_subsys_suspend_late,
+		.restore_early = acpi_subsys_resume_early,
+#endif
+	},
+};
+
+/**
+ * acpi_dev_pm_attach - Prepare device for ACPI power management.
+ * @dev: Device to prepare.
+ *
+ * If @dev has a valid ACPI handle that has a valid struct acpi_device object
+ * attached to it, install a wakeup notification handler for the device and
+ * add it to the general ACPI PM domain.
+ *
+ * This assumes that the @dev's bus type uses generic power management callbacks
+ * (or doesn't use any power management callbacks at all).
+ *
+ * Callers must ensure proper synchronization of this function with power
+ * management callbacks.
+ */
+int acpi_dev_pm_attach(struct device *dev)
+{
+	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
+
+	if (!adev)
+		return -ENODEV;
+
+	if (dev->pm_domain)
+		return -EEXIST;
+
+	acpi_add_pm_notifier(adev, acpi_wakeup_device, dev);
+	dev->pm_domain = &acpi_general_pm_domain;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(acpi_dev_pm_attach);
+
+/**
+ * acpi_dev_pm_detach - Remove ACPI power management from the device.
+ * @dev: Device to take care of.
+ *
+ * Remove the device from the general ACPI PM domain and remove its wakeup
+ * notifier.
+ *
+ * Callers must ensure proper synchronization of this function with power
+ * management callbacks.
+ */
+void acpi_dev_pm_detach(struct device *dev)
+{
+	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
+
+	if (adev && dev->pm_domain == &acpi_general_pm_domain) {
+		dev->pm_domain = NULL;
+		acpi_remove_pm_notifier(adev, acpi_wakeup_device);
+	}
+}
+EXPORT_SYMBOL_GPL(acpi_dev_pm_detach);

commit a6ae7594b1b157e0e7976ed105a7be27d69a5361
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 2 01:40:53 2012 +0100

    ACPI / PM: Move device PM functions related to sleep states
    
    Introduce helper function returning the target sleep state of the
    system and use it to move the remaining device power management
    functions from sleep.c to device_pm.c.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index b4f03f91b0b0..7ddd93463a2e 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -198,6 +198,31 @@ int acpi_device_power_state(struct device *dev, struct acpi_device *adev,
 }
 EXPORT_SYMBOL_GPL(acpi_device_power_state);
 
+/**
+ * acpi_pm_device_sleep_state - Get preferred power state of ACPI device.
+ * @dev: Device whose preferred target power state to return.
+ * @d_min_p: Location to store the upper limit of the allowed states range.
+ * @d_max_in: Deepest low-power state to take into consideration.
+ * Return value: Preferred power state of the device on success, -ENODEV
+ * (if there's no 'struct acpi_device' for @dev) or -EINVAL on failure
+ *
+ * The caller must ensure that @dev is valid before using this function.
+ */
+int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
+{
+	acpi_handle handle = DEVICE_ACPI_HANDLE(dev);
+	struct acpi_device *adev;
+
+	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &adev))) {
+		dev_dbg(dev, "ACPI handle without context in %s!\n", __func__);
+		return -ENODEV;
+	}
+
+	return acpi_device_power_state(dev, adev, acpi_target_system_state(),
+				       d_max_in, d_min_p);
+}
+EXPORT_SYMBOL(acpi_pm_device_sleep_state);
+
 #ifdef CONFIG_PM_RUNTIME
 /**
  * __acpi_device_run_wake - Enable/disable runtime remote wakeup for device.
@@ -274,4 +299,33 @@ int __acpi_device_sleep_wake(struct acpi_device *adev, u32 target_state,
 		acpi_enable_wakeup_device_power(adev, target_state) :
 		acpi_disable_wakeup_device_power(adev);
 }
+
+/**
+ * acpi_pm_device_sleep_wake - Enable or disable device to wake up the system.
+ * @dev: Device to enable/desible to wake up the system from sleep states.
+ * @enable: Whether to enable or disable @dev to wake up the system.
+ */
+int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
+{
+	acpi_handle handle;
+	struct acpi_device *adev;
+	int error;
+
+	if (!device_can_wakeup(dev))
+		return -EINVAL;
+
+	handle = DEVICE_ACPI_HANDLE(dev);
+	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &adev))) {
+		dev_dbg(dev, "ACPI handle without context in %s!\n", __func__);
+		return -ENODEV;
+	}
+
+	error = __acpi_device_sleep_wake(adev, acpi_target_system_state(),
+					 enable);
+	if (!error)
+		dev_info(dev, "System wakeup %s by ACPI\n",
+				enable ? "enabled" : "disabled");
+
+	return error;
+}
 #endif /* CONFIG_PM_SLEEP */

commit dee8370cc87e505ef39567f0974e73d59e75d76b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 2 01:40:36 2012 +0100

    ACPI / PM: Split device wakeup management routines
    
    Two device wakeup management routines in device_pm.c and sleep.c,
    acpi_pm_device_run_wake() and acpi_pm_device_sleep_wake(), take a
    device pointer argument and use it to obtain the ACPI handle of the
    corresponding ACPI namespace node.  That handle is then used to get
    the address of the struct acpi_device object corresponding to the
    struct device passed as the argument.
    
    Unfortunately, that last operation may be costly, because it involves
    taking the global ACPI namespace mutex, so it shouldn't be carried
    out too often.  However, the callers of those routines usually call
    them in a row with acpi_pm_device_sleep_state() which also takes that
    mutex for the same reason, so it would be more efficient if they ran
    acpi_bus_get_device() themselves to obtain a pointer to the struct
    acpi_device object in question and then passed that pointer to the
    appropriate PM routines.
    
    To make that possible, split each of the PM routines mentioned above
    in two parts, one taking a struct acpi_device pointer argument and
    the other implementing the current interface for compatibility.
    
    Additionally, change acpi_pm_device_run_wake() to actually return
    an error code if there is an error while setting up runtime remote
    wakeup for the device.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 81052981045e..b4f03f91b0b0 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -200,38 +200,78 @@ EXPORT_SYMBOL_GPL(acpi_device_power_state);
 
 #ifdef CONFIG_PM_RUNTIME
 /**
- * acpi_pm_device_run_wake - Enable/disable remote wakeup for given device.
- * @phys_dev: Device to enable/disable the platform to wake up.
+ * __acpi_device_run_wake - Enable/disable runtime remote wakeup for device.
+ * @adev: ACPI device to enable/disable the remote wakeup for.
  * @enable: Whether to enable or disable the wakeup functionality.
  *
- * Find the ACPI device object corresponding to @phys_dev and try to
- * enable/disable the GPE associated with it, so that it can generate
- * wakeup signals for the device in response to external (remote) events.
+ * Enable/disable the GPE associated with @adev so that it can generate
+ * wakeup signals for the device in response to external (remote) events and
+ * enable/disable device wakeup power.
+ *
+ * Callers must ensure that @adev is a valid ACPI device node before executing
+ * this function.
+ */
+int __acpi_device_run_wake(struct acpi_device *adev, bool enable)
+{
+	struct acpi_device_wakeup *wakeup = &adev->wakeup;
+
+	if (enable) {
+		acpi_status res;
+		int error;
+
+		error = acpi_enable_wakeup_device_power(adev, ACPI_STATE_S0);
+		if (error)
+			return error;
+
+		res = acpi_enable_gpe(wakeup->gpe_device, wakeup->gpe_number);
+		if (ACPI_FAILURE(res)) {
+			acpi_disable_wakeup_device_power(adev);
+			return -EIO;
+		}
+	} else {
+		acpi_disable_gpe(wakeup->gpe_device, wakeup->gpe_number);
+		acpi_disable_wakeup_device_power(adev);
+	}
+	return 0;
+}
+
+/**
+ * acpi_pm_device_run_wake - Enable/disable remote wakeup for given device.
+ * @dev: Device to enable/disable the platform to wake up.
+ * @enable: Whether to enable or disable the wakeup functionality.
  */
 int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
 {
-	struct acpi_device *dev;
+	struct acpi_device *adev;
 	acpi_handle handle;
 
 	if (!device_run_wake(phys_dev))
 		return -EINVAL;
 
 	handle = DEVICE_ACPI_HANDLE(phys_dev);
-	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &dev))) {
-		dev_dbg(phys_dev, "ACPI handle has no context in %s!\n",
+	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &adev))) {
+		dev_dbg(phys_dev, "ACPI handle without context in %s!\n",
 			__func__);
 		return -ENODEV;
 	}
 
-	if (enable) {
-		acpi_enable_wakeup_device_power(dev, ACPI_STATE_S0);
-		acpi_enable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number);
-	} else {
-		acpi_disable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number);
-		acpi_disable_wakeup_device_power(dev);
-	}
-
-	return 0;
+	return __acpi_device_run_wake(adev, enable);
 }
 EXPORT_SYMBOL(acpi_pm_device_run_wake);
 #endif /* CONFIG_PM_RUNTIME */
+
+ #ifdef CONFIG_PM_SLEEP
+/**
+ * __acpi_device_sleep_wake - Enable or disable device to wake up the system.
+ * @dev: Device to enable/desible to wake up the system.
+ * @target_state: System state the device is supposed to wake up from.
+ * @enable: Whether to enable or disable @dev to wake up the system.
+ */
+int __acpi_device_sleep_wake(struct acpi_device *adev, u32 target_state,
+			     bool enable)
+{
+	return enable ?
+		acpi_enable_wakeup_device_power(adev, target_state) :
+		acpi_disable_wakeup_device_power(adev);
+}
+#endif /* CONFIG_PM_SLEEP */

commit cd7bd02d319eb34fa33d1705cf63f64928643708
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 2 01:40:28 2012 +0100

    ACPI / PM: Move runtime remote wakeup setup routine to device_pm.c
    
    The ACPI function for setting up devices to do runtime remote
    wakeup is now located in drivers/acpi/sleep.c, but
    drivers/acpi/device_pm.c is a more logical place for it, so move it
    there.
    
    No functional changes should result from this modification.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index c017b801171c..81052981045e 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -26,6 +26,7 @@
 #include <linux/export.h>
 #include <linux/mutex.h>
 #include <linux/pm_qos.h>
+#include <linux/pm_runtime.h>
 
 #include <acpi/acpi.h>
 #include <acpi/acpi_bus.h>
@@ -196,3 +197,41 @@ int acpi_device_power_state(struct device *dev, struct acpi_device *adev,
 	return d_max;
 }
 EXPORT_SYMBOL_GPL(acpi_device_power_state);
+
+#ifdef CONFIG_PM_RUNTIME
+/**
+ * acpi_pm_device_run_wake - Enable/disable remote wakeup for given device.
+ * @phys_dev: Device to enable/disable the platform to wake up.
+ * @enable: Whether to enable or disable the wakeup functionality.
+ *
+ * Find the ACPI device object corresponding to @phys_dev and try to
+ * enable/disable the GPE associated with it, so that it can generate
+ * wakeup signals for the device in response to external (remote) events.
+ */
+int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
+{
+	struct acpi_device *dev;
+	acpi_handle handle;
+
+	if (!device_run_wake(phys_dev))
+		return -EINVAL;
+
+	handle = DEVICE_ACPI_HANDLE(phys_dev);
+	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &dev))) {
+		dev_dbg(phys_dev, "ACPI handle has no context in %s!\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (enable) {
+		acpi_enable_wakeup_device_power(dev, ACPI_STATE_S0);
+		acpi_enable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number);
+	} else {
+		acpi_disable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number);
+		acpi_disable_wakeup_device_power(dev);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(acpi_pm_device_run_wake);
+#endif /* CONFIG_PM_RUNTIME */

commit 86b3832c64b6d01092216d84dc6a6b300875d0bb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 2 01:40:18 2012 +0100

    ACPI / PM: Move device power state selection routine to device_pm.c
    
    The ACPI function for choosing device power state is now located
    in drivers/acpi/sleep.c, but drivers/acpi/device_pm.c is a more
    logical place for it, so move it there.
    
    However, instead of moving the function entirely, move its core only
    under a different name and with a different list of arguments, so
    that it is more flexible, and leave a wrapper around it in the
    original location.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 2d2e0bc8891b..c017b801171c 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -23,7 +23,9 @@
  */
 
 #include <linux/device.h>
+#include <linux/export.h>
 #include <linux/mutex.h>
+#include <linux/pm_qos.h>
 
 #include <acpi/acpi.h>
 #include <acpi/acpi_bus.h>
@@ -89,3 +91,108 @@ acpi_status acpi_remove_pm_notifier(struct acpi_device *adev,
 	mutex_unlock(&acpi_pm_notifier_lock);
 	return status;
 }
+
+/**
+ * acpi_device_power_state - Get preferred power state of ACPI device.
+ * @dev: Device whose preferred target power state to return.
+ * @adev: ACPI device node corresponding to @dev.
+ * @target_state: System state to match the resultant device state.
+ * @d_max_in: Deepest low-power state to take into consideration.
+ * @d_min_p: Location to store the upper limit of the allowed states range.
+ * Return value: Preferred power state of the device on success, -ENODEV
+ * (if there's no 'struct acpi_device' for @dev) or -EINVAL on failure
+ *
+ * Find the lowest power (highest number) ACPI device power state that the
+ * device can be in while the system is in the state represented by
+ * @target_state.  If @d_min_p is set, the highest power (lowest number) device
+ * power state that @dev can be in for the given system sleep state is stored
+ * at the location pointed to by it.
+ *
+ * Callers must ensure that @dev and @adev are valid pointers and that @adev
+ * actually corresponds to @dev before using this function.
+ */
+int acpi_device_power_state(struct device *dev, struct acpi_device *adev,
+			    u32 target_state, int d_max_in, int *d_min_p)
+{
+	char acpi_method[] = "_SxD";
+	unsigned long long d_min, d_max;
+	bool wakeup = false;
+
+	if (d_max_in < ACPI_STATE_D0 || d_max_in > ACPI_STATE_D3)
+		return -EINVAL;
+
+	if (d_max_in > ACPI_STATE_D3_HOT) {
+		enum pm_qos_flags_status stat;
+
+		stat = dev_pm_qos_flags(dev, PM_QOS_FLAG_NO_POWER_OFF);
+		if (stat == PM_QOS_FLAGS_ALL)
+			d_max_in = ACPI_STATE_D3_HOT;
+	}
+
+	acpi_method[2] = '0' + target_state;
+	/*
+	 * If the sleep state is S0, the lowest limit from ACPI is D3,
+	 * but if the device has _S0W, we will use the value from _S0W
+	 * as the lowest limit from ACPI.  Finally, we will constrain
+	 * the lowest limit with the specified one.
+	 */
+	d_min = ACPI_STATE_D0;
+	d_max = ACPI_STATE_D3;
+
+	/*
+	 * If present, _SxD methods return the minimum D-state (highest power
+	 * state) we can use for the corresponding S-states.  Otherwise, the
+	 * minimum D-state is D0 (ACPI 3.x).
+	 *
+	 * NOTE: We rely on acpi_evaluate_integer() not clobbering the integer
+	 * provided -- that's our fault recovery, we ignore retval.
+	 */
+	if (target_state > ACPI_STATE_S0) {
+		acpi_evaluate_integer(adev->handle, acpi_method, NULL, &d_min);
+		wakeup = device_may_wakeup(dev) && adev->wakeup.flags.valid
+			&& adev->wakeup.sleep_state >= target_state;
+	} else if (dev_pm_qos_flags(dev, PM_QOS_FLAG_REMOTE_WAKEUP) !=
+			PM_QOS_FLAGS_NONE) {
+		wakeup = adev->wakeup.flags.valid;
+	}
+
+	/*
+	 * If _PRW says we can wake up the system from the target sleep state,
+	 * the D-state returned by _SxD is sufficient for that (we assume a
+	 * wakeup-aware driver if wake is set).  Still, if _SxW exists
+	 * (ACPI 3.x), it should return the maximum (lowest power) D-state that
+	 * can wake the system.  _S0W may be valid, too.
+	 */
+	if (wakeup) {
+		acpi_status status;
+
+		acpi_method[3] = 'W';
+		status = acpi_evaluate_integer(adev->handle, acpi_method, NULL,
+						&d_max);
+		if (ACPI_FAILURE(status)) {
+			if (target_state != ACPI_STATE_S0 ||
+			    status != AE_NOT_FOUND)
+				d_max = d_min;
+		} else if (d_max < d_min) {
+			/* Warn the user of the broken DSDT */
+			printk(KERN_WARNING "ACPI: Wrong value from %s\n",
+				acpi_method);
+			/* Sanitize it */
+			d_min = d_max;
+		}
+	}
+
+	if (d_max_in < d_min)
+		return -EINVAL;
+	if (d_min_p)
+		*d_min_p = d_min;
+	/* constrain d_max with specified lowest limit (max number) */
+	if (d_max > d_max_in) {
+		for (d_max = d_max_in; d_max > d_min; d_max--) {
+			if (adev->power.states[d_max].flags.valid)
+				break;
+		}
+	}
+	return d_max;
+}
+EXPORT_SYMBOL_GPL(acpi_device_power_state);

commit ec2cd81ccfc055155ef4ca673f207168f516d287
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 2 01:40:09 2012 +0100

    ACPI / PM: Move routines for adding/removing device wakeup notifiers
    
    ACPI routines for adding and removing device wakeup notifiers are
    currently defined in a PCI-specific file, but they will be necessary
    for non-PCI devices too, so move them to a separate file under
    drivers/acpi and rename them to indicate their ACPI origins.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
new file mode 100644
index 000000000000..2d2e0bc8891b
--- /dev/null
+++ b/drivers/acpi/device_pm.c
@@ -0,0 +1,91 @@
+/*
+ * drivers/acpi/device_pm.c - ACPI device power management routines.
+ *
+ * Copyright (C) 2012, Intel Corp.
+ * Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/device.h>
+#include <linux/mutex.h>
+
+#include <acpi/acpi.h>
+#include <acpi/acpi_bus.h>
+
+static DEFINE_MUTEX(acpi_pm_notifier_lock);
+
+/**
+ * acpi_add_pm_notifier - Register PM notifier for given ACPI device.
+ * @adev: ACPI device to add the notifier for.
+ * @context: Context information to pass to the notifier routine.
+ *
+ * NOTE: @adev need not be a run-wake or wakeup device to be a valid source of
+ * PM wakeup events.  For example, wakeup events may be generated for bridges
+ * if one of the devices below the bridge is signaling wakeup, even if the
+ * bridge itself doesn't have a wakeup GPE associated with it.
+ */
+acpi_status acpi_add_pm_notifier(struct acpi_device *adev,
+				 acpi_notify_handler handler, void *context)
+{
+	acpi_status status = AE_ALREADY_EXISTS;
+
+	mutex_lock(&acpi_pm_notifier_lock);
+
+	if (adev->wakeup.flags.notifier_present)
+		goto out;
+
+	status = acpi_install_notify_handler(adev->handle,
+					     ACPI_SYSTEM_NOTIFY,
+					     handler, context);
+	if (ACPI_FAILURE(status))
+		goto out;
+
+	adev->wakeup.flags.notifier_present = true;
+
+ out:
+	mutex_unlock(&acpi_pm_notifier_lock);
+	return status;
+}
+
+/**
+ * acpi_remove_pm_notifier - Unregister PM notifier from given ACPI device.
+ * @adev: ACPI device to remove the notifier from.
+ */
+acpi_status acpi_remove_pm_notifier(struct acpi_device *adev,
+				    acpi_notify_handler handler)
+{
+	acpi_status status = AE_BAD_PARAMETER;
+
+	mutex_lock(&acpi_pm_notifier_lock);
+
+	if (!adev->wakeup.flags.notifier_present)
+		goto out;
+
+	status = acpi_remove_notify_handler(adev->handle,
+					    ACPI_SYSTEM_NOTIFY,
+					    handler);
+	if (ACPI_FAILURE(status))
+		goto out;
+
+	adev->wakeup.flags.notifier_present = false;
+
+ out:
+	mutex_unlock(&acpi_pm_notifier_lock);
+	return status;
+}
