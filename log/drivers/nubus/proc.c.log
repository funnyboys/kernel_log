commit 3f3942aca6da351a12543aa776467791b63b3a78
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 15 15:57:23 2018 +0200

    proc: introduce proc_create_single{,_data}
    
    Variants of proc_create{,_data} that directly take a seq_file show
    callback and drastically reduces the boilerplate code in the callers.
    
    All trivial callers converted over.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
index c2e5a7e6bd3e..88e1f9a0faaf 100644
--- a/drivers/nubus/proc.c
+++ b/drivers/nubus/proc.c
@@ -45,18 +45,6 @@ nubus_devices_proc_show(struct seq_file *m, void *v)
 	return 0;
 }
 
-static int nubus_devices_proc_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, nubus_devices_proc_show, NULL);
-}
-
-static const struct file_operations nubus_devices_proc_fops = {
-	.open		= nubus_devices_proc_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
 static struct proc_dir_entry *proc_bus_nubus_dir;
 
 /*
@@ -149,18 +137,6 @@ static int nubus_proc_rsrc_show(struct seq_file *m, void *v)
 	return 0;
 }
 
-static int nubus_proc_rsrc_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, nubus_proc_rsrc_show, inode);
-}
-
-static const struct file_operations nubus_proc_rsrc_fops = {
-	.open		= nubus_proc_rsrc_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
 void nubus_proc_add_rsrc_mem(struct proc_dir_entry *procdir,
 			     const struct nubus_dirent *ent,
 			     unsigned int size)
@@ -176,8 +152,8 @@ void nubus_proc_add_rsrc_mem(struct proc_dir_entry *procdir,
 		pde_data = nubus_proc_alloc_pde_data(nubus_dirptr(ent), size);
 	else
 		pde_data = NULL;
-	proc_create_data(name, S_IFREG | 0444, procdir,
-			 &nubus_proc_rsrc_fops, pde_data);
+	proc_create_single_data(name, S_IFREG | 0444, procdir,
+			nubus_proc_rsrc_show, pde_data);
 }
 
 void nubus_proc_add_rsrc(struct proc_dir_entry *procdir,
@@ -190,32 +166,21 @@ void nubus_proc_add_rsrc(struct proc_dir_entry *procdir,
 		return;
 
 	snprintf(name, sizeof(name), "%x", ent->type);
-	proc_create_data(name, S_IFREG | 0444, procdir,
-			 &nubus_proc_rsrc_fops,
-			 nubus_proc_alloc_pde_data(data, 0));
+	proc_create_single_data(name, S_IFREG | 0444, procdir,
+			nubus_proc_rsrc_show,
+			nubus_proc_alloc_pde_data(data, 0));
 }
 
 /*
  * /proc/nubus stuff
  */
 
-static int nubus_proc_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, nubus_proc_show, NULL);
-}
-
-static const struct file_operations nubus_proc_fops = {
-	.open		= nubus_proc_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
 void __init nubus_proc_init(void)
 {
-	proc_create("nubus", 0, NULL, &nubus_proc_fops);
+	proc_create_single("nubus", 0, NULL, nubus_proc_show);
 	proc_bus_nubus_dir = proc_mkdir("bus/nubus", NULL);
 	if (!proc_bus_nubus_dir)
 		return;
-	proc_create("devices", 0, proc_bus_nubus_dir, &nubus_devices_proc_fops);
+	proc_create_single("devices", 0, proc_bus_nubus_dir,
+			nubus_devices_proc_show);
 }

commit 7f86c765a6a2bb837c45f11526176125ff50e21f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:14 2018 -0500

    nubus: Add support for the driver model
    
    This patch brings basic support for the Linux Driver Model to the
    NuBus subsystem.
    
    For flexibility, the matching of boards with drivers is left up to the
    drivers. This is also the approach taken by NetBSD. A board may have
    many functions, and drivers may have to consider many functional
    resources and board resources in order to match a device.
    
    This implementation does not bind drivers to resources (nor does it bind
    many drivers to the same board). Apple's NuBus declaration ROM design
    is flexible enough to allow that, but I don't see a need to support it
    as we don't use the "slot zero" resources (in the main logic board ROM).
    
    Eliminate the global nubus_boards linked list by rewriting the procfs
    board iterator around bus_for_each_dev(). Hence the nubus device refcount
    can be used to determine the lifespan of board objects.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
index 60c0f40b4d5e..c2e5a7e6bd3e 100644
--- a/drivers/nubus/proc.c
+++ b/drivers/nubus/proc.c
@@ -198,68 +198,17 @@ void nubus_proc_add_rsrc(struct proc_dir_entry *procdir,
 /*
  * /proc/nubus stuff
  */
-static int nubus_proc_show(struct seq_file *m, void *v)
-{
-	const struct nubus_board *board = v;
-
-	/* Display header on line 1 */
-	if (v == SEQ_START_TOKEN)
-		seq_puts(m, "Nubus devices found:\n");
-	else
-		seq_printf(m, "Slot %X: %s\n", board->slot, board->name);
-	return 0;
-}
-
-static void *nubus_proc_start(struct seq_file *m, loff_t *_pos)
-{
-	struct nubus_board *board;
-	unsigned pos;
-
-	if (*_pos > LONG_MAX)
-		return NULL;
-	pos = *_pos;
-	if (pos == 0)
-		return SEQ_START_TOKEN;
-	for (board = nubus_boards; board; board = board->next)
-		if (--pos == 0)
-			break;
-	return board;
-}
-
-static void *nubus_proc_next(struct seq_file *p, void *v, loff_t *_pos)
-{
-	/* Walk the list of NuBus boards */
-	struct nubus_board *board = v;
-
-	++*_pos;
-	if (v == SEQ_START_TOKEN)
-		board = nubus_boards;
-	else if (board)
-		board = board->next;
-	return board;
-}
-
-static void nubus_proc_stop(struct seq_file *p, void *v)
-{
-}
-
-static const struct seq_operations nubus_proc_seqops = {
-	.start	= nubus_proc_start,
-	.next	= nubus_proc_next,
-	.stop	= nubus_proc_stop,
-	.show	= nubus_proc_show,
-};
 
 static int nubus_proc_open(struct inode *inode, struct file *file)
 {
-	return seq_open(file, &nubus_proc_seqops);
+	return single_open(file, nubus_proc_show, NULL);
 }
 
 static const struct file_operations nubus_proc_fops = {
 	.open		= nubus_proc_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
-	.release	= seq_release,
+	.release	= single_release,
 };
 
 void __init nubus_proc_init(void)

commit 41b848160eabb22957652936b66ccafd95ab5ad8
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Adopt standard linked list implementation
    
    This increases code re-use and improves readability.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
index f2b118330be0..60c0f40b4d5e 100644
--- a/drivers/nubus/proc.c
+++ b/drivers/nubus/proc.c
@@ -36,15 +36,12 @@
 static int
 nubus_devices_proc_show(struct seq_file *m, void *v)
 {
-	struct nubus_rsrc *fres = nubus_func_rsrcs;
+	struct nubus_rsrc *fres;
 
-	while (fres) {
-		seq_printf(m, "%x\t%04x %04x %04x %04x",
+	for_each_func_rsrc(fres)
+		seq_printf(m, "%x\t%04x %04x %04x %04x\t%08lx\n",
 			   fres->board->slot, fres->category, fres->type,
-			   fres->dr_sw, fres->dr_hw);
-		seq_printf(m, "\t%08lx\n", fres->board->slot_addr);
-		fres = fres->next;
-	}
+			   fres->dr_sw, fres->dr_hw, fres->board->slot_addr);
 	return 0;
 }
 

commit 189e19e8cbb49f5bf483e55bdbd1e56d3d6bcf75
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Rename struct nubus_dev
    
    It is misleading to call a functional resource a "device". In adopting
    the Linux Driver Model, the struct device will be embedded in struct
    nubus_board. That will compound the terminlogy problem because drivers
    will bind with boards, not with functional resources. Avoid this by
    renaming struct nubus_dev as struct nubus_rsrc. "Functional resource"
    is the vendor's terminology so this helps avoid confusion.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
index f47d90924ab4..f2b118330be0 100644
--- a/drivers/nubus/proc.c
+++ b/drivers/nubus/proc.c
@@ -36,17 +36,14 @@
 static int
 nubus_devices_proc_show(struct seq_file *m, void *v)
 {
-	struct nubus_dev *dev = nubus_devices;
+	struct nubus_rsrc *fres = nubus_func_rsrcs;
 
-	while (dev) {
+	while (fres) {
 		seq_printf(m, "%x\t%04x %04x %04x %04x",
-			      dev->board->slot,
-			      dev->category,
-			      dev->type,
-			      dev->dr_sw,
-			      dev->dr_hw);
-		seq_printf(m, "\t%08lx\n", dev->board->slot_addr);
-		dev = dev->next;
+			   fres->board->slot, fres->category, fres->type,
+			   fres->dr_sw, fres->dr_hw);
+		seq_printf(m, "\t%08lx\n", fres->board->slot_addr);
+		fres = fres->next;
 	}
 	return 0;
 }

commit 2f7dd07ecadac6bdc3d55c217d65efa2834ba1cb
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Rework /proc/bus/nubus/s/ implementation
    
    The /proc/bus/nubus/s/ directory tree for any slot s is missing a lot
    of information. The struct file_operations methods have long been left
    unimplemented (hence the familiar compile-time warning, "Need to set
    some I/O handlers here").
    
    Slot resources have a complex structure which varies depending on board
    function. The logic for interpreting these ROM data structures is found
    in nubus.c. Let's not duplicate that logic in proc.c.
    
    Create the /proc/bus/nubus/s/ inodes while scanning slot s. During
    descent through slot resource subdirectories, call the new
    nubus_proc_add_foo() functions to create the procfs inodes.
    
    Also add a new function, nubus_seq_write_rsrc_mem(), to write the
    contents of a particular slot resource to a given seq_file. This is
    used by the procfs file_operations methods, to finally give userspace
    access to slot ROM information, such as the available video modes.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
index 41ec859bdd8b..f47d90924ab4 100644
--- a/drivers/nubus/proc.c
+++ b/drivers/nubus/proc.c
@@ -11,24 +11,28 @@
    structure in /proc analogous to the structure of the NuBus ROM
    resources.
 
-   Therefore each NuBus device is in fact a directory, which may in
-   turn contain subdirectories.  The "files" correspond to NuBus
-   resource records.  For those types of records which we know how to
-   convert to formats that are meaningful to userspace (mostly just
-   icons) these files will provide "cooked" data.  Otherwise they will
-   simply provide raw access (read-only of course) to the ROM.  */
+   Therefore each board function gets a directory, which may in turn
+   contain subdirectories.  Each slot resource is a file.  Unrecognized
+   resources are empty files, since every resource ID requires a special
+   case (e.g. if the resource ID implies a directory or block, then its
+   value has to be interpreted as a slot ROM pointer etc.).
+ */
 
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/nubus.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
+#include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/module.h>
-
 #include <linux/uaccess.h>
 #include <asm/byteorder.h>
 
+/*
+ * /proc/bus/nubus/devices stuff
+ */
+
 static int
 nubus_devices_proc_show(struct seq_file *m, void *v)
 {
@@ -61,96 +65,141 @@ static const struct file_operations nubus_devices_proc_fops = {
 
 static struct proc_dir_entry *proc_bus_nubus_dir;
 
-static const struct file_operations nubus_proc_subdir_fops = {
-#warning Need to set some I/O handlers here
+/*
+ * /proc/bus/nubus/x/ stuff
+ */
+
+struct proc_dir_entry *nubus_proc_add_board(struct nubus_board *board)
+{
+	char name[2];
+
+	if (!proc_bus_nubus_dir)
+		return NULL;
+	snprintf(name, sizeof(name), "%x", board->slot);
+	return proc_mkdir(name, proc_bus_nubus_dir);
+}
+
+/* The PDE private data for any directory under /proc/bus/nubus/x/
+ * is the bytelanes value for the board in slot x.
+ */
+
+struct proc_dir_entry *nubus_proc_add_rsrc_dir(struct proc_dir_entry *procdir,
+					       const struct nubus_dirent *ent,
+					       struct nubus_board *board)
+{
+	char name[9];
+	int lanes = board->lanes;
+
+	if (!procdir)
+		return NULL;
+	snprintf(name, sizeof(name), "%x", ent->type);
+	return proc_mkdir_data(name, 0555, procdir, (void *)lanes);
+}
+
+/* The PDE private data for a file under /proc/bus/nubus/x/ is a pointer to
+ * an instance of the following structure, which gives the location and size
+ * of the resource data in the slot ROM. For slot resources which hold only a
+ * small integer, this integer value is stored directly and size is set to 0.
+ * A NULL private data pointer indicates an unrecognized resource.
+ */
+
+struct nubus_proc_pde_data {
+	unsigned char *res_ptr;
+	unsigned int res_size;
 };
 
-static void nubus_proc_subdir(struct nubus_dev* dev,
-			      struct proc_dir_entry* parent,
-			      struct nubus_dir* dir)
+static struct nubus_proc_pde_data *
+nubus_proc_alloc_pde_data(unsigned char *ptr, unsigned int size)
 {
-	struct nubus_dirent ent;
-
-	/* Some of these are directories, others aren't */
-	while (nubus_readdir(dir, &ent) != -1) {
-		char name[9];
-		struct proc_dir_entry* e;
-		
-		snprintf(name, sizeof(name), "%x", ent.type);
-		e = proc_create(name, S_IFREG | S_IRUGO | S_IWUSR, parent,
-				&nubus_proc_subdir_fops);
-		if (!e)
-			return;
-	}
+	struct nubus_proc_pde_data *pde_data;
+
+	pde_data = kmalloc(sizeof(*pde_data), GFP_KERNEL);
+	if (!pde_data)
+		return NULL;
+
+	pde_data->res_ptr = ptr;
+	pde_data->res_size = size;
+	return pde_data;
 }
 
-/* Can't do this recursively since the root directory is structured
-   somewhat differently from the subdirectories */
-static void nubus_proc_populate(struct nubus_dev* dev,
-				struct proc_dir_entry* parent,
-				struct nubus_dir* root)
+static int nubus_proc_rsrc_show(struct seq_file *m, void *v)
 {
-	struct nubus_dirent ent;
-
-	/* We know these are all directories (board resource + one or
-	   more functional resources) */
-	while (nubus_readdir(root, &ent) != -1) {
-		char name[9];
-		struct proc_dir_entry* e;
-		struct nubus_dir dir;
-		
-		snprintf(name, sizeof(name), "%x", ent.type);
-		e = proc_mkdir(name, parent);
-		if (!e) return;
-
-		/* And descend */
-		if (nubus_get_subdir(&ent, &dir) == -1) {
-			/* This shouldn't happen */
-			printk(KERN_ERR "NuBus root directory node %x:%x has no subdir!\n",
-			       dev->board->slot, ent.type);
-			continue;
-		} else {
-			nubus_proc_subdir(dev, e, &dir);
-		}
+	struct inode *inode = m->private;
+	struct nubus_proc_pde_data *pde_data;
+
+	pde_data = PDE_DATA(inode);
+	if (!pde_data)
+		return 0;
+
+	if (pde_data->res_size > m->size)
+		return -EFBIG;
+
+	if (pde_data->res_size) {
+		int lanes = (int)proc_get_parent_data(inode);
+		struct nubus_dirent ent;
+
+		if (!lanes)
+			return 0;
+
+		ent.mask = lanes;
+		ent.base = pde_data->res_ptr;
+		ent.data = 0;
+		nubus_seq_write_rsrc_mem(m, &ent, pde_data->res_size);
+	} else {
+		unsigned int data = (unsigned int)pde_data->res_ptr;
+
+		seq_putc(m, data >> 16);
+		seq_putc(m, data >> 8);
+		seq_putc(m, data >> 0);
 	}
+	return 0;
 }
 
-int nubus_proc_attach_device(struct nubus_dev *dev)
+static int nubus_proc_rsrc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, nubus_proc_rsrc_show, inode);
+}
+
+static const struct file_operations nubus_proc_rsrc_fops = {
+	.open		= nubus_proc_rsrc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+void nubus_proc_add_rsrc_mem(struct proc_dir_entry *procdir,
+			     const struct nubus_dirent *ent,
+			     unsigned int size)
 {
-	struct proc_dir_entry *e;
-	struct nubus_dir root;
 	char name[9];
+	struct nubus_proc_pde_data *pde_data;
 
-	if (dev == NULL) {
-		printk(KERN_ERR
-		       "NULL pointer in nubus_proc_attach_device, shoot the programmer!\n");
-		return -1;
-	}
-		
-	if (dev->board == NULL) {
-		printk(KERN_ERR
-		       "NULL pointer in nubus_proc_attach_device, shoot the programmer!\n");
-		printk("dev = %p, dev->board = %p\n", dev, dev->board);
-		return -1;
-	}
-		
-	if (dev->board->procdir)
-		return 0;
+	if (!procdir)
+		return;
 
-	/* Create a directory */
-	snprintf(name, sizeof(name), "%x", dev->board->slot);
-	e = proc_mkdir(name, proc_bus_nubus_dir);
-	dev->board->procdir = e;
-	if (!e)
-		return -ENOMEM;
+	snprintf(name, sizeof(name), "%x", ent->type);
+	if (size)
+		pde_data = nubus_proc_alloc_pde_data(nubus_dirptr(ent), size);
+	else
+		pde_data = NULL;
+	proc_create_data(name, S_IFREG | 0444, procdir,
+			 &nubus_proc_rsrc_fops, pde_data);
+}
 
-	/* Now recursively populate it with files */
-	nubus_get_root_dir(dev->board, &root);
-	nubus_proc_populate(dev, e, &root);
+void nubus_proc_add_rsrc(struct proc_dir_entry *procdir,
+			 const struct nubus_dirent *ent)
+{
+	char name[9];
+	unsigned char *data = (unsigned char *)ent->data;
 
-	return 0;
+	if (!procdir)
+		return;
+
+	snprintf(name, sizeof(name), "%x", ent->type);
+	proc_create_data(name, S_IFREG | 0444, procdir,
+			 &nubus_proc_rsrc_fops,
+			 nubus_proc_alloc_pde_data(data, 0));
 }
-EXPORT_SYMBOL(nubus_proc_attach_device);
 
 /*
  * /proc/nubus stuff
@@ -219,18 +268,11 @@ static const struct file_operations nubus_proc_fops = {
 	.release	= seq_release,
 };
 
-void __init proc_bus_nubus_add_devices(void)
-{
-	struct nubus_dev *dev;
-	
-	for(dev = nubus_devices; dev; dev = dev->next)
-		nubus_proc_attach_device(dev);
-}
-
 void __init nubus_proc_init(void)
 {
 	proc_create("nubus", 0, NULL, &nubus_proc_fops);
 	proc_bus_nubus_dir = proc_mkdir("bus/nubus", NULL);
+	if (!proc_bus_nubus_dir)
+		return;
 	proc_create("devices", 0, proc_bus_nubus_dir, &nubus_devices_proc_fops);
-	proc_bus_nubus_add_devices();
 }

commit 9f97977deb22e602f91047a105b961ffb36adc2b
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Remove redundant code
    
    Eliminate unused values from struct nubus_dev to save wasted memory
    (a Radius PrecisionColor 24X card has about 95 functional resources
    and up to six such cards may be fitted). Also remove redundant static
    variable initialization, an unreachable !MACH_IS_MAC conditional,
    the unused nubus_find_device() function, the bogus get_nubus_list()
    prototype and the pointless card_present temporary variable.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
index 91211192f36f..41ec859bdd8b 100644
--- a/drivers/nubus/proc.c
+++ b/drivers/nubus/proc.c
@@ -230,8 +230,6 @@ void __init proc_bus_nubus_add_devices(void)
 void __init nubus_proc_init(void)
 {
 	proc_create("nubus", 0, NULL, &nubus_proc_fops);
-	if (!MACH_IS_MAC)
-		return;
 	proc_bus_nubus_dir = proc_mkdir("bus/nubus", NULL);
 	proc_create("devices", 0, proc_bus_nubus_dir, &nubus_devices_proc_fops);
 	proc_bus_nubus_add_devices();

commit 6c8b89ea55c9d53979e2be7977e945edba100359
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Call proc_mkdir() not more than once per slot directory
    
    This patch fixes the following WARNING.
    
    proc_dir_entry 'nubus/a' already registered
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper Tainted: G        W       4.13.0-00036-gd57552077387 #1
    Stack from 01c1bd9c:
            01c1bd9c 003c2c8b 01c1bdc0 0001b0fe 00000000 00322f4a 01c43a20 01c43b0c
            01c8c420 01c1bde8 0001b1b8 003a4ac3 00000148 000faa26 00000009 00000000
            01c1bde0 003a4b6c 01c1bdfc 01c1be20 000faa26 003a4ac3 00000148 003a4b6c
            01c43a71 01c8c471 01c10000 00326430 0043d00c 00000005 01c71a00 0020bce0
            00322964 01c1be38 000fac04 01c43a20 01c8c420 01c1bee0 01c8c420 01c1be50
            000fac4c 01c1bee0 00000000 01c43a20 00000000 01c1bee8 0020bd26 01c1bee0
    Call Trace: [<0001b0fe>] __warn+0xae/0xde
     [<00322f4a>] memcmp+0x0/0x5c
     [<0001b1b8>] warn_slowpath_fmt+0x2e/0x36
     [<000faa26>] proc_register+0xbe/0xd8
     [<000faa26>] proc_register+0xbe/0xd8
     [<00326430>] sprintf+0x0/0x20
     [<0020bce0>] nubus_proc_attach_device+0x0/0x1b8
     [<00322964>] strcpy+0x0/0x22
     [<000fac04>] proc_mkdir_data+0x64/0x96
     [<000fac4c>] proc_mkdir+0x16/0x1c
     [<0020bd26>] nubus_proc_attach_device+0x46/0x1b8
     [<0020bce0>] nubus_proc_attach_device+0x0/0x1b8
     [<00322964>] strcpy+0x0/0x22
     [<00001ba6>] kernel_pg_dir+0xba6/0x1000
     [<004339a2>] proc_bus_nubus_add_devices+0x1a/0x2e
     [<000faa40>] proc_create_data+0x0/0xf2
     [<0003297c>] parse_args+0x0/0x2d4
     [<00433a08>] nubus_proc_init+0x52/0x5a
     [<00433944>] nubus_init+0x0/0x44
     [<00433982>] nubus_init+0x3e/0x44
     [<000020dc>] do_one_initcall+0x38/0x196
     [<000020a4>] do_one_initcall+0x0/0x196
     [<0003297c>] parse_args+0x0/0x2d4
     [<00322964>] strcpy+0x0/0x22
     [<00040004>] __up_read+0xe/0x40
     [<004231d4>] repair_env_string+0x0/0x7a
     [<0042312e>] kernel_init_freeable+0xee/0x194
     [<00423146>] kernel_init_freeable+0x106/0x194
     [<00433944>] nubus_init+0x0/0x44
     [<000a6000>] kfree+0x0/0x156
     [<0032768c>] kernel_init+0x0/0xda
     [<00327698>] kernel_init+0xc/0xda
     [<0032768c>] kernel_init+0x0/0xda
     [<00002a90>] ret_from_kernel_thread+0xc/0x14
    ---[ end trace 14a6d619908ea253 ]---
    ------------[ cut here ]------------
    
    This gets repeated with each additional functional reasource.
    
    The problem here is the call to proc_mkdir() when the directory already
    exists. Each nubus_board gets a directory, such as /proc/bus/nubus/s/
    where s is the hex slot number. Therefore, store the 'procdir' pointer
    in struct nubus_board instead of struct nubus_dev.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
index fc20dbcd3b9a..91211192f36f 100644
--- a/drivers/nubus/proc.c
+++ b/drivers/nubus/proc.c
@@ -134,9 +134,13 @@ int nubus_proc_attach_device(struct nubus_dev *dev)
 		return -1;
 	}
 		
+	if (dev->board->procdir)
+		return 0;
+
 	/* Create a directory */
 	snprintf(name, sizeof(name), "%x", dev->board->slot);
-	e = dev->procdir = proc_mkdir(name, proc_bus_nubus_dir);
+	e = proc_mkdir(name, proc_bus_nubus_dir);
+	dev->board->procdir = e;
 	if (!e)
 		return -ENOMEM;
 

commit 2f828fb21df42058084b16d5e07cecdc30dbc3a5
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Avoid array underflow and overflow
    
    Check array indices. Avoid sprintf. Use buffers of sufficient size.
    Use appropriate types for array length parameters.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
index 004a122ac0ff..fc20dbcd3b9a 100644
--- a/drivers/nubus/proc.c
+++ b/drivers/nubus/proc.c
@@ -73,10 +73,10 @@ static void nubus_proc_subdir(struct nubus_dev* dev,
 
 	/* Some of these are directories, others aren't */
 	while (nubus_readdir(dir, &ent) != -1) {
-		char name[8];
+		char name[9];
 		struct proc_dir_entry* e;
 		
-		sprintf(name, "%x", ent.type);
+		snprintf(name, sizeof(name), "%x", ent.type);
 		e = proc_create(name, S_IFREG | S_IRUGO | S_IWUSR, parent,
 				&nubus_proc_subdir_fops);
 		if (!e)
@@ -95,11 +95,11 @@ static void nubus_proc_populate(struct nubus_dev* dev,
 	/* We know these are all directories (board resource + one or
 	   more functional resources) */
 	while (nubus_readdir(root, &ent) != -1) {
-		char name[8];
+		char name[9];
 		struct proc_dir_entry* e;
 		struct nubus_dir dir;
 		
-		sprintf(name, "%x", ent.type);
+		snprintf(name, sizeof(name), "%x", ent.type);
 		e = proc_mkdir(name, parent);
 		if (!e) return;
 
@@ -119,7 +119,7 @@ int nubus_proc_attach_device(struct nubus_dev *dev)
 {
 	struct proc_dir_entry *e;
 	struct nubus_dir root;
-	char name[8];
+	char name[9];
 
 	if (dev == NULL) {
 		printk(KERN_ERR
@@ -135,7 +135,7 @@ int nubus_proc_attach_device(struct nubus_dev *dev)
 	}
 		
 	/* Create a directory */
-	sprintf(name, "%x", dev->board->slot);
+	snprintf(name, sizeof(name), "%x", dev->board->slot);
 	e = dev->procdir = proc_mkdir(name, proc_bus_nubus_dir);
 	if (!e)
 		return -ENOMEM;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
index e8f68f5732f1..004a122ac0ff 100644
--- a/drivers/nubus/proc.c
+++ b/drivers/nubus/proc.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /* drivers/nubus/proc.c: Proc FS interface for NuBus.
 
    By David Huggins-Daines <dhd@debian.org>

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
index 5371b374f1fe..e8f68f5732f1 100644
--- a/drivers/nubus/proc.c
+++ b/drivers/nubus/proc.c
@@ -25,7 +25,7 @@
 #include <linux/init.h>
 #include <linux/module.h>
 
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/byteorder.h>
 
 static int

commit e765acb4673f377c53505c01279c040906bd706e
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri May 3 22:20:38 2013 +0200

    nubus: Kill nubus_proc_detach_device()
    
    Commit 59d8053f1e16904d54ed7469d4b36801ea6b8f2c ("proc: Move non-public
    stuff from linux/proc_fs.h to fs/proc/internal.h") broke Apple NuBus
    support:
    
    drivers/nubus/proc.c: In function ‘nubus_proc_detach_device’:
    drivers/nubus/proc.c:156: error: dereferencing pointer to incomplete type
    drivers/nubus/proc.c:158: error: dereferencing pointer to incomplete type
    
    Fortunately nubus_proc_detach_device() is unused, and appears to have never
    been used, so just remove it.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
index b8286ed65919..5371b374f1fe 100644
--- a/drivers/nubus/proc.c
+++ b/drivers/nubus/proc.c
@@ -147,21 +147,6 @@ int nubus_proc_attach_device(struct nubus_dev *dev)
 }
 EXPORT_SYMBOL(nubus_proc_attach_device);
 
-/* FIXME: this is certainly broken! */
-int nubus_proc_detach_device(struct nubus_dev *dev)
-{
-	struct proc_dir_entry *e;
-
-	if ((e = dev->procdir)) {
-		if (atomic_read(&e->count))
-			return -EBUSY;
-		remove_proc_entry(e->name, proc_bus_nubus_dir);
-		dev->procdir = NULL;
-	}
-	return 0;
-}
-EXPORT_SYMBOL(nubus_proc_detach_device);
-
 /*
  * /proc/nubus stuff
  */

commit 11db656ad462c9aa7aff7e3817214578cfc307b3
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 10 15:05:38 2013 +0100

    nubus: Don't use create_proc_read_entry()
    
    Don't use create_proc_read_entry() as that is deprecated, but rather use
    proc_create_data() and seq_file instead.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-m68k@lists.linux-m68k.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
index bb1446bb2802..b8286ed65919 100644
--- a/drivers/nubus/proc.c
+++ b/drivers/nubus/proc.c
@@ -52,7 +52,6 @@ static int nubus_devices_proc_open(struct inode *inode, struct file *file)
 }
 
 static const struct file_operations nubus_devices_proc_fops = {
-	.owner		= THIS_MODULE,
 	.open		= nubus_devices_proc_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
@@ -61,6 +60,10 @@ static const struct file_operations nubus_devices_proc_fops = {
 
 static struct proc_dir_entry *proc_bus_nubus_dir;
 
+static const struct file_operations nubus_proc_subdir_fops = {
+#warning Need to set some I/O handlers here
+};
+
 static void nubus_proc_subdir(struct nubus_dev* dev,
 			      struct proc_dir_entry* parent,
 			      struct nubus_dir* dir)
@@ -73,10 +76,10 @@ static void nubus_proc_subdir(struct nubus_dev* dev,
 		struct proc_dir_entry* e;
 		
 		sprintf(name, "%x", ent.type);
-#warning Need to set some I/O handlers here
-		e = create_proc_read_entry(name, S_IFREG | S_IRUGO | S_IWUSR,
-					   parent, NULL, NULL);
-		if (!e) return;
+		e = proc_create(name, S_IFREG | S_IRUGO | S_IWUSR, parent,
+				&nubus_proc_subdir_fops);
+		if (!e)
+			return;
 	}
 }
 
@@ -159,6 +162,73 @@ int nubus_proc_detach_device(struct nubus_dev *dev)
 }
 EXPORT_SYMBOL(nubus_proc_detach_device);
 
+/*
+ * /proc/nubus stuff
+ */
+static int nubus_proc_show(struct seq_file *m, void *v)
+{
+	const struct nubus_board *board = v;
+
+	/* Display header on line 1 */
+	if (v == SEQ_START_TOKEN)
+		seq_puts(m, "Nubus devices found:\n");
+	else
+		seq_printf(m, "Slot %X: %s\n", board->slot, board->name);
+	return 0;
+}
+
+static void *nubus_proc_start(struct seq_file *m, loff_t *_pos)
+{
+	struct nubus_board *board;
+	unsigned pos;
+
+	if (*_pos > LONG_MAX)
+		return NULL;
+	pos = *_pos;
+	if (pos == 0)
+		return SEQ_START_TOKEN;
+	for (board = nubus_boards; board; board = board->next)
+		if (--pos == 0)
+			break;
+	return board;
+}
+
+static void *nubus_proc_next(struct seq_file *p, void *v, loff_t *_pos)
+{
+	/* Walk the list of NuBus boards */
+	struct nubus_board *board = v;
+
+	++*_pos;
+	if (v == SEQ_START_TOKEN)
+		board = nubus_boards;
+	else if (board)
+		board = board->next;
+	return board;
+}
+
+static void nubus_proc_stop(struct seq_file *p, void *v)
+{
+}
+
+static const struct seq_operations nubus_proc_seqops = {
+	.start	= nubus_proc_start,
+	.next	= nubus_proc_next,
+	.stop	= nubus_proc_stop,
+	.show	= nubus_proc_show,
+};
+
+static int nubus_proc_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &nubus_proc_seqops);
+}
+
+static const struct file_operations nubus_proc_fops = {
+	.open		= nubus_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
 void __init proc_bus_nubus_add_devices(void)
 {
 	struct nubus_dev *dev;
@@ -169,6 +239,7 @@ void __init proc_bus_nubus_add_devices(void)
 
 void __init nubus_proc_init(void)
 {
+	proc_create("nubus", 0, NULL, &nubus_proc_fops);
 	if (!MACH_IS_MAC)
 		return;
 	proc_bus_nubus_dir = proc_mkdir("bus/nubus", NULL);

commit 8a25378e408022c441a1d27082fea9264323b7e7
Author: David Howells <dhowells@redhat.com>
Date:   Thu Apr 4 16:44:51 2013 +0100

    nubus: Don't use create_proc_entry()
    
    Don't use create_proc_entry() in nubus_proc_subdir().  The files created aren't
    given any way to use them, so for the moment use create_proc_read_entry() with
    a NULL accessor and generate a compile-time warning.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
index 208dd12825bc..bb1446bb2802 100644
--- a/drivers/nubus/proc.c
+++ b/drivers/nubus/proc.c
@@ -73,8 +73,9 @@ static void nubus_proc_subdir(struct nubus_dev* dev,
 		struct proc_dir_entry* e;
 		
 		sprintf(name, "%x", ent.type);
-		e = create_proc_entry(name, S_IFREG | S_IRUGO |
-				      S_IWUSR, parent);
+#warning Need to set some I/O handlers here
+		e = create_proc_read_entry(name, S_IFREG | S_IRUGO | S_IWUSR,
+					   parent, NULL, NULL);
 		if (!e) return;
 	}
 }

commit 076ec04b8ac84a04df67840f15f36218d7519510
Author: Alexey Dobriyan <adobriyan@sw.ru>
Date:   Tue Apr 29 01:01:54 2008 -0700

    proc: convert /proc/bus/nubus to seq_file interface
    
    Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
index cb83acef9479..208dd12825bc 100644
--- a/drivers/nubus/proc.c
+++ b/drivers/nubus/proc.c
@@ -21,6 +21,7 @@
 #include <linux/kernel.h>
 #include <linux/nubus.h>
 #include <linux/proc_fs.h>
+#include <linux/seq_file.h>
 #include <linux/init.h>
 #include <linux/module.h>
 
@@ -28,38 +29,36 @@
 #include <asm/byteorder.h>
 
 static int
-get_nubus_dev_info(char *buf, char **start, off_t pos, int count)
+nubus_devices_proc_show(struct seq_file *m, void *v)
 {
 	struct nubus_dev *dev = nubus_devices;
-	off_t at = 0;
-	int len, cnt;
 
-	cnt = 0;
-	while (dev && count > cnt) {
-		len = sprintf(buf, "%x\t%04x %04x %04x %04x",
+	while (dev) {
+		seq_printf(m, "%x\t%04x %04x %04x %04x",
 			      dev->board->slot,
 			      dev->category,
 			      dev->type,
 			      dev->dr_sw,
 			      dev->dr_hw);
-		len += sprintf(buf+len,
-			       "\t%08lx",
-			       dev->board->slot_addr);
-		buf[len++] = '\n';
-		at += len;
-		if (at >= pos) {
-			if (!*start) {
-				*start = buf + (pos - (at - len));
-				cnt = at - pos;
-			} else
-				cnt += len;
-			buf += len;
-		}
+		seq_printf(m, "\t%08lx\n", dev->board->slot_addr);
 		dev = dev->next;
 	}
-	return (count > cnt) ? cnt : count;
+	return 0;
+}
+
+static int nubus_devices_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, nubus_devices_proc_show, NULL);
 }
 
+static const struct file_operations nubus_devices_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= nubus_devices_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
 static struct proc_dir_entry *proc_bus_nubus_dir;
 
 static void nubus_proc_subdir(struct nubus_dev* dev,
@@ -172,7 +171,6 @@ void __init nubus_proc_init(void)
 	if (!MACH_IS_MAC)
 		return;
 	proc_bus_nubus_dir = proc_mkdir("bus/nubus", NULL);
-	create_proc_info_entry("devices", 0, proc_bus_nubus_dir,
-				get_nubus_dev_info);
+	proc_create("devices", 0, proc_bus_nubus_dir, &nubus_devices_proc_fops);
 	proc_bus_nubus_add_devices();
 }

commit 9c37066d888bf6e1b96ad12304971b3ddeabbad0
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Apr 29 01:01:41 2008 -0700

    proc: remove proc_bus
    
    Remove proc_bus export and variable itself. Using pathnames works fine
    and is slightly more understandable and greppable.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
index e07492be1f4a..cb83acef9479 100644
--- a/drivers/nubus/proc.c
+++ b/drivers/nubus/proc.c
@@ -171,7 +171,7 @@ void __init nubus_proc_init(void)
 {
 	if (!MACH_IS_MAC)
 		return;
-	proc_bus_nubus_dir = proc_mkdir("nubus", proc_bus);
+	proc_bus_nubus_dir = proc_mkdir("bus/nubus", NULL);
 	create_proc_info_entry("devices", 0, proc_bus_nubus_dir,
 				get_nubus_dev_info);
 	proc_bus_nubus_add_devices();

commit 99ffab81071b7088ddebd4be9bbf1ad03c2a9e98
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Feb 4 22:30:23 2008 -0800

    nubus: kill drivers/nubus/nubus_syms.c
    
    nubus: kill drivers/nubus/nubus_syms.c
    
    EXPORT_SYMBOL's belong to the actual code.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
index 5271a4a7af26..e07492be1f4a 100644
--- a/drivers/nubus/proc.c
+++ b/drivers/nubus/proc.c
@@ -22,6 +22,8 @@
 #include <linux/nubus.h>
 #include <linux/proc_fs.h>
 #include <linux/init.h>
+#include <linux/module.h>
+
 #include <asm/uaccess.h>
 #include <asm/byteorder.h>
 
@@ -140,6 +142,7 @@ int nubus_proc_attach_device(struct nubus_dev *dev)
 
 	return 0;
 }
+EXPORT_SYMBOL(nubus_proc_attach_device);
 
 /* FIXME: this is certainly broken! */
 int nubus_proc_detach_device(struct nubus_dev *dev)
@@ -154,6 +157,7 @@ int nubus_proc_detach_device(struct nubus_dev *dev)
 	}
 	return 0;
 }
+EXPORT_SYMBOL(nubus_proc_detach_device);
 
 void __init proc_bus_nubus_add_devices(void)
 {

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/nubus/proc.c b/drivers/nubus/proc.c
new file mode 100644
index 000000000000..5271a4a7af26
--- /dev/null
+++ b/drivers/nubus/proc.c
@@ -0,0 +1,174 @@
+/* drivers/nubus/proc.c: Proc FS interface for NuBus.
+
+   By David Huggins-Daines <dhd@debian.org>
+
+   Much code and many ideas from drivers/pci/proc.c:
+   Copyright (c) 1997, 1998 Martin Mares <mj@atrey.karlin.mff.cuni.cz>
+
+   This is initially based on the Zorro and PCI interfaces.  However,
+   it works somewhat differently.  The intent is to provide a
+   structure in /proc analogous to the structure of the NuBus ROM
+   resources.
+
+   Therefore each NuBus device is in fact a directory, which may in
+   turn contain subdirectories.  The "files" correspond to NuBus
+   resource records.  For those types of records which we know how to
+   convert to formats that are meaningful to userspace (mostly just
+   icons) these files will provide "cooked" data.  Otherwise they will
+   simply provide raw access (read-only of course) to the ROM.  */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/nubus.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+
+static int
+get_nubus_dev_info(char *buf, char **start, off_t pos, int count)
+{
+	struct nubus_dev *dev = nubus_devices;
+	off_t at = 0;
+	int len, cnt;
+
+	cnt = 0;
+	while (dev && count > cnt) {
+		len = sprintf(buf, "%x\t%04x %04x %04x %04x",
+			      dev->board->slot,
+			      dev->category,
+			      dev->type,
+			      dev->dr_sw,
+			      dev->dr_hw);
+		len += sprintf(buf+len,
+			       "\t%08lx",
+			       dev->board->slot_addr);
+		buf[len++] = '\n';
+		at += len;
+		if (at >= pos) {
+			if (!*start) {
+				*start = buf + (pos - (at - len));
+				cnt = at - pos;
+			} else
+				cnt += len;
+			buf += len;
+		}
+		dev = dev->next;
+	}
+	return (count > cnt) ? cnt : count;
+}
+
+static struct proc_dir_entry *proc_bus_nubus_dir;
+
+static void nubus_proc_subdir(struct nubus_dev* dev,
+			      struct proc_dir_entry* parent,
+			      struct nubus_dir* dir)
+{
+	struct nubus_dirent ent;
+
+	/* Some of these are directories, others aren't */
+	while (nubus_readdir(dir, &ent) != -1) {
+		char name[8];
+		struct proc_dir_entry* e;
+		
+		sprintf(name, "%x", ent.type);
+		e = create_proc_entry(name, S_IFREG | S_IRUGO |
+				      S_IWUSR, parent);
+		if (!e) return;
+	}
+}
+
+/* Can't do this recursively since the root directory is structured
+   somewhat differently from the subdirectories */
+static void nubus_proc_populate(struct nubus_dev* dev,
+				struct proc_dir_entry* parent,
+				struct nubus_dir* root)
+{
+	struct nubus_dirent ent;
+
+	/* We know these are all directories (board resource + one or
+	   more functional resources) */
+	while (nubus_readdir(root, &ent) != -1) {
+		char name[8];
+		struct proc_dir_entry* e;
+		struct nubus_dir dir;
+		
+		sprintf(name, "%x", ent.type);
+		e = proc_mkdir(name, parent);
+		if (!e) return;
+
+		/* And descend */
+		if (nubus_get_subdir(&ent, &dir) == -1) {
+			/* This shouldn't happen */
+			printk(KERN_ERR "NuBus root directory node %x:%x has no subdir!\n",
+			       dev->board->slot, ent.type);
+			continue;
+		} else {
+			nubus_proc_subdir(dev, e, &dir);
+		}
+	}
+}
+
+int nubus_proc_attach_device(struct nubus_dev *dev)
+{
+	struct proc_dir_entry *e;
+	struct nubus_dir root;
+	char name[8];
+
+	if (dev == NULL) {
+		printk(KERN_ERR
+		       "NULL pointer in nubus_proc_attach_device, shoot the programmer!\n");
+		return -1;
+	}
+		
+	if (dev->board == NULL) {
+		printk(KERN_ERR
+		       "NULL pointer in nubus_proc_attach_device, shoot the programmer!\n");
+		printk("dev = %p, dev->board = %p\n", dev, dev->board);
+		return -1;
+	}
+		
+	/* Create a directory */
+	sprintf(name, "%x", dev->board->slot);
+	e = dev->procdir = proc_mkdir(name, proc_bus_nubus_dir);
+	if (!e)
+		return -ENOMEM;
+
+	/* Now recursively populate it with files */
+	nubus_get_root_dir(dev->board, &root);
+	nubus_proc_populate(dev, e, &root);
+
+	return 0;
+}
+
+/* FIXME: this is certainly broken! */
+int nubus_proc_detach_device(struct nubus_dev *dev)
+{
+	struct proc_dir_entry *e;
+
+	if ((e = dev->procdir)) {
+		if (atomic_read(&e->count))
+			return -EBUSY;
+		remove_proc_entry(e->name, proc_bus_nubus_dir);
+		dev->procdir = NULL;
+	}
+	return 0;
+}
+
+void __init proc_bus_nubus_add_devices(void)
+{
+	struct nubus_dev *dev;
+	
+	for(dev = nubus_devices; dev; dev = dev->next)
+		nubus_proc_attach_device(dev);
+}
+
+void __init nubus_proc_init(void)
+{
+	if (!MACH_IS_MAC)
+		return;
+	proc_bus_nubus_dir = proc_mkdir("nubus", proc_bus);
+	create_proc_info_entry("devices", 0, proc_bus_nubus_dir,
+				get_nubus_dev_info);
+	proc_bus_nubus_add_devices();
+}
