commit 51b67a6e6592db3b2aa06e870c6546bac095b22b
Author: Himanshu Jha <himanshujha199640@gmail.com>
Date:   Sun Aug 27 13:02:28 2017 +0530

    nubus: Remove cast to void pointer
    
    Casting void pointers to other pointer types is unnecessary.
    
    Signed-off-by: Himanshu Jha <himanshujha199640@gmail.com>
    Link: https://lore.kernel.org/r/1503819148-11676-1-git-send-email-himanshujha199640@gmail.com
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index bb0d63a44f41..f70ba58dbc55 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -163,7 +163,7 @@ unsigned char *nubus_dirptr(const struct nubus_dirent *nd)
 void nubus_get_rsrc_mem(void *dest, const struct nubus_dirent *dirent,
 			unsigned int len)
 {
-	unsigned char *t = (unsigned char *)dest;
+	unsigned char *t = dest;
 	unsigned char *p = nubus_dirptr(dirent);
 
 	while (len) {

commit bdeeed098811b36d1f988521600a89a400830a4b
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed May 9 11:04:48 2018 +1000

    nubus: Call bus_register unconditionally
    
    Loading a NuBus driver module on a non-NuBus machine triggers the
    BUG_ON(!drv->bus->p) in driver_register(), because bus_register() was
    not called, because it is conditional on MACH_IS_MAC.
    
    Fix the crash by calling bus_register() unconditionally. Call it from
    a postcore_initcall(), like other busses do.
    
    Hence, the bus type is available for device_register(), which happens
    in a subsys initcall, and for driver_register(), which happens in a
    device or module initcall.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reported-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Fixes: 7f86c765a6a2 ("nubus: Add support for the driver model")
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index 4621ff98138c..bb0d63a44f41 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -875,7 +875,7 @@ static int __init nubus_init(void)
 		return 0;
 
 	nubus_proc_init();
-	err = nubus_bus_register();
+	err = nubus_parent_device_register();
 	if (err)
 		return err;
 	nubus_scan_bus();

commit 7f86c765a6a2bb837c45f11526176125ff50e21f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:14 2018 -0500

    nubus: Add support for the driver model
    
    This patch brings basic support for the Linux Driver Model to the
    NuBus subsystem.
    
    For flexibility, the matching of boards with drivers is left up to the
    drivers. This is also the approach taken by NetBSD. A board may have
    many functions, and drivers may have to consider many functional
    resources and board resources in order to match a device.
    
    This implementation does not bind drivers to resources (nor does it bind
    many drivers to the same board). Apple's NuBus declaration ROM design
    is flexible enough to allow that, but I don't see a need to support it
    as we don't use the "slot zero" resources (in the main logic board ROM).
    
    Eliminate the global nubus_boards linked list by rewriting the procfs
    board iterator around bus_for_each_dev(). Hence the nubus device refcount
    can be used to determine the lifespan of board objects.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index 0bb54ccd7a1a..4621ff98138c 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -33,7 +33,6 @@
 /* Globals */
 
 LIST_HEAD(nubus_func_rsrcs);
-struct nubus_board *nubus_boards;
 
 /* Meaning of "bytelanes":
 
@@ -715,10 +714,9 @@ static int __init nubus_get_board_resource(struct nubus_board *board, int slot,
 	return 0;
 }
 
-static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
+static void __init nubus_add_board(int slot, int bytelanes)
 {
 	struct nubus_board *board;
-	struct nubus_board **boardp;
 	unsigned char *rp;
 	unsigned long dpat;
 	struct nubus_dir dir;
@@ -731,7 +729,7 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 
 	/* Actually we should probably panic if this fails */
 	if ((board = kzalloc(sizeof(*board), GFP_ATOMIC)) == NULL)
-		return NULL;
+		return;
 	board->fblock = rp;
 
 	/* Dump the format block for debugging purposes */
@@ -794,7 +792,8 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 	if (nubus_readdir(&dir, &ent) == -1) {
 		/* We can't have this! */
 		pr_err("Slot %X: Board resource not found!\n", slot);
-		return NULL;
+		kfree(board);
+		return;
 	}
 
 	if (ent.type < 1 || ent.type > 127)
@@ -823,14 +822,8 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 		list_add_tail(&fres->list, &nubus_func_rsrcs);
 	}
 
-	/* Put it on the global NuBus board chain. Keep entries in order. */
-	for (boardp = &nubus_boards; *boardp != NULL;
-	     boardp = &((*boardp)->next))
-		/* spin */;
-	*boardp = board;
-	board->next = NULL;
-
-	return board;
+	if (nubus_device_register(board))
+		put_device(&board->dev);
 }
 
 static void __init nubus_probe_slot(int slot)
@@ -876,10 +869,15 @@ static void __init nubus_scan_bus(void)
 
 static int __init nubus_init(void)
 {
+	int err;
+
 	if (!MACH_IS_MAC)
 		return 0;
 
 	nubus_proc_init();
+	err = nubus_bus_register();
+	if (err)
+		return err;
 	nubus_scan_bus();
 	return 0;
 }

commit 41b848160eabb22957652936b66ccafd95ab5ad8
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Adopt standard linked list implementation
    
    This increases code re-use and improves readability.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index 3657b13c0022..0bb54ccd7a1a 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -32,7 +32,7 @@
 
 /* Globals */
 
-struct nubus_rsrc *nubus_func_rsrcs;
+LIST_HEAD(nubus_func_rsrcs);
 struct nubus_board *nubus_boards;
 
 /* Meaning of "bytelanes":
@@ -305,33 +305,20 @@ EXPORT_SYMBOL(nubus_rewinddir);
 
 /* Driver interface functions, more or less like in pci.c */
 
-struct nubus_rsrc *nubus_find_type(unsigned short category, unsigned short type,
-				   const struct nubus_rsrc *from)
+struct nubus_rsrc *nubus_first_rsrc_or_null(void)
 {
-	struct nubus_rsrc *itor = from ? from->next : nubus_func_rsrcs;
-
-	while (itor) {
-		if (itor->category == category && itor->type == type)
-			return itor;
-		itor = itor->next;
-	}
-	return NULL;
+	return list_first_entry_or_null(&nubus_func_rsrcs, struct nubus_rsrc,
+					list);
 }
-EXPORT_SYMBOL(nubus_find_type);
+EXPORT_SYMBOL(nubus_first_rsrc_or_null);
 
-struct nubus_rsrc *nubus_find_slot(unsigned int slot,
-				   const struct nubus_rsrc *from)
+struct nubus_rsrc *nubus_next_rsrc_or_null(struct nubus_rsrc *from)
 {
-	struct nubus_rsrc *itor = from ? from->next : nubus_func_rsrcs;
-
-	while (itor) {
-		if (itor->board->slot == slot)
-			return itor;
-		itor = itor->next;
-	}
-	return NULL;
+	if (list_is_last(&from->list, &nubus_func_rsrcs))
+		return NULL;
+	return list_next_entry(from, list);
 }
-EXPORT_SYMBOL(nubus_find_slot);
+EXPORT_SYMBOL(nubus_next_rsrc_or_null);
 
 int
 nubus_find_rsrc(struct nubus_dir *dir, unsigned char rsrc_type,
@@ -819,7 +806,6 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 
 	while (nubus_readdir(&dir, &ent) != -1) {
 		struct nubus_rsrc *fres;
-		struct nubus_rsrc **fresp;
 
 		fres = nubus_get_functional_resource(board, slot, &ent);
 		if (fres == NULL)
@@ -834,16 +820,7 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 		}
 		prev_resid = fres->resid;
 
-		/* We zeroed this out above */
-		if (board->first_func_rsrc == NULL)
-			board->first_func_rsrc = fres;
-
-		/* Put it on the func. resource list. Keep entries in order. */
-		for (fresp = &nubus_func_rsrcs; *fresp != NULL;
-		     fresp = &((*fresp)->next))
-			/* spin */;
-		*fresp = fres;
-		fres->next = NULL;
+		list_add_tail(&fres->list, &nubus_func_rsrcs);
 	}
 
 	/* Put it on the global NuBus board chain. Keep entries in order. */

commit 189e19e8cbb49f5bf483e55bdbd1e56d3d6bcf75
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Rename struct nubus_dev
    
    It is misleading to call a functional resource a "device". In adopting
    the Linux Driver Model, the struct device will be embedded in struct
    nubus_board. That will compound the terminlogy problem because drivers
    will bind with boards, not with functional resources. Avoid this by
    renaming struct nubus_dev as struct nubus_rsrc. "Functional resource"
    is the vendor's terminology so this helps avoid confusion.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index f05541914c21..3657b13c0022 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -32,7 +32,7 @@
 
 /* Globals */
 
-struct nubus_dev *nubus_devices;
+struct nubus_rsrc *nubus_func_rsrcs;
 struct nubus_board *nubus_boards;
 
 /* Meaning of "bytelanes":
@@ -228,12 +228,11 @@ int nubus_get_root_dir(const struct nubus_board *board,
 EXPORT_SYMBOL(nubus_get_root_dir);
 
 /* This is a slyly renamed version of the above */
-int nubus_get_func_dir(const struct nubus_dev *dev,
-		       struct nubus_dir *dir)
+int nubus_get_func_dir(const struct nubus_rsrc *fres, struct nubus_dir *dir)
 {
-	dir->ptr = dir->base = dev->directory;
+	dir->ptr = dir->base = fres->directory;
 	dir->done = 0;
-	dir->mask = dev->board->lanes;
+	dir->mask = fres->board->lanes;
 	return 0;
 }
 EXPORT_SYMBOL(nubus_get_func_dir);
@@ -306,11 +305,10 @@ EXPORT_SYMBOL(nubus_rewinddir);
 
 /* Driver interface functions, more or less like in pci.c */
 
-struct nubus_dev*
-nubus_find_type(unsigned short category, unsigned short type,
-		const struct nubus_dev *from)
+struct nubus_rsrc *nubus_find_type(unsigned short category, unsigned short type,
+				   const struct nubus_rsrc *from)
 {
-	struct nubus_dev *itor = from ? from->next : nubus_devices;
+	struct nubus_rsrc *itor = from ? from->next : nubus_func_rsrcs;
 
 	while (itor) {
 		if (itor->category == category && itor->type == type)
@@ -321,10 +319,10 @@ nubus_find_type(unsigned short category, unsigned short type,
 }
 EXPORT_SYMBOL(nubus_find_type);
 
-struct nubus_dev*
-nubus_find_slot(unsigned int slot, const struct nubus_dev *from)
+struct nubus_rsrc *nubus_find_slot(unsigned int slot,
+				   const struct nubus_rsrc *from)
 {
-	struct nubus_dev *itor = from ? from->next : nubus_devices;
+	struct nubus_rsrc *itor = from ? from->next : nubus_func_rsrcs;
 
 	while (itor) {
 		if (itor->board->slot == slot)
@@ -403,19 +401,19 @@ static int __init nubus_get_display_vidmode(struct nubus_board *board,
 	return 0;
 }
 
-static int __init nubus_get_display_resource(struct nubus_dev *dev,
+static int __init nubus_get_display_resource(struct nubus_rsrc *fres,
 					     struct proc_dir_entry *procdir,
 					     const struct nubus_dirent *ent)
 {
 	switch (ent->type) {
 	case NUBUS_RESID_GAMMADIR:
 		pr_debug("    gamma directory offset: 0x%06x\n", ent->data);
-		nubus_get_block_rsrc_dir(dev->board, procdir, ent);
+		nubus_get_block_rsrc_dir(fres->board, procdir, ent);
 		break;
 	case 0x0080 ... 0x0085:
 		pr_debug("    mode 0x%02x info offset: 0x%06x\n",
 			ent->type, ent->data);
-		nubus_get_display_vidmode(dev->board, procdir, ent);
+		nubus_get_display_vidmode(fres->board, procdir, ent);
 		break;
 	default:
 		pr_debug("    unknown resource 0x%02x, data 0x%06x\n",
@@ -425,7 +423,7 @@ static int __init nubus_get_display_resource(struct nubus_dev *dev,
 	return 0;
 }
 
-static int __init nubus_get_network_resource(struct nubus_dev *dev,
+static int __init nubus_get_network_resource(struct nubus_rsrc *fres,
 					     struct proc_dir_entry *procdir,
 					     const struct nubus_dirent *ent)
 {
@@ -447,7 +445,7 @@ static int __init nubus_get_network_resource(struct nubus_dev *dev,
 	return 0;
 }
 
-static int __init nubus_get_cpu_resource(struct nubus_dev *dev,
+static int __init nubus_get_cpu_resource(struct nubus_rsrc *fres,
 					 struct proc_dir_entry *procdir,
 					 const struct nubus_dirent *ent)
 {
@@ -480,19 +478,19 @@ static int __init nubus_get_cpu_resource(struct nubus_dev *dev,
 	return 0;
 }
 
-static int __init nubus_get_private_resource(struct nubus_dev *dev,
+static int __init nubus_get_private_resource(struct nubus_rsrc *fres,
 					     struct proc_dir_entry *procdir,
 					     const struct nubus_dirent *ent)
 {
-	switch (dev->category) {
+	switch (fres->category) {
 	case NUBUS_CAT_DISPLAY:
-		nubus_get_display_resource(dev, procdir, ent);
+		nubus_get_display_resource(fres, procdir, ent);
 		break;
 	case NUBUS_CAT_NETWORK:
-		nubus_get_network_resource(dev, procdir, ent);
+		nubus_get_network_resource(fres, procdir, ent);
 		break;
 	case NUBUS_CAT_CPU:
-		nubus_get_cpu_resource(dev, procdir, ent);
+		nubus_get_cpu_resource(fres, procdir, ent);
 		break;
 	default:
 		pr_debug("    unknown resource 0x%02x, data 0x%06x\n",
@@ -502,24 +500,25 @@ static int __init nubus_get_private_resource(struct nubus_dev *dev,
 	return 0;
 }
 
-static struct nubus_dev * __init
+static struct nubus_rsrc * __init
 nubus_get_functional_resource(struct nubus_board *board, int slot,
 			      const struct nubus_dirent *parent)
 {
 	struct nubus_dir dir;
 	struct nubus_dirent ent;
-	struct nubus_dev *dev;
+	struct nubus_rsrc *fres;
 
 	pr_debug("  Functional resource 0x%02x:\n", parent->type);
 	nubus_get_subdir(parent, &dir);
 	dir.procdir = nubus_proc_add_rsrc_dir(board->procdir, parent, board);
 
 	/* Actually we should probably panic if this fails */
-	if ((dev = kzalloc(sizeof(*dev), GFP_ATOMIC)) == NULL)
+	fres = kzalloc(sizeof(*fres), GFP_ATOMIC);
+	if (!fres)
 		return NULL;
-	dev->resid = parent->type;
-	dev->directory = dir.base;
-	dev->board = board;
+	fres->resid = parent->type;
+	fres->directory = dir.base;
+	fres->board = board;
 
 	while (nubus_readdir(&dir, &ent) != -1) {
 		switch (ent.type) {
@@ -528,10 +527,10 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 			unsigned short nbtdata[4];
 
 			nubus_get_rsrc_mem(nbtdata, &ent, 8);
-			dev->category = nbtdata[0];
-			dev->type     = nbtdata[1];
-			dev->dr_sw    = nbtdata[2];
-			dev->dr_hw    = nbtdata[3];
+			fres->category = nbtdata[0];
+			fres->type     = nbtdata[1];
+			fres->dr_sw    = nbtdata[2];
+			fres->dr_hw    = nbtdata[3];
 			pr_debug("    type: [cat 0x%x type 0x%x sw 0x%x hw 0x%x]\n",
 				nbtdata[0], nbtdata[1], nbtdata[2], nbtdata[3]);
 			nubus_proc_add_rsrc_mem(dir.procdir, &ent, 8);
@@ -589,11 +588,11 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 		default:
 			/* Local/Private resources have their own
 			   function */
-			nubus_get_private_resource(dev, dir.procdir, &ent);
+			nubus_get_private_resource(fres, dir.procdir, &ent);
 		}
 	}
 
-	return dev;
+	return fres;
 }
 
 /* This is *really* cool. */
@@ -729,7 +728,6 @@ static int __init nubus_get_board_resource(struct nubus_board *board, int slot,
 	return 0;
 }
 
-/* Add a board (might be many devices) to the list */
 static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 {
 	struct nubus_board *board;
@@ -801,10 +799,11 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 	pr_debug("Slot %X resources:\n", slot);
 
 	/* Each slot should have one board resource and any number of
-	   functional resources.  So we'll fill in some fields in the
-	   struct nubus_board from the board resource, then walk down
-	   the list of functional resources, spinning out a nubus_dev
-	   for each of them. */
+	 * functional resources.  So we'll fill in some fields in the
+	 * struct nubus_board from the board resource, then walk down
+	 * the list of functional resources, spinning out a nubus_rsrc
+	 * for each of them.
+	 */
 	if (nubus_readdir(&dir, &ent) == -1) {
 		/* We can't have this! */
 		pr_err("Slot %X: Board resource not found!\n", slot);
@@ -819,32 +818,32 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 	nubus_get_board_resource(board, slot, &ent);
 
 	while (nubus_readdir(&dir, &ent) != -1) {
-		struct nubus_dev *dev;
-		struct nubus_dev **devp;
+		struct nubus_rsrc *fres;
+		struct nubus_rsrc **fresp;
 
-		dev = nubus_get_functional_resource(board, slot, &ent);
-		if (dev == NULL)
+		fres = nubus_get_functional_resource(board, slot, &ent);
+		if (fres == NULL)
 			continue;
 
 		/* Resources should appear in ascending ID order. This sanity
 		 * check prevents duplicate resource IDs.
 		 */
-		if (dev->resid <= prev_resid) {
-			kfree(dev);
+		if (fres->resid <= prev_resid) {
+			kfree(fres);
 			continue;
 		}
-		prev_resid = dev->resid;
+		prev_resid = fres->resid;
 
 		/* We zeroed this out above */
-		if (board->first_dev == NULL)
-			board->first_dev = dev;
+		if (board->first_func_rsrc == NULL)
+			board->first_func_rsrc = fres;
 
-		/* Put it on the global NuBus device chain. Keep entries in order. */
-		for (devp = &nubus_devices; *devp != NULL;
-		     devp = &((*devp)->next))
+		/* Put it on the func. resource list. Keep entries in order. */
+		for (fresp = &nubus_func_rsrcs; *fresp != NULL;
+		     fresp = &((*fresp)->next))
 			/* spin */;
-		*devp = dev;
-		dev->next = NULL;
+		*fresp = fres;
+		fres->next = NULL;
 	}
 
 	/* Put it on the global NuBus board chain. Keep entries in order. */

commit 2f7dd07ecadac6bdc3d55c217d65efa2834ba1cb
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Rework /proc/bus/nubus/s/ implementation
    
    The /proc/bus/nubus/s/ directory tree for any slot s is missing a lot
    of information. The struct file_operations methods have long been left
    unimplemented (hence the familiar compile-time warning, "Need to set
    some I/O handlers here").
    
    Slot resources have a complex structure which varies depending on board
    function. The logic for interpreting these ROM data structures is found
    in nubus.c. Let's not duplicate that logic in proc.c.
    
    Create the /proc/bus/nubus/s/ inodes while scanning slot s. During
    descent through slot resource subdirectories, call the new
    nubus_proc_add_foo() functions to create the procfs inodes.
    
    Also add a new function, nubus_seq_write_rsrc_mem(), to write the
    contents of a particular slot resource to a given seq_file. This is
    used by the procfs file_operations methods, to finally give userspace
    access to slot ROM information, such as the available video modes.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index c56ac36d91f2..f05541914c21 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -15,6 +15,7 @@
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/seq_file.h>
 #include <linux/slab.h>
 #include <asm/setup.h>
 #include <asm/page.h>
@@ -146,7 +147,7 @@ static inline void *nubus_rom_addr(int slot)
 	return (void *)(0xF1000000 + (slot << 24));
 }
 
-static unsigned char *nubus_dirptr(const struct nubus_dirent *nd)
+unsigned char *nubus_dirptr(const struct nubus_dirent *nd)
 {
 	unsigned char *p = nd->base;
 
@@ -173,8 +174,8 @@ void nubus_get_rsrc_mem(void *dest, const struct nubus_dirent *dirent,
 }
 EXPORT_SYMBOL(nubus_get_rsrc_mem);
 
-void nubus_get_rsrc_str(char *dest, const struct nubus_dirent *dirent,
-			unsigned int len)
+unsigned int nubus_get_rsrc_str(char *dest, const struct nubus_dirent *dirent,
+				unsigned int len)
 {
 	char *t = dest;
 	unsigned char *p = nubus_dirptr(dirent);
@@ -189,9 +190,33 @@ void nubus_get_rsrc_str(char *dest, const struct nubus_dirent *dirent,
 	}
 	if (len > 0)
 		*t = '\0';
+	return t - dest;
 }
 EXPORT_SYMBOL(nubus_get_rsrc_str);
 
+void nubus_seq_write_rsrc_mem(struct seq_file *m,
+			      const struct nubus_dirent *dirent,
+			      unsigned int len)
+{
+	unsigned long buf[32];
+	unsigned int buf_size = sizeof(buf);
+	unsigned char *p = nubus_dirptr(dirent);
+
+	/* If possible, write out full buffers */
+	while (len >= buf_size) {
+		unsigned int i;
+
+		for (i = 0; i < ARRAY_SIZE(buf); i++)
+			buf[i] = nubus_get_rom(&p, sizeof(buf[0]),
+					       dirent->mask);
+		seq_write(m, buf, buf_size);
+		len -= buf_size;
+	}
+	/* If not, write out individual bytes */
+	while (len--)
+		seq_putc(m, nubus_get_rom(&p, 1, dirent->mask));
+}
+
 int nubus_get_root_dir(const struct nubus_board *board,
 		       struct nubus_dir *dir)
 {
@@ -326,35 +351,35 @@ EXPORT_SYMBOL(nubus_find_rsrc);
    looking at, and print out lots and lots of information from the
    resource blocks. */
 
-/* FIXME: A lot of this stuff will eventually be useful after
-   initialization, for intelligently probing Ethernet and video chips,
-   among other things.  The rest of it should go in the /proc code.
-   For now, we just use it to give verbose boot logs. */
-
 static int __init nubus_get_block_rsrc_dir(struct nubus_board *board,
+					   struct proc_dir_entry *procdir,
 					   const struct nubus_dirent *parent)
 {
 	struct nubus_dir dir;
 	struct nubus_dirent ent;
 
 	nubus_get_subdir(parent, &dir);
+	dir.procdir = nubus_proc_add_rsrc_dir(procdir, parent, board);
 
 	while (nubus_readdir(&dir, &ent) != -1) {
 		u32 size;
 
 		nubus_get_rsrc_mem(&size, &ent, 4);
 		pr_debug("        block (0x%x), size %d\n", ent.type, size);
+		nubus_proc_add_rsrc_mem(dir.procdir, &ent, size);
 	}
 	return 0;
 }
 
 static int __init nubus_get_display_vidmode(struct nubus_board *board,
+					    struct proc_dir_entry *procdir,
 					    const struct nubus_dirent *parent)
 {
 	struct nubus_dir dir;
 	struct nubus_dirent ent;
 
 	nubus_get_subdir(parent, &dir);
+	dir.procdir = nubus_proc_add_rsrc_dir(procdir, parent, board);
 
 	while (nubus_readdir(&dir, &ent) != -1) {
 		switch (ent.type) {
@@ -366,37 +391,42 @@ static int __init nubus_get_display_vidmode(struct nubus_board *board,
 			nubus_get_rsrc_mem(&size, &ent, 4);
 			pr_debug("        block (0x%x), size %d\n", ent.type,
 				size);
+			nubus_proc_add_rsrc_mem(dir.procdir, &ent, size);
 			break;
 		}
 		default:
 			pr_debug("        unknown resource 0x%02x, data 0x%06x\n",
 				ent.type, ent.data);
+			nubus_proc_add_rsrc_mem(dir.procdir, &ent, 0);
 		}
 	}
 	return 0;
 }
 
 static int __init nubus_get_display_resource(struct nubus_dev *dev,
+					     struct proc_dir_entry *procdir,
 					     const struct nubus_dirent *ent)
 {
 	switch (ent->type) {
 	case NUBUS_RESID_GAMMADIR:
 		pr_debug("    gamma directory offset: 0x%06x\n", ent->data);
-		nubus_get_block_rsrc_dir(dev->board, ent);
+		nubus_get_block_rsrc_dir(dev->board, procdir, ent);
 		break;
 	case 0x0080 ... 0x0085:
 		pr_debug("    mode 0x%02x info offset: 0x%06x\n",
 			ent->type, ent->data);
-		nubus_get_display_vidmode(dev->board, ent);
+		nubus_get_display_vidmode(dev->board, procdir, ent);
 		break;
 	default:
 		pr_debug("    unknown resource 0x%02x, data 0x%06x\n",
 			ent->type, ent->data);
+		nubus_proc_add_rsrc_mem(procdir, ent, 0);
 	}
 	return 0;
 }
 
 static int __init nubus_get_network_resource(struct nubus_dev *dev,
+					     struct proc_dir_entry *procdir,
 					     const struct nubus_dirent *ent)
 {
 	switch (ent->type) {
@@ -406,16 +436,19 @@ static int __init nubus_get_network_resource(struct nubus_dev *dev,
 
 		nubus_get_rsrc_mem(addr, ent, 6);
 		pr_debug("    MAC address: %pM\n", addr);
+		nubus_proc_add_rsrc_mem(procdir, ent, 6);
 		break;
 	}
 	default:
 		pr_debug("    unknown resource 0x%02x, data 0x%06x\n",
 			ent->type, ent->data);
+		nubus_proc_add_rsrc_mem(procdir, ent, 0);
 	}
 	return 0;
 }
 
 static int __init nubus_get_cpu_resource(struct nubus_dev *dev,
+					 struct proc_dir_entry *procdir,
 					 const struct nubus_dirent *ent)
 {
 	switch (ent->type) {
@@ -426,6 +459,7 @@ static int __init nubus_get_cpu_resource(struct nubus_dev *dev,
 		nubus_get_rsrc_mem(&meminfo, ent, 8);
 		pr_debug("    memory: [ 0x%08lx 0x%08lx ]\n",
 			meminfo[0], meminfo[1]);
+		nubus_proc_add_rsrc_mem(procdir, ent, 8);
 		break;
 	}
 	case NUBUS_RESID_ROMINFO:
@@ -435,31 +469,35 @@ static int __init nubus_get_cpu_resource(struct nubus_dev *dev,
 		nubus_get_rsrc_mem(&rominfo, ent, 8);
 		pr_debug("    ROM:    [ 0x%08lx 0x%08lx ]\n",
 			rominfo[0], rominfo[1]);
+		nubus_proc_add_rsrc_mem(procdir, ent, 8);
 		break;
 	}
 	default:
 		pr_debug("    unknown resource 0x%02x, data 0x%06x\n",
 			ent->type, ent->data);
+		nubus_proc_add_rsrc_mem(procdir, ent, 0);
 	}
 	return 0;
 }
 
 static int __init nubus_get_private_resource(struct nubus_dev *dev,
+					     struct proc_dir_entry *procdir,
 					     const struct nubus_dirent *ent)
 {
 	switch (dev->category) {
 	case NUBUS_CAT_DISPLAY:
-		nubus_get_display_resource(dev, ent);
+		nubus_get_display_resource(dev, procdir, ent);
 		break;
 	case NUBUS_CAT_NETWORK:
-		nubus_get_network_resource(dev, ent);
+		nubus_get_network_resource(dev, procdir, ent);
 		break;
 	case NUBUS_CAT_CPU:
-		nubus_get_cpu_resource(dev, ent);
+		nubus_get_cpu_resource(dev, procdir, ent);
 		break;
 	default:
 		pr_debug("    unknown resource 0x%02x, data 0x%06x\n",
 			ent->type, ent->data);
+		nubus_proc_add_rsrc_mem(procdir, ent, 0);
 	}
 	return 0;
 }
@@ -474,6 +512,7 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 
 	pr_debug("  Functional resource 0x%02x:\n", parent->type);
 	nubus_get_subdir(parent, &dir);
+	dir.procdir = nubus_proc_add_rsrc_dir(board->procdir, parent, board);
 
 	/* Actually we should probably panic if this fails */
 	if ((dev = kzalloc(sizeof(*dev), GFP_ATOMIC)) == NULL)
@@ -495,14 +534,17 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 			dev->dr_hw    = nbtdata[3];
 			pr_debug("    type: [cat 0x%x type 0x%x sw 0x%x hw 0x%x]\n",
 				nbtdata[0], nbtdata[1], nbtdata[2], nbtdata[3]);
+			nubus_proc_add_rsrc_mem(dir.procdir, &ent, 8);
 			break;
 		}
 		case NUBUS_RESID_NAME:
 		{
 			char name[64];
+			unsigned int len;
 
-			nubus_get_rsrc_str(name, &ent, sizeof(name));
+			len = nubus_get_rsrc_str(name, &ent, sizeof(name));
 			pr_debug("    name: %s\n", name);
+			nubus_proc_add_rsrc_mem(dir.procdir, &ent, len + 1);
 			break;
 		}
 		case NUBUS_RESID_DRVRDIR:
@@ -511,7 +553,7 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 			   use this :-) */
 			pr_debug("    driver directory offset: 0x%06x\n",
 				ent.data);
-			nubus_get_block_rsrc_dir(board, &ent);
+			nubus_get_block_rsrc_dir(board, dir.procdir, &ent);
 			break;
 		}
 		case NUBUS_RESID_MINOR_BASEOS:
@@ -523,6 +565,7 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 
 			nubus_get_rsrc_mem(&base_offset, &ent, 4);
 			pr_debug("    memory offset: 0x%08x\n", base_offset);
+			nubus_proc_add_rsrc_mem(dir.procdir, &ent, 4);
 			break;
 		}
 		case NUBUS_RESID_MINOR_LENGTH:
@@ -532,18 +575,21 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 
 			nubus_get_rsrc_mem(&length, &ent, 4);
 			pr_debug("    memory length: 0x%08x\n", length);
+			nubus_proc_add_rsrc_mem(dir.procdir, &ent, 4);
 			break;
 		}
 		case NUBUS_RESID_FLAGS:
 			pr_debug("    flags: 0x%06x\n", ent.data);
+			nubus_proc_add_rsrc(dir.procdir, &ent);
 			break;
 		case NUBUS_RESID_HWDEVID:
 			pr_debug("    hwdevid: 0x%06x\n", ent.data);
+			nubus_proc_add_rsrc(dir.procdir, &ent);
 			break;
 		default:
 			/* Local/Private resources have their own
 			   function */
-			nubus_get_private_resource(dev, &ent);
+			nubus_get_private_resource(dev, dir.procdir, &ent);
 		}
 	}
 
@@ -552,6 +598,7 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 
 /* This is *really* cool. */
 static int __init nubus_get_icon(struct nubus_board *board,
+				 struct proc_dir_entry *procdir,
 				 const struct nubus_dirent *ent)
 {
 	/* Should be 32x32 if my memory serves me correctly */
@@ -564,11 +611,13 @@ static int __init nubus_get_icon(struct nubus_board *board,
 		pr_debug("        %08x %08x %08x %08x\n",
 			icon[i * 4 + 0], icon[i * 4 + 1],
 			icon[i * 4 + 2], icon[i * 4 + 3]);
+	nubus_proc_add_rsrc_mem(procdir, ent, 128);
 
 	return 0;
 }
 
 static int __init nubus_get_vendorinfo(struct nubus_board *board,
+				       struct proc_dir_entry *procdir,
 				       const struct nubus_dirent *parent)
 {
 	struct nubus_dir dir;
@@ -578,15 +627,18 @@ static int __init nubus_get_vendorinfo(struct nubus_board *board,
 
 	pr_debug("    vendor info:\n");
 	nubus_get_subdir(parent, &dir);
+	dir.procdir = nubus_proc_add_rsrc_dir(procdir, parent, board);
 
 	while (nubus_readdir(&dir, &ent) != -1) {
 		char name[64];
+		unsigned int len;
 
 		/* These are all strings, we think */
-		nubus_get_rsrc_str(name, &ent, sizeof(name));
+		len = nubus_get_rsrc_str(name, &ent, sizeof(name));
 		if (ent.type < 1 || ent.type > 5)
 			ent.type = 5;
 		pr_debug("    %s: %s\n", vendor_fields[ent.type - 1], name);
+		nubus_proc_add_rsrc_mem(dir.procdir, &ent, len + 1);
 	}
 	return 0;
 }
@@ -599,6 +651,7 @@ static int __init nubus_get_board_resource(struct nubus_board *board, int slot,
 
 	pr_debug("  Board resource 0x%02x:\n", parent->type);
 	nubus_get_subdir(parent, &dir);
+	dir.procdir = nubus_proc_add_rsrc_dir(board->procdir, parent, board);
 
 	while (nubus_readdir(&dir, &ent) != -1) {
 		switch (ent.type) {
@@ -615,49 +668,62 @@ static int __init nubus_get_board_resource(struct nubus_board *board, int slot,
 			    nbtdata[2] != 0 || nbtdata[3] != 0)
 				pr_err("Slot %X: sResource is not a board resource!\n",
 				       slot);
+			nubus_proc_add_rsrc_mem(dir.procdir, &ent, 8);
 			break;
 		}
 		case NUBUS_RESID_NAME:
-			nubus_get_rsrc_str(board->name, &ent,
-					   sizeof(board->name));
+		{
+			unsigned int len;
+
+			len = nubus_get_rsrc_str(board->name, &ent,
+						 sizeof(board->name));
 			pr_debug("    name: %s\n", board->name);
+			nubus_proc_add_rsrc_mem(dir.procdir, &ent, len + 1);
 			break;
+		}
 		case NUBUS_RESID_ICON:
-			nubus_get_icon(board, &ent);
+			nubus_get_icon(board, dir.procdir, &ent);
 			break;
 		case NUBUS_RESID_BOARDID:
 			pr_debug("    board id: 0x%x\n", ent.data);
+			nubus_proc_add_rsrc(dir.procdir, &ent);
 			break;
 		case NUBUS_RESID_PRIMARYINIT:
 			pr_debug("    primary init offset: 0x%06x\n", ent.data);
+			nubus_proc_add_rsrc(dir.procdir, &ent);
 			break;
 		case NUBUS_RESID_VENDORINFO:
-			nubus_get_vendorinfo(board, &ent);
+			nubus_get_vendorinfo(board, dir.procdir, &ent);
 			break;
 		case NUBUS_RESID_FLAGS:
 			pr_debug("    flags: 0x%06x\n", ent.data);
+			nubus_proc_add_rsrc(dir.procdir, &ent);
 			break;
 		case NUBUS_RESID_HWDEVID:
 			pr_debug("    hwdevid: 0x%06x\n", ent.data);
+			nubus_proc_add_rsrc(dir.procdir, &ent);
 			break;
 		case NUBUS_RESID_SECONDINIT:
 			pr_debug("    secondary init offset: 0x%06x\n",
 				 ent.data);
+			nubus_proc_add_rsrc(dir.procdir, &ent);
 			break;
 			/* WTF isn't this in the functional resources? */
 		case NUBUS_RESID_VIDNAMES:
 			pr_debug("    vidnames directory offset: 0x%06x\n",
 				ent.data);
-			nubus_get_block_rsrc_dir(board, &ent);
+			nubus_get_block_rsrc_dir(board, dir.procdir, &ent);
 			break;
 			/* Same goes for this */
 		case NUBUS_RESID_VIDMODES:
 			pr_debug("    video mode parameter directory offset: 0x%06x\n",
 				ent.data);
+			nubus_proc_add_rsrc(dir.procdir, &ent);
 			break;
 		default:
 			pr_debug("    unknown resource 0x%02x, data 0x%06x\n",
 				ent.type, ent.data);
+			nubus_proc_add_rsrc_mem(dir.procdir, &ent, 0);
 		}
 	}
 	return 0;
@@ -748,6 +814,8 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 	if (ent.type < 1 || ent.type > 127)
 		pr_warn("Slot %X: Board resource ID is invalid!\n", slot);
 
+	board->procdir = nubus_proc_add_board(board);
+
 	nubus_get_board_resource(board, slot, &ent);
 
 	while (nubus_readdir(&dir, &ent) != -1) {
@@ -835,8 +903,8 @@ static int __init nubus_init(void)
 	if (!MACH_IS_MAC)
 		return 0;
 
-	nubus_scan_bus();
 	nubus_proc_init();
+	nubus_scan_bus();
 	return 0;
 }
 

commit 883b8cb31a8546b9921c98b255d5f7779d1bc9f6
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Generalize block resource handling
    
    Scrap the specialized code to unpack video mode name resources and
    driver resources. It isn't useful.
    Instead, add a re-usable function to handle lists of block resources of
    any kind, and descend into the video mode table resource directory.
    Rename callers as nubus_get_foo(), consistent with their purpose and
    with related functions in the same file.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index 4ae5c420f13f..c56ac36d91f2 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -331,16 +331,63 @@ EXPORT_SYMBOL(nubus_find_rsrc);
    among other things.  The rest of it should go in the /proc code.
    For now, we just use it to give verbose boot logs. */
 
-static int __init nubus_show_display_resource(struct nubus_dev *dev,
-					      const struct nubus_dirent *ent)
+static int __init nubus_get_block_rsrc_dir(struct nubus_board *board,
+					   const struct nubus_dirent *parent)
+{
+	struct nubus_dir dir;
+	struct nubus_dirent ent;
+
+	nubus_get_subdir(parent, &dir);
+
+	while (nubus_readdir(&dir, &ent) != -1) {
+		u32 size;
+
+		nubus_get_rsrc_mem(&size, &ent, 4);
+		pr_debug("        block (0x%x), size %d\n", ent.type, size);
+	}
+	return 0;
+}
+
+static int __init nubus_get_display_vidmode(struct nubus_board *board,
+					    const struct nubus_dirent *parent)
+{
+	struct nubus_dir dir;
+	struct nubus_dirent ent;
+
+	nubus_get_subdir(parent, &dir);
+
+	while (nubus_readdir(&dir, &ent) != -1) {
+		switch (ent.type) {
+		case 1: /* mVidParams */
+		case 2: /* mTable */
+		{
+			u32 size;
+
+			nubus_get_rsrc_mem(&size, &ent, 4);
+			pr_debug("        block (0x%x), size %d\n", ent.type,
+				size);
+			break;
+		}
+		default:
+			pr_debug("        unknown resource 0x%02x, data 0x%06x\n",
+				ent.type, ent.data);
+		}
+	}
+	return 0;
+}
+
+static int __init nubus_get_display_resource(struct nubus_dev *dev,
+					     const struct nubus_dirent *ent)
 {
 	switch (ent->type) {
 	case NUBUS_RESID_GAMMADIR:
 		pr_debug("    gamma directory offset: 0x%06x\n", ent->data);
+		nubus_get_block_rsrc_dir(dev->board, ent);
 		break;
 	case 0x0080 ... 0x0085:
 		pr_debug("    mode 0x%02x info offset: 0x%06x\n",
 			ent->type, ent->data);
+		nubus_get_display_vidmode(dev->board, ent);
 		break;
 	default:
 		pr_debug("    unknown resource 0x%02x, data 0x%06x\n",
@@ -349,8 +396,8 @@ static int __init nubus_show_display_resource(struct nubus_dev *dev,
 	return 0;
 }
 
-static int __init nubus_show_network_resource(struct nubus_dev *dev,
-					      const struct nubus_dirent *ent)
+static int __init nubus_get_network_resource(struct nubus_dev *dev,
+					     const struct nubus_dirent *ent)
 {
 	switch (ent->type) {
 	case NUBUS_RESID_MAC_ADDRESS:
@@ -368,8 +415,8 @@ static int __init nubus_show_network_resource(struct nubus_dev *dev,
 	return 0;
 }
 
-static int __init nubus_show_cpu_resource(struct nubus_dev *dev,
-					  const struct nubus_dirent *ent)
+static int __init nubus_get_cpu_resource(struct nubus_dev *dev,
+					 const struct nubus_dirent *ent)
 {
 	switch (ent->type) {
 	case NUBUS_RESID_MEMINFO:
@@ -397,18 +444,18 @@ static int __init nubus_show_cpu_resource(struct nubus_dev *dev,
 	return 0;
 }
 
-static int __init nubus_show_private_resource(struct nubus_dev *dev,
-					      const struct nubus_dirent *ent)
+static int __init nubus_get_private_resource(struct nubus_dev *dev,
+					     const struct nubus_dirent *ent)
 {
 	switch (dev->category) {
 	case NUBUS_CAT_DISPLAY:
-		nubus_show_display_resource(dev, ent);
+		nubus_get_display_resource(dev, ent);
 		break;
 	case NUBUS_CAT_NETWORK:
-		nubus_show_network_resource(dev, ent);
+		nubus_get_network_resource(dev, ent);
 		break;
 	case NUBUS_CAT_CPU:
-		nubus_show_cpu_resource(dev, ent);
+		nubus_get_cpu_resource(dev, ent);
 		break;
 	default:
 		pr_debug("    unknown resource 0x%02x, data 0x%06x\n",
@@ -462,14 +509,9 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 		{
 			/* MacOS driver.  If we were NetBSD we might
 			   use this :-) */
-			struct nubus_dir drvr_dir;
-			struct nubus_dirent drvr_ent;
-			unsigned char *driver;
-
-			nubus_get_subdir(&ent, &drvr_dir);
-			nubus_readdir(&drvr_dir, &drvr_ent);
-			driver = nubus_dirptr(&drvr_ent);
-			pr_debug("    driver at: 0x%p\n", driver);
+			pr_debug("    driver directory offset: 0x%06x\n",
+				ent.data);
+			nubus_get_block_rsrc_dir(board, &ent);
 			break;
 		}
 		case NUBUS_RESID_MINOR_BASEOS:
@@ -501,50 +543,13 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 		default:
 			/* Local/Private resources have their own
 			   function */
-			nubus_show_private_resource(dev, &ent);
+			nubus_get_private_resource(dev, &ent);
 		}
 	}
 
 	return dev;
 }
 
-/* This is cool. */
-static int __init nubus_get_vidnames(struct nubus_board *board,
-				     const struct nubus_dirent *parent)
-{
-	struct nubus_dir dir;
-	struct nubus_dirent ent;
-
-	/* FIXME: obviously we want to put this in a header file soon */
-	struct vidmode {
-		u32 size;
-		/* Don't know what this is yet */
-		u16 id;
-		/* Longest one I've seen so far is 26 characters */
-		char name[36];
-	};
-
-	pr_debug("    video modes supported:\n");
-	nubus_get_subdir(parent, &dir);
-
-	while (nubus_readdir(&dir, &ent) != -1) {
-		struct vidmode mode;
-		u32 size;
-
-		/* First get the length */
-		nubus_get_rsrc_mem(&size, &ent, 4);
-
-		/* Now clobber the whole thing */
-		if (size > sizeof(mode) - 1)
-			size = sizeof(mode) - 1;
-		memset(&mode, 0, sizeof(mode));
-		nubus_get_rsrc_mem(&mode, &ent, size);
-		pr_debug("      0x%02x: 0x%04x %s\n", ent.type,
-			mode.id, mode.name);
-	}
-	return 0;
-}
-
 /* This is *really* cool. */
 static int __init nubus_get_icon(struct nubus_board *board,
 				 const struct nubus_dirent *ent)
@@ -641,7 +646,9 @@ static int __init nubus_get_board_resource(struct nubus_board *board, int slot,
 			break;
 			/* WTF isn't this in the functional resources? */
 		case NUBUS_RESID_VIDNAMES:
-			nubus_get_vidnames(board, &ent);
+			pr_debug("    vidnames directory offset: 0x%06x\n",
+				ent.data);
+			nubus_get_block_rsrc_dir(board, &ent);
 			break;
 			/* Same goes for this */
 		case NUBUS_RESID_VIDMODES:

commit 9f97977deb22e602f91047a105b961ffb36adc2b
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Remove redundant code
    
    Eliminate unused values from struct nubus_dev to save wasted memory
    (a Radius PrecisionColor 24X card has about 95 functional resources
    and up to six such cards may be fitted). Also remove redundant static
    variable initialization, an unreachable !MACH_IS_MAC conditional,
    the unused nubus_find_device() function, the bogus get_nubus_list()
    prototype and the pointless card_present temporary variable.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index e7c7e49a074a..4ae5c420f13f 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -281,23 +281,6 @@ EXPORT_SYMBOL(nubus_rewinddir);
 
 /* Driver interface functions, more or less like in pci.c */
 
-struct nubus_dev*
-nubus_find_device(unsigned short category, unsigned short type,
-		  unsigned short dr_hw, unsigned short dr_sw,
-		  const struct nubus_dev *from)
-{
-	struct nubus_dev *itor = from ? from->next : nubus_devices;
-
-	while (itor) {
-		if (itor->category == category && itor->type == type &&
-		    itor->dr_hw == dr_hw && itor->dr_sw == dr_sw)
-			return itor;
-		itor = itor->next;
-	}
-	return NULL;
-}
-EXPORT_SYMBOL(nubus_find_device);
-
 struct nubus_dev*
 nubus_find_type(unsigned short category, unsigned short type,
 		const struct nubus_dev *from)
@@ -469,8 +452,10 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 		}
 		case NUBUS_RESID_NAME:
 		{
-			nubus_get_rsrc_str(dev->name, &ent, sizeof(dev->name));
-			pr_debug("    name: %s\n", dev->name);
+			char name[64];
+
+			nubus_get_rsrc_str(name, &ent, sizeof(name));
+			pr_debug("    name: %s\n", name);
 			break;
 		}
 		case NUBUS_RESID_DRVRDIR:
@@ -479,32 +464,39 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 			   use this :-) */
 			struct nubus_dir drvr_dir;
 			struct nubus_dirent drvr_ent;
+			unsigned char *driver;
 
 			nubus_get_subdir(&ent, &drvr_dir);
 			nubus_readdir(&drvr_dir, &drvr_ent);
-			dev->driver = nubus_dirptr(&drvr_ent);
-			pr_debug("    driver at: 0x%p\n", dev->driver);
+			driver = nubus_dirptr(&drvr_ent);
+			pr_debug("    driver at: 0x%p\n", driver);
 			break;
 		}
 		case NUBUS_RESID_MINOR_BASEOS:
+		{
 			/* We will need this in order to support
 			   multiple framebuffers.  It might be handy
 			   for Ethernet as well */
-			nubus_get_rsrc_mem(&dev->iobase, &ent, 4);
-			pr_debug("    memory offset: 0x%08lx\n", dev->iobase);
+			u32 base_offset;
+
+			nubus_get_rsrc_mem(&base_offset, &ent, 4);
+			pr_debug("    memory offset: 0x%08x\n", base_offset);
 			break;
+		}
 		case NUBUS_RESID_MINOR_LENGTH:
+		{
 			/* Ditto */
-			nubus_get_rsrc_mem(&dev->iosize, &ent, 4);
-			pr_debug("    memory length: 0x%08lx\n", dev->iosize);
+			u32 length;
+
+			nubus_get_rsrc_mem(&length, &ent, 4);
+			pr_debug("    memory length: 0x%08x\n", length);
 			break;
+		}
 		case NUBUS_RESID_FLAGS:
-			dev->flags = ent.data;
-			pr_debug("    flags: 0x%06x\n", dev->flags);
+			pr_debug("    flags: 0x%06x\n", ent.data);
 			break;
 		case NUBUS_RESID_HWDEVID:
-			dev->hwdevid = ent.data;
-			pr_debug("    hwdevid: 0x%06x\n", dev->hwdevid);
+			pr_debug("    hwdevid: 0x%06x\n", ent.data);
 			break;
 		default:
 			/* Local/Private resources have their own
@@ -798,11 +790,8 @@ static void __init nubus_probe_slot(int slot)
 
 	rp = nubus_rom_addr(slot);
 	for (i = 4; i; i--) {
-		int card_present;
-
 		rp--;
-		card_present = hwreg_present(rp);
-		if (!card_present)
+		if (!hwreg_present(rp))
 			continue;
 
 		dp = *rp;
@@ -839,8 +828,6 @@ static int __init nubus_init(void)
 	if (!MACH_IS_MAC)
 		return 0;
 
-	nubus_devices = NULL;
-	nubus_boards = NULL;
 	nubus_scan_bus();
 	nubus_proc_init();
 	return 0;

commit d7811a3678eac540a43d9fd3dda7867280844836
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Validate slot resource IDs
    
    While we are here, include the slot number in the related error messages.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index ef3a115920ca..e7c7e49a074a 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -616,7 +616,8 @@ static int __init nubus_get_board_resource(struct nubus_board *board, int slot,
 				nbtdata[0], nbtdata[1], nbtdata[2], nbtdata[3]);
 			if (nbtdata[0] != 1 || nbtdata[1] != 0 ||
 			    nbtdata[2] != 0 || nbtdata[3] != 0)
-				pr_err("this sResource is not a board resource!\n");
+				pr_err("Slot %X: sResource is not a board resource!\n",
+				       slot);
 			break;
 		}
 		case NUBUS_RESID_NAME:
@@ -672,6 +673,7 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 	unsigned long dpat;
 	struct nubus_dir dir;
 	struct nubus_dirent ent;
+	int prev_resid = -1;
 
 	/* Move to the start of the format block */
 	rp = nubus_rom_addr(slot);
@@ -711,10 +713,10 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 
 	/* Directory offset should be small and negative... */
 	if (!(board->doffset & 0x00FF0000))
-		pr_warn("Dodgy doffset!\n");
+		pr_warn("Slot %X: Dodgy doffset!\n", slot);
 	dpat = nubus_get_rom(&rp, 4, bytelanes);
 	if (dpat != NUBUS_TEST_PATTERN)
-		pr_warn("Wrong test pattern %08lx!\n", dpat);
+		pr_warn("Slot %X: Wrong test pattern %08lx!\n", slot, dpat);
 
 	/*
 	 *	I wonder how the CRC is meant to work -
@@ -740,12 +742,15 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 	   for each of them. */
 	if (nubus_readdir(&dir, &ent) == -1) {
 		/* We can't have this! */
-		pr_err("Board resource not found!\n");
+		pr_err("Slot %X: Board resource not found!\n", slot);
 		return NULL;
-	} else {
-		nubus_get_board_resource(board, slot, &ent);
 	}
 
+	if (ent.type < 1 || ent.type > 127)
+		pr_warn("Slot %X: Board resource ID is invalid!\n", slot);
+
+	nubus_get_board_resource(board, slot, &ent);
+
 	while (nubus_readdir(&dir, &ent) != -1) {
 		struct nubus_dev *dev;
 		struct nubus_dev **devp;
@@ -754,6 +759,15 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 		if (dev == NULL)
 			continue;
 
+		/* Resources should appear in ascending ID order. This sanity
+		 * check prevents duplicate resource IDs.
+		 */
+		if (dev->resid <= prev_resid) {
+			kfree(dev);
+			continue;
+		}
+		prev_resid = dev->resid;
+
 		/* We zeroed this out above */
 		if (board->first_dev == NULL)
 			board->first_dev = dev;

commit f53bad0881a35c45d89bd8c552dc0498b96403c5
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Fix log spam
    
    Testing shows that a single Radius PrecisionColor 24X display board,
    which has 95 functional resources, produces over a thousand lines of
    log messages. Suppress these messages with pr_debug().
    Remove some redundant messages relating to nubus_get_subdir() calls.
    Fix the format block debug messages as the sequence of entries is
    backwards (my bad).
    Move the "scanning slots" message to its proper location.
    
    Fixes: 71ae40e4cf33 ("nubus: Clean up printk calls")
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index 35056cee94b1..ef3a115920ca 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -353,15 +353,15 @@ static int __init nubus_show_display_resource(struct nubus_dev *dev,
 {
 	switch (ent->type) {
 	case NUBUS_RESID_GAMMADIR:
-		pr_info("    gamma directory offset: 0x%06x\n", ent->data);
+		pr_debug("    gamma directory offset: 0x%06x\n", ent->data);
 		break;
 	case 0x0080 ... 0x0085:
-		pr_info("    mode %02X info offset: 0x%06x\n",
-		       ent->type, ent->data);
+		pr_debug("    mode 0x%02x info offset: 0x%06x\n",
+			ent->type, ent->data);
 		break;
 	default:
-		pr_info("    unknown resource %02X, data 0x%06x\n",
-		       ent->type, ent->data);
+		pr_debug("    unknown resource 0x%02x, data 0x%06x\n",
+			ent->type, ent->data);
 	}
 	return 0;
 }
@@ -375,12 +375,12 @@ static int __init nubus_show_network_resource(struct nubus_dev *dev,
 		char addr[6];
 
 		nubus_get_rsrc_mem(addr, ent, 6);
-		pr_info("    MAC address: %pM\n", addr);
+		pr_debug("    MAC address: %pM\n", addr);
 		break;
 	}
 	default:
-		pr_info("    unknown resource %02X, data 0x%06x\n",
-		       ent->type, ent->data);
+		pr_debug("    unknown resource 0x%02x, data 0x%06x\n",
+			ent->type, ent->data);
 	}
 	return 0;
 }
@@ -394,8 +394,8 @@ static int __init nubus_show_cpu_resource(struct nubus_dev *dev,
 		unsigned long meminfo[2];
 
 		nubus_get_rsrc_mem(&meminfo, ent, 8);
-		pr_info("    memory: [ 0x%08lx 0x%08lx ]\n",
-		       meminfo[0], meminfo[1]);
+		pr_debug("    memory: [ 0x%08lx 0x%08lx ]\n",
+			meminfo[0], meminfo[1]);
 		break;
 	}
 	case NUBUS_RESID_ROMINFO:
@@ -403,13 +403,13 @@ static int __init nubus_show_cpu_resource(struct nubus_dev *dev,
 		unsigned long rominfo[2];
 
 		nubus_get_rsrc_mem(&rominfo, ent, 8);
-		pr_info("    ROM:    [ 0x%08lx 0x%08lx ]\n",
-		       rominfo[0], rominfo[1]);
+		pr_debug("    ROM:    [ 0x%08lx 0x%08lx ]\n",
+			rominfo[0], rominfo[1]);
 		break;
 	}
 	default:
-		pr_info("    unknown resource %02X, data 0x%06x\n",
-		       ent->type, ent->data);
+		pr_debug("    unknown resource 0x%02x, data 0x%06x\n",
+			ent->type, ent->data);
 	}
 	return 0;
 }
@@ -428,8 +428,8 @@ static int __init nubus_show_private_resource(struct nubus_dev *dev,
 		nubus_show_cpu_resource(dev, ent);
 		break;
 	default:
-		pr_info("    unknown resource %02X, data 0x%06x\n",
-		       ent->type, ent->data);
+		pr_debug("    unknown resource 0x%02x, data 0x%06x\n",
+			ent->type, ent->data);
 	}
 	return 0;
 }
@@ -442,12 +442,9 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 	struct nubus_dirent ent;
 	struct nubus_dev *dev;
 
-	pr_info("  Function 0x%02x:\n", parent->type);
+	pr_debug("  Functional resource 0x%02x:\n", parent->type);
 	nubus_get_subdir(parent, &dir);
 
-	pr_debug("%s: parent is 0x%p, dir is 0x%p\n",
-	         __func__, parent->base, dir.base);
-
 	/* Actually we should probably panic if this fails */
 	if ((dev = kzalloc(sizeof(*dev), GFP_ATOMIC)) == NULL)
 		return NULL;
@@ -466,14 +463,14 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 			dev->type     = nbtdata[1];
 			dev->dr_sw    = nbtdata[2];
 			dev->dr_hw    = nbtdata[3];
-			pr_info("    type: [cat 0x%x type 0x%x sw 0x%x hw 0x%x]\n",
-			        nbtdata[0], nbtdata[1], nbtdata[2], nbtdata[3]);
+			pr_debug("    type: [cat 0x%x type 0x%x sw 0x%x hw 0x%x]\n",
+				nbtdata[0], nbtdata[1], nbtdata[2], nbtdata[3]);
 			break;
 		}
 		case NUBUS_RESID_NAME:
 		{
 			nubus_get_rsrc_str(dev->name, &ent, sizeof(dev->name));
-			pr_info("    name: %s\n", dev->name);
+			pr_debug("    name: %s\n", dev->name);
 			break;
 		}
 		case NUBUS_RESID_DRVRDIR:
@@ -486,7 +483,7 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 			nubus_get_subdir(&ent, &drvr_dir);
 			nubus_readdir(&drvr_dir, &drvr_ent);
 			dev->driver = nubus_dirptr(&drvr_ent);
-			pr_info("    driver at: 0x%p\n", dev->driver);
+			pr_debug("    driver at: 0x%p\n", dev->driver);
 			break;
 		}
 		case NUBUS_RESID_MINOR_BASEOS:
@@ -494,20 +491,20 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 			   multiple framebuffers.  It might be handy
 			   for Ethernet as well */
 			nubus_get_rsrc_mem(&dev->iobase, &ent, 4);
-			pr_info("    memory offset: 0x%08lx\n", dev->iobase);
+			pr_debug("    memory offset: 0x%08lx\n", dev->iobase);
 			break;
 		case NUBUS_RESID_MINOR_LENGTH:
 			/* Ditto */
 			nubus_get_rsrc_mem(&dev->iosize, &ent, 4);
-			pr_info("    memory length: 0x%08lx\n", dev->iosize);
+			pr_debug("    memory length: 0x%08lx\n", dev->iosize);
 			break;
 		case NUBUS_RESID_FLAGS:
 			dev->flags = ent.data;
-			pr_info("    flags: 0x%06x\n", dev->flags);
+			pr_debug("    flags: 0x%06x\n", dev->flags);
 			break;
 		case NUBUS_RESID_HWDEVID:
 			dev->hwdevid = ent.data;
-			pr_info("    hwdevid: 0x%06x\n", dev->hwdevid);
+			pr_debug("    hwdevid: 0x%06x\n", dev->hwdevid);
 			break;
 		default:
 			/* Local/Private resources have their own
@@ -535,10 +532,8 @@ static int __init nubus_get_vidnames(struct nubus_board *board,
 		char name[36];
 	};
 
-	pr_info("    video modes supported:\n");
+	pr_debug("    video modes supported:\n");
 	nubus_get_subdir(parent, &dir);
-	pr_debug("%s: parent is 0x%p, dir is 0x%p\n",
-	         __func__, parent->base, dir.base);
 
 	while (nubus_readdir(&dir, &ent) != -1) {
 		struct vidmode mode;
@@ -552,7 +547,7 @@ static int __init nubus_get_vidnames(struct nubus_board *board,
 			size = sizeof(mode) - 1;
 		memset(&mode, 0, sizeof(mode));
 		nubus_get_rsrc_mem(&mode, &ent, size);
-		pr_info("      %02X: (%02X) %s\n", ent.type,
+		pr_debug("      0x%02x: 0x%04x %s\n", ent.type,
 			mode.id, mode.name);
 	}
 	return 0;
@@ -563,25 +558,16 @@ static int __init nubus_get_icon(struct nubus_board *board,
 				 const struct nubus_dirent *ent)
 {
 	/* Should be 32x32 if my memory serves me correctly */
-	unsigned char icon[128];
-	int x, y;
+	u32 icon[32];
+	int i;
 
 	nubus_get_rsrc_mem(&icon, ent, 128);
-	pr_info("    icon:\n");
-
-	/* We should actually plot these somewhere in the framebuffer
-	   init.  This is just to demonstrate that they do, in fact,
-	   exist */
-	for (y = 0; y < 32; y++) {
-		pr_info("      ");
-		for (x = 0; x < 32; x++) {
-			if (icon[y * 4 + x / 8] & (0x80 >> (x % 8)))
-				pr_cont("*");
-			else
-				pr_cont(" ");
-		}
-		pr_cont("\n");
-	}
+	pr_debug("    icon:\n");
+	for (i = 0; i < 8; i++)
+		pr_debug("        %08x %08x %08x %08x\n",
+			icon[i * 4 + 0], icon[i * 4 + 1],
+			icon[i * 4 + 2], icon[i * 4 + 3]);
+
 	return 0;
 }
 
@@ -593,10 +579,8 @@ static int __init nubus_get_vendorinfo(struct nubus_board *board,
 	static char *vendor_fields[6] = { "ID", "serial", "revision",
 	                                  "part", "date", "unknown field" };
 
-	pr_info("    vendor info:\n");
+	pr_debug("    vendor info:\n");
 	nubus_get_subdir(parent, &dir);
-	pr_debug("%s: parent is 0x%p, dir is 0x%p\n",
-	         __func__, parent->base, dir.base);
 
 	while (nubus_readdir(&dir, &ent) != -1) {
 		char name[64];
@@ -605,7 +589,7 @@ static int __init nubus_get_vendorinfo(struct nubus_board *board,
 		nubus_get_rsrc_str(name, &ent, sizeof(name));
 		if (ent.type < 1 || ent.type > 5)
 			ent.type = 5;
-		pr_info("    %s: %s\n", vendor_fields[ent.type - 1], name);
+		pr_debug("    %s: %s\n", vendor_fields[ent.type - 1], name);
 	}
 	return 0;
 }
@@ -616,9 +600,8 @@ static int __init nubus_get_board_resource(struct nubus_board *board, int slot,
 	struct nubus_dir dir;
 	struct nubus_dirent ent;
 
+	pr_debug("  Board resource 0x%02x:\n", parent->type);
 	nubus_get_subdir(parent, &dir);
-	pr_debug("%s: parent is 0x%p, dir is 0x%p\n",
-	         __func__, parent->base, dir.base);
 
 	while (nubus_readdir(&dir, &ent) != -1) {
 		switch (ent.type) {
@@ -629,8 +612,8 @@ static int __init nubus_get_board_resource(struct nubus_board *board, int slot,
 			   useful except insofar as it tells us that
 			   we really are looking at a board resource. */
 			nubus_get_rsrc_mem(nbtdata, &ent, 8);
-			pr_info("    type: [cat 0x%x type 0x%x sw 0x%x hw 0x%x]\n",
-			        nbtdata[0], nbtdata[1], nbtdata[2], nbtdata[3]);
+			pr_debug("    type: [cat 0x%x type 0x%x sw 0x%x hw 0x%x]\n",
+				nbtdata[0], nbtdata[1], nbtdata[2], nbtdata[3]);
 			if (nbtdata[0] != 1 || nbtdata[1] != 0 ||
 			    nbtdata[2] != 0 || nbtdata[3] != 0)
 				pr_err("this sResource is not a board resource!\n");
@@ -639,28 +622,29 @@ static int __init nubus_get_board_resource(struct nubus_board *board, int slot,
 		case NUBUS_RESID_NAME:
 			nubus_get_rsrc_str(board->name, &ent,
 					   sizeof(board->name));
-			pr_info("    name: %s\n", board->name);
+			pr_debug("    name: %s\n", board->name);
 			break;
 		case NUBUS_RESID_ICON:
 			nubus_get_icon(board, &ent);
 			break;
 		case NUBUS_RESID_BOARDID:
-			pr_info("    board id: 0x%x\n", ent.data);
+			pr_debug("    board id: 0x%x\n", ent.data);
 			break;
 		case NUBUS_RESID_PRIMARYINIT:
-			pr_info("    primary init offset: 0x%06x\n", ent.data);
+			pr_debug("    primary init offset: 0x%06x\n", ent.data);
 			break;
 		case NUBUS_RESID_VENDORINFO:
 			nubus_get_vendorinfo(board, &ent);
 			break;
 		case NUBUS_RESID_FLAGS:
-			pr_info("    flags: 0x%06x\n", ent.data);
+			pr_debug("    flags: 0x%06x\n", ent.data);
 			break;
 		case NUBUS_RESID_HWDEVID:
-			pr_info("    hwdevid: 0x%06x\n", ent.data);
+			pr_debug("    hwdevid: 0x%06x\n", ent.data);
 			break;
 		case NUBUS_RESID_SECONDINIT:
-			pr_info("    secondary init offset: 0x%06x\n", ent.data);
+			pr_debug("    secondary init offset: 0x%06x\n",
+				 ent.data);
 			break;
 			/* WTF isn't this in the functional resources? */
 		case NUBUS_RESID_VIDNAMES:
@@ -668,12 +652,12 @@ static int __init nubus_get_board_resource(struct nubus_board *board, int slot,
 			break;
 			/* Same goes for this */
 		case NUBUS_RESID_VIDMODES:
-			pr_info("    video mode parameter directory offset: 0x%06x\n",
-			       ent.data);
+			pr_debug("    video mode parameter directory offset: 0x%06x\n",
+				ent.data);
 			break;
 		default:
-			pr_info("    unknown resource %02X, data 0x%06x\n",
-			       ent.type, ent.data);
+			pr_debug("    unknown resource 0x%02x, data 0x%06x\n",
+				ent.type, ent.data);
 		}
 	}
 	return 0;
@@ -700,14 +684,14 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 
 	/* Dump the format block for debugging purposes */
 	pr_debug("Slot %X, format block at 0x%p:\n", slot, rp);
+	pr_debug("%08lx\n", nubus_get_rom(&rp, 4, bytelanes));
+	pr_debug("%08lx\n", nubus_get_rom(&rp, 4, bytelanes));
+	pr_debug("%08lx\n", nubus_get_rom(&rp, 4, bytelanes));
 	pr_debug("%02lx\n", nubus_get_rom(&rp, 1, bytelanes));
 	pr_debug("%02lx\n", nubus_get_rom(&rp, 1, bytelanes));
 	pr_debug("%08lx\n", nubus_get_rom(&rp, 4, bytelanes));
 	pr_debug("%02lx\n", nubus_get_rom(&rp, 1, bytelanes));
 	pr_debug("%02lx\n", nubus_get_rom(&rp, 1, bytelanes));
-	pr_debug("%08lx\n", nubus_get_rom(&rp, 4, bytelanes));
-	pr_debug("%08lx\n", nubus_get_rom(&rp, 4, bytelanes));
-	pr_debug("%08lx\n", nubus_get_rom(&rp, 4, bytelanes));
 	rp = board->fblock;
 
 	board->slot = slot;
@@ -747,7 +731,7 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 	nubus_get_root_dir(board, &dir);
 
 	/* We're ready to rock */
-	pr_info("Slot %X:\n", slot);
+	pr_debug("Slot %X resources:\n", slot);
 
 	/* Each slot should have one board resource and any number of
 	   functional resources.  So we'll fill in some fields in the
@@ -759,7 +743,6 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 		pr_err("Board resource not found!\n");
 		return NULL;
 	} else {
-		pr_info("  Board resource:\n");
 		nubus_get_board_resource(board, slot, &ent);
 	}
 
@@ -831,6 +814,7 @@ static void __init nubus_scan_bus(void)
 {
 	int slot;
 
+	pr_info("NuBus: Scanning NuBus slots.\n");
 	for (slot = 9; slot < 15; slot++) {
 		nubus_probe_slot(slot);
 	}
@@ -841,7 +825,6 @@ static int __init nubus_init(void)
 	if (!MACH_IS_MAC)
 		return 0;
 
-	pr_info("NuBus: Scanning NuBus slots.\n");
 	nubus_devices = NULL;
 	nubus_boards = NULL;
 	nubus_scan_bus();

commit 460cf95e8b6cda2823a6432253ae91d3e1e7a021
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Use static functions where possible
    
    This fixes a couple of warnings from 'make W=1':
    drivers/nubus/nubus.c:790: warning: no previous prototype for 'nubus_probe_slot'
    drivers/nubus/nubus.c:824: warning: no previous prototype for 'nubus_scan_bus'
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index b6c97e07f15e..35056cee94b1 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -793,7 +793,7 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 	return board;
 }
 
-void __init nubus_probe_slot(int slot)
+static void __init nubus_probe_slot(int slot)
 {
 	unsigned char dp;
 	unsigned char *rp;
@@ -827,7 +827,7 @@ void __init nubus_probe_slot(int slot)
 	}
 }
 
-void __init nubus_scan_bus(void)
+static void __init nubus_scan_bus(void)
 {
 	int slot;
 

commit 2f828fb21df42058084b16d5e07cecdc30dbc3a5
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Avoid array underflow and overflow
    
    Check array indices. Avoid sprintf. Use buffers of sufficient size.
    Use appropriate types for array length parameters.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index b793727cd4f7..b6c97e07f15e 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -161,7 +161,7 @@ static unsigned char *nubus_dirptr(const struct nubus_dirent *nd)
    pointed to with offsets) out of the card ROM. */
 
 void nubus_get_rsrc_mem(void *dest, const struct nubus_dirent *dirent,
-			int len)
+			unsigned int len)
 {
 	unsigned char *t = (unsigned char *)dest;
 	unsigned char *p = nubus_dirptr(dirent);
@@ -173,18 +173,22 @@ void nubus_get_rsrc_mem(void *dest, const struct nubus_dirent *dirent,
 }
 EXPORT_SYMBOL(nubus_get_rsrc_mem);
 
-void nubus_get_rsrc_str(void *dest, const struct nubus_dirent *dirent,
-			int len)
+void nubus_get_rsrc_str(char *dest, const struct nubus_dirent *dirent,
+			unsigned int len)
 {
-	unsigned char *t = (unsigned char *)dest;
+	char *t = dest;
 	unsigned char *p = nubus_dirptr(dirent);
 
-	while (len) {
-		*t = nubus_get_rom(&p, 1, dirent->mask);
-		if (!*t++)
+	while (len > 1) {
+		unsigned char c = nubus_get_rom(&p, 1, dirent->mask);
+
+		if (!c)
 			break;
+		*t++ = c;
 		len--;
 	}
+	if (len > 0)
+		*t = '\0';
 }
 EXPORT_SYMBOL(nubus_get_rsrc_str);
 
@@ -468,7 +472,7 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 		}
 		case NUBUS_RESID_NAME:
 		{
-			nubus_get_rsrc_str(dev->name, &ent, 64);
+			nubus_get_rsrc_str(dev->name, &ent, sizeof(dev->name));
 			pr_info("    name: %s\n", dev->name);
 			break;
 		}
@@ -528,7 +532,7 @@ static int __init nubus_get_vidnames(struct nubus_board *board,
 		/* Don't know what this is yet */
 		u16 id;
 		/* Longest one I've seen so far is 26 characters */
-		char name[32];
+		char name[36];
 	};
 
 	pr_info("    video modes supported:\n");
@@ -598,8 +602,8 @@ static int __init nubus_get_vendorinfo(struct nubus_board *board,
 		char name[64];
 
 		/* These are all strings, we think */
-		nubus_get_rsrc_str(name, &ent, 64);
-		if (ent.type > 5)
+		nubus_get_rsrc_str(name, &ent, sizeof(name));
+		if (ent.type < 1 || ent.type > 5)
 			ent.type = 5;
 		pr_info("    %s: %s\n", vendor_fields[ent.type - 1], name);
 	}
@@ -633,7 +637,8 @@ static int __init nubus_get_board_resource(struct nubus_board *board, int slot,
 			break;
 		}
 		case NUBUS_RESID_NAME:
-			nubus_get_rsrc_str(board->name, &ent, 64);
+			nubus_get_rsrc_str(board->name, &ent,
+					   sizeof(board->name));
 			pr_info("    name: %s\n", board->name);
 			break;
 		case NUBUS_RESID_ICON:

commit 9e09d05cfe7df9efa7bbca7d679af534a616026e
Merge: d60a540ac5f2 5e387199c17c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 12:10:24 2017 -0800

    Merge tag 'm68k-for-v4.15-tag1' of git://git.kernel.org/pub/scm/linux/kernel/git/geert/linux-m68k
    
    Pull m68k updates from Geert Uytterhoeven:
    
      - more printk modernization
    
      - various cleanups and fixes (incl. a race condition) for Mac
    
      - defconfig updates
    
    * tag 'm68k-for-v4.15-tag1' of git://git.kernel.org/pub/scm/linux/kernel/git/geert/linux-m68k:
      m68k/defconfig: Update defconfigs for v4.14-rc7
      m68k/mac: Add mutual exclusion for IOP interrupt polling
      m68k/mac: Disentangle VIA/RBV and NuBus initialization
      m68k/mac: Disentangle VIA and OSS initialization
      m68k/mac: More printk modernization

commit 8ee90c5c3fd1af8e68133defb15cfc66c1de3f88
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Thu Oct 26 22:45:24 2017 -0400

    m68k/mac: Disentangle VIA/RBV and NuBus initialization
    
    The Nubus subsystem should not be concerned with differences between VIA,
    RBV and OSS platforms. It should be portable across Macs and PowerMacs.
    This goal has implications for the initialization code relating to bus
    locking and slot interrupts.
    
    During Nubus initialization, bus transactions are "unlocked": on VIA2 and
    RBV machines, via_nubus_init() sets a bit in the via2[gBufB] register to
    allow bus-mastering Nubus cards to arbitrate for the bus. This happens
    upon subsys_initcall(nubus_init). But because nubus_init() has no effect
    on card state, this sequence is arbitrary.
    
    Moreover, when Penguin is used to boot Linux, the bus is already unlocked
    when Linux starts. On OSS machines there's no attempt to unlock Nubus
    transactions at all. (Maybe there's no benefit on that platform or maybe
    no-one knows how.)
    
    All of this demonstrates that there's no benefit in locking out
    bus-mastering cards, as yet. (If the need arises, we could lock the bus
    for the duration of a timing-critical operation.) NetBSD unlocks the
    Nubus early (at VIA initialization) and we can do the same.
    
    via_nubus_init() is also responsible for some VIA interrupt setup that
    should happen earlier than subsys_initcall(nubus_init). And actually, the
    Nubus subsystem need not be involved with slot interrupts: SLOT2IRQ
    works fine because Nubus slot IRQs are geographically assigned
    (regardless of platform).
    
    For certain platforms with PDS slots, some Nubus IRQs may be platform
    IRQs and this is not something that the NuBus subsystem should worry
    about. So let's invoke via_nubus_init() earlier and make the platform
    responsible for bus unlocking and interrupt setup instead of the NuBus
    subsystem.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index df431e8a0631..4f50f30650cd 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -18,11 +18,6 @@
 #include <asm/setup.h>
 #include <asm/page.h>
 #include <asm/hwtest.h>
-#include <asm/mac_via.h>
-#include <asm/mac_oss.h>
-
-extern void via_nubus_init(void);
-extern void oss_nubus_init(void);
 
 /* Constants */
 
@@ -840,14 +835,6 @@ static int __init nubus_init(void)
 	if (!MACH_IS_MAC)
 		return 0;
 
-	/* Initialize the NuBus interrupts */
-	if (oss_present) {
-		oss_nubus_init();
-	} else {
-		via_nubus_init();
-	}
-
-	/* And probe */
 	pr_info("NuBus: Scanning NuBus slots.\n");
 	nubus_devices = NULL;
 	nubus_boards = NULL;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index df431e8a0631..8ce69c833362 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *	Macintosh Nubus Interface Code
  *

commit 85cc313aeb9e2334d9d861d30024a16268b88747
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Apr 22 21:24:16 2017 -0400

    nubus: Fix pointer validation
    
    Fix bounds checking on slot-space pointer movement.
    Remove redundant test for zero byte-lanes value.
    Fix broken byte-lanes vs. address validation.
    
    This patch changes the circumstances under which an error is printed to
    the console and fixes the address validation.
    
    The validation code should work correctly now: the broken test for a
    valid bytelanes value is replaced with a working test (which eliminates
    false negatives) and the 24-bit directory offset bounds check is fixed
    (which eliminates false positives).
    
    Please see "Designing Cards and Drivers for the Macintosh Family"
    ch. 8, "NuBus Card Firmware" for an explanation of the bytelanes check
    and directory offset value.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index f879a0f78b14..df431e8a0631 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -92,9 +92,6 @@ static void nubus_rewind(unsigned char **ptr, int len, int map)
 {
 	unsigned char *p = *ptr;
 
-	/* Sanity check */
-	if (len > 65536)
-		pr_err("rewind of 0x%08x!\n", len);
 	while (len) {
 		do {
 			p--;
@@ -108,8 +105,6 @@ static void nubus_advance(unsigned char **ptr, int len, int map)
 {
 	unsigned char *p = *ptr;
 
-	if (len > 65536)
-		pr_err("advance of 0x%08x!\n", len);
 	while (len) {
 		while (not_useful(p, map))
 			p++;
@@ -121,10 +116,15 @@ static void nubus_advance(unsigned char **ptr, int len, int map)
 
 static void nubus_move(unsigned char **ptr, int len, int map)
 {
+	unsigned long slot_space = (unsigned long)*ptr & 0xFF000000;
+
 	if (len > 0)
 		nubus_advance(ptr, len, map);
 	else if (len < 0)
 		nubus_rewind(ptr, -len, map);
+
+	if (((unsigned long)*ptr & 0xFF000000) != slot_space)
+		pr_err("%s: moved out of slot address space!\n", __func__);
 }
 
 /* Now, functions to read the sResource tree */
@@ -808,8 +808,6 @@ void __init nubus_probe_slot(int slot)
 			continue;
 
 		dp = *rp;
-		if(dp == 0)
-			continue;
 
 		/* The last byte of the format block consists of two
 		   nybbles which are "mirror images" of each other.
@@ -818,7 +816,7 @@ void __init nubus_probe_slot(int slot)
 			continue;
 		/* Check that this value is actually *on* one of the
 		   bytelanes it claims are valid! */
-		if ((dp & 0x0F) >= (1 << i))
+		if (not_useful(rp, dp))
 			continue;
 
 		/* Looks promising.  Let's put it on the list. */

commit 475e6e152a229b6b006d8547476b9f032332870f
Author: David Huggins-Daines <dhd@debian.org>
Date:   Sat Apr 22 21:24:16 2017 -0400

    nubus: Remove slot zero probe
    
    Some long forgotten changes from the linux-mac68k CVS:
    
    Remove the slot 0 (ROM) probing.
    Remove the pointless White Screen Of Death crap.
    
    The original commit is here:
    
    http://linux-mac68k.cvs.sourceforge.net/viewvc/linux-mac68k/linux-mac68k/drivers/nubus/nubus.c?r1=1.22.2.1&r2=1.22.2.2&pathrev=linux-2_2
    
    This is mostly dead code removal. It is also a reversion to the
    pre-v2.3.17 version. The old code was thoroughly tested in Debian Sarge.
    
    The present code for probing fake slot resources in Apple's on-board
    (slot zero) ROMs could be useful if replaced the macintosh_config struct.
    But it can't do so and we don't want two mechanisms for identifying
    on-board hardware.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index 77a48a5164ff..f879a0f78b14 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -13,7 +13,6 @@
 #include <linux/nubus.h>
 #include <linux/errno.h>
 #include <linux/init.h>
-#include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <asm/setup.h>
@@ -34,14 +33,6 @@ extern void oss_nubus_init(void);
 
 #define NUBUS_TEST_PATTERN 0x5A932BC7
 
-/* Define this if you like to live dangerously - it is known not to
-   work on pretty much every machine except the Quadra 630 and the LC
-   III. */
-#undef I_WANT_TO_PROBE_SLOT_ZERO
-
-/* This sometimes helps combat failure to boot */
-#undef TRY_TO_DODGE_WSOD
-
 /* Globals */
 
 struct nubus_dev *nubus_devices;
@@ -454,10 +445,6 @@ nubus_get_functional_resource(struct nubus_board *board, int slot,
 	pr_info("  Function 0x%02x:\n", parent->type);
 	nubus_get_subdir(parent, &dir);
 
-	/* Apple seems to have botched the ROM on the IIx */
-	if (slot == 0 && (unsigned long)dir.base % 2)
-		dir.base += 1;
-
 	pr_debug("%s: parent is 0x%p, dir is 0x%p\n",
 	         __func__, parent->base, dir.base);
 
@@ -691,83 +678,6 @@ static int __init nubus_get_board_resource(struct nubus_board *board, int slot,
 	return 0;
 }
 
-/* Attempt to bypass the somewhat non-obvious arrangement of
-   sResources in the motherboard ROM */
-static void __init nubus_find_rom_dir(struct nubus_board* board)
-{
-	unsigned char *rp;
-	unsigned char *romdir;
-	struct nubus_dir dir;
-	struct nubus_dirent ent;
-
-	/* Check for the extra directory just under the format block */
-	rp = board->fblock;
-	nubus_rewind(&rp, 4, board->lanes);
-	if (nubus_get_rom(&rp, 4, board->lanes) != NUBUS_TEST_PATTERN) {
-		/* OK, the ROM was telling the truth */
-		board->directory = board->fblock;
-		nubus_move(&board->directory,
-			   nubus_expand32(board->doffset),
-			   board->lanes);
-		return;
-	}
-
-	/* On "slot zero", you have to walk down a few more
-	   directories to get to the equivalent of a real card's root
-	   directory.  We don't know what they were smoking when they
-	   came up with this. */
-	romdir = nubus_rom_addr(board->slot);
-	nubus_rewind(&romdir, ROM_DIR_OFFSET, board->lanes);
-	dir.base = dir.ptr = romdir;
-	dir.done = 0;
-	dir.mask = board->lanes;
-
-	/* This one points to an "Unknown Macintosh" directory */
-	if (nubus_readdir(&dir, &ent) == -1)
-		goto badrom;
-
-	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
-		printk(KERN_INFO "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);
-	/* This one takes us to where we want to go. */
-	if (nubus_readdir(&dir, &ent) == -1)
-		goto badrom;
-	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
-		printk(KERN_DEBUG "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);
-	nubus_get_subdir(&ent, &dir);
-
-	/* Resource ID 01, also an "Unknown Macintosh" */
-	if (nubus_readdir(&dir, &ent) == -1)
-		goto badrom;
-	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
-		printk(KERN_DEBUG "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);
-
-	/* FIXME: the first one is *not* always the right one.  We
-	   suspect this has something to do with the ROM revision.
-	   "The HORROR ROM" (LC-series) uses 0x7e, while "The HORROR
-	   Continues" (Q630) uses 0x7b.  The DAFB Macs evidently use
-	   something else.  Please run "Slots" on your Mac (see
-	   include/linux/nubus.h for where to get this program) and
-	   tell us where the 'SiDirPtr' for Slot 0 is.  If you feel
-	   brave, you should also use MacsBug to walk down the ROM
-	   directories like this function does and try to find the
-	   path to that address... */
-	if (nubus_readdir(&dir, &ent) == -1)
-		goto badrom;
-	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
-		printk(KERN_DEBUG "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);
-
-	/* Bwahahahaha... */
-	nubus_get_subdir(&ent, &dir);
-	board->directory = dir.base;
-	return;
-
-	/* Even more evil laughter... */
- badrom:
-	board->directory = board->fblock;
-	nubus_move(&board->directory, nubus_expand32(board->doffset), board->lanes);
-	printk(KERN_ERR "nubus_get_rom_dir: ROM weirdness!  Notify the developers...\n");
-}
-
 /* Add a board (might be many devices) to the list */
 static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 {
@@ -828,8 +738,11 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 	 * since the initial Macintosh ROM releases skipped the check.
 	 */
 
-	/* Attempt to work around slot zero weirdness */
-	nubus_find_rom_dir(board);
+	/* Set up the directory pointer */
+	board->directory = board->fblock;
+	nubus_move(&board->directory, nubus_expand32(board->doffset),
+	           board->lanes);
+
 	nubus_get_root_dir(board, &dir);
 
 	/* We're ready to rock */
@@ -849,9 +762,6 @@ static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 		nubus_get_board_resource(board, slot, &ent);
 	}
 
-	/* Aaaarrrrgghh!  The LC III motherboard has *two* board
-	   resources.  I have no idea WTF to do about this. */
-
 	while (nubus_readdir(&dir, &ent) != -1) {
 		struct nubus_dev *dev;
 		struct nubus_dev **devp;
@@ -922,10 +832,6 @@ void __init nubus_scan_bus(void)
 {
 	int slot;
 
-	/* This might not work on your machine */
-#ifdef I_WANT_TO_PROBE_SLOT_ZERO
-	nubus_probe_slot(0);
-#endif
 	for (slot = 9; slot < 15; slot++) {
 		nubus_probe_slot(slot);
 	}
@@ -943,13 +849,6 @@ static int __init nubus_init(void)
 		via_nubus_init();
 	}
 
-#ifdef TRY_TO_DODGE_WSOD
-	/* Rogue Ethernet interrupts can kill the machine if we don't
-	   do this.  Obviously this is bogus.  Hopefully the local VIA
-	   gurus can fix the real cause of the problem. */
-	mdelay(1000);
-#endif
-
 	/* And probe */
 	pr_info("NuBus: Scanning NuBus slots.\n");
 	nubus_devices = NULL;

commit f42e5550967a3e1e39dc0b1c4e2e7d903e764d5d
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Apr 8 19:51:15 2017 -0400

    nubus: Clean up whitespace
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    [geert: rebased]
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index 56de633f19b9..77a48a5164ff 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -44,8 +44,8 @@ extern void oss_nubus_init(void);
 
 /* Globals */
 
-struct nubus_dev*   nubus_devices;
-struct nubus_board* nubus_boards;
+struct nubus_dev *nubus_devices;
+struct nubus_board *nubus_boards;
 
 /* Meaning of "bytelanes":
 
@@ -69,26 +69,26 @@ struct nubus_board* nubus_boards;
 
    Etcetera, etcetera.  Hopefully this clears up some confusion over
    what the following code actually does.  */
- 
+
 static inline int not_useful(void *p, int map)
 {
-	unsigned long pv=(unsigned long)p;
+	unsigned long pv = (unsigned long)p;
+
 	pv &= 3;
-	if(map & (1<<pv))
+	if (map & (1 << pv))
 		return 0;
 	return 1;
 }
- 
+
 static unsigned long nubus_get_rom(unsigned char **ptr, int len, int map)
 {
 	/* This will hold the result */
 	unsigned long v = 0;
 	unsigned char *p = *ptr;
 
-	while(len)
-	{
+	while (len) {
 		v <<= 8;
-		while(not_useful(p,map))
+		while (not_useful(p, map))
 			p++;
 		v |= *p++;
 		len--;
@@ -99,31 +99,28 @@ static unsigned long nubus_get_rom(unsigned char **ptr, int len, int map)
 
 static void nubus_rewind(unsigned char **ptr, int len, int map)
 {
-	unsigned char *p=*ptr;
+	unsigned char *p = *ptr;
 
 	/* Sanity check */
-	if(len > 65536)
+	if (len > 65536)
 		pr_err("rewind of 0x%08x!\n", len);
-	while(len)
-	{
-		do
-		{
+	while (len) {
+		do {
 			p--;
-		}
-		while(not_useful(p, map));
+		} while (not_useful(p, map));
 		len--;
 	}
-	*ptr=p;
+	*ptr = p;
 }
 
 static void nubus_advance(unsigned char **ptr, int len, int map)
 {
 	unsigned char *p = *ptr;
-	if(len>65536)
+
+	if (len > 65536)
 		pr_err("advance of 0x%08x!\n", len);
-	while(len)
-	{
-		while(not_useful(p,map))
+	while (len) {
+		while (not_useful(p, map))
 			p++;
 		p++;
 		len--;
@@ -133,9 +130,9 @@ static void nubus_advance(unsigned char **ptr, int len, int map)
 
 static void nubus_move(unsigned char **ptr, int len, int map)
 {
-	if(len > 0)
+	if (len > 0)
 		nubus_advance(ptr, len, map);
-	else if(len < 0)
+	else if (len < 0)
 		nubus_rewind(ptr, -len, map);
 }
 
@@ -148,23 +145,24 @@ static void nubus_move(unsigned char **ptr, int len, int map)
 
 static inline long nubus_expand32(long foo)
 {
-	if(foo & 0x00800000)	/* 24bit negative */
+	if (foo & 0x00800000)	/* 24bit negative */
 		foo |= 0xFF000000;
 	return foo;
 }
 
 static inline void *nubus_rom_addr(int slot)
-{	
+{
 	/*
 	 *	Returns the first byte after the card. We then walk
 	 *	backwards to get the lane register and the config
 	 */
-	return (void *)(0xF1000000+(slot<<24));
+	return (void *)(0xF1000000 + (slot << 24));
 }
 
 static unsigned char *nubus_dirptr(const struct nubus_dirent *nd)
 {
 	unsigned char *p = nd->base;
+
 	/* Essentially, just step over the bytelanes using whatever
 	   offset we might have found */
 	nubus_move(&p, nubus_expand32(nd->data), nd->mask);
@@ -175,36 +173,36 @@ static unsigned char *nubus_dirptr(const struct nubus_dirent *nd)
 /* These two are for pulling resource data blocks (i.e. stuff that's
    pointed to with offsets) out of the card ROM. */
 
-void nubus_get_rsrc_mem(void *dest, const struct nubus_dirent* dirent,
+void nubus_get_rsrc_mem(void *dest, const struct nubus_dirent *dirent,
 			int len)
 {
 	unsigned char *t = (unsigned char *)dest;
 	unsigned char *p = nubus_dirptr(dirent);
-	while(len)
-	{
+
+	while (len) {
 		*t++ = nubus_get_rom(&p, 1, dirent->mask);
 		len--;
 	}
 }
 EXPORT_SYMBOL(nubus_get_rsrc_mem);
 
-void nubus_get_rsrc_str(void *dest, const struct nubus_dirent* dirent,
+void nubus_get_rsrc_str(void *dest, const struct nubus_dirent *dirent,
 			int len)
 {
-	unsigned char *t=(unsigned char *)dest;
+	unsigned char *t = (unsigned char *)dest;
 	unsigned char *p = nubus_dirptr(dirent);
-	while(len)
-	{
+
+	while (len) {
 		*t = nubus_get_rom(&p, 1, dirent->mask);
-		if(!*t++)
+		if (!*t++)
 			break;
 		len--;
 	}
 }
 EXPORT_SYMBOL(nubus_get_rsrc_str);
 
-int nubus_get_root_dir(const struct nubus_board* board,
-		       struct nubus_dir* dir)
+int nubus_get_root_dir(const struct nubus_board *board,
+		       struct nubus_dir *dir)
 {
 	dir->ptr = dir->base = board->directory;
 	dir->done = 0;
@@ -214,8 +212,8 @@ int nubus_get_root_dir(const struct nubus_board* board,
 EXPORT_SYMBOL(nubus_get_root_dir);
 
 /* This is a slyly renamed version of the above */
-int nubus_get_func_dir(const struct nubus_dev* dev,
-		       struct nubus_dir* dir)
+int nubus_get_func_dir(const struct nubus_dev *dev,
+		       struct nubus_dir *dir)
 {
 	dir->ptr = dir->base = dev->directory;
 	dir->done = 0;
@@ -224,11 +222,11 @@ int nubus_get_func_dir(const struct nubus_dev* dev,
 }
 EXPORT_SYMBOL(nubus_get_func_dir);
 
-int nubus_get_board_dir(const struct nubus_board* board,
-			struct nubus_dir* dir)
+int nubus_get_board_dir(const struct nubus_board *board,
+			struct nubus_dir *dir)
 {
 	struct nubus_dirent ent;
-	
+
 	dir->ptr = dir->base = board->directory;
 	dir->done = 0;
 	dir->mask = board->lanes;
@@ -256,6 +254,7 @@ EXPORT_SYMBOL(nubus_get_subdir);
 int nubus_readdir(struct nubus_dir *nd, struct nubus_dirent *ent)
 {
 	u32 resid;
+
 	if (nd->done)
 		return -1;
 
@@ -266,27 +265,25 @@ int nubus_readdir(struct nubus_dir *nd, struct nubus_dirent *ent)
 	resid = nubus_get_rom(&nd->ptr, 4, nd->mask);
 
 	/* EOL marker, as per the Apple docs */
-	if((resid&0xff000000) == 0xff000000)
-	{
+	if ((resid & 0xff000000) == 0xff000000) {
 		/* Mark it as done */
 		nd->done = 1;
 		return -1;
 	}
 
 	/* First byte is the resource ID */
-	ent->type  = resid >> 24;
+	ent->type = resid >> 24;
 	/* Low 3 bytes might contain data (or might not) */
 	ent->data = resid & 0xffffff;
-	ent->mask  = nd->mask;
+	ent->mask = nd->mask;
 	return 0;
 }
 EXPORT_SYMBOL(nubus_readdir);
 
-int nubus_rewinddir(struct nubus_dir* dir)
+int nubus_rewinddir(struct nubus_dir *dir)
 {
 	dir->ptr = dir->base;
 	dir->done = 0;
-
 	return 0;
 }
 EXPORT_SYMBOL(nubus_rewinddir);
@@ -294,20 +291,15 @@ EXPORT_SYMBOL(nubus_rewinddir);
 /* Driver interface functions, more or less like in pci.c */
 
 struct nubus_dev*
-nubus_find_device(unsigned short category,
-		  unsigned short type,
-		  unsigned short dr_hw,
-		  unsigned short dr_sw,
-		  const struct nubus_dev* from)
+nubus_find_device(unsigned short category, unsigned short type,
+		  unsigned short dr_hw, unsigned short dr_sw,
+		  const struct nubus_dev *from)
 {
-	struct nubus_dev* itor =
-		from ? from->next : nubus_devices;
+	struct nubus_dev *itor = from ? from->next : nubus_devices;
 
 	while (itor) {
-		if (itor->category == category
-		    && itor->type == type
-		    && itor->dr_hw == dr_hw
-		    && itor->dr_sw == dr_sw)
+		if (itor->category == category && itor->type == type &&
+		    itor->dr_hw == dr_hw && itor->dr_sw == dr_sw)
 			return itor;
 		itor = itor->next;
 	}
@@ -316,16 +308,13 @@ nubus_find_device(unsigned short category,
 EXPORT_SYMBOL(nubus_find_device);
 
 struct nubus_dev*
-nubus_find_type(unsigned short category,
-		unsigned short type,
-		const struct nubus_dev* from)
+nubus_find_type(unsigned short category, unsigned short type,
+		const struct nubus_dev *from)
 {
-	struct nubus_dev* itor =
-		from ? from->next : nubus_devices;
+	struct nubus_dev *itor = from ? from->next : nubus_devices;
 
 	while (itor) {
-		if (itor->category == category
-		    && itor->type == type)
+		if (itor->category == category && itor->type == type)
 			return itor;
 		itor = itor->next;
 	}
@@ -334,12 +323,10 @@ nubus_find_type(unsigned short category,
 EXPORT_SYMBOL(nubus_find_type);
 
 struct nubus_dev*
-nubus_find_slot(unsigned int slot,
-		const struct nubus_dev* from)
+nubus_find_slot(unsigned int slot, const struct nubus_dev *from)
 {
-	struct nubus_dev* itor =
-		from ? from->next : nubus_devices;
-	
+	struct nubus_dev *itor = from ? from->next : nubus_devices;
+
 	while (itor) {
 		if (itor->board->slot == slot)
 			return itor;
@@ -350,13 +337,13 @@ nubus_find_slot(unsigned int slot,
 EXPORT_SYMBOL(nubus_find_slot);
 
 int
-nubus_find_rsrc(struct nubus_dir* dir, unsigned char rsrc_type,
-		struct nubus_dirent* ent)
+nubus_find_rsrc(struct nubus_dir *dir, unsigned char rsrc_type,
+		struct nubus_dirent *ent)
 {
 	while (nubus_readdir(dir, ent) != -1) {
 		if (ent->type == rsrc_type)
 			return 0;
-	}	
+	}
 	return -1;
 }
 EXPORT_SYMBOL(nubus_find_rsrc);
@@ -370,8 +357,8 @@ EXPORT_SYMBOL(nubus_find_rsrc);
    among other things.  The rest of it should go in the /proc code.
    For now, we just use it to give verbose boot logs. */
 
-static int __init nubus_show_display_resource(struct nubus_dev* dev,
-					      const struct nubus_dirent* ent)
+static int __init nubus_show_display_resource(struct nubus_dev *dev,
+					      const struct nubus_dirent *ent)
 {
 	switch (ent->type) {
 	case NUBUS_RESID_GAMMADIR:
@@ -388,14 +375,14 @@ static int __init nubus_show_display_resource(struct nubus_dev* dev,
 	return 0;
 }
 
-static int __init nubus_show_network_resource(struct nubus_dev* dev,
-					      const struct nubus_dirent* ent)
+static int __init nubus_show_network_resource(struct nubus_dev *dev,
+					      const struct nubus_dirent *ent)
 {
 	switch (ent->type) {
 	case NUBUS_RESID_MAC_ADDRESS:
 	{
 		char addr[6];
-		
+
 		nubus_get_rsrc_mem(addr, ent, 6);
 		pr_info("    MAC address: %pM\n", addr);
 		break;
@@ -407,13 +394,14 @@ static int __init nubus_show_network_resource(struct nubus_dev* dev,
 	return 0;
 }
 
-static int __init nubus_show_cpu_resource(struct nubus_dev* dev,
-					  const struct nubus_dirent* ent)
+static int __init nubus_show_cpu_resource(struct nubus_dev *dev,
+					  const struct nubus_dirent *ent)
 {
 	switch (ent->type) {
 	case NUBUS_RESID_MEMINFO:
 	{
 		unsigned long meminfo[2];
+
 		nubus_get_rsrc_mem(&meminfo, ent, 8);
 		pr_info("    memory: [ 0x%08lx 0x%08lx ]\n",
 		       meminfo[0], meminfo[1]);
@@ -422,6 +410,7 @@ static int __init nubus_show_cpu_resource(struct nubus_dev* dev,
 	case NUBUS_RESID_ROMINFO:
 	{
 		unsigned long rominfo[2];
+
 		nubus_get_rsrc_mem(&rominfo, ent, 8);
 		pr_info("    ROM:    [ 0x%08lx 0x%08lx ]\n",
 		       rominfo[0], rominfo[1]);
@@ -434,8 +423,8 @@ static int __init nubus_show_cpu_resource(struct nubus_dev* dev,
 	return 0;
 }
 
-static int __init nubus_show_private_resource(struct nubus_dev* dev,
-					      const struct nubus_dirent* ent)
+static int __init nubus_show_private_resource(struct nubus_dev *dev,
+					      const struct nubus_dirent *ent)
 {
 	switch (dev->category) {
 	case NUBUS_CAT_DISPLAY:
@@ -454,39 +443,37 @@ static int __init nubus_show_private_resource(struct nubus_dev* dev,
 	return 0;
 }
 
-static struct nubus_dev* __init
-	   nubus_get_functional_resource(struct nubus_board* board,
-					 int slot,
-					 const struct nubus_dirent* parent)
+static struct nubus_dev * __init
+nubus_get_functional_resource(struct nubus_board *board, int slot,
+			      const struct nubus_dirent *parent)
 {
-	struct nubus_dir    dir;
+	struct nubus_dir dir;
 	struct nubus_dirent ent;
-	struct nubus_dev*   dev;
-	
+	struct nubus_dev *dev;
+
 	pr_info("  Function 0x%02x:\n", parent->type);
 	nubus_get_subdir(parent, &dir);
 
 	/* Apple seems to have botched the ROM on the IIx */
 	if (slot == 0 && (unsigned long)dir.base % 2)
 		dir.base += 1;
-	
+
 	pr_debug("%s: parent is 0x%p, dir is 0x%p\n",
 	         __func__, parent->base, dir.base);
 
 	/* Actually we should probably panic if this fails */
 	if ((dev = kzalloc(sizeof(*dev), GFP_ATOMIC)) == NULL)
-		return NULL;	
+		return NULL;
 	dev->resid = parent->type;
 	dev->directory = dir.base;
 	dev->board = board;
-	
-	while (nubus_readdir(&dir, &ent) != -1)
-	{
-		switch(ent.type)
-		{
+
+	while (nubus_readdir(&dir, &ent) != -1) {
+		switch (ent.type) {
 		case NUBUS_RESID_TYPE:
 		{
 			unsigned short nbtdata[4];
+
 			nubus_get_rsrc_mem(nbtdata, &ent, 8);
 			dev->category = nbtdata[0];
 			dev->type     = nbtdata[1];
@@ -508,6 +495,7 @@ static struct nubus_dev* __init
 			   use this :-) */
 			struct nubus_dir drvr_dir;
 			struct nubus_dirent drvr_ent;
+
 			nubus_get_subdir(&ent, &drvr_dir);
 			nubus_readdir(&drvr_dir, &drvr_ent);
 			dev->driver = nubus_dirptr(&drvr_ent);
@@ -525,7 +513,7 @@ static struct nubus_dev* __init
 			/* Ditto */
 			nubus_get_rsrc_mem(&dev->iosize, &ent, 4);
 			pr_info("    memory length: 0x%08lx\n", dev->iosize);
-			break;			
+			break;
 		case NUBUS_RESID_FLAGS:
 			dev->flags = ent.data;
 			pr_info("    flags: 0x%06x\n", dev->flags);
@@ -540,16 +528,17 @@ static struct nubus_dev* __init
 			nubus_show_private_resource(dev, &ent);
 		}
 	}
-		
+
 	return dev;
 }
 
 /* This is cool. */
-static int __init nubus_get_vidnames(struct nubus_board* board,
-				     const struct nubus_dirent* parent)
+static int __init nubus_get_vidnames(struct nubus_board *board,
+				     const struct nubus_dirent *parent)
 {
-	struct nubus_dir    dir;
+	struct nubus_dir dir;
 	struct nubus_dirent ent;
+
 	/* FIXME: obviously we want to put this in a header file soon */
 	struct vidmode {
 		u32 size;
@@ -564,14 +553,13 @@ static int __init nubus_get_vidnames(struct nubus_board* board,
 	pr_debug("%s: parent is 0x%p, dir is 0x%p\n",
 	         __func__, parent->base, dir.base);
 
-	while(nubus_readdir(&dir, &ent) != -1)
-	{
+	while (nubus_readdir(&dir, &ent) != -1) {
 		struct vidmode mode;
 		u32 size;
 
 		/* First get the length */
 		nubus_get_rsrc_mem(&size, &ent, 4);
-		
+
 		/* Now clobber the whole thing */
 		if (size > sizeof(mode) - 1)
 			size = sizeof(mode) - 1;
@@ -584,13 +572,13 @@ static int __init nubus_get_vidnames(struct nubus_board* board,
 }
 
 /* This is *really* cool. */
-static int __init nubus_get_icon(struct nubus_board* board,
-				 const struct nubus_dirent* ent)
+static int __init nubus_get_icon(struct nubus_board *board,
+				 const struct nubus_dirent *ent)
 {
 	/* Should be 32x32 if my memory serves me correctly */
 	unsigned char icon[128];
 	int x, y;
-	
+
 	nubus_get_rsrc_mem(&icon, ent, 128);
 	pr_info("    icon:\n");
 
@@ -600,8 +588,7 @@ static int __init nubus_get_icon(struct nubus_board* board,
 	for (y = 0; y < 32; y++) {
 		pr_info("      ");
 		for (x = 0; x < 32; x++) {
-			if (icon[y*4 + x/8]
-			    & (0x80 >> (x%8)))
+			if (icon[y * 4 + x / 8] & (0x80 >> (x % 8)))
 				pr_cont("*");
 			else
 				pr_cont(" ");
@@ -611,23 +598,22 @@ static int __init nubus_get_icon(struct nubus_board* board,
 	return 0;
 }
 
-static int __init nubus_get_vendorinfo(struct nubus_board* board,
-				       const struct nubus_dirent* parent)
+static int __init nubus_get_vendorinfo(struct nubus_board *board,
+				       const struct nubus_dirent *parent)
 {
-	struct nubus_dir    dir;
+	struct nubus_dir dir;
 	struct nubus_dirent ent;
-	static char* vendor_fields[6] = {"ID", "serial", "revision",
-					 "part", "date", "unknown field"};
+	static char *vendor_fields[6] = { "ID", "serial", "revision",
+	                                  "part", "date", "unknown field" };
 
 	pr_info("    vendor info:\n");
 	nubus_get_subdir(parent, &dir);
 	pr_debug("%s: parent is 0x%p, dir is 0x%p\n",
 	         __func__, parent->base, dir.base);
 
-	while(nubus_readdir(&dir, &ent) != -1)
-	{
+	while (nubus_readdir(&dir, &ent) != -1) {
 		char name[64];
-		
+
 		/* These are all strings, we think */
 		nubus_get_rsrc_str(name, &ent, 64);
 		if (ent.type > 5)
@@ -637,18 +623,17 @@ static int __init nubus_get_vendorinfo(struct nubus_board* board,
 	return 0;
 }
 
-static int __init nubus_get_board_resource(struct nubus_board* board, int slot,
-					   const struct nubus_dirent* parent)
+static int __init nubus_get_board_resource(struct nubus_board *board, int slot,
+					   const struct nubus_dirent *parent)
 {
-	struct nubus_dir    dir;
+	struct nubus_dir dir;
 	struct nubus_dirent ent;
-	
+
 	nubus_get_subdir(parent, &dir);
 	pr_debug("%s: parent is 0x%p, dir is 0x%p\n",
 	         __func__, parent->base, dir.base);
 
-	while(nubus_readdir(&dir, &ent) != -1)
-	{
+	while (nubus_readdir(&dir, &ent) != -1) {
 		switch (ent.type) {
 		case NUBUS_RESID_TYPE:
 		{
@@ -689,7 +674,7 @@ static int __init nubus_get_board_resource(struct nubus_board* board, int slot,
 		case NUBUS_RESID_SECONDINIT:
 			pr_info("    secondary init offset: 0x%06x\n", ent.data);
 			break;
-			/* WTF isn't this in the functional resources? */ 
+			/* WTF isn't this in the functional resources? */
 		case NUBUS_RESID_VIDNAMES:
 			nubus_get_vidnames(board, &ent);
 			break;
@@ -697,7 +682,7 @@ static int __init nubus_get_board_resource(struct nubus_board* board, int slot,
 		case NUBUS_RESID_VIDMODES:
 			pr_info("    video mode parameter directory offset: 0x%06x\n",
 			       ent.data);
-			break;			
+			break;
 		default:
 			pr_info("    unknown resource %02X, data 0x%06x\n",
 			       ent.type, ent.data);
@@ -710,8 +695,8 @@ static int __init nubus_get_board_resource(struct nubus_board* board, int slot,
    sResources in the motherboard ROM */
 static void __init nubus_find_rom_dir(struct nubus_board* board)
 {
-	unsigned char* rp;
-	unsigned char* romdir;
+	unsigned char *rp;
+	unsigned char *romdir;
 	struct nubus_dir dir;
 	struct nubus_dirent ent;
 
@@ -744,14 +729,14 @@ static void __init nubus_find_rom_dir(struct nubus_board* board)
 	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
 		printk(KERN_INFO "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);
 	/* This one takes us to where we want to go. */
-	if (nubus_readdir(&dir, &ent) == -1) 
+	if (nubus_readdir(&dir, &ent) == -1)
 		goto badrom;
 	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
 		printk(KERN_DEBUG "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);
 	nubus_get_subdir(&ent, &dir);
 
 	/* Resource ID 01, also an "Unknown Macintosh" */
-	if (nubus_readdir(&dir, &ent) == -1) 
+	if (nubus_readdir(&dir, &ent) == -1)
 		goto badrom;
 	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
 		printk(KERN_DEBUG "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);
@@ -770,12 +755,12 @@ static void __init nubus_find_rom_dir(struct nubus_board* board)
 		goto badrom;
 	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
 		printk(KERN_DEBUG "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);
-	
+
 	/* Bwahahahaha... */
 	nubus_get_subdir(&ent, &dir);
 	board->directory = dir.base;
 	return;
-	
+
 	/* Even more evil laughter... */
  badrom:
 	board->directory = board->fblock;
@@ -784,23 +769,22 @@ static void __init nubus_find_rom_dir(struct nubus_board* board)
 }
 
 /* Add a board (might be many devices) to the list */
-static struct nubus_board* __init nubus_add_board(int slot, int bytelanes)
+static struct nubus_board * __init nubus_add_board(int slot, int bytelanes)
 {
-	struct nubus_board* board;
-	struct nubus_board** boardp;
-
+	struct nubus_board *board;
+	struct nubus_board **boardp;
 	unsigned char *rp;
 	unsigned long dpat;
 	struct nubus_dir dir;
 	struct nubus_dirent ent;
 
 	/* Move to the start of the format block */
-	rp = nubus_rom_addr(slot);		
+	rp = nubus_rom_addr(slot);
 	nubus_rewind(&rp, FORMAT_BLOCK_SIZE, bytelanes);
 
 	/* Actually we should probably panic if this fails */
 	if ((board = kzalloc(sizeof(*board), GFP_ATOMIC)) == NULL)
-		return NULL;	
+		return NULL;
 	board->fblock = rp;
 
 	/* Dump the format block for debugging purposes */
@@ -816,7 +800,7 @@ static struct nubus_board* __init nubus_add_board(int slot, int bytelanes)
 	rp = board->fblock;
 
 	board->slot = slot;
-	board->slot_addr = (unsigned long) nubus_slot_addr(slot);
+	board->slot_addr = (unsigned long)nubus_slot_addr(slot);
 	board->doffset = nubus_get_rom(&rp, 4, bytelanes);
 	/* rom_length is *supposed* to be the total length of the
 	 * ROM.  In practice it is the "amount of ROM used to compute
@@ -827,16 +811,16 @@ static struct nubus_board* __init nubus_add_board(int slot, int bytelanes)
 	board->rom_length = nubus_get_rom(&rp, 4, bytelanes);
 	board->crc = nubus_get_rom(&rp, 4, bytelanes);
 	board->rev = nubus_get_rom(&rp, 1, bytelanes);
-	board->format = nubus_get_rom(&rp,1, bytelanes);
+	board->format = nubus_get_rom(&rp, 1, bytelanes);
 	board->lanes = bytelanes;
 
 	/* Directory offset should be small and negative... */
-	if(!(board->doffset & 0x00FF0000))
+	if (!(board->doffset & 0x00FF0000))
 		pr_warn("Dodgy doffset!\n");
 	dpat = nubus_get_rom(&rp, 4, bytelanes);
-	if(dpat != NUBUS_TEST_PATTERN)
+	if (dpat != NUBUS_TEST_PATTERN)
 		pr_warn("Wrong test pattern %08lx!\n", dpat);
-		
+
 	/*
 	 *	I wonder how the CRC is meant to work -
 	 *		any takers ?
@@ -846,7 +830,7 @@ static struct nubus_board* __init nubus_add_board(int slot, int bytelanes)
 
 	/* Attempt to work around slot zero weirdness */
 	nubus_find_rom_dir(board);
-	nubus_get_root_dir(board, &dir);	
+	nubus_get_root_dir(board, &dir);
 
 	/* We're ready to rock */
 	pr_info("Slot %X:\n", slot);
@@ -869,8 +853,9 @@ static struct nubus_board* __init nubus_add_board(int slot, int bytelanes)
 	   resources.  I have no idea WTF to do about this. */
 
 	while (nubus_readdir(&dir, &ent) != -1) {
-		struct nubus_dev*  dev;
-		struct nubus_dev** devp;
+		struct nubus_dev *dev;
+		struct nubus_dev **devp;
+
 		dev = nubus_get_functional_resource(board, slot, &ent);
 		if (dev == NULL)
 			continue;
@@ -878,32 +863,33 @@ static struct nubus_board* __init nubus_add_board(int slot, int bytelanes)
 		/* We zeroed this out above */
 		if (board->first_dev == NULL)
 			board->first_dev = dev;
-		
+
 		/* Put it on the global NuBus device chain. Keep entries in order. */
-		for (devp=&nubus_devices; *devp!=NULL; devp=&((*devp)->next))
+		for (devp = &nubus_devices; *devp != NULL;
+		     devp = &((*devp)->next))
 			/* spin */;
 		*devp = dev;
-		dev->next = NULL;		
+		dev->next = NULL;
 	}
 
 	/* Put it on the global NuBus board chain. Keep entries in order. */
-	for (boardp=&nubus_boards; *boardp!=NULL; boardp=&((*boardp)->next))
+	for (boardp = &nubus_boards; *boardp != NULL;
+	     boardp = &((*boardp)->next))
 		/* spin */;
 	*boardp = board;
 	board->next = NULL;
-	
+
 	return board;
 }
 
 void __init nubus_probe_slot(int slot)
 {
 	unsigned char dp;
-	unsigned char* rp;
+	unsigned char *rp;
 	int i;
 
-	rp = nubus_rom_addr(slot);	
-	for(i = 4; i; i--)
-	{
+	rp = nubus_rom_addr(slot);
+	for (i = 4; i; i--) {
 		int card_present;
 
 		rp--;
@@ -918,11 +904,11 @@ void __init nubus_probe_slot(int slot)
 		/* The last byte of the format block consists of two
 		   nybbles which are "mirror images" of each other.
 		   These show us the valid bytelanes */
-		if ((((dp>>4) ^ dp) & 0x0F) != 0x0F)
+		if ((((dp >> 4) ^ dp) & 0x0F) != 0x0F)
 			continue;
 		/* Check that this value is actually *on* one of the
 		   bytelanes it claims are valid! */
-		if ((dp & 0x0F) >= (1<<i))
+		if ((dp & 0x0F) >= (1 << i))
 			continue;
 
 		/* Looks promising.  Let's put it on the list. */
@@ -935,19 +921,19 @@ void __init nubus_probe_slot(int slot)
 void __init nubus_scan_bus(void)
 {
 	int slot;
+
 	/* This might not work on your machine */
 #ifdef I_WANT_TO_PROBE_SLOT_ZERO
 	nubus_probe_slot(0);
 #endif
-	for(slot = 9; slot < 15; slot++)
-	{
+	for (slot = 9; slot < 15; slot++) {
 		nubus_probe_slot(slot);
 	}
 }
 
 static int __init nubus_init(void)
 {
-	if (!MACH_IS_MAC) 
+	if (!MACH_IS_MAC)
 		return 0;
 
 	/* Initialize the NuBus interrupts */
@@ -963,11 +949,11 @@ static int __init nubus_init(void)
 	   gurus can fix the real cause of the problem. */
 	mdelay(1000);
 #endif
-	
+
 	/* And probe */
 	pr_info("NuBus: Scanning NuBus slots.\n");
 	nubus_devices = NULL;
-	nubus_boards  = NULL;
+	nubus_boards = NULL;
 	nubus_scan_bus();
 	nubus_proc_init();
 	return 0;

commit 71ae40e4cf3323b89ea910b82947d5e5e08c94bf
Author: David Huggins-Daines <dhd@debian.org>
Date:   Sat Apr 8 19:51:15 2017 -0400

    nubus: Clean up printk calls
    
    Some long forgotten changes from the linux-mac68k CVS:
    
    Fix swapped DrvrSW and DrvrHW values in printk message.
    Suppress debug printk messages.
    Avoid console_loglevel misuse.
    
    The original commits are these:
    
    http://linux-mac68k.cvs.sourceforge.net/viewvc/linux-mac68k/linux-mac68k/drivers/nubus/nubus.c?r1=1.22.2.1&r2=1.22.2.2&pathrev=linux-2_2
    http://linux-mac68k.cvs.sourceforge.net/viewvc/linux-mac68k/linux-mac68k/drivers/nubus/nubus.c?r1=1.21&r2=1.22&pathrev=linux-2_2
    
    The CVS commits fell short of removing all of the misuse of
    console_loglevel in nubus_add_board() so I finished the job.
    I've also added some missing message severity levels and converted
    a printk loop to the MAC address "%pM" format specifier.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index ea9202de56f0..56de633f19b9 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -103,7 +103,7 @@ static void nubus_rewind(unsigned char **ptr, int len, int map)
 
 	/* Sanity check */
 	if(len > 65536)
-		printk(KERN_ERR "rewind of 0x%08x!\n", len);
+		pr_err("rewind of 0x%08x!\n", len);
 	while(len)
 	{
 		do
@@ -120,7 +120,7 @@ static void nubus_advance(unsigned char **ptr, int len, int map)
 {
 	unsigned char *p = *ptr;
 	if(len>65536)
-		printk(KERN_ERR "advance of 0x%08x!\n", len);
+		pr_err("advance of 0x%08x!\n", len);
 	while(len)
 	{
 		while(not_useful(p,map))
@@ -375,14 +375,14 @@ static int __init nubus_show_display_resource(struct nubus_dev* dev,
 {
 	switch (ent->type) {
 	case NUBUS_RESID_GAMMADIR:
-		printk(KERN_INFO "    gamma directory offset: 0x%06x\n", ent->data);
+		pr_info("    gamma directory offset: 0x%06x\n", ent->data);
 		break;
 	case 0x0080 ... 0x0085:
-		printk(KERN_INFO "    mode %02X info offset: 0x%06x\n",
+		pr_info("    mode %02X info offset: 0x%06x\n",
 		       ent->type, ent->data);
 		break;
 	default:
-		printk(KERN_INFO "    unknown resource %02X, data 0x%06x\n",
+		pr_info("    unknown resource %02X, data 0x%06x\n",
 		       ent->type, ent->data);
 	}
 	return 0;
@@ -395,18 +395,13 @@ static int __init nubus_show_network_resource(struct nubus_dev* dev,
 	case NUBUS_RESID_MAC_ADDRESS:
 	{
 		char addr[6];
-		int i;
 		
 		nubus_get_rsrc_mem(addr, ent, 6);
-		printk(KERN_INFO "    MAC address: ");
-		for (i = 0; i < 6; i++)
-			printk("%02x%s", addr[i] & 0xff,
-			       i == 5 ? "" : ":");
-		printk("\n");
+		pr_info("    MAC address: %pM\n", addr);
 		break;
 	}
 	default:
-		printk(KERN_INFO "    unknown resource %02X, data 0x%06x\n",
+		pr_info("    unknown resource %02X, data 0x%06x\n",
 		       ent->type, ent->data);
 	}
 	return 0;
@@ -420,7 +415,7 @@ static int __init nubus_show_cpu_resource(struct nubus_dev* dev,
 	{
 		unsigned long meminfo[2];
 		nubus_get_rsrc_mem(&meminfo, ent, 8);
-		printk(KERN_INFO "    memory: [ 0x%08lx 0x%08lx ]\n",
+		pr_info("    memory: [ 0x%08lx 0x%08lx ]\n",
 		       meminfo[0], meminfo[1]);
 		break;
 	}
@@ -428,12 +423,12 @@ static int __init nubus_show_cpu_resource(struct nubus_dev* dev,
 	{
 		unsigned long rominfo[2];
 		nubus_get_rsrc_mem(&rominfo, ent, 8);
-		printk(KERN_INFO "    ROM:    [ 0x%08lx 0x%08lx ]\n",
+		pr_info("    ROM:    [ 0x%08lx 0x%08lx ]\n",
 		       rominfo[0], rominfo[1]);
 		break;
 	}
 	default:
-		printk(KERN_INFO "    unknown resource %02X, data 0x%06x\n",
+		pr_info("    unknown resource %02X, data 0x%06x\n",
 		       ent->type, ent->data);
 	}
 	return 0;
@@ -453,7 +448,7 @@ static int __init nubus_show_private_resource(struct nubus_dev* dev,
 		nubus_show_cpu_resource(dev, ent);
 		break;
 	default:
-		printk(KERN_INFO "    unknown resource %02X, data 0x%06x\n",
+		pr_info("    unknown resource %02X, data 0x%06x\n",
 		       ent->type, ent->data);
 	}
 	return 0;
@@ -468,16 +463,15 @@ static struct nubus_dev* __init
 	struct nubus_dirent ent;
 	struct nubus_dev*   dev;
 	
-	printk(KERN_INFO "  Function 0x%02x:\n", parent->type);
+	pr_info("  Function 0x%02x:\n", parent->type);
 	nubus_get_subdir(parent, &dir);
 
 	/* Apple seems to have botched the ROM on the IIx */
 	if (slot == 0 && (unsigned long)dir.base % 2)
 		dir.base += 1;
 	
-	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
-		printk(KERN_DEBUG "nubus_get_functional_resource: parent is 0x%p, dir is 0x%p\n",
-		       parent->base, dir.base);
+	pr_debug("%s: parent is 0x%p, dir is 0x%p\n",
+	         __func__, parent->base, dir.base);
 
 	/* Actually we should probably panic if this fails */
 	if ((dev = kzalloc(sizeof(*dev), GFP_ATOMIC)) == NULL)
@@ -498,14 +492,14 @@ static struct nubus_dev* __init
 			dev->type     = nbtdata[1];
 			dev->dr_sw    = nbtdata[2];
 			dev->dr_hw    = nbtdata[3];
-			printk(KERN_INFO "    type: [cat 0x%x type 0x%x hw 0x%x sw 0x%x]\n",
-			       nbtdata[0], nbtdata[1], nbtdata[2], nbtdata[3]);
+			pr_info("    type: [cat 0x%x type 0x%x sw 0x%x hw 0x%x]\n",
+			        nbtdata[0], nbtdata[1], nbtdata[2], nbtdata[3]);
 			break;
 		}
 		case NUBUS_RESID_NAME:
 		{
 			nubus_get_rsrc_str(dev->name, &ent, 64);
-			printk(KERN_INFO "    name: %s\n", dev->name);
+			pr_info("    name: %s\n", dev->name);
 			break;
 		}
 		case NUBUS_RESID_DRVRDIR:
@@ -517,8 +511,7 @@ static struct nubus_dev* __init
 			nubus_get_subdir(&ent, &drvr_dir);
 			nubus_readdir(&drvr_dir, &drvr_ent);
 			dev->driver = nubus_dirptr(&drvr_ent);
-			printk(KERN_INFO "    driver at: 0x%p\n",
-			       dev->driver);
+			pr_info("    driver at: 0x%p\n", dev->driver);
 			break;
 		}
 		case NUBUS_RESID_MINOR_BASEOS:
@@ -526,22 +519,20 @@ static struct nubus_dev* __init
 			   multiple framebuffers.  It might be handy
 			   for Ethernet as well */
 			nubus_get_rsrc_mem(&dev->iobase, &ent, 4);
-			printk(KERN_INFO "    memory offset: 0x%08lx\n",
-			       dev->iobase);
+			pr_info("    memory offset: 0x%08lx\n", dev->iobase);
 			break;
 		case NUBUS_RESID_MINOR_LENGTH:
 			/* Ditto */
 			nubus_get_rsrc_mem(&dev->iosize, &ent, 4);
-			printk(KERN_INFO "    memory length: 0x%08lx\n",
-			       dev->iosize);
+			pr_info("    memory length: 0x%08lx\n", dev->iosize);
 			break;			
 		case NUBUS_RESID_FLAGS:
 			dev->flags = ent.data;
-			printk(KERN_INFO "    flags: 0x%06x\n", dev->flags);
+			pr_info("    flags: 0x%06x\n", dev->flags);
 			break;
 		case NUBUS_RESID_HWDEVID:
 			dev->hwdevid = ent.data;
-			printk(KERN_INFO "    hwdevid: 0x%06x\n", dev->hwdevid);
+			pr_info("    hwdevid: 0x%06x\n", dev->hwdevid);
 			break;
 		default:
 			/* Local/Private resources have their own
@@ -568,11 +559,10 @@ static int __init nubus_get_vidnames(struct nubus_board* board,
 		char name[32];
 	};
 
-	printk(KERN_INFO "    video modes supported:\n");
+	pr_info("    video modes supported:\n");
 	nubus_get_subdir(parent, &dir);
-	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
-		printk(KERN_DEBUG "nubus_get_vidnames: parent is 0x%p, dir is 0x%p\n",
-		       parent->base, dir.base);
+	pr_debug("%s: parent is 0x%p, dir is 0x%p\n",
+	         __func__, parent->base, dir.base);
 
 	while(nubus_readdir(&dir, &ent) != -1)
 	{
@@ -587,7 +577,7 @@ static int __init nubus_get_vidnames(struct nubus_board* board,
 			size = sizeof(mode) - 1;
 		memset(&mode, 0, sizeof(mode));
 		nubus_get_rsrc_mem(&mode, &ent, size);
-		printk (KERN_INFO "      %02X: (%02X) %s\n", ent.type,
+		pr_info("      %02X: (%02X) %s\n", ent.type,
 			mode.id, mode.name);
 	}
 	return 0;
@@ -602,21 +592,21 @@ static int __init nubus_get_icon(struct nubus_board* board,
 	int x, y;
 	
 	nubus_get_rsrc_mem(&icon, ent, 128);
-	printk(KERN_INFO "    icon:\n");
+	pr_info("    icon:\n");
 
 	/* We should actually plot these somewhere in the framebuffer
 	   init.  This is just to demonstrate that they do, in fact,
 	   exist */
 	for (y = 0; y < 32; y++) {
-		printk(KERN_INFO "      ");
+		pr_info("      ");
 		for (x = 0; x < 32; x++) {
 			if (icon[y*4 + x/8]
 			    & (0x80 >> (x%8)))
-				printk("*");
+				pr_cont("*");
 			else
-				printk(" ");
+				pr_cont(" ");
 		}
-		printk("\n");
+		pr_cont("\n");
 	}
 	return 0;
 }
@@ -629,11 +619,10 @@ static int __init nubus_get_vendorinfo(struct nubus_board* board,
 	static char* vendor_fields[6] = {"ID", "serial", "revision",
 					 "part", "date", "unknown field"};
 
-	printk(KERN_INFO "    vendor info:\n");
+	pr_info("    vendor info:\n");
 	nubus_get_subdir(parent, &dir);
-	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
-		printk(KERN_DEBUG "nubus_get_vendorinfo: parent is 0x%p, dir is 0x%p\n",
-		       parent->base, dir.base);
+	pr_debug("%s: parent is 0x%p, dir is 0x%p\n",
+	         __func__, parent->base, dir.base);
 
 	while(nubus_readdir(&dir, &ent) != -1)
 	{
@@ -643,8 +632,7 @@ static int __init nubus_get_vendorinfo(struct nubus_board* board,
 		nubus_get_rsrc_str(name, &ent, 64);
 		if (ent.type > 5)
 			ent.type = 5;
-		printk(KERN_INFO "    %s: %s\n",
-		       vendor_fields[ent.type-1], name);
+		pr_info("    %s: %s\n", vendor_fields[ent.type - 1], name);
 	}
 	return 0;
 }
@@ -656,9 +644,8 @@ static int __init nubus_get_board_resource(struct nubus_board* board, int slot,
 	struct nubus_dirent ent;
 	
 	nubus_get_subdir(parent, &dir);
-	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
-		printk(KERN_DEBUG "nubus_get_board_resource: parent is 0x%p, dir is 0x%p\n",
-		       parent->base, dir.base);
+	pr_debug("%s: parent is 0x%p, dir is 0x%p\n",
+	         __func__, parent->base, dir.base);
 
 	while(nubus_readdir(&dir, &ent) != -1)
 	{
@@ -670,38 +657,37 @@ static int __init nubus_get_board_resource(struct nubus_board* board, int slot,
 			   useful except insofar as it tells us that
 			   we really are looking at a board resource. */
 			nubus_get_rsrc_mem(nbtdata, &ent, 8);
-			printk(KERN_INFO "    type: [cat 0x%x type 0x%x hw 0x%x sw 0x%x]\n",
-			       nbtdata[0], nbtdata[1], nbtdata[2],
-			       nbtdata[3]);
+			pr_info("    type: [cat 0x%x type 0x%x sw 0x%x hw 0x%x]\n",
+			        nbtdata[0], nbtdata[1], nbtdata[2], nbtdata[3]);
 			if (nbtdata[0] != 1 || nbtdata[1] != 0 ||
 			    nbtdata[2] != 0 || nbtdata[3] != 0)
-				printk(KERN_ERR "this sResource is not a board resource!\n");
+				pr_err("this sResource is not a board resource!\n");
 			break;
 		}
 		case NUBUS_RESID_NAME:
 			nubus_get_rsrc_str(board->name, &ent, 64);
-			printk(KERN_INFO "    name: %s\n", board->name);
+			pr_info("    name: %s\n", board->name);
 			break;
 		case NUBUS_RESID_ICON:
 			nubus_get_icon(board, &ent);
 			break;
 		case NUBUS_RESID_BOARDID:
-			printk(KERN_INFO "    board id: 0x%x\n", ent.data);
+			pr_info("    board id: 0x%x\n", ent.data);
 			break;
 		case NUBUS_RESID_PRIMARYINIT:
-			printk(KERN_INFO "    primary init offset: 0x%06x\n", ent.data);
+			pr_info("    primary init offset: 0x%06x\n", ent.data);
 			break;
 		case NUBUS_RESID_VENDORINFO:
 			nubus_get_vendorinfo(board, &ent);
 			break;
 		case NUBUS_RESID_FLAGS:
-			printk(KERN_INFO "    flags: 0x%06x\n", ent.data);
+			pr_info("    flags: 0x%06x\n", ent.data);
 			break;
 		case NUBUS_RESID_HWDEVID:
-			printk(KERN_INFO "    hwdevid: 0x%06x\n", ent.data);
+			pr_info("    hwdevid: 0x%06x\n", ent.data);
 			break;
 		case NUBUS_RESID_SECONDINIT:
-			printk(KERN_INFO "    secondary init offset: 0x%06x\n", ent.data);
+			pr_info("    secondary init offset: 0x%06x\n", ent.data);
 			break;
 			/* WTF isn't this in the functional resources? */ 
 		case NUBUS_RESID_VIDNAMES:
@@ -709,11 +695,11 @@ static int __init nubus_get_board_resource(struct nubus_board* board, int slot,
 			break;
 			/* Same goes for this */
 		case NUBUS_RESID_VIDMODES:
-			printk(KERN_INFO "    video mode parameter directory offset: 0x%06x\n",
+			pr_info("    video mode parameter directory offset: 0x%06x\n",
 			       ent.data);
 			break;			
 		default:
-			printk(KERN_INFO "    unknown resource %02X, data 0x%06x\n",
+			pr_info("    unknown resource %02X, data 0x%06x\n",
 			       ent.type, ent.data);
 		}
 	}
@@ -818,21 +804,17 @@ static struct nubus_board* __init nubus_add_board(int slot, int bytelanes)
 	board->fblock = rp;
 
 	/* Dump the format block for debugging purposes */
-	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG) {
-		int i;
-		printk(KERN_DEBUG "Slot %X, format block at 0x%p\n",
-		       slot, rp);
-		printk(KERN_DEBUG "Format block: ");
-		for (i = 0; i < FORMAT_BLOCK_SIZE; i += 4) {
-			unsigned short foo, bar;
-			foo = nubus_get_rom(&rp, 2, bytelanes);
-			bar = nubus_get_rom(&rp, 2, bytelanes);
-			printk("%04x %04x  ", foo, bar);
-		}
-		printk("\n");
-		rp = board->fblock;
-	}
-	
+	pr_debug("Slot %X, format block at 0x%p:\n", slot, rp);
+	pr_debug("%02lx\n", nubus_get_rom(&rp, 1, bytelanes));
+	pr_debug("%02lx\n", nubus_get_rom(&rp, 1, bytelanes));
+	pr_debug("%08lx\n", nubus_get_rom(&rp, 4, bytelanes));
+	pr_debug("%02lx\n", nubus_get_rom(&rp, 1, bytelanes));
+	pr_debug("%02lx\n", nubus_get_rom(&rp, 1, bytelanes));
+	pr_debug("%08lx\n", nubus_get_rom(&rp, 4, bytelanes));
+	pr_debug("%08lx\n", nubus_get_rom(&rp, 4, bytelanes));
+	pr_debug("%08lx\n", nubus_get_rom(&rp, 4, bytelanes));
+	rp = board->fblock;
+
 	board->slot = slot;
 	board->slot_addr = (unsigned long) nubus_slot_addr(slot);
 	board->doffset = nubus_get_rom(&rp, 4, bytelanes);
@@ -850,10 +832,10 @@ static struct nubus_board* __init nubus_add_board(int slot, int bytelanes)
 
 	/* Directory offset should be small and negative... */
 	if(!(board->doffset & 0x00FF0000))
-		printk(KERN_WARNING "Dodgy doffset!\n");
+		pr_warn("Dodgy doffset!\n");
 	dpat = nubus_get_rom(&rp, 4, bytelanes);
 	if(dpat != NUBUS_TEST_PATTERN)
-		printk(KERN_WARNING "Wrong test pattern %08lx!\n", dpat);
+		pr_warn("Wrong test pattern %08lx!\n", dpat);
 		
 	/*
 	 *	I wonder how the CRC is meant to work -
@@ -867,7 +849,7 @@ static struct nubus_board* __init nubus_add_board(int slot, int bytelanes)
 	nubus_get_root_dir(board, &dir);	
 
 	/* We're ready to rock */
-	printk(KERN_INFO "Slot %X:\n", slot);
+	pr_info("Slot %X:\n", slot);
 
 	/* Each slot should have one board resource and any number of
 	   functional resources.  So we'll fill in some fields in the
@@ -876,10 +858,10 @@ static struct nubus_board* __init nubus_add_board(int slot, int bytelanes)
 	   for each of them. */
 	if (nubus_readdir(&dir, &ent) == -1) {
 		/* We can't have this! */
-		printk(KERN_ERR "Board resource not found!\n");
+		pr_err("Board resource not found!\n");
 		return NULL;
 	} else {
-		printk(KERN_INFO "  Board resource:\n");
+		pr_info("  Board resource:\n");
 		nubus_get_board_resource(board, slot, &ent);
 	}
 
@@ -929,7 +911,6 @@ void __init nubus_probe_slot(int slot)
 		if (!card_present)
 			continue;
 
-		printk(KERN_DEBUG "Now probing slot %X at %p\n", slot, rp);
 		dp = *rp;
 		if(dp == 0)
 			continue;
@@ -984,7 +965,7 @@ static int __init nubus_init(void)
 #endif
 	
 	/* And probe */
-	printk("NuBus: Scanning NuBus slots.\n");
+	pr_info("NuBus: Scanning NuBus slots.\n");
 	nubus_devices = NULL;
 	nubus_boards  = NULL;
 	nubus_scan_bus();

commit e36b9913e00b39ff4afcacff947bc99d305aaac0
Author: David Huggins-Daines <dhd@debian.org>
Date:   Sat Apr 8 19:51:15 2017 -0400

    nubus: Fix nubus_rewinddir
    
    A long forgotten fix from the linux-mac68k CVS:
    
    Initialize dir->done pointer in nubus_rewinddir().
    
    The original commit is here:
    
    http://linux-mac68k.cvs.sourceforge.net/viewvc/linux-mac68k/linux-mac68k/drivers/nubus/nubus.c?r1=1.22&r2=1.22.2.1&pathrev=linux-2_2
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index 3319cf19deeb..ea9202de56f0 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -285,6 +285,8 @@ EXPORT_SYMBOL(nubus_readdir);
 int nubus_rewinddir(struct nubus_dir* dir)
 {
 	dir->ptr = dir->base;
+	dir->done = 0;
+
 	return 0;
 }
 EXPORT_SYMBOL(nubus_rewinddir);

commit bcf8eb09b564096d47f9740ac16057e5f7c8d0f1
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Sep 28 11:06:30 2014 +0200

    nubus: Remove superfluous interrupt disable/restore
    
    As of commit e4dc601bf99ccd1c ("m68k: Disable/restore interrupts in
    hwreg_present()/hwreg_write()"), this is no longer needed.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index 5066a7ef7b6c..3319cf19deeb 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -920,14 +920,10 @@ void __init nubus_probe_slot(int slot)
 	rp = nubus_rom_addr(slot);	
 	for(i = 4; i; i--)
 	{
-		unsigned long flags;
 		int card_present;
 
 		rp--;
-		local_irq_save(flags);
 		card_present = hwreg_present(rp);
-		local_irq_restore(flags);
-	       
 		if (!card_present)
 			continue;
 

commit a8fe19ebfbfd90ec17c02284717238b02efb9580
Author: Borislav Petkov <bp@suse.de>
Date:   Wed Jun 4 16:11:46 2014 -0700

    kernel/printk: use symbolic defines for console loglevels
    
    ... instead of naked numbers.
    
    Stuff in sysrq.c used to set it to 8 which is supposed to mean above
    default level so set it to DEBUG instead as we're terminating/killing all
    tasks and we want to be verbose there.
    
    Also, correct the check in x86_64_start_kernel which should be >= as
    we're clearly issuing the string there for all debug levels, not only
    the magical 10.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Valdis Kletnieks <Valdis.Kletnieks@vt.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index 43926cd25ae8..5066a7ef7b6c 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -473,7 +473,7 @@ static struct nubus_dev* __init
 	if (slot == 0 && (unsigned long)dir.base % 2)
 		dir.base += 1;
 	
-	if (console_loglevel >= 10)
+	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
 		printk(KERN_DEBUG "nubus_get_functional_resource: parent is 0x%p, dir is 0x%p\n",
 		       parent->base, dir.base);
 
@@ -568,7 +568,7 @@ static int __init nubus_get_vidnames(struct nubus_board* board,
 
 	printk(KERN_INFO "    video modes supported:\n");
 	nubus_get_subdir(parent, &dir);
-	if (console_loglevel >= 10)
+	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
 		printk(KERN_DEBUG "nubus_get_vidnames: parent is 0x%p, dir is 0x%p\n",
 		       parent->base, dir.base);
 
@@ -629,7 +629,7 @@ static int __init nubus_get_vendorinfo(struct nubus_board* board,
 
 	printk(KERN_INFO "    vendor info:\n");
 	nubus_get_subdir(parent, &dir);
-	if (console_loglevel >= 10)
+	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
 		printk(KERN_DEBUG "nubus_get_vendorinfo: parent is 0x%p, dir is 0x%p\n",
 		       parent->base, dir.base);
 
@@ -654,7 +654,7 @@ static int __init nubus_get_board_resource(struct nubus_board* board, int slot,
 	struct nubus_dirent ent;
 	
 	nubus_get_subdir(parent, &dir);
-	if (console_loglevel >= 10)
+	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
 		printk(KERN_DEBUG "nubus_get_board_resource: parent is 0x%p, dir is 0x%p\n",
 		       parent->base, dir.base);
 
@@ -753,19 +753,19 @@ static void __init nubus_find_rom_dir(struct nubus_board* board)
 	if (nubus_readdir(&dir, &ent) == -1)
 		goto badrom;
 
-	if (console_loglevel >= 10)
+	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
 		printk(KERN_INFO "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);
 	/* This one takes us to where we want to go. */
 	if (nubus_readdir(&dir, &ent) == -1) 
 		goto badrom;
-	if (console_loglevel >= 10)
+	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
 		printk(KERN_DEBUG "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);
 	nubus_get_subdir(&ent, &dir);
 
 	/* Resource ID 01, also an "Unknown Macintosh" */
 	if (nubus_readdir(&dir, &ent) == -1) 
 		goto badrom;
-	if (console_loglevel >= 10)
+	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
 		printk(KERN_DEBUG "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);
 
 	/* FIXME: the first one is *not* always the right one.  We
@@ -780,7 +780,7 @@ static void __init nubus_find_rom_dir(struct nubus_board* board)
 	   path to that address... */
 	if (nubus_readdir(&dir, &ent) == -1)
 		goto badrom;
-	if (console_loglevel >= 10)
+	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG)
 		printk(KERN_DEBUG "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);
 	
 	/* Bwahahahaha... */
@@ -816,7 +816,7 @@ static struct nubus_board* __init nubus_add_board(int slot, int bytelanes)
 	board->fblock = rp;
 
 	/* Dump the format block for debugging purposes */
-	if (console_loglevel >= 10) {
+	if (console_loglevel >= CONSOLE_LOGLEVEL_DEBUG) {
 		int i;
 		printk(KERN_DEBUG "Slot %X, format block at 0x%p\n",
 		       slot, rp);

commit 11db656ad462c9aa7aff7e3817214578cfc307b3
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 10 15:05:38 2013 +0100

    nubus: Don't use create_proc_read_entry()
    
    Don't use create_proc_read_entry() as that is deprecated, but rather use
    proc_create_data() and seq_file instead.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-m68k@lists.linux-m68k.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index 44d01afafe9c..43926cd25ae8 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -19,7 +19,6 @@
 #include <asm/setup.h>
 #include <asm/page.h>
 #include <asm/hwtest.h>
-#include <linux/proc_fs.h>
 #include <asm/mac_via.h>
 #include <asm/mac_oss.h>
 
@@ -954,56 +953,6 @@ void __init nubus_probe_slot(int slot)
 	}
 }
 
-#if defined(CONFIG_PROC_FS)
-
-/* /proc/nubus stuff */
-
-static int sprint_nubus_board(struct nubus_board* board, char* ptr, int len)
-{
-	if(len < 100)
-		return -1;
-	
-	sprintf(ptr, "Slot %X: %s\n",
-		board->slot, board->name);
-	
-	return strlen(ptr);
-}
-
-static int nubus_read_proc(char *page, char **start, off_t off,
-				int count, int *eof, void *data)
-{
-	int nprinted, len, begin = 0;
-	int size = PAGE_SIZE;
-	struct nubus_board* board;
-	
-	len   = sprintf(page, "Nubus devices found:\n");
-	/* Walk the list of NuBus boards */
-	for (board = nubus_boards; board != NULL; board = board->next)
-	{
-		nprinted = sprint_nubus_board(board, page + len, size - len);
-		if (nprinted < 0)
-			break;
-		len += nprinted;
-		if (len+begin < off) {
-			begin += len;
-			len = 0;
-		}
-		if (len+begin >= off+count)
-			break;
-	}
-	if (len+begin < off)
-		*eof = 1;
-	off -= begin;
-	*start = page + off;
-	len -= off;
-	if (len>count)
-		len = count;
-	if (len<0)
-		len = 0;
-	return len;
-}
-#endif
-
 void __init nubus_scan_bus(void)
 {
 	int slot;
@@ -1041,11 +990,7 @@ static int __init nubus_init(void)
 	nubus_devices = NULL;
 	nubus_boards  = NULL;
 	nubus_scan_bus();
-
-#ifdef CONFIG_PROC_FS
-	create_proc_read_entry("nubus", 0, NULL, nubus_read_proc, NULL);
 	nubus_proc_init();
-#endif
 	return 0;
 }
 

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index b764ac22d523..44d01afafe9c 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -17,7 +17,6 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <asm/setup.h>
-#include <asm/system.h>
 #include <asm/page.h>
 #include <asm/hwtest.h>
 #include <linux/proc_fs.h>

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index f5f75844954c..b764ac22d523 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -15,6 +15,7 @@
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/module.h>
+#include <linux/slab.h>
 #include <asm/setup.h>
 #include <asm/system.h>
 #include <asm/page.h>

commit 2e0eb731e52ebfab177860e59e6e3464c2521839
Author: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
Date:   Wed Oct 15 22:01:31 2008 -0700

    nubus: fix mis-indented statement
    
    It seems this is the right way around because otherwise the len usage in
    the outer loop would be pretty pointless.
    
    Signed-off-by: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index 2f047e573d86..f5f75844954c 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -126,7 +126,7 @@ static void nubus_advance(unsigned char **ptr, int len, int map)
 	{
 		while(not_useful(p,map))
 			p++;
-			p++;
+		p++;
 		len--;
 	}
 	*ptr = p;

commit 99ffab81071b7088ddebd4be9bbf1ad03c2a9e98
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Feb 4 22:30:23 2008 -0800

    nubus: kill drivers/nubus/nubus_syms.c
    
    nubus: kill drivers/nubus/nubus_syms.c
    
    EXPORT_SYMBOL's belong to the actual code.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index f4076aeb2098..2f047e573d86 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -14,6 +14,7 @@
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/delay.h>
+#include <linux/module.h>
 #include <asm/setup.h>
 #include <asm/system.h>
 #include <asm/page.h>
@@ -186,6 +187,7 @@ void nubus_get_rsrc_mem(void *dest, const struct nubus_dirent* dirent,
 		len--;
 	}
 }
+EXPORT_SYMBOL(nubus_get_rsrc_mem);
 
 void nubus_get_rsrc_str(void *dest, const struct nubus_dirent* dirent,
 			int len)
@@ -200,6 +202,7 @@ void nubus_get_rsrc_str(void *dest, const struct nubus_dirent* dirent,
 		len--;
 	}
 }
+EXPORT_SYMBOL(nubus_get_rsrc_str);
 
 int nubus_get_root_dir(const struct nubus_board* board,
 		       struct nubus_dir* dir)
@@ -209,6 +212,7 @@ int nubus_get_root_dir(const struct nubus_board* board,
 	dir->mask = board->lanes;
 	return 0;
 }
+EXPORT_SYMBOL(nubus_get_root_dir);
 
 /* This is a slyly renamed version of the above */
 int nubus_get_func_dir(const struct nubus_dev* dev,
@@ -219,6 +223,7 @@ int nubus_get_func_dir(const struct nubus_dev* dev,
 	dir->mask = dev->board->lanes;
 	return 0;
 }
+EXPORT_SYMBOL(nubus_get_func_dir);
 
 int nubus_get_board_dir(const struct nubus_board* board,
 			struct nubus_dir* dir)
@@ -237,6 +242,7 @@ int nubus_get_board_dir(const struct nubus_board* board,
 		return -1;
 	return 0;
 }
+EXPORT_SYMBOL(nubus_get_board_dir);
 
 int nubus_get_subdir(const struct nubus_dirent *ent,
 		     struct nubus_dir *dir)
@@ -246,6 +252,7 @@ int nubus_get_subdir(const struct nubus_dirent *ent,
 	dir->mask = ent->mask;
 	return 0;
 }
+EXPORT_SYMBOL(nubus_get_subdir);
 
 int nubus_readdir(struct nubus_dir *nd, struct nubus_dirent *ent)
 {
@@ -274,12 +281,14 @@ int nubus_readdir(struct nubus_dir *nd, struct nubus_dirent *ent)
 	ent->mask  = nd->mask;
 	return 0;
 }
+EXPORT_SYMBOL(nubus_readdir);
 
 int nubus_rewinddir(struct nubus_dir* dir)
 {
 	dir->ptr = dir->base;
 	return 0;
 }
+EXPORT_SYMBOL(nubus_rewinddir);
 
 /* Driver interface functions, more or less like in pci.c */
 
@@ -303,6 +312,7 @@ nubus_find_device(unsigned short category,
 	}
 	return NULL;
 }
+EXPORT_SYMBOL(nubus_find_device);
 
 struct nubus_dev*
 nubus_find_type(unsigned short category,
@@ -320,6 +330,7 @@ nubus_find_type(unsigned short category,
 	}
 	return NULL;
 }
+EXPORT_SYMBOL(nubus_find_type);
 
 struct nubus_dev*
 nubus_find_slot(unsigned int slot,
@@ -335,6 +346,7 @@ nubus_find_slot(unsigned int slot,
 	}
 	return NULL;
 }
+EXPORT_SYMBOL(nubus_find_slot);
 
 int
 nubus_find_rsrc(struct nubus_dir* dir, unsigned char rsrc_type,
@@ -346,6 +358,7 @@ nubus_find_rsrc(struct nubus_dir* dir, unsigned char rsrc_type,
 	}	
 	return -1;
 }
+EXPORT_SYMBOL(nubus_find_rsrc);
 
 /* Initialization functions - decide which slots contain stuff worth
    looking at, and print out lots and lots of information from the

commit 081985ac14281d81780bc14562b89434407ca403
Author: Joe Perches <joe@perches.com>
Date:   Sun Feb 3 17:23:36 2008 +0200

    drivers/nubus/: Spelling fixes
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index e503c9c98032..f4076aeb2098 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -352,7 +352,7 @@ nubus_find_rsrc(struct nubus_dir* dir, unsigned char rsrc_type,
    resource blocks. */
 
 /* FIXME: A lot of this stuff will eventually be useful after
-   initializaton, for intelligently probing Ethernet and video chips,
+   initialization, for intelligently probing Ethernet and video chips,
    among other things.  The rest of it should go in the /proc code.
    For now, we just use it to give verbose boot logs. */
 

commit dd00cc486ab1c17049a535413d1751ef3482141c
Author: Yoann Padioleau <padator@wanadoo.fr>
Date:   Thu Jul 19 01:49:03 2007 -0700

    some kmalloc/memset ->kzalloc (tree wide)
    
    Transform some calls to kmalloc/memset to a single kzalloc (or kcalloc).
    
    Here is a short excerpt of the semantic patch performing
    this transformation:
    
    @@
    type T2;
    expression x;
    identifier f,fld;
    expression E;
    expression E1,E2;
    expression e1,e2,e3,y;
    statement S;
    @@
    
     x =
    - kmalloc
    + kzalloc
      (E1,E2)
      ...  when != \(x->fld=E;\|y=f(...,x,...);\|f(...,x,...);\|x=E;\|while(...) S\|for(e1;e2;e3) S\)
    - memset((T2)x,0,E1);
    
    @@
    expression E1,E2,E3;
    @@
    
    - kzalloc(E1 * E2,E3)
    + kcalloc(E1,E2,E3)
    
    [akpm@linux-foundation.org: get kcalloc args the right way around]
    Signed-off-by: Yoann Padioleau <padator@wanadoo.fr>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Bryan Wu <bryan.wu@analog.com>
    Acked-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Dave Airlie <airlied@linux.ie>
    Acked-by: Roland Dreier <rolandd@cisco.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Mauro Carvalho Chehab <mchehab@infradead.org>
    Acked-by: Pierre Ossman <drzeus-list@drzeus.cx>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Acked-by: Greg KH <greg@kroah.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index 3a0a3a734933..e503c9c98032 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -466,9 +466,8 @@ static struct nubus_dev* __init
 		       parent->base, dir.base);
 
 	/* Actually we should probably panic if this fails */
-	if ((dev = kmalloc(sizeof(*dev), GFP_ATOMIC)) == NULL)
+	if ((dev = kzalloc(sizeof(*dev), GFP_ATOMIC)) == NULL)
 		return NULL;	
-	memset(dev, 0, sizeof(*dev));
 	dev->resid = parent->type;
 	dev->directory = dir.base;
 	dev->board = board;
@@ -800,9 +799,8 @@ static struct nubus_board* __init nubus_add_board(int slot, int bytelanes)
 	nubus_rewind(&rp, FORMAT_BLOCK_SIZE, bytelanes);
 
 	/* Actually we should probably panic if this fails */
-	if ((board = kmalloc(sizeof(*board), GFP_ATOMIC)) == NULL)
+	if ((board = kzalloc(sizeof(*board), GFP_ATOMIC)) == NULL)
 		return NULL;	
-	memset(board, 0, sizeof(*board));
 	board->fblock = rp;
 
 	/* Dump the format block for debugging purposes */

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
index 14cbe34eb897..3a0a3a734933 100644
--- a/drivers/nubus/nubus.c
+++ b/drivers/nubus/nubus.c
@@ -7,7 +7,6 @@
  *      and others.
  */
 
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/string.h>

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/nubus/nubus.c b/drivers/nubus/nubus.c
new file mode 100644
index 000000000000..14cbe34eb897
--- /dev/null
+++ b/drivers/nubus/nubus.c
@@ -0,0 +1,1042 @@
+/*
+ *	Macintosh Nubus Interface Code
+ *
+ *      Originally by Alan Cox
+ *
+ *      Mostly rewritten by David Huggins-Daines, C. Scott Ananian,
+ *      and others.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/nubus.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <asm/setup.h>
+#include <asm/system.h>
+#include <asm/page.h>
+#include <asm/hwtest.h>
+#include <linux/proc_fs.h>
+#include <asm/mac_via.h>
+#include <asm/mac_oss.h>
+
+extern void via_nubus_init(void);
+extern void oss_nubus_init(void);
+
+/* Constants */
+
+/* This is, of course, the size in bytelanes, rather than the size in
+   actual bytes */
+#define FORMAT_BLOCK_SIZE 20
+#define ROM_DIR_OFFSET 0x24
+
+#define NUBUS_TEST_PATTERN 0x5A932BC7
+
+/* Define this if you like to live dangerously - it is known not to
+   work on pretty much every machine except the Quadra 630 and the LC
+   III. */
+#undef I_WANT_TO_PROBE_SLOT_ZERO
+
+/* This sometimes helps combat failure to boot */
+#undef TRY_TO_DODGE_WSOD
+
+/* Globals */
+
+struct nubus_dev*   nubus_devices;
+struct nubus_board* nubus_boards;
+
+/* Meaning of "bytelanes":
+
+   The card ROM may appear on any or all bytes of each long word in
+   NuBus memory.  The low 4 bits of the "map" value found in the
+   format block (at the top of the slot address space, as well as at
+   the top of the MacOS ROM) tells us which bytelanes, i.e. which byte
+   offsets within each longword, are valid.  Thus:
+
+   A map of 0x0f, as found in the MacOS ROM, means that all bytelanes
+   are valid.
+
+   A map of 0xf0 means that no bytelanes are valid (We pray that we
+   will never encounter this, but stranger things have happened)
+
+   A map of 0xe1 means that only the MSB of each long word is actually
+   part of the card ROM.  (We hope to never encounter NuBus on a
+   little-endian machine.  Again, stranger things have happened)
+
+   A map of 0x78 means that only the LSB of each long word is valid.
+
+   Etcetera, etcetera.  Hopefully this clears up some confusion over
+   what the following code actually does.  */
+ 
+static inline int not_useful(void *p, int map)
+{
+	unsigned long pv=(unsigned long)p;
+	pv &= 3;
+	if(map & (1<<pv))
+		return 0;
+	return 1;
+}
+ 
+static unsigned long nubus_get_rom(unsigned char **ptr, int len, int map)
+{
+	/* This will hold the result */
+	unsigned long v = 0;
+	unsigned char *p = *ptr;
+
+	while(len)
+	{
+		v <<= 8;
+		while(not_useful(p,map))
+			p++;
+		v |= *p++;
+		len--;
+	}
+	*ptr = p;
+	return v;
+}
+
+static void nubus_rewind(unsigned char **ptr, int len, int map)
+{
+	unsigned char *p=*ptr;
+
+	/* Sanity check */
+	if(len > 65536)
+		printk(KERN_ERR "rewind of 0x%08x!\n", len);
+	while(len)
+	{
+		do
+		{
+			p--;
+		}
+		while(not_useful(p, map));
+		len--;
+	}
+	*ptr=p;
+}
+
+static void nubus_advance(unsigned char **ptr, int len, int map)
+{
+	unsigned char *p = *ptr;
+	if(len>65536)
+		printk(KERN_ERR "advance of 0x%08x!\n", len);
+	while(len)
+	{
+		while(not_useful(p,map))
+			p++;
+			p++;
+		len--;
+	}
+	*ptr = p;
+}
+
+static void nubus_move(unsigned char **ptr, int len, int map)
+{
+	if(len > 0)
+		nubus_advance(ptr, len, map);
+	else if(len < 0)
+		nubus_rewind(ptr, -len, map);
+}
+
+/* Now, functions to read the sResource tree */
+
+/* Each sResource entry consists of a 1-byte ID and a 3-byte data
+   field.  If that data field contains an offset, then obviously we
+   have to expand it from a 24-bit signed number to a 32-bit signed
+   number. */
+
+static inline long nubus_expand32(long foo)
+{
+	if(foo & 0x00800000)	/* 24bit negative */
+		foo |= 0xFF000000;
+	return foo;
+}
+
+static inline void *nubus_rom_addr(int slot)
+{	
+	/*
+	 *	Returns the first byte after the card. We then walk
+	 *	backwards to get the lane register and the config
+	 */
+	return (void *)(0xF1000000+(slot<<24));
+}
+
+static unsigned char *nubus_dirptr(const struct nubus_dirent *nd)
+{
+	unsigned char *p = nd->base;
+	/* Essentially, just step over the bytelanes using whatever
+	   offset we might have found */
+	nubus_move(&p, nubus_expand32(nd->data), nd->mask);
+	/* And return the value */
+	return p;
+}
+
+/* These two are for pulling resource data blocks (i.e. stuff that's
+   pointed to with offsets) out of the card ROM. */
+
+void nubus_get_rsrc_mem(void *dest, const struct nubus_dirent* dirent,
+			int len)
+{
+	unsigned char *t = (unsigned char *)dest;
+	unsigned char *p = nubus_dirptr(dirent);
+	while(len)
+	{
+		*t++ = nubus_get_rom(&p, 1, dirent->mask);
+		len--;
+	}
+}
+
+void nubus_get_rsrc_str(void *dest, const struct nubus_dirent* dirent,
+			int len)
+{
+	unsigned char *t=(unsigned char *)dest;
+	unsigned char *p = nubus_dirptr(dirent);
+	while(len)
+	{
+		*t = nubus_get_rom(&p, 1, dirent->mask);
+		if(!*t++)
+			break;
+		len--;
+	}
+}
+
+int nubus_get_root_dir(const struct nubus_board* board,
+		       struct nubus_dir* dir)
+{
+	dir->ptr = dir->base = board->directory;
+	dir->done = 0;
+	dir->mask = board->lanes;
+	return 0;
+}
+
+/* This is a slyly renamed version of the above */
+int nubus_get_func_dir(const struct nubus_dev* dev,
+		       struct nubus_dir* dir)
+{
+	dir->ptr = dir->base = dev->directory;
+	dir->done = 0;
+	dir->mask = dev->board->lanes;
+	return 0;
+}
+
+int nubus_get_board_dir(const struct nubus_board* board,
+			struct nubus_dir* dir)
+{
+	struct nubus_dirent ent;
+	
+	dir->ptr = dir->base = board->directory;
+	dir->done = 0;
+	dir->mask = board->lanes;
+
+	/* Now dereference it (the first directory is always the board
+	   directory) */
+	if (nubus_readdir(dir, &ent) == -1)
+		return -1;
+	if (nubus_get_subdir(&ent, dir) == -1)
+		return -1;
+	return 0;
+}
+
+int nubus_get_subdir(const struct nubus_dirent *ent,
+		     struct nubus_dir *dir)
+{
+	dir->ptr = dir->base = nubus_dirptr(ent);
+	dir->done = 0;
+	dir->mask = ent->mask;
+	return 0;
+}
+
+int nubus_readdir(struct nubus_dir *nd, struct nubus_dirent *ent)
+{
+	u32 resid;
+	if (nd->done)
+		return -1;
+
+	/* Do this first, otherwise nubus_rewind & co are off by 4 */
+	ent->base = nd->ptr;
+
+	/* This moves nd->ptr forward */
+	resid = nubus_get_rom(&nd->ptr, 4, nd->mask);
+
+	/* EOL marker, as per the Apple docs */
+	if((resid&0xff000000) == 0xff000000)
+	{
+		/* Mark it as done */
+		nd->done = 1;
+		return -1;
+	}
+
+	/* First byte is the resource ID */
+	ent->type  = resid >> 24;
+	/* Low 3 bytes might contain data (or might not) */
+	ent->data = resid & 0xffffff;
+	ent->mask  = nd->mask;
+	return 0;
+}
+
+int nubus_rewinddir(struct nubus_dir* dir)
+{
+	dir->ptr = dir->base;
+	return 0;
+}
+
+/* Driver interface functions, more or less like in pci.c */
+
+struct nubus_dev*
+nubus_find_device(unsigned short category,
+		  unsigned short type,
+		  unsigned short dr_hw,
+		  unsigned short dr_sw,
+		  const struct nubus_dev* from)
+{
+	struct nubus_dev* itor =
+		from ? from->next : nubus_devices;
+
+	while (itor) {
+		if (itor->category == category
+		    && itor->type == type
+		    && itor->dr_hw == dr_hw
+		    && itor->dr_sw == dr_sw)
+			return itor;
+		itor = itor->next;
+	}
+	return NULL;
+}
+
+struct nubus_dev*
+nubus_find_type(unsigned short category,
+		unsigned short type,
+		const struct nubus_dev* from)
+{
+	struct nubus_dev* itor =
+		from ? from->next : nubus_devices;
+
+	while (itor) {
+		if (itor->category == category
+		    && itor->type == type)
+			return itor;
+		itor = itor->next;
+	}
+	return NULL;
+}
+
+struct nubus_dev*
+nubus_find_slot(unsigned int slot,
+		const struct nubus_dev* from)
+{
+	struct nubus_dev* itor =
+		from ? from->next : nubus_devices;
+	
+	while (itor) {
+		if (itor->board->slot == slot)
+			return itor;
+		itor = itor->next;
+	}
+	return NULL;
+}
+
+int
+nubus_find_rsrc(struct nubus_dir* dir, unsigned char rsrc_type,
+		struct nubus_dirent* ent)
+{
+	while (nubus_readdir(dir, ent) != -1) {
+		if (ent->type == rsrc_type)
+			return 0;
+	}	
+	return -1;
+}
+
+/* Initialization functions - decide which slots contain stuff worth
+   looking at, and print out lots and lots of information from the
+   resource blocks. */
+
+/* FIXME: A lot of this stuff will eventually be useful after
+   initializaton, for intelligently probing Ethernet and video chips,
+   among other things.  The rest of it should go in the /proc code.
+   For now, we just use it to give verbose boot logs. */
+
+static int __init nubus_show_display_resource(struct nubus_dev* dev,
+					      const struct nubus_dirent* ent)
+{
+	switch (ent->type) {
+	case NUBUS_RESID_GAMMADIR:
+		printk(KERN_INFO "    gamma directory offset: 0x%06x\n", ent->data);
+		break;
+	case 0x0080 ... 0x0085:
+		printk(KERN_INFO "    mode %02X info offset: 0x%06x\n",
+		       ent->type, ent->data);
+		break;
+	default:
+		printk(KERN_INFO "    unknown resource %02X, data 0x%06x\n",
+		       ent->type, ent->data);
+	}
+	return 0;
+}
+
+static int __init nubus_show_network_resource(struct nubus_dev* dev,
+					      const struct nubus_dirent* ent)
+{
+	switch (ent->type) {
+	case NUBUS_RESID_MAC_ADDRESS:
+	{
+		char addr[6];
+		int i;
+		
+		nubus_get_rsrc_mem(addr, ent, 6);
+		printk(KERN_INFO "    MAC address: ");
+		for (i = 0; i < 6; i++)
+			printk("%02x%s", addr[i] & 0xff,
+			       i == 5 ? "" : ":");
+		printk("\n");
+		break;
+	}
+	default:
+		printk(KERN_INFO "    unknown resource %02X, data 0x%06x\n",
+		       ent->type, ent->data);
+	}
+	return 0;
+}
+
+static int __init nubus_show_cpu_resource(struct nubus_dev* dev,
+					  const struct nubus_dirent* ent)
+{
+	switch (ent->type) {
+	case NUBUS_RESID_MEMINFO:
+	{
+		unsigned long meminfo[2];
+		nubus_get_rsrc_mem(&meminfo, ent, 8);
+		printk(KERN_INFO "    memory: [ 0x%08lx 0x%08lx ]\n",
+		       meminfo[0], meminfo[1]);
+		break;
+	}
+	case NUBUS_RESID_ROMINFO:
+	{
+		unsigned long rominfo[2];
+		nubus_get_rsrc_mem(&rominfo, ent, 8);
+		printk(KERN_INFO "    ROM:    [ 0x%08lx 0x%08lx ]\n",
+		       rominfo[0], rominfo[1]);
+		break;
+	}
+	default:
+		printk(KERN_INFO "    unknown resource %02X, data 0x%06x\n",
+		       ent->type, ent->data);
+	}
+	return 0;
+}
+
+static int __init nubus_show_private_resource(struct nubus_dev* dev,
+					      const struct nubus_dirent* ent)
+{
+	switch (dev->category) {
+	case NUBUS_CAT_DISPLAY:
+		nubus_show_display_resource(dev, ent);
+		break;
+	case NUBUS_CAT_NETWORK:
+		nubus_show_network_resource(dev, ent);
+		break;
+	case NUBUS_CAT_CPU:
+		nubus_show_cpu_resource(dev, ent);
+		break;
+	default:
+		printk(KERN_INFO "    unknown resource %02X, data 0x%06x\n",
+		       ent->type, ent->data);
+	}
+	return 0;
+}
+
+static struct nubus_dev* __init
+	   nubus_get_functional_resource(struct nubus_board* board,
+					 int slot,
+					 const struct nubus_dirent* parent)
+{
+	struct nubus_dir    dir;
+	struct nubus_dirent ent;
+	struct nubus_dev*   dev;
+	
+	printk(KERN_INFO "  Function 0x%02x:\n", parent->type);
+	nubus_get_subdir(parent, &dir);
+
+	/* Apple seems to have botched the ROM on the IIx */
+	if (slot == 0 && (unsigned long)dir.base % 2)
+		dir.base += 1;
+	
+	if (console_loglevel >= 10)
+		printk(KERN_DEBUG "nubus_get_functional_resource: parent is 0x%p, dir is 0x%p\n",
+		       parent->base, dir.base);
+
+	/* Actually we should probably panic if this fails */
+	if ((dev = kmalloc(sizeof(*dev), GFP_ATOMIC)) == NULL)
+		return NULL;	
+	memset(dev, 0, sizeof(*dev));
+	dev->resid = parent->type;
+	dev->directory = dir.base;
+	dev->board = board;
+	
+	while (nubus_readdir(&dir, &ent) != -1)
+	{
+		switch(ent.type)
+		{
+		case NUBUS_RESID_TYPE:
+		{
+			unsigned short nbtdata[4];
+			nubus_get_rsrc_mem(nbtdata, &ent, 8);
+			dev->category = nbtdata[0];
+			dev->type     = nbtdata[1];
+			dev->dr_sw    = nbtdata[2];
+			dev->dr_hw    = nbtdata[3];
+			printk(KERN_INFO "    type: [cat 0x%x type 0x%x hw 0x%x sw 0x%x]\n",
+			       nbtdata[0], nbtdata[1], nbtdata[2], nbtdata[3]);
+			break;
+		}
+		case NUBUS_RESID_NAME:
+		{
+			nubus_get_rsrc_str(dev->name, &ent, 64);
+			printk(KERN_INFO "    name: %s\n", dev->name);
+			break;
+		}
+		case NUBUS_RESID_DRVRDIR:
+		{
+			/* MacOS driver.  If we were NetBSD we might
+			   use this :-) */
+			struct nubus_dir drvr_dir;
+			struct nubus_dirent drvr_ent;
+			nubus_get_subdir(&ent, &drvr_dir);
+			nubus_readdir(&drvr_dir, &drvr_ent);
+			dev->driver = nubus_dirptr(&drvr_ent);
+			printk(KERN_INFO "    driver at: 0x%p\n",
+			       dev->driver);
+			break;
+		}
+		case NUBUS_RESID_MINOR_BASEOS:
+			/* We will need this in order to support
+			   multiple framebuffers.  It might be handy
+			   for Ethernet as well */
+			nubus_get_rsrc_mem(&dev->iobase, &ent, 4);
+			printk(KERN_INFO "    memory offset: 0x%08lx\n",
+			       dev->iobase);
+			break;
+		case NUBUS_RESID_MINOR_LENGTH:
+			/* Ditto */
+			nubus_get_rsrc_mem(&dev->iosize, &ent, 4);
+			printk(KERN_INFO "    memory length: 0x%08lx\n",
+			       dev->iosize);
+			break;			
+		case NUBUS_RESID_FLAGS:
+			dev->flags = ent.data;
+			printk(KERN_INFO "    flags: 0x%06x\n", dev->flags);
+			break;
+		case NUBUS_RESID_HWDEVID:
+			dev->hwdevid = ent.data;
+			printk(KERN_INFO "    hwdevid: 0x%06x\n", dev->hwdevid);
+			break;
+		default:
+			/* Local/Private resources have their own
+			   function */
+			nubus_show_private_resource(dev, &ent);
+		}
+	}
+		
+	return dev;
+}
+
+/* This is cool. */
+static int __init nubus_get_vidnames(struct nubus_board* board,
+				     const struct nubus_dirent* parent)
+{
+	struct nubus_dir    dir;
+	struct nubus_dirent ent;
+	/* FIXME: obviously we want to put this in a header file soon */
+	struct vidmode {
+		u32 size;
+		/* Don't know what this is yet */
+		u16 id;
+		/* Longest one I've seen so far is 26 characters */
+		char name[32];
+	};
+
+	printk(KERN_INFO "    video modes supported:\n");
+	nubus_get_subdir(parent, &dir);
+	if (console_loglevel >= 10)
+		printk(KERN_DEBUG "nubus_get_vidnames: parent is 0x%p, dir is 0x%p\n",
+		       parent->base, dir.base);
+
+	while(nubus_readdir(&dir, &ent) != -1)
+	{
+		struct vidmode mode;
+		u32 size;
+
+		/* First get the length */
+		nubus_get_rsrc_mem(&size, &ent, 4);
+		
+		/* Now clobber the whole thing */
+		if (size > sizeof(mode) - 1)
+			size = sizeof(mode) - 1;
+		memset(&mode, 0, sizeof(mode));
+		nubus_get_rsrc_mem(&mode, &ent, size);
+		printk (KERN_INFO "      %02X: (%02X) %s\n", ent.type,
+			mode.id, mode.name);
+	}
+	return 0;
+}
+
+/* This is *really* cool. */
+static int __init nubus_get_icon(struct nubus_board* board,
+				 const struct nubus_dirent* ent)
+{
+	/* Should be 32x32 if my memory serves me correctly */
+	unsigned char icon[128];
+	int x, y;
+	
+	nubus_get_rsrc_mem(&icon, ent, 128);
+	printk(KERN_INFO "    icon:\n");
+
+	/* We should actually plot these somewhere in the framebuffer
+	   init.  This is just to demonstrate that they do, in fact,
+	   exist */
+	for (y = 0; y < 32; y++) {
+		printk(KERN_INFO "      ");
+		for (x = 0; x < 32; x++) {
+			if (icon[y*4 + x/8]
+			    & (0x80 >> (x%8)))
+				printk("*");
+			else
+				printk(" ");
+		}
+		printk("\n");
+	}
+	return 0;
+}
+
+static int __init nubus_get_vendorinfo(struct nubus_board* board,
+				       const struct nubus_dirent* parent)
+{
+	struct nubus_dir    dir;
+	struct nubus_dirent ent;
+	static char* vendor_fields[6] = {"ID", "serial", "revision",
+					 "part", "date", "unknown field"};
+
+	printk(KERN_INFO "    vendor info:\n");
+	nubus_get_subdir(parent, &dir);
+	if (console_loglevel >= 10)
+		printk(KERN_DEBUG "nubus_get_vendorinfo: parent is 0x%p, dir is 0x%p\n",
+		       parent->base, dir.base);
+
+	while(nubus_readdir(&dir, &ent) != -1)
+	{
+		char name[64];
+		
+		/* These are all strings, we think */
+		nubus_get_rsrc_str(name, &ent, 64);
+		if (ent.type > 5)
+			ent.type = 5;
+		printk(KERN_INFO "    %s: %s\n",
+		       vendor_fields[ent.type-1], name);
+	}
+	return 0;
+}
+
+static int __init nubus_get_board_resource(struct nubus_board* board, int slot,
+					   const struct nubus_dirent* parent)
+{
+	struct nubus_dir    dir;
+	struct nubus_dirent ent;
+	
+	nubus_get_subdir(parent, &dir);
+	if (console_loglevel >= 10)
+		printk(KERN_DEBUG "nubus_get_board_resource: parent is 0x%p, dir is 0x%p\n",
+		       parent->base, dir.base);
+
+	while(nubus_readdir(&dir, &ent) != -1)
+	{
+		switch (ent.type) {
+		case NUBUS_RESID_TYPE:
+		{
+			unsigned short nbtdata[4];
+			/* This type is always the same, and is not
+			   useful except insofar as it tells us that
+			   we really are looking at a board resource. */
+			nubus_get_rsrc_mem(nbtdata, &ent, 8);
+			printk(KERN_INFO "    type: [cat 0x%x type 0x%x hw 0x%x sw 0x%x]\n",
+			       nbtdata[0], nbtdata[1], nbtdata[2],
+			       nbtdata[3]);
+			if (nbtdata[0] != 1 || nbtdata[1] != 0 ||
+			    nbtdata[2] != 0 || nbtdata[3] != 0)
+				printk(KERN_ERR "this sResource is not a board resource!\n");
+			break;
+		}
+		case NUBUS_RESID_NAME:
+			nubus_get_rsrc_str(board->name, &ent, 64);
+			printk(KERN_INFO "    name: %s\n", board->name);
+			break;
+		case NUBUS_RESID_ICON:
+			nubus_get_icon(board, &ent);
+			break;
+		case NUBUS_RESID_BOARDID:
+			printk(KERN_INFO "    board id: 0x%x\n", ent.data);
+			break;
+		case NUBUS_RESID_PRIMARYINIT:
+			printk(KERN_INFO "    primary init offset: 0x%06x\n", ent.data);
+			break;
+		case NUBUS_RESID_VENDORINFO:
+			nubus_get_vendorinfo(board, &ent);
+			break;
+		case NUBUS_RESID_FLAGS:
+			printk(KERN_INFO "    flags: 0x%06x\n", ent.data);
+			break;
+		case NUBUS_RESID_HWDEVID:
+			printk(KERN_INFO "    hwdevid: 0x%06x\n", ent.data);
+			break;
+		case NUBUS_RESID_SECONDINIT:
+			printk(KERN_INFO "    secondary init offset: 0x%06x\n", ent.data);
+			break;
+			/* WTF isn't this in the functional resources? */ 
+		case NUBUS_RESID_VIDNAMES:
+			nubus_get_vidnames(board, &ent);
+			break;
+			/* Same goes for this */
+		case NUBUS_RESID_VIDMODES:
+			printk(KERN_INFO "    video mode parameter directory offset: 0x%06x\n",
+			       ent.data);
+			break;			
+		default:
+			printk(KERN_INFO "    unknown resource %02X, data 0x%06x\n",
+			       ent.type, ent.data);
+		}
+	}
+	return 0;
+}
+
+/* Attempt to bypass the somewhat non-obvious arrangement of
+   sResources in the motherboard ROM */
+static void __init nubus_find_rom_dir(struct nubus_board* board)
+{
+	unsigned char* rp;
+	unsigned char* romdir;
+	struct nubus_dir dir;
+	struct nubus_dirent ent;
+
+	/* Check for the extra directory just under the format block */
+	rp = board->fblock;
+	nubus_rewind(&rp, 4, board->lanes);
+	if (nubus_get_rom(&rp, 4, board->lanes) != NUBUS_TEST_PATTERN) {
+		/* OK, the ROM was telling the truth */
+		board->directory = board->fblock;
+		nubus_move(&board->directory,
+			   nubus_expand32(board->doffset),
+			   board->lanes);
+		return;
+	}
+
+	/* On "slot zero", you have to walk down a few more
+	   directories to get to the equivalent of a real card's root
+	   directory.  We don't know what they were smoking when they
+	   came up with this. */
+	romdir = nubus_rom_addr(board->slot);
+	nubus_rewind(&romdir, ROM_DIR_OFFSET, board->lanes);
+	dir.base = dir.ptr = romdir;
+	dir.done = 0;
+	dir.mask = board->lanes;
+
+	/* This one points to an "Unknown Macintosh" directory */
+	if (nubus_readdir(&dir, &ent) == -1)
+		goto badrom;
+
+	if (console_loglevel >= 10)
+		printk(KERN_INFO "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);
+	/* This one takes us to where we want to go. */
+	if (nubus_readdir(&dir, &ent) == -1) 
+		goto badrom;
+	if (console_loglevel >= 10)
+		printk(KERN_DEBUG "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);
+	nubus_get_subdir(&ent, &dir);
+
+	/* Resource ID 01, also an "Unknown Macintosh" */
+	if (nubus_readdir(&dir, &ent) == -1) 
+		goto badrom;
+	if (console_loglevel >= 10)
+		printk(KERN_DEBUG "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);
+
+	/* FIXME: the first one is *not* always the right one.  We
+	   suspect this has something to do with the ROM revision.
+	   "The HORROR ROM" (LC-series) uses 0x7e, while "The HORROR
+	   Continues" (Q630) uses 0x7b.  The DAFB Macs evidently use
+	   something else.  Please run "Slots" on your Mac (see
+	   include/linux/nubus.h for where to get this program) and
+	   tell us where the 'SiDirPtr' for Slot 0 is.  If you feel
+	   brave, you should also use MacsBug to walk down the ROM
+	   directories like this function does and try to find the
+	   path to that address... */
+	if (nubus_readdir(&dir, &ent) == -1)
+		goto badrom;
+	if (console_loglevel >= 10)
+		printk(KERN_DEBUG "nubus_get_rom_dir: entry %02x %06x\n", ent.type, ent.data);
+	
+	/* Bwahahahaha... */
+	nubus_get_subdir(&ent, &dir);
+	board->directory = dir.base;
+	return;
+	
+	/* Even more evil laughter... */
+ badrom:
+	board->directory = board->fblock;
+	nubus_move(&board->directory, nubus_expand32(board->doffset), board->lanes);
+	printk(KERN_ERR "nubus_get_rom_dir: ROM weirdness!  Notify the developers...\n");
+}
+
+/* Add a board (might be many devices) to the list */
+static struct nubus_board* __init nubus_add_board(int slot, int bytelanes)
+{
+	struct nubus_board* board;
+	struct nubus_board** boardp;
+
+	unsigned char *rp;
+	unsigned long dpat;
+	struct nubus_dir dir;
+	struct nubus_dirent ent;
+
+	/* Move to the start of the format block */
+	rp = nubus_rom_addr(slot);		
+	nubus_rewind(&rp, FORMAT_BLOCK_SIZE, bytelanes);
+
+	/* Actually we should probably panic if this fails */
+	if ((board = kmalloc(sizeof(*board), GFP_ATOMIC)) == NULL)
+		return NULL;	
+	memset(board, 0, sizeof(*board));
+	board->fblock = rp;
+
+	/* Dump the format block for debugging purposes */
+	if (console_loglevel >= 10) {
+		int i;
+		printk(KERN_DEBUG "Slot %X, format block at 0x%p\n",
+		       slot, rp);
+		printk(KERN_DEBUG "Format block: ");
+		for (i = 0; i < FORMAT_BLOCK_SIZE; i += 4) {
+			unsigned short foo, bar;
+			foo = nubus_get_rom(&rp, 2, bytelanes);
+			bar = nubus_get_rom(&rp, 2, bytelanes);
+			printk("%04x %04x  ", foo, bar);
+		}
+		printk("\n");
+		rp = board->fblock;
+	}
+	
+	board->slot = slot;
+	board->slot_addr = (unsigned long) nubus_slot_addr(slot);
+	board->doffset = nubus_get_rom(&rp, 4, bytelanes);
+	/* rom_length is *supposed* to be the total length of the
+	 * ROM.  In practice it is the "amount of ROM used to compute
+	 * the CRC."  So some jokers decide to set it to zero and
+	 * set the crc to zero so they don't have to do any math.
+	 * See the Performa 460 ROM, for example.  Those Apple "engineers".
+	 */
+	board->rom_length = nubus_get_rom(&rp, 4, bytelanes);
+	board->crc = nubus_get_rom(&rp, 4, bytelanes);
+	board->rev = nubus_get_rom(&rp, 1, bytelanes);
+	board->format = nubus_get_rom(&rp,1, bytelanes);
+	board->lanes = bytelanes;
+
+	/* Directory offset should be small and negative... */
+	if(!(board->doffset & 0x00FF0000))
+		printk(KERN_WARNING "Dodgy doffset!\n");
+	dpat = nubus_get_rom(&rp, 4, bytelanes);
+	if(dpat != NUBUS_TEST_PATTERN)
+		printk(KERN_WARNING "Wrong test pattern %08lx!\n", dpat);
+		
+	/*
+	 *	I wonder how the CRC is meant to work -
+	 *		any takers ?
+	 * CSA: According to MAC docs, not all cards pass the CRC anyway,
+	 * since the initial Macintosh ROM releases skipped the check.
+	 */
+
+	/* Attempt to work around slot zero weirdness */
+	nubus_find_rom_dir(board);
+	nubus_get_root_dir(board, &dir);	
+
+	/* We're ready to rock */
+	printk(KERN_INFO "Slot %X:\n", slot);
+
+	/* Each slot should have one board resource and any number of
+	   functional resources.  So we'll fill in some fields in the
+	   struct nubus_board from the board resource, then walk down
+	   the list of functional resources, spinning out a nubus_dev
+	   for each of them. */
+	if (nubus_readdir(&dir, &ent) == -1) {
+		/* We can't have this! */
+		printk(KERN_ERR "Board resource not found!\n");
+		return NULL;
+	} else {
+		printk(KERN_INFO "  Board resource:\n");
+		nubus_get_board_resource(board, slot, &ent);
+	}
+
+	/* Aaaarrrrgghh!  The LC III motherboard has *two* board
+	   resources.  I have no idea WTF to do about this. */
+
+	while (nubus_readdir(&dir, &ent) != -1) {
+		struct nubus_dev*  dev;
+		struct nubus_dev** devp;
+		dev = nubus_get_functional_resource(board, slot, &ent);
+		if (dev == NULL)
+			continue;
+
+		/* We zeroed this out above */
+		if (board->first_dev == NULL)
+			board->first_dev = dev;
+		
+		/* Put it on the global NuBus device chain. Keep entries in order. */
+		for (devp=&nubus_devices; *devp!=NULL; devp=&((*devp)->next))
+			/* spin */;
+		*devp = dev;
+		dev->next = NULL;		
+	}
+
+	/* Put it on the global NuBus board chain. Keep entries in order. */
+	for (boardp=&nubus_boards; *boardp!=NULL; boardp=&((*boardp)->next))
+		/* spin */;
+	*boardp = board;
+	board->next = NULL;
+	
+	return board;
+}
+
+void __init nubus_probe_slot(int slot)
+{
+	unsigned char dp;
+	unsigned char* rp;
+	int i;
+
+	rp = nubus_rom_addr(slot);	
+	for(i = 4; i; i--)
+	{
+		unsigned long flags;
+		int card_present;
+
+		rp--;
+		local_irq_save(flags);
+		card_present = hwreg_present(rp);
+		local_irq_restore(flags);
+	       
+		if (!card_present)
+			continue;
+
+		printk(KERN_DEBUG "Now probing slot %X at %p\n", slot, rp);
+		dp = *rp;
+		if(dp == 0)
+			continue;
+
+		/* The last byte of the format block consists of two
+		   nybbles which are "mirror images" of each other.
+		   These show us the valid bytelanes */
+		if ((((dp>>4) ^ dp) & 0x0F) != 0x0F)
+			continue;
+		/* Check that this value is actually *on* one of the
+		   bytelanes it claims are valid! */
+		if ((dp & 0x0F) >= (1<<i))
+			continue;
+
+		/* Looks promising.  Let's put it on the list. */
+		nubus_add_board(slot, dp);
+
+		return;
+	}
+}
+
+#if defined(CONFIG_PROC_FS)
+
+/* /proc/nubus stuff */
+
+static int sprint_nubus_board(struct nubus_board* board, char* ptr, int len)
+{
+	if(len < 100)
+		return -1;
+	
+	sprintf(ptr, "Slot %X: %s\n",
+		board->slot, board->name);
+	
+	return strlen(ptr);
+}
+
+static int nubus_read_proc(char *page, char **start, off_t off,
+				int count, int *eof, void *data)
+{
+	int nprinted, len, begin = 0;
+	int size = PAGE_SIZE;
+	struct nubus_board* board;
+	
+	len   = sprintf(page, "Nubus devices found:\n");
+	/* Walk the list of NuBus boards */
+	for (board = nubus_boards; board != NULL; board = board->next)
+	{
+		nprinted = sprint_nubus_board(board, page + len, size - len);
+		if (nprinted < 0)
+			break;
+		len += nprinted;
+		if (len+begin < off) {
+			begin += len;
+			len = 0;
+		}
+		if (len+begin >= off+count)
+			break;
+	}
+	if (len+begin < off)
+		*eof = 1;
+	off -= begin;
+	*start = page + off;
+	len -= off;
+	if (len>count)
+		len = count;
+	if (len<0)
+		len = 0;
+	return len;
+}
+#endif
+
+void __init nubus_scan_bus(void)
+{
+	int slot;
+	/* This might not work on your machine */
+#ifdef I_WANT_TO_PROBE_SLOT_ZERO
+	nubus_probe_slot(0);
+#endif
+	for(slot = 9; slot < 15; slot++)
+	{
+		nubus_probe_slot(slot);
+	}
+}
+
+static int __init nubus_init(void)
+{
+	if (!MACH_IS_MAC) 
+		return 0;
+
+	/* Initialize the NuBus interrupts */
+	if (oss_present) {
+		oss_nubus_init();
+	} else {
+		via_nubus_init();
+	}
+
+#ifdef TRY_TO_DODGE_WSOD
+	/* Rogue Ethernet interrupts can kill the machine if we don't
+	   do this.  Obviously this is bogus.  Hopefully the local VIA
+	   gurus can fix the real cause of the problem. */
+	mdelay(1000);
+#endif
+	
+	/* And probe */
+	printk("NuBus: Scanning NuBus slots.\n");
+	nubus_devices = NULL;
+	nubus_boards  = NULL;
+	nubus_scan_bus();
+
+#ifdef CONFIG_PROC_FS
+	create_proc_read_entry("nubus", 0, NULL, nubus_read_proc, NULL);
+	nubus_proc_init();
+#endif
+	return 0;
+}
+
+subsys_initcall(nubus_init);
