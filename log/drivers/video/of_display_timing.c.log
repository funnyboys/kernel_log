commit 892e8ba38f28d68a17122a9e14cf36ea756aa6b8
Author: Douglas Anderson <dianders@chromium.org>
Date:   Mon Jul 22 11:24:37 2019 -0700

    video: of: display_timing: Don't yell if no timing node is present
    
    There may be cases (like in panel-simple.c) where we have a sane
    fallback if no timings are specified in the device tree.  Let's get
    rid of the unconditional pr_err().  We can add error messages in
    individual drivers if it makes sense.
    
    NOTE: we'll still print errors if the node is present but there are
    problems parsing the timings.
    
    Fixes: b8a2948fa2b3 ("drm/panel: simple: Add ability to override typical timing")
    Reported-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190722182439.44844-3-dianders@chromium.org

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 5eedae0799f0..abc9ada798ee 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -125,10 +125,8 @@ int of_get_display_timing(const struct device_node *np, const char *name,
 		return -EINVAL;
 
 	timing_np = of_get_child_by_name(np, name);
-	if (!timing_np) {
-		pr_err("%pOF: could not find node '%s'\n", np, name);
+	if (!timing_np)
 		return -ENOENT;
-	}
 
 	ret = of_parse_display_timing(timing_np, dt);
 

commit 4faba50edbcc1df467f8f308893edc3fdd95536e
Author: Douglas Anderson <dianders@chromium.org>
Date:   Mon Jul 22 11:24:36 2019 -0700

    video: of: display_timing: Add of_node_put() in of_get_display_timing()
    
    From code inspection it can be seen that of_get_display_timing() is
    lacking an of_node_put().  Add it.
    
    Fixes: ffa3fd21de8a ("videomode: implement public of_get_display_timing()")
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190722182439.44844-2-dianders@chromium.org

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index f5c1c469c0af..5eedae0799f0 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -119,6 +119,7 @@ int of_get_display_timing(const struct device_node *np, const char *name,
 		struct display_timing *dt)
 {
 	struct device_node *timing_np;
+	int ret;
 
 	if (!np)
 		return -EINVAL;
@@ -129,7 +130,11 @@ int of_get_display_timing(const struct device_node *np, const char *name,
 		return -ENOENT;
 	}
 
-	return of_parse_display_timing(timing_np, dt);
+	ret = of_parse_display_timing(timing_np, dt);
+
+	of_node_put(timing_np);
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(of_get_display_timing);
 

commit 55716d26439f5c4008b0bcb7f17d1f7c0d8fbcfc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:42 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 428
    
    Based on 1 normalized pattern(s):
    
      this file is released under the gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 68 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190114.292346262@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index c2e7aa103fa5..f5c1c469c0af 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * OF helpers for parsing display timings
  *
  * Copyright (c) 2012 Steffen Trumtrar <s.trumtrar@pengutronix.de>, Pengutronix
  *
  * based on of_videomode.c by Sascha Hauer <s.hauer@pengutronix.de>
- *
- * This file is released under the GPLv2
  */
 #include <linux/export.h>
 #include <linux/of.h>

commit 5c63e407aaabb0464236cfc6279a2d79aede7073
Author: Rob Herring <robh@kernel.org>
Date:   Mon Oct 8 12:57:36 2018 +0200

    fbdev: Convert to using %pOFn instead of device_node.name
    
    In preparation to remove the node name pointer from struct device_node,
    convert printf users to use the %pOFn format specifier.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 5244e93ceafc..c2e7aa103fa5 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -170,7 +170,7 @@ struct display_timings *of_get_display_timings(const struct device_node *np)
 		goto entryfail;
 	}
 
-	pr_debug("%pOF: using %s as default timing\n", np, entry->name);
+	pr_debug("%pOF: using %pOFn as default timing\n", np, entry);
 
 	native_mode = entry;
 

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 83b8963c9657..5244e93ceafc 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -181,8 +181,9 @@ struct display_timings *of_get_display_timings(const struct device_node *np)
 		goto entryfail;
 	}
 
-	disp->timings = kzalloc(sizeof(struct display_timing *) *
-				disp->num_timings, GFP_KERNEL);
+	disp->timings = kcalloc(disp->num_timings,
+				sizeof(struct display_timing *),
+				GFP_KERNEL);
 	if (!disp->timings) {
 		pr_err("%pOF: could not allocate timings array\n", np);
 		goto entryfail;

commit a2a348014aad8bdf1466e027aa1dad2f099b7de6
Author: Vladimir Zapolskiy <vz@mleia.com>
Date:   Mon Mar 12 17:06:54 2018 +0100

    video: of: display_timing: Remove of_display_timings_exist() function
    
    Since introduction of of_display_timings_exist() function in commit
    cc3f414cf2e40 ("video: add of helper for display timings/videomode") it
    didn't attract any users, and the function has no potential, because
    of_get_display_timings() covers its functionality and does more.
    
    Drop the unused exported function from the kernel.
    
    Signed-off-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 8ce0a99bf17c..83b8963c9657 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -244,23 +244,3 @@ struct display_timings *of_get_display_timings(const struct device_node *np)
 	return NULL;
 }
 EXPORT_SYMBOL_GPL(of_get_display_timings);
-
-/**
- * of_display_timings_exist - check if a display-timings node is provided
- * @np: device_node with the timing
- **/
-int of_display_timings_exist(const struct device_node *np)
-{
-	struct device_node *timings_np;
-
-	if (!np)
-		return -EINVAL;
-
-	timings_np = of_parse_phandle(np, "display-timings", 0);
-	if (!timings_np)
-		return -EINVAL;
-
-	of_node_put(timings_np);
-	return 1;
-}
-EXPORT_SYMBOL_GPL(of_display_timings_exist);

commit 6d7e653300e30fd433a845c8c9f48557e799a8de
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 7 17:22:13 2017 +0200

    video: fbdev: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 32b0a7543433..8ce0a99bf17c 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -31,8 +31,7 @@ static int parse_timing_property(const struct device_node *np, const char *name,
 
 	prop = of_find_property(np, name, &length);
 	if (!prop) {
-		pr_err("%s: could not find property %s\n",
-			of_node_full_name(np), name);
+		pr_err("%pOF: could not find property %s\n", np, name);
 		return -EINVAL;
 	}
 
@@ -44,8 +43,7 @@ static int parse_timing_property(const struct device_node *np, const char *name,
 	} else if (cells == 3) {
 		ret = of_property_read_u32_array(np, name, &result->min, cells);
 	} else {
-		pr_err("%s: illegal timing specification in %s\n",
-			of_node_full_name(np), name);
+		pr_err("%pOF: illegal timing specification in %s\n", np, name);
 		return -EINVAL;
 	}
 
@@ -105,8 +103,7 @@ static int of_parse_display_timing(const struct device_node *np,
 		dt->flags |= DISPLAY_FLAGS_DOUBLECLK;
 
 	if (ret) {
-		pr_err("%s: error reading timing properties\n",
-			of_node_full_name(np));
+		pr_err("%pOF: error reading timing properties\n", np);
 		return -EINVAL;
 	}
 
@@ -129,8 +126,7 @@ int of_get_display_timing(const struct device_node *np, const char *name,
 
 	timing_np = of_get_child_by_name(np, name);
 	if (!timing_np) {
-		pr_err("%s: could not find node '%s'\n",
-			of_node_full_name(np), name);
+		pr_err("%pOF: could not find node '%s'\n", np, name);
 		return -ENOENT;
 	}
 
@@ -154,15 +150,13 @@ struct display_timings *of_get_display_timings(const struct device_node *np)
 
 	timings_np = of_get_child_by_name(np, "display-timings");
 	if (!timings_np) {
-		pr_err("%s: could not find display-timings node\n",
-			of_node_full_name(np));
+		pr_err("%pOF: could not find display-timings node\n", np);
 		return NULL;
 	}
 
 	disp = kzalloc(sizeof(*disp), GFP_KERNEL);
 	if (!disp) {
-		pr_err("%s: could not allocate struct disp'\n",
-			of_node_full_name(np));
+		pr_err("%pOF: could not allocate struct disp'\n", np);
 		goto dispfail;
 	}
 
@@ -172,28 +166,25 @@ struct display_timings *of_get_display_timings(const struct device_node *np)
 		entry = of_get_next_child(timings_np, NULL);
 	/* if there is no child, it is useless to go on */
 	if (!entry) {
-		pr_err("%s: no timing specifications given\n",
-			of_node_full_name(np));
+		pr_err("%pOF: no timing specifications given\n", np);
 		goto entryfail;
 	}
 
-	pr_debug("%s: using %s as default timing\n",
-		of_node_full_name(np), entry->name);
+	pr_debug("%pOF: using %s as default timing\n", np, entry->name);
 
 	native_mode = entry;
 
 	disp->num_timings = of_get_child_count(timings_np);
 	if (disp->num_timings == 0) {
 		/* should never happen, as entry was already found above */
-		pr_err("%s: no timings specified\n", of_node_full_name(np));
+		pr_err("%pOF: no timings specified\n", np);
 		goto entryfail;
 	}
 
 	disp->timings = kzalloc(sizeof(struct display_timing *) *
 				disp->num_timings, GFP_KERNEL);
 	if (!disp->timings) {
-		pr_err("%s: could not allocate timings array\n",
-			of_node_full_name(np));
+		pr_err("%pOF: could not allocate timings array\n", np);
 		goto entryfail;
 	}
 
@@ -206,8 +197,8 @@ struct display_timings *of_get_display_timings(const struct device_node *np)
 
 		dt = kzalloc(sizeof(*dt), GFP_KERNEL);
 		if (!dt) {
-			pr_err("%s: could not allocate display_timing struct\n",
-					of_node_full_name(np));
+			pr_err("%pOF: could not allocate display_timing struct\n",
+				np);
 			goto timingfail;
 		}
 
@@ -217,8 +208,8 @@ struct display_timings *of_get_display_timings(const struct device_node *np)
 			 * to not encourage wrong devicetrees, fail in case of
 			 * an error
 			 */
-			pr_err("%s: error in timing %d\n",
-				of_node_full_name(np), disp->num_timings + 1);
+			pr_err("%pOF: error in timing %d\n",
+				np, disp->num_timings + 1);
 			kfree(dt);
 			goto timingfail;
 		}
@@ -236,8 +227,8 @@ struct display_timings *of_get_display_timings(const struct device_node *np)
 	 */
 	of_node_put(native_mode);
 
-	pr_debug("%s: got %d timings. Using timing #%d as default\n",
-		of_node_full_name(np), disp->num_timings,
+	pr_debug("%pOF: got %d timings. Using timing #%d as default\n",
+		np, disp->num_timings,
 		disp->native_mode + 1);
 
 	return disp;

commit 1a3865d64a0d8151c7fe23f4b57a587615ccc5bb
Merge: d8c1abd968f1 85e8f8d175ca
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Nov 16 09:39:21 2016 +1000

    Merge branch 'drm/next/du' of git://linuxtv.org/pinchartl/media into drm-next
    
    rcar-du -next branch.
    
    * 'drm/next/du' of git://linuxtv.org/pinchartl/media:
      drm: rcar-du: Fix LVDS start sequence on Gen3
      drm: rcar-du: Fix H/V sync signal polarity configuration
      drm: rcar-du: Fix display timing controller parameter
      drm: rcar-du: Fix dot clock routing configuration
      drm: rcar-du: Add R8A7796 support
      drm: rcar-du: Add R8A7792 support
      drm: rcar-du: Simplify and fix probe error handling
      drm: rcar-du: Fix crash in encoder failure error path
      drm: rcar-du: Remove memory allocation error message
      drm: rcar-du: Remove test for impossible error condition
      drm: rcar-du: Bring HDMI encoder comments in line with the driver
      drm: rcar-du: Constify node argument to rcar_du_lvds_connector_init()
      video: of: Constify node argument to display timing functions

commit f5a000c9f8c19608f19f16d01338f0738ce3757f
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Oct 3 16:55:48 2016 +0300

    video: of: Constify node argument to display timing functions
    
    The node pointer passed to the display timing functions is never
    modified, make it const.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 8a1076beecd3..26c88f7839d2 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -110,7 +110,7 @@ static int of_parse_display_timing(const struct device_node *np,
  * @name: name of the timing node
  * @dt: display_timing struct to fill
  **/
-int of_get_display_timing(struct device_node *np, const char *name,
+int of_get_display_timing(const struct device_node *np, const char *name,
 		struct display_timing *dt)
 {
 	struct device_node *timing_np;
@@ -133,7 +133,7 @@ EXPORT_SYMBOL_GPL(of_get_display_timing);
  * of_get_display_timings - parse all display_timing entries from a device_node
  * @np: device_node with the subnodes
  **/
-struct display_timings *of_get_display_timings(struct device_node *np)
+struct display_timings *of_get_display_timings(const struct device_node *np)
 {
 	struct device_node *timings_np;
 	struct device_node *entry;
@@ -249,7 +249,7 @@ EXPORT_SYMBOL_GPL(of_get_display_timings);
  * of_display_timings_exist - check if a display-timings node is provided
  * @np: device_node with the timing
  **/
-int of_display_timings_exist(struct device_node *np)
+int of_display_timings_exist(const struct device_node *np)
 {
 	struct device_node *timings_np;
 

commit bd9642b9b8d329bcb0b187aee34c89fc182f2c4d
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 22 13:35:26 2016 +0300

    video: of: display_timing: Add support for syncclk-active property
    
    Configure the DISPLAY_FLAGS_SYNC_POSEDGE/NEGEDGE flags according to the
    binding document.
    If the syncclk-active is present in DT, configure the flags accordingly, if
    it is omitted it means that the SYNC edge is following the pixdata
    configuration.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    CC: Rob Herring <robh+dt@kernel.org>
    CC: Mark Rutland <mark.rutland@arm.com>
    CC: devicetree@vger.kernel.org
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 8a1076beecd3..db992c684f09 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -88,6 +88,15 @@ static int of_parse_display_timing(const struct device_node *np,
 		dt->flags |= val ? DISPLAY_FLAGS_PIXDATA_POSEDGE :
 				DISPLAY_FLAGS_PIXDATA_NEGEDGE;
 
+	if (!of_property_read_u32(np, "syncclk-active", &val))
+		dt->flags |= val ? DISPLAY_FLAGS_SYNC_POSEDGE :
+				DISPLAY_FLAGS_SYNC_NEGEDGE;
+	else if (dt->flags & (DISPLAY_FLAGS_PIXDATA_POSEDGE |
+			      DISPLAY_FLAGS_PIXDATA_NEGEDGE))
+		dt->flags |= dt->flags & DISPLAY_FLAGS_PIXDATA_POSEDGE ?
+				DISPLAY_FLAGS_SYNC_POSEDGE :
+				DISPLAY_FLAGS_SYNC_NEGEDGE;
+
 	if (of_property_read_bool(np, "interlaced"))
 		dt->flags |= DISPLAY_FLAGS_INTERLACED;
 	if (of_property_read_bool(np, "doublescan"))

commit d663baba8b16f3097ac3fb5baf97c54970d2f1ff
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Sep 30 15:24:08 2015 +0530

    video: of: fix memory leak
    
    If of_parse_display_timing() fails we are printing an error message and
    jumping to the error path but we missed freeing "dt".
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 32d8275e4c88..8a1076beecd3 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -210,6 +210,7 @@ struct display_timings *of_get_display_timings(struct device_node *np)
 			 */
 			pr_err("%s: error in timing %d\n",
 				of_node_full_name(np), disp->num_timings + 1);
+			kfree(dt);
 			goto timingfail;
 		}
 

commit 0a582821d4f8edf41d9b56ae057ee2002fc275f0
Merge: 8a5de18239e4 33ac9dba859b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 18 18:03:02 2014 -0700

    Merge tag 'fbdev-3.18' of git://git.kernel.org/pub/scm/linux/kernel/git/tomba/linux
    
    Pull fbdev updates from Tomi Valkeinen:
     - new 6x10 font
     - various small fixes and cleanups
    
    * tag 'fbdev-3.18' of git://git.kernel.org/pub/scm/linux/kernel/git/tomba/linux: (30 commits)
      fonts: Add 6x10 font
      videomode: provide dummy inline functions for !CONFIG_OF
      video/atmel_lcdfb: Introduce regulator support
      fbdev: sh_mobile_hdmi: Re-init regs before irq re-enable on resume
      framebuffer: fix screen corruption when copying
      framebuffer: fix border color
      arm, fbdev, omap2, LLVMLinux: Remove nested function from omapfb
      arm, fbdev, omap2, LLVMLinux: Remove nested function from omap2 dss
      video: fbdev: valkyriefb.c: use container_of to resolve fb_info_valkyrie from fb_info
      video: fbdev: pxafb.c: use container_of to resolve pxafb_info/layer from fb_info
      video: fbdev: cyber2000fb.c: use container_of to resolve cfb_info from fb_info
      video: fbdev: controlfb.c: use container_of to resolve fb_info_control from fb_info
      video: fbdev: sa1100fb.c: use container_of to resolve sa1100fb_info from fb_info
      video: fbdev: stifb.c: use container_of to resolve stifb_info from fb_info
      video: fbdev: sis: sis_main.c: Cleaning up missing null-terminate in conjunction with strncpy
      video: valkyriefb: Fix unused variable warning in set_valkyrie_clock()
      video: fbdev: use %*ph specifier to dump small buffers
      video: mx3fb: always enable BACKLIGHT_LCD_SUPPORT
      video: fbdev: au1200fb: delete double assignment
      video: fbdev: sis: delete double assignment
      ...

commit 68ecfe2fe2e6c636bb7e2cf616e658e342e05362
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Aug 8 12:07:55 2014 +0200

    video: of: display_timing: delete unneeded test before of_node_put
    
    Of_node_put supports NULL as its argument, so the initial test is not
    necessary.  Furthermore, native_mode cannot be NULL at this point.
    
    Suggested by Uwe Kleine-KÃ¶nig.
    
    The semantic patch that fixes this problem is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression e;
    @@
    
    -if (e)
       of_node_put(e);
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 987edf110038..339f831c8412 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -233,8 +233,7 @@ struct display_timings *of_get_display_timings(struct device_node *np)
 	return disp;
 
 timingfail:
-	if (native_mode)
-		of_node_put(native_mode);
+	of_node_put(native_mode);
 	display_timings_release(disp);
 entryfail:
 	kfree(disp);

commit 62795a0d81970bfdd5866ffd87160c670a6b344c
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Jul 11 12:21:36 2014 +0300

    video: of: display_timing: double free on error
    
    The display_timings_release() function frees "disp" and we free it
    again on the next line.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 987edf110038..5c098d5b4043 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -236,6 +236,7 @@ struct display_timings *of_get_display_timings(struct device_node *np)
 	if (native_mode)
 		of_node_put(native_mode);
 	display_timings_release(disp);
+	disp = NULL;
 entryfail:
 	kfree(disp);
 dispfail:

commit 80c68c1e2e801a14d718f2ab9690398a864aa37c
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Fri May 9 15:53:12 2014 +0200

    video: of: display_timing: fix default native-mode setting
    
    Set native mode to the first child node of the display-timings node and not
    the first child node of the display-timings parent node.
    
    Signed-off-by: Boris BREZILLON <boris.brezillon@free-electrons.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 3dc93cfacd47..987edf110038 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -160,7 +160,7 @@ struct display_timings *of_get_display_timings(struct device_node *np)
 	entry = of_parse_phandle(timings_np, "native-mode", 0);
 	/* assume first child as native mode if none provided */
 	if (!entry)
-		entry = of_get_next_child(np, NULL);
+		entry = of_get_next_child(timings_np, NULL);
 	/* if there is no child, it is useless to go on */
 	if (!entry) {
 		pr_err("%s: no timing specifications given\n",

commit dc42715fafed88f44e01eadb965fafa3ceea72bc
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Tue May 13 14:58:21 2014 +0200

    video: of: display_timing: remove two unsafe error messages
    
    The error message would try to dereference the pointer that
    just has been tested to be NULL. As those messages don't
    really add any value without the info that the np could
    provide, just remove them.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index ba5b40f581f6..3dc93cfacd47 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -115,10 +115,8 @@ int of_get_display_timing(struct device_node *np, const char *name,
 {
 	struct device_node *timing_np;
 
-	if (!np) {
-		pr_err("%s: no devicenode given\n", of_node_full_name(np));
+	if (!np)
 		return -EINVAL;
-	}
 
 	timing_np = of_get_child_by_name(np, name);
 	if (!timing_np) {
@@ -142,10 +140,8 @@ struct display_timings *of_get_display_timings(struct device_node *np)
 	struct device_node *native_mode;
 	struct display_timings *disp;
 
-	if (!np) {
-		pr_err("%s: no device node given\n", of_node_full_name(np));
+	if (!np)
 		return NULL;
-	}
 
 	timings_np = of_get_child_by_name(np, "display-timings");
 	if (!timings_np) {

commit 60119a1d686702504fa4cbe666cbcb96744b175c
Author: Andrzej Hajda <a.hajda@samsung.com>
Date:   Wed Sep 25 13:51:31 2013 +0200

    video: of: display_timing: correct display-timings node finding
    
    of_get_display_timing(s) use of_find_node_by_name
    to get child node, this is incorrect, of_get_child_by_name
    should be used instead. The patch fixes it.
    Small typo is also corrected.
    
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 171821ddd78d..ba5b40f581f6 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -120,7 +120,7 @@ int of_get_display_timing(struct device_node *np, const char *name,
 		return -EINVAL;
 	}
 
-	timing_np = of_find_node_by_name(np, name);
+	timing_np = of_get_child_by_name(np, name);
 	if (!timing_np) {
 		pr_err("%s: could not find node '%s'\n",
 			of_node_full_name(np), name);
@@ -143,11 +143,11 @@ struct display_timings *of_get_display_timings(struct device_node *np)
 	struct display_timings *disp;
 
 	if (!np) {
-		pr_err("%s: no devicenode given\n", of_node_full_name(np));
+		pr_err("%s: no device node given\n", of_node_full_name(np));
 		return NULL;
 	}
 
-	timings_np = of_find_node_by_name(np, "display-timings");
+	timings_np = of_get_child_by_name(np, "display-timings");
 	if (!timings_np) {
 		pr_err("%s: could not find display-timings node\n",
 			of_node_full_name(np));

commit 2e17c5a97e231f3cb426f4b7895eab5be5c5442e
Merge: 5f097cd249f0 774d8e34e465
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 9 16:04:31 2013 -0700

    Merge branch 'drm-next' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm updates from Dave Airlie:
     "Okay this is the big one, I was stalled on the fbdev pull req as I
      stupidly let fbdev guys merge a patch I required to fix a warning with
      some patches I had, they ended up merging the patch from the wrong
      place, but the warning should be fixed.  In future I'll just take the
      patch myself!
    
      Outside drm:
    
      There are some snd changes for the HDMI audio interactions on haswell,
      they've been acked for inclusion via my tree.  This relies on the
      wound/wait tree from Ingo which is already merged.
    
      Major changes:
    
      AMD finally released the dynamic power management code for all their
      GPUs from r600->present day, this is great, off by default for now but
      also a huge amount of code, in fact it is most of this pull request.
    
      Since it landed there has been a lot of community testing and Alex has
      sent a lot of fixes for any bugs found so far.  I suspect radeon might
      now be the biggest kernel driver ever :-P p.s.  radeon.dpm=1 to enable
      dynamic powermanagement for anyone.
    
      New drivers:
    
      Renesas r-car display unit.
    
      Other highlights:
    
       - core: GEM CMA prime support, use new w/w mutexs for TTM
         reservations, cursor hotspot, doc updates
       - dvo chips: chrontel 7010B support
       - i915: Haswell (fbc, ips, vecs, watermarks, audio powerwell),
         Valleyview (enabled by default, rc6), lots of pll reworking, 30bpp
         support (this time for sure)
       - nouveau: async buffer object deletion, context/register init
         updates, kernel vp2 engine support, GF117 support, GK110 accel
         support (with external nvidia ucode), context cleanups.
       - exynos: memory leak fixes, Add S3C64XX SoC series support, device
         tree updates, common clock framework support,
       - qxl: cursor hotspot support, multi-monitor support, suspend/resume
         support
       - mgag200: hw cursor support, g200 mode limiting
       - shmobile: prime support
       - tegra: fixes mostly
    
      I've been banging on this quite a lot due to the size of it, and it
      seems to okay on everything I've tested it on."
    
    * 'drm-next' of git://people.freedesktop.org/~airlied/linux: (811 commits)
      drm/radeon/dpm: implement vblank_too_short callback for si
      drm/radeon/dpm: implement vblank_too_short callback for cayman
      drm/radeon/dpm: implement vblank_too_short callback for btc
      drm/radeon/dpm: implement vblank_too_short callback for evergreen
      drm/radeon/dpm: implement vblank_too_short callback for 7xx
      drm/radeon/dpm: add checks against vblank time
      drm/radeon/dpm: add helper to calculate vblank time
      drm/radeon: remove stray line in old pm code
      drm/radeon/dpm: fix display_gap programming on rv7xx
      drm/nvc0/gr: fix gpc firmware regression
      drm/nouveau: fix minor thinko causing bo moves to not be async on kepler
      drm/radeon/dpm: implement force performance level for TN
      drm/radeon/dpm: implement force performance level for ON/LN
      drm/radeon/dpm: implement force performance level for SI
      drm/radeon/dpm: implement force performance level for cayman
      drm/radeon/dpm: implement force performance levels for 7xx/eg/btc
      drm/radeon/dpm: add infrastructure to force performance levels
      drm/radeon: fix surface setup on r1xx
      drm/radeon: add support for 3d perf states on older asics
      drm/radeon: set default clocks for SI when DPM is disabled
      ...

commit 2d178a4abb33916fb8e1dea540921acdafe53875
Author: Steffen Trumtrar <s.trumtrar@pengutronix.de>
Date:   Mon May 27 12:33:34 2013 +0000

    video: of: display_timing: add doubleclk flag
    
    Signed-off-by: Steffen Trumtrar <s.trumtrar@pengutronix.de>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 85c1a419270f..2894e0300a33 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -98,6 +98,8 @@ static struct display_timing *of_get_display_timing(const struct device_node
 		dt->flags |= DISPLAY_FLAGS_INTERLACED;
 	if (of_property_read_bool(np, "doublescan"))
 		dt->flags |= DISPLAY_FLAGS_DOUBLESCAN;
+	if (of_property_read_bool(np, "doubleclk"))
+		dt->flags |= DISPLAY_FLAGS_DOUBLECLK;
 
 	if (ret) {
 		pr_err("%s: error reading timing properties\n",

commit f583662347c62d80ac916658ae491274621c88ca
Author: Steffen Trumtrar <s.trumtrar@pengutronix.de>
Date:   Mon May 27 12:33:05 2013 +0000

    video: display_timing: make parameter const
    
    As the device_node pointer is not changed in of_get_display_timing and
    parse_timing_property it can be a const pointer.
    
    Signed-off-by: Steffen Trumtrar <s.trumtrar@pengutronix.de>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 56009bc02b02..85c1a419270f 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -23,7 +23,7 @@
  * Every display_timing can be specified with either just the typical value or
  * a range consisting of min/typ/max. This function helps handling this
  **/
-static int parse_timing_property(struct device_node *np, const char *name,
+static int parse_timing_property(const struct device_node *np, const char *name,
 			  struct timing_entry *result)
 {
 	struct property *prop;
@@ -56,7 +56,8 @@ static int parse_timing_property(struct device_node *np, const char *name,
  * of_get_display_timing - parse display_timing entry from device_node
  * @np: device_node with the properties
  **/
-static struct display_timing *of_get_display_timing(struct device_node *np)
+static struct display_timing *of_get_display_timing(const struct device_node
+						    *np)
 {
 	struct display_timing *dt;
 	u32 val = 0;

commit ffa3fd21de8ab0db7962b612d4c6e17c0d88e9c2
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 16 15:36:38 2013 +0300

    videomode: implement public of_get_display_timing()
    
    The current of_get_display_timings() reads multiple display timings,
    allocating memory for the entries. However, most of the time when
    parsing display timings from DT data is needed, there's only one display
    timing as it's not common for a LCD panel to support multiple videomodes.
    
    This patch creates a new function:
    
    int of_get_display_timing(struct device_node *np, const char *name,
                   struct display_timing *dt);
    
    which can be used to parse a single display timing entry from the given
    node name.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Steffen Trumtrar <s.trumtrar@pengutronix.de>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 0e8102344b2e..9c0f17b2e6fb 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -53,10 +53,10 @@ static int parse_timing_property(struct device_node *np, const char *name,
 }
 
 /**
- * of_get_display_timing - parse display_timing entry from device_node
+ * of_parse_display_timing - parse display_timing entry from device_node
  * @np: device_node with the properties
  **/
-static int of_get_display_timing(struct device_node *np,
+static int of_parse_display_timing(struct device_node *np,
 		struct display_timing *dt)
 {
 	u32 val = 0;
@@ -102,6 +102,33 @@ static int of_get_display_timing(struct device_node *np,
 	return 0;
 }
 
+/**
+ * of_get_display_timing - parse a display_timing entry
+ * @np: device_node with the timing subnode
+ * @name: name of the timing node
+ * @dt: display_timing struct to fill
+ **/
+int of_get_display_timing(struct device_node *np, const char *name,
+		struct display_timing *dt)
+{
+	struct device_node *timing_np;
+
+	if (!np) {
+		pr_err("%s: no devicenode given\n", of_node_full_name(np));
+		return -EINVAL;
+	}
+
+	timing_np = of_find_node_by_name(np, name);
+	if (!timing_np) {
+		pr_err("%s: could not find node '%s'\n",
+			of_node_full_name(np), name);
+		return -ENOENT;
+	}
+
+	return of_parse_display_timing(timing_np, dt);
+}
+EXPORT_SYMBOL_GPL(of_get_display_timing);
+
 /**
  * of_get_display_timings - parse all display_timing entries from a device_node
  * @np: device_node with the subnodes
@@ -177,7 +204,7 @@ struct display_timings *of_get_display_timings(struct device_node *np)
 			goto timingfail;
 		}
 
-		r = of_get_display_timing(entry, dt);
+		r = of_parse_display_timing(entry, dt);
 		if (r) {
 			/*
 			 * to not encourage wrong devicetrees, fail in case of

commit fcf7e6e5bd84b561eca4f7977c2a547f724f5942
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu May 16 15:29:06 2013 +0300

    videomode: don't allocate mem in of_get_display_timing()
    
    Move the allocation of display_timing memory from of_get_display_timing() to
    of_get_display_timings(). This allows us to use of_get_display_timing()
    in a way that doesn't require dynamic memory allocation.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Steffen Trumtrar <s.trumtrar@pengutronix.de>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 56009bc02b02..0e8102344b2e 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -56,18 +56,13 @@ static int parse_timing_property(struct device_node *np, const char *name,
  * of_get_display_timing - parse display_timing entry from device_node
  * @np: device_node with the properties
  **/
-static struct display_timing *of_get_display_timing(struct device_node *np)
+static int of_get_display_timing(struct device_node *np,
+		struct display_timing *dt)
 {
-	struct display_timing *dt;
 	u32 val = 0;
 	int ret = 0;
 
-	dt = kzalloc(sizeof(*dt), GFP_KERNEL);
-	if (!dt) {
-		pr_err("%s: could not allocate display_timing struct\n",
-			of_node_full_name(np));
-		return NULL;
-	}
+	memset(dt, 0, sizeof(*dt));
 
 	ret |= parse_timing_property(np, "hback-porch", &dt->hback_porch);
 	ret |= parse_timing_property(np, "hfront-porch", &dt->hfront_porch);
@@ -101,11 +96,10 @@ static struct display_timing *of_get_display_timing(struct device_node *np)
 	if (ret) {
 		pr_err("%s: error reading timing properties\n",
 			of_node_full_name(np));
-		kfree(dt);
-		return NULL;
+		return -EINVAL;
 	}
 
-	return dt;
+	return 0;
 }
 
 /**
@@ -174,9 +168,17 @@ struct display_timings *of_get_display_timings(struct device_node *np)
 
 	for_each_child_of_node(timings_np, entry) {
 		struct display_timing *dt;
+		int r;
 
-		dt = of_get_display_timing(entry);
+		dt = kzalloc(sizeof(*dt), GFP_KERNEL);
 		if (!dt) {
+			pr_err("%s: could not allocate display_timing struct\n",
+					of_node_full_name(np));
+			goto timingfail;
+		}
+
+		r = of_get_display_timing(entry, dt);
+		if (r) {
 			/*
 			 * to not encourage wrong devicetrees, fail in case of
 			 * an error

commit 06a3307975aac2d5b5a0e0f2e05d23e769f176b4
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Mar 12 10:26:45 2013 +0200

    videomode: combine videomode dmt_flags and data_flags
    
    Both videomode and display_timing contain flags describing the modes.
    These are stored in dmt_flags and data_flags. There's no need to
    separate these flags, and having separate fields just makes the flags
    more difficult to use.
    
    This patch combines the fields and renames VESA_DMT_* flags to
    DISPLAY_FLAGS_*.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Steffen Trumtrar <s.trumtrar@pengutronix.de>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 13ecd9897010..56009bc02b02 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -79,25 +79,24 @@ static struct display_timing *of_get_display_timing(struct device_node *np)
 	ret |= parse_timing_property(np, "vsync-len", &dt->vsync_len);
 	ret |= parse_timing_property(np, "clock-frequency", &dt->pixelclock);
 
-	dt->dmt_flags = 0;
-	dt->data_flags = 0;
+	dt->flags = 0;
 	if (!of_property_read_u32(np, "vsync-active", &val))
-		dt->dmt_flags |= val ? VESA_DMT_VSYNC_HIGH :
-				VESA_DMT_VSYNC_LOW;
+		dt->flags |= val ? DISPLAY_FLAGS_VSYNC_HIGH :
+				DISPLAY_FLAGS_VSYNC_LOW;
 	if (!of_property_read_u32(np, "hsync-active", &val))
-		dt->dmt_flags |= val ? VESA_DMT_HSYNC_HIGH :
-				VESA_DMT_HSYNC_LOW;
+		dt->flags |= val ? DISPLAY_FLAGS_HSYNC_HIGH :
+				DISPLAY_FLAGS_HSYNC_LOW;
 	if (!of_property_read_u32(np, "de-active", &val))
-		dt->data_flags |= val ? DISPLAY_FLAGS_DE_HIGH :
+		dt->flags |= val ? DISPLAY_FLAGS_DE_HIGH :
 				DISPLAY_FLAGS_DE_LOW;
 	if (!of_property_read_u32(np, "pixelclk-active", &val))
-		dt->data_flags |= val ? DISPLAY_FLAGS_PIXDATA_POSEDGE :
+		dt->flags |= val ? DISPLAY_FLAGS_PIXDATA_POSEDGE :
 				DISPLAY_FLAGS_PIXDATA_NEGEDGE;
 
 	if (of_property_read_bool(np, "interlaced"))
-		dt->data_flags |= DISPLAY_FLAGS_INTERLACED;
+		dt->flags |= DISPLAY_FLAGS_INTERLACED;
 	if (of_property_read_bool(np, "doublescan"))
-		dt->data_flags |= DISPLAY_FLAGS_DOUBLESCAN;
+		dt->flags |= DISPLAY_FLAGS_DOUBLESCAN;
 
 	if (ret) {
 		pr_err("%s: error reading timing properties\n",

commit cc3f414cf2e404130584b63d373161ba6fd24bc2
Author: Steffen Trumtrar <s.trumtrar@pengutronix.de>
Date:   Thu Oct 4 15:32:52 2012 +0200

    video: add of helper for display timings/videomode
    
    This adds support for reading display timings from DT into a struct
    display_timings. The of_display_timing implementation supports multiple
    subnodes. All children are read into an array, that can be queried.
    
    If no native mode is specified, the first subnode will be used.
    
    For cases where the graphics driver knows there can be only one
    mode description or where the driver only supports one mode, a helper
    function of_get_videomode is added, that gets a struct videomode from DT.
    
    Signed-off-by: Steffen Trumtrar <s.trumtrar@pengutronix.de>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Reviewed-by: Thierry Reding <thierry.reding@avionic-design.de>
    Acked-by: Thierry Reding <thierry.reding@avionic-design.de>
    Tested-by: Thierry Reding <thierry.reding@avionic-design.de>
    Tested-by: Philipp Zabel <p.zabel@pengutronix.de>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Tested-by: Afzal Mohammed <Afzal@ti.com>
    Tested-by: Rob Clark <robclark@gmail.com>
    Tested-by: Leela Krishna Amudala <leelakrishna.a@gmail.com>

diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
new file mode 100644
index 000000000000..13ecd9897010
--- /dev/null
+++ b/drivers/video/of_display_timing.c
@@ -0,0 +1,239 @@
+/*
+ * OF helpers for parsing display timings
+ *
+ * Copyright (c) 2012 Steffen Trumtrar <s.trumtrar@pengutronix.de>, Pengutronix
+ *
+ * based on of_videomode.c by Sascha Hauer <s.hauer@pengutronix.de>
+ *
+ * This file is released under the GPLv2
+ */
+#include <linux/export.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <video/display_timing.h>
+#include <video/of_display_timing.h>
+
+/**
+ * parse_timing_property - parse timing_entry from device_node
+ * @np: device_node with the property
+ * @name: name of the property
+ * @result: will be set to the return value
+ *
+ * DESCRIPTION:
+ * Every display_timing can be specified with either just the typical value or
+ * a range consisting of min/typ/max. This function helps handling this
+ **/
+static int parse_timing_property(struct device_node *np, const char *name,
+			  struct timing_entry *result)
+{
+	struct property *prop;
+	int length, cells, ret;
+
+	prop = of_find_property(np, name, &length);
+	if (!prop) {
+		pr_err("%s: could not find property %s\n",
+			of_node_full_name(np), name);
+		return -EINVAL;
+	}
+
+	cells = length / sizeof(u32);
+	if (cells == 1) {
+		ret = of_property_read_u32(np, name, &result->typ);
+		result->min = result->typ;
+		result->max = result->typ;
+	} else if (cells == 3) {
+		ret = of_property_read_u32_array(np, name, &result->min, cells);
+	} else {
+		pr_err("%s: illegal timing specification in %s\n",
+			of_node_full_name(np), name);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+/**
+ * of_get_display_timing - parse display_timing entry from device_node
+ * @np: device_node with the properties
+ **/
+static struct display_timing *of_get_display_timing(struct device_node *np)
+{
+	struct display_timing *dt;
+	u32 val = 0;
+	int ret = 0;
+
+	dt = kzalloc(sizeof(*dt), GFP_KERNEL);
+	if (!dt) {
+		pr_err("%s: could not allocate display_timing struct\n",
+			of_node_full_name(np));
+		return NULL;
+	}
+
+	ret |= parse_timing_property(np, "hback-porch", &dt->hback_porch);
+	ret |= parse_timing_property(np, "hfront-porch", &dt->hfront_porch);
+	ret |= parse_timing_property(np, "hactive", &dt->hactive);
+	ret |= parse_timing_property(np, "hsync-len", &dt->hsync_len);
+	ret |= parse_timing_property(np, "vback-porch", &dt->vback_porch);
+	ret |= parse_timing_property(np, "vfront-porch", &dt->vfront_porch);
+	ret |= parse_timing_property(np, "vactive", &dt->vactive);
+	ret |= parse_timing_property(np, "vsync-len", &dt->vsync_len);
+	ret |= parse_timing_property(np, "clock-frequency", &dt->pixelclock);
+
+	dt->dmt_flags = 0;
+	dt->data_flags = 0;
+	if (!of_property_read_u32(np, "vsync-active", &val))
+		dt->dmt_flags |= val ? VESA_DMT_VSYNC_HIGH :
+				VESA_DMT_VSYNC_LOW;
+	if (!of_property_read_u32(np, "hsync-active", &val))
+		dt->dmt_flags |= val ? VESA_DMT_HSYNC_HIGH :
+				VESA_DMT_HSYNC_LOW;
+	if (!of_property_read_u32(np, "de-active", &val))
+		dt->data_flags |= val ? DISPLAY_FLAGS_DE_HIGH :
+				DISPLAY_FLAGS_DE_LOW;
+	if (!of_property_read_u32(np, "pixelclk-active", &val))
+		dt->data_flags |= val ? DISPLAY_FLAGS_PIXDATA_POSEDGE :
+				DISPLAY_FLAGS_PIXDATA_NEGEDGE;
+
+	if (of_property_read_bool(np, "interlaced"))
+		dt->data_flags |= DISPLAY_FLAGS_INTERLACED;
+	if (of_property_read_bool(np, "doublescan"))
+		dt->data_flags |= DISPLAY_FLAGS_DOUBLESCAN;
+
+	if (ret) {
+		pr_err("%s: error reading timing properties\n",
+			of_node_full_name(np));
+		kfree(dt);
+		return NULL;
+	}
+
+	return dt;
+}
+
+/**
+ * of_get_display_timings - parse all display_timing entries from a device_node
+ * @np: device_node with the subnodes
+ **/
+struct display_timings *of_get_display_timings(struct device_node *np)
+{
+	struct device_node *timings_np;
+	struct device_node *entry;
+	struct device_node *native_mode;
+	struct display_timings *disp;
+
+	if (!np) {
+		pr_err("%s: no devicenode given\n", of_node_full_name(np));
+		return NULL;
+	}
+
+	timings_np = of_find_node_by_name(np, "display-timings");
+	if (!timings_np) {
+		pr_err("%s: could not find display-timings node\n",
+			of_node_full_name(np));
+		return NULL;
+	}
+
+	disp = kzalloc(sizeof(*disp), GFP_KERNEL);
+	if (!disp) {
+		pr_err("%s: could not allocate struct disp'\n",
+			of_node_full_name(np));
+		goto dispfail;
+	}
+
+	entry = of_parse_phandle(timings_np, "native-mode", 0);
+	/* assume first child as native mode if none provided */
+	if (!entry)
+		entry = of_get_next_child(np, NULL);
+	/* if there is no child, it is useless to go on */
+	if (!entry) {
+		pr_err("%s: no timing specifications given\n",
+			of_node_full_name(np));
+		goto entryfail;
+	}
+
+	pr_debug("%s: using %s as default timing\n",
+		of_node_full_name(np), entry->name);
+
+	native_mode = entry;
+
+	disp->num_timings = of_get_child_count(timings_np);
+	if (disp->num_timings == 0) {
+		/* should never happen, as entry was already found above */
+		pr_err("%s: no timings specified\n", of_node_full_name(np));
+		goto entryfail;
+	}
+
+	disp->timings = kzalloc(sizeof(struct display_timing *) *
+				disp->num_timings, GFP_KERNEL);
+	if (!disp->timings) {
+		pr_err("%s: could not allocate timings array\n",
+			of_node_full_name(np));
+		goto entryfail;
+	}
+
+	disp->num_timings = 0;
+	disp->native_mode = 0;
+
+	for_each_child_of_node(timings_np, entry) {
+		struct display_timing *dt;
+
+		dt = of_get_display_timing(entry);
+		if (!dt) {
+			/*
+			 * to not encourage wrong devicetrees, fail in case of
+			 * an error
+			 */
+			pr_err("%s: error in timing %d\n",
+				of_node_full_name(np), disp->num_timings + 1);
+			goto timingfail;
+		}
+
+		if (native_mode == entry)
+			disp->native_mode = disp->num_timings;
+
+		disp->timings[disp->num_timings] = dt;
+		disp->num_timings++;
+	}
+	of_node_put(timings_np);
+	/*
+	 * native_mode points to the device_node returned by of_parse_phandle
+	 * therefore call of_node_put on it
+	 */
+	of_node_put(native_mode);
+
+	pr_debug("%s: got %d timings. Using timing #%d as default\n",
+		of_node_full_name(np), disp->num_timings,
+		disp->native_mode + 1);
+
+	return disp;
+
+timingfail:
+	if (native_mode)
+		of_node_put(native_mode);
+	display_timings_release(disp);
+entryfail:
+	kfree(disp);
+dispfail:
+	of_node_put(timings_np);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(of_get_display_timings);
+
+/**
+ * of_display_timings_exist - check if a display-timings node is provided
+ * @np: device_node with the timing
+ **/
+int of_display_timings_exist(struct device_node *np)
+{
+	struct device_node *timings_np;
+
+	if (!np)
+		return -EINVAL;
+
+	timings_np = of_parse_phandle(np, "display-timings", 0);
+	if (!timings_np)
+		return -EINVAL;
+
+	of_node_put(timings_np);
+	return 1;
+}
+EXPORT_SYMBOL_GPL(of_display_timings_exist);
