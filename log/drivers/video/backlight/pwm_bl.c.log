commit 2644f912b41012c1ce5ff9be99efeec721491b86
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Feb 10 11:15:46 2020 +0100

    backlight: pwm_bl: Switch to full GPIO descriptor
    
    The PWM backlight still supports passing a enable GPIO line as
    platform data using the legacy <linux/gpio.h> API.
    
    It turns out that ever board using this mechanism except one
    is pass .enable_gpio = -1. So we drop all these cargo-culted -1's
    from all instances of this platform data in the kernel.
    
    The remaning board, Palm TC, is converted to pass a machine
    descriptior table with the "enable" GPIO instead, and delete the
    platform data entry for enable_gpio and the code handling it
    and things should work smoothly with the new API.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Acked-by: Krzysztof Kozlowski <krzk@kernel.org
    Reviewed-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index efb4efc2a13d..82b8d7594701 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -7,7 +7,6 @@
 
 #include <linux/delay.h>
 #include <linux/gpio/consumer.h>
-#include <linux/gpio.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -258,8 +257,6 @@ static int pwm_backlight_parse_dt(struct device *dev,
 			     &data->post_pwm_on_delay);
 	of_property_read_u32(node, "pwm-off-delay-ms", &data->pwm_off_delay);
 
-	data->enable_gpio = -EINVAL;
-
 	/*
 	 * Determine the number of brightness levels, if this property is not
 	 * set a default table of brightness levels will be used.
@@ -502,22 +499,6 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		goto err_alloc;
 	}
 
-	/*
-	 * Compatibility fallback for drivers still using the integer GPIO
-	 * platform data. Must go away soon.
-	 */
-	if (!pb->enable_gpio && gpio_is_valid(data->enable_gpio)) {
-		ret = devm_gpio_request_one(&pdev->dev, data->enable_gpio,
-					    GPIOF_OUT_INIT_HIGH, "enable");
-		if (ret < 0) {
-			dev_err(&pdev->dev, "failed to request GPIO#%d: %d\n",
-				data->enable_gpio, ret);
-			goto err_alloc;
-		}
-
-		pb->enable_gpio = gpio_to_desc(data->enable_gpio);
-	}
-
 	/*
 	 * If the GPIO is not known to be already configured as output, that
 	 * is, if gpiod_get_direction returns either 1 or -EINVAL, change the

commit ca58b37034453e690e5278f95f32ea050951cf9f
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Tue Oct 8 14:03:27 2019 +0200

    backlight: pwm_bl: Switch to power-of-2 base for fixed-point math
    
    Using a power-of-2 instead of power-of-10 base makes the computations
    much cheaper. 2^16 is safe; retval never becomes more than 2^48 +
    2^32/2. On a 32 bit platform, the very expensive 64/32 division at the
    end of cie1931() instead becomes essentially free (a shift by 32 is
    just a register rename).
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index ee85055146dd..efb4efc2a13d 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -149,7 +149,8 @@ static const struct backlight_ops pwm_backlight_ops = {
 };
 
 #ifdef CONFIG_OF
-#define PWM_LUMINANCE_SCALE	10000 /* luminance scale */
+#define PWM_LUMINANCE_SHIFT	16
+#define PWM_LUMINANCE_SCALE	(1 << PWM_LUMINANCE_SHIFT) /* luminance scale */
 
 /*
  * CIE lightness to PWM conversion.
@@ -166,23 +167,25 @@ static const struct backlight_ops pwm_backlight_ops = {
  * The following function does the fixed point maths needed to implement the
  * above formula.
  */
-static u64 cie1931(unsigned int lightness, unsigned int scale)
+static u64 cie1931(unsigned int lightness)
 {
 	u64 retval;
 
 	/*
 	 * @lightness is given as a number between 0 and 1, expressed
-	 * as a fixed-point number in scale @scale. Convert to a
-	 * percentage, still expressed as a fixed-point number, so the
-	 * above formulas can be applied.
+	 * as a fixed-point number in scale
+	 * PWM_LUMINANCE_SCALE. Convert to a percentage, still
+	 * expressed as a fixed-point number, so the above formulas
+	 * can be applied.
 	 */
 	lightness *= 100;
-	if (lightness <= (8 * scale)) {
+	if (lightness <= (8 * PWM_LUMINANCE_SCALE)) {
 		retval = DIV_ROUND_CLOSEST(lightness * 10, 9033);
 	} else {
-		retval = (lightness + (16 * scale)) / 116;
+		retval = (lightness + (16 * PWM_LUMINANCE_SCALE)) / 116;
 		retval *= retval * retval;
-		retval = DIV_ROUND_CLOSEST_ULL(retval, (scale * scale));
+		retval += 1ULL << (2*PWM_LUMINANCE_SHIFT - 1);
+		retval >>= 2*PWM_LUMINANCE_SHIFT;
 	}
 
 	return retval;
@@ -216,8 +219,7 @@ int pwm_backlight_brightness_default(struct device *dev,
 	/* Fill the table using the cie1931 algorithm */
 	for (i = 0; i < data->max_brightness; i++) {
 		retval = cie1931((i * PWM_LUMINANCE_SCALE) /
-				 data->max_brightness, PWM_LUMINANCE_SCALE) *
-				 period;
+				 data->max_brightness) * period;
 		retval = DIV_ROUND_CLOSEST_ULL(retval, PWM_LUMINANCE_SCALE);
 		if (retval > UINT_MAX)
 			return -EINVAL;

commit 407feae1cacaa5d00ebe686532a73ad6de747409
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Tue Oct 8 14:03:26 2019 +0200

    backlight: pwm_bl: Drop use of int_pow()
    
    For a fixed small exponent of 3, it is more efficient to simply use
    two explicit multiplications rather than calling the int_pow() library
    function: Aside from the function call overhead, its implementation
    using repeated squaring means it ends up doing four 64x64
    multiplications.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 15d84da77ecd..ee85055146dd 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -180,7 +180,8 @@ static u64 cie1931(unsigned int lightness, unsigned int scale)
 	if (lightness <= (8 * scale)) {
 		retval = DIV_ROUND_CLOSEST(lightness * 10, 9033);
 	} else {
-		retval = int_pow((lightness + (16 * scale)) / 116, 3);
+		retval = (lightness + (16 * scale)) / 116;
+		retval *= retval * retval;
 		retval = DIV_ROUND_CLOSEST_ULL(retval, (scale * scale));
 	}
 

commit e802cbafcbd250a88cbd4ea7f9afb9c0d4267c7a
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Tue Oct 8 14:03:25 2019 +0200

    backlight: pwm_bl: Eliminate a 64/32 division
    
    lightness*1000 is nowhere near overflowing 32 bits, so we can just use
    an ordinary 32/32 division, which is much cheaper than the 64/32 done
    via do_div().
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 3525e04791ce..15d84da77ecd 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -178,7 +178,7 @@ static u64 cie1931(unsigned int lightness, unsigned int scale)
 	 */
 	lightness *= 100;
 	if (lightness <= (8 * scale)) {
-		retval = DIV_ROUND_CLOSEST_ULL(lightness * 10, 9033);
+		retval = DIV_ROUND_CLOSEST(lightness * 10, 9033);
 	} else {
 		retval = int_pow((lightness + (16 * scale)) / 116, 3);
 		retval = DIV_ROUND_CLOSEST_ULL(retval, (scale * scale));

commit efdf690e159ab340486dd6d42f387bbb8f03a579
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Tue Oct 8 14:03:24 2019 +0200

    backlight: pwm_bl: Fix cie1913 comments and constant
    
    The "break-even" point for the two formulas is L==8, which is also
    what the code actually implements. [Incidentally, at that point one
    has Y=0.008856, not 0.08856].
    
    Moreover, all the sources I can find say the linear factor is 903.3
    rather than 902.3, which makes sense since then the formulas agree at
    L==8, both yielding the 0.008856 figure to four significant digits.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 9c4216f08c5a..3525e04791ce 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -156,8 +156,8 @@ static const struct backlight_ops pwm_backlight_ops = {
  *
  * The CIE 1931 lightness formula is what actually describes how we perceive
  * light:
- *          Y = (L* / 902.3)           if L* ≤ 0.08856
- *          Y = ((L* + 16) / 116)^3    if L* > 0.08856
+ *          Y = (L* / 903.3)           if L* ≤ 8
+ *          Y = ((L* + 16) / 116)^3    if L* > 8
  *
  * Where Y is the luminance, the amount of light coming out of the screen, and
  * is a number between 0.0 and 1.0; and L* is the lightness, how bright a human
@@ -170,9 +170,15 @@ static u64 cie1931(unsigned int lightness, unsigned int scale)
 {
 	u64 retval;
 
+	/*
+	 * @lightness is given as a number between 0 and 1, expressed
+	 * as a fixed-point number in scale @scale. Convert to a
+	 * percentage, still expressed as a fixed-point number, so the
+	 * above formulas can be applied.
+	 */
 	lightness *= 100;
 	if (lightness <= (8 * scale)) {
-		retval = DIV_ROUND_CLOSEST_ULL(lightness * 10, 9023);
+		retval = DIV_ROUND_CLOSEST_ULL(lightness * 10, 9033);
 	} else {
 		retval = int_pow((lightness + (16 * scale)) / 116, 3);
 		retval = DIV_ROUND_CLOSEST_ULL(retval, (scale * scale));

commit 349ee1228729df5c2a0cb33506cad2661e40e750
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Thu Oct 3 14:35:02 2019 -0700

    backlight: pwm_bl: Add missing curly branches in else branch
    
    Add curly braces to an 'else' branch in pwm_backlight_update_status()
    to match the corresponding 'if' branch.
    
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Reviewed-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 05d3b3802658..9c4216f08c5a 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -125,8 +125,9 @@ static int pwm_backlight_update_status(struct backlight_device *bl)
 		state.duty_cycle = compute_duty_cycle(pb, brightness);
 		pwm_apply_state(pb->pwm, &state);
 		pwm_backlight_power_on(pb);
-	} else
+	} else {
 		pwm_backlight_power_off(pb);
+	}
 
 	if (pb->notify_after)
 		pb->notify_after(pb->dev, brightness);

commit de6f2a7fa2c9563266e2a3239e16b117daf22b47
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Wed Oct 2 09:56:01 2019 -0700

    backlight: pwm_bl: Don't assign levels table repeatedly
    
    pwm_backlight_probe() re-assigns pb->levels for every brightness
    level. This is not needed and was likely not intended, since
    neither side of the assignment changes during the loop. Assign
    the field only once.
    
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Reviewed-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 746eebc411df..05d3b3802658 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -564,18 +564,17 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	memset(&props, 0, sizeof(struct backlight_properties));
 
 	if (data->levels) {
+		pb->levels = data->levels;
+
 		/*
 		 * For the DT case, only when brightness levels is defined
 		 * data->levels is filled. For the non-DT case, data->levels
 		 * can come from platform data, however is not usual.
 		 */
-		for (i = 0; i <= data->max_brightness; i++) {
+		for (i = 0; i <= data->max_brightness; i++)
 			if (data->levels[i] > pb->scale)
 				pb->scale = data->levels[i];
 
-			pb->levels = data->levels;
-		}
-
 		if (pwm_backlight_is_linear(data))
 			props.scale = BACKLIGHT_SCALE_LINEAR;
 		else

commit c0b64faf0fe6ca2574a00faed1ae833130db4e08
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Tue Jul 9 12:00:07 2019 -0700

    backlight: pwm_bl: Set scale type for brightness curves specified in the DT
    
    Check if a brightness curve specified in the device tree is linear or
    not and set the corresponding property accordingly. This makes the
    scale type available to userspace via the 'scale' sysfs attribute.
    
    To determine if a curve is linear it is compared to a interpolated linear
    curve between min and max brightness. The curve is considered linear if
    no value deviates more than +/-5% of ${brightness_range} from their
    interpolated value.
    
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index d6d2b6407d7e..746eebc411df 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -387,6 +387,31 @@ int pwm_backlight_brightness_default(struct device *dev,
 }
 #endif
 
+static bool pwm_backlight_is_linear(struct platform_pwm_backlight_data *data)
+{
+	unsigned int nlevels = data->max_brightness + 1;
+	unsigned int min_val = data->levels[0];
+	unsigned int max_val = data->levels[nlevels - 1];
+	/*
+	 * Multiplying by 128 means that even in pathological cases such
+	 * as (max_val - min_val) == nlevels the error at max_val is less
+	 * than 1%.
+	 */
+	unsigned int slope = (128 * (max_val - min_val)) / nlevels;
+	unsigned int margin = (max_val - min_val) / 20; /* 5% */
+	int i;
+
+	for (i = 1; i < nlevels; i++) {
+		unsigned int linear_value = min_val + ((i * slope) / 128);
+		unsigned int delta = abs(linear_value - data->levels[i]);
+
+		if (delta > margin)
+			return false;
+	}
+
+	return true;
+}
+
 static int pwm_backlight_initial_power_state(const struct pwm_bl_data *pb)
 {
 	struct device_node *node = pb->dev->of_node;
@@ -550,6 +575,11 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 			pb->levels = data->levels;
 		}
+
+		if (pwm_backlight_is_linear(data))
+			props.scale = BACKLIGHT_SCALE_LINEAR;
+		else
+			props.scale = BACKLIGHT_SCALE_NON_LINEAR;
 	} else if (!data->max_brightness) {
 		/*
 		 * If no brightness levels are provided and max_brightness is

commit 511a204638d7d750f859c332635d09f38273b4f0
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Tue Jul 9 12:00:06 2019 -0700

    backlight: pwm_bl: Set scale type for CIE 1931 curves
    
    For backlight curves calculated with the CIE 1931 algorithm set
    the brightness scale type to non-linear. This makes the scale type
    available to userspace via the 'scale' sysfs attribute.
    
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Tested-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 2201b8c78641..d6d2b6407d7e 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -536,6 +536,8 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		goto err_alloc;
 	}
 
+	memset(&props, 0, sizeof(struct backlight_properties));
+
 	if (data->levels) {
 		/*
 		 * For the DT case, only when brightness levels is defined
@@ -574,6 +576,8 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 			pb->levels = data->levels;
 		}
+
+		props.scale = BACKLIGHT_SCALE_NON_LINEAR;
 	} else {
 		/*
 		 * That only happens for the non-DT case, where platform data
@@ -584,7 +588,6 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 	pb->lth_brightness = data->lth_brightness * (state.period / pb->scale);
 
-	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	props.max_brightness = data->max_brightness;
 	bl = backlight_device_register(dev_name(&pdev->dev), &pdev->dev, pb,

commit 50950626414a982c8ed539128c7f69a3d328a970
Merge: 9637d517347e 73fbfc499448
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 16 09:25:04 2019 -0700

    Merge tag 'backlight-next-5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/backlight
    
    Pull backlight updates from Lee Jones:
     "New Functionality:
       - Provide support for ACPI enumeration; gpio_backlight
    
      Fix-ups:
       - SPDX fixups; pwm_bl
       - Fix linear brightness levels to include number available; pwm_bl"
    
    * tag 'backlight-next-5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/backlight:
      backlight: pwm_bl: Fix heuristic to determine number of brightness levels
      backlight: gpio_backlight: Enable ACPI enumeration
      backlight: pwm_bl: Convert to use SPDX identifier

commit 73fbfc499448455f1e1c77717040e09e25f1d976
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Wed Jun 12 11:00:03 2019 -0700

    backlight: pwm_bl: Fix heuristic to determine number of brightness levels
    
    With commit 88ba95bedb79 ("backlight: pwm_bl: Compute brightness of
    LED linearly to human eye") the number of set bits (aka hweight())
    in the PWM period is used in the heuristic to determine the number
    of brightness levels, when the brightness table isn't specified in
    the DT. The number of set bits doesn't provide a reliable clue about
    the length of the period, instead change the heuristic to:
    
     nlevels = period / fls(period)
    
    Also limit the maximum number of brightness levels to 4096 to avoid
    excessively large tables.
    
    With this the number of levels increases monotonically with the PWM
    period, until the maximum of 4096 levels is reached:
    
    period (ns)    # levels
    
    100            16
    500            62
    1000           111
    5000           416
    10000          769
    50000          3333
    100000         4096
    
    Fixes: 88ba95bedb79 ("backlight: pwm_bl: Compute brightness of LED linearly to human eye")
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Tested-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 1f7f8d5c0bf1..abfd1bca2c11 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -189,29 +189,17 @@ int pwm_backlight_brightness_default(struct device *dev,
 				     struct platform_pwm_backlight_data *data,
 				     unsigned int period)
 {
-	unsigned int counter = 0;
-	unsigned int i, n;
+	unsigned int i;
 	u64 retval;
 
 	/*
-	 * Count the number of bits needed to represent the period number. The
-	 * number of bits is used to calculate the number of levels used for the
-	 * brightness-levels table, the purpose of this calculation is have a
-	 * pre-computed table with enough levels to get linear brightness
-	 * perception. The period is divided by the number of bits so for a
-	 * 8-bit PWM we have 255 / 8 = 32 brightness levels or for a 16-bit PWM
-	 * we have 65535 / 16 = 4096 brightness levels.
-	 *
-	 * Note that this method is based on empirical testing on different
-	 * devices with PWM of 8 and 16 bits of resolution.
+	 * Once we have 4096 levels there's little point going much higher...
+	 * neither interactive sliders nor animation benefits from having
+	 * more values in the table.
 	 */
-	n = period;
-	while (n) {
-		counter += n % 2;
-		n >>= 1;
-	}
+	data->max_brightness =
+		min((int)DIV_ROUND_UP(period, fls(period)), 4096);
 
-	data->max_brightness = DIV_ROUND_UP(period, counter);
 	data->levels = devm_kcalloc(dev, data->max_brightness,
 				    sizeof(*data->levels), GFP_KERNEL);
 	if (!data->levels)

commit 5076fbed57f7f58c839e7ea5a2495c1d083417ae
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jun 19 16:59:27 2019 +0300

    backlight: pwm_bl: Convert to use SPDX identifier
    
    Reduce size of duplicated comments by switching to use SPDX identifier.
    
    No functional change.
    
    While here, correct MODULE_LICENSE() string to be aligned with license text.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index fb45f866b923..1f7f8d5c0bf1 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -1,13 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * linux/drivers/video/backlight/pwm_bl.c
- *
- * simple PWM based backlight control, board code has to setup
+ * Simple PWM based backlight control, board code has to setup
  * 1) pin configuration so PWM waveforms can output
  * 2) platform_data being correctly configured
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/delay.h>
@@ -708,5 +703,5 @@ static struct platform_driver pwm_backlight_driver = {
 module_platform_driver(pwm_backlight_driver);
 
 MODULE_DESCRIPTION("PWM based Backlight Driver");
-MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("platform:pwm-backlight");

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index fb45f866b923..20d379ac8440 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -1,13 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * linux/drivers/video/backlight/pwm_bl.c
  *
  * simple PWM based backlight control, board code has to setup
  * 1) pin configuration so PWM waveforms can output
  * 2) platform_data being correctly configured
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/delay.h>

commit 9f6158946987a5ce3f16da097d18f240a89db417
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue May 14 15:43:08 2019 -0700

    lib/math: move int_pow() from pwm_bl.c for wider use
    
    The integer exponentiation is used in few places and might be used in
    the future by other call sites.  Move it to wider use.
    
    Link: http://lkml.kernel.org/r/20190323172531.80025-2-andriy.shevchenko@linux.intel.com
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 53b8ceea9bde..fb45f866b923 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -155,21 +155,6 @@ static const struct backlight_ops pwm_backlight_ops = {
 #ifdef CONFIG_OF
 #define PWM_LUMINANCE_SCALE	10000 /* luminance scale */
 
-/* An integer based power function */
-static u64 int_pow(u64 base, int exp)
-{
-	u64 result = 1;
-
-	while (exp) {
-		if (exp & 1)
-			result *= base;
-		exp >>= 1;
-		base *= base;
-	}
-
-	return result;
-}
-
 /*
  * CIE lightness to PWM conversion.
  *

commit cec2b18832e26bc866bef2be22eff4e25bbc4034
Author: Chen-Yu Tsai <wens@csie.org>
Date:   Sun Jan 27 22:50:54 2019 +0800

    backlight: pwm_bl: Use gpiod_get_value_cansleep() to get initial state
    
    gpiod_get_value() gives out a warning if access to the underlying gpiochip
    requires sleeping, which is common for I2C based chips:
    
        WARNING: CPU: 0 PID: 77 at drivers/gpio/gpiolib.c:2500 gpiod_get_value+0xd0/0x100
        Modules linked in:
        CPU: 0 PID: 77 Comm: kworker/0:2 Not tainted 4.14.0-rc3-00589-gf32897915d48-dirty #90
        Hardware name: Allwinner sun4i/sun5i Families
        Workqueue: events deferred_probe_work_func
        [<c010ec50>] (unwind_backtrace) from [<c010b784>] (show_stack+0x10/0x14)
        [<c010b784>] (show_stack) from [<c0797224>] (dump_stack+0x88/0x9c)
        [<c0797224>] (dump_stack) from [<c0125b08>] (__warn+0xe8/0x100)
        [<c0125b08>] (__warn) from [<c0125bd0>] (warn_slowpath_null+0x20/0x28)
        [<c0125bd0>] (warn_slowpath_null) from [<c037069c>] (gpiod_get_value+0xd0/0x100)
        [<c037069c>] (gpiod_get_value) from [<c03778d0>] (pwm_backlight_probe+0x238/0x508)
        [<c03778d0>] (pwm_backlight_probe) from [<c0411a2c>] (platform_drv_probe+0x50/0xac)
        [<c0411a2c>] (platform_drv_probe) from [<c0410224>] (driver_probe_device+0x238/0x2e8)
        [<c0410224>] (driver_probe_device) from [<c040e820>] (bus_for_each_drv+0x44/0x94)
        [<c040e820>] (bus_for_each_drv) from [<c040ff0c>] (__device_attach+0xb0/0x114)
        [<c040ff0c>] (__device_attach) from [<c040f4f8>] (bus_probe_device+0x84/0x8c)
        [<c040f4f8>] (bus_probe_device) from [<c040f944>] (deferred_probe_work_func+0x50/0x14c)
        [<c040f944>] (deferred_probe_work_func) from [<c013be84>] (process_one_work+0x1ec/0x414)
        [<c013be84>] (process_one_work) from [<c013ce5c>] (worker_thread+0x2b0/0x5a0)
        [<c013ce5c>] (worker_thread) from [<c0141908>] (kthread+0x14c/0x154)
        [<c0141908>] (kthread) from [<c0107ab0>] (ret_from_fork+0x14/0x24)
    
    This was missed in commit 0c9501f823a4 ("backlight: pwm_bl: Handle gpio
    that can sleep"). The code was then moved to a separate function in
    commit 7613c922315e ("backlight: pwm_bl: Move the checks for initial power
    state to a separate function").
    
    The only usage of gpiod_get_value() is during the probe stage, which is
    safe to sleep in. Switch to gpiod_get_value_cansleep().
    
    Fixes: 0c9501f823a4 ("backlight: pwm_bl: Handle gpio that can sleep")
    Signed-off-by: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index feb90764a811..53b8ceea9bde 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -435,7 +435,7 @@ static int pwm_backlight_initial_power_state(const struct pwm_bl_data *pb)
 	 */
 
 	/* if the enable GPIO is disabled, do not enable the backlight */
-	if (pb->enable_gpio && gpiod_get_value(pb->enable_gpio) == 0)
+	if (pb->enable_gpio && gpiod_get_value_cansleep(pb->enable_gpio) == 0)
 		return FB_BLANK_POWERDOWN;
 
 	/* The regulator is disabled, do not enable the backlight */

commit 3a73e73a10a791344587103a1adbe0c5f02fedeb
Merge: 1c7fc5cbc339 3cee7a7d05b1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 15 06:21:10 2019 +1200

    Merge tag 'backlight-next-4.21' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/backlight
    
    Pull backlight updates from Lee Jones:
     "Fix-ups:
       - Use new of_node_name_eq() API call
    
      Bug Fixes:
       - Internally track 'enabled' state in pwm_bl
       - Fix auto-generated pwm_bl brightness tables parsed by DT
    
    * tag 'backlight-next-4.21' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/backlight:
      backlight: 88pm860x_bl: Use of_node_name_eq for node name comparisons
      backlight: pwm_bl: Fix devicetree parsing with auto-generated brightness tables
      backlight: pwm_bl: Re-add driver internal enabled tracking

commit d347d0c82a99b41efc2770fc01a04066903300df
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Mon Dec 10 13:14:37 2018 +0100

    backlight: pwm_bl: Fix brightness levels for non-DT case.
    
    Commit '88ba95bedb79 ("backlight: pwm_bl: Compute brightness of LED
    linearly to human eye")' allows the possibility to compute a default
    brightness table when there isn't the brightness-levels property in the
    DT. Unfortunately the changes made broke the pwm backlight for the
    non-DT boards.
    
    Usually, the non-DT boards don't pass the brightness levels via platform
    data, instead, it sets the max_brightness in their platform data and the
    driver calculates the level without a table. The offending patch assumed
    that when there is no brightness levels table we should create one, but this
    is clearly wrong for the non-DT case.
    
    After this patch the code handles the DT and the non-DT case taking in
    consideration also if max_brightness is set or not.
    
    Fixes: 88ba95bedb79 ("backlight: pwm_bl: Compute brightness of LED linearly to human eye")
    Reported-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 678b27063198..f9ef0673a083 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -562,7 +562,30 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		goto err_alloc;
 	}
 
-	if (!data->levels) {
+	if (data->levels) {
+		/*
+		 * For the DT case, only when brightness levels is defined
+		 * data->levels is filled. For the non-DT case, data->levels
+		 * can come from platform data, however is not usual.
+		 */
+		for (i = 0; i <= data->max_brightness; i++) {
+			if (data->levels[i] > pb->scale)
+				pb->scale = data->levels[i];
+
+			pb->levels = data->levels;
+		}
+	} else if (!data->max_brightness) {
+		/*
+		 * If no brightness levels are provided and max_brightness is
+		 * not set, use the default brightness table. For the DT case,
+		 * max_brightness is set to 0 when brightness levels is not
+		 * specified. For the non-DT case, max_brightness is usually
+		 * set to some value.
+		 */
+
+		/* Get the PWM period (in nanoseconds) */
+		pwm_get_state(pb->pwm, &state);
+
 		ret = pwm_backlight_brightness_default(&pdev->dev, data,
 						       state.period);
 		if (ret < 0) {
@@ -570,13 +593,19 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 				"failed to setup default brightness table\n");
 			goto err_alloc;
 		}
-	}
 
-	for (i = 0; i <= data->max_brightness; i++) {
-		if (data->levels[i] > pb->scale)
-			pb->scale = data->levels[i];
+		for (i = 0; i <= data->max_brightness; i++) {
+			if (data->levels[i] > pb->scale)
+				pb->scale = data->levels[i];
 
-		pb->levels = data->levels;
+			pb->levels = data->levels;
+		}
+	} else {
+		/*
+		 * That only happens for the non-DT case, where platform data
+		 * sets the max_brightness value.
+		 */
+		pb->scale = data->max_brightness;
 	}
 
 	pb->lth_brightness = data->lth_brightness * (state.period / pb->scale);

commit 61170ee9386888f1e6f7e9cc58e8d9a8c2a3c1dd
Author: Heiko Stuebner <heiko.stuebner@bq.com>
Date:   Mon Nov 12 10:02:57 2018 +0100

    backlight: pwm_bl: Fix devicetree parsing with auto-generated brightness tables
    
    Commit 88ba95bedb79 ("backlight: pwm_bl: Compute brightness of LED linearly
    to human eye") made the parse-dt function return early when using an auto-
    generated brightness-table, but didn't take into account that some more
    settings were handled below the brightness handling, like power-on-delays
    and also setting the pdata enable-gpio to -EINVAL.
    
    This surfaces for example in the case of a backlight without any
    enable-gpio which then tries to use gpio-0 in error.
    
    Fix this by simply moving the trailing settings above the brightness
    handling.
    
    Fixes: 88ba95bedb79 ("backlight: pwm_bl: Compute brightness of LED linearly to human eye")
    Signed-off-by: Heiko Stuebner <heiko.stuebner@bq.com>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index bcd08b41765d..b7b5b31f3824 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -272,6 +272,16 @@ static int pwm_backlight_parse_dt(struct device *dev,
 
 	memset(data, 0, sizeof(*data));
 
+	/*
+	 * These values are optional and set as 0 by default, the out values
+	 * are modified only if a valid u32 value can be decoded.
+	 */
+	of_property_read_u32(node, "post-pwm-on-delay-ms",
+			     &data->post_pwm_on_delay);
+	of_property_read_u32(node, "pwm-off-delay-ms", &data->pwm_off_delay);
+
+	data->enable_gpio = -EINVAL;
+
 	/*
 	 * Determine the number of brightness levels, if this property is not
 	 * set a default table of brightness levels will be used.
@@ -384,15 +394,6 @@ static int pwm_backlight_parse_dt(struct device *dev,
 		data->max_brightness--;
 	}
 
-	/*
-	 * These values are optional and set as 0 by default, the out values
-	 * are modified only if a valid u32 value can be decoded.
-	 */
-	of_property_read_u32(node, "post-pwm-on-delay-ms",
-			     &data->post_pwm_on_delay);
-	of_property_read_u32(node, "pwm-off-delay-ms", &data->pwm_off_delay);
-
-	data->enable_gpio = -EINVAL;
 	return 0;
 }
 

commit e4c8ae3e3d6d473bfbfbb5db234792b9f8ddab3b
Author: Heiko Stuebner <heiko@sntech.de>
Date:   Fri Nov 9 10:48:57 2018 +0100

    backlight: pwm_bl: Re-add driver internal enabled tracking
    
    Commit e6bcca0890b9 ("backlight: pwm_bl: Switch to using "atomic" PWM API")
    removed the driver internal enabled tracking in favor of simply checking
    the pwm state.
    
    This can lead to issues as all of gpio-, regulator- and pwm-state are used
    to determine the initial state and the bootloader or kernel can leave them
    in an inconsistent state at boot.
    
    In my case on rk3399-kevin, the pwm backlight is build as module and the
    kernel disables the supply regulator as unused while keeping the pwm running
    thus pwm_bl calling pwm_backlight_power_off() during probe and creating an
    unmatched regulator-disable call, as it never got enabled from the pwm-bl
    before.
    
    To prevent these consistency issues, reintroduce the driver-internal
    tracking of the enabled state.
    
    Fixes: e6bcca0890b9 ("backlight: pwm_bl: Switch to using "atomic" PWM API")
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Thierry Reding <thierry.reding@gmail.com>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 678b27063198..bcd08b41765d 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -30,6 +30,7 @@ struct pwm_bl_data {
 	struct device		*dev;
 	unsigned int		lth_brightness;
 	unsigned int		*levels;
+	bool			enabled;
 	struct regulator	*power_supply;
 	struct gpio_desc	*enable_gpio;
 	unsigned int		scale;
@@ -50,7 +51,7 @@ static void pwm_backlight_power_on(struct pwm_bl_data *pb)
 	int err;
 
 	pwm_get_state(pb->pwm, &state);
-	if (state.enabled)
+	if (pb->enabled)
 		return;
 
 	err = regulator_enable(pb->power_supply);
@@ -65,6 +66,8 @@ static void pwm_backlight_power_on(struct pwm_bl_data *pb)
 
 	if (pb->enable_gpio)
 		gpiod_set_value_cansleep(pb->enable_gpio, 1);
+
+	pb->enabled = true;
 }
 
 static void pwm_backlight_power_off(struct pwm_bl_data *pb)
@@ -72,7 +75,7 @@ static void pwm_backlight_power_off(struct pwm_bl_data *pb)
 	struct pwm_state state;
 
 	pwm_get_state(pb->pwm, &state);
-	if (!state.enabled)
+	if (!pb->enabled)
 		return;
 
 	if (pb->enable_gpio)
@@ -86,6 +89,7 @@ static void pwm_backlight_power_off(struct pwm_bl_data *pb)
 	pwm_apply_state(pb->pwm, &state);
 
 	regulator_disable(pb->power_supply);
+	pb->enabled = false;
 }
 
 static int compute_duty_cycle(struct pwm_bl_data *pb, int brightness)
@@ -483,6 +487,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	pb->check_fb = data->check_fb;
 	pb->exit = data->exit;
 	pb->dev = &pdev->dev;
+	pb->enabled = false;
 	pb->post_pwm_on_delay = data->post_pwm_on_delay;
 	pb->pwm_off_delay = data->pwm_off_delay;
 

commit e6bcca0890b96a3c2c5e72169de72ba4d2b01b78
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Tue Aug 14 18:50:59 2018 +0200

    backlight: pwm_bl: Switch to using "atomic" PWM API
    
    The "atomic" API allows us to configure PWM period and duty_cycle and
    enable it in one call.
    
    The patch also moves the pwm_init_state just before any use of the
    pwm_state struct, this fixes a potential bug where pwm_get_state
    can be called before pwm_init_state.
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Reviewed-by: Daniel Thompson <daniel.thompson@linaro.org>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index bdfcc0a71db1..678b27063198 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -28,10 +28,8 @@
 struct pwm_bl_data {
 	struct pwm_device	*pwm;
 	struct device		*dev;
-	unsigned int		period;
 	unsigned int		lth_brightness;
 	unsigned int		*levels;
-	bool			enabled;
 	struct regulator	*power_supply;
 	struct gpio_desc	*enable_gpio;
 	unsigned int		scale;
@@ -46,31 +44,35 @@ struct pwm_bl_data {
 	void			(*exit)(struct device *);
 };
 
-static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness)
+static void pwm_backlight_power_on(struct pwm_bl_data *pb)
 {
+	struct pwm_state state;
 	int err;
 
-	if (pb->enabled)
+	pwm_get_state(pb->pwm, &state);
+	if (state.enabled)
 		return;
 
 	err = regulator_enable(pb->power_supply);
 	if (err < 0)
 		dev_err(pb->dev, "failed to enable power supply\n");
 
-	pwm_enable(pb->pwm);
+	state.enabled = true;
+	pwm_apply_state(pb->pwm, &state);
 
 	if (pb->post_pwm_on_delay)
 		msleep(pb->post_pwm_on_delay);
 
 	if (pb->enable_gpio)
 		gpiod_set_value_cansleep(pb->enable_gpio, 1);
-
-	pb->enabled = true;
 }
 
 static void pwm_backlight_power_off(struct pwm_bl_data *pb)
 {
-	if (!pb->enabled)
+	struct pwm_state state;
+
+	pwm_get_state(pb->pwm, &state);
+	if (!state.enabled)
 		return;
 
 	if (pb->enable_gpio)
@@ -79,24 +81,27 @@ static void pwm_backlight_power_off(struct pwm_bl_data *pb)
 	if (pb->pwm_off_delay)
 		msleep(pb->pwm_off_delay);
 
-	pwm_config(pb->pwm, 0, pb->period);
-	pwm_disable(pb->pwm);
+	state.enabled = false;
+	state.duty_cycle = 0;
+	pwm_apply_state(pb->pwm, &state);
 
 	regulator_disable(pb->power_supply);
-	pb->enabled = false;
 }
 
 static int compute_duty_cycle(struct pwm_bl_data *pb, int brightness)
 {
 	unsigned int lth = pb->lth_brightness;
+	struct pwm_state state;
 	u64 duty_cycle;
 
+	pwm_get_state(pb->pwm, &state);
+
 	if (pb->levels)
 		duty_cycle = pb->levels[brightness];
 	else
 		duty_cycle = brightness;
 
-	duty_cycle *= pb->period - lth;
+	duty_cycle *= state.period - lth;
 	do_div(duty_cycle, pb->scale);
 
 	return duty_cycle + lth;
@@ -106,7 +111,7 @@ static int pwm_backlight_update_status(struct backlight_device *bl)
 {
 	struct pwm_bl_data *pb = bl_get_data(bl);
 	int brightness = bl->props.brightness;
-	int duty_cycle;
+	struct pwm_state state;
 
 	if (bl->props.power != FB_BLANK_UNBLANK ||
 	    bl->props.fb_blank != FB_BLANK_UNBLANK ||
@@ -117,9 +122,10 @@ static int pwm_backlight_update_status(struct backlight_device *bl)
 		brightness = pb->notify(pb->dev, brightness);
 
 	if (brightness > 0) {
-		duty_cycle = compute_duty_cycle(pb, brightness);
-		pwm_config(pb->pwm, duty_cycle, pb->period);
-		pwm_backlight_power_on(pb, brightness);
+		pwm_get_state(pb->pwm, &state);
+		state.duty_cycle = compute_duty_cycle(pb, brightness);
+		pwm_apply_state(pb->pwm, &state);
+		pwm_backlight_power_on(pb);
 	} else
 		pwm_backlight_power_off(pb);
 
@@ -447,7 +453,6 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	struct device_node *node = pdev->dev.of_node;
 	struct pwm_bl_data *pb;
 	struct pwm_state state;
-	struct pwm_args pargs;
 	unsigned int i;
 	int ret;
 
@@ -478,7 +483,6 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	pb->check_fb = data->check_fb;
 	pb->exit = data->exit;
 	pb->dev = &pdev->dev;
-	pb->enabled = false;
 	pb->post_pwm_on_delay = data->post_pwm_on_delay;
 	pb->pwm_off_delay = data->pwm_off_delay;
 
@@ -539,10 +543,26 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 	dev_dbg(&pdev->dev, "got pwm for backlight\n");
 
-	if (!data->levels) {
-		/* Get the PWM period (in nanoseconds) */
-		pwm_get_state(pb->pwm, &state);
+	/* Sync up PWM state. */
+	pwm_init_state(pb->pwm, &state);
 
+	/*
+	 * The DT case will set the pwm_period_ns field to 0 and store the
+	 * period, parsed from the DT, in the PWM device. For the non-DT case,
+	 * set the period from platform data if it has not already been set
+	 * via the PWM lookup table.
+	 */
+	if (!state.period && (data->pwm_period_ns > 0))
+		state.period = data->pwm_period_ns;
+
+	ret = pwm_apply_state(pb->pwm, &state);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to apply initial PWM state: %d\n",
+			ret);
+		goto err_alloc;
+	}
+
+	if (!data->levels) {
 		ret = pwm_backlight_brightness_default(&pdev->dev, data,
 						       state.period);
 		if (ret < 0) {
@@ -559,24 +579,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		pb->levels = data->levels;
 	}
 
-	/*
-	 * FIXME: pwm_apply_args() should be removed when switching to
-	 * the atomic PWM API.
-	 */
-	pwm_apply_args(pb->pwm);
-
-	/*
-	 * The DT case will set the pwm_period_ns field to 0 and store the
-	 * period, parsed from the DT, in the PWM device. For the non-DT case,
-	 * set the period from platform data if it has not already been set
-	 * via the PWM lookup table.
-	 */
-	pwm_get_args(pb->pwm, &pargs);
-	pb->period = pargs.period;
-	if (!pb->period && (data->pwm_period_ns > 0))
-		pb->period = data->pwm_period_ns;
-
-	pb->lth_brightness = data->lth_brightness * (pb->period / pb->scale);
+	pb->lth_brightness = data->lth_brightness * (state.period / pb->scale);
 
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;

commit 633786736ed53a53b8d0a630cc3ff57381027081
Author: Daniel Thompson <daniel.thompson@linaro.org>
Date:   Wed Jul 25 08:38:30 2018 +0100

    backlight: pwm_bl: Fix uninitialized variable
    
    Currently, if the DT does not define num-interpolated-steps then
    num_steps is undefined and the interpolation code will deploy randomly.
    Fix with a simple initialize to zero.
    
    Fixes: 573fe6d1c25c ("backlight: pwm_bl: Linear interpolation between brightness-levels")
    Reported-by: Marcel Ziswiler <marcel.ziswiler@toradex.com>
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>
    Tested-by: Marcel Ziswiler <marcel.ziswiler@toradex.com>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 9ee4c1b735b2..bdfcc0a71db1 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -250,7 +250,7 @@ static int pwm_backlight_parse_dt(struct device *dev,
 	struct device_node *node = dev->of_node;
 	unsigned int num_levels = 0;
 	unsigned int levels_count;
-	unsigned int num_steps;
+	unsigned int num_steps = 0;
 	struct property *prop;
 	unsigned int *table;
 	int length;

commit 88ba95bedb7958a89ba107a11d9863ca58b64f22
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Mon Apr 9 10:33:32 2018 +0200

    backlight: pwm_bl: Compute brightness of LED linearly to human eye
    
    When you want to change the brightness using a PWM signal, one thing you
    need to consider is how human perceive the brightness. Human perceive
    the brightness change non-linearly, we have better sensitivity at low
    luminance than high luminance, so to achieve perceived linear dimming,
    the brightness must be matches to the way our eyes behave. The CIE 1931
    lightness formula is what actually describes how we perceive light.
    
    This patch computes a default table with the brightness levels filled
    with the numbers provided by the CIE 1931 algorithm, the number of the
    brightness levels is calculated based on the PWM resolution.
    
    The calculation of the table using the CIE 1931 algorithm is enabled by
    default when you do not define the 'brightness-levels' propriety in your
    device tree.
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 105f199a656d..9ee4c1b735b2 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -143,6 +143,107 @@ static const struct backlight_ops pwm_backlight_ops = {
 };
 
 #ifdef CONFIG_OF
+#define PWM_LUMINANCE_SCALE	10000 /* luminance scale */
+
+/* An integer based power function */
+static u64 int_pow(u64 base, int exp)
+{
+	u64 result = 1;
+
+	while (exp) {
+		if (exp & 1)
+			result *= base;
+		exp >>= 1;
+		base *= base;
+	}
+
+	return result;
+}
+
+/*
+ * CIE lightness to PWM conversion.
+ *
+ * The CIE 1931 lightness formula is what actually describes how we perceive
+ * light:
+ *          Y = (L* / 902.3)           if L* ≤ 0.08856
+ *          Y = ((L* + 16) / 116)^3    if L* > 0.08856
+ *
+ * Where Y is the luminance, the amount of light coming out of the screen, and
+ * is a number between 0.0 and 1.0; and L* is the lightness, how bright a human
+ * perceives the screen to be, and is a number between 0 and 100.
+ *
+ * The following function does the fixed point maths needed to implement the
+ * above formula.
+ */
+static u64 cie1931(unsigned int lightness, unsigned int scale)
+{
+	u64 retval;
+
+	lightness *= 100;
+	if (lightness <= (8 * scale)) {
+		retval = DIV_ROUND_CLOSEST_ULL(lightness * 10, 9023);
+	} else {
+		retval = int_pow((lightness + (16 * scale)) / 116, 3);
+		retval = DIV_ROUND_CLOSEST_ULL(retval, (scale * scale));
+	}
+
+	return retval;
+}
+
+/*
+ * Create a default correction table for PWM values to create linear brightness
+ * for LED based backlights using the CIE1931 algorithm.
+ */
+static
+int pwm_backlight_brightness_default(struct device *dev,
+				     struct platform_pwm_backlight_data *data,
+				     unsigned int period)
+{
+	unsigned int counter = 0;
+	unsigned int i, n;
+	u64 retval;
+
+	/*
+	 * Count the number of bits needed to represent the period number. The
+	 * number of bits is used to calculate the number of levels used for the
+	 * brightness-levels table, the purpose of this calculation is have a
+	 * pre-computed table with enough levels to get linear brightness
+	 * perception. The period is divided by the number of bits so for a
+	 * 8-bit PWM we have 255 / 8 = 32 brightness levels or for a 16-bit PWM
+	 * we have 65535 / 16 = 4096 brightness levels.
+	 *
+	 * Note that this method is based on empirical testing on different
+	 * devices with PWM of 8 and 16 bits of resolution.
+	 */
+	n = period;
+	while (n) {
+		counter += n % 2;
+		n >>= 1;
+	}
+
+	data->max_brightness = DIV_ROUND_UP(period, counter);
+	data->levels = devm_kcalloc(dev, data->max_brightness,
+				    sizeof(*data->levels), GFP_KERNEL);
+	if (!data->levels)
+		return -ENOMEM;
+
+	/* Fill the table using the cie1931 algorithm */
+	for (i = 0; i < data->max_brightness; i++) {
+		retval = cie1931((i * PWM_LUMINANCE_SCALE) /
+				 data->max_brightness, PWM_LUMINANCE_SCALE) *
+				 period;
+		retval = DIV_ROUND_CLOSEST_ULL(retval, PWM_LUMINANCE_SCALE);
+		if (retval > UINT_MAX)
+			return -EINVAL;
+		data->levels[i] = (unsigned int)retval;
+	}
+
+	data->dft_brightness = data->max_brightness / 2;
+	data->max_brightness--;
+
+	return 0;
+}
+
 static int pwm_backlight_parse_dt(struct device *dev,
 				  struct platform_pwm_backlight_data *data)
 {
@@ -161,10 +262,13 @@ static int pwm_backlight_parse_dt(struct device *dev,
 
 	memset(data, 0, sizeof(*data));
 
-	/* determine the number of brightness levels */
+	/*
+	 * Determine the number of brightness levels, if this property is not
+	 * set a default table of brightness levels will be used.
+	 */
 	prop = of_find_property(node, "brightness-levels", &length);
 	if (!prop)
-		return -EINVAL;
+		return 0;
 
 	data->max_brightness = length / sizeof(u32);
 
@@ -294,6 +398,14 @@ static int pwm_backlight_parse_dt(struct device *dev,
 {
 	return -ENODEV;
 }
+
+static
+int pwm_backlight_brightness_default(struct device *dev,
+				     struct platform_pwm_backlight_data *data,
+				     unsigned int period)
+{
+	return -ENODEV;
+}
 #endif
 
 static int pwm_backlight_initial_power_state(const struct pwm_bl_data *pb)
@@ -334,7 +446,9 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	struct backlight_device *bl;
 	struct device_node *node = pdev->dev.of_node;
 	struct pwm_bl_data *pb;
+	struct pwm_state state;
 	struct pwm_args pargs;
+	unsigned int i;
 	int ret;
 
 	if (!data) {
@@ -359,17 +473,6 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		goto err_alloc;
 	}
 
-	if (data->levels) {
-		unsigned int i;
-
-		for (i = 0; i <= data->max_brightness; i++)
-			if (data->levels[i] > pb->scale)
-				pb->scale = data->levels[i];
-
-		pb->levels = data->levels;
-	} else
-		pb->scale = data->max_brightness;
-
 	pb->notify = data->notify;
 	pb->notify_after = data->notify_after;
 	pb->check_fb = data->check_fb;
@@ -436,6 +539,26 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 	dev_dbg(&pdev->dev, "got pwm for backlight\n");
 
+	if (!data->levels) {
+		/* Get the PWM period (in nanoseconds) */
+		pwm_get_state(pb->pwm, &state);
+
+		ret = pwm_backlight_brightness_default(&pdev->dev, data,
+						       state.period);
+		if (ret < 0) {
+			dev_err(&pdev->dev,
+				"failed to setup default brightness table\n");
+			goto err_alloc;
+		}
+	}
+
+	for (i = 0; i <= data->max_brightness; i++) {
+		if (data->levels[i] > pb->scale)
+			pb->scale = data->levels[i];
+
+		pb->levels = data->levels;
+	}
+
 	/*
 	 * FIXME: pwm_apply_args() should be removed when switching to
 	 * the atomic PWM API.

commit 573fe6d1c25c81b0af856ffafb516db7e8d978c5
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Mon Apr 9 10:33:30 2018 +0200

    backlight: pwm_bl: Linear interpolation between brightness-levels
    
    Setting num-interpolated-steps in the dts will allow you to have linear
    interpolation between values of brightness-levels. This way a high
    resolution pwm duty cycle can be used without having to list out every
    possible value in the dts. This system also allows for gamma corrected
    values.
    
    The most simple example is interpolate between two brightness values a
    number of steps, this can be done setting the following in the dts:
    
      brightness-levels = <0 65535>;
      num-interpolated-steps = <1024>;
      default-brightness-level = <512>;
    
    This will create a brightness-level table with the following values:
    
      <0 63 126 189 252 315 378 441 ... 64260 64323 64386 64449 65535>
    
    Another use case can be describe a gamma corrected curve, as we have
    better sensitivity at low luminance than high luminance we probably
    want have smaller steps for low brightness levels values and bigger
    steps for high brightness levels values. This can be achieved with
    the following in the dts:
    
      brightness-levels = <0 4096 65535>;
      num-interpolated-steps = <1024>;
      default-brightness-level = <512>;
    
    This will create a brightness-levels table with the following values:
    
      <0 4 8 12 16 20 ... 4096 4156 4216 4276 ... 65535>
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 44ac5bde4e9d..105f199a656d 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -147,7 +147,11 @@ static int pwm_backlight_parse_dt(struct device *dev,
 				  struct platform_pwm_backlight_data *data)
 {
 	struct device_node *node = dev->of_node;
+	unsigned int num_levels = 0;
+	unsigned int levels_count;
+	unsigned int num_steps;
 	struct property *prop;
+	unsigned int *table;
 	int length;
 	u32 value;
 	int ret;
@@ -167,6 +171,7 @@ static int pwm_backlight_parse_dt(struct device *dev,
 	/* read brightness levels from DT property */
 	if (data->max_brightness > 0) {
 		size_t size = sizeof(*data->levels) * data->max_brightness;
+		unsigned int i, j, n = 0;
 
 		data->levels = devm_kzalloc(dev, size, GFP_KERNEL);
 		if (!data->levels)
@@ -184,6 +189,84 @@ static int pwm_backlight_parse_dt(struct device *dev,
 			return ret;
 
 		data->dft_brightness = value;
+
+		/*
+		 * This property is optional, if is set enables linear
+		 * interpolation between each of the values of brightness levels
+		 * and creates a new pre-computed table.
+		 */
+		of_property_read_u32(node, "num-interpolated-steps",
+				     &num_steps);
+
+		/*
+		 * Make sure that there is at least two entries in the
+		 * brightness-levels table, otherwise we can't interpolate
+		 * between two points.
+		 */
+		if (num_steps) {
+			if (data->max_brightness < 2) {
+				dev_err(dev, "can't interpolate\n");
+				return -EINVAL;
+			}
+
+			/*
+			 * Recalculate the number of brightness levels, now
+			 * taking in consideration the number of interpolated
+			 * steps between two levels.
+			 */
+			for (i = 0; i < data->max_brightness - 1; i++) {
+				if ((data->levels[i + 1] - data->levels[i]) /
+				   num_steps)
+					num_levels += num_steps;
+				else
+					num_levels++;
+			}
+			num_levels++;
+			dev_dbg(dev, "new number of brightness levels: %d\n",
+				num_levels);
+
+			/*
+			 * Create a new table of brightness levels with all the
+			 * interpolated steps.
+			 */
+			size = sizeof(*table) * num_levels;
+			table = devm_kzalloc(dev, size, GFP_KERNEL);
+			if (!table)
+				return -ENOMEM;
+
+			/* Fill the interpolated table. */
+			levels_count = 0;
+			for (i = 0; i < data->max_brightness - 1; i++) {
+				value = data->levels[i];
+				n = (data->levels[i + 1] - value) / num_steps;
+				if (n > 0) {
+					for (j = 0; j < num_steps; j++) {
+						table[levels_count] = value;
+						value += n;
+						levels_count++;
+					}
+				} else {
+					table[levels_count] = data->levels[i];
+					levels_count++;
+				}
+			}
+			table[levels_count] = data->levels[i];
+
+			/*
+			 * As we use interpolation lets remove current
+			 * brightness levels table and replace for the
+			 * new interpolated table.
+			 */
+			devm_kfree(dev, data->levels);
+			data->levels = table;
+
+			/*
+			 * Reassign max_brightness value to the new total number
+			 * of brightness levels.
+			 */
+			data->max_brightness = num_levels;
+		}
+
 		data->max_brightness--;
 	}
 

commit bb084c0f61d659f0e6d371b096e0e57998f191d6
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Sun Jan 14 22:07:10 2018 +0100

    backlight: pwm_bl: Don't use GPIOF_* with gpiod_get_direction
    
    The documentation was wrong, gpiod_get_direction() returns 0/1 instead
    of the GPIOF_* flags. The docs were fixed with commit 94fc73094abe47
    ("gpio: correct docs about return value of gpiod_get_direction"). Now,
    fix this user (until a better, system-wide solution is in place).
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 8e3f1245f5c5..44ac5bde4e9d 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -321,14 +321,14 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 	/*
 	 * If the GPIO is not known to be already configured as output, that
-	 * is, if gpiod_get_direction returns either GPIOF_DIR_IN or -EINVAL,
-	 * change the direction to output and set the GPIO as active.
+	 * is, if gpiod_get_direction returns either 1 or -EINVAL, change the
+	 * direction to output and set the GPIO as active.
 	 * Do not force the GPIO to active when it was already output as it
 	 * could cause backlight flickering or we would enable the backlight too
 	 * early. Leave the decision of the initial backlight state for later.
 	 */
 	if (pb->enable_gpio &&
-	    gpiod_get_direction(pb->enable_gpio) != GPIOF_DIR_OUT)
+	    gpiod_get_direction(pb->enable_gpio) != 0)
 		gpiod_direction_output(pb->enable_gpio, 1);
 
 	pb->power_supply = devm_regulator_get(&pdev->dev, "power");

commit 3157694d8c7fed9046dece8b63434cafef21cbf6
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Wed Mar 28 19:03:25 2018 +0200

    pwm-backlight: Add support for PWM delays proprieties.
    
    Some panels (i.e. N116BGE-L41), in their power sequence specifications,
    request a delay between set the PWM signal and enable the backlight and
    between clear the PWM signal and disable the backlight. Add support for
    the new post-pwm-on-delay-ms and pwm-off-delay-ms proprieties to meet
    the timings.
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Acked-by: Jingoo Han <jingoohan1@gmail.com>
    Acked-by: Thierry Reding <thierry.reding@gmail.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 698ec68bcdc9..8e3f1245f5c5 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -10,6 +10,7 @@
  * published by the Free Software Foundation.
  */
 
+#include <linux/delay.h>
 #include <linux/gpio/consumer.h>
 #include <linux/gpio.h>
 #include <linux/module.h>
@@ -35,6 +36,8 @@ struct pwm_bl_data {
 	struct gpio_desc	*enable_gpio;
 	unsigned int		scale;
 	bool			legacy;
+	unsigned int		post_pwm_on_delay;
+	unsigned int		pwm_off_delay;
 	int			(*notify)(struct device *,
 					  int brightness);
 	void			(*notify_after)(struct device *,
@@ -56,6 +59,9 @@ static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness)
 
 	pwm_enable(pb->pwm);
 
+	if (pb->post_pwm_on_delay)
+		msleep(pb->post_pwm_on_delay);
+
 	if (pb->enable_gpio)
 		gpiod_set_value_cansleep(pb->enable_gpio, 1);
 
@@ -70,6 +76,9 @@ static void pwm_backlight_power_off(struct pwm_bl_data *pb)
 	if (pb->enable_gpio)
 		gpiod_set_value_cansleep(pb->enable_gpio, 0);
 
+	if (pb->pwm_off_delay)
+		msleep(pb->pwm_off_delay);
+
 	pwm_config(pb->pwm, 0, pb->period);
 	pwm_disable(pb->pwm);
 
@@ -178,6 +187,14 @@ static int pwm_backlight_parse_dt(struct device *dev,
 		data->max_brightness--;
 	}
 
+	/*
+	 * These values are optional and set as 0 by default, the out values
+	 * are modified only if a valid u32 value can be decoded.
+	 */
+	of_property_read_u32(node, "post-pwm-on-delay-ms",
+			     &data->post_pwm_on_delay);
+	of_property_read_u32(node, "pwm-off-delay-ms", &data->pwm_off_delay);
+
 	data->enable_gpio = -EINVAL;
 	return 0;
 }
@@ -276,6 +293,8 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	pb->exit = data->exit;
 	pb->dev = &pdev->dev;
 	pb->enabled = false;
+	pb->post_pwm_on_delay = data->post_pwm_on_delay;
+	pb->pwm_off_delay = data->pwm_off_delay;
 
 	pb->enable_gpio = devm_gpiod_get_optional(&pdev->dev, "enable",
 						  GPIOD_ASIS);

commit 5fb5caee92ba35a4a3baa61d45a78eb057e2c031
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Wed Mar 28 19:03:23 2018 +0200

    pwm-backlight: Enable/disable the PWM before/after LCD enable toggle.
    
    Before this patch the enable signal was set before the PWM signal and
    vice-versa on power off. This sequence is wrong, at least, it is on
    the different panels datasheets that I checked, so I inverted the sequence
    to follow the specs.
    
    For reference the following panels have the mentioned sequence:
      - N133HSE-EA1 (Innolux)
      - N116BGE (Innolux)
      - N156BGE-L21 (Innolux)
      - B101EAN0 (Auo)
      - B101AW03 (Auo)
      - LTN101NT05 (Samsung)
      - CLAA101WA01A (Chunghwa)
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Acked-by: Jingoo Han <jingoohan1@gmail.com>
    Acked-by: Thierry Reding <thierry.reding@gmail.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 1c2289ddd555..698ec68bcdc9 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -54,10 +54,11 @@ static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness)
 	if (err < 0)
 		dev_err(pb->dev, "failed to enable power supply\n");
 
+	pwm_enable(pb->pwm);
+
 	if (pb->enable_gpio)
 		gpiod_set_value_cansleep(pb->enable_gpio, 1);
 
-	pwm_enable(pb->pwm);
 	pb->enabled = true;
 }
 
@@ -66,12 +67,12 @@ static void pwm_backlight_power_off(struct pwm_bl_data *pb)
 	if (!pb->enabled)
 		return;
 
-	pwm_config(pb->pwm, 0, pb->period);
-	pwm_disable(pb->pwm);
-
 	if (pb->enable_gpio)
 		gpiod_set_value_cansleep(pb->enable_gpio, 0);
 
+	pwm_config(pb->pwm, 0, pb->period);
+	pwm_disable(pb->pwm);
+
 	regulator_disable(pb->power_supply);
 	pb->enabled = false;
 }

commit 5d0c49acebc9488e37db95f1d4a55644e545ffe7
Author: Derek Basehore <dbasehore@chromium.org>
Date:   Tue Aug 29 13:34:34 2017 -0700

    backlight: pwm_bl: Fix overflow condition
    
    This fixes an overflow condition that can happen with high max
    brightness and period values in compute_duty_cycle. This fixes it by
    using a 64 bit variable for computing the duty cycle.
    
    Signed-off-by: Derek Basehore <dbasehore@chromium.org>
    Acked-by: Thierry Reding <thierry.reding@gmail.com>
    Reviewed-by: Brian Norris <briannorris@chromium.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 9bd17682655a..1c2289ddd555 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -79,14 +79,17 @@ static void pwm_backlight_power_off(struct pwm_bl_data *pb)
 static int compute_duty_cycle(struct pwm_bl_data *pb, int brightness)
 {
 	unsigned int lth = pb->lth_brightness;
-	int duty_cycle;
+	u64 duty_cycle;
 
 	if (pb->levels)
 		duty_cycle = pb->levels[brightness];
 	else
 		duty_cycle = brightness;
 
-	return (duty_cycle * (pb->period - lth) / pb->scale) + lth;
+	duty_cycle *= pb->period - lth;
+	do_div(duty_cycle, pb->scale);
+
+	return duty_cycle + lth;
 }
 
 static int pwm_backlight_update_status(struct backlight_device *bl)

commit 62cdfe658535c39003d4d1b9d7f9b5a23a0db6bf
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Tue Jun 20 13:22:15 2017 +0530

    backlight: pwm_bl: Make of_device_ids const
    
    of_device_ids are not supposed to change at runtime. All functions
    working with of_device_ids provided by <linux/of.h> work with const
    of_device_ids. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Acked-by: Thierry Reding <thierry.reding@gmail.com>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 002f1ce22bd0..9bd17682655a 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -178,7 +178,7 @@ static int pwm_backlight_parse_dt(struct device *dev,
 	return 0;
 }
 
-static struct of_device_id pwm_backlight_of_match[] = {
+static const struct of_device_id pwm_backlight_of_match[] = {
 	{ .compatible = "pwm-backlight" },
 	{ }
 };

commit 892c7788c72480e8282b8aafe0783a244cc9f47f
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Apr 4 12:54:35 2017 +0200

    backlight: pwm_bl: Fix GPIO out for unimplemented .get_direction()
    
    Commit 7613c922315e308a ("backlight: pwm_bl: Move the checks for initial
    power state to a separate function") not just moved some code, but made
    slight changes in semantics.
    
    If a gpiochip doesn't implement the optional .get_direction() callback,
    gpiod_get_direction always returns -EINVAL, which is never equal to
    GPIOF_DIR_IN, leading to the GPIO not being configured for output.
    
    To avoid this, invert the test and check for not GPIOF_DIR_OUT instead,
    like the original code did.
    
    This restores the display on r8a7740/armadillo.
    
    Fixes: 7613c922315e308a ("backlight: pwm_bl: Move the checks for initial power state to a separate function")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index d7efcb632f7d..002f1ce22bd0 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -297,14 +297,15 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	}
 
 	/*
-	 * If the GPIO is configured as input, change the direction to output
-	 * and set the GPIO as active.
+	 * If the GPIO is not known to be already configured as output, that
+	 * is, if gpiod_get_direction returns either GPIOF_DIR_IN or -EINVAL,
+	 * change the direction to output and set the GPIO as active.
 	 * Do not force the GPIO to active when it was already output as it
 	 * could cause backlight flickering or we would enable the backlight too
 	 * early. Leave the decision of the initial backlight state for later.
 	 */
 	if (pb->enable_gpio &&
-	    gpiod_get_direction(pb->enable_gpio) == GPIOF_DIR_IN)
+	    gpiod_get_direction(pb->enable_gpio) != GPIOF_DIR_OUT)
 		gpiod_direction_output(pb->enable_gpio, 1);
 
 	pb->power_supply = devm_regulator_get(&pdev->dev, "power");

commit d1b81294575098d989be1f2f6bb628091ceaa87b
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue Nov 22 15:41:23 2016 +0200

    backlight: pwm_bl: Check the PWM state for initial backlight power state
    
    If the PWM is not enabled the backlight initially should not be enabled
    either if we have booted with DT and there is a phandle pointing to the
    backlight node.
    
    The patch extends the checks to decide if we should keep the backlight off
    initially.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 5712ddd053dd..d7efcb632f7d 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -215,6 +215,10 @@ static int pwm_backlight_initial_power_state(const struct pwm_bl_data *pb)
 	if (!regulator_is_enabled(pb->power_supply))
 		return FB_BLANK_POWERDOWN;
 
+	/* The PWM is disabled, keep it like this */
+	if (!pwm_is_enabled(pb->pwm))
+		return FB_BLANK_POWERDOWN;
+
 	return FB_BLANK_UNBLANK;
 }
 

commit 7613c922315e308a6486d802abed2eb74443dffd
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue Nov 22 15:41:22 2016 +0200

    backlight: pwm_bl: Move the checks for initial power state to a separate function
    
    Move the checks to select the initial state for the backlight to a new
    function and document the checks we are doing.
    
    With the separate function it is going to be easier to fix or improve the
    initial power state configuration later and it is easier to read the code.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Reviewed-by: Philipp Zabel <p.zabel@pengutronix.de>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 12614006211e..5712ddd053dd 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -192,6 +192,32 @@ static int pwm_backlight_parse_dt(struct device *dev,
 }
 #endif
 
+static int pwm_backlight_initial_power_state(const struct pwm_bl_data *pb)
+{
+	struct device_node *node = pb->dev->of_node;
+
+	/* Not booted with device tree or no phandle link to the node */
+	if (!node || !node->phandle)
+		return FB_BLANK_UNBLANK;
+
+	/*
+	 * If the driver is probed from the device tree and there is a
+	 * phandle link pointing to the backlight node, it is safe to
+	 * assume that another driver will enable the backlight at the
+	 * appropriate time. Therefore, if it is disabled, keep it so.
+	 */
+
+	/* if the enable GPIO is disabled, do not enable the backlight */
+	if (pb->enable_gpio && gpiod_get_value(pb->enable_gpio) == 0)
+		return FB_BLANK_POWERDOWN;
+
+	/* The regulator is disabled, do not enable the backlight */
+	if (!regulator_is_enabled(pb->power_supply))
+		return FB_BLANK_POWERDOWN;
+
+	return FB_BLANK_UNBLANK;
+}
+
 static int pwm_backlight_probe(struct platform_device *pdev)
 {
 	struct platform_pwm_backlight_data *data = dev_get_platdata(&pdev->dev);
@@ -200,7 +226,6 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	struct backlight_device *bl;
 	struct device_node *node = pdev->dev.of_node;
 	struct pwm_bl_data *pb;
-	int initial_blank = FB_BLANK_UNBLANK;
 	struct pwm_args pargs;
 	int ret;
 
@@ -267,20 +292,16 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		pb->enable_gpio = gpio_to_desc(data->enable_gpio);
 	}
 
-	if (pb->enable_gpio) {
-		/*
-		 * If the driver is probed from the device tree and there is a
-		 * phandle link pointing to the backlight node, it is safe to
-		 * assume that another driver will enable the backlight at the
-		 * appropriate time. Therefore, if it is disabled, keep it so.
-		 */
-		if (node && node->phandle &&
-		    gpiod_get_direction(pb->enable_gpio) == GPIOF_DIR_OUT &&
-		    gpiod_get_value(pb->enable_gpio) == 0)
-			initial_blank = FB_BLANK_POWERDOWN;
-		else
-			gpiod_direction_output(pb->enable_gpio, 1);
-	}
+	/*
+	 * If the GPIO is configured as input, change the direction to output
+	 * and set the GPIO as active.
+	 * Do not force the GPIO to active when it was already output as it
+	 * could cause backlight flickering or we would enable the backlight too
+	 * early. Leave the decision of the initial backlight state for later.
+	 */
+	if (pb->enable_gpio &&
+	    gpiod_get_direction(pb->enable_gpio) == GPIOF_DIR_IN)
+		gpiod_direction_output(pb->enable_gpio, 1);
 
 	pb->power_supply = devm_regulator_get(&pdev->dev, "power");
 	if (IS_ERR(pb->power_supply)) {
@@ -288,9 +309,6 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		goto err_alloc;
 	}
 
-	if (node && node->phandle && !regulator_is_enabled(pb->power_supply))
-		initial_blank = FB_BLANK_POWERDOWN;
-
 	pb->pwm = devm_pwm_get(&pdev->dev, NULL);
 	if (IS_ERR(pb->pwm) && PTR_ERR(pb->pwm) != -EPROBE_DEFER && !node) {
 		dev_err(&pdev->dev, "unable to request PWM, trying legacy API\n");
@@ -347,7 +365,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	}
 
 	bl->props.brightness = data->dft_brightness;
-	bl->props.power = initial_blank;
+	bl->props.power = pwm_backlight_initial_power_state(pb);
 	backlight_update_status(bl);
 
 	platform_set_drvdata(pdev, bl);

commit 0c9501f823a40a061f755d3789c4705c9fe85f14
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Wed Aug 31 10:18:12 2016 +0200

    backlight: pwm_bl: Handle gpio that can sleep
    
    Some backlight GPIOs might be connected to some i2c based expanders whose
    access might sleep.
    
    Since it's not in any critical path, use the cansleep variant of the GPIO
    API.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index b2b366bb0f97..12614006211e 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -55,7 +55,7 @@ static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness)
 		dev_err(pb->dev, "failed to enable power supply\n");
 
 	if (pb->enable_gpio)
-		gpiod_set_value(pb->enable_gpio, 1);
+		gpiod_set_value_cansleep(pb->enable_gpio, 1);
 
 	pwm_enable(pb->pwm);
 	pb->enabled = true;
@@ -70,7 +70,7 @@ static void pwm_backlight_power_off(struct pwm_bl_data *pb)
 	pwm_disable(pb->pwm);
 
 	if (pb->enable_gpio)
-		gpiod_set_value(pb->enable_gpio, 0);
+		gpiod_set_value_cansleep(pb->enable_gpio, 0);
 
 	regulator_disable(pb->power_supply);
 	pb->enabled = false;

commit 6cb9644db7364ff5d2980ccd365b8cb684145327
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Apr 14 21:17:29 2016 +0200

    backlight: pwm_bl: Use pwm_get_args() where appropriate
    
    The PWM framework has clarified the concept of reference PWM config (the
    platform dependent config retrieved from the DT or the PWM lookup table)
    and real PWM state.
    
    Use pwm_get_args() when the PWM user wants to retrieve this reference
    config and not the current state.
    
    This is part of the rework allowing the PWM framework to support
    hardware readout and expose real PWM state even when the PWM has just
    been requested (before the user calls pwm_config/enable/disable()).
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index a33a290fc956..b2b366bb0f97 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -201,6 +201,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	struct device_node *node = pdev->dev.of_node;
 	struct pwm_bl_data *pb;
 	int initial_blank = FB_BLANK_UNBLANK;
+	struct pwm_args pargs;
 	int ret;
 
 	if (!data) {
@@ -306,13 +307,20 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 	dev_dbg(&pdev->dev, "got pwm for backlight\n");
 
+	/*
+	 * FIXME: pwm_apply_args() should be removed when switching to
+	 * the atomic PWM API.
+	 */
+	pwm_apply_args(pb->pwm);
+
 	/*
 	 * The DT case will set the pwm_period_ns field to 0 and store the
 	 * period, parsed from the DT, in the PWM device. For the non-DT case,
 	 * set the period from platform data if it has not already been set
 	 * via the PWM lookup table.
 	 */
-	pb->period = pwm_get_period(pb->pwm);
+	pwm_get_args(pb->pwm, &pargs);
+	pb->period = pargs.period;
 	if (!pb->period && (data->pwm_period_ns > 0))
 		pb->period = data->pwm_period_ns;
 

commit 7f044b09b68d36811518c55f736a20648e8ed6e2
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Wed Mar 30 22:03:25 2016 +0200

    backlight: pwm_bl: Remove useless call to pwm_set_period()
    
    The PWM period will be set when calling pwm_config. Remove this useless
    call to pwm_set_period(), which might mess up the internal PWM state.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 64f9e1b8655f..a33a290fc956 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -313,10 +313,8 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	 * via the PWM lookup table.
 	 */
 	pb->period = pwm_get_period(pb->pwm);
-	if (!pb->period && (data->pwm_period_ns > 0)) {
+	if (!pb->period && (data->pwm_period_ns > 0))
 		pb->period = data->pwm_period_ns;
-		pwm_set_period(pb->pwm, data->pwm_period_ns);
-	}
 
 	pb->lth_brightness = data->lth_brightness * (pb->period / pb->scale);
 

commit 60d613d6aef4ae49988eeb3ad38af948c561db1e
Author: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
Date:   Sun Jun 14 17:32:14 2015 +0300

    backlight: pwm_bl: Free PWM requested by legacy API on error path
    
    If pwm is requested by legacy pwm_request() and if the following
    backlight_device_register() call fails, add pwm_free() clean-up.
    
    Signed-off-by: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index a22c1ec29de7..64f9e1b8655f 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -328,6 +328,8 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	if (IS_ERR(bl)) {
 		dev_err(&pdev->dev, "failed to register backlight\n");
 		ret = PTR_ERR(bl);
+		if (pb->legacy)
+			pwm_free(pb->pwm);
 		goto err_alloc;
 	}
 

commit 8777078015bb77f0561303b6dea23d40bd9f3053
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Thu Dec 10 10:09:06 2015 +0100

    backlight: pwm_bl: Fix broken PWM backlight for non-dt platforms
    
    Commit ee65ad0e2a9e ("backlight: pwm_bl: Avoid backlight flicker when
    probed from DT") tries to dereference the device of_node pointer
    unconditionally, causing a NULL pointer dereference on non-dt platforms.
    Fix it by replacing the phandle variable with a node variable and
    by checking that for NULL before dereferencing it.
    
    Reported-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Thierry Reding <thierry.reding@gmail.com>
    Tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 3daf9cc9bc31..a22c1ec29de7 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -198,8 +198,8 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	struct platform_pwm_backlight_data defdata;
 	struct backlight_properties props;
 	struct backlight_device *bl;
+	struct device_node *node = pdev->dev.of_node;
 	struct pwm_bl_data *pb;
-	phandle phandle = pdev->dev.of_node->phandle;
 	int initial_blank = FB_BLANK_UNBLANK;
 	int ret;
 
@@ -273,7 +273,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		 * assume that another driver will enable the backlight at the
 		 * appropriate time. Therefore, if it is disabled, keep it so.
 		 */
-		if (phandle &&
+		if (node && node->phandle &&
 		    gpiod_get_direction(pb->enable_gpio) == GPIOF_DIR_OUT &&
 		    gpiod_get_value(pb->enable_gpio) == 0)
 			initial_blank = FB_BLANK_POWERDOWN;
@@ -287,12 +287,11 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		goto err_alloc;
 	}
 
-	if (phandle && !regulator_is_enabled(pb->power_supply))
+	if (node && node->phandle && !regulator_is_enabled(pb->power_supply))
 		initial_blank = FB_BLANK_POWERDOWN;
 
 	pb->pwm = devm_pwm_get(&pdev->dev, NULL);
-	if (IS_ERR(pb->pwm) && PTR_ERR(pb->pwm) != -EPROBE_DEFER
-	    && !pdev->dev.of_node) {
+	if (IS_ERR(pb->pwm) && PTR_ERR(pb->pwm) != -EPROBE_DEFER && !node) {
 		dev_err(&pdev->dev, "unable to request PWM, trying legacy API\n");
 		pb->legacy = true;
 		pb->pwm = pwm_request(data->pwm_id, "pwm-backlight");

commit 3698d7e7d221a5c90d4b55e96d0c8f98a8b4d7df
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Wed Nov 18 18:12:25 2015 +0100

    backlight: pwm_bl: Avoid backlight flicker when probed from DT
    
    If the driver is probed from the device tree, and there is a phandle
    property set on it, and the enable GPIO is already configured as output,
    and the backlight is currently disabled, keep it disabled.
    If all these conditions are met, assume there will be some other driver
    that can enable the backlight at the appropriate time.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Reviewed-by: Christian Gmeiner <christian.gmeiner@gmail.com>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index ae3c6b6fd5db..3daf9cc9bc31 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -199,6 +199,8 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	struct backlight_properties props;
 	struct backlight_device *bl;
 	struct pwm_bl_data *pb;
+	phandle phandle = pdev->dev.of_node->phandle;
+	int initial_blank = FB_BLANK_UNBLANK;
 	int ret;
 
 	if (!data) {
@@ -242,7 +244,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	pb->enabled = false;
 
 	pb->enable_gpio = devm_gpiod_get_optional(&pdev->dev, "enable",
-						  GPIOD_OUT_HIGH);
+						  GPIOD_ASIS);
 	if (IS_ERR(pb->enable_gpio)) {
 		ret = PTR_ERR(pb->enable_gpio);
 		goto err_alloc;
@@ -264,12 +266,30 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		pb->enable_gpio = gpio_to_desc(data->enable_gpio);
 	}
 
+	if (pb->enable_gpio) {
+		/*
+		 * If the driver is probed from the device tree and there is a
+		 * phandle link pointing to the backlight node, it is safe to
+		 * assume that another driver will enable the backlight at the
+		 * appropriate time. Therefore, if it is disabled, keep it so.
+		 */
+		if (phandle &&
+		    gpiod_get_direction(pb->enable_gpio) == GPIOF_DIR_OUT &&
+		    gpiod_get_value(pb->enable_gpio) == 0)
+			initial_blank = FB_BLANK_POWERDOWN;
+		else
+			gpiod_direction_output(pb->enable_gpio, 1);
+	}
+
 	pb->power_supply = devm_regulator_get(&pdev->dev, "power");
 	if (IS_ERR(pb->power_supply)) {
 		ret = PTR_ERR(pb->power_supply);
 		goto err_alloc;
 	}
 
+	if (phandle && !regulator_is_enabled(pb->power_supply))
+		initial_blank = FB_BLANK_POWERDOWN;
+
 	pb->pwm = devm_pwm_get(&pdev->dev, NULL);
 	if (IS_ERR(pb->pwm) && PTR_ERR(pb->pwm) != -EPROBE_DEFER
 	    && !pdev->dev.of_node) {
@@ -320,6 +340,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	}
 
 	bl->props.brightness = data->dft_brightness;
+	bl->props.power = initial_blank;
 	backlight_update_status(bl);
 
 	platform_set_drvdata(pdev, bl);

commit dc881123aa1aeff02ce2dc94c2b810d37173aa90
Author: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
Date:   Mon Oct 12 15:29:03 2015 +0300

    backlight: pwm: Reject legacy PWM request for device defined in DT
    
    Platform PWM backlight data provided by board's device tree should be
    complete enough to successfully request a pwm device using pwm_get()
    API. This change fixes a bug, when an arbitrary (first found) PWM is
    connected to a "pwm-backlight" compatible device, when explicit PWM
    device reference is not given.
    
    Documentation/devicetree/bindings/video/backlight/pwm-backlight.txt
    already describes "pwms" as a required property, instead of blind
    selection of a potentially wrong PWM reject legacy PWM device
    registration request, leave legacy API only for non-dt cases.
    
    Based on initial implementation done by Dmitry Eremin-Solenikov.
    
    Reported-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Signed-off-by: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
    Acked-by: Thierry Reding <thierry.reding@gmail.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index eff379b234cc..ae3c6b6fd5db 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -271,19 +271,18 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	}
 
 	pb->pwm = devm_pwm_get(&pdev->dev, NULL);
-	if (IS_ERR(pb->pwm)) {
-		ret = PTR_ERR(pb->pwm);
-		if (ret == -EPROBE_DEFER)
-			goto err_alloc;
-
+	if (IS_ERR(pb->pwm) && PTR_ERR(pb->pwm) != -EPROBE_DEFER
+	    && !pdev->dev.of_node) {
 		dev_err(&pdev->dev, "unable to request PWM, trying legacy API\n");
 		pb->legacy = true;
 		pb->pwm = pwm_request(data->pwm_id, "pwm-backlight");
-		if (IS_ERR(pb->pwm)) {
-			dev_err(&pdev->dev, "unable to request legacy PWM\n");
-			ret = PTR_ERR(pb->pwm);
-			goto err_alloc;
-		}
+	}
+
+	if (IS_ERR(pb->pwm)) {
+		ret = PTR_ERR(pb->pwm);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "unable to request PWM\n");
+		goto err_alloc;
 	}
 
 	dev_dbg(&pdev->dev, "got pwm for backlight\n");

commit d59b92f93df2d545d87d2341eb0705cc926ea22a
Merge: e0456717e483 cca0ba2df3d4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 24 18:57:00 2015 -0700

    Merge tag 'backlight-for-linus-4.2' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/backlight
    
    Pull backlight updates from Lee Jones:
     "Changes to existing drivers:
    
       - supply MODULE_DEVICE_TABLE() to ensure probing
       - constify struct; da9052_bl
       - enable compile test; lcd_l4f00242t03, lcd_lms283fg05, backlight_gpio
       - suspend/resume bugfix; lp855x_bl
       - devm_gpiod_get_optional() API fixup; pwm_bl
       - error handling fixup; backlight"
    
    * tag 'backlight-for-linus-4.2' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/backlight:
      backlight: Change the return type of backlight_update_status() to int
      backlight: pwm_bl: Simplify usage of devm_gpiod_get_optional
      backlight: lp855x: Don't clear level on suspend/blank
      backlight: Allow compile test of GPIO consumers if !GPIOLIB
      video: backlight: da9052: Constify platform_device_id
      gpio-backlight: Discover driver during boot time

commit cdaefccefa988495e732d85d81914fbba99f4ca6
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sat May 16 22:08:10 2015 +0800

    backlight: pwm_bl: Simplify usage of devm_gpiod_get_optional
    
    Since 39b2bbe3d715 (gpio: add flags argument to gpiod_get*() functions),
    the gpiod_get* functions take an additional parameter that allows to
    specify direction and initial value for output.
    Simplify the usage of devm_gpiod_get_optional accordingly.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 3a145a643e0d..57cb9ec8be43 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -241,7 +241,8 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	pb->dev = &pdev->dev;
 	pb->enabled = false;
 
-	pb->enable_gpio = devm_gpiod_get_optional(&pdev->dev, "enable");
+	pb->enable_gpio = devm_gpiod_get_optional(&pdev->dev, "enable",
+						  GPIOD_OUT_HIGH);
 	if (IS_ERR(pb->enable_gpio)) {
 		ret = PTR_ERR(pb->enable_gpio);
 		goto err_alloc;
@@ -263,9 +264,6 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		pb->enable_gpio = gpio_to_desc(data->enable_gpio);
 	}
 
-	if (pb->enable_gpio)
-		gpiod_direction_output(pb->enable_gpio, 1);
-
 	pb->power_supply = devm_regulator_get(&pdev->dev, "power");
 	if (IS_ERR(pb->power_supply)) {
 		ret = PTR_ERR(pb->power_supply);

commit 68feaca0b13e453aa14ee064c1736202b48b342f
Author: Nicolas Ferre <nicolas.ferre@atmel.com>
Date:   Thu Feb 19 10:30:14 2015 +0100

    backlight: pwm: Handle EPROBE_DEFER while requesting the PWM
    
    When trying to request the PWM device with devm_pwm_get(), the EPROBE_DEFER
    flag is not handled properly. It can lead to the PWM not being found.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Acked-by: Thierry Reding <thierry.reding@gmail.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 3a145a643e0d..6897f1c1bc73 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -274,6 +274,10 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 	pb->pwm = devm_pwm_get(&pdev->dev, NULL);
 	if (IS_ERR(pb->pwm)) {
+		ret = PTR_ERR(pb->pwm);
+		if (ret == -EPROBE_DEFER)
+			goto err_alloc;
+
 		dev_err(&pdev->dev, "unable to request PWM, trying legacy API\n");
 		pb->legacy = true;
 		pb->pwm = pwm_request(data->pwm_id, "pwm-backlight");

commit edf387b6d1a6993103ec95ed934a6daf559535f4
Author: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
Date:   Sat Oct 11 16:46:26 2014 +0300

    backlight: pwm: Clean-up pwm requested using legacy API
    
    If PWM device is requested by means of legacy API pwm_request(), its
    resources are not freed on module unbind, which may cause an oops on
    access, e.g. by reading /sys/kernel/debug/pwm.
    
    Reported-by: Dmitry Eremin-Solenikov <dmitry_eremin@mentor.com>
    Signed-off-by: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index cb5ae4c08469..3a145a643e0d 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -34,6 +34,7 @@ struct pwm_bl_data {
 	struct regulator	*power_supply;
 	struct gpio_desc	*enable_gpio;
 	unsigned int		scale;
+	bool			legacy;
 	int			(*notify)(struct device *,
 					  int brightness);
 	void			(*notify_after)(struct device *,
@@ -274,7 +275,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	pb->pwm = devm_pwm_get(&pdev->dev, NULL);
 	if (IS_ERR(pb->pwm)) {
 		dev_err(&pdev->dev, "unable to request PWM, trying legacy API\n");
-
+		pb->legacy = true;
 		pb->pwm = pwm_request(data->pwm_id, "pwm-backlight");
 		if (IS_ERR(pb->pwm)) {
 			dev_err(&pdev->dev, "unable to request legacy PWM\n");
@@ -339,6 +340,8 @@ static int pwm_backlight_remove(struct platform_device *pdev)
 
 	if (pb->exit)
 		pb->exit(&pdev->dev);
+	if (pb->legacy)
+		pwm_free(pb->pwm);
 
 	return 0;
 }

commit 4e0b7fe38345b81930363b9f1b4b324181ddcc9e
Merge: f43b179bbd84 b6af73b42219
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 11 06:38:33 2014 -0400

    Merge tag 'backlight-for-linus-3.18' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/backlight
    
    Pull backlight driver updates from Lee Jones:
     "Changes to existing drivers:
       - Checkpatch fixes
       - Removal of unused code in generic_bl
       - Removal of superfluous .owner attribute
    
      No new or removed drivers/supported devices"
    
    * tag 'backlight-for-linus-3.18' of git://git.kernel.org/pub/scm/linux/kernel/git/lee/backlight:
      backlight: omap1: add blank line after declarations
      backlight: jornada720: Remove 'else' after a return
      backlight: jornada720: Remove 'else' after a return
      backlight: wm831x_bl: Add blank line after declarations
      backlight: tdo24m: Add blank line after declarations
      backlight: s6e63m0: Remove 'else' after a return
      backlight: pcf50633: Add blank line after declarations
      backlight: lp855x: Add blank line after declarations
      backlight: lms501kf03: Remove 'else' after a return
      backlight: lm3639: Remove unnecessary return statements
      backlight: ld9040: Remove 'else' after a return
      backlight: ili922x: Remove 'else' after a return
      backlight: cr_bllcd: Add blank line after declarations
      backlight: corgi_lcd: Add blank line after declarations
      backlight: ams369fg06: Remove 'else' after a return
      backlight: adp8870: Add blank line after declarations
      backlight: adp8860: Add blank line after declarations
      backlight: adp5520: Add blank line after declarations
      backlight: generic_bl: Remove unused function
      backlight: Remove .owner field for drivers using module_platform_driver

commit 6728f2b109392484d38ac9e365496ac5fa1071f1
Author: Peter Griffin <peter.griffin@linaro.org>
Date:   Wed Aug 13 13:38:38 2014 +0100

    backlight: Remove .owner field for drivers using module_platform_driver
    
    This patch removes the superflous .owner field for drivers which
    use the module_platform_driver or platform_driver_register api,
    as this is overriden in __platform_driver_register.
    
    Signed-off-by: Peter Griffin <peter.griffin@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index d7a3d13e72ec..20963ed5077d 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -389,7 +389,6 @@ static const struct dev_pm_ops pwm_backlight_pm_ops = {
 static struct platform_driver pwm_backlight_driver = {
 	.driver		= {
 		.name		= "pwm-backlight",
-		.owner		= THIS_MODULE,
 		.pm		= &pwm_backlight_pm_ops,
 		.of_match_table	= of_match_ptr(pwm_backlight_of_match),
 	},

commit 937222c4dda495277a8dfbc18bf7e54fe670105c
Author: Lothar Waßmann <LW@KARO-electronics.de>
Date:   Wed Aug 20 08:38:36 2014 +0200

    pwm-backlight: Fix bogus request for GPIO#0 when instantiated from DT
    
    commit 257462dbf3ed ("pwm-backlight: switch to gpiod interface")
    introduced a regression leading to acquiring a bogus GPIO-0 when
    configured from DT without an 'enable-gpios' property.
    The driver will happily accept the 0 initialized 'enable_gpio' member
    of the struct platform_pwm_backlight_data as valid gpio number, and
    request this GPIO as enable pin. In case of multiple driver instances,
    the second will fail to register with the error message:
    pwm-backlight backlight1.23: failed to request GPIO#0: -16
    
    Fix this by setting enable_gpio in the pdata struct to -EINVAL.
    
    Signed-off-by: Lothar Waßmann <LW@KARO-electronics.de>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index d7a3d13e72ec..b85983e97f0a 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -173,6 +173,7 @@ static int pwm_backlight_parse_dt(struct device *dev,
 		data->max_brightness--;
 	}
 
+	data->enable_gpio = -EINVAL;
 	return 0;
 }
 

commit ff9c5422d8ebae60bafedf8608ec54d4d87a6bc0
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Wed Jun 25 18:18:18 2014 +0900

    backlight: pwm-backlight: Use devm_gpiod_get_optional()
    
    Make use of the new devm_gpiod_get_optional() to simplify the probe
    code.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index c9c8496369b3..d7a3d13e72ec 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -239,13 +239,10 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	pb->dev = &pdev->dev;
 	pb->enabled = false;
 
-	pb->enable_gpio = devm_gpiod_get(&pdev->dev, "enable");
+	pb->enable_gpio = devm_gpiod_get_optional(&pdev->dev, "enable");
 	if (IS_ERR(pb->enable_gpio)) {
 		ret = PTR_ERR(pb->enable_gpio);
-		if (ret == -ENOENT)
-			pb->enable_gpio = NULL;
-		else
-			goto err_alloc;
+		goto err_alloc;
 	}
 
 	/*

commit a5d8e2e73c7f1dcee485d55225628317d8d441c0
Author: Andrzej Hajda <a.hajda@samsung.com>
Date:   Fri May 30 12:10:50 2014 +0200

    backlight: Remove trivial get_brightness implementations
    
    Since backlight core returns props.brightness in case get_brightness
    is not implemented trivial implementations are not needed anymore.
    
    Acked-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 38ca88bc5c3e..c9c8496369b3 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -115,11 +115,6 @@ static int pwm_backlight_update_status(struct backlight_device *bl)
 	return 0;
 }
 
-static int pwm_backlight_get_brightness(struct backlight_device *bl)
-{
-	return bl->props.brightness;
-}
-
 static int pwm_backlight_check_fb(struct backlight_device *bl,
 				  struct fb_info *info)
 {
@@ -130,7 +125,6 @@ static int pwm_backlight_check_fb(struct backlight_device *bl,
 
 static const struct backlight_ops pwm_backlight_ops = {
 	.update_status	= pwm_backlight_update_status,
-	.get_brightness	= pwm_backlight_get_brightness,
 	.check_fb	= pwm_backlight_check_fb,
 };
 

commit 16fc3352ea58b481f879f8d965b98208ccc279c2
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Mon May 19 22:42:42 2014 +0200

    pwm-backlight: retrieve configured PWM period
    
    The PWM core is now able to initialize the PWM period from a lookup
    table defined by board files. Use it if available and fallback to the
    value supplied in pwm_period_ns.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index cc49347bbcc0..38ca88bc5c3e 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -296,12 +296,15 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	/*
 	 * The DT case will set the pwm_period_ns field to 0 and store the
 	 * period, parsed from the DT, in the PWM device. For the non-DT case,
-	 * set the period from platform data.
+	 * set the period from platform data if it has not already been set
+	 * via the PWM lookup table.
 	 */
-	if (data->pwm_period_ns > 0)
+	pb->period = pwm_get_period(pb->pwm);
+	if (!pb->period && (data->pwm_period_ns > 0)) {
+		pb->period = data->pwm_period_ns;
 		pwm_set_period(pb->pwm, data->pwm_period_ns);
+	}
 
-	pb->period = pwm_get_period(pb->pwm);
 	pb->lth_brightness = data->lth_brightness * (pb->period / pb->scale);
 
 	memset(&props, 0, sizeof(struct backlight_properties));

commit 257462dbf3ed233de0dc2e489dcc58579535b33f
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Thu Feb 27 14:53:34 2014 +0900

    pwm-backlight: switch to gpiod interface
    
    Switch to the new gpiod interface, which allows to handle GPIO
    properties such as active low transparently and removes a whole bunch of
    code.
    
    There are still a couple of users of this driver that rely on passing
    the enable GPIO number through platform data, so a fallback mechanism
    using a GPIO number is still available to avoid breaking them. It will
    be removed once current users have switched to the GPIO lookup tables
    provided by the gpiod interface.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index fa7f5c35b7fb..cc49347bbcc0 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -10,8 +10,8 @@
  * published by the Free Software Foundation.
  */
 
+#include <linux/gpio/consumer.h>
 #include <linux/gpio.h>
-#include <linux/of_gpio.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -32,8 +32,7 @@ struct pwm_bl_data {
 	unsigned int		*levels;
 	bool			enabled;
 	struct regulator	*power_supply;
-	int			enable_gpio;
-	unsigned long		enable_gpio_flags;
+	struct gpio_desc	*enable_gpio;
 	unsigned int		scale;
 	int			(*notify)(struct device *,
 					  int brightness);
@@ -54,12 +53,8 @@ static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness)
 	if (err < 0)
 		dev_err(pb->dev, "failed to enable power supply\n");
 
-	if (gpio_is_valid(pb->enable_gpio)) {
-		if (pb->enable_gpio_flags & PWM_BACKLIGHT_GPIO_ACTIVE_LOW)
-			gpio_set_value(pb->enable_gpio, 0);
-		else
-			gpio_set_value(pb->enable_gpio, 1);
-	}
+	if (pb->enable_gpio)
+		gpiod_set_value(pb->enable_gpio, 1);
 
 	pwm_enable(pb->pwm);
 	pb->enabled = true;
@@ -73,12 +68,8 @@ static void pwm_backlight_power_off(struct pwm_bl_data *pb)
 	pwm_config(pb->pwm, 0, pb->period);
 	pwm_disable(pb->pwm);
 
-	if (gpio_is_valid(pb->enable_gpio)) {
-		if (pb->enable_gpio_flags & PWM_BACKLIGHT_GPIO_ACTIVE_LOW)
-			gpio_set_value(pb->enable_gpio, 1);
-		else
-			gpio_set_value(pb->enable_gpio, 0);
-	}
+	if (pb->enable_gpio)
+		gpiod_set_value(pb->enable_gpio, 0);
 
 	regulator_disable(pb->power_supply);
 	pb->enabled = false;
@@ -148,7 +139,6 @@ static int pwm_backlight_parse_dt(struct device *dev,
 				  struct platform_pwm_backlight_data *data)
 {
 	struct device_node *node = dev->of_node;
-	enum of_gpio_flags flags;
 	struct property *prop;
 	int length;
 	u32 value;
@@ -189,14 +179,6 @@ static int pwm_backlight_parse_dt(struct device *dev,
 		data->max_brightness--;
 	}
 
-	data->enable_gpio = of_get_named_gpio_flags(node, "enable-gpios", 0,
-						    &flags);
-	if (data->enable_gpio == -EPROBE_DEFER)
-		return -EPROBE_DEFER;
-
-	if (gpio_is_valid(data->enable_gpio) && (flags & OF_GPIO_ACTIVE_LOW))
-		data->enable_gpio_flags |= PWM_BACKLIGHT_GPIO_ACTIVE_LOW;
-
 	return 0;
 }
 
@@ -256,8 +238,6 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	} else
 		pb->scale = data->max_brightness;
 
-	pb->enable_gpio = data->enable_gpio;
-	pb->enable_gpio_flags = data->enable_gpio_flags;
 	pb->notify = data->notify;
 	pb->notify_after = data->notify_after;
 	pb->check_fb = data->check_fb;
@@ -265,26 +245,38 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	pb->dev = &pdev->dev;
 	pb->enabled = false;
 
-	if (gpio_is_valid(pb->enable_gpio)) {
-		unsigned long flags;
-
-		if (pb->enable_gpio_flags & PWM_BACKLIGHT_GPIO_ACTIVE_LOW)
-			flags = GPIOF_OUT_INIT_HIGH;
+	pb->enable_gpio = devm_gpiod_get(&pdev->dev, "enable");
+	if (IS_ERR(pb->enable_gpio)) {
+		ret = PTR_ERR(pb->enable_gpio);
+		if (ret == -ENOENT)
+			pb->enable_gpio = NULL;
 		else
-			flags = GPIOF_OUT_INIT_LOW;
+			goto err_alloc;
+	}
 
-		ret = gpio_request_one(pb->enable_gpio, flags, "enable");
+	/*
+	 * Compatibility fallback for drivers still using the integer GPIO
+	 * platform data. Must go away soon.
+	 */
+	if (!pb->enable_gpio && gpio_is_valid(data->enable_gpio)) {
+		ret = devm_gpio_request_one(&pdev->dev, data->enable_gpio,
+					    GPIOF_OUT_INIT_HIGH, "enable");
 		if (ret < 0) {
 			dev_err(&pdev->dev, "failed to request GPIO#%d: %d\n",
-				pb->enable_gpio, ret);
+				data->enable_gpio, ret);
 			goto err_alloc;
 		}
+
+		pb->enable_gpio = gpio_to_desc(data->enable_gpio);
 	}
 
+	if (pb->enable_gpio)
+		gpiod_direction_output(pb->enable_gpio, 1);
+
 	pb->power_supply = devm_regulator_get(&pdev->dev, "power");
 	if (IS_ERR(pb->power_supply)) {
 		ret = PTR_ERR(pb->power_supply);
-		goto err_gpio;
+		goto err_alloc;
 	}
 
 	pb->pwm = devm_pwm_get(&pdev->dev, NULL);
@@ -295,7 +287,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		if (IS_ERR(pb->pwm)) {
 			dev_err(&pdev->dev, "unable to request legacy PWM\n");
 			ret = PTR_ERR(pb->pwm);
-			goto err_gpio;
+			goto err_alloc;
 		}
 	}
 
@@ -320,7 +312,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	if (IS_ERR(bl)) {
 		dev_err(&pdev->dev, "failed to register backlight\n");
 		ret = PTR_ERR(bl);
-		goto err_gpio;
+		goto err_alloc;
 	}
 
 	if (data->dft_brightness > data->max_brightness) {
@@ -336,9 +328,6 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, bl);
 	return 0;
 
-err_gpio:
-	if (gpio_is_valid(pb->enable_gpio))
-		gpio_free(pb->enable_gpio);
 err_alloc:
 	if (data->exit)
 		data->exit(&pdev->dev);

commit 5f33b896246a2d9bdf01352de11d4dab96ba2fc9
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Apr 29 17:28:59 2014 +0200

    pwm-backlight: Disable backlight on shutdown
    
    When a device is shut down, make sure to disable the backlight. If it
    stays lit, it gives the impression that the device hasn't turned off.
    Furthermore keeping the backlight on may consume power, which is not
    what users expect when they shut down a device.
    
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index b75201ff46f6..fa7f5c35b7fb 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -359,6 +359,14 @@ static int pwm_backlight_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static void pwm_backlight_shutdown(struct platform_device *pdev)
+{
+	struct backlight_device *bl = platform_get_drvdata(pdev);
+	struct pwm_bl_data *pb = bl_get_data(bl);
+
+	pwm_backlight_power_off(pb);
+}
+
 #ifdef CONFIG_PM_SLEEP
 static int pwm_backlight_suspend(struct device *dev)
 {
@@ -404,6 +412,7 @@ static struct platform_driver pwm_backlight_driver = {
 	},
 	.probe		= pwm_backlight_probe,
 	.remove		= pwm_backlight_remove,
+	.shutdown	= pwm_backlight_shutdown,
 };
 
 module_platform_driver(pwm_backlight_driver);

commit ca7a97add4d4a7b0602b3bd1eff5c89da8636713
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Sun Dec 1 13:04:03 2013 -0200

    backlight: pwm_bl: Remove error message upon devm_kzalloc() failure
    
    No need to have a specific OOM message, since there is generic MM out of memory
    message in place.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index fb80d68f4d33..b75201ff46f6 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -241,7 +241,6 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 	pb = devm_kzalloc(&pdev->dev, sizeof(*pb), GFP_KERNEL);
 	if (!pb) {
-		dev_err(&pdev->dev, "no memory for state\n");
 		ret = -ENOMEM;
 		goto err_alloc;
 	}

commit 0bde7294e2ada03d0f1cc61cec51274081d9a9cf
Merge: 449bf8d03c5b 1b3f25ce991d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Nov 16 12:21:40 2013 -0800

    Merge tag 'pwm/for-3.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/thierry.reding/linux-pwm
    
    Pull pwm changes from Thierry Reding:
     "Mostly bug fixes and clean up.  There is a new driver, which is
      actually moving a custom PWM driver from drivers/misc.
    
      The majority of the patches are enhancements to the device tree
      support in the pwm-backlight driver.  Backlights can now additionally
      be powered using a regulator and enabled using a GPIO in addition to
      just the PWM input"
    
    * tag 'pwm/for-3.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/thierry.reding/linux-pwm: (30 commits)
      Documentation/pwm: Update supported SoC name for pwm-samsung
      pwm: samsung: Fix kernel warning while unexporting a channel
      MAINTAINERS: Move PWM subsystem tree to kernel.org
      Documentation/pwm: Fix trivial typos
      pwm-backlight: Remove unused variable
      pwm_backlight: avoid short blank screen while doing hibernation
      pwm-backlight: Fix brightness adjustment
      pwm: add ep93xx PWM support
      pwm-backlight: Allow for non-increasing brightness levels
      pwm-backlight: Add power supply support
      pwm-backlight: Use new enable_gpio field
      unicore32: Initialize PWM backlight enable_gpio field
      ARM: shmobile: Initialize PWM backlight enable_gpio field
      ARM: SAMSUNG: Initialize PWM backlight enable_gpio field
      ARM: pxa: Initialize PWM backlight enable_gpio field
      ARM: OMAP: Initialize PWM backlight enable_gpio field
      pwm-backlight: Add optional enable GPIO
      pwm-backlight: Track enable state
      pwm-backlight: Refactor backlight power on/off
      pwm-backlight: Improve readability
      ...

commit c512794cada491e008eeca822af7e4ad5db72a56
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Nov 12 15:09:04 2013 -0800

    backlight: use dev_get_platdata()
    
    Use the wrapper function for retrieving the platform data instead of
    accessing dev->platform_data directly.  This is a cosmetic change to
    make the code simpler and enhance the readability.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 1fea627394d7..36db5d98dd2f 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -163,7 +163,7 @@ static int pwm_backlight_parse_dt(struct device *dev,
 
 static int pwm_backlight_probe(struct platform_device *pdev)
 {
-	struct platform_pwm_backlight_data *data = pdev->dev.platform_data;
+	struct platform_pwm_backlight_data *data = dev_get_platdata(&pdev->dev);
 	struct platform_pwm_backlight_data defdata;
 	struct backlight_properties props;
 	struct backlight_device *bl;

commit 73d4e2b82b4bb1571b1a7f97012c0db8a0faef42
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Tue Oct 22 09:37:05 2013 +0200

    pwm-backlight: Remove unused variable
    
    I forgot to remove this during earlier cleanup patches and only checked
    various builds for errors, not warnings.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 299533491a95..368232af78d2 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -45,7 +45,7 @@ struct pwm_bl_data {
 
 static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness)
 {
-	int duty_cycle, err;
+	int err;
 
 	if (pb->enabled)
 		return;

commit 1dea1fd09246ada581a99d0669108eea94b7bfee
Author: Huayi Li <huayi.li@csr.com>
Date:   Wed Oct 9 10:33:02 2013 +0800

    pwm_backlight: avoid short blank screen while doing hibernation
    
    Use SIMPLE_DEV_PM_OPS macro will initialize the member "freeze"
    and "thaw" of pwm_backlight_pm_ops as below,
            .freeze = suspend_fn,
            .thaw = resume_fn,
    then during the process of making hibernation snapshot, screen
    will be blank at the moment of freezing, and then light at the
    moment of thawing.
    this is not the right user experience for suspending to disk.
    
    so this patch drops freeze and thaw callback, make the LCD is
    always lighting before the final shutdown.
    
    Signed-off-by: Huayi Li <huayi.li@csr.com>
    Signed-off-by: Barry Song <Baohua.Song@csr.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index f77a7b0ca5e6..299533491a95 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -387,8 +387,14 @@ static int pwm_backlight_resume(struct device *dev)
 }
 #endif
 
-static SIMPLE_DEV_PM_OPS(pwm_backlight_pm_ops, pwm_backlight_suspend,
-			 pwm_backlight_resume);
+static const struct dev_pm_ops pwm_backlight_pm_ops = {
+#ifdef CONFIG_PM_SLEEP
+	.suspend = pwm_backlight_suspend,
+	.resume = pwm_backlight_resume,
+	.poweroff = pwm_backlight_suspend,
+	.restore = pwm_backlight_resume,
+#endif
+};
 
 static struct platform_driver pwm_backlight_driver = {
 	.driver		= {

commit e4bfeda96872bfe6015cd360008b77cd3b981b2b
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Oct 18 10:46:24 2013 +0200

    pwm-backlight: Fix brightness adjustment
    
    Split adjustment of the brightness (by changing the PWM duty cycle) from
    the power on sequence. This fixes an issue where the brightness can no
    longer be updated once the backlight has been enabled.
    
    Reported-by: Marc Dietrich <marvin24@gmx.de>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 32e96e3525a1..f77a7b0ca5e6 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -45,21 +45,11 @@ struct pwm_bl_data {
 
 static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness)
 {
-	unsigned int lth = pb->lth_brightness;
 	int duty_cycle, err;
 
 	if (pb->enabled)
 		return;
 
-	if (pb->levels)
-		duty_cycle = pb->levels[brightness];
-	else
-		duty_cycle = brightness;
-
-	duty_cycle = (duty_cycle * (pb->period - lth) / pb->scale) + lth;
-
-	pwm_config(pb->pwm, duty_cycle, pb->period);
-
 	err = regulator_enable(pb->power_supply);
 	if (err < 0)
 		dev_err(pb->dev, "failed to enable power supply\n");
@@ -94,10 +84,24 @@ static void pwm_backlight_power_off(struct pwm_bl_data *pb)
 	pb->enabled = false;
 }
 
+static int compute_duty_cycle(struct pwm_bl_data *pb, int brightness)
+{
+	unsigned int lth = pb->lth_brightness;
+	int duty_cycle;
+
+	if (pb->levels)
+		duty_cycle = pb->levels[brightness];
+	else
+		duty_cycle = brightness;
+
+	return (duty_cycle * (pb->period - lth) / pb->scale) + lth;
+}
+
 static int pwm_backlight_update_status(struct backlight_device *bl)
 {
 	struct pwm_bl_data *pb = bl_get_data(bl);
 	int brightness = bl->props.brightness;
+	int duty_cycle;
 
 	if (bl->props.power != FB_BLANK_UNBLANK ||
 	    bl->props.fb_blank != FB_BLANK_UNBLANK ||
@@ -107,9 +111,11 @@ static int pwm_backlight_update_status(struct backlight_device *bl)
 	if (pb->notify)
 		brightness = pb->notify(pb->dev, brightness);
 
-	if (brightness > 0)
+	if (brightness > 0) {
+		duty_cycle = compute_duty_cycle(pb, brightness);
+		pwm_config(pb->pwm, duty_cycle, pb->period);
 		pwm_backlight_power_on(pb, brightness);
-	else
+	} else
 		pwm_backlight_power_off(pb);
 
 	if (pb->notify_after)

commit 8f43e18e2769b3b28383903d501b4da29e388aad
Author: Mike Dunn <mikedunn@newsguy.com>
Date:   Sun Sep 22 09:59:56 2013 -0700

    pwm-backlight: Allow for non-increasing brightness levels
    
    Currently the driver assumes that the values specified in the
    brightness-levels device tree property increase as they are parsed from
    left to right.  But boards that invert the signal between the PWM output
    and the backlight will need to specify decreasing brightness-levels.
    This patch removes the assumption that the last element of the array is
    the maximum value, and instead searches the array for the maximum value
    and uses that in the duty cycle calculation.
    
    Signed-off-by: Mike Dunn <mikedunn@newsguy.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index eec6c98527f9..32e96e3525a1 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -34,6 +34,7 @@ struct pwm_bl_data {
 	struct regulator	*power_supply;
 	int			enable_gpio;
 	unsigned long		enable_gpio_flags;
+	unsigned int		scale;
 	int			(*notify)(struct device *,
 					  int brightness);
 	void			(*notify_after)(struct device *,
@@ -42,23 +43,20 @@ struct pwm_bl_data {
 	void			(*exit)(struct device *);
 };
 
-static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness,
-				   int max)
+static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness)
 {
+	unsigned int lth = pb->lth_brightness;
 	int duty_cycle, err;
 
 	if (pb->enabled)
 		return;
 
-	if (pb->levels) {
+	if (pb->levels)
 		duty_cycle = pb->levels[brightness];
-		max = pb->levels[max];
-	} else {
+	else
 		duty_cycle = brightness;
-	}
 
-	duty_cycle = (duty_cycle * (pb->period - pb->lth_brightness) / max) +
-		     pb->lth_brightness;
+	duty_cycle = (duty_cycle * (pb->period - lth) / pb->scale) + lth;
 
 	pwm_config(pb->pwm, duty_cycle, pb->period);
 
@@ -100,7 +98,6 @@ static int pwm_backlight_update_status(struct backlight_device *bl)
 {
 	struct pwm_bl_data *pb = bl_get_data(bl);
 	int brightness = bl->props.brightness;
-	int max = bl->props.max_brightness;
 
 	if (bl->props.power != FB_BLANK_UNBLANK ||
 	    bl->props.fb_blank != FB_BLANK_UNBLANK ||
@@ -111,7 +108,7 @@ static int pwm_backlight_update_status(struct backlight_device *bl)
 		brightness = pb->notify(pb->dev, brightness);
 
 	if (brightness > 0)
-		pwm_backlight_power_on(pb, brightness, max);
+		pwm_backlight_power_on(pb, brightness);
 	else
 		pwm_backlight_power_off(pb);
 
@@ -218,7 +215,6 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	struct backlight_properties props;
 	struct backlight_device *bl;
 	struct pwm_bl_data *pb;
-	unsigned int max;
 	int ret;
 
 	if (!data) {
@@ -245,10 +241,15 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	}
 
 	if (data->levels) {
-		max = data->levels[data->max_brightness];
+		unsigned int i;
+
+		for (i = 0; i <= data->max_brightness; i++)
+			if (data->levels[i] > pb->scale)
+				pb->scale = data->levels[i];
+
 		pb->levels = data->levels;
 	} else
-		max = data->max_brightness;
+		pb->scale = data->max_brightness;
 
 	pb->enable_gpio = data->enable_gpio;
 	pb->enable_gpio_flags = data->enable_gpio_flags;
@@ -304,7 +305,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		pwm_set_period(pb->pwm, data->pwm_period_ns);
 
 	pb->period = pwm_get_period(pb->pwm);
-	pb->lth_brightness = data->lth_brightness * (pb->period / max);
+	pb->lth_brightness = data->lth_brightness * (pb->period / pb->scale);
 
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;

commit 22ceeee16eb8f0d04de3ef43a5174fb30ec18af9
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Aug 30 12:38:34 2013 +0200

    pwm-backlight: Add power supply support
    
    Backlights require a power supply to work properly. This commit adds a
    regulator to power up and power down the backlight.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index cdef4a346555..eec6c98527f9 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -21,6 +21,7 @@
 #include <linux/err.h>
 #include <linux/pwm.h>
 #include <linux/pwm_backlight.h>
+#include <linux/regulator/consumer.h>
 #include <linux/slab.h>
 
 struct pwm_bl_data {
@@ -30,6 +31,7 @@ struct pwm_bl_data {
 	unsigned int		lth_brightness;
 	unsigned int		*levels;
 	bool			enabled;
+	struct regulator	*power_supply;
 	int			enable_gpio;
 	unsigned long		enable_gpio_flags;
 	int			(*notify)(struct device *,
@@ -60,6 +62,10 @@ static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness,
 
 	pwm_config(pb->pwm, duty_cycle, pb->period);
 
+	err = regulator_enable(pb->power_supply);
+	if (err < 0)
+		dev_err(pb->dev, "failed to enable power supply\n");
+
 	if (gpio_is_valid(pb->enable_gpio)) {
 		if (pb->enable_gpio_flags & PWM_BACKLIGHT_GPIO_ACTIVE_LOW)
 			gpio_set_value(pb->enable_gpio, 0);
@@ -86,6 +92,7 @@ static void pwm_backlight_power_off(struct pwm_bl_data *pb)
 			gpio_set_value(pb->enable_gpio, 0);
 	}
 
+	regulator_disable(pb->power_supply);
 	pb->enabled = false;
 }
 
@@ -268,6 +275,12 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		}
 	}
 
+	pb->power_supply = devm_regulator_get(&pdev->dev, "power");
+	if (IS_ERR(pb->power_supply)) {
+		ret = PTR_ERR(pb->power_supply);
+		goto err_gpio;
+	}
+
 	pb->pwm = devm_pwm_get(&pdev->dev, NULL);
 	if (IS_ERR(pb->pwm)) {
 		dev_err(&pdev->dev, "unable to request PWM, trying legacy API\n");

commit 8265b2e4e62632b01f998095d1bbda4d281629fe
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Aug 30 12:32:18 2013 +0200

    pwm-backlight: Use new enable_gpio field
    
    Make use of the new enable_gpio field and allow it to be set from DT as
    well. Now that all legacy users of platform data have been converted to
    initialize this field to an invalid value, it is safe to use the field
    from the driver.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 4053efbe5edb..cdef4a346555 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -10,6 +10,8 @@
  * published by the Free Software Foundation.
  */
 
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -28,6 +30,8 @@ struct pwm_bl_data {
 	unsigned int		lth_brightness;
 	unsigned int		*levels;
 	bool			enabled;
+	int			enable_gpio;
+	unsigned long		enable_gpio_flags;
 	int			(*notify)(struct device *,
 					  int brightness);
 	void			(*notify_after)(struct device *,
@@ -55,6 +59,14 @@ static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness,
 		     pb->lth_brightness;
 
 	pwm_config(pb->pwm, duty_cycle, pb->period);
+
+	if (gpio_is_valid(pb->enable_gpio)) {
+		if (pb->enable_gpio_flags & PWM_BACKLIGHT_GPIO_ACTIVE_LOW)
+			gpio_set_value(pb->enable_gpio, 0);
+		else
+			gpio_set_value(pb->enable_gpio, 1);
+	}
+
 	pwm_enable(pb->pwm);
 	pb->enabled = true;
 }
@@ -67,6 +79,13 @@ static void pwm_backlight_power_off(struct pwm_bl_data *pb)
 	pwm_config(pb->pwm, 0, pb->period);
 	pwm_disable(pb->pwm);
 
+	if (gpio_is_valid(pb->enable_gpio)) {
+		if (pb->enable_gpio_flags & PWM_BACKLIGHT_GPIO_ACTIVE_LOW)
+			gpio_set_value(pb->enable_gpio, 1);
+		else
+			gpio_set_value(pb->enable_gpio, 0);
+	}
+
 	pb->enabled = false;
 }
 
@@ -119,6 +138,7 @@ static int pwm_backlight_parse_dt(struct device *dev,
 				  struct platform_pwm_backlight_data *data)
 {
 	struct device_node *node = dev->of_node;
+	enum of_gpio_flags flags;
 	struct property *prop;
 	int length;
 	u32 value;
@@ -159,11 +179,13 @@ static int pwm_backlight_parse_dt(struct device *dev,
 		data->max_brightness--;
 	}
 
-	/*
-	 * TODO: Most users of this driver use a number of GPIOs to control
-	 *       backlight power. Support for specifying these needs to be
-	 *       added.
-	 */
+	data->enable_gpio = of_get_named_gpio_flags(node, "enable-gpios", 0,
+						    &flags);
+	if (data->enable_gpio == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+
+	if (gpio_is_valid(data->enable_gpio) && (flags & OF_GPIO_ACTIVE_LOW))
+		data->enable_gpio_flags |= PWM_BACKLIGHT_GPIO_ACTIVE_LOW;
 
 	return 0;
 }
@@ -221,6 +243,8 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	} else
 		max = data->max_brightness;
 
+	pb->enable_gpio = data->enable_gpio;
+	pb->enable_gpio_flags = data->enable_gpio_flags;
 	pb->notify = data->notify;
 	pb->notify_after = data->notify_after;
 	pb->check_fb = data->check_fb;
@@ -228,6 +252,22 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	pb->dev = &pdev->dev;
 	pb->enabled = false;
 
+	if (gpio_is_valid(pb->enable_gpio)) {
+		unsigned long flags;
+
+		if (pb->enable_gpio_flags & PWM_BACKLIGHT_GPIO_ACTIVE_LOW)
+			flags = GPIOF_OUT_INIT_HIGH;
+		else
+			flags = GPIOF_OUT_INIT_LOW;
+
+		ret = gpio_request_one(pb->enable_gpio, flags, "enable");
+		if (ret < 0) {
+			dev_err(&pdev->dev, "failed to request GPIO#%d: %d\n",
+				pb->enable_gpio, ret);
+			goto err_alloc;
+		}
+	}
+
 	pb->pwm = devm_pwm_get(&pdev->dev, NULL);
 	if (IS_ERR(pb->pwm)) {
 		dev_err(&pdev->dev, "unable to request PWM, trying legacy API\n");
@@ -236,7 +276,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		if (IS_ERR(pb->pwm)) {
 			dev_err(&pdev->dev, "unable to request legacy PWM\n");
 			ret = PTR_ERR(pb->pwm);
-			goto err_alloc;
+			goto err_gpio;
 		}
 	}
 
@@ -261,7 +301,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	if (IS_ERR(bl)) {
 		dev_err(&pdev->dev, "failed to register backlight\n");
 		ret = PTR_ERR(bl);
-		goto err_alloc;
+		goto err_gpio;
 	}
 
 	if (data->dft_brightness > data->max_brightness) {
@@ -277,6 +317,9 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, bl);
 	return 0;
 
+err_gpio:
+	if (gpio_is_valid(pb->enable_gpio))
+		gpio_free(pb->enable_gpio);
 err_alloc:
 	if (data->exit)
 		data->exit(&pdev->dev);

commit 97c38437115aa0c3fb2d50c488814b503ba529e0
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Oct 2 18:01:02 2013 +0200

    pwm-backlight: Track enable state
    
    Follow up patches will add support for more complex means of powering
    the backlight on and off such as using a regulator. To prevent calls to
    the regulator API from becoming unbalanced, keep track of the enabled
    state internally.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index ab9d5e6012a4..4053efbe5edb 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -27,6 +27,7 @@ struct pwm_bl_data {
 	unsigned int		period;
 	unsigned int		lth_brightness;
 	unsigned int		*levels;
+	bool			enabled;
 	int			(*notify)(struct device *,
 					  int brightness);
 	void			(*notify_after)(struct device *,
@@ -40,6 +41,9 @@ static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness,
 {
 	int duty_cycle, err;
 
+	if (pb->enabled)
+		return;
+
 	if (pb->levels) {
 		duty_cycle = pb->levels[brightness];
 		max = pb->levels[max];
@@ -52,12 +56,18 @@ static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness,
 
 	pwm_config(pb->pwm, duty_cycle, pb->period);
 	pwm_enable(pb->pwm);
+	pb->enabled = true;
 }
 
 static void pwm_backlight_power_off(struct pwm_bl_data *pb)
 {
+	if (!pb->enabled)
+		return;
+
 	pwm_config(pb->pwm, 0, pb->period);
 	pwm_disable(pb->pwm);
+
+	pb->enabled = false;
 }
 
 static int pwm_backlight_update_status(struct backlight_device *bl)
@@ -216,6 +226,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	pb->check_fb = data->check_fb;
 	pb->exit = data->exit;
 	pb->dev = &pdev->dev;
+	pb->enabled = false;
 
 	pb->pwm = devm_pwm_get(&pdev->dev, NULL);
 	if (IS_ERR(pb->pwm)) {

commit 62b744a87c1170b339f993aa3cfb22465974816a
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Oct 7 11:32:02 2013 +0200

    pwm-backlight: Refactor backlight power on/off
    
    In preparation for adding an optional regulator and enable GPIO to the
    driver, split the power on and power off sequences into separate
    functions to reduce code duplication at the multiple call sites.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 774bce38ba42..ab9d5e6012a4 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -35,6 +35,31 @@ struct pwm_bl_data {
 	void			(*exit)(struct device *);
 };
 
+static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness,
+				   int max)
+{
+	int duty_cycle, err;
+
+	if (pb->levels) {
+		duty_cycle = pb->levels[brightness];
+		max = pb->levels[max];
+	} else {
+		duty_cycle = brightness;
+	}
+
+	duty_cycle = (duty_cycle * (pb->period - pb->lth_brightness) / max) +
+		     pb->lth_brightness;
+
+	pwm_config(pb->pwm, duty_cycle, pb->period);
+	pwm_enable(pb->pwm);
+}
+
+static void pwm_backlight_power_off(struct pwm_bl_data *pb)
+{
+	pwm_config(pb->pwm, 0, pb->period);
+	pwm_disable(pb->pwm);
+}
+
 static int pwm_backlight_update_status(struct backlight_device *bl)
 {
 	struct pwm_bl_data *pb = bl_get_data(bl);
@@ -49,24 +74,10 @@ static int pwm_backlight_update_status(struct backlight_device *bl)
 	if (pb->notify)
 		brightness = pb->notify(pb->dev, brightness);
 
-	if (brightness == 0) {
-		pwm_config(pb->pwm, 0, pb->period);
-		pwm_disable(pb->pwm);
-	} else {
-		int duty_cycle;
-
-		if (pb->levels) {
-			duty_cycle = pb->levels[brightness];
-			max = pb->levels[max];
-		} else {
-			duty_cycle = brightness;
-		}
-
-		duty_cycle = pb->lth_brightness +
-		     (duty_cycle * (pb->period - pb->lth_brightness) / max);
-		pwm_config(pb->pwm, duty_cycle, pb->period);
-		pwm_enable(pb->pwm);
-	}
+	if (brightness > 0)
+		pwm_backlight_power_on(pb, brightness, max);
+	else
+		pwm_backlight_power_off(pb);
 
 	if (pb->notify_after)
 		pb->notify_after(pb->dev, brightness);
@@ -267,8 +278,7 @@ static int pwm_backlight_remove(struct platform_device *pdev)
 	struct pwm_bl_data *pb = bl_get_data(bl);
 
 	backlight_device_unregister(bl);
-	pwm_config(pb->pwm, 0, pb->period);
-	pwm_disable(pb->pwm);
+	pwm_backlight_power_off(pb);
 
 	if (pb->exit)
 		pb->exit(&pdev->dev);
@@ -285,8 +295,7 @@ static int pwm_backlight_suspend(struct device *dev)
 	if (pb->notify)
 		pb->notify(pb->dev, 0);
 
-	pwm_config(pb->pwm, 0, pb->period);
-	pwm_disable(pb->pwm);
+	pwm_backlight_power_off(pb);
 
 	if (pb->notify_after)
 		pb->notify_after(pb->dev, 0);

commit 668e63c6701d486c68b49ffffc0e5b7de1a2e95c
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Oct 7 11:30:50 2013 +0200

    pwm-backlight: Improve readability
    
    Add more blank lines to increase readability. While at it, remove a
    trailing blank line at the end of the file.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 1fea627394d7..774bce38ba42 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -269,8 +269,10 @@ static int pwm_backlight_remove(struct platform_device *pdev)
 	backlight_device_unregister(bl);
 	pwm_config(pb->pwm, 0, pb->period);
 	pwm_disable(pb->pwm);
+
 	if (pb->exit)
 		pb->exit(&pdev->dev);
+
 	return 0;
 }
 
@@ -282,10 +284,13 @@ static int pwm_backlight_suspend(struct device *dev)
 
 	if (pb->notify)
 		pb->notify(pb->dev, 0);
+
 	pwm_config(pb->pwm, 0, pb->period);
 	pwm_disable(pb->pwm);
+
 	if (pb->notify_after)
 		pb->notify_after(pb->dev, 0);
+
 	return 0;
 }
 
@@ -294,6 +299,7 @@ static int pwm_backlight_resume(struct device *dev)
 	struct backlight_device *bl = dev_get_drvdata(dev);
 
 	backlight_update_status(bl);
+
 	return 0;
 }
 #endif
@@ -317,4 +323,3 @@ module_platform_driver(pwm_backlight_driver);
 MODULE_DESCRIPTION("PWM based Backlight Driver");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:pwm-backlight");
-

commit c791126b93e800c68557483235321b201c082910
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon Feb 25 17:15:47 2013 +0900

    pwm_backlight: remove unnecessary ifdefs
    
    When the macro such as SIMPLE_DEV_PM_OPS is used, there is
    no need to use '#ifdef CONFIG_PM' to prevent build error. Thus,
    this patch removes unnecessary ifdefs.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Cc: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index fa00304a63d8..1fea627394d7 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -274,7 +274,7 @@ static int pwm_backlight_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int pwm_backlight_suspend(struct device *dev)
 {
 	struct backlight_device *bl = dev_get_drvdata(dev);
@@ -296,19 +296,16 @@ static int pwm_backlight_resume(struct device *dev)
 	backlight_update_status(bl);
 	return 0;
 }
+#endif
 
 static SIMPLE_DEV_PM_OPS(pwm_backlight_pm_ops, pwm_backlight_suspend,
 			 pwm_backlight_resume);
 
-#endif
-
 static struct platform_driver pwm_backlight_driver = {
 	.driver		= {
 		.name		= "pwm-backlight",
 		.owner		= THIS_MODULE,
-#ifdef CONFIG_PM
 		.pm		= &pwm_backlight_pm_ops,
-#endif
 		.of_match_table	= of_match_ptr(pwm_backlight_of_match),
 	},
 	.probe		= pwm_backlight_probe,

commit 3eb05225ee8efb81fe50558f5f9d94e7477ade8f
Merge: ed5dc2372dba 30f786170352
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 26 09:34:29 2013 -0800

    Merge tag 'for-3.9-rc1' of git://gitorious.org/linux-pwm/linux-pwm
    
    Pull PWM changes from Thierry Reding:
     "A new driver has been added to support the PWM mode of the timer
      counter blocks found on Atmel AT91 SoCs.  The VT8500 driver now
      supports changing the PWM signal polarity and the TI drivers (EHRPWM
      and ECAP) gained suspend and resume functionality.
    
      User drivers can now query the core for whether access to a PWM device
      will sleep (if the PWM chip is on a slow bus such as I2C or SPI).
    
      The pwm-backlight driver now handles the backlight BL_CORE_FBBLANK
      state in addition to the FB layer's blanking states.
    
      To round things off, a few fixes and cleanups are also included"
    
    * tag 'for-3.9-rc1' of git://gitorious.org/linux-pwm/linux-pwm:
      pwm: twl: Use to_twl() instead of container_of()
      pwm: tegra: assume CONFIG_OF
      pwm_backlight: Validate dft_brightness in main probe function
      pwm: Export pwm_{set,get}_chip_data()
      pwm: Make Kconfig entries more consistent
      pwm: Add can_sleep property to drivers
      pwm: Add pwm_can_sleep() as exported API to users
      pwm-backlight: handle BL_CORE_FBBLANK state
      pwm: pwm-tiecap: Low power sleep support
      pwm: pwm-tiehrpwm: Low power sleep support
      pwm: pwm-tiehrpwm: Update the clock handling of pwm-tiehrpwm driver
      pwm: vt8500: Add polarity support
      pwm: vt8500: Register write busy test performed incorrectly
      pwm: atmel: add Timer Counter Block PWM driver

commit e6e3dbf95cb1d434d26acf3f0197c279ba052df4
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Thu Feb 21 16:43:46 2013 -0800

    pwm_backlight: use bl_get_data instead of dev_get_drvdata
    
    Use the wrapper function for getting the driver data using
    backlight_device instead of using dev_get_drvdata with &bd->dev, so we can
    directly pass a struct backlight_device.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Cc: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 069983ca49ff..f2f4c43d6e22 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -37,7 +37,7 @@ struct pwm_bl_data {
 
 static int pwm_backlight_update_status(struct backlight_device *bl)
 {
-	struct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);
+	struct pwm_bl_data *pb = bl_get_data(bl);
 	int brightness = bl->props.brightness;
 	int max = bl->props.max_brightness;
 
@@ -83,7 +83,7 @@ static int pwm_backlight_get_brightness(struct backlight_device *bl)
 static int pwm_backlight_check_fb(struct backlight_device *bl,
 				  struct fb_info *info)
 {
-	struct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);
+	struct pwm_bl_data *pb = bl_get_data(bl);
 
 	return !pb->check_fb || pb->check_fb(pb->dev, info);
 }
@@ -264,7 +264,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 static int pwm_backlight_remove(struct platform_device *pdev)
 {
 	struct backlight_device *bl = platform_get_drvdata(pdev);
-	struct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);
+	struct pwm_bl_data *pb = bl_get_data(bl);
 
 	backlight_device_unregister(bl);
 	pwm_config(pb->pwm, 0, pb->period);
@@ -278,7 +278,7 @@ static int pwm_backlight_remove(struct platform_device *pdev)
 static int pwm_backlight_suspend(struct device *dev)
 {
 	struct backlight_device *bl = dev_get_drvdata(dev);
-	struct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);
+	struct pwm_bl_data *pb = bl_get_data(bl);
 
 	if (pb->notify)
 		pb->notify(pb->dev, 0);

commit 83cfd72669ff708c9d21f214606be785ea8a685c
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue Jan 22 14:39:54 2013 +0100

    pwm_backlight: Validate dft_brightness in main probe function
    
    Move the dft_brightness validity check from the DT parsing function to the
    main probe. In this way we can validate it in case we are booting with or
    without DT.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 4af6d1302f17..a71ef4a79ec4 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -134,12 +134,6 @@ static int pwm_backlight_parse_dt(struct device *dev,
 		if (ret < 0)
 			return ret;
 
-		if (value >= data->max_brightness) {
-			dev_warn(dev, "invalid default brightness level: %u, using %u\n",
-				 value, data->max_brightness - 1);
-			value = data->max_brightness - 1;
-		}
-
 		data->dft_brightness = value;
 		data->max_brightness--;
 	}
@@ -248,6 +242,13 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		goto err_alloc;
 	}
 
+	if (data->dft_brightness > data->max_brightness) {
+		dev_warn(&pdev->dev,
+			 "invalid default brightness level: %u, using %u\n",
+			 data->dft_brightness, data->max_brightness);
+		data->dft_brightness = data->max_brightness;
+	}
+
 	bl->props.brightness = data->dft_brightness;
 	backlight_update_status(bl);
 

commit 0132267d659107616eb044777f1b0be55381129a
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Wed Jan 30 15:19:15 2013 +0900

    pwm-backlight: handle BL_CORE_FBBLANK state
    
    According to include/linux/backlight.h, the fb_blank field is to be
    removed and blank status should preferably be set by setting the
    BL_CORE_FBBLANK bit of the state field. This patch ensures this
    condition is also taken into account when updating the backlight state.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 069983ca49ff..4af6d1302f17 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -41,10 +41,9 @@ static int pwm_backlight_update_status(struct backlight_device *bl)
 	int brightness = bl->props.brightness;
 	int max = bl->props.max_brightness;
 
-	if (bl->props.power != FB_BLANK_UNBLANK)
-		brightness = 0;
-
-	if (bl->props.fb_blank != FB_BLANK_UNBLANK)
+	if (bl->props.power != FB_BLANK_UNBLANK ||
+	    bl->props.fb_blank != FB_BLANK_UNBLANK ||
+	    bl->props.state & BL_CORE_FBBLANK)
 		brightness = 0;
 
 	if (pb->notify)

commit 60ce70285b4d3b933eea15e494a9b35fe85b19b7
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon Sep 17 11:50:47 2012 +0530

    pwm-backlight: Use devm_pwm_get() instead of pwm_get()
    
    Managed versions of the pwm_get() and pwm_put() functions were recently
    added to the PWM framework. They can be used to simplify cleanup in the
    error paths and the device removal callback.
    
    Cc: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Acked-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 995f0164c9b0..069983ca49ff 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -213,7 +213,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	pb->exit = data->exit;
 	pb->dev = &pdev->dev;
 
-	pb->pwm = pwm_get(&pdev->dev, NULL);
+	pb->pwm = devm_pwm_get(&pdev->dev, NULL);
 	if (IS_ERR(pb->pwm)) {
 		dev_err(&pdev->dev, "unable to request PWM, trying legacy API\n");
 
@@ -246,7 +246,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	if (IS_ERR(bl)) {
 		dev_err(&pdev->dev, "failed to register backlight\n");
 		ret = PTR_ERR(bl);
-		goto err_bl;
+		goto err_alloc;
 	}
 
 	bl->props.brightness = data->dft_brightness;
@@ -255,8 +255,6 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, bl);
 	return 0;
 
-err_bl:
-	pwm_put(pb->pwm);
 err_alloc:
 	if (data->exit)
 		data->exit(&pdev->dev);
@@ -271,7 +269,6 @@ static int pwm_backlight_remove(struct platform_device *pdev)
 	backlight_device_unregister(bl);
 	pwm_config(pb->pwm, 0, pb->period);
 	pwm_disable(pb->pwm);
-	pwm_put(pb->pwm);
 	if (pb->exit)
 		pb->exit(&pdev->dev);
 	return 0;

commit 9fb978b12f9cc2b4df428764273d96877d0a262d
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Mon Jul 9 15:04:23 2012 +0900

    pwm_backlight: pass correct brightness to callback
    
    pwm_backlight_update_status calls the notify() and notify_after()
    callbacks before and after applying the new PWM settings. However, if
    brightness levels are used, the brightness value will be changed from
    the index into the levels array to the PWM duty cycle length before
    being passed to notify_after(), which results in inconsistent behavior.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 057389d69a51..995f0164c9b0 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -54,14 +54,18 @@ static int pwm_backlight_update_status(struct backlight_device *bl)
 		pwm_config(pb->pwm, 0, pb->period);
 		pwm_disable(pb->pwm);
 	} else {
+		int duty_cycle;
+
 		if (pb->levels) {
-			brightness = pb->levels[brightness];
+			duty_cycle = pb->levels[brightness];
 			max = pb->levels[max];
+		} else {
+			duty_cycle = brightness;
 		}
 
-		brightness = pb->lth_brightness +
-			(brightness * (pb->period - pb->lth_brightness) / max);
-		pwm_config(pb->pwm, brightness, pb->period);
+		duty_cycle = pb->lth_brightness +
+		     (duty_cycle * (pb->period - pb->lth_brightness) / max);
+		pwm_config(pb->pwm, duty_cycle, pb->period);
 		pwm_enable(pb->pwm);
 	}
 

commit 3e3ed6cdc49d758719c148a78c8b04c243ef74d0
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Fri Dec 16 21:25:29 2011 +0100

    pwm-backlight: Add rudimentary device tree support
    
    This commit adds very basic support for device tree probing. Currently,
    only a PWM and a list of distinct brightness levels can be specified.
    Enabling or disabling backlight power via GPIOs is not yet supported.
    
    Reviewed-by: Shawn Guo <shawn.guo@linaro.org>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 342b7d7cbb63..057389d69a51 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -26,11 +26,13 @@ struct pwm_bl_data {
 	struct device		*dev;
 	unsigned int		period;
 	unsigned int		lth_brightness;
+	unsigned int		*levels;
 	int			(*notify)(struct device *,
 					  int brightness);
 	void			(*notify_after)(struct device *,
 					int brightness);
 	int			(*check_fb)(struct device *, struct fb_info *);
+	void			(*exit)(struct device *);
 };
 
 static int pwm_backlight_update_status(struct backlight_device *bl)
@@ -52,6 +54,11 @@ static int pwm_backlight_update_status(struct backlight_device *bl)
 		pwm_config(pb->pwm, 0, pb->period);
 		pwm_disable(pb->pwm);
 	} else {
+		if (pb->levels) {
+			brightness = pb->levels[brightness];
+			max = pb->levels[max];
+		}
+
 		brightness = pb->lth_brightness +
 			(brightness * (pb->period - pb->lth_brightness) / max);
 		pwm_config(pb->pwm, brightness, pb->period);
@@ -83,17 +90,98 @@ static const struct backlight_ops pwm_backlight_ops = {
 	.check_fb	= pwm_backlight_check_fb,
 };
 
+#ifdef CONFIG_OF
+static int pwm_backlight_parse_dt(struct device *dev,
+				  struct platform_pwm_backlight_data *data)
+{
+	struct device_node *node = dev->of_node;
+	struct property *prop;
+	int length;
+	u32 value;
+	int ret;
+
+	if (!node)
+		return -ENODEV;
+
+	memset(data, 0, sizeof(*data));
+
+	/* determine the number of brightness levels */
+	prop = of_find_property(node, "brightness-levels", &length);
+	if (!prop)
+		return -EINVAL;
+
+	data->max_brightness = length / sizeof(u32);
+
+	/* read brightness levels from DT property */
+	if (data->max_brightness > 0) {
+		size_t size = sizeof(*data->levels) * data->max_brightness;
+
+		data->levels = devm_kzalloc(dev, size, GFP_KERNEL);
+		if (!data->levels)
+			return -ENOMEM;
+
+		ret = of_property_read_u32_array(node, "brightness-levels",
+						 data->levels,
+						 data->max_brightness);
+		if (ret < 0)
+			return ret;
+
+		ret = of_property_read_u32(node, "default-brightness-level",
+					   &value);
+		if (ret < 0)
+			return ret;
+
+		if (value >= data->max_brightness) {
+			dev_warn(dev, "invalid default brightness level: %u, using %u\n",
+				 value, data->max_brightness - 1);
+			value = data->max_brightness - 1;
+		}
+
+		data->dft_brightness = value;
+		data->max_brightness--;
+	}
+
+	/*
+	 * TODO: Most users of this driver use a number of GPIOs to control
+	 *       backlight power. Support for specifying these needs to be
+	 *       added.
+	 */
+
+	return 0;
+}
+
+static struct of_device_id pwm_backlight_of_match[] = {
+	{ .compatible = "pwm-backlight" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, pwm_backlight_of_match);
+#else
+static int pwm_backlight_parse_dt(struct device *dev,
+				  struct platform_pwm_backlight_data *data)
+{
+	return -ENODEV;
+}
+#endif
+
 static int pwm_backlight_probe(struct platform_device *pdev)
 {
-	struct backlight_properties props;
 	struct platform_pwm_backlight_data *data = pdev->dev.platform_data;
+	struct platform_pwm_backlight_data defdata;
+	struct backlight_properties props;
 	struct backlight_device *bl;
 	struct pwm_bl_data *pb;
+	unsigned int max;
 	int ret;
 
 	if (!data) {
-		dev_err(&pdev->dev, "failed to find platform data\n");
-		return -EINVAL;
+		ret = pwm_backlight_parse_dt(&pdev->dev, &defdata);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "failed to find platform data\n");
+			return ret;
+		}
+
+		data = &defdata;
 	}
 
 	if (data->init) {
@@ -109,21 +197,42 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		goto err_alloc;
 	}
 
-	pb->period = data->pwm_period_ns;
+	if (data->levels) {
+		max = data->levels[data->max_brightness];
+		pb->levels = data->levels;
+	} else
+		max = data->max_brightness;
+
 	pb->notify = data->notify;
 	pb->notify_after = data->notify_after;
 	pb->check_fb = data->check_fb;
-	pb->lth_brightness = data->lth_brightness *
-		(data->pwm_period_ns / data->max_brightness);
+	pb->exit = data->exit;
 	pb->dev = &pdev->dev;
 
-	pb->pwm = pwm_request(data->pwm_id, "backlight");
+	pb->pwm = pwm_get(&pdev->dev, NULL);
 	if (IS_ERR(pb->pwm)) {
-		dev_err(&pdev->dev, "unable to request PWM for backlight\n");
-		ret = PTR_ERR(pb->pwm);
-		goto err_alloc;
-	} else
-		dev_dbg(&pdev->dev, "got pwm for backlight\n");
+		dev_err(&pdev->dev, "unable to request PWM, trying legacy API\n");
+
+		pb->pwm = pwm_request(data->pwm_id, "pwm-backlight");
+		if (IS_ERR(pb->pwm)) {
+			dev_err(&pdev->dev, "unable to request legacy PWM\n");
+			ret = PTR_ERR(pb->pwm);
+			goto err_alloc;
+		}
+	}
+
+	dev_dbg(&pdev->dev, "got pwm for backlight\n");
+
+	/*
+	 * The DT case will set the pwm_period_ns field to 0 and store the
+	 * period, parsed from the DT, in the PWM device. For the non-DT case,
+	 * set the period from platform data.
+	 */
+	if (data->pwm_period_ns > 0)
+		pwm_set_period(pb->pwm, data->pwm_period_ns);
+
+	pb->period = pwm_get_period(pb->pwm);
+	pb->lth_brightness = data->lth_brightness * (pb->period / max);
 
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
@@ -143,7 +252,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	return 0;
 
 err_bl:
-	pwm_free(pb->pwm);
+	pwm_put(pb->pwm);
 err_alloc:
 	if (data->exit)
 		data->exit(&pdev->dev);
@@ -152,16 +261,15 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 static int pwm_backlight_remove(struct platform_device *pdev)
 {
-	struct platform_pwm_backlight_data *data = pdev->dev.platform_data;
 	struct backlight_device *bl = platform_get_drvdata(pdev);
 	struct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);
 
 	backlight_device_unregister(bl);
 	pwm_config(pb->pwm, 0, pb->period);
 	pwm_disable(pb->pwm);
-	pwm_free(pb->pwm);
-	if (data->exit)
-		data->exit(&pdev->dev);
+	pwm_put(pb->pwm);
+	if (pb->exit)
+		pb->exit(&pdev->dev);
 	return 0;
 }
 
@@ -195,11 +303,12 @@ static SIMPLE_DEV_PM_OPS(pwm_backlight_pm_ops, pwm_backlight_suspend,
 
 static struct platform_driver pwm_backlight_driver = {
 	.driver		= {
-		.name	= "pwm-backlight",
-		.owner	= THIS_MODULE,
+		.name		= "pwm-backlight",
+		.owner		= THIS_MODULE,
 #ifdef CONFIG_PM
-		.pm	= &pwm_backlight_pm_ops,
+		.pm		= &pwm_backlight_pm_ops,
 #endif
+		.of_match_table	= of_match_ptr(pwm_backlight_of_match),
 	},
 	.probe		= pwm_backlight_probe,
 	.remove		= pwm_backlight_remove,

commit ce969228fdb54a7e3d7cc1ed27367fd4b9525d74
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Mar 23 15:02:00 2012 -0700

    drivers/video/backlight: use devm_ functions
    
    The various devm_ functions allocate memory that is released when a driver
    detaches.  This patch uses these functions for data that is allocated in
    the probe function of a platform device and is only freed in the remove
    function.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Florian Tobias Schandinat <FlorianSchandinat@gmx.de>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 7496d04e1d3c..342b7d7cbb63 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -102,7 +102,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 			return ret;
 	}
 
-	pb = kzalloc(sizeof(*pb), GFP_KERNEL);
+	pb = devm_kzalloc(&pdev->dev, sizeof(*pb), GFP_KERNEL);
 	if (!pb) {
 		dev_err(&pdev->dev, "no memory for state\n");
 		ret = -ENOMEM;
@@ -121,7 +121,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	if (IS_ERR(pb->pwm)) {
 		dev_err(&pdev->dev, "unable to request PWM for backlight\n");
 		ret = PTR_ERR(pb->pwm);
-		goto err_pwm;
+		goto err_alloc;
 	} else
 		dev_dbg(&pdev->dev, "got pwm for backlight\n");
 
@@ -144,8 +144,6 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 err_bl:
 	pwm_free(pb->pwm);
-err_pwm:
-	kfree(pb);
 err_alloc:
 	if (data->exit)
 		data->exit(&pdev->dev);
@@ -162,7 +160,6 @@ static int pwm_backlight_remove(struct platform_device *pdev)
 	pwm_config(pb->pwm, 0, pb->period);
 	pwm_disable(pb->pwm);
 	pwm_free(pb->pwm);
-	kfree(pb);
 	if (data->exit)
 		data->exit(&pdev->dev);
 	return 0;

commit e2c17bc6f717a8847df2a867caec6ba4fe85f3fc
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jan 10 15:09:22 2012 -0800

    backlight: convert pwm_bl to dev_pm_ops
    
    Should be no functional changes, mainly a reorganisation to support future
    work.
    
    [akpm@linux-foundation.org: fix CONFIG_PM=n build]
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Florian Tobias Schandinat <FlorianSchandinat@gmx.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index b811e8fb4062..7496d04e1d3c 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -169,10 +169,9 @@ static int pwm_backlight_remove(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_PM
-static int pwm_backlight_suspend(struct platform_device *pdev,
-				 pm_message_t state)
+static int pwm_backlight_suspend(struct device *dev)
 {
-	struct backlight_device *bl = platform_get_drvdata(pdev);
+	struct backlight_device *bl = dev_get_drvdata(dev);
 	struct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);
 
 	if (pb->notify)
@@ -184,27 +183,29 @@ static int pwm_backlight_suspend(struct platform_device *pdev,
 	return 0;
 }
 
-static int pwm_backlight_resume(struct platform_device *pdev)
+static int pwm_backlight_resume(struct device *dev)
 {
-	struct backlight_device *bl = platform_get_drvdata(pdev);
+	struct backlight_device *bl = dev_get_drvdata(dev);
 
 	backlight_update_status(bl);
 	return 0;
 }
-#else
-#define pwm_backlight_suspend	NULL
-#define pwm_backlight_resume	NULL
+
+static SIMPLE_DEV_PM_OPS(pwm_backlight_pm_ops, pwm_backlight_suspend,
+			 pwm_backlight_resume);
+
 #endif
 
 static struct platform_driver pwm_backlight_driver = {
 	.driver		= {
 		.name	= "pwm-backlight",
 		.owner	= THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm	= &pwm_backlight_pm_ops,
+#endif
 	},
 	.probe		= pwm_backlight_probe,
 	.remove		= pwm_backlight_remove,
-	.suspend	= pwm_backlight_suspend,
-	.resume		= pwm_backlight_resume,
 };
 
 module_platform_driver(pwm_backlight_driver);

commit 81178e021689bf86c328f144aa0f0e1b50f5e94c
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Jan 10 15:09:11 2012 -0800

    backlight: convert drivers/video/backlight/* to use module_platform_driver()
    
    Convert the drivers in drivers/video/backlight/* to use the
    module_platform_driver() macro which makes the code smaller and a bit
    simpler.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>      [ep93xx_bl.c]
    Cc: Mike Rapoport <mike@compulab.co.il>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Acked-by: Michael Hennerich <michael.hennerich@analog.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 8b5b2a4124c7..b811e8fb4062 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -207,17 +207,7 @@ static struct platform_driver pwm_backlight_driver = {
 	.resume		= pwm_backlight_resume,
 };
 
-static int __init pwm_backlight_init(void)
-{
-	return platform_driver_register(&pwm_backlight_driver);
-}
-module_init(pwm_backlight_init);
-
-static void __exit pwm_backlight_exit(void)
-{
-	platform_driver_unregister(&pwm_backlight_driver);
-}
-module_exit(pwm_backlight_exit);
+module_platform_driver(pwm_backlight_driver);
 
 MODULE_DESCRIPTION("PWM based Backlight Driver");
 MODULE_LICENSE("GPL");

commit cc7993f6439b49909a8792660c4d0741fec9d584
Author: Dilan Lee <dilee@nvidia.com>
Date:   Thu Aug 25 15:59:17 2011 -0700

    backlight: add a callback 'notify_after' for backlight control
    
    We need a callback to do some things after pwm_enable, pwm_disable
    and pwm_config.
    
    Signed-off-by: Dilan Lee <dilee@nvidia.com>
    Reviewed-by: Robert Morell <rmorell@nvidia.com>
    Reviewed-by: Arun Murthy <arun.murthy@stericsson.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index b8f38ec6eb18..8b5b2a4124c7 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -28,6 +28,8 @@ struct pwm_bl_data {
 	unsigned int		lth_brightness;
 	int			(*notify)(struct device *,
 					  int brightness);
+	void			(*notify_after)(struct device *,
+					int brightness);
 	int			(*check_fb)(struct device *, struct fb_info *);
 };
 
@@ -55,6 +57,10 @@ static int pwm_backlight_update_status(struct backlight_device *bl)
 		pwm_config(pb->pwm, brightness, pb->period);
 		pwm_enable(pb->pwm);
 	}
+
+	if (pb->notify_after)
+		pb->notify_after(pb->dev, brightness);
+
 	return 0;
 }
 
@@ -105,6 +111,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 	pb->period = data->pwm_period_ns;
 	pb->notify = data->notify;
+	pb->notify_after = data->notify_after;
 	pb->check_fb = data->check_fb;
 	pb->lth_brightness = data->lth_brightness *
 		(data->pwm_period_ns / data->max_brightness);
@@ -172,6 +179,8 @@ static int pwm_backlight_suspend(struct platform_device *pdev,
 		pb->notify(pb->dev, 0);
 	pwm_config(pb->pwm, 0, pb->period);
 	pwm_disable(pb->pwm);
+	if (pb->notify_after)
+		pb->notify_after(pb->dev, 0);
 	return 0;
 }
 

commit ef0a5e80f56f6409e957e7117da9551c3d3ff239
Author: Robert Morell <rmorell@nvidia.com>
Date:   Tue Mar 22 16:30:31 2011 -0700

    pwm_backlight: add check_fb() hook
    
    In systems with multiple framebuffer devices, one of the devices might be
    blanked while another is unblanked.  In order for the backlight blanking
    logic to know whether to turn off the backlight for a particular
    framebuffer's blanking notification, it needs to be able to check if a
    given framebuffer device corresponds to the backlight.
    
    This plumbs the check_fb hook from core backlight through the
    pwm_backlight helper to allow platform code to plug in a check_fb hook.
    
    Signed-off-by: Robert Morell <rmorell@nvidia.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Arun Murthy <arun.murthy@stericsson.com>
    Cc: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 2c2a2c703c14..b8f38ec6eb18 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -28,6 +28,7 @@ struct pwm_bl_data {
 	unsigned int		lth_brightness;
 	int			(*notify)(struct device *,
 					  int brightness);
+	int			(*check_fb)(struct device *, struct fb_info *);
 };
 
 static int pwm_backlight_update_status(struct backlight_device *bl)
@@ -62,9 +63,18 @@ static int pwm_backlight_get_brightness(struct backlight_device *bl)
 	return bl->props.brightness;
 }
 
+static int pwm_backlight_check_fb(struct backlight_device *bl,
+				  struct fb_info *info)
+{
+	struct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);
+
+	return !pb->check_fb || pb->check_fb(pb->dev, info);
+}
+
 static const struct backlight_ops pwm_backlight_ops = {
 	.update_status	= pwm_backlight_update_status,
 	.get_brightness	= pwm_backlight_get_brightness,
+	.check_fb	= pwm_backlight_check_fb,
 };
 
 static int pwm_backlight_probe(struct platform_device *pdev)
@@ -95,6 +105,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 	pb->period = data->pwm_period_ns;
 	pb->notify = data->notify;
+	pb->check_fb = data->check_fb;
 	pb->lth_brightness = data->lth_brightness *
 		(data->pwm_period_ns / data->max_brightness);
 	pb->dev = &pdev->dev;

commit bb7ca747f8d6243b3943c5b133048652020f4a50
Author: Matthew Garrett <mjg@redhat.com>
Date:   Tue Mar 22 16:30:21 2011 -0700

    backlight: add backlight type
    
    There may be multiple ways of controlling the backlight on a given
    machine.  Allow drivers to expose the type of interface they are
    providing, making it possible for userspace to make appropriate policy
    decisions.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Alex Deucher <alexdeucher@gmail.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 21866ec69656..2c2a2c703c14 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -108,6 +108,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		dev_dbg(&pdev->dev, "got pwm for backlight\n");
 
 	memset(&props, 0, sizeof(struct backlight_properties));
+	props.type = BACKLIGHT_RAW;
 	props.max_brightness = data->max_brightness;
 	bl = backlight_device_register(dev_name(&pdev->dev), &pdev->dev, pb,
 				       &pwm_backlight_ops, &props);

commit fef7764f8bca9d603a8a51dcb522db97739a33c2
Author: Arun Murthy <arun.murthy@stericsson.com>
Date:   Thu Nov 11 14:05:28 2010 -0800

    backlight: add low threshold to pwm backlight
    
    The intensity of the backlight can be varied from a range of
    max_brightness to zero.  Though most, if not all the pwm based backlight
    devices start flickering at lower brightness value.  And also for each
    device there exists a brightness value below which the backlight appears
    to be turned off though the value is not equal to zero.
    
    If the range of brightness for a device is from zero to max_brightness.  A
    graph is plotted for brightness Vs intensity for the pwm based backlight
    device has to be a linear graph.
    
    intensity
              |   /
              |  /
              | /
              |/
              ---------
             0      max_brightness
    
    But pratically on measuring the above we note that the intensity of
    backlight goes to zero(OFF) when the value in not zero almost nearing to
    zero(some x%).  so the graph looks like
    
    intensity
              |    /
              |   /
              |  /
              |  |
              ------------
             0   x   max_brightness
    
    In order to overcome this drawback knowing this x% i.e nothing but the low
    threshold beyond which the backlight is off and will have no effect, the
    brightness value is being offset by the low threshold value(retaining the
    linearity of the graph).  Now the graph becomes
    
    intensity
              |     /
              |    /
              |   /
              |  /
              -------------
               0      max_brightness
    
    With this for each and every digit increment in the brightness from zero
    there is a change in the intensity of backlight.  Devices having this
    behaviour can set the low threshold brightness(lth_brightness) and pass
    the same as platform data else can have it as zero.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Arun Murthy <arun.murthy@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Acked-by: Richard Purdie <rpurdie@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 550443518891..21866ec69656 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -25,6 +25,7 @@ struct pwm_bl_data {
 	struct pwm_device	*pwm;
 	struct device		*dev;
 	unsigned int		period;
+	unsigned int		lth_brightness;
 	int			(*notify)(struct device *,
 					  int brightness);
 };
@@ -48,7 +49,9 @@ static int pwm_backlight_update_status(struct backlight_device *bl)
 		pwm_config(pb->pwm, 0, pb->period);
 		pwm_disable(pb->pwm);
 	} else {
-		pwm_config(pb->pwm, brightness * pb->period / max, pb->period);
+		brightness = pb->lth_brightness +
+			(brightness * (pb->period - pb->lth_brightness) / max);
+		pwm_config(pb->pwm, brightness, pb->period);
 		pwm_enable(pb->pwm);
 	}
 	return 0;
@@ -92,6 +95,8 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 	pb->period = data->pwm_period_ns;
 	pb->notify = data->notify;
+	pb->lth_brightness = data->lth_brightness *
+		(data->pwm_period_ns / data->max_brightness);
 	pb->dev = &pdev->dev;
 
 	pb->pwm = pwm_request(data->pwm_id, "backlight");

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index b89eebc3f77d..550443518891 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -19,6 +19,7 @@
 #include <linux/err.h>
 #include <linux/pwm.h>
 #include <linux/pwm_backlight.h>
+#include <linux/slab.h>
 
 struct pwm_bl_data {
 	struct pwm_device	*pwm;

commit a19a6ee6cad2b20292a774c2f56ba8039b0fac9c
Author: Matthew Garrett <mjg@redhat.com>
Date:   Wed Feb 17 16:39:44 2010 -0500

    backlight: Allow properties to be passed at registration
    
    Values such as max_brightness should be set before backlights are
    registered, but the current API doesn't allow that. Add a parameter to
    backlight_device_register and update drivers to ensure that they
    set this correctly.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 9d2ec2a1cce8..b89eebc3f77d 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -65,6 +65,7 @@ static const struct backlight_ops pwm_backlight_ops = {
 
 static int pwm_backlight_probe(struct platform_device *pdev)
 {
+	struct backlight_properties props;
 	struct platform_pwm_backlight_data *data = pdev->dev.platform_data;
 	struct backlight_device *bl;
 	struct pwm_bl_data *pb;
@@ -100,15 +101,16 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	} else
 		dev_dbg(&pdev->dev, "got pwm for backlight\n");
 
-	bl = backlight_device_register(dev_name(&pdev->dev), &pdev->dev,
-			pb, &pwm_backlight_ops);
+	memset(&props, 0, sizeof(struct backlight_properties));
+	props.max_brightness = data->max_brightness;
+	bl = backlight_device_register(dev_name(&pdev->dev), &pdev->dev, pb,
+				       &pwm_backlight_ops, &props);
 	if (IS_ERR(bl)) {
 		dev_err(&pdev->dev, "failed to register backlight\n");
 		ret = PTR_ERR(bl);
 		goto err_bl;
 	}
 
-	bl->props.max_brightness = data->max_brightness;
 	bl->props.brightness = data->dft_brightness;
 	backlight_update_status(bl);
 

commit cfc3899fcd0b3b990b29d3d33f75f4edf715e7d1
Author: Ben Dooks <ben@simtec.co.uk>
Date:   Tue Nov 10 17:20:40 2009 +0000

    backlight: Pass device through notify callback in the pwm driver
    
    Add the device to the notify callback's arguments in the PWM backlight
    driver. This brings the notify callback into line with the other
    callbacks defined by this driver.
    
    Signed-off-by: Ben Dooks <ben@simtec.co.uk>
    Signed-off-by: Simtec Linux Team <linux@simtec.co.uk>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index df9e0b32cf39..9d2ec2a1cce8 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -22,8 +22,10 @@
 
 struct pwm_bl_data {
 	struct pwm_device	*pwm;
+	struct device		*dev;
 	unsigned int		period;
-	int			(*notify)(int brightness);
+	int			(*notify)(struct device *,
+					  int brightness);
 };
 
 static int pwm_backlight_update_status(struct backlight_device *bl)
@@ -39,7 +41,7 @@ static int pwm_backlight_update_status(struct backlight_device *bl)
 		brightness = 0;
 
 	if (pb->notify)
-		brightness = pb->notify(brightness);
+		brightness = pb->notify(pb->dev, brightness);
 
 	if (brightness == 0) {
 		pwm_config(pb->pwm, 0, pb->period);
@@ -88,6 +90,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 	pb->period = data->pwm_period_ns;
 	pb->notify = data->notify;
+	pb->dev = &pdev->dev;
 
 	pb->pwm = pwm_request(data->pwm_id, "backlight");
 	if (IS_ERR(pb->pwm)) {
@@ -146,7 +149,7 @@ static int pwm_backlight_suspend(struct platform_device *pdev,
 	struct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);
 
 	if (pb->notify)
-		pb->notify(0);
+		pb->notify(pb->dev, 0);
 	pwm_config(pb->pwm, 0, pb->period);
 	pwm_disable(pb->pwm);
 	return 0;

commit 9905a43b2d563e6f89e4c63c4278ada03f2ebb14
Author: Emese Revfy <re.emese@gmail.com>
Date:   Mon Dec 14 00:58:57 2009 +0100

    backlight: Constify struct backlight_ops
    
    Signed-off-by: Emese Revfy <re.emese@gmail.com>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 887166267443..df9e0b32cf39 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -56,7 +56,7 @@ static int pwm_backlight_get_brightness(struct backlight_device *bl)
 	return bl->props.brightness;
 }
 
-static struct backlight_ops pwm_backlight_ops = {
+static const struct backlight_ops pwm_backlight_ops = {
 	.update_status	= pwm_backlight_update_status,
 	.get_brightness	= pwm_backlight_get_brightness,
 };

commit 82e8b54229fb121946151b82e8ff3c3284bd723f
Author: Marc Zyngier <maz@misterjones.org>
Date:   Fri Jun 19 10:50:54 2009 +0200

    backlight: fix pwm_bl.c to notify platform code when suspending
    
    When suspending, pwm-bl sets duty cycle to 0, and shuts down the pwm
    device.
    
    This patch ensure that the platform code is called before that
    (through the notify callback_, leaving a chance for the platform code
    to configure GPIOs (shutting off the backlight, for example), much like
    it is done during normal operations.
    
    Signed-off-by: Marc Zyngier <maz@misterjones.org>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index e641584e212e..887166267443 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -145,6 +145,8 @@ static int pwm_backlight_suspend(struct platform_device *pdev,
 	struct backlight_device *bl = platform_get_drvdata(pdev);
 	struct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);
 
+	if (pb->notify)
+		pb->notify(0);
 	pwm_config(pb->pwm, 0, pb->period);
 	pwm_disable(pb->pwm);
 	return 0;

commit b8cdd877f2cbcc07b5a287b7273a8eaa4c11ad04
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Tue Feb 10 13:30:37 2009 +0800

    backlight: fix pwm_bl.c when multiple PWM backlights exist
    
    When multiple PWMs are used as backlights, the current code uses
    pdev->name as the backlight name when registering, which will be
    conflicting, use dev_name() instead.
    
    Signed-off-by: Peter Edwards <sweetlilmre@gmail.com>
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index ea07258565f0..e641584e212e 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -3,7 +3,7 @@
  *
  * simple PWM based backlight control, board code has to setup
  * 1) pin configuration so PWM waveforms can output
- * 2) platform_data casts to the PWM id (0/1/2/3 on PXA)
+ * 2) platform_data being correctly configured
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -97,7 +97,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	} else
 		dev_dbg(&pdev->dev, "got pwm for backlight\n");
 
-	bl = backlight_device_register(pdev->name, &pdev->dev,
+	bl = backlight_device_register(dev_name(&pdev->dev), &pdev->dev,
 			pb, &pwm_backlight_ops);
 	if (IS_ERR(bl)) {
 		dev_err(&pdev->dev, "failed to register backlight\n");

commit 8cd6819842b79953c61250c719f61e01e51dd8cd
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Tue Aug 5 13:01:24 2008 -0700

    backlight: add MODULE_ALIAS() to pwm_backlight driver
    
    Add the missing MODULE_ALIAS() to the pwm_backlight driver.
    
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 441e5a707d37..ea07258565f0 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -187,3 +187,5 @@ module_exit(pwm_backlight_exit);
 
 MODULE_DESCRIPTION("PWM based Backlight Driver");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:pwm-backlight");
+

commit 14563a4ec450f35c70fbe5f6ac5199e9d5a0edc5
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Tue Aug 5 13:01:22 2008 -0700

    backlight: add more information output to pwm_backlight
    
    Make the error paths in the pwm_backlight driver more informative in the
    probe path, especially for the times that it finds an error.
    
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Acked-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 6338d0e2fe07..441e5a707d37 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -68,8 +68,10 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	struct pwm_bl_data *pb;
 	int ret;
 
-	if (!data)
+	if (!data) {
+		dev_err(&pdev->dev, "failed to find platform data\n");
 		return -EINVAL;
+	}
 
 	if (data->init) {
 		ret = data->init(&pdev->dev);
@@ -79,6 +81,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 	pb = kzalloc(sizeof(*pb), GFP_KERNEL);
 	if (!pb) {
+		dev_err(&pdev->dev, "no memory for state\n");
 		ret = -ENOMEM;
 		goto err_alloc;
 	}
@@ -91,7 +94,8 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "unable to request PWM for backlight\n");
 		ret = PTR_ERR(pb->pwm);
 		goto err_pwm;
-	}
+	} else
+		dev_dbg(&pdev->dev, "got pwm for backlight\n");
 
 	bl = backlight_device_register(pdev->name, &pdev->dev,
 			pb, &pwm_backlight_ops);

commit 43bda1a6d218744382547a2f8be3240d1c3a151b
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Tue Jul 1 14:18:27 2008 +0100

    [ARM] 5141/1: PWM: pwm_request() should return an PTR_ERR() instead of NULL.
    
    Make the return of pwm_request() be more informative than just
    being NULL on error by using PTR_ERR() to respond with an
    approriate error.
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 8346dfc01cf6..6338d0e2fe07 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -87,9 +87,9 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	pb->notify = data->notify;
 
 	pb->pwm = pwm_request(data->pwm_id, "backlight");
-	if (pb->pwm == NULL) {
+	if (IS_ERR(pb->pwm)) {
 		dev_err(&pdev->dev, "unable to request PWM for backlight\n");
-		ret = -EBUSY;
+		ret = PTR_ERR(pb->pwm);
 		goto err_pwm;
 	}
 

commit 3b73125af69f93972625f4b655675f42ca4274eb
Author: Philipp Zabel <philipp.zabel@gmail.com>
Date:   Thu May 22 14:18:40 2008 +0100

    [ARM] 5044/1: pwm_bl: add init/notify/exit callbacks
    
    This allows platform code to manipulate GPIOs and brightness level as
    needed.
    
    Signed-off-by: Philipp Zabel <philipp.zabel@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 9637f5e08cb6..8346dfc01cf6 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -23,6 +23,7 @@
 struct pwm_bl_data {
 	struct pwm_device	*pwm;
 	unsigned int		period;
+	int			(*notify)(int brightness);
 };
 
 static int pwm_backlight_update_status(struct backlight_device *bl)
@@ -37,6 +38,9 @@ static int pwm_backlight_update_status(struct backlight_device *bl)
 	if (bl->props.fb_blank != FB_BLANK_UNBLANK)
 		brightness = 0;
 
+	if (pb->notify)
+		brightness = pb->notify(brightness);
+
 	if (brightness == 0) {
 		pwm_config(pb->pwm, 0, pb->period);
 		pwm_disable(pb->pwm);
@@ -62,30 +66,39 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	struct platform_pwm_backlight_data *data = pdev->dev.platform_data;
 	struct backlight_device *bl;
 	struct pwm_bl_data *pb;
+	int ret;
 
 	if (!data)
 		return -EINVAL;
 
+	if (data->init) {
+		ret = data->init(&pdev->dev);
+		if (ret < 0)
+			return ret;
+	}
+
 	pb = kzalloc(sizeof(*pb), GFP_KERNEL);
-	if (!pb)
-		return -ENOMEM;
+	if (!pb) {
+		ret = -ENOMEM;
+		goto err_alloc;
+	}
 
 	pb->period = data->pwm_period_ns;
+	pb->notify = data->notify;
 
 	pb->pwm = pwm_request(data->pwm_id, "backlight");
 	if (pb->pwm == NULL) {
 		dev_err(&pdev->dev, "unable to request PWM for backlight\n");
-		kfree(pb);
-		return -EBUSY;
+		ret = -EBUSY;
+		goto err_pwm;
 	}
 
 	bl = backlight_device_register(pdev->name, &pdev->dev,
 			pb, &pwm_backlight_ops);
 	if (IS_ERR(bl)) {
 		dev_err(&pdev->dev, "failed to register backlight\n");
-		pwm_free(pb->pwm);
-		kfree(pb);
-		return PTR_ERR(bl);
+		ret = PTR_ERR(bl);
+		goto err_bl;
 	}
 
 	bl->props.max_brightness = data->max_brightness;
@@ -94,10 +107,20 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, bl);
 	return 0;
+
+err_bl:
+	pwm_free(pb->pwm);
+err_pwm:
+	kfree(pb);
+err_alloc:
+	if (data->exit)
+		data->exit(&pdev->dev);
+	return ret;
 }
 
 static int pwm_backlight_remove(struct platform_device *pdev)
 {
+	struct platform_pwm_backlight_data *data = pdev->dev.platform_data;
 	struct backlight_device *bl = platform_get_drvdata(pdev);
 	struct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);
 
@@ -106,6 +129,8 @@ static int pwm_backlight_remove(struct platform_device *pdev)
 	pwm_disable(pb->pwm);
 	pwm_free(pb->pwm);
 	kfree(pb);
+	if (data->exit)
+		data->exit(&pdev->dev);
 	return 0;
 }
 

commit 42796d37da6ef4fd851dc6d5d0387baf7e2b0c3c
Author: eric miao <eric.miao@marvell.com>
Date:   Mon Apr 14 09:35:08 2008 +0100

    [ARM] pxa: add generic PWM backlight driver
    
    Patch mostly from Eric Miao, with minor edits by rmk to convert
    Eric's driver to a generic PWM-based backlight driver.
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
new file mode 100644
index 000000000000..9637f5e08cb6
--- /dev/null
+++ b/drivers/video/backlight/pwm_bl.c
@@ -0,0 +1,160 @@
+/*
+ * linux/drivers/video/backlight/pwm_bl.c
+ *
+ * simple PWM based backlight control, board code has to setup
+ * 1) pin configuration so PWM waveforms can output
+ * 2) platform_data casts to the PWM id (0/1/2/3 on PXA)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/fb.h>
+#include <linux/backlight.h>
+#include <linux/err.h>
+#include <linux/pwm.h>
+#include <linux/pwm_backlight.h>
+
+struct pwm_bl_data {
+	struct pwm_device	*pwm;
+	unsigned int		period;
+};
+
+static int pwm_backlight_update_status(struct backlight_device *bl)
+{
+	struct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);
+	int brightness = bl->props.brightness;
+	int max = bl->props.max_brightness;
+
+	if (bl->props.power != FB_BLANK_UNBLANK)
+		brightness = 0;
+
+	if (bl->props.fb_blank != FB_BLANK_UNBLANK)
+		brightness = 0;
+
+	if (brightness == 0) {
+		pwm_config(pb->pwm, 0, pb->period);
+		pwm_disable(pb->pwm);
+	} else {
+		pwm_config(pb->pwm, brightness * pb->period / max, pb->period);
+		pwm_enable(pb->pwm);
+	}
+	return 0;
+}
+
+static int pwm_backlight_get_brightness(struct backlight_device *bl)
+{
+	return bl->props.brightness;
+}
+
+static struct backlight_ops pwm_backlight_ops = {
+	.update_status	= pwm_backlight_update_status,
+	.get_brightness	= pwm_backlight_get_brightness,
+};
+
+static int pwm_backlight_probe(struct platform_device *pdev)
+{
+	struct platform_pwm_backlight_data *data = pdev->dev.platform_data;
+	struct backlight_device *bl;
+	struct pwm_bl_data *pb;
+
+	if (!data)
+		return -EINVAL;
+
+	pb = kzalloc(sizeof(*pb), GFP_KERNEL);
+	if (!pb)
+		return -ENOMEM;
+
+	pb->period = data->pwm_period_ns;
+
+	pb->pwm = pwm_request(data->pwm_id, "backlight");
+	if (pb->pwm == NULL) {
+		dev_err(&pdev->dev, "unable to request PWM for backlight\n");
+		kfree(pb);
+		return -EBUSY;
+	}
+
+	bl = backlight_device_register(pdev->name, &pdev->dev,
+			pb, &pwm_backlight_ops);
+	if (IS_ERR(bl)) {
+		dev_err(&pdev->dev, "failed to register backlight\n");
+		pwm_free(pb->pwm);
+		kfree(pb);
+		return PTR_ERR(bl);
+	}
+
+	bl->props.max_brightness = data->max_brightness;
+	bl->props.brightness = data->dft_brightness;
+	backlight_update_status(bl);
+
+	platform_set_drvdata(pdev, bl);
+	return 0;
+}
+
+static int pwm_backlight_remove(struct platform_device *pdev)
+{
+	struct backlight_device *bl = platform_get_drvdata(pdev);
+	struct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);
+
+	backlight_device_unregister(bl);
+	pwm_config(pb->pwm, 0, pb->period);
+	pwm_disable(pb->pwm);
+	pwm_free(pb->pwm);
+	kfree(pb);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int pwm_backlight_suspend(struct platform_device *pdev,
+				 pm_message_t state)
+{
+	struct backlight_device *bl = platform_get_drvdata(pdev);
+	struct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);
+
+	pwm_config(pb->pwm, 0, pb->period);
+	pwm_disable(pb->pwm);
+	return 0;
+}
+
+static int pwm_backlight_resume(struct platform_device *pdev)
+{
+	struct backlight_device *bl = platform_get_drvdata(pdev);
+
+	backlight_update_status(bl);
+	return 0;
+}
+#else
+#define pwm_backlight_suspend	NULL
+#define pwm_backlight_resume	NULL
+#endif
+
+static struct platform_driver pwm_backlight_driver = {
+	.driver		= {
+		.name	= "pwm-backlight",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= pwm_backlight_probe,
+	.remove		= pwm_backlight_remove,
+	.suspend	= pwm_backlight_suspend,
+	.resume		= pwm_backlight_resume,
+};
+
+static int __init pwm_backlight_init(void)
+{
+	return platform_driver_register(&pwm_backlight_driver);
+}
+module_init(pwm_backlight_init);
+
+static void __exit pwm_backlight_exit(void)
+{
+	platform_driver_unregister(&pwm_backlight_driver);
+}
+module_exit(pwm_backlight_exit);
+
+MODULE_DESCRIPTION("PWM based Backlight Driver");
+MODULE_LICENSE("GPL");
