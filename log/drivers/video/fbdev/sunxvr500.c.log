commit 8a48ac339398f21282985bff16552447d41dcfb2
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Dec 3 18:38:50 2019 +0200

    video: constify fb ops across all drivers
    
    Now that the fbops member of struct fb_info is const, we can start
    making the ops const as well.
    
    This does not cover all drivers; some actually modify the fbops struct,
    for example to adjust for different configurations, and others do more
    involved things that I'd rather not touch in practically obsolete
    drivers. Mostly this is the low hanging fruit where we can add "const"
    and be done with it.
    
    v3:
    - un-constify atyfb, mb862xx, nvidia and uvesabf (0day)
    
    v2:
    - fix typo (Christophe de Dinechin)
    - use "static const" instead of "const static" in mx3fb.c
    - also constify smscufx.c
    
    Cc: linux-fbdev@vger.kernel.org
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/ce67f14435f3af498f2e8bf35ce4be11f7504132.1575390740.git.jani.nikula@intel.com

diff --git a/drivers/video/fbdev/sunxvr500.c b/drivers/video/fbdev/sunxvr500.c
index d392976126a6..9daf17b11106 100644
--- a/drivers/video/fbdev/sunxvr500.c
+++ b/drivers/video/fbdev/sunxvr500.c
@@ -186,7 +186,7 @@ static void e3d_copyarea(struct fb_info *info, const struct fb_copyarea *area)
 	spin_unlock_irqrestore(&ep->lock, flags);
 }
 
-static struct fb_ops e3d_ops = {
+static const struct fb_ops e3d_ops = {
 	.owner			= THIS_MODULE,
 	.fb_setcolreg		= e3d_setcolreg,
 	.fb_fillrect		= e3d_fillrect,

commit 0adcdbcb179624d7b3677264f2cd228e7d89eea9
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Fri Jun 28 12:30:08 2019 +0200

    video: fbdev: don't print error message on framebuffer_alloc() failure
    
    framebuffer_alloc() can fail only on kzalloc() memory allocation
    failure and since kzalloc() will print error message in such case
    we can omit printing extra error message in drivers (which BTW is
    what the majority of framebuffer_alloc() users is doing already).
    
    Cc: "Bruno Pr√©mont" <bonbons@linux-vserver.org>
    Cc: Jiri Kosina <jikos@kernel.org>
    Cc: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/drivers/video/fbdev/sunxvr500.c b/drivers/video/fbdev/sunxvr500.c
index bc595937df08..d392976126a6 100644
--- a/drivers/video/fbdev/sunxvr500.c
+++ b/drivers/video/fbdev/sunxvr500.c
@@ -272,7 +272,6 @@ static int e3d_pci_register(struct pci_dev *pdev,
 
 	info = framebuffer_alloc(sizeof(struct e3d_info), &pdev->dev);
 	if (!info) {
-		printk(KERN_ERR "e3d: Cannot allocate fb_info\n");
 		err = -ENOMEM;
 		goto err_disable;
 	}

commit 7c2ab2ae510e3d9ea32757aeb649dbc90ef6e053
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Tue Aug 1 17:20:43 2017 +0200

    video: fbdev: sunxvr500: constify pci_device_id.
    
    pci_device_id are not supposed to change at runtime. All functions
    working with pci_device_id provided by <linux/pci.h> work with
    const pci_device_id. So mark the non-const structs as const.
    
    File size before:
       text    data     bss     dec     hex filename
        170     488       0     658     292 drivers/video/fbdev/sunxvr500.o
    
    File size after adding 'const':
       text    data     bss     dec     hex filename
        394     264       0     658     292 drivers/video/fbdev/sunxvr500.o
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Antonino Daplas <adaplas@gmail.com>
    Cc: Maik Broemme <mbroemme@libmpq.org>
    Cc: Florian Tobias Schandinat <FlorianSchandinat@gmx.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/drivers/video/fbdev/sunxvr500.c b/drivers/video/fbdev/sunxvr500.c
index dc0d886e4e7e..bc595937df08 100644
--- a/drivers/video/fbdev/sunxvr500.c
+++ b/drivers/video/fbdev/sunxvr500.c
@@ -393,7 +393,7 @@ static int e3d_pci_register(struct pci_dev *pdev,
 	return err;
 }
 
-static struct pci_device_id e3d_pci_table[] = {
+static const struct pci_device_id e3d_pci_table[] = {
 	{	PCI_DEVICE(PCI_VENDOR_ID_3DLABS, 0x7a0),	},
 	{	PCI_DEVICE(0x1091, 0x7a0),			},
 	{	PCI_DEVICE(PCI_VENDOR_ID_3DLABS, 0x7a2),	},

commit d61b0ef7184f3b5a7e068f503ccaa6e2701c00ea
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Feb 21 22:13:10 2016 -0500

    drivers/video: make fbdev/sunxvr500.c explicitly non-modular
    
    The Kconfig currently controlling compilation of this code is:
    
    config FB_XVR500
            bool "Sun XVR-500 3DLABS Wildcat support"
    
    ...meaning that it currently is not being built as a module by anyone.
    Lets remove the modular code that is essentially orphaned, so that
    when reading the driver there is no doubt it is builtin-only.
    
    We explicitly disallow a driver unbind, since that doesn't have a
    sensible use case anyway, and it allows us to drop the ".remove"
    code for non-modular drivers.
    
    Since module_init translates to device_initcall in the non-modular
    case, the init ordering remains unchanged with this commit.
    
    We don't replace module.h with init.h since the file already has that.
    
    We also delete the MODULE_LICENSE tag etc. since all that information
    was (or is now) contained at the top of the file in the comments.
    
    Cc: Jean-Christophe Plagniol-Villard <plagnioj@jcrosoft.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: sparclinux@vger.kernel.org
    Cc: linux-fbdev@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/video/fbdev/sunxvr500.c b/drivers/video/fbdev/sunxvr500.c
index 387350d004df..dc0d886e4e7e 100644
--- a/drivers/video/fbdev/sunxvr500.c
+++ b/drivers/video/fbdev/sunxvr500.c
@@ -1,9 +1,10 @@
-/* sunxvr500.c: Sun 3DLABS XVR-500 Expert3D driver for sparc64 systems
+/* sunxvr500.c: Sun 3DLABS XVR-500 Expert3D fb driver for sparc64 systems
+ *
+ * License: GPL
  *
  * Copyright (C) 2007 David S. Miller (davem@davemloft.net)
  */
 
-#include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/fb.h>
 #include <linux/pci.h>
@@ -392,25 +393,6 @@ static int e3d_pci_register(struct pci_dev *pdev,
 	return err;
 }
 
-static void e3d_pci_unregister(struct pci_dev *pdev)
-{
-	struct fb_info *info = pci_get_drvdata(pdev);
-	struct e3d_info *ep = info->par;
-
-	unregister_framebuffer(info);
-
-	iounmap(ep->ramdac);
-	iounmap(ep->fb_base);
-
-	pci_release_region(pdev, 0);
-	pci_release_region(pdev, 1);
-
-	fb_dealloc_cmap(&info->cmap);
-        framebuffer_release(info);
-
-	pci_disable_device(pdev);
-}
-
 static struct pci_device_id e3d_pci_table[] = {
 	{	PCI_DEVICE(PCI_VENDOR_ID_3DLABS, 0x7a0),	},
 	{	PCI_DEVICE(0x1091, 0x7a0),			},
@@ -434,10 +416,12 @@ static struct pci_device_id e3d_pci_table[] = {
 };
 
 static struct pci_driver e3d_driver = {
+	.driver = {
+		.suppress_bind_attrs = true,
+	},
 	.name		= "e3d",
 	.id_table	= e3d_pci_table,
 	.probe		= e3d_pci_register,
-	.remove		= e3d_pci_unregister,
 };
 
 static int __init e3d_init(void)
@@ -447,16 +431,4 @@ static int __init e3d_init(void)
 
 	return pci_register_driver(&e3d_driver);
 }
-
-static void __exit e3d_exit(void)
-{
-	pci_unregister_driver(&e3d_driver);
-}
-
-module_init(e3d_init);
-module_exit(e3d_exit);
-
-MODULE_DESCRIPTION("framebuffer driver for Sun XVR-500 graphics");
-MODULE_AUTHOR("David S. Miller <davem@davemloft.net>");
-MODULE_VERSION("1.0");
-MODULE_LICENSE("GPL");
+device_initcall(e3d_init);

commit f7018c21350204c4cf628462f229d44d03545254
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Feb 13 15:31:38 2014 +0200

    video: move fbdev to drivers/video/fbdev
    
    The drivers/video directory is a mess. It contains generic video related
    files, directories for backlight, console, linux logo, lots of fbdev
    device drivers, fbdev framework files.
    
    Make some order into the chaos by creating drivers/video/fbdev
    directory, and move all fbdev related files there.
    
    No functionality is changed, although I guess it is possible that some
    subtle Makefile build order related issue could be created by this
    patch.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Rob Clark <robdclark@gmail.com>
    Acked-by: Jingoo Han <jg1.han@samsung.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/video/fbdev/sunxvr500.c b/drivers/video/fbdev/sunxvr500.c
new file mode 100644
index 000000000000..387350d004df
--- /dev/null
+++ b/drivers/video/fbdev/sunxvr500.c
@@ -0,0 +1,462 @@
+/* sunxvr500.c: Sun 3DLABS XVR-500 Expert3D driver for sparc64 systems
+ *
+ * Copyright (C) 2007 David S. Miller (davem@davemloft.net)
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fb.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/of_device.h>
+
+#include <asm/io.h>
+
+/* XXX This device has a 'dev-comm' property which apparently is
+ * XXX a pointer into the openfirmware's address space which is
+ * XXX a shared area the kernel driver can use to keep OBP
+ * XXX informed about the current resolution setting.  The idea
+ * XXX is that the kernel can change resolutions, and as long
+ * XXX as the values in the 'dev-comm' area are accurate then
+ * XXX OBP can still render text properly to the console.
+ * XXX
+ * XXX I'm still working out the layout of this and whether there
+ * XXX are any signatures we need to look for etc.
+ */
+struct e3d_info {
+	struct fb_info		*info;
+	struct pci_dev		*pdev;
+
+	spinlock_t		lock;
+
+	char __iomem		*fb_base;
+	unsigned long		fb_base_phys;
+
+	unsigned long		fb8_buf_diff;
+	unsigned long		regs_base_phys;
+
+	void __iomem		*ramdac;
+
+	struct device_node	*of_node;
+
+	unsigned int		width;
+	unsigned int		height;
+	unsigned int		depth;
+	unsigned int		fb_size;
+
+	u32			fb_base_reg;
+	u32			fb8_0_off;
+	u32			fb8_1_off;
+
+	u32			pseudo_palette[16];
+};
+
+static int e3d_get_props(struct e3d_info *ep)
+{
+	ep->width = of_getintprop_default(ep->of_node, "width", 0);
+	ep->height = of_getintprop_default(ep->of_node, "height", 0);
+	ep->depth = of_getintprop_default(ep->of_node, "depth", 8);
+
+	if (!ep->width || !ep->height) {
+		printk(KERN_ERR "e3d: Critical properties missing for %s\n",
+		       pci_name(ep->pdev));
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* My XVR-500 comes up, at 1280x768 and a FB base register value of
+ * 0x04000000, the following video layout register values:
+ *
+ * RAMDAC_VID_WH	0x03ff04ff
+ * RAMDAC_VID_CFG	0x1a0b0088
+ * RAMDAC_VID_32FB_0	0x04000000
+ * RAMDAC_VID_32FB_1	0x04800000
+ * RAMDAC_VID_8FB_0	0x05000000
+ * RAMDAC_VID_8FB_1	0x05200000
+ * RAMDAC_VID_XXXFB	0x05400000
+ * RAMDAC_VID_YYYFB	0x05c00000
+ * RAMDAC_VID_ZZZFB	0x05e00000
+ */
+/* Video layout registers */
+#define RAMDAC_VID_WH		0x00000070UL /* (height-1)<<16 | (width-1) */
+#define RAMDAC_VID_CFG		0x00000074UL /* 0x1a000088|(linesz_log2<<16) */
+#define RAMDAC_VID_32FB_0	0x00000078UL /* PCI base 32bpp FB buffer 0 */
+#define RAMDAC_VID_32FB_1	0x0000007cUL /* PCI base 32bpp FB buffer 1 */
+#define RAMDAC_VID_8FB_0	0x00000080UL /* PCI base 8bpp FB buffer 0 */
+#define RAMDAC_VID_8FB_1	0x00000084UL /* PCI base 8bpp FB buffer 1 */
+#define RAMDAC_VID_XXXFB	0x00000088UL /* PCI base of XXX FB */
+#define RAMDAC_VID_YYYFB	0x0000008cUL /* PCI base of YYY FB */
+#define RAMDAC_VID_ZZZFB	0x00000090UL /* PCI base of ZZZ FB */
+
+/* CLUT registers */
+#define RAMDAC_INDEX		0x000000bcUL
+#define RAMDAC_DATA		0x000000c0UL
+
+static void e3d_clut_write(struct e3d_info *ep, int index, u32 val)
+{
+	void __iomem *ramdac = ep->ramdac;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ep->lock, flags);
+
+	writel(index, ramdac + RAMDAC_INDEX);
+	writel(val, ramdac + RAMDAC_DATA);
+
+	spin_unlock_irqrestore(&ep->lock, flags);
+}
+
+static int e3d_setcolreg(unsigned regno,
+			 unsigned red, unsigned green, unsigned blue,
+			 unsigned transp, struct fb_info *info)
+{
+	struct e3d_info *ep = info->par;
+	u32 red_8, green_8, blue_8;
+	u32 red_10, green_10, blue_10;
+	u32 value;
+
+	if (regno >= 256)
+		return 1;
+
+	red_8 = red >> 8;
+	green_8 = green >> 8;
+	blue_8 = blue >> 8;
+
+	value = (blue_8 << 24) | (green_8 << 16) | (red_8 << 8);
+
+	if (info->fix.visual == FB_VISUAL_TRUECOLOR && regno < 16)
+		((u32 *)info->pseudo_palette)[regno] = value;
+
+
+	red_10 = red >> 6;
+	green_10 = green >> 6;
+	blue_10 = blue >> 6;
+
+	value = (blue_10 << 20) | (green_10 << 10) | (red_10 << 0);
+	e3d_clut_write(ep, regno, value);
+
+	return 0;
+}
+
+/* XXX This is a bit of a hack.  I can't figure out exactly how the
+ * XXX two 8bpp areas of the framebuffer work.  I imagine there is
+ * XXX a WID attribute somewhere else in the framebuffer which tells
+ * XXX the ramdac which of the two 8bpp framebuffer regions to take
+ * XXX the pixel from.  So, for now, render into both regions to make
+ * XXX sure the pixel shows up.
+ */
+static void e3d_imageblit(struct fb_info *info, const struct fb_image *image)
+{
+	struct e3d_info *ep = info->par;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ep->lock, flags);
+	cfb_imageblit(info, image);
+	info->screen_base += ep->fb8_buf_diff;
+	cfb_imageblit(info, image);
+	info->screen_base -= ep->fb8_buf_diff;
+	spin_unlock_irqrestore(&ep->lock, flags);
+}
+
+static void e3d_fillrect(struct fb_info *info, const struct fb_fillrect *rect)
+{
+	struct e3d_info *ep = info->par;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ep->lock, flags);
+	cfb_fillrect(info, rect);
+	info->screen_base += ep->fb8_buf_diff;
+	cfb_fillrect(info, rect);
+	info->screen_base -= ep->fb8_buf_diff;
+	spin_unlock_irqrestore(&ep->lock, flags);
+}
+
+static void e3d_copyarea(struct fb_info *info, const struct fb_copyarea *area)
+{
+	struct e3d_info *ep = info->par;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ep->lock, flags);
+	cfb_copyarea(info, area);
+	info->screen_base += ep->fb8_buf_diff;
+	cfb_copyarea(info, area);
+	info->screen_base -= ep->fb8_buf_diff;
+	spin_unlock_irqrestore(&ep->lock, flags);
+}
+
+static struct fb_ops e3d_ops = {
+	.owner			= THIS_MODULE,
+	.fb_setcolreg		= e3d_setcolreg,
+	.fb_fillrect		= e3d_fillrect,
+	.fb_copyarea		= e3d_copyarea,
+	.fb_imageblit		= e3d_imageblit,
+};
+
+static int e3d_set_fbinfo(struct e3d_info *ep)
+{
+	struct fb_info *info = ep->info;
+	struct fb_var_screeninfo *var = &info->var;
+
+	info->flags = FBINFO_DEFAULT;
+	info->fbops = &e3d_ops;
+	info->screen_base = ep->fb_base;
+	info->screen_size = ep->fb_size;
+
+	info->pseudo_palette = ep->pseudo_palette;
+
+	/* Fill fix common fields */
+	strlcpy(info->fix.id, "e3d", sizeof(info->fix.id));
+        info->fix.smem_start = ep->fb_base_phys;
+        info->fix.smem_len = ep->fb_size;
+        info->fix.type = FB_TYPE_PACKED_PIXELS;
+	if (ep->depth == 32 || ep->depth == 24)
+		info->fix.visual = FB_VISUAL_TRUECOLOR;
+	else
+		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+
+	var->xres = ep->width;
+	var->yres = ep->height;
+	var->xres_virtual = var->xres;
+	var->yres_virtual = var->yres;
+	var->bits_per_pixel = ep->depth;
+
+	var->red.offset = 8;
+	var->red.length = 8;
+	var->green.offset = 16;
+	var->green.length = 8;
+	var->blue.offset = 24;
+	var->blue.length = 8;
+	var->transp.offset = 0;
+	var->transp.length = 0;
+
+	if (fb_alloc_cmap(&info->cmap, 256, 0)) {
+		printk(KERN_ERR "e3d: Cannot allocate color map.\n");
+		return -ENOMEM;
+	}
+
+        return 0;
+}
+
+static int e3d_pci_register(struct pci_dev *pdev,
+			    const struct pci_device_id *ent)
+{
+	struct device_node *of_node;
+	const char *device_type;
+	struct fb_info *info;
+	struct e3d_info *ep;
+	unsigned int line_length;
+	int err;
+
+	of_node = pci_device_to_OF_node(pdev);
+	if (!of_node) {
+		printk(KERN_ERR "e3d: Cannot find OF node of %s\n",
+		       pci_name(pdev));
+		return -ENODEV;
+	}
+
+	device_type = of_get_property(of_node, "device_type", NULL);
+	if (!device_type) {
+		printk(KERN_INFO "e3d: Ignoring secondary output device "
+		       "at %s\n", pci_name(pdev));
+		return -ENODEV;
+	}
+
+	err = pci_enable_device(pdev);
+	if (err < 0) {
+		printk(KERN_ERR "e3d: Cannot enable PCI device %s\n",
+		       pci_name(pdev));
+		goto err_out;
+	}
+
+	info = framebuffer_alloc(sizeof(struct e3d_info), &pdev->dev);
+	if (!info) {
+		printk(KERN_ERR "e3d: Cannot allocate fb_info\n");
+		err = -ENOMEM;
+		goto err_disable;
+	}
+
+	ep = info->par;
+	ep->info = info;
+	ep->pdev = pdev;
+	spin_lock_init(&ep->lock);
+	ep->of_node = of_node;
+
+	/* Read the PCI base register of the frame buffer, which we
+	 * need in order to interpret the RAMDAC_VID_*FB* values in
+	 * the ramdac correctly.
+	 */
+	pci_read_config_dword(pdev, PCI_BASE_ADDRESS_0,
+			      &ep->fb_base_reg);
+	ep->fb_base_reg &= PCI_BASE_ADDRESS_MEM_MASK;
+
+	ep->regs_base_phys = pci_resource_start (pdev, 1);
+	err = pci_request_region(pdev, 1, "e3d regs");
+	if (err < 0) {
+		printk("e3d: Cannot request region 1 for %s\n",
+		       pci_name(pdev));
+		goto err_release_fb;
+	}
+	ep->ramdac = ioremap(ep->regs_base_phys + 0x8000, 0x1000);
+	if (!ep->ramdac) {
+		err = -ENOMEM;
+		goto err_release_pci1;
+	}
+
+	ep->fb8_0_off = readl(ep->ramdac + RAMDAC_VID_8FB_0);
+	ep->fb8_0_off -= ep->fb_base_reg;
+
+	ep->fb8_1_off = readl(ep->ramdac + RAMDAC_VID_8FB_1);
+	ep->fb8_1_off -= ep->fb_base_reg;
+
+	ep->fb8_buf_diff = ep->fb8_1_off - ep->fb8_0_off;
+
+	ep->fb_base_phys = pci_resource_start (pdev, 0);
+	ep->fb_base_phys += ep->fb8_0_off;
+
+	err = pci_request_region(pdev, 0, "e3d framebuffer");
+	if (err < 0) {
+		printk("e3d: Cannot request region 0 for %s\n",
+		       pci_name(pdev));
+		goto err_unmap_ramdac;
+	}
+
+	err = e3d_get_props(ep);
+	if (err)
+		goto err_release_pci0;
+
+	line_length = (readl(ep->ramdac + RAMDAC_VID_CFG) >> 16) & 0xff;
+	line_length = 1 << line_length;
+
+	switch (ep->depth) {
+	case 8:
+		info->fix.line_length = line_length;
+		break;
+	case 16:
+		info->fix.line_length = line_length * 2;
+		break;
+	case 24:
+		info->fix.line_length = line_length * 3;
+		break;
+	case 32:
+		info->fix.line_length = line_length * 4;
+		break;
+	}
+	ep->fb_size = info->fix.line_length * ep->height;
+
+	ep->fb_base = ioremap(ep->fb_base_phys, ep->fb_size);
+	if (!ep->fb_base) {
+		err = -ENOMEM;
+		goto err_release_pci0;
+	}
+
+	err = e3d_set_fbinfo(ep);
+	if (err)
+		goto err_unmap_fb;
+
+	pci_set_drvdata(pdev, info);
+
+	printk("e3d: Found device at %s\n", pci_name(pdev));
+
+	err = register_framebuffer(info);
+	if (err < 0) {
+		printk(KERN_ERR "e3d: Could not register framebuffer %s\n",
+		       pci_name(pdev));
+		goto err_free_cmap;
+	}
+
+	return 0;
+
+err_free_cmap:
+	fb_dealloc_cmap(&info->cmap);
+
+err_unmap_fb:
+	iounmap(ep->fb_base);
+
+err_release_pci0:
+	pci_release_region(pdev, 0);
+
+err_unmap_ramdac:
+	iounmap(ep->ramdac);
+
+err_release_pci1:
+	pci_release_region(pdev, 1);
+
+err_release_fb:
+        framebuffer_release(info);
+
+err_disable:
+	pci_disable_device(pdev);
+
+err_out:
+	return err;
+}
+
+static void e3d_pci_unregister(struct pci_dev *pdev)
+{
+	struct fb_info *info = pci_get_drvdata(pdev);
+	struct e3d_info *ep = info->par;
+
+	unregister_framebuffer(info);
+
+	iounmap(ep->ramdac);
+	iounmap(ep->fb_base);
+
+	pci_release_region(pdev, 0);
+	pci_release_region(pdev, 1);
+
+	fb_dealloc_cmap(&info->cmap);
+        framebuffer_release(info);
+
+	pci_disable_device(pdev);
+}
+
+static struct pci_device_id e3d_pci_table[] = {
+	{	PCI_DEVICE(PCI_VENDOR_ID_3DLABS, 0x7a0),	},
+	{	PCI_DEVICE(0x1091, 0x7a0),			},
+	{	PCI_DEVICE(PCI_VENDOR_ID_3DLABS, 0x7a2),	},
+	{	.vendor = PCI_VENDOR_ID_3DLABS,
+		.device = PCI_ANY_ID,
+		.subvendor = PCI_VENDOR_ID_3DLABS,
+		.subdevice = 0x0108,
+	},
+	{	.vendor = PCI_VENDOR_ID_3DLABS,
+		.device = PCI_ANY_ID,
+		.subvendor = PCI_VENDOR_ID_3DLABS,
+		.subdevice = 0x0140,
+	},
+	{	.vendor = PCI_VENDOR_ID_3DLABS,
+		.device = PCI_ANY_ID,
+		.subvendor = PCI_VENDOR_ID_3DLABS,
+		.subdevice = 0x1024,
+	},
+	{ 0, }
+};
+
+static struct pci_driver e3d_driver = {
+	.name		= "e3d",
+	.id_table	= e3d_pci_table,
+	.probe		= e3d_pci_register,
+	.remove		= e3d_pci_unregister,
+};
+
+static int __init e3d_init(void)
+{
+	if (fb_get_options("e3d", NULL))
+		return -ENODEV;
+
+	return pci_register_driver(&e3d_driver);
+}
+
+static void __exit e3d_exit(void)
+{
+	pci_unregister_driver(&e3d_driver);
+}
+
+module_init(e3d_init);
+module_exit(e3d_exit);
+
+MODULE_DESCRIPTION("framebuffer driver for Sun XVR-500 graphics");
+MODULE_AUTHOR("David S. Miller <davem@davemloft.net>");
+MODULE_VERSION("1.0");
+MODULE_LICENSE("GPL");
