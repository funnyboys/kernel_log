commit 9f68e3655aae6d49d6ba05dd263f99f33c2567af
Merge: 4cadc60d6bcf d47c7f062680
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 30 08:04:01 2020 -0800

    Merge tag 'drm-next-2020-01-30' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Davbe Airlie:
     "This is the main pull request for graphics for 5.6. Usual selection of
      changes all over.
    
      I've got one outstanding vmwgfx pull that touches mm so kept it
      separate until after all of this lands. I'll try and get it to you
      soon after this, but it might be early next week (nothing wrong with
      code, just my schedule is messy)
    
      This also hits a lot of fbdev drivers with some cleanups.
    
      Other notables:
       - vulkan timeline semaphore support added to syncobjs
       - nouveau turing secureboot/graphics support
       - Displayport MST display stream compression support
    
      Detailed summary:
    
      uapi:
       - dma-buf heaps added (and fixed)
       - command line add support for panel oreientation
       - command line allow overriding penguin count
    
      drm:
       - mipi dsi definition updates
       - lockdep annotations for dma_resv
       - remove dma-buf kmap/kunmap support
       - constify fb_ops in all fbdev drivers
       - MST fix for daisy chained hotplug-
       - CTA-861-G modes with VIC >= 193 added
       - fix drm_panel_of_backlight export
       - LVDS decoder support
       - more device based logging support
       - scanline alighment for dumb buffers
       - MST DSC helpers
    
      scheduler:
       - documentation fixes
       - job distribution improvements
    
      panel:
       - Logic PD type 28 panel support
       - Jimax8729d MIPI-DSI
       - igenic JZ4770
       - generic DSI devicetree bindings
       - sony acx424AKP panel
       - Leadtek LTK500HD1829
       - xinpeng XPP055C272
       - AUO B116XAK01
       - GiantPlus GPM940B0
       - BOE NV140FHM-N49
       - Satoz SAT050AT40H12R2
       - Sharp LS020B1DD01D panels.
    
      ttm:
       - use blocking WW lock
    
      i915:
       - hw/uapi state separation
       - Lock annotation improvements
       - selftest improvements
       - ICL/TGL DSI VDSC support
       - VBT parsing improvments
       - Display refactoring
       - DSI updates + fixes
       - HDCP 2.2 for CFL
       - CML PCI ID fixes
       - GLK+ fbc fix
       - PSR fixes
       - GEN/GT refactor improvments
       - DP MST fixes
       - switch context id alloc to xarray
       - workaround updates
       - LMEM debugfs support
       - tiled monitor fixes
       - ICL+ clock gating programming removed
       - DP MST disable sequence fixed
       - LMEM discontiguous object maps
       - prefaulting for discontiguous objects
       - use LMEM for dumb buffers if possible
       - add LMEM mmap support
    
      amdgpu:
       - enable sync object timelines for vulkan
       - MST atomic routines
       - enable MST DSC support
       - add DMCUB display microengine support
       - DC OEM i2c support
       - Renoir DC fixes
       - Initial HDCP 2.x support
       - BACO support for Arcturus
       - Use BACO for runtime PM power save
       - gfxoff on navi10
       - gfx10 golden updates and fixes
       - DCN support on POWER
       - GFXOFF for raven1 refresh
       - MM engine idle handlers cleanup
       - 10bpc EDP panel fixes
       - renoir watermark fixes
       - SR-IOV fixes
       - Arcturus VCN fixes
       - GDDR6 training fixes
       - freesync fixes
       - Pollock support
    
      amdkfd:
       - unify more codepath with amdgpu
       - use KIQ to setup HIQ rather than MMIO
    
      radeon:
       - fix vma fault handler race
       - PPC DMA fix
       - register check fixes for r100/r200
    
      nouveau:
       - mmap_sem vs dma_resv fix
       - rewrite the ACR secure boot code for Turing
       - TU10x graphics engine support (TU11x pending)
       - Page kind mapping for turing
       - 10-bit LUT support
       - GP10B Tegra fixes
       - HD audio regression fix
    
      hisilicon/hibmc:
       - use generic fbdev code and helpers
    
      rockchip:
       - dsi/px30 support
    
      virtio:
       - fb damage support
       - static some functions
    
      vc4:
       - use dma_resv lock wrappers
    
      msm:
       - use dma_resv lock wrappers
       - sc7180 display + DSI support
       - a618 support
       - UBWC support improvements
    
      vmwgfx:
       - updates + new logging uapi
    
      exynos:
       - enable/disable callback cleanups
    
      etnaviv:
       - use dma_resv lock wrappers
    
      atmel-hlcdc:
       - clock fixes
    
      mediatek:
       - cmdq support
       - non-smooth cursor fixes
       - ctm property support
    
      sun4i:
       - suspend support
       - A64 mipi dsi support
    
      rcar-du:
       - Color management module support
       - LVDS encoder dual-link support
       - R8A77980 support
    
      analogic:
       - add support for an6345
    
      ast:
       - atomic modeset support
       - primary plane garbage fix
    
      arcgpu:
       - fixes for fourcc handling
    
      tegra:
       - minor fixes and improvments
    
      mcde:
       - vblank support
    
      meson:
       - OSD1 plane AFBC commit
    
      gma500:
       - add pageflip support
       - reomve global drm_dev
    
      komeda:
       - tweak debugfs output
       - d32 support
       - runtime PM suppotr
    
      udl:
       - use generic shmem helpers
       - cleanup and fixes"
    
    * tag 'drm-next-2020-01-30' of git://anongit.freedesktop.org/drm/drm: (1998 commits)
      drm/nouveau/fb/gp102-: allow module to load even when scrubber binary is missing
      drm/nouveau/acr: return error when registering LSF if ACR not supported
      drm/nouveau/disp/gv100-: not all channel types support reporting error codes
      drm/nouveau/disp/nv50-: prevent oops when no channel method map provided
      drm/nouveau: support synchronous pushbuf submission
      drm/nouveau: signal pending fences when channel has been killed
      drm/nouveau: reject attempts to submit to dead channels
      drm/nouveau: zero vma pointer even if we only unreference it rather than free
      drm/nouveau: Add HD-audio component notifier support
      drm/nouveau: fix build error without CONFIG_IOMMU_API
      drm/nouveau/kms/nv04: remove set but not used variable 'width'
      drm/nouveau/kms/nv50: remove set but not unused variable 'nv_connector'
      drm/nouveau/mmu: fix comptag memory leak
      drm/nouveau/gr/gp10b: Use gp100_grctx and gp100_gr_zbc
      drm/nouveau/pmu/gm20b,gp10b: Fix Falcon bootstrapping
      drm/exynos: Rename Exynos to lowercase
      drm/exynos: change callback names
      drm/mst: Don't do atomic checks over disabled managers
      drm/amdgpu: add the lost mutex_init back
      drm/amd/display: skip opp blank or unblank if test pattern enabled
      ...

commit 2ec1431ffac9f891a11ac955a9ee914e0547215e
Author: kbuild test robot <lkp@intel.com>
Date:   Sat Jan 4 21:43:31 2020 +0100

    video: fbdev: mmp: fix platform_get_irq.cocci warnings
    
    Remove dev_err() messages after platform_get_irq*() failures.
    Line 450 is redundant because platform_get_irq() already prints
    an error.
    
    Generated by: scripts/coccinelle/api/platform_get_irq.cocci
    
    Fixes: dd90e9ae55a1 ("video: fbdev: mmp: add COMPILE_TEST support")
    Signed-off-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Julia Lawall <julia.lawall@inria.fr>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/alpine.DEB.2.21.2001042140310.6944@hadrien

diff --git a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
index b877a606ce26..88c137f5c729 100644
--- a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
+++ b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
@@ -456,7 +456,6 @@ static int mmphw_probe(struct platform_device *pdev)
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
-		dev_err(&pdev->dev, "%s: no IRQ defined\n", __func__);
 		ret = -ENOENT;
 		goto failed;
 	}

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
index 17174cd7a5bb..974e4c28b08b 100644
--- a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
+++ b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
@@ -485,7 +485,7 @@ static int mmphw_probe(struct platform_device *pdev)
 		goto failed;
 	}
 
-	ctrl->reg_base = devm_ioremap_nocache(ctrl->dev,
+	ctrl->reg_base = devm_ioremap(ctrl->dev,
 			res->start, resource_size(res));
 	if (ctrl->reg_base == NULL) {
 		dev_err(ctrl->dev, "%s: res %pR map failed\n", __func__, res);

commit e41f6b17aba58f4504491ebddc6ae4ce14f33ef3
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Jun 27 16:08:43 2019 +0200

    video: fbdev: mmp: fix sparse warnings about using incorrect types
    
    Use ->screen_buffer instead of ->screen_base in mmpfb driver.
    
    [ Please see commit 17a7b0b4d974 ("fb.h: Provide alternate screen_base
      pointer") for details. ]
    
    Also fix all other sparse warnings about using incorrect types in
    mmp display subsystem.
    
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/ee796b43-f200-d41a-b18c-ae3d6bcaaa67@samsung.com

diff --git a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
index 17174cd7a5bb..b877a606ce26 100644
--- a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
+++ b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
@@ -136,19 +136,26 @@ static void overlay_set_win(struct mmp_overlay *overlay, struct mmp_win *win)
 	mutex_lock(&overlay->access_ok);
 
 	if (overlay_is_vid(overlay)) {
-		writel_relaxed(win->pitch[0], &regs->v_pitch_yc);
-		writel_relaxed(win->pitch[2] << 16 |
-				win->pitch[1], &regs->v_pitch_uv);
-
-		writel_relaxed((win->ysrc << 16) | win->xsrc, &regs->v_size);
-		writel_relaxed((win->ydst << 16) | win->xdst, &regs->v_size_z);
-		writel_relaxed(win->ypos << 16 | win->xpos, &regs->v_start);
+		writel_relaxed(win->pitch[0],
+				(void __iomem *)&regs->v_pitch_yc);
+		writel_relaxed(win->pitch[2] << 16 | win->pitch[1],
+				(void __iomem *)&regs->v_pitch_uv);
+
+		writel_relaxed((win->ysrc << 16) | win->xsrc,
+				(void __iomem *)&regs->v_size);
+		writel_relaxed((win->ydst << 16) | win->xdst,
+				(void __iomem *)&regs->v_size_z);
+		writel_relaxed(win->ypos << 16 | win->xpos,
+				(void __iomem *)&regs->v_start);
 	} else {
-		writel_relaxed(win->pitch[0], &regs->g_pitch);
-
-		writel_relaxed((win->ysrc << 16) | win->xsrc, &regs->g_size);
-		writel_relaxed((win->ydst << 16) | win->xdst, &regs->g_size_z);
-		writel_relaxed(win->ypos << 16 | win->xpos, &regs->g_start);
+		writel_relaxed(win->pitch[0], (void __iomem *)&regs->g_pitch);
+
+		writel_relaxed((win->ysrc << 16) | win->xsrc,
+				(void __iomem *)&regs->g_size);
+		writel_relaxed((win->ydst << 16) | win->xdst,
+				(void __iomem *)&regs->g_size_z);
+		writel_relaxed(win->ypos << 16 | win->xpos,
+				(void __iomem *)&regs->g_start);
 	}
 
 	dmafetch_set_fmt(overlay);
@@ -233,11 +240,11 @@ static int overlay_set_addr(struct mmp_overlay *overlay, struct mmp_addr *addr)
 	memcpy(&overlay->addr, addr, sizeof(struct mmp_addr));
 
 	if (overlay_is_vid(overlay)) {
-		writel_relaxed(addr->phys[0], &regs->v_y0);
-		writel_relaxed(addr->phys[1], &regs->v_u0);
-		writel_relaxed(addr->phys[2], &regs->v_v0);
+		writel_relaxed(addr->phys[0], (void __iomem *)&regs->v_y0);
+		writel_relaxed(addr->phys[1], (void __iomem *)&regs->v_u0);
+		writel_relaxed(addr->phys[2], (void __iomem *)&regs->v_v0);
 	} else
-		writel_relaxed(addr->phys[0], &regs->g_0);
+		writel_relaxed(addr->phys[0], (void __iomem *)&regs->g_0);
 
 	return overlay->addr.phys[0];
 }
@@ -268,16 +275,18 @@ static void path_set_mode(struct mmp_path *path, struct mmp_mode *mode)
 	tmp |= dsi_rbswap & CFG_INTFRBSWAP_MASK;
 	writel_relaxed(tmp, ctrl_regs(path) + intf_rbswap_ctrl(path->id));
 
-	writel_relaxed((mode->yres << 16) | mode->xres, &regs->screen_active);
+	writel_relaxed((mode->yres << 16) | mode->xres,
+		(void __iomem *)&regs->screen_active);
 	writel_relaxed((mode->left_margin << 16) | mode->right_margin,
-		&regs->screen_h_porch);
+		(void __iomem *)&regs->screen_h_porch);
 	writel_relaxed((mode->upper_margin << 16) | mode->lower_margin,
-		&regs->screen_v_porch);
+		(void __iomem *)&regs->screen_v_porch);
 	total_x = mode->xres + mode->left_margin + mode->right_margin +
 		mode->hsync_len;
 	total_y = mode->yres + mode->upper_margin + mode->lower_margin +
 		mode->vsync_len;
-	writel_relaxed((total_y << 16) | total_x, &regs->screen_size);
+	writel_relaxed((total_y << 16) | total_x,
+		(void __iomem *)&regs->screen_size);
 
 	/* vsync ctrl */
 	if (path->output_type == PATH_OUT_DSI)
@@ -285,7 +294,7 @@ static void path_set_mode(struct mmp_path *path, struct mmp_mode *mode)
 	else
 		vsync_ctrl = ((mode->xres + mode->right_margin) << 16)
 					| (mode->xres + mode->right_margin);
-	writel_relaxed(vsync_ctrl, &regs->vsync_ctrl);
+	writel_relaxed(vsync_ctrl, (void __iomem *)&regs->vsync_ctrl);
 
 	/* set pixclock div */
 	sclk_src = clk_get_rate(path_to_ctrl(path)->clk);
@@ -366,9 +375,9 @@ static void path_set_default(struct mmp_path *path)
 	writel_relaxed(dma_ctrl1, ctrl_regs(path) + dma_ctrl(1, path->id));
 
 	/* Configure default register values */
-	writel_relaxed(0x00000000, &regs->blank_color);
-	writel_relaxed(0x00000000, &regs->g_1);
-	writel_relaxed(0x00000000, &regs->g_start);
+	writel_relaxed(0x00000000, (void __iomem *)&regs->blank_color);
+	writel_relaxed(0x00000000, (void __iomem *)&regs->g_1);
+	writel_relaxed(0x00000000, (void __iomem *)&regs->g_start);
 
 	/*
 	 * 1.enable multiple burst request in DMA AXI

commit b27b0017efa28217d234c23acbceadb1a71cf53a
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Jun 21 15:13:14 2019 +0200

    video: fbdev-MMP: Use struct_size() in devm_kzalloc()
    
    One of the more common cases of allocation size calculations is finding
    the size of a structure that has a zero-sized array at the end, along
    with memory for some number of elements for that array. For example:
    
    struct foo {
        int stuff;
        struct boo entry[];
    };
    
    size = sizeof(struct foo) + count * sizeof(struct boo);
    instance = devm_kzalloc(dev, size, GFP_KERNEL);
    
    Instead of leaving these open-coded and prone to type mistakes, we can
    now use the new struct_size() helper:
    
    instance = devm_kzalloc(dev, struct_size(instance, entry, count), GFP_KERNEL);
    
    Notice that, in this case, variable size is not necessary, hence it
    is removed.
    
    This code was detected with the help of Coccinelle.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
index 87d943f15a12..17174cd7a5bb 100644
--- a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
+++ b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
@@ -433,7 +433,7 @@ static int mmphw_probe(struct platform_device *pdev)
 {
 	struct mmp_mach_plat_info *mi;
 	struct resource *res;
-	int ret, i, size, irq;
+	int ret, i, irq;
 	struct mmphw_path_plat *path_plat;
 	struct mmphw_ctrl *ctrl = NULL;
 
@@ -461,9 +461,9 @@ static int mmphw_probe(struct platform_device *pdev)
 	}
 
 	/* allocate */
-	size = sizeof(struct mmphw_ctrl) + sizeof(struct mmphw_path_plat) *
-	       mi->path_num;
-	ctrl = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
+	ctrl = devm_kzalloc(&pdev->dev,
+			    struct_size(ctrl, path_plats, mi->path_num),
+			    GFP_KERNEL);
 	if (!ctrl) {
 		ret = -ENOMEM;
 		goto failed;

commit 1ccea77e2a2687cae171b7987eb44730ec8c6d5f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:43 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 13
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not see http www gnu org licenses
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details [based]
      [from] [clk] [highbank] [c] you should have received a copy of the
      gnu general public license along with this program if not see http
      www gnu org licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 355 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154041.837383322@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
index fcdbb2df137f..87d943f15a12 100644
--- a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
+++ b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * linux/drivers/video/mmp/hw/mmp_ctrl.c
  * Marvell MMP series Display Controller support
@@ -6,20 +7,6 @@
  * Authors:  Guoqing Li <ligq@marvell.com>
  *          Lisa Du <cldu@marvell.com>
  *          Zhou Zhu <zzhu3@marvell.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
- *
  */
 #include <linux/module.h>
 #include <linux/moduleparam.h>

commit 965bef6483e2bab20cd959d014f83b48da70e71c
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Apr 26 12:24:18 2018 +0200

    video: fbdev-MMP: Improve a size determination in path_init()
    
    Replace the specification of a data structure by a pointer dereference
    as the parameter for the operator "sizeof" to make the corresponding size
    determination a bit safer according to the Linux coding style convention.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
index 9f912ea0bfce..fcdbb2df137f 100644
--- a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
+++ b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
@@ -406,7 +406,7 @@ static int path_init(struct mmphw_path_plat *path_plat,
 	dev_info(ctrl->dev, "%s: %s\n", __func__, config->name);
 
 	/* init driver data */
-	path_info = kzalloc(sizeof(struct mmp_path_info), GFP_KERNEL);
+	path_info = kzalloc(sizeof(*path_info), GFP_KERNEL);
 	if (!path_info)
 		return 0;
 

commit e0e894f5941871a08cddeda0ad6996c82613d0a7
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Apr 26 12:24:18 2018 +0200

    video: fbdev-MMP: Delete an error message for a failed memory allocation in two functions
    
    Omit an extra message for a memory allocation failure in these functions.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
index b6f83d5df9fd..9f912ea0bfce 100644
--- a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
+++ b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
@@ -407,11 +407,9 @@ static int path_init(struct mmphw_path_plat *path_plat,
 
 	/* init driver data */
 	path_info = kzalloc(sizeof(struct mmp_path_info), GFP_KERNEL);
-	if (!path_info) {
-		dev_err(ctrl->dev, "%s: unable to alloc path_info for %s\n",
-				__func__, config->name);
+	if (!path_info)
 		return 0;
-	}
+
 	path_info->name = config->name;
 	path_info->id = path_plat->id;
 	path_info->dev = ctrl->dev;

commit c3a2da26e6216033456c1d5375cd1d2629d1fd09
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jan 25 16:03:01 2016 +0100

    fbdev: mmp: print IRQ resource using %pR format string
    
    resource_size_t cannot be printed using the %x format string
    when we it is defined as u64:
    
    drivers/video/fbdev/mmp/hw/mmp_ctrl.c: In function 'mmphw_probe':
    drivers/video/fbdev/mmp/hw/mmp_ctrl.c:506:22: error: format '%x' expects argument of type 'unsigned int', but argument 4 has type 'resource_size_t {aka long long unsigned int}' [-Werror=format=]
       dev_err(ctrl->dev, "%s: res %x - %x map failed\n", __func__,
                          ^
    drivers/video/fbdev/mmp/hw/mmp_ctrl.c:506:22: error: format '%x' expects argument of type 'unsigned int', but argument 5 has type 'resource_size_t {aka long long unsigned int}' [-Werror=format=]
    
    This changes the format string to %pR, which is interpreted
    by the printk implementation to pretty-print a resource
    structure.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
index de54a4748065..b6f83d5df9fd 100644
--- a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
+++ b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
@@ -503,8 +503,7 @@ static int mmphw_probe(struct platform_device *pdev)
 	ctrl->reg_base = devm_ioremap_nocache(ctrl->dev,
 			res->start, resource_size(res));
 	if (ctrl->reg_base == NULL) {
-		dev_err(ctrl->dev, "%s: res %x - %x map failed\n", __func__,
-			res->start, res->end);
+		dev_err(ctrl->dev, "%s: res %pR map failed\n", __func__, res);
 		ret = -ENOMEM;
 		goto failed;
 	}

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit 3163e4cd16584a461e89bf0abbd410f40fd2286f
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sun Nov 23 15:45:03 2014 +0100

    video: fbdev-MMP: Deletion of an unnecessary check before the function call "mmp_unregister_path"
    
    The mmp_unregister_path() function tests whether its argument is NULL
    and then returns immediately. Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
index 8621a9f2bdcc..3c12bd83b561 100644
--- a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
+++ b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
@@ -441,8 +441,7 @@ static void path_deinit(struct mmphw_path_plat *path_plat)
 	if (!path_plat)
 		return;
 
-	if (path_plat->path)
-		mmp_unregister_path(path_plat->path);
+	mmp_unregister_path(path_plat->path);
 }
 
 static int mmphw_probe(struct platform_device *pdev)

commit dcb7b311646f0b95c8a950a0be842fe5e195b904
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:53 2014 +0200

    video: fbdev: mmp: hw: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
index 8621a9f2bdcc..117383634de9 100644
--- a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
+++ b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
@@ -572,7 +572,6 @@ static int mmphw_probe(struct platform_device *pdev)
 static struct platform_driver mmphw_driver = {
 	.driver		= {
 		.name	= "mmp-disp",
-		.owner	= THIS_MODULE,
 	},
 	.probe		= mmphw_probe,
 };

commit f7018c21350204c4cf628462f229d44d03545254
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Feb 13 15:31:38 2014 +0200

    video: move fbdev to drivers/video/fbdev
    
    The drivers/video directory is a mess. It contains generic video related
    files, directories for backlight, console, linux logo, lots of fbdev
    device drivers, fbdev framework files.
    
    Make some order into the chaos by creating drivers/video/fbdev
    directory, and move all fbdev related files there.
    
    No functionality is changed, although I guess it is possible that some
    subtle Makefile build order related issue could be created by this
    patch.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Rob Clark <robdclark@gmail.com>
    Acked-by: Jingoo Han <jg1.han@samsung.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/video/fbdev/mmp/hw/mmp_ctrl.c b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
new file mode 100644
index 000000000000..8621a9f2bdcc
--- /dev/null
+++ b/drivers/video/fbdev/mmp/hw/mmp_ctrl.c
@@ -0,0 +1,588 @@
+/*
+ * linux/drivers/video/mmp/hw/mmp_ctrl.c
+ * Marvell MMP series Display Controller support
+ *
+ * Copyright (C) 2012 Marvell Technology Group Ltd.
+ * Authors:  Guoqing Li <ligq@marvell.com>
+ *          Lisa Du <cldu@marvell.com>
+ *          Zhou Zhu <zzhu3@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/vmalloc.h>
+#include <linux/uaccess.h>
+#include <linux/kthread.h>
+#include <linux/io.h>
+
+#include "mmp_ctrl.h"
+
+static irqreturn_t ctrl_handle_irq(int irq, void *dev_id)
+{
+	struct mmphw_ctrl *ctrl = (struct mmphw_ctrl *)dev_id;
+	u32 isr, imask, tmp;
+
+	isr = readl_relaxed(ctrl->reg_base + SPU_IRQ_ISR);
+	imask = readl_relaxed(ctrl->reg_base + SPU_IRQ_ENA);
+
+	do {
+		/* clear clock only */
+		tmp = readl_relaxed(ctrl->reg_base + SPU_IRQ_ISR);
+		if (tmp & isr)
+			writel_relaxed(~isr, ctrl->reg_base + SPU_IRQ_ISR);
+	} while ((isr = readl_relaxed(ctrl->reg_base + SPU_IRQ_ISR)) & imask);
+
+	return IRQ_HANDLED;
+}
+
+static u32 fmt_to_reg(struct mmp_overlay *overlay, int pix_fmt)
+{
+	u32 rbswap = 0, uvswap = 0, yuvswap = 0,
+		csc_en = 0, val = 0,
+		vid = overlay_is_vid(overlay);
+
+	switch (pix_fmt) {
+	case PIXFMT_RGB565:
+	case PIXFMT_RGB1555:
+	case PIXFMT_RGB888PACK:
+	case PIXFMT_RGB888UNPACK:
+	case PIXFMT_RGBA888:
+		rbswap = 1;
+		break;
+	case PIXFMT_VYUY:
+	case PIXFMT_YVU422P:
+	case PIXFMT_YVU420P:
+		uvswap = 1;
+		break;
+	case PIXFMT_YUYV:
+		yuvswap = 1;
+		break;
+	default:
+		break;
+	}
+
+	switch (pix_fmt) {
+	case PIXFMT_RGB565:
+	case PIXFMT_BGR565:
+		break;
+	case PIXFMT_RGB1555:
+	case PIXFMT_BGR1555:
+		val = 0x1;
+		break;
+	case PIXFMT_RGB888PACK:
+	case PIXFMT_BGR888PACK:
+		val = 0x2;
+		break;
+	case PIXFMT_RGB888UNPACK:
+	case PIXFMT_BGR888UNPACK:
+		val = 0x3;
+		break;
+	case PIXFMT_RGBA888:
+	case PIXFMT_BGRA888:
+		val = 0x4;
+		break;
+	case PIXFMT_UYVY:
+	case PIXFMT_VYUY:
+	case PIXFMT_YUYV:
+		val = 0x5;
+		csc_en = 1;
+		break;
+	case PIXFMT_YUV422P:
+	case PIXFMT_YVU422P:
+		val = 0x6;
+		csc_en = 1;
+		break;
+	case PIXFMT_YUV420P:
+	case PIXFMT_YVU420P:
+		val = 0x7;
+		csc_en = 1;
+		break;
+	default:
+		break;
+	}
+
+	return (dma_palette(0) | dma_fmt(vid, val) |
+		dma_swaprb(vid, rbswap) | dma_swapuv(vid, uvswap) |
+		dma_swapyuv(vid, yuvswap) | dma_csc(vid, csc_en));
+}
+
+static void dmafetch_set_fmt(struct mmp_overlay *overlay)
+{
+	u32 tmp;
+	struct mmp_path *path = overlay->path;
+	tmp = readl_relaxed(ctrl_regs(path) + dma_ctrl(0, path->id));
+	tmp &= ~dma_mask(overlay_is_vid(overlay));
+	tmp |= fmt_to_reg(overlay, overlay->win.pix_fmt);
+	writel_relaxed(tmp, ctrl_regs(path) + dma_ctrl(0, path->id));
+}
+
+static void overlay_set_win(struct mmp_overlay *overlay, struct mmp_win *win)
+{
+	struct lcd_regs *regs = path_regs(overlay->path);
+
+	/* assert win supported */
+	memcpy(&overlay->win, win, sizeof(struct mmp_win));
+
+	mutex_lock(&overlay->access_ok);
+
+	if (overlay_is_vid(overlay)) {
+		writel_relaxed(win->pitch[0], &regs->v_pitch_yc);
+		writel_relaxed(win->pitch[2] << 16 |
+				win->pitch[1], &regs->v_pitch_uv);
+
+		writel_relaxed((win->ysrc << 16) | win->xsrc, &regs->v_size);
+		writel_relaxed((win->ydst << 16) | win->xdst, &regs->v_size_z);
+		writel_relaxed(win->ypos << 16 | win->xpos, &regs->v_start);
+	} else {
+		writel_relaxed(win->pitch[0], &regs->g_pitch);
+
+		writel_relaxed((win->ysrc << 16) | win->xsrc, &regs->g_size);
+		writel_relaxed((win->ydst << 16) | win->xdst, &regs->g_size_z);
+		writel_relaxed(win->ypos << 16 | win->xpos, &regs->g_start);
+	}
+
+	dmafetch_set_fmt(overlay);
+	mutex_unlock(&overlay->access_ok);
+}
+
+static void dmafetch_onoff(struct mmp_overlay *overlay, int on)
+{
+	u32 mask = overlay_is_vid(overlay) ? CFG_DMA_ENA_MASK :
+		   CFG_GRA_ENA_MASK;
+	u32 enable = overlay_is_vid(overlay) ? CFG_DMA_ENA(1) : CFG_GRA_ENA(1);
+	u32 tmp;
+	struct mmp_path *path = overlay->path;
+
+	mutex_lock(&overlay->access_ok);
+	tmp = readl_relaxed(ctrl_regs(path) + dma_ctrl(0, path->id));
+	tmp &= ~mask;
+	tmp |= (on ? enable : 0);
+	writel(tmp, ctrl_regs(path) + dma_ctrl(0, path->id));
+	mutex_unlock(&overlay->access_ok);
+}
+
+static void path_enabledisable(struct mmp_path *path, int on)
+{
+	u32 tmp;
+	mutex_lock(&path->access_ok);
+	tmp = readl_relaxed(ctrl_regs(path) + LCD_SCLK(path));
+	if (on)
+		tmp &= ~SCLK_DISABLE;
+	else
+		tmp |= SCLK_DISABLE;
+	writel_relaxed(tmp, ctrl_regs(path) + LCD_SCLK(path));
+	mutex_unlock(&path->access_ok);
+}
+
+static void path_onoff(struct mmp_path *path, int on)
+{
+	if (path->status == on) {
+		dev_info(path->dev, "path %s is already %s\n",
+				path->name, stat_name(path->status));
+		return;
+	}
+
+	if (on) {
+		path_enabledisable(path, 1);
+
+		if (path->panel && path->panel->set_onoff)
+			path->panel->set_onoff(path->panel, 1);
+	} else {
+		if (path->panel && path->panel->set_onoff)
+			path->panel->set_onoff(path->panel, 0);
+
+		path_enabledisable(path, 0);
+	}
+	path->status = on;
+}
+
+static void overlay_set_onoff(struct mmp_overlay *overlay, int on)
+{
+	if (overlay->status == on) {
+		dev_info(overlay_to_ctrl(overlay)->dev, "overlay %s is already %s\n",
+			overlay->path->name, stat_name(overlay->status));
+		return;
+	}
+	overlay->status = on;
+	dmafetch_onoff(overlay, on);
+	if (overlay->path->ops.check_status(overlay->path)
+			!= overlay->path->status)
+		path_onoff(overlay->path, on);
+}
+
+static void overlay_set_fetch(struct mmp_overlay *overlay, int fetch_id)
+{
+	overlay->dmafetch_id = fetch_id;
+}
+
+static int overlay_set_addr(struct mmp_overlay *overlay, struct mmp_addr *addr)
+{
+	struct lcd_regs *regs = path_regs(overlay->path);
+
+	/* FIXME: assert addr supported */
+	memcpy(&overlay->addr, addr, sizeof(struct mmp_addr));
+
+	if (overlay_is_vid(overlay)) {
+		writel_relaxed(addr->phys[0], &regs->v_y0);
+		writel_relaxed(addr->phys[1], &regs->v_u0);
+		writel_relaxed(addr->phys[2], &regs->v_v0);
+	} else
+		writel_relaxed(addr->phys[0], &regs->g_0);
+
+	return overlay->addr.phys[0];
+}
+
+static void path_set_mode(struct mmp_path *path, struct mmp_mode *mode)
+{
+	struct lcd_regs *regs = path_regs(path);
+	u32 total_x, total_y, vsync_ctrl, tmp, sclk_src, sclk_div,
+		link_config = path_to_path_plat(path)->link_config,
+		dsi_rbswap = path_to_path_plat(path)->link_config;
+
+	/* FIXME: assert videomode supported */
+	memcpy(&path->mode, mode, sizeof(struct mmp_mode));
+
+	mutex_lock(&path->access_ok);
+
+	/* polarity of timing signals */
+	tmp = readl_relaxed(ctrl_regs(path) + intf_ctrl(path->id)) & 0x1;
+	tmp |= mode->vsync_invert ? 0 : 0x8;
+	tmp |= mode->hsync_invert ? 0 : 0x4;
+	tmp |= link_config & CFG_DUMBMODE_MASK;
+	tmp |= CFG_DUMB_ENA(1);
+	writel_relaxed(tmp, ctrl_regs(path) + intf_ctrl(path->id));
+
+	/* interface rb_swap setting */
+	tmp = readl_relaxed(ctrl_regs(path) + intf_rbswap_ctrl(path->id)) &
+		(~(CFG_INTFRBSWAP_MASK));
+	tmp |= dsi_rbswap & CFG_INTFRBSWAP_MASK;
+	writel_relaxed(tmp, ctrl_regs(path) + intf_rbswap_ctrl(path->id));
+
+	writel_relaxed((mode->yres << 16) | mode->xres, &regs->screen_active);
+	writel_relaxed((mode->left_margin << 16) | mode->right_margin,
+		&regs->screen_h_porch);
+	writel_relaxed((mode->upper_margin << 16) | mode->lower_margin,
+		&regs->screen_v_porch);
+	total_x = mode->xres + mode->left_margin + mode->right_margin +
+		mode->hsync_len;
+	total_y = mode->yres + mode->upper_margin + mode->lower_margin +
+		mode->vsync_len;
+	writel_relaxed((total_y << 16) | total_x, &regs->screen_size);
+
+	/* vsync ctrl */
+	if (path->output_type == PATH_OUT_DSI)
+		vsync_ctrl = 0x01330133;
+	else
+		vsync_ctrl = ((mode->xres + mode->right_margin) << 16)
+					| (mode->xres + mode->right_margin);
+	writel_relaxed(vsync_ctrl, &regs->vsync_ctrl);
+
+	/* set pixclock div */
+	sclk_src = clk_get_rate(path_to_ctrl(path)->clk);
+	sclk_div = sclk_src / mode->pixclock_freq;
+	if (sclk_div * mode->pixclock_freq < sclk_src)
+		sclk_div++;
+
+	dev_info(path->dev, "%s sclk_src %d sclk_div 0x%x pclk %d\n",
+			__func__, sclk_src, sclk_div, mode->pixclock_freq);
+
+	tmp = readl_relaxed(ctrl_regs(path) + LCD_SCLK(path));
+	tmp &= ~CLK_INT_DIV_MASK;
+	tmp |= sclk_div;
+	writel_relaxed(tmp, ctrl_regs(path) + LCD_SCLK(path));
+
+	mutex_unlock(&path->access_ok);
+}
+
+static struct mmp_overlay_ops mmphw_overlay_ops = {
+	.set_fetch = overlay_set_fetch,
+	.set_onoff = overlay_set_onoff,
+	.set_win = overlay_set_win,
+	.set_addr = overlay_set_addr,
+};
+
+static void ctrl_set_default(struct mmphw_ctrl *ctrl)
+{
+	u32 tmp, irq_mask;
+
+	/*
+	 * LCD Global control(LCD_TOP_CTRL) should be configed before
+	 * any other LCD registers read/write, or there maybe issues.
+	 */
+	tmp = readl_relaxed(ctrl->reg_base + LCD_TOP_CTRL);
+	tmp |= 0xfff0;
+	writel_relaxed(tmp, ctrl->reg_base + LCD_TOP_CTRL);
+
+
+	/* disable all interrupts */
+	irq_mask = path_imasks(0) | err_imask(0) |
+		   path_imasks(1) | err_imask(1);
+	tmp = readl_relaxed(ctrl->reg_base + SPU_IRQ_ENA);
+	tmp &= ~irq_mask;
+	tmp |= irq_mask;
+	writel_relaxed(tmp, ctrl->reg_base + SPU_IRQ_ENA);
+}
+
+static void path_set_default(struct mmp_path *path)
+{
+	struct lcd_regs *regs = path_regs(path);
+	u32 dma_ctrl1, mask, tmp, path_config;
+
+	path_config = path_to_path_plat(path)->path_config;
+
+	/* Configure IOPAD: should be parallel only */
+	if (PATH_OUT_PARALLEL == path->output_type) {
+		mask = CFG_IOPADMODE_MASK | CFG_BURST_MASK | CFG_BOUNDARY_MASK;
+		tmp = readl_relaxed(ctrl_regs(path) + SPU_IOPAD_CONTROL);
+		tmp &= ~mask;
+		tmp |= path_config;
+		writel_relaxed(tmp, ctrl_regs(path) + SPU_IOPAD_CONTROL);
+	}
+
+	/* Select path clock source */
+	tmp = readl_relaxed(ctrl_regs(path) + LCD_SCLK(path));
+	tmp &= ~SCLK_SRC_SEL_MASK;
+	tmp |= path_config;
+	writel_relaxed(tmp, ctrl_regs(path) + LCD_SCLK(path));
+
+	/*
+	 * Configure default bits: vsync triggers DMA,
+	 * power save enable, configure alpha registers to
+	 * display 100% graphics, and set pixel command.
+	 */
+	dma_ctrl1 = 0x2032ff81;
+
+	dma_ctrl1 |= CFG_VSYNC_INV_MASK;
+	writel_relaxed(dma_ctrl1, ctrl_regs(path) + dma_ctrl(1, path->id));
+
+	/* Configure default register values */
+	writel_relaxed(0x00000000, &regs->blank_color);
+	writel_relaxed(0x00000000, &regs->g_1);
+	writel_relaxed(0x00000000, &regs->g_start);
+
+	/*
+	 * 1.enable multiple burst request in DMA AXI
+	 * bus arbiter for faster read if not tv path;
+	 * 2.enable horizontal smooth filter;
+	 */
+	mask = CFG_GRA_HSMOOTH_MASK | CFG_DMA_HSMOOTH_MASK | CFG_ARBFAST_ENA(1);
+	tmp = readl_relaxed(ctrl_regs(path) + dma_ctrl(0, path->id));
+	tmp |= mask;
+	if (PATH_TV == path->id)
+		tmp &= ~CFG_ARBFAST_ENA(1);
+	writel_relaxed(tmp, ctrl_regs(path) + dma_ctrl(0, path->id));
+}
+
+static int path_init(struct mmphw_path_plat *path_plat,
+		struct mmp_mach_path_config *config)
+{
+	struct mmphw_ctrl *ctrl = path_plat->ctrl;
+	struct mmp_path_info *path_info;
+	struct mmp_path *path = NULL;
+
+	dev_info(ctrl->dev, "%s: %s\n", __func__, config->name);
+
+	/* init driver data */
+	path_info = kzalloc(sizeof(struct mmp_path_info), GFP_KERNEL);
+	if (!path_info) {
+		dev_err(ctrl->dev, "%s: unable to alloc path_info for %s\n",
+				__func__, config->name);
+		return 0;
+	}
+	path_info->name = config->name;
+	path_info->id = path_plat->id;
+	path_info->dev = ctrl->dev;
+	path_info->overlay_num = config->overlay_num;
+	path_info->overlay_ops = &mmphw_overlay_ops;
+	path_info->set_mode = path_set_mode;
+	path_info->plat_data = path_plat;
+
+	/* create/register platform device */
+	path = mmp_register_path(path_info);
+	if (!path) {
+		kfree(path_info);
+		return 0;
+	}
+	path_plat->path = path;
+	path_plat->path_config = config->path_config;
+	path_plat->link_config = config->link_config;
+	path_plat->dsi_rbswap = config->dsi_rbswap;
+	path_set_default(path);
+
+	kfree(path_info);
+	return 1;
+}
+
+static void path_deinit(struct mmphw_path_plat *path_plat)
+{
+	if (!path_plat)
+		return;
+
+	if (path_plat->path)
+		mmp_unregister_path(path_plat->path);
+}
+
+static int mmphw_probe(struct platform_device *pdev)
+{
+	struct mmp_mach_plat_info *mi;
+	struct resource *res;
+	int ret, i, size, irq;
+	struct mmphw_path_plat *path_plat;
+	struct mmphw_ctrl *ctrl = NULL;
+
+	/* get resources from platform data */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "%s: no IO memory defined\n", __func__);
+		ret = -ENOENT;
+		goto failed;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "%s: no IRQ defined\n", __func__);
+		ret = -ENOENT;
+		goto failed;
+	}
+
+	/* get configs from platform data */
+	mi = pdev->dev.platform_data;
+	if (mi == NULL || !mi->path_num || !mi->paths) {
+		dev_err(&pdev->dev, "%s: no platform data defined\n", __func__);
+		ret = -EINVAL;
+		goto failed;
+	}
+
+	/* allocate */
+	size = sizeof(struct mmphw_ctrl) + sizeof(struct mmphw_path_plat) *
+	       mi->path_num;
+	ctrl = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
+	if (!ctrl) {
+		ret = -ENOMEM;
+		goto failed;
+	}
+
+	ctrl->name = mi->name;
+	ctrl->path_num = mi->path_num;
+	ctrl->dev = &pdev->dev;
+	ctrl->irq = irq;
+	platform_set_drvdata(pdev, ctrl);
+	mutex_init(&ctrl->access_ok);
+
+	/* map registers.*/
+	if (!devm_request_mem_region(ctrl->dev, res->start,
+			resource_size(res), ctrl->name)) {
+		dev_err(ctrl->dev,
+			"can't request region for resource %pR\n", res);
+		ret = -EINVAL;
+		goto failed;
+	}
+
+	ctrl->reg_base = devm_ioremap_nocache(ctrl->dev,
+			res->start, resource_size(res));
+	if (ctrl->reg_base == NULL) {
+		dev_err(ctrl->dev, "%s: res %x - %x map failed\n", __func__,
+			res->start, res->end);
+		ret = -ENOMEM;
+		goto failed;
+	}
+
+	/* request irq */
+	ret = devm_request_irq(ctrl->dev, ctrl->irq, ctrl_handle_irq,
+		IRQF_SHARED, "lcd_controller", ctrl);
+	if (ret < 0) {
+		dev_err(ctrl->dev, "%s unable to request IRQ %d\n",
+				__func__, ctrl->irq);
+		ret = -ENXIO;
+		goto failed;
+	}
+
+	/* get clock */
+	ctrl->clk = devm_clk_get(ctrl->dev, mi->clk_name);
+	if (IS_ERR(ctrl->clk)) {
+		dev_err(ctrl->dev, "unable to get clk %s\n", mi->clk_name);
+		ret = -ENOENT;
+		goto failed;
+	}
+	clk_prepare_enable(ctrl->clk);
+
+	/* init global regs */
+	ctrl_set_default(ctrl);
+
+	/* init pathes from machine info and register them */
+	for (i = 0; i < ctrl->path_num; i++) {
+		/* get from config and machine info */
+		path_plat = &ctrl->path_plats[i];
+		path_plat->id = i;
+		path_plat->ctrl = ctrl;
+
+		/* path init */
+		if (!path_init(path_plat, &mi->paths[i])) {
+			ret = -EINVAL;
+			goto failed_path_init;
+		}
+	}
+
+#ifdef CONFIG_MMP_DISP_SPI
+	ret = lcd_spi_register(ctrl);
+	if (ret < 0)
+		goto failed_path_init;
+#endif
+
+	dev_info(ctrl->dev, "device init done\n");
+
+	return 0;
+
+failed_path_init:
+	for (i = 0; i < ctrl->path_num; i++) {
+		path_plat = &ctrl->path_plats[i];
+		path_deinit(path_plat);
+	}
+
+	clk_disable_unprepare(ctrl->clk);
+failed:
+	dev_err(&pdev->dev, "device init failed\n");
+
+	return ret;
+}
+
+static struct platform_driver mmphw_driver = {
+	.driver		= {
+		.name	= "mmp-disp",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= mmphw_probe,
+};
+
+static int mmphw_init(void)
+{
+	return platform_driver_register(&mmphw_driver);
+}
+module_init(mmphw_init);
+
+MODULE_AUTHOR("Li Guoqing<ligq@marvell.com>");
+MODULE_DESCRIPTION("Framebuffer driver for mmp");
+MODULE_LICENSE("GPL");
