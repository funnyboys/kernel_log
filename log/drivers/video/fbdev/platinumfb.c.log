commit 8a48ac339398f21282985bff16552447d41dcfb2
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Dec 3 18:38:50 2019 +0200

    video: constify fb ops across all drivers
    
    Now that the fbops member of struct fb_info is const, we can start
    making the ops const as well.
    
    This does not cover all drivers; some actually modify the fbops struct,
    for example to adjust for different configurations, and others do more
    involved things that I'd rather not touch in practically obsolete
    drivers. Mostly this is the low hanging fruit where we can add "const"
    and be done with it.
    
    v3:
    - un-constify atyfb, mb862xx, nvidia and uvesabf (0day)
    
    v2:
    - fix typo (Christophe de Dinechin)
    - use "static const" instead of "const static" in mx3fb.c
    - also constify smscufx.c
    
    Cc: linux-fbdev@vger.kernel.org
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/ce67f14435f3af498f2e8bf35ce4be11f7504132.1575390740.git.jani.nikula@intel.com

diff --git a/drivers/video/fbdev/platinumfb.c b/drivers/video/fbdev/platinumfb.c
index 632b246ca35f..ce413a9df06e 100644
--- a/drivers/video/fbdev/platinumfb.c
+++ b/drivers/video/fbdev/platinumfb.c
@@ -96,7 +96,7 @@ static int platinum_var_to_par(struct fb_var_screeninfo *var,
  * Interface used by the world
  */
 
-static struct fb_ops platinumfb_ops = {
+static const struct fb_ops platinumfb_ops = {
 	.owner =	THIS_MODULE,
 	.fb_check_var	= platinumfb_check_var,
 	.fb_set_par	= platinumfb_set_par,

commit 0adcdbcb179624d7b3677264f2cd228e7d89eea9
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Fri Jun 28 12:30:08 2019 +0200

    video: fbdev: don't print error message on framebuffer_alloc() failure
    
    framebuffer_alloc() can fail only on kzalloc() memory allocation
    failure and since kzalloc() will print error message in such case
    we can omit printing extra error message in drivers (which BTW is
    what the majority of framebuffer_alloc() users is doing already).
    
    Cc: "Bruno Pr√©mont" <bonbons@linux-vserver.org>
    Cc: Jiri Kosina <jikos@kernel.org>
    Cc: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/drivers/video/fbdev/platinumfb.c b/drivers/video/fbdev/platinumfb.c
index 76f299375a00..632b246ca35f 100644
--- a/drivers/video/fbdev/platinumfb.c
+++ b/drivers/video/fbdev/platinumfb.c
@@ -538,10 +538,9 @@ static int platinumfb_probe(struct platform_device* odev)
 	dev_info(&odev->dev, "Found Apple Platinum video hardware\n");
 
 	info = framebuffer_alloc(sizeof(*pinfo), &odev->dev);
-	if (info == NULL) {
-		dev_err(&odev->dev, "Failed to allocate fbdev !\n");
+	if (!info)
 		return -ENOMEM;
-	}
+
 	pinfo = info->par;
 
 	if (of_address_to_resource(dp, 0, &pinfo->rsrc_reg) ||

commit 066ac5c3c4bb467d6e8c7255e36c77060efe5ef7
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Jan 15 15:18:56 2019 +1100

    powerpc, fbdev: Use NV_CMODE and NV_VMODE only when CONFIG_PPC32 && CONFIG_PPC_PMAC && CONFIG_NVRAM
    
    This patch addresses inconsistencies in Mac framebuffer drivers and their
    use of Kconfig symbols relating to NVRAM, so PPC64 can use CONFIG_NVRAM.
    
    The defined(CONFIG_NVRAM) condition is replaced with the weaker
    IS_REACHABLE(CONFIG_NVRAM) condition, like atari_scsi.
    
    Macintosh framebuffer drivers use default settings for color mode and
    video mode that are found in NVRAM. On PCI Macs, MacOS stores display
    settings in the Name Registry (NR) partition in NVRAM*. On NuBus Macs,
    there is no NR partition and MacOS stores display mode settings in PRAM**.
    
    Early-model Macs are the ones most likely to benefit from these settings,
    since they are more likely to have a fixed-frequency monitor connected to
    the built-in framebuffer device. Moreover, a single NV_CMODE value and
    a single NV_VMODE value provide for only one display.
    
    The NV_CMODE and NV_VMODE constants are apparently offsets into the NR
    partition for Old World machines. This also suggests that these defaults
    are not useful on later models. The NR partition seems to be optional on
    New World machines. CONFIG_NVRAM cannot be enabled on PPC64 at present.
    
    It is safe to say that NVRAM support in PowerMac fbdev drivers is only
    applicable to CONFIG_PPC32 so make this condition explicit. This means
    matroxfb driver won't crash on PPC64 when CONFIG_NVRAM becomes available
    there.
    
    For imsttfb, add the missing CONFIG_NVRAM test to prevent a build failure,
    since PPC64 does not implement nvram_read_byte(). Also add a missing
    machine_is(powermac) check. Change the inconsistent dependency on
    CONFIG_PPC and the matching #ifdef tests to CONFIG_PPC_PMAC.
    
    For valkyriefb, to improve clarity and consistency with the other PowerMac
    fbdev drivers, test for CONFIG_PPC_PMAC instead of !CONFIG_MAC. Remove a
    bogus comment regarding PRAM.
    
    * See GetPreferredConfiguration and SavePreferredConfiguration in
    "Designing PCI Cards and Drivers for Power Macintosh Computers".
    
    ** See SetDefaultMode and GetDefaultMode in "Designing Cards and Drivers
    for the Macintosh Family".
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/fbdev/platinumfb.c b/drivers/video/fbdev/platinumfb.c
index bf6b7fb83cf4..76f299375a00 100644
--- a/drivers/video/fbdev/platinumfb.c
+++ b/drivers/video/fbdev/platinumfb.c
@@ -345,23 +345,18 @@ static int platinum_init_fb(struct fb_info *info)
 
 	sense = read_platinum_sense(pinfo);
 	printk(KERN_INFO "platinumfb: Monitor sense value = 0x%x, ", sense);
-	if (default_vmode == VMODE_NVRAM) {
-#ifdef CONFIG_NVRAM
+
+	if (IS_REACHABLE(CONFIG_NVRAM) && default_vmode == VMODE_NVRAM)
 		default_vmode = nvram_read_byte(NV_VMODE);
-		if (default_vmode <= 0 || default_vmode > VMODE_MAX ||
-		    !platinum_reg_init[default_vmode-1])
-#endif
-			default_vmode = VMODE_CHOOSE;
-	}
-	if (default_vmode == VMODE_CHOOSE) {
+	if (default_vmode <= 0 || default_vmode > VMODE_MAX ||
+	    !platinum_reg_init[default_vmode - 1]) {
 		default_vmode = mac_map_monitor_sense(sense);
+		if (!platinum_reg_init[default_vmode - 1])
+			default_vmode = VMODE_640_480_60;
 	}
-	if (default_vmode <= 0 || default_vmode > VMODE_MAX)
-		default_vmode = VMODE_640_480_60;
-#ifdef CONFIG_NVRAM
-	if (default_cmode == CMODE_NVRAM)
+
+	if (IS_REACHABLE(CONFIG_NVRAM) && default_cmode == CMODE_NVRAM)
 		default_cmode = nvram_read_byte(NV_CMODE);
-#endif
 	if (default_cmode < CMODE_8 || default_cmode > CMODE_32)
 		default_cmode = CMODE_8;
 	/*

commit e04e39507c3c3da9cba31ee2e52f51b10b6350d0
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Tue Oct 9 13:51:35 2018 +0000

    drivers/video/fbdev: use ioremap_wc/wt() instead of __ioremap()
    
    _PAGE_NO_CACHE is a platform specific flag. In addition, this flag
    is misleading because one would think it requests a noncached page
    whereas a noncached page is _PAGE_NO_CACHE | _PAGE_GUARDED
    
    _PAGE_NO_CACHE alone means write combined noncached page, so lets
    use ioremap_wc() instead.
    
    _PAGE_WRITETHRU is also platform specific flag. Use ioremap_wt()
    instead.
    
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/video/fbdev/platinumfb.c b/drivers/video/fbdev/platinumfb.c
index 377d3399a3ad..bf6b7fb83cf4 100644
--- a/drivers/video/fbdev/platinumfb.c
+++ b/drivers/video/fbdev/platinumfb.c
@@ -32,9 +32,7 @@
 #include <linux/nvram.h>
 #include <linux/of_device.h>
 #include <linux/of_platform.h>
-#include <asm/io.h>
 #include <asm/prom.h>
-#include <asm/pgtable.h>
 
 #include "macmodes.h"
 #include "platinumfb.h"
@@ -577,8 +575,7 @@ static int platinumfb_probe(struct platform_device* odev)
 
 	/* frame buffer - map only 4MB */
 	pinfo->frame_buffer_phys = pinfo->rsrc_fb.start;
-	pinfo->frame_buffer = __ioremap(pinfo->rsrc_fb.start, 0x400000,
-					_PAGE_WRITETHRU);
+	pinfo->frame_buffer = ioremap_wt(pinfo->rsrc_fb.start, 0x400000);
 	pinfo->base_frame_buffer = pinfo->frame_buffer;
 
 	/* registers */

commit f5718726714cd6114876c4e3ca9b6992ab81176c
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Tue Feb 3 16:36:21 2015 +1100

    powerpc: Move Power Macintosh drivers to generic byteswappers
    
    ppc has special instruction forms to efficiently load and store values
    in non-native endianness.  These can be accessed via the arch-specific
    {ld,st}_le{16,32}() inlines in arch/powerpc/include/asm/swab.h.
    
    However, gcc is perfectly capable of generating the byte-reversing
    load/store instructions when using the normal, generic cpu_to_le*() and
    le*_to_cpu() functions eaning the arch-specific functions don't have much
    point.
    
    Worse the "le" in the names of the arch specific functions is now
    misleading, because they always generate byte-reversing forms, but some
    ppc machines can now run a little-endian kernel.
    
    To start getting rid of the arch-specific forms, this patch removes them
    from all the old Power Macintosh drivers, replacing them with the
    generic byteswappers.
    
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/video/fbdev/platinumfb.c b/drivers/video/fbdev/platinumfb.c
index 518d1fd38a81..377d3399a3ad 100644
--- a/drivers/video/fbdev/platinumfb.c
+++ b/drivers/video/fbdev/platinumfb.c
@@ -168,7 +168,7 @@ static int platinumfb_blank(int blank,  struct fb_info *fb)
 	struct fb_info_platinum *info = (struct fb_info_platinum *) fb;
 	int	ctrl;
 
-	ctrl = ld_le32(&info->platinum_regs->ctrl.r) | 0x33;
+	ctrl = le32_to_cpup(&info->platinum_regs->ctrl.r) | 0x33;
 	if (blank)
 		--blank_mode;
 	if (blank & VESA_VSYNC_SUSPEND)

commit 6a732becfd2fe1525718de8eb5c17314265a15f2
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:51 2014 +0200

    video: fbdev: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/video/fbdev/platinumfb.c b/drivers/video/fbdev/platinumfb.c
index 4c9299576827..518d1fd38a81 100644
--- a/drivers/video/fbdev/platinumfb.c
+++ b/drivers/video/fbdev/platinumfb.c
@@ -679,7 +679,6 @@ static struct platform_driver platinum_driver =
 {
 	.driver = {
 		.name = "platinumfb",
-		.owner = THIS_MODULE,
 		.of_match_table = platinumfb_match,
 	},
 	.probe		= platinumfb_probe,

commit f7018c21350204c4cf628462f229d44d03545254
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Feb 13 15:31:38 2014 +0200

    video: move fbdev to drivers/video/fbdev
    
    The drivers/video directory is a mess. It contains generic video related
    files, directories for backlight, console, linux logo, lots of fbdev
    device drivers, fbdev framework files.
    
    Make some order into the chaos by creating drivers/video/fbdev
    directory, and move all fbdev related files there.
    
    No functionality is changed, although I guess it is possible that some
    subtle Makefile build order related issue could be created by this
    patch.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Rob Clark <robdclark@gmail.com>
    Acked-by: Jingoo Han <jg1.han@samsung.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/video/fbdev/platinumfb.c b/drivers/video/fbdev/platinumfb.c
new file mode 100644
index 000000000000..4c9299576827
--- /dev/null
+++ b/drivers/video/fbdev/platinumfb.c
@@ -0,0 +1,714 @@
+/*
+ *  platinumfb.c -- frame buffer device for the PowerMac 'platinum' display
+ *
+ *  Copyright (C) 1998 Franz Sirl
+ *
+ *  Frame buffer structure from:
+ *    drivers/video/controlfb.c -- frame buffer device for
+ *    Apple 'control' display chip.
+ *    Copyright (C) 1998 Dan Jacobowitz
+ *
+ *  Hardware information from:
+ *    platinum.c: Console support for PowerMac "platinum" display adaptor.
+ *    Copyright (C) 1996 Paul Mackerras and Mark Abene
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#undef DEBUG
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/nvram.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <asm/io.h>
+#include <asm/prom.h>
+#include <asm/pgtable.h>
+
+#include "macmodes.h"
+#include "platinumfb.h"
+
+static int default_vmode = VMODE_NVRAM;
+static int default_cmode = CMODE_NVRAM;
+
+struct fb_info_platinum {
+	struct fb_info			*info;
+
+	int				vmode, cmode;
+	int				xres, yres;
+	int				vxres, vyres;
+	int				xoffset, yoffset;
+
+	struct {
+		__u8 red, green, blue;
+	}				palette[256];
+	u32				pseudo_palette[16];
+	
+	volatile struct cmap_regs	__iomem *cmap_regs;
+	unsigned long			cmap_regs_phys;
+	
+	volatile struct platinum_regs	__iomem *platinum_regs;
+	unsigned long			platinum_regs_phys;
+	
+	__u8				__iomem *frame_buffer;
+	volatile __u8			__iomem *base_frame_buffer;
+	unsigned long			frame_buffer_phys;
+	
+	unsigned long			total_vram;
+	int				clktype;
+	int				dactype;
+
+	struct resource			rsrc_fb, rsrc_reg;
+};
+
+/*
+ * Frame buffer device API
+ */
+
+static int platinumfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+	u_int transp, struct fb_info *info);
+static int platinumfb_blank(int blank_mode, struct fb_info *info);
+static int platinumfb_set_par (struct fb_info *info);
+static int platinumfb_check_var (struct fb_var_screeninfo *var, struct fb_info *info);
+
+/*
+ * internal functions
+ */
+
+static inline int platinum_vram_reqd(int video_mode, int color_mode);
+static int read_platinum_sense(struct fb_info_platinum *pinfo);
+static void set_platinum_clock(struct fb_info_platinum *pinfo);
+static void platinum_set_hardware(struct fb_info_platinum *pinfo);
+static int platinum_var_to_par(struct fb_var_screeninfo *var,
+			       struct fb_info_platinum *pinfo,
+			       int check_only);
+
+/*
+ * Interface used by the world
+ */
+
+static struct fb_ops platinumfb_ops = {
+	.owner =	THIS_MODULE,
+	.fb_check_var	= platinumfb_check_var,
+	.fb_set_par	= platinumfb_set_par,
+	.fb_setcolreg	= platinumfb_setcolreg,
+	.fb_blank	= platinumfb_blank,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+};
+
+/*
+ * Checks a var structure
+ */
+static int platinumfb_check_var (struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	return platinum_var_to_par(var, info->par, 1);
+}
+
+/*
+ * Applies current var to display
+ */
+static int platinumfb_set_par (struct fb_info *info)
+{
+	struct fb_info_platinum *pinfo = info->par;
+	struct platinum_regvals *init;
+	int err, offset = 0x20;
+
+	if((err = platinum_var_to_par(&info->var, pinfo, 0))) {
+		printk (KERN_ERR "platinumfb_set_par: error calling"
+				 " platinum_var_to_par: %d.\n", err);
+		return err;
+	}
+
+	platinum_set_hardware(pinfo);
+
+	init = platinum_reg_init[pinfo->vmode-1];
+	
+ 	if ((pinfo->vmode == VMODE_832_624_75) && (pinfo->cmode > CMODE_8))
+  		offset = 0x10;
+
+	info->screen_base = pinfo->frame_buffer + init->fb_offset + offset;
+	mutex_lock(&info->mm_lock);
+	info->fix.smem_start = (pinfo->frame_buffer_phys) + init->fb_offset + offset;
+	mutex_unlock(&info->mm_lock);
+	info->fix.visual = (pinfo->cmode == CMODE_8) ?
+		FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;
+ 	info->fix.line_length = vmode_attrs[pinfo->vmode-1].hres * (1<<pinfo->cmode)
+		+ offset;
+	printk("line_length: %x\n", info->fix.line_length);
+	return 0;
+}
+
+static int platinumfb_blank(int blank,  struct fb_info *fb)
+{
+/*
+ *  Blank the screen if blank_mode != 0, else unblank. If blank == NULL
+ *  then the caller blanks by setting the CLUT (Color Look Up Table) to all
+ *  black. Return 0 if blanking succeeded, != 0 if un-/blanking failed due
+ *  to e.g. a video mode which doesn't support it. Implements VESA suspend
+ *  and powerdown modes on hardware that supports disabling hsync/vsync:
+ *    blank_mode == 2: suspend vsync
+ *    blank_mode == 3: suspend hsync
+ *    blank_mode == 4: powerdown
+ */
+/* [danj] I think there's something fishy about those constants... */
+/*
+	struct fb_info_platinum *info = (struct fb_info_platinum *) fb;
+	int	ctrl;
+
+	ctrl = ld_le32(&info->platinum_regs->ctrl.r) | 0x33;
+	if (blank)
+		--blank_mode;
+	if (blank & VESA_VSYNC_SUSPEND)
+		ctrl &= ~3;
+	if (blank & VESA_HSYNC_SUSPEND)
+		ctrl &= ~0x30;
+	out_le32(&info->platinum_regs->ctrl.r, ctrl);
+*/
+/* TODO: Figure out how the heck to powerdown this thing! */
+	return 0;
+}
+
+static int platinumfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+			      u_int transp, struct fb_info *info)
+{
+	struct fb_info_platinum *pinfo = info->par;
+	volatile struct cmap_regs __iomem *cmap_regs = pinfo->cmap_regs;
+
+	if (regno > 255)
+		return 1;
+
+	red >>= 8;
+	green >>= 8;
+	blue >>= 8;
+
+	pinfo->palette[regno].red = red;
+	pinfo->palette[regno].green = green;
+	pinfo->palette[regno].blue = blue;
+
+	out_8(&cmap_regs->addr, regno);		/* tell clut what addr to fill	*/
+	out_8(&cmap_regs->lut, red);		/* send one color channel at	*/
+	out_8(&cmap_regs->lut, green);		/* a time...			*/
+	out_8(&cmap_regs->lut, blue);
+
+	if (regno < 16) {
+		int i;
+		u32 *pal = info->pseudo_palette;
+		switch (pinfo->cmode) {
+		case CMODE_16:
+			pal[regno] = (regno << 10) | (regno << 5) | regno;
+			break;
+		case CMODE_32:
+			i = (regno << 8) | regno;
+			pal[regno] = (i << 16) | i;
+			break;
+		}
+	}
+	
+	return 0;
+}
+
+static inline int platinum_vram_reqd(int video_mode, int color_mode)
+{
+	int baseval = vmode_attrs[video_mode-1].hres * (1<<color_mode);
+
+	if ((video_mode == VMODE_832_624_75) && (color_mode > CMODE_8))
+		baseval += 0x10;
+	else
+		baseval += 0x20;
+
+	return vmode_attrs[video_mode-1].vres * baseval + 0x1000;
+}
+
+#define STORE_D2(a, d) { \
+	out_8(&cmap_regs->addr, (a+32)); \
+	out_8(&cmap_regs->d2, (d)); \
+}
+
+static void set_platinum_clock(struct fb_info_platinum *pinfo)
+{
+	volatile struct cmap_regs __iomem *cmap_regs = pinfo->cmap_regs;
+	struct platinum_regvals	*init;
+
+	init = platinum_reg_init[pinfo->vmode-1];
+
+	STORE_D2(6, 0xc6);
+	out_8(&cmap_regs->addr,3+32);
+
+	if (in_8(&cmap_regs->d2) == 2) {
+		STORE_D2(7, init->clock_params[pinfo->clktype][0]);
+		STORE_D2(8, init->clock_params[pinfo->clktype][1]);
+		STORE_D2(3, 3);
+	} else {
+		STORE_D2(4, init->clock_params[pinfo->clktype][0]);
+		STORE_D2(5, init->clock_params[pinfo->clktype][1]);
+		STORE_D2(3, 2);
+	}
+
+	__delay(5000);
+	STORE_D2(9, 0xa6);
+}
+
+
+/* Now how about actually saying, Make it so! */
+/* Some things in here probably don't need to be done each time. */
+static void platinum_set_hardware(struct fb_info_platinum *pinfo)
+{
+	volatile struct platinum_regs	__iomem *platinum_regs = pinfo->platinum_regs;
+	volatile struct cmap_regs	__iomem *cmap_regs = pinfo->cmap_regs;
+	struct platinum_regvals		*init;
+	int				i;
+	int				vmode, cmode;
+	
+	vmode = pinfo->vmode;
+	cmode = pinfo->cmode;
+
+	init = platinum_reg_init[vmode - 1];
+
+	/* Initialize display timing registers */
+	out_be32(&platinum_regs->reg[24].r, 7);	/* turn display off */
+
+	for (i = 0; i < 26; ++i)
+		out_be32(&platinum_regs->reg[i+32].r, init->regs[i]);
+
+	out_be32(&platinum_regs->reg[26+32].r, (pinfo->total_vram == 0x100000 ?
+						init->offset[cmode] + 4 - cmode :
+						init->offset[cmode]));
+	out_be32(&platinum_regs->reg[16].r, (unsigned) pinfo->frame_buffer_phys+init->fb_offset+0x10);
+	out_be32(&platinum_regs->reg[18].r, init->pitch[cmode]);
+	out_be32(&platinum_regs->reg[19].r, (pinfo->total_vram == 0x100000 ?
+					     init->mode[cmode+1] :
+					     init->mode[cmode]));
+	out_be32(&platinum_regs->reg[20].r, (pinfo->total_vram == 0x100000 ? 0x11 : 0x1011));
+	out_be32(&platinum_regs->reg[21].r, 0x100);
+	out_be32(&platinum_regs->reg[22].r, 1);
+	out_be32(&platinum_regs->reg[23].r, 1);
+	out_be32(&platinum_regs->reg[26].r, 0xc00);
+	out_be32(&platinum_regs->reg[27].r, 0x235);
+	/* out_be32(&platinum_regs->reg[27].r, 0x2aa); */
+
+	STORE_D2(0, (pinfo->total_vram == 0x100000 ?
+		     init->dacula_ctrl[cmode] & 0xf :
+		     init->dacula_ctrl[cmode]));
+	STORE_D2(1, 4);
+	STORE_D2(2, 0);
+
+	set_platinum_clock(pinfo);
+
+	out_be32(&platinum_regs->reg[24].r, 0);	/* turn display on */
+}
+
+/*
+ * Set misc info vars for this driver
+ */
+static void platinum_init_info(struct fb_info *info,
+			       struct fb_info_platinum *pinfo)
+{
+	/* Fill fb_info */
+	info->fbops = &platinumfb_ops;
+	info->pseudo_palette = pinfo->pseudo_palette;
+        info->flags = FBINFO_DEFAULT;
+	info->screen_base = pinfo->frame_buffer + 0x20;
+
+	fb_alloc_cmap(&info->cmap, 256, 0);
+
+	/* Fill fix common fields */
+	strcpy(info->fix.id, "platinum");
+	info->fix.mmio_start = pinfo->platinum_regs_phys;
+	info->fix.mmio_len = 0x1000;
+	info->fix.type = FB_TYPE_PACKED_PIXELS;
+	info->fix.smem_start = pinfo->frame_buffer_phys + 0x20; /* will be updated later */
+	info->fix.smem_len = pinfo->total_vram - 0x20;
+        info->fix.ywrapstep = 0;
+	info->fix.xpanstep = 0;
+	info->fix.ypanstep = 0;
+        info->fix.type_aux = 0;
+        info->fix.accel = FB_ACCEL_NONE;
+}
+
+
+static int platinum_init_fb(struct fb_info *info)
+{
+	struct fb_info_platinum *pinfo = info->par;
+	struct fb_var_screeninfo var;
+	int sense, rc;
+
+	sense = read_platinum_sense(pinfo);
+	printk(KERN_INFO "platinumfb: Monitor sense value = 0x%x, ", sense);
+	if (default_vmode == VMODE_NVRAM) {
+#ifdef CONFIG_NVRAM
+		default_vmode = nvram_read_byte(NV_VMODE);
+		if (default_vmode <= 0 || default_vmode > VMODE_MAX ||
+		    !platinum_reg_init[default_vmode-1])
+#endif
+			default_vmode = VMODE_CHOOSE;
+	}
+	if (default_vmode == VMODE_CHOOSE) {
+		default_vmode = mac_map_monitor_sense(sense);
+	}
+	if (default_vmode <= 0 || default_vmode > VMODE_MAX)
+		default_vmode = VMODE_640_480_60;
+#ifdef CONFIG_NVRAM
+	if (default_cmode == CMODE_NVRAM)
+		default_cmode = nvram_read_byte(NV_CMODE);
+#endif
+	if (default_cmode < CMODE_8 || default_cmode > CMODE_32)
+		default_cmode = CMODE_8;
+	/*
+	 * Reduce the pixel size if we don't have enough VRAM.
+	 */
+	while(default_cmode > CMODE_8 &&
+	      platinum_vram_reqd(default_vmode, default_cmode) > pinfo->total_vram)
+		default_cmode--;
+
+	printk("platinumfb:  Using video mode %d and color mode %d.\n", default_vmode, default_cmode);
+
+	/* Setup default var */
+	if (mac_vmode_to_var(default_vmode, default_cmode, &var) < 0) {
+		/* This shouldn't happen! */
+		printk("mac_vmode_to_var(%d, %d,) failed\n", default_vmode, default_cmode);
+try_again:
+		default_vmode = VMODE_640_480_60;
+		default_cmode = CMODE_8;
+		if (mac_vmode_to_var(default_vmode, default_cmode, &var) < 0) {
+			printk(KERN_ERR "platinumfb: mac_vmode_to_var() failed\n");
+			return -ENXIO;
+		}
+	}
+
+	/* Initialize info structure */
+	platinum_init_info(info, pinfo);
+
+	/* Apply default var */
+	info->var = var;
+	var.activate = FB_ACTIVATE_NOW;
+	rc = fb_set_var(info, &var);
+	if (rc && (default_vmode != VMODE_640_480_60 || default_cmode != CMODE_8))
+		goto try_again;
+
+	/* Register with fbdev layer */
+	rc = register_framebuffer(info);
+	if (rc < 0)
+		return rc;
+
+	fb_info(info, "Apple Platinum frame buffer device\n");
+
+	return 0;
+}
+
+/*
+ * Get the monitor sense value.
+ * Note that this can be called before calibrate_delay,
+ * so we can't use udelay.
+ */
+static int read_platinum_sense(struct fb_info_platinum *info)
+{
+	volatile struct platinum_regs __iomem *platinum_regs = info->platinum_regs;
+	int sense;
+
+	out_be32(&platinum_regs->reg[23].r, 7);	/* turn off drivers */
+	__delay(2000);
+	sense = (~in_be32(&platinum_regs->reg[23].r) & 7) << 8;
+
+	/* drive each sense line low in turn and collect the other 2 */
+	out_be32(&platinum_regs->reg[23].r, 3);	/* drive A low */
+	__delay(2000);
+	sense |= (~in_be32(&platinum_regs->reg[23].r) & 3) << 4;
+	out_be32(&platinum_regs->reg[23].r, 5);	/* drive B low */
+	__delay(2000);
+	sense |= (~in_be32(&platinum_regs->reg[23].r) & 4) << 1;
+	sense |= (~in_be32(&platinum_regs->reg[23].r) & 1) << 2;
+	out_be32(&platinum_regs->reg[23].r, 6);	/* drive C low */
+	__delay(2000);
+	sense |= (~in_be32(&platinum_regs->reg[23].r) & 6) >> 1;
+
+	out_be32(&platinum_regs->reg[23].r, 7);	/* turn off drivers */
+
+	return sense;
+}
+
+/*
+ * This routine takes a user-supplied var, and picks the best vmode/cmode from it.
+ * It also updates the var structure to the actual mode data obtained
+ */
+static int platinum_var_to_par(struct fb_var_screeninfo *var, 
+			       struct fb_info_platinum *pinfo,
+			       int check_only)
+{
+	int vmode, cmode;
+
+	if (mac_var_to_vmode(var, &vmode, &cmode) != 0) {
+		printk(KERN_ERR "platinum_var_to_par: mac_var_to_vmode unsuccessful.\n");
+		printk(KERN_ERR "platinum_var_to_par: var->xres = %d\n", var->xres);
+		printk(KERN_ERR "platinum_var_to_par: var->yres = %d\n", var->yres);
+		printk(KERN_ERR "platinum_var_to_par: var->xres_virtual = %d\n", var->xres_virtual);
+		printk(KERN_ERR "platinum_var_to_par: var->yres_virtual = %d\n", var->yres_virtual);
+		printk(KERN_ERR "platinum_var_to_par: var->bits_per_pixel = %d\n", var->bits_per_pixel);
+		printk(KERN_ERR "platinum_var_to_par: var->pixclock = %d\n", var->pixclock);
+		printk(KERN_ERR "platinum_var_to_par: var->vmode = %d\n", var->vmode);
+		return -EINVAL;
+	}
+
+	if (!platinum_reg_init[vmode-1]) {
+		printk(KERN_ERR "platinum_var_to_par, vmode %d not valid.\n", vmode);
+		return -EINVAL;
+	}
+
+	if (platinum_vram_reqd(vmode, cmode) > pinfo->total_vram) {
+		printk(KERN_ERR "platinum_var_to_par, not enough ram for vmode %d, cmode %d.\n", vmode, cmode);
+		return -EINVAL;
+	}
+
+	if (mac_vmode_to_var(vmode, cmode, var))
+		return -EINVAL;
+
+	if (check_only)
+		return 0;
+
+	pinfo->vmode = vmode;
+	pinfo->cmode = cmode;
+	pinfo->xres = vmode_attrs[vmode-1].hres;
+	pinfo->yres = vmode_attrs[vmode-1].vres;
+	pinfo->xoffset = 0;
+	pinfo->yoffset = 0;
+	pinfo->vxres = pinfo->xres;
+	pinfo->vyres = pinfo->yres;
+	
+	return 0;
+}
+
+
+/* 
+ * Parse user specified options (`video=platinumfb:')
+ */
+static int __init platinumfb_setup(char *options)
+{
+	char *this_opt;
+
+	if (!options || !*options)
+		return 0;
+
+	while ((this_opt = strsep(&options, ",")) != NULL) {
+		if (!strncmp(this_opt, "vmode:", 6)) {
+	    		int vmode = simple_strtoul(this_opt+6, NULL, 0);
+			if (vmode > 0 && vmode <= VMODE_MAX)
+				default_vmode = vmode;
+		} else if (!strncmp(this_opt, "cmode:", 6)) {
+			int depth = simple_strtoul(this_opt+6, NULL, 0);
+			switch (depth) {
+			 case 0:
+			 case 8:
+			    default_cmode = CMODE_8;
+			    break;
+			 case 15:
+			 case 16:
+			    default_cmode = CMODE_16;
+			    break;
+			 case 24:
+			 case 32:
+			    default_cmode = CMODE_32;
+			    break;
+			}
+		}
+	}
+	return 0;
+}
+
+#ifdef __powerpc__
+#define invalidate_cache(addr) \
+	asm volatile("eieio; dcbf 0,%1" \
+	: "=m" (*(addr)) : "r" (addr) : "memory");
+#else
+#define invalidate_cache(addr)
+#endif
+
+static int platinumfb_probe(struct platform_device* odev)
+{
+	struct device_node	*dp = odev->dev.of_node;
+	struct fb_info		*info;
+	struct fb_info_platinum	*pinfo;
+	volatile __u8		*fbuffer;
+	int			bank0, bank1, bank2, bank3, rc;
+
+	dev_info(&odev->dev, "Found Apple Platinum video hardware\n");
+
+	info = framebuffer_alloc(sizeof(*pinfo), &odev->dev);
+	if (info == NULL) {
+		dev_err(&odev->dev, "Failed to allocate fbdev !\n");
+		return -ENOMEM;
+	}
+	pinfo = info->par;
+
+	if (of_address_to_resource(dp, 0, &pinfo->rsrc_reg) ||
+	    of_address_to_resource(dp, 1, &pinfo->rsrc_fb)) {
+		dev_err(&odev->dev, "Can't get resources\n");
+		framebuffer_release(info);
+		return -ENXIO;
+	}
+	dev_dbg(&odev->dev, " registers  : 0x%llx...0x%llx\n",
+		(unsigned long long)pinfo->rsrc_reg.start,
+		(unsigned long long)pinfo->rsrc_reg.end);
+	dev_dbg(&odev->dev, " framebuffer: 0x%llx...0x%llx\n",
+		(unsigned long long)pinfo->rsrc_fb.start,
+		(unsigned long long)pinfo->rsrc_fb.end);
+
+	/* Do not try to request register space, they overlap with the
+	 * northbridge and that can fail. Only request framebuffer
+	 */
+	if (!request_mem_region(pinfo->rsrc_fb.start,
+				resource_size(&pinfo->rsrc_fb),
+				"platinumfb framebuffer")) {
+		printk(KERN_ERR "platinumfb: Can't request framebuffer !\n");
+		framebuffer_release(info);
+		return -ENXIO;
+	}
+
+	/* frame buffer - map only 4MB */
+	pinfo->frame_buffer_phys = pinfo->rsrc_fb.start;
+	pinfo->frame_buffer = __ioremap(pinfo->rsrc_fb.start, 0x400000,
+					_PAGE_WRITETHRU);
+	pinfo->base_frame_buffer = pinfo->frame_buffer;
+
+	/* registers */
+	pinfo->platinum_regs_phys = pinfo->rsrc_reg.start;
+	pinfo->platinum_regs = ioremap(pinfo->rsrc_reg.start, 0x1000);
+
+	pinfo->cmap_regs_phys = 0xf301b000;	/* XXX not in prom? */
+	request_mem_region(pinfo->cmap_regs_phys, 0x1000, "platinumfb cmap");
+	pinfo->cmap_regs = ioremap(pinfo->cmap_regs_phys, 0x1000);
+
+	/* Grok total video ram */
+	out_be32(&pinfo->platinum_regs->reg[16].r, (unsigned)pinfo->frame_buffer_phys);
+	out_be32(&pinfo->platinum_regs->reg[20].r, 0x1011);	/* select max vram */
+	out_be32(&pinfo->platinum_regs->reg[24].r, 0);	/* switch in vram */
+
+	fbuffer = pinfo->base_frame_buffer;
+	fbuffer[0x100000] = 0x34;
+	fbuffer[0x100008] = 0x0;
+	invalidate_cache(&fbuffer[0x100000]);
+	fbuffer[0x200000] = 0x56;
+	fbuffer[0x200008] = 0x0;
+	invalidate_cache(&fbuffer[0x200000]);
+	fbuffer[0x300000] = 0x78;
+	fbuffer[0x300008] = 0x0;
+	invalidate_cache(&fbuffer[0x300000]);
+	bank0 = 1; /* builtin 1MB vram, always there */
+	bank1 = fbuffer[0x100000] == 0x34;
+	bank2 = fbuffer[0x200000] == 0x56;
+	bank3 = fbuffer[0x300000] == 0x78;
+	pinfo->total_vram = (bank0 + bank1 + bank2 + bank3) * 0x100000;
+	printk(KERN_INFO "platinumfb: Total VRAM = %dMB (%d%d%d%d)\n",
+	       (unsigned int) (pinfo->total_vram / 1024 / 1024),
+	       bank3, bank2, bank1, bank0);
+
+	/*
+	 * Try to determine whether we have an old or a new DACula.
+	 */
+	out_8(&pinfo->cmap_regs->addr, 0x40);
+	pinfo->dactype = in_8(&pinfo->cmap_regs->d2);
+	switch (pinfo->dactype) {
+	case 0x3c:
+		pinfo->clktype = 1;
+		printk(KERN_INFO "platinumfb: DACula type 0x3c\n");
+		break;
+	case 0x84:
+		pinfo->clktype = 0;
+		printk(KERN_INFO "platinumfb: DACula type 0x84\n");
+		break;
+	default:
+		pinfo->clktype = 0;
+		printk(KERN_INFO "platinumfb: Unknown DACula type: %x\n", pinfo->dactype);
+		break;
+	}
+	dev_set_drvdata(&odev->dev, info);
+	
+	rc = platinum_init_fb(info);
+	if (rc != 0) {
+		iounmap(pinfo->frame_buffer);
+		iounmap(pinfo->platinum_regs);
+		iounmap(pinfo->cmap_regs);
+		framebuffer_release(info);
+	}
+
+	return rc;
+}
+
+static int platinumfb_remove(struct platform_device* odev)
+{
+	struct fb_info		*info = dev_get_drvdata(&odev->dev);
+	struct fb_info_platinum	*pinfo = info->par;
+	
+        unregister_framebuffer (info);
+	
+	/* Unmap frame buffer and registers */
+	iounmap(pinfo->frame_buffer);
+	iounmap(pinfo->platinum_regs);
+	iounmap(pinfo->cmap_regs);
+
+	release_mem_region(pinfo->rsrc_fb.start,
+			   resource_size(&pinfo->rsrc_fb));
+
+	release_mem_region(pinfo->cmap_regs_phys, 0x1000);
+
+	framebuffer_release(info);
+
+	return 0;
+}
+
+static struct of_device_id platinumfb_match[] = 
+{
+	{
+	.name 		= "platinum",
+	},
+	{},
+};
+
+static struct platform_driver platinum_driver = 
+{
+	.driver = {
+		.name = "platinumfb",
+		.owner = THIS_MODULE,
+		.of_match_table = platinumfb_match,
+	},
+	.probe		= platinumfb_probe,
+	.remove		= platinumfb_remove,
+};
+
+static int __init platinumfb_init(void)
+{
+#ifndef MODULE
+	char *option = NULL;
+
+	if (fb_get_options("platinumfb", &option))
+		return -ENODEV;
+	platinumfb_setup(option);
+#endif
+	platform_driver_register(&platinum_driver);
+
+	return 0;
+}
+
+static void __exit platinumfb_exit(void)
+{
+	platform_driver_unregister(&platinum_driver);
+}
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("framebuffer driver for Apple Platinum video");
+module_init(platinumfb_init);
+
+#ifdef MODULE
+module_exit(platinumfb_exit);
+#endif
