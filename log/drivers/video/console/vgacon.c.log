commit 513dc792d6060d5ef572e43852683097a8420f56
Author: Zhang Xiaoxu <zhangxiaoxu5@huawei.com>
Date:   Wed Mar 4 10:24:29 2020 +0800

    vgacon: Fix a UAF in vgacon_invert_region
    
    When syzkaller tests, there is a UAF:
      BUG: KASan: use after free in vgacon_invert_region+0x9d/0x110 at addr
        ffff880000100000
      Read of size 2 by task syz-executor.1/16489
      page:ffffea0000004000 count:0 mapcount:-127 mapping:          (null)
      index:0x0
      page flags: 0xfffff00000000()
      page dumped because: kasan: bad access detected
      CPU: 1 PID: 16489 Comm: syz-executor.1 Not tainted
      Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
      rel-1.9.3-0-ge2fc41e-prebuilt.qemu-project.org 04/01/2014
      Call Trace:
        [<ffffffffb119f309>] dump_stack+0x1e/0x20
        [<ffffffffb04af957>] kasan_report+0x577/0x950
        [<ffffffffb04ae652>] __asan_load2+0x62/0x80
        [<ffffffffb090f26d>] vgacon_invert_region+0x9d/0x110
        [<ffffffffb0a39d95>] invert_screen+0xe5/0x470
        [<ffffffffb0a21dcb>] set_selection+0x44b/0x12f0
        [<ffffffffb0a3bfae>] tioclinux+0xee/0x490
        [<ffffffffb0a1d114>] vt_ioctl+0xff4/0x2670
        [<ffffffffb0a0089a>] tty_ioctl+0x46a/0x1a10
        [<ffffffffb052db3d>] do_vfs_ioctl+0x5bd/0xc40
        [<ffffffffb052e2f2>] SyS_ioctl+0x132/0x170
        [<ffffffffb11c9b1b>] system_call_fastpath+0x22/0x27
        Memory state around the buggy address:
         ffff8800000fff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00
         00 00
         ffff8800000fff80: 00 00 00 00 00 00 00 00 00 00 00 00 00
         00 00 00
        >ffff880000100000: ff ff ff ff ff ff ff ff ff ff ff ff ff
         ff ff ff
    
    It can be reproduce in the linux mainline by the program:
      #include <stdio.h>
      #include <stdlib.h>
      #include <unistd.h>
      #include <fcntl.h>
      #include <sys/types.h>
      #include <sys/stat.h>
      #include <sys/ioctl.h>
      #include <linux/vt.h>
    
      struct tiocl_selection {
        unsigned short xs;      /* X start */
        unsigned short ys;      /* Y start */
        unsigned short xe;      /* X end */
        unsigned short ye;      /* Y end */
        unsigned short sel_mode; /* selection mode */
      };
    
      #define TIOCL_SETSEL    2
      struct tiocl {
        unsigned char type;
        unsigned char pad;
        struct tiocl_selection sel;
      };
    
      int main()
      {
        int fd = 0;
        const char *dev = "/dev/char/4:1";
    
        struct vt_consize v = {0};
        struct tiocl tioc = {0};
    
        fd = open(dev, O_RDWR, 0);
    
        v.v_rows = 3346;
        ioctl(fd, VT_RESIZEX, &v);
    
        tioc.type = TIOCL_SETSEL;
        ioctl(fd, TIOCLINUX, &tioc);
    
        return 0;
      }
    
    When resize the screen, update the 'vc->vc_size_row' to the new_row_size,
    but when 'set_origin' in 'vgacon_set_origin', vgacon use 'vga_vram_base'
    for 'vc_origin' and 'vc_visible_origin', not 'vc_screenbuf'. It maybe
    smaller than 'vc_screenbuf'. When TIOCLINUX, use the new_row_size to calc
    the offset, it maybe larger than the vga_vram_size in vgacon driver, then
    bad access.
    Also, if set an larger screenbuf firstly, then set an more larger
    screenbuf, when copy old_origin to new_origin, a bad access may happen.
    
    So, If the screen size larger than vga_vram, resize screen should be
    failed. This alse fix CVE-2020-8649 and CVE-2020-8647.
    
    Linus pointed out that overflow checking seems absent. We're saved by
    the existing bounds checks in vc_do_resize() with rather strict
    limits:
    
            if (cols > VC_RESIZE_MAXCOL || lines > VC_RESIZE_MAXROW)
                    return -EINVAL;
    
    Fixes: 0aec4867dca14 ("[PATCH] SVGATextMode fix")
    Reference: CVE-2020-8647 and CVE-2020-8649
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Zhang Xiaoxu <zhangxiaoxu5@huawei.com>
    [danvet: augment commit message to point out overflow safety]
    Cc: stable@vger.kernel.org
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200304022429.37738-1-zhangxiaoxu5@huawei.com

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index de7b8382aba9..998b0de1812f 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -1316,6 +1316,9 @@ static int vgacon_font_get(struct vc_data *c, struct console_font *font)
 static int vgacon_resize(struct vc_data *c, unsigned int width,
 			 unsigned int height, unsigned int user)
 {
+	if ((width << 1) * height > vga_vram_size)
+		return -EINVAL;
+
 	if (width % 2 || width > screen_info.orig_video_cols ||
 	    height > (screen_info.orig_video_lines * vga_default_font_height)/
 	    c->vc_font.height)

commit 3e3d38bd0da72cf93d533ca587886e075e414238
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Fri Oct 18 11:18:41 2019 +0800

    vgacon: Use pr_warn instead of pr_warning
    
    As said in commit f2c2cbcc35d4 ("powerpc: Use pr_warn instead of
    pr_warning"), removing pr_warning so all logging messages use a
    consistent <prefix>_warn style. Let's do it.
    
    Link: http://lkml.kernel.org/r/20191018031850.48498-24-wangkefeng.wang@huawei.com
    To: linux-kernel@vger.kernel.org
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Cc: linux-fbdev@vger.kernel.org
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index c6b3bdbbdbc9..de7b8382aba9 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -113,9 +113,9 @@ static int __init text_mode(char *str)
 {
 	vgacon_text_mode_force = true;
 
-	pr_warning("You have booted with nomodeset. This means your GPU drivers are DISABLED\n");
-	pr_warning("Any video related functionality will be severely degraded, and you may not even be able to suspend the system properly\n");
-	pr_warning("Unless you actually understand what nomodeset does, you should reboot without enabling it\n");
+	pr_warn("You have booted with nomodeset. This means your GPU drivers are DISABLED\n");
+	pr_warn("Any video related functionality will be severely degraded, and you may not even be able to suspend the system properly\n");
+	pr_warn("Unless you actually understand what nomodeset does, you should reboot without enabling it\n");
 
 	return 1;
 }

commit bfd8d8fe98b8792f362cd210a7873969f8d2fc04
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Thu Jan 10 16:33:55 2019 -0500

    vgacon: unconfuse vc_origin when using soft scrollback
    
    When CONFIG_VGACON_SOFT_SCROLLBACK is selected, the VGA display memory
    index and vc_visible_origin don't change when scrollback is activated.
    The actual screen content is saved away and the scrollbackdata is copied
    over it. However the vt code, and /dev/vcs devices in particular, still
    expect vc_origin to always point at the actual screen content not the
    displayed scrollback content.
    
    So adjust vc_origin to point at the saved screen content when scrollback
    is active and set it back to vc_visible_origin when restoring the screen.
    
    This fixes /dev/vcsa<n> that return scrollback content when they
    shouldn't (onli /dev/vcsa without a number should), and also fixes
    /dev/vcsu that should return scrollback content when scrollback is
    active but currently doesn't.
    
    An unnecessary call to vga_set_mem_top() is also removed.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Cc: stable@vger.kernel.org # v4.19+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 09731b2f6815..c6b3bdbbdbc9 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -271,6 +271,7 @@ static void vgacon_scrollback_update(struct vc_data *c, int t, int count)
 
 static void vgacon_restore_screen(struct vc_data *c)
 {
+	c->vc_origin = c->vc_visible_origin;
 	vgacon_scrollback_cur->save = 0;
 
 	if (!vga_is_gfx && !vgacon_scrollback_cur->restore) {
@@ -287,8 +288,7 @@ static void vgacon_scrolldelta(struct vc_data *c, int lines)
 	int start, end, count, soff;
 
 	if (!lines) {
-		c->vc_visible_origin = c->vc_origin;
-		vga_set_mem_top(c);
+		vgacon_restore_screen(c);
 		return;
 	}
 
@@ -298,6 +298,7 @@ static void vgacon_scrolldelta(struct vc_data *c, int lines)
 	if (!vgacon_scrollback_cur->save) {
 		vgacon_cursor(c, CM_ERASE);
 		vgacon_save_screen(c);
+		c->vc_origin = (unsigned long)c->vc_screenbuf;
 		vgacon_scrollback_cur->save = 1;
 	}
 
@@ -335,7 +336,7 @@ static void vgacon_scrolldelta(struct vc_data *c, int lines)
 		int copysize;
 
 		int diff = c->vc_rows - count;
-		void *d = (void *) c->vc_origin;
+		void *d = (void *) c->vc_visible_origin;
 		void *s = (void *) c->vc_screenbuf;
 
 		count *= c->vc_size_row;

commit ff459c2dc0b51e5041af65dae44e44233ff26b48
Author: Lyude Paul <lyude@redhat.com>
Date:   Tue Jul 24 19:11:26 2018 +0200

    video/console/vgacon: Print big fat warning with nomodeset
    
    It's been a pretty good while since kernel modesetting was introduced.
    It has almost entirely replaced previous solutions which required
    userspace modesetting, and I can't even recall any drivers off the top
    of my head for modern day hardware that don't only support one or the
    other. Even nvidia's ugly blob does not require the use of nomodeset,
    and only requires that nouveau be blacklisted.
    
    Effectively, the only thing nomodeset does in the year 2018 is disable
    your graphics drivers. Since VESA is a thing, this will give many users
    the false impression that they've actually fixed an issue they were
    having with their machine simply because the laptop will boot up to a
    degraded GUI. This of course, is never actually the case.
    
    Things get even worse when you consider that there's still an enormous
    amount of tutorials users find on the internet that still suggest adding
    nomodeset, along with various users who have been around long enough to
    still suggest it.
    
    There really isn't any legitimate reason I can see for this to be an
    option that's used by anyone else other then developers, or properly
    informed users. So, let's end the confusion and start printing warnings
    whenever it's enabled.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: "Jan H. Schönherr" <jschoenh@amazon.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index f09e17b60e45..09731b2f6815 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -112,6 +112,11 @@ EXPORT_SYMBOL(vgacon_text_force);
 static int __init text_mode(char *str)
 {
 	vgacon_text_mode_force = true;
+
+	pr_warning("You have booted with nomodeset. This means your GPU drivers are DISABLED\n");
+	pr_warning("Any video related functionality will be severely degraded, and you may not even be able to suspend the system properly\n");
+	pr_warning("Unless you actually understand what nomodeset does, you should reboot without enabling it\n");
+
 	return 1;
 }
 

commit c396a5bf457fb60159dcedbd4f48d53a62be030a
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Feb 26 16:04:20 2018 -0800

    console: Expand dummy functions for CFI
    
    This expands the no-op dummy functions into full prototypes to avoid
    indirect call mismatches when running under Control Flow Integrity
    checking, like with Clang's -fsanitize=cfi.
    
    Co-Developed-by: Sami Tolvanen <samitolvanen@google.com>
    Signed-off-by: Sami Tolvanen <samitolvanen@google.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index a17ba1465815..f09e17b60e45 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -1272,7 +1272,8 @@ static int vgacon_adjust_height(struct vc_data *vc, unsigned fontheight)
 	return 0;
 }
 
-static int vgacon_font_set(struct vc_data *c, struct console_font *font, unsigned flags)
+static int vgacon_font_set(struct vc_data *c, struct console_font *font,
+			   unsigned int flags)
 {
 	unsigned charcount = font->charcount;
 	int rc;
@@ -1407,21 +1408,20 @@ static bool vgacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,
  *  The console `switch' structure for the VGA based console
  */
 
-static int vgacon_dummy(struct vc_data *c)
-{
-	return 0;
-}
-
-#define DUMMY (void *) vgacon_dummy
+static void vgacon_clear(struct vc_data *vc, int sy, int sx, int height,
+			 int width) { }
+static void vgacon_putc(struct vc_data *vc, int c, int ypos, int xpos) { }
+static void vgacon_putcs(struct vc_data *vc, const unsigned short *s,
+			 int count, int ypos, int xpos) { }
 
 const struct consw vga_con = {
 	.owner = THIS_MODULE,
 	.con_startup = vgacon_startup,
 	.con_init = vgacon_init,
 	.con_deinit = vgacon_deinit,
-	.con_clear = DUMMY,
-	.con_putc = DUMMY,
-	.con_putcs = DUMMY,
+	.con_clear = vgacon_clear,
+	.con_putc = vgacon_putc,
+	.con_putcs = vgacon_putcs,
 	.con_cursor = vgacon_cursor,
 	.con_scroll = vgacon_scroll,
 	.con_switch = vgacon_switch,

commit c82084117f79bcae085e40da526253736a247120
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Dec 1 11:06:39 2017 -0600

    vgacon: Set VGA struct resource types
    
    Set the resource type when we reserve VGA-related I/O port resources.
    
    The resource code doesn't actually look at the type, so it inserts
    resources without a type in the tree correctly even without this change.
    But if we ever print a resource without a type, it looks like this:
    
      vga+ [??? 0x000003c0-0x000003df flags 0x0]
    
    Setting the type means it will be printed correctly as:
    
      vga+ [io  0x000003c0-0x000003df]
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 445b1dc5d441..a17ba1465815 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -422,7 +422,10 @@ static const char *vgacon_startup(void)
 		vga_video_port_val = VGA_CRT_DM;
 		if ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {
 			static struct resource ega_console_resource =
-			    { .name = "ega", .start = 0x3B0, .end = 0x3BF };
+			    { .name	= "ega",
+			      .flags	= IORESOURCE_IO,
+			      .start	= 0x3B0,
+			      .end	= 0x3BF };
 			vga_video_type = VIDEO_TYPE_EGAM;
 			vga_vram_size = 0x8000;
 			display_desc = "EGA+";
@@ -430,9 +433,15 @@ static const char *vgacon_startup(void)
 					 &ega_console_resource);
 		} else {
 			static struct resource mda1_console_resource =
-			    { .name = "mda", .start = 0x3B0, .end = 0x3BB };
+			    { .name	= "mda",
+			      .flags	= IORESOURCE_IO,
+			      .start	= 0x3B0,
+			      .end	= 0x3BB };
 			static struct resource mda2_console_resource =
-			    { .name = "mda", .start = 0x3BF, .end = 0x3BF };
+			    { .name	= "mda",
+			      .flags	= IORESOURCE_IO,
+			      .start	= 0x3BF,
+			      .end	= 0x3BF };
 			vga_video_type = VIDEO_TYPE_MDA;
 			vga_vram_size = 0x2000;
 			display_desc = "*MDA";
@@ -454,15 +463,21 @@ static const char *vgacon_startup(void)
 			vga_vram_size = 0x8000;
 
 			if (!screen_info.orig_video_isVGA) {
-				static struct resource ega_console_resource
-				    = { .name = "ega", .start = 0x3C0, .end = 0x3DF };
+				static struct resource ega_console_resource =
+				    { .name	= "ega",
+				      .flags	= IORESOURCE_IO,
+				      .start	= 0x3C0,
+				      .end	= 0x3DF };
 				vga_video_type = VIDEO_TYPE_EGAC;
 				display_desc = "EGA";
 				request_resource(&ioport_resource,
 						 &ega_console_resource);
 			} else {
-				static struct resource vga_console_resource
-				    = { .name = "vga+", .start = 0x3C0, .end = 0x3DF };
+				static struct resource vga_console_resource =
+				    { .name	= "vga+",
+				      .flags	= IORESOURCE_IO,
+				      .start	= 0x3C0,
+				      .end	= 0x3DF };
 				vga_video_type = VIDEO_TYPE_VGAC;
 				display_desc = "VGA+";
 				request_resource(&ioport_resource,
@@ -494,7 +509,10 @@ static const char *vgacon_startup(void)
 			}
 		} else {
 			static struct resource cga_console_resource =
-			    { .name = "cga", .start = 0x3D4, .end = 0x3D5 };
+			    { .name	= "cga",
+			      .flags	= IORESOURCE_IO,
+			      .start	= 0x3D4,
+			      .end	= 0x3D5 };
 			vga_video_type = VIDEO_TYPE_CGA;
 			vga_vram_size = 0x2000;
 			display_desc = "*CGA";

commit b9a58de545858ac9ee67745cdea6d94cc322938e
Author: Jan H. Schönherr <jschoenh@amazon.de>
Date:   Mon Sep 4 16:00:50 2017 +0200

    vgacon: Prevent faulty bootparams.screeninfo from causing harm
    
    If a zero for the number of colums or rows manages to slip through,
    gotoxy() will underflow vc->vc_pos, causing the next action on the
    referenced memory to end with a page fault.
    
    Make the check in vgacon_startup() more pessimistic to prevent that.
    
    Signed-off-by: Jan H. Schönherr <jschoenh@amazon.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index dc06cb6a15dc..445b1dc5d441 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -398,9 +398,8 @@ static const char *vgacon_startup(void)
 #endif
 	}
 
-	/* boot_params.screen_info initialized? */
-	if ((screen_info.orig_video_mode  == 0) &&
-	    (screen_info.orig_video_lines == 0) &&
+	/* boot_params.screen_info reasonably initialized? */
+	if ((screen_info.orig_video_lines == 0) ||
 	    (screen_info.orig_video_cols  == 0))
 		goto no_vga;
 

commit 1a336c934623b011c289a298aff3b7fdefb3f876
Author: Manuel Schölling <manuel.schoelling@gmx.de>
Date:   Fri Jan 13 21:07:58 2017 +0100

    console: Make persistent scrollback a boot parameter
    
    The impact of the persistent scrollback feature on the code size is
    rather small, so the config option is removed. The feature stays
    disabled by default and can be enabled by using the boot command line
    parameter 'vgacon.scrollback_persistent=1' or by setting
    VGACON_SOFT_SCROLLBACK_PERSISTENT_ENABLE_BY_DEFAULT=y.
    
    Signed-off-by: Manuel Schölling <manuel.schoelling@gmx.de>
    Suggested-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index ca23d222e029..dc06cb6a15dc 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -174,11 +174,11 @@ struct vgacon_scrollback_info {
 };
 
 static struct vgacon_scrollback_info *vgacon_scrollback_cur;
-#ifdef CONFIG_VGACON_SOFT_SCROLLBACK_PERSISTENT
 static struct vgacon_scrollback_info vgacon_scrollbacks[MAX_NR_CONSOLES];
-#else
-static struct vgacon_scrollback_info vgacon_scrollbacks[1];
-#endif
+static bool scrollback_persistent = \
+	IS_ENABLED(CONFIG_VGACON_SOFT_SCROLLBACK_PERSISTENT_ENABLE_BY_DEFAULT);
+module_param_named(scrollback_persistent, scrollback_persistent, bool, 0000);
+MODULE_PARM_DESC(scrollback_persistent, "Enable persistent scrollback for all vga consoles");
 
 static void vgacon_scrollback_reset(int vc_num, size_t reset_size)
 {
@@ -213,20 +213,19 @@ static void vgacon_scrollback_init(int vc_num)
 
 static void vgacon_scrollback_switch(int vc_num)
 {
-#ifndef CONFIG_VGACON_SOFT_SCROLLBACK_PERSISTENT
-	vc_num = 0;
-#endif
+	if (!scrollback_persistent)
+		vc_num = 0;
 
 	if (!vgacon_scrollbacks[vc_num].data) {
 		vgacon_scrollback_init(vc_num);
 	} else {
-#ifdef CONFIG_VGACON_SOFT_SCROLLBACK_PERSISTENT
-		vgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];
-#else
-		size_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;
+		if (scrollback_persistent) {
+			vgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];
+		} else {
+			size_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;
 
-		vgacon_scrollback_reset(vc_num, size);
-#endif
+			vgacon_scrollback_reset(vc_num, size);
+		}
 	}
 }
 

commit aabd31c421ddc730edf6d89c4ed3885e4fca5e30
Author: Manuel Schölling <manuel.schoelling@gmx.de>
Date:   Fri Jan 13 21:07:57 2017 +0100

    console: Add persistent scrollback buffers for all VGA consoles
    
    Add a scrollback buffers for each VGA console. The benefit is that
    the scrollback history is not flushed when switching between consoles
    but is persistent.
    The buffers are allocated on demand when a new console is opened.
    
    This breaks tools like clear_console that rely on flushing the
    scrollback history by switching back and forth between consoles
    which is why this feature is disabled by default.
    Use the escape sequence \e[3J instead for flushing the buffer.
    
    Signed-off-by: Manuel Schölling <manuel.schoelling@gmx.de>
    Reviewed-by: Andrey Utkin <andrey_utkin@fastmail.com>
    Tested-by: Andrey Utkin <andrey_utkin@fastmail.com>
    Tested-by: Adam Borowski <kilobyte@angband.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 9a7c2bbc5326..ca23d222e029 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -162,7 +162,7 @@ static inline void vga_set_mem_top(struct vc_data *c)
 
 #ifdef CONFIG_VGACON_SOFT_SCROLLBACK
 /* software scrollback */
-static struct vgacon_scrollback_info {
+struct vgacon_scrollback_info {
 	void *data;
 	int tail;
 	int size;
@@ -171,74 +171,110 @@ static struct vgacon_scrollback_info {
 	int cur;
 	int save;
 	int restore;
-} vgacon_scrollback;
+};
+
+static struct vgacon_scrollback_info *vgacon_scrollback_cur;
+#ifdef CONFIG_VGACON_SOFT_SCROLLBACK_PERSISTENT
+static struct vgacon_scrollback_info vgacon_scrollbacks[MAX_NR_CONSOLES];
+#else
+static struct vgacon_scrollback_info vgacon_scrollbacks[1];
+#endif
 
-static void vgacon_scrollback_reset(size_t reset_size)
+static void vgacon_scrollback_reset(int vc_num, size_t reset_size)
 {
-	if (vgacon_scrollback.data && reset_size > 0)
-		memset(vgacon_scrollback.data, 0, reset_size);
+	struct vgacon_scrollback_info *scrollback = &vgacon_scrollbacks[vc_num];
+
+	if (scrollback->data && reset_size > 0)
+		memset(scrollback->data, 0, reset_size);
 
-	vgacon_scrollback.cnt  = 0;
-	vgacon_scrollback.tail = 0;
-	vgacon_scrollback.cur  = 0;
+	scrollback->cnt  = 0;
+	scrollback->tail = 0;
+	scrollback->cur  = 0;
 }
 
-static void vgacon_scrollback_init(int pitch)
+static void vgacon_scrollback_init(int vc_num)
 {
-	int rows = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024/pitch;
-
-	if (vgacon_scrollback.data) {
-		vgacon_scrollback.cnt  = 0;
-		vgacon_scrollback.tail = 0;
-		vgacon_scrollback.cur  = 0;
-		vgacon_scrollback.rows = rows - 1;
-		vgacon_scrollback.size = rows * pitch;
+	int pitch = vga_video_num_columns * 2;
+	size_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;
+	int rows = size / pitch;
+	void *data;
+
+	data = kmalloc_array(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE, 1024,
+			     GFP_NOWAIT);
+
+	vgacon_scrollbacks[vc_num].data = data;
+	vgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];
+
+	vgacon_scrollback_cur->rows = rows - 1;
+	vgacon_scrollback_cur->size = rows * pitch;
+
+	vgacon_scrollback_reset(vc_num, size);
+}
+
+static void vgacon_scrollback_switch(int vc_num)
+{
+#ifndef CONFIG_VGACON_SOFT_SCROLLBACK_PERSISTENT
+	vc_num = 0;
+#endif
+
+	if (!vgacon_scrollbacks[vc_num].data) {
+		vgacon_scrollback_init(vc_num);
+	} else {
+#ifdef CONFIG_VGACON_SOFT_SCROLLBACK_PERSISTENT
+		vgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];
+#else
+		size_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;
+
+		vgacon_scrollback_reset(vc_num, size);
+#endif
 	}
 }
 
 static void vgacon_scrollback_startup(void)
 {
-	vgacon_scrollback.data = kcalloc(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE,
-		1024, GFP_NOWAIT);
-	vgacon_scrollback_init(vga_video_num_columns * 2);
+	vgacon_scrollback_cur = &vgacon_scrollbacks[0];
+	vgacon_scrollback_init(0);
 }
 
 static void vgacon_scrollback_update(struct vc_data *c, int t, int count)
 {
 	void *p;
 
-	if (!vgacon_scrollback.size || c->vc_num != fg_console)
+	if (!vgacon_scrollback_cur->data || !vgacon_scrollback_cur->size ||
+	    c->vc_num != fg_console)
 		return;
 
 	p = (void *) (c->vc_origin + t * c->vc_size_row);
 
 	while (count--) {
-		scr_memcpyw(vgacon_scrollback.data + vgacon_scrollback.tail,
+		scr_memcpyw(vgacon_scrollback_cur->data +
+			    vgacon_scrollback_cur->tail,
 			    p, c->vc_size_row);
-		vgacon_scrollback.cnt++;
+
+		vgacon_scrollback_cur->cnt++;
 		p += c->vc_size_row;
-		vgacon_scrollback.tail += c->vc_size_row;
+		vgacon_scrollback_cur->tail += c->vc_size_row;
 
-		if (vgacon_scrollback.tail >= vgacon_scrollback.size)
-			vgacon_scrollback.tail = 0;
+		if (vgacon_scrollback_cur->tail >= vgacon_scrollback_cur->size)
+			vgacon_scrollback_cur->tail = 0;
 
-		if (vgacon_scrollback.cnt > vgacon_scrollback.rows)
-			vgacon_scrollback.cnt = vgacon_scrollback.rows;
+		if (vgacon_scrollback_cur->cnt > vgacon_scrollback_cur->rows)
+			vgacon_scrollback_cur->cnt = vgacon_scrollback_cur->rows;
 
-		vgacon_scrollback.cur = vgacon_scrollback.cnt;
+		vgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;
 	}
 }
 
 static void vgacon_restore_screen(struct vc_data *c)
 {
-	vgacon_scrollback.save = 0;
+	vgacon_scrollback_cur->save = 0;
 
-	if (!vga_is_gfx && !vgacon_scrollback.restore) {
+	if (!vga_is_gfx && !vgacon_scrollback_cur->restore) {
 		scr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,
 			    c->vc_screenbuf_size > vga_vram_size ?
 			    vga_vram_size : c->vc_screenbuf_size);
-		vgacon_scrollback.restore = 1;
-		vgacon_scrollback.cur = vgacon_scrollback.cnt;
+		vgacon_scrollback_cur->restore = 1;
+		vgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;
 	}
 }
 
@@ -252,41 +288,41 @@ static void vgacon_scrolldelta(struct vc_data *c, int lines)
 		return;
 	}
 
-	if (!vgacon_scrollback.data)
+	if (!vgacon_scrollback_cur->data)
 		return;
 
-	if (!vgacon_scrollback.save) {
+	if (!vgacon_scrollback_cur->save) {
 		vgacon_cursor(c, CM_ERASE);
 		vgacon_save_screen(c);
-		vgacon_scrollback.save = 1;
+		vgacon_scrollback_cur->save = 1;
 	}
 
-	vgacon_scrollback.restore = 0;
-	start = vgacon_scrollback.cur + lines;
+	vgacon_scrollback_cur->restore = 0;
+	start = vgacon_scrollback_cur->cur + lines;
 	end = start + abs(lines);
 
 	if (start < 0)
 		start = 0;
 
-	if (start > vgacon_scrollback.cnt)
-		start = vgacon_scrollback.cnt;
+	if (start > vgacon_scrollback_cur->cnt)
+		start = vgacon_scrollback_cur->cnt;
 
 	if (end < 0)
 		end = 0;
 
-	if (end > vgacon_scrollback.cnt)
-		end = vgacon_scrollback.cnt;
+	if (end > vgacon_scrollback_cur->cnt)
+		end = vgacon_scrollback_cur->cnt;
 
-	vgacon_scrollback.cur = start;
+	vgacon_scrollback_cur->cur = start;
 	count = end - start;
-	soff = vgacon_scrollback.tail - ((vgacon_scrollback.cnt - end) *
-					 c->vc_size_row);
+	soff = vgacon_scrollback_cur->tail -
+		((vgacon_scrollback_cur->cnt - end) * c->vc_size_row);
 	soff -= count * c->vc_size_row;
 
 	if (soff < 0)
-		soff += vgacon_scrollback.size;
+		soff += vgacon_scrollback_cur->size;
 
-	count = vgacon_scrollback.cnt - start;
+	count = vgacon_scrollback_cur->cnt - start;
 
 	if (count > c->vc_rows)
 		count = c->vc_rows;
@@ -300,13 +336,13 @@ static void vgacon_scrolldelta(struct vc_data *c, int lines)
 
 		count *= c->vc_size_row;
 		/* how much memory to end of buffer left? */
-		copysize = min(count, vgacon_scrollback.size - soff);
-		scr_memcpyw(d, vgacon_scrollback.data + soff, copysize);
+		copysize = min(count, vgacon_scrollback_cur->size - soff);
+		scr_memcpyw(d, vgacon_scrollback_cur->data + soff, copysize);
 		d += copysize;
 		count -= copysize;
 
 		if (count) {
-			scr_memcpyw(d, vgacon_scrollback.data, count);
+			scr_memcpyw(d, vgacon_scrollback_cur->data, count);
 			d += count;
 		}
 
@@ -320,13 +356,13 @@ static void vgacon_flush_scrollback(struct vc_data *c)
 {
 	size_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;
 
-	if (c->vc_num == fg_console)
-		vgacon_scrollback_reset(size);
+	vgacon_scrollback_reset(c->vc_num, size);
 }
 #else
 #define vgacon_scrollback_startup(...) do { } while (0)
 #define vgacon_scrollback_init(...)    do { } while (0)
 #define vgacon_scrollback_update(...)  do { } while (0)
+#define vgacon_scrollback_switch(...)  do { } while (0)
 
 static void vgacon_restore_screen(struct vc_data *c)
 {
@@ -805,7 +841,7 @@ static int vgacon_switch(struct vc_data *c)
 			vgacon_doresize(c, c->vc_cols, c->vc_rows);
 	}
 
-	vgacon_scrollback_init(c->vc_size_row);
+	vgacon_scrollback_switch(c->vc_num);
 	return 0;		/* Redrawing not needed */
 }
 

commit bcd375f7f71f7106c97516bf5395149954ef8810
Author: Manuel Schölling <manuel.schoelling@gmx.de>
Date:   Fri Jan 13 21:07:56 2017 +0100

    console: Add callback to flush scrollback buffer to consw struct
    
    This new callback is in preparation for persistent scrollback buffer
    support for VGA consoles.
    With a single scrollback buffer for all consoles, we could flush the
    buffer just by invocating consw->con_switch(). But when each VGA console
    has its own scrollback buffer, we need a new callback to tell the
    video console driver which buffer to flush.
    
    Signed-off-by: Manuel Schölling <manuel.schoelling@gmx.de>
    Reviewed-by: Andrey Utkin <andrey_utkin@fastmail.com>
    Tested-by: Andrey Utkin <andrey_utkin@fastmail.com>
    Tested-by: Adam Borowski <kilobyte@angband.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 48b97648d4af..9a7c2bbc5326 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -173,6 +173,16 @@ static struct vgacon_scrollback_info {
 	int restore;
 } vgacon_scrollback;
 
+static void vgacon_scrollback_reset(size_t reset_size)
+{
+	if (vgacon_scrollback.data && reset_size > 0)
+		memset(vgacon_scrollback.data, 0, reset_size);
+
+	vgacon_scrollback.cnt  = 0;
+	vgacon_scrollback.tail = 0;
+	vgacon_scrollback.cur  = 0;
+}
+
 static void vgacon_scrollback_init(int pitch)
 {
 	int rows = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024/pitch;
@@ -305,6 +315,14 @@ static void vgacon_scrolldelta(struct vc_data *c, int lines)
 	} else
 		vgacon_cursor(c, CM_MOVE);
 }
+
+static void vgacon_flush_scrollback(struct vc_data *c)
+{
+	size_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;
+
+	if (c->vc_num == fg_console)
+		vgacon_scrollback_reset(size);
+}
 #else
 #define vgacon_scrollback_startup(...) do { } while (0)
 #define vgacon_scrollback_init(...)    do { } while (0)
@@ -322,6 +340,10 @@ static void vgacon_scrolldelta(struct vc_data *c, int lines)
 			vga_vram_size);
 	vga_set_mem_top(c);
 }
+
+static void vgacon_flush_scrollback(struct vc_data *c)
+{
+}
 #endif /* CONFIG_VGACON_SOFT_SCROLLBACK */
 
 static const char *vgacon_startup(void)
@@ -1329,7 +1351,6 @@ static bool vgacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,
 	return true;
 }
 
-
 /*
  *  The console `switch' structure for the VGA based console
  */
@@ -1362,6 +1383,7 @@ const struct consw vga_con = {
 	.con_save_screen = vgacon_save_screen,
 	.con_build_attr = vgacon_build_attr,
 	.con_invert_region = vgacon_invert_region,
+	.con_flush_scrollback = vgacon_flush_scrollback,
 };
 EXPORT_SYMBOL(vga_con);
 

commit 66da39eb91b42ab70dd49ef0b9ac5f4cfa76c9c3
Author: Manuel Schölling <manuel.schoelling@gmx.de>
Date:   Fri Jan 13 21:07:55 2017 +0100

    console: Move scrollback data into its own struct
    
    This refactoring is in preparation for persistent scrollback
    support for VGA console.
    
    Signed-off-by: Manuel Schölling <manuel.schoelling@gmx.de>
    Reviewed-by: Andrey Utkin <andrey_utkin@fastmail.com>
    Tested-by: Andrey Utkin <andrey_utkin@fastmail.com>
    Tested-by: Adam Borowski <kilobyte@angband.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index c22a56232b7c..48b97648d4af 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -162,31 +162,34 @@ static inline void vga_set_mem_top(struct vc_data *c)
 
 #ifdef CONFIG_VGACON_SOFT_SCROLLBACK
 /* software scrollback */
-static void *vgacon_scrollback;
-static int vgacon_scrollback_tail;
-static int vgacon_scrollback_size;
-static int vgacon_scrollback_rows;
-static int vgacon_scrollback_cnt;
-static int vgacon_scrollback_cur;
-static int vgacon_scrollback_save;
-static int vgacon_scrollback_restore;
+static struct vgacon_scrollback_info {
+	void *data;
+	int tail;
+	int size;
+	int rows;
+	int cnt;
+	int cur;
+	int save;
+	int restore;
+} vgacon_scrollback;
 
 static void vgacon_scrollback_init(int pitch)
 {
 	int rows = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024/pitch;
 
-	if (vgacon_scrollback) {
-		vgacon_scrollback_cnt  = 0;
-		vgacon_scrollback_tail = 0;
-		vgacon_scrollback_cur  = 0;
-		vgacon_scrollback_rows = rows - 1;
-		vgacon_scrollback_size = rows * pitch;
+	if (vgacon_scrollback.data) {
+		vgacon_scrollback.cnt  = 0;
+		vgacon_scrollback.tail = 0;
+		vgacon_scrollback.cur  = 0;
+		vgacon_scrollback.rows = rows - 1;
+		vgacon_scrollback.size = rows * pitch;
 	}
 }
 
 static void vgacon_scrollback_startup(void)
 {
-	vgacon_scrollback = kcalloc(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE, 1024, GFP_NOWAIT);
+	vgacon_scrollback.data = kcalloc(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE,
+		1024, GFP_NOWAIT);
 	vgacon_scrollback_init(vga_video_num_columns * 2);
 }
 
@@ -194,38 +197,38 @@ static void vgacon_scrollback_update(struct vc_data *c, int t, int count)
 {
 	void *p;
 
-	if (!vgacon_scrollback_size || c->vc_num != fg_console)
+	if (!vgacon_scrollback.size || c->vc_num != fg_console)
 		return;
 
 	p = (void *) (c->vc_origin + t * c->vc_size_row);
 
 	while (count--) {
-		scr_memcpyw(vgacon_scrollback + vgacon_scrollback_tail,
+		scr_memcpyw(vgacon_scrollback.data + vgacon_scrollback.tail,
 			    p, c->vc_size_row);
-		vgacon_scrollback_cnt++;
+		vgacon_scrollback.cnt++;
 		p += c->vc_size_row;
-		vgacon_scrollback_tail += c->vc_size_row;
+		vgacon_scrollback.tail += c->vc_size_row;
 
-		if (vgacon_scrollback_tail >= vgacon_scrollback_size)
-			vgacon_scrollback_tail = 0;
+		if (vgacon_scrollback.tail >= vgacon_scrollback.size)
+			vgacon_scrollback.tail = 0;
 
-		if (vgacon_scrollback_cnt > vgacon_scrollback_rows)
-			vgacon_scrollback_cnt = vgacon_scrollback_rows;
+		if (vgacon_scrollback.cnt > vgacon_scrollback.rows)
+			vgacon_scrollback.cnt = vgacon_scrollback.rows;
 
-		vgacon_scrollback_cur = vgacon_scrollback_cnt;
+		vgacon_scrollback.cur = vgacon_scrollback.cnt;
 	}
 }
 
 static void vgacon_restore_screen(struct vc_data *c)
 {
-	vgacon_scrollback_save = 0;
+	vgacon_scrollback.save = 0;
 
-	if (!vga_is_gfx && !vgacon_scrollback_restore) {
+	if (!vga_is_gfx && !vgacon_scrollback.restore) {
 		scr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,
 			    c->vc_screenbuf_size > vga_vram_size ?
 			    vga_vram_size : c->vc_screenbuf_size);
-		vgacon_scrollback_restore = 1;
-		vgacon_scrollback_cur = vgacon_scrollback_cnt;
+		vgacon_scrollback.restore = 1;
+		vgacon_scrollback.cur = vgacon_scrollback.cnt;
 	}
 }
 
@@ -239,41 +242,41 @@ static void vgacon_scrolldelta(struct vc_data *c, int lines)
 		return;
 	}
 
-	if (!vgacon_scrollback)
+	if (!vgacon_scrollback.data)
 		return;
 
-	if (!vgacon_scrollback_save) {
+	if (!vgacon_scrollback.save) {
 		vgacon_cursor(c, CM_ERASE);
 		vgacon_save_screen(c);
-		vgacon_scrollback_save = 1;
+		vgacon_scrollback.save = 1;
 	}
 
-	vgacon_scrollback_restore = 0;
-	start = vgacon_scrollback_cur + lines;
+	vgacon_scrollback.restore = 0;
+	start = vgacon_scrollback.cur + lines;
 	end = start + abs(lines);
 
 	if (start < 0)
 		start = 0;
 
-	if (start > vgacon_scrollback_cnt)
-		start = vgacon_scrollback_cnt;
+	if (start > vgacon_scrollback.cnt)
+		start = vgacon_scrollback.cnt;
 
 	if (end < 0)
 		end = 0;
 
-	if (end > vgacon_scrollback_cnt)
-		end = vgacon_scrollback_cnt;
+	if (end > vgacon_scrollback.cnt)
+		end = vgacon_scrollback.cnt;
 
-	vgacon_scrollback_cur = start;
+	vgacon_scrollback.cur = start;
 	count = end - start;
-	soff = vgacon_scrollback_tail - ((vgacon_scrollback_cnt - end) *
+	soff = vgacon_scrollback.tail - ((vgacon_scrollback.cnt - end) *
 					 c->vc_size_row);
 	soff -= count * c->vc_size_row;
 
 	if (soff < 0)
-		soff += vgacon_scrollback_size;
+		soff += vgacon_scrollback.size;
 
-	count = vgacon_scrollback_cnt - start;
+	count = vgacon_scrollback.cnt - start;
 
 	if (count > c->vc_rows)
 		count = c->vc_rows;
@@ -287,13 +290,13 @@ static void vgacon_scrolldelta(struct vc_data *c, int lines)
 
 		count *= c->vc_size_row;
 		/* how much memory to end of buffer left? */
-		copysize = min(count, vgacon_scrollback_size - soff);
-		scr_memcpyw(d, vgacon_scrollback + soff, copysize);
+		copysize = min(count, vgacon_scrollback.size - soff);
+		scr_memcpyw(d, vgacon_scrollback.data + soff, copysize);
 		d += copysize;
 		count -= copysize;
 
 		if (count) {
-			scr_memcpyw(d, vgacon_scrollback, count);
+			scr_memcpyw(d, vgacon_scrollback.data, count);
 			d += count;
 		}
 

commit b9c8b7fc252cd8e7e629f14bb8a68d54889470da
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Oct 3 11:18:39 2016 +0200

    vgacon: remove prehistoric macros
    
    These macros:
    * CAN_LOAD_EGA_FONTS
    * CAN_LOAD_PALETTE
    * TRIDENT_GLITCH
    * VGA_CAN_DO_64KB
    * SLOW_VGA
    are either always set or always unset. They come from the linux 2.1
    times. And given nobody switched them to some configurable options, I
    assume nobody actually uses them.
    
    So remove the macros and leave in place appropriate branches of the
    conditional code.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: <linux-fbdev@vger.kernel.org>
    Cc: <linux-doc@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index d13d5d372604..c22a56232b7c 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -60,15 +60,6 @@ static struct vgastate vgastate;
 
 #define BLANK 0x0020
 
-#define CAN_LOAD_EGA_FONTS	/* undefine if the user must not do this */
-#define CAN_LOAD_PALETTE	/* undefine if the user must not do this */
-
-/* You really do _NOT_ want to define this, unless you have buggy
- * Trident VGA which will resize cursor when moving it between column
- * 15 & 16. If you define this and your VGA is OK, inverse bug will
- * appear.
- */
-#undef TRIDENT_GLITCH
 #define VGA_FONTWIDTH       8   /* VGA does not support fontwidths != 8 */
 /*
  *  Interface used by the world
@@ -157,18 +148,10 @@ static inline void write_vga(unsigned char reg, unsigned int val)
 	 * handlers, thus the write has to be IRQ-atomic.
 	 */
 	raw_spin_lock_irqsave(&vga_lock, flags);
-
-#ifndef SLOW_VGA
 	v1 = reg + (val & 0xff00);
 	v2 = reg + 1 + ((val << 8) & 0xff00);
 	outw(v1, vga_video_port_reg);
 	outw(v2, vga_video_port_reg);
-#else
-	outb_p(reg, vga_video_port_reg);
-	outb_p(val >> 8, vga_video_port_val);
-	outb_p(reg + 1, vga_video_port_reg);
-	outb_p(val & 0xff, vga_video_port_val);
-#endif
 	raw_spin_unlock_irqrestore(&vga_lock, flags);
 }
 
@@ -426,18 +409,6 @@ static const char *vgacon_startup(void)
 				request_resource(&ioport_resource,
 						 &vga_console_resource);
 
-#ifdef VGA_CAN_DO_64KB
-				/*
-				 * get 64K rather than 32K of video RAM.
-				 * This doesn't actually work on all "VGA"
-				 * controllers (it seems like setting MM=01
-				 * and COE=1 isn't necessarily a good idea)
-				 */
-				vga_vram_base = 0xa0000;
-				vga_vram_size = 0x10000;
-				outb_p(6, VGA_GFX_I);
-				outb_p(6, VGA_GFX_D);
-#endif
 				/*
 				 * Normalise the palette registers, to point
 				 * the 16 screen colours to the first 16
@@ -627,11 +598,6 @@ static void vgacon_set_cursor_size(int xpos, int from, int to)
 	unsigned long flags;
 	int curs, cure;
 
-#ifdef TRIDENT_GLITCH
-	if (xpos < 16)
-		from--, to--;
-#endif
-
 	if ((from == cursor_size_lastfrom) && (to == cursor_size_lastto))
 		return;
 	cursor_size_lastfrom = from;
@@ -833,12 +799,10 @@ static void vga_set_palette(struct vc_data *vc, const unsigned char *table)
 
 static void vgacon_set_palette(struct vc_data *vc, const unsigned char *table)
 {
-#ifdef CAN_LOAD_PALETTE
 	if (vga_video_type != VIDEO_TYPE_VGAC || vga_palette_blanked
 	    || !con_is_visible(vc))
 		return;
 	vga_set_palette(vc, table);
-#endif
 }
 
 /* structure holding original VGA register settings */
@@ -1021,8 +985,6 @@ static int vgacon_blank(struct vc_data *c, int blank, int mode_switch)
  * (sizif@botik.yaroslavl.su).
  */
 
-#ifdef CAN_LOAD_EGA_FONTS
-
 #define colourmap 0xa0000
 /* Pauline Middelink <middelin@polyware.iaf.nl> reports that we
    should use 0xA0000 for the bwmap as well.. */
@@ -1039,10 +1001,6 @@ static int vgacon_do_font_op(struct vgastate *state, char *arg, int set,
 	if (vga_video_type != VIDEO_TYPE_EGAM) {
 		charmap = (char *) VGA_MAP_MEM(colourmap, 0);
 		beg = 0x0e;
-#ifdef VGA_CAN_DO_64KB
-		if (vga_video_type == VIDEO_TYPE_VGAC)
-			beg = 0x06;
-#endif
 	} else {
 		charmap = (char *) VGA_MAP_MEM(blackwmap, 0);
 		beg = 0x0a;
@@ -1271,13 +1229,6 @@ static int vgacon_font_get(struct vc_data *c, struct console_font *font)
 	return vgacon_do_font_op(&vgastate, font->data, 0, vga_512_chars);
 }
 
-#else
-
-#define vgacon_font_set NULL
-#define vgacon_font_get NULL
-
-#endif
-
 static int vgacon_resize(struct vc_data *c, unsigned int width,
 			 unsigned int height, unsigned int user)
 {

commit 96fd95542391d2ceb15515f41566dbb6776d9858
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Oct 3 11:18:38 2016 +0200

    vgacon: switch boolean variables to bool
    
    These variables:
    * vga_can_do_color
    * vgacon_text_mode_force
    * vga_font_is_default
    * vga_hardscroll_enabled
    * vga_hardscroll_user_enable
    * vga_init_done
    * vga_is_gfx
    * vga_palette_blanked
    * vga_512_chars
    are used exclusively as a boolean value, so make them really a bool.
    
    Remove also useless "? true : false".
    
    __read_mostly annotations removed too as they obfuscate the code and I
    doubt they improve anything measurable given the variables are used
    from .con_scroll, .con_startup and such.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: <linux-fbdev@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index ede6a5a85ccd..d13d5d372604 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -88,7 +88,7 @@ static struct uni_pagedir *vgacon_uni_pagedir;
 static int vgacon_refcount;
 
 /* Description of the hardware situation */
-static int		vga_init_done		__read_mostly;
+static bool		vga_init_done;
 static unsigned long	vga_vram_base		__read_mostly;	/* Base of video memory */
 static unsigned long	vga_vram_end		__read_mostly;	/* End of video memory */
 static unsigned int	vga_vram_size		__read_mostly;	/* Size of video memory */
@@ -96,31 +96,31 @@ static u16		vga_video_port_reg	__read_mostly;	/* Video register select port */
 static u16		vga_video_port_val	__read_mostly;	/* Video register value port */
 static unsigned int	vga_video_num_columns;			/* Number of text columns */
 static unsigned int	vga_video_num_lines;			/* Number of text lines */
-static int		vga_can_do_color	__read_mostly;	/* Do we support colors? */
+static bool		vga_can_do_color;			/* Do we support colors? */
 static unsigned int	vga_default_font_height __read_mostly;	/* Height of default screen font */
 static unsigned char	vga_video_type		__read_mostly;	/* Card type */
-static unsigned char	vga_hardscroll_enabled	__read_mostly;
-static unsigned char	vga_hardscroll_user_enable __read_mostly = 1;
-static unsigned char	vga_font_is_default = 1;
+static bool		vga_font_is_default = true;
 static int		vga_vesa_blanked;
-static int 		vga_palette_blanked;
-static int 		vga_is_gfx;
-static int 		vga_512_chars;
+static bool 		vga_palette_blanked;
+static bool 		vga_is_gfx;
+static bool 		vga_512_chars;
 static int 		vga_video_font_height;
 static int 		vga_scan_lines		__read_mostly;
 static unsigned int 	vga_rolled_over;
 
-static int vgacon_text_mode_force;
+static bool vgacon_text_mode_force;
+static bool vga_hardscroll_enabled;
+static bool vga_hardscroll_user_enable = true;
 
 bool vgacon_text_force(void)
 {
-	return vgacon_text_mode_force ? true : false;
+	return vgacon_text_mode_force;
 }
 EXPORT_SYMBOL(vgacon_text_force);
 
 static int __init text_mode(char *str)
 {
-	vgacon_text_mode_force = 1;
+	vgacon_text_mode_force = true;
 	return 1;
 }
 
@@ -134,7 +134,7 @@ static int __init no_scroll(char *str)
 	 * Braille reader made by F.H. Papenmeier (Germany).
 	 * Use the "no-scroll" bootflag.
 	 */
-	vga_hardscroll_user_enable = vga_hardscroll_enabled = 0;
+	vga_hardscroll_user_enable = vga_hardscroll_enabled = false;
 	return 1;
 }
 
@@ -402,7 +402,7 @@ static const char *vgacon_startup(void)
 		}
 	} else {
 		/* If not, it is color. */
-		vga_can_do_color = 1;
+		vga_can_do_color = true;
 		vga_vram_base = 0xb8000;
 		vga_video_port_reg = VGA_CRT_IC;
 		vga_video_port_val = VGA_CRT_DC;
@@ -517,7 +517,7 @@ static const char *vgacon_startup(void)
 
 	if (!vga_init_done) {
 		vgacon_scrollback_startup();
-		vga_init_done = 1;
+		vga_init_done = true;
 	}
 
 	return display_desc;
@@ -609,7 +609,7 @@ static u8 vgacon_build_attr(struct vc_data *c, u8 color, u8 intensity,
 
 static void vgacon_invert_region(struct vc_data *c, u16 * p, int count)
 {
-	int col = vga_can_do_color;
+	const bool col = vga_can_do_color;
 
 	while (count--) {
 		u16 a = scr_readw(p);
@@ -981,24 +981,24 @@ static int vgacon_blank(struct vc_data *c, int blank, int mode_switch)
 		}
 		if (vga_palette_blanked) {
 			vga_set_palette(c, color_table);
-			vga_palette_blanked = 0;
+			vga_palette_blanked = false;
 			return 0;
 		}
-		vga_is_gfx = 0;
+		vga_is_gfx = false;
 		/* Tell console.c that it has to restore the screen itself */
 		return 1;
 	case 1:		/* Normal blanking */
 	case -1:	/* Obsolete */
 		if (!mode_switch && vga_video_type == VIDEO_TYPE_VGAC) {
 			vga_pal_blank(&vgastate);
-			vga_palette_blanked = 1;
+			vga_palette_blanked = true;
 			return 0;
 		}
 		vgacon_set_origin(c);
 		scr_memsetw((void *) vga_vram_base, BLANK,
 			    c->vc_screenbuf_size);
 		if (mode_switch)
-			vga_is_gfx = 1;
+			vga_is_gfx = true;
 		return 1;
 	default:		/* VESA blanking */
 		if (vga_video_type == VIDEO_TYPE_VGAC) {
@@ -1029,7 +1029,8 @@ static int vgacon_blank(struct vc_data *c, int blank, int mode_switch)
 #define blackwmap 0xa0000
 #define cmapsz 8192
 
-static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
+static int vgacon_do_font_op(struct vgastate *state, char *arg, int set,
+		bool ch512)
 {
 	unsigned short video_port_status = vga_video_port_reg + 6;
 	int font_select = 0x00, beg, i;
@@ -1055,7 +1056,7 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 	if (!arg)
 		return -EINVAL;	/* Return to default font not supported */
 
-	vga_font_is_default = 0;
+	vga_font_is_default = false;
 	font_select = ch512 ? 0x04 : 0x00;
 #else
 	/*
@@ -1066,7 +1067,7 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 	if (set) {
 		vga_font_is_default = !arg;
 		if (!arg)
-			ch512 = 0;	/* Default font is always 256 */
+			ch512 = false;	/* Default font is always 256 */
 		font_select = arg ? (ch512 ? 0x0e : 0x0a) : 0x00;
 	}
 

commit 35cc56f9a30480c8a0cca809cf341614a2144758
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Oct 3 11:18:35 2016 +0200

    tty: vgacon+sisusb, move scrolldelta to a common helper
    
    The code is mirrorred in scrolldelta implementations of both vgacon
    and sisusb. Let's move the code to a separate helper where we will
    perform a common cleanup and further changes.
    
    While we are moving the code, make it linear and save one indentation
    level. This is done by returning from the "!lines" then-branch
    immediatelly. This allows flushing the else-branch 1 level to the
    left, obviously.
    
    Few more new lines and comments were added too.
    
    And do not forget to export the helper function given sisusb can be
    built as module.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Thomas Winischhofer <thomas@winischhofer.net>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: <linux-fbdev@vger.kernel.org>
    Cc: <linux-usb@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 4c54a873452e..ede6a5a85ccd 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -332,31 +332,8 @@ static void vgacon_restore_screen(struct vc_data *c)
 
 static void vgacon_scrolldelta(struct vc_data *c, int lines)
 {
-	if (!lines)		/* Turn scrollback off */
-		c->vc_visible_origin = c->vc_origin;
-	else {
-		int margin = c->vc_size_row * 4;
-		int ul, we, p, st;
-
-		if (vga_rolled_over >
-		    (c->vc_scr_end - vga_vram_base) + margin) {
-			ul = c->vc_scr_end - vga_vram_base;
-			we = vga_rolled_over + c->vc_size_row;
-		} else {
-			ul = 0;
-			we = vga_vram_size;
-		}
-		p = (c->vc_visible_origin - vga_vram_base - ul + we) % we +
-		    lines * c->vc_size_row;
-		st = (c->vc_origin - vga_vram_base - ul + we) % we;
-		if (st < 2 * margin)
-			margin = 0;
-		if (p < margin)
-			p = 0;
-		if (p > st - margin)
-			p = st;
-		c->vc_visible_origin = vga_vram_base + (p + ul) % we;
-	}
+	vc_scrolldelta_helper(c, lines, vga_rolled_over, (void *)vga_vram_base,
+			vga_vram_size);
 	vga_set_mem_top(c);
 }
 #endif /* CONFIG_VGACON_SOFT_SCROLLBACK */

commit d705ff38189fcfbbfa6aa97363d30c23348ad166
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Oct 3 11:18:33 2016 +0200

    tty: vt, cleanup and document con_scroll
    
    Scrolling helpers scrup and scrdown both accept 'top' and 'bottom' as
    unsigned int. Number of lines 'nr' is accepted as int, but all callers
    pass down unsigned too. So change the type of 'nr' to unsigned too.
    Now, promote unsigned int from the helpers up to the con_scroll
    hook which actually accepted all those as signed int.
    
    Next, the 'dir' parameter can have only two values and we define
    constants for that: SM_UP and SM_DOWN. Switch them to enum and do
    proper type checking on 'dir' too.
    
    Finally, document the behaviour of the hook.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Thomas Winischhofer <thomas@winischhofer.net>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: <linux-fbdev@vger.kernel.org>
    Cc: <linux-usb@vger.kernel.org>
    Cc: <linux-parisc@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 11576611a974..4c54a873452e 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -83,8 +83,6 @@ static int vgacon_blank(struct vc_data *c, int blank, int mode_switch);
 static void vgacon_scrolldelta(struct vc_data *c, int lines);
 static int vgacon_set_origin(struct vc_data *c);
 static void vgacon_save_screen(struct vc_data *c);
-static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,
-			 int lines);
 static void vgacon_invert_region(struct vc_data *c, u16 * p, int count);
 static struct uni_pagedir *vgacon_uni_pagedir;
 static int vgacon_refcount;
@@ -1350,17 +1348,17 @@ static void vgacon_save_screen(struct vc_data *c)
 			    c->vc_screenbuf_size > vga_vram_size ? vga_vram_size : c->vc_screenbuf_size);
 }
 
-static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,
-			 int lines)
+static bool vgacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,
+		enum con_scroll dir, unsigned int lines)
 {
 	unsigned long oldo;
 	unsigned int delta;
 
 	if (t || b != c->vc_rows || vga_is_gfx || c->vc_mode != KD_TEXT)
-		return 0;
+		return false;
 
 	if (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)
-		return 0;
+		return false;
 
 	vgacon_restore_screen(c);
 	oldo = c->vc_origin;
@@ -1396,7 +1394,7 @@ static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,
 	c->vc_visible_origin = c->vc_origin;
 	vga_set_mem_top(c);
 	c->vc_pos = (c->vc_pos - oldo) + c->vc_origin;
-	return 1;
+	return true;
 }
 
 

commit 6ca8dfd78187d8238abc5b2996848a0c8f07948d
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jun 23 13:34:35 2016 +0200

    tty: vt, convert more macros to functions
    
    Namely convert:
    * IS_FG -> con_is_fg
    * DO_UPDATE -> con_should_update
    * CON_IS_VISIBLE -> con_is_visible
    
    DO_UPDATE was a weird name for a yes/no answer, so the new name is
    con_should_update.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Thomas Winischhofer <thomas@winischhofer.net>
    Cc: Jean-Christophe Plagniol-Villard <plagnioj@jcrosoft.com>
    Cc: linux-usb@vger.kernel.org
    Cc: linux-fbdev@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index e280b3ceebd9..11576611a974 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -589,7 +589,7 @@ static void vgacon_init(struct vc_data *c, int init)
 static void vgacon_deinit(struct vc_data *c)
 {
 	/* When closing the active console, reset video origin */
-	if (CON_IS_VISIBLE(c)) {
+	if (con_is_visible(c)) {
 		c->vc_visible_origin = vga_vram_base;
 		vga_set_mem_top(c);
 	}
@@ -860,7 +860,7 @@ static void vgacon_set_palette(struct vc_data *vc, const unsigned char *table)
 {
 #ifdef CAN_LOAD_PALETTE
 	if (vga_video_type != VIDEO_TYPE_VGAC || vga_palette_blanked
-	    || !CON_IS_VISIBLE(vc))
+	    || !con_is_visible(vc))
 		return;
 	vga_set_palette(vc, table);
 #endif
@@ -1248,7 +1248,7 @@ static int vgacon_adjust_height(struct vc_data *vc, unsigned fontheight)
 		struct vc_data *c = vc_cons[i].d;
 
 		if (c && c->vc_sw == &vga_con) {
-			if (CON_IS_VISIBLE(c)) {
+			if (con_is_visible(c)) {
 			        /* void size to cause regs to be rewritten */
 				cursor_size_lastfrom = 0;
 				cursor_size_lastto = 0;
@@ -1312,7 +1312,7 @@ static int vgacon_resize(struct vc_data *c, unsigned int width,
 		   return success */
 		return (user) ? 0 : -EINVAL;
 
-	if (CON_IS_VISIBLE(c) && !vga_is_gfx) /* who knows */
+	if (con_is_visible(c) && !vga_is_gfx) /* who knows */
 		vgacon_doresize(c, width, height);
 	return 0;
 }

commit 52ad1f38b4f6e2f2133668247036ad64ef7ae18a
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jun 23 13:34:28 2016 +0200

    tty: vt, remove consw->con_bmove
    
    It is never called since commit 81732c3b2fede (tty vt: Fix line
    garbage in virtual console on command line edition) in 3.7. So remove
    all the callbacks.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Thomas Winischhofer <thomas@winischhofer.net>
    Cc: linux-usb@vger.kernel.org
    Cc: Jean-Christophe Plagniol-Villard <plagnioj@jcrosoft.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: linux-fbdev@vger.kernel.org
    Cc: linux-parisc@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index aaae9bd23900..e280b3ceebd9 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -1421,7 +1421,6 @@ const struct consw vga_con = {
 	.con_putcs = DUMMY,
 	.con_cursor = vgacon_cursor,
 	.con_scroll = vgacon_scroll,
-	.con_bmove = DUMMY,
 	.con_switch = vgacon_switch,
 	.con_blank = vgacon_blank,
 	.con_font_set = vgacon_font_set,

commit 709280da6238629c3b488b7be87c6d9185f4d03e
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jun 23 13:34:27 2016 +0200

    tty: vt, consw->con_set_palette cleanup
    
    * allow NULL consw->con_set_palette (some consoles define an empty
      hook)
    * => remove empty hooks now
    * return value of consw->con_set_palette is never checked => make the
      function void
    * document consw->con_set_palette a bit
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Thomas Winischhofer <thomas@winischhofer.net>
    Cc: linux-usb@vger.kernel.org
    Cc: Jean-Christophe Plagniol-Villard <plagnioj@jcrosoft.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: linux-fbdev@vger.kernel.org
    Cc: linux-parisc@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index f447d6916991..aaae9bd23900 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -856,16 +856,13 @@ static void vga_set_palette(struct vc_data *vc, const unsigned char *table)
 	}
 }
 
-static int vgacon_set_palette(struct vc_data *vc, const unsigned char *table)
+static void vgacon_set_palette(struct vc_data *vc, const unsigned char *table)
 {
 #ifdef CAN_LOAD_PALETTE
 	if (vga_video_type != VIDEO_TYPE_VGAC || vga_palette_blanked
 	    || !CON_IS_VISIBLE(vc))
-		return -EINVAL;
+		return;
 	vga_set_palette(vc, table);
-	return 0;
-#else
-	return -EINVAL;
 #endif
 }
 

commit 97293de977365fe672daec2523e66ef457104921
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jun 23 13:34:26 2016 +0200

    tty: vt, consw->con_scrolldelta cleanup
    
    * allow NULL consw->con_scrolldelta (some consoles define an empty
      hook)
    * => remove empty hooks now
    * return value of consw->con_scrolldelta is never checked => make the
      function void
    * document consw->con_scrolldelta a bit
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Thomas Winischhofer <thomas@winischhofer.net>
    Cc: linux-usb@vger.kernel.org
    Cc: Jean-Christophe Plagniol-Villard <plagnioj@jcrosoft.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: linux-fbdev@vger.kernel.org
    Cc: linux-parisc@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 8bf911002cba..f447d6916991 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -80,7 +80,7 @@ static void vgacon_deinit(struct vc_data *c);
 static void vgacon_cursor(struct vc_data *c, int mode);
 static int vgacon_switch(struct vc_data *c);
 static int vgacon_blank(struct vc_data *c, int blank, int mode_switch);
-static int vgacon_scrolldelta(struct vc_data *c, int lines);
+static void vgacon_scrolldelta(struct vc_data *c, int lines);
 static int vgacon_set_origin(struct vc_data *c);
 static void vgacon_save_screen(struct vc_data *c);
 static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,
@@ -248,18 +248,18 @@ static void vgacon_restore_screen(struct vc_data *c)
 	}
 }
 
-static int vgacon_scrolldelta(struct vc_data *c, int lines)
+static void vgacon_scrolldelta(struct vc_data *c, int lines)
 {
 	int start, end, count, soff;
 
 	if (!lines) {
 		c->vc_visible_origin = c->vc_origin;
 		vga_set_mem_top(c);
-		return 1;
+		return;
 	}
 
 	if (!vgacon_scrollback)
-		return 1;
+		return;
 
 	if (!vgacon_scrollback_save) {
 		vgacon_cursor(c, CM_ERASE);
@@ -320,8 +320,6 @@ static int vgacon_scrolldelta(struct vc_data *c, int lines)
 			scr_memcpyw(d, s, diff * c->vc_size_row);
 	} else
 		vgacon_cursor(c, CM_MOVE);
-
-	return 1;
 }
 #else
 #define vgacon_scrollback_startup(...) do { } while (0)
@@ -334,7 +332,7 @@ static void vgacon_restore_screen(struct vc_data *c)
 		vgacon_scrolldelta(c, 0);
 }
 
-static int vgacon_scrolldelta(struct vc_data *c, int lines)
+static void vgacon_scrolldelta(struct vc_data *c, int lines)
 {
 	if (!lines)		/* Turn scrollback off */
 		c->vc_visible_origin = c->vc_origin;
@@ -362,7 +360,6 @@ static int vgacon_scrolldelta(struct vc_data *c, int lines)
 		c->vc_visible_origin = vga_vram_base + (p + ul) % we;
 	}
 	vga_set_mem_top(c);
-	return 1;
 }
 #endif /* CONFIG_VGACON_SOFT_SCROLLBACK */
 

commit 8ede5cce4f0baff77ef63aa3cb3afc65d0317e0b
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Mar 31 10:08:16 2016 +0200

    tty: vt, make color_table const
    
    This means all ->con_set_palette have to have the second parameter
    const too now.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 517f565b65d7..8bf911002cba 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -80,7 +80,6 @@ static void vgacon_deinit(struct vc_data *c);
 static void vgacon_cursor(struct vc_data *c, int mode);
 static int vgacon_switch(struct vc_data *c);
 static int vgacon_blank(struct vc_data *c, int blank, int mode_switch);
-static int vgacon_set_palette(struct vc_data *vc, unsigned char *table);
 static int vgacon_scrolldelta(struct vc_data *c, int lines);
 static int vgacon_set_origin(struct vc_data *c);
 static void vgacon_save_screen(struct vc_data *c);
@@ -847,7 +846,7 @@ static int vgacon_switch(struct vc_data *c)
 	return 0;		/* Redrawing not needed */
 }
 
-static void vga_set_palette(struct vc_data *vc, unsigned char *table)
+static void vga_set_palette(struct vc_data *vc, const unsigned char *table)
 {
 	int i, j;
 
@@ -860,7 +859,7 @@ static void vga_set_palette(struct vc_data *vc, unsigned char *table)
 	}
 }
 
-static int vgacon_set_palette(struct vc_data *vc, unsigned char *table)
+static int vgacon_set_palette(struct vc_data *vc, const unsigned char *table)
 {
 #ifdef CAN_LOAD_PALETTE
 	if (vga_video_type != VIDEO_TYPE_VGAC || vga_palette_blanked

commit 89f0244e7f732c5007a065c8f0e5ad44343ae1aa
Author: Mark Rustad <mark.d.rustad@intel.com>
Date:   Tue Oct 14 04:53:49 2014 -0700

    video/console: Resolve several shadow warnings
    
    Resolve shadow warnings that appear in W=2 builds by renaming
    the "state" global to "vgastate".
    
    Signed-off-by: Mark Rustad <mark.d.rustad@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 6e6aa704fe84..517f565b65d7 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -56,7 +56,7 @@ static int cursor_size_lastfrom;
 static int cursor_size_lastto;
 static u32 vgacon_xres;
 static u32 vgacon_yres;
-static struct vgastate state;
+static struct vgastate vgastate;
 
 #define BLANK 0x0020
 
@@ -400,7 +400,7 @@ static const char *vgacon_startup(void)
 
 	vga_video_num_lines = screen_info.orig_video_lines;
 	vga_video_num_columns = screen_info.orig_video_cols;
-	state.vgabase = NULL;
+	vgastate.vgabase = NULL;
 
 	if (screen_info.orig_video_mode == 7) {
 		/* Monochrome display */
@@ -851,12 +851,12 @@ static void vga_set_palette(struct vc_data *vc, unsigned char *table)
 {
 	int i, j;
 
-	vga_w(state.vgabase, VGA_PEL_MSK, 0xff);
+	vga_w(vgastate.vgabase, VGA_PEL_MSK, 0xff);
 	for (i = j = 0; i < 16; i++) {
-		vga_w(state.vgabase, VGA_PEL_IW, table[i]);
-		vga_w(state.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);
-		vga_w(state.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);
-		vga_w(state.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);
+		vga_w(vgastate.vgabase, VGA_PEL_IW, table[i]);
+		vga_w(vgastate.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);
+		vga_w(vgastate.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);
+		vga_w(vgastate.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);
 	}
 }
 
@@ -1008,7 +1008,7 @@ static int vgacon_blank(struct vc_data *c, int blank, int mode_switch)
 	switch (blank) {
 	case 0:		/* Unblank */
 		if (vga_vesa_blanked) {
-			vga_vesa_unblank(&state);
+			vga_vesa_unblank(&vgastate);
 			vga_vesa_blanked = 0;
 		}
 		if (vga_palette_blanked) {
@@ -1022,7 +1022,7 @@ static int vgacon_blank(struct vc_data *c, int blank, int mode_switch)
 	case 1:		/* Normal blanking */
 	case -1:	/* Obsolete */
 		if (!mode_switch && vga_video_type == VIDEO_TYPE_VGAC) {
-			vga_pal_blank(&state);
+			vga_pal_blank(&vgastate);
 			vga_palette_blanked = 1;
 			return 0;
 		}
@@ -1034,7 +1034,7 @@ static int vgacon_blank(struct vc_data *c, int blank, int mode_switch)
 		return 1;
 	default:		/* VESA blanking */
 		if (vga_video_type == VIDEO_TYPE_VGAC) {
-			vga_vesa_blank(&state, blank - 1);
+			vga_vesa_blank(&vgastate, blank - 1);
 			vga_vesa_blanked = blank;
 		}
 		return 0;
@@ -1280,7 +1280,7 @@ static int vgacon_font_set(struct vc_data *c, struct console_font *font, unsigne
 	    (charcount != 256 && charcount != 512))
 		return -EINVAL;
 
-	rc = vgacon_do_font_op(&state, font->data, 1, charcount == 512);
+	rc = vgacon_do_font_op(&vgastate, font->data, 1, charcount == 512);
 	if (rc)
 		return rc;
 
@@ -1299,7 +1299,7 @@ static int vgacon_font_get(struct vc_data *c, struct console_font *font)
 	font->charcount = vga_512_chars ? 512 : 256;
 	if (!font->data)
 		return 0;
-	return vgacon_do_font_op(&state, font->data, 0, vga_512_chars);
+	return vgacon_do_font_op(&vgastate, font->data, 0, vga_512_chars);
 }
 
 #else

commit 884d6147ba19640a40fb45efe64360cdf92cac27
Merge: fb54918af7e7 223a6f2b975a
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jun 19 10:54:35 2014 +1000

    Merge tag 'drm-intel-fixes-2014-06-17' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    First round of fixes for 3.16-rc, mostly cc: stable, and the vt/vgacon
    fixes from Daniel [1] to avoid hangs and unclaimed register errors on
    module load/reload.
    
    * tag 'drm-intel-fixes-2014-06-17' of git://anongit.freedesktop.org/drm-intel:
      drm/i915/bdw: remove erroneous chv specific workarounds from bdw code
      drm/i915: fix possible refcount leak when resetting forcewake
      drm/i915: Reorder semaphore deadlock check
      drm/i95: Initialize active ring->pid to -1
      drm/i915: set backlight duty cycle after backlight enable for gen4
      drm/i915: Avoid div-by-zero when pixel_multiplier is zero
      drm/i915: Disable FBC by default also on Haswell and later
      drm/i915: Kick out vga console
      drm/i915: Fixup global gtt cleanup
      vt: Don't ignore unbind errors in vt_unbind
      vt: Fix up unregistration of vt drivers
      vt: Fix replacement console check when unbinding

commit a4de05268e674e8ed31df6348269e22d6c6a1803
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jun 5 16:20:46 2014 +0200

    drm/i915: Kick out vga console
    
    Touching the VGA resources on an IVB EFI machine causes hard hangs when
    we then kick out the efifb. Ouch.
    
    Apparently this also prevents unclaimed register errors on hsw and
    hard machine hangs on my i855gm when trying to unbind fbcon.
    
    Also, we want this to make I915_FBDEV=n safe.
    
    v2: Rebase and pimp commit message.
    
    v3: We also need to unregister the vga console, otherwise the unbind
    of the fb console before module unload might resurrect it again.
    
    v4: Ignore errors when the vga console is already unregistered - this
    can happen when e.g. reloading i915.ko.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=67813
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Cc: Jean-Christophe Plagniol-Villard <plagnioj@jcrosoft.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: linux-fbdev@vger.kernel.org
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk> (v1)
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 9d8feac67637..84acd6223dc5 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -1440,5 +1440,6 @@ const struct consw vga_con = {
 	.con_build_attr = vgacon_build_attr,
 	.con_invert_region = vgacon_invert_region,
 };
+EXPORT_SYMBOL(vga_con);
 
 MODULE_LICENSE("GPL");

commit e4bdab70dd07d8648a1ec3e029239aa86eb836b6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 13 12:09:28 2014 +0200

    console: Use explicit pointer type for vc_uni_pagedir* fields
    
    The vc_data.vc_uni_pagedir filed is currently long int, supposedly to
    be served generically.  This, however, leads to lots of cast to
    pointer, and rather it worsens the readability significantly.
    
    Actually, we have now only a single uni_pagedir map implementation,
    and this won't change likely.  So, it'd be much more simple and
    error-prone to just use the exact pointer for struct uni_pagedir
    instead of long.
    
    Ditto for vc_uni_pagedir_loc.  It's a pointer to the uni_pagedir, thus
    it can be changed similarly to the exact type.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 9e18770aaba6..f267284b423b 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -87,7 +87,7 @@ static void vgacon_save_screen(struct vc_data *c);
 static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,
 			 int lines);
 static void vgacon_invert_region(struct vc_data *c, u16 * p, int count);
-static unsigned long vgacon_uni_pagedir;
+static struct uni_pagedir *vgacon_uni_pagedir;
 static int vgacon_refcount;
 
 /* Description of the hardware situation */
@@ -554,7 +554,7 @@ static const char *vgacon_startup(void)
 
 static void vgacon_init(struct vc_data *c, int init)
 {
-	unsigned long p;
+	struct uni_pagedir *p;
 
 	/*
 	 * We cannot be loaded as a module, therefore init is always 1,

commit 0f2893f0d1acff4bb1677b60c0486adc0075cb99
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 13 12:09:27 2014 +0200

    vgacon: Fix & cleanup refcounting
    
    The vgacon driver prepares a two element array of uni_pagedir_loc and
    uses the second item as its own reference counter for sharing the
    uni_pagedir.  And the code assumes blindly that the second item is
    available if the assigned vc_uni_pagedir isn't the standard one, which
    might be wrong (although currently it's so).
    
    This patch fixes that wrong assumption, and gives a slight cleanup
    along with it: namely, instead of array, just give the uni_pagedir_loc
    and a separate refcount variable.  It makes the code a bit more
    understandable at first glance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 9d8feac67637..9e18770aaba6 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -87,7 +87,8 @@ static void vgacon_save_screen(struct vc_data *c);
 static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,
 			 int lines);
 static void vgacon_invert_region(struct vc_data *c, u16 * p, int count);
-static unsigned long vgacon_uni_pagedir[2];
+static unsigned long vgacon_uni_pagedir;
+static int vgacon_refcount;
 
 /* Description of the hardware situation */
 static int		vga_init_done		__read_mostly;
@@ -575,12 +576,12 @@ static void vgacon_init(struct vc_data *c, int init)
 	if (vga_512_chars)
 		c->vc_hi_font_mask = 0x0800;
 	p = *c->vc_uni_pagedir_loc;
-	if (c->vc_uni_pagedir_loc == &c->vc_uni_pagedir ||
-	    !--c->vc_uni_pagedir_loc[1])
+	if (c->vc_uni_pagedir_loc != &vgacon_uni_pagedir) {
 		con_free_unimap(c);
-	c->vc_uni_pagedir_loc = vgacon_uni_pagedir;
-	vgacon_uni_pagedir[1]++;
-	if (!vgacon_uni_pagedir[0] && p)
+		c->vc_uni_pagedir_loc = &vgacon_uni_pagedir;
+		vgacon_refcount++;
+	}
+	if (!vgacon_uni_pagedir && p)
 		con_set_default_unimap(c);
 
 	/* Only set the default if the user didn't deliberately override it */
@@ -597,7 +598,7 @@ static void vgacon_deinit(struct vc_data *c)
 		vga_set_mem_top(c);
 	}
 
-	if (!--vgacon_uni_pagedir[1])
+	if (!--vgacon_refcount)
 		con_free_unimap(c);
 	c->vc_uni_pagedir_loc = &c->vc_uni_pagedir;
 	con_set_default_unimap(c);

commit 0ab3691fa8ac15ed94f9e2fa7c2958ab41d2e3f5
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jun 27 10:07:39 2013 +1000

    vgacon: fix missing include.
    
    This fixes the build error.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 0dd6d9625bb5..9d8feac67637 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -42,6 +42,7 @@
 #include <linux/kd.h>
 #include <linux/slab.h>
 #include <linux/vt_kern.h>
+#include <linux/sched.h>
 #include <linux/selection.h>
 #include <linux/spinlock.h>
 #include <linux/ioport.h>

commit 7e6d72c15ff4cc0c27573901bb05f9eddbd71ed4
Author: Marcelo Tosatti <mtosatti@redhat.com>
Date:   Thu Jun 20 18:05:56 2013 -0300

    vgacon.c: add cond reschedule points in vgacon_do_font_op
    
    Booting a 64-vcpu KVM guest, with CONFIG_PREEMPT_VOLUNTARY,
    can result in a soft lockup:
    
    BUG: soft lockup - CPU#41 stuck for 67s! [setfont:1505]
     RIP: 0010:[<ffffffff812c48da>]
    [<ffffffff812c48da>] vgacon_do_font_op.clone.0+0x1ba/0x550
    
    This is due to the 8192 (cmapsz) IO operations taking longer than expected
    due to lock contention in QEMU.
    
    Add conditional resched points in between writes allowing other tasks to
    execute.
    
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 5855d17d19ac..0dd6d9625bb5 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -1124,11 +1124,15 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 
 	if (arg) {
 		if (set)
-			for (i = 0; i < cmapsz; i++)
+			for (i = 0; i < cmapsz; i++) {
 				vga_writeb(arg[i], charmap + i);
+				cond_resched();
+			}
 		else
-			for (i = 0; i < cmapsz; i++)
+			for (i = 0; i < cmapsz; i++) {
 				arg[i] = vga_readb(charmap + i);
+				cond_resched();
+			}
 
 		/*
 		 * In 512-character mode, the character map is not contiguous if
@@ -1139,11 +1143,15 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 			charmap += 2 * cmapsz;
 			arg += cmapsz;
 			if (set)
-				for (i = 0; i < cmapsz; i++)
+				for (i = 0; i < cmapsz; i++) {
 					vga_writeb(arg[i], charmap + i);
+					cond_resched();
+				}
 			else
-				for (i = 0; i < cmapsz; i++)
+				for (i = 0; i < cmapsz; i++) {
 					arg[i] = vga_readb(charmap + i);
+					cond_resched();
+				}
 		}
 	}
 

commit 2a2483072393b27f4336ab068a1f48ca19ff1c1e
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jan 24 14:14:19 2013 +1000

    vgacon/vt: clear buffer attributes when we load a 512 character font (v2)
    
    When we switch from 256->512 byte font rendering mode, it means the
    current contents of the screen is being reinterpreted. The bit that holds
    the high bit of the 9-bit font, may have been previously set, and thus
    the new font misrenders.
    
    The problem case we see is grub2 writes spaces with the bit set, so it
    ends up with data like 0x820, which gets reinterpreted into 0x120 char
    which the font translates into G with a circumflex. This flashes up on
    screen at boot and is quite ugly.
    
    A current side effect of this patch though is that any rendering on the
    screen changes color to a slightly darker color, but at least the screen
    no longer corrupts.
    
    v2: as suggested by hpa, always clear the attribute space, whether we
    are are going to or from 512 chars.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index d449a74d4a31..5855d17d19ac 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -1064,7 +1064,7 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 	unsigned short video_port_status = vga_video_port_reg + 6;
 	int font_select = 0x00, beg, i;
 	char *charmap;
-	
+	bool clear_attribs = false;
 	if (vga_video_type != VIDEO_TYPE_EGAM) {
 		charmap = (char *) VGA_MAP_MEM(colourmap, 0);
 		beg = 0x0e;
@@ -1169,12 +1169,6 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 
 	/* if 512 char mode is already enabled don't re-enable it. */
 	if ((set) && (ch512 != vga_512_chars)) {
-		/* attribute controller */
-		for (i = 0; i < MAX_NR_CONSOLES; i++) {
-			struct vc_data *c = vc_cons[i].d;
-			if (c && c->vc_sw == &vga_con)
-				c->vc_hi_font_mask = ch512 ? 0x0800 : 0;
-		}
 		vga_512_chars = ch512;
 		/* 256-char: enable intensity bit
 		   512-char: disable intensity bit */
@@ -1185,8 +1179,22 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 		   it means, but it works, and it appears necessary */
 		inb_p(video_port_status);
 		vga_wattr(state->vgabase, VGA_AR_ENABLE_DISPLAY, 0);	
+		clear_attribs = true;
 	}
 	raw_spin_unlock_irq(&vga_lock);
+
+	if (clear_attribs) {
+		for (i = 0; i < MAX_NR_CONSOLES; i++) {
+			struct vc_data *c = vc_cons[i].d;
+			if (c && c->vc_sw == &vga_con) {
+				/* force hi font mask to 0, so we always clear
+				   the bit on either transition */
+				c->vc_hi_font_mask = 0x00;
+				clear_buffer_attributes(c);
+				c->vc_hi_font_mask = ch512 ? 0x0800 : 0;
+			}
+		}
+	}
 	return 0;
 }
 

commit 6b2c1800f1d3a608af952cfbd57f8f1a71c5d9b4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 25 16:17:02 2009 +0200

    locking, video: Annotate vga console lock as raw
    
    The vga_lock lock can be taken in atomic context and therefore
    cannot be preempted on -rt - annotate it.
    
    In mainline this change documents the low level nature of
    the lock - otherwise there's no functional difference. Lockdep
    and Sparse checking will work as usual.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 915fd74da7a2..d449a74d4a31 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -50,7 +50,7 @@
 #include <video/vga.h>
 #include <asm/io.h>
 
-static DEFINE_SPINLOCK(vga_lock);
+static DEFINE_RAW_SPINLOCK(vga_lock);
 static int cursor_size_lastfrom;
 static int cursor_size_lastto;
 static u32 vgacon_xres;
@@ -157,7 +157,7 @@ static inline void write_vga(unsigned char reg, unsigned int val)
 	 * ddprintk might set the console position from interrupt
 	 * handlers, thus the write has to be IRQ-atomic.
 	 */
-	spin_lock_irqsave(&vga_lock, flags);
+	raw_spin_lock_irqsave(&vga_lock, flags);
 
 #ifndef SLOW_VGA
 	v1 = reg + (val & 0xff00);
@@ -170,7 +170,7 @@ static inline void write_vga(unsigned char reg, unsigned int val)
 	outb_p(reg + 1, vga_video_port_reg);
 	outb_p(val & 0xff, vga_video_port_val);
 #endif
-	spin_unlock_irqrestore(&vga_lock, flags);
+	raw_spin_unlock_irqrestore(&vga_lock, flags);
 }
 
 static inline void vga_set_mem_top(struct vc_data *c)
@@ -664,7 +664,7 @@ static void vgacon_set_cursor_size(int xpos, int from, int to)
 	cursor_size_lastfrom = from;
 	cursor_size_lastto = to;
 
-	spin_lock_irqsave(&vga_lock, flags);
+	raw_spin_lock_irqsave(&vga_lock, flags);
 	if (vga_video_type >= VIDEO_TYPE_VGAC) {
 		outb_p(VGA_CRTC_CURSOR_START, vga_video_port_reg);
 		curs = inb_p(vga_video_port_val);
@@ -682,7 +682,7 @@ static void vgacon_set_cursor_size(int xpos, int from, int to)
 	outb_p(curs, vga_video_port_val);
 	outb_p(VGA_CRTC_CURSOR_END, vga_video_port_reg);
 	outb_p(cure, vga_video_port_val);
-	spin_unlock_irqrestore(&vga_lock, flags);
+	raw_spin_unlock_irqrestore(&vga_lock, flags);
 }
 
 static void vgacon_cursor(struct vc_data *c, int mode)
@@ -757,7 +757,7 @@ static int vgacon_doresize(struct vc_data *c,
 	unsigned int scanlines = height * c->vc_font.height;
 	u8 scanlines_lo = 0, r7 = 0, vsync_end = 0, mode, max_scan;
 
-	spin_lock_irqsave(&vga_lock, flags);
+	raw_spin_lock_irqsave(&vga_lock, flags);
 
 	vgacon_xres = width * VGA_FONTWIDTH;
 	vgacon_yres = height * c->vc_font.height;
@@ -808,7 +808,7 @@ static int vgacon_doresize(struct vc_data *c,
 		outb_p(vsync_end, vga_video_port_val);
 	}
 
-	spin_unlock_irqrestore(&vga_lock, flags);
+	raw_spin_unlock_irqrestore(&vga_lock, flags);
 	return 0;
 }
 
@@ -891,11 +891,11 @@ static void vga_vesa_blank(struct vgastate *state, int mode)
 {
 	/* save original values of VGA controller registers */
 	if (!vga_vesa_blanked) {
-		spin_lock_irq(&vga_lock);
+		raw_spin_lock_irq(&vga_lock);
 		vga_state.SeqCtrlIndex = vga_r(state->vgabase, VGA_SEQ_I);
 		vga_state.CrtCtrlIndex = inb_p(vga_video_port_reg);
 		vga_state.CrtMiscIO = vga_r(state->vgabase, VGA_MIS_R);
-		spin_unlock_irq(&vga_lock);
+		raw_spin_unlock_irq(&vga_lock);
 
 		outb_p(0x00, vga_video_port_reg);	/* HorizontalTotal */
 		vga_state.HorizontalTotal = inb_p(vga_video_port_val);
@@ -918,7 +918,7 @@ static void vga_vesa_blank(struct vgastate *state, int mode)
 
 	/* assure that video is enabled */
 	/* "0x20" is VIDEO_ENABLE_bit in register 01 of sequencer */
-	spin_lock_irq(&vga_lock);
+	raw_spin_lock_irq(&vga_lock);
 	vga_wseq(state->vgabase, VGA_SEQ_CLOCK_MODE, vga_state.ClockingMode | 0x20);
 
 	/* test for vertical retrace in process.... */
@@ -954,13 +954,13 @@ static void vga_vesa_blank(struct vgastate *state, int mode)
 	/* restore both index registers */
 	vga_w(state->vgabase, VGA_SEQ_I, vga_state.SeqCtrlIndex);
 	outb_p(vga_state.CrtCtrlIndex, vga_video_port_reg);
-	spin_unlock_irq(&vga_lock);
+	raw_spin_unlock_irq(&vga_lock);
 }
 
 static void vga_vesa_unblank(struct vgastate *state)
 {
 	/* restore original values of VGA controller registers */
-	spin_lock_irq(&vga_lock);
+	raw_spin_lock_irq(&vga_lock);
 	vga_w(state->vgabase, VGA_MIS_W, vga_state.CrtMiscIO);
 
 	outb_p(0x00, vga_video_port_reg);	/* HorizontalTotal */
@@ -985,7 +985,7 @@ static void vga_vesa_unblank(struct vgastate *state)
 	/* restore index/control registers */
 	vga_w(state->vgabase, VGA_SEQ_I, vga_state.SeqCtrlIndex);
 	outb_p(vga_state.CrtCtrlIndex, vga_video_port_reg);
-	spin_unlock_irq(&vga_lock);
+	raw_spin_unlock_irq(&vga_lock);
 }
 
 static void vga_pal_blank(struct vgastate *state)
@@ -1104,7 +1104,7 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 		charmap += 4 * cmapsz;
 #endif
 
-	spin_lock_irq(&vga_lock);
+	raw_spin_lock_irq(&vga_lock);
 	/* First, the Sequencer */
 	vga_wseq(state->vgabase, VGA_SEQ_RESET, 0x1);
 	/* CPU writes only to map 2 */
@@ -1120,7 +1120,7 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 	vga_wgfx(state->vgabase, VGA_GFX_MODE, 0x00);
 	/* map start at A000:0000 */
 	vga_wgfx(state->vgabase, VGA_GFX_MISC, 0x00);
-	spin_unlock_irq(&vga_lock);
+	raw_spin_unlock_irq(&vga_lock);
 
 	if (arg) {
 		if (set)
@@ -1147,7 +1147,7 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 		}
 	}
 
-	spin_lock_irq(&vga_lock);
+	raw_spin_lock_irq(&vga_lock);
 	/* First, the sequencer, Synchronous reset */
 	vga_wseq(state->vgabase, VGA_SEQ_RESET, 0x01);	
 	/* CPU writes to maps 0 and 1 */
@@ -1186,7 +1186,7 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 		inb_p(video_port_status);
 		vga_wattr(state->vgabase, VGA_AR_ENABLE_DISPLAY, 0);	
 	}
-	spin_unlock_irq(&vga_lock);
+	raw_spin_unlock_irq(&vga_lock);
 	return 0;
 }
 
@@ -1211,26 +1211,26 @@ static int vgacon_adjust_height(struct vc_data *vc, unsigned fontheight)
 	   registers; they are write-only on EGA, but it appears that they
 	   are all don't care bits on EGA, so I guess it doesn't matter. */
 
-	spin_lock_irq(&vga_lock);
+	raw_spin_lock_irq(&vga_lock);
 	outb_p(0x07, vga_video_port_reg);	/* CRTC overflow register */
 	ovr = inb_p(vga_video_port_val);
 	outb_p(0x09, vga_video_port_reg);	/* Font size register */
 	fsr = inb_p(vga_video_port_val);
-	spin_unlock_irq(&vga_lock);
+	raw_spin_unlock_irq(&vga_lock);
 
 	vde = maxscan & 0xff;	/* Vertical display end reg */
 	ovr = (ovr & 0xbd) +	/* Overflow register */
 	    ((maxscan & 0x100) >> 7) + ((maxscan & 0x200) >> 3);
 	fsr = (fsr & 0xe0) + (fontheight - 1);	/*  Font size register */
 
-	spin_lock_irq(&vga_lock);
+	raw_spin_lock_irq(&vga_lock);
 	outb_p(0x07, vga_video_port_reg);	/* CRTC overflow register */
 	outb_p(ovr, vga_video_port_val);
 	outb_p(0x09, vga_video_port_reg);	/* Font size */
 	outb_p(fsr, vga_video_port_val);
 	outb_p(0x12, vga_video_port_reg);	/* Vertical display limit */
 	outb_p(vde, vga_video_port_val);
-	spin_unlock_irq(&vga_lock);
+	raw_spin_unlock_irq(&vga_lock);
 	vga_video_font_height = fontheight;
 
 	for (i = 0; i < MAX_NR_CONSOLES; i++) {

commit 63b1dd07fa378f2683ad03e543c36ec76f489364
Author: Amerigo Wang <amwang@redhat.com>
Date:   Wed Jan 19 06:24:02 2011 +0000

    video: fix some comments in drivers/video/console/vgacon.c
    
    Now vgacon_scrollback_startup() uses slab, not bootmem,
    the comment above it is obsolete, so does __init_refok.
    
    Signed-off-by: WANG Cong <amwang@redhat.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index c97491b8b39b..915fd74da7a2 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -202,11 +202,7 @@ static void vgacon_scrollback_init(int pitch)
 	}
 }
 
-/*
- * Called only duing init so call of alloc_bootmen is ok.
- * Marked __init_refok to silence modpost.
- */
-static void __init_refok vgacon_scrollback_startup(void)
+static void vgacon_scrollback_startup(void)
 {
 	vgacon_scrollback = kcalloc(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE, 1024, GFP_NOWAIT);
 	vgacon_scrollback_init(vga_video_num_columns * 2);

commit 554ec37aca8f5fbe4d70df462d7032aaa5d95ae9
Author: Yannick Heneault <yannick_heneault@matrox.com>
Date:   Wed Jan 12 17:00:04 2011 -0800

    vgacon: check for efi machine
    
    It seems there is a small problem of VGA palette corruption on EFI
    machine.  When the kernel initializes the architecture, it checks if the
    machine is a EFI machine and assumes that a VGA console can exist.
    
    When it initializes the console in vgacon_startup it checks if it can
    really use the VGA console.  I think this is where a check is missing.
    Currently, the function can fail if a VESA boot mode is detected but not if
    a EFI boot mode was used.
    
    Thus vgacon_startup() doesn't fail and initialize the video card for a real
    VGA mode.  This function changes the first 16entries of the VGA palette.
    
    When the efifb driver kicks in, the palette is not restored to default
    ramp value, thus the 16 first entry remain in a modified state.  The
    following patch prevent this corruption.
    
    Signed-off-by: Yannick Heneault <yheneaul@matrox.com>
    Cc: Dave Airlie <airlied@linux.ie>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 915448ec75bf..c97491b8b39b 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -375,7 +375,8 @@ static const char *vgacon_startup(void)
 	u16 saved1, saved2;
 	volatile u16 *p;
 
-	if (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB) {
+	if (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB ||
+	    screen_info.orig_video_isVGA == VIDEO_TYPE_EFI) {
 	      no_vga:
 #ifdef CONFIG_DUMMY_CONSOLE
 		conswitchp = &dummy_con;

commit 451a3c24b0135bce54542009b5fde43846c7cf67
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Nov 17 16:26:55 2010 +0100

    BKL: remove extraneous #include <smp_lock.h>
    
    The big kernel lock has been removed from all these files at some point,
    leaving only the #include.
    
    Remove this too as a cleanup.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 54e32c513610..915448ec75bf 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -47,7 +47,6 @@
 #include <linux/ioport.h>
 #include <linux/init.h>
 #include <linux/screen_info.h>
-#include <linux/smp_lock.h>
 #include <video/vga.h>
 #include <asm/io.h>
 

commit 83ceb67d7dfe6aedf0e47dd6887b7b3c753542b2
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jun 1 22:53:03 2010 +0200

    tty: fix console_sem lock order
    
    vgacon_do_font_op releases and reacquires the BTM while holding
    console_sem. This violates the rule that BTM has to be the
    outer lock whenever we hold both.
    
    There does not seem to be any reason to give up the BTM here,
    so just stop doing that.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 71970057c118..54e32c513610 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -1108,7 +1108,6 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 		charmap += 4 * cmapsz;
 #endif
 
-	tty_unlock();
 	spin_lock_irq(&vga_lock);
 	/* First, the Sequencer */
 	vga_wseq(state->vgabase, VGA_SEQ_RESET, 0x1);
@@ -1192,7 +1191,6 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 		vga_wattr(state->vgabase, VGA_AR_ENABLE_DISPLAY, 0);	
 	}
 	spin_unlock_irq(&vga_lock);
-	tty_lock();
 	return 0;
 }
 

commit ec79d6056de58511d8e46d9ae59d3878f958dc3e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jun 1 22:53:01 2010 +0200

    tty: replace BKL with a new tty_lock
    
    As a preparation for replacing the big kernel lock
    in the TTY layer, wrap all the callers in new
    macros tty_lock, tty_lock_nested and tty_unlock.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 182dd6f8aadd..71970057c118 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -1108,7 +1108,7 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 		charmap += 4 * cmapsz;
 #endif
 
-	unlock_kernel();
+	tty_unlock();
 	spin_lock_irq(&vga_lock);
 	/* First, the Sequencer */
 	vga_wseq(state->vgabase, VGA_SEQ_RESET, 0x1);
@@ -1192,7 +1192,7 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 		vga_wattr(state->vgabase, VGA_AR_ENABLE_DISPLAY, 0);	
 	}
 	spin_unlock_irq(&vga_lock);
-	lock_kernel();
+	tty_lock();
 	return 0;
 }
 

commit 6aed359df4d82c38145d95957b741f0b08d24074
Author: Thiago Farina <tfransosi@gmail.com>
Date:   Fri Mar 5 13:44:17 2010 -0800

    console/vgacon.c: mark file-local symbol static
    
    warning: symbol 'vgacon_text_mode_force' was not declared. Should it be static?
    
    Signed-off-by: Thiago Farina <tfransosi@gmail.com>
    Acked-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index cc4bbbe44aca..182dd6f8aadd 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -112,7 +112,7 @@ static int 		vga_video_font_height;
 static int 		vga_scan_lines		__read_mostly;
 static unsigned int 	vga_rolled_over;
 
-int vgacon_text_mode_force = 0;
+static int vgacon_text_mode_force;
 
 bool vgacon_text_force(void)
 {

commit b434a680a29424856e0f40199daa9f65963c7cb4
Author: Matthew Garrett <mjg@redhat.com>
Date:   Fri Nov 13 14:57:02 2009 -0500

    vgacon: Add support for setting the default cursor state
    
    Pass the vga cursor state to the vt layer, ensuring that we don't hide
    the cursor when the bootloader has deliberately disabled it.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    LKML-Reference: <1258142222-16092-3-git-send-email-mjg@redhat.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 564643edb3c1..cc4bbbe44aca 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -586,7 +586,10 @@ static void vgacon_init(struct vc_data *c, int init)
 	if (!vgacon_uni_pagedir[0] && p)
 		con_set_default_unimap(c);
 
-	hide_boot_cursor(screen_info.flags & VIDEO_FLAGS_NOCURSOR);
+	/* Only set the default if the user didn't deliberately override it */
+	if (global_cursor_default == -1)
+		global_cursor_default =
+			!(screen_info.flags & VIDEO_FLAGS_NOCURSOR);
 }
 
 static void vgacon_deinit(struct vc_data *c)

commit f6c06b6807ff9281295989ebad72523865325a4f
Author: Matthew Garrett <mjg@redhat.com>
Date:   Fri Nov 13 15:14:11 2009 -0500

    vc: Add support for hiding the cursor when creating VTs
    
    Add support for setting a global default for whether or not a visible
    cursor should be enabled when creating VCs. The default will be to do so,
    unless overridden by the user at boot time or by a driver.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    LKML-Reference: <1258143251-5818-1-git-send-email-mjg@redhat.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index da55ccaf4d55..564643edb3c1 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -585,6 +585,8 @@ static void vgacon_init(struct vc_data *c, int init)
 	vgacon_uni_pagedir[1]++;
 	if (!vgacon_uni_pagedir[0] && p)
 		con_set_default_unimap(c);
+
+	hide_boot_cursor(screen_info.flags & VIDEO_FLAGS_NOCURSOR);
 }
 
 static void vgacon_deinit(struct vc_data *c)

commit f0c7d2b72ad1a694c0c886a14cc708841181e9bd
Author: Francisco Jerez <currojerez@riseup.net>
Date:   Tue Sep 22 16:47:53 2009 -0700

    vgacon: prevent vgacon_deinit from touching the hardware for inactive consoles.
    
    fbcon makes the (reasonable) assumption that it only needs to program the
    hardware once, when fbcon_init() is called for the foreground console.
    
    This doesn't always play well with vgacon because vgacon_deinit() is only
    doing its job when the last console it owns is closed (when switching from
    vgacon to fbcon, that's usually *after* fbcon_init() has set the new
    mode).
    
    Depending on the hardware this can cause the wrong framebuffer location to
    be scanned out (e.g.  reproduced on nv05 with the nouveau framebuffer
    driver).
    
    Signed-off-by: Francisco Jerez <currojerez@riseup.net>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Krzysztof Helt <krzysztof.h1@poczta.fm>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 74e96cf83b7e..da55ccaf4d55 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -589,12 +589,14 @@ static void vgacon_init(struct vc_data *c, int init)
 
 static void vgacon_deinit(struct vc_data *c)
 {
-	/* When closing the last console, reset video origin */
-	if (!--vgacon_uni_pagedir[1]) {
+	/* When closing the active console, reset video origin */
+	if (CON_IS_VISIBLE(c)) {
 		c->vc_visible_origin = vga_vram_base;
 		vga_set_mem_top(c);
-		con_free_unimap(c);
 	}
+
+	if (!--vgacon_uni_pagedir[1])
+		con_free_unimap(c);
 	c->vc_uni_pagedir_loc = &c->vc_uni_pagedir;
 	con_set_default_unimap(c);
 }

commit 6d6c971778c5257fc815e1ebe01779fefda6293c
Author: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
Date:   Sun Sep 20 15:28:01 2009 +0530

    includecheck fix: drivers/video, vgacon.c
    
    fix the following 'make includecheck' warning:
    
      drivers/video/console/vgacon.c: linux/slab.h is included more than once.
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
    Cc: Martin Mares <mj@ucw.cz>
    Cc: mchehab@infradead.org
    Cc: Sam Ravnborg <sam@ravnborg.org>
    LKML-Reference: <1247067624.4382.88.camel@ht.satnam>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 59d7d5ec17a4..74e96cf83b7e 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -180,7 +180,6 @@ static inline void vga_set_mem_top(struct vc_data *c)
 }
 
 #ifdef CONFIG_VGACON_SOFT_SCROLLBACK
-#include <linux/slab.h>
 /* software scrollback */
 static void *vgacon_scrollback;
 static int vgacon_scrollback_tail;

commit b8ec757390282e21d349bf6b602a8cb182da0429
Author: Pekka Enberg <penberg@cs.helsinki.fi>
Date:   Thu Jun 11 19:25:37 2009 +0300

    vgacon: use slab allocator instead of the bootmem allocator
    
    Slab is initialized before the console subsystem so use the slab allocator in
    vgacon_scrollback_startup().
    
    Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 38e86b84dce0..59d7d5ec17a4 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -180,7 +180,7 @@ static inline void vga_set_mem_top(struct vc_data *c)
 }
 
 #ifdef CONFIG_VGACON_SOFT_SCROLLBACK
-#include <linux/bootmem.h>
+#include <linux/slab.h>
 /* software scrollback */
 static void *vgacon_scrollback;
 static int vgacon_scrollback_tail;
@@ -210,8 +210,7 @@ static void vgacon_scrollback_init(int pitch)
  */
 static void __init_refok vgacon_scrollback_startup(void)
 {
-	vgacon_scrollback = alloc_bootmem(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE
-					  * 1024);
+	vgacon_scrollback = kcalloc(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE, 1024, GFP_NOWAIT);
 	vgacon_scrollback_init(vga_video_num_columns * 2);
 }
 

commit b175dc09285b36200a83b78baf167905181fb4e5
Author: Stefan Bader <stefan.bader@canonical.com>
Date:   Thu Apr 30 15:08:44 2009 -0700

    vgacon: return the upper half of 512 character fonts
    
    Uwe Geuder noted that he gets random bitmaps on a text console if he tried
    to type extended characters (like the e acute).  For him everything above
    unicode 0xa0 was corrupted.
    
    After some digging there seems to be a little culprit in vgacon since the
    beginning of ages (well git).  The function vgacon_font_get will store the
    number of characters correctly in font->charcount but then calls to
    vgacon_do_font_op(..., 0, 0).  Which means only the lower 256 characters
    are actually stored to the fontdata.  The rest is left untouched.  So the
    next time that saved data is used, the garbled font appears.  This happens
    on every switch between text consoles.
    
    Addresses https://bugs.launchpad.net/ubuntu/+source/linux/+bug/355057
    
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>
    Tested-by: Uwe Geuder <ubuntuLp-ugeuder@sneakemail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index d012edda6d11..38e86b84dce0 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -1282,7 +1282,7 @@ static int vgacon_font_get(struct vc_data *c, struct console_font *font)
 	font->charcount = vga_512_chars ? 512 : 256;
 	if (!font->data)
 		return 0;
-	return vgacon_do_font_op(&state, font->data, 0, 0);
+	return vgacon_do_font_op(&state, font->data, 0, vga_512_chars);
 }
 
 #else

commit 025dfdafe77f20b3890981a394774baab7b9c827
Author: Frederik Schwarzer <schwarzerf@gmail.com>
Date:   Thu Oct 16 19:02:37 2008 +0200

    trivial: fix then -> than typos in comments and documentation
    
    - (better, more, bigger ...) then -> (...) than
    
    Signed-off-by: Frederik Schwarzer <schwarzerf@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index e6210725b9ab..d012edda6d11 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -1332,7 +1332,7 @@ static void vgacon_save_screen(struct vc_data *c)
 		c->vc_y = screen_info.orig_y;
 	}
 
-	/* We can't copy in more then the size of the video buffer,
+	/* We can't copy in more than the size of the video buffer,
 	 * or we'll be copying in VGA BIOS */
 
 	if (!vga_is_gfx)

commit f453ba0460742ad027ae0c4c7d61e62817b3e7ef
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Nov 7 14:05:41 2008 -0800

    DRM: add mode setting support
    
    Add mode setting support to the DRM layer.
    
    This is a fairly big chunk of work that allows DRM drivers to provide
    full output control and configuration capabilities to userspace.  It was
    motivated by several factors:
      - the fb layer's APIs aren't suited for anything but simple
        configurations
      - coordination between the fb layer, DRM layer, and various userspace
        drivers is poor to non-existent (radeonfb excepted)
      - user level mode setting drivers makes displaying panic & oops
        messages more difficult
      - suspend/resume of graphics state is possible in many more
        configurations with kernel level support
    
    This commit just adds the core DRM part of the mode setting APIs.
    Driver specific commits using these new structure and APIs will follow.
    
    Co-authors: Jesse Barnes <jbarnes@virtuousgeek.org>, Jakob Bornecrantz <jakob@tungstengraphics.com>
    Contributors: Alan Hourihane <alanh@tungstengraphics.com>, Maarten Maathuis <madman2003@gmail.com>
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 448d209a0bf2..e6210725b9ab 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -112,6 +112,23 @@ static int 		vga_video_font_height;
 static int 		vga_scan_lines		__read_mostly;
 static unsigned int 	vga_rolled_over;
 
+int vgacon_text_mode_force = 0;
+
+bool vgacon_text_force(void)
+{
+	return vgacon_text_mode_force ? true : false;
+}
+EXPORT_SYMBOL(vgacon_text_force);
+
+static int __init text_mode(char *str)
+{
+	vgacon_text_mode_force = 1;
+	return 1;
+}
+
+/* force text mode - used by kernel modesetting */
+__setup("nomodeset", text_mode);
+
 static int __init no_scroll(char *str)
 {
 	/*

commit 5ab4840968cd094586f65fce978e35c66d25ac78
Author: Marcin Slusarz <marcin.slusarz@gmail.com>
Date:   Wed Oct 15 22:03:50 2008 -0700

    vgacon: vgacon_scrolldelta simplification
    
    There's no point in checking diff == c->vc_rows, because it can be true
    only when count == 0, but we already checked that.  Additionally move
    variables used only in one block to this block.
    
    Signed-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>
    Cc: Antonino Daplas <adaplas@gmail.com>
    Acked-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 3556268fe0a0..448d209a0bf2 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -239,8 +239,7 @@ static void vgacon_restore_screen(struct vc_data *c)
 
 static int vgacon_scrolldelta(struct vc_data *c, int lines)
 {
-	int start, end, count, soff, diff;
-	void *d, *s;
+	int start, end, count, soff;
 
 	if (!lines) {
 		c->vc_visible_origin = c->vc_origin;
@@ -287,13 +286,13 @@ static int vgacon_scrolldelta(struct vc_data *c, int lines)
 	if (count > c->vc_rows)
 		count = c->vc_rows;
 
-	diff = c->vc_rows - count;
-
-	d = (void *) c->vc_origin;
-	s = (void *) c->vc_screenbuf;
-
 	if (count) {
 		int copysize;
+
+		int diff = c->vc_rows - count;
+		void *d = (void *) c->vc_origin;
+		void *s = (void *) c->vc_screenbuf;
+
 		count *= c->vc_size_row;
 		/* how much memory to end of buffer left? */
 		copysize = min(count, vgacon_scrollback_size - soff);
@@ -305,14 +304,11 @@ static int vgacon_scrolldelta(struct vc_data *c, int lines)
 			scr_memcpyw(d, vgacon_scrollback, count);
 			d += count;
 		}
-	}
 
-	if (diff == c->vc_rows) {
-		vgacon_cursor(c, CM_MOVE);
-	} else {
 		if (diff)
 			scr_memcpyw(d, s, diff * c->vc_size_row);
-	}
+	} else
+		vgacon_cursor(c, CM_MOVE);
 
 	return 1;
 }

commit c38182a713df5268d8a4a33819a77f93b950f84c
Author: Marcin Slusarz <marcin.slusarz@gmail.com>
Date:   Wed Oct 15 22:03:49 2008 -0700

    vgacon: optimize scrolling
    
    Join multiple scr_memcpyw into 1-3 calls (usually 2).  (benchmarked
    average speedup: 1%)
    
    Signed-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>
    Cc: Krzysztof Helt <krzysztof.h1@poczta.fm>
    Cc: Antonino Daplas <adaplas@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 6df29a62d720..3556268fe0a0 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -292,23 +292,26 @@ static int vgacon_scrolldelta(struct vc_data *c, int lines)
 	d = (void *) c->vc_origin;
 	s = (void *) c->vc_screenbuf;
 
-	while (count--) {
-		scr_memcpyw(d, vgacon_scrollback + soff, c->vc_size_row);
-		d += c->vc_size_row;
-		soff += c->vc_size_row;
-
-		if (soff >= vgacon_scrollback_size)
-			soff = 0;
+	if (count) {
+		int copysize;
+		count *= c->vc_size_row;
+		/* how much memory to end of buffer left? */
+		copysize = min(count, vgacon_scrollback_size - soff);
+		scr_memcpyw(d, vgacon_scrollback + soff, copysize);
+		d += copysize;
+		count -= copysize;
+
+		if (count) {
+			scr_memcpyw(d, vgacon_scrollback, count);
+			d += count;
+		}
 	}
 
 	if (diff == c->vc_rows) {
 		vgacon_cursor(c, CM_MOVE);
 	} else {
-		while (diff--) {
-			scr_memcpyw(d, s, c->vc_size_row);
-			d += c->vc_size_row;
-			s += c->vc_size_row;
-		}
+		if (diff)
+			scr_memcpyw(d, s, diff * c->vc_size_row);
 	}
 
 	return 1;

commit 93f78da405685a756beeaeae4b5e41fcec39eab3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 14 12:12:02 2008 -0700

    Revert "vt: fix background color on line feed"
    
    This reverts commit c9e587abfdec2c2aaa55fab83bcb4972e2f84f9b, and the
    subsequent commits that fixed it up:
    
     - afa9b649 "fbcon: prevent cursor disappearance after switching to 512
       character font"
    
     - d850a2fa "vt/fbcon: fix background color on line feed"
    
     - 7fe3915a "vt/fbcon: update scrl_erase_char after 256/512-glyph font
       switch"
    
    by request of Alan Cox. Quoth Alan:
      "Unfortunately it's wrong and its been causing breakages because
       various apps like ncurses expect our previous (and correct)
       behaviour."
    
    Alexander sent out a similar patch.
    
    Requested-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Tested-by: Jan Engelhardt <jengelh@medozas.de>
    Cc: Alexander V. Lukyanov <lav@netis.ru>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index bd1f57b259d9..6df29a62d720 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -1350,7 +1350,7 @@ static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,
 		} else
 			c->vc_origin += delta;
 		scr_memsetw((u16 *) (c->vc_origin + c->vc_screenbuf_size -
-				     delta), c->vc_scrl_erase_char,
+				     delta), c->vc_video_erase_char,
 			    delta);
 	} else {
 		if (oldo - delta < vga_vram_base) {
@@ -1363,7 +1363,7 @@ static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,
 		} else
 			c->vc_origin -= delta;
 		c->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;
-		scr_memsetw((u16 *) (c->vc_origin), c->vc_scrl_erase_char,
+		scr_memsetw((u16 *) (c->vc_origin), c->vc_video_erase_char,
 			    delta);
 	}
 	c->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;

commit c9e587abfdec2c2aaa55fab83bcb4972e2f84f9b
Author: Jan Engelhardt <jengelh@computergmbh.de>
Date:   Tue Apr 29 00:59:46 2008 -0700

    vt: fix background color on line feed
    
    A command that causes a line feed while a background color is active,
    such as
    
            perl -e 'print "x" x 60, "\e[44m", "x" x 40, "\e[0m\n"'
    and
            perl -e 'print "x" x 40, "\e[44m\n", "x" x 40, "\e[0m\n"'
    
    causes the line that was started as a result of the line feed to be completely
    filled with the currently active background color instead of the default
    color.
    
    When scrolling, part of the current screen is memcpy'd/memmove'd to the new
    region, and the new line(s) that will appear as a result are cleared using
    memset.  However, the lines are cleared with vc->vc_video_erase_char, causing
    them to be colored with the currently active background color.  This is
    different from X11 terminal emulators which always paint the new lines with
    the default background color (e.g.  `xterm -bg black`).
    
    The clear operation (\e[1J and \e[2J) also use vc_video_erase_char, so a new
    vc->vc_scrl_erase_char is introduced with contains the erase character used
    for scrolling, which is built from vc->vc_def_color instead of vc->vc_color.
    
    Signed-off-by: Jan Engelhardt <jengelh@computergmbh.de>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 6df29a62d720..bd1f57b259d9 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -1350,7 +1350,7 @@ static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,
 		} else
 			c->vc_origin += delta;
 		scr_memsetw((u16 *) (c->vc_origin + c->vc_screenbuf_size -
-				     delta), c->vc_video_erase_char,
+				     delta), c->vc_scrl_erase_char,
 			    delta);
 	} else {
 		if (oldo - delta < vga_vram_base) {
@@ -1363,7 +1363,7 @@ static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,
 		} else
 			c->vc_origin -= delta;
 		c->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;
-		scr_memsetw((u16 *) (c->vc_origin), c->vc_video_erase_char,
+		scr_memsetw((u16 *) (c->vc_origin), c->vc_scrl_erase_char,
 			    delta);
 	}
 	c->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;

commit cbfb3e09c5f5cc21994fd06abb5b5839589d5b9a
Author: Marcin Slusarz <marcin.slusarz@gmail.com>
Date:   Wed Feb 6 01:39:12 2008 -0800

    vgacon: fix sparse warning about shadowing 'i' symbol
    
    Signed-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index f65bcd314d54..6df29a62d720 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -1153,8 +1153,6 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 
 	/* if 512 char mode is already enabled don't re-enable it. */
 	if ((set) && (ch512 != vga_512_chars)) {
-		int i;	
-		
 		/* attribute controller */
 		for (i = 0; i < MAX_NR_CONSOLES; i++) {
 			struct vc_data *c = vc_cons[i].d;

commit 3ea335100014785fd2518461705654b200e58d00
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Tue Oct 16 22:36:04 2007 -0700

    Remove magic macros for screen_info structure members
    
    Stop using magic macros for screen_info structure members.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index a5698714d43d..f65bcd314d54 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -362,7 +362,7 @@ static const char *vgacon_startup(void)
 	u16 saved1, saved2;
 	volatile u16 *p;
 
-	if (ORIG_VIDEO_ISVGA == VIDEO_TYPE_VLFB) {
+	if (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB) {
 	      no_vga:
 #ifdef CONFIG_DUMMY_CONSOLE
 		conswitchp = &dummy_con;
@@ -373,28 +373,29 @@ static const char *vgacon_startup(void)
 	}
 
 	/* boot_params.screen_info initialized? */
-	if ((ORIG_VIDEO_MODE  == 0) &&
-	    (ORIG_VIDEO_LINES == 0) &&
-	    (ORIG_VIDEO_COLS  == 0))
+	if ((screen_info.orig_video_mode  == 0) &&
+	    (screen_info.orig_video_lines == 0) &&
+	    (screen_info.orig_video_cols  == 0))
 		goto no_vga;
 
 	/* VGA16 modes are not handled by VGACON */
-	if ((ORIG_VIDEO_MODE == 0x0D) ||	/* 320x200/4 */
-	    (ORIG_VIDEO_MODE == 0x0E) ||	/* 640x200/4 */
-	    (ORIG_VIDEO_MODE == 0x10) ||	/* 640x350/4 */
-	    (ORIG_VIDEO_MODE == 0x12) ||	/* 640x480/4 */
-	    (ORIG_VIDEO_MODE == 0x6A))	/* 800x600/4, 0x6A is very common */
+	if ((screen_info.orig_video_mode == 0x0D) ||	/* 320x200/4 */
+	    (screen_info.orig_video_mode == 0x0E) ||	/* 640x200/4 */
+	    (screen_info.orig_video_mode == 0x10) ||	/* 640x350/4 */
+	    (screen_info.orig_video_mode == 0x12) ||	/* 640x480/4 */
+	    (screen_info.orig_video_mode == 0x6A))	/* 800x600/4 (VESA) */
 		goto no_vga;
 
-	vga_video_num_lines = ORIG_VIDEO_LINES;
-	vga_video_num_columns = ORIG_VIDEO_COLS;
+	vga_video_num_lines = screen_info.orig_video_lines;
+	vga_video_num_columns = screen_info.orig_video_cols;
 	state.vgabase = NULL;
 
-	if (ORIG_VIDEO_MODE == 7) {	/* Is this a monochrome display? */
+	if (screen_info.orig_video_mode == 7) {
+		/* Monochrome display */
 		vga_vram_base = 0xb0000;
 		vga_video_port_reg = VGA_CRT_IM;
 		vga_video_port_val = VGA_CRT_DM;
-		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10) {
+		if ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {
 			static struct resource ega_console_resource =
 			    { .name = "ega", .start = 0x3B0, .end = 0x3BF };
 			vga_video_type = VIDEO_TYPE_EGAM;
@@ -422,12 +423,12 @@ static const char *vgacon_startup(void)
 		vga_vram_base = 0xb8000;
 		vga_video_port_reg = VGA_CRT_IC;
 		vga_video_port_val = VGA_CRT_DC;
-		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10) {
+		if ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {
 			int i;
 
 			vga_vram_size = 0x8000;
 
-			if (!ORIG_VIDEO_ISVGA) {
+			if (!screen_info.orig_video_isVGA) {
 				static struct resource ega_console_resource
 				    = { .name = "ega", .start = 0x3C0, .end = 0x3DF };
 				vga_video_type = VIDEO_TYPE_EGAC;
@@ -521,14 +522,14 @@ static const char *vgacon_startup(void)
 	    || vga_video_type == VIDEO_TYPE_VGAC
 	    || vga_video_type == VIDEO_TYPE_EGAM) {
 		vga_hardscroll_enabled = vga_hardscroll_user_enable;
-		vga_default_font_height = ORIG_VIDEO_POINTS;
-		vga_video_font_height = ORIG_VIDEO_POINTS;
+		vga_default_font_height = screen_info.orig_video_points;
+		vga_video_font_height = screen_info.orig_video_points;
 		/* This may be suboptimal but is a safe bet - go with it */
 		vga_scan_lines =
 		    vga_video_font_height * vga_video_num_lines;
 	}
 
-	vgacon_xres = ORIG_VIDEO_COLS * VGA_FONTWIDTH;
+	vgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;
 	vgacon_yres = vga_scan_lines;
 
 	if (!vga_init_done) {
@@ -798,7 +799,7 @@ static int vgacon_switch(struct vc_data *c)
 {
 	int x = c->vc_cols * VGA_FONTWIDTH;
 	int y = c->vc_rows * c->vc_font.height;
-	int rows = ORIG_VIDEO_LINES * vga_default_font_height/
+	int rows = screen_info.orig_video_lines * vga_default_font_height/
 		c->vc_font.height;
 	/*
 	 * We need to save screen size here as it's the only way
@@ -818,7 +819,7 @@ static int vgacon_switch(struct vc_data *c)
 
 		if ((vgacon_xres != x || vgacon_yres != y) &&
 		    (!(vga_video_num_columns % 2) &&
-		     vga_video_num_columns <= ORIG_VIDEO_COLS &&
+		     vga_video_num_columns <= screen_info.orig_video_cols &&
 		     vga_video_num_lines <= rows))
 			vgacon_doresize(c, c->vc_cols, c->vc_rows);
 	}
@@ -1280,8 +1281,8 @@ static int vgacon_font_get(struct vc_data *c, struct console_font *font)
 static int vgacon_resize(struct vc_data *c, unsigned int width,
 			 unsigned int height, unsigned int user)
 {
-	if (width % 2 || width > ORIG_VIDEO_COLS ||
-	    height > (ORIG_VIDEO_LINES * vga_default_font_height)/
+	if (width % 2 || width > screen_info.orig_video_cols ||
+	    height > (screen_info.orig_video_lines * vga_default_font_height)/
 	    c->vc_font.height)
 		/* let svgatextmode tinker with video timings and
 		   return success */
@@ -1313,8 +1314,8 @@ static void vgacon_save_screen(struct vc_data *c)
 		 * console initialization routines.
 		 */
 		vga_bootup_console = 1;
-		c->vc_x = ORIG_X;
-		c->vc_y = ORIG_Y;
+		c->vc_x = screen_info.orig_x;
+		c->vc_y = screen_info.orig_y;
 	}
 
 	/* We can't copy in more then the size of the video buffer,

commit 30c826451d3e5bbc6e11bba0e7fee5d2f49d9b75
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Mon Oct 15 17:13:22 2007 -0700

    [x86] remove uses of magic macros for boot_params access
    
    Instead of using magic macros for boot_params access, simply use the
    boot_params structure.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index e9afb7ebd566..a5698714d43d 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -372,7 +372,7 @@ static const char *vgacon_startup(void)
 #endif
 	}
 
-	/* SCREEN_INFO initialized? */
+	/* boot_params.screen_info initialized? */
 	if ((ORIG_VIDEO_MODE  == 0) &&
 	    (ORIG_VIDEO_LINES == 0) &&
 	    (ORIG_VIDEO_COLS  == 0))

commit e400b6ec4ede4dc0aa8e5640425df5b29796fe0e
Author: Antonino A. Daplas <adaplas@gmail.com>
Date:   Tue Oct 16 01:29:35 2007 -0700

    vt/vgacon: Check if screen resize request comes from userspace
    
    Various console drivers are able to resize the screen via the con_resize()
    hook.  This hook is also visible in userspace via the TIOCWINSZ, VT_RESIZE and
    VT_RESIZEX ioctl's.  One particular utility, SVGATextMode, expects that
    con_resize() of the VGA console will always return success even if the
    resulting screen is not compatible with the hardware.  However, this
    particular behavior of the VGA console, as reported in Kernel Bugzilla Bug
    7513, can cause undefined behavior if the user starts with a console size
    larger than 80x25.
    
    To work around this problem, add an extra parameter to con_resize().  This
    parameter is ignored by drivers except for vgacon.  If this parameter is
    non-zero, then the resize request came from a VT_RESIZE or VT_RESIZEX ioctl
    and vgacon will always return success.  If this parameter is zero, vgacon will
    return -EINVAL if the requested size is not compatible with the hardware.  The
    latter is the more correct behavior.
    
    With this change, SVGATextMode should still work correctly while in-kernel and
    stty resize calls can expect correct behavior from vgacon.
    
    Signed-off-by: Antonino Daplas <adaplas@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index d18b73aafa0d..e9afb7ebd566 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -1278,13 +1278,14 @@ static int vgacon_font_get(struct vc_data *c, struct console_font *font)
 #endif
 
 static int vgacon_resize(struct vc_data *c, unsigned int width,
-				unsigned int height)
+			 unsigned int height, unsigned int user)
 {
 	if (width % 2 || width > ORIG_VIDEO_COLS ||
 	    height > (ORIG_VIDEO_LINES * vga_default_font_height)/
 	    c->vc_font.height)
-		/* let svgatextmode tinker with video timings */
-		return 0;
+		/* let svgatextmode tinker with video timings and
+		   return success */
+		return (user) ? 0 : -EINVAL;
 
 	if (CON_IS_VISIBLE(c) && !vga_is_gfx) /* who knows */
 		vgacon_doresize(c, width, height);

commit 80e27982a66ea8306a704ba8bdf634ed480d4b46
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jul 21 04:37:31 2007 -0700

    console: fix section mismatch warning in vgacon.c
    
    Fix following section mismatch warning:
    WARNING: vmlinux.o(.text+0x121e62): Section mismatch: reference to .init.text:__alloc_bootmem (between 'vgacon_startup' and 'vgacon_scrolldelta')
    
    Browsing the code it seems that vgacon_scrollback_startup() is only called
    during the init phase so the reference to the .init.text section is OK.
    
    Teach modpost not to warn using ___init_refok.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: "Antonino A. Daplas" <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index f46fe95f69fb..d18b73aafa0d 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -187,7 +187,11 @@ static void vgacon_scrollback_init(int pitch)
 	}
 }
 
-static void vgacon_scrollback_startup(void)
+/*
+ * Called only duing init so call of alloc_bootmen is ok.
+ * Marked __init_refok to silence modpost.
+ */
+static void __init_refok vgacon_scrollback_startup(void)
 {
 	vgacon_scrollback = alloc_bootmem(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE
 					  * 1024);

commit a1a4849c419337f649c6633219b555eb4d4d955a
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Wed May 16 22:11:09 2007 -0700

    Refine SCREEN_INFO sanity check for vgacon initialization
    
    Refine SCREEN_INFO sanity check for vgacon initialization.
    
    Checking video mode field only to see whenever SCREEN_INFO is
    initialized is not enougth, in some cases it is zero although
    a vga card is present.  Lets additionally check cols and lines.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Alan <alan@lxorguk.ukuu.org.uk>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: Eric W. Biederman <ebiederm@xmission.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 2460b82a1d93..f46fe95f69fb 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -368,9 +368,14 @@ static const char *vgacon_startup(void)
 #endif
 	}
 
+	/* SCREEN_INFO initialized? */
+	if ((ORIG_VIDEO_MODE  == 0) &&
+	    (ORIG_VIDEO_LINES == 0) &&
+	    (ORIG_VIDEO_COLS  == 0))
+		goto no_vga;
+
 	/* VGA16 modes are not handled by VGACON */
-	if ((ORIG_VIDEO_MODE == 0x00) ||	/* SCREEN_INFO not initialized */
-	    (ORIG_VIDEO_MODE == 0x0D) ||	/* 320x200/4 */
+	if ((ORIG_VIDEO_MODE == 0x0D) ||	/* 320x200/4 */
 	    (ORIG_VIDEO_MODE == 0x0E) ||	/* 640x200/4 */
 	    (ORIG_VIDEO_MODE == 0x10) ||	/* 640x350/4 */
 	    (ORIG_VIDEO_MODE == 0x12) ||	/* 640x480/4 */

commit 2ae854777592856ad8ce4d4cdb6114804e2e28f6
Author: Antonino A. Daplas <adaplas@gmail.com>
Date:   Tue May 8 00:40:06 2007 -0700

    vgacon: disallow console operations when in KD_GRAPHICS mode
    
    Reported by James Pearson as:
    
             boot to run level 3
    
             if not root, then make sure /dev/console is writeable
    
             login and type:
    
             setterm -blank 0
    
             start X
    
             type into an xterm:
    
             while true; do echo "" > /dev/console; usleep 100000; done
    
             while the above loop is running switch to the text console and back
             again (Ctrl-Alt-F1 then Ctrl-Alt-F7)
    
             ... and the screen will be shifting (and wrapping) to the left.
    
    This problem stems from continuously writing text to the system console (which
    is in KD_TEXT mode) while the foreground console is in KD_GRAPHICS
    mode. Somewhere along the way, console printing got confused and omitted the
    KD_GRAPHICS/KD_TEXT test.  Thus, vgacon attempted to scroll the screen of X,
    which causes X to shift.
    
    Fix by disallowing vgacon to touch the hardware when the vc is in KD_GRAPHICS
    mode. A definitive fix entails a full audit of the console code.
    
    Signed-off-by: Antonino Daplas <adaplas@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index d0d2733ef479..2460b82a1d93 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -660,6 +660,9 @@ static void vgacon_set_cursor_size(int xpos, int from, int to)
 
 static void vgacon_cursor(struct vc_data *c, int mode)
 {
+	if (c->vc_mode != KD_TEXT)
+		return;
+
 	vgacon_restore_screen(c);
 
 	switch (mode) {
@@ -1318,7 +1321,7 @@ static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,
 	unsigned long oldo;
 	unsigned int delta;
 
-	if (t || b != c->vc_rows || vga_is_gfx)
+	if (t || b != c->vc_rows || vga_is_gfx || c->vc_mode != KD_TEXT)
 		return 0;
 
 	if (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)

commit cf36a65b08969d3cff3c1c878b7e0fdf148379b7
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Tue May 8 00:38:05 2007 -0700

    vt-add-color-support-to-the-underline-and-italic-attributes-fix
    
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Cc: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 53c22197b631..d0d2733ef479 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -86,8 +86,6 @@ static int vgacon_set_origin(struct vc_data *c);
 static void vgacon_save_screen(struct vc_data *c);
 static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,
 			 int lines);
-static u8 vgacon_build_attr(struct vc_data *c, u8 color, u8 intensity,
-			    u8 blink, u8 underline, u8 reverse, u8);
 static void vgacon_invert_region(struct vc_data *c, u16 * p, int count);
 static unsigned long vgacon_uni_pagedir[2];
 

commit fa6ce9ab5fbcb4c276c48861584b70d387e787b3
Author: Jan Engelhardt <jengelh@linux01.gwdg.de>
Date:   Tue May 8 00:38:04 2007 -0700

    vt: add color support to the "underline" and "italic" attributes
    
    Add color support to the "underline" and "italic" attributes as in
    OpenBSD/NetBSD-style (vt220) and xterm.
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Acked-by: "Antonino A. Daplas" <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 3e67c34df9a5..53c22197b631 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -87,7 +87,7 @@ static void vgacon_save_screen(struct vc_data *c);
 static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,
 			 int lines);
 static u8 vgacon_build_attr(struct vc_data *c, u8 color, u8 intensity,
-			    u8 blink, u8 underline, u8 reverse);
+			    u8 blink, u8 underline, u8 reverse, u8);
 static void vgacon_invert_region(struct vc_data *c, u16 * p, int count);
 static unsigned long vgacon_uni_pagedir[2];
 
@@ -578,12 +578,14 @@ static void vgacon_deinit(struct vc_data *c)
 }
 
 static u8 vgacon_build_attr(struct vc_data *c, u8 color, u8 intensity,
-			    u8 blink, u8 underline, u8 reverse)
+			    u8 blink, u8 underline, u8 reverse, u8 italic)
 {
 	u8 attr = color;
 
 	if (vga_can_do_color) {
-		if (underline)
+		if (italic)
+			attr = (attr & 0xF0) | c->vc_itcolor;
+		else if (underline)
 			attr = (attr & 0xf0) | c->vc_ulcolor;
 		else if (intensity == 0)
 			attr = (attr & 0xf0) | c->vc_halfcolor;
@@ -597,7 +599,9 @@ static u8 vgacon_build_attr(struct vc_data *c, u8 color, u8 intensity,
 	if (intensity == 2)
 		attr ^= 0x08;
 	if (!vga_can_do_color) {
-		if (underline)
+		if (italic)
+			attr = (attr & 0xF8) | 0x02;
+		else if (underline)
 			attr = (attr & 0xf8) | 0x01;
 		else if (intensity == 0)
 			attr = (attr & 0xf0) | 0x08;

commit f82af20e1a028e16b9bb11da081fa1148d40fa6a
Author: Gerd Hoffmann <kraxel@suse.de>
Date:   Wed May 2 19:27:19 2007 +0200

    [PATCH] x86-64: ignore vgacon if hardware not present
    
    Avoid trying to set up vgacon if there's no vga hardware present.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@xensource.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Cc: Alan <alan@lxorguk.ukuu.org.uk>
    Acked-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 91a20785108a..3e67c34df9a5 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -371,7 +371,8 @@ static const char *vgacon_startup(void)
 	}
 
 	/* VGA16 modes are not handled by VGACON */
-	if ((ORIG_VIDEO_MODE == 0x0D) ||	/* 320x200/4 */
+	if ((ORIG_VIDEO_MODE == 0x00) ||	/* SCREEN_INFO not initialized */
+	    (ORIG_VIDEO_MODE == 0x0D) ||	/* 320x200/4 */
 	    (ORIG_VIDEO_MODE == 0x0E) ||	/* 640x200/4 */
 	    (ORIG_VIDEO_MODE == 0x10) ||	/* 640x350/4 */
 	    (ORIG_VIDEO_MODE == 0x12) ||	/* 640x480/4 */

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 4a9bde2c839b..91a20785108a 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -35,7 +35,6 @@
 
 #include <linux/module.h>
 #include <linux/types.h>
-#include <linux/sched.h>
 #include <linux/fs.h>
 #include <linux/kernel.h>
 #include <linux/console.h>

commit 0128beeee8749e3cb01c27ef9d1da217f5d7b3b8
Author: Helge Deller <deller@gmx.de>
Date:   Fri Dec 8 02:40:29 2006 -0800

    [PATCH] constify and annotate __read_mostly in vgacon.c and fbmem.c
    
    - annotate some variables from vgacon.c and fbmem.c as __read_mostly
    - move the mask[] array in fb_set_logo_truepalette() into the .rodata section
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 0a2c10a1abf8..4a9bde2c839b 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -93,27 +93,27 @@ static void vgacon_invert_region(struct vc_data *c, u16 * p, int count);
 static unsigned long vgacon_uni_pagedir[2];
 
 /* Description of the hardware situation */
-static unsigned long	vga_vram_base;		/* Base of video memory */
-static unsigned long	vga_vram_end;		/* End of video memory */
-static int		vga_vram_size;		/* Size of video memory */
-static u16		vga_video_port_reg;	/* Video register select port */
-static u16		vga_video_port_val;	/* Video register value port */
-static unsigned int	vga_video_num_columns;	/* Number of text columns */
-static unsigned int	vga_video_num_lines;	/* Number of text lines */
-static int		vga_can_do_color = 0;	/* Do we support colors? */
-static unsigned int	vga_default_font_height;/* Height of default screen font */
-static unsigned char	vga_video_type;		/* Card type */
-static unsigned char	vga_hardscroll_enabled;
-static unsigned char	vga_hardscroll_user_enable = 1;
+static int		vga_init_done		__read_mostly;
+static unsigned long	vga_vram_base		__read_mostly;	/* Base of video memory */
+static unsigned long	vga_vram_end		__read_mostly;	/* End of video memory */
+static unsigned int	vga_vram_size		__read_mostly;	/* Size of video memory */
+static u16		vga_video_port_reg	__read_mostly;	/* Video register select port */
+static u16		vga_video_port_val	__read_mostly;	/* Video register value port */
+static unsigned int	vga_video_num_columns;			/* Number of text columns */
+static unsigned int	vga_video_num_lines;			/* Number of text lines */
+static int		vga_can_do_color	__read_mostly;	/* Do we support colors? */
+static unsigned int	vga_default_font_height __read_mostly;	/* Height of default screen font */
+static unsigned char	vga_video_type		__read_mostly;	/* Card type */
+static unsigned char	vga_hardscroll_enabled	__read_mostly;
+static unsigned char	vga_hardscroll_user_enable __read_mostly = 1;
 static unsigned char	vga_font_is_default = 1;
 static int		vga_vesa_blanked;
 static int 		vga_palette_blanked;
 static int 		vga_is_gfx;
 static int 		vga_512_chars;
 static int 		vga_video_font_height;
-static int 		vga_scan_lines;
-static unsigned int 	vga_rolled_over = 0;
-static int              vga_init_done;
+static int 		vga_scan_lines		__read_mostly;
+static unsigned int 	vga_rolled_over;
 
 static int __init no_scroll(char *str)
 {

commit 894673ee6122a3ce1958e1fe096901ba5356a96b
Author: Jon Smirl <jonsmir@gmail.com>
Date:   Mon Jul 10 04:44:13 2006 -0700

    [PATCH] tty: Remove include of screen_info.h from tty.h
    
    screen_info.h doesn't have anything to do with the tty layer and shouldn't be
    included by tty.h.  This patches removes the include and modifies all users to
    directly include screen_info.h.  struct screen_info is mainly used to
    communicate with the console drivers in drivers/video/console.  Note that this
    patch touches every arch and I have no way of testing it.  If there is a
    mistake the worst thing that will happen is a compile error.
    
    [akpm@osdl.org: fix arm build]
    [akpm@osdl.org: fix alpha build]
    Signed-off-by: Jon Smirl <jonsmir@gmail.com>
    Signed-off-by: Antonino Daplas <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 7f1f0e7a5b20..0a2c10a1abf8 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -47,6 +47,7 @@
 #include <linux/spinlock.h>
 #include <linux/ioport.h>
 #include <linux/init.h>
+#include <linux/screen_info.h>
 #include <linux/smp_lock.h>
 #include <video/vga.h>
 #include <asm/io.h>

commit a8f340e394ff30b79ab5b03c67ab4c94b2ac3646
Author: Jon Smirl <jonsmir@gmail.com>
Date:   Mon Jul 10 04:44:12 2006 -0700

    [PATCH] vt: Remove VT-specific declarations and definitions from tty.h
    
    MAX_NR_CONSOLES, fg_console, want_console and last_console are more of a
    function of the VT layer than the TTY one.  Moving these to vt.h and vt_kern.h
    allows all of the framebuffer and VT console drivers to remove their
    dependency on tty.h.
    
    [akpm@osdl.org: fix alpha build]
    Signed-off-by: Jon Smirl <jonsmir@gmail.com>
    Signed-off-by: Antonino Daplas <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 05735ff4e9c5..7f1f0e7a5b20 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -38,7 +38,6 @@
 #include <linux/sched.h>
 #include <linux/fs.h>
 #include <linux/kernel.h>
-#include <linux/tty.h>
 #include <linux/console.h>
 #include <linux/string.h>
 #include <linux/kd.h>

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 01401cd63ac0..05735ff4e9c5 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -33,7 +33,6 @@
  *  more details.
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/sched.h>

commit 740e518efcd84ce5e53ecf3c4c9be08cf8f3747c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 14:47:06 2006 -0700

    [PATCH] 64bit resource: C99 changes for struct resource declarations
    
    Based on an original patch from Ralf Baechle <ralf@linux-mips.org> and
    Vivek Goyal <vgoyal@in.ibm.com>.  This is needed in order to prepare for
    changing the size of resources.
    
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index f32b590730f2..01401cd63ac0 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -390,7 +390,7 @@ static const char *vgacon_startup(void)
 		vga_video_port_val = VGA_CRT_DM;
 		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10) {
 			static struct resource ega_console_resource =
-			    { "ega", 0x3B0, 0x3BF };
+			    { .name = "ega", .start = 0x3B0, .end = 0x3BF };
 			vga_video_type = VIDEO_TYPE_EGAM;
 			vga_vram_size = 0x8000;
 			display_desc = "EGA+";
@@ -398,9 +398,9 @@ static const char *vgacon_startup(void)
 					 &ega_console_resource);
 		} else {
 			static struct resource mda1_console_resource =
-			    { "mda", 0x3B0, 0x3BB };
+			    { .name = "mda", .start = 0x3B0, .end = 0x3BB };
 			static struct resource mda2_console_resource =
-			    { "mda", 0x3BF, 0x3BF };
+			    { .name = "mda", .start = 0x3BF, .end = 0x3BF };
 			vga_video_type = VIDEO_TYPE_MDA;
 			vga_vram_size = 0x2000;
 			display_desc = "*MDA";
@@ -423,14 +423,14 @@ static const char *vgacon_startup(void)
 
 			if (!ORIG_VIDEO_ISVGA) {
 				static struct resource ega_console_resource
-				    = { "ega", 0x3C0, 0x3DF };
+				    = { .name = "ega", .start = 0x3C0, .end = 0x3DF };
 				vga_video_type = VIDEO_TYPE_EGAC;
 				display_desc = "EGA";
 				request_resource(&ioport_resource,
 						 &ega_console_resource);
 			} else {
 				static struct resource vga_console_resource
-				    = { "vga+", 0x3C0, 0x3DF };
+				    = { .name = "vga+", .start = 0x3C0, .end = 0x3DF };
 				vga_video_type = VIDEO_TYPE_VGAC;
 				display_desc = "VGA+";
 				request_resource(&ioport_resource,
@@ -474,7 +474,7 @@ static const char *vgacon_startup(void)
 			}
 		} else {
 			static struct resource cga_console_resource =
-			    { "cga", 0x3D4, 0x3D5 };
+			    { .name = "cga", .start = 0x3D4, .end = 0x3D5 };
 			vga_video_type = VIDEO_TYPE_CGA;
 			vga_vram_size = 0x2000;
 			display_desc = "*CGA";

commit 50ec42edd9784fad6a37b05be03064ea24098db6
Author: Antonino A. Daplas <adaplas@gmail.com>
Date:   Mon Jun 26 00:27:02 2006 -0700

    [PATCH] Detaching fbcon: fix vgacon to allow retaking of the console
    
    One of the limitations of the framebuffer console system is its inablity to
    unload or detach itself from the console layer.  And once it loads, it also
    locks in framebuffer drivers preventing their unload. Although the con2fbmap
    utility does provide a means to unload individual drivers, it requires that at
    least one framebuffer driver is loaded for use by fbcon.
    
    With this change, it is possible to detach fbcon from the console layer. If it
    is detached, it will reattach the boot console driver (which is permanently
    loaded) back to the console layer so the system can continue to work.  As a
    consequence, fbcon will also decrement its reference count of individual
    framebuffer drivers, allowing all of these drivers to be unloaded even if
    fbcon is still loaded.
    
    Unless you use drivers that restores the display to text mode (rivafb and
    i810fb, for example), detaching fbcon does require assistance from userspace
    tools (ie, vbetools) for text mode to be restored completely.  Without the
    help of these tools, fbcon will leave the VGA console corrupted. The methods
    that can be used will be described in Documentation/fb/fbcon.txt.
    
    Because the vt layer also increments the module reference count for each
    console driver, fbcon cannot be directly unloaded.  It must be detached first
    prior to unload.
    
    Similarly, fbcon can be reattached to the console layer without having to
    reload the module.  A nice feature if fbcon is compiled statically.
    
    Attaching and detaching fbcon is done via sysfs attributes. A class device
    entry for fbcon is created in /sys/class/graphics. The two attributes that
    controls this feature are detach and attach. Two other attributes that are
    piggybacked under /sys/class/graphics/fb[n] that are fbcon-specific,
    'con_rotate' and 'con_rotate_all' are moved to fbcon.  They are renamed as
    'rotate' and 'rotate_all' respectively.
    
    Overall, this feature is a great help for developers working in the
    framebuffer or console layer.  There is not need to continually reboot the
    kernel for every small change. It is also useful for regular users who wants
    to choose between a graphical console or a text console without having to
    reboot.
    
    Example usage for x86:
    
    /* start in text mode */
    modprobe xxxfb
    modprobe fbcon
    /* graphical mode with fbcon using xxxfb */
    echo 1 > /sys/class/graphics/fbcon/detach
    /* back to text mode, will produce corrupt display unless vbetool is used */
    rmmod xxxfb
    modprobe yyyfb
    /* back to graphical mode with fbcon using yyyfb */
    
    Before trying out this feature, please read Documentation/fb/fbcon.txt.
    
    This patch:
    
    In order for fbcon to detach itself from the console layer, vgacon, which is a
    boot console driver, must be fixed so it can retake the console multiple
    times, not just during init.  The following needs to be done:
    
    - remove __init from the vgacon_startup, this is called again by
      take_over_console().
    
    - vc->rows and vc->cols are set manually by vgacon during init. After init,
      vc_resize() can be used
    
    - make sure the scrollback_buffer is not reallocated
    
    Signed-off-by: Antonino Daplas <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index e64d42e2449e..f32b590730f2 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -114,6 +114,7 @@ static int 		vga_512_chars;
 static int 		vga_video_font_height;
 static int 		vga_scan_lines;
 static unsigned int 	vga_rolled_over = 0;
+static int              vga_init_done;
 
 static int __init no_scroll(char *str)
 {
@@ -190,7 +191,7 @@ static void vgacon_scrollback_init(int pitch)
 	}
 }
 
-static void __init vgacon_scrollback_startup(void)
+static void vgacon_scrollback_startup(void)
 {
 	vgacon_scrollback = alloc_bootmem(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE
 					  * 1024);
@@ -355,7 +356,7 @@ static int vgacon_scrolldelta(struct vc_data *c, int lines)
 }
 #endif /* CONFIG_VGACON_SOFT_SCROLLBACK */
 
-static const char __init *vgacon_startup(void)
+static const char *vgacon_startup(void)
 {
 	const char *display_desc = NULL;
 	u16 saved1, saved2;
@@ -523,7 +524,12 @@ static const char __init *vgacon_startup(void)
 
 	vgacon_xres = ORIG_VIDEO_COLS * VGA_FONTWIDTH;
 	vgacon_yres = vga_scan_lines;
-	vgacon_scrollback_startup();
+
+	if (!vga_init_done) {
+		vgacon_scrollback_startup();
+		vga_init_done = 1;
+	}
+
 	return display_desc;
 }
 
@@ -531,10 +537,20 @@ static void vgacon_init(struct vc_data *c, int init)
 {
 	unsigned long p;
 
-	/* We cannot be loaded as a module, therefore init is always 1 */
+	/*
+	 * We cannot be loaded as a module, therefore init is always 1,
+	 * but vgacon_init can be called more than once, and init will
+	 * not be 1.
+	 */
 	c->vc_can_do_color = vga_can_do_color;
-	c->vc_cols = vga_video_num_columns;
-	c->vc_rows = vga_video_num_lines;
+
+	/* set dimensions manually if init != 0 since vc_resize() will fail */
+	if (init) {
+		c->vc_cols = vga_video_num_columns;
+		c->vc_rows = vga_video_num_lines;
+	} else
+		vc_resize(c, vga_video_num_columns, vga_video_num_lines);
+
 	c->vc_scan_lines = vga_scan_lines;
 	c->vc_font.height = vga_video_font_height;
 	c->vc_complement_mask = 0x7700;

commit 4f1bcaf094ccc512c23e10104c05a6f8e5b7a9e4
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jun 22 14:47:32 2006 -0700

    [PATCH] vgacon: make VGA_MAP_MEM take size, remove extra use
    
    VGA_MAP_MEM translates to ioremap() on some architectures.  It makes sense
    to do this to vga_vram_base, because we're going to access memory between
    vga_vram_base and vga_vram_end.
    
    But it doesn't really make sense to map starting at vga_vram_end, because
    we aren't going to access memory starting there.  On ia64, which always has
    to be different, ioremapping vga_vram_end gives you something completely
    incompatible with ioremapped vga_vram_start, so vga_vram_size ends up being
    nonsense.
    
    As a bonus, we often know the size up front, so we can use ioremap()
    correctly, rather than giving it a zero size.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index d5a04b68c4d4..e64d42e2449e 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -391,7 +391,7 @@ static const char __init *vgacon_startup(void)
 			static struct resource ega_console_resource =
 			    { "ega", 0x3B0, 0x3BF };
 			vga_video_type = VIDEO_TYPE_EGAM;
-			vga_vram_end = 0xb8000;
+			vga_vram_size = 0x8000;
 			display_desc = "EGA+";
 			request_resource(&ioport_resource,
 					 &ega_console_resource);
@@ -401,7 +401,7 @@ static const char __init *vgacon_startup(void)
 			static struct resource mda2_console_resource =
 			    { "mda", 0x3BF, 0x3BF };
 			vga_video_type = VIDEO_TYPE_MDA;
-			vga_vram_end = 0xb2000;
+			vga_vram_size = 0x2000;
 			display_desc = "*MDA";
 			request_resource(&ioport_resource,
 					 &mda1_console_resource);
@@ -418,7 +418,7 @@ static const char __init *vgacon_startup(void)
 		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10) {
 			int i;
 
-			vga_vram_end = 0xc0000;
+			vga_vram_size = 0x8000;
 
 			if (!ORIG_VIDEO_ISVGA) {
 				static struct resource ega_console_resource
@@ -443,7 +443,7 @@ static const char __init *vgacon_startup(void)
 				 * and COE=1 isn't necessarily a good idea)
 				 */
 				vga_vram_base = 0xa0000;
-				vga_vram_end = 0xb0000;
+				vga_vram_size = 0x10000;
 				outb_p(6, VGA_GFX_I);
 				outb_p(6, VGA_GFX_D);
 #endif
@@ -475,7 +475,7 @@ static const char __init *vgacon_startup(void)
 			static struct resource cga_console_resource =
 			    { "cga", 0x3D4, 0x3D5 };
 			vga_video_type = VIDEO_TYPE_CGA;
-			vga_vram_end = 0xba000;
+			vga_vram_size = 0x2000;
 			display_desc = "*CGA";
 			request_resource(&ioport_resource,
 					 &cga_console_resource);
@@ -483,9 +483,8 @@ static const char __init *vgacon_startup(void)
 		}
 	}
 
-	vga_vram_base = VGA_MAP_MEM(vga_vram_base);
-	vga_vram_end = VGA_MAP_MEM(vga_vram_end);
-	vga_vram_size = vga_vram_end - vga_vram_base;
+	vga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);
+	vga_vram_end = vga_vram_base + vga_vram_size;
 
 	/*
 	 *      Find out if there is a graphics card present.
@@ -1020,14 +1019,14 @@ static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
 	char *charmap;
 	
 	if (vga_video_type != VIDEO_TYPE_EGAM) {
-		charmap = (char *) VGA_MAP_MEM(colourmap);
+		charmap = (char *) VGA_MAP_MEM(colourmap, 0);
 		beg = 0x0e;
 #ifdef VGA_CAN_DO_64KB
 		if (vga_video_type == VIDEO_TYPE_VGAC)
 			beg = 0x06;
 #endif
 	} else {
-		charmap = (char *) VGA_MAP_MEM(blackwmap);
+		charmap = (char *) VGA_MAP_MEM(blackwmap, 0);
 		beg = 0x0a;
 	}
 

commit 15bdab959c9bb909c0317480dd9b35748a8f7887
Author: Antonino A. Daplas <adaplas@gmail.com>
Date:   Mon Mar 27 01:17:20 2006 -0800

    [PATCH] vgacon: Add support for soft scrollback
    
    The scrollback buffer of the VGA console is located in VGA RAM.  This RAM
    is fixed in size and is very small.  To make the scrollback buffer larger,
    it must be placed instead in System RAM.
    
    This patch adds this feature.  The feature and the size of the buffer are
    made as a kernel config option.  Besides consuming kernel memory, this
    feature will slow down the console by approximately 20%.
    
    Signed-off-by: Antonino Daplas <adaplas@pol.net>
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Jindrich Makovicka <makovick@kmlinux.fjfi.cvut.cz>
    Cc: Martin Mares <mj@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 61894d5bb219..d5a04b68c4d4 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -93,7 +93,6 @@ static u8 vgacon_build_attr(struct vc_data *c, u8 color, u8 intensity,
 static void vgacon_invert_region(struct vc_data *c, u16 * p, int count);
 static unsigned long vgacon_uni_pagedir[2];
 
-
 /* Description of the hardware situation */
 static unsigned long	vga_vram_base;		/* Base of video memory */
 static unsigned long	vga_vram_end;		/* End of video memory */
@@ -161,6 +160,201 @@ static inline void write_vga(unsigned char reg, unsigned int val)
 	spin_unlock_irqrestore(&vga_lock, flags);
 }
 
+static inline void vga_set_mem_top(struct vc_data *c)
+{
+	write_vga(12, (c->vc_visible_origin - vga_vram_base) / 2);
+}
+
+#ifdef CONFIG_VGACON_SOFT_SCROLLBACK
+#include <linux/bootmem.h>
+/* software scrollback */
+static void *vgacon_scrollback;
+static int vgacon_scrollback_tail;
+static int vgacon_scrollback_size;
+static int vgacon_scrollback_rows;
+static int vgacon_scrollback_cnt;
+static int vgacon_scrollback_cur;
+static int vgacon_scrollback_save;
+static int vgacon_scrollback_restore;
+
+static void vgacon_scrollback_init(int pitch)
+{
+	int rows = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024/pitch;
+
+	if (vgacon_scrollback) {
+		vgacon_scrollback_cnt  = 0;
+		vgacon_scrollback_tail = 0;
+		vgacon_scrollback_cur  = 0;
+		vgacon_scrollback_rows = rows - 1;
+		vgacon_scrollback_size = rows * pitch;
+	}
+}
+
+static void __init vgacon_scrollback_startup(void)
+{
+	vgacon_scrollback = alloc_bootmem(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE
+					  * 1024);
+	vgacon_scrollback_init(vga_video_num_columns * 2);
+}
+
+static void vgacon_scrollback_update(struct vc_data *c, int t, int count)
+{
+	void *p;
+
+	if (!vgacon_scrollback_size || c->vc_num != fg_console)
+		return;
+
+	p = (void *) (c->vc_origin + t * c->vc_size_row);
+
+	while (count--) {
+		scr_memcpyw(vgacon_scrollback + vgacon_scrollback_tail,
+			    p, c->vc_size_row);
+		vgacon_scrollback_cnt++;
+		p += c->vc_size_row;
+		vgacon_scrollback_tail += c->vc_size_row;
+
+		if (vgacon_scrollback_tail >= vgacon_scrollback_size)
+			vgacon_scrollback_tail = 0;
+
+		if (vgacon_scrollback_cnt > vgacon_scrollback_rows)
+			vgacon_scrollback_cnt = vgacon_scrollback_rows;
+
+		vgacon_scrollback_cur = vgacon_scrollback_cnt;
+	}
+}
+
+static void vgacon_restore_screen(struct vc_data *c)
+{
+	vgacon_scrollback_save = 0;
+
+	if (!vga_is_gfx && !vgacon_scrollback_restore) {
+		scr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,
+			    c->vc_screenbuf_size > vga_vram_size ?
+			    vga_vram_size : c->vc_screenbuf_size);
+		vgacon_scrollback_restore = 1;
+		vgacon_scrollback_cur = vgacon_scrollback_cnt;
+	}
+}
+
+static int vgacon_scrolldelta(struct vc_data *c, int lines)
+{
+	int start, end, count, soff, diff;
+	void *d, *s;
+
+	if (!lines) {
+		c->vc_visible_origin = c->vc_origin;
+		vga_set_mem_top(c);
+		return 1;
+	}
+
+	if (!vgacon_scrollback)
+		return 1;
+
+	if (!vgacon_scrollback_save) {
+		vgacon_cursor(c, CM_ERASE);
+		vgacon_save_screen(c);
+		vgacon_scrollback_save = 1;
+	}
+
+	vgacon_scrollback_restore = 0;
+	start = vgacon_scrollback_cur + lines;
+	end = start + abs(lines);
+
+	if (start < 0)
+		start = 0;
+
+	if (start > vgacon_scrollback_cnt)
+		start = vgacon_scrollback_cnt;
+
+	if (end < 0)
+		end = 0;
+
+	if (end > vgacon_scrollback_cnt)
+		end = vgacon_scrollback_cnt;
+
+	vgacon_scrollback_cur = start;
+	count = end - start;
+	soff = vgacon_scrollback_tail - ((vgacon_scrollback_cnt - end) *
+					 c->vc_size_row);
+	soff -= count * c->vc_size_row;
+
+	if (soff < 0)
+		soff += vgacon_scrollback_size;
+
+	count = vgacon_scrollback_cnt - start;
+
+	if (count > c->vc_rows)
+		count = c->vc_rows;
+
+	diff = c->vc_rows - count;
+
+	d = (void *) c->vc_origin;
+	s = (void *) c->vc_screenbuf;
+
+	while (count--) {
+		scr_memcpyw(d, vgacon_scrollback + soff, c->vc_size_row);
+		d += c->vc_size_row;
+		soff += c->vc_size_row;
+
+		if (soff >= vgacon_scrollback_size)
+			soff = 0;
+	}
+
+	if (diff == c->vc_rows) {
+		vgacon_cursor(c, CM_MOVE);
+	} else {
+		while (diff--) {
+			scr_memcpyw(d, s, c->vc_size_row);
+			d += c->vc_size_row;
+			s += c->vc_size_row;
+		}
+	}
+
+	return 1;
+}
+#else
+#define vgacon_scrollback_startup(...) do { } while (0)
+#define vgacon_scrollback_init(...)    do { } while (0)
+#define vgacon_scrollback_update(...)  do { } while (0)
+
+static void vgacon_restore_screen(struct vc_data *c)
+{
+	if (c->vc_origin != c->vc_visible_origin)
+		vgacon_scrolldelta(c, 0);
+}
+
+static int vgacon_scrolldelta(struct vc_data *c, int lines)
+{
+	if (!lines)		/* Turn scrollback off */
+		c->vc_visible_origin = c->vc_origin;
+	else {
+		int margin = c->vc_size_row * 4;
+		int ul, we, p, st;
+
+		if (vga_rolled_over >
+		    (c->vc_scr_end - vga_vram_base) + margin) {
+			ul = c->vc_scr_end - vga_vram_base;
+			we = vga_rolled_over + c->vc_size_row;
+		} else {
+			ul = 0;
+			we = vga_vram_size;
+		}
+		p = (c->vc_visible_origin - vga_vram_base - ul + we) % we +
+		    lines * c->vc_size_row;
+		st = (c->vc_origin - vga_vram_base - ul + we) % we;
+		if (st < 2 * margin)
+			margin = 0;
+		if (p < margin)
+			p = 0;
+		if (p > st - margin)
+			p = st;
+		c->vc_visible_origin = vga_vram_base + (p + ul) % we;
+	}
+	vga_set_mem_top(c);
+	return 1;
+}
+#endif /* CONFIG_VGACON_SOFT_SCROLLBACK */
+
 static const char __init *vgacon_startup(void)
 {
 	const char *display_desc = NULL;
@@ -330,7 +524,7 @@ static const char __init *vgacon_startup(void)
 
 	vgacon_xres = ORIG_VIDEO_COLS * VGA_FONTWIDTH;
 	vgacon_yres = vga_scan_lines;
-
+	vgacon_scrollback_startup();
 	return display_desc;
 }
 
@@ -357,11 +551,6 @@ static void vgacon_init(struct vc_data *c, int init)
 		con_set_default_unimap(c);
 }
 
-static inline void vga_set_mem_top(struct vc_data *c)
-{
-	write_vga(12, (c->vc_visible_origin - vga_vram_base) / 2);
-}
-
 static void vgacon_deinit(struct vc_data *c)
 {
 	/* When closing the last console, reset video origin */
@@ -455,8 +644,8 @@ static void vgacon_set_cursor_size(int xpos, int from, int to)
 
 static void vgacon_cursor(struct vc_data *c, int mode)
 {
-	if (c->vc_origin != c->vc_visible_origin)
-		vgacon_scrolldelta(c, 0);
+	vgacon_restore_screen(c);
+
 	switch (mode) {
 	case CM_ERASE:
 		write_vga(14, (c->vc_pos - vga_vram_base) / 2);
@@ -606,6 +795,7 @@ static int vgacon_switch(struct vc_data *c)
 			vgacon_doresize(c, c->vc_cols, c->vc_rows);
 	}
 
+	vgacon_scrollback_init(c->vc_size_row);
 	return 0;		/* Redrawing not needed */
 }
 
@@ -1073,37 +1263,6 @@ static int vgacon_resize(struct vc_data *c, unsigned int width,
 	return 0;
 }
 
-static int vgacon_scrolldelta(struct vc_data *c, int lines)
-{
-	if (!lines)		/* Turn scrollback off */
-		c->vc_visible_origin = c->vc_origin;
-	else {
-		int margin = c->vc_size_row * 4;
-		int ul, we, p, st;
-
-		if (vga_rolled_over >
-		    (c->vc_scr_end - vga_vram_base) + margin) {
-			ul = c->vc_scr_end - vga_vram_base;
-			we = vga_rolled_over + c->vc_size_row;
-		} else {
-			ul = 0;
-			we = vga_vram_size;
-		}
-		p = (c->vc_visible_origin - vga_vram_base - ul + we) % we +
-		    lines * c->vc_size_row;
-		st = (c->vc_origin - vga_vram_base - ul + we) % we;
-		if (st < 2 * margin)
-			margin = 0;
-		if (p < margin)
-			p = 0;
-		if (p > st - margin)
-			p = st;
-		c->vc_visible_origin = vga_vram_base + (p + ul) % we;
-	}
-	vga_set_mem_top(c);
-	return 1;
-}
-
 static int vgacon_set_origin(struct vc_data *c)
 {
 	if (vga_is_gfx ||	/* We don't play origin tricks in graphic modes */
@@ -1146,15 +1305,14 @@ static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,
 	if (t || b != c->vc_rows || vga_is_gfx)
 		return 0;
 
-	if (c->vc_origin != c->vc_visible_origin)
-		vgacon_scrolldelta(c, 0);
-
 	if (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)
 		return 0;
 
+	vgacon_restore_screen(c);
 	oldo = c->vc_origin;
 	delta = lines * c->vc_size_row;
 	if (dir == SM_UP) {
+		vgacon_scrollback_update(c, t, lines);
 		if (c->vc_scr_end + delta >= vga_vram_end) {
 			scr_memcpyw((u16 *) vga_vram_base,
 				    (u16 *) (oldo + delta),

commit 2115aea8185c8987b7688111953322742bd8795c
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Mon Mar 27 01:17:19 2006 -0800

    [PATCH] vgacon: fix EGA cursor resize function
    
    This corrects cursor resize on ega boards: registers are write-only, so we
    shouldn't even try to read them.  And on ega, 31/30 produces a flat cursor.
    Using 31/31 is better: except with 32 pixels high fonts, it shouldn't show
    up.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 5a86978537d2..61894d5bb219 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -433,17 +433,22 @@ static void vgacon_set_cursor_size(int xpos, int from, int to)
 	cursor_size_lastto = to;
 
 	spin_lock_irqsave(&vga_lock, flags);
-	outb_p(0x0a, vga_video_port_reg);	/* Cursor start */
-	curs = inb_p(vga_video_port_val);
-	outb_p(0x0b, vga_video_port_reg);	/* Cursor end */
-	cure = inb_p(vga_video_port_val);
+	if (vga_video_type >= VIDEO_TYPE_VGAC) {
+		outb_p(VGA_CRTC_CURSOR_START, vga_video_port_reg);
+		curs = inb_p(vga_video_port_val);
+		outb_p(VGA_CRTC_CURSOR_END, vga_video_port_reg);
+		cure = inb_p(vga_video_port_val);
+	} else {
+		curs = 0;
+		cure = 0;
+	}
 
 	curs = (curs & 0xc0) | from;
 	cure = (cure & 0xe0) | to;
 
-	outb_p(0x0a, vga_video_port_reg);	/* Cursor start */
+	outb_p(VGA_CRTC_CURSOR_START, vga_video_port_reg);
 	outb_p(curs, vga_video_port_val);
-	outb_p(0x0b, vga_video_port_reg);	/* Cursor end */
+	outb_p(VGA_CRTC_CURSOR_END, vga_video_port_reg);
 	outb_p(cure, vga_video_port_val);
 	spin_unlock_irqrestore(&vga_lock, flags);
 }
@@ -455,7 +460,10 @@ static void vgacon_cursor(struct vc_data *c, int mode)
 	switch (mode) {
 	case CM_ERASE:
 		write_vga(14, (c->vc_pos - vga_vram_base) / 2);
-		vgacon_set_cursor_size(c->vc_x, 31, 30);
+	        if (vga_video_type >= VIDEO_TYPE_VGAC)
+			vgacon_set_cursor_size(c->vc_x, 31, 30);
+		else
+			vgacon_set_cursor_size(c->vc_x, 31, 31);
 		break;
 
 	case CM_MOVE:
@@ -493,7 +501,10 @@ static void vgacon_cursor(struct vc_data *c, int mode)
 						10 ? 1 : 2));
 			break;
 		case CUR_NONE:
-			vgacon_set_cursor_size(c->vc_x, 31, 30);
+			if (vga_video_type >= VIDEO_TYPE_VGAC)
+				vgacon_set_cursor_size(c->vc_x, 31, 30);
+			else
+				vgacon_set_cursor_size(c->vc_x, 31, 31);
 			break;
 		default:
 			vgacon_set_cursor_size(c->vc_x, 1,

commit d1521260f57d70d0ba86d2a309ec1ce7979be2fc
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Fri Feb 24 13:03:59 2006 -0800

    [PATCH] vgacon: no vertical resizing on EGA
    
    EGA boards suck: they mostly have write-only registers.  This is
    particularly problematic for the overflow register: for being able to write
    to it, we would have to handle vertical sync & such too, which (I'd say)
    would potentially break a lot of configurations.  Instead, just disabling
    vertical resize for EGA boards is just nice enough (horizontal resize still
    works).
    
    Fixes http://bugzilla.kernel.org/show_bug.cgi?id=6106
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Cc: Rafal Olearski <olearski@mail2.kim.net.pl>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 12d9329d1408..5a86978537d2 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -509,57 +509,60 @@ static int vgacon_doresize(struct vc_data *c,
 {
 	unsigned long flags;
 	unsigned int scanlines = height * c->vc_font.height;
-	u8 scanlines_lo, r7, vsync_end, mode, max_scan;
+	u8 scanlines_lo = 0, r7 = 0, vsync_end = 0, mode, max_scan;
 
 	spin_lock_irqsave(&vga_lock, flags);
 
-	outb_p(VGA_CRTC_MAX_SCAN, vga_video_port_reg);
-	max_scan = inb_p(vga_video_port_val);
-
-	if (max_scan & 0x80)
-		scanlines <<= 1;
-
 	vgacon_xres = width * VGA_FONTWIDTH;
 	vgacon_yres = height * c->vc_font.height;
-	outb_p(VGA_CRTC_MODE, vga_video_port_reg);
-	mode = inb_p(vga_video_port_val);
+	if (vga_video_type >= VIDEO_TYPE_VGAC) {
+		outb_p(VGA_CRTC_MAX_SCAN, vga_video_port_reg);
+		max_scan = inb_p(vga_video_port_val);
 
-	if (mode & 0x04)
-		scanlines >>= 1;
+		if (max_scan & 0x80)
+			scanlines <<= 1;
 
-	scanlines -= 1;
-	scanlines_lo = scanlines & 0xff;
+		outb_p(VGA_CRTC_MODE, vga_video_port_reg);
+		mode = inb_p(vga_video_port_val);
 
-	outb_p(VGA_CRTC_OVERFLOW, vga_video_port_reg);
-	r7 = inb_p(vga_video_port_val) & ~0x42;
+		if (mode & 0x04)
+			scanlines >>= 1;
 
-	if (scanlines & 0x100)
-		r7 |= 0x02;
-	if (scanlines & 0x200)
-		r7 |= 0x40;
+		scanlines -= 1;
+		scanlines_lo = scanlines & 0xff;
 
-	/* deprotect registers */
-	outb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);
-	vsync_end = inb_p(vga_video_port_val);
-	outb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);
-	outb_p(vsync_end & ~0x80, vga_video_port_val);
+		outb_p(VGA_CRTC_OVERFLOW, vga_video_port_reg);
+		r7 = inb_p(vga_video_port_val) & ~0x42;
+
+		if (scanlines & 0x100)
+			r7 |= 0x02;
+		if (scanlines & 0x200)
+			r7 |= 0x40;
+
+		/* deprotect registers */
+		outb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);
+		vsync_end = inb_p(vga_video_port_val);
+		outb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);
+		outb_p(vsync_end & ~0x80, vga_video_port_val);
+	}
 
 	outb_p(VGA_CRTC_H_DISP, vga_video_port_reg);
 	outb_p(width - 1, vga_video_port_val);
 	outb_p(VGA_CRTC_OFFSET, vga_video_port_reg);
 	outb_p(width >> 1, vga_video_port_val);
 
-	outb_p(VGA_CRTC_V_DISP_END, vga_video_port_reg);
-	outb_p(scanlines_lo, vga_video_port_val);
-	outb_p(VGA_CRTC_OVERFLOW, vga_video_port_reg);
-	outb_p(r7,vga_video_port_val);
+	if (vga_video_type >= VIDEO_TYPE_VGAC) {
+		outb_p(VGA_CRTC_V_DISP_END, vga_video_port_reg);
+		outb_p(scanlines_lo, vga_video_port_val);
+		outb_p(VGA_CRTC_OVERFLOW, vga_video_port_reg);
+		outb_p(r7,vga_video_port_val);
 
-	/* reprotect registers */
-	outb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);
-	outb_p(vsync_end, vga_video_port_val);
+		/* reprotect registers */
+		outb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);
+		outb_p(vsync_end, vga_video_port_val);
+	}
 
 	spin_unlock_irqrestore(&vga_lock, flags);
-
 	return 0;
 }
 

commit 53dbb26dbcf0d844967677633d7587c1d34740d5
Author: Antonino A. Daplas <adaplas@gmail.com>
Date:   Sun Jan 8 01:02:36 2006 -0800

    [PATCH] vgacon: Workaround for resize bug in some chipsets
    
    Reported from Redhat Bugzilla Bug 170450
    
    "I updated to the development kernel and now during boot only the top of the
    text is visable. For example the monitor screen the is the lines and I can
    only see text in the asterisk area.

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index f4e1c4b4191e..12d9329d1408 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -56,6 +56,8 @@
 static DEFINE_SPINLOCK(vga_lock);
 static int cursor_size_lastfrom;
 static int cursor_size_lastto;
+static u32 vgacon_xres;
+static u32 vgacon_yres;
 static struct vgastate state;
 
 #define BLANK 0x0020
@@ -69,7 +71,7 @@ static struct vgastate state;
  * appear.
  */
 #undef TRIDENT_GLITCH
-
+#define VGA_FONTWIDTH       8   /* VGA does not support fontwidths != 8 */
 /*
  *  Interface used by the world
  */
@@ -325,6 +327,10 @@ static const char __init *vgacon_startup(void)
 		vga_scan_lines =
 		    vga_video_font_height * vga_video_num_lines;
 	}
+
+	vgacon_xres = ORIG_VIDEO_COLS * VGA_FONTWIDTH;
+	vgacon_yres = vga_scan_lines;
+
 	return display_desc;
 }
 
@@ -513,6 +519,8 @@ static int vgacon_doresize(struct vc_data *c,
 	if (max_scan & 0x80)
 		scanlines <<= 1;
 
+	vgacon_xres = width * VGA_FONTWIDTH;
+	vgacon_yres = height * c->vc_font.height;
 	outb_p(VGA_CRTC_MODE, vga_video_port_reg);
 	mode = inb_p(vga_video_port_val);
 
@@ -557,6 +565,10 @@ static int vgacon_doresize(struct vc_data *c,
 
 static int vgacon_switch(struct vc_data *c)
 {
+	int x = c->vc_cols * VGA_FONTWIDTH;
+	int y = c->vc_rows * c->vc_font.height;
+	int rows = ORIG_VIDEO_LINES * vga_default_font_height/
+		c->vc_font.height;
 	/*
 	 * We need to save screen size here as it's the only way
 	 * we can spot the screen has been resized and we need to
@@ -572,10 +584,11 @@ static int vgacon_switch(struct vc_data *c)
 		scr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,
 			    c->vc_screenbuf_size > vga_vram_size ?
 				vga_vram_size : c->vc_screenbuf_size);
-		if (!(vga_video_num_columns % 2) &&
-		    vga_video_num_columns <= ORIG_VIDEO_COLS &&
-		    vga_video_num_lines <= (ORIG_VIDEO_LINES *
-			vga_default_font_height) / c->vc_font.height)
+
+		if ((vgacon_xres != x || vgacon_yres != y) &&
+		    (!(vga_video_num_columns % 2) &&
+		     vga_video_num_columns <= ORIG_VIDEO_COLS &&
+		     vga_video_num_lines <= rows))
 			vgacon_doresize(c, c->vc_cols, c->vc_rows);
 	}
 
@@ -999,7 +1012,8 @@ static int vgacon_font_set(struct vc_data *c, struct console_font *font, unsigne
 	if (vga_video_type < VIDEO_TYPE_EGAM)
 		return -EINVAL;
 
-	if (font->width != 8 || (charcount != 256 && charcount != 512))
+	if (font->width != VGA_FONTWIDTH ||
+	    (charcount != 256 && charcount != 512))
 		return -EINVAL;
 
 	rc = vgacon_do_font_op(&state, font->data, 1, charcount == 512);
@@ -1016,7 +1030,7 @@ static int vgacon_font_get(struct vc_data *c, struct console_font *font)
 	if (vga_video_type < VIDEO_TYPE_EGAM)
 		return -EINVAL;
 
-	font->width = 8;
+	font->width = VGA_FONTWIDTH;
 	font->height = c->vc_font.height;
 	font->charcount = vga_512_chars ? 512 : 256;
 	if (!font->data)

commit 954de9141e75cf2f1ce69ccdbedc83ec827a01ec
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Sun Jan 8 01:02:34 2006 -0800

    [PATCH] vgacon: fix doublescan mode
    
    When doublescan mode is in use, scanlines must be doubled.
    
    Thanks to Jason Dravet <dravet@hotmail.com> for reporting and testing.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 167de397e4b4..f4e1c4b4191e 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -503,10 +503,16 @@ static int vgacon_doresize(struct vc_data *c,
 {
 	unsigned long flags;
 	unsigned int scanlines = height * c->vc_font.height;
-	u8 scanlines_lo, r7, vsync_end, mode;
+	u8 scanlines_lo, r7, vsync_end, mode, max_scan;
 
 	spin_lock_irqsave(&vga_lock, flags);
 
+	outb_p(VGA_CRTC_MAX_SCAN, vga_video_port_reg);
+	max_scan = inb_p(vga_video_port_val);
+
+	if (max_scan & 0x80)
+		scanlines <<= 1;
+
 	outb_p(VGA_CRTC_MODE, vga_video_port_reg);
 	mode = inb_p(vga_video_port_val);
 

commit 5ef897c71a8985b62b7ec320a37376daaad364d0
Author: Antonino A. Daplas <adaplas@gmail.com>
Date:   Mon Nov 21 21:32:26 2005 -0800

    [PATCH] vgacon: Fix usage of stale height value on vc initialization
    
    Reported by: Wayne E. Harlan
    
    "[1.] One line summary of the problem:
    When the kernel option "vga=1" is used, additional tty's (alt+control+Fx
    with x=2,3,4,5, etc) do not provide the full 50 lines of output.  The first
    one does have 50 lines, however.
    
    [2.] Full description of the problem/report:
    These addtitional tty's show only 39 lines plus the top pixel of the 40-th
    line.  The remaining lines are black and not shown.  Kernel version
    2.6.13.4 does not show this problem."
    
    This bug is caused by using a stale font height value on vgacon_init.
    
    Booting with vga=1 gives an 80x50 screen with an 8x8 font.  Somewhere
    during the initialization, the font was changed to 8x9 and the first
    vc was correctly resized to 80x44.  However, the rest of the vc's were
    not allocated yet, and when they were subsequently initialized, they
    still used a font height of 8 (instead of 9) causing the mentioned bug.
    
    Fix by saving the new font height to vga_video_font_height.
    
    Signed-off-by: Antonino Daplas <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 274f90543e32..167de397e4b4 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -966,6 +966,7 @@ static int vgacon_adjust_height(struct vc_data *vc, unsigned fontheight)
 	outb_p(0x12, vga_video_port_reg);	/* Vertical display limit */
 	outb_p(vde, vga_video_port_val);
 	spin_unlock_irq(&vga_lock);
+	vga_video_font_height = fontheight;
 
 	for (i = 0; i < MAX_NR_CONSOLES; i++) {
 		struct vc_data *c = vc_cons[i].d;

commit 88dcb6c4113afe93a6c4891ec43bef6a17c83155
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Sat Nov 5 22:19:50 2005 +0100

    [PATCH] Set the vga cursor even when hidden
    
    Some visually impaired people use hardware devices which directly read
    the vga screen. When newt for instance asks to hide the cursor for
    better visual aspect, the kernel puts the vga cursor out of the screen,
    so that the cursor position can't be read by the hardware device. This
    is a great loss for such people.
    
    Here is a patch which uses the same technique as CUR_NONE for hiding the
    cursor while still moving it.
    
    Mario, you should apply it to the speakup kernel for access floppies
    asap. I'll submit a 2.4 patch too.
    
    Signed-off-by: samuel.thibault@ens-lyon.org
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 56cd199605f4..274f90543e32 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -448,7 +448,8 @@ static void vgacon_cursor(struct vc_data *c, int mode)
 		vgacon_scrolldelta(c, 0);
 	switch (mode) {
 	case CM_ERASE:
-		write_vga(14, (vga_vram_end - vga_vram_base - 1) / 2);
+		write_vga(14, (c->vc_pos - vga_vram_base) / 2);
+		vgacon_set_cursor_size(c->vc_x, 31, 30);
 		break;
 
 	case CM_MOVE:

commit 1a66ddcb770fbd20ce115910c7828cafdba099c1
Author: Pozsar Balazs <pozsy@uhulinux.hu>
Date:   Sun Oct 30 15:03:06 2005 -0800

    [PATCH] fix vgacon blanking
    
    This patch fixes a long-standing vgacon bug: characters with the bright bit
    set were left on the screen and not blacked out.  All I did was that I
    lookuped up some examples on the net about setting the vga palette, and
    added the call missing from the linux kernel, but included in all other
    ones.  It works for me.
    
    You can test this by writing something with the bright set to the
    console, for example:
      echo -e "\e[1;31mhello there\e[0m"
    and then wait for the console to blank itself (by default, after 10 mins
    of inactivity), maybe making it faster using
      setterm -blank 1
    so you only have to wait 1 minute.
    
    Signed-off-by: Pozsar Balazs <pozsy@uhulinux.hu>
    Cc: James Simmons <jsimmons@infradead.org>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 809fee2140ac..56cd199605f4 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -579,6 +579,7 @@ static void vga_set_palette(struct vc_data *vc, unsigned char *table)
 {
 	int i, j;
 
+	vga_w(state.vgabase, VGA_PEL_MSK, 0xff);
 	for (i = j = 0; i < 16; i++) {
 		vga_w(state.vgabase, VGA_PEL_IW, table[i]);
 		vga_w(state.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);
@@ -721,6 +722,7 @@ static void vga_pal_blank(struct vgastate *state)
 {
 	int i;
 
+	vga_w(state->vgabase, VGA_PEL_MSK, 0xff);
 	for (i = 0; i < 16; i++) {
 		vga_w(state->vgabase, VGA_PEL_IW, i);
 		vga_w(state->vgabase, VGA_PEL_D, 0);

commit 0aec4867dca149e2049e8439b76bd82ad9dac52c
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Sun Oct 16 20:29:22 2005 -0700

    [PATCH] SVGATextMode fix
    
    Fix bug 5441.
    
    I didn't know about messy programs like svgatextmode...  Couldn't this be
    integrated in some linux/drivers/video/console/svgacon.c ?...  So because
    of the existence of the svgatextmode program, the kernel is not supposed to
    touch to CRT_OVERFLOW/SYNC_END/DISP/DISP_END/OFFSET ?
    
    Disabling the check in vgacon_resize() might help indeed, but I'm really
    not sure whether it will work for any chipset: in my patch, CRT registers
    are set at each console switch, since stty rows/cols apply to consoles
    separately...
    
    The attached solution is to keep the test, but if it fails, we assume that
    the caller knows what it does (i.e.  it is svgatextmode) and then disable
    any further call to vgacon_doresize.  Svgatextmode is usually used to
    _expand_ the display, not to shrink it.  And it is harmless in the case of
    a too big stty rows/cols: the display will just be cropped.  I tested it on
    my laptop, and it works fine with svgatextmode.
    
    A better solution would be that svgatextmode explicitely tells the kernel
    not to care about video timing, but for this an interface needs be defined
    and svgatextmode be patched.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 6ef6f7760e47..809fee2140ac 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -565,7 +565,11 @@ static int vgacon_switch(struct vc_data *c)
 		scr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,
 			    c->vc_screenbuf_size > vga_vram_size ?
 				vga_vram_size : c->vc_screenbuf_size);
-		vgacon_doresize(c, c->vc_cols, c->vc_rows);
+		if (!(vga_video_num_columns % 2) &&
+		    vga_video_num_columns <= ORIG_VIDEO_COLS &&
+		    vga_video_num_lines <= (ORIG_VIDEO_LINES *
+			vga_default_font_height) / c->vc_font.height)
+			vgacon_doresize(c, c->vc_cols, c->vc_rows);
 	}
 
 	return 0;		/* Redrawing not needed */
@@ -1023,7 +1027,8 @@ static int vgacon_resize(struct vc_data *c, unsigned int width,
 	if (width % 2 || width > ORIG_VIDEO_COLS ||
 	    height > (ORIG_VIDEO_LINES * vga_default_font_height)/
 	    c->vc_font.height)
-		return -EINVAL;
+		/* let svgatextmode tinker with video timings */
+		return 0;
 
 	if (CON_IS_VISIBLE(c) && !vga_is_gfx) /* who knows */
 		vgacon_doresize(c, width, height);

commit 6d36ba629e0ef47a03d3703ee1d38143c25532a8
Author: Antonino A. Daplas <adaplas@gmail.com>
Date:   Thu Sep 15 21:14:56 2005 +0800

    [PATCH] vgacon: Fix sanity checking in vgacon_resize
    
    Reported by: walt <wa1ter@myrealbox.com>
    
    "I routinely switch the console font during bootup to
    8x8 so I can get 50 lines per screen.  Until 09 Sept,
    just changing to the small font automatically gave me
    all 50 lines -- but now I'm only getting 25 lines even
    with the small font.  The bottom half of the screen
    displays the text that already scrolled off the top."
    
    This bug is due to an erroneous check in the recently added hook,
    vgacon_resize(). It checks the new height against the original number of
    rows of the console. Because the original number of rows depends on both
    the scanline and the font height, check it instead against the
    scanline/fontheight.
    
    Signed-off-by: Antonino Daplas <adaplas@pol.net>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 0705cd741411..6ef6f7760e47 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -1020,7 +1020,9 @@ static int vgacon_font_get(struct vc_data *c, struct console_font *font)
 static int vgacon_resize(struct vc_data *c, unsigned int width,
 				unsigned int height)
 {
-	if (width % 2 || width > ORIG_VIDEO_COLS || height > ORIG_VIDEO_LINES)
+	if (width % 2 || width > ORIG_VIDEO_COLS ||
+	    height > (ORIG_VIDEO_LINES * vga_default_font_height)/
+	    c->vc_font.height)
 		return -EINVAL;
 
 	if (CON_IS_VISIBLE(c) && !vga_is_gfx) /* who knows */

commit 28254d439b8c65f93cb331f5aa741efa6a8ec62f
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Fri Sep 9 13:01:58 2005 -0700

    [PATCH] vga text console and stty cols/rows
    
    Some people use 66-cells braille devices for reading the console, and hence
    would like to reduce the width of the screen by using:
    
    stty cols 66
    
    However, the vga text console doesn't behave correctly: the 14 first
    characters of the second line are put on the right of the first line and so
    forth.
    
    Here is a patch to correct that.  It corrects the disp_end and offset
    registers of the vga board on console resize and console switch.
    
    On usual screens, you then correctly get a right and/or bottom blank
    margin.  On some laptop panels, the output is resized so that text actually
    gets magnified, which can be great for some people (see
    http://dept-info.labri.fr/~thibault/ls.jpg ).
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index d27fa91e5886..0705cd741411 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -497,6 +497,57 @@ static void vgacon_cursor(struct vc_data *c, int mode)
 	}
 }
 
+static int vgacon_doresize(struct vc_data *c,
+		unsigned int width, unsigned int height)
+{
+	unsigned long flags;
+	unsigned int scanlines = height * c->vc_font.height;
+	u8 scanlines_lo, r7, vsync_end, mode;
+
+	spin_lock_irqsave(&vga_lock, flags);
+
+	outb_p(VGA_CRTC_MODE, vga_video_port_reg);
+	mode = inb_p(vga_video_port_val);
+
+	if (mode & 0x04)
+		scanlines >>= 1;
+
+	scanlines -= 1;
+	scanlines_lo = scanlines & 0xff;
+
+	outb_p(VGA_CRTC_OVERFLOW, vga_video_port_reg);
+	r7 = inb_p(vga_video_port_val) & ~0x42;
+
+	if (scanlines & 0x100)
+		r7 |= 0x02;
+	if (scanlines & 0x200)
+		r7 |= 0x40;
+
+	/* deprotect registers */
+	outb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);
+	vsync_end = inb_p(vga_video_port_val);
+	outb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);
+	outb_p(vsync_end & ~0x80, vga_video_port_val);
+
+	outb_p(VGA_CRTC_H_DISP, vga_video_port_reg);
+	outb_p(width - 1, vga_video_port_val);
+	outb_p(VGA_CRTC_OFFSET, vga_video_port_reg);
+	outb_p(width >> 1, vga_video_port_val);
+
+	outb_p(VGA_CRTC_V_DISP_END, vga_video_port_reg);
+	outb_p(scanlines_lo, vga_video_port_val);
+	outb_p(VGA_CRTC_OVERFLOW, vga_video_port_reg);
+	outb_p(r7,vga_video_port_val);
+
+	/* reprotect registers */
+	outb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);
+	outb_p(vsync_end, vga_video_port_val);
+
+	spin_unlock_irqrestore(&vga_lock, flags);
+
+	return 0;
+}
+
 static int vgacon_switch(struct vc_data *c)
 {
 	/*
@@ -510,9 +561,13 @@ static int vgacon_switch(struct vc_data *c)
 	/* We can only copy out the size of the video buffer here,
 	 * otherwise we get into VGA BIOS */
 
-	if (!vga_is_gfx)
+	if (!vga_is_gfx) {
 		scr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,
-			    c->vc_screenbuf_size > vga_vram_size ? vga_vram_size : c->vc_screenbuf_size);
+			    c->vc_screenbuf_size > vga_vram_size ?
+				vga_vram_size : c->vc_screenbuf_size);
+		vgacon_doresize(c, c->vc_cols, c->vc_rows);
+	}
+
 	return 0;		/* Redrawing not needed */
 }
 
@@ -962,6 +1017,17 @@ static int vgacon_font_get(struct vc_data *c, struct console_font *font)
 
 #endif
 
+static int vgacon_resize(struct vc_data *c, unsigned int width,
+				unsigned int height)
+{
+	if (width % 2 || width > ORIG_VIDEO_COLS || height > ORIG_VIDEO_LINES)
+		return -EINVAL;
+
+	if (CON_IS_VISIBLE(c) && !vga_is_gfx) /* who knows */
+		vgacon_doresize(c, width, height);
+	return 0;
+}
+
 static int vgacon_scrolldelta(struct vc_data *c, int lines)
 {
 	if (!lines)		/* Turn scrollback off */
@@ -1103,6 +1169,7 @@ const struct consw vga_con = {
 	.con_blank = vgacon_blank,
 	.con_font_set = vgacon_font_set,
 	.con_font_get = vgacon_font_get,
+	.con_resize = vgacon_resize,
 	.con_set_palette = vgacon_set_palette,
 	.con_scrolldelta = vgacon_scrolldelta,
 	.con_set_origin = vgacon_set_origin,

commit f18cd8f7053a1e6755d1c1396884b2bfa1577e54
Author: James Simmons <jsimmons@pentafluge.infradead.org>
Date:   Tue Jun 21 17:17:00 2005 -0700

    [PATCH] VGA to fbcon fix.
    
    Currently when going from vgacon to fbcon the VT screenbuffer are often
    different sizes.  In the case when they are different sizes a new VT
    screenbuffer is allocated and the contents are copied into the new buffer.
    
    Currently the amount copied from VGA text memory to the new screenbuf is
    the size of the framebuffer console.  If the framebuffer console new VT
    screen buffer is greater than the VGA text memory size then we get some of
    the VGA BIOS contents as well.
    
    This patch will only allow you to copy up to the size of VGA text memory
    now.  The rest is filled with erase characters.
    
    Initial patch by Jordan Crouse <jordan.crouse@amd.com>
    
    Signed-off-by: James Simmons <jsimmons@www.infradead.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index bcf59b28a14f..d27fa91e5886 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -95,6 +95,7 @@ static unsigned long vgacon_uni_pagedir[2];
 /* Description of the hardware situation */
 static unsigned long	vga_vram_base;		/* Base of video memory */
 static unsigned long	vga_vram_end;		/* End of video memory */
+static int		vga_vram_size;		/* Size of video memory */
 static u16		vga_video_port_reg;	/* Video register select port */
 static u16		vga_video_port_val;	/* Video register value port */
 static unsigned int	vga_video_num_columns;	/* Number of text columns */
@@ -288,6 +289,7 @@ static const char __init *vgacon_startup(void)
 
 	vga_vram_base = VGA_MAP_MEM(vga_vram_base);
 	vga_vram_end = VGA_MAP_MEM(vga_vram_end);
+	vga_vram_size = vga_vram_end - vga_vram_base;
 
 	/*
 	 *      Find out if there is a graphics card present.
@@ -504,9 +506,13 @@ static int vgacon_switch(struct vc_data *c)
 	 */
 	vga_video_num_columns = c->vc_cols;
 	vga_video_num_lines = c->vc_rows;
+
+	/* We can only copy out the size of the video buffer here,
+	 * otherwise we get into VGA BIOS */
+
 	if (!vga_is_gfx)
 		scr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,
-			    c->vc_screenbuf_size);
+			    c->vc_screenbuf_size > vga_vram_size ? vga_vram_size : c->vc_screenbuf_size);
 	return 0;		/* Redrawing not needed */
 }
 
@@ -961,7 +967,6 @@ static int vgacon_scrolldelta(struct vc_data *c, int lines)
 	if (!lines)		/* Turn scrollback off */
 		c->vc_visible_origin = c->vc_origin;
 	else {
-		int vram_size = vga_vram_end - vga_vram_base;
 		int margin = c->vc_size_row * 4;
 		int ul, we, p, st;
 
@@ -971,7 +976,7 @@ static int vgacon_scrolldelta(struct vc_data *c, int lines)
 			we = vga_rolled_over + c->vc_size_row;
 		} else {
 			ul = 0;
-			we = vram_size;
+			we = vga_vram_size;
 		}
 		p = (c->vc_visible_origin - vga_vram_base - ul + we) % we +
 		    lines * c->vc_size_row;
@@ -1012,9 +1017,13 @@ static void vgacon_save_screen(struct vc_data *c)
 		c->vc_x = ORIG_X;
 		c->vc_y = ORIG_Y;
 	}
+
+	/* We can't copy in more then the size of the video buffer,
+	 * or we'll be copying in VGA BIOS */
+
 	if (!vga_is_gfx)
 		scr_memcpyw((u16 *) c->vc_screenbuf, (u16 *) c->vc_origin,
-			    c->vc_screenbuf_size);
+			    c->vc_screenbuf_size > vga_vram_size ? vga_vram_size : c->vc_screenbuf_size);
 }
 
 static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,

commit a40920b42ae232fac514cc4a1eb92996114af340
Author: Bill Nottingham <notting@redhat.com>
Date:   Sun May 1 08:59:07 2005 -0700

    [PATCH] vgacon: set vc_hi_font_mask correctly
    
    When allocating a new VC with vgacon_init(), the font is shared across all
    the VGA consoles.  However, the font mask was always set to the default
    value of zero in visual_init(), even if we were using 512 character fonts
    at the time.
    
    Moreover, code in vgacon.c:vga_do_font_op() didn't reset the mask if the
    console driver thinks it's already in 512 character mode.  This means that
    to *fix* it, you'd actually have to take the console out of 512 character
    mode and then set it back.
    
    The attached sets vc_hi_font_mask in vgacon_init() for any new consoles
    opened if the vgacon driver is already in 512 character mode, solving this.
    
    This bug goes back to 2.4.18 at least, probably earlier.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index 7d1ae06667c6..bcf59b28a14f 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -337,6 +337,8 @@ static void vgacon_init(struct vc_data *c, int init)
 	c->vc_scan_lines = vga_scan_lines;
 	c->vc_font.height = vga_video_font_height;
 	c->vc_complement_mask = 0x7700;
+	if (vga_512_chars)
+		c->vc_hi_font_mask = 0x0800;
 	p = *c->vc_uni_pagedir_loc;
 	if (c->vc_uni_pagedir_loc == &c->vc_uni_pagedir ||
 	    !--c->vc_uni_pagedir_loc[1])

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
new file mode 100644
index 000000000000..7d1ae06667c6
--- /dev/null
+++ b/drivers/video/console/vgacon.c
@@ -0,0 +1,1103 @@
+/*
+ *  linux/drivers/video/vgacon.c -- Low level VGA based console driver
+ *
+ *	Created 28 Sep 1997 by Geert Uytterhoeven
+ *
+ *	Rewritten by Martin Mares <mj@ucw.cz>, July 1998
+ *
+ *  This file is based on the old console.c, vga.c and vesa_blank.c drivers.
+ *
+ *	Copyright (C) 1991, 1992  Linus Torvalds
+ *			    1995  Jay Estabrook
+ *
+ *	User definable mapping table and font loading by Eugene G. Crosser,
+ *	<crosser@average.org>
+ *
+ *	Improved loadable font/UTF-8 support by H. Peter Anvin
+ *	Feb-Sep 1995 <peter.anvin@linux.org>
+ *
+ *	Colour palette handling, by Simon Tatham
+ *	17-Jun-95 <sgt20@cam.ac.uk>
+ *
+ *	if 512 char mode is already enabled don't re-enable it,
+ *	because it causes screen to flicker, by Mitja Horvat
+ *	5-May-96 <mitja.horvat@guest.arnes.si>
+ *
+ *	Use 2 outw instead of 4 outb_p to reduce erroneous text
+ *	flashing on RHS of screen during heavy console scrolling .
+ *	Oct 1996, Paul Gortmaker.
+ *
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/tty.h>
+#include <linux/console.h>
+#include <linux/string.h>
+#include <linux/kd.h>
+#include <linux/slab.h>
+#include <linux/vt_kern.h>
+#include <linux/selection.h>
+#include <linux/spinlock.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/smp_lock.h>
+#include <video/vga.h>
+#include <asm/io.h>
+
+static DEFINE_SPINLOCK(vga_lock);
+static int cursor_size_lastfrom;
+static int cursor_size_lastto;
+static struct vgastate state;
+
+#define BLANK 0x0020
+
+#define CAN_LOAD_EGA_FONTS	/* undefine if the user must not do this */
+#define CAN_LOAD_PALETTE	/* undefine if the user must not do this */
+
+/* You really do _NOT_ want to define this, unless you have buggy
+ * Trident VGA which will resize cursor when moving it between column
+ * 15 & 16. If you define this and your VGA is OK, inverse bug will
+ * appear.
+ */
+#undef TRIDENT_GLITCH
+
+/*
+ *  Interface used by the world
+ */
+
+static const char *vgacon_startup(void);
+static void vgacon_init(struct vc_data *c, int init);
+static void vgacon_deinit(struct vc_data *c);
+static void vgacon_cursor(struct vc_data *c, int mode);
+static int vgacon_switch(struct vc_data *c);
+static int vgacon_blank(struct vc_data *c, int blank, int mode_switch);
+static int vgacon_set_palette(struct vc_data *vc, unsigned char *table);
+static int vgacon_scrolldelta(struct vc_data *c, int lines);
+static int vgacon_set_origin(struct vc_data *c);
+static void vgacon_save_screen(struct vc_data *c);
+static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,
+			 int lines);
+static u8 vgacon_build_attr(struct vc_data *c, u8 color, u8 intensity,
+			    u8 blink, u8 underline, u8 reverse);
+static void vgacon_invert_region(struct vc_data *c, u16 * p, int count);
+static unsigned long vgacon_uni_pagedir[2];
+
+
+/* Description of the hardware situation */
+static unsigned long	vga_vram_base;		/* Base of video memory */
+static unsigned long	vga_vram_end;		/* End of video memory */
+static u16		vga_video_port_reg;	/* Video register select port */
+static u16		vga_video_port_val;	/* Video register value port */
+static unsigned int	vga_video_num_columns;	/* Number of text columns */
+static unsigned int	vga_video_num_lines;	/* Number of text lines */
+static int		vga_can_do_color = 0;	/* Do we support colors? */
+static unsigned int	vga_default_font_height;/* Height of default screen font */
+static unsigned char	vga_video_type;		/* Card type */
+static unsigned char	vga_hardscroll_enabled;
+static unsigned char	vga_hardscroll_user_enable = 1;
+static unsigned char	vga_font_is_default = 1;
+static int		vga_vesa_blanked;
+static int 		vga_palette_blanked;
+static int 		vga_is_gfx;
+static int 		vga_512_chars;
+static int 		vga_video_font_height;
+static int 		vga_scan_lines;
+static unsigned int 	vga_rolled_over = 0;
+
+static int __init no_scroll(char *str)
+{
+	/*
+	 * Disabling scrollback is required for the Braillex ib80-piezo
+	 * Braille reader made by F.H. Papenmeier (Germany).
+	 * Use the "no-scroll" bootflag.
+	 */
+	vga_hardscroll_user_enable = vga_hardscroll_enabled = 0;
+	return 1;
+}
+
+__setup("no-scroll", no_scroll);
+
+/*
+ * By replacing the four outb_p with two back to back outw, we can reduce
+ * the window of opportunity to see text mislocated to the RHS of the
+ * console during heavy scrolling activity. However there is the remote
+ * possibility that some pre-dinosaur hardware won't like the back to back
+ * I/O. Since the Xservers get away with it, we should be able to as well.
+ */
+static inline void write_vga(unsigned char reg, unsigned int val)
+{
+	unsigned int v1, v2;
+	unsigned long flags;
+
+	/*
+	 * ddprintk might set the console position from interrupt
+	 * handlers, thus the write has to be IRQ-atomic.
+	 */
+	spin_lock_irqsave(&vga_lock, flags);
+
+#ifndef SLOW_VGA
+	v1 = reg + (val & 0xff00);
+	v2 = reg + 1 + ((val << 8) & 0xff00);
+	outw(v1, vga_video_port_reg);
+	outw(v2, vga_video_port_reg);
+#else
+	outb_p(reg, vga_video_port_reg);
+	outb_p(val >> 8, vga_video_port_val);
+	outb_p(reg + 1, vga_video_port_reg);
+	outb_p(val & 0xff, vga_video_port_val);
+#endif
+	spin_unlock_irqrestore(&vga_lock, flags);
+}
+
+static const char __init *vgacon_startup(void)
+{
+	const char *display_desc = NULL;
+	u16 saved1, saved2;
+	volatile u16 *p;
+
+	if (ORIG_VIDEO_ISVGA == VIDEO_TYPE_VLFB) {
+	      no_vga:
+#ifdef CONFIG_DUMMY_CONSOLE
+		conswitchp = &dummy_con;
+		return conswitchp->con_startup();
+#else
+		return NULL;
+#endif
+	}
+
+	/* VGA16 modes are not handled by VGACON */
+	if ((ORIG_VIDEO_MODE == 0x0D) ||	/* 320x200/4 */
+	    (ORIG_VIDEO_MODE == 0x0E) ||	/* 640x200/4 */
+	    (ORIG_VIDEO_MODE == 0x10) ||	/* 640x350/4 */
+	    (ORIG_VIDEO_MODE == 0x12) ||	/* 640x480/4 */
+	    (ORIG_VIDEO_MODE == 0x6A))	/* 800x600/4, 0x6A is very common */
+		goto no_vga;
+
+	vga_video_num_lines = ORIG_VIDEO_LINES;
+	vga_video_num_columns = ORIG_VIDEO_COLS;
+	state.vgabase = NULL;
+
+	if (ORIG_VIDEO_MODE == 7) {	/* Is this a monochrome display? */
+		vga_vram_base = 0xb0000;
+		vga_video_port_reg = VGA_CRT_IM;
+		vga_video_port_val = VGA_CRT_DM;
+		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10) {
+			static struct resource ega_console_resource =
+			    { "ega", 0x3B0, 0x3BF };
+			vga_video_type = VIDEO_TYPE_EGAM;
+			vga_vram_end = 0xb8000;
+			display_desc = "EGA+";
+			request_resource(&ioport_resource,
+					 &ega_console_resource);
+		} else {
+			static struct resource mda1_console_resource =
+			    { "mda", 0x3B0, 0x3BB };
+			static struct resource mda2_console_resource =
+			    { "mda", 0x3BF, 0x3BF };
+			vga_video_type = VIDEO_TYPE_MDA;
+			vga_vram_end = 0xb2000;
+			display_desc = "*MDA";
+			request_resource(&ioport_resource,
+					 &mda1_console_resource);
+			request_resource(&ioport_resource,
+					 &mda2_console_resource);
+			vga_video_font_height = 14;
+		}
+	} else {
+		/* If not, it is color. */
+		vga_can_do_color = 1;
+		vga_vram_base = 0xb8000;
+		vga_video_port_reg = VGA_CRT_IC;
+		vga_video_port_val = VGA_CRT_DC;
+		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10) {
+			int i;
+
+			vga_vram_end = 0xc0000;
+
+			if (!ORIG_VIDEO_ISVGA) {
+				static struct resource ega_console_resource
+				    = { "ega", 0x3C0, 0x3DF };
+				vga_video_type = VIDEO_TYPE_EGAC;
+				display_desc = "EGA";
+				request_resource(&ioport_resource,
+						 &ega_console_resource);
+			} else {
+				static struct resource vga_console_resource
+				    = { "vga+", 0x3C0, 0x3DF };
+				vga_video_type = VIDEO_TYPE_VGAC;
+				display_desc = "VGA+";
+				request_resource(&ioport_resource,
+						 &vga_console_resource);
+
+#ifdef VGA_CAN_DO_64KB
+				/*
+				 * get 64K rather than 32K of video RAM.
+				 * This doesn't actually work on all "VGA"
+				 * controllers (it seems like setting MM=01
+				 * and COE=1 isn't necessarily a good idea)
+				 */
+				vga_vram_base = 0xa0000;
+				vga_vram_end = 0xb0000;
+				outb_p(6, VGA_GFX_I);
+				outb_p(6, VGA_GFX_D);
+#endif
+				/*
+				 * Normalise the palette registers, to point
+				 * the 16 screen colours to the first 16
+				 * DAC entries.
+				 */
+
+				for (i = 0; i < 16; i++) {
+					inb_p(VGA_IS1_RC);
+					outb_p(i, VGA_ATT_W);
+					outb_p(i, VGA_ATT_W);
+				}
+				outb_p(0x20, VGA_ATT_W);
+
+				/*
+				 * Now set the DAC registers back to their
+				 * default values
+				 */
+				for (i = 0; i < 16; i++) {
+					outb_p(color_table[i], VGA_PEL_IW);
+					outb_p(default_red[i], VGA_PEL_D);
+					outb_p(default_grn[i], VGA_PEL_D);
+					outb_p(default_blu[i], VGA_PEL_D);
+				}
+			}
+		} else {
+			static struct resource cga_console_resource =
+			    { "cga", 0x3D4, 0x3D5 };
+			vga_video_type = VIDEO_TYPE_CGA;
+			vga_vram_end = 0xba000;
+			display_desc = "*CGA";
+			request_resource(&ioport_resource,
+					 &cga_console_resource);
+			vga_video_font_height = 8;
+		}
+	}
+
+	vga_vram_base = VGA_MAP_MEM(vga_vram_base);
+	vga_vram_end = VGA_MAP_MEM(vga_vram_end);
+
+	/*
+	 *      Find out if there is a graphics card present.
+	 *      Are there smarter methods around?
+	 */
+	p = (volatile u16 *) vga_vram_base;
+	saved1 = scr_readw(p);
+	saved2 = scr_readw(p + 1);
+	scr_writew(0xAA55, p);
+	scr_writew(0x55AA, p + 1);
+	if (scr_readw(p) != 0xAA55 || scr_readw(p + 1) != 0x55AA) {
+		scr_writew(saved1, p);
+		scr_writew(saved2, p + 1);
+		goto no_vga;
+	}
+	scr_writew(0x55AA, p);
+	scr_writew(0xAA55, p + 1);
+	if (scr_readw(p) != 0x55AA || scr_readw(p + 1) != 0xAA55) {
+		scr_writew(saved1, p);
+		scr_writew(saved2, p + 1);
+		goto no_vga;
+	}
+	scr_writew(saved1, p);
+	scr_writew(saved2, p + 1);
+
+	if (vga_video_type == VIDEO_TYPE_EGAC
+	    || vga_video_type == VIDEO_TYPE_VGAC
+	    || vga_video_type == VIDEO_TYPE_EGAM) {
+		vga_hardscroll_enabled = vga_hardscroll_user_enable;
+		vga_default_font_height = ORIG_VIDEO_POINTS;
+		vga_video_font_height = ORIG_VIDEO_POINTS;
+		/* This may be suboptimal but is a safe bet - go with it */
+		vga_scan_lines =
+		    vga_video_font_height * vga_video_num_lines;
+	}
+	return display_desc;
+}
+
+static void vgacon_init(struct vc_data *c, int init)
+{
+	unsigned long p;
+
+	/* We cannot be loaded as a module, therefore init is always 1 */
+	c->vc_can_do_color = vga_can_do_color;
+	c->vc_cols = vga_video_num_columns;
+	c->vc_rows = vga_video_num_lines;
+	c->vc_scan_lines = vga_scan_lines;
+	c->vc_font.height = vga_video_font_height;
+	c->vc_complement_mask = 0x7700;
+	p = *c->vc_uni_pagedir_loc;
+	if (c->vc_uni_pagedir_loc == &c->vc_uni_pagedir ||
+	    !--c->vc_uni_pagedir_loc[1])
+		con_free_unimap(c);
+	c->vc_uni_pagedir_loc = vgacon_uni_pagedir;
+	vgacon_uni_pagedir[1]++;
+	if (!vgacon_uni_pagedir[0] && p)
+		con_set_default_unimap(c);
+}
+
+static inline void vga_set_mem_top(struct vc_data *c)
+{
+	write_vga(12, (c->vc_visible_origin - vga_vram_base) / 2);
+}
+
+static void vgacon_deinit(struct vc_data *c)
+{
+	/* When closing the last console, reset video origin */
+	if (!--vgacon_uni_pagedir[1]) {
+		c->vc_visible_origin = vga_vram_base;
+		vga_set_mem_top(c);
+		con_free_unimap(c);
+	}
+	c->vc_uni_pagedir_loc = &c->vc_uni_pagedir;
+	con_set_default_unimap(c);
+}
+
+static u8 vgacon_build_attr(struct vc_data *c, u8 color, u8 intensity,
+			    u8 blink, u8 underline, u8 reverse)
+{
+	u8 attr = color;
+
+	if (vga_can_do_color) {
+		if (underline)
+			attr = (attr & 0xf0) | c->vc_ulcolor;
+		else if (intensity == 0)
+			attr = (attr & 0xf0) | c->vc_halfcolor;
+	}
+	if (reverse)
+		attr =
+		    ((attr) & 0x88) | ((((attr) >> 4) | ((attr) << 4)) &
+				       0x77);
+	if (blink)
+		attr ^= 0x80;
+	if (intensity == 2)
+		attr ^= 0x08;
+	if (!vga_can_do_color) {
+		if (underline)
+			attr = (attr & 0xf8) | 0x01;
+		else if (intensity == 0)
+			attr = (attr & 0xf0) | 0x08;
+	}
+	return attr;
+}
+
+static void vgacon_invert_region(struct vc_data *c, u16 * p, int count)
+{
+	int col = vga_can_do_color;
+
+	while (count--) {
+		u16 a = scr_readw(p);
+		if (col)
+			a = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) |
+			    (((a) & 0x0700) << 4);
+		else
+			a ^= ((a & 0x0700) == 0x0100) ? 0x7000 : 0x7700;
+		scr_writew(a, p++);
+	}
+}
+
+static void vgacon_set_cursor_size(int xpos, int from, int to)
+{
+	unsigned long flags;
+	int curs, cure;
+
+#ifdef TRIDENT_GLITCH
+	if (xpos < 16)
+		from--, to--;
+#endif
+
+	if ((from == cursor_size_lastfrom) && (to == cursor_size_lastto))
+		return;
+	cursor_size_lastfrom = from;
+	cursor_size_lastto = to;
+
+	spin_lock_irqsave(&vga_lock, flags);
+	outb_p(0x0a, vga_video_port_reg);	/* Cursor start */
+	curs = inb_p(vga_video_port_val);
+	outb_p(0x0b, vga_video_port_reg);	/* Cursor end */
+	cure = inb_p(vga_video_port_val);
+
+	curs = (curs & 0xc0) | from;
+	cure = (cure & 0xe0) | to;
+
+	outb_p(0x0a, vga_video_port_reg);	/* Cursor start */
+	outb_p(curs, vga_video_port_val);
+	outb_p(0x0b, vga_video_port_reg);	/* Cursor end */
+	outb_p(cure, vga_video_port_val);
+	spin_unlock_irqrestore(&vga_lock, flags);
+}
+
+static void vgacon_cursor(struct vc_data *c, int mode)
+{
+	if (c->vc_origin != c->vc_visible_origin)
+		vgacon_scrolldelta(c, 0);
+	switch (mode) {
+	case CM_ERASE:
+		write_vga(14, (vga_vram_end - vga_vram_base - 1) / 2);
+		break;
+
+	case CM_MOVE:
+	case CM_DRAW:
+		write_vga(14, (c->vc_pos - vga_vram_base) / 2);
+		switch (c->vc_cursor_type & 0x0f) {
+		case CUR_UNDERLINE:
+			vgacon_set_cursor_size(c->vc_x,
+					       c->vc_font.height -
+					       (c->vc_font.height <
+						10 ? 2 : 3),
+					       c->vc_font.height -
+					       (c->vc_font.height <
+						10 ? 1 : 2));
+			break;
+		case CUR_TWO_THIRDS:
+			vgacon_set_cursor_size(c->vc_x,
+					       c->vc_font.height / 3,
+					       c->vc_font.height -
+					       (c->vc_font.height <
+						10 ? 1 : 2));
+			break;
+		case CUR_LOWER_THIRD:
+			vgacon_set_cursor_size(c->vc_x,
+					       (c->vc_font.height * 2) / 3,
+					       c->vc_font.height -
+					       (c->vc_font.height <
+						10 ? 1 : 2));
+			break;
+		case CUR_LOWER_HALF:
+			vgacon_set_cursor_size(c->vc_x,
+					       c->vc_font.height / 2,
+					       c->vc_font.height -
+					       (c->vc_font.height <
+						10 ? 1 : 2));
+			break;
+		case CUR_NONE:
+			vgacon_set_cursor_size(c->vc_x, 31, 30);
+			break;
+		default:
+			vgacon_set_cursor_size(c->vc_x, 1,
+					       c->vc_font.height);
+			break;
+		}
+		break;
+	}
+}
+
+static int vgacon_switch(struct vc_data *c)
+{
+	/*
+	 * We need to save screen size here as it's the only way
+	 * we can spot the screen has been resized and we need to
+	 * set size of freshly allocated screens ourselves.
+	 */
+	vga_video_num_columns = c->vc_cols;
+	vga_video_num_lines = c->vc_rows;
+	if (!vga_is_gfx)
+		scr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,
+			    c->vc_screenbuf_size);
+	return 0;		/* Redrawing not needed */
+}
+
+static void vga_set_palette(struct vc_data *vc, unsigned char *table)
+{
+	int i, j;
+
+	for (i = j = 0; i < 16; i++) {
+		vga_w(state.vgabase, VGA_PEL_IW, table[i]);
+		vga_w(state.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);
+		vga_w(state.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);
+		vga_w(state.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);
+	}
+}
+
+static int vgacon_set_palette(struct vc_data *vc, unsigned char *table)
+{
+#ifdef CAN_LOAD_PALETTE
+	if (vga_video_type != VIDEO_TYPE_VGAC || vga_palette_blanked
+	    || !CON_IS_VISIBLE(vc))
+		return -EINVAL;
+	vga_set_palette(vc, table);
+	return 0;
+#else
+	return -EINVAL;
+#endif
+}
+
+/* structure holding original VGA register settings */
+static struct {
+	unsigned char SeqCtrlIndex;	/* Sequencer Index reg.   */
+	unsigned char CrtCtrlIndex;	/* CRT-Contr. Index reg.  */
+	unsigned char CrtMiscIO;	/* Miscellaneous register */
+	unsigned char HorizontalTotal;	/* CRT-Controller:00h */
+	unsigned char HorizDisplayEnd;	/* CRT-Controller:01h */
+	unsigned char StartHorizRetrace;	/* CRT-Controller:04h */
+	unsigned char EndHorizRetrace;	/* CRT-Controller:05h */
+	unsigned char Overflow;	/* CRT-Controller:07h */
+	unsigned char StartVertRetrace;	/* CRT-Controller:10h */
+	unsigned char EndVertRetrace;	/* CRT-Controller:11h */
+	unsigned char ModeControl;	/* CRT-Controller:17h */
+	unsigned char ClockingMode;	/* Seq-Controller:01h */
+} vga_state;
+
+static void vga_vesa_blank(struct vgastate *state, int mode)
+{
+	/* save original values of VGA controller registers */
+	if (!vga_vesa_blanked) {
+		spin_lock_irq(&vga_lock);
+		vga_state.SeqCtrlIndex = vga_r(state->vgabase, VGA_SEQ_I);
+		vga_state.CrtCtrlIndex = inb_p(vga_video_port_reg);
+		vga_state.CrtMiscIO = vga_r(state->vgabase, VGA_MIS_R);
+		spin_unlock_irq(&vga_lock);
+
+		outb_p(0x00, vga_video_port_reg);	/* HorizontalTotal */
+		vga_state.HorizontalTotal = inb_p(vga_video_port_val);
+		outb_p(0x01, vga_video_port_reg);	/* HorizDisplayEnd */
+		vga_state.HorizDisplayEnd = inb_p(vga_video_port_val);
+		outb_p(0x04, vga_video_port_reg);	/* StartHorizRetrace */
+		vga_state.StartHorizRetrace = inb_p(vga_video_port_val);
+		outb_p(0x05, vga_video_port_reg);	/* EndHorizRetrace */
+		vga_state.EndHorizRetrace = inb_p(vga_video_port_val);
+		outb_p(0x07, vga_video_port_reg);	/* Overflow */
+		vga_state.Overflow = inb_p(vga_video_port_val);
+		outb_p(0x10, vga_video_port_reg);	/* StartVertRetrace */
+		vga_state.StartVertRetrace = inb_p(vga_video_port_val);
+		outb_p(0x11, vga_video_port_reg);	/* EndVertRetrace */
+		vga_state.EndVertRetrace = inb_p(vga_video_port_val);
+		outb_p(0x17, vga_video_port_reg);	/* ModeControl */
+		vga_state.ModeControl = inb_p(vga_video_port_val);
+		vga_state.ClockingMode = vga_rseq(state->vgabase, VGA_SEQ_CLOCK_MODE);
+	}
+
+	/* assure that video is enabled */
+	/* "0x20" is VIDEO_ENABLE_bit in register 01 of sequencer */
+	spin_lock_irq(&vga_lock);
+	vga_wseq(state->vgabase, VGA_SEQ_CLOCK_MODE, vga_state.ClockingMode | 0x20);
+
+	/* test for vertical retrace in process.... */
+	if ((vga_state.CrtMiscIO & 0x80) == 0x80)
+		vga_w(state->vgabase, VGA_MIS_W, vga_state.CrtMiscIO & 0xEF);
+
+	/*
+	 * Set <End of vertical retrace> to minimum (0) and
+	 * <Start of vertical Retrace> to maximum (incl. overflow)
+	 * Result: turn off vertical sync (VSync) pulse.
+	 */
+	if (mode & VESA_VSYNC_SUSPEND) {
+		outb_p(0x10, vga_video_port_reg);	/* StartVertRetrace */
+		outb_p(0xff, vga_video_port_val);	/* maximum value */
+		outb_p(0x11, vga_video_port_reg);	/* EndVertRetrace */
+		outb_p(0x40, vga_video_port_val);	/* minimum (bits 0..3)  */
+		outb_p(0x07, vga_video_port_reg);	/* Overflow */
+		outb_p(vga_state.Overflow | 0x84, vga_video_port_val);	/* bits 9,10 of vert. retrace */
+	}
+
+	if (mode & VESA_HSYNC_SUSPEND) {
+		/*
+		 * Set <End of horizontal retrace> to minimum (0) and
+		 *  <Start of horizontal Retrace> to maximum
+		 * Result: turn off horizontal sync (HSync) pulse.
+		 */
+		outb_p(0x04, vga_video_port_reg);	/* StartHorizRetrace */
+		outb_p(0xff, vga_video_port_val);	/* maximum */
+		outb_p(0x05, vga_video_port_reg);	/* EndHorizRetrace */
+		outb_p(0x00, vga_video_port_val);	/* minimum (0) */
+	}
+
+	/* restore both index registers */
+	vga_w(state->vgabase, VGA_SEQ_I, vga_state.SeqCtrlIndex);
+	outb_p(vga_state.CrtCtrlIndex, vga_video_port_reg);
+	spin_unlock_irq(&vga_lock);
+}
+
+static void vga_vesa_unblank(struct vgastate *state)
+{
+	/* restore original values of VGA controller registers */
+	spin_lock_irq(&vga_lock);
+	vga_w(state->vgabase, VGA_MIS_W, vga_state.CrtMiscIO);
+
+	outb_p(0x00, vga_video_port_reg);	/* HorizontalTotal */
+	outb_p(vga_state.HorizontalTotal, vga_video_port_val);
+	outb_p(0x01, vga_video_port_reg);	/* HorizDisplayEnd */
+	outb_p(vga_state.HorizDisplayEnd, vga_video_port_val);
+	outb_p(0x04, vga_video_port_reg);	/* StartHorizRetrace */
+	outb_p(vga_state.StartHorizRetrace, vga_video_port_val);
+	outb_p(0x05, vga_video_port_reg);	/* EndHorizRetrace */
+	outb_p(vga_state.EndHorizRetrace, vga_video_port_val);
+	outb_p(0x07, vga_video_port_reg);	/* Overflow */
+	outb_p(vga_state.Overflow, vga_video_port_val);
+	outb_p(0x10, vga_video_port_reg);	/* StartVertRetrace */
+	outb_p(vga_state.StartVertRetrace, vga_video_port_val);
+	outb_p(0x11, vga_video_port_reg);	/* EndVertRetrace */
+	outb_p(vga_state.EndVertRetrace, vga_video_port_val);
+	outb_p(0x17, vga_video_port_reg);	/* ModeControl */
+	outb_p(vga_state.ModeControl, vga_video_port_val);
+	/* ClockingMode */
+	vga_wseq(state->vgabase, VGA_SEQ_CLOCK_MODE, vga_state.ClockingMode);
+
+	/* restore index/control registers */
+	vga_w(state->vgabase, VGA_SEQ_I, vga_state.SeqCtrlIndex);
+	outb_p(vga_state.CrtCtrlIndex, vga_video_port_reg);
+	spin_unlock_irq(&vga_lock);
+}
+
+static void vga_pal_blank(struct vgastate *state)
+{
+	int i;
+
+	for (i = 0; i < 16; i++) {
+		vga_w(state->vgabase, VGA_PEL_IW, i);
+		vga_w(state->vgabase, VGA_PEL_D, 0);
+		vga_w(state->vgabase, VGA_PEL_D, 0);
+		vga_w(state->vgabase, VGA_PEL_D, 0);
+	}
+}
+
+static int vgacon_blank(struct vc_data *c, int blank, int mode_switch)
+{
+	switch (blank) {
+	case 0:		/* Unblank */
+		if (vga_vesa_blanked) {
+			vga_vesa_unblank(&state);
+			vga_vesa_blanked = 0;
+		}
+		if (vga_palette_blanked) {
+			vga_set_palette(c, color_table);
+			vga_palette_blanked = 0;
+			return 0;
+		}
+		vga_is_gfx = 0;
+		/* Tell console.c that it has to restore the screen itself */
+		return 1;
+	case 1:		/* Normal blanking */
+	case -1:	/* Obsolete */
+		if (!mode_switch && vga_video_type == VIDEO_TYPE_VGAC) {
+			vga_pal_blank(&state);
+			vga_palette_blanked = 1;
+			return 0;
+		}
+		vgacon_set_origin(c);
+		scr_memsetw((void *) vga_vram_base, BLANK,
+			    c->vc_screenbuf_size);
+		if (mode_switch)
+			vga_is_gfx = 1;
+		return 1;
+	default:		/* VESA blanking */
+		if (vga_video_type == VIDEO_TYPE_VGAC) {
+			vga_vesa_blank(&state, blank - 1);
+			vga_vesa_blanked = blank;
+		}
+		return 0;
+	}
+}
+
+/*
+ * PIO_FONT support.
+ *
+ * The font loading code goes back to the codepage package by
+ * Joel Hoffman (joel@wam.umd.edu). (He reports that the original
+ * reference is: "From: p. 307 of _Programmer's Guide to PC & PS/2
+ * Video Systems_ by Richard Wilton. 1987.  Microsoft Press".)
+ *
+ * Change for certain monochrome monitors by Yury Shevchuck
+ * (sizif@botik.yaroslavl.su).
+ */
+
+#ifdef CAN_LOAD_EGA_FONTS
+
+#define colourmap 0xa0000
+/* Pauline Middelink <middelin@polyware.iaf.nl> reports that we
+   should use 0xA0000 for the bwmap as well.. */
+#define blackwmap 0xa0000
+#define cmapsz 8192
+
+static int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)
+{
+	unsigned short video_port_status = vga_video_port_reg + 6;
+	int font_select = 0x00, beg, i;
+	char *charmap;
+	
+	if (vga_video_type != VIDEO_TYPE_EGAM) {
+		charmap = (char *) VGA_MAP_MEM(colourmap);
+		beg = 0x0e;
+#ifdef VGA_CAN_DO_64KB
+		if (vga_video_type == VIDEO_TYPE_VGAC)
+			beg = 0x06;
+#endif
+	} else {
+		charmap = (char *) VGA_MAP_MEM(blackwmap);
+		beg = 0x0a;
+	}
+
+#ifdef BROKEN_GRAPHICS_PROGRAMS
+	/*
+	 * All fonts are loaded in slot 0 (0:1 for 512 ch)
+	 */
+
+	if (!arg)
+		return -EINVAL;	/* Return to default font not supported */
+
+	vga_font_is_default = 0;
+	font_select = ch512 ? 0x04 : 0x00;
+#else
+	/*
+	 * The default font is kept in slot 0 and is never touched.
+	 * A custom font is loaded in slot 2 (256 ch) or 2:3 (512 ch)
+	 */
+
+	if (set) {
+		vga_font_is_default = !arg;
+		if (!arg)
+			ch512 = 0;	/* Default font is always 256 */
+		font_select = arg ? (ch512 ? 0x0e : 0x0a) : 0x00;
+	}
+
+	if (!vga_font_is_default)
+		charmap += 4 * cmapsz;
+#endif
+
+	unlock_kernel();
+	spin_lock_irq(&vga_lock);
+	/* First, the Sequencer */
+	vga_wseq(state->vgabase, VGA_SEQ_RESET, 0x1);
+	/* CPU writes only to map 2 */
+	vga_wseq(state->vgabase, VGA_SEQ_PLANE_WRITE, 0x04);	
+	/* Sequential addressing */
+	vga_wseq(state->vgabase, VGA_SEQ_MEMORY_MODE, 0x07);	
+	/* Clear synchronous reset */
+	vga_wseq(state->vgabase, VGA_SEQ_RESET, 0x03);
+
+	/* Now, the graphics controller, select map 2 */
+	vga_wgfx(state->vgabase, VGA_GFX_PLANE_READ, 0x02);		
+	/* disable odd-even addressing */
+	vga_wgfx(state->vgabase, VGA_GFX_MODE, 0x00);
+	/* map start at A000:0000 */
+	vga_wgfx(state->vgabase, VGA_GFX_MISC, 0x00);
+	spin_unlock_irq(&vga_lock);
+
+	if (arg) {
+		if (set)
+			for (i = 0; i < cmapsz; i++)
+				vga_writeb(arg[i], charmap + i);
+		else
+			for (i = 0; i < cmapsz; i++)
+				arg[i] = vga_readb(charmap + i);
+
+		/*
+		 * In 512-character mode, the character map is not contiguous if
+		 * we want to remain EGA compatible -- which we do
+		 */
+
+		if (ch512) {
+			charmap += 2 * cmapsz;
+			arg += cmapsz;
+			if (set)
+				for (i = 0; i < cmapsz; i++)
+					vga_writeb(arg[i], charmap + i);
+			else
+				for (i = 0; i < cmapsz; i++)
+					arg[i] = vga_readb(charmap + i);
+		}
+	}
+
+	spin_lock_irq(&vga_lock);
+	/* First, the sequencer, Synchronous reset */
+	vga_wseq(state->vgabase, VGA_SEQ_RESET, 0x01);	
+	/* CPU writes to maps 0 and 1 */
+	vga_wseq(state->vgabase, VGA_SEQ_PLANE_WRITE, 0x03);
+	/* odd-even addressing */
+	vga_wseq(state->vgabase, VGA_SEQ_MEMORY_MODE, 0x03);
+	/* Character Map Select */
+	if (set)
+		vga_wseq(state->vgabase, VGA_SEQ_CHARACTER_MAP, font_select);
+	/* clear synchronous reset */
+	vga_wseq(state->vgabase, VGA_SEQ_RESET, 0x03);
+
+	/* Now, the graphics controller, select map 0 for CPU */
+	vga_wgfx(state->vgabase, VGA_GFX_PLANE_READ, 0x00);
+	/* enable even-odd addressing */
+	vga_wgfx(state->vgabase, VGA_GFX_MODE, 0x10);
+	/* map starts at b800:0 or b000:0 */
+	vga_wgfx(state->vgabase, VGA_GFX_MISC, beg);
+
+	/* if 512 char mode is already enabled don't re-enable it. */
+	if ((set) && (ch512 != vga_512_chars)) {
+		int i;	
+		
+		/* attribute controller */
+		for (i = 0; i < MAX_NR_CONSOLES; i++) {
+			struct vc_data *c = vc_cons[i].d;
+			if (c && c->vc_sw == &vga_con)
+				c->vc_hi_font_mask = ch512 ? 0x0800 : 0;
+		}
+		vga_512_chars = ch512;
+		/* 256-char: enable intensity bit
+		   512-char: disable intensity bit */
+		inb_p(video_port_status);	/* clear address flip-flop */
+		/* color plane enable register */
+		vga_wattr(state->vgabase, VGA_ATC_PLANE_ENABLE, ch512 ? 0x07 : 0x0f);
+		/* Wilton (1987) mentions the following; I don't know what
+		   it means, but it works, and it appears necessary */
+		inb_p(video_port_status);
+		vga_wattr(state->vgabase, VGA_AR_ENABLE_DISPLAY, 0);	
+	}
+	spin_unlock_irq(&vga_lock);
+	lock_kernel();
+	return 0;
+}
+
+/*
+ * Adjust the screen to fit a font of a certain height
+ */
+static int vgacon_adjust_height(struct vc_data *vc, unsigned fontheight)
+{
+	unsigned char ovr, vde, fsr;
+	int rows, maxscan, i;
+
+	rows = vc->vc_scan_lines / fontheight;	/* Number of video rows we end up with */
+	maxscan = rows * fontheight - 1;	/* Scan lines to actually display-1 */
+
+	/* Reprogram the CRTC for the new font size
+	   Note: the attempt to read the overflow register will fail
+	   on an EGA, but using 0xff for the previous value appears to
+	   be OK for EGA text modes in the range 257-512 scan lines, so I
+	   guess we don't need to worry about it.
+
+	   The same applies for the spill bits in the font size and cursor
+	   registers; they are write-only on EGA, but it appears that they
+	   are all don't care bits on EGA, so I guess it doesn't matter. */
+
+	spin_lock_irq(&vga_lock);
+	outb_p(0x07, vga_video_port_reg);	/* CRTC overflow register */
+	ovr = inb_p(vga_video_port_val);
+	outb_p(0x09, vga_video_port_reg);	/* Font size register */
+	fsr = inb_p(vga_video_port_val);
+	spin_unlock_irq(&vga_lock);
+
+	vde = maxscan & 0xff;	/* Vertical display end reg */
+	ovr = (ovr & 0xbd) +	/* Overflow register */
+	    ((maxscan & 0x100) >> 7) + ((maxscan & 0x200) >> 3);
+	fsr = (fsr & 0xe0) + (fontheight - 1);	/*  Font size register */
+
+	spin_lock_irq(&vga_lock);
+	outb_p(0x07, vga_video_port_reg);	/* CRTC overflow register */
+	outb_p(ovr, vga_video_port_val);
+	outb_p(0x09, vga_video_port_reg);	/* Font size */
+	outb_p(fsr, vga_video_port_val);
+	outb_p(0x12, vga_video_port_reg);	/* Vertical display limit */
+	outb_p(vde, vga_video_port_val);
+	spin_unlock_irq(&vga_lock);
+
+	for (i = 0; i < MAX_NR_CONSOLES; i++) {
+		struct vc_data *c = vc_cons[i].d;
+
+		if (c && c->vc_sw == &vga_con) {
+			if (CON_IS_VISIBLE(c)) {
+			        /* void size to cause regs to be rewritten */
+				cursor_size_lastfrom = 0;
+				cursor_size_lastto = 0;
+				c->vc_sw->con_cursor(c, CM_DRAW);
+			}
+			c->vc_font.height = fontheight;
+			vc_resize(c, 0, rows);	/* Adjust console size */
+		}
+	}
+	return 0;
+}
+
+static int vgacon_font_set(struct vc_data *c, struct console_font *font, unsigned flags)
+{
+	unsigned charcount = font->charcount;
+	int rc;
+
+	if (vga_video_type < VIDEO_TYPE_EGAM)
+		return -EINVAL;
+
+	if (font->width != 8 || (charcount != 256 && charcount != 512))
+		return -EINVAL;
+
+	rc = vgacon_do_font_op(&state, font->data, 1, charcount == 512);
+	if (rc)
+		return rc;
+
+	if (!(flags & KD_FONT_FLAG_DONT_RECALC))
+		rc = vgacon_adjust_height(c, font->height);
+	return rc;
+}
+
+static int vgacon_font_get(struct vc_data *c, struct console_font *font)
+{
+	if (vga_video_type < VIDEO_TYPE_EGAM)
+		return -EINVAL;
+
+	font->width = 8;
+	font->height = c->vc_font.height;
+	font->charcount = vga_512_chars ? 512 : 256;
+	if (!font->data)
+		return 0;
+	return vgacon_do_font_op(&state, font->data, 0, 0);
+}
+
+#else
+
+#define vgacon_font_set NULL
+#define vgacon_font_get NULL
+
+#endif
+
+static int vgacon_scrolldelta(struct vc_data *c, int lines)
+{
+	if (!lines)		/* Turn scrollback off */
+		c->vc_visible_origin = c->vc_origin;
+	else {
+		int vram_size = vga_vram_end - vga_vram_base;
+		int margin = c->vc_size_row * 4;
+		int ul, we, p, st;
+
+		if (vga_rolled_over >
+		    (c->vc_scr_end - vga_vram_base) + margin) {
+			ul = c->vc_scr_end - vga_vram_base;
+			we = vga_rolled_over + c->vc_size_row;
+		} else {
+			ul = 0;
+			we = vram_size;
+		}
+		p = (c->vc_visible_origin - vga_vram_base - ul + we) % we +
+		    lines * c->vc_size_row;
+		st = (c->vc_origin - vga_vram_base - ul + we) % we;
+		if (st < 2 * margin)
+			margin = 0;
+		if (p < margin)
+			p = 0;
+		if (p > st - margin)
+			p = st;
+		c->vc_visible_origin = vga_vram_base + (p + ul) % we;
+	}
+	vga_set_mem_top(c);
+	return 1;
+}
+
+static int vgacon_set_origin(struct vc_data *c)
+{
+	if (vga_is_gfx ||	/* We don't play origin tricks in graphic modes */
+	    (console_blanked && !vga_palette_blanked))	/* Nor we write to blanked screens */
+		return 0;
+	c->vc_origin = c->vc_visible_origin = vga_vram_base;
+	vga_set_mem_top(c);
+	vga_rolled_over = 0;
+	return 1;
+}
+
+static void vgacon_save_screen(struct vc_data *c)
+{
+	static int vga_bootup_console = 0;
+
+	if (!vga_bootup_console) {
+		/* This is a gross hack, but here is the only place we can
+		 * set bootup console parameters without messing up generic
+		 * console initialization routines.
+		 */
+		vga_bootup_console = 1;
+		c->vc_x = ORIG_X;
+		c->vc_y = ORIG_Y;
+	}
+	if (!vga_is_gfx)
+		scr_memcpyw((u16 *) c->vc_screenbuf, (u16 *) c->vc_origin,
+			    c->vc_screenbuf_size);
+}
+
+static int vgacon_scroll(struct vc_data *c, int t, int b, int dir,
+			 int lines)
+{
+	unsigned long oldo;
+	unsigned int delta;
+
+	if (t || b != c->vc_rows || vga_is_gfx)
+		return 0;
+
+	if (c->vc_origin != c->vc_visible_origin)
+		vgacon_scrolldelta(c, 0);
+
+	if (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)
+		return 0;
+
+	oldo = c->vc_origin;
+	delta = lines * c->vc_size_row;
+	if (dir == SM_UP) {
+		if (c->vc_scr_end + delta >= vga_vram_end) {
+			scr_memcpyw((u16 *) vga_vram_base,
+				    (u16 *) (oldo + delta),
+				    c->vc_screenbuf_size - delta);
+			c->vc_origin = vga_vram_base;
+			vga_rolled_over = oldo - vga_vram_base;
+		} else
+			c->vc_origin += delta;
+		scr_memsetw((u16 *) (c->vc_origin + c->vc_screenbuf_size -
+				     delta), c->vc_video_erase_char,
+			    delta);
+	} else {
+		if (oldo - delta < vga_vram_base) {
+			scr_memmovew((u16 *) (vga_vram_end -
+					      c->vc_screenbuf_size +
+					      delta), (u16 *) oldo,
+				     c->vc_screenbuf_size - delta);
+			c->vc_origin = vga_vram_end - c->vc_screenbuf_size;
+			vga_rolled_over = 0;
+		} else
+			c->vc_origin -= delta;
+		c->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;
+		scr_memsetw((u16 *) (c->vc_origin), c->vc_video_erase_char,
+			    delta);
+	}
+	c->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;
+	c->vc_visible_origin = c->vc_origin;
+	vga_set_mem_top(c);
+	c->vc_pos = (c->vc_pos - oldo) + c->vc_origin;
+	return 1;
+}
+
+
+/*
+ *  The console `switch' structure for the VGA based console
+ */
+
+static int vgacon_dummy(struct vc_data *c)
+{
+	return 0;
+}
+
+#define DUMMY (void *) vgacon_dummy
+
+const struct consw vga_con = {
+	.owner = THIS_MODULE,
+	.con_startup = vgacon_startup,
+	.con_init = vgacon_init,
+	.con_deinit = vgacon_deinit,
+	.con_clear = DUMMY,
+	.con_putc = DUMMY,
+	.con_putcs = DUMMY,
+	.con_cursor = vgacon_cursor,
+	.con_scroll = vgacon_scroll,
+	.con_bmove = DUMMY,
+	.con_switch = vgacon_switch,
+	.con_blank = vgacon_blank,
+	.con_font_set = vgacon_font_set,
+	.con_font_get = vgacon_font_get,
+	.con_set_palette = vgacon_set_palette,
+	.con_scrolldelta = vgacon_scrolldelta,
+	.con_set_origin = vgacon_set_origin,
+	.con_save_screen = vgacon_save_screen,
+	.con_build_attr = vgacon_build_attr,
+	.con_invert_region = vgacon_invert_region,
+};
+
+MODULE_LICENSE("GPL");
