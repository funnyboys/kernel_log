commit fa2bfead910322e44e7e0bb74364ac198a2abd32
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:52:48 2020 +0200

    PM: sleep: core: Rename dev_pm_smart_suspend_and_suspended()
    
    Because all callers of dev_pm_smart_suspend_and_suspended use it only
    for checking whether or not to skip driver suspend callbacks for a
    device, rename it to dev_pm_skip_suspend() in analogy with
    dev_pm_skip_resume().
    
    No functional impact.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index decf82595340..da6510af1221 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -776,7 +776,7 @@ static int pci_pm_suspend(struct device *dev)
 
 static int pci_pm_suspend_late(struct device *dev)
 {
-	if (dev_pm_smart_suspend_and_suspended(dev))
+	if (dev_pm_skip_suspend(dev))
 		return 0;
 
 	pci_fixup_device(pci_fixup_suspend, to_pci_dev(dev));
@@ -789,7 +789,7 @@ static int pci_pm_suspend_noirq(struct device *dev)
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
-	if (dev_pm_smart_suspend_and_suspended(dev))
+	if (dev_pm_skip_suspend(dev))
 		return 0;
 
 	if (pci_has_legacy_pm_support(pci_dev))
@@ -1126,7 +1126,7 @@ static int pci_pm_poweroff(struct device *dev)
 
 static int pci_pm_poweroff_late(struct device *dev)
 {
-	if (dev_pm_smart_suspend_and_suspended(dev))
+	if (dev_pm_skip_suspend(dev))
 		return 0;
 
 	pci_fixup_device(pci_fixup_suspend, to_pci_dev(dev));
@@ -1139,7 +1139,7 @@ static int pci_pm_poweroff_noirq(struct device *dev)
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
-	if (dev_pm_smart_suspend_and_suspended(dev))
+	if (dev_pm_skip_suspend(dev))
 		return 0;
 
 	if (pci_has_legacy_pm_support(pci_dev))

commit 76c70cb58ce30264af4b714109ee756da25d830a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:52:30 2020 +0200

    PM: sleep: core: Rename dev_pm_may_skip_resume()
    
    The name of dev_pm_may_skip_resume() may be easily confused with the
    power.may_skip_resume flag which is not checked by that function, so
    rename the former as dev_pm_skip_resume().
    
    No functional impact.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index ce220b1987df..decf82595340 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -891,7 +891,7 @@ static int pci_pm_resume_noirq(struct device *dev)
 	pci_power_t prev_state = pci_dev->current_state;
 	bool skip_bus_pm = pci_dev->skip_bus_pm;
 
-	if (dev_pm_may_skip_resume(dev))
+	if (dev_pm_skip_resume(dev))
 		return 0;
 
 	/*
@@ -920,7 +920,7 @@ static int pci_pm_resume_noirq(struct device *dev)
 
 static int pci_pm_resume_early(struct device *dev)
 {
-	if (dev_pm_may_skip_resume(dev))
+	if (dev_pm_skip_resume(dev))
 		return 0;
 
 	return pm_generic_resume_early(dev);

commit 0fe8a1be599ab97f840ba22d98cb8f24a9f9e872
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:52:19 2020 +0200

    PM: sleep: core: Rework the power.may_skip_resume handling
    
    Because the power.may_skip_resume device status bit is taken
    into account in combination with the DPM_FLAG_LEAVE_SUSPENDED
    driver flag, it can be set to 'true' for all devices in the
    "suspend" phase of a suspend-resume cycle, so do that.
    
    Then, neither the PM core nor the middle-layer (sybsystem) code
    handling it needs to set it to 'true' any more and it just has
    to be cleared if there is a reason to avoid skipping the "noirq"
    and "early" resume callbacks provided by the driver, so update
    the code in question accordingly.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 685fbf044911..ce220b1987df 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -789,10 +789,8 @@ static int pci_pm_suspend_noirq(struct device *dev)
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
-	if (dev_pm_smart_suspend_and_suspended(dev)) {
-		dev->power.may_skip_resume = true;
+	if (dev_pm_smart_suspend_and_suspended(dev))
 		return 0;
-	}
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend_late(dev, PMSG_SUSPEND);
@@ -880,8 +878,8 @@ static int pci_pm_suspend_noirq(struct device *dev)
 	 * pci_pm_complete() to take care of fixing up the device's state
 	 * anyway, if need be.
 	 */
-	dev->power.may_skip_resume = device_may_wakeup(dev) ||
-					!device_can_wakeup(dev);
+	if (device_can_wakeup(dev) && !device_may_wakeup(dev))
+		dev->power.may_skip_resume = false;
 
 	return 0;
 }

commit 6e176bf8d46194353163c2cb660808bc633b45d9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:52:08 2020 +0200

    PM: sleep: core: Do not skip callbacks in the resume phase
    
    The current code in device_resume_noirq() causes the entire early
    resume and resume phases of device suspend to be skipped for
    devices for which the noirq resume phase have been skipped (due
    to the LEAVE_SUSPENDED flag being set) on the premise that those
    devices should stay in runtime-suspend after system-wide resume.
    
    However, that may not be correct in two situations.  First, the
    middle layer (subsystem) noirq resume callback may be missing for
    a given device, but its early resume callback may be present and it
    may need to do something even if it decides to skip the driver
    callback.  Second, if the device's wakeup settings were adjusted
    in the suspend phase without resuming the device (that was in
    runtime suspend at that time), they most likely need to be
    adjusted again in the resume phase and so the driver callback
    in that phase needs to be run.
    
    For the above reason, modify the core to allow the middle layer
    ->resume_late callback to run even if its ->resume_noirq callback
    is missing (and the core has skipped the driver-level callback
    in that phase) and to allow all device callbacks to run in the
    resume phase.  Also make the core set the PM-runtime status of
    devices with SMART_SUSPEND set whose resume callbacks are not
    skipped to "active" in the "noirq" resume phase and update the
    affected subsystems (PCI and ACPI) accordingly.
    
    After this change, middle-layer (subsystem) callbacks will always
    be invoked in all phases of system suspend and resume and driver
    callbacks will always run in the prepare, suspend, resume, and
    complete phases for all devices.
    
    For devices with SMART_SUSPEND set, driver callbacks will be
    skipped in the late and noirq phases of system suspend if those
    devices remain in runtime suspend in __device_suspend_late().
    Driver callbacks will also be skipped for them during the
    noirq and early phases of the "thaw" transition related to
    hibernation in that case.
    
    Setting LEAVE_SUSPENDED means that the driver allows its callbacks
    to be skipped in the noirq and early phases of system resume, but
    some additional conditions need to be met for that to happen (among
    other things, the power.may_skip_resume flag needs to be set for the
    device during system suspend for the driver callbacks to be skipped
    during the subsequent resume transition).
    
    For all devices with SMART_SUSPEND set whose driver callbacks are
    invoked during system resume, the PM-runtime status will be set to
    "active" (by the core).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 0454ca0e4e3f..685fbf044911 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -896,14 +896,6 @@ static int pci_pm_resume_noirq(struct device *dev)
 	if (dev_pm_may_skip_resume(dev))
 		return 0;
 
-	/*
-	 * Devices with DPM_FLAG_SMART_SUSPEND may be left in runtime suspend
-	 * during system suspend, so update their runtime PM status to "active"
-	 * as they are going to be put into D0 shortly.
-	 */
-	if (dev_pm_smart_suspend_and_suspended(dev))
-		pm_runtime_set_active(dev);
-
 	/*
 	 * In the suspend-to-idle case, devices left in D0 during suspend will
 	 * stay in D0, so it is not necessary to restore or update their
@@ -928,6 +920,14 @@ static int pci_pm_resume_noirq(struct device *dev)
 	return 0;
 }
 
+static int pci_pm_resume_early(struct device *dev)
+{
+	if (dev_pm_may_skip_resume(dev))
+		return 0;
+
+	return pm_generic_resume_early(dev);
+}
+
 static int pci_pm_resume(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
@@ -961,6 +961,7 @@ static int pci_pm_resume(struct device *dev)
 #define pci_pm_suspend_late	NULL
 #define pci_pm_suspend_noirq	NULL
 #define pci_pm_resume		NULL
+#define pci_pm_resume_early	NULL
 #define pci_pm_resume_noirq	NULL
 
 #endif /* !CONFIG_SUSPEND */
@@ -1358,6 +1359,7 @@ static const struct dev_pm_ops pci_dev_pm_ops = {
 	.suspend = pci_pm_suspend,
 	.suspend_late = pci_pm_suspend_late,
 	.resume = pci_pm_resume,
+	.resume_early = pci_pm_resume_early,
 	.freeze = pci_pm_freeze,
 	.thaw = pci_pm_thaw,
 	.poweroff = pci_pm_poweroff,

commit ad9001f2f41198784b0423646450ba2cb24793a3
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Nov 12 12:16:17 2019 +0300

    PCI/PM: Add missing link delays required by the PCIe spec
    
    Currently Linux does not follow PCIe spec regarding the required delays
    after reset. A concrete example is a Thunderbolt add-in-card that consists
    of a PCIe switch and two PCIe endpoints:
    
      +-1b.0-[01-6b]----00.0-[02-6b]--+-00.0-[03]----00.0 TBT controller
                                      +-01.0-[04-36]-- DS hotplug port
                                      +-02.0-[37]----00.0 xHCI controller
                                      \-04.0-[38-6b]-- DS hotplug port
    
    The root port (1b.0) and the PCIe switch downstream ports are all PCIe Gen3
    so they support 8GT/s link speeds.
    
    We wait for the PCIe hierarchy to enter D3cold (runtime):
    
      pcieport 0000:00:1b.0: power state changed by ACPI to D3cold
    
    When it wakes up from D3cold, according to the PCIe 5.0 section 5.8 the
    PCIe switch is put to reset and its power is re-applied. This means that we
    must follow the rules in PCIe 5.0 section 6.6.1.
    
    For the PCIe Gen3 ports we are dealing with here, the following applies:
    
      With a Downstream Port that supports Link speeds greater than 5.0 GT/s,
      software must wait a minimum of 100 ms after Link training completes
      before sending a Configuration Request to the device immediately below
      that Port. Software can determine when Link training completes by polling
      the Data Link Layer Link Active bit or by setting up an associated
      interrupt (see Section 6.7.3.3).
    
    Translating this into the above topology we would need to do this (DLLLA
    stands for Data Link Layer Link Active):
    
      0000:00:1b.0: wait for 100 ms after DLLLA is set before access to 0000:01:00.0
      0000:02:00.0: wait for 100 ms after DLLLA is set before access to 0000:03:00.0
      0000:02:02.0: wait for 100 ms after DLLLA is set before access to 0000:37:00.0
    
    I've instrumented the kernel with some additional logging so we can see the
    actual delays performed:
    
      pcieport 0000:00:1b.0: power state changed by ACPI to D0
      pcieport 0000:00:1b.0: waiting for D3cold delay of 100 ms
      pcieport 0000:00:1b.0: waiting for D3hot delay of 10 ms
      pcieport 0000:02:01.0: waiting for D3hot delay of 10 ms
      pcieport 0000:02:04.0: waiting for D3hot delay of 10 ms
    
    For the switch upstream port (01:00.0 reachable through 00:1b.0 root port)
    we wait for 100 ms but not taking into account the DLLLA requirement. We
    then wait 10 ms for D3hot -> D0 transition of the root port and the two
    downstream hotplug ports. This means that we deviate from what the spec
    requires.
    
    Performing the same check for system sleep (s2idle) transitions it turns
    out to be even worse. None of the mandatory delays are performed. If this
    would be S3 instead of s2idle then according to PCI FW spec 3.2 section
    4.6.8. there is a specific _DSM that allows the OS to skip the delays but
    this platform does not provide the _DSM and does not go to S3 anyway so no
    firmware is involved that could already handle these delays.
    
    On this particular platform these delays are not actually needed because
    there is an additional delay as part of the ACPI power resource that is
    used to turn on power to the hierarchy but since that additional delay is
    not required by any of standards (PCIe, ACPI) it is not present in the
    Intel Ice Lake, for example where missing the mandatory delays causes
    pciehp to start tearing down the stack too early (links are not yet
    trained). Below is an example how it looks like when this happens:
    
      pcieport 0000:83:04.0: pciehp: Slot(4): Card not present
      pcieport 0000:87:04.0: PME# disabled
      pcieport 0000:83:04.0: pciehp: pciehp_unconfigure_device: domain:bus:dev = 0000:86:00
      pcieport 0000:86:00.0: Refused to change power state, currently in D3
      pcieport 0000:86:00.0: restoring config space at offset 0x3c (was 0xffffffff, writing 0x201ff)
      pcieport 0000:86:00.0: restoring config space at offset 0x38 (was 0xffffffff, writing 0x0)
      ...
    
    There is also one reported case (see the bugzilla link below) where the
    missing delay causes xHCI on a Titan Ridge controller fail to runtime
    resume when USB-C dock is plugged. This does not involve pciehp but instead
    the PCI core fails to runtime resume the xHCI device:
    
      pcieport 0000:04:02.0: restoring config space at offset 0xc (was 0x10000, writing 0x10020)
      pcieport 0000:04:02.0: restoring config space at offset 0x4 (was 0x100000, writing 0x100406)
      xhci_hcd 0000:39:00.0: Refused to change power state, currently in D3
      xhci_hcd 0000:39:00.0: restoring config space at offset 0x3c (was 0xffffffff, writing 0x1ff)
      xhci_hcd 0000:39:00.0: restoring config space at offset 0x38 (was 0xffffffff, writing 0x0)
      ...
    
    Add a new function pci_bridge_wait_for_secondary_bus() that is called on
    PCI core resume and runtime resume paths accordingly if the bridge entered
    D3cold (and thus went through reset).
    
    This is second attempt to add the missing delays. The previous solution in
    c2bf1fc212f7 ("PCI: Add missing link delays required by the PCIe spec") was
    reverted because of two issues it caused:
    
      1. One system become unresponsive after S3 resume due to PME service
         spinning in pcie_pme_work_fn(). The root port in question reports that
         the xHCI sent PME but the xHCI device itself does not have PME status
         set. The PME status bit is never cleared in the root port resulting
         the indefinite loop in pcie_pme_work_fn().
    
      2. Slows down resume if the root/downstream port does not support Data
         Link Layer Active Reporting because pcie_wait_for_link_delay() waits
         1100 ms in that case.
    
    This version should avoid the above issues because we restrict the delay to
    happen only if the port went into D3cold.
    
    Link: https://lore.kernel.org/linux-pci/SL2P216MB01878BBCD75F21D882AEEA2880C60@SL2P216MB0187.KORP216.PROD.OUTLOOK.COM/
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=203885
    Link: https://lore.kernel.org/r/20191112091617.70282-3-mika.westerberg@linux.intel.com
    Reported-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 08d3bdbc8c04..0454ca0e4e3f 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -890,6 +890,8 @@ static int pci_pm_resume_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+	pci_power_t prev_state = pci_dev->current_state;
+	bool skip_bus_pm = pci_dev->skip_bus_pm;
 
 	if (dev_pm_may_skip_resume(dev))
 		return 0;
@@ -908,12 +910,15 @@ static int pci_pm_resume_noirq(struct device *dev)
 	 * configuration here and attempting to put them into D0 again is
 	 * pointless, so avoid doing that.
 	 */
-	if (!(pci_dev->skip_bus_pm && pm_suspend_no_platform()))
+	if (!(skip_bus_pm && pm_suspend_no_platform()))
 		pci_pm_default_resume_early(pci_dev);
 
 	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 	pcie_pme_root_status_cleanup(pci_dev);
 
+	if (!skip_bus_pm && prev_state == PCI_D3cold)
+		pci_bridge_wait_for_secondary_bus(pci_dev);
+
 	if (pci_has_legacy_pm_support(pci_dev))
 		return 0;
 
@@ -1299,6 +1304,7 @@ static int pci_pm_runtime_resume(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+	pci_power_t prev_state = pci_dev->current_state;
 	int error = 0;
 
 	/*
@@ -1314,6 +1320,9 @@ static int pci_pm_runtime_resume(struct device *dev)
 	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 	pci_pm_default_resume(pci_dev);
 
+	if (prev_state == PCI_D3cold)
+		pci_bridge_wait_for_secondary_bus(pci_dev);
+
 	if (pm && pm->runtime_resume)
 		error = pm->runtime_resume(dev);
 

commit 81cfa5908fd6fe610b7c47b742fe30d6d897ba0f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Nov 5 11:13:43 2019 +0100

    PCI/PM: Move power state update away from pci_power_up()
    
    Move the invocation of pci_update_current_state() from pci_power_up() to
    pci_pm_default_resume_early(), which is the only caller of that function.
    
    Preparatory change, no functional impact.
    
    Link: https://lore.kernel.org/r/37482337.udjOGdOKNb@kreacher
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index e89fd90eaa93..08d3bdbc8c04 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -531,6 +531,7 @@ static void pci_pm_default_resume(struct pci_dev *pci_dev)
 static void pci_pm_default_resume_early(struct pci_dev *pci_dev)
 {
 	pci_power_up(pci_dev);
+	pci_update_current_state(pci_dev, PCI_D0);
 	pci_restore_state(pci_dev);
 	pci_pme_restore(pci_dev);
 }

commit 1a1daf097e21e544dd3e7c0ff620d78a9795fbf2
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Oct 31 17:37:54 2019 -0500

    PCI/PM: Remove unused pci_driver.suspend_late() hook
    
    The struct pci_driver.suspend_late() hook is one of the legacy PCI power
    management callbacks, and there are no remaining users of it.  Remove it.
    
    Link: https://lore.kernel.org/r/20191101204558.210235-7-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index fc372c2d529a..e89fd90eaa93 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -599,32 +599,12 @@ static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 static int pci_legacy_suspend_late(struct device *dev, pm_message_t state)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct pci_driver *drv = pci_dev->driver;
-
-	if (drv && drv->suspend_late) {
-		pci_power_t prev = pci_dev->current_state;
-		int error;
-
-		error = drv->suspend_late(pci_dev, state);
-		suspend_report_result(drv->suspend_late, error);
-		if (error)
-			return error;
-
-		if (!pci_dev->state_saved && pci_dev->current_state != PCI_D0
-		    && pci_dev->current_state != PCI_UNKNOWN) {
-			pci_WARN_ONCE(pci_dev, pci_dev->current_state != prev,
-				      "PCI PM: Device state not saved by %pS\n",
-				      drv->suspend_late);
-			goto Fixup;
-		}
-	}
 
 	if (!pci_dev->state_saved)
 		pci_save_state(pci_dev);
 
 	pci_pm_set_unknown_state(pci_dev);
 
-Fixup:
 	pci_fixup_device(pci_fixup_suspend_late, pci_dev);
 
 	return 0;
@@ -653,7 +633,7 @@ static void pci_pm_default_suspend(struct pci_dev *pci_dev)
 static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
 {
 	struct pci_driver *drv = pci_dev->driver;
-	bool ret = drv && (drv->suspend || drv->suspend_late || drv->resume);
+	bool ret = drv && (drv->suspend || drv->resume);
 
 	/*
 	 * Legacy PM support is used by default, so warn if the new framework is

commit 89cdbc3546354c359558a1809133902028c57da4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Oct 31 17:53:04 2019 -0500

    PCI/PM: Remove unused pci_driver.resume_early() hook
    
    The struct pci_driver.resume_early() hook is one of the legacy PCI power
    management callbacks, and there are no remaining users of it.  Remove it.
    
    Link: https://lore.kernel.org/r/20191101204558.210235-6-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 5337cbbd69de..fc372c2d529a 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -630,15 +630,6 @@ static int pci_legacy_suspend_late(struct device *dev, pm_message_t state)
 	return 0;
 }
 
-static int pci_legacy_resume_early(struct device *dev)
-{
-	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct pci_driver *drv = pci_dev->driver;
-
-	return drv && drv->resume_early ?
-			drv->resume_early(pci_dev) : 0;
-}
-
 static int pci_legacy_resume(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
@@ -662,8 +653,7 @@ static void pci_pm_default_suspend(struct pci_dev *pci_dev)
 static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
 {
 	struct pci_driver *drv = pci_dev->driver;
-	bool ret = drv && (drv->suspend || drv->suspend_late || drv->resume
-		|| drv->resume_early);
+	bool ret = drv && (drv->suspend || drv->suspend_late || drv->resume);
 
 	/*
 	 * Legacy PM support is used by default, so warn if the new framework is
@@ -944,7 +934,7 @@ static int pci_pm_resume_noirq(struct device *dev)
 	pcie_pme_root_status_cleanup(pci_dev);
 
 	if (pci_has_legacy_pm_support(pci_dev))
-		return pci_legacy_resume_early(dev);
+		return 0;
 
 	if (pm && pm->resume_noirq)
 		return pm->resume_noirq(dev);
@@ -1074,9 +1064,8 @@ static int pci_pm_thaw_noirq(struct device *dev)
 	}
 
 	/*
-	 * Both the legacy ->resume_early() and the new pm->thaw_noirq()
-	 * callbacks assume the device has been returned to D0 and its
-	 * config state has been restored.
+	 * The pm->thaw_noirq() callback assumes the device has been
+	 * returned to D0 and its config state has been restored.
 	 *
 	 * In addition, pci_restore_state() restores MSI-X state in MMIO
 	 * space, which requires the device to be in D0, so return it to D0
@@ -1087,7 +1076,7 @@ static int pci_pm_thaw_noirq(struct device *dev)
 	pci_restore_state(pci_dev);
 
 	if (pci_has_legacy_pm_support(pci_dev))
-		return pci_legacy_resume_early(dev);
+		return 0;
 
 	if (pm && pm->thaw_noirq)
 		return pm->thaw_noirq(dev);
@@ -1219,7 +1208,7 @@ static int pci_pm_restore_noirq(struct device *dev)
 	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 
 	if (pci_has_legacy_pm_support(pci_dev))
-		return pci_legacy_resume_early(dev);
+		return 0;
 
 	if (pm && pm->restore_noirq)
 		return pm->restore_noirq(dev);

commit 12bcae44bf48595c71898330076576075590e15b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Oct 7 07:52:28 2019 -0500

    PCI/PM: Use pci_WARN() to include device information
    
    Add and use pci_WARN() wrappers so warnings include device information.
    
    Link: https://lore.kernel.org/r/20191017212851.54237-3-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 407b1df5ea7c..5337cbbd69de 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -585,9 +585,9 @@ static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 
 		if (!pci_dev->state_saved && pci_dev->current_state != PCI_D0
 		    && pci_dev->current_state != PCI_UNKNOWN) {
-			WARN_ONCE(pci_dev->current_state != prev,
-				"PCI PM: Device state not saved by %pS\n",
-				drv->suspend);
+			pci_WARN_ONCE(pci_dev, pci_dev->current_state != prev,
+				      "PCI PM: Device state not saved by %pS\n",
+				      drv->suspend);
 		}
 	}
 
@@ -612,9 +612,9 @@ static int pci_legacy_suspend_late(struct device *dev, pm_message_t state)
 
 		if (!pci_dev->state_saved && pci_dev->current_state != PCI_D0
 		    && pci_dev->current_state != PCI_UNKNOWN) {
-			WARN_ONCE(pci_dev->current_state != prev,
-				"PCI PM: Device state not saved by %pS\n",
-				drv->suspend_late);
+			pci_WARN_ONCE(pci_dev, pci_dev->current_state != prev,
+				      "PCI PM: Device state not saved by %pS\n",
+				      drv->suspend_late);
 			goto Fixup;
 		}
 	}
@@ -670,8 +670,8 @@ static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
 	 * supported as well.  Drivers are supposed to support either the
 	 * former, or the latter, but not both at the same time.
 	 */
-	WARN(ret && drv->driver.pm, "driver %s device %04x:%04x\n",
-		drv->name, pci_dev->vendor, pci_dev->device);
+	pci_WARN(pci_dev, ret && drv->driver.pm, "device %04x:%04x\n",
+		 pci_dev->vendor, pci_dev->device);
 
 	return ret;
 }
@@ -794,9 +794,9 @@ static int pci_pm_suspend(struct device *dev)
 
 		if (!pci_dev->state_saved && pci_dev->current_state != PCI_D0
 		    && pci_dev->current_state != PCI_UNKNOWN) {
-			WARN_ONCE(pci_dev->current_state != prev,
-				"PCI PM: State of device not saved by %pS\n",
-				pm->suspend);
+			pci_WARN_ONCE(pci_dev, pci_dev->current_state != prev,
+				      "PCI PM: State of device not saved by %pS\n",
+				      pm->suspend);
 		}
 	}
 
@@ -842,9 +842,9 @@ static int pci_pm_suspend_noirq(struct device *dev)
 
 		if (!pci_dev->state_saved && pci_dev->current_state != PCI_D0
 		    && pci_dev->current_state != PCI_UNKNOWN) {
-			WARN_ONCE(pci_dev->current_state != prev,
-				"PCI PM: State of device not saved by %pS\n",
-				pm->suspend_noirq);
+			pci_WARN_ONCE(pci_dev, pci_dev->current_state != prev,
+				      "PCI PM: State of device not saved by %pS\n",
+				      pm->suspend_noirq);
 			goto Fixup;
 		}
 	}
@@ -1311,9 +1311,9 @@ static int pci_pm_runtime_suspend(struct device *dev)
 	if (pm && pm->runtime_suspend
 	    && !pci_dev->state_saved && pci_dev->current_state != PCI_D0
 	    && pci_dev->current_state != PCI_UNKNOWN) {
-		WARN_ONCE(pci_dev->current_state != prev,
-			"PCI PM: State of device not saved by %pS\n",
-			pm->runtime_suspend);
+		pci_WARN_ONCE(pci_dev, pci_dev->current_state != prev,
+			      "PCI PM: State of device not saved by %pS\n",
+			      pm->runtime_suspend);
 		return 0;
 	}
 

commit 6941a0c2bdedfb729fb166091e12d06e4fce177f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Oct 7 07:55:18 2019 -0500

    PCI/PM: Use PCI dev_printk() wrappers for consistency
    
    Use the PCI dev_printk() wrappers for consistency with the rest of the PCI
    core.  No functional change intended.
    
    Link: https://lore.kernel.org/r/20191017212851.54237-2-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index dd70ab2519c9..407b1df5ea7c 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -315,7 +315,8 @@ static long local_pci_probe(void *_ddi)
 	 * Probe function should return < 0 for failure, 0 for success
 	 * Treat values > 0 as success, but warn.
 	 */
-	dev_warn(dev, "Driver probe function unexpectedly returned %d\n", rc);
+	pci_warn(pci_dev, "Driver probe function unexpectedly returned %d\n",
+		 rc);
 	return 0;
 }
 
@@ -865,7 +866,7 @@ static int pci_pm_suspend_noirq(struct device *dev)
 			pci_prepare_to_sleep(pci_dev);
 	}
 
-	dev_dbg(dev, "PCI PM: Suspend power state: %s\n",
+	pci_dbg(pci_dev, "PCI PM: Suspend power state: %s\n",
 		pci_power_name(pci_dev->current_state));
 
 	if (pci_dev->current_state == PCI_D0) {
@@ -880,7 +881,7 @@ static int pci_pm_suspend_noirq(struct device *dev)
 	}
 
 	if (pci_dev->skip_bus_pm && pm_suspend_no_platform()) {
-		dev_dbg(dev, "PCI PM: Skipped\n");
+		pci_dbg(pci_dev, "PCI PM: Skipped\n");
 		goto Fixup;
 	}
 
@@ -1295,11 +1296,11 @@ static int pci_pm_runtime_suspend(struct device *dev)
 		 * log level.
 		 */
 		if (error == -EBUSY || error == -EAGAIN) {
-			dev_dbg(dev, "can't suspend now (%ps returned %d)\n",
+			pci_dbg(pci_dev, "can't suspend now (%ps returned %d)\n",
 				pm->runtime_suspend, error);
 			return error;
 		} else if (error) {
-			dev_err(dev, "can't suspend (%ps returned %d)\n",
+			pci_err(pci_dev, "can't suspend (%ps returned %d)\n",
 				pm->runtime_suspend, error);
 			return error;
 		}

commit 6da2f2ccfd2deb81a63fc23a505ccd72de005c39
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Oct 14 13:46:50 2019 -0500

    PCI/PM: Make power management op coding style consistent
    
    Some of the power management ops use this style:
    
      struct device_driver *drv = dev->driver;
      if (drv && drv->pm && drv->pm->prepare(dev))
        drv->pm->prepare(dev);
    
    while others use this:
    
      const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
      if (pm && pm->runtime_resume)
        pm->runtime_resume(dev);
    
    Convert the first style to the second so they're all consistent.  Remove
    local "error" variables when unnecessary.  No functional change intended.
    
    Link: https://lore.kernel.org/r/20191014230016.240912-6-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index abee2a790a10..dd70ab2519c9 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -679,11 +679,11 @@ static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
 
 static int pci_pm_prepare(struct device *dev)
 {
-	struct device_driver *drv = dev->driver;
 	struct pci_dev *pci_dev = to_pci_dev(dev);
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
-	if (drv && drv->pm && drv->pm->prepare) {
-		int error = drv->pm->prepare(dev);
+	if (pm && pm->prepare) {
+		int error = pm->prepare(dev);
 		if (error < 0)
 			return error;
 
@@ -917,8 +917,7 @@ static int pci_pm_suspend_noirq(struct device *dev)
 static int pci_pm_resume_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct device_driver *drv = dev->driver;
-	int error = 0;
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
 	if (dev_pm_may_skip_resume(dev))
 		return 0;
@@ -946,17 +945,16 @@ static int pci_pm_resume_noirq(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
 
-	if (drv && drv->pm && drv->pm->resume_noirq)
-		error = drv->pm->resume_noirq(dev);
+	if (pm && pm->resume_noirq)
+		return pm->resume_noirq(dev);
 
-	return error;
+	return 0;
 }
 
 static int pci_pm_resume(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
-	int error = 0;
 
 	/*
 	 * This is necessary for the suspend error path in which resume is
@@ -972,12 +970,12 @@ static int pci_pm_resume(struct device *dev)
 
 	if (pm) {
 		if (pm->resume)
-			error = pm->resume(dev);
+			return pm->resume(dev);
 	} else {
 		pci_pm_reenable_device(pci_dev);
 	}
 
-	return error;
+	return 0;
 }
 
 #else /* !CONFIG_SUSPEND */
@@ -1037,16 +1035,16 @@ static int pci_pm_freeze(struct device *dev)
 static int pci_pm_freeze_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct device_driver *drv = dev->driver;
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend_late(dev, PMSG_FREEZE);
 
-	if (drv && drv->pm && drv->pm->freeze_noirq) {
+	if (pm && pm->freeze_noirq) {
 		int error;
 
-		error = drv->pm->freeze_noirq(dev);
-		suspend_report_result(drv->pm->freeze_noirq, error);
+		error = pm->freeze_noirq(dev);
+		suspend_report_result(pm->freeze_noirq, error);
 		if (error)
 			return error;
 	}
@@ -1065,8 +1063,8 @@ static int pci_pm_freeze_noirq(struct device *dev)
 static int pci_pm_thaw_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct device_driver *drv = dev->driver;
-	int error = 0;
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+	int error;
 
 	if (pcibios_pm_ops.thaw_noirq) {
 		error = pcibios_pm_ops.thaw_noirq(dev);
@@ -1090,10 +1088,10 @@ static int pci_pm_thaw_noirq(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
 
-	if (drv && drv->pm && drv->pm->thaw_noirq)
-		error = drv->pm->thaw_noirq(dev);
+	if (pm && pm->thaw_noirq)
+		return pm->thaw_noirq(dev);
 
-	return error;
+	return 0;
 }
 
 static int pci_pm_thaw(struct device *dev)
@@ -1164,24 +1162,24 @@ static int pci_pm_poweroff_late(struct device *dev)
 static int pci_pm_poweroff_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct device_driver *drv = dev->driver;
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
 	if (dev_pm_smart_suspend_and_suspended(dev))
 		return 0;
 
-	if (pci_has_legacy_pm_support(to_pci_dev(dev)))
+	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend_late(dev, PMSG_HIBERNATE);
 
-	if (!drv || !drv->pm) {
+	if (!pm) {
 		pci_fixup_device(pci_fixup_suspend_late, pci_dev);
 		return 0;
 	}
 
-	if (drv->pm->poweroff_noirq) {
+	if (pm->poweroff_noirq) {
 		int error;
 
-		error = drv->pm->poweroff_noirq(dev);
-		suspend_report_result(drv->pm->poweroff_noirq, error);
+		error = pm->poweroff_noirq(dev);
+		suspend_report_result(pm->poweroff_noirq, error);
 		if (error)
 			return error;
 	}
@@ -1207,8 +1205,8 @@ static int pci_pm_poweroff_noirq(struct device *dev)
 static int pci_pm_restore_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct device_driver *drv = dev->driver;
-	int error = 0;
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+	int error;
 
 	if (pcibios_pm_ops.restore_noirq) {
 		error = pcibios_pm_ops.restore_noirq(dev);
@@ -1222,17 +1220,16 @@ static int pci_pm_restore_noirq(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
 
-	if (drv && drv->pm && drv->pm->restore_noirq)
-		error = drv->pm->restore_noirq(dev);
+	if (pm && pm->restore_noirq)
+		return pm->restore_noirq(dev);
 
-	return error;
+	return 0;
 }
 
 static int pci_pm_restore(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
-	int error = 0;
 
 	/*
 	 * This is necessary for the hibernation error path in which restore is
@@ -1248,12 +1245,12 @@ static int pci_pm_restore(struct device *dev)
 
 	if (pm) {
 		if (pm->restore)
-			error = pm->restore(dev);
+			return pm->restore(dev);
 	} else {
 		pci_pm_reenable_device(pci_dev);
 	}
 
-	return error;
+	return 0;
 }
 
 #else /* !CONFIG_HIBERNATE_CALLBACKS */
@@ -1329,9 +1326,9 @@ static int pci_pm_runtime_suspend(struct device *dev)
 
 static int pci_pm_runtime_resume(struct device *dev)
 {
-	int rc = 0;
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+	int error = 0;
 
 	/*
 	 * Restoring config space is necessary even if the device is not bound
@@ -1347,18 +1344,17 @@ static int pci_pm_runtime_resume(struct device *dev)
 	pci_pm_default_resume(pci_dev);
 
 	if (pm && pm->runtime_resume)
-		rc = pm->runtime_resume(dev);
+		error = pm->runtime_resume(dev);
 
 	pci_dev->runtime_d3cold = false;
 
-	return rc;
+	return error;
 }
 
 static int pci_pm_runtime_idle(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
-	int ret = 0;
 
 	/*
 	 * If pci_dev->driver is not set (unbound), the device should
@@ -1371,9 +1367,9 @@ static int pci_pm_runtime_idle(struct device *dev)
 		return -ENOSYS;
 
 	if (pm->runtime_idle)
-		ret = pm->runtime_idle(dev);
+		return pm->runtime_idle(dev);
 
-	return ret;
+	return 0;
 }
 
 static const struct dev_pm_ops pci_dev_pm_ops = {

commit f7b32a86e455b035dd45a334c203abf6fe118cf3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Oct 12 17:15:57 2019 -0500

    PCI/PM: Run resume fixups before disabling wakeup events
    
    pci_pm_resume() and pci_pm_restore() call pci_pm_default_resume(), which
    runs resume fixups before disabling wakeup events:
    
      static void pci_pm_default_resume(struct pci_dev *pci_dev)
      {
        pci_fixup_device(pci_fixup_resume, pci_dev);
        pci_enable_wake(pci_dev, PCI_D0, false);
      }
    
    pci_pm_runtime_resume() does both of these, but in the opposite order:
    
      pci_enable_wake(pci_dev, PCI_D0, false);
      pci_fixup_device(pci_fixup_resume, pci_dev);
    
    We should always use the same ordering unless there's a reason to do
    otherwise.  Change pci_pm_runtime_resume() to call pci_pm_default_resume()
    instead of open-coding this, so the fixups are always done before disabling
    wakeup events.
    
    pci_pm_default_resume() is called from pci_pm_runtime_resume(), which is
    under #ifdef CONFIG_PM.  If SUSPEND and HIBERNATION are disabled, PM_SLEEP
    is disabled also, so move pci_pm_default_resume() from #ifdef
    CONFIG_PM_SLEEP to #ifdef CONFIG_PM.
    
    Link: https://lore.kernel.org/r/20191014230016.240912-5-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 0c3086793e4e..abee2a790a10 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -517,6 +517,12 @@ static int pci_restore_standard_config(struct pci_dev *pci_dev)
 	return 0;
 }
 
+static void pci_pm_default_resume(struct pci_dev *pci_dev)
+{
+	pci_fixup_device(pci_fixup_resume, pci_dev);
+	pci_enable_wake(pci_dev, PCI_D0, false);
+}
+
 #endif
 
 #ifdef CONFIG_PM_SLEEP
@@ -645,12 +651,6 @@ static int pci_legacy_resume(struct device *dev)
 
 /* Auxiliary functions used by the new power management framework */
 
-static void pci_pm_default_resume(struct pci_dev *pci_dev)
-{
-	pci_fixup_device(pci_fixup_resume, pci_dev);
-	pci_enable_wake(pci_dev, PCI_D0, false);
-}
-
 static void pci_pm_default_suspend(struct pci_dev *pci_dev)
 {
 	/* Disable non-bridge devices without PM support */
@@ -992,7 +992,6 @@ static int pci_pm_resume(struct device *dev)
 
 #ifdef CONFIG_HIBERNATE_CALLBACKS
 
-
 /*
  * pcibios_pm_ops - provide arch-specific hooks when a PCI device is doing
  * a hibernate transition
@@ -1345,8 +1344,7 @@ static int pci_pm_runtime_resume(struct device *dev)
 		return 0;
 
 	pci_fixup_device(pci_fixup_resume_early, pci_dev);
-	pci_enable_wake(pci_dev, PCI_D0, false);
-	pci_fixup_device(pci_fixup_resume, pci_dev);
+	pci_pm_default_resume(pci_dev);
 
 	if (pm && pm->runtime_resume)
 		rc = pm->runtime_resume(dev);

commit ec6a75ef8e33fe33f963b916fd902c52a0be33ff
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Oct 10 16:54:36 2019 -0500

    PCI/PM: Clear PCIe PME Status even for legacy power management
    
    Previously, pci_pm_resume_noirq() cleared the PME Status bit in the Root
    Status register only if the device had no driver or the driver did not
    implement legacy power management.  It should clear PME Status regardless
    of what sort of power management the driver supports, so do this before
    checking for legacy power management.
    
    This affects Root Ports and Root Complex Event Collectors, for which the
    usual driver is the PCIe portdrv, which implements new power management, so
    this change is just on principle, not to fix any actual defects.
    
    Fixes: a39bd851dccf ("PCI/PM: Clear PCIe PME Status bit in core, not PCIe port driver")
    Link: https://lore.kernel.org/r/20191014230016.240912-4-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index d4ac8ce8c1f9..0c3086793e4e 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -941,12 +941,11 @@ static int pci_pm_resume_noirq(struct device *dev)
 		pci_pm_default_resume_early(pci_dev);
 
 	pci_fixup_device(pci_fixup_resume_early, pci_dev);
+	pcie_pme_root_status_cleanup(pci_dev);
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
 
-	pcie_pme_root_status_cleanup(pci_dev);
-
 	if (drv && drv->pm && drv->pm->resume_noirq)
 		error = drv->pm->resume_noirq(dev);
 

commit f2c33ccacb2d4bbeae2a255a7ca0cbfd03017b7c
Author: Dexuan Cui <decui@microsoft.com>
Date:   Wed Aug 14 01:06:55 2019 +0000

    PCI/PM: Always return devices to D0 when thawing
    
    pci_pm_thaw_noirq() is supposed to return the device to D0 and restore its
    configuration registers, but previously it only did that for devices whose
    drivers implemented the new power management ops.
    
    Hibernation, e.g., via "echo disk > /sys/power/state", involves freezing
    devices, creating a hibernation image, thawing devices, writing the image,
    and powering off.  The fact that thawing did not return devices with legacy
    power management to D0 caused errors, e.g., in this path:
    
      pci_pm_thaw_noirq
        if (pci_has_legacy_pm_support(pci_dev)) # true for Mellanox VF driver
          return pci_legacy_resume_early(dev)   # ... legacy PM skips the rest
        pci_set_power_state(pci_dev, PCI_D0)
        pci_restore_state(pci_dev)
      pci_pm_thaw
        if (pci_has_legacy_pm_support(pci_dev))
          pci_legacy_resume
            drv->resume
              mlx4_resume
                ...
                  pci_enable_msix_range
                    ...
                      if (dev->current_state != PCI_D0)  # <---
                        return -EINVAL;
    
    which caused these warnings:
    
      mlx4_core a6d1:00:02.0: INTx is not supported in multi-function mode, aborting
      PM: dpm_run_callback(): pci_pm_thaw+0x0/0xd7 returns -95
      PM: Device a6d1:00:02.0 failed to thaw: error -95
    
    Return devices to D0 and restore config registers for all devices, not just
    those whose drivers support new power management.
    
    [bhelgaas: also call pci_restore_state() before pci_legacy_resume_early(),
    update comment, add stable tag, commit log]
    Link: https://lore.kernel.org/r/KU1P153MB016637CAEAD346F0AA8E3801BFAD0@KU1P153MB0166.APCP153.PROD.OUTLOOK.COM
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: stable@vger.kernel.org      # v4.13+

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index a8124e47bf6e..d4ac8ce8c1f9 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1076,17 +1076,22 @@ static int pci_pm_thaw_noirq(struct device *dev)
 			return error;
 	}
 
-	if (pci_has_legacy_pm_support(pci_dev))
-		return pci_legacy_resume_early(dev);
-
 	/*
-	 * pci_restore_state() requires the device to be in D0 (because of MSI
-	 * restoration among other things), so force it into D0 in case the
-	 * driver's "freeze" callbacks put it into a low-power state directly.
+	 * Both the legacy ->resume_early() and the new pm->thaw_noirq()
+	 * callbacks assume the device has been returned to D0 and its
+	 * config state has been restored.
+	 *
+	 * In addition, pci_restore_state() restores MSI-X state in MMIO
+	 * space, which requires the device to be in D0, so return it to D0
+	 * in case the driver's "freeze" callbacks put it into a low-power
+	 * state.
 	 */
 	pci_set_power_state(pci_dev, PCI_D0);
 	pci_restore_state(pci_dev);
 
+	if (pci_has_legacy_pm_support(pci_dev))
+		return pci_legacy_resume_early(dev);
+
 	if (drv && drv->pm && drv->pm->thaw_noirq)
 		error = drv->pm->thaw_noirq(dev);
 

commit fb4da215ed92f564f7ca090bb81a199b0d6cab8a
Merge: 2a3c389a0fde 7b4b0f6b34d8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 15 20:44:49 2019 -0700

    Merge tag 'pci-v5.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Enumeration changes:
    
       - Evaluate PCI Boot Configuration _DSM to learn if firmware wants us
         to preserve its resource assignments (Benjamin Herrenschmidt)
    
       - Simplify resource distribution (Nicholas Johnson)
    
       - Decode 32 GT/s link speed (Gustavo Pimentel)
    
      Virtualization:
    
       - Fix incorrect caching of VF config space size (Alex Williamson)
    
       - Fix VF driver probing sysfs knobs (Alex Williamson)
    
      Peer-to-peer DMA:
    
       - Fix dma_virt_ops check (Logan Gunthorpe)
    
      Altera host bridge driver:
    
       - Allow building as module (Ley Foon Tan)
    
      Armada 8K host bridge driver:
    
       - add PHYs support (Miquel Raynal)
    
      DesignWare host bridge driver:
    
       - Export APIs to support removable loadable module (Vidya Sagar)
    
       - Enable Relaxed Ordering erratum workaround only on Tegra20 &
         Tegra30 (Vidya Sagar)
    
      Hyper-V host bridge driver:
    
       - Fix use-after-free in eject (Dexuan Cui)
    
      Mobiveil host bridge driver:
    
       - Clean up and fix many issues, including non-identify mapped
         windows, 64-bit windows, multi-MSI, class code, INTx clearing (Hou
         Zhiqiang)
    
      Qualcomm host bridge driver:
    
       - Use clk bulk API for 2.4.0 controllers (Bjorn Andersson)
    
       - Add QCS404 support (Bjorn Andersson)
    
       - Assert PERST for at least 100ms (Niklas Cassel)
    
      R-Car host bridge driver:
    
       - Add r8a774a1 DT support (Biju Das)
    
      Tegra host bridge driver:
    
       - Add support for Gen2, opportunistic UpdateFC and ACK (PCIe protocol
         details) AER, GPIO-based PERST# (Manikanta Maddireddy)
    
       - Fix many issues, including power-on failure cases, interrupt
         masking in suspend, UPHY settings, AFI dynamic clock gating,
         pending DLL transactions (Manikanta Maddireddy)
    
      Xilinx host bridge driver:
    
       - Fix NWL Multi-MSI programming (Bharat Kumar Gogada)
    
      Endpoint support:
    
       - Fix 64bit BAR support (Alan Mikhak)
    
       - Fix pcitest build issues (Alan Mikhak, Andy Shevchenko)
    
      Bug fixes:
    
       - Fix NVIDIA GPU multi-function power dependencies (Abhishek Sahu)
    
       - Fix NVIDIA GPU HDA enablement issue (Lukas Wunner)
    
       - Ignore lockdep for sysfs "remove" (Marek Vasut)
    
      Misc:
    
       - Convert docs to reST (Changbin Du, Mauro Carvalho Chehab)"
    
    * tag 'pci-v5.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (107 commits)
      PCI: Enable NVIDIA HDA controllers
      tools: PCI: Fix installation when `make tools/pci_install`
      PCI: dwc: pci-dra7xx: Fix compilation when !CONFIG_GPIOLIB
      PCI: Fix typos and whitespace errors
      PCI: mobiveil: Fix INTx interrupt clearing in mobiveil_pcie_isr()
      PCI: mobiveil: Fix infinite-loop in the INTx handling function
      PCI: mobiveil: Move PCIe PIO enablement out of inbound window routine
      PCI: mobiveil: Add upper 32-bit PCI base address setup in inbound window
      PCI: mobiveil: Add upper 32-bit CPU base address setup in outbound window
      PCI: mobiveil: Mask out hardcoded bits in inbound/outbound windows setup
      PCI: mobiveil: Clear the control fields before updating it
      PCI: mobiveil: Add configured inbound windows counter
      PCI: mobiveil: Fix the valid check for inbound and outbound windows
      PCI: mobiveil: Clean-up program_{ib/ob}_windows()
      PCI: mobiveil: Remove an unnecessary return value check
      PCI: mobiveil: Fix error return values
      PCI: mobiveil: Refactor the MEM/IO outbound window initialization
      PCI: mobiveil: Make some register updates more readable
      PCI: mobiveil: Reformat the code for readability
      dt-bindings: PCI: mobiveil: Change gpio_slave and apb_csr to optional
      ...

commit 3dbeb448543efc01f04cadd6d358b9f33dd20d31
Merge: 50e163d43ab1 02bd45a28bf3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 8 10:51:25 2019 +0200

    Merge branch 'pm-sleep'
    
    * pm-sleep:
      PM: sleep: Drop dev_pm_skip_next_resume_phases()
      ACPI: PM: Drop unused function and function header
      ACPI: PM: Introduce "poweroff" callbacks for ACPI PM domain and LPSS
      ACPI: PM: Simplify and fix PM domain hibernation callbacks
      PCI: PM: Simplify bus-level hibernation callbacks
      PM: ACPI/PCI: Resume all devices during hibernation
      kernel: power: swap: use kzalloc() instead of kmalloc() followed by memset()
      PM: sleep: Update struct wakeup_source documentation
      drivers: base: power: remove wakeup_sources_stats_dentry variable
      PM: suspend: Rename pm_suspend_via_s2idle()
      PM: sleep: Show how long dpm_suspend_start() and dpm_suspend_end() take
      PM: hibernate: powerpc: Expose pfn_is_nosave() prototype

commit a78ae45a795aa579efa4094729073bbdab02da25
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 1 12:46:45 2019 +0200

    PCI: PM: Simplify bus-level hibernation callbacks
    
    After a previous change causing all runtime-suspended PCI devices
    to be resumed before creating a snapshot image of memory during
    hibernation, it is not necessary to worry about the case in which
    them might be left in runtime-suspend any more, so get rid of the
    code related to that from bus-level PCI hibernation callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index ce54fa3ed94a..ac3e80baef0a 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -994,22 +994,11 @@ static int pci_pm_freeze(struct device *dev)
 	return 0;
 }
 
-static int pci_pm_freeze_late(struct device *dev)
-{
-	if (dev_pm_smart_suspend_and_suspended(dev))
-		return 0;
-
-	return pm_generic_freeze_late(dev);
-}
-
 static int pci_pm_freeze_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
 
-	if (dev_pm_smart_suspend_and_suspended(dev))
-		return 0;
-
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend_late(dev, PMSG_FREEZE);
 
@@ -1039,16 +1028,6 @@ static int pci_pm_thaw_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	/*
-	 * If the device is in runtime suspend, the code below may not work
-	 * correctly with it, so skip that code and make the PM core skip all of
-	 * the subsequent "thaw" callbacks for the device.
-	 */
-	if (dev_pm_smart_suspend_and_suspended(dev)) {
-		dev_pm_skip_next_resume_phases(dev);
-		return 0;
-	}
-
 	if (pcibios_pm_ops.thaw_noirq) {
 		error = pcibios_pm_ops.thaw_noirq(dev);
 		if (error)
@@ -1183,10 +1162,6 @@ static int pci_pm_restore_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	/* This is analogous to the pci_pm_resume_noirq() case. */
-	if (dev_pm_smart_suspend_and_suspended(dev))
-		pm_runtime_set_active(dev);
-
 	if (pcibios_pm_ops.restore_noirq) {
 		error = pcibios_pm_ops.restore_noirq(dev);
 		if (error)
@@ -1235,7 +1210,6 @@ static int pci_pm_restore(struct device *dev)
 #else /* !CONFIG_HIBERNATE_CALLBACKS */
 
 #define pci_pm_freeze		NULL
-#define pci_pm_freeze_late	NULL
 #define pci_pm_freeze_noirq	NULL
 #define pci_pm_thaw		NULL
 #define pci_pm_thaw_noirq	NULL
@@ -1361,7 +1335,6 @@ static const struct dev_pm_ops pci_dev_pm_ops = {
 	.suspend_late = pci_pm_suspend_late,
 	.resume = pci_pm_resume,
 	.freeze = pci_pm_freeze,
-	.freeze_late = pci_pm_freeze_late,
 	.thaw = pci_pm_thaw,
 	.poweroff = pci_pm_poweroff,
 	.poweroff_late = pci_pm_poweroff_late,

commit 501debd4aa5edc755037c39ea5a8fba23b41e580
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 1 12:44:25 2019 +0200

    PM: ACPI/PCI: Resume all devices during hibernation
    
    Both the PCI bus type and the ACPI PM domain avoid resuming
    runtime-suspended devices with DPM_FLAG_SMART_SUSPEND set during
    hibernation (before creating the snapshot image of system memory),
    but that turns out to be a mistake.  It leads to functional issues
    and adds complexity that's hard to justify.
    
    For this reason, resume all runtime-suspended PCI devices and all
    devices in the ACPI PM domains before creating a snapshot image of
    system memory during hibernation.
    
    Fixes: 05087360fd7a (ACPI / PM: Take SMART_SUSPEND driver flag into account)
    Fixes: c4b65157aeef (PCI / PM: Take SMART_SUSPEND driver flag into account)
    Link: https://lore.kernel.org/linux-acpi/917d4399-2e22-67b1-9d54-808561f9083f@uwyo.edu/T/#maf065fe6e4974f2a9d79f332ab99dfaba635f64c
    Reported-by: Robert R. Howell <RHowell@uwyo.edu>
    Tested-by: Robert R. Howell <RHowell@uwyo.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 5eadbc3d0969..ce54fa3ed94a 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -972,15 +972,15 @@ static int pci_pm_freeze(struct device *dev)
 	}
 
 	/*
-	 * This used to be done in pci_pm_prepare() for all devices and some
-	 * drivers may depend on it, so do it here.  Ideally, runtime-suspended
-	 * devices should not be touched during freeze/thaw transitions,
-	 * however.
+	 * Resume all runtime-suspended devices before creating a snapshot
+	 * image of system memory, because the restore kernel generally cannot
+	 * be expected to always handle them consistently and they need to be
+	 * put into the runtime-active metastate during system resume anyway,
+	 * so it is better to ensure that the state saved in the image will be
+	 * always consistent with that.
 	 */
-	if (!dev_pm_smart_suspend_and_suspended(dev)) {
-		pm_runtime_resume(dev);
-		pci_dev->state_saved = false;
-	}
+	pm_runtime_resume(dev);
+	pci_dev->state_saved = false;
 
 	if (pm->freeze) {
 		int error;

commit 28ad4b4e3496871ade868c3d0ecf5c53e4a49041
Merge: 471a739a47aa b51033e06c2e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jun 30 13:41:52 2019 +0200

    Merge back PCI power management material for v5.3.

commit b51033e06c2ebbad322370f4a35c84488e61b342
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jun 25 14:09:12 2019 +0200

    PCI: PM/ACPI: Refresh all stale power state data in pci_pm_complete()
    
    In pci_pm_complete() there are checks to decide whether or not to
    resume devices that were left in runtime-suspend during the preceding
    system-wide transition into a sleep state.  They involve checking the
    current power state of the device and comparing it with the power
    state of it set before the preceding system-wide transition, but the
    platform component of the device's power state is not handled
    correctly in there.
    
    Namely, on platforms with ACPI, the device power state information
    needs to be updated with care, so that the reference counters of
    power resources used by the device (if any) are set to ensure that
    the refreshed power state of it will be maintained going forward.
    
    To that end, introduce a new ->refresh_state() platform PM callback
    for PCI devices, for asking the platform to refresh the device power
    state data and ensure that the corresponding power state will be
    maintained going forward, make it invoke acpi_device_update_power()
    (for devices with ACPI PM) on platforms with ACPI and make
    pci_pm_complete() use it, through a new pci_refresh_power_state()
    wrapper function.
    
    Fixes: a0d2a959d3da (PCI: Avoid unnecessary resume after direct-complete)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index bd097ea5925c..3149f11ca265 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -710,7 +710,14 @@ static void pci_pm_complete(struct device *dev)
 	if (pm_runtime_suspended(dev) && pm_resume_via_firmware()) {
 		pci_power_t pre_sleep_state = pci_dev->current_state;
 
-		pci_update_current_state(pci_dev, pci_dev->current_state);
+		pci_refresh_power_state(pci_dev);
+		/*
+		 * On platforms with ACPI this check may also trigger for
+		 * devices sharing power resources if one of those power
+		 * resources has been activated as a result of a change of the
+		 * power state of another device sharing it.  However, in that
+		 * case it is also better to resume the device, in general.
+		 */
 		if (pci_dev->current_state < pre_sleep_state)
 			pm_request_resume(dev);
 	}

commit 471a739a47aa7d582f0cdf9d392957d04632bae2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 26 00:20:23 2019 +0200

    PCI: PM: Avoid skipping bus-level PM on platforms without ACPI
    
    There are platforms that do not call pm_set_suspend_via_firmware(),
    so pm_suspend_via_firmware() returns 'false' on them, but the power
    states of PCI devices (PCIe ports in particular) are changed as a
    result of powering down core platform components during system-wide
    suspend.  Thus the pm_suspend_via_firmware() checks in
    pci_pm_suspend_noirq() and pci_pm_resume_noirq() introduced by
    commit 3e26c5feed2a ("PCI: PM: Skip devices in D0 for suspend-to-
    idle") are not sufficient to determine that devices left in D0
    during suspend will remain in D0 during resume and so the bus-level
    power management can be skipped for them.
    
    For this reason, introduce a new global suspend flag,
    PM_SUSPEND_FLAG_NO_PLATFORM, set it for suspend-to-idle only
    and replace the pm_suspend_via_firmware() checks mentioned above
    with checks against this flag.
    
    Fixes: 3e26c5feed2a ("PCI: PM: Skip devices in D0 for suspend-to-idle")
    Reported-by: Jon Hunter <jonathanh@nvidia.com>
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 98af9ecd4a90..ca3793002e2f 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -859,7 +859,7 @@ static int pci_pm_suspend_noirq(struct device *dev)
 			pci_dev->bus->self->skip_bus_pm = true;
 	}
 
-	if (pci_dev->skip_bus_pm && !pm_suspend_via_firmware()) {
+	if (pci_dev->skip_bus_pm && pm_suspend_no_platform()) {
 		dev_dbg(dev, "PCI PM: Skipped\n");
 		goto Fixup;
 	}
@@ -914,10 +914,10 @@ static int pci_pm_resume_noirq(struct device *dev)
 	/*
 	 * In the suspend-to-idle case, devices left in D0 during suspend will
 	 * stay in D0, so it is not necessary to restore or update their
-	 * configuration here and attempting to put them into D0 again may
-	 * confuse some firmware, so avoid doing that.
+	 * configuration here and attempting to put them into D0 again is
+	 * pointless, so avoid doing that.
 	 */
-	if (!pci_dev->skip_bus_pm || pm_suspend_via_firmware())
+	if (!(pci_dev->skip_bus_pm && pm_suspend_no_platform()))
 		pci_pm_default_resume_early(pci_dev);
 
 	pci_fixup_device(pci_fixup_resume_early, pci_dev);

commit 25bc694a8a086bfee6e5b9dd9e53f4de721b0acf
Merge: 3e26c5feed2a 000dd5316e1c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 24 10:11:27 2019 +0200

    Merge back PCI power management material for v5.3.

commit 0c7376ada9508141becec9b897d73b65ce66a15a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 7 00:32:31 2019 +0200

    PCI: PM: Replace pci_dev_keep_suspended() with two functions
    
    The code in pci_dev_keep_suspended() is relatively hard to follow due
    to the negative checks in it and in its callers and the function has
    a possible side-effect (disabling the PME) which doesn't really match
    its role.
    
    For this reason, move the PME disabling from pci_dev_keep_suspended()
    to a separate function and change the semantics (and name) of the
    rest of it, so that 'true' is returned when the device needs to be
    resumed (and not the other way around).  Change the callers of
    pci_dev_keep_suspended() accordingly.
    
    While at it, make the code flow in pci_pm_poweroff() reflect the
    pci_pm_suspend() more closely to avoid arbitrary differences between
    them.
    
    This is a cosmetic change with no intention to alter behavior.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 5eadbc3d0969..dd656cf19a12 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -679,6 +679,7 @@ static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
 static int pci_pm_prepare(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
+	struct pci_dev *pci_dev = to_pci_dev(dev);
 
 	if (drv && drv->pm && drv->pm->prepare) {
 		int error = drv->pm->prepare(dev);
@@ -688,7 +689,15 @@ static int pci_pm_prepare(struct device *dev)
 		if (!error && dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_PREPARE))
 			return 0;
 	}
-	return pci_dev_keep_suspended(to_pci_dev(dev));
+	if (pci_dev_need_resume(pci_dev))
+		return 0;
+
+	/*
+	 * The PME setting needs to be adjusted here in case the direct-complete
+	 * optimization is used with respect to this device.
+	 */
+	pci_dev_adjust_pme(pci_dev);
+	return 1;
 }
 
 static void pci_pm_complete(struct device *dev)
@@ -758,9 +767,11 @@ static int pci_pm_suspend(struct device *dev)
 	 * better to resume the device from runtime suspend here.
 	 */
 	if (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND) ||
-	    !pci_dev_keep_suspended(pci_dev)) {
+	    pci_dev_need_resume(pci_dev)) {
 		pm_runtime_resume(dev);
 		pci_dev->state_saved = false;
+	} else {
+		pci_dev_adjust_pme(pci_dev);
 	}
 
 	if (pm->suspend) {
@@ -1108,10 +1119,13 @@ static int pci_pm_poweroff(struct device *dev)
 
 	/* The reason to do that is the same as in pci_pm_suspend(). */
 	if (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND) ||
-	    !pci_dev_keep_suspended(pci_dev))
+	    pci_dev_need_resume(pci_dev)) {
 		pm_runtime_resume(dev);
+		pci_dev->state_saved = false;
+	} else {
+		pci_dev_adjust_pme(pci_dev);
+	}
 
-	pci_dev->state_saved = false;
 	if (pm->poweroff) {
 		int error;
 

commit 3e26c5feed2add218046ecf91bab3cfa9bf762a6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jun 13 23:59:45 2019 +0200

    PCI: PM: Skip devices in D0 for suspend-to-idle
    
    Commit d491f2b75237 ("PCI: PM: Avoid possible suspend-to-idle issue")
    attempted to avoid a problem with devices whose drivers want them to
    stay in D0 over suspend-to-idle and resume, but it did not go as far
    as it should with that.
    
    Namely, first of all, the power state of a PCI bridge with a
    downstream device in D0 must be D0 (based on the PCI PM spec r1.2,
    sec 6, table 6-1, if the bridge is not in D0, there can be no PCI
    transactions on its secondary bus), but that is not actively enforced
    during system-wide PM transitions, so use the skip_bus_pm flag
    introduced by commit d491f2b75237 for that.
    
    Second, the configuration of devices left in D0 (whatever the reason)
    during suspend-to-idle need not be changed and attempting to put them
    into D0 again by force is pointless, so explicitly avoid doing that.
    
    Fixes: d491f2b75237 ("PCI: PM: Avoid possible suspend-to-idle issue")
    Reported-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 5eadbc3d0969..98af9ecd4a90 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -524,7 +524,6 @@ static void pci_pm_default_resume_early(struct pci_dev *pci_dev)
 	pci_power_up(pci_dev);
 	pci_restore_state(pci_dev);
 	pci_pme_restore(pci_dev);
-	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 }
 
 /*
@@ -831,18 +830,16 @@ static int pci_pm_suspend_noirq(struct device *dev)
 
 	if (pci_dev->skip_bus_pm) {
 		/*
-		 * The function is running for the second time in a row without
+		 * Either the device is a bridge with a child in D0 below it, or
+		 * the function is running for the second time in a row without
 		 * going through full resume, which is possible only during
-		 * suspend-to-idle in a spurious wakeup case.  Moreover, the
-		 * device was originally left in D0, so its power state should
-		 * not be changed here and the device register values saved
-		 * originally should be restored on resume again.
+		 * suspend-to-idle in a spurious wakeup case.  The device should
+		 * be in D0 at this point, but if it is a bridge, it may be
+		 * necessary to save its state.
 		 */
-		pci_dev->state_saved = true;
-	} else if (pci_dev->state_saved) {
-		if (pci_dev->current_state == PCI_D0)
-			pci_dev->skip_bus_pm = true;
-	} else {
+		if (!pci_dev->state_saved)
+			pci_save_state(pci_dev);
+	} else if (!pci_dev->state_saved) {
 		pci_save_state(pci_dev);
 		if (pci_power_manageable(pci_dev))
 			pci_prepare_to_sleep(pci_dev);
@@ -851,6 +848,22 @@ static int pci_pm_suspend_noirq(struct device *dev)
 	dev_dbg(dev, "PCI PM: Suspend power state: %s\n",
 		pci_power_name(pci_dev->current_state));
 
+	if (pci_dev->current_state == PCI_D0) {
+		pci_dev->skip_bus_pm = true;
+		/*
+		 * Per PCI PM r1.2, table 6-1, a bridge must be in D0 if any
+		 * downstream device is in D0, so avoid changing the power state
+		 * of the parent bridge by setting the skip_bus_pm flag for it.
+		 */
+		if (pci_dev->bus->self)
+			pci_dev->bus->self->skip_bus_pm = true;
+	}
+
+	if (pci_dev->skip_bus_pm && !pm_suspend_via_firmware()) {
+		dev_dbg(dev, "PCI PM: Skipped\n");
+		goto Fixup;
+	}
+
 	pci_pm_set_unknown_state(pci_dev);
 
 	/*
@@ -898,7 +911,16 @@ static int pci_pm_resume_noirq(struct device *dev)
 	if (dev_pm_smart_suspend_and_suspended(dev))
 		pm_runtime_set_active(dev);
 
-	pci_pm_default_resume_early(pci_dev);
+	/*
+	 * In the suspend-to-idle case, devices left in D0 during suspend will
+	 * stay in D0, so it is not necessary to restore or update their
+	 * configuration here and attempting to put them into D0 again may
+	 * confuse some firmware, so avoid doing that.
+	 */
+	if (!pci_dev->skip_bus_pm || pm_suspend_via_firmware())
+		pci_pm_default_resume_early(pci_dev);
+
+	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
@@ -1194,6 +1216,7 @@ static int pci_pm_restore_noirq(struct device *dev)
 	}
 
 	pci_pm_default_resume_early(pci_dev);
+	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);

commit 2d2f4273cbe9058d1f5a518e5e880d27d7b3b30f
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu May 9 13:27:22 2019 -0600

    PCI: Always allow probing with driver_override
    
    Commit 0e7df22401a3 ("PCI: Add sysfs sriov_drivers_autoprobe to control
    VF driver binding") introduced the sriov_drivers_autoprobe attribute
    which allows users to prevent the kernel from automatically probing a
    driver for new VFs as they are created.  This allows VFs to be spawned
    without automatically binding the new device to a host driver, such as
    in cases where the user intends to use the device only with a meta
    driver like vfio-pci.  However, the current implementation prevents any
    use of drivers_probe with the VF while sriov_drivers_autoprobe=0.  This
    blocks the now current general practice of setting driver_override
    followed by using drivers_probe to bind a device to a specified driver.
    
    The kernel never automatically sets a driver_override therefore it seems
    we can assume a driver_override reflects the intent of the user.  Also,
    probing a device using a driver_override match seems outside the scope
    of the 'auto' part of sriov_drivers_autoprobe.  Therefore, let's allow
    driver_override matches regardless of sriov_drivers_autoprobe, which we
    can do by simply testing if a driver_override is set for a device as a
    'can probe' condition.
    
    Fixes: 0e7df22401a3 ("PCI: Add sysfs sriov_drivers_autoprobe to control VF driver binding")
    Link: https://lore.kernel.org/lkml/155742996741.21878.569845487290798703.stgit@gimli.home
    Link: https://lore.kernel.org/linux-pci/155672991496.20698.4279330795743262888.stgit@gimli.home/T/#u
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 53874aae3873..b6a3a51801f0 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -399,7 +399,8 @@ void __weak pcibios_free_irq(struct pci_dev *dev)
 #ifdef CONFIG_PCI_IOV
 static inline bool pci_device_can_probe(struct pci_dev *pdev)
 {
-	return (!pdev->is_virtfn || pdev->physfn->sriov->drivers_autoprobe);
+	return (!pdev->is_virtfn || pdev->physfn->sriov->drivers_autoprobe ||
+		pdev->driver_override);
 }
 #else
 static inline bool pci_device_can_probe(struct pci_dev *pdev)

commit 76002d8b48c4b08c9bd414517dd295e132ad910b
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Wed May 1 11:00:16 2019 -0600

    PCI: Return error if cannot probe VF
    
    Commit 0e7df22401a3 ("PCI: Add sysfs sriov_drivers_autoprobe to control
    VF driver binding") allows the user to specify that drivers for VFs of
    a PF should not be probed, but it actually causes pci_device_probe() to
    return success back to the driver core in this case.  Therefore by all
    sysfs appearances the device is bound to a driver, the driver link from
    the device exists as does the device link back from the driver, yet the
    driver's probe function is never called on the device.  We also fail to
    do any sort of cleanup when we're prohibited from probing the device,
    the IRQ setup remains in place and we even hold a device reference.
    
    Instead, abort with errno before any setup or references are taken when
    pci_device_can_probe() prevents us from trying to probe the device.
    
    Link: https://lore.kernel.org/lkml/155672991496.20698.4279330795743262888.stgit@gimli.home
    Fixes: 0e7df22401a3 ("PCI: Add sysfs sriov_drivers_autoprobe to control VF driver binding")
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index cae630fe6387..53874aae3873 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -414,6 +414,9 @@ static int pci_device_probe(struct device *dev)
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct pci_driver *drv = to_pci_driver(dev->driver);
 
+	if (!pci_device_can_probe(pci_dev))
+		return -ENODEV;
+
 	pci_assign_irq(pci_dev);
 
 	error = pcibios_alloc_irq(pci_dev);
@@ -421,12 +424,10 @@ static int pci_device_probe(struct device *dev)
 		return error;
 
 	pci_dev_get(pci_dev);
-	if (pci_device_can_probe(pci_dev)) {
-		error = __pci_device_probe(drv, pci_dev);
-		if (error) {
-			pcibios_free_irq(pci_dev);
-			pci_dev_put(pci_dev);
-		}
+	error = __pci_device_probe(drv, pci_dev);
+	if (error) {
+		pcibios_free_irq(pci_dev);
+		pci_dev_put(pci_dev);
 	}
 
 	return error;

commit d491f2b75237ef37d8867830ab7fad8d9659e853
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 17 11:08:50 2019 +0200

    PCI: PM: Avoid possible suspend-to-idle issue
    
    If a PCI driver leaves the device handled by it in D0 and calls
    pci_save_state() on the device in its ->suspend() or ->suspend_late()
    callback, it can expect the device to stay in D0 over the whole
    s2idle cycle.  However, that may not be the case if there is a
    spurious wakeup while the system is suspended, because in that case
    pci_pm_suspend_noirq() will run again after pci_pm_resume_noirq()
    which calls pci_restore_state(), via pci_pm_default_resume_early(),
    so state_saved is cleared and the second iteration of
    pci_pm_suspend_noirq() will invoke pci_prepare_to_sleep() which
    may change the power state of the device.
    
    To avoid that, add a new internal flag, skip_bus_pm, that will be set
    by pci_pm_suspend_noirq() when it runs for the first time during the
    given system suspend-resume cycle if the state of the device has
    been saved already and the device is still in D0.  Setting that flag
    will cause the next iterations of pci_pm_suspend_noirq() to set
    state_saved for pci_pm_resume_noirq(), so that it always restores the
    device state from the originally saved data, and avoid calling
    pci_prepare_to_sleep() for the device.
    
    Fixes: 33e4f80ee69b ("ACPI / PM: Ignore spurious SCI wakeups from suspend-to-idle")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Keith Busch <keith.busch@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index cae630fe6387..5eadbc3d0969 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -734,6 +734,8 @@ static int pci_pm_suspend(struct device *dev)
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
+	pci_dev->skip_bus_pm = false;
+
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_SUSPEND);
 
@@ -827,7 +829,20 @@ static int pci_pm_suspend_noirq(struct device *dev)
 		}
 	}
 
-	if (!pci_dev->state_saved) {
+	if (pci_dev->skip_bus_pm) {
+		/*
+		 * The function is running for the second time in a row without
+		 * going through full resume, which is possible only during
+		 * suspend-to-idle in a spurious wakeup case.  Moreover, the
+		 * device was originally left in D0, so its power state should
+		 * not be changed here and the device register values saved
+		 * originally should be restored on resume again.
+		 */
+		pci_dev->state_saved = true;
+	} else if (pci_dev->state_saved) {
+		if (pci_dev->current_state == PCI_D0)
+			pci_dev->skip_bus_pm = true;
+	} else {
 		pci_save_state(pci_dev);
 		if (pci_power_manageable(pci_dev))
 			pci_prepare_to_sleep(pci_dev);

commit 0968621917add2e0d60c8fbc4e24c670cb14319c
Merge: 573de2a6e844 0f46c78391e1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 09:18:12 2019 -0700

    Merge tag 'printk-for-5.2' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk updates from Petr Mladek:
    
     - Allow state reset of printk_once() calls.
    
     - Prevent crashes when dereferencing invalid pointers in vsprintf().
       Only the first byte is checked for simplicity.
    
     - Make vsprintf warnings consistent and inlined.
    
     - Treewide conversion of obsolete %pf, %pF to %ps, %pF printf
       modifiers.
    
     - Some clean up of vsprintf and test_printf code.
    
    * tag 'printk-for-5.2' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk:
      lib/vsprintf: Make function pointer_string static
      vsprintf: Limit the length of inlined error messages
      vsprintf: Avoid confusion between invalid address and value
      vsprintf: Prevent crash when dereferencing invalid pointers
      vsprintf: Consolidate handling of unknown pointer specifiers
      vsprintf: Factor out %pO handler as kobject_string()
      vsprintf: Factor out %pV handler as va_format()
      vsprintf: Factor out %p[iI] handler as ip_addr_string()
      vsprintf: Do not check address of well-known strings
      vsprintf: Consistent %pK handling for kptr_restrict == 0
      vsprintf: Shuffle restricted_pointer()
      printk: Tie printk_once / printk_deferred_once into .data.once for reset
      treewide: Switch printk users from %pf and %pF to %ps and %pS, respectively
      lib/test_printf: Switch to bitmap_zalloc()

commit d75f773c86a2b8b7278e2c33343b46a4024bc002
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Mon Mar 25 21:32:28 2019 +0200

    treewide: Switch printk users from %pf and %pF to %ps and %pS, respectively
    
    %pF and %pf are functionally equivalent to %pS and %ps conversion
    specifiers. The former are deprecated, therefore switch the current users
    to use the preferred variant.
    
    The changes have been produced by the following command:
    
            git grep -l '%p[fF]' | grep -v '^\(tools\|Documentation\)/' | \
            while read i; do perl -i -pe 's/%pf/%ps/g; s/%pF/%pS/g;' $i; done
    
    And verifying the result.
    
    Link: http://lkml.kernel.org/r/20190325193229.23390-1-sakari.ailus@linux.intel.com
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: sparclinux@vger.kernel.org
    Cc: linux-um@lists.infradead.org
    Cc: xen-devel@lists.xenproject.org
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-pm@vger.kernel.org
    Cc: drbd-dev@lists.linbit.com
    Cc: linux-block@vger.kernel.org
    Cc: linux-mmc@vger.kernel.org
    Cc: linux-nvdimm@lists.01.org
    Cc: linux-pci@vger.kernel.org
    Cc: linux-scsi@vger.kernel.org
    Cc: linux-btrfs@vger.kernel.org
    Cc: linux-f2fs-devel@lists.sourceforge.net
    Cc: linux-mm@kvack.org
    Cc: ceph-devel@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: David Sterba <dsterba@suse.com> (for btrfs)
    Acked-by: Mike Rapoport <rppt@linux.ibm.com> (for mm/memblock.c)
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (for drivers/pci)
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 79b1610a8beb..11a877461584 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -578,7 +578,7 @@ static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 		if (!pci_dev->state_saved && pci_dev->current_state != PCI_D0
 		    && pci_dev->current_state != PCI_UNKNOWN) {
 			WARN_ONCE(pci_dev->current_state != prev,
-				"PCI PM: Device state not saved by %pF\n",
+				"PCI PM: Device state not saved by %pS\n",
 				drv->suspend);
 		}
 	}
@@ -605,7 +605,7 @@ static int pci_legacy_suspend_late(struct device *dev, pm_message_t state)
 		if (!pci_dev->state_saved && pci_dev->current_state != PCI_D0
 		    && pci_dev->current_state != PCI_UNKNOWN) {
 			WARN_ONCE(pci_dev->current_state != prev,
-				"PCI PM: Device state not saved by %pF\n",
+				"PCI PM: Device state not saved by %pS\n",
 				drv->suspend_late);
 			goto Fixup;
 		}
@@ -773,7 +773,7 @@ static int pci_pm_suspend(struct device *dev)
 		if (!pci_dev->state_saved && pci_dev->current_state != PCI_D0
 		    && pci_dev->current_state != PCI_UNKNOWN) {
 			WARN_ONCE(pci_dev->current_state != prev,
-				"PCI PM: State of device not saved by %pF\n",
+				"PCI PM: State of device not saved by %pS\n",
 				pm->suspend);
 		}
 	}
@@ -821,7 +821,7 @@ static int pci_pm_suspend_noirq(struct device *dev)
 		if (!pci_dev->state_saved && pci_dev->current_state != PCI_D0
 		    && pci_dev->current_state != PCI_UNKNOWN) {
 			WARN_ONCE(pci_dev->current_state != prev,
-				"PCI PM: State of device not saved by %pF\n",
+				"PCI PM: State of device not saved by %pS\n",
 				pm->suspend_noirq);
 			goto Fixup;
 		}
@@ -1260,11 +1260,11 @@ static int pci_pm_runtime_suspend(struct device *dev)
 		 * log level.
 		 */
 		if (error == -EBUSY || error == -EAGAIN) {
-			dev_dbg(dev, "can't suspend now (%pf returned %d)\n",
+			dev_dbg(dev, "can't suspend now (%ps returned %d)\n",
 				pm->runtime_suspend, error);
 			return error;
 		} else if (error) {
-			dev_err(dev, "can't suspend (%pf returned %d)\n",
+			dev_err(dev, "can't suspend (%ps returned %d)\n",
 				pm->runtime_suspend, error);
 			return error;
 		}
@@ -1276,7 +1276,7 @@ static int pci_pm_runtime_suspend(struct device *dev)
 	    && !pci_dev->state_saved && pci_dev->current_state != PCI_D0
 	    && pci_dev->current_state != PCI_UNKNOWN) {
 		WARN_ONCE(pci_dev->current_state != prev,
-			"PCI PM: State of device not saved by %pF\n",
+			"PCI PM: State of device not saved by %pS\n",
 			pm->runtime_suspend);
 		return 0;
 	}

commit 20a796a969efe37c2dd38b72538407e544f41de4
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Fri Feb 8 09:54:39 2019 -0700

    PCI: Clean up usage of __u32 type
    
    The double underscore types are meant for compatibility in userspace
    headers which does not apply here. Therefore, change to use the standard
    no-underscore types.
    
    The origin of the double underscore types dates back to before the git era
    so I was not able to find a commit to see the original justification.
    
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 79b1610a8beb..71853befd435 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -100,7 +100,7 @@ static ssize_t new_id_store(struct device_driver *driver, const char *buf,
 {
 	struct pci_driver *pdrv = to_pci_driver(driver);
 	const struct pci_device_id *ids = pdrv->id_table;
-	__u32 vendor, device, subvendor = PCI_ANY_ID,
+	u32 vendor, device, subvendor = PCI_ANY_ID,
 		subdevice = PCI_ANY_ID, class = 0, class_mask = 0;
 	unsigned long driver_data = 0;
 	int fields = 0;
@@ -168,7 +168,7 @@ static ssize_t remove_id_store(struct device_driver *driver, const char *buf,
 {
 	struct pci_dynid *dynid, *n;
 	struct pci_driver *pdrv = to_pci_driver(driver);
-	__u32 vendor, device, subvendor = PCI_ANY_ID,
+	u32 vendor, device, subvendor = PCI_ANY_ID,
 		subdevice = PCI_ANY_ID, class = 0, class_mask = 0;
 	int fields = 0;
 	size_t retval = -ENODEV;

commit 926b02d3eb547daa1d56cf9b586f31b270488b77
Merge: cf26057a9441 72199051af62
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 5 17:57:34 2019 -0800

    Merge tag 'pci-v4.21-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - Remove unused lists from ASPM pcie_link_state (Frederick Lawler)
    
     - Fix Broadcom CNB20LE host bridge unintended sign extension (Colin Ian
       King)
    
     - Expand Kconfig "PF" acronyms (Randy Dunlap)
    
     - Update MAINTAINERS for arch/x86/kernel/early-quirks.c (Bjorn Helgaas)
    
     - Add missing include to drivers/pci.h (Alexandru Gagniuc)
    
     - Override Synopsys USB 3.x HAPS device class so dwc3-haps can claim it
       instead of xhci (Thinh Nguyen)
    
     - Clean up P2PDMA documentation (Randy Dunlap)
    
     - Allow runtime PM even if driver doesn't supply callbacks (Jarkko
       Nikula)
    
     - Remove status check after submitting Switchtec MRPC Firmware Download
       commands to avoid Completion Timeouts (Kelvin Cao)
    
     - Set Switchtec coherent DMA mask to allow 64-bit DMA (Boris Glimcher)
    
     - Fix Switchtec SWITCHTEC_IOCTL_EVENT_IDX_ALL flag overwrite issue
       (Joey Zhang)
    
     - Enable write combining for Switchtec MRPC Input buffers (Kelvin Cao)
    
     - Add Switchtec MRPC DMA mode support (Wesley Sheng)
    
     - Skip VF scanning on powerpc, which does this in firmware (Sebastian
       Ott)
    
     - Add Amlogic Meson PCIe controller driver and DT bindings (Yue Wang)
    
     - Constify histb dw_pcie_host_ops structure (Julia Lawall)
    
     - Support multiple power domains for imx6 (Leonard Crestez)
    
     - Constify layerscape driver data (Stefan Agner)
    
     - Update imx6 Kconfig to allow imx6 PCIe in imx7 kernel (Trent Piepho)
    
     - Support armada8k GPIO reset (Baruch Siach)
    
     - Support suspend/resume support on imx6 (Leonard Crestez)
    
     - Don't hard-code DesignWare DBI/ATU offst (Stephen Warren)
    
     - Skip i.MX6 PHY setup on i.MX7D (Andrey Smirnov)
    
     - Remove Jianguo Sun from HiSilicon STB maintainers (Lorenzo Pieralisi)
    
     - Mask DesignWare interrupts instead of disabling them to avoid lost
       interrupts (Marc Zyngier)
    
     - Add locking when acking DesignWare interrupts (Marc Zyngier)
    
     - Ack DesignWare interrupts in the proper callbacks (Marc Zyngier)
    
     - Use devm resource parser in mediatek (Honghui Zhang)
    
     - Remove unused mediatek "num-lanes" DT property (Honghui Zhang)
    
     - Add UniPhier PCIe controller driver and DT bindings (Kunihiko
       Hayashi)
    
     - Enable MSI for imx6 downstream components (Richard Zhu)
    
    * tag 'pci-v4.21-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (40 commits)
      PCI: imx: Enable MSI from downstream components
      s390/pci: skip VF scanning
      PCI/IOV: Add flag so platforms can skip VF scanning
      PCI/IOV: Factor out sriov_add_vfs()
      PCI: uniphier: Add UniPhier PCIe host controller support
      dt-bindings: PCI: Add UniPhier PCIe host controller description
      PCI: amlogic: Add the Amlogic Meson PCIe controller driver
      dt-bindings: PCI: meson: add DT bindings for Amlogic Meson PCIe controller
      arm64: dts: mt7622: Remove un-used property for PCIe
      arm: dts: mt7623: Remove un-used property for PCIe
      dt-bindings: PCI: MediaTek: Remove un-used property
      PCI: mediatek: Remove un-used variant in struct mtk_pcie_port
      MAINTAINERS: Remove Jianguo Sun from HiSilicon STB DWC entry
      PCI: dwc: Don't hard-code DBI/ATU offset
      PCI: imx: Add imx6sx suspend/resume support
      PCI: armada8k: Add support for gpio controlled reset signal
      PCI: dwc: Adjust Kconfig to allow IMX6 PCIe host on IMX7
      PCI: dwc: layerscape: Constify driver data
      PCI: imx: Add multi-pd support
      PCI: Override Synopsys USB 3.x HAPS device class
      ...

commit 664204410afb3b0f538d176ad0c2713b04abd4b9
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Fri Dec 14 18:49:01 2018 -0700

    PCI: Remove unused attr variable in pci_dma_configure
    
    Clang warns:
    
    drivers/pci/pci-driver.c:1603:21: error: unused variable 'attr'
    [-Werror,-Wunused-variable]
    
    Commit e5361ca29f2f ("ACPI / scan: Refactor _CCA enforcement") removed
    attr's use and replaced it with its assigned value so it is no longer
    needed.
    
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 1b58e058b13f..ea55444e6ead 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1600,7 +1600,6 @@ static int pci_dma_configure(struct device *dev)
 		ret = of_dma_configure(dev, bridge->parent->of_node, true);
 	} else if (has_acpi_companion(bridge)) {
 		struct acpi_device *adev = to_acpi_device_node(bridge->fwnode);
-		enum dev_dma_attr attr = acpi_get_dma_attr(adev);
 
 		ret = acpi_dma_configure(dev, acpi_get_dma_attr(adev));
 	}

commit e5361ca29f2fea345c08d2b5cb5e3b1840cbafb8
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Thu Dec 6 13:20:49 2018 -0800

    ACPI / scan: Refactor _CCA enforcement
    
    Rather than checking the DMA attribute at each callsite, just pass it
    through for acpi_dma_configure() to handle directly. That can then deal
    with the relatively exceptional DEV_DMA_NOT_SUPPORTED case by explicitly
    installing dummy DMA ops instead of just skipping setup entirely. This
    will then free up the dev->dma_ops == NULL case for some valuable
    fastpath optimisations.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Jesper Dangaard Brouer <brouer@redhat.com>
    Tested-by: Jesper Dangaard Brouer <brouer@redhat.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Tony Luck <tony.luck@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index bef17c3fca67..1b58e058b13f 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1602,8 +1602,7 @@ static int pci_dma_configure(struct device *dev)
 		struct acpi_device *adev = to_acpi_device_node(bridge->fwnode);
 		enum dev_dma_attr attr = acpi_get_dma_attr(adev);
 
-		if (attr != DEV_DMA_NOT_SUPPORTED)
-			ret = acpi_dma_configure(dev, attr);
+		ret = acpi_dma_configure(dev, acpi_get_dma_attr(adev));
 	}
 
 	pci_put_host_bridge_device(bridge);

commit c5eb1190074cfb14c5d9cac692f1912eecf1a5e4
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Tue Oct 23 14:45:52 2018 +0300

    PCI / PM: Allow runtime PM without callback functions
    
    a9c8088c7988 ("i2c: i801: Don't restore config registers on runtime PM")
    nullified the runtime PM suspend/resume callback pointers while keeping the
    runtime PM enabled.
    
    This caused the SMBus PCI device to stay in D0 with
    /sys/devices/.../power/runtime_status showing "error" when the runtime PM
    framework attempted to autosuspend the device.  This is due to PCI bus
    runtime PM, which checks for driver runtime PM callbacks and returns
    -ENOSYS if they are not set.
    
    Since i2c-i801.c doesn't need to do anything device-specific for runtime
    PM, Jean Delvare proposed this be fixed in the PCI core rather than adding
    dummy runtime PM callback functions in the PCI drivers.
    
    Change pci_pm_runtime_suspend()/pci_pm_runtime_resume() so they allow
    changing the PCI device power state during runtime PM transitions even if
    the driver supplies no runtime PM callbacks.
    
    This fixes the runtime PM regression on i2c-i801.c.
    
    It is not obvious why the code previously required the runtime PM
    callbacks.  The test has been there since the code was introduced by
    6cbf82148ff2 ("PCI PM: Run-time callbacks for PCI bus type").
    
    On the other hand, a similar change was done to generic runtime PM
    callbacks in 05aa55dddb9e ("PM / Runtime: Lenient generic runtime pm
    callbacks").
    
    Fixes: a9c8088c7988 ("i2c: i801: Don't restore config registers on runtime PM")
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Jean Delvare <jdelvare@suse.de>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: stable@vger.kernel.org      # v4.18+

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index bef17c3fca67..33f3f475e5c6 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1251,30 +1251,29 @@ static int pci_pm_runtime_suspend(struct device *dev)
 		return 0;
 	}
 
-	if (!pm || !pm->runtime_suspend)
-		return -ENOSYS;
-
 	pci_dev->state_saved = false;
-	error = pm->runtime_suspend(dev);
-	if (error) {
+	if (pm && pm->runtime_suspend) {
+		error = pm->runtime_suspend(dev);
 		/*
 		 * -EBUSY and -EAGAIN is used to request the runtime PM core
 		 * to schedule a new suspend, so log the event only with debug
 		 * log level.
 		 */
-		if (error == -EBUSY || error == -EAGAIN)
+		if (error == -EBUSY || error == -EAGAIN) {
 			dev_dbg(dev, "can't suspend now (%pf returned %d)\n",
 				pm->runtime_suspend, error);
-		else
+			return error;
+		} else if (error) {
 			dev_err(dev, "can't suspend (%pf returned %d)\n",
 				pm->runtime_suspend, error);
-
-		return error;
+			return error;
+		}
 	}
 
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
 
-	if (!pci_dev->state_saved && pci_dev->current_state != PCI_D0
+	if (pm && pm->runtime_suspend
+	    && !pci_dev->state_saved && pci_dev->current_state != PCI_D0
 	    && pci_dev->current_state != PCI_UNKNOWN) {
 		WARN_ONCE(pci_dev->current_state != prev,
 			"PCI PM: State of device not saved by %pF\n",
@@ -1292,7 +1291,7 @@ static int pci_pm_runtime_suspend(struct device *dev)
 
 static int pci_pm_runtime_resume(struct device *dev)
 {
-	int rc;
+	int rc = 0;
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
@@ -1306,14 +1305,12 @@ static int pci_pm_runtime_resume(struct device *dev)
 	if (!pci_dev->driver)
 		return 0;
 
-	if (!pm || !pm->runtime_resume)
-		return -ENOSYS;
-
 	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 	pci_enable_wake(pci_dev, PCI_D0, false);
 	pci_fixup_device(pci_fixup_resume, pci_dev);
 
-	rc = pm->runtime_resume(dev);
+	if (pm && pm->runtime_resume)
+		rc = pm->runtime_resume(dev);
 
 	pci_dev->runtime_d3cold = false;
 

commit a40f72db8a3770ea135f4f48a007256fd1519549
Merge: c0638a455382 2538fb89b8f4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:58:54 2018 -0500

    Merge branch 'pci/misc'
    
      - Mark fall-through switch cases before enabling -Wimplicit-fallthrough
        (Gustavo A. R. Silva)
    
      - Move DMA-debug PCI init from arch code to PCI core (Christoph Hellwig)
    
      - Fix pci_request_irq() usage of IRQF_ONESHOT when no handler is supplied
        (Heiner Kallweit)
    
      - Unify PCI and DMA direction #defines (Shunyong Yang)
    
      - Add PCI_DEVICE_DATA() macro (Andy Shevchenko)
    
      - Check for VPD completion before checking for timeout (Bert Kenward)
    
      - Limit Netronome NFP5000 config space size to work around erratum (Jakub
        Kicinski)
    
    * pci/misc:
      PCI: Limit config space size for Netronome NFP5000
      PCI/VPD: Check for VPD access completion before checking for timeout
      PCI: Add PCI_DEVICE_DATA() macro to fully describe device ID entry
      PCI: Unify PCI and normal DMA direction definitions
      PCI: Use IRQF_ONESHOT if pci_request_irq() called with no handler
      PCI: Call dma_debug_add_bus() for pci_bus_type from PCI core
      PCI: Mark fall-through switch cases before enabling -Wimplicit-fallthrough
    
    # Conflicts:
    #       drivers/pci/hotplug/pciehp_ctrl.c

commit a8651194f9f61406cb8926feeeb7829258295b2a
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jul 30 09:38:42 2018 +0200

    PCI: Call dma_debug_add_bus() for pci_bus_type from PCI core
    
    There is nothing arch-specific about PCI or dma-debug, so call
    dma_debug_add_bus() from the PCI core just after registering the bus type.
    
    Most of dma-debug is already generic; this just adds reporting of pending
    dma-allocations on driver unload for arches other than powerpc, sh, and
    x86.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index c125d53033c6..7a02f94fd231 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1667,7 +1667,7 @@ static int __init pci_driver_init(void)
 	if (ret)
 		return ret;
 #endif
-
+	dma_debug_add_bus(&pci_bus_type);
 	return 0;
 }
 postcore_initcall(pci_driver_init);

commit 38972375ef7bdc7dd989bcb48d5448662a95bca2
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Fri Jun 29 15:08:52 2018 -0500

    PCI/IOV: Reset total_VFs limit after detaching PF driver
    
    The TotalVFs register in the SR-IOV capability is the hardware limit on the
    number of VFs.  A PF driver can limit the number of VFs further with
    pci_sriov_set_totalvfs().  When the PF driver is removed, reset any VF
    limit that was imposed by the driver because that limit may not apply to
    other drivers.
    
    Before 8d85a7a4f2c9 ("PCI/IOV: Allow PF drivers to limit total_VFs to 0"),
    pci_sriov_set_totalvfs(pdev, 0) meant "we can enable TotalVFs virtual
    functions", and the nfp driver used that to remove the VF limit when the
    driver unloads.
    
    8d85a7a4f2c9 broke that because instead of removing the VF limit,
    pci_sriov_set_totalvfs(pdev, 0) actually sets the limit to zero, and that
    limit persists even if another driver is loaded.
    
    We could fix that by making the nfp driver reset the limit when it unloads,
    but it seems more robust to do it in the PCI core instead of relying on the
    driver.
    
    The regression scenario is:
    
      nfp_pci_probe (driver 1)
      ...
      nfp_pci_remove
        pci_sriov_set_totalvfs(pf->pdev, 0)   # limits VFs to 0
    
      ...
      nfp_pci_probe (driver 2)
        nfp_rtsym_read_le("nfd_vf_cfg_max_vfs")
        # no VF limit from firmware
    
    Now driver 2 is broken because the VF limit is still 0 from driver 1.
    
    Fixes: 8d85a7a4f2c9 ("PCI/IOV: Allow PF drivers to limit total_VFs to 0")
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    [bhelgaas: changelog, rename functions]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index c125d53033c6..6792292b5fc7 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -445,6 +445,7 @@ static int pci_device_remove(struct device *dev)
 		}
 		pcibios_free_irq(pci_dev);
 		pci_dev->driver = NULL;
+		pci_iov_remove(pci_dev);
 	}
 
 	/* Undo the runtime PM settings in local_pci_probe() */

commit 3a3869f1c443383ef8354ffa0e5fb8df65d8b549
Merge: 3036bc45364f 488ad6d3678b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 7 12:45:58 2018 -0700

    Merge tag 'pci-v4.18-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
      - unify AER decoding for native and ACPI CPER sources (Alexandru
        Gagniuc)
    
      - add TLP header info to AER tracepoint (Thomas Tai)
    
      - add generic pcie_wait_for_link() interface (Oza Pawandeep)
    
      - handle AER ERR_FATAL by removing and re-enumerating devices, as
        Downstream Port Containment does (Oza Pawandeep)
    
      - factor out common code between AER and DPC recovery (Oza Pawandeep)
    
      - stop triggering DPC for ERR_NONFATAL errors (Oza Pawandeep)
    
      - share ERR_FATAL recovery path between AER and DPC (Oza Pawandeep)
    
      - disable ASPM L1.2 substate if we don't have LTR (Bjorn Helgaas)
    
      - respect platform ownership of LTR (Bjorn Helgaas)
    
      - clear interrupt status in top half to avoid interrupt storm (Oza
        Pawandeep)
    
      - neaten pci=earlydump output (Andy Shevchenko)
    
      - avoid errors when extended config space inaccessible (Gilles Buloz)
    
      - prevent sysfs disable of device while driver attached (Christoph
        Hellwig)
    
      - use core interface to report PCIe link properties in bnx2x, bnxt_en,
        cxgb4, ixgbe (Bjorn Helgaas)
    
      - remove unused pcie_get_minimum_link() (Bjorn Helgaas)
    
      - fix use-before-set error in ibmphp (Dan Carpenter)
    
      - fix pciehp timeouts caused by Command Completed errata (Bjorn
        Helgaas)
    
      - fix refcounting in pnv_php hotplug (Julia Lawall)
    
      - clear pciehp Presence Detect and Data Link Layer Status Changed on
        resume so we don't miss hotplug events (Mika Westerberg)
    
      - only request pciehp control if we support it, so platform can use
        ACPI hotplug otherwise (Mika Westerberg)
    
      - convert SHPC to be builtin only (Mika Westerberg)
    
      - request SHPC control via _OSC if we support it (Mika Westerberg)
    
      - simplify SHPC handoff from firmware (Mika Westerberg)
    
      - fix an SHPC quirk that mistakenly included *all* AMD bridges as well
        as devices from any vendor with device ID 0x7458 (Bjorn Helgaas)
    
      - assign a bus number even to non-native hotplug bridges to leave
        space for acpiphp additions, to fix a common Thunderbolt xHCI
        hot-add failure (Mika Westerberg)
    
      - keep acpiphp from scanning native hotplug bridges, to fix common
        Thunderbolt hot-add failures (Mika Westerberg)
    
      - improve "partially hidden behind bridge" messages from core (Mika
        Westerberg)
    
      - add macros for PCIe Link Control 2 register (Frederick Lawler)
    
      - replace IB/hfi1 custom macros with PCI core versions (Frederick
        Lawler)
    
      - remove dead microblaze and xtensa code (Bjorn Helgaas)
    
      - use dev_printk() when possible in xtensa and mips (Bjorn Helgaas)
    
      - remove unused pcie_port_acpi_setup() and portdrv_acpi.c (Bjorn
        Helgaas)
    
      - add managed interface to get PCI host bridge resources from OF (Jan
        Kiszka)
    
      - add support for unbinding generic PCI host controller (Jan Kiszka)
    
      - fix memory leaks when unbinding generic PCI host controller (Jan
        Kiszka)
    
      - request legacy VGA framebuffer only for VGA devices to avoid false
        device conflicts (Bjorn Helgaas)
    
      - turn on PCI_COMMAND_IO & PCI_COMMAND_MEMORY in pci_enable_device()
        like everybody else, not in pcibios_fixup_bus() (Bjorn Helgaas)
    
      - add generic enable function for simple SR-IOV hardware (Alexander
        Duyck)
    
      - use generic SR-IOV enable for ena, nvme (Alexander Duyck)
    
      - add ACS quirk for Intel 7th & 8th Gen mobile (Alex Williamson)
    
      - add ACS quirk for Intel 300 series (Mika Westerberg)
    
      - enable register clock for Armada 7K/8K (Gregory CLEMENT)
    
      - reduce Keystone "link already up" log level (Fabio Estevam)
    
      - move private DT functions to drivers/pci/ (Rob Herring)
    
      - factor out dwc CONFIG_PCI Kconfig dependencies (Rob Herring)
    
      - add DesignWare support to the endpoint test driver (Gustavo
        Pimentel)
    
      - add DesignWare support for endpoint mode (Gustavo Pimentel)
    
      - use devm_ioremap_resource() instead of devm_ioremap() in dra7xx and
        artpec6 (Gustavo Pimentel)
    
      - fix Qualcomm bitwise NOT issue (Dan Carpenter)
    
      - add Qualcomm runtime PM support (Srinivas Kandagatla)
    
      - fix DesignWare enumeration below bridges (Koen Vandeputte)
    
      - use usleep() instead of mdelay() in endpoint test (Jia-Ju Bai)
    
      - add configfs entries for pci_epf_driver device IDs (Kishon Vijay
        Abraham I)
    
      - clean up pci_endpoint_test driver (Gustavo Pimentel)
    
      - update Layerscape maintainer email addresses (Minghuan Lian)
    
      - add COMPILE_TEST to improve build test coverage (Rob Herring)
    
      - fix Hyper-V bus registration failure caused by domain/serial number
        confusion (Sridhar Pitchai)
    
      - improve Hyper-V refcounting and coding style (Stephen Hemminger)
    
      - avoid potential Hyper-V hang waiting for a response that will never
        come (Dexuan Cui)
    
      - implement Mediatek chained IRQ handling (Honghui Zhang)
    
      - fix vendor ID & class type for Mediatek MT7622 (Honghui Zhang)
    
      - add Mobiveil PCIe host controller driver (Subrahmanya Lingappa)
    
      - add Mobiveil MSI support (Subrahmanya Lingappa)
    
      - clean up clocks, MSI, IRQ mappings in R-Car probe failure paths
        (Marek Vasut)
    
      - poll more frequently (5us vs 5ms) while waiting for R-Car data link
        active (Marek Vasut)
    
      - use generic OF parsing interface in R-Car (Vladimir Zapolskiy)
    
      - add R-Car V3H (R8A77980) "compatible" string (Sergei Shtylyov)
    
      - add R-Car gen3 PHY support (Sergei Shtylyov)
    
      - improve R-Car PHYRDY polling (Sergei Shtylyov)
    
      - clean up R-Car macros (Marek Vasut)
    
      - use runtime PM for R-Car controller clock (Dien Pham)
    
      - update arm64 defconfig for Rockchip (Shawn Lin)
    
      - refactor Rockchip code to facilitate both root port and endpoint
        mode (Shawn Lin)
    
      - add Rockchip endpoint mode driver (Shawn Lin)
    
      - support VMD "membar shadow" feature (Jon Derrick)
    
      - support VMD bus number offsets (Jon Derrick)
    
      - add VMD "no AER source ID" quirk for more device IDs (Jon Derrick)
    
      - remove unnecessary host controller CONFIG_PCIEPORTBUS Kconfig
        selections (Bjorn Helgaas)
    
      - clean up quirks.c organization and whitespace (Bjorn Helgaas)
    
    * tag 'pci-v4.18-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (144 commits)
      PCI/AER: Replace struct pcie_device with pci_dev
      PCI/AER: Remove unused parameters
      PCI: qcom: Include gpio/consumer.h
      PCI: Improve "partially hidden behind bridge" log message
      PCI: Improve pci_scan_bridge() and pci_scan_bridge_extend() doc
      PCI: Move resource distribution for single bridge outside loop
      PCI: Account for all bridges on bus when distributing bus numbers
      ACPI / hotplug / PCI: Drop unnecessary parentheses
      ACPI / hotplug / PCI: Mark stale PCI devices disconnected
      ACPI / hotplug / PCI: Don't scan bridges managed by native hotplug
      PCI: hotplug: Add hotplug_is_native()
      PCI: shpchp: Add shpchp_is_native()
      PCI: shpchp: Fix AMD POGO identification
      PCI: mobiveil: Add MSI support
      PCI: mobiveil: Add Mobiveil PCIe Host Bridge IP driver
      PCI/AER: Decode Error Source Requester ID
      PCI/AER: Remove aer_recover_work_func() forward declaration
      PCI/DPC: Use the generic pcie_do_fatal_recovery() path
      PCI/AER: Pass service type to pcie_do_fatal_recovery()
      PCI/DPC: Disable ERR_NONFATAL handling by DPC
      ...

commit 3c89adb0d11117f64d5b501730be7fb2bf53a479
Merge: 11e7c2188061 a24e16b1310c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 5 09:38:39 2018 -0700

    Merge tag 'pm-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael Wysocki:
     "These include a significant update of the generic power domains
      (genpd) and Operating Performance Points (OPP) frameworks, mostly
      related to the introduction of power domain performance levels,
      cpufreq updates (new driver for Qualcomm Kryo processors, updates of
      the existing drivers, some core fixes, schedutil governor
      improvements), PCI power management fixes, ACPI workaround for
      EC-based wakeup events handling on resume from suspend-to-idle, and
      major updates of the turbostat and pm-graph utilities.
    
      Specifics:
    
       - Introduce power domain performance levels into the the generic
         power domains (genpd) and Operating Performance Points (OPP)
         frameworks (Viresh Kumar, Rajendra Nayak, Dan Carpenter).
    
       - Fix two issues in the runtime PM framework related to the
         initialization and removal of devices using device links (Ulf
         Hansson).
    
       - Clean up the initialization of drivers for devices in PM domains
         (Ulf Hansson, Geert Uytterhoeven).
    
       - Fix a cpufreq core issue related to the policy sysfs interface
         causing CPU online to fail for CPUs sharing one cpufreq policy in
         some situations (Tao Wang).
    
       - Make it possible to use platform-specific suspend/resume hooks in
         the cpufreq-dt driver and make the Armada 37xx DVFS use that
         feature (Viresh Kumar, Miquel Raynal).
    
       - Optimize policy transition notifications in cpufreq (Viresh Kumar).
    
       - Improve the iowait boost mechanism in the schedutil cpufreq
         governor (Patrick Bellasi).
    
       - Improve the handling of deferred frequency updates in the schedutil
         cpufreq governor (Joel Fernandes, Dietmar Eggemann, Rafael Wysocki,
         Viresh Kumar).
    
       - Add a new cpufreq driver for Qualcomm Kryo (Ilia Lin).
    
       - Fix and clean up some cpufreq drivers (Colin Ian King, Dmitry
         Osipenko, Doug Smythies, Luc Van Oostenryck, Simon Horman, Viresh
         Kumar).
    
       - Fix the handling of PCI devices with the DPM_SMART_SUSPEND flag set
         and update stale comments in the PCI core PM code (Rafael Wysocki).
    
       - Work around an issue related to the handling of EC-based wakeup
         events in the ACPI PM core during resume from suspend-to-idle if
         the EC has been put into the low-power mode (Rafael Wysocki).
    
       - Improve the handling of wakeup source objects in the PM core (Doug
         Berger, Mahendran Ganesh, Rafael Wysocki).
    
       - Update the driver core to prevent deferred probe from breaking
         suspend/resume ordering (Feng Kan).
    
       - Clean up the PM core somewhat (Bjorn Helgaas, Ulf Hansson, Rafael
         Wysocki).
    
       - Make the core suspend/resume code and cpufreq support the RT patch
         (Sebastian Andrzej Siewior, Thomas Gleixner).
    
       - Consolidate the PM QoS handling in cpuidle governors (Rafael
         Wysocki).
    
       - Fix a possible crash in the hibernation core (Tetsuo Handa).
    
       - Update the rockchip-io Adaptive Voltage Scaling (AVS) driver (David
         Wu).
    
       - Update the turbostat utility (fixes, cleanups, new CPU IDs, new
         command line options, built-in "Low Power Idle" counters support,
         new POLL and POLL% columns) and add an entry for it to MAINTAINERS
         (Len Brown, Artem Bityutskiy, Chen Yu, Laura Abbott, Matt Turner,
         Prarit Bhargava, Srinivas Pandruvada).
    
       - Update the pm-graph to version 5.1 (Todd Brandt).
    
       - Update the intel_pstate_tracer utility (Doug Smythies)"
    
    * tag 'pm-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (128 commits)
      tools/power turbostat: update version number
      tools/power turbostat: Add Node in output
      tools/power turbostat: add node information into turbostat calculations
      tools/power turbostat: remove num_ from cpu_topology struct
      tools/power turbostat: rename num_cores_per_pkg to num_cores_per_node
      tools/power turbostat: track thread ID in cpu_topology
      tools/power turbostat: Calculate additional node information for a package
      tools/power turbostat: Fix node and siblings lookup data
      tools/power turbostat: set max_num_cpus equal to the cpumask length
      tools/power turbostat: if --num_iterations, print for specific number of iterations
      tools/power turbostat: Add Cannon Lake support
      tools/power turbostat: delete duplicate #defines
      x86: msr-index.h: Correct SNB_C1/C3_AUTO_UNDEMOTE defines
      tools/power turbostat: Correct SNB_C1/C3_AUTO_UNDEMOTE defines
      tools/power turbostat: add POLL and POLL% column
      tools/power turbostat: Fix --hide Pk%pc10
      tools/power turbostat: Build-in "Low Power Idle" counters support
      tools/power turbostat: Don't make man pages executable
      tools/power turbostat: remove blank lines
      tools/power turbostat: a small C-states dump readability immprovement
      ...

commit 656088aa9b513907833ba091d0dcde87571fe05b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 18 10:17:42 2018 +0200

    PCI / PM: Do not clear state_saved for devices that remain suspended
    
    The state_saved flag should not be cleared in pci_pm_suspend() if the
    given device is going to remain suspended, or the device's config
    space will not be restored properly during the subsequent resume.
    
    Namely, if the device is going to stay in suspend, both the late
    and noirq callbacks return early for it, so if its state_saved flag
    is cleared in pci_pm_suspend(), it will remain unset throughout the
    remaining part of suspend and resume and pci_restore_state() called
    for the device going forward will return without doing anything.
    
    For this reason, change pci_pm_suspend() to only clear state_saved
    if the given device is not going to remain suspended.  [This is
    analogous to what commit ae860a19f37c (PCI / PM: Do not clear
    state_saved in pci_pm_freeze() when smart suspend is set) did for
    hibernation.]
    
    Fixes: c4b65157aeef (PCI / PM: Take SMART_SUSPEND driver flag into account)
    Cc: 4.15+ <stable@vger.kernel.org> # 4.15+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index b9a131137e64..c816b0683a82 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -753,10 +753,11 @@ static int pci_pm_suspend(struct device *dev)
 	 * better to resume the device from runtime suspend here.
 	 */
 	if (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND) ||
-	    !pci_dev_keep_suspended(pci_dev))
+	    !pci_dev_keep_suspended(pci_dev)) {
 		pm_runtime_resume(dev);
+		pci_dev->state_saved = false;
+	}
 
-	pci_dev->state_saved = false;
 	if (pm->suspend) {
 		pci_power_t prev = pci_dev->current_state;
 		int error;

commit 2e28bc84cf6eecd3759d7ae723bb0f5f09becf76
Author: Oza Pawandeep <poza@codeaurora.org>
Date:   Thu May 17 16:44:15 2018 -0500

    PCI/AER: Factor out error reporting to drivers/pci/pcie/err.c
    
    Move the error reporting callbacks from aerdrv_core.c to err.c, where they
    can be used by DPC in addition to AER.
    
    As part of aerdrv_core.c, these callbacks were built under CONFIG_PCIEAER.
    Moving them to the new err.c means they will now be built under
    CONFIG_PCIEPORTBUS, so adjust the definition of pci_uevent_ers() to match.
    
    Signed-off-by: Oza Pawandeep <poza@codeaurora.org>
    [bhelgaas: in reset_link(), initialize "driver" even if CONFIG_PCIEAER is
    unset, update pci_uevent_ers() #ifdef wrapper]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 6ace47099fc5..ffb956457b4a 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1535,7 +1535,7 @@ static int pci_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return 0;
 }
 
-#if defined(CONFIG_PCIEAER) || defined(CONFIG_EEH)
+#if defined(CONFIG_PCIEPORTBUS) || defined(CONFIG_EEH)
 /**
  * pci_uevent_ers - emit a uevent during recovery path of PCI device
  * @pdev: PCI device undergoing error recovery

commit 3d6ce86ee79465e1b1b6e287f8ea26b553fc768e
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu May 3 16:25:08 2018 +0200

    drivers: remove force dma flag from buses
    
    With each bus implementing its own DMA configuration callback, there is no
    need for bus to explicitly set the force_dma flag.  Modify the
    of_dma_configure function to accept an input parameter which specifies if
    implicit DMA configuration is required when it is not described by the
    firmware.
    
    Signed-off-by: Nipun Gupta <nipun.gupta@nxp.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>  # PCI parts
    Reviewed-by: Rob Herring <robh@kernel.org>
    [hch: tweaked the changelog a bit]
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index ba8c6b46269e..f8269a725667 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1595,7 +1595,7 @@ static int pci_dma_configure(struct device *dev)
 
 	if (IS_ENABLED(CONFIG_OF) && bridge->parent &&
 	    bridge->parent->of_node) {
-		ret = of_dma_configure(dev, bridge->parent->of_node);
+		ret = of_dma_configure(dev, bridge->parent->of_node, true);
 	} else if (has_acpi_companion(bridge)) {
 		struct acpi_device *adev = to_acpi_device_node(bridge->fwnode);
 		enum dev_dma_attr attr = acpi_get_dma_attr(adev);
@@ -1621,7 +1621,6 @@ struct bus_type pci_bus_type = {
 	.pm		= PCI_PM_OPS_PTR,
 	.num_vf		= pci_bus_num_vf,
 	.dma_configure	= pci_dma_configure,
-	.force_dma	= true,
 };
 EXPORT_SYMBOL(pci_bus_type);
 

commit 07397df29e57cde5799af16e8f148ae10ed75285
Author: Nipun Gupta <nipun.gupta@nxp.com>
Date:   Sat Apr 28 08:21:58 2018 +0530

    dma-mapping: move dma configuration to bus infrastructure
    
    ACPI/OF support for configuration of DMA is a bus specific aspect, and
    thus should be configured by the bus.  Introduces a 'dma_configure' bus
    method so that busses can control their DMA capabilities.
    
    Also update the PCI, Platform, ACPI and host1x buses to use the new
    method.
    
    Suggested-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Nipun Gupta <nipun.gupta@nxp.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>  # PCI parts
    Acked-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    [hch: simplified host1x_dma_configure based on a comment from Thierry,
          rewrote changelog]
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index b9a131137e64..ba8c6b46269e 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -16,6 +16,8 @@
 #include <linux/pm_runtime.h>
 #include <linux/suspend.h>
 #include <linux/kexec.h>
+#include <linux/of_device.h>
+#include <linux/acpi.h>
 #include "pci.h"
 #include "pcie/portdrv.h"
 
@@ -1577,6 +1579,35 @@ static int pci_bus_num_vf(struct device *dev)
 	return pci_num_vf(to_pci_dev(dev));
 }
 
+/**
+ * pci_dma_configure - Setup DMA configuration
+ * @dev: ptr to dev structure
+ *
+ * Function to update PCI devices's DMA configuration using the same
+ * info from the OF node or ACPI node of host bridge's parent (if any).
+ */
+static int pci_dma_configure(struct device *dev)
+{
+	struct device *bridge;
+	int ret = 0;
+
+	bridge = pci_get_host_bridge_device(to_pci_dev(dev));
+
+	if (IS_ENABLED(CONFIG_OF) && bridge->parent &&
+	    bridge->parent->of_node) {
+		ret = of_dma_configure(dev, bridge->parent->of_node);
+	} else if (has_acpi_companion(bridge)) {
+		struct acpi_device *adev = to_acpi_device_node(bridge->fwnode);
+		enum dev_dma_attr attr = acpi_get_dma_attr(adev);
+
+		if (attr != DEV_DMA_NOT_SUPPORTED)
+			ret = acpi_dma_configure(dev, attr);
+	}
+
+	pci_put_host_bridge_device(bridge);
+	return ret;
+}
+
 struct bus_type pci_bus_type = {
 	.name		= "pci",
 	.match		= pci_bus_match,
@@ -1589,6 +1620,7 @@ struct bus_type pci_bus_type = {
 	.drv_groups	= pci_drv_groups,
 	.pm		= PCI_PM_OPS_PTR,
 	.num_vf		= pci_bus_num_vf,
+	.dma_configure	= pci_dma_configure,
 	.force_dma	= true,
 };
 EXPORT_SYMBOL(pci_bus_type);

commit ae860a19f37c686e7c5816e96640168b7174a096
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Apr 20 15:22:02 2018 +0300

    PCI / PM: Do not clear state_saved in pci_pm_freeze() when smart suspend is set
    
    If a driver uses DPM_FLAG_SMART_SUSPEND and the device is already
    runtime suspended when hibernate is started PCI core skips runtime
    resuming the device but still clears pci_dev->state_saved. After the
    hibernation image is written pci_pm_thaw_noirq() makes sure subsequent
    thaw phases for the device are also skipped leaving it runtime suspended
    with pci_dev->state_saved == false.
    
    When the device is eventually runtime resumed pci_pm_runtime_resume()
    restores config space by calling pci_restore_standard_config(), however
    because pci_dev->state_saved == false pci_restore_state() never actually
    restores the config space leaving the device in a state that is not what
    the driver might expect.
    
    For example here is what happens for intel-lpss I2C devices once the
    hibernation snapshot is taken:
    
      intel-lpss 0000:00:15.0: power state changed by ACPI to D0
      intel-lpss 0000:00:1e.0: power state changed by ACPI to D3cold
      video LNXVIDEO:00: Restoring backlight state
      PM: hibernation exit
      i2c_designware i2c_designware.1: Unknown Synopsys component type: 0xffffffff
      i2c_designware i2c_designware.0: Unknown Synopsys component type: 0xffffffff
      i2c_designware i2c_designware.1: timeout in disabling adapter
      i2c_designware i2c_designware.0: timeout in disabling adapter
    
    Since PCI config space is not restored the device is still in D3hot
    making MMIO register reads return 0xffffffff.
    
    Fix this by clearing pci_dev->state_saved only if we actually end up
    runtime resuming the device.
    
    Fixes: c4b65157aeef (PCI / PM: Take SMART_SUSPEND driver flag into account)
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: 4.15+ <stable@vger.kernel.org> # 4.15+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 6ace47099fc5..b9a131137e64 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -958,10 +958,11 @@ static int pci_pm_freeze(struct device *dev)
 	 * devices should not be touched during freeze/thaw transitions,
 	 * however.
 	 */
-	if (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND))
+	if (!dev_pm_smart_suspend_and_suspended(dev)) {
 		pm_runtime_resume(dev);
+		pci_dev->state_saved = false;
+	}
 
-	pci_dev->state_saved = false;
 	if (pm->freeze) {
 		int error;
 

commit 3c0d551e02b2590fa71a1354f2f1994551a33315
Merge: 19fd08b85bc7 5f7644190986
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 6 18:31:06 2018 -0700

    Merge tag 'pci-v4.17-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - move pci_uevent_ers() out of pci.h (Michael Ellerman)
    
     - skip ASPM common clock warning if BIOS already configured it (Sinan
       Kaya)
    
     - fix ASPM Coverity warning about threshold_ns (Gustavo A. R. Silva)
    
     - remove last user of pci_get_bus_and_slot() and the function itself
       (Sinan Kaya)
    
     - add decoding for 16 GT/s link speed (Jay Fang)
    
     - add interfaces to get max link speed and width (Tal Gilboa)
    
     - add pcie_bandwidth_capable() to compute max supported link bandwidth
       (Tal Gilboa)
    
     - add pcie_bandwidth_available() to compute bandwidth available to
       device (Tal Gilboa)
    
     - add pcie_print_link_status() to log link speed and whether it's
       limited (Tal Gilboa)
    
     - use PCI core interfaces to report when device performance may be
       limited by its slot instead of doing it in each driver (Tal Gilboa)
    
     - fix possible cpqphp NULL pointer dereference (Shawn Lin)
    
     - rescan more of the hierarchy on ACPI hotplug to fix Thunderbolt/xHCI
       hotplug (Mika Westerberg)
    
     - add support for PCI I/O port space that's neither directly accessible
       via CPU in/out instructions nor directly mapped into CPU physical
       memory space. This is fairly intrusive and includes minor changes to
       interfaces used for I/O space on most platforms (Zhichang Yuan, John
       Garry)
    
     - add support for HiSilicon Hip06/Hip07 LPC I/O space (Zhichang Yuan,
       John Garry)
    
     - use PCI_EXP_DEVCTL2_COMP_TIMEOUT in rapidio/tsi721 (Bjorn Helgaas)
    
     - remove possible NULL pointer dereference in of_pci_bus_find_domain_nr()
       (Shawn Lin)
    
     - report quirk timings with dev_info (Bjorn Helgaas)
    
     - report quirks that take longer than 10ms (Bjorn Helgaas)
    
     - add and use Altera Vendor ID (Johannes Thumshirn)
    
     - tidy Makefiles and comments (Bjorn Helgaas)
    
     - don't set up INTx if MSI or MSI-X is enabled to align cris, frv,
       ia64, and mn10300 with x86 (Bjorn Helgaas)
    
     - move pcieport_if.h to drivers/pci/pcie/ to encapsulate it (Frederick
       Lawler)
    
     - merge pcieport_if.h into portdrv.h (Bjorn Helgaas)
    
     - move workaround for BIOS PME issue from portdrv to PCI core (Bjorn
       Helgaas)
    
     - completely disable portdrv with "pcie_ports=compat" (Bjorn Helgaas)
    
     - remove portdrv link order dependency (Bjorn Helgaas)
    
     - remove support for unused VC portdrv service (Bjorn Helgaas)
    
     - simplify portdrv feature permission checking (Bjorn Helgaas)
    
     - remove "pcie_hp=nomsi" parameter (use "pci=nomsi" instead) (Bjorn
       Helgaas)
    
     - remove unnecessary "pcie_ports=auto" parameter (Bjorn Helgaas)
    
     - use cached AER capability offset (Frederick Lawler)
    
     - don't enable DPC if BIOS hasn't granted AER control (Mika Westerberg)
    
     - rename pcie-dpc.c to dpc.c (Bjorn Helgaas)
    
     - use generic pci_mmap_resource_range() instead of powerpc and xtensa
       arch-specific versions (David Woodhouse)
    
     - support arbitrary PCI host bridge offsets on sparc (Yinghai Lu)
    
     - remove System and Video ROM reservations on sparc (Bjorn Helgaas)
    
     - probe for device reset support during enumeration instead of runtime
       (Bjorn Helgaas)
    
     - add ACS quirk for Ampere (ne APM) root ports (Feng Kan)
    
     - add function 1 DMA alias quirk for Marvell 88SE9220 (Thomas
       Vincent-Cross)
    
     - protect device restore with device lock (Sinan Kaya)
    
     - handle failure of FLR gracefully (Sinan Kaya)
    
     - handle CRS (config retry status) after device resets (Sinan Kaya)
    
     - skip various config reads for SR-IOV VFs as an optimization
       (KarimAllah Ahmed)
    
     - consolidate VPD code in vpd.c (Bjorn Helgaas)
    
     - add Tegra dependency on PCI_MSI_IRQ_DOMAIN (Arnd Bergmann)
    
     - add DT support for R-Car r8a7743 (Biju Das)
    
     - fix a PCI_EJECT vs PCI_BUS_RELATIONS race condition in Hyper-V host
       bridge driver that causes a general protection fault (Dexuan Cui)
    
     - fix Hyper-V host bridge hang in MSI setup on 1-vCPU VMs with SR-IOV
       (Dexuan Cui)
    
     - fix Hyper-V host bridge hang when ejecting a VF before setting up MSI
       (Dexuan Cui)
    
     - make several structures static (Fengguang Wu)
    
     - increase number of MSI IRQs supported by Synopsys DesignWare bridges
       from 32 to 256 (Gustavo Pimentel)
    
     - implemented multiplexed IRQ domain API and remove obsolete MSI IRQ
       API from DesignWare drivers (Gustavo Pimentel)
    
     - add Tegra power management support (Manikanta Maddireddy)
    
     - add Tegra loadable module support (Manikanta Maddireddy)
    
     - handle 64-bit BARs correctly in endpoint support (Niklas Cassel)
    
     - support optional regulator for HiSilicon STB (Shawn Guo)
    
     - use regulator bulk API for Qualcomm apq8064 (Srinivas Kandagatla)
    
     - support power supplies for Qualcomm msm8996 (Srinivas Kandagatla)
    
    * tag 'pci-v4.17-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (123 commits)
      MAINTAINERS: Add John Garry as maintainer for HiSilicon LPC driver
      HISI LPC: Add ACPI support
      ACPI / scan: Do not enumerate Indirect IO host children
      ACPI / scan: Rename acpi_is_serial_bus_slave() for more general use
      HISI LPC: Support the LPC host on Hip06/Hip07 with DT bindings
      of: Add missing I/O range exception for indirect-IO devices
      PCI: Apply the new generic I/O management on PCI IO hosts
      PCI: Add fwnode handler as input param of pci_register_io_range()
      PCI: Remove __weak tag from pci_register_io_range()
      MAINTAINERS: Add missing /drivers/pci/cadence directory entry
      fm10k: Report PCIe link properties with pcie_print_link_status()
      net/mlx5e: Use pcie_bandwidth_available() to compute bandwidth
      net/mlx5: Report PCIe link properties with pcie_print_link_status()
      net/mlx4_core: Report PCIe link properties with pcie_print_link_status()
      PCI: Add pcie_print_link_status() to log link speed and whether it's limited
      PCI: Add pcie_bandwidth_available() to compute bandwidth available to device
      misc: pci_endpoint_test: Handle 64-bit BARs properly
      PCI: designware-ep: Make dw_pcie_ep_reset_bar() handle 64-bit BARs properly
      PCI: endpoint: Make sure that BAR_5 does not have 64-bit flag set when clearing
      PCI: endpoint: Make epc->ops->clear_bar()/pci_epc_clear_bar() take struct *epf_bar
      ...

commit 64ae499cf2eece26bc395184aa2c9a18aa49d199
Merge: ac30aa596996 e02602bd7625
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 4 13:27:58 2018 -0500

    Merge branch 'pci/portdrv'
    
      - move pcieport_if.h to drivers/pci/pcie/ to encapsulate it (Frederick
        Lawler)
    
      - merge pcieport_if.h into portdrv.h (Bjorn Helgaas)
    
      - move workaround for BIOS PME issue from portdrv to PCI core (Bjorn
        Helgaas)
    
      - completely disable portdrv with "pcie_ports=compat" (Bjorn Helgaas)
    
      - remove portdrv link order dependency (Bjorn Helgaas)
    
      - remove support for unused VC portdrv service (Bjorn Helgaas)
    
      - simplify portdrv feature permission checking (Bjorn Helgaas)
    
      - remove "pcie_hp=nomsi" parameter (use "pci=nomsi" instead) (Bjorn
        Helgaas)
    
      - remove unnecessary "pcie_ports=auto" parameter (Bjorn Helgaas)
    
      - use cached AER capability offset (Frederick Lawler)
    
      - don't enable DPC if BIOS hasn't granted AER control (Mika Westerberg)
    
      - rename pcie-dpc.c to dpc.c (Bjorn Helgaas)
    
    * pci/portdrv:
      PCI/DPC: Rename from pcie-dpc.c to dpc.c
      PCI/DPC: Do not enable DPC if AER control is not allowed by the BIOS
      PCI/AER: Use cached AER Capability offset
      PCI/portdrv: Rename and reverse sense of pcie_ports_auto
      PCI/portdrv: Encapsulate pcie_ports_auto inside the port driver
      PCI/portdrv: Remove unnecessary "pcie_ports=auto" parameter
      PCI/portdrv: Remove "pcie_hp=nomsi" kernel parameter
      PCI/portdrv: Remove unnecessary include of <linux/pci-aspm.h>
      PCI/portdrv: Simplify PCIe feature permission checking
      PCI/portdrv: Remove unused PCIE_PORT_SERVICE_VC
      PCI/portdrv: Remove pcie_port_bus_type link order dependency
      PCI/portdrv: Disable port driver in compat mode
      PCI/PM: Clear PCIe PME Status bit for Root Complex Event Collectors
      PCI/PM: Clear PCIe PME Status bit in core, not PCIe port driver
      PCI/PM: Move pcie_clear_root_pme_status() to core
      PCI/portdrv: Merge pcieport_if.h into portdrv.h
      PCI/portdrv: Move pcieport_if.h to drivers/pci/pcie/
    
    Conflicts:
            drivers/pci/pcie/Makefile
            drivers/pci/pcie/portdrv.h

commit 43b90eaed57679731ae340a47cef49e59a321c2e
Merge: 3da1b6174ba3 ad32eb2df801
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 4 13:27:45 2018 -0500

    Merge branch 'pci/misc'
    
      - use PCI_EXP_DEVCTL2_COMP_TIMEOUT in rapidio/tsi721 (Bjorn Helgaas)
    
      - remove possible NULL pointer dereference in of_pci_bus_find_domain_nr()
        (Shawn Lin)
    
      - report quirk timings with dev_info (Bjorn Helgaas)
    
      - report quirks that take longer than 10ms (Bjorn Helgaas)
    
      - add and use Altera Vendor ID (Johannes Thumshirn)
    
      - tidy Makefiles and comments (Bjorn Helgaas)
    
    * pci/misc:
      PCI: Always define the of_node helpers
      PCI: Tidy comments
      PCI: Tidy Makefiles
      mcb: Add Altera PCI ID to mcb-pci
      PCI: Add Altera vendor ID
      PCI: Report quirks that take more than 10ms
      PCI: Report quirk timings with pci_info() instead of pr_debug()
      PCI: Fix NULL pointer dereference in of_pci_bus_find_domain_nr()
      rapidio/tsi721: use PCI_EXP_DEVCTL2_COMP_TIMEOUT macro

commit c6c889d932bb49d95273711a790d16f814cb213b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:06:56 2018 -0600

    PCI/portdrv: Remove pcie_port_bus_type link order dependency
    
    The pcie_port_bus_type must be registered before drivers that depend on it
    can be registered.  Those drivers include:
    
      pcied_init()                # PCIe native hotplug driver
      aer_service_init()          # AER driver
      dpc_service_init()          # DPC driver
      pcie_pme_service_init()     # PME driver
    
    Previously we registered pcie_port_bus_type from pcie_portdrv_init(), a
    device_initcall.  The callers of pcie_port_service_register() (above) are
    also device_initcalls.  This is fragile because the device_initcall
    ordering depends on link order, which is not explicit.
    
    Register pcie_port_bus_type from pci_driver_init() along with pci_bus_type.
    This removes the link order dependency between portdrv and the pciehp, AER,
    DPC, and PCIe PME drivers.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 646da0d2d7a8..21eb2f7ad95d 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -19,6 +19,7 @@
 #include <linux/suspend.h>
 #include <linux/kexec.h>
 #include "pci.h"
+#include "pcie/portdrv.h"
 
 struct pci_dynid {
 	struct list_head node;
@@ -1552,8 +1553,49 @@ struct bus_type pci_bus_type = {
 };
 EXPORT_SYMBOL(pci_bus_type);
 
+#ifdef CONFIG_PCIEPORTBUS
+static int pcie_port_bus_match(struct device *dev, struct device_driver *drv)
+{
+	struct pcie_device *pciedev;
+	struct pcie_port_service_driver *driver;
+
+	if (drv->bus != &pcie_port_bus_type || dev->bus != &pcie_port_bus_type)
+		return 0;
+
+	pciedev = to_pcie_device(dev);
+	driver = to_service_driver(drv);
+
+	if (driver->service != pciedev->service)
+		return 0;
+
+	if (driver->port_type != PCIE_ANY_PORT &&
+	    driver->port_type != pci_pcie_type(pciedev->port))
+		return 0;
+
+	return 1;
+}
+
+struct bus_type pcie_port_bus_type = {
+	.name		= "pci_express",
+	.match		= pcie_port_bus_match,
+};
+EXPORT_SYMBOL_GPL(pcie_port_bus_type);
+#endif
+
 static int __init pci_driver_init(void)
 {
-	return bus_register(&pci_bus_type);
+	int ret;
+
+	ret = bus_register(&pci_bus_type);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_PCIEPORTBUS
+	ret = bus_register(&pcie_port_bus_type);
+	if (ret)
+		return ret;
+#endif
+
+	return 0;
 }
 postcore_initcall(pci_driver_init);

commit 3620c71484f7a19b2588e577ea732f55719f5b1f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:06:55 2018 -0600

    PCI/PM: Clear PCIe PME Status bit for Root Complex Event Collectors
    
    Per PCIe r4.0, sec 6.1.6, Root Complex Event Collectors can generate PME
    interrupts on behalf of Root Complex Integrated Endpoints.
    
    Linux does not currently enable PME interrupts from RC Event Collectors,
    but fe31e69740ed ("PCI/PCIe: Clear Root PME Status bits early during system
    resume") suggests PME interrupts may be enabled by the platform for ACPI-
    based runtime wakeup.
    
    Clear the PCIe PME Status bit for Root Complex Event Collectors during
    resume, just like we already do for Root Ports.
    
    If the BIOS enables PME interrupts for an event collector and neglects to
    clear the status bit on resume, this change should fix the same bug as
    fe31e69740ed (PMEs not working after waking from a sleep state), but for
    Root Complex Integrated Endpoints.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index c49af2b679bc..646da0d2d7a8 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -722,7 +722,8 @@ static void pcie_pme_root_status_cleanup(struct pci_dev *pci_dev)
 	 * Clear those bits now just in case (shouldn't hurt).
 	 */
 	if (pci_is_pcie(pci_dev) &&
-	    pci_pcie_type(pci_dev) == PCI_EXP_TYPE_ROOT_PORT)
+	    (pci_pcie_type(pci_dev) == PCI_EXP_TYPE_ROOT_PORT ||
+	     pci_pcie_type(pci_dev) == PCI_EXP_TYPE_RC_EC))
 		pcie_clear_root_pme_status(pci_dev);
 }
 

commit df62ab5e0f75608919df7442654b0fab78246b7b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 16:36:33 2018 -0600

    PCI: Tidy comments
    
    Remove pointless comments that tell us the file name, remove blank line
    comments, follow multi-line comment conventions.  No functional change
    intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 3bed6beda051..5f1215222113 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1,7 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * drivers/pci/pci-driver.c
- *
  * (C) Copyright 2002-2004, 2007 Greg Kroah-Hartman <greg@kroah.com>
  * (C) Copyright 2007 Novell Inc.
  */

commit 5775b843a619b3c93f946e2b55a208d9f0f48b59
Author: Rafael J. Wysocki <rjw@rjwysocki.net>
Date:   Sat Mar 3 10:53:24 2018 +0100

    PCI: Restore config space on runtime resume despite being unbound
    
    We leave PCI devices not bound to a driver in D0 during runtime suspend.
    But they may have a parent which is bound and can be transitioned to
    D3cold at runtime.  Once the parent goes to D3cold, the unbound child
    may go to D3cold as well.  When the child goes to D3cold, its internal
    state, including configuration of BARs, MSI, ASPM, MPS, etc., is lost.
    
    One example are recent hybrid graphics laptops which cut power to the
    discrete GPU when the root port above it goes to ACPI power state D3.
    Users may provoke this by unbinding the GPU driver and allowing runtime
    PM on the GPU via sysfs:  The PM core will then treat the GPU as
    "suspended", which in turn allows the root port to runtime suspend,
    causing the power resources listed in its _PR3 object to be powered off.
    The GPU's BARs will be uninitialized when a driver later probes it.
    
    Another example are hybrid graphics laptops where the GPU itself (rather
    than the root port) is capable of runtime suspending to D3cold.  If the
    GPU's integrated HDA controller is not bound and the GPU's driver
    decides to runtime suspend to D3cold, the HDA controller's BARs will be
    uninitialized when a driver later probes it.
    
    Fix by saving and restoring config space over a runtime suspend cycle
    even if the device is not bound.
    
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Tested-by: Peter Wu <peter@lekensteyn.nl>              # Nvidia Optimus
    Tested-by: Lukas Wunner <lukas@wunner.de>              # MacBook Pro
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    [lukas: add commit message, bikeshed code comments for clarity]
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/92fb6e6ae2730915eb733c08e2f76c6a313e3860.1520068884.git.lukas@wunner.de

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 3bed6beda051..6a67cdbd0e6a 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1224,11 +1224,14 @@ static int pci_pm_runtime_suspend(struct device *dev)
 	int error;
 
 	/*
-	 * If pci_dev->driver is not set (unbound), the device should
-	 * always remain in D0 regardless of the runtime PM status
+	 * If pci_dev->driver is not set (unbound), we leave the device in D0,
+	 * but it may go to D3cold when the bridge above it runtime suspends.
+	 * Save its config space in case that happens.
 	 */
-	if (!pci_dev->driver)
+	if (!pci_dev->driver) {
+		pci_save_state(pci_dev);
 		return 0;
+	}
 
 	if (!pm || !pm->runtime_suspend)
 		return -ENOSYS;
@@ -1276,16 +1279,18 @@ static int pci_pm_runtime_resume(struct device *dev)
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
 	/*
-	 * If pci_dev->driver is not set (unbound), the device should
-	 * always remain in D0 regardless of the runtime PM status
+	 * Restoring config space is necessary even if the device is not bound
+	 * to a driver because although we left it in D0, it may have gone to
+	 * D3cold when the bridge above it runtime suspended.
 	 */
+	pci_restore_standard_config(pci_dev);
+
 	if (!pci_dev->driver)
 		return 0;
 
 	if (!pm || !pm->runtime_resume)
 		return -ENOSYS;
 
-	pci_restore_standard_config(pci_dev);
 	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 	pci_enable_wake(pci_dev, PCI_D0, false);
 	pci_fixup_device(pci_fixup_resume, pci_dev);

commit a39bd851dccfdcb89db3d9a6b03283aaf15f310c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:06:54 2018 -0600

    PCI/PM: Clear PCIe PME Status bit in core, not PCIe port driver
    
    fe31e69740ed ("PCI/PCIe: Clear Root PME Status bits early during system
    resume") added a .resume_noirq() callback to the PCIe port driver to clear
    the PME Status bit during resume to work around a BIOS issue.
    
    The BIOS evidently enabled PME interrupts for ACPI-based runtime wakeups
    but did not clear the PME Status bit during resume, which meant PMEs after
    resume did not trigger interrupts because PME Status did not transition
    from cleared to set.
    
    The fix was in the PCIe port driver, so it worked when CONFIG_PCIEPORTBUS
    was set.  But I think we *always* want the fix because the platform may use
    PME interrupts even if Linux is built without the PCIe port driver.
    
    Move the fix from the port driver to the PCI core so we can work around
    this "PME doesn't work after waking from a sleep state" issue regardless of
    CONFIG_PCIEPORTBUS.
    
    [bhelgaas: folded in warning fix from Arnd Bergmann <arnd@arndb.de>:
    https://lkml.kernel.org/r/20180328134747.2062348-1-arnd@arndb.de]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 3bed6beda051..c49af2b679bc 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -714,6 +714,17 @@ static void pci_pm_complete(struct device *dev)
 #endif /* !CONFIG_PM_SLEEP */
 
 #ifdef CONFIG_SUSPEND
+static void pcie_pme_root_status_cleanup(struct pci_dev *pci_dev)
+{
+	/*
+	 * Some BIOSes forget to clear Root PME Status bits after system
+	 * wakeup, which breaks ACPI-based runtime wakeup on PCI Express.
+	 * Clear those bits now just in case (shouldn't hurt).
+	 */
+	if (pci_is_pcie(pci_dev) &&
+	    pci_pcie_type(pci_dev) == PCI_EXP_TYPE_ROOT_PORT)
+		pcie_clear_root_pme_status(pci_dev);
+}
 
 static int pci_pm_suspend(struct device *dev)
 {
@@ -873,6 +884,8 @@ static int pci_pm_resume_noirq(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
 
+	pcie_pme_root_status_cleanup(pci_dev);
+
 	if (drv && drv->pm && drv->pm->resume_noirq)
 		error = drv->pm->resume_noirq(dev);
 

commit 3ecac020d6dd09259414f423b577347ebee9f533
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Thu Feb 8 23:20:35 2018 +1100

    PCI/AER: Move pci_uevent_ers() out of pci.h
    
    There's no reason pci_uevent_ers() needs to be inline in pci.h, so move it
    out to a C file.
    
    Given it's used by AER the obvious location would be somewhere in
    drivers/pci/pcie/aer, but because it's also used by powerpc EEH code
    unfortunately that doesn't work in the case where EEH is enabled but
    PCIEPORTBUS is not.
    
    So for now put it in pci-driver.c, next to pci_uevent(), with an
    appropriate #ifdef so it's not built if AER and EEH are both disabled.
    
    While we're moving it also fix up the kernel doc comment for @pdev to be
    accurate.
    
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>
    Reviewed-by: Bryant G. Ly <bryantly@linux.vnet.ibm.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 3bed6beda051..8876b98546ce 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1517,6 +1517,42 @@ static int pci_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return 0;
 }
 
+#if defined(CONFIG_PCIEAER) || defined(CONFIG_EEH)
+/**
+ * pci_uevent_ers - emit a uevent during recovery path of PCI device
+ * @pdev: PCI device undergoing error recovery
+ * @err_type: type of error event
+ */
+void pci_uevent_ers(struct pci_dev *pdev, enum pci_ers_result err_type)
+{
+	int idx = 0;
+	char *envp[3];
+
+	switch (err_type) {
+	case PCI_ERS_RESULT_NONE:
+	case PCI_ERS_RESULT_CAN_RECOVER:
+		envp[idx++] = "ERROR_EVENT=BEGIN_RECOVERY";
+		envp[idx++] = "DEVICE_ONLINE=0";
+		break;
+	case PCI_ERS_RESULT_RECOVERED:
+		envp[idx++] = "ERROR_EVENT=SUCCESSFUL_RECOVERY";
+		envp[idx++] = "DEVICE_ONLINE=1";
+		break;
+	case PCI_ERS_RESULT_DISCONNECT:
+		envp[idx++] = "ERROR_EVENT=FAILED_RECOVERY";
+		envp[idx++] = "DEVICE_ONLINE=0";
+		break;
+	default:
+		break;
+	}
+
+	if (idx > 0) {
+		envp[idx++] = NULL;
+		kobject_uevent_env(&pdev->dev.kobj, KOBJ_CHANGE, envp);
+	}
+}
+#endif
+
 static int pci_bus_num_vf(struct device *dev)
 {
 	return pci_num_vf(to_pci_dev(dev));

commit 105cf3c8c6264dce4bcdab877feb8037bc4109b1
Merge: e237f98a9c13 ab8c609356fb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 6 09:59:40 2018 -0800

    Merge tag 'pci-v4.16-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - skip AER driver error recovery callbacks for correctable errors
       reported via ACPI APEI, as we already do for errors reported via the
       native path (Tyler Baicar)
    
     - fix DPC shared interrupt handling (Alex Williamson)
    
     - print full DPC interrupt number (Keith Busch)
    
     - enable DPC only if AER is available (Keith Busch)
    
     - simplify DPC code (Bjorn Helgaas)
    
     - calculate ASPM L1 substate parameter instead of hardcoding it (Bjorn
       Helgaas)
    
     - enable Latency Tolerance Reporting for ASPM L1 substates (Bjorn
       Helgaas)
    
     - move ASPM internal interfaces out of public header (Bjorn Helgaas)
    
     - allow hot-removal of VGA devices (Mika Westerberg)
    
     - speed up unplug and shutdown by assuming Thunderbolt controllers
       don't support Command Completed events (Lukas Wunner)
    
     - add AtomicOps support for GPU and Infiniband drivers (Felix Kuehling,
       Jay Cornwall)
    
     - expose "ari_enabled" in sysfs to help NIC naming (Stuart Hayes)
    
     - clean up PCI DMA interface usage (Christoph Hellwig)
    
     - remove PCI pool API (replaced with DMA pool) (Romain Perier)
    
     - deprecate pci_get_bus_and_slot(), which assumed PCI domain 0 (Sinan
       Kaya)
    
     - move DT PCI code from drivers/of/ to drivers/pci/ (Rob Herring)
    
     - add PCI-specific wrappers for dev_info(), etc (Frederick Lawler)
    
     - remove warnings on sysfs mmap failure (Bjorn Helgaas)
    
     - quiet ROM validation messages (Alex Deucher)
    
     - remove redundant memory alloc failure messages (Markus Elfring)
    
     - fill in types for compile-time VGA and other I/O port resources
       (Bjorn Helgaas)
    
     - make "pci=pcie_scan_all" work for Root Ports as well as Downstream
       Ports to help AmigaOne X1000 (Bjorn Helgaas)
    
     - add SPDX tags to all PCI files (Bjorn Helgaas)
    
     - quirk Marvell 9128 DMA aliases (Alex Williamson)
    
     - quirk broken INTx disable on Ceton InfiniTV4 (Bjorn Helgaas)
    
     - fix CONFIG_PCI=n build by adding dummy pci_irqd_intx_xlate() (Niklas
       Cassel)
    
     - use DMA API to get MSI address for DesignWare IP (Niklas Cassel)
    
     - fix endpoint-mode DMA mask configuration (Kishon Vijay Abraham I)
    
     - fix ARTPEC-6 incorrect IS_ERR() usage (Wei Yongjun)
    
     - add support for ARTPEC-7 SoC (Niklas Cassel)
    
     - add endpoint-mode support for ARTPEC (Niklas Cassel)
    
     - add Cadence PCIe host and endpoint controller driver (Cyrille
       Pitchen)
    
     - handle multiple INTx status bits being set in dra7xx (Vignesh R)
    
     - translate dra7xx hwirq range to fix INTD handling (Vignesh R)
    
     - remove deprecated Exynos PHY initialization code (Jaehoon Chung)
    
     - fix MSI erratum workaround for HiSilicon Hip06/Hip07 (Dongdong Liu)
    
     - fix NULL pointer dereference in iProc BCMA driver (Ray Jui)
    
     - fix Keystone interrupt-controller-node lookup (Johan Hovold)
    
     - constify qcom driver structures (Julia Lawall)
    
     - rework Tegra config space mapping to increase space available for
       endpoints (Vidya Sagar)
    
     - simplify Tegra driver by using bus->sysdata (Manikanta Maddireddy)
    
     - remove PCI_REASSIGN_ALL_BUS usage on Tegra (Manikanta Maddireddy)
    
     - add support for Global Fabric Manager Server (GFMS) event to
       Microsemi Switchtec switch driver (Logan Gunthorpe)
    
     - add IDs for Switchtec PSX 24xG3 and PSX 48xG3 (Kelvin Cao)
    
    * tag 'pci-v4.16-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (140 commits)
      PCI: cadence: Add EndPoint Controller driver for Cadence PCIe controller
      dt-bindings: PCI: cadence: Add DT bindings for Cadence PCIe endpoint controller
      PCI: endpoint: Fix EPF device name to support multi-function devices
      PCI: endpoint: Add the function number as argument to EPC ops
      PCI: cadence: Add host driver for Cadence PCIe controller
      dt-bindings: PCI: cadence: Add DT bindings for Cadence PCIe host controller
      PCI: Add vendor ID for Cadence
      PCI: Add generic function to probe PCI host controllers
      PCI: generic: fix missing call of pci_free_resource_list()
      PCI: OF: Add generic function to parse and allocate PCI resources
      PCI: Regroup all PCI related entries into drivers/pci/Makefile
      PCI/DPC: Reformat DPC register definitions
      PCI/DPC: Add and use DPC Status register field definitions
      PCI/DPC: Squash dpc_rp_pio_get_info() into dpc_process_rp_pio_error()
      PCI/DPC: Remove unnecessary RP PIO register structs
      PCI/DPC: Push dpc->rp_pio_status assignment into dpc_rp_pio_get_info()
      PCI/DPC: Squash dpc_rp_pio_print_error() into dpc_rp_pio_get_info()
      PCI/DPC: Make RP PIO log size check more generic
      PCI/DPC: Rename local "status" to "dpc_status"
      PCI/DPC: Squash dpc_rp_pio_print_tlp_header() into dpc_rp_pio_print_error()
      ...

commit 8cfab3cf63cfe5a53e2e566b3b86b30c187edf3a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 26 12:50:27 2018 -0600

    PCI: Add SPDX GPL-2.0 to replace GPL v2 boilerplate
    
    Add SPDX GPL-2.0 to all PCI files that specified the GPL version 2 license.
    
    Remove the boilerplate GPL version 2 language, relying on the assertion in
    b24413180f56 ("License cleanup: add SPDX GPL-2.0 license identifier to
    files with no license") that the SPDX identifier may be used instead of the
    full boilerplate text.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 945099d49f8f..9993aa1bda7d 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1,11 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * drivers/pci/pci-driver.c
  *
  * (C) Copyright 2002-2004, 2007 Greg Kroah-Hartman <greg@kroah.com>
  * (C) Copyright 2007 Novell Inc.
- *
- * Released under the GPL v2 only.
- *
  */
 
 #include <linux/pci.h>

commit 4b67157f04b584379dd0e7426bf3485a85c9bb77
Merge: f9b736f64aae 1131b0a4af91
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 18 02:55:09 2018 +0100

    Merge branch 'pm-core'
    
    * pm-core: (29 commits)
      dmaengine: rcar-dmac: Make DMAC reinit during system resume explicit
      PM / runtime: Allow no callbacks in pm_runtime_force_suspend|resume()
      PM / runtime: Check ignore_children in pm_runtime_need_not_resume()
      PM / runtime: Rework pm_runtime_force_suspend/resume()
      PM / wakeup: Print warn if device gets enabled as wakeup source during sleep
      PM / core: Propagate wakeup_path status flag in __device_suspend_late()
      PM / core: Re-structure code for clearing the direct_complete flag
      PM: i2c-designware-platdrv: Optimize power management
      PM: i2c-designware-platdrv: Use DPM_FLAG_SMART_PREPARE
      PM / mfd: intel-lpss: Use DPM_FLAG_SMART_SUSPEND
      PCI / PM: Use SMART_SUSPEND and LEAVE_SUSPENDED flags for PCIe ports
      PM / wakeup: Add device_set_wakeup_path() helper to control wakeup path
      PM / core: Assign the wakeup_path status flag in __device_prepare()
      PM / wakeup: Do not fail dev_pm_attach_wake_irq() unnecessarily
      PM / core: Direct DPM_FLAG_LEAVE_SUSPENDED handling
      PM / core: Direct DPM_FLAG_SMART_SUSPEND optimization
      PM / core: Add helpers for subsystem callback selection
      PM / wakeup: Drop redundant check from device_init_wakeup()
      PM / wakeup: Drop redundant check from device_set_wakeup_enable()
      PM / wakeup: only recommend "call"ing device_init_wakeup() once
      ...

commit bee344cb70e9bf5ad929e0a493c0f7aa3a587bfb
Author: Luis de Bethencourt <luisbg@kernel.org>
Date:   Wed Jan 17 10:33:21 2018 +0000

    PCI / PM: Remove spurious semicolon
    
    The trailing semicolon is an empty statement that does no operation.
    Removing it since it doesn't do anything.
    
    Signed-off-by: Luis de Bethencourt <luisbg@kernel.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 14fd865a5120..765890e77cd5 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -953,7 +953,7 @@ static int pci_pm_freeze_late(struct device *dev)
 	if (dev_pm_smart_suspend_and_suspended(dev))
 		return 0;
 
-	return pm_generic_freeze_late(dev);;
+	return pm_generic_freeze_late(dev);
 }
 
 static int pci_pm_freeze_noirq(struct device *dev)

commit 5839ee7389e893a31e4e3c9cf17b50d14103c902
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 15 03:07:18 2017 +0100

    PCI / PM: Force devices to D0 in pci_pm_thaw_noirq()
    
    It is incorrect to call pci_restore_state() for devices in low-power
    states (D1-D3), as that involves the restoration of MSI setup which
    requires MMIO to be operational and that is only the case in D0.
    
    However, pci_pm_thaw_noirq() may do that if the driver's "freeze"
    callbacks put the device into a low-power state, so fix it by making
    it force devices into D0 via pci_set_power_state() instead of trying
    to "update" their power state which is pointless.
    
    Fixes: e60514bd4485 (PCI/PM: Restore the status of PCI devices across hibernation)
    Cc: 4.13+ <stable@vger.kernel.org> # 4.13+
    Reported-by: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Maarten Lankhorst <dev@mblankhorst.nl>
    Tested-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Maarten Lankhorst <dev@mblankhorst.nl>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 945099d49f8f..14fd865a5120 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1012,7 +1012,12 @@ static int pci_pm_thaw_noirq(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
 
-	pci_update_current_state(pci_dev, PCI_D0);
+	/*
+	 * pci_restore_state() requires the device to be in D0 (because of MSI
+	 * restoration among other things), so force it into D0 in case the
+	 * driver's "freeze" callbacks put it into a low-power state directly.
+	 */
+	pci_set_power_state(pci_dev, PCI_D0);
 	pci_restore_state(pci_dev);
 
 	if (drv && drv->pm && drv->pm->thaw_noirq)

commit c51a024e3913e9dbaf4dfcb9aaba825668a89ace
Merge: 3487972d7fa6 34fb8f0ba9ce
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Dec 16 02:05:48 2017 +0100

    Merge back PM core material for v4.16.

commit 3487972d7fa6c5143951436ada5933dcf0ec659d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Dec 7 02:41:18 2017 +0100

    PM / sleep: Avoid excess pm_runtime_enable() calls in device_resume()
    
    Middle-layer code doing suspend-time optimizations for devices with
    the DPM_FLAG_SMART_SUSPEND flag set (currently, the PCI bus type and
    the ACPI PM domain) needs to make the core skip ->thaw_early and
    ->thaw callbacks for those devices in some cases and it sets the
    power.direct_complete flag for them for this purpose.
    
    However, it turns out that setting power.direct_complete outside of
    the PM core is a bad idea as it triggers an excess invocation of
    pm_runtime_enable() in device_resume().
    
    For this reason, provide a helper to clear power.is_late_suspended
    and power.is_suspended to be invoked by the middle-layer code in
    question instead of setting power.direct_complete and make that code
    call the new helper.
    
    Fixes: c4b65157aeef (PCI / PM: Take SMART_SUSPEND driver flag into account)
    Fixes: 05087360fd7a (ACPI / PM: Take SMART_SUSPEND driver flag into account)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 7f47bb72bf30..945099d49f8f 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -999,7 +999,7 @@ static int pci_pm_thaw_noirq(struct device *dev)
 	 * the subsequent "thaw" callbacks for the device.
 	 */
 	if (dev_pm_smart_suspend_and_suspended(dev)) {
-		dev->power.direct_complete = true;
+		dev_pm_skip_next_resume_phases(dev);
 		return 0;
 	}
 

commit bd755d770ac78e8eeda05877ba66cc66f151e10e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Nov 18 15:33:52 2017 +0100

    PCI / PM: Support for LEAVE_SUSPENDED driver flag
    
    Add support for DPM_FLAG_LEAVE_SUSPENDED to the PCI bus type by
    making it (a) set the power.may_skip_resume status bit for devices
    that, from its perspective, may be left in suspend after system
    wakeup from sleep and (b) return early from pci_pm_resume_noirq()
    for devices whose remaining resume callbacks during the transition
    under way are going to be skipped by the PM core.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 7f47bb72bf30..3cf2da22acf2 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -699,7 +699,7 @@ static void pci_pm_complete(struct device *dev)
 	pm_generic_complete(dev);
 
 	/* Resume device if platform firmware has put it in reset-power-on */
-	if (dev->power.direct_complete && pm_resume_via_firmware()) {
+	if (pm_runtime_suspended(dev) && pm_resume_via_firmware()) {
 		pci_power_t pre_sleep_state = pci_dev->current_state;
 
 		pci_update_current_state(pci_dev, pci_dev->current_state);
@@ -783,8 +783,10 @@ static int pci_pm_suspend_noirq(struct device *dev)
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
-	if (dev_pm_smart_suspend_and_suspended(dev))
+	if (dev_pm_smart_suspend_and_suspended(dev)) {
+		dev->power.may_skip_resume = true;
 		return 0;
+	}
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend_late(dev, PMSG_SUSPEND);
@@ -838,6 +840,16 @@ static int pci_pm_suspend_noirq(struct device *dev)
 Fixup:
 	pci_fixup_device(pci_fixup_suspend_late, pci_dev);
 
+	/*
+	 * If the target system sleep state is suspend-to-idle, it is sufficient
+	 * to check whether or not the device's wakeup settings are good for
+	 * runtime PM.  Otherwise, the pm_resume_via_firmware() check will cause
+	 * pci_pm_complete() to take care of fixing up the device's state
+	 * anyway, if need be.
+	 */
+	dev->power.may_skip_resume = device_may_wakeup(dev) ||
+					!device_can_wakeup(dev);
+
 	return 0;
 }
 
@@ -847,6 +859,9 @@ static int pci_pm_resume_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	if (dev_pm_may_skip_resume(dev))
+		return 0;
+
 	/*
 	 * Devices with DPM_FLAG_SMART_SUSPEND may be left in runtime suspend
 	 * during system suspend, so update their runtime PM status to "active"

commit e37e0ee0190034a059c9faea8adfb4982fb24ddd
Merge: 23c258763ba9 c9eb6172c328
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 14 16:54:12 2017 -0800

    Merge tag 'dma-mapping-4.15' of git://git.infradead.org/users/hch/dma-mapping
    
    Pull dma-mapping updates from Christoph Hellwig:
    
     - turn dma_cache_sync into a dma_map_ops instance and remove
       implementation that purely are dead because the architecture doesn't
       support noncoherent allocations
    
     - add a flag for busses that need DMA configuration (Robin Murphy)
    
    * tag 'dma-mapping-4.15' of git://git.infradead.org/users/hch/dma-mapping:
      dma-mapping: turn dma_cache_sync into a dma_map_ops method
      sh: make dma_cache_sync a no-op
      xtensa: make dma_cache_sync a no-op
      unicore32: make dma_cache_sync a no-op
      powerpc: make dma_cache_sync a no-op
      mn10300: make dma_cache_sync a no-op
      microblaze: make dma_cache_sync a no-op
      ia64: make dma_cache_sync a no-op
      frv: make dma_cache_sync a no-op
      x86: make dma_cache_sync a no-op
      floppy: consolidate the dummy fd_cacheflush definition
      drivers: flag buses which demand DMA configuration

commit 1efef68262dc567f0c09da9d11924e8287cd3a8b
Merge: 05d658b5b572 05087360fd7a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 13 01:41:26 2017 +0100

    Merge branch 'pm-core'
    
    * pm-core:
      ACPI / PM: Take SMART_SUSPEND driver flag into account
      PCI / PM: Take SMART_SUSPEND driver flag into account
      PCI / PM: Drop unnecessary invocations of pcibios_pm_ops callbacks
      PM / core: Add SMART_SUSPEND driver flag
      PCI / PM: Use the NEVER_SKIP driver flag
      PM / core: Add NEVER_SKIP and SMART_PREPARE driver flags
      PM / core: Convert timers to use timer_setup()
      PM / core: Fix kerneldoc comments of four functions
      PM / core: Drop legacy class suspend/resume operations

commit c4b65157aeefad29b2351a00a010e8c40ce7fd0e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 26 12:12:22 2017 +0200

    PCI / PM: Take SMART_SUSPEND driver flag into account
    
    Make the PCI bus type take DPM_FLAG_SMART_SUSPEND into account in its
    system-wide PM callbacks and make sure that all code that should not
    run in parallel with pci_pm_runtime_resume() is executed in the "late"
    phases of system suspend, freeze and poweroff transitions.
    
    [Note that the pm_runtime_suspended() check in pci_dev_keep_suspended()
    is an optimization, because if is not passed, all of the subsequent
    checks may be skipped and some of them are much more overhead in
    general.]
    
    Also use the observation that if the device is in runtime suspend
    at the beginning of the "late" phase of a system-wide suspend-like
    transition, its state cannot change going forward (runtime PM is
    disabled for it at that time) until the transition is over and the
    subsequent system-wide PM callbacks should be skipped for it (as
    they generally assume the device to not be suspended), so add checks
    for that in pci_pm_suspend_late/noirq(), pci_pm_freeze_late/noirq()
    and pci_pm_poweroff_late/noirq().
    
    Moreover, if pci_pm_resume_noirq() or pci_pm_restore_noirq() is
    called during the subsequent system-wide resume transition and if
    the device was left in runtime suspend previously, its runtime PM
    status needs to be changed to "active" as it is going to be put
    into the full-power state, so add checks for that too to these
    functions.
    
    In turn, if pci_pm_thaw_noirq() runs after the device has been
    left in runtime suspend, the subsequent "thaw" callbacks need
    to be skipped for it (as they may not work correctly with a
    suspended device), so set the power.direct_complete flag for the
    device then to make the PM core skip those callbacks.
    
    In addition to the above add a core helper for checking if
    DPM_FLAG_SMART_SUSPEND is set and the device runtime PM status is
    "suspended" at the same time, which is done quite often in the new
    code (and will be done elsewhere going forward too).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index c1aeeb10539e..d19bd54d337e 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -734,18 +734,25 @@ static int pci_pm_suspend(struct device *dev)
 
 	if (!pm) {
 		pci_pm_default_suspend(pci_dev);
-		goto Fixup;
+		return 0;
 	}
 
 	/*
-	 * PCI devices suspended at run time need to be resumed at this point,
-	 * because in general it is necessary to reconfigure them for system
-	 * suspend.  Namely, if the device is supposed to wake up the system
-	 * from the sleep state, we may need to reconfigure it for this purpose.
-	 * In turn, if the device is not supposed to wake up the system from the
-	 * sleep state, we'll have to prevent it from signaling wake-up.
+	 * PCI devices suspended at run time may need to be resumed at this
+	 * point, because in general it may be necessary to reconfigure them for
+	 * system suspend.  Namely, if the device is expected to wake up the
+	 * system from the sleep state, it may have to be reconfigured for this
+	 * purpose, or if the device is not expected to wake up the system from
+	 * the sleep state, it should be prevented from signaling wakeup events
+	 * going forward.
+	 *
+	 * Also if the driver of the device does not indicate that its system
+	 * suspend callbacks can cope with runtime-suspended devices, it is
+	 * better to resume the device from runtime suspend here.
 	 */
-	pm_runtime_resume(dev);
+	if (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND) ||
+	    !pci_dev_keep_suspended(pci_dev))
+		pm_runtime_resume(dev);
 
 	pci_dev->state_saved = false;
 	if (pm->suspend) {
@@ -765,17 +772,27 @@ static int pci_pm_suspend(struct device *dev)
 		}
 	}
 
- Fixup:
-	pci_fixup_device(pci_fixup_suspend, pci_dev);
-
 	return 0;
 }
 
+static int pci_pm_suspend_late(struct device *dev)
+{
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		return 0;
+
+	pci_fixup_device(pci_fixup_suspend, to_pci_dev(dev));
+
+	return pm_generic_suspend_late(dev);
+}
+
 static int pci_pm_suspend_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		return 0;
+
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend_late(dev, PMSG_SUSPEND);
 
@@ -834,6 +851,14 @@ static int pci_pm_resume_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	/*
+	 * Devices with DPM_FLAG_SMART_SUSPEND may be left in runtime suspend
+	 * during system suspend, so update their runtime PM status to "active"
+	 * as they are going to be put into D0 shortly.
+	 */
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		pm_runtime_set_active(dev);
+
 	pci_pm_default_resume_early(pci_dev);
 
 	if (pci_has_legacy_pm_support(pci_dev))
@@ -876,6 +901,7 @@ static int pci_pm_resume(struct device *dev)
 #else /* !CONFIG_SUSPEND */
 
 #define pci_pm_suspend		NULL
+#define pci_pm_suspend_late	NULL
 #define pci_pm_suspend_noirq	NULL
 #define pci_pm_resume		NULL
 #define pci_pm_resume_noirq	NULL
@@ -910,7 +936,8 @@ static int pci_pm_freeze(struct device *dev)
 	 * devices should not be touched during freeze/thaw transitions,
 	 * however.
 	 */
-	pm_runtime_resume(dev);
+	if (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND))
+		pm_runtime_resume(dev);
 
 	pci_dev->state_saved = false;
 	if (pm->freeze) {
@@ -925,11 +952,22 @@ static int pci_pm_freeze(struct device *dev)
 	return 0;
 }
 
+static int pci_pm_freeze_late(struct device *dev)
+{
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		return 0;
+
+	return pm_generic_freeze_late(dev);;
+}
+
 static int pci_pm_freeze_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
 
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		return 0;
+
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend_late(dev, PMSG_FREEZE);
 
@@ -959,6 +997,16 @@ static int pci_pm_thaw_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	/*
+	 * If the device is in runtime suspend, the code below may not work
+	 * correctly with it, so skip that code and make the PM core skip all of
+	 * the subsequent "thaw" callbacks for the device.
+	 */
+	if (dev_pm_smart_suspend_and_suspended(dev)) {
+		dev->power.direct_complete = true;
+		return 0;
+	}
+
 	if (pcibios_pm_ops.thaw_noirq) {
 		error = pcibios_pm_ops.thaw_noirq(dev);
 		if (error)
@@ -1008,11 +1056,13 @@ static int pci_pm_poweroff(struct device *dev)
 
 	if (!pm) {
 		pci_pm_default_suspend(pci_dev);
-		goto Fixup;
+		return 0;
 	}
 
 	/* The reason to do that is the same as in pci_pm_suspend(). */
-	pm_runtime_resume(dev);
+	if (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND) ||
+	    !pci_dev_keep_suspended(pci_dev))
+		pm_runtime_resume(dev);
 
 	pci_dev->state_saved = false;
 	if (pm->poweroff) {
@@ -1024,17 +1074,27 @@ static int pci_pm_poweroff(struct device *dev)
 			return error;
 	}
 
- Fixup:
-	pci_fixup_device(pci_fixup_suspend, pci_dev);
-
 	return 0;
 }
 
+static int pci_pm_poweroff_late(struct device *dev)
+{
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		return 0;
+
+	pci_fixup_device(pci_fixup_suspend, to_pci_dev(dev));
+
+	return pm_generic_poweroff_late(dev);
+}
+
 static int pci_pm_poweroff_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
 
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		return 0;
+
 	if (pci_has_legacy_pm_support(to_pci_dev(dev)))
 		return pci_legacy_suspend_late(dev, PMSG_HIBERNATE);
 
@@ -1076,6 +1136,10 @@ static int pci_pm_restore_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	/* This is analogous to the pci_pm_resume_noirq() case. */
+	if (dev_pm_smart_suspend_and_suspended(dev))
+		pm_runtime_set_active(dev);
+
 	if (pcibios_pm_ops.restore_noirq) {
 		error = pcibios_pm_ops.restore_noirq(dev);
 		if (error)
@@ -1124,10 +1188,12 @@ static int pci_pm_restore(struct device *dev)
 #else /* !CONFIG_HIBERNATE_CALLBACKS */
 
 #define pci_pm_freeze		NULL
+#define pci_pm_freeze_late	NULL
 #define pci_pm_freeze_noirq	NULL
 #define pci_pm_thaw		NULL
 #define pci_pm_thaw_noirq	NULL
 #define pci_pm_poweroff		NULL
+#define pci_pm_poweroff_late	NULL
 #define pci_pm_poweroff_noirq	NULL
 #define pci_pm_restore		NULL
 #define pci_pm_restore_noirq	NULL
@@ -1243,10 +1309,13 @@ static const struct dev_pm_ops pci_dev_pm_ops = {
 	.prepare = pci_pm_prepare,
 	.complete = pci_pm_complete,
 	.suspend = pci_pm_suspend,
+	.suspend_late = pci_pm_suspend_late,
 	.resume = pci_pm_resume,
 	.freeze = pci_pm_freeze,
+	.freeze_late = pci_pm_freeze_late,
 	.thaw = pci_pm_thaw,
 	.poweroff = pci_pm_poweroff,
+	.poweroff_late = pci_pm_poweroff_late,
 	.restore = pci_pm_restore,
 	.suspend_noirq = pci_pm_suspend_noirq,
 	.resume_noirq = pci_pm_resume_noirq,

commit 302666d8a55ce7eb5fb0bd9fbd9437d74e0ce77c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 26 12:12:16 2017 +0200

    PCI / PM: Drop unnecessary invocations of pcibios_pm_ops callbacks
    
    The only user of non-empty pcibios_pm_ops is s390 and it only uses
    "noirq" callbacks, so drop the invocations of the other pcibios_pm_ops
    callbacks from the PCI PM code.
    
    That will allow subsequent changes to be somewhat simpler.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 68a32703b30a..c1aeeb10539e 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -922,9 +922,6 @@ static int pci_pm_freeze(struct device *dev)
 			return error;
 	}
 
-	if (pcibios_pm_ops.freeze)
-		return pcibios_pm_ops.freeze(dev);
-
 	return 0;
 }
 
@@ -986,12 +983,6 @@ static int pci_pm_thaw(struct device *dev)
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 	int error = 0;
 
-	if (pcibios_pm_ops.thaw) {
-		error = pcibios_pm_ops.thaw(dev);
-		if (error)
-			return error;
-	}
-
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume(dev);
 
@@ -1036,9 +1027,6 @@ static int pci_pm_poweroff(struct device *dev)
  Fixup:
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
 
-	if (pcibios_pm_ops.poweroff)
-		return pcibios_pm_ops.poweroff(dev);
-
 	return 0;
 }
 
@@ -1111,12 +1099,6 @@ static int pci_pm_restore(struct device *dev)
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 	int error = 0;
 
-	if (pcibios_pm_ops.restore) {
-		error = pcibios_pm_ops.restore(dev);
-		if (error)
-			return error;
-	}
-
 	/*
 	 * This is necessary for the hibernation error path in which restore is
 	 * called without restoring the standard config registers of the device.

commit 08810a4119aaebf6318f209ec5dd9828e969cba4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 25 14:12:29 2017 +0200

    PM / core: Add NEVER_SKIP and SMART_PREPARE driver flags
    
    The motivation for this change is to provide a way to work around
    a problem with the direct-complete mechanism used for avoiding
    system suspend/resume handling for devices in runtime suspend.
    
    The problem is that some middle layer code (the PCI bus type and
    the ACPI PM domain in particular) returns positive values from its
    system suspend ->prepare callbacks regardless of whether the driver's
    ->prepare returns a positive value or 0, which effectively prevents
    drivers from being able to control the direct-complete feature.
    Some drivers need that control, however, and the PCI bus type has
    grown its own flag to deal with this issue, but since it is not
    limited to PCI, it is better to address it by adding driver flags at
    the core level.
    
    To that end, add a driver_flags field to struct dev_pm_info for flags
    that can be set by device drivers at the probe time to inform the PM
    core and/or bus types, PM domains and so on on the capabilities and/or
    preferences of device drivers.  Also add two static inline helpers
    for setting that field and testing it against a given set of flags
    and make the driver core clear it automatically on driver remove
    and probe failures.
    
    Define and document two PM driver flags related to the direct-
    complete feature: NEVER_SKIP and SMART_PREPARE that can be used,
    respectively, to indicate to the PM core that the direct-complete
    mechanism should never be used for the device and to inform the
    middle layer code (bus types, PM domains etc) that it can only
    request the PM core to use the direct-complete mechanism for
    the device (by returning a positive value from its ->prepare
    callback) if it also has been requested by the driver.
    
    While at it, make the core check pm_runtime_suspended() when
    setting power.direct_complete so that it doesn't need to be
    checked by ->prepare callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 11bd267fc137..68a32703b30a 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -689,8 +689,11 @@ static int pci_pm_prepare(struct device *dev)
 
 	if (drv && drv->pm && drv->pm->prepare) {
 		int error = drv->pm->prepare(dev);
-		if (error)
+		if (error < 0)
 			return error;
+
+		if (!error && dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_PREPARE))
+			return 0;
 	}
 	return pci_dev_keep_suspended(to_pci_dev(dev));
 }

commit d89e2378a97fafdc74cbf997e7c88af75b81610a
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Thu Oct 12 16:56:14 2017 +0100

    drivers: flag buses which demand DMA configuration
    
    We do not want the common dma_configure() pathway to apply
    indiscriminately to all devices, since there are plenty of buses which
    do not have DMA capability, and if their child devices were used for
    DMA API calls it would only be indicative of a driver bug. However,
    there are a number of buses for which DMA is implicitly expected even
    when not described by firmware - those we whitelist with an automatic
    opt-in to dma_configure(), assuming that the DMA address space and the
    physical address space are equivalent if not otherwise specified.
    
    Commit 723288836628 ("of: restrict DMA configuration") introduced a
    short-term fix by comparing explicit bus types, but this approach is far
    from pretty, doesn't scale well, and fails to cope at all with bus
    drivers which may be built as modules, like host1x. Let's refine things
    by making that opt-in a property of the bus type, which neatly addresses
    those problems and lets the decision of whether firmware description of
    DMA capability should be optional or mandatory stay internal to the bus
    drivers themselves.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 11bd267fc137..38bdb97b6dc6 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1466,6 +1466,7 @@ struct bus_type pci_bus_type = {
 	.drv_groups	= pci_drv_groups,
 	.pm		= PCI_PM_OPS_PTR,
 	.num_vf		= pci_bus_num_vf,
+	.force_dma	= true,
 };
 EXPORT_SYMBOL(pci_bus_type);
 

commit ca67ab5c5afbcec9df199e01838270eb5668af68
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Sep 30 01:31:15 2017 +0200

    PCI / PM: Add dev_dbg() to print device suspend power states
    
    It sometimes is useful to know what power states the kernel thinks
    it puts PCI devices into during system suspend, so add a dev_dbg()
    statement for that.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 3d04b59ffdb2..9be563067c0c 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -798,6 +798,9 @@ static int pci_pm_suspend_noirq(struct device *dev)
 			pci_prepare_to_sleep(pci_dev);
 	}
 
+	dev_dbg(dev, "PCI PM: Suspend power state: %s\n",
+		pci_power_name(pci_dev->current_state));
+
 	pci_pm_set_unknown_state(pci_dev);
 
 	/*

commit 1cb31d3fd4d96b19624328da0a0496adf76f98a6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Sep 25 01:33:13 2017 +0200

    PCI / PM: Do not resume any devices in pci_pm_prepare()
    
    It should not be necessary to resume devices with ignore_children set
    in pci_pm_prepare(), because they should be resumed explicitly by
    their children drivers during suspend if need be and they will be
    resumed by pci_pm_suspend() after that anyway, so avoid doing that.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 11bd267fc137..3d04b59ffdb2 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -680,13 +680,6 @@ static int pci_pm_prepare(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
 
-	/*
-	 * Devices having power.ignore_children set may still be necessary for
-	 * suspending their children in the next phase of device suspend.
-	 */
-	if (dev->power.ignore_children)
-		pm_runtime_resume(dev);
-
 	if (drv && drv->pm && drv->pm->prepare) {
 		int error = drv->pm->prepare(dev);
 		if (error)

commit 53ac64aac9af8cd0e5456c8a9bb68c47b571b0a9
Merge: 439644096c1a 298bd7fb26cb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 5 12:45:03 2017 -0700

    Merge tag 'acpi-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI updates from Rafael Wysocki:
     "These include a usual ACPICA code update (this time to upstream
      revision 20170728), a fix for a boot crash on some systems with
      Thunderbolt devices connected at boot time, a rework of the handling
      of PCI bridges when setting up device wakeup, new support for Apple
      device properties, support for DMA configurations reported via ACPI on
      ARM64, APEI-related updates, ACPI EC driver updates and assorted minor
      modifications in several places.
    
      Specifics:
    
       - Update the ACPICA code in the kernel to upstream revision 20170728
         including:
          * Alias operator handling update (Bob Moore).
          * Deferred resolution of reference package elements (Bob Moore).
          * Support for the _DMA method in walk resources (Bob Moore).
          * Tables handling update and support for deferred table
            verification (Lv Zheng).
          * Update of SMMU models for IORT (Robin Murphy).
          * Compiler and disassembler updates (Alex James, Erik Schmauss,
            Ganapatrao Kulkarni, James Morse).
          * Tools updates (Erik Schmauss, Lv Zheng).
          * Assorted minor fixes and cleanups (Bob Moore, Kees Cook, Lv
            Zheng, Shao Ming).
    
       - Rework the initialization of non-wakeup GPEs with method handlers
         in order to address a boot crash on some systems with Thunderbolt
         devices connected at boot time where we miss an early hotplug event
         due to a delay in GPE enabling (Rafael Wysocki).
    
       - Rework the handling of PCI bridges when setting up ACPI-based
         device wakeup in order to avoid disabling wakeup for bridges
         prematurely (Rafael Wysocki).
    
       - Consolidate Apple DMI checks throughout the tree, add support for
         Apple device properties to the device properties framework and use
         these properties for the handling of I2C and SPI devices on Apple
         systems (Lukas Wunner).
    
       - Add support for _DMA to the ACPI-based device properties lookup
         code and make it possible to use the information from there to
         configure DMA regions on ARM64 systems (Lorenzo Pieralisi).
    
       - Fix several issues in the APEI code, add support for exporting the
         BERT error region over sysfs and update APEI MAINTAINERS entry with
         reviewers information (Borislav Petkov, Dongjiu Geng, Loc Ho, Punit
         Agrawal, Tony Luck, Yazen Ghannam).
    
       - Fix a potential initialization ordering issue in the ACPI EC driver
         and clean it up somewhat (Lv Zheng).
    
       - Update the ACPI SPCR driver to extend the existing XGENE 8250
         workaround in it to a new platform (m400) and to work around an
         Xgene UART clock issue (Graeme Gregory).
    
       - Add a new utility function to the ACPI core to support using ACPI
         OEM ID / OEM Table ID / Revision for system identification in
         blacklisting or similar and switch over the existing code already
         using this information to this new interface (Toshi Kani).
    
       - Fix an xpower PMIC issue related to GPADC reads that always return
         0 without extra pin manipulations (Hans de Goede).
    
       - Add statements to print debug messages in a couple of places in the
         ACPI core for easier diagnostics (Rafael Wysocki).
    
       - Clean up the ACPI processor driver slightly (Colin Ian King, Hanjun
         Guo).
    
       - Clean up the ACPI x86 boot code somewhat (Andy Shevchenko).
    
       - Add a quirk for Dell OptiPlex 9020M to the ACPI backlight driver
         (Alex Hung).
    
       - Assorted fixes, cleanups and updates related to ACPI (Amitoj Kaur
         Chawla, Bhumika Goyal, Frank Rowand, Jean Delvare, Punit Agrawal,
         Ronald Tschalr, Sumeet Pawnikar)"
    
    * tag 'acpi-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (75 commits)
      ACPI / APEI: Suppress message if HEST not present
      intel_pstate: convert to use acpi_match_platform_list()
      ACPI / blacklist: add acpi_match_platform_list()
      ACPI, APEI, EINJ: Subtract any matching Register Region from Trigger resources
      ACPI: make device_attribute const
      ACPI / sysfs: Extend ACPI sysfs to provide access to boot error region
      ACPI: APEI: fix the wrong iteration of generic error status block
      ACPI / processor: make function acpi_processor_check_duplicates() static
      ACPI / EC: Clean up EC GPE mask flag
      ACPI: EC: Fix possible issues related to EC initialization order
      ACPI / PM: Add debug statements to acpi_pm_notify_handler()
      ACPI: Add debug statements to acpi_global_event_handler()
      ACPI / scan: Enable GPEs before scanning the namespace
      ACPICA: Make it possible to enable runtime GPEs earlier
      ACPICA: Dispatch active GPEs at init time
      ACPI: SPCR: work around clock issue on xgene UART
      ACPI: SPCR: extend XGENE 8250 workaround to m400
      ACPI / LPSS: Don't abort ACPI scan on missing mem resource
      mailbox: pcc: Drop uninformative output during boot
      ACPI/IORT: Add IORT named component memory address limits
      ...

commit 92d50fc1602ecef44babe411c475344e55e1cdd9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 19 15:01:06 2017 +0200

    PCI/IB: add support for pci driver attribute groups
    
    Some drivers (specifically the nes IB driver), want to create a lot of
    sysfs driver attributes.  Instead of open-coding the creation and
    removal of these files (and getting it wrong btw), it's a better idea to
    let the driver core handle all of this logic for us.
    
    So add a new field to the pci driver structure, **groups, that allows
    pci drivers to specify an attribute group list it wishes to have created
    when it is registered with the driver core.
    
    Big bonus is now the driver doesn't race with userspace when the sysfs
    files are created vs. when the kobject is announced, so any script/tool
    that actually wanted to use these files will not have to poll waiting
    for them to show up.
    
    Cc: Faisal Latif <faisal.latif@intel.com>
    Cc: Doug Ledford <dledford@redhat.com>
    Cc: Sean Hefty <sean.hefty@intel.com>
    Cc: Hal Rosenstock <hal.rosenstock@gmail.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index d51e8738f9c2..4450feaf5c00 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1307,6 +1307,7 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 	drv->driver.bus = &pci_bus_type;
 	drv->driver.owner = owner;
 	drv->driver.mod_name = mod_name;
+	drv->driver.groups = drv->groups;
 
 	spin_lock_init(&drv->dynids.lock);
 	INIT_LIST_HEAD(&drv->dynids.list);

commit baecc470d5fd6e2d94eb2a7e242ba291ac7182ac
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 21 14:38:08 2017 +0200

    PCI / PM: Skip bridges in pci_enable_wake()
    
    PCI bridges only have a reason to generate wakeup signals on behalf
    of devices below them, so avoid preparing bridges for wakeup directly
    in pci_enable_wake().
    
    Also drop the pci_has_subordinate() check from pci_pm_default_resume()
    as this will be done by pci_enable_wake() itself now.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index d51e8738f9c2..e426f8b44c92 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -647,9 +647,7 @@ static int pci_legacy_resume(struct device *dev)
 static void pci_pm_default_resume(struct pci_dev *pci_dev)
 {
 	pci_fixup_device(pci_fixup_resume, pci_dev);
-
-	if (!pci_has_subordinate(pci_dev))
-		pci_enable_wake(pci_dev, PCI_D0, false);
+	pci_enable_wake(pci_dev, PCI_D0, false);
 }
 
 static void pci_pm_default_suspend(struct pci_dev *pci_dev)

commit ec4b8ddcd3b9836ae06fcf8d7f6442e7d9f0c6e6
Merge: 1633b396105b c7b5a4e6e8fb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 14 13:15:49 2017 +0200

    Merge branch 'pm-pci'
    
    * pm-pci:
      PCI / PM: Fix native PME handling during system suspend/resume
      PCI / PM: Restore PME Enable after config space restoration

commit 0ce3fcaff92908c370334ce3b9111aeea71159d6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 12 03:05:39 2017 +0200

    PCI / PM: Restore PME Enable after config space restoration
    
    Commit dc15e71eefc7 (PCI / PM: Restore PME Enable if skipping wakeup
    setup) introduced a mechanism by which the PME Enable bit can be
    restored by pci_enable_wake() if dev->wakeup_prepared is set in
    case it has been overwritten by PCI config space restoration.
    
    However, that commit overlooked the fact that on some systems (Dell
    XPS13 9360 in particular) the AML handling wakeup events checks PME
    Status and PME Enable and it won't trigger a Notify() for devices
    where those bits are not set while it is running.
    
    That happens during resume from suspend-to-idle when pci_restore_state()
    invoked by pci_pm_default_resume_early() clears PME Enable before the
    wakeup events are processed by AML, effectively causing those wakeup
    events to be ignored.
    
    Fix this issue by restoring the PME Enable configuration right after
    pci_restore_state() has been called instead of doing that in
    pci_enable_wake().
    
    Fixes: dc15e71eefc7 (PCI / PM: Restore PME Enable if skipping wakeup setup)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index ffe7d54d9328..1a93b48b0dd9 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -506,6 +506,7 @@ static int pci_restore_standard_config(struct pci_dev *pci_dev)
 	}
 
 	pci_restore_state(pci_dev);
+	pci_pme_restore(pci_dev);
 	return 0;
 }
 
@@ -517,6 +518,7 @@ static void pci_pm_default_resume_early(struct pci_dev *pci_dev)
 {
 	pci_power_up(pci_dev);
 	pci_restore_state(pci_dev);
+	pci_pme_restore(pci_dev);
 	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 }
 

commit f263fbb8d60824993c1b64385056a3cfdbb21d45
Merge: 026d15f6b987 6aed468480e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 8 15:51:57 2017 -0700

    Merge tag 'pci-v4.13-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
      - add sysfs max_link_speed/width, current_link_speed/width (Wong Vee
        Khee)
    
      - make host bridge IRQ mapping much more generic (Matthew Minter,
        Lorenzo Pieralisi)
    
      - convert most drivers to pci_scan_root_bus_bridge() (Lorenzo
        Pieralisi)
    
      - mutex sriov_configure() (Jakub Kicinski)
    
      - mutex pci_error_handlers callbacks (Christoph Hellwig)
    
      - split ->reset_notify() into ->reset_prepare()/reset_done()
        (Christoph Hellwig)
    
      - support multiple PCIe portdrv interrupts for MSI as well as MSI-X
        (Gabriele Paoloni)
    
      - allocate MSI/MSI-X vector for Downstream Port Containment (Gabriele
        Paoloni)
    
      - fix MSI IRQ affinity pre/post/min_vecs issue (Michael Hernandez)
    
      - test INTx masking during enumeration, not at run-time (Piotr Gregor)
    
      - avoid using device_may_wakeup() for runtime PM (Rafael J. Wysocki)
    
      - restore the status of PCI devices across hibernation (Chen Yu)
    
      - keep parent resources that start at 0x0 (Ard Biesheuvel)
    
      - enable ECRC only if device supports it (Bjorn Helgaas)
    
      - restore PRI and PASID state after Function-Level Reset (CQ Tang)
    
      - skip DPC event if device is not present (Keith Busch)
    
      - check domain when matching SMBIOS info (Sujith Pandel)
    
      - mark Intel XXV710 NIC INTx masking as broken (Alex Williamson)
    
      - avoid AMD SB7xx EHCI USB wakeup defect (Kai-Heng Feng)
    
      - work around long-standing Macbook Pro poweroff issue (Bjorn Helgaas)
    
      - add Switchtec "running" status flag (Logan Gunthorpe)
    
      - fix dra7xx incorrect RW1C IRQ register usage (Arvind Yadav)
    
      - modify xilinx-nwl IRQ chip for legacy interrupts (Bharat Kumar
        Gogada)
    
      - move VMD SRCU cleanup after bus, child device removal (Jon Derrick)
    
      - add Faraday clock handling (Linus Walleij)
    
      - configure Rockchip MPS and reorganize (Shawn Lin)
    
      - limit Qualcomm TLP size to 2K (hardware issue) (Srinivas Kandagatla)
    
      - support Tegra MSI 64-bit addressing (Thierry Reding)
    
      - use Rockchip normal (not privileged) register bank (Shawn Lin)
    
      - add HiSilicon Kirin SoC PCIe controller driver (Xiaowei Song)
    
      - add Sigma Designs Tango SMP8759 PCIe controller driver (Marc
        Gonzalez)
    
      - add MediaTek PCIe host controller support (Ryder Lee)
    
      - add Qualcomm IPQ4019 support (John Crispin)
    
      - add HyperV vPCI protocol v1.2 support (Jork Loeser)
    
      - add i.MX6 regulator support (Quentin Schulz)
    
    * tag 'pci-v4.13-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (113 commits)
      PCI: tango: Add Sigma Designs Tango SMP8759 PCIe host bridge support
      PCI: Add DT binding for Sigma Designs Tango PCIe controller
      PCI: rockchip: Use normal register bank for config accessors
      dt-bindings: PCI: Add documentation for MediaTek PCIe
      PCI: Remove __pci_dev_reset() and pci_dev_reset()
      PCI: Split ->reset_notify() method into ->reset_prepare() and ->reset_done()
      PCI: xilinx: Make of_device_ids const
      PCI: xilinx-nwl: Modify IRQ chip for legacy interrupts
      PCI: vmd: Move SRCU cleanup after bus, child device removal
      PCI: vmd: Correct comment: VMD domains start at 0x10000, not 0x1000
      PCI: versatile: Add local struct device pointers
      PCI: tegra: Do not allocate MSI target memory
      PCI: tegra: Support MSI 64-bit addressing
      PCI: rockchip: Use local struct device pointer consistently
      PCI: rockchip: Check for clk_prepare_enable() errors during resume
      MAINTAINERS: Remove Wenrui Li as Rockchip PCIe driver maintainer
      PCI: rockchip: Configure RC's MPS setting
      PCI: rockchip: Reconfigure configuration space header type
      PCI: rockchip: Split out rockchip_pcie_cfg_configuration_accesses()
      PCI: rockchip: Move configuration accesses into rockchip_pcie_cfg_atu()
      ...

commit 408c9861c6979db974455b9e7a9bcadd60e0934c
Merge: b39de277b02f 8f8e5c3e2796
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 4 13:39:41 2017 -0700

    Merge tag 'pm-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael Wysocki:
     "The big ticket items here are the rework of suspend-to-idle in order
      to add proper support for power button wakeup from it on recent Dell
      laptops and the rework of interfaces exporting the current CPU
      frequency on x86.
    
      In addition to that, support for a few new pieces of hardware is
      added, the PCI/ACPI device wakeup infrastructure is simplified
      significantly and the wakeup IRQ framework is fixed to unbreak the IRQ
      bus locking infrastructure.
    
      Also, there are some functional improvements for intel_pstate, tools
      updates and small fixes and cleanups all over.
    
      Specifics:
    
       - Rework suspend-to-idle to allow it to take wakeup events signaled
         by the EC into account on ACPI-based platforms in order to properly
         support power button wakeup from suspend-to-idle on recent Dell
         laptops (Rafael Wysocki).
    
         That includes the core suspend-to-idle code rework, support for the
         Low Power S0 _DSM interface, and support for the ACPI INT0002
         Virtual GPIO device from Hans de Goede (required for USB keyboard
         wakeup from suspend-to-idle to work on some machines).
    
       - Stop trying to export the current CPU frequency via /proc/cpuinfo
         on x86 as that is inaccurate and confusing (Len Brown).
    
       - Rework the way in which the current CPU frequency is exported by
         the kernel (over the cpufreq sysfs interface) on x86 systems with
         the APERF and MPERF registers by always using values read from
         these registers, when available, to compute the current frequency
         regardless of which cpufreq driver is in use (Len Brown).
    
       - Rework the PCI/ACPI device wakeup infrastructure to remove the
         questionable and artificial distinction between "devices that can
         wake up the system from sleep states" and "devices that can
         generate wakeup signals in the working state" from it, which allows
         the code to be simplified quite a bit (Rafael Wysocki).
    
       - Fix the wakeup IRQ framework by making it use SRCU instead of RCU
         which doesn't allow sleeping in the read-side critical sections,
         but which in turn is expected to be allowed by the IRQ bus locking
         infrastructure (Thomas Gleixner).
    
       - Modify some computations in the intel_pstate driver to avoid
         rounding errors resulting from them (Srinivas Pandruvada).
    
       - Reduce the overhead of the intel_pstate driver in the HWP
         (hardware-managed P-states) mode and when the "performance" P-state
         selection algorithm is in use by making it avoid registering
         scheduler callbacks in those cases (Len Brown).
    
       - Rework the energy_performance_preference sysfs knob in intel_pstate
         by changing the values that correspond to different symbolic hint
         names used by it (Len Brown).
    
       - Make it possible to use more than one cpuidle driver at the same
         time on ARM (Daniel Lezcano).
    
       - Make it possible to prevent the cpuidle menu governor from using
         the 0 state by disabling it via sysfs (Nicholas Piggin).
    
       - Add support for FFH (Fixed Functional Hardware) MWAIT in ACPI C1 on
         AMD systems (Yazen Ghannam).
    
       - Make the CPPC cpufreq driver take the lowest nonlinear performance
         information into account (Prashanth Prakash).
    
       - Add support for hi3660 to the cpufreq-dt driver, fix the imx6q
         driver and clean up the sfi, exynos5440 and intel_pstate drivers
         (Colin Ian King, Krzysztof Kozlowski, Octavian Purdila, Rafael
         Wysocki, Tao Wang).
    
       - Fix a few minor issues in the generic power domains (genpd)
         framework and clean it up somewhat (Krzysztof Kozlowski, Mikko
         Perttunen, Viresh Kumar).
    
       - Fix a couple of minor issues in the operating performance points
         (OPP) framework and clean it up somewhat (Viresh Kumar).
    
       - Fix a CONFIG dependency in the hibernation core and clean it up
         slightly (Balbir Singh, Arvind Yadav, BaoJun Luo).
    
       - Add rk3228 support to the rockchip-io adaptive voltage scaling
         (AVS) driver (David Wu).
    
       - Fix an incorrect bit shift operation in the RAPL power capping
         driver (Adam Lessnau).
    
       - Add support for the EPP field in the HWP (hardware managed
         P-states) control register, HWP.EPP, to the x86_energy_perf_policy
         tool and update msr-index.h with HWP.EPP values (Len Brown).
    
       - Fix some minor issues in the turbostat tool (Len Brown).
    
       - Add support for AMD family 0x17 CPUs to the cpupower tool and fix a
         minor issue in it (Sherry Hurwitz).
    
       - Assorted cleanups, mostly related to the constification of some
         data structures (Arvind Yadav, Joe Perches, Kees Cook, Krzysztof
         Kozlowski)"
    
    * tag 'pm-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (69 commits)
      cpufreq: Update scaling_cur_freq documentation
      cpufreq: intel_pstate: Clean up after performance governor changes
      PM: hibernate: constify attribute_group structures.
      cpuidle: menu: allow state 0 to be disabled
      intel_idle: Use more common logging style
      PM / Domains: Fix missing default_power_down_ok comment
      PM / Domains: Fix unsafe iteration over modified list of domains
      PM / Domains: Fix unsafe iteration over modified list of domain providers
      PM / Domains: Fix unsafe iteration over modified list of device links
      PM / Domains: Handle safely genpd_syscore_switch() call on non-genpd device
      PM / Domains: Call driver's noirq callbacks
      PM / core: Drop run_wake flag from struct dev_pm_info
      PCI / PM: Simplify device wakeup settings code
      PCI / PM: Drop pme_interrupt flag from struct pci_dev
      ACPI / PM: Consolidate device wakeup settings code
      ACPI / PM: Drop run_wake from struct acpi_device_wakeup_flags
      PM / QoS: constify *_attribute_group.
      PM / AVS: rockchip-io: add io selectors and supplies for rk3228
      powercap/RAPL: prevent overridding bits outside of the mask
      PM / sysfs: Constify attribute groups
      ...

commit 974668417b74ec5f68df2411f53b3d3812565059
Merge: 9a715cd54347 d565ed38d045
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 3 20:27:48 2017 -0700

    Merge tag 'driver-core-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the big driver core update for 4.13-rc1.
    
      The large majority of this is a lot of cleanup of old fields in the
      driver core structures and their remaining usages in random drivers.
      All of those fixes have been reviewed by the various subsystem
      maintainers. There's also some small firmware updates in here, a new
      kobject uevent api interface that makes userspace interaction easier,
      and a few other minor things.
    
      All of these have been in linux-next for a long while with no reported
      issues"
    
    * tag 'driver-core-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (56 commits)
      arm: mach-rpc: ecard: fix build error
      zram: convert remaining CLASS_ATTR() to CLASS_ATTR_RO()
      driver-core: remove struct bus_type.dev_attrs
      powerpc: vio_cmo: use dev_groups and not dev_attrs for bus_type
      powerpc: vio: use dev_groups and not dev_attrs for bus_type
      USB: usbip: convert to use DRIVER_ATTR_RW
      s390: drivers: convert to use DRIVER_ATTR_RO/WO
      platform: thinkpad_acpi: convert to use DRIVER_ATTR_RO/RW
      pcmcia: ds: convert to use DRIVER_ATTR_RO
      wireless: ipw2x00: convert to use DRIVER_ATTR_RW
      net: ehea: convert to use DRIVER_ATTR_RO
      net: caif: convert to use DRIVER_ATTR_RO
      TTY: hvc: convert to use DRIVER_ATTR_RW
      PCI: pci-driver: convert to use DRIVER_ATTR_WO
      IB: nes: convert to use DRIVER_ATTR_RW
      HID: hid-core: convert to use DRIVER_ATTR_RO and drv_groups
      arm: ecard: fix dev_groups patch typo
      tty: serdev: use dev_groups and not dev_attrs for bus_type
      sparc: vio: use dev_groups and not dev_attrs for bus_type
      hid: intel-ish-hid: use dev_groups and not dev_attrs for bus_type
      ...

commit 44d745fb5d06cce62501a39e9dd47a47b111777b
Merge: bb02ce95a59e 769b461fc0c0
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jul 3 08:00:29 2017 -0500

    Merge branch 'pci/irq-fixups' into next
    
    * pci/irq-fixups:
      arm64: PCI: Drop DT IRQ allocation from pcibios_alloc_irq()
      PCI: xilinx-nwl: Move to struct pci_host_bridge IRQ mapping functions
      PCI: rockchip: Move to struct pci_host_bridge IRQ mapping functions
      PCI: xgene: Move to struct pci_host_bridge IRQ mapping functions
      PCI: altera: Drop pci_fixup_irqs()
      PCI: versatile: Drop pci_fixup_irqs()
      PCI: generic: Drop pci_fixup_irqs()
      PCI: faraday: Drop pci_fixup_irqs()
      PCI: designware: Drop pci_fixup_irqs()
      PCI: iproc: Drop pci_fixup_irqs()
      PCI: rcar: Drop pci_fixup_irqs()
      PCI: xilinx: Drop pci_fixup_irqs()
      PCI: tegra: Drop pci_fixup_irqs()
      ARM/PCI: Remove pci_fixup_irqs() call for bios32 host controllers
      PCI: Add a call to pci_assign_irq() in pci_device_probe()
      OF/PCI: Update of_irq_parse_and_map_pci() comment
      PCI: Add pci_assign_irq() function and have pci_fixup_irqs() use it
      PCI: Add IRQ mapping function pointers to pci_host_bridge struct
      PCI: Build setup-irq.o on all arches
      PCI: Remove pci_scan_root_bus_msi()
      PCI: xilinx-nwl: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: rockchip: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: generic: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: xgene: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: xilinx: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: altera: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: versatile: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: iproc: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: rcar: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: aardvark: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: designware: Convert PCI scan API to pci_scan_root_bus_bridge()
      ARM/PCI: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: Make pci_register_host_bridge() PCI core internal
      PCI: Add pci_scan_root_bus_bridge() interface
      PCI: tegra: Fix host bridge memory leakage
      PCI: faraday: Fix host bridge memory leakage
      PCI: Add devm_pci_alloc_host_bridge() interface
      PCI: Add pci_free_host_bridge() interface
      PCI: Initialize bridge release function at bridge allocation
      PCI: faraday: Convert IRQ masking to raw PCI config accessors
      PCI: iproc: Convert link check to raw PCI config accessors
      PCI: xilinx-nwl: Remove nwl_pcie_enable_msi() unused bus parameter

commit 30fdfb929e82450bbf3d0e0aba56efbc29b52b52
Author: Matthew Minter <matt@masarand.com>
Date:   Wed Jun 28 15:14:04 2017 -0500

    PCI: Add a call to pci_assign_irq() in pci_device_probe()
    
    The pci_assign_irq() function allows assignment of an IRQ to devices during
    device enable time rather than only at boot.  Therefore call it in the
    pci_device_probe() function during the enable device code path so this
    assignment can be performed.
    
    This patch will do nothing on arches which do not set the IRQ mapping
    function pointers and is therefore currently a nop, however as support for
    these function pointers is added to arch-specific code this will cause IRQ
    assignment to migrate to device enable time allowing the new code paths to
    be used.
    
    Signed-off-by: Matthew Minter <matt@masarand.com>
    [lorenzo.pieralisi@arm.com: moved pci_assign_irq() call site]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 192e7b681b96..11167c65ca37 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -412,6 +412,8 @@ static int pci_device_probe(struct device *dev)
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct pci_driver *drv = to_pci_driver(dev->driver);
 
+	pci_assign_irq(pci_dev);
+
 	error = pcibios_alloc_irq(pci_dev);
 	if (error < 0)
 		return error;

commit e60514bd4485c0c7c5a7cf779b200ce0b95c70d6
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Thu May 25 16:49:07 2017 +0800

    PCI/PM: Restore the status of PCI devices across hibernation
    
    Currently we saw a lot of "No irq handler" errors during hibernation, which
    caused the system hang finally:
    
      ata4.00: qc timeout (cmd 0xec)
      ata4.00: failed to IDENTIFY (I/O error, err_mask=0x4)
      ata4.00: revalidation failed (errno=-5)
      ata4: SATA link up 6.0 Gbps (SStatus 133 SControl 300)
      do_IRQ: 31.151 No irq handler for vector
    
    According to above logs, there is an interrupt triggered and it is
    dispatched to CPU31 with a vector number 151, but there is no handler for
    it, thus this IRQ will not get acked and will cause an IRQ flood which
    kills the system.  To be more specific, the 31.151 is an interrupt from the
    AHCI host controller.
    
    After some investigation, the reason why this issue is triggered is because
    the thaw_noirq() function does not restore the MSI/MSI-X settings across
    hibernation.
    
    The scenario is illustrated below:
    
      1. Before hibernation, IRQ 34 is the handler for the AHCI device, which
         is bound to CPU31.
    
      2. Hibernation starts, the AHCI device is put into low power state.
    
      3. All the nonboot CPUs are put offline, so IRQ 34 has to be migrated to
         the last alive one - CPU0.
    
      4. After the snapshot has been created, all the nonboot CPUs are brought
         up again; IRQ 34 remains bound to CPU0.
    
      5. AHCI devices are put into D0.
    
      6. The snapshot is written to the disk.
    
    The issue is triggered in step 6.  The AHCI interrupt should be delivered
    to CPU0, however it is delivered to the original CPU31 instead, which
    causes the "No irq handler" issue.
    
    Ying Huang has provided a clue that, in step 3 it is possible that writing
    to the register might not take effect as the PCI devices have been
    suspended.
    
    In step 3, the IRQ 34 affinity should be modified from CPU31 to CPU0, but
    in fact it is not.  In __pci_write_msi_msg(), if the device is already in
    low power state, the low level MSI message entry will not be updated but
    cached.  During the device restore process after a normal suspend/resume,
    pci_restore_msi_state() writes the cached MSI back to the hardware.
    
    But this is not the case for hibernation.  pci_restore_msi_state() is not
    currently called in pci_pm_thaw_noirq(), although pci_save_state() has
    saved the necessary PCI cached information in pci_pm_freeze_noirq().
    
    Restore the PCI status for the device during hibernation.  Otherwise the
    status might be lost across hibernation (for example, settings for MSI,
    MSI-X, ATS, ACS, IOV, etc.), which might cause problems during hibernation.
    
    Suggested-by: Ying Huang <ying.huang@intel.com>
    Suggested-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    [bhelgaas: changelog]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: stable@vger.kernel.org
    Cc: Len Brown <len.brown@intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: Ying Huang <ying.huang@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 192e7b681b96..b399fa31e0a2 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -964,6 +964,7 @@ static int pci_pm_thaw_noirq(struct device *dev)
 		return pci_legacy_resume_early(dev);
 
 	pci_update_current_state(pci_dev, PCI_D0);
+	pci_restore_state(pci_dev);
 
 	if (drv && drv->pm && drv->pm->thaw_noirq)
 		error = drv->pm->thaw_noirq(dev);

commit 0847684cfc5f0e9f009919bfdcb041d60e19b856
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 24 01:57:35 2017 +0200

    PCI / PM: Simplify device wakeup settings code
    
    After previous changes it is not necessary to distinguish between
    device wakeup for run time and device wakeup from system sleep states
    any more, so rework the PCI device wakeup settings code accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 192e7b681b96..ffe7d54d9328 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1216,7 +1216,7 @@ static int pci_pm_runtime_resume(struct device *dev)
 
 	pci_restore_standard_config(pci_dev);
 	pci_fixup_device(pci_fixup_resume_early, pci_dev);
-	__pci_enable_wake(pci_dev, PCI_D0, true, false);
+	pci_enable_wake(pci_dev, PCI_D0, false);
 	pci_fixup_device(pci_fixup_resume, pci_dev);
 
 	rc = pm->runtime_resume(dev);

commit a942774128deb4a909e85742e20da6e249a92bfe
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jun 9 11:03:06 2017 +0200

    PCI: pci-driver: convert to use DRIVER_ATTR_WO
    
    We are trying to get rid of DRIVER_ATTR(), and all of the pci-driver
    core driver attributes can be trivially changed to use DRIVER_ATTR_WO().
    
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: <linux-pci@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 192e7b681b96..934a78a2fbef 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -96,7 +96,7 @@ static void pci_free_dynids(struct pci_driver *drv)
  *
  * Allow PCI IDs to be added to an existing driver via sysfs.
  */
-static ssize_t store_new_id(struct device_driver *driver, const char *buf,
+static ssize_t new_id_store(struct device_driver *driver, const char *buf,
 			    size_t count)
 {
 	struct pci_driver *pdrv = to_pci_driver(driver);
@@ -154,7 +154,7 @@ static ssize_t store_new_id(struct device_driver *driver, const char *buf,
 		return retval;
 	return count;
 }
-static DRIVER_ATTR(new_id, S_IWUSR, NULL, store_new_id);
+static DRIVER_ATTR_WO(new_id);
 
 /**
  * store_remove_id - remove a PCI device ID from this driver
@@ -164,7 +164,7 @@ static DRIVER_ATTR(new_id, S_IWUSR, NULL, store_new_id);
  *
  * Removes a dynamic pci device ID to this driver.
  */
-static ssize_t store_remove_id(struct device_driver *driver, const char *buf,
+static ssize_t remove_id_store(struct device_driver *driver, const char *buf,
 			       size_t count)
 {
 	struct pci_dynid *dynid, *n;
@@ -198,7 +198,7 @@ static ssize_t store_remove_id(struct device_driver *driver, const char *buf,
 
 	return retval;
 }
-static DRIVER_ATTR(remove_id, S_IWUSR, NULL, store_remove_id);
+static DRIVER_ATTR_WO(remove_id);
 
 static struct attribute *pci_drv_attrs[] = {
 	&driver_attr_new_id.attr,

commit 0b2c2a71e6f07fb67e6f72817d39910f64d2e258
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 24 10:15:32 2017 +0200

    PCI: Replace the racy recursion prevention
    
    pci_call_probe() can called recursively when a physcial function is probed
    and the probing creates virtual functions, which are populated via
    pci_bus_add_device() which in turn can end up calling pci_call_probe()
    again.
    
    The code has an interesting way to prevent recursing into the workqueue
    code.  That's accomplished by a check whether the current task runs already
    on the numa node which is associated with the device.
    
    While that works to prevent the recursion into the workqueue code, it's
    racy versus normal execution as there is no guarantee that the node does
    not vanish after the check.
    
    There is another issue with this code. It dereferences cpumask_of_node()
    unconditionally without checking whether the node is available.
    
    Make the detection reliable by:
    
     - Mark a probed device as 'is_probed' in pci_call_probe()
    
     - Check in pci_call_probe for a virtual function. If it's a virtual
       function and the associated physical function device is marked
       'is_probed' then this is a recursive call, so the call can be invoked in
       the calling context.
    
     - Add a check whether the node is online before dereferencing it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: linux-pci@vger.kernel.org
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/20170524081548.771457199@linutronix.de

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 5bf92fd983e5..fe6be6382505 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -320,10 +320,19 @@ static long local_pci_probe(void *_ddi)
 	return 0;
 }
 
+static bool pci_physfn_is_probed(struct pci_dev *dev)
+{
+#ifdef CONFIG_PCI_IOV
+	return dev->is_virtfn && dev->physfn->is_probed;
+#else
+	return false;
+#endif
+}
+
 static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
 			  const struct pci_device_id *id)
 {
-	int error, node;
+	int error, node, cpu;
 	struct drv_dev_and_id ddi = { drv, dev, id };
 
 	/*
@@ -332,33 +341,27 @@ static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
 	 * on the right node.
 	 */
 	node = dev_to_node(&dev->dev);
+	dev->is_probed = 1;
+
+	cpu_hotplug_disable();
 
 	/*
-	 * On NUMA systems, we are likely to call a PF probe function using
-	 * work_on_cpu().  If that probe calls pci_enable_sriov() (which
-	 * adds the VF devices via pci_bus_add_device()), we may re-enter
-	 * this function to call the VF probe function.  Calling
-	 * work_on_cpu() again will cause a lockdep warning.  Since VFs are
-	 * always on the same node as the PF, we can work around this by
-	 * avoiding work_on_cpu() when we're already on the correct node.
-	 *
-	 * Preemption is enabled, so it's theoretically unsafe to use
-	 * numa_node_id(), but even if we run the probe function on the
-	 * wrong node, it should be functionally correct.
+	 * Prevent nesting work_on_cpu() for the case where a Virtual Function
+	 * device is probed from work_on_cpu() of the Physical device.
 	 */
-	if (node >= 0 && node != numa_node_id()) {
-		int cpu;
-
-		cpu_hotplug_disable();
+	if (node < 0 || node >= MAX_NUMNODES || !node_online(node) ||
+	    pci_physfn_is_probed(dev))
+		cpu = nr_cpu_ids;
+	else
 		cpu = cpumask_any_and(cpumask_of_node(node), cpu_online_mask);
-		if (cpu < nr_cpu_ids)
-			error = work_on_cpu(cpu, local_pci_probe, &ddi);
-		else
-			error = local_pci_probe(&ddi);
-		cpu_hotplug_enable();
-	} else
+
+	if (cpu < nr_cpu_ids)
+		error = work_on_cpu(cpu, local_pci_probe, &ddi);
+	else
 		error = local_pci_probe(&ddi);
 
+	dev->is_probed = 0;
+	cpu_hotplug_enable();
 	return error;
 }
 

commit 1ddd45f8d76f0c15ec4e44073eeaaee6a806ee81
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 24 10:15:31 2017 +0200

    PCI: Use cpu_hotplug_disable() instead of get_online_cpus()
    
    Converting the hotplug locking, i.e. get_online_cpus(), to a percpu rwsem
    unearthed a circular lock dependency which was hidden from lockdep due to
    the lockdep annotation of get_online_cpus() which prevents lockdep from
    creating full dependency chains. There are several variants of this. And
    example is:
    
    Chain exists of:
    
    cpu_hotplug_lock.rw_sem --> drm_global_mutex --> &item->mutex
    
    CPU0                    CPU1
    ----                    ----
    lock(&item->mutex);
                            lock(drm_global_mutex);
                            lock(&item->mutex);
    lock(cpu_hotplug_lock.rw_sem);
    
    because there are dependencies through workqueues. The call chain is:
    
            get_online_cpus
            apply_workqueue_attrs
            __alloc_workqueue_key
            ttm_mem_global_init
            ast_ttm_mem_global_init
            drm_global_item_ref
            ast_mm_init
            ast_driver_load
            drm_dev_register
            drm_get_pci_dev
            ast_pci_probe
            local_pci_probe
            work_for_cpu_fn
            process_one_work
            worker_thread
    
    This is not a problem of get_online_cpus() recursion, it's a possible
    deadlock undetected by lockdep so far.
    
    The cure is to use cpu_hotplug_disable() instead of get_online_cpus() to
    protect the PCI probing.
    
    There is a side effect to this: cpu_hotplug_disable() makes a concurrent
    cpu hotplug attempt via the sysfs interfaces fail with -EBUSY, but PCI
    probing usually happens during the boot process where no interaction is
    possible. Any later invocations are infrequent enough and concurrent
    hotplug attempts are so unlikely that the danger of user space visible
    regressions is very close to zero. Anyway, thats preferrable over a real
    deadlock.
    
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: linux-pci@vger.kernel.org
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/20170524081548.691198590@linutronix.de

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 192e7b681b96..5bf92fd983e5 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -349,13 +349,13 @@ static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
 	if (node >= 0 && node != numa_node_id()) {
 		int cpu;
 
-		get_online_cpus();
+		cpu_hotplug_disable();
 		cpu = cpumask_any_and(cpumask_of_node(node), cpu_online_mask);
 		if (cpu < nr_cpu_ids)
 			error = work_on_cpu(cpu, local_pci_probe, &ddi);
 		else
 			error = local_pci_probe(&ddi);
-		put_online_cpus();
+		cpu_hotplug_enable();
 	} else
 		error = local_pci_probe(&ddi);
 

commit ef1b5dad5a386885998d11eb45ca7fd183079965
Merge: 889e4dd916a1 63af8f7a8293
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 28 10:36:12 2017 -0500

    Merge branch 'pci/virtualization' into next
    
    * pci/virtualization:
      ixgbe: Use pcie_flr() instead of duplicating it
      IB/hfi1: Use pcie_flr() instead of duplicating it
      PCI: Call pcie_flr() from reset_chelsio_generic_dev()
      PCI: Call pcie_flr() from reset_intel_82599_sfp_virtfn()
      PCI: Export pcie_flr()
      PCI: Add sysfs sriov_drivers_autoprobe to control VF driver binding
      PCI: Avoid FLR for Intel 82579 NICs
    
    Conflicts:
            include/linux/pci.h

commit 0e7df22401a3dfd403b26dea62dd00e0598b538b
Author: Bodong Wang <bodong@mellanox.com>
Date:   Thu Apr 13 01:51:40 2017 +0300

    PCI: Add sysfs sriov_drivers_autoprobe to control VF driver binding
    
    Sometimes it is not desirable to bind SR-IOV VFs to drivers.  This can save
    host side resource usage by VF instances that will be assigned to VMs.
    
    Add a new PCI sysfs interface "sriov_drivers_autoprobe" to control that
    from the PF.  To modify it, echo 0/n/N (disable probe) or 1/y/Y (enable
    probe) to:
    
      /sys/bus/pci/devices/<DOMAIN:BUS:DEVICE.FUNCTION>/sriov_drivers_autoprobe
    
    Note that this must be done before enabling VFs.  The change will not take
    effect if VFs are already enabled.  Simply, one can disable VFs by setting
    sriov_numvfs to 0, choose whether to probe or not, and then re-enable the
    VFs by restoring sriov_numvfs.
    
    [bhelgaas: changelog, ABI doc]
    Signed-off-by: Bodong Wang <bodong@mellanox.com>
    Signed-off-by: Eli Cohen <eli@mellanox.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index afa72717a979..f99f7fe749b8 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -394,6 +394,18 @@ void __weak pcibios_free_irq(struct pci_dev *dev)
 {
 }
 
+#ifdef CONFIG_PCI_IOV
+static inline bool pci_device_can_probe(struct pci_dev *pdev)
+{
+	return (!pdev->is_virtfn || pdev->physfn->sriov->drivers_autoprobe);
+}
+#else
+static inline bool pci_device_can_probe(struct pci_dev *pdev)
+{
+	return true;
+}
+#endif
+
 static int pci_device_probe(struct device *dev)
 {
 	int error;
@@ -405,10 +417,12 @@ static int pci_device_probe(struct device *dev)
 		return error;
 
 	pci_dev_get(pci_dev);
-	error = __pci_device_probe(drv, pci_dev);
-	if (error) {
-		pcibios_free_irq(pci_dev);
-		pci_dev_put(pci_dev);
+	if (pci_device_can_probe(pci_dev)) {
+		error = __pci_device_probe(drv, pci_dev);
+		if (error) {
+			pcibios_free_irq(pci_dev);
+			pci_dev_put(pci_dev);
+		}
 	}
 
 	return error;

commit fda78d7a0ead144f4b2cdb582dcba47911f4952c
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Jan 26 14:07:47 2017 -0500

    PCI/MSI: Stop disabling MSI/MSI-X in pci_device_shutdown()
    
    The pci_bus_type .shutdown method, pci_device_shutdown(), is called from
    device_shutdown() in the kernel restart and shutdown paths.
    
    Previously, pci_device_shutdown() called pci_msi_shutdown() and
    pci_msix_shutdown().  This disables MSI and MSI-X, which causes the device
    to fall back to raising interrupts via INTx.  But the driver is still bound
    to the device, it doesn't know about this change, and it likely doesn't
    have an INTx handler, so these INTx interrupts cause "nobody cared"
    warnings like this:
    
      irq 16: nobody cared (try booting with the "irqpoll" option)
      CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.8.2-1.el7_UNSUPPORTED.x86_64 #1
      Hardware name: Hewlett-Packard HP Z820 Workstation/158B, BIOS J63 v03.90 06/
      ...
    
    The MSI disabling code was added by d52877c7b1af ("pci/irq: let
    pci_device_shutdown to call pci_msi_shutdown v2") because a driver left MSI
    enabled and kdump failed because the kexeced kernel wasn't prepared to
    receive the MSI interrupts.
    
    Subsequent commits 1851617cd2da ("PCI/MSI: Disable MSI at enumeration even
    if kernel doesn't support MSI") and  e80e7edc55ba ("PCI/MSI: Initialize MSI
    capability for all architectures") changed the kexeced kernel to disable
    all MSIs itself so it no longer depends on the crashed kernel to clean up
    after itself.
    
    Stop disabling MSI/MSI-X in pci_device_shutdown().  This resolves the
    "nobody cared" unhandled IRQ issue above.  It also allows PCI serial
    devices, which may rely on the MSI interrupts, to continue outputting
    messages during reboot/shutdown.
    
    [bhelgaas: changelog, drop pci_msi_shutdown() and pci_msix_shutdown() calls
    altogether]
    Fixes: https://bugzilla.kernel.org/show_bug.cgi?id=187351
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Alex Williamson <alex.williamson@redhat.com>
    CC: David Arcari <darcari@redhat.com>
    CC: Myron Stowe <mstowe@redhat.com>
    CC: Lukas Wunner <lukas@wunner.de>
    CC: Keith Busch <keith.busch@intel.com>
    CC: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index afa72717a979..8ec136164e93 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -461,8 +461,6 @@ static void pci_device_shutdown(struct device *dev)
 
 	if (drv && drv->shutdown)
 		drv->shutdown(pci_dev);
-	pci_msi_shutdown(pci_dev);
-	pci_msix_shutdown(pci_dev);
 
 	/*
 	 * If this is a kexec reboot, turn off Bus Master bit on the

commit 60e8d3e11645a1b9c4197d9786df3894332c1685
Merge: 190c3ee06a0f c4d052ce970e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 23 11:53:22 2017 -0800

    Merge tag 'pci-v4.11-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - add ASPM L1 substate support
    
     - enable PCIe Extended Tags when supported
    
     - configure PCIe MPS settings on iProc, Versatile, X-Gene, and Xilinx
    
     - increase VPD access timeout
    
     - add ACS quirks for Intel Union Point, Qualcomm QDF2400 and QDF2432
    
     - use new pci_irq_alloc_vectors() in more drivers
    
     - fix MSI affinity memory leak
    
     - remove unused MSI interfaces and update documentation
    
     - remove unused AER .link_reset() callback
    
     - avoid pci_lock / p->pi_lock deadlock seen with perf
    
     - serialize sysfs enable/disable num_vfs operations
    
     - move DesignWare IP from drivers/pci/host/ to drivers/pci/dwc/ and
       refactor so we can support both hosts and endpoints
    
     - add DT ECAM-like support for HiSilicon Hip06/Hip07 controllers
    
     - add Rockchip system power management support
    
     - add Thunder-X cn81xx and cn83xx support
    
     - add Exynos 5440 PCIe PHY support
    
    * tag 'pci-v4.11-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (93 commits)
      PCI: dwc: Remove dependency of designware on CONFIG_PCI
      PCI: dwc: Add CONFIG_PCIE_DW_HOST to enable PCI dwc host
      PCI: dwc: Split pcie-designware.c into host and core files
      PCI: dwc: designware: Fix style errors in pcie-designware.c
      PCI: dwc: designware: Parse "num-lanes" property in dw_pcie_setup_rc()
      PCI: dwc: all: Split struct pcie_port into host-only and core structures
      PCI: dwc: designware: Get device pointer at the start of dw_pcie_host_init()
      PCI: dwc: all: Rename cfg_read/cfg_write to read/write
      PCI: dwc: all: Use platform_set_drvdata() to save private data
      PCI: dwc: designware: Move register defines to designware header file
      PCI: dwc: Use PTR_ERR_OR_ZERO to simplify code
      PCI: dra7xx: Group PHY API invocations
      PCI: dra7xx: Enable MSI and legacy interrupts simultaneously
      PCI: dra7xx: Add support to force RC to work in GEN1 mode
      PCI: dra7xx: Simplify probe code with devm_gpiod_get_optional()
      PCI: Move DesignWare IP support to new drivers/pci/dwc/ directory
      PCI: exynos: Support the PHY generic framework
      Documentation: binding: Modify the exynos5440 PCIe binding
      phy: phy-exynos-pcie: Add support for Exynos PCIe PHY
      Documentation: samsung-phy: Add exynos-pcie-phy binding
      ...

commit fed678145d02d08d75825d9f0854fad93cffd1a0
Author: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
Date:   Mon Feb 6 13:34:14 2017 -0200

    PCI: Remove duplicate check for positive return value from probe() functions
    
    Function __pci_device_probe() tries to be careful about a PCI driver
    probe() hook returning a positive value, but this is not really necessary,
    since the same fix up is already done in local_pci_probe() (preceded by a
    noisy warning), which renders this instance dead code.
    
    Signed-off-by: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 1ccce1cd6aca..3e0516ee9eab 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -381,8 +381,6 @@ static int __pci_device_probe(struct pci_driver *drv, struct pci_dev *pci_dev)
 		id = pci_match_device(drv, pci_dev);
 		if (id)
 			error = pci_call_probe(drv, pci_dev, id);
-		if (error >= 0)
-			error = 0;
 	}
 	return error;
 }

commit 02e0bea6c83c657617195135667e6a3f50d3bfb3
Author: Phil Sutter <phil@nwl.cc>
Date:   Wed Jan 18 14:04:38 2017 +0100

    PCI: implement num_vf bus type callback
    
    Signed-off-by: Phil Sutter <phil@nwl.cc>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 1ccce1cd6aca..63d8e18fb6b1 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1432,6 +1432,11 @@ static int pci_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return 0;
 }
 
+static int pci_bus_num_vf(struct device *dev)
+{
+	return pci_num_vf(to_pci_dev(dev));
+}
+
 struct bus_type pci_bus_type = {
 	.name		= "pci",
 	.match		= pci_bus_match,
@@ -1443,6 +1448,7 @@ struct bus_type pci_bus_type = {
 	.bus_groups	= pci_bus_groups,
 	.drv_groups	= pci_drv_groups,
 	.pm		= PCI_PM_OPS_PTR,
+	.num_vf		= pci_bus_num_vf,
 };
 EXPORT_SYMBOL(pci_bus_type);
 

commit 3f4f35678fb83da2f9ef17ddaa7507a45c2f7049
Merge: 6c6cba49495c a0d2a959d3da
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Oct 3 09:43:21 2016 -0500

    Merge branch 'pci/pm' into next
    
    * pci/pm:
      PCI: Avoid unnecessary resume after direct-complete
      PCI: Recognize D3cold in pci_update_current_state()
      PCI: Query platform firmware for device power state
      PCI: Afford direct-complete to devices with non-standard PM

commit a0d2a959d3da343554523d26902de1d40a9e5c28
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Sep 18 05:39:20 2016 +0200

    PCI: Avoid unnecessary resume after direct-complete
    
    Commit 58a1fbbb2ee8 ("PM / PCI / ACPI: Kick devices that might have been
    reset by firmware") added a runtime resume for devices that were runtime
    suspended when the system entered sleep.
    
    The motivation was that devices might be in a reset-power-on state after
    waking from system sleep, so their power state as perceived by Linux
    (stored in pci_dev->current_state) would no longer reflect reality.  By
    resuming such devices, we allow them to return to a low-power state via
    autosuspend and also bring their current_state in sync with reality.
    
    However for devices that are *not* in a reset-power-on state, doing an
    unconditional resume wastes energy.  A more refined approach is called for
    which issues a runtime resume only if the power state after direct-complete
    is shallower than it was before. To achieve this, update the device's
    current_state and compare it to its pre-sleep value.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index e39a67c8ef39..fd4b9c48fd2a 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -684,8 +684,19 @@ static int pci_pm_prepare(struct device *dev)
 
 static void pci_pm_complete(struct device *dev)
 {
-	pci_dev_complete_resume(to_pci_dev(dev));
-	pm_complete_with_resume_check(dev);
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+
+	pci_dev_complete_resume(pci_dev);
+	pm_generic_complete(dev);
+
+	/* Resume device if platform firmware has put it in reset-power-on */
+	if (dev->power.direct_complete && pm_resume_via_firmware()) {
+		pci_power_t pre_sleep_state = pci_dev->current_state;
+
+		pci_update_current_state(pci_dev, pci_dev->current_state);
+		if (pci_dev->current_state < pre_sleep_state)
+			pm_request_resume(dev);
+	}
 }
 
 #else /* !CONFIG_PM_SLEEP */

commit ad618c9983be3136e9e7209ffd7c4102720d0739
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Aug 9 11:53:11 2016 +0200

    PCI: Drop CONFIG_KEXEC_CORE ifdeffery
    
    Drop the CONFIG_KEXEC_CORE #ifdef around reference to "kexec_in_progress".
    
    Commit 2b94ed245861 ("kexec: define kexec_in_progress in !CONFIG_KEXEC
    case") has made this unnecessary.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index e39a67c8ef39..edd78e04b693 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -466,7 +466,6 @@ static void pci_device_shutdown(struct device *dev)
 	pci_msi_shutdown(pci_dev);
 	pci_msix_shutdown(pci_dev);
 
-#ifdef CONFIG_KEXEC_CORE
 	/*
 	 * If this is a kexec reboot, turn off Bus Master bit on the
 	 * device to tell it to not continue to do DMA. Don't touch
@@ -476,7 +475,6 @@ static void pci_device_shutdown(struct device *dev)
 	 */
 	if (kexec_in_progress && (pci_dev->current_state <= PCI_D3hot))
 		pci_clear_master(pci_dev);
-#endif
 }
 
 #ifdef CONFIG_PM

commit 9d26d3a8f1b0c442339a235f9508bdad8af91043
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Jun 2 11:17:12 2016 +0300

    PCI: Put PCIe ports into D3 during suspend
    
    Currently the Linux PCI core does not touch power state of PCI bridges and
    PCIe ports when system suspend is entered.  Leaving them in D0 consumes
    power unnecessarily and may prevent the CPU from entering deeper C-states.
    
    With recent PCIe hardware we can power down the ports to save power given
    that we take into account few restrictions:
    
      - The PCIe port hardware is recent enough, starting from 2015.
    
      - Devices connected to PCIe ports are effectively in D3cold once the port
        is transitioned to D3 (the config space is not accessible anymore and
        the link may be powered down).
    
      - Devices behind the PCIe port need to be allowed to transition to D3cold
        and back.  There is a way both drivers and userspace can forbid this.
    
      - If the device behind the PCIe port is capable of waking the system it
        needs to be able to do so from D3cold.
    
    This patch adds a new flag to struct pci_device called 'bridge_d3'.  This
    flag is set and cleared by the PCI core whenever there is a change in power
    management state of any of the devices behind the PCIe port.  When system
    later on is suspended we only need to check this flag and if it is true
    transition the port to D3 otherwise we leave it in D0.
    
    Also provide override mechanism via command line parameter
    "pcie_port_pm=[off|force]" that can be used to disable or enable the
    feature regardless of the BIOS manufacturing date.
    
    Tested-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index d7ffd66814bb..e39a67c8ef39 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -777,7 +777,7 @@ static int pci_pm_suspend_noirq(struct device *dev)
 
 	if (!pci_dev->state_saved) {
 		pci_save_state(pci_dev);
-		if (!pci_has_subordinate(pci_dev))
+		if (pci_power_manageable(pci_dev))
 			pci_prepare_to_sleep(pci_dev);
 	}
 
@@ -1144,7 +1144,6 @@ static int pci_pm_runtime_suspend(struct device *dev)
 		return -ENOSYS;
 
 	pci_dev->state_saved = false;
-	pci_dev->no_d3cold = false;
 	error = pm->runtime_suspend(dev);
 	if (error) {
 		/*
@@ -1161,8 +1160,6 @@ static int pci_pm_runtime_suspend(struct device *dev)
 
 		return error;
 	}
-	if (!pci_dev->d3cold_allowed)
-		pci_dev->no_d3cold = true;
 
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
 

commit 06bf403de344a8a0811ebd24992d2a08022c5225
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Nov 30 21:02:55 2015 +0200

    PCI / PM: Tune down retryable runtime suspend error messages
    
    The runtime PM core doesn't treat EBUSY and EAGAIN retvals from the driver
    suspend hooks as errors, but they still show up as errors in dmesg. Tune
    them down. See rpm_suspend() for details of handling these return values.
    
    Note that we use dev_dbg() for the retryable retvals, so after this
    change you'll need either CONFIG_DYNAMIC_DEBUG or CONFIG_PCI_DEBUG
    for them to show up in the log.
    
    One problem caused by this was noticed by Daniel: the i915 driver
    returns EAGAIN to signal a temporary failure to suspend and as a request
    towards the RPM core for scheduling a suspend again. This is a normal
    event, but the resulting error message flags a breakage during the
    driver's automated testing which parses dmesg and picks up the error.
    
    Reported-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://bugs.freedesktop.org/show_bug.cgi?id=92992
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 4446fcb5effd..d7ffd66814bb 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1146,9 +1146,21 @@ static int pci_pm_runtime_suspend(struct device *dev)
 	pci_dev->state_saved = false;
 	pci_dev->no_d3cold = false;
 	error = pm->runtime_suspend(dev);
-	suspend_report_result(pm->runtime_suspend, error);
-	if (error)
+	if (error) {
+		/*
+		 * -EBUSY and -EAGAIN is used to request the runtime PM core
+		 * to schedule a new suspend, so log the event only with debug
+		 * log level.
+		 */
+		if (error == -EBUSY || error == -EAGAIN)
+			dev_dbg(dev, "can't suspend now (%pf returned %d)\n",
+				pm->runtime_suspend, error);
+		else
+			dev_err(dev, "can't suspend (%pf returned %d)\n",
+				pm->runtime_suspend, error);
+
 		return error;
+	}
 	if (!pci_dev->d3cold_allowed)
 		pci_dev->no_d3cold = true;
 

commit 3c87b791880a2e0dad281c6494b94968d412bfa3
Merge: 0280d1a099da 7225107e1582
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 6 11:29:53 2015 -0800

    Merge tag 'pci-v4.4-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Resource management:
       - Add support for Enhanced Allocation devices (Sean O. Stalley)
       - Add Enhanced Allocation register entries (Sean O. Stalley)
       - Handle IORESOURCE_PCI_FIXED when sizing resources (David Daney)
       - Handle IORESOURCE_PCI_FIXED when assigning resources (David Daney)
       - Handle Enhanced Allocation capability for SR-IOV devices (David Daney)
       - Clear IORESOURCE_UNSET when reverting to firmware-assigned address (Bjorn Helgaas)
       - Make Enhanced Allocation bitmasks more obvious (Bjorn Helgaas)
       - Expand Enhanced Allocation BAR output (Bjorn Helgaas)
       - Add of_pci_check_probe_only to parse "linux,pci-probe-only" (Marc Zyngier)
       - Fix lookup of linux,pci-probe-only property (Marc Zyngier)
       - Add sparc mem64 resource parsing for root bus (Yinghai Lu)
    
      PCI device hotplug:
       - pciehp: Queue power work requests in dedicated function (Guenter Roeck)
    
      Driver binding:
       - Add builtin_pci_driver() to avoid registration boilerplate (Paul Gortmaker)
    
      Virtualization:
       - Set SR-IOV NumVFs to zero after enumeration (Alexander Duyck)
       - Remove redundant validation of SR-IOV offset/stride registers (Alexander Duyck)
       - Remove VFs in reverse order if virtfn_add() fails (Alexander Duyck)
       - Reorder pcibios_sriov_disable() (Alexander Duyck)
       - Wait 1 second between disabling VFs and clearing NumVFs (Alexander Duyck)
       - Fix sriov_enable() error path for pcibios_enable_sriov() failures (Alexander Duyck)
       - Enable SR-IOV ARI Capable Hierarchy before reading TotalVFs (Ben Shelton)
       - Don't try to restore VF BARs (Wei Yang)
    
      MSI:
       - Don't alloc pcibios-irq when MSI is enabled (Joerg Roedel)
       - Add msi_controller setup_irqs() method for special multivector setup (Lucas Stach)
       - Export all remapped MSIs to sysfs attributes (Romain Bezut)
       - Disable MSI on SiS 761 (Ondrej Zary)
    
      AER:
       - Clear error status registers during enumeration and restore (Taku Izumi)
    
      Generic host bridge driver:
       - Fix lookup of linux,pci-probe-only property (Marc Zyngier)
       - Allow multiple hosts with different map_bus() methods (David Daney)
       - Pass starting bus number to pci_scan_root_bus() (David Daney)
       - Fix address window calculation for non-zero starting bus (David Daney)
    
      Altera host bridge driver:
       - Add msi.h to ARM Kbuild (Ley Foon Tan)
       - Add Altera PCIe host controller driver (Ley Foon Tan)
       - Add Altera PCIe MSI driver (Ley Foon Tan)
    
      APM X-Gene host bridge driver:
       - Remove msi_controller assignment (Duc Dang)
    
      Broadcom iProc host bridge driver:
       - Fix header comment "Corporation" misspelling (Florian Fainelli)
       - Fix code comment to match code (Ray Jui)
       - Remove unused struct iproc_pcie.irqs[] (Ray Jui)
       - Call pci_fixup_irqs() for ARM64 as well as ARM (Ray Jui)
       - Fix PCIe reset logic (Ray Jui)
       - Improve link detection logic (Ray Jui)
       - Update PCIe device tree bindings (Ray Jui)
       - Add outbound mapping support (Ray Jui)
    
      Freescale i.MX6 host bridge driver:
       - Return real error code from imx6_add_pcie_port() (Fabio Estevam)
       - Add PCIE_PHY_RX_ASIC_OUT_VALID definition (Fabio Estevam)
    
      Freescale Layerscape host bridge driver:
       - Remove ls_pcie_establish_link() (Minghuan Lian)
       - Ignore PCIe controllers in Endpoint mode (Minghuan Lian)
       - Factor out SCFG related function (Minghuan Lian)
       - Update ls_add_pcie_port() (Minghuan Lian)
       - Remove unused fields from struct ls_pcie (Minghuan Lian)
       - Add support for LS1043a and LS2080a (Minghuan Lian)
       - Add ls_pcie_msi_host_init() (Minghuan Lian)
    
      HiSilicon host bridge driver:
       - Add HiSilicon SoC Hip05 PCIe driver (Zhou Wang)
    
      Marvell MVEBU host bridge driver:
       - Return zero for reserved or unimplemented config space (Russell King)
       - Use exact config access size; don't read/modify/write (Russell King)
       - Use of_get_available_child_count() (Russell King)
       - Use for_each_available_child_of_node() to walk child nodes (Russell King)
       - Report full node name when reporting a DT error (Russell King)
       - Use port->name rather than "PCIe%d.%d" (Russell King)
       - Move port parsing and resource claiming to  separate function (Russell King)
       - Fix memory leaks and refcount leaks (Russell King)
       - Split port parsing and resource claiming from  port setup (Russell King)
       - Use gpio_set_value_cansleep() (Russell King)
       - Use devm_kcalloc() to allocate an array (Russell King)
       - Use gpio_desc to carry around gpio (Russell King)
       - Improve clock/reset handling (Russell King)
       - Add PCI Express root complex capability block (Russell King)
       - Remove code restricting accesses to slot 0 (Russell King)
    
      NVIDIA Tegra host bridge driver:
       - Wrap static pgprot_t initializer with __pgprot() (Ard Biesheuvel)
    
      Renesas R-Car host bridge driver:
       - Build pci-rcar-gen2.c only on ARM (Geert Uytterhoeven)
       - Build pcie-rcar.c only on ARM (Geert Uytterhoeven)
       - Make PCI aware of the I/O resources (Phil Edworthy)
       - Remove dependency on ARM-specific struct hw_pci (Phil Edworthy)
       - Set root bus nr to that provided in DT (Phil Edworthy)
       - Fix I/O offset for multiple host bridges (Phil Edworthy)
    
      ST Microelectronics SPEAr13xx host bridge driver:
       - Fix dw_pcie_cfg_read/write() usage (Gabriele Paoloni)
    
      Synopsys DesignWare host bridge driver:
       - Make "clocks" and "clock-names" optional DT properties (Bhupesh Sharma)
       - Use exact access size in dw_pcie_cfg_read() (Gabriele Paoloni)
       - Simplify dw_pcie_cfg_read/write() interfaces (Gabriele Paoloni)
       - Require config accesses to be naturally aligned (Gabriele Paoloni)
       - Make "num-lanes" an optional DT property (Gabriele Paoloni)
       - Move calculation of bus addresses to DRA7xx (Gabriele Paoloni)
       - Replace ARM pci_sys_data->align_resource with global function pointer (Gabriele Paoloni)
       - Factor out MSI msg setup (Lucas Stach)
       - Implement multivector MSI IRQ setup (Lucas Stach)
       - Make get_msi_addr() return phys_addr_t, not u32 (Lucas Stach)
       - Set up high part of MSI target address (Lucas Stach)
       - Fix PORT_LOGIC_LINK_WIDTH_MASK (Zhou Wang)
       - Revert "PCI: designware: Program ATU with untranslated address" (Zhou Wang)
       - Use of_pci_get_host_bridge_resources() to parse DT (Zhou Wang)
       - Make driver arch-agnostic (Zhou Wang)
    
      Miscellaneous:
       - Make x86 pci_subsys_init() static (Alexander Kuleshov)
       - Turn off Request Attributes to avoid Chelsio T5 Completion erratum (Hariprasad Shenai)"
    
    * tag 'pci-v4.4-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (94 commits)
      PCI: altera: Add Altera PCIe MSI driver
      PCI: hisi: Add HiSilicon SoC Hip05 PCIe driver
      PCI: layerscape: Add ls_pcie_msi_host_init()
      PCI: layerscape: Add support for LS1043a and LS2080a
      PCI: layerscape: Remove unused fields from struct ls_pcie
      PCI: layerscape: Update ls_add_pcie_port()
      PCI: layerscape: Factor out SCFG related function
      PCI: layerscape: Ignore PCIe controllers in Endpoint mode
      PCI: layerscape: Remove ls_pcie_establish_link()
      PCI: designware: Make "clocks" and "clock-names" optional DT properties
      PCI: designware: Make driver arch-agnostic
      ARM/PCI: Replace pci_sys_data->align_resource with global function pointer
      PCI: designware: Use of_pci_get_host_bridge_resources() to parse DT
      Revert "PCI: designware: Program ATU with untranslated address"
      PCI: designware: Move calculation of bus addresses to DRA7xx
      PCI: designware: Make "num-lanes" an optional DT property
      PCI: designware: Require config accesses to be naturally aligned
      PCI: designware: Simplify dw_pcie_cfg_read/write() interfaces
      PCI: designware: Use exact access size in dw_pcie_cfg_read()
      PCI: spear: Fix dw_pcie_cfg_read/write() usage
      ...

commit 58a1fbbb2ee873dd1fe327e80bc7b08e80866269
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 7 00:50:24 2015 +0200

    PM / PCI / ACPI: Kick devices that might have been reset by firmware
    
    There is a concern that if the platform firmware was involved in
    the system resume that's being completed,  some devices might have
    been reset by it and if those devices had the power.direct_complete
    flag set during the preceding suspend transition, they may stay
    in a reset-power-on state indefinitely (until they are runtime-resumed
    and then suspended again).  That may not be a big deal from the
    individual device's perspective, but if the system is an SoC, it may
    be prevented from entering deep SoC-wide low-power states on idle
    because of that.
    
    The devices that are most likely to be affected by this issue are
    PCI devices and ACPI-enumerated devices using the general ACPI PM
    domain, so to prevent it from happening for those devices, force a
    runtime resume for them if they have their power.direct_complete
    flags set and the platform firmware was involved in the resume
    transition currently in progress.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index c9ce3073d7fe..306124bba61e 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -687,7 +687,7 @@ static int pci_pm_prepare(struct device *dev)
 static void pci_pm_complete(struct device *dev)
 {
 	pci_dev_complete_resume(to_pci_dev(dev));
-	pm_generic_complete(dev);
+	pm_complete_with_resume_check(dev);
 }
 
 #else /* !CONFIG_PM_SLEEP */

commit c2df86ea924a8548f54ce90e46fdd6c9495119b2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Sep 30 02:44:29 2015 +0200

    PM / sleep: Drop pm_request_idle() from pm_generic_complete()
    
    The pm_request_idle() in pm_generic_complete() is pointless as it is
    called with the runtime PM usage counter different from zero (bumped
    up by the core during the prepare phase of system suspend) and the
    core calls pm_runtime_put() for all devices after executing their
    complete callbacks, so drop it.
    
    This allows the PCI PM layer to use pm_generic_complete() too.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 8dfb144b8ccf..c9ce3073d7fe 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -686,13 +686,8 @@ static int pci_pm_prepare(struct device *dev)
 
 static void pci_pm_complete(struct device *dev)
 {
-	struct device_driver *drv = dev->driver;
-	struct pci_dev *pci_dev = to_pci_dev(dev);
-
-	pci_dev_complete_resume(pci_dev);
-
-	if (drv && drv->pm && drv->pm->complete)
-		drv->pm->complete(dev);
+	pci_dev_complete_resume(to_pci_dev(dev));
+	pm_generic_complete(dev);
 }
 
 #else /* !CONFIG_PM_SLEEP */

commit 2cef548adf58e9a58a411948b98edb9a3980dbe6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Sep 30 01:10:24 2015 +0200

    PCI / PM: Avoid resuming more devices during system suspend
    
    Commit bac2a909a096 (PCI / PM: Avoid resuming PCI devices during
    system suspend) introduced a mechanism by which some PCI devices that
    were runtime-suspended at the system suspend time might be left in
    that state for the duration of the system suspend-resume cycle.
    However, it overlooked devices that were marked as capable of waking
    up the system just because PME support was detected in their PCI
    config space.
    
    Namely, in that case, device_can_wakeup(dev) returns 'true' for the
    device and if the device is not configured for system wakeup,
    device_may_wakeup(dev) returns 'false' and it will be resumed during
    system suspend even though configuring it for system wakeup may not
    really make sense at all.
    
    To avoid this problem, simply disable PME for PCI devices that have
    not been configured for system wakeup and are runtime-suspended at
    the system suspend time for the duration of the suspend-resume cycle.
    
    If the device is in D3cold, its config space is not available and it
    shouldn't be written to, but that's only possible if the device
    has platform PM support and the platform code is responsible for
    checking whether or not the device's configuration is suitable for
    system suspend in that case.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 108a3118ace7..8dfb144b8ccf 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -684,10 +684,21 @@ static int pci_pm_prepare(struct device *dev)
 	return pci_dev_keep_suspended(to_pci_dev(dev));
 }
 
+static void pci_pm_complete(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+
+	pci_dev_complete_resume(pci_dev);
+
+	if (drv && drv->pm && drv->pm->complete)
+		drv->pm->complete(dev);
+}
 
 #else /* !CONFIG_PM_SLEEP */
 
 #define pci_pm_prepare	NULL
+#define pci_pm_complete	NULL
 
 #endif /* !CONFIG_PM_SLEEP */
 
@@ -1218,6 +1229,7 @@ static int pci_pm_runtime_idle(struct device *dev)
 
 static const struct dev_pm_ops pci_dev_pm_ops = {
 	.prepare = pci_pm_prepare,
+	.complete = pci_pm_complete,
 	.suspend = pci_pm_suspend,
 	.resume = pci_pm_resume,
 	.freeze = pci_pm_freeze,

commit a8360062ccfb4b891d3013d0e55826c8bcb02bfb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Sep 18 03:08:40 2015 +0200

    PCI / PM: Update runtime PM documentation for PCI devices
    
    Section 3.2 "Device Runtime Power Management" of pci.txt has become
    outdated, so update it to correctly reflect the current code flow.
    
    Also update the comment in local_pci_probe() to document the fact
    that pm_runtime_put_noidle() is not the only runtime PM helper
    function that can be used to decrement the device's runtime PM
    usage counter in .probe().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index dd652f2ae03d..108a3118ace7 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -299,9 +299,10 @@ static long local_pci_probe(void *_ddi)
 	 * Unbound PCI devices are always put in D0, regardless of
 	 * runtime PM status.  During probe, the device is set to
 	 * active and the usage count is incremented.  If the driver
-	 * supports runtime PM, it should call pm_runtime_put_noidle()
-	 * in its probe routine and pm_runtime_get_noresume() in its
-	 * remove routine.
+	 * supports runtime PM, it should call pm_runtime_put_noidle(),
+	 * or any other runtime PM helper function decrementing the usage
+	 * count, in its probe routine and pm_runtime_get_noresume() in
+	 * its remove routine.
 	 */
 	pm_runtime_get_sync(dev);
 	pci_dev->driver = pci_drv;

commit 9222097f0d2f88db602c0340d19d90a1c72b5fec
Author: Zhen Lei <thunder.leizhen@huawei.com>
Date:   Thu Sep 10 18:40:31 2015 +0800

    PCI: Remove unnecessary "if" statement
    
    In store_remove_id(), set the default return value to -ENODEV, and
    overwrite it with the input buffer size if we find a matching list entry.
    Then we don't need to test whether to return an error or the count.
    
    No functional change.
    
    [bhelgaas: changelog]
    Signed-off-by: Zhen Lei <thunder.leizhen@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index dd652f2ae03d..2865ba37e295 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -172,7 +172,7 @@ static ssize_t store_remove_id(struct device_driver *driver, const char *buf,
 	__u32 vendor, device, subvendor = PCI_ANY_ID,
 		subdevice = PCI_ANY_ID, class = 0, class_mask = 0;
 	int fields = 0;
-	int retval = -ENODEV;
+	size_t retval = -ENODEV;
 
 	fields = sscanf(buf, "%x %x %x %x %x %x",
 			&vendor, &device, &subvendor, &subdevice,
@@ -190,15 +190,13 @@ static ssize_t store_remove_id(struct device_driver *driver, const char *buf,
 		    !((id->class ^ class) & class_mask)) {
 			list_del(&dynid->node);
 			kfree(dynid);
-			retval = 0;
+			retval = count;
 			break;
 		}
 	}
 	spin_unlock(&pdrv->dynids.lock);
 
-	if (retval)
-		return retval;
-	return count;
+	return retval;
 }
 static DRIVER_ATTR(remove_id, S_IWUSR, NULL, store_remove_id);
 

commit 2965faa5e03d1e71e9ff9aa143fff39e0a77543a
Author: Dave Young <dyoung@redhat.com>
Date:   Wed Sep 9 15:38:55 2015 -0700

    kexec: split kexec_load syscall from kexec core code
    
    There are two kexec load syscalls, kexec_load another and kexec_file_load.
     kexec_file_load has been splited as kernel/kexec_file.c.  In this patch I
    split kexec_load syscall code to kernel/kexec.c.
    
    And add a new kconfig option KEXEC_CORE, so we can disable kexec_load and
    use kexec_file_load only, or vice verse.
    
    The original requirement is from Ted Ts'o, he want kexec kernel signature
    being checked with CONFIG_KEXEC_VERIFY_SIG enabled.  But kexec-tools use
    kexec_load syscall can bypass the checking.
    
    Vivek Goyal proposed to create a common kconfig option so user can compile
    in only one syscall for loading kexec kernel.  KEXEC/KEXEC_FILE selects
    KEXEC_CORE so that old config files still work.
    
    Because there's general code need CONFIG_KEXEC_CORE, so I updated all the
    architecture Kconfig with a new option KEXEC_CORE, and let KEXEC selects
    KEXEC_CORE in arch Kconfig.  Also updated general kernel code with to
    kexec_load syscall.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Vivek Goyal <vgoyal@redhat.com>
    Cc: Petr Tesarik <ptesarik@suse.cz>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: Josh Boyer <jwboyer@fedoraproject.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 52a880ca1768..dd652f2ae03d 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -467,7 +467,7 @@ static void pci_device_shutdown(struct device *dev)
 	pci_msi_shutdown(pci_dev);
 	pci_msix_shutdown(pci_dev);
 
-#ifdef CONFIG_KEXEC
+#ifdef CONFIG_KEXEC_CORE
 	/*
 	 * If this is a kexec reboot, turn off Bus Master bit on the
 	 * device to tell it to not continue to do DMA. Don't touch

commit 890e4847587fcff5eb0438e90992ad7d2a261f33
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Jun 10 16:54:58 2015 +0800

    PCI: Add pcibios_alloc_irq() and pcibios_free_irq()
    
    Add pcibios_alloc_irq() and pcibios_free_irq(), which are called when
    binding/unbinding PCI device drivers.
    
    PCI arch code may implement these to manage IRQ resources for hotplugged
    devices.
    
    [bhelgaas: changelog]
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 3cb2210de553..52a880ca1768 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -388,18 +388,31 @@ static int __pci_device_probe(struct pci_driver *drv, struct pci_dev *pci_dev)
 	return error;
 }
 
+int __weak pcibios_alloc_irq(struct pci_dev *dev)
+{
+	return 0;
+}
+
+void __weak pcibios_free_irq(struct pci_dev *dev)
+{
+}
+
 static int pci_device_probe(struct device *dev)
 {
-	int error = 0;
-	struct pci_driver *drv;
-	struct pci_dev *pci_dev;
+	int error;
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct pci_driver *drv = to_pci_driver(dev->driver);
+
+	error = pcibios_alloc_irq(pci_dev);
+	if (error < 0)
+		return error;
 
-	drv = to_pci_driver(dev->driver);
-	pci_dev = to_pci_dev(dev);
 	pci_dev_get(pci_dev);
 	error = __pci_device_probe(drv, pci_dev);
-	if (error)
+	if (error) {
+		pcibios_free_irq(pci_dev);
 		pci_dev_put(pci_dev);
+	}
 
 	return error;
 }
@@ -415,6 +428,7 @@ static int pci_device_remove(struct device *dev)
 			drv->remove(pci_dev);
 			pm_runtime_put_noidle(dev);
 		}
+		pcibios_free_irq(pci_dev);
 		pci_dev->driver = NULL;
 	}
 

commit 872912352c5be930e9568e5f3b6d73107d9f278d
Merge: c08f8467939e b5e82233cab4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 10 15:09:41 2015 -0800

    Merge tag 'pm+acpi-3.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "We have a few new features this time, including a new SFI-based
      cpufreq driver, a new devfreq driver for Tegra Activity Monitor, a new
      devfreq class for providing its governors with raw utilization data
      and a new ACPI driver for AMD SoCs.
    
      Still, the majority of changes here are reworks of existing code to
      make it more straightforward or to prepare it for implementing new
      features on top of it.  The primary example is the rework of ACPI
      resources handling from Jiang Liu, Thomas Gleixner and Lv Zheng with
      support for IOAPIC hotplug implemented on top of it, but there is
      quite a number of changes of this kind in the cpufreq core, ACPICA,
      ACPI EC driver, ACPI processor driver and the generic power domains
      core code too.
    
      The most active developer is Viresh Kumar with his cpufreq changes.
    
      Specifics:
    
       - Rework of the core ACPI resources parsing code to fix issues in it
         and make using resource offsets more convenient and consolidation
         of some resource-handing code in a couple of places that have grown
         analagous data structures and code to cover the the same gap in the
         core (Jiang Liu, Thomas Gleixner, Lv Zheng).
    
       - ACPI-based IOAPIC hotplug support on top of the resources handling
         rework (Jiang Liu, Yinghai Lu).
    
       - ACPICA update to upstream release 20150204 including an interrupt
         handling rework that allows drivers to install raw handlers for
         ACPI GPEs which then become entirely responsible for the given GPE
         and the ACPICA core code won't touch it (Lv Zheng, David E Box,
         Octavian Purdila).
    
       - ACPI EC driver rework to fix several concurrency issues and other
         problems related to events handling on top of the ACPICA's new
         support for raw GPE handlers (Lv Zheng).
    
       - New ACPI driver for AMD SoCs analogous to the LPSS (Low-Power
         Subsystem) driver for Intel chips (Ken Xue).
    
       - Two minor fixes of the ACPI LPSS driver (Heikki Krogerus, Jarkko
         Nikula).
    
       - Two new blacklist entries for machines (Samsung 730U3E/740U3E and
         510R) where the native backlight interface doesn't work correctly
         while the ACPI one does (Hans de Goede).
    
       - Rework of the ACPI processor driver's handling of idle states to
         make the code more straightforward and less bloated overall (Rafael
         J Wysocki).
    
       - Assorted minor fixes related to ACPI and SFI (Andreas Ruprecht,
         Andy Shevchenko, Hanjun Guo, Jan Beulich, Rafael J Wysocki, Yaowei
         Bai).
    
       - PCI core power management modification to avoid resuming (some)
         runtime-suspended devices during system suspend if they are in the
         right states already (Rafael J Wysocki).
    
       - New SFI-based cpufreq driver for Intel platforms using SFI
         (Srinidhi Kasagar).
    
       - cpufreq core fixes, cleanups and simplifications (Viresh Kumar,
         Doug Anderson, Wolfram Sang).
    
       - SkyLake CPU support and other updates for the intel_pstate driver
         (Kristen Carlson Accardi, Srinivas Pandruvada).
    
       - cpufreq-dt driver cleanup (Markus Elfring).
    
       - Init fix for the ARM big.LITTLE cpuidle driver (Sudeep Holla).
    
       - Generic power domains core code fixes and cleanups (Ulf Hansson).
    
       - Operating Performance Points (OPP) core code cleanups and kernel
         documentation update (Nishanth Menon).
    
       - New dabugfs interface to make the list of PM QoS constraints
         available to user space (Nishanth Menon).
    
       - New devfreq driver for Tegra Activity Monitor (Tomeu Vizoso).
    
       - New devfreq class (devfreq_event) to provide raw utilization data
         to devfreq governors (Chanwoo Choi).
    
       - Assorted minor fixes and cleanups related to power management
         (Andreas Ruprecht, Krzysztof Kozlowski, Rickard Strandqvist, Pavel
         Machek, Todd E Brandt, Wonhong Kwon).
    
       - turbostat updates (Len Brown) and cpupower Makefile improvement
         (Sriram Raghunathan)"
    
    * tag 'pm+acpi-3.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (151 commits)
      tools/power turbostat: relax dependency on APERF_MSR
      tools/power turbostat: relax dependency on invariant TSC
      Merge branch 'pci/host-generic' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci into acpi-resources
      tools/power turbostat: decode MSR_*_PERF_LIMIT_REASONS
      tools/power turbostat: relax dependency on root permission
      ACPI / video: Add disable_native_backlight quirk for Samsung 510R
      ACPI / PM: Remove unneeded nested #ifdef
      USB / PM: Remove unneeded #ifdef and associated dead code
      intel_pstate: provide option to only use intel_pstate with HWP
      ACPI / EC: Add GPE reference counting debugging messages
      ACPI / EC: Add query flushing support
      ACPI / EC: Refine command storm prevention support
      ACPI / EC: Add command flushing support.
      ACPI / EC: Introduce STARTED/STOPPED flags to replace BLOCKED flag
      ACPI: add AMD ACPI2Platform device support for x86 system
      ACPI / table: remove duplicate NULL check for the handler of acpi_table_parse()
      ACPI / EC: Update revision due to raw handler mode.
      ACPI / EC: Reduce ec_poll() by referencing the last register access timestamp.
      ACPI / EC: Fix several GPE handling issues by deploying ACPI_GPE_DISPATCH_RAW_HANDLER mode.
      ACPICA: Events: Enable APIs to allow interrupt/polling adaptive request based GPE handling model
      ...

commit bac2a909a096c9110525c18cbb8ce73c660d5f71
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 21 02:17:42 2015 +0100

    PCI / PM: Avoid resuming PCI devices during system suspend
    
    Commit f25c0ae2b4c4 (ACPI / PM: Avoid resuming devices in ACPI PM
    domain during system suspend) modified the ACPI PM domain's system
    suspend callbacks to allow devices attached to it to be left in the
    runtime-suspended state during system suspend so as to optimize
    the suspend process.
    
    This was based on the general mechanism introduced by commit
    aae4518b3124 (PM / sleep: Mechanism to avoid resuming runtime-suspended
    devices unnecessarily).
    
    Extend that approach to PCI devices by modifying the PCI bus type's
    ->prepare callback to return 1 for devices that are runtime-suspended
    when it is being executed and that are in a suitable power state and
    need not be resumed going forward.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 887e6bd95af7..741023e94008 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -653,7 +653,6 @@ static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
 static int pci_pm_prepare(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
-	int error = 0;
 
 	/*
 	 * Devices having power.ignore_children set may still be necessary for
@@ -662,10 +661,12 @@ static int pci_pm_prepare(struct device *dev)
 	if (dev->power.ignore_children)
 		pm_runtime_resume(dev);
 
-	if (drv && drv->pm && drv->pm->prepare)
-		error = drv->pm->prepare(dev);
-
-	return error;
+	if (drv && drv->pm && drv->pm->prepare) {
+		int error = drv->pm->prepare(dev);
+		if (error)
+			return error;
+	}
+	return pci_dev_keep_suspended(to_pci_dev(dev));
 }
 
 

commit 145b3fe579db66fbe999a2bc3fd5b63dffe9636d
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Tue Dec 2 17:35:04 2014 +0100

    PCI: Generate uppercase hex for modalias var in uevent
    
    Some implementations of modprobe fail to load the driver for a PCI device
    automatically because the "interface" part of the modalias from the kernel
    is lowercase, and the modalias from file2alias is uppercase.
    
    The "interface" is the low-order byte of the Class Code, defined in PCI
    r3.0, Appendix D.  Most interface types defined in the spec do not use
    alpha characters, so they won't be affected.  For example, 00h, 01h, 10h,
    20h, etc. are unaffected.
    
    Print the "interface" byte of the Class Code in uppercase hex, as we
    already do for the Vendor ID, Device ID, Class, etc.
    
    Commit 89ec3dcf17fd ("PCI: Generate uppercase hex for modalias interface
    class") fixed only half of the problem.  Some udev implementations rely on
    the uevent file and not the modalias file.
    
    Fixes: d1ded203adf1 ("PCI: add MODALIAS to hotplug event for pci devices")
    Fixes: 89ec3dcf17fd ("PCI: Generate uppercase hex for modalias interface class")
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    CC: stable@vger.kernel.org

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 887e6bd95af7..09a66bad8018 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1383,7 +1383,7 @@ static int pci_uevent(struct device *dev, struct kobj_uevent_env *env)
 	if (add_uevent_var(env, "PCI_SLOT_NAME=%s", pci_name(pdev)))
 		return -ENOMEM;
 
-	if (add_uevent_var(env, "MODALIAS=pci:v%08Xd%08Xsv%08Xsd%08Xbc%02Xsc%02Xi%02x",
+	if (add_uevent_var(env, "MODALIAS=pci:v%08Xd%08Xsv%08Xsd%08Xbc%02Xsc%02Xi%02X",
 			   pdev->vendor, pdev->device,
 			   pdev->subsystem_vendor, pdev->subsystem_device,
 			   (u8)(pdev->class >> 16), (u8)(pdev->class >> 8),

commit fbb988be7f691599f17c6915c605bd09ec4318b4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 27 23:16:57 2014 +0100

    PCI / PM: Drop CONFIG_PM_RUNTIME from the PCI core
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so quite a few
    depend on CONFIG_PM.
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM in the PCI core code.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 2b3c89425bb5..887e6bd95af7 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1104,7 +1104,7 @@ static int pci_pm_restore(struct device *dev)
 
 #endif /* !CONFIG_HIBERNATE_CALLBACKS */
 
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 
 static int pci_pm_runtime_suspend(struct device *dev)
 {
@@ -1200,16 +1200,6 @@ static int pci_pm_runtime_idle(struct device *dev)
 	return ret;
 }
 
-#else /* !CONFIG_PM_RUNTIME */
-
-#define pci_pm_runtime_suspend	NULL
-#define pci_pm_runtime_resume	NULL
-#define pci_pm_runtime_idle	NULL
-
-#endif /* !CONFIG_PM_RUNTIME */
-
-#ifdef CONFIG_PM
-
 static const struct dev_pm_ops pci_dev_pm_ops = {
 	.prepare = pci_pm_prepare,
 	.suspend = pci_pm_suspend,
@@ -1231,11 +1221,15 @@ static const struct dev_pm_ops pci_dev_pm_ops = {
 
 #define PCI_PM_OPS_PTR	(&pci_dev_pm_ops)
 
-#else /* !COMFIG_PM_OPS */
+#else /* !CONFIG_PM */
+
+#define pci_pm_runtime_suspend	NULL
+#define pci_pm_runtime_resume	NULL
+#define pci_pm_runtime_idle	NULL
 
 #define PCI_PM_OPS_PTR	NULL
 
-#endif /* !COMFIG_PM_OPS */
+#endif /* !CONFIG_PM */
 
 /**
  * __pci_register_driver - register a new pci driver

commit 3b7f1016628e04f937bafd468ce6fa437b92e275
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Fri Jul 25 10:36:14 2014 +0200

    PCI: Remove unnecessary variable in pci_add_dynid()
    
    The variable "retval" in pci_add_dynid() is only used to store the return
    value of driver_attach() and is then directly returned.  Remove the
    variable and directly pass on driver_attach()'s return value.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index d04c5adafc16..2b3c89425bb5 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -55,7 +55,6 @@ int pci_add_dynid(struct pci_driver *drv,
 		  unsigned long driver_data)
 {
 	struct pci_dynid *dynid;
-	int retval;
 
 	dynid = kzalloc(sizeof(*dynid), GFP_KERNEL);
 	if (!dynid)
@@ -73,9 +72,7 @@ int pci_add_dynid(struct pci_driver *drv,
 	list_add_tail(&dynid->node, &drv->dynids.list);
 	spin_unlock(&drv->dynids.lock);
 
-	retval = driver_attach(&drv->driver);
-
-	return retval;
+	return driver_attach(&drv->driver);
 }
 EXPORT_SYMBOL_GPL(pci_add_dynid);
 

commit 7d2a01b87f1682fde87461864e6682031bfaa0a9
Author: Andreas Noever <andreas.noever@gmail.com>
Date:   Tue Jun 3 22:04:09 2014 +0200

    PCI: Add pci_fixup_suspend_late quirk pass
    
    Add pci_fixup_suspend_late as a new pci_fixup_pass. The pass is called
    from suspend_noirq and poweroff_noirq. Using the same pass for suspend
    and hibernate is consistent with resume_early which is called by
    resume_noirq and restore_noirq.
    
    The new quirk pass is required for Thunderbolt support on Apple
    hardware.
    
    Signed-off-by: Andreas Noever <andreas.noever@gmail.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 3f8e3dbcaa7c..d04c5adafc16 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -582,7 +582,7 @@ static int pci_legacy_suspend_late(struct device *dev, pm_message_t state)
 			WARN_ONCE(pci_dev->current_state != prev,
 				"PCI PM: Device state not saved by %pF\n",
 				drv->suspend_late);
-			return 0;
+			goto Fixup;
 		}
 	}
 
@@ -591,6 +591,9 @@ static int pci_legacy_suspend_late(struct device *dev, pm_message_t state)
 
 	pci_pm_set_unknown_state(pci_dev);
 
+Fixup:
+	pci_fixup_device(pci_fixup_suspend_late, pci_dev);
+
 	return 0;
 }
 
@@ -734,7 +737,7 @@ static int pci_pm_suspend_noirq(struct device *dev)
 
 	if (!pm) {
 		pci_save_state(pci_dev);
-		return 0;
+		goto Fixup;
 	}
 
 	if (pm->suspend_noirq) {
@@ -751,7 +754,7 @@ static int pci_pm_suspend_noirq(struct device *dev)
 			WARN_ONCE(pci_dev->current_state != prev,
 				"PCI PM: State of device not saved by %pF\n",
 				pm->suspend_noirq);
-			return 0;
+			goto Fixup;
 		}
 	}
 
@@ -775,6 +778,9 @@ static int pci_pm_suspend_noirq(struct device *dev)
 	if (pci_dev->class == PCI_CLASS_SERIAL_USB_EHCI)
 		pci_write_config_word(pci_dev, PCI_COMMAND, 0);
 
+Fixup:
+	pci_fixup_device(pci_fixup_suspend_late, pci_dev);
+
 	return 0;
 }
 
@@ -999,8 +1005,10 @@ static int pci_pm_poweroff_noirq(struct device *dev)
 	if (pci_has_legacy_pm_support(to_pci_dev(dev)))
 		return pci_legacy_suspend_late(dev, PMSG_HIBERNATE);
 
-	if (!drv || !drv->pm)
+	if (!drv || !drv->pm) {
+		pci_fixup_device(pci_fixup_suspend_late, pci_dev);
 		return 0;
+	}
 
 	if (drv->pm->poweroff_noirq) {
 		int error;
@@ -1021,6 +1029,8 @@ static int pci_pm_poweroff_noirq(struct device *dev)
 	if (pci_dev->class == PCI_CLASS_SERIAL_USB_EHCI)
 		pci_write_config_word(pci_dev, PCI_COMMAND, 0);
 
+	pci_fixup_device(pci_fixup_suspend_late, pci_dev);
+
 	if (pcibios_pm_ops.poweroff_noirq)
 		return pcibios_pm_ops.poweroff_noirq(dev);
 

commit 3c78bc61f5ef3bc87e7f94f67ec737d2273f120b
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 18 20:13:49 2014 -0400

    PCI: Whitespace cleanup
    
    Fix various whitespace errors.
    
    No functional change.
    
    [bhelgaas: fix other similar problems]
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index b91a17fe425b..3f8e3dbcaa7c 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -99,15 +99,15 @@ static void pci_free_dynids(struct pci_driver *drv)
  *
  * Allow PCI IDs to be added to an existing driver via sysfs.
  */
-static ssize_t
-store_new_id(struct device_driver *driver, const char *buf, size_t count)
+static ssize_t store_new_id(struct device_driver *driver, const char *buf,
+			    size_t count)
 {
 	struct pci_driver *pdrv = to_pci_driver(driver);
 	const struct pci_device_id *ids = pdrv->id_table;
-	__u32 vendor, device, subvendor=PCI_ANY_ID,
-		subdevice=PCI_ANY_ID, class=0, class_mask=0;
-	unsigned long driver_data=0;
-	int fields=0;
+	__u32 vendor, device, subvendor = PCI_ANY_ID,
+		subdevice = PCI_ANY_ID, class = 0, class_mask = 0;
+	unsigned long driver_data = 0;
+	int fields = 0;
 	int retval = 0;
 
 	fields = sscanf(buf, "%x %x %x %x %x %x %lx",
@@ -167,8 +167,8 @@ static DRIVER_ATTR(new_id, S_IWUSR, NULL, store_new_id);
  *
  * Removes a dynamic pci device ID to this driver.
  */
-static ssize_t
-store_remove_id(struct device_driver *driver, const char *buf, size_t count)
+static ssize_t store_remove_id(struct device_driver *driver, const char *buf,
+			       size_t count)
 {
 	struct pci_dynid *dynid, *n;
 	struct pci_driver *pdrv = to_pci_driver(driver);
@@ -374,8 +374,7 @@ static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
  * returns 0 on success, else error.
  * side-effect: pci_dev->driver is set to drv when drv claims pci_dev.
  */
-static int
-__pci_device_probe(struct pci_driver *drv, struct pci_dev *pci_dev)
+static int __pci_device_probe(struct pci_driver *drv, struct pci_dev *pci_dev)
 {
 	const struct pci_device_id *id;
 	int error = 0;
@@ -392,7 +391,7 @@ __pci_device_probe(struct pci_driver *drv, struct pci_dev *pci_dev)
 	return error;
 }
 
-static int pci_device_probe(struct device * dev)
+static int pci_device_probe(struct device *dev)
 {
 	int error = 0;
 	struct pci_driver *drv;
@@ -408,10 +407,10 @@ static int pci_device_probe(struct device * dev)
 	return error;
 }
 
-static int pci_device_remove(struct device * dev)
+static int pci_device_remove(struct device *dev)
 {
-	struct pci_dev * pci_dev = to_pci_dev(dev);
-	struct pci_driver * drv = pci_dev->driver;
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct pci_driver *drv = pci_dev->driver;
 
 	if (drv) {
 		if (drv->remove) {
@@ -539,8 +538,8 @@ static int pci_pm_reenable_device(struct pci_dev *pci_dev)
 
 static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 {
-	struct pci_dev * pci_dev = to_pci_dev(dev);
-	struct pci_driver * drv = pci_dev->driver;
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct pci_driver *drv = pci_dev->driver;
 
 	if (drv && drv->suspend) {
 		pci_power_t prev = pci_dev->current_state;
@@ -566,8 +565,8 @@ static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 
 static int pci_legacy_suspend_late(struct device *dev, pm_message_t state)
 {
-	struct pci_dev * pci_dev = to_pci_dev(dev);
-	struct pci_driver * drv = pci_dev->driver;
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct pci_driver *drv = pci_dev->driver;
 
 	if (drv && drv->suspend_late) {
 		pci_power_t prev = pci_dev->current_state;
@@ -597,8 +596,8 @@ static int pci_legacy_suspend_late(struct device *dev, pm_message_t state)
 
 static int pci_legacy_resume_early(struct device *dev)
 {
-	struct pci_dev * pci_dev = to_pci_dev(dev);
-	struct pci_driver * drv = pci_dev->driver;
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct pci_driver *drv = pci_dev->driver;
 
 	return drv && drv->resume_early ?
 			drv->resume_early(pci_dev) : 0;
@@ -606,8 +605,8 @@ static int pci_legacy_resume_early(struct device *dev)
 
 static int pci_legacy_resume(struct device *dev)
 {
-	struct pci_dev * pci_dev = to_pci_dev(dev);
-	struct pci_driver * drv = pci_dev->driver;
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct pci_driver *drv = pci_dev->driver;
 
 	pci_fixup_device(pci_fixup_resume, pci_dev);
 
@@ -1269,8 +1268,7 @@ EXPORT_SYMBOL(__pci_register_driver);
  * driverless.
  */
 
-void
-pci_unregister_driver(struct pci_driver *drv)
+void pci_unregister_driver(struct pci_driver *drv)
 {
 	driver_unregister(&drv->driver);
 	pci_free_dynids(drv);
@@ -1288,14 +1286,13 @@ static struct pci_driver pci_compat_driver = {
  * Returns the appropriate pci_driver structure or %NULL if there is no
  * registered driver for the device.
  */
-struct pci_driver *
-pci_dev_driver(const struct pci_dev *dev)
+struct pci_driver *pci_dev_driver(const struct pci_dev *dev)
 {
 	if (dev->driver)
 		return dev->driver;
 	else {
 		int i;
-		for(i=0; i<=PCI_ROM_RESOURCE; i++)
+		for (i = 0; i <= PCI_ROM_RESOURCE; i++)
 			if (dev->resource[i].flags & IORESOURCE_BUSY)
 				return &pci_compat_driver;
 	}

commit b7fe943421396b61b9f7a97c2554ed999e0f3658
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 25 14:32:25 2014 -0600

    PCI: Move EXPORT_SYMBOL so it immediately follows function/variable
    
    Move EXPORT_SYMBOL so it immediately follows the function or variable.
    
    No functional change.
    
    [bhelgaas: squash similar changes, fix hotplug, probe, rom, search, too]
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 837d71f5390b..b91a17fe425b 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -77,6 +77,7 @@ int pci_add_dynid(struct pci_driver *drv,
 
 	return retval;
 }
+EXPORT_SYMBOL_GPL(pci_add_dynid);
 
 static void pci_free_dynids(struct pci_driver *drv)
 {
@@ -235,6 +236,7 @@ const struct pci_device_id *pci_match_id(const struct pci_device_id *ids,
 	}
 	return NULL;
 }
+EXPORT_SYMBOL(pci_match_id);
 
 static const struct pci_device_id pci_device_id_any = {
 	.vendor = PCI_ANY_ID,
@@ -1255,6 +1257,7 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 	/* register with core */
 	return driver_register(&drv->driver);
 }
+EXPORT_SYMBOL(__pci_register_driver);
 
 /**
  * pci_unregister_driver - unregister a pci driver
@@ -1272,6 +1275,7 @@ pci_unregister_driver(struct pci_driver *drv)
 	driver_unregister(&drv->driver);
 	pci_free_dynids(drv);
 }
+EXPORT_SYMBOL(pci_unregister_driver);
 
 static struct pci_driver pci_compat_driver = {
 	.name = "compat"
@@ -1297,6 +1301,7 @@ pci_dev_driver(const struct pci_dev *dev)
 	}
 	return NULL;
 }
+EXPORT_SYMBOL(pci_dev_driver);
 
 /**
  * pci_bus_match - Tell if a PCI device structure has a matching PCI device id structure
@@ -1342,6 +1347,7 @@ struct pci_dev *pci_dev_get(struct pci_dev *dev)
 		get_device(&dev->dev);
 	return dev;
 }
+EXPORT_SYMBOL(pci_dev_get);
 
 /**
  * pci_dev_put - release a use of the pci device structure
@@ -1355,6 +1361,7 @@ void pci_dev_put(struct pci_dev *dev)
 	if (dev)
 		put_device(&dev->dev);
 }
+EXPORT_SYMBOL(pci_dev_put);
 
 static int pci_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
@@ -1400,19 +1407,10 @@ struct bus_type pci_bus_type = {
 	.drv_groups	= pci_drv_groups,
 	.pm		= PCI_PM_OPS_PTR,
 };
+EXPORT_SYMBOL(pci_bus_type);
 
 static int __init pci_driver_init(void)
 {
 	return bus_register(&pci_bus_type);
 }
-
 postcore_initcall(pci_driver_init);
-
-EXPORT_SYMBOL_GPL(pci_add_dynid);
-EXPORT_SYMBOL(pci_match_id);
-EXPORT_SYMBOL(__pci_register_driver);
-EXPORT_SYMBOL(pci_unregister_driver);
-EXPORT_SYMBOL(pci_dev_driver);
-EXPORT_SYMBOL(pci_bus_type);
-EXPORT_SYMBOL(pci_dev_get);
-EXPORT_SYMBOL(pci_dev_put);

commit d1a2523d2adc0b6910dbc2a9aed44c4217134db1
Merge: 79d458bf4743 cab9a128dad0 56604faed112 782a985d7af2
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed May 28 16:21:07 2014 -0600

    Merge branches 'pci/hotplug', 'pci/pci_is_bridge' and 'pci/virtualization' into next
    
    * pci/hotplug:
      PCI: cpqphp: Fix possible null pointer dereference
      NVMe: Implement PCIe reset notification callback
      PCI: Notify driver before and after device reset
    
    * pci/pci_is_bridge:
      pcmcia: Use pci_is_bridge() to simplify code
      PCI: pciehp: Use pci_is_bridge() to simplify code
      PCI: acpiphp: Use pci_is_bridge() to simplify code
      PCI: cpcihp: Use pci_is_bridge() to simplify code
      PCI: shpchp: Use pci_is_bridge() to simplify code
      PCI: rpaphp: Use pci_is_bridge() to simplify code
      sparc/PCI: Use pci_is_bridge() to simplify code
      powerpc/PCI: Use pci_is_bridge() to simplify code
      ia64/PCI: Use pci_is_bridge() to simplify code
      x86/PCI: Use pci_is_bridge() to simplify code
      PCI: Use pci_is_bridge() to simplify code
      PCI: Add new pci_is_bridge() interface
      PCI: Rename pci_is_bridge() to pci_has_subordinate()
    
    * pci/virtualization:
      PCI: Introduce new device binding path using pci_dev.driver_override
    
    Conflicts:
            drivers/pci/pci-sysfs.c

commit 782a985d7af26db39e86070d28f987cad21313c0
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue May 20 08:53:21 2014 -0600

    PCI: Introduce new device binding path using pci_dev.driver_override
    
    The driver_override field allows us to specify the driver for a device
    rather than relying on the driver to provide a positive match of the
    device.  This shortcuts the existing process of looking up the vendor and
    device ID, adding them to the driver new_id, binding the device, then
    removing the ID, but it also provides a couple advantages.
    
    First, the above existing process allows the driver to bind to any device
    matching the new_id for the window where it's enabled.  This is often not
    desired, such as the case of trying to bind a single device to a meta
    driver like pci-stub or vfio-pci.  Using driver_override we can do this
    deterministically using:
    
      echo pci-stub > /sys/bus/pci/devices/0000:03:00.0/driver_override
      echo 0000:03:00.0 > /sys/bus/pci/devices/0000:03:00.0/driver/unbind
      echo 0000:03:00.0 > /sys/bus/pci/drivers_probe
    
    Previously we could not invoke drivers_probe after adding a device to
    new_id for a driver as we get non-deterministic behavior whether the driver
    we intend or the standard driver will claim the device.  Now it becomes a
    deterministic process, only the driver matching driver_override will probe
    the device.
    
    To return the device to the standard driver, we simply clear the
    driver_override and reprobe the device:
    
      echo > /sys/bus/pci/devices/0000:03:00.0/driver_override
      echo 0000:03:00.0 > /sys/bus/pci/devices/0000:03:00.0/driver/unbind
      echo 0000:03:00.0 > /sys/bus/pci/drivers_probe
    
    Another advantage to this approach is that we can specify a driver override
    to force a specific binding or prevent any binding.  For instance when an
    IOMMU group is exposed to userspace through VFIO we require that all
    devices within that group are owned by VFIO.  However, devices can be
    hot-added into an IOMMU group, in which case we want to prevent the device
    from binding to any driver (override driver = "none") or perhaps have it
    automatically bind to vfio-pci.  With driver_override it's a simple matter
    for this field to be set internally when the device is first discovered to
    prevent driver matches.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Reviewed-by: Alexander Graf <agraf@suse.de>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index d911e0c1f359..4393c12e9135 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -216,6 +216,13 @@ const struct pci_device_id *pci_match_id(const struct pci_device_id *ids,
 	return NULL;
 }
 
+static const struct pci_device_id pci_device_id_any = {
+	.vendor = PCI_ANY_ID,
+	.device = PCI_ANY_ID,
+	.subvendor = PCI_ANY_ID,
+	.subdevice = PCI_ANY_ID,
+};
+
 /**
  * pci_match_device - Tell if a PCI device structure has a matching PCI device id structure
  * @drv: the PCI driver to match against
@@ -229,18 +236,30 @@ static const struct pci_device_id *pci_match_device(struct pci_driver *drv,
 						    struct pci_dev *dev)
 {
 	struct pci_dynid *dynid;
+	const struct pci_device_id *found_id = NULL;
+
+	/* When driver_override is set, only bind to the matching driver */
+	if (dev->driver_override && strcmp(dev->driver_override, drv->name))
+		return NULL;
 
 	/* Look at the dynamic ids first, before the static ones */
 	spin_lock(&drv->dynids.lock);
 	list_for_each_entry(dynid, &drv->dynids.list, node) {
 		if (pci_match_one_device(&dynid->id, dev)) {
-			spin_unlock(&drv->dynids.lock);
-			return &dynid->id;
+			found_id = &dynid->id;
+			break;
 		}
 	}
 	spin_unlock(&drv->dynids.lock);
 
-	return pci_match_id(drv->id_table, dev);
+	if (!found_id)
+		found_id = pci_match_id(drv->id_table, dev);
+
+	/* driver_override will always match, send a dummy id */
+	if (!found_id && dev->driver_override)
+		found_id = &pci_device_id_any;
+
+	return found_id;
 }
 
 struct drv_dev_and_id {

commit 326c1cdae74186bfab3464e8f3378c7fa324be12
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Sun May 4 12:23:36 2014 +0800

    PCI: Rename pci_is_bridge() to pci_has_subordinate()
    
    Previously, pci_is_bridge() returned true only when a subordinate bus
    existed.  Rename pci_is_bridge() to pci_has_subordinate() to better
    indicate what we're checking.
    
    No functional change.
    
    [bhelgaas: changelog]
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index d911e0c1f359..b7850cb4b907 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -580,14 +580,14 @@ static void pci_pm_default_resume(struct pci_dev *pci_dev)
 {
 	pci_fixup_device(pci_fixup_resume, pci_dev);
 
-	if (!pci_is_bridge(pci_dev))
+	if (!pci_has_subordinate(pci_dev))
 		pci_enable_wake(pci_dev, PCI_D0, false);
 }
 
 static void pci_pm_default_suspend(struct pci_dev *pci_dev)
 {
 	/* Disable non-bridge devices without PM support */
-	if (!pci_is_bridge(pci_dev))
+	if (!pci_has_subordinate(pci_dev))
 		pci_disable_enabled_device(pci_dev);
 }
 
@@ -717,7 +717,7 @@ static int pci_pm_suspend_noirq(struct device *dev)
 
 	if (!pci_dev->state_saved) {
 		pci_save_state(pci_dev);
-		if (!pci_is_bridge(pci_dev))
+		if (!pci_has_subordinate(pci_dev))
 			pci_prepare_to_sleep(pci_dev);
 	}
 
@@ -971,7 +971,7 @@ static int pci_pm_poweroff_noirq(struct device *dev)
 			return error;
 	}
 
-	if (!pci_dev->state_saved && !pci_is_bridge(pci_dev))
+	if (!pci_dev->state_saved && !pci_has_subordinate(pci_dev))
 		pci_prepare_to_sleep(pci_dev);
 
 	/*

commit efdd4070f38e962d69c11f23c5aa033121a8cf0f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Apr 5 15:08:22 2014 -0600

    PCI: Remove dead code
    
    "pdev" can never be NULL here, so remove the test.
    
    Found by Coverity (CID 744313).
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 650ce8935fd7..ff236ed4f5cf 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1345,8 +1345,6 @@ static int pci_uevent(struct device *dev, struct kobj_uevent_env *env)
 		return -ENODEV;
 
 	pdev = to_pci_dev(dev);
-	if (!pdev)
-		return -ENODEV;
 
 	if (add_uevent_var(env, "PCI_CLASS=%04X", pdev->class))
 		return -ENOMEM;
@@ -1367,6 +1365,7 @@ static int pci_uevent(struct device *dev, struct kobj_uevent_env *env)
 			   (u8)(pdev->class >> 16), (u8)(pdev->class >> 8),
 			   (u8)(pdev->class)))
 		return -ENOMEM;
+
 	return 0;
 }
 

commit 8895d3bcb8ba960b1b83f95d772b641352ea8e51
Author: Bandan Das <bsd@redhat.com>
Date:   Tue Apr 1 21:32:59 2014 -0400

    PCI: Fail new_id for vendor/device values already built into driver
    
    While using the sysfs new_id interface, the user can unintentionally feed
    incorrect values if the driver static table has a matching entry.  This is
    possible since only the device and vendor fields are mandatory and the rest
    are optional.  As a result, store_new_id() will fill in default values that
    are then passed on to the driver and can have unintended consequences.
    
    As an example, consider the ixgbe driver and the 82599EB network card:
    
      echo "8086 10fb" > /sys/bus/pci/drivers/ixgbe/new_id
    
    This will pass a pci_device_id with driver_data = 0 to ixgbe_probe(), which
    uses that zero to index a table of card operations.  The zeroth entry of
    the table does *not* correspond to the 82599 operations.
    
    This change returns an error if the user attempts to add a dynid for a
    vendor/device combination for which a static entry already exists.
    However, if the user intentionally wants a different set of values, she
    must provide all the 7 fields and that will be accepted.
    
    [bhelgaas: drop KVM text since the problem isn't KVM-specific]
    Signed-off-by: Bandan Das <bsd@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index d911e0c1f359..650ce8935fd7 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -107,7 +107,7 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 		subdevice=PCI_ANY_ID, class=0, class_mask=0;
 	unsigned long driver_data=0;
 	int fields=0;
-	int retval;
+	int retval = 0;
 
 	fields = sscanf(buf, "%x %x %x %x %x %x %lx",
 			&vendor, &device, &subvendor, &subdevice,
@@ -115,6 +115,26 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 	if (fields < 2)
 		return -EINVAL;
 
+	if (fields != 7) {
+		struct pci_dev *pdev = kzalloc(sizeof(*pdev), GFP_KERNEL);
+		if (!pdev)
+			return -ENOMEM;
+
+		pdev->vendor = vendor;
+		pdev->device = device;
+		pdev->subsystem_vendor = subvendor;
+		pdev->subsystem_device = subdevice;
+		pdev->class = class;
+
+		if (pci_match_id(pdrv->id_table, pdev))
+			retval = -EEXIST;
+
+		kfree(pdev);
+
+		if (retval)
+			return retval;
+	}
+
 	/* Only accept driver_data values that match an existing id_table
 	   entry */
 	if (ids) {

commit 7cd0602d7836c0056fe9bdab014d5ac5ec5cb291
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 26 01:00:30 2014 +0100

    PCI / PM: Resume runtime-suspended devices later during system suspend
    
    Runtime-suspended devices are resumed during system suspend by
    pci_pm_prepare() for two reasons: First, because they may need
    to be reprogrammed in order to change their wakeup settings and,
    second, because they may need to be operatonal for their children
    to be successfully suspended.  That is a problem, though, if there
    are many runtime-suspended devices that need to be resumed this
    way during system suspend, because the .prepare() PM callbacks of
    devices are executed sequentially and the times taken by them
    accumulate, which may increase the total system suspend time quite
    a bit.
    
    For this reason, move the resume of runtime-suspended devices up
    to the next phase of device suspend (during system suspend), except
    for the ones that have power.ignore_children set.  The exception is
    made, because the devices with power.ignore_children set may still
    be necessary for their children to be successfully suspended (during
    system suspend) and they won't be resumed automatically as a result
    of the runtime resume of their children.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 25f0bc659164..d911e0c1f359 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -616,15 +616,11 @@ static int pci_pm_prepare(struct device *dev)
 	int error = 0;
 
 	/*
-	 * PCI devices suspended at run time need to be resumed at this
-	 * point, because in general it is necessary to reconfigure them for
-	 * system suspend.  Namely, if the device is supposed to wake up the
-	 * system from the sleep state, we may need to reconfigure it for this
-	 * purpose.  In turn, if the device is not supposed to wake up the
-	 * system from the sleep state, we'll have to prevent it from signaling
-	 * wake-up.
+	 * Devices having power.ignore_children set may still be necessary for
+	 * suspending their children in the next phase of device suspend.
 	 */
-	pm_runtime_resume(dev);
+	if (dev->power.ignore_children)
+		pm_runtime_resume(dev);
 
 	if (drv && drv->pm && drv->pm->prepare)
 		error = drv->pm->prepare(dev);
@@ -654,6 +650,16 @@ static int pci_pm_suspend(struct device *dev)
 		goto Fixup;
 	}
 
+	/*
+	 * PCI devices suspended at run time need to be resumed at this point,
+	 * because in general it is necessary to reconfigure them for system
+	 * suspend.  Namely, if the device is supposed to wake up the system
+	 * from the sleep state, we may need to reconfigure it for this purpose.
+	 * In turn, if the device is not supposed to wake up the system from the
+	 * sleep state, we'll have to prevent it from signaling wake-up.
+	 */
+	pm_runtime_resume(dev);
+
 	pci_dev->state_saved = false;
 	if (pm->suspend) {
 		pci_power_t prev = pci_dev->current_state;
@@ -808,6 +814,14 @@ static int pci_pm_freeze(struct device *dev)
 		return 0;
 	}
 
+	/*
+	 * This used to be done in pci_pm_prepare() for all devices and some
+	 * drivers may depend on it, so do it here.  Ideally, runtime-suspended
+	 * devices should not be touched during freeze/thaw transitions,
+	 * however.
+	 */
+	pm_runtime_resume(dev);
+
 	pci_dev->state_saved = false;
 	if (pm->freeze) {
 		int error;
@@ -915,6 +929,9 @@ static int pci_pm_poweroff(struct device *dev)
 		goto Fixup;
 	}
 
+	/* The reason to do that is the same as in pci_pm_suspend(). */
+	pm_runtime_resume(dev);
+
 	pci_dev->state_saved = false;
 	if (pm->poweroff) {
 		int error;

commit 4fc9bbf98fd66f879e628d8537ba7c240be2b58e
Author: Khalid Aziz <khalid.aziz@oracle.com>
Date:   Wed Nov 27 15:19:25 2013 -0700

    PCI: Disable Bus Master only on kexec reboot
    
    Add a flag to tell the PCI subsystem that kernel is shutting down in
    preparation to kexec a kernel.  Add code in PCI subsystem to use this flag
    to clear Bus Master bit on PCI devices only in case of kexec reboot.
    
    This fixes a power-off problem on Acer Aspire V5-573G and likely other
    machines and avoids any other issues caused by clearing Bus Master bit on
    PCI devices in normal shutdown path.  The problem was introduced by
    b566a22c2332 ("PCI: disable Bus Master on PCI device shutdown").
    
    This patch is based on discussion at
    http://marc.info/?l=linux-pci&m=138425645204355&w=2
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=63861
    Reported-by: Chang Liu <cl91tp@gmail.com>
    Signed-off-by: Khalid Aziz <khalid.aziz@oracle.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Konstantin Khlebnikov <koct9i@gmail.com>
    Cc: stable@vger.kernel.org      # v3.5+

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 7edd5c307446..25f0bc659164 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -19,6 +19,7 @@
 #include <linux/cpu.h>
 #include <linux/pm_runtime.h>
 #include <linux/suspend.h>
+#include <linux/kexec.h>
 #include "pci.h"
 
 struct pci_dynid {
@@ -415,12 +416,17 @@ static void pci_device_shutdown(struct device *dev)
 	pci_msi_shutdown(pci_dev);
 	pci_msix_shutdown(pci_dev);
 
+#ifdef CONFIG_KEXEC
 	/*
-	 * Turn off Bus Master bit on the device to tell it to not
-	 * continue to do DMA. Don't touch devices in D3cold or unknown states.
+	 * If this is a kexec reboot, turn off Bus Master bit on the
+	 * device to tell it to not continue to do DMA. Don't touch
+	 * devices in D3cold or unknown states.
+	 * If it is not a kexec reboot, firmware will hit the PCI
+	 * devices with big hammer and stop their DMA any way.
 	 */
-	if (pci_dev->current_state <= PCI_D3hot)
+	if (kexec_in_progress && (pci_dev->current_state <= PCI_D3hot))
 		pci_clear_master(pci_dev);
+#endif
 }
 
 #ifdef CONFIG_PM

commit 12c3156f10c5d8c5f1fb3f0bbdb8c1ddb1d1f65c
Author: Alexander Duyck <alexander.h.duyck@intel.com>
Date:   Mon Nov 18 10:59:59 2013 -0700

    PCI: Avoid unnecessary CPU switch when calling driver .probe() method
    
    If we are already on a CPU local to the device, call the driver .probe()
    method directly without using work_on_cpu().
    
    This is a workaround for a lockdep warning in the following scenario:
    
      pci_call_probe
        work_on_cpu(cpu, local_pci_probe, ...)
          driver .probe
            pci_enable_sriov
              ...
                pci_bus_add_device
                  ...
                    pci_call_probe
                      work_on_cpu(cpu, local_pci_probe, ...)
    
    It would be better to fix PCI so we don't call VF driver .probe() methods
    from inside a PF driver .probe() method, but that's a bigger project.
    
    [bhelgaas: open bugzilla, rework comments & changelog]
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=65071
    Link: http://lkml.kernel.org/r/CAE9FiQXYQEAZ=0sG6+2OdffBqfLS9MpoN1xviRR9aDbxPxcKxQ@mail.gmail.com
    Link: http://lkml.kernel.org/r/20130624195942.40795.27292.stgit@ahduyck-cp1.jf.intel.com
    Tested-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 9042fdbd7244..7edd5c307446 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -288,12 +288,27 @@ static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
 	int error, node;
 	struct drv_dev_and_id ddi = { drv, dev, id };
 
-	/* Execute driver initialization on node where the device's
-	   bus is attached to.  This way the driver likely allocates
-	   its local memory on the right node without any need to
-	   change it. */
+	/*
+	 * Execute driver initialization on node where the device is
+	 * attached.  This way the driver likely allocates its local memory
+	 * on the right node.
+	 */
 	node = dev_to_node(&dev->dev);
-	if (node >= 0) {
+
+	/*
+	 * On NUMA systems, we are likely to call a PF probe function using
+	 * work_on_cpu().  If that probe calls pci_enable_sriov() (which
+	 * adds the VF devices via pci_bus_add_device()), we may re-enter
+	 * this function to call the VF probe function.  Calling
+	 * work_on_cpu() again will cause a lockdep warning.  Since VFs are
+	 * always on the same node as the PF, we can work around this by
+	 * avoiding work_on_cpu() when we're already on the correct node.
+	 *
+	 * Preemption is enabled, so it's theoretically unsafe to use
+	 * numa_node_id(), but even if we run the probe function on the
+	 * wrong node, it should be functionally correct.
+	 */
+	if (node >= 0 && node != numa_node_id()) {
 		int cpu;
 
 		get_online_cpus();
@@ -305,6 +320,7 @@ static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
 		put_online_cpus();
 	} else
 		error = local_pci_probe(&ddi);
+
 	return error;
 }
 

commit f7625980f5820edd1a73536e1a03bcbc1f889fec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 14 11:28:18 2013 -0700

    PCI: Fix whitespace, capitalization, and spelling errors
    
    Fix whitespace, capitalization, and spelling errors.  No functional change.
    I know "busses" is not an error, but "buses" was more common, so I used it
    consistently.
    
    Signed-off-by: Marta Rybczynska <rybczynska@gmail.com> (pci_reset_bridge_secondary_bus())
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 454853507b7e..9042fdbd7244 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -312,7 +312,7 @@ static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
  * __pci_device_probe - check if a driver wants to claim a specific PCI device
  * @drv: driver to call to check if it wants the PCI device
  * @pci_dev: PCI device being probed
- * 
+ *
  * returns 0 on success, else error.
  * side-effect: pci_dev->driver is set to drv when drv claims pci_dev.
  */
@@ -378,7 +378,7 @@ static int pci_device_remove(struct device * dev)
 	 * We would love to complain here if pci_dev->is_enabled is set, that
 	 * the driver should have called pci_disable_device(), but the
 	 * unfortunate fact is there are too many odd BIOS and bridge setups
-	 * that don't like drivers doing that all of the time.  
+	 * that don't like drivers doing that all of the time.
 	 * Oh well, we can dream of sane hardware when we sleep, no matter how
 	 * horrible the crap we have to deal with is when we are awake...
 	 */
@@ -1156,10 +1156,10 @@ static const struct dev_pm_ops pci_dev_pm_ops = {
  * @drv: the driver structure to register
  * @owner: owner module of drv
  * @mod_name: module name string
- * 
+ *
  * Adds the driver structure to the list of registered drivers.
- * Returns a negative value on error, otherwise 0. 
- * If no error occurred, the driver remains registered even if 
+ * Returns a negative value on error, otherwise 0.
+ * If no error occurred, the driver remains registered even if
  * no device was claimed during registration.
  */
 int __pci_register_driver(struct pci_driver *drv, struct module *owner,
@@ -1181,7 +1181,7 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 /**
  * pci_unregister_driver - unregister a pci driver
  * @drv: the driver structure to unregister
- * 
+ *
  * Deletes the driver structure from the list of registered PCI drivers,
  * gives it a chance to clean up by calling its remove() function for
  * each device it was responsible for, and marks those devices as
@@ -1203,7 +1203,7 @@ static struct pci_driver pci_compat_driver = {
  * pci_dev_driver - get the pci_driver of a device
  * @dev: the device to query
  *
- * Returns the appropriate pci_driver structure or %NULL if there is no 
+ * Returns the appropriate pci_driver structure or %NULL if there is no
  * registered driver for the device.
  */
 struct pci_driver *
@@ -1224,7 +1224,7 @@ pci_dev_driver(const struct pci_dev *dev)
  * pci_bus_match - Tell if a PCI device structure has a matching PCI device id structure
  * @dev: the PCI device structure to match against
  * @drv: the device driver to search for matching PCI device id structures
- * 
+ *
  * Used by a driver to check whether a PCI device present in the
  * system is in its list of supported devices. Returns the matching
  * pci_device_id structure or %NULL if there is no match.

commit c245f2422031fec447e4d9e35fb0ef0fd5e42ab9
Merge: 589a1b076ff9 f92d74c1f5af
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Nov 6 16:26:48 2013 -0700

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Warn on driver probe return value greater than zero
      PCI: Drop warning about drivers that don't use pci_set_master()
      PCI: Workaround missing pci_set_master in pci drivers
      PCI: Update pcie_ports 'auto' behavior for non-ACPI platforms

commit f92d74c1f5afaff7cd1ea14ade8f1ba6b519e422
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Fri Nov 1 14:34:55 2013 -0500

    PCI: Warn on driver probe return value greater than zero
    
    Ages ago, drivers could return values greater than zero from their probe
    function and this would be regarded as success.
    
    But after f3ec4f87d607 ("PCI: change device runtime PM settings for probe
    and remove") and 967577b06241 ("PCI/PM: Keep runtime PM enabled for unbound
    PCI devices"), we set dev->driver to NULL if the driver's probe function
    returns a value greater than zero.
    
    __pci_device_probe() treats this as success, and drivers can still mostly
    work even with dev->driver == NULL, but PCI power management doesn't work,
    and we don't call the driver's remove function on rmmod.
    
    To help catch these driver problems, issue a warning in this case.
    
    [bhelgaas: changelog]
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index b60fe6737f78..0929ae3e7830 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -264,11 +264,19 @@ static long local_pci_probe(void *_ddi)
 	pm_runtime_get_sync(dev);
 	pci_dev->driver = pci_drv;
 	rc = pci_drv->probe(pci_dev, ddi->id);
-	if (rc) {
+	if (!rc)
+		return rc;
+	if (rc < 0) {
 		pci_dev->driver = NULL;
 		pm_runtime_put_sync(dev);
+		return rc;
 	}
-	return rc;
+	/*
+	 * Probe function should return < 0 for failure, 0 for success
+	 * Treat values > 0 as success, but warn.
+	 */
+	dev_warn(dev, "Driver probe function unexpectedly returned %d\n", rc);
+	return 0;
 }
 
 static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,

commit 33de1b8bf6e11a3bc69faf2f7ffb3692c723bdf5
Merge: cc17a67c0762 0394cb192db4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Oct 31 14:12:40 2013 -0600

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Report pci_pme_active() kmalloc failure
      mn10300/PCI: Remove useless pcibios_last_bus
      frv/PCI: Remove pcibios_last_bus
      PCI: Fail MSI/MSI-X initialization if device is not in PCI_D0
      x86/PCI: Coalesce multiple overlapping host bridge windows
      MAINTAINERS: Add arch/x86/pci to PCI file patterns
      PCI/PM: Remove pci_pm_complete()
      PCI: Add pci_dev_show_local_cpu() to simplify code
      mn10300/PCI: Remove unused pci_mem_start
      cris/PCI: Remove unused pci_mem_start
      PCI: Make pci_dev_pm_ops static
    
    Conflicts:
            drivers/pci/pci-sysfs.c

commit 84822b158fd3fc7d9f9c67f1b26a1e007880e13c
Author: Liu Chuansheng <chuansheng.liu@intel.com>
Date:   Mon Oct 7 15:29:27 2013 -0600

    PCI/PM: Remove pci_pm_complete()
    
    88d26136 ("PM: Prevent runtime suspend during system resume") removed the
    pm_runtime_put_sync() from pci_pm_complete() to PM core code
    device_complete().
    
    Here the pci_pm_complete() is doing the same work which can be done in
    device_complete(), so we can remove it directly.
    
    Signed-off-by: Liu Chuansheng <chuansheng.liu@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 32b6bc5a23ac..b60fe6737f78 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -599,18 +599,10 @@ static int pci_pm_prepare(struct device *dev)
 	return error;
 }
 
-static void pci_pm_complete(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-
-	if (drv && drv->pm && drv->pm->complete)
-		drv->pm->complete(dev);
-}
 
 #else /* !CONFIG_PM_SLEEP */
 
 #define pci_pm_prepare	NULL
-#define pci_pm_complete	NULL
 
 #endif /* !CONFIG_PM_SLEEP */
 
@@ -1123,7 +1115,6 @@ static int pci_pm_runtime_idle(struct device *dev)
 
 static const struct dev_pm_ops pci_dev_pm_ops = {
 	.prepare = pci_pm_prepare,
-	.complete = pci_pm_complete,
 	.suspend = pci_pm_suspend,
 	.resume = pci_pm_resume,
 	.freeze = pci_pm_freeze,

commit f91da04d0aebf8edbcd2fde5f9d7df85a0b6f6cd
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Fri Oct 4 12:04:44 2013 -0600

    PCI: Make pci_dev_pm_ops static
    
    pci_dev_pm_ops is local to pci-driver.c.  Make it static.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 98f7b9b89507..32b6bc5a23ac 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1121,7 +1121,7 @@ static int pci_pm_runtime_idle(struct device *dev)
 
 #ifdef CONFIG_PM
 
-const struct dev_pm_ops pci_dev_pm_ops = {
+static const struct dev_pm_ops pci_dev_pm_ops = {
 	.prepare = pci_pm_prepare,
 	.complete = pci_pm_complete,
 	.suspend = pci_pm_suspend,

commit 5136b2da770d53f026ab091f0423729ebf37a6b5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Oct 6 23:55:40 2013 -0700

    PCI: convert bus code to use dev_groups
    
    The dev_attrs field of struct bus_type is going away soon, dev_groups
    should be used instead.  This converts the PCI bus code to use the
    correct field.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 38f3c0140dfb..9f85960a62ed 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1319,7 +1319,7 @@ struct bus_type pci_bus_type = {
 	.probe		= pci_device_probe,
 	.remove		= pci_device_remove,
 	.shutdown	= pci_device_shutdown,
-	.dev_attrs	= pci_dev_attrs,
+	.dev_groups	= pci_dev_groups,
 	.bus_groups	= pci_bus_groups,
 	.drv_groups	= pci_drv_groups,
 	.pm		= PCI_PM_OPS_PTR,

commit 2229c1fbc5bd3bd7eb376285de159d086e79d58a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Oct 7 14:51:20 2013 -0600

    PCI: convert bus code to use drv_groups
    
    The drv_attrs field of struct bus_type is going away soon, drv_groups
    should be used instead.  This converts the PCI bus code to use the
    correct field.
    
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index e00f74143115..38f3c0140dfb 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -135,6 +135,7 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 		return retval;
 	return count;
 }
+static DRIVER_ATTR(new_id, S_IWUSR, NULL, store_new_id);
 
 /**
  * store_remove_id - remove a PCI device ID from this driver
@@ -180,12 +181,14 @@ store_remove_id(struct device_driver *driver, const char *buf, size_t count)
 		return retval;
 	return count;
 }
+static DRIVER_ATTR(remove_id, S_IWUSR, NULL, store_remove_id);
 
-static struct driver_attribute pci_drv_attrs[] = {
-	__ATTR(new_id, S_IWUSR, NULL, store_new_id),
-	__ATTR(remove_id, S_IWUSR, NULL, store_remove_id),
-	__ATTR_NULL,
+static struct attribute *pci_drv_attrs[] = {
+	&driver_attr_new_id.attr,
+	&driver_attr_remove_id.attr,
+	NULL,
 };
+ATTRIBUTE_GROUPS(pci_drv);
 
 /**
  * pci_match_id - See if a pci device matches a given pci_id table
@@ -1318,7 +1321,7 @@ struct bus_type pci_bus_type = {
 	.shutdown	= pci_device_shutdown,
 	.dev_attrs	= pci_dev_attrs,
 	.bus_groups	= pci_bus_groups,
-	.drv_attrs	= pci_drv_attrs,
+	.drv_groups	= pci_drv_groups,
 	.pm		= PCI_PM_OPS_PTR,
 };
 

commit 0f49ba5599048aae2fb3479a1814736e969cf38c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Oct 7 14:51:02 2013 -0600

    PCI: convert bus code to use bus_groups
    
    The bus_attrs field of struct bus_type is going away soon, dev_groups
    should be used instead.  This converts the PCI bus code to use the
    correct field.
    
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 98f7b9b89507..e00f74143115 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1317,7 +1317,7 @@ struct bus_type pci_bus_type = {
 	.remove		= pci_device_remove,
 	.shutdown	= pci_device_shutdown,
 	.dev_attrs	= pci_dev_attrs,
-	.bus_attrs	= pci_bus_attrs,
+	.bus_groups	= pci_bus_groups,
 	.drv_attrs	= pci_drv_attrs,
 	.pm		= PCI_PM_OPS_PTR,
 };

commit 699c1985587aad3432c5ae19801efb4186db8b7a
Author: Sebastian Ott <sebott@linux.vnet.ibm.com>
Date:   Tue Aug 20 16:41:02 2013 +0200

    PCI: Add pcibios_pm_ops for optional arch-specific hibernate functionality
    
    Platforms may want to provide architecture-specific functionality when
    a PCI device is doing a hibernate transition.  Add a weak symbol
    pcibios_pm_ops that architectures can override to do so.
    
    [bhelgaas: fold in return value checks from v2 patch]
    Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index e6515e21afa3..98f7b9b89507 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -763,6 +763,13 @@ static int pci_pm_resume(struct device *dev)
 
 #ifdef CONFIG_HIBERNATE_CALLBACKS
 
+
+/*
+ * pcibios_pm_ops - provide arch-specific hooks when a PCI device is doing
+ * a hibernate transition
+ */
+struct dev_pm_ops __weak pcibios_pm_ops;
+
 static int pci_pm_freeze(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
@@ -786,6 +793,9 @@ static int pci_pm_freeze(struct device *dev)
 			return error;
 	}
 
+	if (pcibios_pm_ops.freeze)
+		return pcibios_pm_ops.freeze(dev);
+
 	return 0;
 }
 
@@ -811,6 +821,9 @@ static int pci_pm_freeze_noirq(struct device *dev)
 
 	pci_pm_set_unknown_state(pci_dev);
 
+	if (pcibios_pm_ops.freeze_noirq)
+		return pcibios_pm_ops.freeze_noirq(dev);
+
 	return 0;
 }
 
@@ -820,6 +833,12 @@ static int pci_pm_thaw_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	if (pcibios_pm_ops.thaw_noirq) {
+		error = pcibios_pm_ops.thaw_noirq(dev);
+		if (error)
+			return error;
+	}
+
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
 
@@ -837,6 +856,12 @@ static int pci_pm_thaw(struct device *dev)
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 	int error = 0;
 
+	if (pcibios_pm_ops.thaw) {
+		error = pcibios_pm_ops.thaw(dev);
+		if (error)
+			return error;
+	}
+
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume(dev);
 
@@ -878,6 +903,9 @@ static int pci_pm_poweroff(struct device *dev)
  Fixup:
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
 
+	if (pcibios_pm_ops.poweroff)
+		return pcibios_pm_ops.poweroff(dev);
+
 	return 0;
 }
 
@@ -911,6 +939,9 @@ static int pci_pm_poweroff_noirq(struct device *dev)
 	if (pci_dev->class == PCI_CLASS_SERIAL_USB_EHCI)
 		pci_write_config_word(pci_dev, PCI_COMMAND, 0);
 
+	if (pcibios_pm_ops.poweroff_noirq)
+		return pcibios_pm_ops.poweroff_noirq(dev);
+
 	return 0;
 }
 
@@ -920,6 +951,12 @@ static int pci_pm_restore_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	if (pcibios_pm_ops.restore_noirq) {
+		error = pcibios_pm_ops.restore_noirq(dev);
+		if (error)
+			return error;
+	}
+
 	pci_pm_default_resume_early(pci_dev);
 
 	if (pci_has_legacy_pm_support(pci_dev))
@@ -937,6 +974,12 @@ static int pci_pm_restore(struct device *dev)
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 	int error = 0;
 
+	if (pcibios_pm_ops.restore) {
+		error = pcibios_pm_ops.restore(dev);
+		if (error)
+			return error;
+	}
+
 	/*
 	 * This is necessary for the hibernation error path in which restore is
 	 * called without restoring the standard config registers of the device.

commit 45f0a85c8258741d11bda25c0a5669c06267204a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 3 21:49:52 2013 +0200

    PM / Runtime: Rework the "runtime idle" helper routine
    
    The "runtime idle" helper routine, rpm_idle(), currently ignores
    return values from .runtime_idle() callbacks executed by it.
    However, it turns out that many subsystems use
    pm_generic_runtime_idle() which checks the return value of the
    driver's callback and executes pm_runtime_suspend() for the device
    unless that value is not 0.  If that logic is moved to rpm_idle()
    instead, pm_generic_runtime_idle() can be dropped and its users
    will not need any .runtime_idle() callbacks any more.
    
    Moreover, the PCI, SCSI, and SATA subsystems' .runtime_idle()
    routines, pci_pm_runtime_idle(), scsi_runtime_idle(), and
    ata_port_runtime_idle(), respectively, as well as a few drivers'
    ones may be simplified if rpm_idle() calls rpm_suspend() after 0 has
    been returned by the .runtime_idle() callback executed by it.
    
    To reduce overall code bloat, make the changes described above.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 79277fb36c6b..e6515e21afa3 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1050,26 +1050,22 @@ static int pci_pm_runtime_idle(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+	int ret = 0;
 
 	/*
 	 * If pci_dev->driver is not set (unbound), the device should
 	 * always remain in D0 regardless of the runtime PM status
 	 */
 	if (!pci_dev->driver)
-		goto out;
+		return 0;
 
 	if (!pm)
 		return -ENOSYS;
 
-	if (pm->runtime_idle) {
-		int ret = pm->runtime_idle(dev);
-		if (ret)
-			return ret;
-	}
+	if (pm->runtime_idle)
+		ret = pm->runtime_idle(dev);
 
-out:
-	pm_runtime_suspend(dev);
-	return 0;
+	return ret;
 }
 
 #else /* !CONFIG_PM_RUNTIME */

commit 6e0eda3c389887168455b92b6f7b48f552227067
Author: Konstantin Khlebnikov <khlebnikov@openvz.org>
Date:   Thu Mar 14 18:49:37 2013 +0400

    PCI: Don't try to disable Bus Master on disconnected PCI devices
    
    This is a fix for commit 7897e60227 ("PCI: Disable Bus Master
    unconditionally in pci_device_shutdown()").  Vivek reported that
    with this commit, kexec failed because none of his SATA disks
    came up.
    
    A ->shutdown() callback might put the device in D3cold, which means config
    space is no longer available.
    
    [bhelgaas: changelog]
    Link: https://lkml.org/lkml/2013/3/12/529
    Reported-and-Tested-by: Vivek Goyal <vgoyal@redhat.com>
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@openvz.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 1fa1e482a999..79277fb36c6b 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -390,9 +390,10 @@ static void pci_device_shutdown(struct device *dev)
 
 	/*
 	 * Turn off Bus Master bit on the device to tell it to not
-	 * continue to do DMA
+	 * continue to do DMA. Don't touch devices in D3cold or unknown states.
 	 */
-	pci_clear_master(pci_dev);
+	if (pci_dev->current_state <= PCI_D3hot)
+		pci_clear_master(pci_dev);
 }
 
 #ifdef CONFIG_PM

commit 20f24208f631141bafe57ce5bcc8f2e7f3c41aae
Merge: f2dfcde4ccd1 82fee4d67ab8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Feb 12 13:42:36 2013 -0700

    Merge branch 'pci/konstantin-runtime-pm' into next
    
    * pci/konstantin-runtime-pm:
      PCI/PM: Clear state_saved during suspend
      PCI: Use atomic_inc_return() rather than atomic_add_return()
      PCI: Catch attempts to disable already-disabled devices
      PCI: Disable Bus Master unconditionally in pci_device_shutdown()

commit 82fee4d67ab86d6fe5eb0f9a9e988ca9d654d765
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Feb 4 15:56:05 2013 +0400

    PCI/PM: Clear state_saved during suspend
    
    This patch clears pci_dev->state_saved at the beginning of suspending.
    PCI config state may be saved long before that.  Some drivers call
    pci_save_state() from the ->probe() callback to get snapshot of sane
    configuration space to use in the ->slot_reset() callback.
    
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@openvz.org> # add comment
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index dc5bdce63f12..f9aa311b9f34 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -628,6 +628,7 @@ static int pci_pm_suspend(struct device *dev)
 		goto Fixup;
 	}
 
+	pci_dev->state_saved = false;
 	if (pm->suspend) {
 		pci_power_t prev = pci_dev->current_state;
 		int error;
@@ -774,6 +775,7 @@ static int pci_pm_freeze(struct device *dev)
 		return 0;
 	}
 
+	pci_dev->state_saved = false;
 	if (pm->freeze) {
 		int error;
 
@@ -862,6 +864,7 @@ static int pci_pm_poweroff(struct device *dev)
 		goto Fixup;
 	}
 
+	pci_dev->state_saved = false;
 	if (pm->poweroff) {
 		int error;
 
@@ -987,6 +990,7 @@ static int pci_pm_runtime_suspend(struct device *dev)
 	if (!pm || !pm->runtime_suspend)
 		return -ENOSYS;
 
+	pci_dev->state_saved = false;
 	pci_dev->no_d3cold = false;
 	error = pm->runtime_suspend(dev);
 	suspend_report_result(pm->runtime_suspend, error);

commit 7897e6022761ace7377f0f784fca059da55f5d71
Author: Konstantin Khlebnikov <khlebnikov@openvz.org>
Date:   Mon Feb 4 15:55:58 2013 +0400

    PCI: Disable Bus Master unconditionally in pci_device_shutdown()
    
    Commit b566a22c23 ("PCI: disable Bus Master on PCI device shutdown")
    used pci_disable_device(), but that doesn't disable Bus Mastering
    unconditionally; we allow nested enable/disable calls, and only the
    last disable call actually does anything.
    
    This uses pci_clear_master() to unconditionally clear the Bus Master
    bit.
    
    Matthew Garrett and Alan Cox said (see LKML link below) that clearing Bus
    Master for all PCI devices may lead to unpredictable consequences: some
    devices ignores this bit and continue DMA, some of them hang after that or
    crash the whole system.  But we're already trying to clear Bus Master in
    general because of b566a22c23; this merely deals with the cases where
    drivers haven't shut down the device correctly.
    
    [bhelgaas: changelog]
    Link: https://lkml.org/lkml/2012/6/6/278
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@openvz.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index f79cbcd3944b..dc5bdce63f12 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -392,7 +392,7 @@ static void pci_device_shutdown(struct device *dev)
 	 * Turn off Bus Master bit on the device to tell it to not
 	 * continue to do DMA
 	 */
-	pci_disable_device(pci_dev);
+	pci_clear_master(pci_dev);
 }
 
 #ifdef CONFIG_PM

commit 58d9a38f6facb28e935ec2747f6d9e9bf4684118
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jan 21 13:20:51 2013 -0800

    PCI: Skip attaching driver in device_add()
    
    We want to add PCI devices to the device tree as early as possible but
    delay attaching drivers.
    
    device_add() adds a device to the device hierarchy and (via
    device_attach()) attaches a matching driver and calls its .probe() method.
    We want to separate adding the device to the hierarchy from attaching the
    driver.
    
    This patch does that by adding "match_driver" in struct pci_dev.  When
    false, we return failure from pci_bus_match(), which makes device_attach()
    believe there's no matching driver.
    
    Later, we set "match_driver = true" and call device_attach() again, which
    now attaches the driver and calls its .probe() method.
    
    [bhelgaas: changelog, explicitly init dev->match_driver,
    fold device_attach() call into pci_bus_add_device()]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index f79cbcd3944b..acdcc3c6ecdd 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1186,9 +1186,13 @@ pci_dev_driver(const struct pci_dev *dev)
 static int pci_bus_match(struct device *dev, struct device_driver *drv)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct pci_driver *pci_drv = to_pci_driver(drv);
+	struct pci_driver *pci_drv;
 	const struct pci_device_id *found_id;
 
+	if (!pci_dev->match_driver)
+		return 0;
+
+	pci_drv = to_pci_driver(drv);
 	found_id = pci_match_device(pci_drv, pci_dev);
 	if (found_id)
 		return 1;

commit 193c0d682525987db59ac3a24531a77e4947aa95
Merge: 8b0cab14951f 1cb73f8c479e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 13 12:14:47 2012 -0800

    Merge tag 'for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI update from Bjorn Helgaas:
     "Host bridge hotplug:
       - Untangle _PRT from struct pci_bus (Bjorn Helgaas)
       - Request _OSC control before scanning root bus (Taku Izumi)
       - Assign resources when adding host bridge (Yinghai Lu)
       - Remove root bus when removing host bridge (Yinghai Lu)
       - Remove _PRT during hot remove (Yinghai Lu)
    
      SRIOV
        - Add sysfs knobs to control numVFs (Don Dutile)
    
      Power management
       - Notify devices when power resource turned on (Huang Ying)
    
      Bug fixes
       - Work around broken _SEG on HP xw9300 (Bjorn Helgaas)
       - Keep runtime PM enabled for unbound PCI devices (Huang Ying)
       - Fix Optimus dual-GPU runtime D3 suspend issue (Dave Airlie)
       - Fix xen frontend shutdown issue (David Vrabel)
       - Work around PLX PCI 9050 BAR alignment erratum (Ian Abbott)
    
      Miscellaneous
       - Add GPL license for drivers/pci/ioapic (Andrew Cooks)
       - Add standard PCI-X, PCIe ASPM register #defines (Bjorn Helgaas)
       - NumaChip remote PCI support (Daniel Blueman)
       - Fix PCIe Link Capabilities Supported Link Speed definition (Jingoo
         Han)
       - Convert dev_printk() to dev_info(), etc (Joe Perches)
       - Add support for non PCI BAR ROM data (Matthew Garrett)
       - Add x86 support for host bridge translation offset (Mike Yoknis)
       - Report success only when every driver supports AER (Vijay
         Pandarathil)"
    
    Fix up trivial conflicts.
    
    * tag 'for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (48 commits)
      PCI: Use phys_addr_t for physical ROM address
      x86/PCI: Add NumaChip remote PCI support
      ath9k: Use standard #defines for PCIe Capability ASPM fields
      iwlwifi: Use standard #defines for PCIe Capability ASPM fields
      iwlwifi: collapse wrapper for pcie_capability_read_word()
      iwlegacy: Use standard #defines for PCIe Capability ASPM fields
      iwlegacy: collapse wrapper for pcie_capability_read_word()
      cxgb3: Use standard #defines for PCIe Capability ASPM fields
      PCI: Add standard PCIe Capability Link ASPM field names
      PCI/portdrv: Use PCI Express Capability accessors
      PCI: Use standard PCIe Capability Link register field names
      x86: Use PCI setup data
      PCI: Add support for non-BAR ROMs
      PCI: Add pcibios_add_device
      EFI: Stash ROMs if they're not in the PCI BAR
      PCI: Add and use standard PCI-X Capability register names
      PCI/PM: Keep runtime PM enabled for unbound PCI devices
      xen-pcifront: Handle backend CLOSED without CLOSING
      PCI: SRIOV control and status via sysfs (documentation)
      PCI/AER: Report success only when every device has AER-aware driver
      ...

commit edb1daab8e91338b7e2a6c41faec695891ccda35
Merge: be5cd530bd23 967577b06241
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Dec 4 16:13:03 2012 -0700

    Merge branch 'pci/huang-d3cold-fixes' into next
    
    * pci/huang-d3cold-fixes:
      PCI/PM: Keep runtime PM enabled for unbound PCI devices

commit 967577b062417b4e4b8e27b711220f4124f5153a
Author: Huang Ying <ying.huang@intel.com>
Date:   Tue Nov 20 16:08:22 2012 +0800

    PCI/PM: Keep runtime PM enabled for unbound PCI devices
    
    For unbound PCI devices, what we need is:
    
     - Always in D0 state, because some devices do not work again after
       being put into D3 by the PCI bus.
    
     - In SUSPENDED state if allowed, so that the parent devices can still
       be put into low power state.
    
    To satisfy these requirements, the runtime PM for the unbound PCI
    devices are disabled and set to SUSPENDED state.  One issue of this
    solution is that the PCI devices will be put into SUSPENDED state even
    if the SUSPENDED state is forbidden via the sysfs interface
    (.../power/control) of the device.  This is not an issue for most
    devices, because most PCI devices are not used at all if unbound.
    But there are exceptions.  For example, unbound VGA card can be used
    for display, but suspending its parents makes it stop working.
    
    To fix the issue, we keep the runtime PM enabled when the PCI devices
    are unbound.  But the runtime PM callbacks will do nothing if the PCI
    devices are unbound.  This way, we can put the PCI devices into
    SUSPENDED state without putting the PCI devices into D3 state.
    
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=48201
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    CC: stable@vger.kernel.org          # v3.6+

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 6c94fc9489e7..6c66c5b8e152 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -256,31 +256,26 @@ struct drv_dev_and_id {
 static long local_pci_probe(void *_ddi)
 {
 	struct drv_dev_and_id *ddi = _ddi;
-	struct device *dev = &ddi->dev->dev;
-	struct device *parent = dev->parent;
+	struct pci_dev *pci_dev = ddi->dev;
+	struct pci_driver *pci_drv = ddi->drv;
+	struct device *dev = &pci_dev->dev;
 	int rc;
 
-	/* The parent bridge must be in active state when probing */
-	if (parent)
-		pm_runtime_get_sync(parent);
-	/* Unbound PCI devices are always set to disabled and suspended.
-	 * During probe, the device is set to enabled and active and the
-	 * usage count is incremented.  If the driver supports runtime PM,
-	 * it should call pm_runtime_put_noidle() in its probe routine and
-	 * pm_runtime_get_noresume() in its remove routine.
+	/*
+	 * Unbound PCI devices are always put in D0, regardless of
+	 * runtime PM status.  During probe, the device is set to
+	 * active and the usage count is incremented.  If the driver
+	 * supports runtime PM, it should call pm_runtime_put_noidle()
+	 * in its probe routine and pm_runtime_get_noresume() in its
+	 * remove routine.
 	 */
-	pm_runtime_get_noresume(dev);
-	pm_runtime_set_active(dev);
-	pm_runtime_enable(dev);
-
-	rc = ddi->drv->probe(ddi->dev, ddi->id);
+	pm_runtime_get_sync(dev);
+	pci_dev->driver = pci_drv;
+	rc = pci_drv->probe(pci_dev, ddi->id);
 	if (rc) {
-		pm_runtime_disable(dev);
-		pm_runtime_set_suspended(dev);
-		pm_runtime_put_noidle(dev);
+		pci_dev->driver = NULL;
+		pm_runtime_put_sync(dev);
 	}
-	if (parent)
-		pm_runtime_put(parent);
 	return rc;
 }
 
@@ -330,10 +325,8 @@ __pci_device_probe(struct pci_driver *drv, struct pci_dev *pci_dev)
 		id = pci_match_device(drv, pci_dev);
 		if (id)
 			error = pci_call_probe(drv, pci_dev, id);
-		if (error >= 0) {
-			pci_dev->driver = drv;
+		if (error >= 0)
 			error = 0;
-		}
 	}
 	return error;
 }
@@ -369,9 +362,7 @@ static int pci_device_remove(struct device * dev)
 	}
 
 	/* Undo the runtime PM settings in local_pci_probe() */
-	pm_runtime_disable(dev);
-	pm_runtime_set_suspended(dev);
-	pm_runtime_put_noidle(dev);
+	pm_runtime_put_sync(dev);
 
 	/*
 	 * If the device is still on, set the power state as "unknown",
@@ -994,6 +985,13 @@ static int pci_pm_runtime_suspend(struct device *dev)
 	pci_power_t prev = pci_dev->current_state;
 	int error;
 
+	/*
+	 * If pci_dev->driver is not set (unbound), the device should
+	 * always remain in D0 regardless of the runtime PM status
+	 */
+	if (!pci_dev->driver)
+		return 0;
+
 	if (!pm || !pm->runtime_suspend)
 		return -ENOSYS;
 
@@ -1029,6 +1027,13 @@ static int pci_pm_runtime_resume(struct device *dev)
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
+	/*
+	 * If pci_dev->driver is not set (unbound), the device should
+	 * always remain in D0 regardless of the runtime PM status
+	 */
+	if (!pci_dev->driver)
+		return 0;
+
 	if (!pm || !pm->runtime_resume)
 		return -ENOSYS;
 
@@ -1046,8 +1051,16 @@ static int pci_pm_runtime_resume(struct device *dev)
 
 static int pci_pm_runtime_idle(struct device *dev)
 {
+	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
+	/*
+	 * If pci_dev->driver is not set (unbound), the device should
+	 * always remain in D0 regardless of the runtime PM status
+	 */
+	if (!pci_dev->driver)
+		goto out;
+
 	if (!pm)
 		return -ENOSYS;
 
@@ -1057,8 +1070,8 @@ static int pci_pm_runtime_idle(struct device *dev)
 			return ret;
 	}
 
+out:
 	pm_runtime_suspend(dev);
-
 	return 0;
 }
 

commit 8ccc9aa17a0ccfabf3b2eb31243c3204f81166f6
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Nov 21 15:34:58 2012 -0500

    PCI: Move pci_uevent into pci-driver.c
    
    With the demise of CONFIG_HOTPLUG as an option, the pci_uevent
    function located in hotplug.c will now always be used and doesn't need
    special treatment in the Makefile.  Move pci_uevent into pci-driver.c
    and remove hotplug.c
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 8919801cb27e..1dc78c5cabf8 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1215,6 +1215,39 @@ void pci_dev_put(struct pci_dev *dev)
 		put_device(&dev->dev);
 }
 
+static int pci_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct pci_dev *pdev;
+
+	if (!dev)
+		return -ENODEV;
+
+	pdev = to_pci_dev(dev);
+	if (!pdev)
+		return -ENODEV;
+
+	if (add_uevent_var(env, "PCI_CLASS=%04X", pdev->class))
+		return -ENOMEM;
+
+	if (add_uevent_var(env, "PCI_ID=%04X:%04X", pdev->vendor, pdev->device))
+		return -ENOMEM;
+
+	if (add_uevent_var(env, "PCI_SUBSYS_ID=%04X:%04X", pdev->subsystem_vendor,
+			   pdev->subsystem_device))
+		return -ENOMEM;
+
+	if (add_uevent_var(env, "PCI_SLOT_NAME=%s", pci_name(pdev)))
+		return -ENOMEM;
+
+	if (add_uevent_var(env, "MODALIAS=pci:v%08Xd%08Xsv%08Xsd%08Xbc%02Xsc%02Xi%02x",
+			   pdev->vendor, pdev->device,
+			   pdev->subsystem_vendor, pdev->subsystem_device,
+			   (u8)(pdev->class >> 16), (u8)(pdev->class >> 8),
+			   (u8)(pdev->class)))
+		return -ENOMEM;
+	return 0;
+}
+
 struct bus_type pci_bus_type = {
 	.name		= "pci",
 	.match		= pci_bus_match,

commit b40b97ae736cad3084b13d2969b10c474572de89
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Nov 21 15:34:57 2012 -0500

    PCI: Remove CONFIG_HOTPLUG ifdefs
    
    Remove conditional code based on CONFIG_HOTPLUG being false.  It's
    always on now in preparation of it going away as an option.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 6c94fc9489e7..8919801cb27e 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -89,10 +89,6 @@ static void pci_free_dynids(struct pci_driver *drv)
 	spin_unlock(&drv->dynids.lock);
 }
 
-/*
- * Dynamic device ID manipulation via sysfs is disabled for !CONFIG_HOTPLUG
- */
-#ifdef CONFIG_HOTPLUG
 /**
  * store_new_id - sysfs frontend to pci_add_dynid()
  * @driver: target device driver
@@ -191,10 +187,6 @@ static struct driver_attribute pci_drv_attrs[] = {
 	__ATTR_NULL,
 };
 
-#else
-#define pci_drv_attrs	NULL
-#endif /* CONFIG_HOTPLUG */
-
 /**
  * pci_match_id - See if a pci device matches a given pci_id table
  * @ids: array of PCI device id structures to search in
@@ -1223,13 +1215,6 @@ void pci_dev_put(struct pci_dev *dev)
 		put_device(&dev->dev);
 }
 
-#ifndef CONFIG_HOTPLUG
-int pci_uevent(struct device *dev, struct kobj_uevent_env *env)
-{
-	return -ENODEV;
-}
-#endif
-
 struct bus_type pci_bus_type = {
 	.name		= "pci",
 	.match		= pci_bus_match,

commit d3fe3988fb24e5ed13b2243b789a652882d3b26c
Merge: 7db78a9c864d ff8e59bc4ec3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Nov 26 13:00:57 2012 -0700

    Merge branch 'for-linus' into next
    
    * for-linus:
      PCI/portdrv: Don't create hotplug slots unless port supports hotplug
      PCI/PM: Fix proc config reg access for D3cold and bridge suspending
      PCI/PM: Resume device before shutdown
      PCI/PM: Fix deadlock when unbinding device if parent in D3cold

commit 42eca2302146fed51335b95128e949ee6f54478f
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Oct 29 17:26:54 2012 -0600

    PCI: Don't touch card regs after runtime suspend D3
    
    If the driver takes care of state saving, don't touch any registers on it.
    
    Optimus (dual-gpu) laptops seem to have their own form of D3cold, but
    unfortunately enter it on normal D3 transitions via the ACPI callback.
    
    So when we use runtime PM to transition to D3, the card disappears off
    the PCI bus, however we then try to access registers on it in the
    runtime suspend finish, which really doesn't work.
    
    This patch checks whether the pci state is saved and doesn't attempt to hit
    any registers after that point if it is.
    
    (Looks okay to Rafael)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 94c6e2aa03d6..11d9c8a9d0d0 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1023,10 +1023,10 @@ static int pci_pm_runtime_suspend(struct device *dev)
 		return 0;
 	}
 
-	if (!pci_dev->state_saved)
+	if (!pci_dev->state_saved) {
 		pci_save_state(pci_dev);
-
-	pci_finish_runtime_suspend(pci_dev);
+		pci_finish_runtime_suspend(pci_dev);
+	}
 
 	return 0;
 }

commit 3ff2de9ba1a2e22e548979dbcd46e999b22c93d8
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Oct 24 14:54:14 2012 +0800

    PCI/PM: Resume device before shutdown
    
    Some actions during shutdown need device to be in D0 state, such as
    MSI shutdown etc, so resume device before shutdown.
    
    Without this patch, a device may not be enumerated after a kexec
    because the corresponding bridge is not in D0, so that
    configuration space of the device is not accessible.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    CC: stable@vger.kernel.org              # v3.6+

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 94c6e2aa03d6..6c94fc9489e7 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -398,6 +398,8 @@ static void pci_device_shutdown(struct device *dev)
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct pci_driver *drv = pci_dev->driver;
 
+	pm_runtime_resume(dev);
+
 	if (drv && drv->shutdown)
 		drv->shutdown(pci_dev);
 	pci_msi_shutdown(pci_dev);
@@ -408,16 +410,6 @@ static void pci_device_shutdown(struct device *dev)
 	 * continue to do DMA
 	 */
 	pci_disable_device(pci_dev);
-
-	/*
-	 * Devices may be enabled to wake up by runtime PM, but they need not
-	 * be supposed to wake up the system from its "power off" state (e.g.
-	 * ACPI S5).  Therefore disable wakeup for all devices that aren't
-	 * supposed to wake up the system at this point.  The state argument
-	 * will be ignored by pci_enable_wake().
-	 */
-	if (!device_may_wakeup(dev))
-		pci_enable_wake(pci_dev, PCI_UNKNOWN, false);
 }
 
 #ifdef CONFIG_PM

commit 16642a2e7be23bbda013fc32d8f6c68982eab603
Merge: 51562cba9893 b9142167a2bb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 2 18:32:35 2012 -0700

    Merge tag 'pm-for-3.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael J Wysocki:
    
     - Improved system suspend/resume and runtime PM handling for the SH
       TMU, CMT and MTU2 clock event devices (also used by ARM/shmobile).
    
     - Generic PM domains framework extensions related to cpuidle support
       and domain objects lookup using names.
    
     - ARM/shmobile power management updates including improved support for
       the SH7372's A4S power domain containing the CPU core.
    
     - cpufreq changes related to AMD CPUs support from Matthew Garrett,
       Andre Przywara and Borislav Petkov.
    
     - cpu0 cpufreq driver from Shawn Guo.
    
     - cpufreq governor fixes related to the relaxing of limit from Michal
       Pecio.
    
     - OMAP cpufreq updates from Axel Lin and Richard Zhao.
    
     - cpuidle ladder governor fixes related to the disabling of states from
       Carsten Emde and me.
    
     - Runtime PM core updates related to the interactions with the system
       suspend core from Alan Stern and Kevin Hilman.
    
     - Wakeup sources modification allowing more helper functions to be
       called from interrupt context from John Stultz and additional
       diagnostic code from Todd Poynor.
    
     - System suspend error code path fix from Feng Hong.
    
    Fixed up conflicts in cpufreq/powernow-k8 that stemmed from the
    workqueue fixes conflicting fairly badly with the removal of support for
    hardware P-state chips.  The changes were independent but somewhat
    intertwined.
    
    * tag 'pm-for-3.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (76 commits)
      Revert "PM QoS: Use spinlock in the per-device PM QoS constraints code"
      PM / Runtime: let rpm_resume() succeed if RPM_ACTIVE, even when disabled, v2
      cpuidle: rename function name "__cpuidle_register_driver", v2
      cpufreq: OMAP: Check IS_ERR() instead of NULL for omap_device_get_by_hwmod_name
      cpuidle: remove some empty lines
      PM: Prevent runtime suspend during system resume
      PM QoS: Use spinlock in the per-device PM QoS constraints code
      PM / Sleep: use resume event when call dpm_resume_early
      cpuidle / ACPI : move cpuidle_device field out of the acpi_processor_power structure
      ACPI / processor: remove pointless variable initialization
      ACPI / processor: remove unused function parameter
      cpufreq: OMAP: remove loops_per_jiffy recalculate for smp
      sections: fix section conflicts in drivers/cpufreq
      cpufreq: conservative: update frequency when limits are relaxed
      cpufreq / ondemand: update frequency when limits are relaxed
      properly __init-annotate pm_sysrq_init()
      cpufreq: Add a generic cpufreq-cpu0 driver
      PM / OPP: Initialize OPP table from device tree
      ARM: add cpufreq transiton notifier to adjust loops_per_jiffy for smp
      cpufreq: Remove support for hardware P-state chips from powernow-k8
      ...

commit 057d51a1268fe4be039db8ff0791fcfcb63a4f1b
Merge: 071f58279f27 88d26136a256
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 24 13:31:38 2012 +0200

    Merge branch 'pm-sleep'
    
    * pm-sleep:
      PM: Prevent runtime suspend during system resume
      PM / Sleep: use resume event when call dpm_resume_early
    
    Conflicts:
            drivers/base/power/main.c (trivial)

commit 88d26136a256576e444db312179e17af6dd0ea87
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Sep 19 21:59:02 2012 +0200

    PM: Prevent runtime suspend during system resume
    
    This patch (as1591) moves the pm_runtime_get_noresume() and
    pm_runtime_put_sync() calls from __device_suspend() and
    device_resume() to device_prepare() and device_complete() in the PM
    core.
    
    The reason for doing this is to make sure that parent devices remain
    at full power (i.e., don't go into runtime suspend) while their
    children are being resumed from a system sleep.
    
    The PCI core already contained equivalent code to serve the same
    purpose.  The patch removes the duplicated code, since it is no longer
    needed.  One of the comments from the PCI core gets moved into the PM
    core, and a second comment is added to explain whe the _get_noresume
    and _put_sync calls are present.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 185be3703343..51cd90bcdd4c 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -623,21 +623,6 @@ static int pci_pm_prepare(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	/*
-	 * If a PCI device configured to wake up the system from sleep states
-	 * has been suspended at run time and there's a resume request pending
-	 * for it, this is equivalent to the device signaling wakeup, so the
-	 * system suspend operation should be aborted.
-	 */
-	pm_runtime_get_noresume(dev);
-	if (pm_runtime_barrier(dev) && device_may_wakeup(dev))
-		pm_wakeup_event(dev, 0);
-
-	if (pm_wakeup_pending()) {
-		pm_runtime_put_sync(dev);
-		return -EBUSY;
-	}
-
 	/*
 	 * PCI devices suspended at run time need to be resumed at this
 	 * point, because in general it is necessary to reconfigure them for
@@ -661,8 +646,6 @@ static void pci_pm_complete(struct device *dev)
 
 	if (drv && drv->pm && drv->pm->complete)
 		drv->pm->complete(dev);
-
-	pm_runtime_put_sync(dev);
 }
 
 #else /* !CONFIG_PM_SLEEP */

commit bfb09a86f5f60f9a83c676b53db8d9210549ee19
Author: Konstantin Khlebnikov <khlebnikov@openvz.org>
Date:   Wed Aug 8 14:47:51 2012 +0400

    PCI: Convert "new_id"/"remove_id" into generic pci_bus driver attributes
    
    This patch removes hardcoded sysfs attributes manipulation and
    converts them into generic pci_bus->drv_attrs. This saves several bytes.
    
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@openvz.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index d6fd6b6d9d4b..9e1d2959e226 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -139,7 +139,6 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 		return retval;
 	return count;
 }
-static DRIVER_ATTR(new_id, S_IWUSR, NULL, store_new_id);
 
 /**
  * store_remove_id - remove a PCI device ID from this driver
@@ -185,38 +184,16 @@ store_remove_id(struct device_driver *driver, const char *buf, size_t count)
 		return retval;
 	return count;
 }
-static DRIVER_ATTR(remove_id, S_IWUSR, NULL, store_remove_id);
 
-static int
-pci_create_newid_files(struct pci_driver *drv)
-{
-	int error = 0;
+static struct driver_attribute pci_drv_attrs[] = {
+	__ATTR(new_id, S_IWUSR, NULL, store_new_id),
+	__ATTR(remove_id, S_IWUSR, NULL, store_remove_id),
+	__ATTR_NULL,
+};
 
-	if (drv->probe != NULL) {
-		error = driver_create_file(&drv->driver, &driver_attr_new_id);
-		if (error == 0) {
-			error = driver_create_file(&drv->driver,
-					&driver_attr_remove_id);
-			if (error)
-				driver_remove_file(&drv->driver,
-						&driver_attr_new_id);
-		}
-	}
-	return error;
-}
-
-static void pci_remove_newid_files(struct pci_driver *drv)
-{
-	driver_remove_file(&drv->driver, &driver_attr_remove_id);
-	driver_remove_file(&drv->driver, &driver_attr_new_id);
-}
-#else /* !CONFIG_HOTPLUG */
-static inline int pci_create_newid_files(struct pci_driver *drv)
-{
-	return 0;
-}
-static inline void pci_remove_newid_files(struct pci_driver *drv) {}
-#endif
+#else
+#define pci_drv_attrs	NULL
+#endif /* CONFIG_HOTPLUG */
 
 /**
  * pci_match_id - See if a pci device matches a given pci_id table
@@ -1162,8 +1139,6 @@ const struct dev_pm_ops pci_dev_pm_ops = {
 int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 			  const char *mod_name)
 {
-	int error;
-
 	/* initialize common driver fields */
 	drv->driver.name = drv->name;
 	drv->driver.bus = &pci_bus_type;
@@ -1174,19 +1149,7 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 	INIT_LIST_HEAD(&drv->dynids.list);
 
 	/* register with core */
-	error = driver_register(&drv->driver);
-	if (error)
-		goto out;
-
-	error = pci_create_newid_files(drv);
-	if (error)
-		goto out_newid;
-out:
-	return error;
-
-out_newid:
-	driver_unregister(&drv->driver);
-	goto out;
+	return driver_register(&drv->driver);
 }
 
 /**
@@ -1202,7 +1165,6 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 void
 pci_unregister_driver(struct pci_driver *drv)
 {
-	pci_remove_newid_files(drv);
 	driver_unregister(&drv->driver);
 	pci_free_dynids(drv);
 }
@@ -1302,6 +1264,7 @@ struct bus_type pci_bus_type = {
 	.shutdown	= pci_device_shutdown,
 	.dev_attrs	= pci_dev_attrs,
 	.bus_attrs	= pci_bus_attrs,
+	.drv_attrs	= pci_drv_attrs,
 	.pm		= PCI_PM_OPS_PTR,
 };
 

commit ea8c88f13d9fb1d6b39a05bfa07ae076ca1c6803
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Aug 8 09:07:39 2012 +0800

    PCI/PM: Keep parent bridge active when probing device
    
    This patch fixes the following bug:
    
    http://marc.info/?l=linux-pci&m=134329923124234&w=2
    
    The root cause of the bug is as follow.
    
    If a device is not bound with the corresponding driver, the device
    runtime PM will be disabled and the device will be put into suspended
    state.  So that, the bridge/PCIe port connected to it may be put into
    suspended and low power state.  When do probing for the device later,
    because the bridge/PCIe port connected to it is in low power state,
    the IO access to device may fail.
    
    To solve the issue, the bridge/PCIe port connected to the device is
    put into active state before probing.
    
    Reported-by: Bjorn Mork <bjorn@mork.no>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 5270f1a99328..d6fd6b6d9d4b 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -280,8 +280,12 @@ static long local_pci_probe(void *_ddi)
 {
 	struct drv_dev_and_id *ddi = _ddi;
 	struct device *dev = &ddi->dev->dev;
+	struct device *parent = dev->parent;
 	int rc;
 
+	/* The parent bridge must be in active state when probing */
+	if (parent)
+		pm_runtime_get_sync(parent);
 	/* Unbound PCI devices are always set to disabled and suspended.
 	 * During probe, the device is set to enabled and active and the
 	 * usage count is incremented.  If the driver supports runtime PM,
@@ -298,6 +302,8 @@ static long local_pci_probe(void *_ddi)
 		pm_runtime_set_suspended(dev);
 		pm_runtime_put_noidle(dev);
 	}
+	if (parent)
+		pm_runtime_put(parent);
 	return rc;
 }
 

commit 0b68c8e2c3afaf9807eb1ebe0ccfb3b809570aa4
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Aug 12 23:26:07 2012 +0200

    PCI: EHCI: Fix crash during hibernation on ASUS computers
    
    Commit dbf0e4c (PCI: EHCI: fix crash during suspend on ASUS
    computers) added a workaround for an ASUS suspend issue related to
    USB EHCI and a bug in a number of ASUS BIOSes that attempt to shut
    down the EHCI controller during system suspend if its PCI command
    register doesn't contain 0 at that time.
    
    It turns out that the same workaround is necessary in the analogous
    hibernation code path, so add it.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=45811
    Reported-and-tested-by: Oleksij Rempel <bug-track@fisher-privat.net>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 185be3703343..5270f1a99328 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -959,6 +959,13 @@ static int pci_pm_poweroff_noirq(struct device *dev)
 	if (!pci_dev->state_saved && !pci_is_bridge(pci_dev))
 		pci_prepare_to_sleep(pci_dev);
 
+	/*
+	 * The reason for doing this here is the same as for the analogous code
+	 * in pci_pm_suspend_noirq().
+	 */
+	if (pci_dev->class == PCI_CLASS_SERIAL_USB_EHCI)
+		pci_write_config_word(pci_dev, PCI_COMMAND, 0);
+
 	return 0;
 }
 

commit 6dd53aa4563a2c69e80a24d2cc68d484b5ea2891
Merge: f14121ab3591 63b96f7baeba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 24 16:17:07 2012 -0700

    Merge tag 'for-3.6' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI changes from Bjorn Helgaas:
     "Host bridge hotplug:
        - Add MMCONFIG support for hot-added host bridges (Jiang Liu)
      Device hotplug:
        - Move fixups from __init to __devinit (Sebastian Andrzej Siewior)
        - Call FINAL fixups for hot-added devices, too (Myron Stowe)
        - Factor out generic code for P2P bridge hot-add (Yinghai Lu)
        - Remove all functions in a slot, not just those with _EJx (Amos
          Kong)
      Dynamic resource management:
        - Track bus number allocation (struct resource tree per domain)
          (Yinghai Lu)
        - Make P2P bridge 1K I/O windows work with resource reassignment
          (Bjorn Helgaas, Yinghai Lu)
        - Disable decoding while updating 64-bit BARs (Bjorn Helgaas)
      Power management:
        - Add PCIe runtime D3cold support (Huang Ying)
      Virtualization:
        - Add VFIO infrastructure (ACS, DMA source ID quirks) (Alex
          Williamson)
        - Add quirks for devices with broken INTx masking (Jan Kiszka)
      Miscellaneous:
        - Fix some PCI Express capability version issues (Myron Stowe)
        - Factor out some arch code with a weak, generic, pcibios_setup()
          (Myron Stowe)"
    
    * tag 'for-3.6' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (122 commits)
      PCI: hotplug: ensure a consistent return value in error case
      PCI: fix undefined reference to 'pci_fixup_final_inited'
      PCI: build resource code for M68K architecture
      PCI: pciehp: remove unused pciehp_get_max_lnk_width(), pciehp_get_cur_lnk_width()
      PCI: reorder __pci_assign_resource() (no change)
      PCI: fix truncation of resource size to 32 bits
      PCI: acpiphp: merge acpiphp_debug and debug
      PCI: acpiphp: remove unused res_lock
      sparc/PCI: replace pci_cfg_fake_ranges() with pci_read_bridge_bases()
      PCI: call final fixups hot-added devices
      PCI: move final fixups from __init to __devinit
      x86/PCI: move final fixups from __init to __devinit
      MIPS/PCI: move final fixups from __init to __devinit
      PCI: support sizing P2P bridge I/O windows with 1K granularity
      PCI: reimplement P2P bridge 1K I/O windows (Intel P64H2)
      PCI: disable MEM decoding while updating 64-bit MEM BARs
      PCI: leave MEM and IO decoding disabled during 64-bit BAR sizing, too
      PCI: never discard enable/suspend/resume_early/resume fixups
      PCI: release temporary reference in __nv_msi_ht_cap_quirk()
      PCI: restructure 'pci_do_fixups()'
      ...

commit dbf0e4c7257f8d684ec1a3c919853464293de66e
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jul 9 11:09:21 2012 -0400

    PCI: EHCI: fix crash during suspend on ASUS computers
    
    Quite a few ASUS computers experience a nasty problem, related to the
    EHCI controllers, when going into system suspend.  It was observed
    that the problem didn't occur if the controllers were not put into the
    D3 power state before starting the suspend, and commit
    151b61284776be2d6f02d48c23c3625678960b97 (USB: EHCI: fix crash during
    suspend on ASUS computers) was created to do this.
    
    It turned out this approach messed up other computers that didn't have
    the problem -- it prevented USB wakeup from working.  Consequently
    commit c2fb8a3fa25513de8fedb38509b1f15a5bbee47b (USB: add
    NO_D3_DURING_SLEEP flag and revert 151b61284776be2) was merged; it
    reverted the earlier commit and added a whitelist of known good board
    names.
    
    Now we know the actual cause of the problem.  Thanks to AceLan Kao for
    tracking it down.
    
    According to him, an engineer at ASUS explained that some of their
    BIOSes contain a bug that was added in an attempt to work around a
    problem in early versions of Windows.  When the computer goes into S3
    suspend, the BIOS tries to verify that the EHCI controllers were first
    quiesced by the OS.  Nothing's wrong with this, but the BIOS does it
    by checking that the PCI COMMAND registers contain 0 without checking
    the controllers' power state.  If the register isn't 0, the BIOS
    assumes the controller needs to be quiesced and tries to do so.  This
    involves making various MMIO accesses to the controller, which don't
    work very well if the controller is already in D3.  The end result is
    a system hang or memory corruption.
    
    Since the value in the PCI COMMAND register doesn't matter once the
    controller has been suspended, and since the value will be restored
    anyway when the controller is resumed, we can work around the BIOS bug
    simply by setting the register to 0 during system suspend.  This patch
    (as1590) does so and also reverts the second commit mentioned above,
    which is now unnecessary.
    
    In theory we could do this for every PCI device.  However to avoid
    introducing new problems, the patch restricts itself to EHCI host
    controllers.
    
    Finally the affected systems can suspend with USB wakeup working
    properly.
    
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=37632
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=42728
    Based-on-patch-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Dniel Fraga <fragabr@gmail.com>
    Tested-by: Javier Marcet <jmarcet@gmail.com>
    Tested-by: Andrey Rahmatullin <wrar@wrar.name>
    Tested-by: Oleksij Rempel <bug-track@fisher-privat.net>
    Tested-by: Pavel Pisa <pisa@cmp.felk.cvut.cz>
    Cc: stable <stable@vger.kernel.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index bf0cee629b60..099f46cd8e87 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -748,6 +748,18 @@ static int pci_pm_suspend_noirq(struct device *dev)
 
 	pci_pm_set_unknown_state(pci_dev);
 
+	/*
+	 * Some BIOSes from ASUS have a bug: If a USB EHCI host controller's
+	 * PCI COMMAND register isn't 0, the BIOS assumes that the controller
+	 * hasn't been quiesced and tries to turn it off.  If the controller
+	 * is already in D3, this can hang or cause memory corruption.
+	 *
+	 * Since the value of the COMMAND register doesn't matter once the
+	 * device has been suspended, we can safely set it to 0 here.
+	 */
+	if (pci_dev->class == PCI_CLASS_SERIAL_USB_EHCI)
+		pci_write_config_word(pci_dev, PCI_COMMAND, 0);
+
 	return 0;
 }
 

commit db288c9c5f9db45610dab3940377625132b4af41
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 5 15:20:00 2012 -0600

    PCI / PM: restore the original behavior of pci_set_power_state()
    
    Commit cc2893b6 (PCI: Ensure we re-enable devices on resume)
    addressed the problem with USB not being powered after resume on
    recent Lenovo machines, but it did that in a suboptimal way.
    Namely, it should have changed the relevant code paths only,
    which are pci_pm_resume_noirq() and pci_pm_restore_noirq() supposed
    to restore the device's power and standard configuration registers
    after system resume from suspend or hibernation.  Instead, however,
    it modified pci_set_power_state() which is executed in several
    other situations too.  That resulted in some undesirable effects,
    like attempting to change a device's power state in the same way
    multiple times in a row (up to as many as 4 times in a row in the
    snd_hda_intel driver).
    
    Fix the bug addressed by commit cc2893b6 in an alternative way,
    by forcibly powering up all devices in pci_pm_default_resume_early(),
    which is called by pci_pm_resume_noirq() and pci_pm_restore_noirq()
    to restore the device's power and standard configuration registers,
    and modifying pci_pm_runtime_resume() to avoid the forcible power-up
    if not necessary.  Then, revert the changes made by commit cc2893b6
    to make the confusion introduced by it go away.
    
    Acked-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index ca2e4c79a588..1dd1d9dfa173 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -459,16 +459,17 @@ static int pci_restore_standard_config(struct pci_dev *pci_dev)
 	return 0;
 }
 
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+
 static void pci_pm_default_resume_early(struct pci_dev *pci_dev)
 {
-	pci_restore_standard_config(pci_dev);
+	pci_power_up(pci_dev);
+	pci_restore_state(pci_dev);
 	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 }
 
-#endif
-
-#ifdef CONFIG_PM_SLEEP
-
 /*
  * Default "suspend" method for devices that have no driver provided suspend,
  * or not even a driver at all (second part).
@@ -1054,7 +1055,8 @@ static int pci_pm_runtime_resume(struct device *dev)
 	if (!pm || !pm->runtime_resume)
 		return -ENOSYS;
 
-	pci_pm_default_resume_early(pci_dev);
+	pci_restore_standard_config(pci_dev);
+	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 	__pci_enable_wake(pci_dev, PCI_D0, true, false);
 	pci_fixup_device(pci_fixup_resume, pci_dev);
 

commit 448bd857d48e69b33ef323739dc6d8ca20d4cda7
Author: Huang Ying <ying.huang@intel.com>
Date:   Sat Jun 23 10:23:51 2012 +0800

    PCI/PM: add PCIe runtime D3cold support
    
    This patch adds runtime D3cold support and corresponding ACPI platform
    support.  This patch only enables runtime D3cold support; it does not
    enable D3cold support during system suspend/hibernate.
    
    D3cold is the deepest power saving state for a PCIe device, where its main
    power is removed.  While it is in D3cold, you can't access the device at
    all, not even its configuration space (which is still accessible in D3hot).
    Therefore the PCI PM registers can not be used to transition into/out of
    the D3cold state; that must be done by platform logic such as ACPI _PR3.
    
    To support wakeup from D3cold, a system may provide auxiliary power, which
    allows a device to request wakeup using a Beacon or the sideband WAKE#
    signal.  WAKE# is usually connected to platform logic such as ACPI GPE.
    This is quite different from other power saving states, where devices
    request wakeup via a PME message on the PCIe link.
    
    Some devices, such as those in plug-in slots, have no direct platform
    logic.  For example, there is usually no ACPI _PR3 for them.  D3cold
    support for these devices can be done via the PCIe Downstream Port leading
    to the device.  When the PCIe port is powered on/off, the device is powered
    on/off too.  Wakeup events from the device will be notified to the
    corresponding PCIe port.
    
    For more information about PCIe D3cold and corresponding ACPI support,
    please refer to:
    
    - PCI Express Base Specification Revision 2.0
    - Advanced Configuration and Power Interface Specification Revision 5.0
    
    [bhelgaas: changelog]
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>
    Originally-by: Zheng Yan <zheng.z.yan@intel.com>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index bf0cee629b60..ca2e4c79a588 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1019,10 +1019,13 @@ static int pci_pm_runtime_suspend(struct device *dev)
 	if (!pm || !pm->runtime_suspend)
 		return -ENOSYS;
 
+	pci_dev->no_d3cold = false;
 	error = pm->runtime_suspend(dev);
 	suspend_report_result(pm->runtime_suspend, error);
 	if (error)
 		return error;
+	if (!pci_dev->d3cold_allowed)
+		pci_dev->no_d3cold = true;
 
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
 
@@ -1044,6 +1047,7 @@ static int pci_pm_runtime_suspend(struct device *dev)
 
 static int pci_pm_runtime_resume(struct device *dev)
 {
+	int rc;
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
@@ -1054,7 +1058,11 @@ static int pci_pm_runtime_resume(struct device *dev)
 	__pci_enable_wake(pci_dev, PCI_D0, true, false);
 	pci_fixup_device(pci_fixup_resume, pci_dev);
 
-	return pm->runtime_resume(dev);
+	rc = pm->runtime_resume(dev);
+
+	pci_dev->runtime_d3cold = false;
+
+	return rc;
 }
 
 static int pci_pm_runtime_idle(struct device *dev)

commit b566a22c23327f18ce941ffad0ca907e50a53d41
Author: Khalid Aziz <khalid.aziz@hp.com>
Date:   Fri Apr 27 13:00:33 2012 -0600

    PCI: disable Bus Master on PCI device shutdown
    
    Disable Bus Master bit on the device in pci_device_shutdown() to ensure PCI
    devices do not continue to DMA data after shutdown.  This can cause memory
    corruption in case of a kexec where the current kernel shuts down and
    transfers control to a new kernel while a PCI device continues to DMA to
    memory that does not belong to it any more in the new kernel.
    
    I have tested this code on two laptops, two workstations and a 16-socket
    server.  kexec worked correctly on all of them.
    
    Signed-off-by: Khalid Aziz <khalid.aziz@hp.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 6b54b23b990b..bf0cee629b60 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -420,6 +420,12 @@ static void pci_device_shutdown(struct device *dev)
 	pci_msi_shutdown(pci_dev);
 	pci_msix_shutdown(pci_dev);
 
+	/*
+	 * Turn off Bus Master bit on the device to tell it to not
+	 * continue to do DMA
+	 */
+	pci_disable_device(pci_dev);
+
 	/*
 	 * Devices may be enabled to wake up by runtime PM, but they need not
 	 * be supposed to wake up the system from its "power off" state (e.g.

commit 475c77edf826333aa61625f49d6a2bec26ecb5a6
Merge: 934e18b5cb45 1488d5158dcd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 23 14:02:12 2012 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci
    
    Pull PCI changes (including maintainer change) from Jesse Barnes:
     "This pull has some good cleanups from Bjorn and Yinghai, as well as
      some more code from Yinghai to better handle resource re-allocation
      when enabled.
    
      There's also a new initcall_debug feature from Arjan which will print
      out quirk timing information to help identify slow quirks for fixing
      or refinement (Yinghai sent in a few patches to do just that once the
      new debug code landed).
    
      Beyond that, I'm handing off PCI maintainership to Bjorn Helgaas.
      He's been a core PCI and Linux contributor for some time now, and has
      kindly volunteered to take over.  I just don't feel I have the time
      for PCI review and work that it deserves lately (I've taken on some
      other projects), and haven't been as responsive lately as I'd like, so
      I approached Bjorn asking if he'd like to manage things.  He's going
      to give it a try, and I'm confident he'll do at least as well as I
      have in keeping the tree managed, patches flowing, and keeping things
      stable."
    
    Fix up some fairly trivial conflicts due to other cleanups (mips device
    resource fixup cleanups clashing with list handling cleanup, ppc iseries
    removal clashing with pci_probe_only cleanup etc)
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci: (112 commits)
      PCI: Bjorn gets PCI hotplug too
      PCI: hand PCI maintenance over to Bjorn Helgaas
      unicore32/PCI: move <asm-generic/pci-bridge.h> include to asm/pci.h
      sparc/PCI: convert devtree and arch-probed bus addresses to resource
      powerpc/PCI: allow reallocation on PA Semi
      powerpc/PCI: convert devtree bus addresses to resource
      powerpc/PCI: compute I/O space bus-to-resource offset consistently
      arm/PCI: don't export pci_flags
      PCI: fix bridge I/O window bus-to-resource conversion
      x86/PCI: add spinlock held check to 'pcibios_fwaddrmap_lookup()'
      PCI / PCIe: Introduce command line option to disable ARI
      PCI: make acpihp use __pci_remove_bus_device instead
      PCI: export __pci_remove_bus_device
      PCI: Rename pci_remove_behind_bridge to pci_stop_and_remove_behind_bridge
      PCI: Rename pci_remove_bus_device to pci_stop_and_remove_bus_device
      PCI: print out PCI device info along with duration
      PCI: Move "pci reassigndev resource alignment" out of quirks.c
      PCI: Use class for quirk for usb host controller fixup
      PCI: Use class for quirk for ti816x class fixup
      PCI: Use class for quirk for intel e100 interrupt fixup
      ...

commit 5b415f1e79e0c09366f26e3eabe751642059285a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 7 00:50:35 2012 +0100

    PCI / PM: Disable wakeup during shutdown for devices not enabled to wake up
    
    If a PCI device is enabled to generate wakeup signals (PME) when put
    into a low-power state by runtime PM, it will be still enabled to
    generate those signals after the system shutdown, unless its driver's
    .shutdown() callback takes care of the wakeup signals generation
    setting.  Moreover, there are devices that are not enabled to wake
    up the system and that are configured by runtime PM to generate
    wakeup signals so that (runtime) remote wakeup works with them.
    Those devices should be reconfigured during system shutdown so that
    they don't generate wakeup signals, but at least some drivers don't
    do that.  However, that very well may be done by the PCI core so
    that drivers don't have to worry about it.  For this reason, modify
    pci_device_shutdown() to disable the generation of wakeup events for
    devices not supposed to wake up the system.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=37952
    Reported-and-tested-by: Kamil Iskra <kamil.54002@iskra.name>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 3623d65f8b86..5d19695c771a 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -430,6 +430,16 @@ static void pci_device_shutdown(struct device *dev)
 		drv->shutdown(pci_dev);
 	pci_msi_shutdown(pci_dev);
 	pci_msix_shutdown(pci_dev);
+
+	/*
+	 * Devices may be enabled to wake up by runtime PM, but they need not
+	 * be supposed to wake up the system from its "power off" state (e.g.
+	 * ACPI S5).  Therefore disable wakeup for all devices that aren't
+	 * supposed to wake up the system at this point.  The state argument
+	 * will be ignored by pci_enable_wake().
+	 */
+	if (!device_may_wakeup(dev))
+		pci_enable_wake(pci_dev, PCI_UNKNOWN, false);
 }
 
 #ifdef CONFIG_PM

commit ed283e9f0a2cc0541870828c76c6c6997c51a318
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jan 24 14:35:13 2012 -0500

    USB/PCI/PCMCIA: Clean up new_id and remove_id sysfs attribute routines
    
    This patch (as1514) cleans up some places where new_id and remove_id
    sysfs attributes are created and deleted.  Handling both attributes in
    a single routine rather than a pair of routines makes the code
    smaller.  It also prevents certain kinds of errors, like one we
    currently have in the USB subsystem: The removeid attribute is often
    created even when newid isn't (because the driver's no_dynamid_id flag
    is set).
    
    In the case of the PCMCIA subsystem, the newid attribute is created
    but never explicitly deleted.  The patch adds a deletion routine.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Acked-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index ff540477fe8b..8d9616b821ca 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -188,43 +188,34 @@ store_remove_id(struct device_driver *driver, const char *buf, size_t count)
 static DRIVER_ATTR(remove_id, S_IWUSR, NULL, store_remove_id);
 
 static int
-pci_create_newid_file(struct pci_driver *drv)
+pci_create_newid_files(struct pci_driver *drv)
 {
 	int error = 0;
-	if (drv->probe != NULL)
-		error = driver_create_file(&drv->driver, &driver_attr_new_id);
-	return error;
-}
-
-static void pci_remove_newid_file(struct pci_driver *drv)
-{
-	driver_remove_file(&drv->driver, &driver_attr_new_id);
-}
 
-static int
-pci_create_removeid_file(struct pci_driver *drv)
-{
-	int error = 0;
-	if (drv->probe != NULL)
-		error = driver_create_file(&drv->driver,&driver_attr_remove_id);
+	if (drv->probe != NULL) {
+		error = driver_create_file(&drv->driver, &driver_attr_new_id);
+		if (error == 0) {
+			error = driver_create_file(&drv->driver,
+					&driver_attr_remove_id);
+			if (error)
+				driver_remove_file(&drv->driver,
+						&driver_attr_new_id);
+		}
+	}
 	return error;
 }
 
-static void pci_remove_removeid_file(struct pci_driver *drv)
+static void pci_remove_newid_files(struct pci_driver *drv)
 {
 	driver_remove_file(&drv->driver, &driver_attr_remove_id);
+	driver_remove_file(&drv->driver, &driver_attr_new_id);
 }
 #else /* !CONFIG_HOTPLUG */
-static inline int pci_create_newid_file(struct pci_driver *drv)
+static inline int pci_create_newid_files(struct pci_driver *drv)
 {
 	return 0;
 }
-static inline void pci_remove_newid_file(struct pci_driver *drv) {}
-static inline int pci_create_removeid_file(struct pci_driver *drv)
-{
-	return 0;
-}
-static inline void pci_remove_removeid_file(struct pci_driver *drv) {}
+static inline void pci_remove_newid_files(struct pci_driver *drv) {}
 #endif
 
 /**
@@ -1136,18 +1127,12 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 	if (error)
 		goto out;
 
-	error = pci_create_newid_file(drv);
+	error = pci_create_newid_files(drv);
 	if (error)
 		goto out_newid;
-
-	error = pci_create_removeid_file(drv);
-	if (error)
-		goto out_removeid;
 out:
 	return error;
 
-out_removeid:
-	pci_remove_newid_file(drv);
 out_newid:
 	driver_unregister(&drv->driver);
 	goto out;
@@ -1166,8 +1151,7 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 void
 pci_unregister_driver(struct pci_driver *drv)
 {
-	pci_remove_removeid_file(drv);
-	pci_remove_newid_file(drv);
+	pci_remove_newid_files(drv);
 	driver_unregister(&drv->driver);
 	pci_free_dynids(drv);
 }

commit cef9bc56e1e944afd11f96de569657117a138c6d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jan 24 13:34:41 2012 -0500

    Dynamic ID addition doesn't need get_driver()
    
    As part of the removal of get_driver()/put_driver(), this patch
    (as1511) changes all the places that add dynamic IDs for drivers.
    Since these additions are done by writing to the drivers' sysfs
    attribute files, and the attributes are removed when the drivers are
    unregistered, there is no reason to take an extra reference to the
    drivers.
    
    The one exception is the pci-stub driver, which calls pci_add_dynid()
    as part of its registration.  But again, there's no reason to take an
    extra reference here, because the driver can't be unloaded while it is
    being registered.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: Jesse Barnes <jbarnes@virtuousgeek.org>
    CC: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 3623d65f8b86..ff540477fe8b 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -72,9 +72,7 @@ int pci_add_dynid(struct pci_driver *drv,
 	list_add_tail(&dynid->node, &drv->dynids.list);
 	spin_unlock(&drv->dynids.lock);
 
-	get_driver(&drv->driver);
 	retval = driver_attach(&drv->driver);
-	put_driver(&drv->driver);
 
 	return retval;
 }

commit 82440a8253e09047410ff4df5c202be15645573f
Author: David Fries <David@Fries.net>
Date:   Sun Nov 20 15:29:46 2011 -0600

    PCI: pci_has_legacy_pm_support add driver and device to WARN
    
    Include the driver name and device in warning when a pci driver
    supports both legacy pm and new framework as just the stack trace
    gives no way to identify the driver.
    
    Signed-off-by: David Fries <David@Fries.net>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 12d1e81a8abe..3623d65f8b86 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -604,7 +604,8 @@ static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
 	 * supported as well.  Drivers are supposed to support either the
 	 * former, or the latter, but not both at the same time.
 	 */
-	WARN_ON(ret && drv->driver.pm);
+	WARN(ret && drv->driver.pm, "driver %s device %04x:%04x\n",
+		drv->name, pci_dev->vendor, pci_dev->device);
 
 	return ret;
 }

commit eea3fc0357eb89d0b2d1af37bdfb83eb4076a542
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jul 6 10:51:40 2011 +0200

    PCI / PM: Detect early wakeup in pci_pm_prepare()
    
    A subsequent patch is going to move the invocation of
    pm_runtime_barrier() from dpm_prepare() to __device_suspend().
    Consequently, early wakeup events resulting from runtime resume
    requests for wakeup devices queued up right before system suspend
    will only be detected after all of the subsystem-level .prepare()
    callbacks have run.  However, the PCI bus type calls
    pm_runtime_get_sync() from its pci_pm_prepare() callback routine,
    so it would destroy the early wakeup events information regarding PCI
    devices.  To prevent this from happening add an early wakeup
    detection mechanism, analogous to the one currently in dpm_prepare(),
    to pci_pm_prepare().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 46767c53917a..12d1e81a8abe 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -18,6 +18,7 @@
 #include <linux/sched.h>
 #include <linux/cpu.h>
 #include <linux/pm_runtime.h>
+#include <linux/suspend.h>
 #include "pci.h"
 
 struct pci_dynid {
@@ -615,6 +616,21 @@ static int pci_pm_prepare(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	/*
+	 * If a PCI device configured to wake up the system from sleep states
+	 * has been suspended at run time and there's a resume request pending
+	 * for it, this is equivalent to the device signaling wakeup, so the
+	 * system suspend operation should be aborted.
+	 */
+	pm_runtime_get_noresume(dev);
+	if (pm_runtime_barrier(dev) && device_may_wakeup(dev))
+		pm_wakeup_event(dev, 0);
+
+	if (pm_wakeup_pending()) {
+		pm_runtime_put_sync(dev);
+		return -EBUSY;
+	}
+
 	/*
 	 * PCI devices suspended at run time need to be resumed at this
 	 * point, because in general it is necessary to reconfigure them for
@@ -624,7 +640,7 @@ static int pci_pm_prepare(struct device *dev)
 	 * system from the sleep state, we'll have to prevent it from signaling
 	 * wake-up.
 	 */
-	pm_runtime_get_sync(dev);
+	pm_runtime_resume(dev);
 
 	if (drv && drv->pm && drv->pm->prepare)
 		error = drv->pm->prepare(dev);

commit a5f76d5eba157bf637beb2dd18026db2917c512e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jun 21 23:47:15 2011 +0200

    PCI / PM: Block races between runtime PM and system sleep
    
    After commit e8665002477f0278f84f898145b1f141ba26ee26
    (PM: Allow pm_runtime_suspend() to succeed during system suspend) it
    is possible that a device resumed by the pm_runtime_resume(dev) in
    pci_pm_prepare() will be suspended immediately from a work item,
    timer function or otherwise, defeating the very purpose of calling
    pm_runtime_resume(dev) from there.  To prevent that from happening
    it is necessary to increment the runtime PM usage counter of the
    device by replacing pm_runtime_resume() with pm_runtime_get_sync().
    Moreover, the incremented runtime PM usage counter has to be
    decremented by the corresponding pci_pm_complete(), via
    pm_runtime_put_sync().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: stable@kernel.org
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 135df164a4c1..46767c53917a 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -624,7 +624,7 @@ static int pci_pm_prepare(struct device *dev)
 	 * system from the sleep state, we'll have to prevent it from signaling
 	 * wake-up.
 	 */
-	pm_runtime_resume(dev);
+	pm_runtime_get_sync(dev);
 
 	if (drv && drv->pm && drv->pm->prepare)
 		error = drv->pm->prepare(dev);
@@ -638,6 +638,8 @@ static void pci_pm_complete(struct device *dev)
 
 	if (drv && drv->pm && drv->pm->complete)
 		drv->pm->complete(dev);
+
+	pm_runtime_put_sync(dev);
 }
 
 #else /* !CONFIG_PM_SLEEP */

commit 1f112cee07b314e244ee9e71d9c1e6950dc13327
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Apr 11 22:54:42 2011 +0200

    PM / Hibernate: Introduce CONFIG_HIBERNATE_CALLBACKS
    
    Xen save/restore is going to use hibernate device callbacks for
    quiescing devices and putting them back to normal operations and it
    would need to select CONFIG_HIBERNATION for this purpose.  However,
    that also would cause the hibernate interfaces for user space to be
    enabled, which might confuse user space, because the Xen kernels
    don't support hibernation.  Moreover, it would be wasteful, as it
    would make the Xen kernels include a substantial amount of code that
    they would never use.
    
    To address this issue introduce new power management Kconfig option
    CONFIG_HIBERNATE_CALLBACKS, such that it will only select the code
    that is necessary for the hibernate device callbacks to work and make
    CONFIG_HIBERNATION select it.  Then, Xen save/restore will be able to
    select CONFIG_HIBERNATE_CALLBACKS without dragging the entire
    hibernate code along with it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Shriram Rajagopalan <rshriram@cs.ubc.ca>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index d86ea8b01137..135df164a4c1 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -781,7 +781,7 @@ static int pci_pm_resume(struct device *dev)
 
 #endif /* !CONFIG_SUSPEND */
 
-#ifdef CONFIG_HIBERNATION
+#ifdef CONFIG_HIBERNATE_CALLBACKS
 
 static int pci_pm_freeze(struct device *dev)
 {
@@ -970,7 +970,7 @@ static int pci_pm_restore(struct device *dev)
 	return error;
 }
 
-#else /* !CONFIG_HIBERNATION */
+#else /* !CONFIG_HIBERNATE_CALLBACKS */
 
 #define pci_pm_freeze		NULL
 #define pci_pm_freeze_noirq	NULL
@@ -981,7 +981,7 @@ static int pci_pm_restore(struct device *dev)
 #define pci_pm_restore		NULL
 #define pci_pm_restore_noirq	NULL
 
-#endif /* !CONFIG_HIBERNATION */
+#endif /* !CONFIG_HIBERNATE_CALLBACKS */
 
 #ifdef CONFIG_PM_RUNTIME
 

commit aa33860158114d0df3c7997bc1dd41c0168e1c2a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Feb 11 00:06:54 2011 +0100

    PM: Remove CONFIG_PM_OPS
    
    After redefining CONFIG_PM to depend on (CONFIG_PM_SLEEP ||
    CONFIG_PM_RUNTIME) the CONFIG_PM_OPS option is redundant and can be
    replaced with CONFIG_PM.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 88246dd46452..d86ea8b01137 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -431,7 +431,7 @@ static void pci_device_shutdown(struct device *dev)
 	pci_msix_shutdown(pci_dev);
 }
 
-#ifdef CONFIG_PM_OPS
+#ifdef CONFIG_PM
 
 /* Auxiliary functions used for system resume and run-time resume. */
 
@@ -1059,7 +1059,7 @@ static int pci_pm_runtime_idle(struct device *dev)
 
 #endif /* !CONFIG_PM_RUNTIME */
 
-#ifdef CONFIG_PM_OPS
+#ifdef CONFIG_PM
 
 const struct dev_pm_ops pci_dev_pm_ops = {
 	.prepare = pci_pm_prepare,

commit 23ea3793fd368fd6a1ea20659699e280e2996658
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Thu Nov 18 15:02:31 2010 -0800

    PCI: fix __pci_device_probe kernel-doc warning
    
    Fix kernel-doc warning for __pci_device_probe():
    
    Warning(drivers/pci/pci-driver.c:341): missing initial short description on line:
     * __pci_device_probe()
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 80e551ee640b..88246dd46452 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -338,7 +338,7 @@ static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
 }
 
 /**
- * __pci_device_probe()
+ * __pci_device_probe - check if a driver wants to claim a specific PCI device
  * @drv: driver to call to check if it wants the PCI device
  * @pci_dev: PCI device being probed
  * 

commit 1d3c16a818e992c199844954d95c17fd7ce6cbba
Author: Jon Mason <jon.mason@exar.com>
Date:   Tue Nov 30 17:43:26 2010 -0600

    PCI: make pci_restore_state return void
    
    pci_restore_state only ever returns 0, thus there is no benefit in
    having it return any value.  Also, a large majority of the callers do
    not check the return code of pci_restore_state.  Make the
    pci_restore_state a void return and avoid the overhead.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Jon Mason <jon.mason@exar.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 8a6f797de8e5..80e551ee640b 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -449,7 +449,8 @@ static int pci_restore_standard_config(struct pci_dev *pci_dev)
 			return error;
 	}
 
-	return pci_restore_state(pci_dev);
+	pci_restore_state(pci_dev);
+	return 0;
 }
 
 static void pci_pm_default_resume_early(struct pci_dev *pci_dev)

commit f3ec4f87d607f40497afdb5ac03f11e2ea253d52
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jun 8 15:23:51 2010 -0400

    PCI: change device runtime PM settings for probe and remove
    
    This patch (as1388) changes the way the PCI core handles runtime PM
    settings when probing or unbinding drivers.  Now the core will make
    sure the device is enabled for runtime PM, with a usage count >= 1,
    when a driver is probed.  It does the same when calling a driver's
    remove method.
    
    If the driver wants to use runtime PM, all it has to do is call
    pm_runtime_pu_noidle() near the end of its probe routine (to cancel
    the core's usage increment) and pm_runtime_get_noresume() near the
    start of its remove routine (to restore the usage count).  It does not
    need to mess around with setting the runtime state to enabled,
    disabled, active, or suspended.
    
    The patch updates e1000e and r8169, the only PCI drivers that already
    use the existing runtime PM interface.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index f9a0aec3abcf..8a6f797de8e5 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -289,8 +289,26 @@ struct drv_dev_and_id {
 static long local_pci_probe(void *_ddi)
 {
 	struct drv_dev_and_id *ddi = _ddi;
-
-	return ddi->drv->probe(ddi->dev, ddi->id);
+	struct device *dev = &ddi->dev->dev;
+	int rc;
+
+	/* Unbound PCI devices are always set to disabled and suspended.
+	 * During probe, the device is set to enabled and active and the
+	 * usage count is incremented.  If the driver supports runtime PM,
+	 * it should call pm_runtime_put_noidle() in its probe routine and
+	 * pm_runtime_get_noresume() in its remove routine.
+	 */
+	pm_runtime_get_noresume(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+	rc = ddi->drv->probe(ddi->dev, ddi->id);
+	if (rc) {
+		pm_runtime_disable(dev);
+		pm_runtime_set_suspended(dev);
+		pm_runtime_put_noidle(dev);
+	}
+	return rc;
 }
 
 static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
@@ -369,11 +387,19 @@ static int pci_device_remove(struct device * dev)
 	struct pci_driver * drv = pci_dev->driver;
 
 	if (drv) {
-		if (drv->remove)
+		if (drv->remove) {
+			pm_runtime_get_sync(dev);
 			drv->remove(pci_dev);
+			pm_runtime_put_noidle(dev);
+		}
 		pci_dev->driver = NULL;
 	}
 
+	/* Undo the runtime PM settings in local_pci_probe() */
+	pm_runtime_disable(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_put_noidle(dev);
+
 	/*
 	 * If the device is still on, set the power state as "unknown",
 	 * since it might change by the next time we load the driver.

commit 6cbf82148ff286ec22a55be6836c3a5bffc489c1
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 17 23:44:58 2010 +0100

    PCI PM: Run-time callbacks for PCI bus type
    
    Introduce run-time PM callbacks for the PCI bus type.  Make the new
    callbacks work in analogy with the existing system sleep PM
    callbacks, so that the drivers already converted to struct dev_pm_ops
    can use their suspend and resume routines for run-time PM without
    modifications.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index e5d47be3c6d7..f9a0aec3abcf 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -17,6 +17,7 @@
 #include <linux/slab.h>
 #include <linux/sched.h>
 #include <linux/cpu.h>
+#include <linux/pm_runtime.h>
 #include "pci.h"
 
 struct pci_dynid {
@@ -404,6 +405,35 @@ static void pci_device_shutdown(struct device *dev)
 	pci_msix_shutdown(pci_dev);
 }
 
+#ifdef CONFIG_PM_OPS
+
+/* Auxiliary functions used for system resume and run-time resume. */
+
+/**
+ * pci_restore_standard_config - restore standard config registers of PCI device
+ * @pci_dev: PCI device to handle
+ */
+static int pci_restore_standard_config(struct pci_dev *pci_dev)
+{
+	pci_update_current_state(pci_dev, PCI_UNKNOWN);
+
+	if (pci_dev->current_state != PCI_D0) {
+		int error = pci_set_power_state(pci_dev, PCI_D0);
+		if (error)
+			return error;
+	}
+
+	return pci_restore_state(pci_dev);
+}
+
+static void pci_pm_default_resume_early(struct pci_dev *pci_dev)
+{
+	pci_restore_standard_config(pci_dev);
+	pci_fixup_device(pci_fixup_resume_early, pci_dev);
+}
+
+#endif
+
 #ifdef CONFIG_PM_SLEEP
 
 /*
@@ -520,29 +550,6 @@ static int pci_legacy_resume(struct device *dev)
 
 /* Auxiliary functions used by the new power management framework */
 
-/**
- * pci_restore_standard_config - restore standard config registers of PCI device
- * @pci_dev: PCI device to handle
- */
-static int pci_restore_standard_config(struct pci_dev *pci_dev)
-{
-	pci_update_current_state(pci_dev, PCI_UNKNOWN);
-
-	if (pci_dev->current_state != PCI_D0) {
-		int error = pci_set_power_state(pci_dev, PCI_D0);
-		if (error)
-			return error;
-	}
-
-	return pci_restore_state(pci_dev);
-}
-
-static void pci_pm_default_resume_noirq(struct pci_dev *pci_dev)
-{
-	pci_restore_standard_config(pci_dev);
-	pci_fixup_device(pci_fixup_resume_early, pci_dev);
-}
-
 static void pci_pm_default_resume(struct pci_dev *pci_dev)
 {
 	pci_fixup_device(pci_fixup_resume, pci_dev);
@@ -581,6 +588,17 @@ static int pci_pm_prepare(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	/*
+	 * PCI devices suspended at run time need to be resumed at this
+	 * point, because in general it is necessary to reconfigure them for
+	 * system suspend.  Namely, if the device is supposed to wake up the
+	 * system from the sleep state, we may need to reconfigure it for this
+	 * purpose.  In turn, if the device is not supposed to wake up the
+	 * system from the sleep state, we'll have to prevent it from signaling
+	 * wake-up.
+	 */
+	pm_runtime_resume(dev);
+
 	if (drv && drv->pm && drv->pm->prepare)
 		error = drv->pm->prepare(dev);
 
@@ -595,6 +613,13 @@ static void pci_pm_complete(struct device *dev)
 		drv->pm->complete(dev);
 }
 
+#else /* !CONFIG_PM_SLEEP */
+
+#define pci_pm_prepare	NULL
+#define pci_pm_complete	NULL
+
+#endif /* !CONFIG_PM_SLEEP */
+
 #ifdef CONFIG_SUSPEND
 
 static int pci_pm_suspend(struct device *dev)
@@ -681,7 +706,7 @@ static int pci_pm_resume_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	pci_pm_default_resume_noirq(pci_dev);
+	pci_pm_default_resume_early(pci_dev);
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
@@ -879,7 +904,7 @@ static int pci_pm_restore_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	pci_pm_default_resume_noirq(pci_dev);
+	pci_pm_default_resume_early(pci_dev);
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
@@ -931,6 +956,84 @@ static int pci_pm_restore(struct device *dev)
 
 #endif /* !CONFIG_HIBERNATION */
 
+#ifdef CONFIG_PM_RUNTIME
+
+static int pci_pm_runtime_suspend(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+	pci_power_t prev = pci_dev->current_state;
+	int error;
+
+	if (!pm || !pm->runtime_suspend)
+		return -ENOSYS;
+
+	error = pm->runtime_suspend(dev);
+	suspend_report_result(pm->runtime_suspend, error);
+	if (error)
+		return error;
+
+	pci_fixup_device(pci_fixup_suspend, pci_dev);
+
+	if (!pci_dev->state_saved && pci_dev->current_state != PCI_D0
+	    && pci_dev->current_state != PCI_UNKNOWN) {
+		WARN_ONCE(pci_dev->current_state != prev,
+			"PCI PM: State of device not saved by %pF\n",
+			pm->runtime_suspend);
+		return 0;
+	}
+
+	if (!pci_dev->state_saved)
+		pci_save_state(pci_dev);
+
+	pci_finish_runtime_suspend(pci_dev);
+
+	return 0;
+}
+
+static int pci_pm_runtime_resume(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (!pm || !pm->runtime_resume)
+		return -ENOSYS;
+
+	pci_pm_default_resume_early(pci_dev);
+	__pci_enable_wake(pci_dev, PCI_D0, true, false);
+	pci_fixup_device(pci_fixup_resume, pci_dev);
+
+	return pm->runtime_resume(dev);
+}
+
+static int pci_pm_runtime_idle(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (!pm)
+		return -ENOSYS;
+
+	if (pm->runtime_idle) {
+		int ret = pm->runtime_idle(dev);
+		if (ret)
+			return ret;
+	}
+
+	pm_runtime_suspend(dev);
+
+	return 0;
+}
+
+#else /* !CONFIG_PM_RUNTIME */
+
+#define pci_pm_runtime_suspend	NULL
+#define pci_pm_runtime_resume	NULL
+#define pci_pm_runtime_idle	NULL
+
+#endif /* !CONFIG_PM_RUNTIME */
+
+#ifdef CONFIG_PM_OPS
+
 const struct dev_pm_ops pci_dev_pm_ops = {
 	.prepare = pci_pm_prepare,
 	.complete = pci_pm_complete,
@@ -946,15 +1049,18 @@ const struct dev_pm_ops pci_dev_pm_ops = {
 	.thaw_noirq = pci_pm_thaw_noirq,
 	.poweroff_noirq = pci_pm_poweroff_noirq,
 	.restore_noirq = pci_pm_restore_noirq,
+	.runtime_suspend = pci_pm_runtime_suspend,
+	.runtime_resume = pci_pm_runtime_resume,
+	.runtime_idle = pci_pm_runtime_idle,
 };
 
 #define PCI_PM_OPS_PTR	(&pci_dev_pm_ops)
 
-#else /* !CONFIG_PM_SLEEP */
+#else /* !COMFIG_PM_OPS */
 
 #define PCI_PM_OPS_PTR	NULL
 
-#endif /* !CONFIG_PM_SLEEP */
+#endif /* !COMFIG_PM_OPS */
 
 /**
  * __pci_register_driver - register a new pci driver

commit 4406c56d0a4da7a37b9180abeaece6cd00bcc874
Merge: 6b7b352f2102 5e3573db2bd5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 16 07:49:54 2009 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (75 commits)
      PCI hotplug: clean up acpi_run_hpp()
      PCI hotplug: acpiphp: use generic pci_configure_slot()
      PCI hotplug: shpchp: use generic pci_configure_slot()
      PCI hotplug: pciehp: use generic pci_configure_slot()
      PCI hotplug: add pci_configure_slot()
      PCI hotplug: clean up acpi_get_hp_params_from_firmware() interface
      PCI hotplug: acpiphp: don't cache hotplug_params in acpiphp_bridge
      PCI hotplug: acpiphp: remove superfluous _HPP/_HPX evaluation
      PCI: Clear saved_state after the state has been restored
      PCI PM: Return error codes from pci_pm_resume()
      PCI: use dev_printk in quirk messages
      PCI / PCIe portdrv: Fix pcie_portdrv_slot_reset()
      PCI Hotplug: convert acpi_pci_detect_ejectable() to take an acpi_handle
      PCI Hotplug: acpiphp: find bridges the easy way
      PCI: pcie portdrv: remove unused variable
      PCI / ACPI PM: Propagate wake-up enable for devices w/o ACPI support
      ACPI PM: Replace wakeup.prepared with reference counter
      PCI PM: Introduce device flag wakeup_prepared
      PCI / ACPI PM: Rework some debug messages
      PCI PM: Simplify PCI wake-up code
      ...
    
    Fixed up conflict in arch/powerpc/kernel/pci_64.c due to OF device tree
    scanning having been moved and merged for the 32- and 64-bit cases.  The
    'needs_freset' initialization added in 6e19314cc ("PCI/powerpc: support
    PCIe fundamental reset") is now in arch/powerpc/kernel/pci_of_scan.c.

commit 4b77b0a2ba27d64f58f16d8d4d48d8319dda36ff
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Sep 9 23:49:59 2009 +0200

    PCI: Clear saved_state after the state has been restored
    
    Some PCI devices fail if their standard configuration registers are
    restored twice in a row.  Prevent this from happening by making
    pci_restore_state() clear the saved_state flag of the device right
    after the device's standard configuration registers have been
    populated with the previously saved values.
    
    Simplify PCI PM callbacks by removing the direct clearing of
    state_saved from them, as it shouldn't be necessary any more (except
    in pci_pm_thaw(), where it has to be cleared, so that the values saved
    during the "freeze" phase of hibernation are not used later by mistake).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index dbfc93cb5d01..ffc15e97d11c 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -445,8 +445,6 @@ static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	struct pci_driver * drv = pci_dev->driver;
 
-	pci_dev->state_saved = false;
-
 	if (drv && drv->suspend) {
 		pci_power_t prev = pci_dev->current_state;
 		int error;
@@ -542,7 +540,6 @@ static int pci_restore_standard_config(struct pci_dev *pci_dev)
 static void pci_pm_default_resume_noirq(struct pci_dev *pci_dev)
 {
 	pci_restore_standard_config(pci_dev);
-	pci_dev->state_saved = false;
 	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 }
 
@@ -608,8 +605,6 @@ static int pci_pm_suspend(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_SUSPEND);
 
-	pci_dev->state_saved = false;
-
 	if (!pm) {
 		pci_pm_default_suspend(pci_dev);
 		goto Fixup;
@@ -744,8 +739,6 @@ static int pci_pm_freeze(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_FREEZE);
 
-	pci_dev->state_saved = false;
-
 	if (!pm) {
 		pci_pm_default_suspend(pci_dev);
 		return 0;
@@ -821,6 +814,8 @@ static int pci_pm_thaw(struct device *dev)
 		pci_pm_reenable_device(pci_dev);
 	}
 
+	pci_dev->state_saved = false;
+
 	return error;
 }
 
@@ -832,8 +827,6 @@ static int pci_pm_poweroff(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_HIBERNATE);
 
-	pci_dev->state_saved = false;
-
 	if (!pm) {
 		pci_pm_default_suspend(pci_dev);
 		goto Fixup;

commit 999cce4a52d5abdda5d2cec6bac241899bc19e4c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Sep 9 23:51:27 2009 +0200

    PCI PM: Return error codes from pci_pm_resume()
    
    Currently pci_pm_resume() always returns 0, which makes the error
    variable defined in there a bit pointless.  Make pci_pm_resume()
    return error codes obtained from drivers' callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index c66dc4341fa0..dbfc93cb5d01 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -722,7 +722,7 @@ static int pci_pm_resume(struct device *dev)
 		pci_pm_reenable_device(pci_dev);
 	}
 
-	return 0;
+	return error;
 }
 
 #else /* !CONFIG_SUSPEND */

commit 9dba910e9de2c4aa15ec1286f10052c107ef48ca
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Sep 3 15:26:36 2009 +0900

    PCI: separate out pci_add_dynid()
    
    Separate out pci_add_dynid() from store_new_id() and export it so that
    in-kernel code can add PCI IDs dynamically.  As the function will be
    available regardless of HOTPLUG, put it and pull pci_free_dynids()
    outside of CONFIG_HOTPLUG.
    
    This will be used by pci-stub to initialize initial IDs via module
    param.
    
    While at it, remove bogus get_driver() failure check.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Reviewed-by: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index f99bc7f089f1..c66dc4341fa0 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -19,37 +19,98 @@
 #include <linux/cpu.h>
 #include "pci.h"
 
-/*
- * Dynamic device IDs are disabled for !CONFIG_HOTPLUG
- */
-
 struct pci_dynid {
 	struct list_head node;
 	struct pci_device_id id;
 };
 
-#ifdef CONFIG_HOTPLUG
+/**
+ * pci_add_dynid - add a new PCI device ID to this driver and re-probe devices
+ * @drv: target pci driver
+ * @vendor: PCI vendor ID
+ * @device: PCI device ID
+ * @subvendor: PCI subvendor ID
+ * @subdevice: PCI subdevice ID
+ * @class: PCI class
+ * @class_mask: PCI class mask
+ * @driver_data: private driver data
+ *
+ * Adds a new dynamic pci device ID to this driver and causes the
+ * driver to probe for all devices again.  @drv must have been
+ * registered prior to calling this function.
+ *
+ * CONTEXT:
+ * Does GFP_KERNEL allocation.
+ *
+ * RETURNS:
+ * 0 on success, -errno on failure.
+ */
+int pci_add_dynid(struct pci_driver *drv,
+		  unsigned int vendor, unsigned int device,
+		  unsigned int subvendor, unsigned int subdevice,
+		  unsigned int class, unsigned int class_mask,
+		  unsigned long driver_data)
+{
+	struct pci_dynid *dynid;
+	int retval;
+
+	dynid = kzalloc(sizeof(*dynid), GFP_KERNEL);
+	if (!dynid)
+		return -ENOMEM;
+
+	dynid->id.vendor = vendor;
+	dynid->id.device = device;
+	dynid->id.subvendor = subvendor;
+	dynid->id.subdevice = subdevice;
+	dynid->id.class = class;
+	dynid->id.class_mask = class_mask;
+	dynid->id.driver_data = driver_data;
 
+	spin_lock(&drv->dynids.lock);
+	list_add_tail(&dynid->node, &drv->dynids.list);
+	spin_unlock(&drv->dynids.lock);
+
+	get_driver(&drv->driver);
+	retval = driver_attach(&drv->driver);
+	put_driver(&drv->driver);
+
+	return retval;
+}
+
+static void pci_free_dynids(struct pci_driver *drv)
+{
+	struct pci_dynid *dynid, *n;
+
+	spin_lock(&drv->dynids.lock);
+	list_for_each_entry_safe(dynid, n, &drv->dynids.list, node) {
+		list_del(&dynid->node);
+		kfree(dynid);
+	}
+	spin_unlock(&drv->dynids.lock);
+}
+
+/*
+ * Dynamic device ID manipulation via sysfs is disabled for !CONFIG_HOTPLUG
+ */
+#ifdef CONFIG_HOTPLUG
 /**
- * store_new_id - add a new PCI device ID to this driver and re-probe devices
+ * store_new_id - sysfs frontend to pci_add_dynid()
  * @driver: target device driver
  * @buf: buffer for scanning device ID data
  * @count: input size
  *
- * Adds a new dynamic pci device ID to this driver,
- * and causes the driver to probe for all devices again.
+ * Allow PCI IDs to be added to an existing driver via sysfs.
  */
 static ssize_t
 store_new_id(struct device_driver *driver, const char *buf, size_t count)
 {
-	struct pci_dynid *dynid;
 	struct pci_driver *pdrv = to_pci_driver(driver);
 	const struct pci_device_id *ids = pdrv->id_table;
 	__u32 vendor, device, subvendor=PCI_ANY_ID,
 		subdevice=PCI_ANY_ID, class=0, class_mask=0;
 	unsigned long driver_data=0;
 	int fields=0;
-	int retval=0;
+	int retval;
 
 	fields = sscanf(buf, "%x %x %x %x %x %x %lx",
 			&vendor, &device, &subvendor, &subdevice,
@@ -72,27 +133,8 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 			return retval;
 	}
 
-	dynid = kzalloc(sizeof(*dynid), GFP_KERNEL);
-	if (!dynid)
-		return -ENOMEM;
-
-	dynid->id.vendor = vendor;
-	dynid->id.device = device;
-	dynid->id.subvendor = subvendor;
-	dynid->id.subdevice = subdevice;
-	dynid->id.class = class;
-	dynid->id.class_mask = class_mask;
-	dynid->id.driver_data = driver_data;
-
-	spin_lock(&pdrv->dynids.lock);
-	list_add_tail(&dynid->node, &pdrv->dynids.list);
-	spin_unlock(&pdrv->dynids.lock);
-
-	if (get_driver(&pdrv->driver)) {
-		retval = driver_attach(&pdrv->driver);
-		put_driver(&pdrv->driver);
-	}
-
+	retval = pci_add_dynid(pdrv, vendor, device, subvendor, subdevice,
+			       class, class_mask, driver_data);
 	if (retval)
 		return retval;
 	return count;
@@ -145,19 +187,6 @@ store_remove_id(struct device_driver *driver, const char *buf, size_t count)
 }
 static DRIVER_ATTR(remove_id, S_IWUSR, NULL, store_remove_id);
 
-static void
-pci_free_dynids(struct pci_driver *drv)
-{
-	struct pci_dynid *dynid, *n;
-
-	spin_lock(&drv->dynids.lock);
-	list_for_each_entry_safe(dynid, n, &drv->dynids.list, node) {
-		list_del(&dynid->node);
-		kfree(dynid);
-	}
-	spin_unlock(&drv->dynids.lock);
-}
-
 static int
 pci_create_newid_file(struct pci_driver *drv)
 {
@@ -186,7 +215,6 @@ static void pci_remove_removeid_file(struct pci_driver *drv)
 	driver_remove_file(&drv->driver, &driver_attr_remove_id);
 }
 #else /* !CONFIG_HOTPLUG */
-static inline void pci_free_dynids(struct pci_driver *drv) {}
 static inline int pci_create_newid_file(struct pci_driver *drv)
 {
 	return 0;
@@ -1106,6 +1134,7 @@ static int __init pci_driver_init(void)
 
 postcore_initcall(pci_driver_init);
 
+EXPORT_SYMBOL_GPL(pci_add_dynid);
 EXPORT_SYMBOL(pci_match_id);
 EXPORT_SYMBOL(__pci_register_driver);
 EXPORT_SYMBOL(pci_unregister_driver);

commit 4b61bb575b1fb42ab1df228ae7812e5135f656da
Merge: 805423e84e90 326ba5010a54
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Aug 27 22:00:20 2009 -0700

    Merge commit 'v2.6.31-rc8' into next

commit c82f63e411f1b58427c103bd95af2863b1c96dd1
Author: Alek Du <alek.du@intel.com>
Date:   Sat Aug 8 08:46:19 2009 +0800

    PCI: check saved state before restore
    
    Without the check, the config space may be filled with zeros. Though
    the driver should try to avoid call restoring before saving, but the
    pci layer also should check this.
    
    Also removes the existing check in pci_restore_standard_config, since
    it's superfluous with the new check in restore_state.
    
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Alek Du <alek.du@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index d76c4c85367e..f99bc7f089f1 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -508,7 +508,7 @@ static int pci_restore_standard_config(struct pci_dev *pci_dev)
 			return error;
 	}
 
-	return pci_dev->state_saved ? pci_restore_state(pci_dev) : 0;
+	return pci_restore_state(pci_dev);
 }
 
 static void pci_pm_default_resume_noirq(struct pci_dev *pci_dev)

commit 8150f32b90f630ad3e460f026ce338cb81685bc9
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Jul 24 22:11:32 2009 -0700

    Driver Core: Make PM operations a const pointer
    
    They are not supposed to be modified by drivers, so make them const.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index d76c4c85367e..0c2ea44ae5e1 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -575,7 +575,7 @@ static void pci_pm_complete(struct device *dev)
 static int pci_pm_suspend(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_SUSPEND);
@@ -613,7 +613,7 @@ static int pci_pm_suspend(struct device *dev)
 static int pci_pm_suspend_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend_late(dev, PMSG_SUSPEND);
@@ -672,7 +672,7 @@ static int pci_pm_resume_noirq(struct device *dev)
 static int pci_pm_resume(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 	int error = 0;
 
 	/*
@@ -711,7 +711,7 @@ static int pci_pm_resume(struct device *dev)
 static int pci_pm_freeze(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_FREEZE);
@@ -780,7 +780,7 @@ static int pci_pm_thaw_noirq(struct device *dev)
 static int pci_pm_thaw(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 	int error = 0;
 
 	if (pci_has_legacy_pm_support(pci_dev))
@@ -799,7 +799,7 @@ static int pci_pm_thaw(struct device *dev)
 static int pci_pm_poweroff(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_HIBERNATE);
@@ -872,7 +872,7 @@ static int pci_pm_restore_noirq(struct device *dev)
 static int pci_pm_restore(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 	int error = 0;
 
 	/*
@@ -910,7 +910,7 @@ static int pci_pm_restore(struct device *dev)
 
 #endif /* !CONFIG_HIBERNATION */
 
-struct dev_pm_ops pci_dev_pm_ops = {
+const struct dev_pm_ops pci_dev_pm_ops = {
 	.prepare = pci_pm_prepare,
 	.complete = pci_pm_complete,
 	.suspend = pci_pm_suspend,

commit 90975ef71246c5c688ead04e8ff6f36dc92d28b3
Merge: cab4e4c43f92 558f6ab9106e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 5 10:33:07 2009 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux-2.6-cpumask
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux-2.6-cpumask: (36 commits)
      cpumask: remove cpumask allocation from idle_balance, fix
      numa, cpumask: move numa_node_id default implementation to topology.h, fix
      cpumask: remove cpumask allocation from idle_balance
      x86: cpumask: x86 mmio-mod.c use cpumask_var_t for downed_cpus
      x86: cpumask: update 32-bit APM not to mug current->cpus_allowed
      x86: microcode: cleanup
      x86: cpumask: use work_on_cpu in arch/x86/kernel/microcode_core.c
      cpumask: fix CONFIG_CPUMASK_OFFSTACK=y cpu hotunplug crash
      numa, cpumask: move numa_node_id default implementation to topology.h
      cpumask: convert node_to_cpumask_map[] to cpumask_var_t
      cpumask: remove x86 cpumask_t uses.
      cpumask: use cpumask_var_t in uv_flush_tlb_others.
      cpumask: remove cpumask_t assignment from vector_allocation_domain()
      cpumask: make Xen use the new operators.
      cpumask: clean up summit's send_IPI functions
      cpumask: use new cpumask functions throughout x86
      x86: unify cpu_callin_mask/cpu_callout_mask/cpu_initialized_mask/cpu_sibling_setup_mask
      cpumask: convert struct cpuinfo_x86's llc_shared_map to cpumask_var_t
      cpumask: convert node_to_cpumask_map[] to cpumask_var_t
      x86: unify 32 and 64-bit node_to_cpumask_map
      ...

commit e76e5b2c663ac74ae6a542ac20795c625e36a5cd
Merge: 32527bc0e4b4 eeafda70bf28
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 1 09:47:12 2009 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (88 commits)
      PCI: fix HT MSI mapping fix
      PCI: don't enable too much HT MSI mapping
      x86/PCI: make pci=lastbus=255 work when acpi is on
      PCI: save and restore PCIe 2.0 registers
      PCI: update fakephp for bus_id removal
      PCI: fix kernel oops on bridge removal
      PCI: fix conflict between SR-IOV and config space sizing
      powerpc/PCI: include pci.h in powerpc MSI implementation
      PCI Hotplug: schedule fakephp for feature removal
      PCI Hotplug: rename legacy_fakephp to fakephp
      PCI Hotplug: restore fakephp interface with complete reimplementation
      PCI: Introduce /sys/bus/pci/devices/.../rescan
      PCI: Introduce /sys/bus/pci/devices/.../remove
      PCI: Introduce /sys/bus/pci/rescan
      PCI: Introduce pci_rescan_bus()
      PCI: do not enable bridges more than once
      PCI: do not initialize bridges more than once
      PCI: always scan child buses
      PCI: pci_scan_slot() returns newly found devices
      PCI: don't scan existing devices
      ...
    
    Fix trivial append-only conflict in Documentation/feature-removal-schedule.txt

commit 558f6ab9106e6be701acb0257e7171df1bbccf04
Merge: 15f7176eb1cc 65fb0d23fcdd
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Tue Mar 31 13:33:50 2009 +1030

    Merge branch 'cpumask-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    Conflicts:
    
            arch/x86/include/asm/topology.h
            drivers/oprofile/buffer_sync.c
    (Both cases: changed in Linus' tree, removed in Ingo's).

commit 931ff68a5a53fa84bcdf9b1b179a80e54e034bd0
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Mar 16 22:40:50 2009 +0100

    PCI PM: Restore config spaces of all devices during early resume
    
    At present the configuration spaces of PCI devices that have no
    drivers or no PM support in the drivers (either legacy or through a
    pm object) are not saved during suspend and, consequently, they are
    not restored during resume.  This generally may lead to the state of
    the system being slightly inconsistent after the resume, so it's
    better to save and restore the configuration spaces of these devices
    as well.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 3c1831c82f5b..267de88551c9 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -516,13 +516,13 @@ static int pci_pm_suspend(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_SUSPEND);
 
+	pci_dev->state_saved = false;
+
 	if (!pm) {
 		pci_pm_default_suspend(pci_dev);
 		goto Fixup;
 	}
 
-	pci_dev->state_saved = false;
-
 	if (pm->suspend) {
 		pci_power_t prev = pci_dev->current_state;
 		int error;
@@ -554,8 +554,10 @@ static int pci_pm_suspend_noirq(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend_late(dev, PMSG_SUSPEND);
 
-	if (!pm)
+	if (!pm) {
+		pci_save_state(pci_dev);
 		return 0;
+	}
 
 	if (pm->suspend_noirq) {
 		pci_power_t prev = pci_dev->current_state;
@@ -650,13 +652,13 @@ static int pci_pm_freeze(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_FREEZE);
 
+	pci_dev->state_saved = false;
+
 	if (!pm) {
 		pci_pm_default_suspend(pci_dev);
 		return 0;
 	}
 
-	pci_dev->state_saved = false;
-
 	if (pm->freeze) {
 		int error;
 
@@ -738,13 +740,13 @@ static int pci_pm_poweroff(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_HIBERNATE);
 
+	pci_dev->state_saved = false;
+
 	if (!pm) {
 		pci_pm_default_suspend(pci_dev);
 		goto Fixup;
 	}
 
-	pci_dev->state_saved = false;
-
 	if (pm->poweroff) {
 		int error;
 

commit 46939f8b15e44f065d052e89ea4f2adc81fdc740
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Mar 16 22:40:26 2009 +0100

    PCI PM: Put devices into low power states during late suspend (rev. 2)
    
    Once we have allowed timer interrupts to be enabled during the late
    phase of suspending devices, we are now able to use the generic
    pci_set_power_state() to put PCI devices into low power states at
    that time.  We can also use some related platform callbacks, like the
    ones preparing devices for wake-up, during the late suspend.
    
    Doing this will allow us to avoid the race condition where a device
    using shared interrupts is put into a low power state with interrupts
    enabled and then an interrupt (for another device) comes in and
    confuses its driver.  At the same time, devices that don't support
    the native PCI PM or that require some additional, platform-specific
    operations to be carried out to put them into low power states will
    be handled as appropriate.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 8395206d1aee..3c1831c82f5b 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -352,53 +352,60 @@ static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 {
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	struct pci_driver * drv = pci_dev->driver;
-	int error = 0;
+
+	pci_dev->state_saved = false;
 
 	if (drv && drv->suspend) {
 		pci_power_t prev = pci_dev->current_state;
-
-		pci_dev->state_saved = false;
+		int error;
 
 		error = drv->suspend(pci_dev, state);
 		suspend_report_result(drv->suspend, error);
 		if (error)
 			return error;
 
-		if (pci_dev->state_saved)
-			goto Fixup;
-
-		if (pci_dev->current_state != PCI_D0
+		if (!pci_dev->state_saved && pci_dev->current_state != PCI_D0
 		    && pci_dev->current_state != PCI_UNKNOWN) {
 			WARN_ONCE(pci_dev->current_state != prev,
 				"PCI PM: Device state not saved by %pF\n",
 				drv->suspend);
-			goto Fixup;
 		}
 	}
 
-	pci_save_state(pci_dev);
-	/*
-	 * This is for compatibility with existing code with legacy PM support.
-	 */
-	pci_pm_set_unknown_state(pci_dev);
-
- Fixup:
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
 
-	return error;
+	return 0;
 }
 
 static int pci_legacy_suspend_late(struct device *dev, pm_message_t state)
 {
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	struct pci_driver * drv = pci_dev->driver;
-	int error = 0;
 
 	if (drv && drv->suspend_late) {
+		pci_power_t prev = pci_dev->current_state;
+		int error;
+
 		error = drv->suspend_late(pci_dev, state);
 		suspend_report_result(drv->suspend_late, error);
+		if (error)
+			return error;
+
+		if (!pci_dev->state_saved && pci_dev->current_state != PCI_D0
+		    && pci_dev->current_state != PCI_UNKNOWN) {
+			WARN_ONCE(pci_dev->current_state != prev,
+				"PCI PM: Device state not saved by %pF\n",
+				drv->suspend_late);
+			return 0;
+		}
 	}
-	return error;
+
+	if (!pci_dev->state_saved)
+		pci_save_state(pci_dev);
+
+	pci_pm_set_unknown_state(pci_dev);
+
+	return 0;
 }
 
 static int pci_legacy_resume_early(struct device *dev)
@@ -460,7 +467,6 @@ static void pci_pm_default_suspend(struct pci_dev *pci_dev)
 	/* Disable non-bridge devices without PM support */
 	if (!pci_is_bridge(pci_dev))
 		pci_disable_enabled_device(pci_dev);
-	pci_save_state(pci_dev);
 }
 
 static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
@@ -526,24 +532,14 @@ static int pci_pm_suspend(struct device *dev)
 		if (error)
 			return error;
 
-		if (pci_dev->state_saved)
-			goto Fixup;
-
-		if (pci_dev->current_state != PCI_D0
+		if (!pci_dev->state_saved && pci_dev->current_state != PCI_D0
 		    && pci_dev->current_state != PCI_UNKNOWN) {
 			WARN_ONCE(pci_dev->current_state != prev,
 				"PCI PM: State of device not saved by %pF\n",
 				pm->suspend);
-			goto Fixup;
 		}
 	}
 
-	if (!pci_dev->state_saved) {
-		pci_save_state(pci_dev);
-		if (!pci_is_bridge(pci_dev))
-			pci_prepare_to_sleep(pci_dev);
-	}
-
  Fixup:
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
 
@@ -553,21 +549,41 @@ static int pci_pm_suspend(struct device *dev)
 static int pci_pm_suspend_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct device_driver *drv = dev->driver;
-	int error = 0;
+	struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend_late(dev, PMSG_SUSPEND);
 
-	if (drv && drv->pm && drv->pm->suspend_noirq) {
-		error = drv->pm->suspend_noirq(dev);
-		suspend_report_result(drv->pm->suspend_noirq, error);
+	if (!pm)
+		return 0;
+
+	if (pm->suspend_noirq) {
+		pci_power_t prev = pci_dev->current_state;
+		int error;
+
+		error = pm->suspend_noirq(dev);
+		suspend_report_result(pm->suspend_noirq, error);
+		if (error)
+			return error;
+
+		if (!pci_dev->state_saved && pci_dev->current_state != PCI_D0
+		    && pci_dev->current_state != PCI_UNKNOWN) {
+			WARN_ONCE(pci_dev->current_state != prev,
+				"PCI PM: State of device not saved by %pF\n",
+				pm->suspend_noirq);
+			return 0;
+		}
 	}
 
-	if (!error)
-		pci_pm_set_unknown_state(pci_dev);
+	if (!pci_dev->state_saved) {
+		pci_save_state(pci_dev);
+		if (!pci_is_bridge(pci_dev))
+			pci_prepare_to_sleep(pci_dev);
+	}
 
-	return error;
+	pci_pm_set_unknown_state(pci_dev);
+
+	return 0;
 }
 
 static int pci_pm_resume_noirq(struct device *dev)
@@ -650,9 +666,6 @@ static int pci_pm_freeze(struct device *dev)
 			return error;
 	}
 
-	if (!pci_dev->state_saved)
-		pci_save_state(pci_dev);
-
 	return 0;
 }
 
@@ -660,20 +673,25 @@ static int pci_pm_freeze_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
-	int error = 0;
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend_late(dev, PMSG_FREEZE);
 
 	if (drv && drv->pm && drv->pm->freeze_noirq) {
+		int error;
+
 		error = drv->pm->freeze_noirq(dev);
 		suspend_report_result(drv->pm->freeze_noirq, error);
+		if (error)
+			return error;
 	}
 
-	if (!error)
-		pci_pm_set_unknown_state(pci_dev);
+	if (!pci_dev->state_saved)
+		pci_save_state(pci_dev);
 
-	return error;
+	pci_pm_set_unknown_state(pci_dev);
+
+	return 0;
 }
 
 static int pci_pm_thaw_noirq(struct device *dev)
@@ -716,7 +734,6 @@ static int pci_pm_poweroff(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
-	int error = 0;
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_HIBERNATE);
@@ -729,33 +746,44 @@ static int pci_pm_poweroff(struct device *dev)
 	pci_dev->state_saved = false;
 
 	if (pm->poweroff) {
+		int error;
+
 		error = pm->poweroff(dev);
 		suspend_report_result(pm->poweroff, error);
+		if (error)
+			return error;
 	}
 
-	if (!pci_dev->state_saved && !pci_is_bridge(pci_dev))
-		pci_prepare_to_sleep(pci_dev);
-
  Fixup:
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
 
-	return error;
+	return 0;
 }
 
 static int pci_pm_poweroff_noirq(struct device *dev)
 {
+	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
-	int error = 0;
 
 	if (pci_has_legacy_pm_support(to_pci_dev(dev)))
 		return pci_legacy_suspend_late(dev, PMSG_HIBERNATE);
 
-	if (drv && drv->pm && drv->pm->poweroff_noirq) {
+	if (!drv || !drv->pm)
+		return 0;
+
+	if (drv->pm->poweroff_noirq) {
+		int error;
+
 		error = drv->pm->poweroff_noirq(dev);
 		suspend_report_result(drv->pm->poweroff_noirq, error);
+		if (error)
+			return error;
 	}
 
-	return error;
+	if (!pci_dev->state_saved && !pci_is_bridge(pci_dev))
+		pci_prepare_to_sleep(pci_dev);
+
+	return 0;
 }
 
 static int pci_pm_restore_noirq(struct device *dev)

commit 0128a89cf75124500b5b69f0c3c7b7c5aa60676f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Mar 16 22:40:18 2009 +0100

    PCI PM: Move pci_restore_standard_config to pci-driver.c
    
    Move pci_restore_standard_config() from pci.c to pci-driver.c and
    make it static.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index a5f11ad975b2..8395206d1aee 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -423,6 +423,23 @@ static int pci_legacy_resume(struct device *dev)
 
 /* Auxiliary functions used by the new power management framework */
 
+/**
+ * pci_restore_standard_config - restore standard config registers of PCI device
+ * @pci_dev: PCI device to handle
+ */
+static int pci_restore_standard_config(struct pci_dev *pci_dev)
+{
+	pci_update_current_state(pci_dev, PCI_UNKNOWN);
+
+	if (pci_dev->current_state != PCI_D0) {
+		int error = pci_set_power_state(pci_dev, PCI_D0);
+		if (error)
+			return error;
+	}
+
+	return pci_dev->state_saved ? pci_restore_state(pci_dev) : 0;
+}
+
 static void pci_pm_default_resume_noirq(struct pci_dev *pci_dev)
 {
 	pci_restore_standard_config(pci_dev);

commit 57ef80266e14ecc363380268fedc64e519047b4a
Author: Frans Pop <elendil@planet.nl>
Date:   Mon Mar 16 22:39:56 2009 +0100

    PCI PM: Consistently use variable name "error" for pm call return values
    
    I noticed two functions use a variable "i" to store the return value of PM
    function calls while the rest of the file uses "error". As "i" normally
    indicates a counter of some sort it seems better to keep this consistent.
    
    Signed-off-by: Frans Pop <elendil@planet.nl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 93eac1423585..a5f11ad975b2 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -352,17 +352,17 @@ static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 {
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	struct pci_driver * drv = pci_dev->driver;
-	int i = 0;
+	int error = 0;
 
 	if (drv && drv->suspend) {
 		pci_power_t prev = pci_dev->current_state;
 
 		pci_dev->state_saved = false;
 
-		i = drv->suspend(pci_dev, state);
-		suspend_report_result(drv->suspend, i);
-		if (i)
-			return i;
+		error = drv->suspend(pci_dev, state);
+		suspend_report_result(drv->suspend, error);
+		if (error)
+			return error;
 
 		if (pci_dev->state_saved)
 			goto Fixup;
@@ -385,20 +385,20 @@ static int pci_legacy_suspend(struct device *dev, pm_message_t state)
  Fixup:
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
 
-	return i;
+	return error;
 }
 
 static int pci_legacy_suspend_late(struct device *dev, pm_message_t state)
 {
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	struct pci_driver * drv = pci_dev->driver;
-	int i = 0;
+	int error = 0;
 
 	if (drv && drv->suspend_late) {
-		i = drv->suspend_late(pci_dev, state);
-		suspend_report_result(drv->suspend_late, i);
+		error = drv->suspend_late(pci_dev, state);
+		suspend_report_result(drv->suspend_late, error);
 	}
-	return i;
+	return error;
 }
 
 static int pci_legacy_resume_early(struct device *dev)

commit 705b1aaa823e800490f157cd9366ad8cff385f5f
Author: Alex Chiang <achiang@hp.com>
Date:   Fri Mar 20 14:56:31 2009 -0600

    PCI: Introduce /sys/bus/pci/rescan
    
    This interface allows the user to force a rescan of all PCI buses
    in system, and rediscover devices that have been removed earlier.
    
    pci_bus_attrs implementation from Trent Piepho.
    
    Thanks to Vegard Nossum for discovering locking issues with the
    sysfs interface.
    
    Cc: Trent Piepho <xyzzy@speakeasy.org>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 87a5ddbb324f..95d198570290 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1049,6 +1049,7 @@ struct bus_type pci_bus_type = {
 	.remove		= pci_device_remove,
 	.shutdown	= pci_device_shutdown,
 	.dev_attrs	= pci_dev_attrs,
+	.bus_attrs	= pci_bus_attrs,
 	.pm		= PCI_PM_OPS_PTR,
 };
 

commit 0994375e9614f78657031e04e30019b9cdb62795
Author: Chris Wright <chrisw@sous-sol.org>
Date:   Mon Feb 23 21:52:23 2009 -0800

    PCI: add remove_id sysfs entry
    
    This adds a remove_id sysfs entry to allow users of new_id to later
    remove the added dynid.  One use case is management tools that want to
    dynamically bind/unbind devices to pci-stub driver while devices are
    assigned to KVM guests.  Rather than having to track which driver was
    originally bound to the driver, a mangement tool can simply:
    
    Guest uses device
    
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 93eac1423585..87a5ddbb324f 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -99,6 +99,52 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 }
 static DRIVER_ATTR(new_id, S_IWUSR, NULL, store_new_id);
 
+/**
+ * store_remove_id - remove a PCI device ID from this driver
+ * @driver: target device driver
+ * @buf: buffer for scanning device ID data
+ * @count: input size
+ *
+ * Removes a dynamic pci device ID to this driver.
+ */
+static ssize_t
+store_remove_id(struct device_driver *driver, const char *buf, size_t count)
+{
+	struct pci_dynid *dynid, *n;
+	struct pci_driver *pdrv = to_pci_driver(driver);
+	__u32 vendor, device, subvendor = PCI_ANY_ID,
+		subdevice = PCI_ANY_ID, class = 0, class_mask = 0;
+	int fields = 0;
+	int retval = -ENODEV;
+
+	fields = sscanf(buf, "%x %x %x %x %x %x",
+			&vendor, &device, &subvendor, &subdevice,
+			&class, &class_mask);
+	if (fields < 2)
+		return -EINVAL;
+
+	spin_lock(&pdrv->dynids.lock);
+	list_for_each_entry_safe(dynid, n, &pdrv->dynids.list, node) {
+		struct pci_device_id *id = &dynid->id;
+		if ((id->vendor == vendor) &&
+		    (id->device == device) &&
+		    (subvendor == PCI_ANY_ID || id->subvendor == subvendor) &&
+		    (subdevice == PCI_ANY_ID || id->subdevice == subdevice) &&
+		    !((id->class ^ class) & class_mask)) {
+			list_del(&dynid->node);
+			kfree(dynid);
+			retval = 0;
+			break;
+		}
+	}
+	spin_unlock(&pdrv->dynids.lock);
+
+	if (retval)
+		return retval;
+	return count;
+}
+static DRIVER_ATTR(remove_id, S_IWUSR, NULL, store_remove_id);
+
 static void
 pci_free_dynids(struct pci_driver *drv)
 {
@@ -125,6 +171,20 @@ static void pci_remove_newid_file(struct pci_driver *drv)
 {
 	driver_remove_file(&drv->driver, &driver_attr_new_id);
 }
+
+static int
+pci_create_removeid_file(struct pci_driver *drv)
+{
+	int error = 0;
+	if (drv->probe != NULL)
+		error = driver_create_file(&drv->driver,&driver_attr_remove_id);
+	return error;
+}
+
+static void pci_remove_removeid_file(struct pci_driver *drv)
+{
+	driver_remove_file(&drv->driver, &driver_attr_remove_id);
+}
 #else /* !CONFIG_HOTPLUG */
 static inline void pci_free_dynids(struct pci_driver *drv) {}
 static inline int pci_create_newid_file(struct pci_driver *drv)
@@ -132,6 +192,11 @@ static inline int pci_create_newid_file(struct pci_driver *drv)
 	return 0;
 }
 static inline void pci_remove_newid_file(struct pci_driver *drv) {}
+static inline int pci_create_removeid_file(struct pci_driver *drv)
+{
+	return 0;
+}
+static inline void pci_remove_removeid_file(struct pci_driver *drv) {}
 #endif
 
 /**
@@ -852,13 +917,23 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 	/* register with core */
 	error = driver_register(&drv->driver);
 	if (error)
-		return error;
+		goto out;
 
 	error = pci_create_newid_file(drv);
 	if (error)
-		driver_unregister(&drv->driver);
+		goto out_newid;
 
+	error = pci_create_removeid_file(drv);
+	if (error)
+		goto out_removeid;
+out:
 	return error;
+
+out_removeid:
+	pci_remove_newid_file(drv);
+out_newid:
+	driver_unregister(&drv->driver);
+	goto out;
 }
 
 /**
@@ -874,6 +949,7 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 void
 pci_unregister_driver(struct pci_driver *drv)
 {
+	pci_remove_removeid_file(drv);
 	pci_remove_newid_file(drv);
 	driver_unregister(&drv->driver);
 	pci_free_dynids(drv);

commit a70f730282019f487aa33a84e5ac9a5e89c5abd0
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Mar 13 14:49:46 2009 +1030

    cpumask: replace node_to_cpumask with cpumask_of_node.
    
    Impact: cleanup
    
    node_to_cpumask (and the blecherous node_to_cpumask_ptr which
    contained a declaration) are replaced now everyone implements
    cpumask_of_node.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 93eac1423585..b522f883d674 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -212,10 +212,9 @@ static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
 	node = dev_to_node(&dev->dev);
 	if (node >= 0) {
 		int cpu;
-		node_to_cpumask_ptr(nodecpumask, node);
 
 		get_online_cpus();
-		cpu = cpumask_any_and(nodecpumask, cpu_online_mask);
+		cpu = cpumask_any_and(cpumask_of_node(node), cpu_online_mask);
 		if (cpu < nr_cpu_ids)
 			error = work_on_cpu(cpu, local_pci_probe, &ddi);
 		else

commit 5294e256717923f4a3297bb8b802f5e0625763f3
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 4 02:09:07 2009 +0100

    PCI PM: make the PM core more careful with drivers using the new PM framework
    
    Currently, the PM core always attempts to manage devices with drivers
    that use the new PM framework.  In particular, it attempts to disable
    the devices (which is unnecessary), to save their state (which may be
    undesirable if the driver has done that already) and to put them into
    low power states (again, this may be undesirable if the driver has
    already put the device into a low power state).  That need not be
    the right thing to do, so make the core be more careful in this
    respect.
    
    Generally, there are the following categories of devices to consider:
    * bridge devices without drivers
    * non-bridge devices without drivers
    * bridge devices with drivers
    * non-bridge devices with drivers
    and each of them should be handled differently.
    
    For bridge devices without drivers the PCI PM core will save their
    state on suspend and restore it (early) during resume, after putting
    them into D0 if necessary.  It will not attempt to do anything else
    to these devices.
    
    For non-bridge devices without drivers the PCI PM core will disable
    them and save their state on suspend.  During resume, it will put
    them into D0, if necessary, restore their state (early) and reenable
    them.
    
    For bridge devices with drivers the PCI PM core will only save
    their state on suspend if the driver hasn't done that already.
    Still, the core will restore their state (early) during resume,
    after putting them into D0, if necessary.
    
    For non-bridge devices with drivers the PCI PM core will only save
    their state on suspend if the driver hasn't done that already.  Also,
    if the state of the device hasn't been saved by the driver, the core
    will attempt to put the device into a low power state.  During
    resume the core will restore the state of the device (early), after
    putting it into D0, if necessary.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index ac6c9e493f4c..93eac1423585 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -430,39 +430,22 @@ static void pci_pm_default_resume_noirq(struct pci_dev *pci_dev)
 	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 }
 
-static int pci_pm_default_resume(struct pci_dev *pci_dev)
+static void pci_pm_default_resume(struct pci_dev *pci_dev)
 {
 	pci_fixup_device(pci_fixup_resume, pci_dev);
 
-	if (pci_is_bridge(pci_dev))
-		return 0;
-
-	pci_enable_wake(pci_dev, PCI_D0, false);
-	return pci_pm_reenable_device(pci_dev);
+	if (!pci_is_bridge(pci_dev))
+		pci_enable_wake(pci_dev, PCI_D0, false);
 }
 
-static void pci_pm_default_suspend_generic(struct pci_dev *pci_dev)
+static void pci_pm_default_suspend(struct pci_dev *pci_dev)
 {
-	/* If a non-bridge device is enabled at this point, disable it */
+	/* Disable non-bridge devices without PM support */
 	if (!pci_is_bridge(pci_dev))
 		pci_disable_enabled_device(pci_dev);
-	/*
-	 * Save state with interrupts enabled, because in principle the bus the
-	 * device is on may be put into a low power state after this code runs.
-	 */
 	pci_save_state(pci_dev);
 }
 
-static void pci_pm_default_suspend(struct pci_dev *pci_dev, bool prepare)
-{
-	pci_pm_default_suspend_generic(pci_dev);
-
-	if (prepare && !pci_is_bridge(pci_dev))
-		pci_prepare_to_sleep(pci_dev);
-
-	pci_fixup_device(pci_fixup_suspend, pci_dev);
-}
-
 static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
 {
 	struct pci_driver *drv = pci_dev->driver;
@@ -506,20 +489,48 @@ static int pci_pm_suspend(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
-	int error = 0;
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_SUSPEND);
 
-	if (pm && pm->suspend) {
+	if (!pm) {
+		pci_pm_default_suspend(pci_dev);
+		goto Fixup;
+	}
+
+	pci_dev->state_saved = false;
+
+	if (pm->suspend) {
+		pci_power_t prev = pci_dev->current_state;
+		int error;
+
 		error = pm->suspend(dev);
 		suspend_report_result(pm->suspend, error);
+		if (error)
+			return error;
+
+		if (pci_dev->state_saved)
+			goto Fixup;
+
+		if (pci_dev->current_state != PCI_D0
+		    && pci_dev->current_state != PCI_UNKNOWN) {
+			WARN_ONCE(pci_dev->current_state != prev,
+				"PCI PM: State of device not saved by %pF\n",
+				pm->suspend);
+			goto Fixup;
+		}
 	}
 
-	if (!error)
-		pci_pm_default_suspend(pci_dev, !!pm);
+	if (!pci_dev->state_saved) {
+		pci_save_state(pci_dev);
+		if (!pci_is_bridge(pci_dev))
+			pci_prepare_to_sleep(pci_dev);
+	}
 
-	return error;
+ Fixup:
+	pci_fixup_device(pci_fixup_suspend, pci_dev);
+
+	return 0;
 }
 
 static int pci_pm_suspend_noirq(struct device *dev)
@@ -562,7 +573,7 @@ static int pci_pm_resume_noirq(struct device *dev)
 static int pci_pm_resume(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct device_driver *drv = dev->driver;
+	struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 	int error = 0;
 
 	/*
@@ -575,12 +586,16 @@ static int pci_pm_resume(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume(dev);
 
-	error = pci_pm_default_resume(pci_dev);
+	pci_pm_default_resume(pci_dev);
 
-	if (!error && drv && drv->pm && drv->pm->resume)
-		error = drv->pm->resume(dev);
+	if (pm) {
+		if (pm->resume)
+			error = pm->resume(dev);
+	} else {
+		pci_pm_reenable_device(pci_dev);
+	}
 
-	return error;
+	return 0;
 }
 
 #else /* !CONFIG_SUSPEND */
@@ -597,21 +612,31 @@ static int pci_pm_resume(struct device *dev)
 static int pci_pm_freeze(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct device_driver *drv = dev->driver;
-	int error = 0;
+	struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_FREEZE);
 
-	if (drv && drv->pm && drv->pm->freeze) {
-		error = drv->pm->freeze(dev);
-		suspend_report_result(drv->pm->freeze, error);
+	if (!pm) {
+		pci_pm_default_suspend(pci_dev);
+		return 0;
 	}
 
-	if (!error)
-		pci_pm_default_suspend_generic(pci_dev);
+	pci_dev->state_saved = false;
 
-	return error;
+	if (pm->freeze) {
+		int error;
+
+		error = pm->freeze(dev);
+		suspend_report_result(pm->freeze, error);
+		if (error)
+			return error;
+	}
+
+	if (!pci_dev->state_saved)
+		pci_save_state(pci_dev);
+
+	return 0;
 }
 
 static int pci_pm_freeze_noirq(struct device *dev)
@@ -654,16 +679,18 @@ static int pci_pm_thaw_noirq(struct device *dev)
 static int pci_pm_thaw(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct device_driver *drv = dev->driver;
+	struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 	int error = 0;
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume(dev);
 
-	pci_pm_reenable_device(pci_dev);
-
-	if (drv && drv->pm && drv->pm->thaw)
-		error =  drv->pm->thaw(dev);
+	if (pm) {
+		if (pm->thaw)
+			error = pm->thaw(dev);
+	} else {
+		pci_pm_reenable_device(pci_dev);
+	}
 
 	return error;
 }
@@ -677,13 +704,23 @@ static int pci_pm_poweroff(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_HIBERNATE);
 
-	if (pm && pm->poweroff) {
+	if (!pm) {
+		pci_pm_default_suspend(pci_dev);
+		goto Fixup;
+	}
+
+	pci_dev->state_saved = false;
+
+	if (pm->poweroff) {
 		error = pm->poweroff(dev);
 		suspend_report_result(pm->poweroff, error);
 	}
 
-	if (!error)
-		pci_pm_default_suspend(pci_dev, !!pm);
+	if (!pci_dev->state_saved && !pci_is_bridge(pci_dev))
+		pci_prepare_to_sleep(pci_dev);
+
+ Fixup:
+	pci_fixup_device(pci_fixup_suspend, pci_dev);
 
 	return error;
 }
@@ -724,7 +761,7 @@ static int pci_pm_restore_noirq(struct device *dev)
 static int pci_pm_restore(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct device_driver *drv = dev->driver;
+	struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 	int error = 0;
 
 	/*
@@ -737,10 +774,14 @@ static int pci_pm_restore(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume(dev);
 
-	error = pci_pm_default_resume(pci_dev);
+	pci_pm_default_resume(pci_dev);
 
-	if (!error && drv && drv->pm && drv->pm->restore)
-		error = drv->pm->restore(dev);
+	if (pm) {
+		if (pm->restore)
+			error = pm->restore(dev);
+	} else {
+		pci_pm_reenable_device(pci_dev);
+	}
 
 	return error;
 }

commit cbbc2f6b0d438f80831c20124137ea92f0e5149b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 4 02:01:15 2009 +0100

    PCI PM: Do not disable and enable bridges during suspend-resume
    
    It is a mistake to disable and enable PCI bridges and PCI Express
    ports during suspend-resume, at least at the time when it is
    currently done.  Disabling them may lead to problems with accessing
    devices behind them and they should be automatically enabled when
    their standard config spaces are restored.  Fix this by not attempting
    to disable bridges during suspend and enable them during resume.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index fdb6a697e05a..ac6c9e493f4c 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -434,16 +434,18 @@ static int pci_pm_default_resume(struct pci_dev *pci_dev)
 {
 	pci_fixup_device(pci_fixup_resume, pci_dev);
 
-	if (!pci_is_bridge(pci_dev))
-		pci_enable_wake(pci_dev, PCI_D0, false);
+	if (pci_is_bridge(pci_dev))
+		return 0;
 
+	pci_enable_wake(pci_dev, PCI_D0, false);
 	return pci_pm_reenable_device(pci_dev);
 }
 
 static void pci_pm_default_suspend_generic(struct pci_dev *pci_dev)
 {
-	/* If device is enabled at this point, disable it */
-	pci_disable_enabled_device(pci_dev);
+	/* If a non-bridge device is enabled at this point, disable it */
+	if (!pci_is_bridge(pci_dev))
+		pci_disable_enabled_device(pci_dev);
 	/*
 	 * Save state with interrupts enabled, because in principle the bus the
 	 * device is on may be put into a low power state after this code runs.

commit 99dadce8756bf08f5f8baf749533d044f6b3ff25
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 4 01:59:09 2009 +0100

    PCI PM: Fix saving of device state in pci_legacy_suspend
    
    Make pci_legacy_suspend() save the state of the device if it is
    in PCI_UNKNOWN after its suspend callback has run and warn only if
    the power state of the device has been changed by its suspend
    callback.
    
    Also, use WARN_ONCE(), which is more useful, in pci_legacy_suspend(),
    so that the name of the offending function is printed.
    
    Additionally, remove the unnecessary line of code setting
    pci_dev->state_saved.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 6613bef25bf2..fdb6a697e05a 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -355,6 +355,8 @@ static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 	int i = 0;
 
 	if (drv && drv->suspend) {
+		pci_power_t prev = pci_dev->current_state;
+
 		pci_dev->state_saved = false;
 
 		i = drv->suspend(pci_dev, state);
@@ -365,12 +367,16 @@ static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 		if (pci_dev->state_saved)
 			goto Fixup;
 
-		if (WARN_ON_ONCE(pci_dev->current_state != PCI_D0))
+		if (pci_dev->current_state != PCI_D0
+		    && pci_dev->current_state != PCI_UNKNOWN) {
+			WARN_ONCE(pci_dev->current_state != prev,
+				"PCI PM: Device state not saved by %pF\n",
+				drv->suspend);
 			goto Fixup;
+		}
 	}
 
 	pci_save_state(pci_dev);
-	pci_dev->state_saved = true;
 	/*
 	 * This is for compatibility with existing code with legacy PM support.
 	 */

commit ddb7c9d29fac34626aef2af9f19787a888e4ca9c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 4 01:56:14 2009 +0100

    PCI PM: Fix handling of devices without drivers
    
    Suspend to RAM is reported to break on some machines as a result of
    attempting to put one of driverless PCI devices into a low power
    state.  Avoid that by not attepmting to power manage driverless
    devices during suspend.
    
    Fix up pci_pm_poweroff() after a previous incomplete fix for the same
    thing during hibernation.
    
    This patch is reported to fix the regression from 2.6.28 tracked as
    http://bugzilla.kernel.org/show_bug.cgi?id=12605
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-and-tested-by: Eric Sesterhenn <snakebyte@gmx.de>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index ab1d615425a8..6613bef25bf2 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -445,11 +445,11 @@ static void pci_pm_default_suspend_generic(struct pci_dev *pci_dev)
 	pci_save_state(pci_dev);
 }
 
-static void pci_pm_default_suspend(struct pci_dev *pci_dev)
+static void pci_pm_default_suspend(struct pci_dev *pci_dev, bool prepare)
 {
 	pci_pm_default_suspend_generic(pci_dev);
 
-	if (!pci_is_bridge(pci_dev))
+	if (prepare && !pci_is_bridge(pci_dev))
 		pci_prepare_to_sleep(pci_dev);
 
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
@@ -497,19 +497,19 @@ static void pci_pm_complete(struct device *dev)
 static int pci_pm_suspend(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct device_driver *drv = dev->driver;
+	struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 	int error = 0;
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_SUSPEND);
 
-	if (drv && drv->pm && drv->pm->suspend) {
-		error = drv->pm->suspend(dev);
-		suspend_report_result(drv->pm->suspend, error);
+	if (pm && pm->suspend) {
+		error = pm->suspend(dev);
+		suspend_report_result(pm->suspend, error);
 	}
 
 	if (!error)
-		pci_pm_default_suspend(pci_dev);
+		pci_pm_default_suspend(pci_dev, !!pm);
 
 	return error;
 }
@@ -663,22 +663,19 @@ static int pci_pm_thaw(struct device *dev)
 static int pci_pm_poweroff(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct device_driver *drv = dev->driver;
+	struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
 	int error = 0;
 
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_HIBERNATE);
 
-	if (!drv || !drv->pm)
-		return 0;
-
-	if (drv->pm->poweroff) {
-		error = drv->pm->poweroff(dev);
-		suspend_report_result(drv->pm->poweroff, error);
+	if (pm && pm->poweroff) {
+		error = pm->poweroff(dev);
+		suspend_report_result(pm->poweroff, error);
 	}
 
 	if (!error)
-		pci_pm_default_suspend(pci_dev);
+		pci_pm_default_suspend(pci_dev, !!pm);
 
 	return error;
 }

commit 545ffd58adc86b8d33449dab44fe81b503a6f81b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jan 22 23:36:56 2009 +0100

    PCI PM: Fix hibernation breakage on EeePC 701
    
    Hibernation breaks on EeePC 701 as a result of attempting to put one
    of its (driverless) devices into a low power state.  Avoid that by
    not attepmting to power manage driverless devices during hibernation.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-and-tested-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 4884c4840b3d..ab1d615425a8 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -669,7 +669,10 @@ static int pci_pm_poweroff(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_HIBERNATE);
 
-	if (drv && drv->pm && drv->pm->poweroff) {
+	if (!drv || !drv->pm)
+		return 0;
+
+	if (drv->pm->poweroff) {
 		error = drv->pm->poweroff(dev);
 		suspend_report_result(drv->pm->poweroff, error);
 	}

commit 418e4da33f45fd7bdcce48778b149b780ff730bc
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jan 26 21:43:08 2009 +0100

    PCI PM: Fix suspend error paths and testing facility breakage
    
    If one of device drivers refuses to suspend by returning error code
    from its ->suspend() callback, the devices that have already been
    suspended are resumed by executing their drivers' ->resume()
    callbacks.  Some of these callbacks expect the device's
    configuration space to be restored if the device has been put into
    D3 before they are called.  Unfortunately, this mechanism has been
    broken by recent changes moving the restoration of config spaces
    of some devices (most importantly, USB controllers and HDA Intel)
    into the resume callbacks executed with interrupts off.  Obviously,
    these callbacks are not invoked in the suspend error path and, as a
    result, the system cannot be successfully brought back into the
    working state in case of a suspend error.  The same thing happens
    in the hibernation error path right before putting the system into
    S4.
    
    Similarly, the suspend testing facility associated with the
    /sys/power/pm_test file is broken, because it uses the very same
    mechanism that is used in the suspend and hibernation error paths.
    
    Fix the breakage by making the PCI core restore the configuration
    spaces of PCI devices that haven't been restored already before
    pci_pm_resume() is called for those devices by the PM core.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 9de07b75b993..4884c4840b3d 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -370,6 +370,7 @@ static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 	}
 
 	pci_save_state(pci_dev);
+	pci_dev->state_saved = true;
 	/*
 	 * This is for compatibility with existing code with legacy PM support.
 	 */
@@ -419,6 +420,7 @@ static int pci_legacy_resume(struct device *dev)
 static void pci_pm_default_resume_noirq(struct pci_dev *pci_dev)
 {
 	pci_restore_standard_config(pci_dev);
+	pci_dev->state_saved = false;
 	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 }
 
@@ -555,6 +557,13 @@ static int pci_pm_resume(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	/*
+	 * This is necessary for the suspend error path in which resume is
+	 * called without restoring the standard config registers of the device.
+	 */
+	if (pci_dev->state_saved)
+		pci_restore_standard_config(pci_dev);
+
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume(dev);
 
@@ -710,6 +719,13 @@ static int pci_pm_restore(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	/*
+	 * This is necessary for the hibernation error path in which restore is
+	 * called without restoring the standard config registers of the device.
+	 */
+	if (pci_dev->state_saved)
+		pci_restore_standard_config(pci_dev);
+
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume(dev);
 

commit aa8c6c93747f7b55fa11e1624fec8ca33763a805
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 16 21:54:43 2009 +0100

    PCI PM: Restore standard config registers of all devices early
    
    There is a problem in our handling of suspend-resume of PCI devices that
    many of them have their standard config registers restored with
    interrupts enabled and they are put into the full power state with
    interrupts enabled as well.  This may lead to the following scenario:
      * an interrupt vector is shared between two or more devices
      * one device is resumed earlier and generates an interrupt
      * the interrupt handler of another device tries to handle it and
        attempts to access the device the config space of which hasn't been
        restored yet and/or which still is in a low power state
      * the system crashes as a result
    
    To prevent this from happening we should restore the standard
    configuration registers of all devices with interrupts disabled and we
    should put them into the D0 power state right after that.
    Unfortunately, this cannot be done using the existing
    pci_set_power_state(), because it can sleep.  Also, to do it we have to
    make sure that the config spaces of all devices were actually saved
    during suspend.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index c697f2680856..9de07b75b993 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -355,17 +355,27 @@ static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 	int i = 0;
 
 	if (drv && drv->suspend) {
+		pci_dev->state_saved = false;
+
 		i = drv->suspend(pci_dev, state);
 		suspend_report_result(drv->suspend, i);
-	} else {
-		pci_save_state(pci_dev);
-		/*
-		 * This is for compatibility with existing code with legacy PM
-		 * support.
-		 */
-		pci_pm_set_unknown_state(pci_dev);
+		if (i)
+			return i;
+
+		if (pci_dev->state_saved)
+			goto Fixup;
+
+		if (WARN_ON_ONCE(pci_dev->current_state != PCI_D0))
+			goto Fixup;
 	}
 
+	pci_save_state(pci_dev);
+	/*
+	 * This is for compatibility with existing code with legacy PM support.
+	 */
+	pci_pm_set_unknown_state(pci_dev);
+
+ Fixup:
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
 
 	return i;
@@ -386,81 +396,34 @@ static int pci_legacy_suspend_late(struct device *dev, pm_message_t state)
 
 static int pci_legacy_resume_early(struct device *dev)
 {
-	int error = 0;
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	struct pci_driver * drv = pci_dev->driver;
 
-	pci_fixup_device(pci_fixup_resume_early, pci_dev);
-
-	if (drv && drv->resume_early)
-		error = drv->resume_early(pci_dev);
-	return error;
+	return drv && drv->resume_early ?
+			drv->resume_early(pci_dev) : 0;
 }
 
 static int pci_legacy_resume(struct device *dev)
 {
-	int error;
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	struct pci_driver * drv = pci_dev->driver;
 
 	pci_fixup_device(pci_fixup_resume, pci_dev);
 
-	if (drv && drv->resume) {
-		error = drv->resume(pci_dev);
-	} else {
-		/* restore the PCI config space */
-		pci_restore_state(pci_dev);
-		error = pci_pm_reenable_device(pci_dev);
-	}
-	return error;
+	return drv && drv->resume ?
+			drv->resume(pci_dev) : pci_pm_reenable_device(pci_dev);
 }
 
 /* Auxiliary functions used by the new power management framework */
 
-static int pci_restore_standard_config(struct pci_dev *pci_dev)
-{
-	struct pci_dev *parent = pci_dev->bus->self;
-	int error = 0;
-
-	/* Check if the device's bus is operational */
-	if (!parent || parent->current_state == PCI_D0) {
-		pci_restore_state(pci_dev);
-		pci_update_current_state(pci_dev, PCI_D0);
-	} else {
-		dev_warn(&pci_dev->dev, "unable to restore config, "
-			"bridge %s in low power state D%d\n", pci_name(parent),
-			parent->current_state);
-		pci_dev->current_state = PCI_UNKNOWN;
-		error = -EAGAIN;
-	}
-
-	return error;
-}
-
-static bool pci_is_bridge(struct pci_dev *pci_dev)
-{
-	return !!(pci_dev->subordinate);
-}
-
 static void pci_pm_default_resume_noirq(struct pci_dev *pci_dev)
 {
-	if (pci_restore_standard_config(pci_dev))
-		pci_fixup_device(pci_fixup_resume_early, pci_dev);
+	pci_restore_standard_config(pci_dev);
+	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 }
 
 static int pci_pm_default_resume(struct pci_dev *pci_dev)
 {
-	/*
-	 * pci_restore_standard_config() should have been called once already,
-	 * but it would have failed if the device's parent bridge had not been
-	 * in power state D0 at that time.  Check it and try again if necessary.
-	 */
-	if (pci_dev->current_state == PCI_UNKNOWN) {
-		int error = pci_restore_standard_config(pci_dev);
-		if (error)
-			return error;
-	}
-
 	pci_fixup_device(pci_fixup_resume, pci_dev);
 
 	if (!pci_is_bridge(pci_dev))
@@ -575,11 +538,11 @@ static int pci_pm_resume_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	pci_pm_default_resume_noirq(pci_dev);
+
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
 
-	pci_pm_default_resume_noirq(pci_dev);
-
 	if (drv && drv->pm && drv->pm->resume_noirq)
 		error = drv->pm->resume_noirq(dev);
 
@@ -730,11 +693,11 @@ static int pci_pm_restore_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	pci_pm_default_resume_noirq(pci_dev);
+
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
 
-	pci_pm_default_resume_noirq(pci_dev);
-
 	if (drv && drv->pm && drv->pm->restore_noirq)
 		error = drv->pm->restore_noirq(dev);
 

commit f6dc1e5e3d4b523e1616b43beddb04e4fb1d376a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jan 7 13:12:22 2009 +0100

    PCI PM: Put PM callbacks in the order of execution
    
    Put PM callbacks in drivers/pci/pci-driver.c in the order in which
    they are executed which makes it much easier to follow the code.
    
    No functional changes should result from this.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index b7e67c2f40b9..c697f2680856 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -384,6 +384,19 @@ static int pci_legacy_suspend_late(struct device *dev, pm_message_t state)
 	return i;
 }
 
+static int pci_legacy_resume_early(struct device *dev)
+{
+	int error = 0;
+	struct pci_dev * pci_dev = to_pci_dev(dev);
+	struct pci_driver * drv = pci_dev->driver;
+
+	pci_fixup_device(pci_fixup_resume_early, pci_dev);
+
+	if (drv && drv->resume_early)
+		error = drv->resume_early(pci_dev);
+	return error;
+}
+
 static int pci_legacy_resume(struct device *dev)
 {
 	int error;
@@ -402,19 +415,6 @@ static int pci_legacy_resume(struct device *dev)
 	return error;
 }
 
-static int pci_legacy_resume_early(struct device *dev)
-{
-	int error = 0;
-	struct pci_dev * pci_dev = to_pci_dev(dev);
-	struct pci_driver * drv = pci_dev->driver;
-
-	pci_fixup_device(pci_fixup_resume_early, pci_dev);
-
-	if (drv && drv->resume_early)
-		error = drv->resume_early(pci_dev);
-	return error;
-}
-
 /* Auxiliary functions used by the new power management framework */
 
 static int pci_restore_standard_config(struct pci_dev *pci_dev)
@@ -569,36 +569,36 @@ static int pci_pm_suspend_noirq(struct device *dev)
 	return error;
 }
 
-static int pci_pm_resume(struct device *dev)
+static int pci_pm_resume_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
 	if (pci_has_legacy_pm_support(pci_dev))
-		return pci_legacy_resume(dev);
+		return pci_legacy_resume_early(dev);
 
-	error = pci_pm_default_resume(pci_dev);
+	pci_pm_default_resume_noirq(pci_dev);
 
-	if (!error && drv && drv->pm && drv->pm->resume)
-		error = drv->pm->resume(dev);
+	if (drv && drv->pm && drv->pm->resume_noirq)
+		error = drv->pm->resume_noirq(dev);
 
 	return error;
 }
 
-static int pci_pm_resume_noirq(struct device *dev)
+static int pci_pm_resume(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
 	if (pci_has_legacy_pm_support(pci_dev))
-		return pci_legacy_resume_early(dev);
+		return pci_legacy_resume(dev);
 
-	pci_pm_default_resume_noirq(pci_dev);
+	error = pci_pm_default_resume(pci_dev);
 
-	if (drv && drv->pm && drv->pm->resume_noirq)
-		error = drv->pm->resume_noirq(dev);
+	if (!error && drv && drv->pm && drv->pm->resume)
+		error = drv->pm->resume(dev);
 
 	return error;
 }
@@ -654,36 +654,36 @@ static int pci_pm_freeze_noirq(struct device *dev)
 	return error;
 }
 
-static int pci_pm_thaw(struct device *dev)
+static int pci_pm_thaw_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
 	if (pci_has_legacy_pm_support(pci_dev))
-		return pci_legacy_resume(dev);
+		return pci_legacy_resume_early(dev);
 
-	pci_pm_reenable_device(pci_dev);
+	pci_update_current_state(pci_dev, PCI_D0);
 
-	if (drv && drv->pm && drv->pm->thaw)
-		error =  drv->pm->thaw(dev);
+	if (drv && drv->pm && drv->pm->thaw_noirq)
+		error = drv->pm->thaw_noirq(dev);
 
 	return error;
 }
 
-static int pci_pm_thaw_noirq(struct device *dev)
+static int pci_pm_thaw(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
 	if (pci_has_legacy_pm_support(pci_dev))
-		return pci_legacy_resume_early(dev);
+		return pci_legacy_resume(dev);
 
-	pci_update_current_state(pci_dev, PCI_D0);
+	pci_pm_reenable_device(pci_dev);
 
-	if (drv && drv->pm && drv->pm->thaw_noirq)
-		error = drv->pm->thaw_noirq(dev);
+	if (drv && drv->pm && drv->pm->thaw)
+		error =  drv->pm->thaw(dev);
 
 	return error;
 }
@@ -724,36 +724,36 @@ static int pci_pm_poweroff_noirq(struct device *dev)
 	return error;
 }
 
-static int pci_pm_restore(struct device *dev)
+static int pci_pm_restore_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
 	if (pci_has_legacy_pm_support(pci_dev))
-		return pci_legacy_resume(dev);
+		return pci_legacy_resume_early(dev);
 
-	error = pci_pm_default_resume(pci_dev);
+	pci_pm_default_resume_noirq(pci_dev);
 
-	if (!error && drv && drv->pm && drv->pm->restore)
-		error = drv->pm->restore(dev);
+	if (drv && drv->pm && drv->pm->restore_noirq)
+		error = drv->pm->restore_noirq(dev);
 
 	return error;
 }
 
-static int pci_pm_restore_noirq(struct device *dev)
+static int pci_pm_restore(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
 	if (pci_has_legacy_pm_support(pci_dev))
-		return pci_legacy_resume_early(dev);
+		return pci_legacy_resume(dev);
 
-	pci_pm_default_resume_noirq(pci_dev);
+	error = pci_pm_default_resume(pci_dev);
 
-	if (drv && drv->pm && drv->pm->restore_noirq)
-		error = drv->pm->restore_noirq(dev);
+	if (!error && drv && drv->pm && drv->pm->restore)
+		error = drv->pm->restore(dev);
 
 	return error;
 }

commit d67e37d7933ba3b28a63ff38c957e433aaca5dc4
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jan 7 13:11:28 2009 +0100

    PCI PM: Run default PM callbacks for all devices using new framework
    
    It should be quite clear that it generally makes sense to execute
    the default PM callbacks (ie. the callbacks used for handling
    suspend, hibernation and resume of PCI devices without drivers) for
    all devices.  Of course, the drivers that provide legacy PCI PM
    support (ie. the ->suspend, ->suspend_late, ->resume_early
    or ->resume hooks in the pci_driver structure), carry out these
    operations too, so we can't do it for devices with such drivers.
    Still, we can make the default PM callbacks run for devices with
    drivers using the new framework (ie. implement the pm object), since
    there are no such drivers at the moment.
    
    This also simplifies the code and makes it smaller.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 02bf4d4125e4..b7e67c2f40b9 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -486,6 +486,8 @@ static void pci_pm_default_suspend(struct pci_dev *pci_dev)
 
 	if (!pci_is_bridge(pci_dev))
 		pci_prepare_to_sleep(pci_dev);
+
+	pci_fixup_device(pci_fixup_suspend, pci_dev);
 }
 
 static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
@@ -536,16 +538,13 @@ static int pci_pm_suspend(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_SUSPEND);
 
-	if (drv && drv->pm) {
-		if (drv->pm->suspend) {
-			error = drv->pm->suspend(dev);
-			suspend_report_result(drv->pm->suspend, error);
-		}
-	} else {
-		pci_pm_default_suspend(pci_dev);
+	if (drv && drv->pm && drv->pm->suspend) {
+		error = drv->pm->suspend(dev);
+		suspend_report_result(drv->pm->suspend, error);
 	}
 
-	pci_fixup_device(pci_fixup_suspend, pci_dev);
+	if (!error)
+		pci_pm_default_suspend(pci_dev);
 
 	return error;
 }
@@ -559,15 +558,14 @@ static int pci_pm_suspend_noirq(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend_late(dev, PMSG_SUSPEND);
 
-	if (drv && drv->pm) {
-		if (drv->pm->suspend_noirq) {
-			error = drv->pm->suspend_noirq(dev);
-			suspend_report_result(drv->pm->suspend_noirq, error);
-		}
-	} else {
-		pci_pm_set_unknown_state(pci_dev);
+	if (drv && drv->pm && drv->pm->suspend_noirq) {
+		error = drv->pm->suspend_noirq(dev);
+		suspend_report_result(drv->pm->suspend_noirq, error);
 	}
 
+	if (!error)
+		pci_pm_set_unknown_state(pci_dev);
+
 	return error;
 }
 
@@ -580,14 +578,10 @@ static int pci_pm_resume(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume(dev);
 
-	if (drv && drv->pm) {
-		pci_fixup_device(pci_fixup_resume, pci_dev);
+	error = pci_pm_default_resume(pci_dev);
 
-		if (drv->pm->resume)
-			error = drv->pm->resume(dev);
-	} else {
-		error = pci_pm_default_resume(pci_dev);
-	}
+	if (!error && drv && drv->pm && drv->pm->resume)
+		error = drv->pm->resume(dev);
 
 	return error;
 }
@@ -601,14 +595,10 @@ static int pci_pm_resume_noirq(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
 
-	if (drv && drv->pm) {
-		pci_fixup_device(pci_fixup_resume_early, pci_dev);
+	pci_pm_default_resume_noirq(pci_dev);
 
-		if (drv->pm->resume_noirq)
-			error = drv->pm->resume_noirq(dev);
-	} else {
-		pci_pm_default_resume_noirq(pci_dev);
-	}
+	if (drv && drv->pm && drv->pm->resume_noirq)
+		error = drv->pm->resume_noirq(dev);
 
 	return error;
 }
@@ -633,15 +623,14 @@ static int pci_pm_freeze(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_FREEZE);
 
-	if (drv && drv->pm) {
-		if (drv->pm->freeze) {
-			error = drv->pm->freeze(dev);
-			suspend_report_result(drv->pm->freeze, error);
-		}
-	} else {
-		pci_pm_default_suspend_generic(pci_dev);
+	if (drv && drv->pm && drv->pm->freeze) {
+		error = drv->pm->freeze(dev);
+		suspend_report_result(drv->pm->freeze, error);
 	}
 
+	if (!error)
+		pci_pm_default_suspend_generic(pci_dev);
+
 	return error;
 }
 
@@ -654,15 +643,14 @@ static int pci_pm_freeze_noirq(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend_late(dev, PMSG_FREEZE);
 
-	if (drv && drv->pm) {
-		if (drv->pm->freeze_noirq) {
-			error = drv->pm->freeze_noirq(dev);
-			suspend_report_result(drv->pm->freeze_noirq, error);
-		}
-	} else {
-		pci_pm_set_unknown_state(pci_dev);
+	if (drv && drv->pm && drv->pm->freeze_noirq) {
+		error = drv->pm->freeze_noirq(dev);
+		suspend_report_result(drv->pm->freeze_noirq, error);
 	}
 
+	if (!error)
+		pci_pm_set_unknown_state(pci_dev);
+
 	return error;
 }
 
@@ -675,12 +663,10 @@ static int pci_pm_thaw(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume(dev);
 
-	if (drv && drv->pm) {
-		if (drv->pm->thaw)
-			error =  drv->pm->thaw(dev);
-	} else {
-		pci_pm_reenable_device(pci_dev);
-	}
+	pci_pm_reenable_device(pci_dev);
+
+	if (drv && drv->pm && drv->pm->thaw)
+		error =  drv->pm->thaw(dev);
 
 	return error;
 }
@@ -694,12 +680,10 @@ static int pci_pm_thaw_noirq(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
 
-	if (drv && drv->pm) {
-		if (drv->pm->thaw_noirq)
-			error = drv->pm->thaw_noirq(dev);
-	} else {
-		pci_update_current_state(pci_dev, PCI_D0);
-	}
+	pci_update_current_state(pci_dev, PCI_D0);
+
+	if (drv && drv->pm && drv->pm->thaw_noirq)
+		error = drv->pm->thaw_noirq(dev);
 
 	return error;
 }
@@ -713,16 +697,13 @@ static int pci_pm_poweroff(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_suspend(dev, PMSG_HIBERNATE);
 
-	if (drv && drv->pm) {
-		if (drv->pm->poweroff) {
-			error = drv->pm->poweroff(dev);
-			suspend_report_result(drv->pm->poweroff, error);
-		}
-	} else {
-		pci_pm_default_suspend(pci_dev);
+	if (drv && drv->pm && drv->pm->poweroff) {
+		error = drv->pm->poweroff(dev);
+		suspend_report_result(drv->pm->poweroff, error);
 	}
 
-	pci_fixup_device(pci_fixup_suspend, pci_dev);
+	if (!error)
+		pci_pm_default_suspend(pci_dev);
 
 	return error;
 }
@@ -735,11 +716,9 @@ static int pci_pm_poweroff_noirq(struct device *dev)
 	if (pci_has_legacy_pm_support(to_pci_dev(dev)))
 		return pci_legacy_suspend_late(dev, PMSG_HIBERNATE);
 
-	if (drv && drv->pm) {
-		if (drv->pm->poweroff_noirq) {
-			error = drv->pm->poweroff_noirq(dev);
-			suspend_report_result(drv->pm->poweroff_noirq, error);
-		}
+	if (drv && drv->pm && drv->pm->poweroff_noirq) {
+		error = drv->pm->poweroff_noirq(dev);
+		suspend_report_result(drv->pm->poweroff_noirq, error);
 	}
 
 	return error;
@@ -754,14 +733,10 @@ static int pci_pm_restore(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume(dev);
 
-	if (drv && drv->pm) {
-		pci_fixup_device(pci_fixup_resume, pci_dev);
+	error = pci_pm_default_resume(pci_dev);
 
-		if (drv->pm->restore)
-			error = drv->pm->restore(dev);
-	} else {
-		error = pci_pm_default_resume(pci_dev);
-	}
+	if (!error && drv && drv->pm && drv->pm->restore)
+		error = drv->pm->restore(dev);
 
 	return error;
 }
@@ -775,14 +750,10 @@ static int pci_pm_restore_noirq(struct device *dev)
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
 
-	if (drv && drv->pm) {
-		pci_fixup_device(pci_fixup_resume_early, pci_dev);
+	pci_pm_default_resume_noirq(pci_dev);
 
-		if (drv->pm->restore_noirq)
-			error = drv->pm->restore_noirq(dev);
-	} else {
-		pci_pm_default_resume_noirq(pci_dev);
-	}
+	if (drv && drv->pm && drv->pm->restore_noirq)
+		error = drv->pm->restore_noirq(dev);
 
 	return error;
 }

commit ad8cfa1defee14a5181d9b63e666318c51cfaeed
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jan 7 13:09:37 2009 +0100

    PCI PM: Call pci_fixup_device from legacy routines
    
    The size of drivers/pci/pci-driver.c can be reduced quite a bit
    if pci_fixup_device() is called from the legacy PM callbacks, so make
    it happen.
    
    No functional changes should result from this.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 2e76945a1cd8..02bf4d4125e4 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -365,6 +365,9 @@ static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 		 */
 		pci_pm_set_unknown_state(pci_dev);
 	}
+
+	pci_fixup_device(pci_fixup_suspend, pci_dev);
+
 	return i;
 }
 
@@ -387,6 +390,8 @@ static int pci_legacy_resume(struct device *dev)
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	struct pci_driver * drv = pci_dev->driver;
 
+	pci_fixup_device(pci_fixup_resume, pci_dev);
+
 	if (drv && drv->resume) {
 		error = drv->resume(pci_dev);
 	} else {
@@ -403,6 +408,8 @@ static int pci_legacy_resume_early(struct device *dev)
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	struct pci_driver * drv = pci_dev->driver;
 
+	pci_fixup_device(pci_fixup_resume_early, pci_dev);
+
 	if (drv && drv->resume_early)
 		error = drv->resume_early(pci_dev);
 	return error;
@@ -526,10 +533,8 @@ static int pci_pm_suspend(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	if (pci_has_legacy_pm_support(pci_dev)) {
-		error = pci_legacy_suspend(dev, PMSG_SUSPEND);
-		goto Exit;
-	}
+	if (pci_has_legacy_pm_support(pci_dev))
+		return pci_legacy_suspend(dev, PMSG_SUSPEND);
 
 	if (drv && drv->pm) {
 		if (drv->pm->suspend) {
@@ -540,7 +545,6 @@ static int pci_pm_suspend(struct device *dev)
 		pci_pm_default_suspend(pci_dev);
 	}
 
- Exit:
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
 
 	return error;
@@ -573,10 +577,8 @@ static int pci_pm_resume(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	if (pci_has_legacy_pm_support(pci_dev)) {
-		pci_fixup_device(pci_fixup_resume, pci_dev);
+	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume(dev);
-	}
 
 	if (drv && drv->pm) {
 		pci_fixup_device(pci_fixup_resume, pci_dev);
@@ -596,10 +598,8 @@ static int pci_pm_resume_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	if (pci_has_legacy_pm_support(pci_dev)) {
-		pci_fixup_device(pci_fixup_resume_early, pci_dev);
+	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
-	}
 
 	if (drv && drv->pm) {
 		pci_fixup_device(pci_fixup_resume_early, pci_dev);
@@ -630,11 +630,8 @@ static int pci_pm_freeze(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	if (pci_has_legacy_pm_support(pci_dev)) {
-		error = pci_legacy_suspend(dev, PMSG_FREEZE);
-		pci_fixup_device(pci_fixup_suspend, pci_dev);
-		return error;
-	}
+	if (pci_has_legacy_pm_support(pci_dev))
+		return pci_legacy_suspend(dev, PMSG_FREEZE);
 
 	if (drv && drv->pm) {
 		if (drv->pm->freeze) {
@@ -675,10 +672,8 @@ static int pci_pm_thaw(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	if (pci_has_legacy_pm_support(pci_dev)) {
-		pci_fixup_device(pci_fixup_resume, pci_dev);
+	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume(dev);
-	}
 
 	if (drv && drv->pm) {
 		if (drv->pm->thaw)
@@ -696,10 +691,8 @@ static int pci_pm_thaw_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	if (pci_has_legacy_pm_support(pci_dev)) {
-		pci_fixup_device(pci_fixup_resume_early, to_pci_dev(dev));
+	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
-	}
 
 	if (drv && drv->pm) {
 		if (drv->pm->thaw_noirq)
@@ -717,10 +710,8 @@ static int pci_pm_poweroff(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	if (pci_has_legacy_pm_support(pci_dev)) {
-		error = pci_legacy_suspend(dev, PMSG_HIBERNATE);
-		goto Exit;
-	}
+	if (pci_has_legacy_pm_support(pci_dev))
+		return pci_legacy_suspend(dev, PMSG_HIBERNATE);
 
 	if (drv && drv->pm) {
 		if (drv->pm->poweroff) {
@@ -731,7 +722,6 @@ static int pci_pm_poweroff(struct device *dev)
 		pci_pm_default_suspend(pci_dev);
 	}
 
- Exit:
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
 
 	return error;
@@ -761,10 +751,8 @@ static int pci_pm_restore(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	if (pci_has_legacy_pm_support(pci_dev)) {
-		pci_fixup_device(pci_fixup_resume, pci_dev);
+	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume(dev);
-	}
 
 	if (drv && drv->pm) {
 		pci_fixup_device(pci_fixup_resume, pci_dev);
@@ -784,10 +772,8 @@ static int pci_pm_restore_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	if (pci_has_legacy_pm_support(pci_dev)) {
-		pci_fixup_device(pci_fixup_resume_early, pci_dev);
+	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
-	}
 
 	if (drv && drv->pm) {
 		pci_fixup_device(pci_fixup_resume_early, pci_dev);

commit bb8089454391ac5577215aec1f1991adcd4b4cbf
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jan 7 14:15:17 2009 +0100

    PCI PM: Rearrange code in pci-driver.c
    
    Rename two functions and rearrange code in drivers/pci/pci-driver.c
    so that it's easier to follow.  In particular, separate invocations
    of the legacy callbacks from the rest of the new callbacks' code.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 750ee79c178f..2e76945a1cd8 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -318,7 +318,7 @@ static void pci_device_shutdown(struct device *dev)
  * Default "suspend" method for devices that have no driver provided suspend,
  * or not even a driver at all (second part).
  */
-static void pci_default_pm_suspend_late(struct pci_dev *pci_dev)
+static void pci_pm_set_unknown_state(struct pci_dev *pci_dev)
 {
 	/*
 	 * mark its power state as "unknown", since we don't know if
@@ -332,7 +332,7 @@ static void pci_default_pm_suspend_late(struct pci_dev *pci_dev)
  * Default "resume" method for devices that have no driver provided resume,
  * or not even a driver at all (second part).
  */
-static int pci_default_pm_resume_late(struct pci_dev *pci_dev)
+static int pci_pm_reenable_device(struct pci_dev *pci_dev)
 {
 	int retval;
 
@@ -363,7 +363,7 @@ static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 		 * This is for compatibility with existing code with legacy PM
 		 * support.
 		 */
-		pci_default_pm_suspend_late(pci_dev);
+		pci_pm_set_unknown_state(pci_dev);
 	}
 	return i;
 }
@@ -392,7 +392,7 @@ static int pci_legacy_resume(struct device *dev)
 	} else {
 		/* restore the PCI config space */
 		pci_restore_state(pci_dev);
-		error = pci_default_pm_resume_late(pci_dev);
+		error = pci_pm_reenable_device(pci_dev);
 	}
 	return error;
 }
@@ -459,7 +459,7 @@ static int pci_pm_default_resume(struct pci_dev *pci_dev)
 	if (!pci_is_bridge(pci_dev))
 		pci_enable_wake(pci_dev, PCI_D0, false);
 
-	return pci_default_pm_resume_late(pci_dev);
+	return pci_pm_reenable_device(pci_dev);
 }
 
 static void pci_pm_default_suspend_generic(struct pci_dev *pci_dev)
@@ -484,9 +484,17 @@ static void pci_pm_default_suspend(struct pci_dev *pci_dev)
 static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
 {
 	struct pci_driver *drv = pci_dev->driver;
-
-	return drv && (drv->suspend || drv->suspend_late || drv->resume
+	bool ret = drv && (drv->suspend || drv->suspend_late || drv->resume
 		|| drv->resume_early);
+
+	/*
+	 * Legacy PM support is used by default, so warn if the new framework is
+	 * supported as well.  Drivers are supposed to support either the
+	 * former, or the latter, but not both at the same time.
+	 */
+	WARN_ON(ret && drv->driver.pm);
+
+	return ret;
 }
 
 /* New power management framework */
@@ -518,17 +526,21 @@ static int pci_pm_suspend(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	if (pci_has_legacy_pm_support(pci_dev)) {
+		error = pci_legacy_suspend(dev, PMSG_SUSPEND);
+		goto Exit;
+	}
+
 	if (drv && drv->pm) {
 		if (drv->pm->suspend) {
 			error = drv->pm->suspend(dev);
 			suspend_report_result(drv->pm->suspend, error);
 		}
-	} else if (pci_has_legacy_pm_support(pci_dev)) {
-		error = pci_legacy_suspend(dev, PMSG_SUSPEND);
 	} else {
 		pci_pm_default_suspend(pci_dev);
 	}
 
+ Exit:
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
 
 	return error;
@@ -540,15 +552,16 @@ static int pci_pm_suspend_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	if (pci_has_legacy_pm_support(pci_dev))
+		return pci_legacy_suspend_late(dev, PMSG_SUSPEND);
+
 	if (drv && drv->pm) {
 		if (drv->pm->suspend_noirq) {
 			error = drv->pm->suspend_noirq(dev);
 			suspend_report_result(drv->pm->suspend_noirq, error);
 		}
-	} else if (pci_has_legacy_pm_support(pci_dev)) {
-		error = pci_legacy_suspend_late(dev, PMSG_SUSPEND);
 	} else {
-		pci_default_pm_suspend_late(pci_dev);
+		pci_pm_set_unknown_state(pci_dev);
 	}
 
 	return error;
@@ -560,14 +573,16 @@ static int pci_pm_resume(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	if (pci_has_legacy_pm_support(pci_dev)) {
+		pci_fixup_device(pci_fixup_resume, pci_dev);
+		return pci_legacy_resume(dev);
+	}
+
 	if (drv && drv->pm) {
 		pci_fixup_device(pci_fixup_resume, pci_dev);
 
 		if (drv->pm->resume)
 			error = drv->pm->resume(dev);
-	} else if (pci_has_legacy_pm_support(pci_dev)) {
-		pci_fixup_device(pci_fixup_resume, pci_dev);
-		error = pci_legacy_resume(dev);
 	} else {
 		error = pci_pm_default_resume(pci_dev);
 	}
@@ -581,14 +596,16 @@ static int pci_pm_resume_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	if (pci_has_legacy_pm_support(pci_dev)) {
+		pci_fixup_device(pci_fixup_resume_early, pci_dev);
+		return pci_legacy_resume_early(dev);
+	}
+
 	if (drv && drv->pm) {
 		pci_fixup_device(pci_fixup_resume_early, pci_dev);
 
 		if (drv->pm->resume_noirq)
 			error = drv->pm->resume_noirq(dev);
-	} else if (pci_has_legacy_pm_support(pci_dev)) {
-		pci_fixup_device(pci_fixup_resume_early, pci_dev);
-		error = pci_legacy_resume_early(dev);
 	} else {
 		pci_pm_default_resume_noirq(pci_dev);
 	}
@@ -613,14 +630,17 @@ static int pci_pm_freeze(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	if (pci_has_legacy_pm_support(pci_dev)) {
+		error = pci_legacy_suspend(dev, PMSG_FREEZE);
+		pci_fixup_device(pci_fixup_suspend, pci_dev);
+		return error;
+	}
+
 	if (drv && drv->pm) {
 		if (drv->pm->freeze) {
 			error = drv->pm->freeze(dev);
 			suspend_report_result(drv->pm->freeze, error);
 		}
-	} else if (pci_has_legacy_pm_support(pci_dev)) {
-		error = pci_legacy_suspend(dev, PMSG_FREEZE);
-		pci_fixup_device(pci_fixup_suspend, pci_dev);
 	} else {
 		pci_pm_default_suspend_generic(pci_dev);
 	}
@@ -634,15 +654,16 @@ static int pci_pm_freeze_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	if (pci_has_legacy_pm_support(pci_dev))
+		return pci_legacy_suspend_late(dev, PMSG_FREEZE);
+
 	if (drv && drv->pm) {
 		if (drv->pm->freeze_noirq) {
 			error = drv->pm->freeze_noirq(dev);
 			suspend_report_result(drv->pm->freeze_noirq, error);
 		}
-	} else if (pci_has_legacy_pm_support(pci_dev)) {
-		error = pci_legacy_suspend_late(dev, PMSG_FREEZE);
 	} else {
-		pci_default_pm_suspend_late(pci_dev);
+		pci_pm_set_unknown_state(pci_dev);
 	}
 
 	return error;
@@ -654,14 +675,16 @@ static int pci_pm_thaw(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	if (pci_has_legacy_pm_support(pci_dev)) {
+		pci_fixup_device(pci_fixup_resume, pci_dev);
+		return pci_legacy_resume(dev);
+	}
+
 	if (drv && drv->pm) {
 		if (drv->pm->thaw)
 			error =  drv->pm->thaw(dev);
-	} else if (pci_has_legacy_pm_support(pci_dev)) {
-		pci_fixup_device(pci_fixup_resume, pci_dev);
-		error = pci_legacy_resume(dev);
 	} else {
-		pci_default_pm_resume_late(pci_dev);
+		pci_pm_reenable_device(pci_dev);
 	}
 
 	return error;
@@ -673,12 +696,14 @@ static int pci_pm_thaw_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	if (pci_has_legacy_pm_support(pci_dev)) {
+		pci_fixup_device(pci_fixup_resume_early, to_pci_dev(dev));
+		return pci_legacy_resume_early(dev);
+	}
+
 	if (drv && drv->pm) {
 		if (drv->pm->thaw_noirq)
 			error = drv->pm->thaw_noirq(dev);
-	} else if (pci_has_legacy_pm_support(pci_dev)) {
-		pci_fixup_device(pci_fixup_resume_early, to_pci_dev(dev));
-		error = pci_legacy_resume_early(dev);
 	} else {
 		pci_update_current_state(pci_dev, PCI_D0);
 	}
@@ -692,17 +717,21 @@ static int pci_pm_poweroff(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	if (pci_has_legacy_pm_support(pci_dev)) {
+		error = pci_legacy_suspend(dev, PMSG_HIBERNATE);
+		goto Exit;
+	}
+
 	if (drv && drv->pm) {
 		if (drv->pm->poweroff) {
 			error = drv->pm->poweroff(dev);
 			suspend_report_result(drv->pm->poweroff, error);
 		}
-	} else if (pci_has_legacy_pm_support(pci_dev)) {
-		error = pci_legacy_suspend(dev, PMSG_HIBERNATE);
 	} else {
 		pci_pm_default_suspend(pci_dev);
 	}
 
+ Exit:
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
 
 	return error;
@@ -713,13 +742,14 @@ static int pci_pm_poweroff_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	if (pci_has_legacy_pm_support(to_pci_dev(dev)))
+		return pci_legacy_suspend_late(dev, PMSG_HIBERNATE);
+
 	if (drv && drv->pm) {
 		if (drv->pm->poweroff_noirq) {
 			error = drv->pm->poweroff_noirq(dev);
 			suspend_report_result(drv->pm->poweroff_noirq, error);
 		}
-	} else if (pci_has_legacy_pm_support(to_pci_dev(dev))) {
-		error = pci_legacy_suspend_late(dev, PMSG_HIBERNATE);
 	}
 
 	return error;
@@ -731,14 +761,16 @@ static int pci_pm_restore(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	if (pci_has_legacy_pm_support(pci_dev)) {
+		pci_fixup_device(pci_fixup_resume, pci_dev);
+		return pci_legacy_resume(dev);
+	}
+
 	if (drv && drv->pm) {
 		pci_fixup_device(pci_fixup_resume, pci_dev);
 
 		if (drv->pm->restore)
 			error = drv->pm->restore(dev);
-	} else if (pci_has_legacy_pm_support(pci_dev)) {
-		pci_fixup_device(pci_fixup_resume, pci_dev);
-		error = pci_legacy_resume(dev);
 	} else {
 		error = pci_pm_default_resume(pci_dev);
 	}
@@ -752,14 +784,16 @@ static int pci_pm_restore_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	if (pci_has_legacy_pm_support(pci_dev)) {
+		pci_fixup_device(pci_fixup_resume_early, pci_dev);
+		return pci_legacy_resume_early(dev);
+	}
+
 	if (drv && drv->pm) {
 		pci_fixup_device(pci_fixup_resume_early, pci_dev);
 
 		if (drv->pm->restore_noirq)
 			error = drv->pm->restore_noirq(dev);
-	} else if (pci_has_legacy_pm_support(pci_dev)) {
-		pci_fixup_device(pci_fixup_resume_early, pci_dev);
-		error = pci_legacy_resume_early(dev);
 	} else {
 		pci_pm_default_resume_noirq(pci_dev);
 	}

commit 734104292ff77dc71fe626b4ebd91b314547ca1b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jan 7 13:07:15 2009 +0100

    PCI PM: Avoid touching devices behind bridges in unknown state
    
    It generally is better to avoid accessing devices behind bridges that
    may not be in the D0 power state, because in that case the bridges'
    secondary buses may not be accessible.  For this reason, during the
    early phase of resume (ie. with interrupts disabled), before
    restoring the standard config registers of a device, check the power
    state of the bridge the device is behind and postpone the restoration
    of the device's config space, as well as any other operations that
    would involve accessing the device, if that state is not D0.
    
    In such cases the restoration of the device's config space will be
    retried during the "normal" phase of resume (ie. with interrupts
    enabled), so that the bridge can be put into D0 before that happens.
    
    Also, save standard configuration registers of PCI devices during the
    "normal" phase of suspend (ie. with interrupts enabled), so that the
    bridges the devices are behind can be put into low power states (we
    don't put bridges into low power states at the moment, but we may
    want to do it in the future and it seems reasonable to design for
    that).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index bfaa77d88537..750ee79c178f 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -314,23 +314,12 @@ static void pci_device_shutdown(struct device *dev)
 
 #ifdef CONFIG_PM_SLEEP
 
-/*
- * Default "suspend" method for devices that have no driver provided suspend,
- * or not even a driver at all (first part).
- */
-static void pci_default_pm_suspend_early(struct pci_dev *pci_dev)
-{
-	/* If device is enabled at this point, disable it */
-	pci_disable_enabled_device(pci_dev);
-}
-
 /*
  * Default "suspend" method for devices that have no driver provided suspend,
  * or not even a driver at all (second part).
  */
 static void pci_default_pm_suspend_late(struct pci_dev *pci_dev)
 {
-	pci_save_state(pci_dev);
 	/*
 	 * mark its power state as "unknown", since we don't know if
 	 * e.g. the BIOS will change its device state when we suspend.
@@ -339,16 +328,6 @@ static void pci_default_pm_suspend_late(struct pci_dev *pci_dev)
 		pci_dev->current_state = PCI_UNKNOWN;
 }
 
-/*
- * Default "resume" method for devices that have no driver provided resume,
- * or not even a driver at all (first part).
- */
-static void pci_default_pm_resume_early(struct pci_dev *pci_dev)
-{
-	/* restore the PCI config space */
-	pci_restore_state(pci_dev);
-}
-
 /*
  * Default "resume" method for devices that have no driver provided resume,
  * or not even a driver at all (second part).
@@ -379,9 +358,10 @@ static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 		i = drv->suspend(pci_dev, state);
 		suspend_report_result(drv->suspend, i);
 	} else {
+		pci_save_state(pci_dev);
 		/*
-		 * For compatibility with existing code with legacy PM support
-		 * don't call pci_default_pm_suspend_early() here.
+		 * This is for compatibility with existing code with legacy PM
+		 * support.
 		 */
 		pci_default_pm_suspend_late(pci_dev);
 	}
@@ -410,7 +390,8 @@ static int pci_legacy_resume(struct device *dev)
 	if (drv && drv->resume) {
 		error = drv->resume(pci_dev);
 	} else {
-		pci_default_pm_resume_early(pci_dev);
+		/* restore the PCI config space */
+		pci_restore_state(pci_dev);
 		error = pci_default_pm_resume_late(pci_dev);
 	}
 	return error;
@@ -429,22 +410,72 @@ static int pci_legacy_resume_early(struct device *dev)
 
 /* Auxiliary functions used by the new power management framework */
 
+static int pci_restore_standard_config(struct pci_dev *pci_dev)
+{
+	struct pci_dev *parent = pci_dev->bus->self;
+	int error = 0;
+
+	/* Check if the device's bus is operational */
+	if (!parent || parent->current_state == PCI_D0) {
+		pci_restore_state(pci_dev);
+		pci_update_current_state(pci_dev, PCI_D0);
+	} else {
+		dev_warn(&pci_dev->dev, "unable to restore config, "
+			"bridge %s in low power state D%d\n", pci_name(parent),
+			parent->current_state);
+		pci_dev->current_state = PCI_UNKNOWN;
+		error = -EAGAIN;
+	}
+
+	return error;
+}
+
 static bool pci_is_bridge(struct pci_dev *pci_dev)
 {
 	return !!(pci_dev->subordinate);
 }
 
+static void pci_pm_default_resume_noirq(struct pci_dev *pci_dev)
+{
+	if (pci_restore_standard_config(pci_dev))
+		pci_fixup_device(pci_fixup_resume_early, pci_dev);
+}
+
 static int pci_pm_default_resume(struct pci_dev *pci_dev)
 {
+	/*
+	 * pci_restore_standard_config() should have been called once already,
+	 * but it would have failed if the device's parent bridge had not been
+	 * in power state D0 at that time.  Check it and try again if necessary.
+	 */
+	if (pci_dev->current_state == PCI_UNKNOWN) {
+		int error = pci_restore_standard_config(pci_dev);
+		if (error)
+			return error;
+	}
+
+	pci_fixup_device(pci_fixup_resume, pci_dev);
+
 	if (!pci_is_bridge(pci_dev))
 		pci_enable_wake(pci_dev, PCI_D0, false);
 
 	return pci_default_pm_resume_late(pci_dev);
 }
 
+static void pci_pm_default_suspend_generic(struct pci_dev *pci_dev)
+{
+	/* If device is enabled at this point, disable it */
+	pci_disable_enabled_device(pci_dev);
+	/*
+	 * Save state with interrupts enabled, because in principle the bus the
+	 * device is on may be put into a low power state after this code runs.
+	 */
+	pci_save_state(pci_dev);
+}
+
 static void pci_pm_default_suspend(struct pci_dev *pci_dev)
 {
-	pci_default_pm_suspend_early(pci_dev);
+	pci_pm_default_suspend_generic(pci_dev);
 
 	if (!pci_is_bridge(pci_dev))
 		pci_prepare_to_sleep(pci_dev);
@@ -529,12 +560,13 @@ static int pci_pm_resume(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	pci_fixup_device(pci_fixup_resume, pci_dev);
-
 	if (drv && drv->pm) {
+		pci_fixup_device(pci_fixup_resume, pci_dev);
+
 		if (drv->pm->resume)
 			error = drv->pm->resume(dev);
 	} else if (pci_has_legacy_pm_support(pci_dev)) {
+		pci_fixup_device(pci_fixup_resume, pci_dev);
 		error = pci_legacy_resume(dev);
 	} else {
 		error = pci_pm_default_resume(pci_dev);
@@ -549,15 +581,16 @@ static int pci_pm_resume_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	pci_fixup_device(pci_fixup_resume_early, to_pci_dev(dev));
-
 	if (drv && drv->pm) {
+		pci_fixup_device(pci_fixup_resume_early, pci_dev);
+
 		if (drv->pm->resume_noirq)
 			error = drv->pm->resume_noirq(dev);
 	} else if (pci_has_legacy_pm_support(pci_dev)) {
+		pci_fixup_device(pci_fixup_resume_early, pci_dev);
 		error = pci_legacy_resume_early(dev);
 	} else {
-		pci_default_pm_resume_early(pci_dev);
+		pci_pm_default_resume_noirq(pci_dev);
 	}
 
 	return error;
@@ -589,7 +622,7 @@ static int pci_pm_freeze(struct device *dev)
 		error = pci_legacy_suspend(dev, PMSG_FREEZE);
 		pci_fixup_device(pci_fixup_suspend, pci_dev);
 	} else {
-		pci_default_pm_suspend_early(pci_dev);
+		pci_pm_default_suspend_generic(pci_dev);
 	}
 
 	return error;
@@ -647,7 +680,7 @@ static int pci_pm_thaw_noirq(struct device *dev)
 		pci_fixup_device(pci_fixup_resume_early, to_pci_dev(dev));
 		error = pci_legacy_resume_early(dev);
 	} else {
-		pci_default_pm_resume_early(pci_dev);
+		pci_update_current_state(pci_dev, PCI_D0);
 	}
 
 	return error;
@@ -698,12 +731,13 @@ static int pci_pm_restore(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	pci_fixup_device(pci_fixup_resume, pci_dev);
-
 	if (drv && drv->pm) {
+		pci_fixup_device(pci_fixup_resume, pci_dev);
+
 		if (drv->pm->restore)
 			error = drv->pm->restore(dev);
 	} else if (pci_has_legacy_pm_support(pci_dev)) {
+		pci_fixup_device(pci_fixup_resume, pci_dev);
 		error = pci_legacy_resume(dev);
 	} else {
 		error = pci_pm_default_resume(pci_dev);
@@ -718,15 +752,16 @@ static int pci_pm_restore_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	pci_fixup_device(pci_fixup_resume_early, pci_dev);
-
 	if (drv && drv->pm) {
+		pci_fixup_device(pci_fixup_resume_early, pci_dev);
+
 		if (drv->pm->restore_noirq)
 			error = drv->pm->restore_noirq(dev);
 	} else if (pci_has_legacy_pm_support(pci_dev)) {
+		pci_fixup_device(pci_fixup_resume_early, pci_dev);
 		error = pci_legacy_resume_early(dev);
 	} else {
-		pci_default_pm_resume_early(pci_dev);
+		pci_pm_default_resume_noirq(pci_dev);
 	}
 
 	return error;

commit 07e836e8d1f3688311d97fe1bf46980b0f9ae9c1
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jan 7 13:06:10 2009 +0100

    PCI PM: Move pci_has_legacy_pm_support
    
    Move pci_has_legacy_pm_support() closer to the functions that
    call it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 2617ebb34e14..bfaa77d88537 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -314,14 +314,6 @@ static void pci_device_shutdown(struct device *dev)
 
 #ifdef CONFIG_PM_SLEEP
 
-static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
-{
-	struct pci_driver *drv = pci_dev->driver;
-
-	return drv && (drv->suspend || drv->suspend_late || drv->resume
-		|| drv->resume_early);
-}
-
 /*
  * Default "suspend" method for devices that have no driver provided suspend,
  * or not even a driver at all (first part).
@@ -458,6 +450,14 @@ static void pci_pm_default_suspend(struct pci_dev *pci_dev)
 		pci_prepare_to_sleep(pci_dev);
 }
 
+static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
+{
+	struct pci_driver *drv = pci_dev->driver;
+
+	return drv && (drv->suspend || drv->suspend_late || drv->resume
+		|| drv->resume_early);
+}
+
 /* New power management framework */
 
 static int pci_pm_prepare(struct device *dev)

commit 571ff7584bb9e05fca0eb79752ae55a46faf3a98
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jan 7 13:05:05 2009 +0100

    PCI PM: Power-manage devices without drivers during suspend-resume
    
    PCI devices without drivers can be put into low power states during
    suspend with the help of pci_prepare_to_sleep() and prevented from
    generating wake-up events during resume with the help of
    pci_enable_wake().  However, it's better not to put bridges into
    low power states during suspend, because that might result in entire
    bus segments being powered off.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 57cb0015a470..2617ebb34e14 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -435,6 +435,31 @@ static int pci_legacy_resume_early(struct device *dev)
 	return error;
 }
 
+/* Auxiliary functions used by the new power management framework */
+
+static bool pci_is_bridge(struct pci_dev *pci_dev)
+{
+	return !!(pci_dev->subordinate);
+}
+
+static int pci_pm_default_resume(struct pci_dev *pci_dev)
+{
+	if (!pci_is_bridge(pci_dev))
+		pci_enable_wake(pci_dev, PCI_D0, false);
+
+	return pci_default_pm_resume_late(pci_dev);
+}
+
+static void pci_pm_default_suspend(struct pci_dev *pci_dev)
+{
+	pci_default_pm_suspend_early(pci_dev);
+
+	if (!pci_is_bridge(pci_dev))
+		pci_prepare_to_sleep(pci_dev);
+}
+
+/* New power management framework */
+
 static int pci_pm_prepare(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
@@ -470,7 +495,7 @@ static int pci_pm_suspend(struct device *dev)
 	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_suspend(dev, PMSG_SUSPEND);
 	} else {
-		pci_default_pm_suspend_early(pci_dev);
+		pci_pm_default_suspend(pci_dev);
 	}
 
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
@@ -512,7 +537,7 @@ static int pci_pm_resume(struct device *dev)
 	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_resume(dev);
 	} else {
-		error = pci_default_pm_resume_late(pci_dev);
+		error = pci_pm_default_resume(pci_dev);
 	}
 
 	return error;
@@ -642,7 +667,7 @@ static int pci_pm_poweroff(struct device *dev)
 	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_suspend(dev, PMSG_HIBERNATE);
 	} else {
-		pci_default_pm_suspend_early(pci_dev);
+		pci_pm_default_suspend(pci_dev);
 	}
 
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
@@ -681,7 +706,7 @@ static int pci_pm_restore(struct device *dev)
 	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_resume(dev);
 	} else {
-		error = pci_default_pm_resume_late(pci_dev);
+		error = pci_pm_default_resume(pci_dev);
 	}
 
 	return error;

commit fa58d305d9925b01830e535896a7227a868a9e15
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jan 7 13:03:42 2009 +0100

    PCI PM: Add suspend counterpart of pci_reenable_device
    
    PCI devices without drivers are not disabled during suspend and
    hibernation, but they are enabled during resume, with the help of
    pci_reenable_device(), so there is an unbalanced execution of
    pcibios_enable_device() in the resume code path.
    
    To correct this introduce function pci_disable_enabled_device()
    that will disable the argument device, if it is enabled when the
    function is being run, without updating the device's pci_dev
    structure and use it in the suspend code path to balance the
    pci_reenable_device() executed during resume.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 23bdf64411e5..57cb0015a470 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -324,9 +324,19 @@ static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
 
 /*
  * Default "suspend" method for devices that have no driver provided suspend,
- * or not even a driver at all.
+ * or not even a driver at all (first part).
+ */
+static void pci_default_pm_suspend_early(struct pci_dev *pci_dev)
+{
+	/* If device is enabled at this point, disable it */
+	pci_disable_enabled_device(pci_dev);
+}
+
+/*
+ * Default "suspend" method for devices that have no driver provided suspend,
+ * or not even a driver at all (second part).
  */
-static void pci_default_pm_suspend(struct pci_dev *pci_dev)
+static void pci_default_pm_suspend_late(struct pci_dev *pci_dev)
 {
 	pci_save_state(pci_dev);
 	/*
@@ -377,7 +387,11 @@ static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 		i = drv->suspend(pci_dev, state);
 		suspend_report_result(drv->suspend, i);
 	} else {
-		pci_default_pm_suspend(pci_dev);
+		/*
+		 * For compatibility with existing code with legacy PM support
+		 * don't call pci_default_pm_suspend_early() here.
+		 */
+		pci_default_pm_suspend_late(pci_dev);
 	}
 	return i;
 }
@@ -455,7 +469,10 @@ static int pci_pm_suspend(struct device *dev)
 		}
 	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_suspend(dev, PMSG_SUSPEND);
+	} else {
+		pci_default_pm_suspend_early(pci_dev);
 	}
+
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
 
 	return error;
@@ -475,7 +492,7 @@ static int pci_pm_suspend_noirq(struct device *dev)
 	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_suspend_late(dev, PMSG_SUSPEND);
 	} else {
-		pci_default_pm_suspend(pci_dev);
+		pci_default_pm_suspend_late(pci_dev);
 	}
 
 	return error;
@@ -546,6 +563,8 @@ static int pci_pm_freeze(struct device *dev)
 	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_suspend(dev, PMSG_FREEZE);
 		pci_fixup_device(pci_fixup_suspend, pci_dev);
+	} else {
+		pci_default_pm_suspend_early(pci_dev);
 	}
 
 	return error;
@@ -565,7 +584,7 @@ static int pci_pm_freeze_noirq(struct device *dev)
 	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_suspend_late(dev, PMSG_FREEZE);
 	} else {
-		pci_default_pm_suspend(pci_dev);
+		pci_default_pm_suspend_late(pci_dev);
 	}
 
 	return error;
@@ -583,6 +602,8 @@ static int pci_pm_thaw(struct device *dev)
 	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		pci_fixup_device(pci_fixup_resume, pci_dev);
 		error = pci_legacy_resume(dev);
+	} else {
+		pci_default_pm_resume_late(pci_dev);
 	}
 
 	return error;
@@ -600,6 +621,8 @@ static int pci_pm_thaw_noirq(struct device *dev)
 	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		pci_fixup_device(pci_fixup_resume_early, to_pci_dev(dev));
 		error = pci_legacy_resume_early(dev);
+	} else {
+		pci_default_pm_resume_early(pci_dev);
 	}
 
 	return error;
@@ -618,6 +641,8 @@ static int pci_pm_poweroff(struct device *dev)
 		}
 	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_suspend(dev, PMSG_HIBERNATE);
+	} else {
+		pci_default_pm_suspend_early(pci_dev);
 	}
 
 	pci_fixup_device(pci_fixup_suspend, pci_dev);

commit c9b9972b3c88272be02d971346285d1c67fbb95f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jan 7 13:02:36 2009 +0100

    PCI PM: Fix poweroff and restore callbacks
    
    pci_fixup_device() is called too early in pci_pm_poweroff() and too
    late in pci_pm_restore().  Moreover, pci_pm_restore_noirq() calls
    pci_fixup_device() twice and in a wrong way.  Fix that.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index c3f76be832d4..23bdf64411e5 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -611,8 +611,6 @@ static int pci_pm_poweroff(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	pci_fixup_device(pci_fixup_suspend, pci_dev);
-
 	if (drv && drv->pm) {
 		if (drv->pm->poweroff) {
 			error = drv->pm->poweroff(dev);
@@ -622,6 +620,8 @@ static int pci_pm_poweroff(struct device *dev)
 		error = pci_legacy_suspend(dev, PMSG_HIBERNATE);
 	}
 
+	pci_fixup_device(pci_fixup_suspend, pci_dev);
+
 	return error;
 }
 
@@ -648,6 +648,8 @@ static int pci_pm_restore(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
+	pci_fixup_device(pci_fixup_resume, pci_dev);
+
 	if (drv && drv->pm) {
 		if (drv->pm->restore)
 			error = drv->pm->restore(dev);
@@ -656,7 +658,6 @@ static int pci_pm_restore(struct device *dev)
 	} else {
 		error = pci_default_pm_resume_late(pci_dev);
 	}
-	pci_fixup_device(pci_fixup_resume, pci_dev);
 
 	return error;
 }
@@ -667,7 +668,7 @@ static int pci_pm_restore_noirq(struct device *dev)
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	pci_fixup_device(pci_fixup_resume, pci_dev);
+	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 
 	if (drv && drv->pm) {
 		if (drv->pm->restore_noirq)
@@ -677,7 +678,6 @@ static int pci_pm_restore_noirq(struct device *dev)
 	} else {
 		pci_default_pm_resume_early(pci_dev);
 	}
-	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 
 	return error;
 }

commit 873392ca514f87eae39f53b6944caf85b1a047cb
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Wed Dec 31 23:54:56 2008 +1030

    PCI: work_on_cpu: use in drivers/pci/pci-driver.c
    
    This uses work_on_cpu(), rather than altering the cpumask of the
    thread which we happen to be.
    
    Note the cleanups:
    
    1) I've removed the CONFIG_NUMA test, since dev_to_node() returns -1
       for !CONFIG_NUMA anyway and the compiler will eliminate it.
    
    2) No need to reset mempolicy to default (a bad idea anyway) since
       work_on_cpu is run from a workqueue.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 888191a3b0d1..c3f76be832d4 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -16,6 +16,7 @@
 #include <linux/string.h>
 #include <linux/slab.h>
 #include <linux/sched.h>
+#include <linux/cpu.h>
 #include "pci.h"
 
 /*
@@ -185,32 +186,43 @@ static const struct pci_device_id *pci_match_device(struct pci_driver *drv,
 	return pci_match_id(drv->id_table, dev);
 }
 
+struct drv_dev_and_id {
+	struct pci_driver *drv;
+	struct pci_dev *dev;
+	const struct pci_device_id *id;
+};
+
+static long local_pci_probe(void *_ddi)
+{
+	struct drv_dev_and_id *ddi = _ddi;
+
+	return ddi->drv->probe(ddi->dev, ddi->id);
+}
+
 static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
 			  const struct pci_device_id *id)
 {
-	int error;
-#ifdef CONFIG_NUMA
-	/* Execute driver initialization on node where the
-	   device's bus is attached to.  This way the driver likely
-	   allocates its local memory on the right node without
-	   any need to change it. */
-	struct mempolicy *oldpol;
-	cpumask_t oldmask = current->cpus_allowed;
-	int node = dev_to_node(&dev->dev);
+	int error, node;
+	struct drv_dev_and_id ddi = { drv, dev, id };
 
+	/* Execute driver initialization on node where the device's
+	   bus is attached to.  This way the driver likely allocates
+	   its local memory on the right node without any need to
+	   change it. */
+	node = dev_to_node(&dev->dev);
 	if (node >= 0) {
+		int cpu;
 		node_to_cpumask_ptr(nodecpumask, node);
-		set_cpus_allowed_ptr(current, nodecpumask);
-	}
-	/* And set default memory allocation policy */
-	oldpol = current->mempolicy;
-	current->mempolicy = NULL;	/* fall back to system default policy */
-#endif
-	error = drv->probe(dev, id);
-#ifdef CONFIG_NUMA
-	set_cpus_allowed_ptr(current, &oldmask);
-	current->mempolicy = oldpol;
-#endif
+
+		get_online_cpus();
+		cpu = cpumask_any_and(nodecpumask, cpu_online_mask);
+		if (cpu < nr_cpu_ids)
+			error = work_on_cpu(cpu, local_pci_probe, &ddi);
+		else
+			error = local_pci_probe(&ddi);
+		put_online_cpus();
+	} else
+		error = local_pci_probe(&ddi);
 	return error;
 }
 

commit 2debb4d2019fa05a0896f1591dea0e0dc21bc046
Author: Chris Wright <chrisw@sous-sol.org>
Date:   Tue Nov 25 19:36:10 2008 -0800

    PCI: allow pci driver to support only dynids
    
    commit b41d6cf38e27 (PCI: Check dynids driver_data value for validity)
    requires all drivers to include an id table to try and match
    driver_data.  Before validating driver_data check driver has an id
    table.
    
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Cc: Milton Miller <miltonm@bga.com>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 99d867bcf22a..888191a3b0d1 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -48,7 +48,7 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 		subdevice=PCI_ANY_ID, class=0, class_mask=0;
 	unsigned long driver_data=0;
 	int fields=0;
-	int retval;
+	int retval=0;
 
 	fields = sscanf(buf, "%x %x %x %x %x %x %lx",
 			&vendor, &device, &subvendor, &subdevice,
@@ -58,16 +58,18 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 
 	/* Only accept driver_data values that match an existing id_table
 	   entry */
-	retval = -EINVAL;
-	while (ids->vendor || ids->subvendor || ids->class_mask) {
-		if (driver_data == ids->driver_data) {
-			retval = 0;
-			break;
+	if (ids) {
+		retval = -EINVAL;
+		while (ids->vendor || ids->subvendor || ids->class_mask) {
+			if (driver_data == ids->driver_data) {
+				retval = 0;
+				break;
+			}
+			ids++;
 		}
-		ids++;
+		if (retval)	/* No match */
+			return retval;
 	}
-	if (retval)	/* No match */
-		return retval;
 
 	dynid = kzalloc(sizeof(*dynid), GFP_KERNEL);
 	if (!dynid)

commit 355a72d75b3b4f4877db4c9070c798238028ecb5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Dec 8 00:34:57 2008 +0100

    PCI: Rework default handling of suspend and resume
    
    Rework the handling of suspend and resume of PCI devices which have
    no drivers or the drivers of which do not provide any suspend-resume
    callbacks in such a way that their standard PCI configuration
    registers will be saved and restored with interrupts disabled.  This
    should prevent such devices, including PCI bridges, from being
    resumed too late to be able to function correctly during the resume
    of the other PCI devices that may depend on them.
    
    Also, to remove one possible source of future confusion, drop the
    default handling of suspend and resume for PCI devices with drivers
    providing the 'pm' object introduced by the new suspend-resume
    framework (there are no such PCI drivers at the moment).
    
    This patch addresses the regression from 2.6.26 tracked as
    http://bugzilla.kernel.org/show_bug.cgi?id=12121 .
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 4042d211c3e5..99d867bcf22a 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -300,6 +300,14 @@ static void pci_device_shutdown(struct device *dev)
 
 #ifdef CONFIG_PM_SLEEP
 
+static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
+{
+	struct pci_driver *drv = pci_dev->driver;
+
+	return drv && (drv->suspend || drv->suspend_late || drv->resume
+		|| drv->resume_early);
+}
+
 /*
  * Default "suspend" method for devices that have no driver provided suspend,
  * or not even a driver at all.
@@ -317,14 +325,22 @@ static void pci_default_pm_suspend(struct pci_dev *pci_dev)
 
 /*
  * Default "resume" method for devices that have no driver provided resume,
- * or not even a driver at all.
+ * or not even a driver at all (first part).
  */
-static int pci_default_pm_resume(struct pci_dev *pci_dev)
+static void pci_default_pm_resume_early(struct pci_dev *pci_dev)
 {
-	int retval = 0;
-
 	/* restore the PCI config space */
 	pci_restore_state(pci_dev);
+}
+
+/*
+ * Default "resume" method for devices that have no driver provided resume,
+ * or not even a driver at all (second part).
+ */
+static int pci_default_pm_resume_late(struct pci_dev *pci_dev)
+{
+	int retval;
+
 	/* if the device was enabled before suspend, reenable */
 	retval = pci_reenable_device(pci_dev);
 	/*
@@ -371,10 +387,12 @@ static int pci_legacy_resume(struct device *dev)
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	struct pci_driver * drv = pci_dev->driver;
 
-	if (drv && drv->resume)
+	if (drv && drv->resume) {
 		error = drv->resume(pci_dev);
-	else
-		error = pci_default_pm_resume(pci_dev);
+	} else {
+		pci_default_pm_resume_early(pci_dev);
+		error = pci_default_pm_resume_late(pci_dev);
+	}
 	return error;
 }
 
@@ -420,10 +438,8 @@ static int pci_pm_suspend(struct device *dev)
 		if (drv->pm->suspend) {
 			error = drv->pm->suspend(dev);
 			suspend_report_result(drv->pm->suspend, error);
-		} else {
-			pci_default_pm_suspend(pci_dev);
 		}
-	} else {
+	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_suspend(dev, PMSG_SUSPEND);
 	}
 	pci_fixup_device(pci_fixup_suspend, pci_dev);
@@ -433,6 +449,7 @@ static int pci_pm_suspend(struct device *dev)
 
 static int pci_pm_suspend_noirq(struct device *dev)
 {
+	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
@@ -441,8 +458,10 @@ static int pci_pm_suspend_noirq(struct device *dev)
 			error = drv->pm->suspend_noirq(dev);
 			suspend_report_result(drv->pm->suspend_noirq, error);
 		}
-	} else {
+	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_suspend_late(dev, PMSG_SUSPEND);
+	} else {
+		pci_default_pm_suspend(pci_dev);
 	}
 
 	return error;
@@ -452,15 +471,17 @@ static int pci_pm_resume(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
-	int error;
+	int error = 0;
 
 	pci_fixup_device(pci_fixup_resume, pci_dev);
 
 	if (drv && drv->pm) {
-		error = drv->pm->resume ? drv->pm->resume(dev) :
-			pci_default_pm_resume(pci_dev);
-	} else {
+		if (drv->pm->resume)
+			error = drv->pm->resume(dev);
+	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_resume(dev);
+	} else {
+		error = pci_default_pm_resume_late(pci_dev);
 	}
 
 	return error;
@@ -468,6 +489,7 @@ static int pci_pm_resume(struct device *dev)
 
 static int pci_pm_resume_noirq(struct device *dev)
 {
+	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
@@ -476,8 +498,10 @@ static int pci_pm_resume_noirq(struct device *dev)
 	if (drv && drv->pm) {
 		if (drv->pm->resume_noirq)
 			error = drv->pm->resume_noirq(dev);
-	} else {
+	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_resume_early(dev);
+	} else {
+		pci_default_pm_resume_early(pci_dev);
 	}
 
 	return error;
@@ -504,10 +528,8 @@ static int pci_pm_freeze(struct device *dev)
 		if (drv->pm->freeze) {
 			error = drv->pm->freeze(dev);
 			suspend_report_result(drv->pm->freeze, error);
-		} else {
-			pci_default_pm_suspend(pci_dev);
 		}
-	} else {
+	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_suspend(dev, PMSG_FREEZE);
 		pci_fixup_device(pci_fixup_suspend, pci_dev);
 	}
@@ -517,6 +539,7 @@ static int pci_pm_freeze(struct device *dev)
 
 static int pci_pm_freeze_noirq(struct device *dev)
 {
+	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
@@ -525,8 +548,10 @@ static int pci_pm_freeze_noirq(struct device *dev)
 			error = drv->pm->freeze_noirq(dev);
 			suspend_report_result(drv->pm->freeze_noirq, error);
 		}
-	} else {
+	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_suspend_late(dev, PMSG_FREEZE);
+	} else {
+		pci_default_pm_suspend(pci_dev);
 	}
 
 	return error;
@@ -534,14 +559,15 @@ static int pci_pm_freeze_noirq(struct device *dev)
 
 static int pci_pm_thaw(struct device *dev)
 {
+	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
 	if (drv && drv->pm) {
 		if (drv->pm->thaw)
 			error =  drv->pm->thaw(dev);
-	} else {
-		pci_fixup_device(pci_fixup_resume, to_pci_dev(dev));
+	} else if (pci_has_legacy_pm_support(pci_dev)) {
+		pci_fixup_device(pci_fixup_resume, pci_dev);
 		error = pci_legacy_resume(dev);
 	}
 
@@ -550,13 +576,14 @@ static int pci_pm_thaw(struct device *dev)
 
 static int pci_pm_thaw_noirq(struct device *dev)
 {
+	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
 	if (drv && drv->pm) {
 		if (drv->pm->thaw_noirq)
 			error = drv->pm->thaw_noirq(dev);
-	} else {
+	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		pci_fixup_device(pci_fixup_resume_early, to_pci_dev(dev));
 		error = pci_legacy_resume_early(dev);
 	}
@@ -566,17 +593,18 @@ static int pci_pm_thaw_noirq(struct device *dev)
 
 static int pci_pm_poweroff(struct device *dev)
 {
+	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	pci_fixup_device(pci_fixup_suspend, to_pci_dev(dev));
+	pci_fixup_device(pci_fixup_suspend, pci_dev);
 
 	if (drv && drv->pm) {
 		if (drv->pm->poweroff) {
 			error = drv->pm->poweroff(dev);
 			suspend_report_result(drv->pm->poweroff, error);
 		}
-	} else {
+	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_suspend(dev, PMSG_HIBERNATE);
 	}
 
@@ -593,7 +621,7 @@ static int pci_pm_poweroff_noirq(struct device *dev)
 			error = drv->pm->poweroff_noirq(dev);
 			suspend_report_result(drv->pm->poweroff_noirq, error);
 		}
-	} else {
+	} else if (pci_has_legacy_pm_support(to_pci_dev(dev))) {
 		error = pci_legacy_suspend_late(dev, PMSG_HIBERNATE);
 	}
 
@@ -604,13 +632,15 @@ static int pci_pm_restore(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct device_driver *drv = dev->driver;
-	int error;
+	int error = 0;
 
 	if (drv && drv->pm) {
-		error = drv->pm->restore ? drv->pm->restore(dev) :
-			pci_default_pm_resume(pci_dev);
-	} else {
+		if (drv->pm->restore)
+			error = drv->pm->restore(dev);
+	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_resume(dev);
+	} else {
+		error = pci_default_pm_resume_late(pci_dev);
 	}
 	pci_fixup_device(pci_fixup_resume, pci_dev);
 
@@ -628,8 +658,10 @@ static int pci_pm_restore_noirq(struct device *dev)
 	if (drv && drv->pm) {
 		if (drv->pm->restore_noirq)
 			error = drv->pm->restore_noirq(dev);
-	} else {
+	} else if (pci_has_legacy_pm_support(pci_dev)) {
 		error = pci_legacy_resume_early(dev);
+	} else {
+		pci_default_pm_resume_early(pci_dev);
 	}
 	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 

commit adf094931ffb25ef4b381559918f1a34181a5273
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Oct 6 22:46:05 2008 +0200

    PM: Simplify the new suspend/hibernation framework for devices
    
    PM: Simplify the new suspend/hibernation framework for devices
    
    Following the discussion at the Kernel Summit, simplify the new
    device PM framework by merging 'struct pm_ops' and
    'struct pm_ext_ops' and removing pointers to 'struct pm_ext_ops'
    from 'struct platform_driver' and 'struct pci_driver'.
    
    After this change, the suspend/hibernation callbacks will only
    reside in 'struct device_driver' as well as at the bus type/
    device class/device type level.  Accordingly, PCI and platform
    device drivers are now expected to put their suspend/hibernation
    callbacks into the 'struct device_driver' embedded in
    'struct pci_driver' or 'struct platform_driver', respectively.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index b4cdd690ae71..4042d211c3e5 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -433,8 +433,7 @@ static int pci_pm_suspend(struct device *dev)
 
 static int pci_pm_suspend_noirq(struct device *dev)
 {
-	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct pci_driver *drv = pci_dev->driver;
+	struct device_driver *drv = dev->driver;
 	int error = 0;
 
 	if (drv && drv->pm) {
@@ -469,11 +468,10 @@ static int pci_pm_resume(struct device *dev)
 
 static int pci_pm_resume_noirq(struct device *dev)
 {
-	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct pci_driver *drv = pci_dev->driver;
+	struct device_driver *drv = dev->driver;
 	int error = 0;
 
-	pci_fixup_device(pci_fixup_resume_early, pci_dev);
+	pci_fixup_device(pci_fixup_resume_early, to_pci_dev(dev));
 
 	if (drv && drv->pm) {
 		if (drv->pm->resume_noirq)
@@ -519,8 +517,7 @@ static int pci_pm_freeze(struct device *dev)
 
 static int pci_pm_freeze_noirq(struct device *dev)
 {
-	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct pci_driver *drv = pci_dev->driver;
+	struct device_driver *drv = dev->driver;
 	int error = 0;
 
 	if (drv && drv->pm) {
@@ -553,15 +550,14 @@ static int pci_pm_thaw(struct device *dev)
 
 static int pci_pm_thaw_noirq(struct device *dev)
 {
-	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct pci_driver *drv = pci_dev->driver;
+	struct device_driver *drv = dev->driver;
 	int error = 0;
 
 	if (drv && drv->pm) {
 		if (drv->pm->thaw_noirq)
 			error = drv->pm->thaw_noirq(dev);
 	} else {
-		pci_fixup_device(pci_fixup_resume_early, pci_dev);
+		pci_fixup_device(pci_fixup_resume_early, to_pci_dev(dev));
 		error = pci_legacy_resume_early(dev);
 	}
 
@@ -589,8 +585,7 @@ static int pci_pm_poweroff(struct device *dev)
 
 static int pci_pm_poweroff_noirq(struct device *dev)
 {
-	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct pci_driver *drv = pci_dev->driver;
+	struct device_driver *drv = dev->driver;
 	int error = 0;
 
 	if (drv && drv->pm) {
@@ -625,7 +620,7 @@ static int pci_pm_restore(struct device *dev)
 static int pci_pm_restore_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct pci_driver *drv = pci_dev->driver;
+	struct device_driver *drv = dev->driver;
 	int error = 0;
 
 	pci_fixup_device(pci_fixup_resume, pci_dev);
@@ -654,17 +649,15 @@ static int pci_pm_restore_noirq(struct device *dev)
 
 #endif /* !CONFIG_HIBERNATION */
 
-struct pm_ext_ops pci_pm_ops = {
-	.base = {
-		.prepare = pci_pm_prepare,
-		.complete = pci_pm_complete,
-		.suspend = pci_pm_suspend,
-		.resume = pci_pm_resume,
-		.freeze = pci_pm_freeze,
-		.thaw = pci_pm_thaw,
-		.poweroff = pci_pm_poweroff,
-		.restore = pci_pm_restore,
-	},
+struct dev_pm_ops pci_dev_pm_ops = {
+	.prepare = pci_pm_prepare,
+	.complete = pci_pm_complete,
+	.suspend = pci_pm_suspend,
+	.resume = pci_pm_resume,
+	.freeze = pci_pm_freeze,
+	.thaw = pci_pm_thaw,
+	.poweroff = pci_pm_poweroff,
+	.restore = pci_pm_restore,
 	.suspend_noirq = pci_pm_suspend_noirq,
 	.resume_noirq = pci_pm_resume_noirq,
 	.freeze_noirq = pci_pm_freeze_noirq,
@@ -673,7 +666,7 @@ struct pm_ext_ops pci_pm_ops = {
 	.restore_noirq = pci_pm_restore_noirq,
 };
 
-#define PCI_PM_OPS_PTR	&pci_pm_ops
+#define PCI_PM_OPS_PTR	(&pci_dev_pm_ops)
 
 #else /* !CONFIG_PM_SLEEP */
 
@@ -703,9 +696,6 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 	drv->driver.owner = owner;
 	drv->driver.mod_name = mod_name;
 
-	if (drv->pm)
-		drv->driver.pm = &drv->pm->base;
-
 	spin_lock_init(&drv->dynids.lock);
 	INIT_LIST_HEAD(&drv->dynids.list);
 

commit b41d6cf38e27a940d998d989526a9748de1bf028
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sun Aug 17 21:06:59 2008 +0200

    PCI: Check dynids driver_data value for validity
    
    Only accept dynids whose driver_data value matches one of the driver's
    pci_driver_id entries. This prevents the user from accidentally passing
    values the drivers do not expect.
    
    Cc: Milton Miller <miltonm@bga.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 4940a53c56a3..b4cdd690ae71 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -43,18 +43,32 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 {
 	struct pci_dynid *dynid;
 	struct pci_driver *pdrv = to_pci_driver(driver);
+	const struct pci_device_id *ids = pdrv->id_table;
 	__u32 vendor, device, subvendor=PCI_ANY_ID,
 		subdevice=PCI_ANY_ID, class=0, class_mask=0;
 	unsigned long driver_data=0;
 	int fields=0;
-	int retval = 0;
+	int retval;
 
-	fields = sscanf(buf, "%x %x %x %x %x %x %lux",
+	fields = sscanf(buf, "%x %x %x %x %x %x %lx",
 			&vendor, &device, &subvendor, &subdevice,
 			&class, &class_mask, &driver_data);
 	if (fields < 2)
 		return -EINVAL;
 
+	/* Only accept driver_data values that match an existing id_table
+	   entry */
+	retval = -EINVAL;
+	while (ids->vendor || ids->subvendor || ids->class_mask) {
+		if (driver_data == ids->driver_data) {
+			retval = 0;
+			break;
+		}
+		ids++;
+	}
+	if (retval)	/* No match */
+		return retval;
+
 	dynid = kzalloc(sizeof(*dynid), GFP_KERNEL);
 	if (!dynid)
 		return -ENOMEM;

commit edbc25caaa492a82e19baa915f1f6b0a0db6554d
Author: Milton Miller <miltonm@bga.com>
Date:   Thu Jul 10 16:29:37 2008 -0500

    PCI: remove dynids.use_driver_data
    
    The driver flag dynids.use_driver_data is almost consistently not set,
    and causes more problems than it solves.  It was initially intended as a
    flag to indicate whether a driver's usage of driver_data had been
    carefully inspected and was ready for values from userspace.  That audit
    was never done, so most drivers just get a 0 for driver_data when new
    IDs are added from userspace via sysfs.  So remove the flag, allowing
    drivers to see the data directly (a followon patch validates the passed
    driver_data value against what the drivers expect).
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index a13f53486114..4940a53c56a3 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -65,8 +65,7 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 	dynid->id.subdevice = subdevice;
 	dynid->id.class = class;
 	dynid->id.class_mask = class_mask;
-	dynid->id.driver_data = pdrv->dynids.use_driver_data ?
-		driver_data : 0UL;
+	dynid->id.driver_data = driver_data;
 
 	spin_lock(&pdrv->dynids.lock);
 	list_add_tail(&dynid->node, &pdrv->dynids.list);

commit dc7c65db2845a8d17432d89252c4227a9a7cb15f
Merge: 8a0ca91e1db5 58b6e5538460
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 16 17:25:46 2008 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (72 commits)
      Revert "x86/PCI: ACPI based PCI gap calculation"
      PCI: remove unnecessary volatile in PCIe hotplug struct controller
      x86/PCI: ACPI based PCI gap calculation
      PCI: include linux/pm_wakeup.h for device_set_wakeup_capable
      PCI PM: Fix pci_prepare_to_sleep
      x86/PCI: Fix PCI config space for domains > 0
      Fix acpi_pm_device_sleep_wake() by providing a stub for CONFIG_PM_SLEEP=n
      PCI: Simplify PCI device PM code
      PCI PM: Introduce pci_prepare_to_sleep and pci_back_from_sleep
      PCI ACPI: Rework PCI handling of wake-up
      ACPI: Introduce new device wakeup flag 'prepared'
      ACPI: Introduce acpi_device_sleep_wake function
      PCI: rework pci_set_power_state function to call platform first
      PCI: Introduce platform_pci_power_manageable function
      ACPI: Introduce acpi_bus_power_manageable function
      PCI: make pci_name use dev_name
      PCI: handle pci_name() being const
      PCI: add stub for pci_set_consistent_dma_mask()
      PCI: remove unused arch pcibios_update_resource() functions
      PCI: fix pci_setup_device()'s sprinting into a const buffer
      ...
    
    Fixed up conflicts in various files (arch/x86/kernel/setup_64.c,
    arch/x86/pci/irq.c, arch/x86/pci/pci.h, drivers/acpi/sleep/main.c,
    drivers/pci/pci.c, drivers/pci/pci.h, include/acpi/acpi_bus.h) from x86
    and ACPI updates manually.

commit bbb44d9f23d868a2837c6b22b8dfb123d8e7800c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue May 20 00:49:04 2008 +0200

    PCI: implement new suspend/resume callbacks
    
    Implement new suspend and hibernation callbacks for the PCI bus type.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 677fd9d6db12..8eb8a3091dc7 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -274,7 +274,57 @@ static int pci_device_remove(struct device * dev)
 	return 0;
 }
 
-static int pci_device_suspend(struct device * dev, pm_message_t state)
+static void pci_device_shutdown(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct pci_driver *drv = pci_dev->driver;
+
+	if (drv && drv->shutdown)
+		drv->shutdown(pci_dev);
+	pci_msi_shutdown(pci_dev);
+	pci_msix_shutdown(pci_dev);
+}
+
+#ifdef CONFIG_PM_SLEEP
+
+/*
+ * Default "suspend" method for devices that have no driver provided suspend,
+ * or not even a driver at all.
+ */
+static void pci_default_pm_suspend(struct pci_dev *pci_dev)
+{
+	pci_save_state(pci_dev);
+	/*
+	 * mark its power state as "unknown", since we don't know if
+	 * e.g. the BIOS will change its device state when we suspend.
+	 */
+	if (pci_dev->current_state == PCI_D0)
+		pci_dev->current_state = PCI_UNKNOWN;
+}
+
+/*
+ * Default "resume" method for devices that have no driver provided resume,
+ * or not even a driver at all.
+ */
+static int pci_default_pm_resume(struct pci_dev *pci_dev)
+{
+	int retval = 0;
+
+	/* restore the PCI config space */
+	pci_restore_state(pci_dev);
+	/* if the device was enabled before suspend, reenable */
+	retval = pci_reenable_device(pci_dev);
+	/*
+	 * if the device was busmaster before the suspend, make it busmaster
+	 * again
+	 */
+	if (pci_dev->is_busmaster)
+		pci_set_master(pci_dev);
+
+	return retval;
+}
+
+static int pci_legacy_suspend(struct device *dev, pm_message_t state)
 {
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	struct pci_driver * drv = pci_dev->driver;
@@ -284,21 +334,12 @@ static int pci_device_suspend(struct device * dev, pm_message_t state)
 		i = drv->suspend(pci_dev, state);
 		suspend_report_result(drv->suspend, i);
 	} else {
-		pci_save_state(pci_dev);
-		/*
-		 * mark its power state as "unknown", since we don't know if
-		 * e.g. the BIOS will change its device state when we suspend.
-		 */
-		if (pci_dev->current_state == PCI_D0)
-			pci_dev->current_state = PCI_UNKNOWN;
+		pci_default_pm_suspend(pci_dev);
 	}
-
-	pci_fixup_device(pci_fixup_suspend, pci_dev);
-
 	return i;
 }
 
-static int pci_device_suspend_late(struct device * dev, pm_message_t state)
+static int pci_legacy_suspend_late(struct device *dev, pm_message_t state)
 {
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	struct pci_driver * drv = pci_dev->driver;
@@ -311,26 +352,7 @@ static int pci_device_suspend_late(struct device * dev, pm_message_t state)
 	return i;
 }
 
-/*
- * Default resume method for devices that have no driver provided resume,
- * or not even a driver at all.
- */
-static int pci_default_resume(struct pci_dev *pci_dev)
-{
-	int retval = 0;
-
-	/* restore the PCI config space */
-	pci_restore_state(pci_dev);
-	/* if the device was enabled before suspend, reenable */
-	retval = pci_reenable_device(pci_dev);
-	/* if the device was busmaster before the suspend, make it busmaster again */
-	if (pci_dev->is_busmaster)
-		pci_set_master(pci_dev);
-
-	return retval;
-}
-
-static int pci_device_resume(struct device * dev)
+static int pci_legacy_resume(struct device *dev)
 {
 	int error;
 	struct pci_dev * pci_dev = to_pci_dev(dev);
@@ -339,35 +361,313 @@ static int pci_device_resume(struct device * dev)
 	if (drv && drv->resume)
 		error = drv->resume(pci_dev);
 	else
-		error = pci_default_resume(pci_dev);
-	pci_fixup_device(pci_fixup_resume, pci_dev);
+		error = pci_default_pm_resume(pci_dev);
 	return error;
 }
 
-static int pci_device_resume_early(struct device * dev)
+static int pci_legacy_resume_early(struct device *dev)
 {
 	int error = 0;
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	struct pci_driver * drv = pci_dev->driver;
 
-	pci_fixup_device(pci_fixup_resume_early, pci_dev);
-
 	if (drv && drv->resume_early)
 		error = drv->resume_early(pci_dev);
 	return error;
 }
 
-static void pci_device_shutdown(struct device *dev)
+static int pci_pm_prepare(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int error = 0;
+
+	if (drv && drv->pm && drv->pm->prepare)
+		error = drv->pm->prepare(dev);
+
+	return error;
+}
+
+static void pci_pm_complete(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+
+	if (drv && drv->pm && drv->pm->complete)
+		drv->pm->complete(dev);
+}
+
+#ifdef CONFIG_SUSPEND
+
+static int pci_pm_suspend(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct device_driver *drv = dev->driver;
+	int error = 0;
+
+	if (drv && drv->pm) {
+		if (drv->pm->suspend) {
+			error = drv->pm->suspend(dev);
+			suspend_report_result(drv->pm->suspend, error);
+		} else {
+			pci_default_pm_suspend(pci_dev);
+		}
+	} else {
+		error = pci_legacy_suspend(dev, PMSG_SUSPEND);
+	}
+	pci_fixup_device(pci_fixup_suspend, pci_dev);
+
+	return error;
+}
+
+static int pci_pm_suspend_noirq(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct pci_driver *drv = pci_dev->driver;
+	int error = 0;
 
-	if (drv && drv->shutdown)
-		drv->shutdown(pci_dev);
-	pci_msi_shutdown(pci_dev);
-	pci_msix_shutdown(pci_dev);
+	if (drv && drv->pm) {
+		if (drv->pm->suspend_noirq) {
+			error = drv->pm->suspend_noirq(dev);
+			suspend_report_result(drv->pm->suspend_noirq, error);
+		}
+	} else {
+		error = pci_legacy_suspend_late(dev, PMSG_SUSPEND);
+	}
+
+	return error;
+}
+
+static int pci_pm_resume(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct device_driver *drv = dev->driver;
+	int error;
+
+	pci_fixup_device(pci_fixup_resume, pci_dev);
+
+	if (drv && drv->pm) {
+		error = drv->pm->resume ? drv->pm->resume(dev) :
+			pci_default_pm_resume(pci_dev);
+	} else {
+		error = pci_legacy_resume(dev);
+	}
+
+	return error;
+}
+
+static int pci_pm_resume_noirq(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct pci_driver *drv = pci_dev->driver;
+	int error = 0;
+
+	pci_fixup_device(pci_fixup_resume_early, pci_dev);
+
+	if (drv && drv->pm) {
+		if (drv->pm->resume_noirq)
+			error = drv->pm->resume_noirq(dev);
+	} else {
+		error = pci_legacy_resume_early(dev);
+	}
+
+	return error;
+}
+
+#else /* !CONFIG_SUSPEND */
+
+#define pci_pm_suspend		NULL
+#define pci_pm_suspend_noirq	NULL
+#define pci_pm_resume		NULL
+#define pci_pm_resume_noirq	NULL
+
+#endif /* !CONFIG_SUSPEND */
+
+#ifdef CONFIG_HIBERNATION
+
+static int pci_pm_freeze(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct device_driver *drv = dev->driver;
+	int error = 0;
+
+	if (drv && drv->pm) {
+		if (drv->pm->freeze) {
+			error = drv->pm->freeze(dev);
+			suspend_report_result(drv->pm->freeze, error);
+		} else {
+			pci_default_pm_suspend(pci_dev);
+		}
+	} else {
+		error = pci_legacy_suspend(dev, PMSG_FREEZE);
+		pci_fixup_device(pci_fixup_suspend, pci_dev);
+	}
+
+	return error;
+}
+
+static int pci_pm_freeze_noirq(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct pci_driver *drv = pci_dev->driver;
+	int error = 0;
+
+	if (drv && drv->pm) {
+		if (drv->pm->freeze_noirq) {
+			error = drv->pm->freeze_noirq(dev);
+			suspend_report_result(drv->pm->freeze_noirq, error);
+		}
+	} else {
+		error = pci_legacy_suspend_late(dev, PMSG_FREEZE);
+	}
+
+	return error;
+}
+
+static int pci_pm_thaw(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int error = 0;
+
+	if (drv && drv->pm) {
+		if (drv->pm->thaw)
+			error =  drv->pm->thaw(dev);
+	} else {
+		pci_fixup_device(pci_fixup_resume, to_pci_dev(dev));
+		error = pci_legacy_resume(dev);
+	}
+
+	return error;
+}
+
+static int pci_pm_thaw_noirq(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct pci_driver *drv = pci_dev->driver;
+	int error = 0;
+
+	if (drv && drv->pm) {
+		if (drv->pm->thaw_noirq)
+			error = drv->pm->thaw_noirq(dev);
+	} else {
+		pci_fixup_device(pci_fixup_resume_early, pci_dev);
+		error = pci_legacy_resume_early(dev);
+	}
+
+	return error;
+}
+
+static int pci_pm_poweroff(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int error = 0;
+
+	pci_fixup_device(pci_fixup_suspend, to_pci_dev(dev));
+
+	if (drv && drv->pm) {
+		if (drv->pm->poweroff) {
+			error = drv->pm->poweroff(dev);
+			suspend_report_result(drv->pm->poweroff, error);
+		}
+	} else {
+		error = pci_legacy_suspend(dev, PMSG_HIBERNATE);
+	}
+
+	return error;
+}
+
+static int pci_pm_poweroff_noirq(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct pci_driver *drv = pci_dev->driver;
+	int error = 0;
+
+	if (drv && drv->pm) {
+		if (drv->pm->poweroff_noirq) {
+			error = drv->pm->poweroff_noirq(dev);
+			suspend_report_result(drv->pm->poweroff_noirq, error);
+		}
+	} else {
+		error = pci_legacy_suspend_late(dev, PMSG_HIBERNATE);
+	}
+
+	return error;
+}
+
+static int pci_pm_restore(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct device_driver *drv = dev->driver;
+	int error;
+
+	if (drv && drv->pm) {
+		error = drv->pm->restore ? drv->pm->restore(dev) :
+			pci_default_pm_resume(pci_dev);
+	} else {
+		error = pci_legacy_resume(dev);
+	}
+	pci_fixup_device(pci_fixup_resume, pci_dev);
+
+	return error;
+}
+
+static int pci_pm_restore_noirq(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct pci_driver *drv = pci_dev->driver;
+	int error = 0;
+
+	pci_fixup_device(pci_fixup_resume, pci_dev);
+
+	if (drv && drv->pm) {
+		if (drv->pm->restore_noirq)
+			error = drv->pm->restore_noirq(dev);
+	} else {
+		error = pci_legacy_resume_early(dev);
+	}
+	pci_fixup_device(pci_fixup_resume_early, pci_dev);
+
+	return error;
 }
 
+#else /* !CONFIG_HIBERNATION */
+
+#define pci_pm_freeze		NULL
+#define pci_pm_freeze_noirq	NULL
+#define pci_pm_thaw		NULL
+#define pci_pm_thaw_noirq	NULL
+#define pci_pm_poweroff		NULL
+#define pci_pm_poweroff_noirq	NULL
+#define pci_pm_restore		NULL
+#define pci_pm_restore_noirq	NULL
+
+#endif /* !CONFIG_HIBERNATION */
+
+struct pm_ext_ops pci_pm_ops = {
+	.base = {
+		.prepare = pci_pm_prepare,
+		.complete = pci_pm_complete,
+		.suspend = pci_pm_suspend,
+		.resume = pci_pm_resume,
+		.freeze = pci_pm_freeze,
+		.thaw = pci_pm_thaw,
+		.poweroff = pci_pm_poweroff,
+		.restore = pci_pm_restore,
+	},
+	.suspend_noirq = pci_pm_suspend_noirq,
+	.resume_noirq = pci_pm_resume_noirq,
+	.freeze_noirq = pci_pm_freeze_noirq,
+	.thaw_noirq = pci_pm_thaw_noirq,
+	.poweroff_noirq = pci_pm_poweroff_noirq,
+	.restore_noirq = pci_pm_restore_noirq,
+};
+
+#define PCI_PM_OPS_PTR	&pci_pm_ops
+
+#else /* !CONFIG_PM_SLEEP */
+
+#define PCI_PM_OPS_PTR	NULL
+
+#endif /* !CONFIG_PM_SLEEP */
+
 /**
  * __pci_register_driver - register a new pci driver
  * @drv: the driver structure to register
@@ -390,6 +690,9 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 	drv->driver.owner = owner;
 	drv->driver.mod_name = mod_name;
 
+	if (drv->pm)
+		drv->driver.pm = &drv->pm->base;
+
 	spin_lock_init(&drv->dynids.lock);
 	INIT_LIST_HEAD(&drv->dynids.list);
 
@@ -515,12 +818,9 @@ struct bus_type pci_bus_type = {
 	.uevent		= pci_uevent,
 	.probe		= pci_device_probe,
 	.remove		= pci_device_remove,
-	.suspend	= pci_device_suspend,
-	.suspend_late	= pci_device_suspend_late,
-	.resume_early	= pci_device_resume_early,
-	.resume		= pci_device_resume,
 	.shutdown	= pci_device_shutdown,
 	.dev_attrs	= pci_dev_attrs,
+	.pm		= PCI_PM_OPS_PTR,
 };
 
 static int __init pci_driver_init(void)

commit e1a2a51e684bfe9d6165992d4a065439617a3107
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu May 15 21:51:31 2008 +0200

    Suspend/Resume bug in PCI layer wrt quirks
    
    Some quirks should be called with interrupt disabled, we can't directly
    call them in .resume_early. Also the patch introduces
    pci_fixup_resume_early and pci_fixup_suspend, which matches current
    device core callbacks (.suspend/.resume_early).
    
    TBD: Somebody knows why we need quirk resume should double check if a
    quirk should be called in resume or resume_early. I changed some per my
    understanding, but can't make sure I fixed all.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 72cf61ed8f96..677fd9d6db12 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -292,6 +292,9 @@ static int pci_device_suspend(struct device * dev, pm_message_t state)
 		if (pci_dev->current_state == PCI_D0)
 			pci_dev->current_state = PCI_UNKNOWN;
 	}
+
+	pci_fixup_device(pci_fixup_suspend, pci_dev);
+
 	return i;
 }
 
@@ -337,6 +340,7 @@ static int pci_device_resume(struct device * dev)
 		error = drv->resume(pci_dev);
 	else
 		error = pci_default_resume(pci_dev);
+	pci_fixup_device(pci_fixup_resume, pci_dev);
 	return error;
 }
 
@@ -346,7 +350,7 @@ static int pci_device_resume_early(struct device * dev)
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	struct pci_driver * drv = pci_dev->driver;
 
-	pci_fixup_device(pci_fixup_resume, pci_dev);
+	pci_fixup_device(pci_fixup_resume_early, pci_dev);
 
 	if (drv && drv->resume_early)
 		error = drv->resume_early(pci_dev);

commit 4efeb4dd3c0bf534e431a8e7c72d0afbd4cd24aa
Author: Yinghai Lu <Yinghai.Lu@Sun.COM>
Date:   Mon May 12 21:21:05 2008 +0200

    PCI: use dev_to_node in pci_call_probe
    
    to make sure get one online node.
    
    Signed-off-by: Yinghai Lu <yinghai.lu@sun.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 72cf61ed8f96..e1637bd82b8e 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -181,7 +181,7 @@ static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
 	   any need to change it. */
 	struct mempolicy *oldpol;
 	cpumask_t oldmask = current->cpus_allowed;
-	int node = pcibus_to_node(dev->bus);
+	int node = dev_to_node(&dev->dev);
 
 	if (node >= 0) {
 		node_to_cpumask_ptr(nodecpumask, node);

commit d52877c7b1afb8c37ebe17e2005040b79cb618b0
Author: Yinghai Lu <yhlu.kernel.send@gmail.com>
Date:   Wed Apr 23 14:58:09 2008 -0700

    pci/irq: let pci_device_shutdown to call pci_msi_shutdown v2
    
    [PATCH 2/2] pci/irq: let pci_device_shutdown to call pci_msi_shutdown v2
    
    this change
    
    | commit 23a274c8a5adafc74a66f16988776fc7dd6f6e51
    | Author: Prakash, Sathya <sathya.prakash@lsi.com>
    | Date:   Fri Mar 7 15:53:21 2008 +0530
    |
    |     [SCSI] mpt fusion: Enable MSI by default for SAS controllers
    |
    |     This patch modifies the driver to enable MSI by default for all SAS chips.
    |
    |     Signed-off-by: Sathya Prakash <sathya.prakash@lsi.com>
    |     Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    |
    Causes the kexec of a RHEL 5.1 kernel to fail.
    
    root casue: the rhel 5.1 kernel still uses INTx emulation.  and
    mptscsih_shutdown doesn't call pci_disable_msi to reenable INTx on kexec path
    
    So call pci_msi_shutdown in the shutdown path to do the same thing to msix
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Jesse Barnes <jbarnes@hobbes.lan>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index e8d94fafc280..72cf61ed8f96 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -360,6 +360,8 @@ static void pci_device_shutdown(struct device *dev)
 
 	if (drv && drv->shutdown)
 		drv->shutdown(pci_dev);
+	pci_msi_shutdown(pci_dev);
+	pci_msix_shutdown(pci_dev);
 }
 
 /**

commit f70316dace2bb99730800d47044acb818c6735f6
Author: Mike Travis <travis@sgi.com>
Date:   Fri Apr 4 18:11:06 2008 -0700

    generic: use new set_cpus_allowed_ptr function
    
      * Use new set_cpus_allowed_ptr() function added by previous patch,
        which instead of passing the "newly allowed cpus" cpumask_t arg
        by value,  pass it by pointer:
    
        -int set_cpus_allowed(struct task_struct *p, cpumask_t new_mask)
        +int set_cpus_allowed_ptr(struct task_struct *p, const cpumask_t *new_mask)
    
      * Modify CPU_MASK_ALL
    
    Depends on:
            [sched-devel]: sched: add new set_cpus_allowed_ptr function
    
    Signed-off-by: Mike Travis <travis@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index e571c72e6753..e8d94fafc280 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -182,15 +182,18 @@ static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
 	struct mempolicy *oldpol;
 	cpumask_t oldmask = current->cpus_allowed;
 	int node = pcibus_to_node(dev->bus);
-	if (node >= 0 && node_online(node))
-	    set_cpus_allowed(current, node_to_cpumask(node));
+
+	if (node >= 0) {
+		node_to_cpumask_ptr(nodecpumask, node);
+		set_cpus_allowed_ptr(current, nodecpumask);
+	}
 	/* And set default memory allocation policy */
 	oldpol = current->mempolicy;
 	current->mempolicy = NULL;	/* fall back to system default policy */
 #endif
 	error = drv->probe(dev, id);
 #ifdef CONFIG_NUMA
-	set_cpus_allowed(current, oldmask);
+	set_cpus_allowed_ptr(current, &oldmask);
 	current->mempolicy = oldpol;
 #endif
 	return error;

commit 74e27e44b0407fb1f6e8d1f7b7818f108463c4b8
Author: Lee Schermerhorn <Lee.Schermerhorn@hp.com>
Date:   Wed Nov 21 15:07:05 2007 -0800

    PCI: Mem Policy: fix mempolicy usage in pci driver
    
    In an attempt to ensure memory allocation from the local node, the pci
    driver temporarily replaces the current task's memory policy with the
    system default policy.  Trying to be a good citizen, the driver then call's
    mpol_get() on the new policy.  When it's finished probing, it undoes the
    '_get by calling mpol_free() [on the system default policy] and then
    restores the current task's saved mempolicy.
    
    A couple of issues here:
    
    1) it's never necessary to set a task's mempolicy to the
       system default policy in order to get system default
       allocation behavior.  Simply set the current task's
       mempolicy to NULL and allocations will fall back to
       system default policy.
    
    2) we should never [need to] call mpol_free() on the system
       default policy.  [I plan on trapping this with a VM_BUG_ON()
       in a subsequent patch.]
    
    This patch removes the calls to mpol_get() and mpol_free()
    and uses NULL for the temporary task mempolicy to effect
    default allocation behavior.
    
    Signed-off-by: Lee Schermerhorn <lee.schermerhorn@hp.com>
    Acked-by: Christoph Lameter <clameter@sgi.com>
    Acked-by: Mel Gorman <mel@csn.ul.ie>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index c4fa35d1dd77..e571c72e6753 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -186,13 +186,11 @@ static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
 	    set_cpus_allowed(current, node_to_cpumask(node));
 	/* And set default memory allocation policy */
 	oldpol = current->mempolicy;
-	current->mempolicy = &default_policy;
-	mpol_get(current->mempolicy);
+	current->mempolicy = NULL;	/* fall back to system default policy */
 #endif
 	error = drv->probe(dev, id);
 #ifdef CONFIG_NUMA
 	set_cpus_allowed(current, oldmask);
-	mpol_free(current->mempolicy);
 	current->mempolicy = oldpol;
 #endif
 	return error;

commit 2b937303188807b498d1a3163f60305f0941538e
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 28 12:23:18 2007 -0800

    PCI: remove foolish code from pci-driver.c
    
    The PCI bus should not be trying to declare its own attribute type.
    Especially as this code could never ever be called because the driver
    core overwrites the driver kobject type to be its own internal type.
    Delete all of this code as it was never being used and is not correct.
    
    Also update my copyright on the file while I'm touching things there.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 73e362992694..c4fa35d1dd77 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -1,6 +1,11 @@
 /*
  * drivers/pci/pci-driver.c
  *
+ * (C) Copyright 2002-2004, 2007 Greg Kroah-Hartman <greg@kroah.com>
+ * (C) Copyright 2007 Novell Inc.
+ *
+ * Released under the GPL v2 only.
+ *
  */
 
 #include <linux/pci.h>
@@ -356,50 +361,6 @@ static void pci_device_shutdown(struct device *dev)
 		drv->shutdown(pci_dev);
 }
 
-#define kobj_to_pci_driver(obj) container_of(obj, struct device_driver, kobj)
-#define attr_to_driver_attribute(obj) container_of(obj, struct driver_attribute, attr)
-
-static ssize_t
-pci_driver_attr_show(struct kobject * kobj, struct attribute *attr, char *buf)
-{
-	struct device_driver *driver = kobj_to_pci_driver(kobj);
-	struct driver_attribute *dattr = attr_to_driver_attribute(attr);
-	ssize_t ret;
-
-	if (!get_driver(driver))
-		return -ENODEV;
-
-	ret = dattr->show ? dattr->show(driver, buf) : -EIO;
-
-	put_driver(driver);
-	return ret;
-}
-
-static ssize_t
-pci_driver_attr_store(struct kobject * kobj, struct attribute *attr,
-		      const char *buf, size_t count)
-{
-	struct device_driver *driver = kobj_to_pci_driver(kobj);
-	struct driver_attribute *dattr = attr_to_driver_attribute(attr);
-	ssize_t ret;
-
-	if (!get_driver(driver))
-		return -ENODEV;
-
-	ret = dattr->store ? dattr->store(driver, buf, count) : -EIO;
-
-	put_driver(driver);
-	return ret;
-}
-
-static struct sysfs_ops pci_driver_sysfs_ops = {
-	.show = pci_driver_attr_show,
-	.store = pci_driver_attr_store,
-};
-static struct kobj_type pci_driver_kobj_type = {
-	.sysfs_ops = &pci_driver_sysfs_ops,
-};
-
 /**
  * __pci_register_driver - register a new pci driver
  * @drv: the driver structure to register
@@ -421,7 +382,6 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 	drv->driver.bus = &pci_bus_type;
 	drv->driver.owner = owner;
 	drv->driver.mod_name = mod_name;
-	drv->driver.kobj.ktype = &pci_driver_kobj_type;
 
 	spin_lock_init(&drv->dynids.lock);
 	INIT_LIST_HEAD(&drv->dynids.list);

commit 03d43b19b9f56c1d18bc8f2f7890534fbe6a285d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 28 12:23:18 2007 -0800

    PCI: use proper call to driver_create_file
    
    Don't try to call the "raw" sysfs_create_file when we already have a
    helper function to do this kind of work for us.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 6d1a21611818..73e362992694 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -96,17 +96,21 @@ pci_create_newid_file(struct pci_driver *drv)
 {
 	int error = 0;
 	if (drv->probe != NULL)
-		error = sysfs_create_file(&drv->driver.kobj,
-					  &driver_attr_new_id.attr);
+		error = driver_create_file(&drv->driver, &driver_attr_new_id);
 	return error;
 }
 
+static void pci_remove_newid_file(struct pci_driver *drv)
+{
+	driver_remove_file(&drv->driver, &driver_attr_new_id);
+}
 #else /* !CONFIG_HOTPLUG */
 static inline void pci_free_dynids(struct pci_driver *drv) {}
 static inline int pci_create_newid_file(struct pci_driver *drv)
 {
 	return 0;
 }
+static inline void pci_remove_newid_file(struct pci_driver *drv) {}
 #endif
 
 /**
@@ -447,6 +451,7 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 void
 pci_unregister_driver(struct pci_driver *drv)
 {
+	pci_remove_newid_file(drv);
 	driver_unregister(&drv->driver);
 	pci_free_dynids(drv);
 }

commit d73460d79bc88de74221d73723ed61a0081b7a36
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Oct 24 18:27:18 2007 +0200

    PCI: make pci_match_device() static
    
    pci_match_device() no longer has any other users.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 6e2760b6c20a..6d1a21611818 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -143,8 +143,8 @@ const struct pci_device_id *pci_match_id(const struct pci_device_id *ids,
  * system is in its list of supported devices.  Returns the matching
  * pci_device_id structure or %NULL if there is no match.
  */
-const struct pci_device_id *pci_match_device(struct pci_driver *drv,
-					     struct pci_dev *dev)
+static const struct pci_device_id *pci_match_device(struct pci_driver *drv,
+						    struct pci_dev *dev)
 {
 	struct pci_dynid *dynid;
 
@@ -559,7 +559,6 @@ static int __init pci_driver_init(void)
 postcore_initcall(pci_driver_init);
 
 EXPORT_SYMBOL(pci_match_id);
-EXPORT_SYMBOL(pci_match_device);
 EXPORT_SYMBOL(__pci_register_driver);
 EXPORT_SYMBOL(pci_unregister_driver);
 EXPORT_SYMBOL(pci_dev_driver);

commit 6a84258e5f5bb8b9bd72e06a5837fa6fdacaf5c5
Merge: efefc6eb38d4 f3e6f164c238
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Fri Oct 12 15:50:23 2007 -0700

    Merge master.kernel.org:/pub/scm/linux/kernel/git/gregkh/pci-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/gregkh/pci-2.6: (37 commits)
      PCI: merge almost all of pci_32.h and pci_64.h together
      PCI: X86: Introduce and enable PCI domain support
      PCI: Add 'nodomains' boot option, and pci_domains_supported global
      PCI: modify PCI bridge control ISA flag for clarity
      PCI: use _CRS for PCI resource allocation
      PCI: avoid P2P prefetch window for expansion ROMs
      PCI: skip ISA ioresource alignment on some systems
      PCI: remove transparent bridge sizing
      pci: write file size to inode on proc bus file write
      pci: use size stored in proc_dir_entry for proc bus files
      pci: implement "pci=noaer"
      PCI: fix IDE legacy mode resources
      MSI: Use correct data offset for 32-bit MSI in read_msi_msg()
      PCI: Fix incorrect argument order to list_add_tail() in PCI dynamic ID code
      PCI: i386: Compaq EVO N800c needs PCI bus renumbering
      PCI: Remove no longer correct documentation regarding MSI vector assignment
      PCI: re-enable onboard sound on "MSI K8T Neo2-FIR"
      PCI: quirk_vt82c586_acpi: Omit reading PCI revision ID
      PCI: quirk amd_8131_mmrbc: Omit reading pci revision ID
      cpqphp: Use PCI_CLASS_REVISION instead of PCI_REVISION_ID for read
      ...

commit a56bc69a182f501582557af7fad5bc882b1c856c
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Fri Sep 14 15:33:13 2007 +1000

    PCI: Fix incorrect argument order to list_add_tail() in PCI dynamic ID code
    
    The code for dynamically assigning new ids to PCI drivers,
    store_new_id(), calls list_add_tail() with the list head and new node
    arguments in reversed order.
    
    The result is that every new id written essentially overwrites the
    previous list of ids.
    
    Caught with the help of Rusty's "horribly bad" list_node patch:
     http://lkml.org/lkml/2007/6/10/10
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 004bc2487270..c43ecedce673 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -54,7 +54,6 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 	if (!dynid)
 		return -ENOMEM;
 
-	INIT_LIST_HEAD(&dynid->node);
 	dynid->id.vendor = vendor;
 	dynid->id.device = device;
 	dynid->id.subvendor = subvendor;
@@ -65,7 +64,7 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 		driver_data : 0UL;
 
 	spin_lock(&pdrv->dynids.lock);
-	list_add_tail(&pdrv->dynids.list, &dynid->node);
+	list_add_tail(&dynid->node, &pdrv->dynids.list);
 	spin_unlock(&pdrv->dynids.lock);
 
 	if (get_driver(&pdrv->driver)) {

commit 7eff2e7a8b65c25920207324e56611150eb1cd9a
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Aug 14 15:15:12 2007 +0200

    Driver core: change add_uevent_var to use a struct
    
    This changes the uevent buffer functions to use a struct instead of a
    long list of parameters. It does no longer require the caller to do the
    proper buffer termination and size accounting, which is currently wrong
    in some places. It fixes a known bug where parts of the uevent
    environment are overwritten because of wrong index calculations.
    
    Many thanks to Mathieu Desnoyers for finding bugs and improving the
    error handling.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 004bc2487270..f61be3abfdca 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -532,8 +532,7 @@ void pci_dev_put(struct pci_dev *dev)
 }
 
 #ifndef CONFIG_HOTPLUG
-int pci_uevent(struct device *dev, char **envp, int num_envp,
-	       char *buffer, int buffer_size)
+int pci_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	return -ENODEV;
 }

commit 0b62e13b5c9b4871641973e024cc9dd440b5bb58
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Jul 27 14:43:35 2007 +0900

    pci: rename __pci_reenable_device() to pci_reenable_device()
    
    Rename __pci_reenable_device() to pci_reenable_device().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 8e58ea3d95c0..004bc2487270 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -310,7 +310,7 @@ static int pci_default_resume(struct pci_dev *pci_dev)
 	/* restore the PCI config space */
 	pci_restore_state(pci_dev);
 	/* if the device was enabled before suspend, reenable */
-	retval = __pci_reenable_device(pci_dev);
+	retval = pci_reenable_device(pci_dev);
 	/* if the device was busmaster before the suspend, make it busmaster again */
 	if (pci_dev->is_busmaster)
 		pci_set_master(pci_dev);

commit 8b60756a628a73bc8bf8b59d8716cb3f09b7e7eb
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Wed May 9 07:19:14 2007 +0200

    Fix more "deprecated" spellos.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 3bb7739d26a5..8e58ea3d95c0 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -119,7 +119,7 @@ static inline int pci_create_newid_file(struct pci_driver *drv)
  * system is in its list of supported devices.  Returns the matching
  * pci_device_id structure or %NULL if there is no match.
  *
- * Depreciated, don't use this as it will not catch any dynamic ids
+ * Deprecated, don't use this as it will not catch any dynamic ids
  * that a driver might want to check for.
  */
 const struct pci_device_id *pci_match_id(const struct pci_device_id *ids,

commit 5adc55da4a7758021bcc374904b0f8b076508a11
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Mar 27 03:02:51 2007 +0200

    PCI: remove the broken PCI_MULTITHREAD_PROBE option
    
    This patch removes the PCI_MULTITHREAD_PROBE option that had already
    been marked as broken.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 07fdb3cd6172..3bb7739d26a5 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -13,20 +13,6 @@
 #include <linux/sched.h>
 #include "pci.h"
 
-/*
- *  Registration of PCI drivers and handling of hot-pluggable devices.
- */
-
-/* multithreaded probe logic */
-static int pci_multithread_probe =
-#ifdef CONFIG_PCI_MULTITHREAD_PROBE
-	1;
-#else
-	0;
-#endif
-__module_param_call("", pci_multithread_probe, param_set_bool, param_get_bool, &pci_multithread_probe, 0644);
-
-
 /*
  * Dynamic device IDs are disabled for !CONFIG_HOTPLUG
  */
@@ -569,7 +555,6 @@ struct bus_type pci_bus_type = {
 
 static int __init pci_driver_init(void)
 {
-	pci_bus_type.multithread_probe = pci_multithread_probe;
 	return bus_register(&pci_bus_type);
 }
 

commit 6ba186361ed2cda7e174856a3ab8a8e3237b3c3d
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sat Apr 7 17:21:28 2007 +0200

    PCI: Require vendor and device for new_id
    
    Currently, there is no minimum number of fields required when adding
    a new device ID to a PCI driver through the new_id sysfs file. It is
    possible to add a new ID with only the vendor ID set, causing the
    driver to attempt to attach to all PCI devices from that vendor. This
    has been reported to happen accidentally:
      http://lists.lm-sensors.org/pipermail/lm-sensors/2007-March/019366.html
    It is even possible to not even set the vendor ID field, causing the
    driver to attempt to attach to _all_ the PCI devices.
    
    This sounds dangerous and I fail to see any valid use of this
    "feature". Thus I suggest that we now require at least the first two
    fields (vendor ID and device ID) to be set. For what it's worth, this
    is what the USB subsystem does.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 39e80fcef4b3..07fdb3cd6172 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -52,7 +52,7 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 {
 	struct pci_dynid *dynid;
 	struct pci_driver *pdrv = to_pci_driver(driver);
-	__u32 vendor=PCI_ANY_ID, device=PCI_ANY_ID, subvendor=PCI_ANY_ID,
+	__u32 vendor, device, subvendor=PCI_ANY_ID,
 		subdevice=PCI_ANY_ID, class=0, class_mask=0;
 	unsigned long driver_data=0;
 	int fields=0;
@@ -61,7 +61,7 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 	fields = sscanf(buf, "%x %x %x %x %x %x %lux",
 			&vendor, &device, &subvendor, &subdevice,
 			&class, &class_mask, &driver_data);
-	if (fields < 0)
+	if (fields < 2)
 		return -EINVAL;
 
 	dynid = kzalloc(sizeof(*dynid), GFP_KERNEL);

commit 21c7f30b1d3f8a3de3128478daca3ce203fc8733
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Mon Feb 5 16:15:25 2007 -0800

    driver core: per-subsystem multithreaded probing
    
    Make multithreaded probing work per subsystem instead of per driver.
    
    It doesn't make much sense to probe the same device for multiple drivers in
    parallel (after all, only one driver can bind to the device).  Instead, create
    a probing thread for each device that probes the drivers one after another.
    Also make the decision to use multi-threaded probe per bus instead of per
    device and adapt the pci code.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index a3c1755b2f28..39e80fcef4b3 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -434,11 +434,6 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 	drv->driver.mod_name = mod_name;
 	drv->driver.kobj.ktype = &pci_driver_kobj_type;
 
-	if (pci_multithread_probe)
-		drv->driver.multithread_probe = pci_multithread_probe;
-	else
-		drv->driver.multithread_probe = drv->multithread_probe;
-
 	spin_lock_init(&drv->dynids.lock);
 	INIT_LIST_HEAD(&drv->dynids.list);
 
@@ -574,6 +569,7 @@ struct bus_type pci_bus_type = {
 
 static int __init pci_driver_init(void)
 {
+	pci_bus_type.multithread_probe = pci_multithread_probe;
 	return bus_register(&pci_bus_type);
 }
 

commit f95d882d81ee731be2a4a3b34f86810e29b68836
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Sat Feb 10 14:41:56 2007 -0800

    PCI/sysfs/kobject kernel-doc fixes
    
    Fix kernel-doc warnings in PCI, sysfs, and kobject files.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 4438ae1ede4f..a3c1755b2f28 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -415,6 +415,7 @@ static struct kobj_type pci_driver_kobj_type = {
  * __pci_register_driver - register a new pci driver
  * @drv: the driver structure to register
  * @owner: owner module of drv
+ * @mod_name: module name string
  * 
  * Adds the driver structure to the list of registered drivers.
  * Returns a negative value on error, otherwise 0. 

commit 78149df6d565c36675463352d0bfe0000b02b7a7
Merge: c96e2c92072d 14719f325e1c
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Wed Feb 7 19:23:44 2007 -0800

    Merge master.kernel.org:/pub/scm/linux/kernel/git/gregkh/pci-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/gregkh/pci-2.6: (41 commits)
      Revert "PCI: remove duplicate device id from ata_piix"
      msi: Make MSI useable more architectures
      msi: Kill the msi_desc array.
      msi: Remove attach_msi_entry.
      msi: Fix msi_remove_pci_irq_vectors.
      msi: Remove msi_lock.
      msi: Kill msi_lookup_irq
      MSI: Combine pci_(save|restore)_msi/msix_state
      MSI: Remove pci_scan_msi_device()
      MSI: Replace pci_msi_quirk with calls to pci_no_msi()
      PCI: remove duplicate device id from ipr
      PCI: remove duplicate device id from ata_piix
      PCI: power management: remove noise on non-manageable hw
      PCI: cleanup MSI code
      PCI: make isa_bridge Alpha-only
      PCI: remove quirk_sis_96x_compatible()
      PCI: Speed up the Intel SMBus unhiding quirk
      PCI Quirk: 1k I/O space IOBL_ADR fix on P64H2
      shpchp: delete trailing whitespace
      shpchp: remove DBG_XXX_ROUTINE
      ...

commit 38cc13022ed3cea949722d5a6f49025da82c9fd0
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Mon Dec 18 10:30:00 2006 +0900

    PCI : add extremely specialized __pci_reenable_device for default resume
    
    Original patch was posted as "PCI : Move pci_fixup_device and is_enabled".
    This 3 of 3 patches does:
    
      - add __pci_reenable_device
        (recover former change of 1st patch)
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Cc: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 1ec546d3d53c..dd2da9b6b119 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -324,8 +324,7 @@ static int pci_default_resume(struct pci_dev *pci_dev)
 	/* restore the PCI config space */
 	pci_restore_state(pci_dev);
 	/* if the device was enabled before suspend, reenable */
-	if (atomic_read(&pci_dev->enable_cnt))
-		retval = pci_enable_device(pci_dev);
+	retval = __pci_reenable_device(pci_dev);
 	/* if the device was busmaster before the suspend, make it busmaster again */
 	if (pci_dev->is_busmaster)
 		pci_set_master(pci_dev);

commit 924b08f3ff12eb0e8ecd9e9a9b6a5b884a495c23
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Mon Dec 18 10:27:45 2006 +0900

    PCI : remove too specialized __pci_enable_device for default resume
    
    Original patch was posted as "PCI : Move pci_fixup_device and is_enabled".
    This 1 of 3 patches does:
    
      - reverts small part of Inaky's patch
        (remove __pci_enable_device)
        This change will be recovered by 3rd patch.
    
      - temporarily remove pci_fixup_device.
        This change will be recovered by 2nd patch.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Cc: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 92d5e8db0de7..1ec546d3d53c 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -325,7 +325,7 @@ static int pci_default_resume(struct pci_dev *pci_dev)
 	pci_restore_state(pci_dev);
 	/* if the device was enabled before suspend, reenable */
 	if (atomic_read(&pci_dev->enable_cnt))
-		retval = __pci_enable_device(pci_dev);
+		retval = pci_enable_device(pci_dev);
 	/* if the device was busmaster before the suspend, make it busmaster again */
 	if (pci_dev->is_busmaster)
 		pci_set_master(pci_dev);

commit 725522b5453dd680412f2b6463a988e4fd148757
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jan 15 11:50:02 2007 -0800

    PCI: add the sysfs driver name to all modules
    
    This adds the module name to all PCI drivers, if they are built into the
    kernel or not.  It will show up in /sys/modules/MODULE_NAME/drivers/
    
    It also fixes up the IDE core, which was calling __pci_register_driver()
    directly.
    
    Cc: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 92d5e8db0de7..358766885260 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -422,7 +422,8 @@ static struct kobj_type pci_driver_kobj_type = {
  * If no error occurred, the driver remains registered even if 
  * no device was claimed during registration.
  */
-int __pci_register_driver(struct pci_driver *drv, struct module *owner)
+int __pci_register_driver(struct pci_driver *drv, struct module *owner,
+			  const char *mod_name)
 {
 	int error;
 
@@ -430,6 +431,7 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner)
 	drv->driver.name = drv->name;
 	drv->driver.bus = &pci_bus_type;
 	drv->driver.owner = owner;
+	drv->driver.mod_name = mod_name;
 	drv->driver.kobj.ktype = &pci_driver_kobj_type;
 
 	if (pci_multithread_probe)

commit ae9608af9e300395ec032479621f32688c121141
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue Jan 9 21:41:01 2007 -0800

    PCI: fix pci-driver kernel-doc
    
    Function short description should be on only one line.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index b8d2385e29bc..92d5e8db0de7 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -150,8 +150,7 @@ const struct pci_device_id *pci_match_id(const struct pci_device_id *ids,
 }
 
 /**
- * pci_match_device - Tell if a PCI device structure has a matching
- *                    PCI device id structure
+ * pci_match_device - Tell if a PCI device structure has a matching PCI device id structure
  * @drv: the PCI driver to match against
  * @dev: the PCI device structure to match against
  *

commit 1597cacbe39802d86656d1f2e6329895bd2ef531
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Dec 4 15:14:45 2006 -0800

    PCI: Fix multiple problems with VIA hardware
    
    This patch is designed to fix:
    - Disk eating corruptor on KT7 after resume from RAM
    - VIA IRQ handling
    - VIA fixups for bus lockups after resume from RAM
    
    The core of this is to add a table of resume fixups run at resume time.
    We need to do this for a variety of boards and features, but particularly
    we need to do this to get various critical VIA fixups done on resume.
    
    The second part of the problem is to handle VIA IRQ number rules which
    are a bit odd and need special handling for PIC interrupts. Various
    patches broke various boxes and while this one may not be perfect
    (hopefully it is) it ensures the workaround is applied to the right
    devices only.
    
    From: Jean Delvare <khali@linux-fr.org>
    
    Now that PCI quirks are replayed on software resume, we can safely
    re-enable the Asus SMBus unhiding quirk even when software suspend support
    is enabled.
    
    [akpm@osdl.org: fix const warning]
    Signed-off-by: Alan Cox <alan@redhat.com>
    Cc: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index de5b9011d038..b8d2385e29bc 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -353,6 +353,8 @@ static int pci_device_resume_early(struct device * dev)
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	struct pci_driver * drv = pci_dev->driver;
 
+	pci_fixup_device(pci_fixup_resume, pci_dev);
+
 	if (drv && drv->resume_early)
 		error = drv->resume_early(pci_dev);
 	return error;

commit 7461b60afa62b26943e97861d87b9f9a32d7fd9c
Author: Russell King <rmk+lkml@arm.linux.org.uk>
Date:   Wed Nov 29 21:18:04 2006 +0000

    PCI: use /sys/bus/pci/drivers/<driver>/new_id first
    
    Unfortunately, the .../new_id feature does not work with the 8250_pci
    driver.
    
    The reason for this comes down to the way .../new_id is implemented.
    When PCI tries to match a driver to a device, it checks the modules
    static device ID tables _before_ checking the dynamic new_id tables.
    
    When a driver is capable of matching by ID, and falls back to matching
    by class (as 8250_pci does), this makes it absolutely impossible to
    specify a board by ID, and as such the correct driver_data value to
    use with it.
    
    Let's say you have a serial board with vendor 0x1234 and device 0x5678.
    It's class is set to PCI_CLASS_COMMUNICATION_SERIAL.
    
    On boot, this card is matched to the 8250_pci driver, which tries to
    probe it because it matched using the class entry.  The driver finds
    that it is unable to automatically detect the correct settings to use,
    so it returns -ENODEV.
    
    You know that the information the driver needs is to match this card
    using a device_data value of '7'.  So you echo 1234 5678 0 0 0 0 7
    into new_id.
    
    The kernel attempts to re-bind 8250_pci to this device.  However,
    because it scans the PCI driver tables, it _again_ matches the class
    entry which has the wrong device_data.  It fails.
    
    End of story.  You can't support the card without rebuilding the
    kernel (or writing a specific PCI probe module to support it.)
    
    So, can we make new_id override the driver-internal PCI ID tables?
    IOW, like this:
    
    
    From: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index e5ae3a0c13bb..de5b9011d038 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -162,14 +162,9 @@ const struct pci_device_id *pci_match_id(const struct pci_device_id *ids,
 const struct pci_device_id *pci_match_device(struct pci_driver *drv,
 					     struct pci_dev *dev)
 {
-	const struct pci_device_id *id;
 	struct pci_dynid *dynid;
 
-	id = pci_match_id(drv->id_table, dev);
-	if (id)
-		return id;
-
-	/* static ids didn't match, lets look at the dynamic ones */
+	/* Look at the dynamic ids first, before the static ones */
 	spin_lock(&drv->dynids.lock);
 	list_for_each_entry(dynid, &drv->dynids.list, node) {
 		if (pci_match_one_device(&dynid->id, dev)) {
@@ -178,7 +173,8 @@ const struct pci_device_id *pci_match_device(struct pci_driver *drv,
 		}
 	}
 	spin_unlock(&drv->dynids.lock);
-	return NULL;
+
+	return pci_match_id(drv->id_table, dev);
 }
 
 static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,

commit bae94d02371c402408a4edfb95e71e88dbd3e973
Author: Inaky Perez-Gonzalez <inaky@linux.intel.com>
Date:   Wed Nov 22 12:40:31 2006 -0800

    PCI: switch pci_{enable,disable}_device() to be nestable
    
    Changes the pci_{enable,disable}_device() functions to work in a
    nested basis, so that eg, three calls to enable_device() require three
    calls to disable_device().
    
    The reason for this is to simplify PCI drivers for
    multi-interface/capability devices. These are devices that cram more
    than one interface in a single function. A relevant example of that is
    the Wireless [USB] Host Controller Interface (similar to EHCI) [see
    http://www.intel.com/technology/comms/wusb/whci.htm].
    
    In these kind of devices, multiple interfaces are accessed through a
    single bar and IRQ line. For that, the drivers map only the smallest
    area of the bar to access their register banks and use shared IRQ
    handlers.
    
    However, because the order at which those drivers load cannot be known
    ahead of time, the sequence in which the calls to pci_enable_device()
    and pci_disable_device() cannot be predicted. Thus:
    
    1. driverA     starts     pci_enable_device()
    2. driverB     starts     pci_enable_device()
    3. driverA     shutdown   pci_disable_device()
    4. driverB     shutdown   pci_disable_device()
    
    between steps 3 and 4, driver B would loose access to it's device,
    even if it didn't intend to.
    
    By using this modification, the device won't be disabled until all the
    callers to enable() have called disable().
    
    This is implemented by replacing 'struct pci_dev->is_enabled' from a
    bitfield to an atomic use count. Each caller to enable increments it,
    each caller to disable decrements it. When the count increments from 0
    to 1, __pci_enable_device() is called to actually enable the
    device. When it drops to zero, pci_disable_device() actually does the
    disabling.
    
    We keep the backend __pci_enable_device() for pci_default_resume() to
    use and also change the sysfs method implementation, so that userspace
    enabling/disabling the device doesn't disable it one time too much.
    
    Signed-off-by: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 84ec9c8f6703..e5ae3a0c13bb 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -329,8 +329,8 @@ static int pci_default_resume(struct pci_dev *pci_dev)
 	/* restore the PCI config space */
 	pci_restore_state(pci_dev);
 	/* if the device was enabled before suspend, reenable */
-	if (pci_dev->is_enabled)
-		retval = pci_enable_device(pci_dev);
+	if (atomic_read(&pci_dev->enable_cnt))
+		retval = __pci_enable_device(pci_dev);
 	/* if the device was busmaster before the suspend, make it busmaster again */
 	if (pci_dev->is_busmaster)
 		pci_set_master(pci_dev);

commit 50bf14b3ff05fb6e10688021b96f95d30a300f8d
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Wed Nov 8 19:53:59 2006 -0800

    pci: fix __pci_register_driver error handling
    
    __pci_register_driver() error path forgot to unwind.
    driver_unregister() needs to be called when pci_create_newid_file() failed.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 194f1d21d3d7..84ec9c8f6703 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -445,9 +445,12 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner)
 
 	/* register with core */
 	error = driver_register(&drv->driver);
+	if (error)
+		return error;
 
-	if (!error)
-		error = pci_create_newid_file(drv);
+	error = pci_create_newid_file(drv);
+	if (error)
+		driver_unregister(&drv->driver);
 
 	return error;
 }

commit 2449e06a5696b7af1c8a369b04c97f3b139cf3bb
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Fri Oct 20 14:45:32 2006 -0700

    PCI: reset pci device state to unknown state for resume
    
    Considering below scenario:
    1.Unload a PCI device's driver, the device ->current remains in PCI_D0.
    2.Do suspend/resume circle. After that, BIOS puts the device to D3.
    3.Reload the device driver. The calling pci_set_power_state in the
    driver can't change the state to D0, as set_power_state thinks the
    device is already in D0.
    
    A bug is reported at http://bugzilla.kernel.org/show_bug.cgi?id=6024
    Pat attached a patch at
    http://marc.theaimsgroup.com/?l=linux-pci&m=114049761428561&w=2 for this
    issue, but it's lost. As pci_set_power_state can handle D3 -> D0
    correctly (restore config space), I simplified Patrick's patch.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Cc: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index b1c0c707d96c..194f1d21d3d7 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -264,6 +264,13 @@ static int pci_device_remove(struct device * dev)
 		pci_dev->driver = NULL;
 	}
 
+	/*
+	 * If the device is still on, set the power state as "unknown",
+	 * since it might change by the next time we load the driver.
+	 */
+	if (pci_dev->current_state == PCI_D0)
+		pci_dev->current_state = PCI_UNKNOWN;
+
 	/*
 	 * We would love to complain here if pci_dev->is_enabled is set, that
 	 * the driver should have called pci_disable_device(), but the
@@ -288,6 +295,12 @@ static int pci_device_suspend(struct device * dev, pm_message_t state)
 		suspend_report_result(drv->suspend, i);
 	} else {
 		pci_save_state(pci_dev);
+		/*
+		 * mark its power state as "unknown", since we don't know if
+		 * e.g. the BIOS will change its device state when we suspend.
+		 */
+		if (pci_dev->current_state == PCI_D0)
+			pci_dev->current_state = PCI_UNKNOWN;
 	}
 	return i;
 }

commit 50b0075520a0acba9cabab5203bbce918b966d9a
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Wed Aug 16 17:42:18 2006 +0100

    PCI: Multiprobe sanitizer
    
    There are numerous drivers that can use multithreaded probing but having
    some kind of global flag as the way to control this makes migration to
    threaded probing hard and since it enables it everywhere and is almost
    as likely to cause serious pain as holding a clog dance in a minefield.
    
    If we have a pci_driver multithread_probe flag to inherit you can turn
    it on for one driver at a time.
    
    From playing so far however I think we need a different model at the
    device layer which serializes until the called probe function says "ok
    you can start another one now". That would need some kind of flag and
    semaphore plus a helper function.
    
    Anyway in the absence of that this is a starting point to usefully play
    with this stuff
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 309629e03bae..b1c0c707d96c 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -421,7 +421,11 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner)
 	drv->driver.bus = &pci_bus_type;
 	drv->driver.owner = owner;
 	drv->driver.kobj.ktype = &pci_driver_kobj_type;
-	drv->driver.multithread_probe = pci_multithread_probe;
+
+	if (pci_multithread_probe)
+		drv->driver.multithread_probe = pci_multithread_probe;
+	else
+		drv->driver.multithread_probe = drv->multithread_probe;
 
 	spin_lock_init(&drv->dynids.lock);
 	INIT_LIST_HEAD(&drv->dynids.list);

commit b19441af185559118e8247382ea4f2f76ebffc6d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 28 11:43:25 2006 -0700

    PCI: fix __must_check warnings
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index d8ace1f90dd2..309629e03bae 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -56,6 +56,7 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 		subdevice=PCI_ANY_ID, class=0, class_mask=0;
 	unsigned long driver_data=0;
 	int fields=0;
+	int retval = 0;
 
 	fields = sscanf(buf, "%x %x %x %x %x %x %lux",
 			&vendor, &device, &subvendor, &subdevice,
@@ -82,10 +83,12 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 	spin_unlock(&pdrv->dynids.lock);
 
 	if (get_driver(&pdrv->driver)) {
-		driver_attach(&pdrv->driver);
+		retval = driver_attach(&pdrv->driver);
 		put_driver(&pdrv->driver);
 	}
 
+	if (retval)
+		return retval;
 	return count;
 }
 static DRIVER_ATTR(new_id, S_IWUSR, NULL, store_new_id);

commit 0f397f865076e3471ec884ee73ad5e34165fac2a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jul 18 10:59:59 2006 -0700

    PCI: enable driver multi-threaded probe
    
    This provides a build and run-time option to turn on multhreaded probe
    for all PCI drivers.  It can cause bad problems on multi-processor
    machines that take a while to find their root disks, and play havoc on
    machines that don't use persistant device names for block or network
    devices.
    
    But it can cause speedups on some machines, my tiny laptop's boot goes
    up by 0.4 seconds, and my desktop boots up several seconds faster.
    
    Use at your own risk!!!
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 8948ac9ab681..d8ace1f90dd2 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -17,6 +17,16 @@
  *  Registration of PCI drivers and handling of hot-pluggable devices.
  */
 
+/* multithreaded probe logic */
+static int pci_multithread_probe =
+#ifdef CONFIG_PCI_MULTITHREAD_PROBE
+	1;
+#else
+	0;
+#endif
+__module_param_call("", pci_multithread_probe, param_set_bool, param_get_bool, &pci_multithread_probe, 0644);
+
+
 /*
  * Dynamic device IDs are disabled for !CONFIG_HOTPLUG
  */
@@ -408,6 +418,7 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner)
 	drv->driver.bus = &pci_bus_type;
 	drv->driver.owner = owner;
 	drv->driver.kobj.ktype = &pci_driver_kobj_type;
+	drv->driver.multithread_probe = pci_multithread_probe;
 
 	spin_lock_init(&drv->dynids.lock);
 	INIT_LIST_HEAD(&drv->dynids.list);

commit 1d3a82af45428c5e8deaa119cdeb79611ae46371
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Aug 30 14:09:47 2006 -0700

    PM: no suspend_prepare() phase
    
    Remove the new suspend_prepare() phase.  It doesn't seem very usable,
    has never been tested, doesn't address fault cleanup, and would need
    a sibling resume_complete(); plus there are no real use cases.  It
    could be restored later if those issues get resolved.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Linus Torvalds <torvalds@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 9e7d6ceb3805..8948ac9ab681 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -264,19 +264,6 @@ static int pci_device_remove(struct device * dev)
 	return 0;
 }
 
-static int pci_device_suspend_prepare(struct device * dev, pm_message_t state)
-{
-	struct pci_dev * pci_dev = to_pci_dev(dev);
-	struct pci_driver * drv = pci_dev->driver;
-	int i = 0;
-
-	if (drv && drv->suspend_prepare) {
-		i = drv->suspend_prepare(pci_dev, state);
-		suspend_report_result(drv->suspend_prepare, i);
-	}
-	return i;
-}
-
 static int pci_device_suspend(struct device * dev, pm_message_t state)
 {
 	struct pci_dev * pci_dev = to_pci_dev(dev);
@@ -544,7 +531,6 @@ struct bus_type pci_bus_type = {
 	.uevent		= pci_uevent,
 	.probe		= pci_device_probe,
 	.remove		= pci_device_remove,
-	.suspend_prepare= pci_device_suspend_prepare,
 	.suspend	= pci_device_suspend,
 	.suspend_late	= pci_device_suspend_late,
 	.resume_early	= pci_device_resume_early,

commit cbd69dbbf1adfce6e048f15afc8629901ca9dae5
Author: Linus Torvalds <torvalds@osdl.org>
Date:   Sat Jun 24 14:50:29 2006 -0700

    Suspend changes for PCI core
    
    Changes the PCI core to use the new suspend infrastructure changes.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 474e9cd0e9e4..9e7d6ceb3805 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -264,6 +264,19 @@ static int pci_device_remove(struct device * dev)
 	return 0;
 }
 
+static int pci_device_suspend_prepare(struct device * dev, pm_message_t state)
+{
+	struct pci_dev * pci_dev = to_pci_dev(dev);
+	struct pci_driver * drv = pci_dev->driver;
+	int i = 0;
+
+	if (drv && drv->suspend_prepare) {
+		i = drv->suspend_prepare(pci_dev, state);
+		suspend_report_result(drv->suspend_prepare, i);
+	}
+	return i;
+}
+
 static int pci_device_suspend(struct device * dev, pm_message_t state)
 {
 	struct pci_dev * pci_dev = to_pci_dev(dev);
@@ -279,6 +292,18 @@ static int pci_device_suspend(struct device * dev, pm_message_t state)
 	return i;
 }
 
+static int pci_device_suspend_late(struct device * dev, pm_message_t state)
+{
+	struct pci_dev * pci_dev = to_pci_dev(dev);
+	struct pci_driver * drv = pci_dev->driver;
+	int i = 0;
+
+	if (drv && drv->suspend_late) {
+		i = drv->suspend_late(pci_dev, state);
+		suspend_report_result(drv->suspend_late, i);
+	}
+	return i;
+}
 
 /*
  * Default resume method for devices that have no driver provided resume,
@@ -313,6 +338,17 @@ static int pci_device_resume(struct device * dev)
 	return error;
 }
 
+static int pci_device_resume_early(struct device * dev)
+{
+	int error = 0;
+	struct pci_dev * pci_dev = to_pci_dev(dev);
+	struct pci_driver * drv = pci_dev->driver;
+
+	if (drv && drv->resume_early)
+		error = drv->resume_early(pci_dev);
+	return error;
+}
+
 static void pci_device_shutdown(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
@@ -508,9 +544,12 @@ struct bus_type pci_bus_type = {
 	.uevent		= pci_uevent,
 	.probe		= pci_device_probe,
 	.remove		= pci_device_remove,
+	.suspend_prepare= pci_device_suspend_prepare,
 	.suspend	= pci_device_suspend,
-	.shutdown	= pci_device_shutdown,
+	.suspend_late	= pci_device_suspend_late,
+	.resume_early	= pci_device_resume_early,
 	.resume		= pci_device_resume,
+	.shutdown	= pci_device_shutdown,
 	.dev_attrs	= pci_dev_attrs,
 };
 

commit 39ba487fe22a63b3df7c543c82d01db0f0fed700
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Tue Aug 15 10:57:16 2006 +0200

    [PATCH] PCI: kerneldoc correction in pci-driver
    
    Removes an unused kerneldoc entry from pci_match_device and
    put the others into correct order.
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 10e1a905c144..474e9cd0e9e4 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -139,9 +139,8 @@ const struct pci_device_id *pci_match_id(const struct pci_device_id *ids,
 /**
  * pci_match_device - Tell if a PCI device structure has a matching
  *                    PCI device id structure
- * @ids: array of PCI device id structures to search in
- * @dev: the PCI device structure to match against
  * @drv: the PCI driver to match against
+ * @dev: the PCI device structure to match against
  *
  * Used by a driver to check whether a PCI device present in the
  * system is in its list of supported devices.  Returns the matching

commit 8d92bc2270d67a43b1d7e94a8cb6f81f1435fe9a
Author: Jean Delvare <khali@linux-fr.org>
Date:   Tue Apr 18 14:49:56 2006 +0200

    [PATCH] PCI: Error handling on PCI device resume
    
    We currently don't handle errors properly when resuming a PCI device:
    * In pci_default_resume() we capture the error code returned by
      pci_enable_device() but don't pass it up to the caller.
      Introduced by commit 95a629657dbe28e44a312c47815b3dc3f1ce0970
    * In pci_resume_device(), the errors possibly returned by the driver's
      .resume method or by the generic pci_default_resume() function are
      ignored.
    
    This patch fixes both issues.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 1456759936c5..10e1a905c144 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -285,9 +285,9 @@ static int pci_device_suspend(struct device * dev, pm_message_t state)
  * Default resume method for devices that have no driver provided resume,
  * or not even a driver at all.
  */
-static void pci_default_resume(struct pci_dev *pci_dev)
+static int pci_default_resume(struct pci_dev *pci_dev)
 {
-	int retval;
+	int retval = 0;
 
 	/* restore the PCI config space */
 	pci_restore_state(pci_dev);
@@ -297,18 +297,21 @@ static void pci_default_resume(struct pci_dev *pci_dev)
 	/* if the device was busmaster before the suspend, make it busmaster again */
 	if (pci_dev->is_busmaster)
 		pci_set_master(pci_dev);
+
+	return retval;
 }
 
 static int pci_device_resume(struct device * dev)
 {
+	int error;
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	struct pci_driver * drv = pci_dev->driver;
 
 	if (drv && drv->resume)
-		drv->resume(pci_dev);
+		error = drv->resume(pci_dev);
 	else
-		pci_default_resume(pci_dev);
-	return 0;
+		error = pci_default_resume(pci_dev);
+	return error;
 }
 
 static void pci_device_shutdown(struct device *dev)

commit 026694920579590c73b5c56705d543568ed5ad41
Author: Andrew Morton <akpm@osdl.org>
Date:   Thu Mar 23 01:38:34 2006 -0800

    [PATCH] pm: print name of failed suspend function
    
    Print more diagnostic info to help identify the source of power management
    suspend failures.
    
    Example:
    
    usb_hcd_pci_suspend(): pci_set_power_state+0x0/0x1af() returns -22
    pci_device_suspend(): usb_hcd_pci_suspend+0x0/0x11b() returns -22
    suspend_device(): pci_device_suspend+0x0/0x34() returns -22
    
    Work-in-progress.  It needs lots more suspend_report_result() calls sprinkled
    everywhere.
    
    Cc: Patrick Mochel <mochel@digitalimplant.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@suspend2.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index f22f69ac6445..1456759936c5 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -271,10 +271,12 @@ static int pci_device_suspend(struct device * dev, pm_message_t state)
 	struct pci_driver * drv = pci_dev->driver;
 	int i = 0;
 
-	if (drv && drv->suspend)
+	if (drv && drv->suspend) {
 		i = drv->suspend(pci_dev, state);
-	else
+		suspend_report_result(drv->suspend, i);
+	} else {
 		pci_save_state(pci_dev);
+	}
 	return i;
 }
 

commit f5afe8064f3087bead8fea7e32547c2a3ada5fd0
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Tue Feb 28 15:34:49 2006 +0100

    [PATCH] PCI: kzalloc() conversion in drivers/pci
    
    this patch converts drivers/pci to kzalloc usage.
    Compile tested with allyes config.
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index eb5b50c8770c..f22f69ac6445 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -53,11 +53,10 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 	if (fields < 0)
 		return -EINVAL;
 
-	dynid = kmalloc(sizeof(*dynid), GFP_KERNEL);
+	dynid = kzalloc(sizeof(*dynid), GFP_KERNEL);
 	if (!dynid)
 		return -ENOMEM;
 
-	memset(dynid, 0, sizeof(*dynid));
 	INIT_LIST_HEAD(&dynid->node);
 	dynid->id.vendor = vendor;
 	dynid->id.device = device;

commit 50defa1ccaffc197a133d92acb48d696d5ea3539
Author: Brian Gerst <bgerst@didntduck.org>
Date:   Sun Feb 19 16:05:52 2006 -0500

    [PATCH] PCI: Add pci_device_shutdown to pci_bus_type
    
    The extra compatability code is not necessary.  Any code still using
    the old shutdown method will trigger the warning in driver_register()
    instead.
    
    Signed-off-by: Brian Gerst <bgerst@didntduck.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 0aa14c92b570..eb5b50c8770c 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -380,14 +380,6 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner)
 	/* initialize common driver fields */
 	drv->driver.name = drv->name;
 	drv->driver.bus = &pci_bus_type;
-	/* FIXME, once all of the existing PCI drivers have been fixed to set
-	 * the pci shutdown function, this test can go away. */
-	if (!drv->driver.shutdown)
-		drv->driver.shutdown = pci_device_shutdown;
-	else
-		printk(KERN_WARNING "Warning: PCI driver %s has a struct "
-			"device_driver shutdown method, please update!\n",
-			drv->name);
 	drv->driver.owner = owner;
 	drv->driver.kobj.ktype = &pci_driver_kobj_type;
 
@@ -514,6 +506,7 @@ struct bus_type pci_bus_type = {
 	.probe		= pci_device_probe,
 	.remove		= pci_device_remove,
 	.suspend	= pci_device_suspend,
+	.shutdown	= pci_device_shutdown,
 	.resume		= pci_device_resume,
 	.dev_attrs	= pci_dev_attrs,
 };

commit b15d686a2b589c9e4f1ea116553e9c3c3d030dae
Author: Russell King <rmk@arm.linux.org.uk>
Date:   Thu Jan 5 14:30:22 2006 +0000

    [PATCH] Add pci_bus_type probe and remove methods
    
    Move the PCI bus device probe/remove methods to the bus_type
    structure.  We leave the shutdown method alone since there
    are compatibility issues with that.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 7146b69b812c..0aa14c92b570 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -380,8 +380,6 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner)
 	/* initialize common driver fields */
 	drv->driver.name = drv->name;
 	drv->driver.bus = &pci_bus_type;
-	drv->driver.probe = pci_device_probe;
-	drv->driver.remove = pci_device_remove;
 	/* FIXME, once all of the existing PCI drivers have been fixed to set
 	 * the pci shutdown function, this test can go away. */
 	if (!drv->driver.shutdown)
@@ -513,6 +511,8 @@ struct bus_type pci_bus_type = {
 	.name		= "pci",
 	.match		= pci_bus_match,
 	.uevent		= pci_uevent,
+	.probe		= pci_device_probe,
+	.remove		= pci_device_remove,
 	.suspend	= pci_device_suspend,
 	.resume		= pci_device_resume,
 	.dev_attrs	= pci_dev_attrs,

commit 312c004d36ce6c739512bac83b452f4c20ab1f62
Author: Kay Sievers <kay.sievers@suse.de>
Date:   Wed Nov 16 09:00:00 2005 +0100

    [PATCH] driver core: replace "hotplug" by "uevent"
    
    Leave the overloaded "hotplug" word to susbsystems which are handling
    real devices. The driver core does not "plug" anything, it just exports
    the state to userspace and generates events.
    
    Signed-off-by: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index a9046d4b8af3..7146b69b812c 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -502,8 +502,8 @@ void pci_dev_put(struct pci_dev *dev)
 }
 
 #ifndef CONFIG_HOTPLUG
-int pci_hotplug (struct device *dev, char **envp, int num_envp,
-		 char *buffer, int buffer_size)
+int pci_uevent(struct device *dev, char **envp, int num_envp,
+	       char *buffer, int buffer_size)
 {
 	return -ENODEV;
 }
@@ -512,7 +512,7 @@ int pci_hotplug (struct device *dev, char **envp, int num_envp,
 struct bus_type pci_bus_type = {
 	.name		= "pci",
 	.match		= pci_bus_match,
-	.hotplug	= pci_hotplug,
+	.uevent		= pci_uevent,
 	.suspend	= pci_device_suspend,
 	.resume		= pci_device_resume,
 	.dev_attrs	= pci_dev_attrs,

commit 863b18f4b5e7d9e6903b353328cf6fa084dbb619
Author: Laurent riffard <laurent.riffard@free.fr>
Date:   Thu Oct 27 23:12:54 2005 +0200

    [PATCH] PCI: automatically set device_driver.owner
    
    A nice feature of sysfs is that it can create the symlink from the
    driver to the module that is contained in it.
    
    It requires that the device_driver.owner is set, what is not the
    case for many PCI drivers.
    
    This patch allows pci_register_driver to set automatically the
    device_driver.owner for any PCI driver.
    
    Credits to Al Viro who suggested the method.
    
    Signed-off-by: Laurent Riffard <laurent.riffard@free.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    --
    
     drivers/ide/setup-pci.c  |   12 +++++++-----
     drivers/pci/pci-driver.c |    9 +++++----
     include/linux/ide.h      |    3 ++-
     include/linux/pci.h      |   10 ++++++++--
     4 files changed, 22 insertions(+), 12 deletions(-)

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index efb88c10ed16..a9046d4b8af3 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -364,15 +364,16 @@ static struct kobj_type pci_driver_kobj_type = {
 };
 
 /**
- * pci_register_driver - register a new pci driver
+ * __pci_register_driver - register a new pci driver
  * @drv: the driver structure to register
+ * @owner: owner module of drv
  * 
  * Adds the driver structure to the list of registered drivers.
  * Returns a negative value on error, otherwise 0. 
  * If no error occurred, the driver remains registered even if 
  * no device was claimed during registration.
  */
-int pci_register_driver(struct pci_driver *drv)
+int __pci_register_driver(struct pci_driver *drv, struct module *owner)
 {
 	int error;
 
@@ -389,7 +390,7 @@ int pci_register_driver(struct pci_driver *drv)
 		printk(KERN_WARNING "Warning: PCI driver %s has a struct "
 			"device_driver shutdown method, please update!\n",
 			drv->name);
-	drv->driver.owner = drv->owner;
+	drv->driver.owner = owner;
 	drv->driver.kobj.ktype = &pci_driver_kobj_type;
 
 	spin_lock_init(&drv->dynids.lock);
@@ -526,7 +527,7 @@ postcore_initcall(pci_driver_init);
 
 EXPORT_SYMBOL(pci_match_id);
 EXPORT_SYMBOL(pci_match_device);
-EXPORT_SYMBOL(pci_register_driver);
+EXPORT_SYMBOL(__pci_register_driver);
 EXPORT_SYMBOL(pci_unregister_driver);
 EXPORT_SYMBOL(pci_dev_driver);
 EXPORT_SYMBOL(pci_bus_type);

commit f8eb1005a5bdb019d2a4ff3ef8d8e8015b22afcb
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Fri Oct 28 20:36:51 2005 -0700

    [PATCH] pci-driver: store_new_id() not inline
    
    store_new_id() should not be (and cannot be) inline;
    the function pointer is stored in a device_attribute table.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 94e68c54d273..efb88c10ed16 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -37,7 +37,7 @@ struct pci_dynid {
  * Adds a new dynamic pci device ID to this driver,
  * and causes the driver to probe for all devices again.
  */
-static inline ssize_t
+static ssize_t
 store_new_id(struct device_driver *driver, const char *buf, size_t count)
 {
 	struct pci_dynid *dynid;

commit 8c65b4a60450590e79a28e9717ceffa9e4debb3f
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Mon Nov 7 00:59:43 2005 -0800

    [PATCH] fix remaining missing includes
    
    Fix more include file problems that surfaced since I submitted the previous
    fix-missing-includes.patch.  This should now allow not to include sched.h
    from module.h, which is done by a followup patch.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index ae986e590b48..94e68c54d273 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -10,6 +10,7 @@
 #include <linux/mempolicy.h>
 #include <linux/string.h>
 #include <linux/slab.h>
+#include <linux/sched.h>
 #include "pci.h"
 
 /*

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 8972e6a3aac0..ae986e590b48 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -8,6 +8,8 @@
 #include <linux/init.h>
 #include <linux/device.h>
 #include <linux/mempolicy.h>
+#include <linux/string.h>
+#include <linux/slab.h>
 #include "pci.h"
 
 /*

commit 8f7020d36374dda9366fee1343f8eacfe8f5e641
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sun Oct 23 11:57:38 2005 -0700

    [PATCH] kernel-doc: PCI fixes
    
    PCI: add descriptions for missing function parameters.
    Eliminate all kernel-doc warnings here.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index f906f1a8fe6a..8972e6a3aac0 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -26,7 +26,10 @@ struct pci_dynid {
 #ifdef CONFIG_HOTPLUG
 
 /**
- * store_new_id
+ * store_new_id - add a new PCI device ID to this driver and re-probe devices
+ * @driver: target device driver
+ * @buf: buffer for scanning device ID data
+ * @count: input size
  *
  * Adds a new dynamic pci device ID to this driver,
  * and causes the driver to probe for all devices again.
@@ -194,8 +197,10 @@ static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
 
 /**
  * __pci_device_probe()
+ * @drv: driver to call to check if it wants the PCI device
+ * @pci_dev: PCI device being probed
  * 
- * returns 0  on success, else error.
+ * returns 0 on success, else error.
  * side-effect: pci_dev->driver is set to drv when drv claims pci_dev.
  */
 static int
@@ -440,11 +445,11 @@ pci_dev_driver(const struct pci_dev *dev)
 
 /**
  * pci_bus_match - Tell if a PCI device structure has a matching PCI device id structure
- * @ids: array of PCI device id structures to search in
  * @dev: the PCI device structure to match against
+ * @drv: the device driver to search for matching PCI device id structures
  * 
  * Used by a driver to check whether a PCI device present in the
- * system is in its list of supported devices.Returns the matching
+ * system is in its list of supported devices. Returns the matching
  * pci_device_id structure or %NULL if there is no match.
  */
 static int pci_bus_match(struct device *dev, struct device_driver *drv)

commit a1720fdbd0f90e64668a59a304d01c5ba001b450
Author: Russell King <rmk+lkml@arm.linux.org.uk>
Date:   Sun Oct 16 21:31:36 2005 +0100

    [PATCH] PCI: Fixup PCI driver shutdown
    
    Add a warning to pci driver registration code so that we know
    whether we have drivers using the obsolete driver shutdown
    method.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 0d0d533894e0..f906f1a8fe6a 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -377,6 +377,10 @@ int pci_register_driver(struct pci_driver *drv)
 	 * the pci shutdown function, this test can go away. */
 	if (!drv->driver.shutdown)
 		drv->driver.shutdown = pci_device_shutdown;
+	else
+		printk(KERN_WARNING "Warning: PCI driver %s has a struct "
+			"device_driver shutdown method, please update!\n",
+			drv->name);
 	drv->driver.owner = drv->owner;
 	drv->driver.kobj.ktype = &pci_driver_kobj_type;
 

commit 95a629657dbe28e44a312c47815b3dc3f1ce0970
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jul 28 11:37:33 2005 -0700

    [PATCH] PCI: start paying attention to a lot of pci function return values
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 414c77299c7d..0d0d533894e0 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -272,17 +272,19 @@ static int pci_device_suspend(struct device * dev, pm_message_t state)
 }
 
 
-/* 
+/*
  * Default resume method for devices that have no driver provided resume,
  * or not even a driver at all.
  */
 static void pci_default_resume(struct pci_dev *pci_dev)
 {
+	int retval;
+
 	/* restore the PCI config space */
 	pci_restore_state(pci_dev);
 	/* if the device was enabled before suspend, reenable */
 	if (pci_dev->is_enabled)
-		pci_enable_device(pci_dev);
+		retval = pci_enable_device(pci_dev);
 	/* if the device was busmaster before the suspend, make it busmaster again */
 	if (pci_dev->is_busmaster)
 		pci_set_master(pci_dev);

commit d42c69972b853fd33a26c8c7405624be41a22136
Author: Andi Kleen <ak@suse.de>
Date:   Wed Jul 6 19:56:03 2005 +0200

    [PATCH] PCI: Run PCI driver initialization on local node
    
    Run PCI driver initialization on local node
    
    Instead of adding messy kmalloc_node()s everywhere run the
    PCI driver probe on the node local to the device.
    
    This would not have helped for IDE, but should for
    other more clean drivers that do more initialization in probe().
    It won't help for drivers that do most of the work
    on first open (like many network drivers)
    
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index e4115a0d5ba6..414c77299c7d 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -7,6 +7,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/device.h>
+#include <linux/mempolicy.h>
 #include "pci.h"
 
 /*
@@ -163,6 +164,34 @@ const struct pci_device_id *pci_match_device(struct pci_driver *drv,
 	return NULL;
 }
 
+static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
+			  const struct pci_device_id *id)
+{
+	int error;
+#ifdef CONFIG_NUMA
+	/* Execute driver initialization on node where the
+	   device's bus is attached to.  This way the driver likely
+	   allocates its local memory on the right node without
+	   any need to change it. */
+	struct mempolicy *oldpol;
+	cpumask_t oldmask = current->cpus_allowed;
+	int node = pcibus_to_node(dev->bus);
+	if (node >= 0 && node_online(node))
+	    set_cpus_allowed(current, node_to_cpumask(node));
+	/* And set default memory allocation policy */
+	oldpol = current->mempolicy;
+	current->mempolicy = &default_policy;
+	mpol_get(current->mempolicy);
+#endif
+	error = drv->probe(dev, id);
+#ifdef CONFIG_NUMA
+	set_cpus_allowed(current, oldmask);
+	mpol_free(current->mempolicy);
+	current->mempolicy = oldpol;
+#endif
+	return error;
+}
+
 /**
  * __pci_device_probe()
  * 
@@ -180,7 +209,7 @@ __pci_device_probe(struct pci_driver *drv, struct pci_dev *pci_dev)
 
 		id = pci_match_device(drv, pci_dev);
 		if (id)
-			error = drv->probe(pci_dev, id);
+			error = pci_call_probe(drv, pci_dev, id);
 		if (error >= 0) {
 			pci_dev->driver = drv;
 			error = 0;

commit 3d3c2ae1101c1f2dff7e2f9d514769779dbd2737
Author: Greg KH <gregkh@suse.de>
Date:   Wed Jul 6 09:09:38 2005 -0700

    [PATCH] PCI: fix !CONFIG_HOTPLUG pci build problem
    
    Here's a patch to fix the build issue when CONFIG_HOTPLUG is not enabled
    in 2.6.13-rc2.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index aac6de9568e5..e4115a0d5ba6 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -17,13 +17,13 @@
  * Dynamic device IDs are disabled for !CONFIG_HOTPLUG
  */
 
-#ifdef CONFIG_HOTPLUG
-
 struct pci_dynid {
 	struct list_head node;
 	struct pci_device_id id;
 };
 
+#ifdef CONFIG_HOTPLUG
+
 /**
  * store_new_id
  *

commit 75865858971add95809c5c9cd35dc4cfba08e33b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jun 30 02:18:12 2005 -0700

    [PATCH] PCI: clean up dynamic pci id logic
    
    The dynamic pci id logic has been bothering me for a while, and now that
    I started to look into how to move some of this to the driver core, I
    thought it was time to clean it all up.
    
    It ends up making the code smaller, and easier to follow, and fixes a
    few bugs at the same time (dynamic ids were not being matched
    everywhere, and so could be missed on some call paths for new devices,
    semaphore not needed to be grabbed when adding a new id and calling the
    driver core, etc.)
    
    I also renamed the function pci_match_device() to pci_match_id() as
    that's what it really does.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index e65bf2b395aa..aac6de9568e5 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -7,7 +7,6 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/device.h>
-#include <linux/pci-dynids.h>
 #include "pci.h"
 
 /*
@@ -19,35 +18,11 @@
  */
 
 #ifdef CONFIG_HOTPLUG
-/**
- * pci_device_probe_dynamic()
- *
- * Walk the dynamic ID list looking for a match.
- * returns 0 and sets pci_dev->driver when drv claims pci_dev, else error.
- */
-static int
-pci_device_probe_dynamic(struct pci_driver *drv, struct pci_dev *pci_dev)
-{
-	int error = -ENODEV;
-	struct list_head *pos;
-	struct dynid *dynid;
 
-	spin_lock(&drv->dynids.lock);
-	list_for_each(pos, &drv->dynids.list) {
-		dynid = list_entry(pos, struct dynid, node);
-		if (pci_match_one_device(&dynid->id, pci_dev)) {
-			spin_unlock(&drv->dynids.lock);
-			error = drv->probe(pci_dev, &dynid->id);
-			if (error >= 0) {
-				pci_dev->driver = drv;
-				return 0;
-			}
-			return error;
-		}
-	}
-	spin_unlock(&drv->dynids.lock);
-	return error;
-}
+struct pci_dynid {
+	struct list_head node;
+	struct pci_device_id id;
+};
 
 /**
  * store_new_id
@@ -58,8 +33,7 @@ pci_device_probe_dynamic(struct pci_driver *drv, struct pci_dev *pci_dev)
 static inline ssize_t
 store_new_id(struct device_driver *driver, const char *buf, size_t count)
 {
-	struct dynid *dynid;
-	struct bus_type * bus;
+	struct pci_dynid *dynid;
 	struct pci_driver *pdrv = to_pci_driver(driver);
 	__u32 vendor=PCI_ANY_ID, device=PCI_ANY_ID, subvendor=PCI_ANY_ID,
 		subdevice=PCI_ANY_ID, class=0, class_mask=0;
@@ -91,37 +65,22 @@ store_new_id(struct device_driver *driver, const char *buf, size_t count)
 	list_add_tail(&pdrv->dynids.list, &dynid->node);
 	spin_unlock(&pdrv->dynids.lock);
 
-	bus = get_bus(pdrv->driver.bus);
-	if (bus) {
-		if (get_driver(&pdrv->driver)) {
-			down_write(&bus->subsys.rwsem);
-			driver_attach(&pdrv->driver);
-			up_write(&bus->subsys.rwsem);
-			put_driver(&pdrv->driver);
-		}
-		put_bus(bus);
+	if (get_driver(&pdrv->driver)) {
+		driver_attach(&pdrv->driver);
+		put_driver(&pdrv->driver);
 	}
 
 	return count;
 }
-
 static DRIVER_ATTR(new_id, S_IWUSR, NULL, store_new_id);
-static inline void
-pci_init_dynids(struct pci_dynids *dynids)
-{
-	spin_lock_init(&dynids->lock);
-	INIT_LIST_HEAD(&dynids->list);
-}
 
 static void
 pci_free_dynids(struct pci_driver *drv)
 {
-	struct list_head *pos, *n;
-	struct dynid *dynid;
+	struct pci_dynid *dynid, *n;
 
 	spin_lock(&drv->dynids.lock);
-	list_for_each_safe(pos, n, &drv->dynids.list) {
-		dynid = list_entry(pos, struct dynid, node);
+	list_for_each_entry_safe(dynid, n, &drv->dynids.list, node) {
 		list_del(&dynid->node);
 		kfree(dynid);
 	}
@@ -138,83 +97,70 @@ pci_create_newid_file(struct pci_driver *drv)
 	return error;
 }
 
-static int
-pci_bus_match_dynids(const struct pci_dev *pci_dev, struct pci_driver *pci_drv)
-{
-	struct list_head *pos;
-	struct dynid *dynid;
-
-	spin_lock(&pci_drv->dynids.lock);
-	list_for_each(pos, &pci_drv->dynids.list) {
-		dynid = list_entry(pos, struct dynid, node);
-		if (pci_match_one_device(&dynid->id, pci_dev)) {
-			spin_unlock(&pci_drv->dynids.lock);
-			return 1;
-		}
-	}
-	spin_unlock(&pci_drv->dynids.lock);
-	return 0;
-}
-
 #else /* !CONFIG_HOTPLUG */
-static inline int pci_device_probe_dynamic(struct pci_driver *drv, struct pci_dev *pci_dev)
-{
-	return -ENODEV;
-}
-static inline void pci_init_dynids(struct pci_dynids *dynids) {}
 static inline void pci_free_dynids(struct pci_driver *drv) {}
 static inline int pci_create_newid_file(struct pci_driver *drv)
 {
 	return 0;
 }
-static inline int pci_bus_match_dynids(const struct pci_dev *pci_dev, struct pci_driver *pci_drv)
-{
-	return 0;
-}
 #endif
 
 /**
- * pci_match_device - Tell if a PCI device structure has a matching
- *                    PCI device id structure
+ * pci_match_id - See if a pci device matches a given pci_id table
  * @ids: array of PCI device id structures to search in
- * @dev: the PCI device structure to match against
- * 
+ * @dev: the PCI device structure to match against.
+ *
  * Used by a driver to check whether a PCI device present in the
- * system is in its list of supported devices.Returns the matching
+ * system is in its list of supported devices.  Returns the matching
  * pci_device_id structure or %NULL if there is no match.
+ *
+ * Depreciated, don't use this as it will not catch any dynamic ids
+ * that a driver might want to check for.
  */
-const struct pci_device_id *
-pci_match_device(const struct pci_device_id *ids, const struct pci_dev *dev)
+const struct pci_device_id *pci_match_id(const struct pci_device_id *ids,
+					 struct pci_dev *dev)
 {
-	while (ids->vendor || ids->subvendor || ids->class_mask) {
-		if (pci_match_one_device(ids, dev))
-			return ids;
-		ids++;
+	if (ids) {
+		while (ids->vendor || ids->subvendor || ids->class_mask) {
+			if (pci_match_one_device(ids, dev))
+				return ids;
+			ids++;
+		}
 	}
 	return NULL;
 }
 
 /**
- * pci_device_probe_static()
- * 
- * returns 0 and sets pci_dev->driver when drv claims pci_dev, else error.
+ * pci_match_device - Tell if a PCI device structure has a matching
+ *                    PCI device id structure
+ * @ids: array of PCI device id structures to search in
+ * @dev: the PCI device structure to match against
+ * @drv: the PCI driver to match against
+ *
+ * Used by a driver to check whether a PCI device present in the
+ * system is in its list of supported devices.  Returns the matching
+ * pci_device_id structure or %NULL if there is no match.
  */
-static int
-pci_device_probe_static(struct pci_driver *drv, struct pci_dev *pci_dev)
-{		   
-	int error = -ENODEV;
+const struct pci_device_id *pci_match_device(struct pci_driver *drv,
+					     struct pci_dev *dev)
+{
 	const struct pci_device_id *id;
+	struct pci_dynid *dynid;
 
-	if (!drv->id_table)
-		return error;
-	id = pci_match_device(drv->id_table, pci_dev);
+	id = pci_match_id(drv->id_table, dev);
 	if (id)
-		error = drv->probe(pci_dev, id);
-	if (error >= 0) {
-		pci_dev->driver = drv;
-		error = 0;
+		return id;
+
+	/* static ids didn't match, lets look at the dynamic ones */
+	spin_lock(&drv->dynids.lock);
+	list_for_each_entry(dynid, &drv->dynids.list, node) {
+		if (pci_match_one_device(&dynid->id, dev)) {
+			spin_unlock(&drv->dynids.lock);
+			return &dynid->id;
+		}
 	}
-	return error;
+	spin_unlock(&drv->dynids.lock);
+	return NULL;
 }
 
 /**
@@ -225,13 +171,20 @@ pci_device_probe_static(struct pci_driver *drv, struct pci_dev *pci_dev)
  */
 static int
 __pci_device_probe(struct pci_driver *drv, struct pci_dev *pci_dev)
-{		   
+{
+	const struct pci_device_id *id;
 	int error = 0;
 
 	if (!pci_dev->driver && drv->probe) {
-		error = pci_device_probe_static(drv, pci_dev);
-		if (error == -ENODEV)
-			error = pci_device_probe_dynamic(drv, pci_dev);
+		error = -ENODEV;
+
+		id = pci_match_device(drv, pci_dev);
+		if (id)
+			error = drv->probe(pci_dev, id);
+		if (error >= 0) {
+			pci_dev->driver = drv;
+			error = 0;
+		}
 	}
 	return error;
 }
@@ -371,12 +324,6 @@ static struct kobj_type pci_driver_kobj_type = {
 	.sysfs_ops = &pci_driver_sysfs_ops,
 };
 
-static int
-pci_populate_driver_dir(struct pci_driver *drv)
-{
-	return pci_create_newid_file(drv);
-}
-
 /**
  * pci_register_driver - register a new pci driver
  * @drv: the driver structure to register
@@ -401,13 +348,15 @@ int pci_register_driver(struct pci_driver *drv)
 		drv->driver.shutdown = pci_device_shutdown;
 	drv->driver.owner = drv->owner;
 	drv->driver.kobj.ktype = &pci_driver_kobj_type;
-	pci_init_dynids(&drv->dynids);
+
+	spin_lock_init(&drv->dynids.lock);
+	INIT_LIST_HEAD(&drv->dynids.list);
 
 	/* register with core */
 	error = driver_register(&drv->driver);
 
 	if (!error)
-		pci_populate_driver_dir(drv);
+		error = pci_create_newid_file(drv);
 
 	return error;
 }
@@ -463,21 +412,17 @@ pci_dev_driver(const struct pci_dev *dev)
  * system is in its list of supported devices.Returns the matching
  * pci_device_id structure or %NULL if there is no match.
  */
-static int pci_bus_match(struct device * dev, struct device_driver * drv) 
+static int pci_bus_match(struct device *dev, struct device_driver *drv)
 {
-	const struct pci_dev * pci_dev = to_pci_dev(dev);
-	struct pci_driver * pci_drv = to_pci_driver(drv);
-	const struct pci_device_id * ids = pci_drv->id_table;
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct pci_driver *pci_drv = to_pci_driver(drv);
 	const struct pci_device_id *found_id;
 
-	if (!ids)
-		return 0;
-
-	found_id = pci_match_device(ids, pci_dev);
+	found_id = pci_match_device(pci_drv, pci_dev);
 	if (found_id)
 		return 1;
 
-	return pci_bus_match_dynids(pci_dev, pci_drv);
+	return 0;
 }
 
 /**
@@ -536,6 +481,7 @@ static int __init pci_driver_init(void)
 
 postcore_initcall(pci_driver_init);
 
+EXPORT_SYMBOL(pci_match_id);
 EXPORT_SYMBOL(pci_match_device);
 EXPORT_SYMBOL(pci_register_driver);
 EXPORT_SYMBOL(pci_unregister_driver);

commit fc7e4828995d8c9e4c9597f8a19179e4ab53f73e
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Fri Apr 29 01:26:27 2005 -0500

    [PATCH] sysfs: (driver/pci) if show/store is missing return -EIO
    
    sysfs: fix drivers/pci so if an attribute does not implement
           show or store method read/write will return -EIO
           instead of 0.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index cf2cff7480f1..e65bf2b395aa 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -335,13 +335,14 @@ pci_driver_attr_show(struct kobject * kobj, struct attribute *attr, char *buf)
 {
 	struct device_driver *driver = kobj_to_pci_driver(kobj);
 	struct driver_attribute *dattr = attr_to_driver_attribute(attr);
-	ssize_t ret = 0;
+	ssize_t ret;
 
-	if (get_driver(driver)) {
-		if (dattr->show)
-			ret = dattr->show(driver, buf);
-		put_driver(driver);
-	}
+	if (!get_driver(driver))
+		return -ENODEV;
+
+	ret = dattr->show ? dattr->show(driver, buf) : -EIO;
+
+	put_driver(driver);
 	return ret;
 }
 
@@ -351,13 +352,14 @@ pci_driver_attr_store(struct kobject * kobj, struct attribute *attr,
 {
 	struct device_driver *driver = kobj_to_pci_driver(kobj);
 	struct driver_attribute *dattr = attr_to_driver_attribute(attr);
-	ssize_t ret = 0;
+	ssize_t ret;
 
-	if (get_driver(driver)) {
-		if (dattr->store)
-			ret = dattr->store(driver, buf, count);
-		put_driver(driver);
-	}
+	if (!get_driver(driver))
+		return -ENODEV;
+
+	ret = dattr->store ? dattr->store(driver, buf, count) : -EIO;
+
+	put_driver(driver);
 	return ret;
 }
 

commit c83d9945c05570ba6b8ec5460c99d1ab7c6e6671
Author: Mika Kukkonen <mikukkon@miku.homelinux.net>
Date:   Sat Jun 18 22:49:56 2005 +0300

    [PATCH] Fix typo in drivers/pci/pci-driver.c
    
    The git commit 794f5bfa77955c4455f6d72d8b0e2bee25f1ff0c
    accidentally suffers from a previous typo in that file
    (',' instead of ';' in end of line). Patch included.
    
    Signed-off-by: Mika Kukkonen (mikukkon@iki.fi)
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index f315df2005bc..cf2cff7480f1 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -396,7 +396,7 @@ int pci_register_driver(struct pci_driver *drv)
 	/* FIXME, once all of the existing PCI drivers have been fixed to set
 	 * the pci shutdown function, this test can go away. */
 	if (!drv->driver.shutdown)
-		drv->driver.shutdown = pci_device_shutdown,
+		drv->driver.shutdown = pci_device_shutdown;
 	drv->driver.owner = drv->owner;
 	drv->driver.kobj.ktype = &pci_driver_kobj_type;
 	pci_init_dynids(&drv->dynids);

commit 794f5bfa77955c4455f6d72d8b0e2bee25f1ff0c
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jun 17 12:25:25 2005 -0700

    [PATCH] PCI: don't override drv->shutdown unconditionally
    
    There are many drivers that have been setting the generic driver
    model level shutdown callback, and pci thus must not override it.
    
    Without this patch we can have really bad data loss on various
    raid controllers.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index fe98553c978f..f315df2005bc 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -393,7 +393,10 @@ int pci_register_driver(struct pci_driver *drv)
 	drv->driver.bus = &pci_bus_type;
 	drv->driver.probe = pci_device_probe;
 	drv->driver.remove = pci_device_remove;
-	drv->driver.shutdown = pci_device_shutdown,
+	/* FIXME, once all of the existing PCI drivers have been fixed to set
+	 * the pci shutdown function, this test can go away. */
+	if (!drv->driver.shutdown)
+		drv->driver.shutdown = pci_device_shutdown,
 	drv->driver.owner = drv->owner;
 	drv->driver.kobj.ktype = &pci_driver_kobj_type;
 	pci_init_dynids(&drv->dynids);

commit eaae4b3a84a3781543a32bcaf0a33306ae915574
Author: Steven Cole <elenstev@mesatop.com>
Date:   Tue May 3 18:38:30 2005 -0600

    [PATCH] PCI: Spelling fixes for drivers/pci.
    
    Here are some spelling corrections for drivers/pci.
    
    CONTROLER -> CONTROLLER
    Regisetr -> Register
    harware -> hardware
    inital -> initial
    Initilize -> Initialize
    funtion -> function
    funciton -> function
    occured -> occurred
    
    Signed-off-by: Steven Cole <elenstev@mesatop.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index b42466ccbb30..fe98553c978f 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -381,7 +381,7 @@ pci_populate_driver_dir(struct pci_driver *drv)
  * 
  * Adds the driver structure to the list of registered drivers.
  * Returns a negative value on error, otherwise 0. 
- * If no error occured, the driver remains registered even if 
+ * If no error occurred, the driver remains registered even if 
  * no device was claimed during registration.
  */
 int pci_register_driver(struct pci_driver *drv)

commit c8958177224622411b9979eabb5610e30b06034b
Author: Greg KH <gregkh@suse.de>
Date:   Fri Apr 8 14:53:31 2005 +0900

    [PATCH] PCI: Add pci shutdown ability
    
    Now pci drivers can know when the system is going down without having to
    add a reboot notifier event.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 37b7961efc44..b42466ccbb30 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -318,6 +318,14 @@ static int pci_device_resume(struct device * dev)
 	return 0;
 }
 
+static void pci_device_shutdown(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct pci_driver *drv = pci_dev->driver;
+
+	if (drv && drv->shutdown)
+		drv->shutdown(pci_dev);
+}
 
 #define kobj_to_pci_driver(obj) container_of(obj, struct device_driver, kobj)
 #define attr_to_driver_attribute(obj) container_of(obj, struct driver_attribute, attr)
@@ -385,6 +393,7 @@ int pci_register_driver(struct pci_driver *drv)
 	drv->driver.bus = &pci_bus_type;
 	drv->driver.probe = pci_device_probe;
 	drv->driver.remove = pci_device_remove;
+	drv->driver.shutdown = pci_device_shutdown,
 	drv->driver.owner = drv->owner;
 	drv->driver.kobj.ktype = &pci_driver_kobj_type;
 	pci_init_dynids(&drv->dynids);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
new file mode 100644
index 000000000000..37b7961efc44
--- /dev/null
+++ b/drivers/pci/pci-driver.c
@@ -0,0 +1,531 @@
+/*
+ * drivers/pci/pci-driver.c
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/pci-dynids.h>
+#include "pci.h"
+
+/*
+ *  Registration of PCI drivers and handling of hot-pluggable devices.
+ */
+
+/*
+ * Dynamic device IDs are disabled for !CONFIG_HOTPLUG
+ */
+
+#ifdef CONFIG_HOTPLUG
+/**
+ * pci_device_probe_dynamic()
+ *
+ * Walk the dynamic ID list looking for a match.
+ * returns 0 and sets pci_dev->driver when drv claims pci_dev, else error.
+ */
+static int
+pci_device_probe_dynamic(struct pci_driver *drv, struct pci_dev *pci_dev)
+{
+	int error = -ENODEV;
+	struct list_head *pos;
+	struct dynid *dynid;
+
+	spin_lock(&drv->dynids.lock);
+	list_for_each(pos, &drv->dynids.list) {
+		dynid = list_entry(pos, struct dynid, node);
+		if (pci_match_one_device(&dynid->id, pci_dev)) {
+			spin_unlock(&drv->dynids.lock);
+			error = drv->probe(pci_dev, &dynid->id);
+			if (error >= 0) {
+				pci_dev->driver = drv;
+				return 0;
+			}
+			return error;
+		}
+	}
+	spin_unlock(&drv->dynids.lock);
+	return error;
+}
+
+/**
+ * store_new_id
+ *
+ * Adds a new dynamic pci device ID to this driver,
+ * and causes the driver to probe for all devices again.
+ */
+static inline ssize_t
+store_new_id(struct device_driver *driver, const char *buf, size_t count)
+{
+	struct dynid *dynid;
+	struct bus_type * bus;
+	struct pci_driver *pdrv = to_pci_driver(driver);
+	__u32 vendor=PCI_ANY_ID, device=PCI_ANY_ID, subvendor=PCI_ANY_ID,
+		subdevice=PCI_ANY_ID, class=0, class_mask=0;
+	unsigned long driver_data=0;
+	int fields=0;
+
+	fields = sscanf(buf, "%x %x %x %x %x %x %lux",
+			&vendor, &device, &subvendor, &subdevice,
+			&class, &class_mask, &driver_data);
+	if (fields < 0)
+		return -EINVAL;
+
+	dynid = kmalloc(sizeof(*dynid), GFP_KERNEL);
+	if (!dynid)
+		return -ENOMEM;
+
+	memset(dynid, 0, sizeof(*dynid));
+	INIT_LIST_HEAD(&dynid->node);
+	dynid->id.vendor = vendor;
+	dynid->id.device = device;
+	dynid->id.subvendor = subvendor;
+	dynid->id.subdevice = subdevice;
+	dynid->id.class = class;
+	dynid->id.class_mask = class_mask;
+	dynid->id.driver_data = pdrv->dynids.use_driver_data ?
+		driver_data : 0UL;
+
+	spin_lock(&pdrv->dynids.lock);
+	list_add_tail(&pdrv->dynids.list, &dynid->node);
+	spin_unlock(&pdrv->dynids.lock);
+
+	bus = get_bus(pdrv->driver.bus);
+	if (bus) {
+		if (get_driver(&pdrv->driver)) {
+			down_write(&bus->subsys.rwsem);
+			driver_attach(&pdrv->driver);
+			up_write(&bus->subsys.rwsem);
+			put_driver(&pdrv->driver);
+		}
+		put_bus(bus);
+	}
+
+	return count;
+}
+
+static DRIVER_ATTR(new_id, S_IWUSR, NULL, store_new_id);
+static inline void
+pci_init_dynids(struct pci_dynids *dynids)
+{
+	spin_lock_init(&dynids->lock);
+	INIT_LIST_HEAD(&dynids->list);
+}
+
+static void
+pci_free_dynids(struct pci_driver *drv)
+{
+	struct list_head *pos, *n;
+	struct dynid *dynid;
+
+	spin_lock(&drv->dynids.lock);
+	list_for_each_safe(pos, n, &drv->dynids.list) {
+		dynid = list_entry(pos, struct dynid, node);
+		list_del(&dynid->node);
+		kfree(dynid);
+	}
+	spin_unlock(&drv->dynids.lock);
+}
+
+static int
+pci_create_newid_file(struct pci_driver *drv)
+{
+	int error = 0;
+	if (drv->probe != NULL)
+		error = sysfs_create_file(&drv->driver.kobj,
+					  &driver_attr_new_id.attr);
+	return error;
+}
+
+static int
+pci_bus_match_dynids(const struct pci_dev *pci_dev, struct pci_driver *pci_drv)
+{
+	struct list_head *pos;
+	struct dynid *dynid;
+
+	spin_lock(&pci_drv->dynids.lock);
+	list_for_each(pos, &pci_drv->dynids.list) {
+		dynid = list_entry(pos, struct dynid, node);
+		if (pci_match_one_device(&dynid->id, pci_dev)) {
+			spin_unlock(&pci_drv->dynids.lock);
+			return 1;
+		}
+	}
+	spin_unlock(&pci_drv->dynids.lock);
+	return 0;
+}
+
+#else /* !CONFIG_HOTPLUG */
+static inline int pci_device_probe_dynamic(struct pci_driver *drv, struct pci_dev *pci_dev)
+{
+	return -ENODEV;
+}
+static inline void pci_init_dynids(struct pci_dynids *dynids) {}
+static inline void pci_free_dynids(struct pci_driver *drv) {}
+static inline int pci_create_newid_file(struct pci_driver *drv)
+{
+	return 0;
+}
+static inline int pci_bus_match_dynids(const struct pci_dev *pci_dev, struct pci_driver *pci_drv)
+{
+	return 0;
+}
+#endif
+
+/**
+ * pci_match_device - Tell if a PCI device structure has a matching
+ *                    PCI device id structure
+ * @ids: array of PCI device id structures to search in
+ * @dev: the PCI device structure to match against
+ * 
+ * Used by a driver to check whether a PCI device present in the
+ * system is in its list of supported devices.Returns the matching
+ * pci_device_id structure or %NULL if there is no match.
+ */
+const struct pci_device_id *
+pci_match_device(const struct pci_device_id *ids, const struct pci_dev *dev)
+{
+	while (ids->vendor || ids->subvendor || ids->class_mask) {
+		if (pci_match_one_device(ids, dev))
+			return ids;
+		ids++;
+	}
+	return NULL;
+}
+
+/**
+ * pci_device_probe_static()
+ * 
+ * returns 0 and sets pci_dev->driver when drv claims pci_dev, else error.
+ */
+static int
+pci_device_probe_static(struct pci_driver *drv, struct pci_dev *pci_dev)
+{		   
+	int error = -ENODEV;
+	const struct pci_device_id *id;
+
+	if (!drv->id_table)
+		return error;
+	id = pci_match_device(drv->id_table, pci_dev);
+	if (id)
+		error = drv->probe(pci_dev, id);
+	if (error >= 0) {
+		pci_dev->driver = drv;
+		error = 0;
+	}
+	return error;
+}
+
+/**
+ * __pci_device_probe()
+ * 
+ * returns 0  on success, else error.
+ * side-effect: pci_dev->driver is set to drv when drv claims pci_dev.
+ */
+static int
+__pci_device_probe(struct pci_driver *drv, struct pci_dev *pci_dev)
+{		   
+	int error = 0;
+
+	if (!pci_dev->driver && drv->probe) {
+		error = pci_device_probe_static(drv, pci_dev);
+		if (error == -ENODEV)
+			error = pci_device_probe_dynamic(drv, pci_dev);
+	}
+	return error;
+}
+
+static int pci_device_probe(struct device * dev)
+{
+	int error = 0;
+	struct pci_driver *drv;
+	struct pci_dev *pci_dev;
+
+	drv = to_pci_driver(dev->driver);
+	pci_dev = to_pci_dev(dev);
+	pci_dev_get(pci_dev);
+	error = __pci_device_probe(drv, pci_dev);
+	if (error)
+		pci_dev_put(pci_dev);
+
+	return error;
+}
+
+static int pci_device_remove(struct device * dev)
+{
+	struct pci_dev * pci_dev = to_pci_dev(dev);
+	struct pci_driver * drv = pci_dev->driver;
+
+	if (drv) {
+		if (drv->remove)
+			drv->remove(pci_dev);
+		pci_dev->driver = NULL;
+	}
+
+	/*
+	 * We would love to complain here if pci_dev->is_enabled is set, that
+	 * the driver should have called pci_disable_device(), but the
+	 * unfortunate fact is there are too many odd BIOS and bridge setups
+	 * that don't like drivers doing that all of the time.  
+	 * Oh well, we can dream of sane hardware when we sleep, no matter how
+	 * horrible the crap we have to deal with is when we are awake...
+	 */
+
+	pci_dev_put(pci_dev);
+	return 0;
+}
+
+static int pci_device_suspend(struct device * dev, pm_message_t state)
+{
+	struct pci_dev * pci_dev = to_pci_dev(dev);
+	struct pci_driver * drv = pci_dev->driver;
+	int i = 0;
+
+	if (drv && drv->suspend)
+		i = drv->suspend(pci_dev, state);
+	else
+		pci_save_state(pci_dev);
+	return i;
+}
+
+
+/* 
+ * Default resume method for devices that have no driver provided resume,
+ * or not even a driver at all.
+ */
+static void pci_default_resume(struct pci_dev *pci_dev)
+{
+	/* restore the PCI config space */
+	pci_restore_state(pci_dev);
+	/* if the device was enabled before suspend, reenable */
+	if (pci_dev->is_enabled)
+		pci_enable_device(pci_dev);
+	/* if the device was busmaster before the suspend, make it busmaster again */
+	if (pci_dev->is_busmaster)
+		pci_set_master(pci_dev);
+}
+
+static int pci_device_resume(struct device * dev)
+{
+	struct pci_dev * pci_dev = to_pci_dev(dev);
+	struct pci_driver * drv = pci_dev->driver;
+
+	if (drv && drv->resume)
+		drv->resume(pci_dev);
+	else
+		pci_default_resume(pci_dev);
+	return 0;
+}
+
+
+#define kobj_to_pci_driver(obj) container_of(obj, struct device_driver, kobj)
+#define attr_to_driver_attribute(obj) container_of(obj, struct driver_attribute, attr)
+
+static ssize_t
+pci_driver_attr_show(struct kobject * kobj, struct attribute *attr, char *buf)
+{
+	struct device_driver *driver = kobj_to_pci_driver(kobj);
+	struct driver_attribute *dattr = attr_to_driver_attribute(attr);
+	ssize_t ret = 0;
+
+	if (get_driver(driver)) {
+		if (dattr->show)
+			ret = dattr->show(driver, buf);
+		put_driver(driver);
+	}
+	return ret;
+}
+
+static ssize_t
+pci_driver_attr_store(struct kobject * kobj, struct attribute *attr,
+		      const char *buf, size_t count)
+{
+	struct device_driver *driver = kobj_to_pci_driver(kobj);
+	struct driver_attribute *dattr = attr_to_driver_attribute(attr);
+	ssize_t ret = 0;
+
+	if (get_driver(driver)) {
+		if (dattr->store)
+			ret = dattr->store(driver, buf, count);
+		put_driver(driver);
+	}
+	return ret;
+}
+
+static struct sysfs_ops pci_driver_sysfs_ops = {
+	.show = pci_driver_attr_show,
+	.store = pci_driver_attr_store,
+};
+static struct kobj_type pci_driver_kobj_type = {
+	.sysfs_ops = &pci_driver_sysfs_ops,
+};
+
+static int
+pci_populate_driver_dir(struct pci_driver *drv)
+{
+	return pci_create_newid_file(drv);
+}
+
+/**
+ * pci_register_driver - register a new pci driver
+ * @drv: the driver structure to register
+ * 
+ * Adds the driver structure to the list of registered drivers.
+ * Returns a negative value on error, otherwise 0. 
+ * If no error occured, the driver remains registered even if 
+ * no device was claimed during registration.
+ */
+int pci_register_driver(struct pci_driver *drv)
+{
+	int error;
+
+	/* initialize common driver fields */
+	drv->driver.name = drv->name;
+	drv->driver.bus = &pci_bus_type;
+	drv->driver.probe = pci_device_probe;
+	drv->driver.remove = pci_device_remove;
+	drv->driver.owner = drv->owner;
+	drv->driver.kobj.ktype = &pci_driver_kobj_type;
+	pci_init_dynids(&drv->dynids);
+
+	/* register with core */
+	error = driver_register(&drv->driver);
+
+	if (!error)
+		pci_populate_driver_dir(drv);
+
+	return error;
+}
+
+/**
+ * pci_unregister_driver - unregister a pci driver
+ * @drv: the driver structure to unregister
+ * 
+ * Deletes the driver structure from the list of registered PCI drivers,
+ * gives it a chance to clean up by calling its remove() function for
+ * each device it was responsible for, and marks those devices as
+ * driverless.
+ */
+
+void
+pci_unregister_driver(struct pci_driver *drv)
+{
+	driver_unregister(&drv->driver);
+	pci_free_dynids(drv);
+}
+
+static struct pci_driver pci_compat_driver = {
+	.name = "compat"
+};
+
+/**
+ * pci_dev_driver - get the pci_driver of a device
+ * @dev: the device to query
+ *
+ * Returns the appropriate pci_driver structure or %NULL if there is no 
+ * registered driver for the device.
+ */
+struct pci_driver *
+pci_dev_driver(const struct pci_dev *dev)
+{
+	if (dev->driver)
+		return dev->driver;
+	else {
+		int i;
+		for(i=0; i<=PCI_ROM_RESOURCE; i++)
+			if (dev->resource[i].flags & IORESOURCE_BUSY)
+				return &pci_compat_driver;
+	}
+	return NULL;
+}
+
+/**
+ * pci_bus_match - Tell if a PCI device structure has a matching PCI device id structure
+ * @ids: array of PCI device id structures to search in
+ * @dev: the PCI device structure to match against
+ * 
+ * Used by a driver to check whether a PCI device present in the
+ * system is in its list of supported devices.Returns the matching
+ * pci_device_id structure or %NULL if there is no match.
+ */
+static int pci_bus_match(struct device * dev, struct device_driver * drv) 
+{
+	const struct pci_dev * pci_dev = to_pci_dev(dev);
+	struct pci_driver * pci_drv = to_pci_driver(drv);
+	const struct pci_device_id * ids = pci_drv->id_table;
+	const struct pci_device_id *found_id;
+
+	if (!ids)
+		return 0;
+
+	found_id = pci_match_device(ids, pci_dev);
+	if (found_id)
+		return 1;
+
+	return pci_bus_match_dynids(pci_dev, pci_drv);
+}
+
+/**
+ * pci_dev_get - increments the reference count of the pci device structure
+ * @dev: the device being referenced
+ *
+ * Each live reference to a device should be refcounted.
+ *
+ * Drivers for PCI devices should normally record such references in
+ * their probe() methods, when they bind to a device, and release
+ * them by calling pci_dev_put(), in their disconnect() methods.
+ *
+ * A pointer to the device with the incremented reference counter is returned.
+ */
+struct pci_dev *pci_dev_get(struct pci_dev *dev)
+{
+	if (dev)
+		get_device(&dev->dev);
+	return dev;
+}
+
+/**
+ * pci_dev_put - release a use of the pci device structure
+ * @dev: device that's been disconnected
+ *
+ * Must be called when a user of a device is finished with it.  When the last
+ * user of the device calls this function, the memory of the device is freed.
+ */
+void pci_dev_put(struct pci_dev *dev)
+{
+	if (dev)
+		put_device(&dev->dev);
+}
+
+#ifndef CONFIG_HOTPLUG
+int pci_hotplug (struct device *dev, char **envp, int num_envp,
+		 char *buffer, int buffer_size)
+{
+	return -ENODEV;
+}
+#endif
+
+struct bus_type pci_bus_type = {
+	.name		= "pci",
+	.match		= pci_bus_match,
+	.hotplug	= pci_hotplug,
+	.suspend	= pci_device_suspend,
+	.resume		= pci_device_resume,
+	.dev_attrs	= pci_dev_attrs,
+};
+
+static int __init pci_driver_init(void)
+{
+	return bus_register(&pci_bus_type);
+}
+
+postcore_initcall(pci_driver_init);
+
+EXPORT_SYMBOL(pci_match_device);
+EXPORT_SYMBOL(pci_register_driver);
+EXPORT_SYMBOL(pci_unregister_driver);
+EXPORT_SYMBOL(pci_dev_driver);
+EXPORT_SYMBOL(pci_bus_type);
+EXPORT_SYMBOL(pci_dev_get);
+EXPORT_SYMBOL(pci_dev_put);
