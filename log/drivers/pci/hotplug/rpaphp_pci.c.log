commit b6eebb093cad0feb56c717611ee0d2d7c66b4ec7
Author: Oliver O'Halloran <oohall@gmail.com>
Date:   Fri Mar 6 18:39:03 2020 +1100

    powerpc/eeh: Make early EEH init pseries specific
    
    The eeh_ops->probe() function is called from two different contexts:
    
    1. On pseries, where we set EEH_PROBE_MODE_DEVTREE, it's called in
       eeh_add_device_early() which is supposed to run before we create
       a pci_dev.
    
    2. On PowerNV, where we set EEH_PROBE_MODE_DEV, it's called in
       eeh_device_add_late() which is supposed to run *after* the
       pci_dev is created.
    
    The "early" probe is required because PAPR requires that we perform an RTAS
    call to enable EEH support on a device before we start interacting with it
    via config space or MMIO. This requirement doesn't exist on PowerNV and
    shoehorning two completely separate initialisation paths into a common
    interface just results in a convoluted code everywhere.
    
    Additionally the early probe requires the probe function to take an pci_dn
    rather than a pci_dev argument. We'd like to make pci_dn a pseries specific
    data structure since there's no real requirement for them on PowerNV. To
    help both goals move the early probe into the pseries containment zone
    so the platform depedence is more explicit.
    
    Reviewed-by: Sam Bobroff <sbobroff@linux.ibm.com>
    Signed-off-by: Oliver O'Halloran <oohall@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20200306073904.4737-5-oohall@gmail.com

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 61ebbd832afb..c380bdacd146 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -96,7 +96,7 @@ int rpaphp_enable_slot(struct slot *slot)
 		}
 
 		if (list_empty(&bus->devices)) {
-			eeh_add_device_tree_early(PCI_DN(slot->dn));
+			pseries_eeh_init_edev_recursive(PCI_DN(slot->dn));
 			pci_hp_add_devices(bus);
 		}
 

commit a4b4f61db8ccbd2744fc00bed3bdd912278f4595
Author: Oliver O'Halloran <oohall@gmail.com>
Date:   Fri Mar 6 18:39:01 2020 +1100

    powerpc/eeh: Do early EEH init only when required
    
    The pci hotplug helper (pci_hp_add_devices()) calls
    eeh_add_device_tree_early() to scan the device-tree for new PCI devices and
    do the early EEH probe before the device is scanned. This early probe is a
    no-op in a lot of cases because:
    
    a) The early init is only required to satisfy a PAPR requirement that EEH
       be configured before we start doing config accesses. On PowerNV it is
       a no-op.
    
    b) It's a no-op for devices that have already had their eeh_dev
       initialised.
    
    There are four callers of pci_hp_add_devices():
    
    1. arch/powerpc/kernel/eeh_driver.c
            Here the hotplug helper is called when re-scanning pci_devs that
            were removed during an EEH recovery pass. The EEH stat for each
            removed device (the eeh_dev) is retained across a recovery pass
            so the early init is a no-op in this case.
    
    2. drivers/pci/hotplug/pnv_php.c
            This is also a no-op since the PowerNV hotplug driver is, suprisingly,
            PowerNV specific.
    
    3. drivers/pci/hotplug/rpaphp_core.c
    4. drivers/pci/hotplug/rpaphp_pci.c
            In these two cases new devices have been hotplugged and FW has
            provided new DT nodes for each. These are the only two cases where
            the EEH we might have new PCI device nodes in the DT so these are
            the only two cases where the early EEH probe needs to be done.
    
    We can move the calls to eeh_add_device_tree_early() to the locations where
    it's needed and remove it from the generic path. This is preparation for
    making the early EEH probe pseries specific.
    
    Reviewed-by: Sam Bobroff <sbobroff@linux.ibm.com>
    Signed-off-by: Oliver O'Halloran <oohall@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20200306073904.4737-3-oohall@gmail.com

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index beca61badeea..61ebbd832afb 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -95,8 +95,10 @@ int rpaphp_enable_slot(struct slot *slot)
 			return -EINVAL;
 		}
 
-		if (list_empty(&bus->devices))
+		if (list_empty(&bus->devices)) {
+			eeh_add_device_tree_early(PCI_DN(slot->dn));
 			pci_hp_add_devices(bus);
+		}
 
 		if (!list_empty(&bus->devices)) {
 			slot->state = CONFIGURED;

commit a7da21613c4efcd4cc0235e6a30bec96ae47c619
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Sep 8 09:59:01 2018 +0200

    PCI: hotplug: Drop hotplug_slot_info
    
    Ever since the PCI hotplug core was introduced in 2002, drivers had to
    allocate and register a struct hotplug_slot_info for every slot:
    https://git.kernel.org/tglx/history/c/a8a2069f432c
    
    Apparently the idea was that drivers furnish the hotplug core with an
    up-to-date card presence status, power status, latch status and
    attention indicator status as well as notify the hotplug core of changes
    thereof.  However only 4 out of 12 hotplug drivers bother to notify the
    hotplug core with pci_hp_change_slot_info() and the hotplug core never
    made any use of the information:  There is just a single macro in
    pci_hotplug_core.c, GET_STATUS(), which uses the hotplug_slot_info if
    the driver lacks the corresponding callback in hotplug_slot_ops.  The
    macro is called when the user reads the attribute via sysfs.
    
    Now, if the callback isn't defined, the attribute isn't exposed in sysfs
    in the first place (see e.g. has_power_file()).  There are only two
    situations when the hotplug_slot_info would actually be accessed:
    
    * If the driver defines ->enable_slot or ->disable_slot but not
      ->get_power_status.
    
    * If the driver defines ->set_attention_status but not
      ->get_attention_status.
    
    There is no driver doing the former and just a single driver doing the
    latter, namely pnv_php.c.  Amend it with a ->get_attention_status
    callback.  With that, the hotplug_slot_info becomes completely unused by
    the PCI hotplug core.  But a few drivers use it internally as a cache:
    
    cpcihp uses it to cache the latch_status and adapter_status.
    cpqhp uses it to cache the adapter_status.
    pnv_php and rpaphp use it to cache the attention_status.
    shpchp uses it to cache all four values.
    
    Amend these drivers to cache the information in their private slot
    struct.  shpchp's slot struct already contains members to cache the
    power_status and adapter_status, so additional members are only needed
    for the other two values.  In the case of cpqphp, the cached value is
    only accessed in a single place, so instead of caching it, read the
    current value from the hardware.
    
    Caution:  acpiphp, cpci, cpqhp, shpchp, asus-wmi and eeepc-laptop
    populate the hotplug_slot_info with initial values on probe.  That code
    is herewith removed.  There is a theoretical chance that the code has
    side effects without which the driver fails to function, e.g. if the
    ACPI method to read the adapter status needs to be executed at least
    once on probe.  That seems unlikely to me, still maintainers should
    review the changes carefully for this possibility.
    
    Rafael adds: "I'm not aware of any case in which it will break anything,
    [...] but if that happens, it may be necessary to add the execution of
    the control methods in question directly to the initialization part."
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>  # drivers/pci/hotplug/rpa*
    Acked-by: Sebastian Ott <sebott@linux.ibm.com>        # drivers/pci/hotplug/s390*
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com> # drivers/platform/x86
    Cc: Len Brown <lenb@kernel.org>
    Cc: Scott Murray <scott@spiteful.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Oliver OHalloran <oliveroh@au1.ibm.com>
    Cc: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Cc: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Cc: Corentin Chary <corentin.chary@gmail.com>
    Cc: Darren Hart <dvhart@infradead.org>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 0aac33e15dab..beca61badeea 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -54,25 +54,21 @@ int rpaphp_get_sensor_state(struct slot *slot, int *state)
  * rpaphp_enable_slot - record slot state, config pci device
  * @slot: target &slot
  *
- * Initialize values in the slot, and the hotplug_slot info
- * structures to indicate if there is a pci card plugged into
- * the slot. If the slot is not empty, run the pcibios routine
+ * Initialize values in the slot structure to indicate if there is a pci card
+ * plugged into the slot. If the slot is not empty, run the pcibios routine
  * to get pcibios stuff correctly set up.
  */
 int rpaphp_enable_slot(struct slot *slot)
 {
 	int rc, level, state;
 	struct pci_bus *bus;
-	struct hotplug_slot_info *info = slot->hotplug_slot->info;
 
-	info->adapter_status = NOT_VALID;
 	slot->state = EMPTY;
 
 	/* Find out if the power is turned on for the slot */
 	rc = rtas_get_power_level(slot->power_domain, &level);
 	if (rc)
 		return rc;
-	info->power_status = level;
 
 	/* Figure out if there is an adapter in the slot */
 	rc = rpaphp_get_sensor_state(slot, &state);
@@ -85,13 +81,11 @@ int rpaphp_enable_slot(struct slot *slot)
 		return -EINVAL;
 	}
 
-	info->adapter_status = EMPTY;
 	slot->bus = bus;
 	slot->pci_devs = &bus->devices;
 
 	/* if there's an adapter in the slot, go add the pci devices */
 	if (state == PRESENT) {
-		info->adapter_status = NOT_CONFIGURED;
 		slot->state = NOT_CONFIGURED;
 
 		/* non-empty slot has to have child */
@@ -105,7 +99,6 @@ int rpaphp_enable_slot(struct slot *slot)
 			pci_hp_add_devices(bus);
 
 		if (!list_empty(&bus->devices)) {
-			info->adapter_status = CONFIGURED;
 			slot->state = CONFIGURED;
 		}
 

commit 736759ef59d86a7bcefb1cdb629abecafc645a46
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 26 14:22:04 2018 -0600

    PCI: Add SPDX GPL-2.0+ to replace GPL v2 or later boilerplate
    
    Add SPDX GPL-2.0+ to all PCI files that specified the GPL and allowed
    either GPL version 2 or any later version.
    
    Remove the boilerplate GPL version 2 or later language, relying on the
    assertion in b24413180f56 ("License cleanup: add SPDX GPL-2.0 license
    identifier to files with no license") that the SPDX identifier may be used
    instead of the full boilerplate text.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 32aabc533be8..0aac33e15dab 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -1,24 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * PCI Hot Plug Controller Driver for RPA-compliant PPC64 platform.
  * Copyright (C) 2003 Linda Xie <lxie@us.ibm.com>
  *
  * All rights reserved.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at
- * your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
- * NON INFRINGEMENT.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
  * Send feedback to <lxie@us.ibm.com>
  *
  */

commit b63773a801ff7f7f047894a9be23616f4491aca8
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:43:21 2017 -0500

    PCI: Convert to using %pOF instead of full_name()
    
    Now that we have a custom printf format specifier, convert users of
    full_name() to use %pOF instead.  This is preparation for removing storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index ea41ea1d3c00..32aabc533be8 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -95,7 +95,7 @@ int rpaphp_enable_slot(struct slot *slot)
 
 	bus = pci_find_bus_by_node(slot->dn);
 	if (!bus) {
-		err("%s: no pci_bus for dn %s\n", __func__, slot->dn->full_name);
+		err("%s: no pci_bus for dn %pOF\n", __func__, slot->dn);
 		return -EINVAL;
 	}
 
@@ -125,7 +125,7 @@ int rpaphp_enable_slot(struct slot *slot)
 
 		if (rpaphp_debug) {
 			struct pci_dev *dev;
-			dbg("%s: pci_devs of slot[%s]\n", __func__, slot->dn->full_name);
+			dbg("%s: pci_devs of slot[%pOF]\n", __func__, slot->dn);
 			list_for_each_entry(dev, &bus->devices, bus_list)
 				dbg("\t%s\n", pci_name(dev));
 		}

commit 3773dd258e91e1e14d95cdf17b9d83a1a7b27af1
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Tue May 3 15:41:38 2016 +1000

    powerpc/pci: Rename pcibios_find_pci_bus()
    
    This renames pcibios_find_pci_bus() to pci_find_bus_by_node() to
    avoid conflicts with those PCI subsystem weak function names, which
    have prefix "pcibios". No logical changes introduced.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Reviewed-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 137a8924adc5..ea41ea1d3c00 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -93,7 +93,7 @@ int rpaphp_enable_slot(struct slot *slot)
 	if (rc)
 		return rc;
 
-	bus = pcibios_find_pci_bus(slot->dn);
+	bus = pci_find_bus_by_node(slot->dn);
 	if (!bus) {
 		err("%s: no pci_bus for dn %s\n", __func__, slot->dn->full_name);
 		return -EINVAL;

commit bd251b893d46240fc12d9fa9316d9ea6ec2b69a7
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Tue May 3 15:41:37 2016 +1000

    powerpc/pci: Rename pcibios_{add, remove}_pci_devices()
    
    This renames pcibios_{add,remove}_pci_devices() to avoid conflicts
    with names of the weak functions in PCI subsystem, which have the
    prefix "pcibios". No logical changes introduced.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Reviewed-By: Alistair Popple <alistair@popple.id.au>
    Reviewed-by: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
    Reviewed-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 7836d6913e67..137a8924adc5 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -116,7 +116,7 @@ int rpaphp_enable_slot(struct slot *slot)
 		}
 
 		if (list_empty(&bus->devices))
-			pcibios_add_pci_devices(bus);
+			pci_hp_add_devices(bus);
 
 		if (!list_empty(&bus->devices)) {
 			info->adapter_status = CONFIGURED;

commit ff3ce480e8b59fbc0f459476fe1b5451464592a5
Author: Bogicevic Sasa <brutallesale@gmail.com>
Date:   Sun Dec 27 13:21:11 2015 -0800

    PCI: Fix all whitespace issues
    
    Fix all whitespace issues (missing or needed whitespace) in all files in
    drivers/pci.  Code is compiled with allyesconfig before and after code
    changes and objects are recorded and checked with objdiff and they are not
    changed after this commit.
    
    Signed-off-by: Bogicevic Sasa <brutallesale@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 9243f3e7a1c9..7836d6913e67 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -126,7 +126,7 @@ int rpaphp_enable_slot(struct slot *slot)
 		if (rpaphp_debug) {
 			struct pci_dev *dev;
 			dbg("%s: pci_devs of slot[%s]\n", __func__, slot->dn->full_name);
-			list_for_each_entry (dev, &bus->devices, bus_list)
+			list_for_each_entry(dev, &bus->devices, bus_list)
 				dbg("\t%s\n", pci_name(dev));
 		}
 	}

commit f7625980f5820edd1a73536e1a03bcbc1f889fec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 14 11:28:18 2013 -0700

    PCI: Fix whitespace, capitalization, and spelling errors
    
    Fix whitespace, capitalization, and spelling errors.  No functional change.
    I know "busses" is not an error, but "buses" was more common, so I used it
    consistently.
    
    Signed-off-by: Marta Rybczynska <rybczynska@gmail.com> (pci_reset_bridge_secondary_bus())
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 513e1e282391..9243f3e7a1c9 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -44,7 +44,7 @@ int rpaphp_get_sensor_state(struct slot *slot, int *state)
 			dbg("%s: slot must be power up to get sensor-state\n",
 			    __func__);
 
-			/* some slots have to be powered up 
+			/* some slots have to be powered up
 			 * before get-sensor will succeed.
 			 */
 			rc = rtas_set_power_level(slot->power_domain, POWER_ON,
@@ -133,4 +133,3 @@ int rpaphp_enable_slot(struct slot *slot)
 
 	return 0;
 }
-

commit 5d9bc1fa47f0c1561f1d7c0bdff5e24860852b42
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Mon Oct 13 09:59:12 2008 -0700

    PCI hotplug: rpaphp: make debug var unique
    
    Change debug variable name to one more unique to this driver.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 5acfd4f3d4cb..513e1e282391 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -123,7 +123,7 @@ int rpaphp_enable_slot(struct slot *slot)
 			slot->state = CONFIGURED;
 		}
 
-		if (debug) {
+		if (rpaphp_debug) {
 			struct pci_dev *dev;
 			dbg("%s: pci_devs of slot[%s]\n", __func__, slot->dn->full_name);
 			list_for_each_entry (dev, &bus->devices, bus_list)

commit 66bef8c059015ba2b36bb5759080336feb01e680
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 19:09:46 2008 -0800

    PCI: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 6571e9b4c2ec..5acfd4f3d4cb 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -42,7 +42,7 @@ int rpaphp_get_sensor_state(struct slot *slot, int *state)
 	if (rc < 0) {
 		if (rc == -EFAULT || rc == -EEXIST) {
 			dbg("%s: slot must be power up to get sensor-state\n",
-			    __FUNCTION__);
+			    __func__);
 
 			/* some slots have to be powered up 
 			 * before get-sensor will succeed.
@@ -51,15 +51,15 @@ int rpaphp_get_sensor_state(struct slot *slot, int *state)
 						  &setlevel);
 			if (rc < 0) {
 				dbg("%s: power on slot[%s] failed rc=%d.\n",
-				    __FUNCTION__, slot->name, rc);
+				    __func__, slot->name, rc);
 			} else {
 				rc = rtas_get_sensor(DR_ENTITY_SENSE,
 						     slot->index, state);
 			}
 		} else if (rc == -ENODEV)
-			info("%s: slot is unusable\n", __FUNCTION__);
+			info("%s: slot is unusable\n", __func__);
 		else
-			err("%s failed to get sensor state\n", __FUNCTION__);
+			err("%s failed to get sensor state\n", __func__);
 	}
 	return rc;
 }
@@ -95,7 +95,7 @@ int rpaphp_enable_slot(struct slot *slot)
 
 	bus = pcibios_find_pci_bus(slot->dn);
 	if (!bus) {
-		err("%s: no pci_bus for dn %s\n", __FUNCTION__, slot->dn->full_name);
+		err("%s: no pci_bus for dn %s\n", __func__, slot->dn->full_name);
 		return -EINVAL;
 	}
 
@@ -111,7 +111,7 @@ int rpaphp_enable_slot(struct slot *slot)
 		/* non-empty slot has to have child */
 		if (!slot->dn->child) {
 			err("%s: slot[%s]'s device_node doesn't have child for adapter\n",
-			    __FUNCTION__, slot->name);
+			    __func__, slot->name);
 			return -EINVAL;
 		}
 
@@ -125,7 +125,7 @@ int rpaphp_enable_slot(struct slot *slot)
 
 		if (debug) {
 			struct pci_dev *dev;
-			dbg("%s: pci_devs of slot[%s]\n", __FUNCTION__, slot->dn->full_name);
+			dbg("%s: pci_devs of slot[%s]\n", __func__, slot->dn->full_name);
 			list_for_each_entry (dev, &bus->devices, bus_list)
 				dbg("\t%s\n", pci_name(dev));
 		}

commit 1b7c9fcaa147662628078c83ecaf1ef2c5c9c9d0
Author: Linas Vepstas <linas@austin.ibm.com>
Date:   Sun Nov 25 23:51:37 2007 -0800

    pci hotplug: fix rpaphp directory naming
    
    Fix presentation of the slot number in the /sys/bus/pci/slots
    directory to match that used in the majority of other drivers.
    
    > Greg said:
    > How is anyone supposed to write sane managability tools in the
    > presence
    > of such anarchy?
    >
    > > ~ # cat /sys/bus/pci/slots/0000:00:02.2/phy_location
    > > U787A.001.DNZ00Z5-P1-C2
    >
    > Right.  This should look like:
    >
    > # cat /sys/bus/pci/slots/U787A.001.DNZ00Z5-P1-C2/address
    > 0000:00:02
    
    This patch implements exactly what you describe. Boot tested.
    I assume you really mean it -- if so, then please review and
    ack the patch !?
    
    I have absolutely no clue if this breaks any existing IBM tools.
    I'm pretty sure it doesn't ... but attention Mike Strosaker! does it?
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Cc: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Cc: <strosake@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 0de84533cd80..6571e9b4c2ec 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -64,19 +64,6 @@ int rpaphp_get_sensor_state(struct slot *slot, int *state)
 	return rc;
 }
 
-static void set_slot_name(struct slot *slot)
-{
-	struct pci_bus *bus = slot->bus;
-	struct pci_dev *bridge;
-
-	bridge = bus->self;
-	if (bridge)
-		strcpy(slot->name, pci_name(bridge));
-	else
-		sprintf(slot->name, "%04x:%02x:00.0", pci_domain_nr(bus),
-			bus->number);
-}
-
 /**
  * rpaphp_enable_slot - record slot state, config pci device
  * @slot: target &slot
@@ -115,7 +102,6 @@ int rpaphp_enable_slot(struct slot *slot)
 	info->adapter_status = EMPTY;
 	slot->bus = bus;
 	slot->pci_devs = &bus->devices;
-	set_slot_name(slot);
 
 	/* if there's an adapter in the slot, go add the pci devices */
 	if (state == PRESENT) {

commit 26e6c66e47fe7f69ef6ddb078e312204a1f17823
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Wed Nov 28 09:04:30 2007 -0800

    pci hotplug: kernel-doc fixes
    
    acpiphp.h: not using kernel-doc, so change /** to /*
    acpiphp_core.c: lots of kernel-doc cleanups
    acpiphp_glue.c: lots of kernel-doc cleanups
    acpiphp_ibm.c: lots of kernel-doc cleanups
    cpqphp_core.c: lots of kernel-doc cleanups
    cpqphp_ctrl.c: lots of kernel-doc cleanups
    fakephp.c:  correct kernel-doc notation
    pciehp_ctrl.c: correct kernel-doc notation
    rpadlpar_core.c: correct function names & kernel-doc notation
    rpaphp_core.c: correct kernel-doc notation
    shpchp_ctrl.c: correct kernel-doc notation
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Kristen Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 54ca8650d511..0de84533cd80 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -79,6 +79,7 @@ static void set_slot_name(struct slot *slot)
 
 /**
  * rpaphp_enable_slot - record slot state, config pci device
+ * @slot: target &slot
  *
  * Initialize values in the slot, and the hotplug_slot info
  * structures to indicate if there is a pci card plugged into

commit fea54b8cc9c8290b4c99d481c3e600c46eb18fd5
Author: Linas Vepstas <linas@austin.ibm.com>
Date:   Fri Apr 13 15:34:20 2007 -0700

    PCI: rpaphp: Rename rpaphp_register_pci_slot() to rpaphp_enable_slot()
    
    Rename rpaphp_register_pci_slot() because its easy to confuse
    with  rpaphp_register_slot() even though it does something
    completely different. Rename it to rpaphp_enable_slot() because
    its almost identical to enbale_slot().
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Cc: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 2e297b9ffa75..54ca8650d511 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -77,7 +77,15 @@ static void set_slot_name(struct slot *slot)
 			bus->number);
 }
 
-int rpaphp_register_pci_slot(struct slot *slot)
+/**
+ * rpaphp_enable_slot - record slot state, config pci device
+ *
+ * Initialize values in the slot, and the hotplug_slot info
+ * structures to indicate if there is a pci card plugged into
+ * the slot. If the slot is not empty, run the pcibios routine
+ * to get pcibios stuff correctly set up.
+ */
+int rpaphp_enable_slot(struct slot *slot)
 {
 	int rc, level, state;
 	struct pci_bus *bus;

commit 6f79eb749df7f1eea76c947f31603ade7d2b5f6d
Author: Linas Vepstas <linas@austin.ibm.com>
Date:   Fri Apr 13 15:34:19 2007 -0700

    PCI: rpaphp: refactor tail call to rpaphp_register_slot()
    
    Eliminate the tail call to rpaphp_register_slot()
    by placing it in the caller. This will help later
    dis-entanglement.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Cc: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 6271be8b155e..2e297b9ffa75 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -136,6 +136,6 @@ int rpaphp_register_pci_slot(struct slot *slot)
 		}
 	}
 
-	return rpaphp_register_slot(slot);
+	return 0;
 }
 

commit 307ff12e35526cfab9f09cafcb17239286e6eb85
Author: Linas Vepstas <linas@austin.ibm.com>
Date:   Fri Apr 13 15:34:17 2007 -0700

    PCI: rpaphp: remove print_slot_pci_funcs()
    
    The debug function print_slot_pci_funcs() is a large wrapper
    around two debug print statements.  Just invoke these directly.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Cc: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 6417b7074ed4..6271be8b155e 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -64,21 +64,6 @@ int rpaphp_get_sensor_state(struct slot *slot, int *state)
 	return rc;
 }
 
-static void print_slot_pci_funcs(struct pci_bus *bus)
-{
-	struct device_node *dn;
-	struct pci_dev *dev;
-
-	dn = pci_bus_to_OF_node(bus);
-	if (!dn)
-		return;
-
-	dbg("%s: pci_devs of slot[%s]\n", __FUNCTION__, dn->full_name);
-	list_for_each_entry (dev, &bus->devices, bus_list)
-		dbg("\t%s\n", pci_name(dev));
-	return;
-}
-
 static void set_slot_name(struct slot *slot)
 {
 	struct pci_bus *bus = slot->bus;
@@ -138,11 +123,17 @@ int rpaphp_register_pci_slot(struct slot *slot)
 		if (list_empty(&bus->devices))
 			pcibios_add_pci_devices(bus);
 
-		print_slot_pci_funcs(bus);
 		if (!list_empty(&bus->devices)) {
 			info->adapter_status = CONFIGURED;
 			slot->state = CONFIGURED;
 		}
+
+		if (debug) {
+			struct pci_dev *dev;
+			dbg("%s: pci_devs of slot[%s]\n", __FUNCTION__, slot->dn->full_name);
+			list_for_each_entry (dev, &bus->devices, bus_list)
+				dbg("\t%s\n", pci_name(dev));
+		}
 	}
 
 	return rpaphp_register_slot(slot);

commit 03a667559138d47cea487823332c4712fc6fbec7
Author: Linas Vepstas <linas@austin.ibm.com>
Date:   Fri Apr 13 15:34:16 2007 -0700

    PCI: rpaphp: Remove setup_pci_slot()
    
    The setup_pci_slot() routine appears to be nothing else than
    a big, complicated wrapper around pcibios_add_pci_devices().
    Remove the wrapping, and call pcibios_add_pci_devices() directly.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Cc: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index b6a991ab9b7e..6417b7074ed4 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -92,64 +92,15 @@ static void set_slot_name(struct slot *slot)
 			bus->number);
 }
 
-static int setup_pci_slot(struct slot *slot)
-{
-	struct device_node *dn = slot->dn;
-	struct pci_bus *bus;
-
-	BUG_ON(!dn);
-	bus = pcibios_find_pci_bus(dn);
-	if (!bus) {
-		err("%s: no pci_bus for dn %s\n", __FUNCTION__, dn->full_name);
-		goto exit_rc;
-	}
-
-	slot->bus = bus;
-	slot->pci_devs = &bus->devices;
-	set_slot_name(slot);
-
-	/* find slot's pci_dev if it's not empty */
-	if (slot->hotplug_slot->info->adapter_status == EMPTY) {
-		slot->state = EMPTY;	/* slot is empty */
-	} else {
-		/* slot is occupied */
-		if (!dn->child) {
-			/* non-empty slot has to have child */
-			err("%s: slot[%s]'s device_node doesn't have child for adapter\n", 
-				__FUNCTION__, slot->name);
-			goto exit_rc;
-		}
-
-		if (slot->hotplug_slot->info->adapter_status == NOT_CONFIGURED) {
-			dbg("%s CONFIGURING pci adapter in slot[%s]\n",  
-				__FUNCTION__, slot->name);
-			pcibios_add_pci_devices(slot->bus);
-
-		} else if (slot->hotplug_slot->info->adapter_status != CONFIGURED) {
-			err("%s: slot[%s]'s adapter_status is NOT_VALID.\n",
-				__FUNCTION__, slot->name);
-			goto exit_rc;
-		}
-		print_slot_pci_funcs(slot->bus);
-		if (!list_empty(slot->pci_devs)) {
-			slot->state = CONFIGURED;
-		} else {
-			/* DLPAR add as opposed to 
-		 	 * boot time */
-			slot->state = NOT_CONFIGURED;
-		}
-	}
-	return 0;
-exit_rc:
-	return -EINVAL;
-}
-
 int rpaphp_register_pci_slot(struct slot *slot)
 {
 	int rc, level, state;
 	struct pci_bus *bus;
 	struct hotplug_slot_info *info = slot->hotplug_slot->info;
 
+	info->adapter_status = NOT_VALID;
+	slot->state = EMPTY;
+
 	/* Find out if the power is turned on for the slot */
 	rc = rtas_get_power_level(slot->power_domain, &level);
 	if (rc)
@@ -157,23 +108,42 @@ int rpaphp_register_pci_slot(struct slot *slot)
 	info->power_status = level;
 
 	/* Figure out if there is an adapter in the slot */
-	info->adapter_status = NOT_VALID;
 	rc = rpaphp_get_sensor_state(slot, &state);
 	if (rc)
 		return rc;
 
-	if (state == EMPTY)
-		info->adapter_status = EMPTY;
-	else if (state == PRESENT) {
-		bus = pcibios_find_pci_bus(slot->dn);
-		if (bus && !list_empty(&bus->devices))
-			info->adapter_status = CONFIGURED;
-		else
-			info->adapter_status = NOT_CONFIGURED;
+	bus = pcibios_find_pci_bus(slot->dn);
+	if (!bus) {
+		err("%s: no pci_bus for dn %s\n", __FUNCTION__, slot->dn->full_name);
+		return -EINVAL;
 	}
 
-	if (setup_pci_slot(slot))
-		return -EINVAL;
+	info->adapter_status = EMPTY;
+	slot->bus = bus;
+	slot->pci_devs = &bus->devices;
+	set_slot_name(slot);
+
+	/* if there's an adapter in the slot, go add the pci devices */
+	if (state == PRESENT) {
+		info->adapter_status = NOT_CONFIGURED;
+		slot->state = NOT_CONFIGURED;
+
+		/* non-empty slot has to have child */
+		if (!slot->dn->child) {
+			err("%s: slot[%s]'s device_node doesn't have child for adapter\n",
+			    __FUNCTION__, slot->name);
+			return -EINVAL;
+		}
+
+		if (list_empty(&bus->devices))
+			pcibios_add_pci_devices(bus);
+
+		print_slot_pci_funcs(bus);
+		if (!list_empty(&bus->devices)) {
+			info->adapter_status = CONFIGURED;
+			slot->state = CONFIGURED;
+		}
+	}
 
 	return rpaphp_register_slot(slot);
 }

commit bf0af511fcc856649a2a39c627828695b580d124
Author: Linas Vepstas <linas@austin.ibm.com>
Date:   Fri Apr 13 15:34:14 2007 -0700

    PCI: rpaphp: Remove another wrappered function
    
    Remove another stove-pipe; this funcion was called from
    two different places, with a compile-time const that is
    then run-time checked to perform two different things.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Cc: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index ba8c83770abe..b6a991ab9b7e 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -64,43 +64,6 @@ int rpaphp_get_sensor_state(struct slot *slot, int *state)
 	return rc;
 }
 
-/**
- * get_pci_adapter_status - get the status of a slot
- * 
- * 0-- slot is empty
- * 1-- adapter is configured
- * 2-- adapter is not configured
- * 3-- not valid
- */
-int rpaphp_get_pci_adapter_status(struct slot *slot, int is_init, u8 * value)
-{
-	struct pci_bus *bus;
-	int state, rc;
-
-	*value = NOT_VALID;
-	rc = rpaphp_get_sensor_state(slot, &state);
-	if (rc)
-		goto exit;
-
- 	if (state == EMPTY)
- 		*value = EMPTY;
- 	else if (state == PRESENT) {
-		if (!is_init) {
-			/* at run-time slot->state can be changed by */
-			/* config/unconfig adapter */
-			*value = slot->state;
-		} else {
-			bus = pcibios_find_pci_bus(slot->dn);
-			if (bus && !list_empty(&bus->devices))
-				*value = CONFIGURED;
-			else
-				*value = NOT_CONFIGURED;
-		}
-	}
-exit:
-	return rc;
-}
-
 static void print_slot_pci_funcs(struct pci_bus *bus)
 {
 	struct device_node *dn;
@@ -183,20 +146,30 @@ static int setup_pci_slot(struct slot *slot)
 
 int rpaphp_register_pci_slot(struct slot *slot)
 {
-	int rc, level;
+	int rc, level, state;
+	struct pci_bus *bus;
 	struct hotplug_slot_info *info = slot->hotplug_slot->info;
 
+	/* Find out if the power is turned on for the slot */
 	rc = rtas_get_power_level(slot->power_domain, &level);
 	if (rc)
 		return rc;
 	info->power_status = level;
 
-	rpaphp_get_pci_adapter_status(slot, 1, &info->adapter_status);
+	/* Figure out if there is an adapter in the slot */
+	info->adapter_status = NOT_VALID;
+	rc = rpaphp_get_sensor_state(slot, &state);
+	if (rc)
+		return rc;
 
-	if (info->adapter_status == NOT_VALID) {
-		err("%s: NOT_VALID: skip dn->full_name=%s\n",
-		    __FUNCTION__, slot->dn->full_name);
-		return -EINVAL;
+	if (state == EMPTY)
+		info->adapter_status = EMPTY;
+	else if (state == PRESENT) {
+		bus = pcibios_find_pci_bus(slot->dn);
+		if (bus && !list_empty(&bus->devices))
+			info->adapter_status = CONFIGURED;
+		else
+			info->adapter_status = NOT_CONFIGURED;
 	}
 
 	if (setup_pci_slot(slot))

commit 427310ff02e80cc80826407c0121cec3694c9e7d
Author: Linas Vepstas <linas@austin.ibm.com>
Date:   Fri Apr 13 15:34:13 2007 -0700

    PCI: rpaphp: Remve another call that is a wrapper
    
    Remove another stovepipe: a call which wraps another call, and
    just adds printks.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Cc: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 881e8073c807..ba8c83770abe 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -183,9 +183,14 @@ static int setup_pci_slot(struct slot *slot)
 
 int rpaphp_register_pci_slot(struct slot *slot)
 {
+	int rc, level;
 	struct hotplug_slot_info *info = slot->hotplug_slot->info;
 
-	rpaphp_get_power_status(slot, &info->power_status);
+	rc = rtas_get_power_level(slot->power_domain, &level);
+	if (rc)
+		return rc;
+	info->power_status = level;
+
 	rpaphp_get_pci_adapter_status(slot, 1, &info->adapter_status);
 
 	if (info->adapter_status == NOT_VALID) {

commit 517d5a0417e19101eaa769039d1921d626ee546c
Author: Linas Vepstas <linas@austin.ibm.com>
Date:   Fri Apr 13 15:34:12 2007 -0700

    PCI: rpaphp: remove a function that does nothing but wrap debug printks
    
    Remove a stove-pipe-- a function that is called from only one place,
    does nothing but wraps another function with debug printk's.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Cc: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index a669ba3f29c9..881e8073c807 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -116,23 +116,6 @@ static void print_slot_pci_funcs(struct pci_bus *bus)
 	return;
 }
 
-static int setup_pci_hotplug_slot_info(struct slot *slot)
-{
-	struct hotplug_slot_info *hotplug_slot_info = slot->hotplug_slot->info;
-
-	dbg("%s Initilize the PCI slot's hotplug->info structure ...\n",
-	    __FUNCTION__);
-	rpaphp_get_power_status(slot, &hotplug_slot_info->power_status);
-	rpaphp_get_pci_adapter_status(slot, 1,
-				      &hotplug_slot_info->adapter_status);
-	if (hotplug_slot_info->adapter_status == NOT_VALID) {
-		err("%s: NOT_VALID: skip dn->full_name=%s\n",
-		    __FUNCTION__, slot->dn->full_name);
-		return -EINVAL;
-	}
-	return 0;
-}
-
 static void set_slot_name(struct slot *slot)
 {
 	struct pci_bus *bus = slot->bus;
@@ -200,14 +183,20 @@ static int setup_pci_slot(struct slot *slot)
 
 int rpaphp_register_pci_slot(struct slot *slot)
 {
-	int rc = -EINVAL;
+	struct hotplug_slot_info *info = slot->hotplug_slot->info;
+
+	rpaphp_get_power_status(slot, &info->power_status);
+	rpaphp_get_pci_adapter_status(slot, 1, &info->adapter_status);
+
+	if (info->adapter_status == NOT_VALID) {
+		err("%s: NOT_VALID: skip dn->full_name=%s\n",
+		    __FUNCTION__, slot->dn->full_name);
+		return -EINVAL;
+	}
 
-	if (setup_pci_hotplug_slot_info(slot))
-		goto exit_rc;
 	if (setup_pci_slot(slot))
-		goto exit_rc;
-	rc = rpaphp_register_slot(slot);
-exit_rc:
-	return rc;
+		return -EINVAL;
+
+	return rpaphp_register_slot(slot);
 }
 

commit 31be7586d1122538747519d786408f142f59dd46
Author: Linas Vepstas <linas@austin.ibm.com>
Date:   Fri Apr 13 15:34:09 2007 -0700

    PCI: rpaphp: match up alloc and free in same routine
    
    The routine that called an alloc should be the same routine that
    calles the mathcing free, if anything in the middle failed.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Cc: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 6f6cbede5135..a669ba3f29c9 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -195,7 +195,6 @@ static int setup_pci_slot(struct slot *slot)
 	}
 	return 0;
 exit_rc:
-	dealloc_slot_struct(slot);
 	return -EINVAL;
 }
 

commit f6afbad82c6b7bab0198442592b110341fb419ba
Author: linas@austin.ibm.com <linas@austin.ibm.com>
Date:   Thu Jan 12 18:31:01 2006 -0600

    [PATCH] powerpc/PCI hotplug: cleanup: add prefix
    
    Minor cleanup. Add the prefix rpaphp_* to several generic-sounding routines.
    Remove rpaphp_remove_slot(), which is a one-liner.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index d1297d070a75..6f6cbede5135 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -199,7 +199,7 @@ static int setup_pci_slot(struct slot *slot)
 	return -EINVAL;
 }
 
-int register_pci_slot(struct slot *slot)
+int rpaphp_register_pci_slot(struct slot *slot)
 {
 	int rc = -EINVAL;
 
@@ -207,7 +207,7 @@ int register_pci_slot(struct slot *slot)
 		goto exit_rc;
 	if (setup_pci_slot(slot))
 		goto exit_rc;
-	rc = register_slot(slot);
+	rc = rpaphp_register_slot(slot);
 exit_rc:
 	return rc;
 }

commit e06b80b78db96ca272db4ec0b26ce1092a1a9704
Author: linas@austin.ibm.com <linas@austin.ibm.com>
Date:   Thu Jan 12 18:28:22 2006 -0600

    [PATCH] powerpc/PCI hotplug: merge rpaphp_enable_pci_slot()
    
    Remove general baroqueness.  The function rpaphp_enable_pci_slot()
    has a fairly simple logic structure, once all of the debug printk's
    are removed. Its called from only one place, and that place also
    has a very simple structure once he printk's are removed.  Merge
    the two together.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index ce7ebec05933..d1297d070a75 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -32,7 +32,7 @@
 #include "../pci.h"		/* for pci_add_new_bus */
 #include "rpaphp.h"
 
-static int rpaphp_get_sensor_state(struct slot *slot, int *state)
+int rpaphp_get_sensor_state(struct slot *slot, int *state)
 {
 	int rc;
 	int setlevel;
@@ -212,31 +212,3 @@ int register_pci_slot(struct slot *slot)
 	return rc;
 }
 
-int rpaphp_enable_pci_slot(struct slot *slot)
-{
-	int retval = 0, state;
-
-	retval = rpaphp_get_sensor_state(slot, &state);
-	if (retval)
-		goto exit;
-	dbg("%s: sensor state[%d]\n", __FUNCTION__, state);
-	/* if slot is not empty, enable the adapter */
-	if (state == PRESENT) {
-		dbg("%s : slot[%s] is occupied.\n", __FUNCTION__, slot->name);
-		pcibios_add_pci_devices(slot->bus);
-		slot->state = CONFIGURED;
-		info("%s: devices in slot[%s] configured\n",
-					__FUNCTION__, slot->name);
-	} else if (state == EMPTY) {
-		dbg("%s : slot[%s] is empty\n", __FUNCTION__, slot->name);
-		slot->state = EMPTY;
-	} else {
-		err("%s: slot[%s] is in invalid state\n", __FUNCTION__,
-		    slot->name);
-		slot->state = NOT_VALID;
-		retval = -EINVAL;
-	}
-exit:
-	dbg("%s - Exit: rc[%d]\n", __FUNCTION__, retval);
-	return retval;
-}

commit 8fe64399cccf8dddcc4e5eaff270a12064f6fe9f
Author: linas@austin.ibm.com <linas@austin.ibm.com>
Date:   Thu Jan 12 18:26:27 2006 -0600

    [PATCH] powerpc/PCI hotplug: de-convolute rpaphp_unconfig_pci_adap
    
    Remove general baroqueness.  The function rpaphp_unconfig_pci_adapter()
    is really just three lines of code, once all the dbg printks are removed.
    And its called in only one place. So replace the call by the thre lines.
    Also, provide proper semaphore locking in the affected function
    disable_slot()
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 1f5e73be47c7..ce7ebec05933 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -116,18 +116,6 @@ static void print_slot_pci_funcs(struct pci_bus *bus)
 	return;
 }
 
-int rpaphp_unconfig_pci_adapter(struct pci_bus *bus)
-{
-	struct pci_dev *dev, *tmp;
-
-	list_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {
-		eeh_remove_bus_device(dev);
-		pci_remove_bus_device(dev);
-	}
-	return 0;
-}
-EXPORT_SYMBOL_GPL(rpaphp_unconfig_pci_adapter);
-
 static int setup_pci_hotplug_slot_info(struct slot *slot)
 {
 	struct hotplug_slot_info *hotplug_slot_info = slot->hotplug_slot->info;

commit 8a85a70db8c65fd1703b4597f72fe6ee25642234
Author: linas@austin.ibm.com <linas@austin.ibm.com>
Date:   Thu Jan 12 18:24:27 2006 -0600

    [PATCH] powerpc/PCI hotplug: remove remove_bus_device()
    
    The function rpaphp_eeh_remove_bus_device() is a dupe of
    eeh_remove_bus_device(). Remove it.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index b93d9c964eea..1f5e73be47c7 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -116,30 +116,12 @@ static void print_slot_pci_funcs(struct pci_bus *bus)
 	return;
 }
 
-static void rpaphp_eeh_remove_bus_device(struct pci_dev *dev)
-{
-	eeh_remove_device(dev);
-	if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {
-		struct pci_bus *bus = dev->subordinate;
-		struct list_head *ln;
-		if (!bus)
-			return; 
-		for (ln = bus->devices.next; ln != &bus->devices; ln = ln->next) {
-			struct pci_dev *pdev = pci_dev_b(ln);
-			if (pdev)
-				rpaphp_eeh_remove_bus_device(pdev);
-		}
-
-	}
-	return;
-}
-
 int rpaphp_unconfig_pci_adapter(struct pci_bus *bus)
 {
 	struct pci_dev *dev, *tmp;
 
 	list_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {
-		rpaphp_eeh_remove_bus_device(dev);
+		eeh_remove_bus_device(dev);
 		pci_remove_bus_device(dev);
 	}
 	return 0;

commit 7fec77e4793f307b30846a3d4015d329ffc0b685
Author: linas@austin.ibm.com <linas@austin.ibm.com>
Date:   Thu Jan 12 18:22:07 2006 -0600

    [PATCH] powerpc/PCI hotplug: merge config_pci_adapter
    
    Remove general baroqueness.  The function rpaphp_config_pci_adapter()
    is really just one line of code, once all the dbg printks are removed.
    And its called in only one place. So replace the call by the one line.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 1a12ebd10e34..b93d9c964eea 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -116,24 +116,6 @@ static void print_slot_pci_funcs(struct pci_bus *bus)
 	return;
 }
 
-int rpaphp_config_pci_adapter(struct pci_bus *bus)
-{
-	struct device_node *dn = pci_bus_to_OF_node(bus);
-	int rc = -ENODEV;
-
-	dbg("Entry %s: slot[%s]\n", __FUNCTION__, dn->full_name);
-	if (!dn)
-		goto exit;
-
-	pcibios_add_pci_devices(bus);
-	print_slot_pci_funcs(bus);
-	rc = 0;
-exit:
-	dbg("Exit %s:  rc=%d\n", __FUNCTION__, rc);
-	return rc;
-}
-EXPORT_SYMBOL_GPL(rpaphp_config_pci_adapter);
-
 static void rpaphp_eeh_remove_bus_device(struct pci_dev *dev)
 {
 	eeh_remove_device(dev);
@@ -225,10 +207,7 @@ static int setup_pci_slot(struct slot *slot)
 		if (slot->hotplug_slot->info->adapter_status == NOT_CONFIGURED) {
 			dbg("%s CONFIGURING pci adapter in slot[%s]\n",  
 				__FUNCTION__, slot->name);
-			if (rpaphp_config_pci_adapter(slot->bus)) {
-				err("%s: CONFIG pci adapter failed\n", __FUNCTION__);
-				goto exit_rc;		
-			}
+			pcibios_add_pci_devices(slot->bus);
 
 		} else if (slot->hotplug_slot->info->adapter_status != CONFIGURED) {
 			err("%s: slot[%s]'s adapter_status is NOT_VALID.\n",
@@ -274,16 +253,10 @@ int rpaphp_enable_pci_slot(struct slot *slot)
 	/* if slot is not empty, enable the adapter */
 	if (state == PRESENT) {
 		dbg("%s : slot[%s] is occupied.\n", __FUNCTION__, slot->name);
-		retval = rpaphp_config_pci_adapter(slot->bus);
-		if (!retval) {
-			slot->state = CONFIGURED;
-			info("%s: devices in slot[%s] configured\n",
+		pcibios_add_pci_devices(slot->bus);
+		slot->state = CONFIGURED;
+		info("%s: devices in slot[%s] configured\n",
 					__FUNCTION__, slot->name);
-		} else {
-			slot->state = NOT_CONFIGURED;
-			dbg("%s: no pci_dev struct for adapter in slot[%s]\n",
-			    __FUNCTION__, slot->name);
-		}
 	} else if (state == EMPTY) {
 		dbg("%s : slot[%s] is empty\n", __FUNCTION__, slot->name);
 		slot->state = EMPTY;

commit eca845c71816669dace4bf1954d9ab276abb0002
Author: linas@austin.ibm.com <linas@austin.ibm.com>
Date:   Thu Jan 12 18:20:26 2006 -0600

    [PATCH] powerpc/PCI hotplug: remove rpaphp_fixup_new_pci_devices()
    
    The function rpaphp_fixup_new_pci_devices() has been migrated to
    pcibios_fixup_new_pci_devices() in
    arch/powerpc/platforms/pseries/pci_dlpar.c
    This patch removes the old version.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index f16d0f9240ee..1a12ebd10e34 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -101,140 +101,6 @@ int rpaphp_get_pci_adapter_status(struct slot *slot, int is_init, u8 * value)
 	return rc;
 }
 
-/* Must be called before pci_bus_add_devices */
-void rpaphp_fixup_new_pci_devices(struct pci_bus *bus, int fix_bus)
-{
-	struct pci_dev *dev;
-
-	list_for_each_entry(dev, &bus->devices, bus_list) {
-		/*
-		 * Skip already-present devices (which are on the
-		 * global device list.)
-		 */
-		if (list_empty(&dev->global_list)) {
-			int i;
-			
-			/* Need to setup IOMMU tables */
-			ppc_md.iommu_dev_setup(dev);
-
-			if(fix_bus)
-				pcibios_fixup_device_resources(dev, bus);
-			pci_read_irq_line(dev);
-			for (i = 0; i < PCI_NUM_RESOURCES; i++) {
-				struct resource *r = &dev->resource[i];
-
-				if (r->parent || !r->start || !r->flags)
-					continue;
-				pci_claim_resource(dev, i);
-			}
-		}
-	}
-}
-
-static void rpaphp_eeh_add_bus_device(struct pci_bus *bus)
-{
-	struct pci_dev *dev;
-
-	list_for_each_entry(dev, &bus->devices, bus_list) {
-		eeh_add_device_late(dev);
-		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {
-			struct pci_bus *subbus = dev->subordinate;
-			if (subbus)
-				rpaphp_eeh_add_bus_device (subbus);
-		}
-	}
-}
-
-static int rpaphp_pci_config_bridge(struct pci_dev *dev)
-{
-	u8 sec_busno;
-	struct pci_bus *child_bus;
-	struct pci_dev *child_dev;
-
-	dbg("Enter %s:  BRIDGE dev=%s\n", __FUNCTION__, pci_name(dev));
-
-	/* get busno of downstream bus */
-	pci_read_config_byte(dev, PCI_SECONDARY_BUS, &sec_busno);
-		
-	/* add to children of PCI bridge dev->bus */
-	child_bus = pci_add_new_bus(dev->bus, dev, sec_busno);
-	if (!child_bus) {
-		err("%s: could not add second bus\n", __FUNCTION__);
-		return -EIO;
-	}
-	sprintf(child_bus->name, "PCI Bus #%02x", child_bus->number);
-	/* do pci_scan_child_bus */
-	pci_scan_child_bus(child_bus);
-
-	list_for_each_entry(child_dev, &child_bus->devices, bus_list) {
-		eeh_add_device_late(child_dev);
-	}
-
-	 /* fixup new pci devices without touching bus struct */
-	rpaphp_fixup_new_pci_devices(child_bus, 0);
-
-	/* Make the discovered devices available */
-	pci_bus_add_devices(child_bus);
-	return 0;
-}
-
-void rpaphp_init_new_devs(struct pci_bus *bus)
-{
-	rpaphp_fixup_new_pci_devices(bus, 0);
-	rpaphp_eeh_add_bus_device(bus);
-}
-EXPORT_SYMBOL_GPL(rpaphp_init_new_devs);
-
-/*****************************************************************************
- rpaphp_pci_config_slot() will  configure all devices under the
- given slot->dn and return the the first pci_dev.
- *****************************************************************************/
-static struct pci_dev *
-rpaphp_pci_config_slot(struct pci_bus *bus)
-{
-	struct device_node *dn = pci_bus_to_OF_node(bus);
-	struct pci_dev *dev = NULL;
-	int slotno;
-	int num;
-
-	dbg("Enter %s: dn=%s bus=%s\n", __FUNCTION__, dn->full_name, bus->name);
-	if (!dn || !dn->child)
-		return NULL;
-
-	if (_machine == PLATFORM_PSERIES_LPAR) {
-		of_scan_bus(dn, bus);
-		if (list_empty(&bus->devices)) {
-			err("%s: No new device found\n", __FUNCTION__);
-			return NULL;
-		}
-
-		rpaphp_init_new_devs(bus);
-		pci_bus_add_devices(bus);
-		dev = list_entry(&bus->devices, struct pci_dev, bus_list);
-	} else {
-		slotno = PCI_SLOT(PCI_DN(dn->child)->devfn);
-
-		/* pci_scan_slot should find all children */
-		num = pci_scan_slot(bus, PCI_DEVFN(slotno, 0));
-		if (num) {
-			rpaphp_fixup_new_pci_devices(bus, 1);
-			pci_bus_add_devices(bus);
-		}
-		if (list_empty(&bus->devices)) {
-			err("%s: No new device found\n", __FUNCTION__);
-			return NULL;
-		}
-		list_for_each_entry(dev, &bus->devices, bus_list) {
-			if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE)
-				rpaphp_pci_config_bridge(dev);
-
-			rpaphp_eeh_add_bus_device(bus);
-		}
-	}
-
-	return dev;
-}
-
 static void print_slot_pci_funcs(struct pci_bus *bus)
 {
 	struct device_node *dn;
@@ -253,19 +119,13 @@ static void print_slot_pci_funcs(struct pci_bus *bus)
 int rpaphp_config_pci_adapter(struct pci_bus *bus)
 {
 	struct device_node *dn = pci_bus_to_OF_node(bus);
-	struct pci_dev *dev;
 	int rc = -ENODEV;
 
 	dbg("Entry %s: slot[%s]\n", __FUNCTION__, dn->full_name);
 	if (!dn)
 		goto exit;
 
-	eeh_add_device_tree_early(dn);
-	dev = rpaphp_pci_config_slot(bus);
-	if (!dev) {
-		err("%s: can't find any devices.\n", __FUNCTION__);
-		goto exit;
-	}
+	pcibios_add_pci_devices(bus);
 	print_slot_pci_funcs(bus);
 	rc = 0;
 exit:

commit 01657868be1c21b2b8b0e683ea24bdcc2331d522
Author: linas@austin.ibm.com <linas@austin.ibm.com>
Date:   Thu Jan 12 18:18:26 2006 -0600

    [PATCH] powerpc/PCI hotplug: remove rpaphp_find_bus()
    
    The function rpaphp_find_pci_bus() has been migrated to
    pcibios_find_pci_bus() in arch/powerpc/platforms/pseries/pci_dlpar.c
    This patch removes the old version.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 396b54b0c847..f16d0f9240ee 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -32,36 +32,6 @@
 #include "../pci.h"		/* for pci_add_new_bus */
 #include "rpaphp.h"
 
-static struct pci_bus *find_bus_among_children(struct pci_bus *bus,
-					struct device_node *dn)
-{
-	struct pci_bus *child = NULL;
-	struct list_head *tmp;
-	struct device_node *busdn;
-
-	busdn = pci_bus_to_OF_node(bus);
-	if (busdn == dn)
-		return bus;
-
-	list_for_each(tmp, &bus->children) {
-		child = find_bus_among_children(pci_bus_b(tmp), dn);
-		if (child)
-			break;
-	}
-	return child;
-}
-
-struct pci_bus *rpaphp_find_pci_bus(struct device_node *dn)
-{
-	struct pci_dn *pdn = dn->data;
-
-	if (!pdn  || !pdn->phb || !pdn->phb->bus)
-		return NULL;
-
-	return find_bus_among_children(pdn->phb->bus, dn);
-}
-EXPORT_SYMBOL_GPL(rpaphp_find_pci_bus);
-
 static int rpaphp_get_sensor_state(struct slot *slot, int *state)
 {
 	int rc;
@@ -120,7 +90,7 @@ int rpaphp_get_pci_adapter_status(struct slot *slot, int is_init, u8 * value)
 			/* config/unconfig adapter */
 			*value = slot->state;
 		} else {
-			bus = rpaphp_find_pci_bus(slot->dn);
+			bus = pcibios_find_pci_bus(slot->dn);
 			if (bus && !list_empty(&bus->devices))
 				*value = CONFIGURED;
 			else
@@ -370,7 +340,7 @@ static int setup_pci_slot(struct slot *slot)
 	struct pci_bus *bus;
 
 	BUG_ON(!dn);
-	bus = rpaphp_find_pci_bus(dn);
+	bus = pcibios_find_pci_bus(dn);
 	if (!bus) {
 		err("%s: no pci_bus for dn %s\n", __FUNCTION__, dn->full_name);
 		goto exit_rc;

commit f5c99dfc11dce8f26c1ceedb6595fa0eac335ea3
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Sun Dec 11 06:42:38 2005 +0100

    [PATCH] PCI: Reduce nr of ptr derefs in drivers/pci/hotplug/rpaphp_pci.c
    
    Here's a small patch to reduce the nr. of pointer dereferences in
    drivers/pci/hotplug/rpaphp_pci.c
    
    Benefits:
     - micro speed optimization due to fewer pointer derefs
     - generated code should be slightly smaller
     - better readability
    
    note: due to lack of both hardware and cross-compile tools this patch is,
          unfortunately, completely untested.
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 6f21c73be3c0..396b54b0c847 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -336,13 +336,14 @@ EXPORT_SYMBOL_GPL(rpaphp_unconfig_pci_adapter);
 
 static int setup_pci_hotplug_slot_info(struct slot *slot)
 {
+	struct hotplug_slot_info *hotplug_slot_info = slot->hotplug_slot->info;
+
 	dbg("%s Initilize the PCI slot's hotplug->info structure ...\n",
 	    __FUNCTION__);
-	rpaphp_get_power_status(slot, &slot->hotplug_slot->info->power_status);
+	rpaphp_get_power_status(slot, &hotplug_slot_info->power_status);
 	rpaphp_get_pci_adapter_status(slot, 1,
-				      &slot->hotplug_slot->info->
-				      adapter_status);
-	if (slot->hotplug_slot->info->adapter_status == NOT_VALID) {
+				      &hotplug_slot_info->adapter_status);
+	if (hotplug_slot_info->adapter_status == NOT_VALID) {
 		err("%s: NOT_VALID: skip dn->full_name=%s\n",
 		    __FUNCTION__, slot->dn->full_name);
 		return -EINVAL;

commit cd5b50be8d8e8e6170da3a261fc625fd603f9dc4
Author: linas@austin.ibm.com <linas@austin.ibm.com>
Date:   Thu Dec 1 18:59:58 2005 -0600

    [PATCH] PCI Hotplug/powerpc: more removal of duplicated code
    
    The RPAPHP code contains two routines that appear to be gratuitous copies
    of very similar pci code.  In particular,
    
       rpaphp_claim_resource ~~ pci_claim_resource
          (there is a minor, non-functional difference)
    
       rpadlpar_claim_one_bus == pcibios_claim_one_bus
          (the code is identical)
    
    This patch removes the rpaphp versions of the code.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index fc2368710cf7..6f21c73be3c0 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -62,28 +62,6 @@ struct pci_bus *rpaphp_find_pci_bus(struct device_node *dn)
 }
 EXPORT_SYMBOL_GPL(rpaphp_find_pci_bus);
 
-int rpaphp_claim_resource(struct pci_dev *dev, int resource)
-{
-	struct resource *res = &dev->resource[resource];
-	struct resource *root = pci_find_parent_resource(dev, res);
-	char *dtype = resource < PCI_BRIDGE_RESOURCES ? "device" : "bridge";
-	int err = -EINVAL;
-
-	if (root != NULL) {
-		err = request_resource(root, res);
-	}
-
-	if (err) {
-		err("PCI: %s region %d of %s %s [%lx:%lx]\n",
-		    root ? "Address space collision on" :
-		    "No parent found for",
-		    resource, dtype, pci_name(dev), res->start, res->end);
-	}
-	return err;
-}
-
-EXPORT_SYMBOL_GPL(rpaphp_claim_resource);
-
 static int rpaphp_get_sensor_state(struct slot *slot, int *state)
 {
 	int rc;
@@ -177,7 +155,7 @@ void rpaphp_fixup_new_pci_devices(struct pci_bus *bus, int fix_bus)
 
 				if (r->parent || !r->start || !r->flags)
 					continue;
-				rpaphp_claim_resource(dev, i);
+				pci_claim_resource(dev, i);
 			}
 		}
 	}

commit d681db4aed4453c7d34adfbb64956271186514e9
Author: linas@austin.ibm.com <linas@austin.ibm.com>
Date:   Thu Dec 1 18:56:14 2005 -0600

    [PATCH] PCI Hotplug/powerpc: remove duplicated code
    
    The RPAPHP code contains a routine that duplicates some existing code.
    This patch removes the rpaphp version of the code.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 4b35097b3d9f..fc2368710cf7 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -287,18 +287,6 @@ rpaphp_pci_config_slot(struct pci_bus *bus)
 	return dev;
 }
 
-void rpaphp_eeh_init_nodes(struct device_node *dn)
-{
-	struct device_node *sib;
-
-	for (sib = dn->child; sib; sib = sib->sibling) 
-		rpaphp_eeh_init_nodes(sib);
-	eeh_add_device_early(dn);
-	return;
-	
-}
-EXPORT_SYMBOL_GPL(rpaphp_eeh_init_nodes);
-
 static void print_slot_pci_funcs(struct pci_bus *bus)
 {
 	struct device_node *dn;
@@ -324,7 +312,7 @@ int rpaphp_config_pci_adapter(struct pci_bus *bus)
 	if (!dn)
 		goto exit;
 
-	rpaphp_eeh_init_nodes(dn);
+	eeh_add_device_tree_early(dn);
 	dev = rpaphp_pci_config_slot(bus);
 	if (!dev) {
 		err("%s: can't find any devices.\n", __FUNCTION__);

commit 89a071b80767c3a7ed56e13ae5e810f751b19eeb
Author: akpm@osdl.org <akpm@osdl.org>
Date:   Sun Nov 13 16:06:33 2005 -0800

    [PATCH] rpaphp_pci build fix
    
    (akpm: _machine is some ppc64 thing - this is a powerpc-only driver)
    
    Signed-off-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index a7859a84d1ae..4b35097b3d9f 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -253,7 +253,7 @@ rpaphp_pci_config_slot(struct pci_bus *bus)
 	if (!dn || !dn->child)
 		return NULL;
 
-	if (systemcfg->platform == PLATFORM_PSERIES_LPAR) {
+	if (_machine == PLATFORM_PSERIES_LPAR) {
 		of_scan_bus(dn, bus);
 		if (list_empty(&bus->devices)) {
 			err("%s: No new device found\n", __FUNCTION__);

commit 5fa80fcdca9d20d30c9ecec30d4dbff4ed93a5c6
Author: John Rose <johnrose@austin.ibm.com>
Date:   Fri Nov 4 15:38:50 2005 -0600

    [PATCH] dlpar regression for ppc64 - probe change
    
    This patch contains the driver bits for enabling DLPAR and PCI Hotplug
    for the new OF-based PCI probe.  This functionality was regressed when
    the new PCI approach was introduced.  Please apply if appropriate.
    
    Signed-off-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index f7c12d7dfcfc..a7859a84d1ae 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -154,8 +154,7 @@ int rpaphp_get_pci_adapter_status(struct slot *slot, int is_init, u8 * value)
 }
 
 /* Must be called before pci_bus_add_devices */
-static void 
-rpaphp_fixup_new_pci_devices(struct pci_bus *bus, int fix_bus)
+void rpaphp_fixup_new_pci_devices(struct pci_bus *bus, int fix_bus)
 {
 	struct pci_dev *dev;
 
@@ -184,6 +183,20 @@ rpaphp_fixup_new_pci_devices(struct pci_bus *bus, int fix_bus)
 	}
 }
 
+static void rpaphp_eeh_add_bus_device(struct pci_bus *bus)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		eeh_add_device_late(dev);
+		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {
+			struct pci_bus *subbus = dev->subordinate;
+			if (subbus)
+				rpaphp_eeh_add_bus_device (subbus);
+		}
+	}
+}
+
 static int rpaphp_pci_config_bridge(struct pci_dev *dev)
 {
 	u8 sec_busno;
@@ -217,6 +230,13 @@ static int rpaphp_pci_config_bridge(struct pci_dev *dev)
 	return 0;
 }
 
+void rpaphp_init_new_devs(struct pci_bus *bus)
+{
+	rpaphp_fixup_new_pci_devices(bus, 0);
+	rpaphp_eeh_add_bus_device(bus);
+}
+EXPORT_SYMBOL_GPL(rpaphp_init_new_devs);
+
 /*****************************************************************************
  rpaphp_pci_config_slot() will  configure all devices under the
  given slot->dn and return the the first pci_dev.
@@ -233,36 +253,51 @@ rpaphp_pci_config_slot(struct pci_bus *bus)
 	if (!dn || !dn->child)
 		return NULL;
 
-	slotno = PCI_SLOT(PCI_DN(dn->child)->devfn);
+	if (systemcfg->platform == PLATFORM_PSERIES_LPAR) {
+		of_scan_bus(dn, bus);
+		if (list_empty(&bus->devices)) {
+			err("%s: No new device found\n", __FUNCTION__);
+			return NULL;
+		}
 
-	/* pci_scan_slot should find all children */
-	num = pci_scan_slot(bus, PCI_DEVFN(slotno, 0));
-	if (num) {
-		rpaphp_fixup_new_pci_devices(bus, 1);
+		rpaphp_init_new_devs(bus);
 		pci_bus_add_devices(bus);
-	}
-	if (list_empty(&bus->devices)) {
-		err("%s: No new device found\n", __FUNCTION__);
-		return NULL;
-	}
-	list_for_each_entry(dev, &bus->devices, bus_list) {
-		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE)
-			rpaphp_pci_config_bridge(dev);
+		dev = list_entry(&bus->devices, struct pci_dev, bus_list);
+	} else {
+		slotno = PCI_SLOT(PCI_DN(dn->child)->devfn);
+
+		/* pci_scan_slot should find all children */
+		num = pci_scan_slot(bus, PCI_DEVFN(slotno, 0));
+		if (num) {
+			rpaphp_fixup_new_pci_devices(bus, 1);
+			pci_bus_add_devices(bus);
+		}
+		if (list_empty(&bus->devices)) {
+			err("%s: No new device found\n", __FUNCTION__);
+			return NULL;
+		}
+		list_for_each_entry(dev, &bus->devices, bus_list) {
+			if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE)
+				rpaphp_pci_config_bridge(dev);
+
+			rpaphp_eeh_add_bus_device(bus);
+		}
 	}
 
 	return dev;
 }
 
-static void enable_eeh(struct device_node *dn)
+void rpaphp_eeh_init_nodes(struct device_node *dn)
 {
 	struct device_node *sib;
 
 	for (sib = dn->child; sib; sib = sib->sibling) 
-		enable_eeh(sib);
+		rpaphp_eeh_init_nodes(sib);
 	eeh_add_device_early(dn);
 	return;
 	
 }
+EXPORT_SYMBOL_GPL(rpaphp_eeh_init_nodes);
 
 static void print_slot_pci_funcs(struct pci_bus *bus)
 {
@@ -289,7 +324,7 @@ int rpaphp_config_pci_adapter(struct pci_bus *bus)
 	if (!dn)
 		goto exit;
 
-	enable_eeh(dn);
+	rpaphp_eeh_init_nodes(dn);
 	dev = rpaphp_pci_config_slot(bus);
 	if (!dev) {
 		err("%s: can't find any devices.\n", __FUNCTION__);
@@ -331,6 +366,7 @@ int rpaphp_unconfig_pci_adapter(struct pci_bus *bus)
 	}
 	return 0;
 }
+EXPORT_SYMBOL_GPL(rpaphp_unconfig_pci_adapter);
 
 static int setup_pci_hotplug_slot_info(struct slot *slot)
 {
@@ -444,8 +480,8 @@ int rpaphp_enable_pci_slot(struct slot *slot)
 		retval = rpaphp_config_pci_adapter(slot->bus);
 		if (!retval) {
 			slot->state = CONFIGURED;
-			dbg("%s: PCI devices in slot[%s] has been configured\n", 
-				__FUNCTION__, slot->name);
+			info("%s: devices in slot[%s] configured\n",
+					__FUNCTION__, slot->name);
 		} else {
 			slot->state = NOT_CONFIGURED;
 			dbg("%s: no pci_dev struct for adapter in slot[%s]\n",

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 46c157d26a2f..f7c12d7dfcfc 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -23,11 +23,13 @@
  *
  */
 #include <linux/pci.h>
+#include <linux/string.h>
+
 #include <asm/pci-bridge.h>
 #include <asm/rtas.h>
 #include <asm/machdep.h>
-#include "../pci.h"		/* for pci_add_new_bus */
 
+#include "../pci.h"		/* for pci_add_new_bus */
 #include "rpaphp.h"
 
 static struct pci_bus *find_bus_among_children(struct pci_bus *bus,

commit 934199e95d6ac28f42686fe3009877eff33e06c3
Author: linas <linas@austin.ibm.com>
Date:   Wed Sep 28 19:33:38 2005 -0500

    [PATCH] ppc64 PCI Hotplug: cleanup unsymmetric API routines
    
    This is a minor patch to the ppc64 PCI hotplug code; it makes the call to
    rpaphp_unconfig_pci_adapter() symmetric with respect to the call to
    rpaphp_config_pci_adapter().  I discussed this with John Rose, who
    had provided the last round of changes for these functions; he
    appearently had this patch but somehow failed to mail it out.
    
    Tested. (added/removed device).
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    
     drivers/pci/hotplug/rpaphp.h      |    3 ++-
     drivers/pci/hotplug/rpaphp_core.c |    5 ++++-
     drivers/pci/hotplug/rpaphp_pci.c  |   11 +++--------
     3 files changed, 9 insertions(+), 10 deletions(-)

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 49e4d10a6488..46c157d26a2f 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -319,20 +319,15 @@ static void rpaphp_eeh_remove_bus_device(struct pci_dev *dev)
 	return;
 }
 
-int rpaphp_unconfig_pci_adapter(struct slot *slot)
+int rpaphp_unconfig_pci_adapter(struct pci_bus *bus)
 {
 	struct pci_dev *dev, *tmp;
-	int retval = 0;
 
-	list_for_each_entry_safe(dev, tmp, slot->pci_devs, bus_list) {
+	list_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {
 		rpaphp_eeh_remove_bus_device(dev);
 		pci_remove_bus_device(dev);
 	}
-
-	slot->state = NOT_CONFIGURED;
-	info("%s: devices in slot[%s] unconfigured.\n", __FUNCTION__,
-	     slot->name);
-	return retval;
+	return 0;
 }
 
 static int setup_pci_hotplug_slot_info(struct slot *slot)

commit 1635317facea3094ddf34082cd86797efb1d9f7e
Author: Paul Mackerras <paulus@samba.org>
Date:   Tue Sep 6 13:17:54 2005 +1000

    [PATCH] Separate pci bits out of struct device_node
    
    This patch pulls the PCI-related junk out of struct device_node and
    puts it in a separate structure, struct pci_dn.  The device_node now
    just has a void * pointer in it, which points to a struct pci_dn for
    nodes that represent PCI devices.  It could potentially be used in
    future for device-specific data for other sorts of devices, such as
    virtual I/O devices.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 17a0279ebcb9..49e4d10a6488 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -51,10 +51,12 @@ static struct pci_bus *find_bus_among_children(struct pci_bus *bus,
 
 struct pci_bus *rpaphp_find_pci_bus(struct device_node *dn)
 {
-	if (!dn->phb || !dn->phb->bus)
+	struct pci_dn *pdn = dn->data;
+
+	if (!pdn  || !pdn->phb || !pdn->phb->bus)
 		return NULL;
 
-	return find_bus_among_children(dn->phb->bus, dn);
+	return find_bus_among_children(pdn->phb->bus, dn);
 }
 EXPORT_SYMBOL_GPL(rpaphp_find_pci_bus);
 
@@ -229,7 +231,7 @@ rpaphp_pci_config_slot(struct pci_bus *bus)
 	if (!dn || !dn->child)
 		return NULL;
 
-	slotno = PCI_SLOT(dn->child->devfn);
+	slotno = PCI_SLOT(PCI_DN(dn->child)->devfn);
 
 	/* pci_scan_slot should find all children */
 	num = pci_scan_slot(bus, PCI_DEVFN(slotno, 0));

commit 56d8456b06ad1316bff3c75caed5e06e786f20d8
Author: John Rose <johnrose@austin.ibm.com>
Date:   Mon Jul 25 10:17:03 2005 -0500

    [PATCH] PCI Hotplug: rpaphp: Purify hotplug
    
    Currently rpaphp registers the following bus types as hotplug slots:
    1) Actual PCI Hotplug slots
    2) Embedded/Internal PCI slots
    3) PCI Host Bridges
    
    The second and third bus types are not actually direct parents of
    removable adapters.  As such, the rpaphp has special case code to fake
    results for attributes like power, adapter status, etc.  This patch
    removes types 2 and 3 from the rpaphp module.
    
    This patch also changes the DLPAR module so that slots can be
    DLPAR-added/removed without having been designated as hotplug-capable.
    
    Signed-off-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index f2f1cd0f941a..17a0279ebcb9 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -49,13 +49,14 @@ static struct pci_bus *find_bus_among_children(struct pci_bus *bus,
 	return child;
 }
 
-static struct pci_bus *rpaphp_find_pci_bus(struct device_node *dn)
+struct pci_bus *rpaphp_find_pci_bus(struct device_node *dn)
 {
 	if (!dn->phb || !dn->phb->bus)
 		return NULL;
 
 	return find_bus_among_children(dn->phb->bus, dn);
 }
+EXPORT_SYMBOL_GPL(rpaphp_find_pci_bus);
 
 int rpaphp_claim_resource(struct pci_dev *dev, int resource)
 {
@@ -129,10 +130,8 @@ int rpaphp_get_pci_adapter_status(struct slot *slot, int is_init, u8 * value)
 	if (rc)
 		goto exit;
 
- 	if ((state == EMPTY) || (slot->type == PHB)) {
- 		dbg("slot is empty\n");
+ 	if (state == EMPTY)
  		*value = EMPTY;
- 	}
  	else if (state == PRESENT) {
 		if (!is_init) {
 			/* at run-time slot->state can be changed by */
@@ -423,10 +422,6 @@ int register_pci_slot(struct slot *slot)
 {
 	int rc = -EINVAL;
 
-	if ((slot->type == EMBEDDED) || (slot->type == PHB))
-		slot->removable = 0;
-	else
-		slot->removable = 1;
 	if (setup_pci_hotplug_slot_info(slot))
 		goto exit_rc;
 	if (setup_pci_slot(slot))

commit 940903c5a5a906c622a79b3101586deb1a1b3480
Author: John Rose <johnrose@austin.ibm.com>
Date:   Mon Jul 25 10:16:58 2005 -0500

    [PATCH] PCI Hotplug: rpaphp: Export slot enable
    
    This patch exports rpaphp_config_pci_adapter() for use by the rpadlpar
    module.  It also changes this function by removing any dependencies on
    struct slot.  The patch also changes the RPA DLPAR-add path to enable
    newly-added slots in a separate step from that which registers them as
    hotplug slots.
    
    Signed-off-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 30a892ca4b37..f2f1cd0f941a 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -219,14 +219,15 @@ static int rpaphp_pci_config_bridge(struct pci_dev *dev)
  given slot->dn and return the the first pci_dev.
  *****************************************************************************/
 static struct pci_dev *
-rpaphp_pci_config_slot(struct device_node *dn, struct pci_bus *bus)
+rpaphp_pci_config_slot(struct pci_bus *bus)
 {
+	struct device_node *dn = pci_bus_to_OF_node(bus);
 	struct pci_dev *dev = NULL;
 	int slotno;
 	int num;
 
 	dbg("Enter %s: dn=%s bus=%s\n", __FUNCTION__, dn->full_name, bus->name);
-	if (!dn->child)
+	if (!dn || !dn->child)
 		return NULL;
 
 	slotno = PCI_SLOT(dn->child->devfn);
@@ -260,35 +261,44 @@ static void enable_eeh(struct device_node *dn)
 	
 }
 
-static void print_slot_pci_funcs(struct slot *slot)
+static void print_slot_pci_funcs(struct pci_bus *bus)
 {
+	struct device_node *dn;
 	struct pci_dev *dev;
 
-	dbg("%s: pci_devs of slot[%s]\n", __FUNCTION__, slot->name);
-	list_for_each_entry (dev, slot->pci_devs, bus_list)
+	dn = pci_bus_to_OF_node(bus);
+	if (!dn)
+		return;
+
+	dbg("%s: pci_devs of slot[%s]\n", __FUNCTION__, dn->full_name);
+	list_for_each_entry (dev, &bus->devices, bus_list)
 		dbg("\t%s\n", pci_name(dev));
 	return;
 }
 
-static int rpaphp_config_pci_adapter(struct slot *slot)
+int rpaphp_config_pci_adapter(struct pci_bus *bus)
 {
+	struct device_node *dn = pci_bus_to_OF_node(bus);
 	struct pci_dev *dev;
 	int rc = -ENODEV;
 
-	dbg("Entry %s: slot[%s]\n", __FUNCTION__, slot->name);
+	dbg("Entry %s: slot[%s]\n", __FUNCTION__, dn->full_name);
+	if (!dn)
+		goto exit;
 
-	enable_eeh(slot->dn);
-	dev = rpaphp_pci_config_slot(slot->dn, slot->bus);
+	enable_eeh(dn);
+	dev = rpaphp_pci_config_slot(bus);
 	if (!dev) {
 		err("%s: can't find any devices.\n", __FUNCTION__);
 		goto exit;
 	}
-	print_slot_pci_funcs(slot);
+	print_slot_pci_funcs(bus);
 	rc = 0;
 exit:
 	dbg("Exit %s:  rc=%d\n", __FUNCTION__, rc);
 	return rc;
 }
+EXPORT_SYMBOL_GPL(rpaphp_config_pci_adapter);
 
 static void rpaphp_eeh_remove_bus_device(struct pci_dev *dev)
 {
@@ -384,7 +394,7 @@ static int setup_pci_slot(struct slot *slot)
 		if (slot->hotplug_slot->info->adapter_status == NOT_CONFIGURED) {
 			dbg("%s CONFIGURING pci adapter in slot[%s]\n",  
 				__FUNCTION__, slot->name);
-			if (rpaphp_config_pci_adapter(slot)) {
+			if (rpaphp_config_pci_adapter(slot->bus)) {
 				err("%s: CONFIG pci adapter failed\n", __FUNCTION__);
 				goto exit_rc;		
 			}
@@ -394,7 +404,7 @@ static int setup_pci_slot(struct slot *slot)
 				__FUNCTION__, slot->name);
 			goto exit_rc;
 		}
-		print_slot_pci_funcs(slot);
+		print_slot_pci_funcs(slot->bus);
 		if (!list_empty(slot->pci_devs)) {
 			slot->state = CONFIGURED;
 		} else {
@@ -437,7 +447,7 @@ int rpaphp_enable_pci_slot(struct slot *slot)
 	/* if slot is not empty, enable the adapter */
 	if (state == PRESENT) {
 		dbg("%s : slot[%s] is occupied.\n", __FUNCTION__, slot->name);
-		retval = rpaphp_config_pci_adapter(slot);
+		retval = rpaphp_config_pci_adapter(slot->bus);
 		if (!retval) {
 			slot->state = CONFIGURED;
 			dbg("%s: PCI devices in slot[%s] has been configured\n", 

commit 0945cd5f908a09ad99bf42d7ded16f26f24f317d
Author: John Rose <johnrose@austin.ibm.com>
Date:   Mon Jul 25 10:16:53 2005 -0500

    [PATCH] PCI Hotplug: rpaphp: Remove rpaphp_find_pci
    
    The rpaphp module currently uses a fragile method to find a pci device
    by its device node.  This function is unnecessary, so this patch scraps
    it.
    
    Signed-off-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 54fff5fb0094..30a892ca4b37 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -30,22 +30,7 @@
 
 #include "rpaphp.h"
 
-struct pci_dev *rpaphp_find_pci_dev(struct device_node *dn)
-{
-	struct pci_dev *dev = NULL;
-	char bus_id[BUS_ID_SIZE];
-
-	sprintf(bus_id, "%04x:%02x:%02x.%d", dn->phb->global_number,
-		dn->busno, PCI_SLOT(dn->devfn), PCI_FUNC(dn->devfn));
-	for_each_pci_dev(dev) {
-		if (!strcmp(pci_name(dev), bus_id)) {
-			break;
-		}
-	}
-	return dev;
-}
-
-struct pci_bus *find_bus_among_children(struct pci_bus *bus,
+static struct pci_bus *find_bus_among_children(struct pci_bus *bus,
 					struct device_node *dn)
 {
 	struct pci_bus *child = NULL;
@@ -64,15 +49,14 @@ struct pci_bus *find_bus_among_children(struct pci_bus *bus,
 	return child;
 }
 
-struct pci_bus *rpaphp_find_pci_bus(struct device_node *dn)
+static struct pci_bus *rpaphp_find_pci_bus(struct device_node *dn)
 {
-	BUG_ON(!dn->phb || !dn->phb->bus);
+	if (!dn->phb || !dn->phb->bus)
+		return NULL;
 
 	return find_bus_among_children(dn->phb->bus, dn);
 }
 
-EXPORT_SYMBOL_GPL(rpaphp_find_pci_dev);
-
 int rpaphp_claim_resource(struct pci_dev *dev, int resource)
 {
 	struct resource *res = &dev->resource[resource];
@@ -137,9 +121,8 @@ static int rpaphp_get_sensor_state(struct slot *slot, int *state)
  */
 int rpaphp_get_pci_adapter_status(struct slot *slot, int is_init, u8 * value)
 {
+	struct pci_bus *bus;
 	int state, rc;
- 	struct device_node *child_dn;
- 	struct pci_dev *child_dev = NULL;
 
 	*value = NOT_VALID;
 	rc = rpaphp_get_sensor_state(slot, &state);
@@ -156,20 +139,11 @@ int rpaphp_get_pci_adapter_status(struct slot *slot, int is_init, u8 * value)
 			/* config/unconfig adapter */
 			*value = slot->state;
 		} else {
- 			child_dn = slot->dn->child;
- 			if (child_dn)
- 				child_dev = rpaphp_find_pci_dev(child_dn);
-
- 			if (child_dev)
- 				*value = CONFIGURED;
- 			else if (!child_dn)
-				dbg("%s: %s is not valid OFDT node\n",
-				    __FUNCTION__, slot->dn->full_name);
-			else {
-				err("%s: can't find pdev of adapter in slot[%s]\n", 
-					__FUNCTION__, slot->dn->full_name);
+			bus = rpaphp_find_pci_bus(slot->dn);
+			if (bus && !list_empty(&bus->devices))
+				*value = CONFIGURED;
+			else
 				*value = NOT_CONFIGURED;
-			}
 		}
 	}
 exit:
@@ -252,24 +226,26 @@ rpaphp_pci_config_slot(struct device_node *dn, struct pci_bus *bus)
 	int num;
 
 	dbg("Enter %s: dn=%s bus=%s\n", __FUNCTION__, dn->full_name, bus->name);
+	if (!dn->child)
+		return NULL;
 
-	if (dn->child) {
-		slotno = PCI_SLOT(dn->child->devfn);
+	slotno = PCI_SLOT(dn->child->devfn);
 
-		/* pci_scan_slot should find all children */
-		num = pci_scan_slot(bus, PCI_DEVFN(slotno, 0));
-		if (num) {
-			rpaphp_fixup_new_pci_devices(bus, 1);
-			pci_bus_add_devices(bus);
-		}
-		dev = rpaphp_find_pci_dev(dn->child);
-		if (!dev) {
-			err("No new device found\n");
-			return NULL;
-		}
+	/* pci_scan_slot should find all children */
+	num = pci_scan_slot(bus, PCI_DEVFN(slotno, 0));
+	if (num) {
+		rpaphp_fixup_new_pci_devices(bus, 1);
+		pci_bus_add_devices(bus);
+	}
+	if (list_empty(&bus->devices)) {
+		err("%s: No new device found\n", __FUNCTION__);
+		return NULL;
+	}
+	list_for_each_entry(dev, &bus->devices, bus_list) {
 		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE)
 			rpaphp_pci_config_bridge(dev);
 	}
+
 	return dev;
 }
 

commit 9c209c919df95f83aa042b3352c43841ad15a02b
Author: John Rose <johnrose@austin.ibm.com>
Date:   Mon Jul 25 11:13:38 2005 -0500

    [PATCH] PCI Hotplug: rpaphp: Change slot pci reference
    
    The slot structure in the rpaphp module currently references the PCI
    contents of the slot using the PCI device of the parent bridge.  This
    is unnecessary, since the module is actually interested in the
    subordinate bus of the bridge.  The dependency on a PCI bridge device
    also prohibits the module from registering hotplug slots that have a
    root bridge as a parent, since root bridges on PPC64 don't have PCI
    devices.
    
    This patch changes struct slot to reference the PCI subsystem using a
    pci_bus rather than a pci_dev.
    
    Signed-off-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index 30d10fcc24b2..54fff5fb0094 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -45,6 +45,32 @@ struct pci_dev *rpaphp_find_pci_dev(struct device_node *dn)
 	return dev;
 }
 
+struct pci_bus *find_bus_among_children(struct pci_bus *bus,
+					struct device_node *dn)
+{
+	struct pci_bus *child = NULL;
+	struct list_head *tmp;
+	struct device_node *busdn;
+
+	busdn = pci_bus_to_OF_node(bus);
+	if (busdn == dn)
+		return bus;
+
+	list_for_each(tmp, &bus->children) {
+		child = find_bus_among_children(pci_bus_b(tmp), dn);
+		if (child)
+			break;
+	}
+	return child;
+}
+
+struct pci_bus *rpaphp_find_pci_bus(struct device_node *dn)
+{
+	BUG_ON(!dn->phb || !dn->phb->bus);
+
+	return find_bus_among_children(dn->phb->bus, dn);
+}
+
 EXPORT_SYMBOL_GPL(rpaphp_find_pci_dev);
 
 int rpaphp_claim_resource(struct pci_dev *dev, int resource)
@@ -69,11 +95,6 @@ int rpaphp_claim_resource(struct pci_dev *dev, int resource)
 
 EXPORT_SYMBOL_GPL(rpaphp_claim_resource);
 
-static struct pci_dev *rpaphp_find_bridge_pdev(struct slot *slot)
-{
-	return rpaphp_find_pci_dev(slot->dn);
-}
-
 static int rpaphp_get_sensor_state(struct slot *slot, int *state)
 {
 	int rc;
@@ -226,20 +247,22 @@ static int rpaphp_pci_config_bridge(struct pci_dev *dev)
 static struct pci_dev *
 rpaphp_pci_config_slot(struct device_node *dn, struct pci_bus *bus)
 {
-	struct device_node *eads_first_child = dn->child;
 	struct pci_dev *dev = NULL;
+	int slotno;
 	int num;
 
 	dbg("Enter %s: dn=%s bus=%s\n", __FUNCTION__, dn->full_name, bus->name);
 
-	if (eads_first_child) {
-		/* pci_scan_slot should find all children of EADs */
-		num = pci_scan_slot(bus, PCI_DEVFN(PCI_SLOT(eads_first_child->devfn), 0));
+	if (dn->child) {
+		slotno = PCI_SLOT(dn->child->devfn);
+
+		/* pci_scan_slot should find all children */
+		num = pci_scan_slot(bus, PCI_DEVFN(slotno, 0));
 		if (num) {
 			rpaphp_fixup_new_pci_devices(bus, 1);
 			pci_bus_add_devices(bus);
 		}
-		dev = rpaphp_find_pci_dev(eads_first_child);
+		dev = rpaphp_find_pci_dev(dn->child);
 		if (!dev) {
 			err("No new device found\n");
 			return NULL;
@@ -273,31 +296,19 @@ static void print_slot_pci_funcs(struct slot *slot)
 
 static int rpaphp_config_pci_adapter(struct slot *slot)
 {
-	struct pci_bus *pci_bus;
 	struct pci_dev *dev;
 	int rc = -ENODEV;
 
 	dbg("Entry %s: slot[%s]\n", __FUNCTION__, slot->name);
 
-	if (slot->bridge) {
-
-		pci_bus = slot->bridge->subordinate;
-		if (!pci_bus) {
-			err("%s: can't find bus structure\n", __FUNCTION__);
-			goto exit;
-		}
-		enable_eeh(slot->dn);
-		dev = rpaphp_pci_config_slot(slot->dn, pci_bus);
-		if (!dev) {
-			err("%s: can't find any devices.\n", __FUNCTION__);
-			goto exit;
-		}
-		print_slot_pci_funcs(slot);
-		rc = 0;
-	} else {
-		/* slot is not enabled */
-		err("slot doesn't have pci_dev structure\n");
+	enable_eeh(slot->dn);
+	dev = rpaphp_pci_config_slot(slot->dn, slot->bus);
+	if (!dev) {
+		err("%s: can't find any devices.\n", __FUNCTION__);
+		goto exit;
 	}
+	print_slot_pci_funcs(slot);
+	rc = 0;
 exit:
 	dbg("Exit %s:  rc=%d\n", __FUNCTION__, rc);
 	return rc;
@@ -323,13 +334,14 @@ static void rpaphp_eeh_remove_bus_device(struct pci_dev *dev)
 
 int rpaphp_unconfig_pci_adapter(struct slot *slot)
 {
-	struct pci_dev *dev;
+	struct pci_dev *dev, *tmp;
 	int retval = 0;
 
-	list_for_each_entry(dev, slot->pci_devs, bus_list)
+	list_for_each_entry_safe(dev, tmp, slot->pci_devs, bus_list) {
 		rpaphp_eeh_remove_bus_device(dev);
+		pci_remove_bus_device(dev);
+	}
 
-	pci_remove_behind_bridge(slot->bridge);
 	slot->state = NOT_CONFIGURED;
 	info("%s: devices in slot[%s] unconfigured.\n", __FUNCTION__,
 	     slot->name);
@@ -352,66 +364,41 @@ static int setup_pci_hotplug_slot_info(struct slot *slot)
 	return 0;
 }
 
-static int set_phb_slot_name(struct slot *slot)
+static void set_slot_name(struct slot *slot)
 {
-	struct device_node *dn;
-	struct pci_controller *phb;
-	struct pci_bus *bus;
-
-	dn = slot->dn;
-	if (!dn) {
-		return -EINVAL;
-	}
-	phb = dn->phb;
-	if (!phb) {
-		return -EINVAL;
-	}
-	bus = phb->bus;
-	if (!bus) {
-		return -EINVAL;
-	}
+	struct pci_bus *bus = slot->bus;
+	struct pci_dev *bridge;
 
-	sprintf(slot->name, "%04x:%02x:%02x.%x", pci_domain_nr(bus),
-			bus->number, 0, 0);
-	return 0;
+	bridge = bus->self;
+	if (bridge)
+		strcpy(slot->name, pci_name(bridge));
+	else
+		sprintf(slot->name, "%04x:%02x:00.0", pci_domain_nr(bus),
+			bus->number);
 }
 
 static int setup_pci_slot(struct slot *slot)
 {
+	struct device_node *dn = slot->dn;
 	struct pci_bus *bus;
-	int rc;
 
-	if (slot->type == PHB) {
-		rc = set_phb_slot_name(slot);
-		if (rc < 0) {
-			err("%s: failed to set phb slot name\n", __FUNCTION__);
-			goto exit_rc;
-		}
-	} else {
-		slot->bridge = rpaphp_find_bridge_pdev(slot);
-		if (!slot->bridge) {
-			/* slot being added doesn't have pci_dev yet */
-			err("%s: no pci_dev for bridge dn %s\n",
-					__FUNCTION__, slot->name);
-			goto exit_rc;
-		}
-
-		bus = slot->bridge->subordinate;
-		if (!bus)
-			goto exit_rc;
-		slot->pci_devs = &bus->devices;
-
-		dbg("%s set slot->name to %s\n",  __FUNCTION__,
-				pci_name(slot->bridge));
-		strcpy(slot->name, pci_name(slot->bridge));
+	BUG_ON(!dn);
+	bus = rpaphp_find_pci_bus(dn);
+	if (!bus) {
+		err("%s: no pci_bus for dn %s\n", __FUNCTION__, dn->full_name);
+		goto exit_rc;
 	}
 
+	slot->bus = bus;
+	slot->pci_devs = &bus->devices;
+	set_slot_name(slot);
+
 	/* find slot's pci_dev if it's not empty */
 	if (slot->hotplug_slot->info->adapter_status == EMPTY) {
 		slot->state = EMPTY;	/* slot is empty */
 	} else {
 		/* slot is occupied */
-		if (!(slot->dn->child)) {
+		if (!dn->child) {
 			/* non-empty slot has to have child */
 			err("%s: slot[%s]'s device_node doesn't have child for adapter\n", 
 				__FUNCTION__, slot->name);

commit 5eeb8c63a38ff20285f3bbe7bcfe5e7c33c8ba14
Author: John Rose <johnrose@austin.ibm.com>
Date:   Mon Jul 25 10:16:42 2005 -0500

    [PATCH] PCI Hotplug: rpaphp: Move VIO registration
    
    Currently, rpaphp registers Virtual I/O slots as hotplug slots.  The
    only purpose of this registration is to ensure that the VIO subsystem
    is notified of new VIO buses during DLPAR adds.  Similarly, rpaphp
    notifies the VIO subsystem when a VIO bus is DLPAR-removed.  The rpaphp
    module has special case code to fake results for attributes like power,
    adapter status, etc.
    
    The VIO register/unregister functions could just as easily be made from
    the DLPAR module.  This patch moves the VIO registration calls to the
    DLPAR module, and removes the VIO fluff from rpaphp altogether.
    
    Signed-off-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index ab67d3d1a59c..30d10fcc24b2 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -265,11 +265,9 @@ static void print_slot_pci_funcs(struct slot *slot)
 {
 	struct pci_dev *dev;
 
-	if (slot->dev_type == PCI_DEV) {
-		dbg("%s: pci_devs of slot[%s]\n", __FUNCTION__, slot->name);
-		list_for_each_entry (dev, slot->dev.pci_devs, bus_list)
-			dbg("\t%s\n", pci_name(dev));
-	}
+	dbg("%s: pci_devs of slot[%s]\n", __FUNCTION__, slot->name);
+	list_for_each_entry (dev, slot->pci_devs, bus_list)
+		dbg("\t%s\n", pci_name(dev));
 	return;
 }
 
@@ -328,7 +326,7 @@ int rpaphp_unconfig_pci_adapter(struct slot *slot)
 	struct pci_dev *dev;
 	int retval = 0;
 
-	list_for_each_entry(dev, slot->dev.pci_devs, bus_list)
+	list_for_each_entry(dev, slot->pci_devs, bus_list)
 		rpaphp_eeh_remove_bus_device(dev);
 
 	pci_remove_behind_bridge(slot->bridge);
@@ -401,7 +399,7 @@ static int setup_pci_slot(struct slot *slot)
 		bus = slot->bridge->subordinate;
 		if (!bus)
 			goto exit_rc;
-		slot->dev.pci_devs = &bus->devices;
+		slot->pci_devs = &bus->devices;
 
 		dbg("%s set slot->name to %s\n",  __FUNCTION__,
 				pci_name(slot->bridge));
@@ -434,7 +432,7 @@ static int setup_pci_slot(struct slot *slot)
 			goto exit_rc;
 		}
 		print_slot_pci_funcs(slot);
-		if (!list_empty(slot->dev.pci_devs)) {
+		if (!list_empty(slot->pci_devs)) {
 			slot->state = CONFIGURED;
 		} else {
 			/* DLPAR add as opposed to 
@@ -452,7 +450,6 @@ int register_pci_slot(struct slot *slot)
 {
 	int rc = -EINVAL;
 
-	slot->dev_type = PCI_DEV;
 	if ((slot->type == EMBEDDED) || (slot->type == PHB))
 		slot->removable = 0;
 	else

commit bde168412440084e649e7e04938bd1ab6e7bf978
Author: John Rose <johnrose@austin.ibm.com>
Date:   Mon Jul 25 10:16:37 2005 -0500

    [PATCH] PCI Hotplug: rpaphp: Remove unused stuff
    
    Subject line says it all :)
    
    Signed-off-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
index d8305a935aab..ab67d3d1a59c 100644
--- a/drivers/pci/hotplug/rpaphp_pci.c
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -186,39 +186,6 @@ rpaphp_fixup_new_pci_devices(struct pci_bus *bus, int fix_bus)
 	}
 }
 
-static int rpaphp_pci_config_bridge(struct pci_dev *dev);
-
-/*****************************************************************************
- rpaphp_pci_config_slot() will  configure all devices under the 
- given slot->dn and return the the first pci_dev.
- *****************************************************************************/
-static struct pci_dev *
-rpaphp_pci_config_slot(struct device_node *dn, struct pci_bus *bus)
-{
-	struct device_node *eads_first_child = dn->child;
-	struct pci_dev *dev = NULL;
-	int num;
-	
-	dbg("Enter %s: dn=%s bus=%s\n", __FUNCTION__, dn->full_name, bus->name);
-
-	if (eads_first_child) {
-		/* pci_scan_slot should find all children of EADs */
-		num = pci_scan_slot(bus, PCI_DEVFN(PCI_SLOT(eads_first_child->devfn), 0));
-		if (num) {
-			rpaphp_fixup_new_pci_devices(bus, 1); 
-			pci_bus_add_devices(bus);
-		}
-		dev = rpaphp_find_pci_dev(eads_first_child);
-		if (!dev) {
-			err("No new device found\n");
-			return NULL;
-		}
-		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) 
-			rpaphp_pci_config_bridge(dev);
-	}
-	return dev;
-}
-
 static int rpaphp_pci_config_bridge(struct pci_dev *dev)
 {
 	u8 sec_busno;
@@ -252,6 +219,37 @@ static int rpaphp_pci_config_bridge(struct pci_dev *dev)
 	return 0;
 }
 
+/*****************************************************************************
+ rpaphp_pci_config_slot() will  configure all devices under the
+ given slot->dn and return the the first pci_dev.
+ *****************************************************************************/
+static struct pci_dev *
+rpaphp_pci_config_slot(struct device_node *dn, struct pci_bus *bus)
+{
+	struct device_node *eads_first_child = dn->child;
+	struct pci_dev *dev = NULL;
+	int num;
+
+	dbg("Enter %s: dn=%s bus=%s\n", __FUNCTION__, dn->full_name, bus->name);
+
+	if (eads_first_child) {
+		/* pci_scan_slot should find all children of EADs */
+		num = pci_scan_slot(bus, PCI_DEVFN(PCI_SLOT(eads_first_child->devfn), 0));
+		if (num) {
+			rpaphp_fixup_new_pci_devices(bus, 1);
+			pci_bus_add_devices(bus);
+		}
+		dev = rpaphp_find_pci_dev(eads_first_child);
+		if (!dev) {
+			err("No new device found\n");
+			return NULL;
+		}
+		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE)
+			rpaphp_pci_config_bridge(dev);
+	}
+	return dev;
+}
+
 static void enable_eeh(struct device_node *dn)
 {
 	struct device_node *sib;
@@ -502,37 +500,3 @@ int rpaphp_enable_pci_slot(struct slot *slot)
 	dbg("%s - Exit: rc[%d]\n", __FUNCTION__, retval);
 	return retval;
 }
-
-struct hotplug_slot *rpaphp_find_hotplug_slot(struct pci_dev *dev)
-{
-	struct list_head	*tmp, *n;
-	struct slot		*slot;
-
-	list_for_each_safe(tmp, n, &rpaphp_slot_head) {
-		struct pci_bus *bus;
-		struct list_head *ln;
-
-		slot = list_entry(tmp, struct slot, rpaphp_slot_list);
-		if (slot->bridge == NULL) {
-			if (slot->dev_type == PCI_DEV) {
-				printk(KERN_WARNING "PCI slot missing bridge %s %s \n", 
-				                    slot->name, slot->location);
-			}
-			continue;
-		}
-
-		bus = slot->bridge->subordinate;
-		if (!bus) {
-			continue;  /* should never happen? */
-		}
-		for (ln = bus->devices.next; ln != &bus->devices; ln = ln->next) {
-                                struct pci_dev *pdev = pci_dev_b(ln);
-				if (pdev == dev)
-					return slot->hotplug_slot;
-		}
-	}
-
-	return NULL;
-}
-
-EXPORT_SYMBOL_GPL(rpaphp_find_hotplug_slot);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
new file mode 100644
index 000000000000..d8305a935aab
--- /dev/null
+++ b/drivers/pci/hotplug/rpaphp_pci.c
@@ -0,0 +1,538 @@
+/*
+ * PCI Hot Plug Controller Driver for RPA-compliant PPC64 platform.
+ * Copyright (C) 2003 Linda Xie <lxie@us.ibm.com>
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Send feedback to <lxie@us.ibm.com>
+ *
+ */
+#include <linux/pci.h>
+#include <asm/pci-bridge.h>
+#include <asm/rtas.h>
+#include <asm/machdep.h>
+#include "../pci.h"		/* for pci_add_new_bus */
+
+#include "rpaphp.h"
+
+struct pci_dev *rpaphp_find_pci_dev(struct device_node *dn)
+{
+	struct pci_dev *dev = NULL;
+	char bus_id[BUS_ID_SIZE];
+
+	sprintf(bus_id, "%04x:%02x:%02x.%d", dn->phb->global_number,
+		dn->busno, PCI_SLOT(dn->devfn), PCI_FUNC(dn->devfn));
+	for_each_pci_dev(dev) {
+		if (!strcmp(pci_name(dev), bus_id)) {
+			break;
+		}
+	}
+	return dev;
+}
+
+EXPORT_SYMBOL_GPL(rpaphp_find_pci_dev);
+
+int rpaphp_claim_resource(struct pci_dev *dev, int resource)
+{
+	struct resource *res = &dev->resource[resource];
+	struct resource *root = pci_find_parent_resource(dev, res);
+	char *dtype = resource < PCI_BRIDGE_RESOURCES ? "device" : "bridge";
+	int err = -EINVAL;
+
+	if (root != NULL) {
+		err = request_resource(root, res);
+	}
+
+	if (err) {
+		err("PCI: %s region %d of %s %s [%lx:%lx]\n",
+		    root ? "Address space collision on" :
+		    "No parent found for",
+		    resource, dtype, pci_name(dev), res->start, res->end);
+	}
+	return err;
+}
+
+EXPORT_SYMBOL_GPL(rpaphp_claim_resource);
+
+static struct pci_dev *rpaphp_find_bridge_pdev(struct slot *slot)
+{
+	return rpaphp_find_pci_dev(slot->dn);
+}
+
+static int rpaphp_get_sensor_state(struct slot *slot, int *state)
+{
+	int rc;
+	int setlevel;
+
+	rc = rtas_get_sensor(DR_ENTITY_SENSE, slot->index, state);
+
+	if (rc < 0) {
+		if (rc == -EFAULT || rc == -EEXIST) {
+			dbg("%s: slot must be power up to get sensor-state\n",
+			    __FUNCTION__);
+
+			/* some slots have to be powered up 
+			 * before get-sensor will succeed.
+			 */
+			rc = rtas_set_power_level(slot->power_domain, POWER_ON,
+						  &setlevel);
+			if (rc < 0) {
+				dbg("%s: power on slot[%s] failed rc=%d.\n",
+				    __FUNCTION__, slot->name, rc);
+			} else {
+				rc = rtas_get_sensor(DR_ENTITY_SENSE,
+						     slot->index, state);
+			}
+		} else if (rc == -ENODEV)
+			info("%s: slot is unusable\n", __FUNCTION__);
+		else
+			err("%s failed to get sensor state\n", __FUNCTION__);
+	}
+	return rc;
+}
+
+/**
+ * get_pci_adapter_status - get the status of a slot
+ * 
+ * 0-- slot is empty
+ * 1-- adapter is configured
+ * 2-- adapter is not configured
+ * 3-- not valid
+ */
+int rpaphp_get_pci_adapter_status(struct slot *slot, int is_init, u8 * value)
+{
+	int state, rc;
+ 	struct device_node *child_dn;
+ 	struct pci_dev *child_dev = NULL;
+
+	*value = NOT_VALID;
+	rc = rpaphp_get_sensor_state(slot, &state);
+	if (rc)
+		goto exit;
+
+ 	if ((state == EMPTY) || (slot->type == PHB)) {
+ 		dbg("slot is empty\n");
+ 		*value = EMPTY;
+ 	}
+ 	else if (state == PRESENT) {
+		if (!is_init) {
+			/* at run-time slot->state can be changed by */
+			/* config/unconfig adapter */
+			*value = slot->state;
+		} else {
+ 			child_dn = slot->dn->child;
+ 			if (child_dn)
+ 				child_dev = rpaphp_find_pci_dev(child_dn);
+
+ 			if (child_dev)
+ 				*value = CONFIGURED;
+ 			else if (!child_dn)
+				dbg("%s: %s is not valid OFDT node\n",
+				    __FUNCTION__, slot->dn->full_name);
+			else {
+				err("%s: can't find pdev of adapter in slot[%s]\n", 
+					__FUNCTION__, slot->dn->full_name);
+				*value = NOT_CONFIGURED;
+			}
+		}
+	}
+exit:
+	return rc;
+}
+
+/* Must be called before pci_bus_add_devices */
+static void 
+rpaphp_fixup_new_pci_devices(struct pci_bus *bus, int fix_bus)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		/*
+		 * Skip already-present devices (which are on the
+		 * global device list.)
+		 */
+		if (list_empty(&dev->global_list)) {
+			int i;
+			
+			/* Need to setup IOMMU tables */
+			ppc_md.iommu_dev_setup(dev);
+
+			if(fix_bus)
+				pcibios_fixup_device_resources(dev, bus);
+			pci_read_irq_line(dev);
+			for (i = 0; i < PCI_NUM_RESOURCES; i++) {
+				struct resource *r = &dev->resource[i];
+
+				if (r->parent || !r->start || !r->flags)
+					continue;
+				rpaphp_claim_resource(dev, i);
+			}
+		}
+	}
+}
+
+static int rpaphp_pci_config_bridge(struct pci_dev *dev);
+
+/*****************************************************************************
+ rpaphp_pci_config_slot() will  configure all devices under the 
+ given slot->dn and return the the first pci_dev.
+ *****************************************************************************/
+static struct pci_dev *
+rpaphp_pci_config_slot(struct device_node *dn, struct pci_bus *bus)
+{
+	struct device_node *eads_first_child = dn->child;
+	struct pci_dev *dev = NULL;
+	int num;
+	
+	dbg("Enter %s: dn=%s bus=%s\n", __FUNCTION__, dn->full_name, bus->name);
+
+	if (eads_first_child) {
+		/* pci_scan_slot should find all children of EADs */
+		num = pci_scan_slot(bus, PCI_DEVFN(PCI_SLOT(eads_first_child->devfn), 0));
+		if (num) {
+			rpaphp_fixup_new_pci_devices(bus, 1); 
+			pci_bus_add_devices(bus);
+		}
+		dev = rpaphp_find_pci_dev(eads_first_child);
+		if (!dev) {
+			err("No new device found\n");
+			return NULL;
+		}
+		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) 
+			rpaphp_pci_config_bridge(dev);
+	}
+	return dev;
+}
+
+static int rpaphp_pci_config_bridge(struct pci_dev *dev)
+{
+	u8 sec_busno;
+	struct pci_bus *child_bus;
+	struct pci_dev *child_dev;
+
+	dbg("Enter %s:  BRIDGE dev=%s\n", __FUNCTION__, pci_name(dev));
+
+	/* get busno of downstream bus */
+	pci_read_config_byte(dev, PCI_SECONDARY_BUS, &sec_busno);
+		
+	/* add to children of PCI bridge dev->bus */
+	child_bus = pci_add_new_bus(dev->bus, dev, sec_busno);
+	if (!child_bus) {
+		err("%s: could not add second bus\n", __FUNCTION__);
+		return -EIO;
+	}
+	sprintf(child_bus->name, "PCI Bus #%02x", child_bus->number);
+	/* do pci_scan_child_bus */
+	pci_scan_child_bus(child_bus);
+
+	list_for_each_entry(child_dev, &child_bus->devices, bus_list) {
+		eeh_add_device_late(child_dev);
+	}
+
+	 /* fixup new pci devices without touching bus struct */
+	rpaphp_fixup_new_pci_devices(child_bus, 0);
+
+	/* Make the discovered devices available */
+	pci_bus_add_devices(child_bus);
+	return 0;
+}
+
+static void enable_eeh(struct device_node *dn)
+{
+	struct device_node *sib;
+
+	for (sib = dn->child; sib; sib = sib->sibling) 
+		enable_eeh(sib);
+	eeh_add_device_early(dn);
+	return;
+	
+}
+
+static void print_slot_pci_funcs(struct slot *slot)
+{
+	struct pci_dev *dev;
+
+	if (slot->dev_type == PCI_DEV) {
+		dbg("%s: pci_devs of slot[%s]\n", __FUNCTION__, slot->name);
+		list_for_each_entry (dev, slot->dev.pci_devs, bus_list)
+			dbg("\t%s\n", pci_name(dev));
+	}
+	return;
+}
+
+static int rpaphp_config_pci_adapter(struct slot *slot)
+{
+	struct pci_bus *pci_bus;
+	struct pci_dev *dev;
+	int rc = -ENODEV;
+
+	dbg("Entry %s: slot[%s]\n", __FUNCTION__, slot->name);
+
+	if (slot->bridge) {
+
+		pci_bus = slot->bridge->subordinate;
+		if (!pci_bus) {
+			err("%s: can't find bus structure\n", __FUNCTION__);
+			goto exit;
+		}
+		enable_eeh(slot->dn);
+		dev = rpaphp_pci_config_slot(slot->dn, pci_bus);
+		if (!dev) {
+			err("%s: can't find any devices.\n", __FUNCTION__);
+			goto exit;
+		}
+		print_slot_pci_funcs(slot);
+		rc = 0;
+	} else {
+		/* slot is not enabled */
+		err("slot doesn't have pci_dev structure\n");
+	}
+exit:
+	dbg("Exit %s:  rc=%d\n", __FUNCTION__, rc);
+	return rc;
+}
+
+static void rpaphp_eeh_remove_bus_device(struct pci_dev *dev)
+{
+	eeh_remove_device(dev);
+	if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {
+		struct pci_bus *bus = dev->subordinate;
+		struct list_head *ln;
+		if (!bus)
+			return; 
+		for (ln = bus->devices.next; ln != &bus->devices; ln = ln->next) {
+			struct pci_dev *pdev = pci_dev_b(ln);
+			if (pdev)
+				rpaphp_eeh_remove_bus_device(pdev);
+		}
+
+	}
+	return;
+}
+
+int rpaphp_unconfig_pci_adapter(struct slot *slot)
+{
+	struct pci_dev *dev;
+	int retval = 0;
+
+	list_for_each_entry(dev, slot->dev.pci_devs, bus_list)
+		rpaphp_eeh_remove_bus_device(dev);
+
+	pci_remove_behind_bridge(slot->bridge);
+	slot->state = NOT_CONFIGURED;
+	info("%s: devices in slot[%s] unconfigured.\n", __FUNCTION__,
+	     slot->name);
+	return retval;
+}
+
+static int setup_pci_hotplug_slot_info(struct slot *slot)
+{
+	dbg("%s Initilize the PCI slot's hotplug->info structure ...\n",
+	    __FUNCTION__);
+	rpaphp_get_power_status(slot, &slot->hotplug_slot->info->power_status);
+	rpaphp_get_pci_adapter_status(slot, 1,
+				      &slot->hotplug_slot->info->
+				      adapter_status);
+	if (slot->hotplug_slot->info->adapter_status == NOT_VALID) {
+		err("%s: NOT_VALID: skip dn->full_name=%s\n",
+		    __FUNCTION__, slot->dn->full_name);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int set_phb_slot_name(struct slot *slot)
+{
+	struct device_node *dn;
+	struct pci_controller *phb;
+	struct pci_bus *bus;
+
+	dn = slot->dn;
+	if (!dn) {
+		return -EINVAL;
+	}
+	phb = dn->phb;
+	if (!phb) {
+		return -EINVAL;
+	}
+	bus = phb->bus;
+	if (!bus) {
+		return -EINVAL;
+	}
+
+	sprintf(slot->name, "%04x:%02x:%02x.%x", pci_domain_nr(bus),
+			bus->number, 0, 0);
+	return 0;
+}
+
+static int setup_pci_slot(struct slot *slot)
+{
+	struct pci_bus *bus;
+	int rc;
+
+	if (slot->type == PHB) {
+		rc = set_phb_slot_name(slot);
+		if (rc < 0) {
+			err("%s: failed to set phb slot name\n", __FUNCTION__);
+			goto exit_rc;
+		}
+	} else {
+		slot->bridge = rpaphp_find_bridge_pdev(slot);
+		if (!slot->bridge) {
+			/* slot being added doesn't have pci_dev yet */
+			err("%s: no pci_dev for bridge dn %s\n",
+					__FUNCTION__, slot->name);
+			goto exit_rc;
+		}
+
+		bus = slot->bridge->subordinate;
+		if (!bus)
+			goto exit_rc;
+		slot->dev.pci_devs = &bus->devices;
+
+		dbg("%s set slot->name to %s\n",  __FUNCTION__,
+				pci_name(slot->bridge));
+		strcpy(slot->name, pci_name(slot->bridge));
+	}
+
+	/* find slot's pci_dev if it's not empty */
+	if (slot->hotplug_slot->info->adapter_status == EMPTY) {
+		slot->state = EMPTY;	/* slot is empty */
+	} else {
+		/* slot is occupied */
+		if (!(slot->dn->child)) {
+			/* non-empty slot has to have child */
+			err("%s: slot[%s]'s device_node doesn't have child for adapter\n", 
+				__FUNCTION__, slot->name);
+			goto exit_rc;
+		}
+
+		if (slot->hotplug_slot->info->adapter_status == NOT_CONFIGURED) {
+			dbg("%s CONFIGURING pci adapter in slot[%s]\n",  
+				__FUNCTION__, slot->name);
+			if (rpaphp_config_pci_adapter(slot)) {
+				err("%s: CONFIG pci adapter failed\n", __FUNCTION__);
+				goto exit_rc;		
+			}
+
+		} else if (slot->hotplug_slot->info->adapter_status != CONFIGURED) {
+			err("%s: slot[%s]'s adapter_status is NOT_VALID.\n",
+				__FUNCTION__, slot->name);
+			goto exit_rc;
+		}
+		print_slot_pci_funcs(slot);
+		if (!list_empty(slot->dev.pci_devs)) {
+			slot->state = CONFIGURED;
+		} else {
+			/* DLPAR add as opposed to 
+		 	 * boot time */
+			slot->state = NOT_CONFIGURED;
+		}
+	}
+	return 0;
+exit_rc:
+	dealloc_slot_struct(slot);
+	return -EINVAL;
+}
+
+int register_pci_slot(struct slot *slot)
+{
+	int rc = -EINVAL;
+
+	slot->dev_type = PCI_DEV;
+	if ((slot->type == EMBEDDED) || (slot->type == PHB))
+		slot->removable = 0;
+	else
+		slot->removable = 1;
+	if (setup_pci_hotplug_slot_info(slot))
+		goto exit_rc;
+	if (setup_pci_slot(slot))
+		goto exit_rc;
+	rc = register_slot(slot);
+exit_rc:
+	return rc;
+}
+
+int rpaphp_enable_pci_slot(struct slot *slot)
+{
+	int retval = 0, state;
+
+	retval = rpaphp_get_sensor_state(slot, &state);
+	if (retval)
+		goto exit;
+	dbg("%s: sensor state[%d]\n", __FUNCTION__, state);
+	/* if slot is not empty, enable the adapter */
+	if (state == PRESENT) {
+		dbg("%s : slot[%s] is occupied.\n", __FUNCTION__, slot->name);
+		retval = rpaphp_config_pci_adapter(slot);
+		if (!retval) {
+			slot->state = CONFIGURED;
+			dbg("%s: PCI devices in slot[%s] has been configured\n", 
+				__FUNCTION__, slot->name);
+		} else {
+			slot->state = NOT_CONFIGURED;
+			dbg("%s: no pci_dev struct for adapter in slot[%s]\n",
+			    __FUNCTION__, slot->name);
+		}
+	} else if (state == EMPTY) {
+		dbg("%s : slot[%s] is empty\n", __FUNCTION__, slot->name);
+		slot->state = EMPTY;
+	} else {
+		err("%s: slot[%s] is in invalid state\n", __FUNCTION__,
+		    slot->name);
+		slot->state = NOT_VALID;
+		retval = -EINVAL;
+	}
+exit:
+	dbg("%s - Exit: rc[%d]\n", __FUNCTION__, retval);
+	return retval;
+}
+
+struct hotplug_slot *rpaphp_find_hotplug_slot(struct pci_dev *dev)
+{
+	struct list_head	*tmp, *n;
+	struct slot		*slot;
+
+	list_for_each_safe(tmp, n, &rpaphp_slot_head) {
+		struct pci_bus *bus;
+		struct list_head *ln;
+
+		slot = list_entry(tmp, struct slot, rpaphp_slot_list);
+		if (slot->bridge == NULL) {
+			if (slot->dev_type == PCI_DEV) {
+				printk(KERN_WARNING "PCI slot missing bridge %s %s \n", 
+				                    slot->name, slot->location);
+			}
+			continue;
+		}
+
+		bus = slot->bridge->subordinate;
+		if (!bus) {
+			continue;  /* should never happen? */
+		}
+		for (ln = bus->devices.next; ln != &bus->devices; ln = ln->next) {
+                                struct pci_dev *pdev = pci_dev_b(ln);
+				if (pdev == dev)
+					return slot->hotplug_slot;
+		}
+	}
+
+	return NULL;
+}
+
+EXPORT_SYMBOL_GPL(rpaphp_find_hotplug_slot);
