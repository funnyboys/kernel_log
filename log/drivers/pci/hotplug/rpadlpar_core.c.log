commit b6eebb093cad0feb56c717611ee0d2d7c66b4ec7
Author: Oliver O'Halloran <oohall@gmail.com>
Date:   Fri Mar 6 18:39:03 2020 +1100

    powerpc/eeh: Make early EEH init pseries specific
    
    The eeh_ops->probe() function is called from two different contexts:
    
    1. On pseries, where we set EEH_PROBE_MODE_DEVTREE, it's called in
       eeh_add_device_early() which is supposed to run before we create
       a pci_dev.
    
    2. On PowerNV, where we set EEH_PROBE_MODE_DEV, it's called in
       eeh_device_add_late() which is supposed to run *after* the
       pci_dev is created.
    
    The "early" probe is required because PAPR requires that we perform an RTAS
    call to enable EEH support on a device before we start interacting with it
    via config space or MMIO. This requirement doesn't exist on PowerNV and
    shoehorning two completely separate initialisation paths into a common
    interface just results in a convoluted code everywhere.
    
    Additionally the early probe requires the probe function to take an pci_dn
    rather than a pci_dev argument. We'd like to make pci_dn a pseries specific
    data structure since there's no real requirement for them on PowerNV. To
    help both goals move the early probe into the pseries containment zone
    so the platform depedence is more explicit.
    
    Reviewed-by: Sam Bobroff <sbobroff@linux.ibm.com>
    Signed-off-by: Oliver O'Halloran <oohall@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20200306073904.4737-5-oohall@gmail.com

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 977946e4e613..c5eb509c72f0 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -140,7 +140,7 @@ static void dlpar_pci_add_bus(struct device_node *dn)
 	struct pci_controller *phb = pdn->phb;
 	struct pci_dev *dev = NULL;
 
-	eeh_add_device_tree_early(pdn);
+	pseries_eeh_init_edev_recursive(pdn);
 
 	/* Add EADS device to PHB bus, adding new entry to bus->devices */
 	dev = of_create_pci_dev(dn, phb->bus, pdn->devfn);

commit 55507aea58824578610eb0cb5c250a0c997987c9
Author: Krzysztof Wilczynski <kw@linux.com>
Date:   Mon Aug 26 00:10:39 2019 +0200

    PCI: Remove unnecessary returns
    
    Remove unnecessary "return" statements at the end of void functions.  No
    functional change intended.
    
    Link: https://lore.kernel.org/r/20190825221039.6977-1-kw@linux.com
    Link: https://lore.kernel.org/r/20190826095143.21353-1-kw@linux.com
    Signed-off-by: Krzysztof Wilczynski <kw@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 182f9e3443ee..977946e4e613 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -473,7 +473,6 @@ int __init rpadlpar_io_init(void)
 void rpadlpar_io_exit(void)
 {
 	dlpar_sysfs_exit();
-	return;
 }
 
 module_init(rpadlpar_io_init);

commit fb26228bfc4ce3951544848555c0278e2832e618
Author: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
Date:   Fri Mar 22 13:27:21 2019 -0500

    PCI: rpadlpar: Fix leaked device_node references in add/remove paths
    
    The find_dlpar_node() helper returns a device node with its reference
    incremented.  Both the add and remove paths use this helper for find the
    appropriate node, but fail to release the reference when done.
    
    Annotate the find_dlpar_node() helper with a comment about the incremented
    reference count and call of_node_put() on the obtained device_node in the
    add and remove paths.  Also, fixup a reference leak in the find_vio_slot()
    helper where we fail to call of_node_put() on the vdevice node after we
    iterate over its children.
    
    Signed-off-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index e2356a9c7088..182f9e3443ee 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -51,6 +51,7 @@ static struct device_node *find_vio_slot_node(char *drc_name)
 		if (rc == 0)
 			break;
 	}
+	of_node_put(parent);
 
 	return dn;
 }
@@ -71,6 +72,7 @@ static struct device_node *find_php_slot_pci_node(char *drc_name,
 	return np;
 }
 
+/* Returns a device_node with its reference count incremented */
 static struct device_node *find_dlpar_node(char *drc_name, int *node_type)
 {
 	struct device_node *dn;
@@ -306,6 +308,7 @@ int dlpar_add_slot(char *drc_name)
 			rc = dlpar_add_phb(drc_name, dn);
 			break;
 	}
+	of_node_put(dn);
 
 	printk(KERN_INFO "%s: slot %s added\n", DLPAR_MODULE_NAME, drc_name);
 exit:
@@ -439,6 +442,7 @@ int dlpar_remove_slot(char *drc_name)
 			rc = dlpar_remove_pci_slot(drc_name, dn);
 			break;
 	}
+	of_node_put(dn);
 	vm_unmap_aliases();
 
 	printk(KERN_INFO "%s: slot %s removed\n", DLPAR_MODULE_NAME, drc_name);

commit 105cf3c8c6264dce4bcdab877feb8037bc4109b1
Merge: e237f98a9c13 ab8c609356fb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 6 09:59:40 2018 -0800

    Merge tag 'pci-v4.16-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - skip AER driver error recovery callbacks for correctable errors
       reported via ACPI APEI, as we already do for errors reported via the
       native path (Tyler Baicar)
    
     - fix DPC shared interrupt handling (Alex Williamson)
    
     - print full DPC interrupt number (Keith Busch)
    
     - enable DPC only if AER is available (Keith Busch)
    
     - simplify DPC code (Bjorn Helgaas)
    
     - calculate ASPM L1 substate parameter instead of hardcoding it (Bjorn
       Helgaas)
    
     - enable Latency Tolerance Reporting for ASPM L1 substates (Bjorn
       Helgaas)
    
     - move ASPM internal interfaces out of public header (Bjorn Helgaas)
    
     - allow hot-removal of VGA devices (Mika Westerberg)
    
     - speed up unplug and shutdown by assuming Thunderbolt controllers
       don't support Command Completed events (Lukas Wunner)
    
     - add AtomicOps support for GPU and Infiniband drivers (Felix Kuehling,
       Jay Cornwall)
    
     - expose "ari_enabled" in sysfs to help NIC naming (Stuart Hayes)
    
     - clean up PCI DMA interface usage (Christoph Hellwig)
    
     - remove PCI pool API (replaced with DMA pool) (Romain Perier)
    
     - deprecate pci_get_bus_and_slot(), which assumed PCI domain 0 (Sinan
       Kaya)
    
     - move DT PCI code from drivers/of/ to drivers/pci/ (Rob Herring)
    
     - add PCI-specific wrappers for dev_info(), etc (Frederick Lawler)
    
     - remove warnings on sysfs mmap failure (Bjorn Helgaas)
    
     - quiet ROM validation messages (Alex Deucher)
    
     - remove redundant memory alloc failure messages (Markus Elfring)
    
     - fill in types for compile-time VGA and other I/O port resources
       (Bjorn Helgaas)
    
     - make "pci=pcie_scan_all" work for Root Ports as well as Downstream
       Ports to help AmigaOne X1000 (Bjorn Helgaas)
    
     - add SPDX tags to all PCI files (Bjorn Helgaas)
    
     - quirk Marvell 9128 DMA aliases (Alex Williamson)
    
     - quirk broken INTx disable on Ceton InfiniTV4 (Bjorn Helgaas)
    
     - fix CONFIG_PCI=n build by adding dummy pci_irqd_intx_xlate() (Niklas
       Cassel)
    
     - use DMA API to get MSI address for DesignWare IP (Niklas Cassel)
    
     - fix endpoint-mode DMA mask configuration (Kishon Vijay Abraham I)
    
     - fix ARTPEC-6 incorrect IS_ERR() usage (Wei Yongjun)
    
     - add support for ARTPEC-7 SoC (Niklas Cassel)
    
     - add endpoint-mode support for ARTPEC (Niklas Cassel)
    
     - add Cadence PCIe host and endpoint controller driver (Cyrille
       Pitchen)
    
     - handle multiple INTx status bits being set in dra7xx (Vignesh R)
    
     - translate dra7xx hwirq range to fix INTD handling (Vignesh R)
    
     - remove deprecated Exynos PHY initialization code (Jaehoon Chung)
    
     - fix MSI erratum workaround for HiSilicon Hip06/Hip07 (Dongdong Liu)
    
     - fix NULL pointer dereference in iProc BCMA driver (Ray Jui)
    
     - fix Keystone interrupt-controller-node lookup (Johan Hovold)
    
     - constify qcom driver structures (Julia Lawall)
    
     - rework Tegra config space mapping to increase space available for
       endpoints (Vidya Sagar)
    
     - simplify Tegra driver by using bus->sysdata (Manikanta Maddireddy)
    
     - remove PCI_REASSIGN_ALL_BUS usage on Tegra (Manikanta Maddireddy)
    
     - add support for Global Fabric Manager Server (GFMS) event to
       Microsemi Switchtec switch driver (Logan Gunthorpe)
    
     - add IDs for Switchtec PSX 24xG3 and PSX 48xG3 (Kelvin Cao)
    
    * tag 'pci-v4.16-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (140 commits)
      PCI: cadence: Add EndPoint Controller driver for Cadence PCIe controller
      dt-bindings: PCI: cadence: Add DT bindings for Cadence PCIe endpoint controller
      PCI: endpoint: Fix EPF device name to support multi-function devices
      PCI: endpoint: Add the function number as argument to EPC ops
      PCI: cadence: Add host driver for Cadence PCIe controller
      dt-bindings: PCI: cadence: Add DT bindings for Cadence PCIe host controller
      PCI: Add vendor ID for Cadence
      PCI: Add generic function to probe PCI host controllers
      PCI: generic: fix missing call of pci_free_resource_list()
      PCI: OF: Add generic function to parse and allocate PCI resources
      PCI: Regroup all PCI related entries into drivers/pci/Makefile
      PCI/DPC: Reformat DPC register definitions
      PCI/DPC: Add and use DPC Status register field definitions
      PCI/DPC: Squash dpc_rp_pio_get_info() into dpc_process_rp_pio_error()
      PCI/DPC: Remove unnecessary RP PIO register structs
      PCI/DPC: Push dpc->rp_pio_status assignment into dpc_rp_pio_get_info()
      PCI/DPC: Squash dpc_rp_pio_print_error() into dpc_rp_pio_get_info()
      PCI/DPC: Make RP PIO log size check more generic
      PCI/DPC: Rename local "status" to "dpc_status"
      PCI/DPC: Squash dpc_rp_pio_print_tlp_header() into dpc_rp_pio_print_error()
      ...

commit 736759ef59d86a7bcefb1cdb629abecafc645a46
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 26 14:22:04 2018 -0600

    PCI: Add SPDX GPL-2.0+ to replace GPL v2 or later boilerplate
    
    Add SPDX GPL-2.0+ to all PCI files that specified the GPL and allowed
    either GPL version 2 or any later version.
    
    Remove the boilerplate GPL version 2 or later language, relying on the
    assertion in b24413180f56 ("License cleanup: add SPDX GPL-2.0 license
    identifier to files with no license") that the SPDX identifier may be used
    instead of the full boilerplate text.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index a3449d717a99..1935146e37ad 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Interface for Dynamic Logical Partitioning of I/O Slots on
  * RPA-compliant PPC64 platform.
@@ -8,11 +9,6 @@
  * October 2003
  *
  * Copyright (C) 2003 IBM.
- *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
  */
 
 #undef DEBUG

commit 2fcf3ae508c23bea25ab0a0e639805eb7e573b58
Author: Michael Bringmann <mwb@linux.vnet.ibm.com>
Date:   Fri Dec 1 17:19:48 2017 -0600

    hotplug/drc-info: Add code to search ibm,drc-info property
    
    rpadlpar_core.c: Provide parallel routines to search the older device-
    tree properties ("ibm,drc-indexes", "ibm,drc-names", "ibm,drc-types"
    and "ibm,drc-power-domains"), or the new property "ibm,drc-info".
    
    The interface to examine the DRC information is changed from a "get"
    function that returns values for local verification elsewhere, to a
    "check" function that validates the 'name' and/or 'type' of a device
    node.  This update hides the format of the underlying device-tree
    properties, and concentrates the value checks into a single function
    without requiring the user to verify whether a search was successful.
    
    Signed-off-by: Michael Bringmann <mwb@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index a3449d717a99..fc01d7d807f3 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -27,6 +27,7 @@
 #include <linux/mutex.h>
 #include <asm/rtas.h>
 #include <asm/vio.h>
+#include <linux/firmware.h>
 
 #include "../pci.h"
 #include "rpaphp.h"
@@ -44,15 +45,14 @@ static struct device_node *find_vio_slot_node(char *drc_name)
 {
 	struct device_node *parent = of_find_node_by_name(NULL, "vdevice");
 	struct device_node *dn = NULL;
-	char *name;
 	int rc;
 
 	if (!parent)
 		return NULL;
 
 	while ((dn = of_get_next_child(parent, dn))) {
-		rc = rpaphp_get_drc_props(dn, NULL, &name, NULL, NULL);
-		if ((rc == 0) && (!strcmp(drc_name, name)))
+		rc = rpaphp_check_drc_props(dn, drc_name, NULL);
+		if (rc == 0)
 			break;
 	}
 
@@ -64,15 +64,12 @@ static struct device_node *find_php_slot_pci_node(char *drc_name,
 						  char *drc_type)
 {
 	struct device_node *np = NULL;
-	char *name;
-	char *type;
 	int rc;
 
 	while ((np = of_find_node_by_name(np, "pci"))) {
-		rc = rpaphp_get_drc_props(np, NULL, &name, &type, NULL);
+		rc = rpaphp_check_drc_props(np, drc_name, drc_type);
 		if (rc == 0)
-			if (!strcmp(drc_name, name) && !strcmp(drc_type, type))
-				break;
+			break;
 	}
 
 	return np;

commit b63773a801ff7f7f047894a9be23616f4491aca8
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:43:21 2017 -0500

    PCI: Convert to using %pOF instead of full_name()
    
    Now that we have a custom printf format specifier, convert users of
    full_name() to use %pOF instead.  This is preparation for removing storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 3f93a4e79595..a3449d717a99 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -150,8 +150,8 @@ static void dlpar_pci_add_bus(struct device_node *dn)
 	/* Add EADS device to PHB bus, adding new entry to bus->devices */
 	dev = of_create_pci_dev(dn, phb->bus, pdn->devfn);
 	if (!dev) {
-		printk(KERN_ERR "%s: failed to create pci dev for %s\n",
-				__func__, dn->full_name);
+		printk(KERN_ERR "%s: failed to create pci dev for %pOF\n",
+				__func__, dn);
 		return;
 	}
 

commit 63d182abd71cb47cee4adb8dd2afd71d987794d5
Author: Rahul Krishnan <mrahul.krishnan@gmail.com>
Date:   Sat Dec 24 15:08:00 2016 +0530

    PCI: rpadlpar: Remove unnecessary return statement
    
    Remove unnecessary return statement using spatch tool.
    
    Signed-off-by: Rahul Krishnan <mrahul.krishnan@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index c614ff7c3bc3..3f93a4e79595 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -463,7 +463,6 @@ static inline int is_dlpar_capable(void)
 
 int __init rpadlpar_io_init(void)
 {
-	int rc = 0;
 
 	if (!is_dlpar_capable()) {
 		printk(KERN_WARNING "%s: partition not DLPAR capable\n",
@@ -471,8 +470,7 @@ int __init rpadlpar_io_init(void)
 		return -EPERM;
 	}
 
-	rc = dlpar_sysfs_init();
-	return rc;
+	return dlpar_sysfs_init();
 }
 
 void rpadlpar_io_exit(void)

commit 99e5cde5eae78bef95bfe7c16ccda87fb070149b
Author: Johan Hovold <johan@kernel.org>
Date:   Tue Nov 1 16:26:03 2016 +0100

    powerpc/pci/rpadlpar: Fix device reference leaks
    
    Make sure to drop any device reference taken by vio_find_node() when
    adding and removing virtual I/O slots.
    
    Fixes: 5eeb8c63a38f ("[PATCH] PCI Hotplug: rpaphp: Move VIO registration")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index dc67f39779ec..c614ff7c3bc3 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -257,8 +257,13 @@ static int dlpar_add_phb(char *drc_name, struct device_node *dn)
 
 static int dlpar_add_vio_slot(char *drc_name, struct device_node *dn)
 {
-	if (vio_find_node(dn))
+	struct vio_dev *vio_dev;
+
+	vio_dev = vio_find_node(dn);
+	if (vio_dev) {
+		put_device(&vio_dev->dev);
 		return -EINVAL;
+	}
 
 	if (!vio_register_device_node(dn)) {
 		printk(KERN_ERR
@@ -334,6 +339,9 @@ static int dlpar_remove_vio_slot(char *drc_name, struct device_node *dn)
 		return -EINVAL;
 
 	vio_unregister_device(vio_dev);
+
+	put_device(&vio_dev->dev);
+
 	return 0;
 }
 

commit 3773dd258e91e1e14d95cdf17b9d83a1a7b27af1
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Tue May 3 15:41:38 2016 +1000

    powerpc/pci: Rename pcibios_find_pci_bus()
    
    This renames pcibios_find_pci_bus() to pci_find_bus_by_node() to
    avoid conflicts with those PCI subsystem weak function names, which
    have prefix "pcibios". No logical changes introduced.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Reviewed-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index b770d6de815a..dc67f39779ec 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -175,7 +175,7 @@ static int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)
 	struct pci_dev *dev;
 	struct pci_controller *phb;
 
-	if (pcibios_find_pci_bus(dn))
+	if (pci_find_bus_by_node(dn))
 		return -EINVAL;
 
 	/* Add pci bus */
@@ -212,7 +212,7 @@ static int dlpar_remove_phb(char *drc_name, struct device_node *dn)
 	struct pci_dn *pdn;
 	int rc = 0;
 
-	if (!pcibios_find_pci_bus(dn))
+	if (!pci_find_bus_by_node(dn))
 		return -EINVAL;
 
 	/* If pci slot is hotpluggable, use hotplug to remove it */
@@ -356,7 +356,7 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 
 	pci_lock_rescan_remove();
 
-	bus = pcibios_find_pci_bus(dn);
+	bus = pci_find_bus_by_node(dn);
 	if (!bus) {
 		ret = -EINVAL;
 		goto out;

commit bd251b893d46240fc12d9fa9316d9ea6ec2b69a7
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Tue May 3 15:41:37 2016 +1000

    powerpc/pci: Rename pcibios_{add, remove}_pci_devices()
    
    This renames pcibios_{add,remove}_pci_devices() to avoid conflicts
    with names of the weak functions in PCI subsystem, which have the
    prefix "pcibios". No logical changes introduced.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Reviewed-By: Alistair Popple <alistair@popple.id.au>
    Reviewed-by: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
    Reviewed-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index b46b57d870fc..b770d6de815a 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -380,7 +380,7 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 	}
 
 	/* Remove all devices below slot */
-	pcibios_remove_pci_devices(bus);
+	pci_hp_remove_devices(bus);
 
 	/* Unmap PCI IO space */
 	if (pcibios_unmap_io_space(bus)) {

commit 2ac83cccabbc8d264c20ce11931d60e0e6ea3f53
Author: Geliang Tang <geliangtang@163.com>
Date:   Sat Dec 12 21:36:57 2015 +0800

    PCI: hotplug: Use list_for_each_entry() to simplify code
    
    Use list_for_each_entry() instead of list_for_each() to simplify the code.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index e12bafdc42e0..b46b57d870fc 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -114,11 +114,10 @@ static struct device_node *find_dlpar_node(char *drc_name, int *node_type)
  */
 static struct slot *find_php_slot(struct device_node *dn)
 {
-	struct list_head *tmp, *n;
-	struct slot *slot;
+	struct slot *slot, *next;
 
-	list_for_each_safe(tmp, n, &rpaphp_slot_head) {
-		slot = list_entry(tmp, struct slot, rpaphp_slot_list);
+	list_for_each_entry_safe(slot, next, &rpaphp_slot_head,
+				 rpaphp_slot_list) {
 		if (slot->dn == dn)
 			return slot;
 	}

commit ff57b454ddb938d98d48d8df356357000fedc88c
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Tue Mar 17 16:15:06 2015 +1100

    powerpc/eeh: Do probe on pci_dn
    
    Originally, EEH core probes on device_node or pci_dev to populate
    EEH devices and PEs, which conflicts with the fact: SRIOV VFs are
    usually enabled and created by PF's driver and they don't have the
    corresponding device_nodes. Instead, SRIOV VFs have dynamically
    created pci_dn, which can be used for EEH probe.
    
    The patch reworks EEH probe for PowerNV and pSeries platforms to
    do probing based on pci_dn, instead of pci_dev or device_node any
    more.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 7660232ef460..e12bafdc42e0 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -146,7 +146,7 @@ static void dlpar_pci_add_bus(struct device_node *dn)
 	struct pci_controller *phb = pdn->phb;
 	struct pci_dev *dev = NULL;
 
-	eeh_add_device_tree_early(dn);
+	eeh_add_device_tree_early(pdn);
 
 	/* Add EADS device to PHB bus, adding new entry to bus->devices */
 	dev = of_create_pci_dev(dn, phb->bus, pdn->devfn);

commit f86e1f152e949b24ef336c640009183c01cfd9bf
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Sun May 4 12:23:43 2014 +0800

    PCI: rpaphp: Use pci_is_bridge() to simplify code
    
    Use pci_is_bridge() to simplify code.  No functional change.
    
    Requires: 326c1cdae741 PCI: Rename pci_is_bridge() to pci_has_subordinate()
    Requires: 1c86438c9423 PCI: Add new pci_is_bridge() interface
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 4fcdeedda31b..7660232ef460 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -157,8 +157,7 @@ static void dlpar_pci_add_bus(struct device_node *dn)
 	}
 
 	/* Scan below the new bridge */
-	if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
-	    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)
+	if (pci_is_bridge(dev))
 		of_scan_pci_bridge(dev);
 
 	/* Map IO space for child bus, which may or may not succeed */

commit c4ec84c7db0e4b01ed40cc2388f16ae5c6513cc0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 14 12:03:14 2014 -0700

    PCI: hotplug: Use global PCI rescan-remove locking
    
    Multiple race conditions are possible between PCI hotplug and the generic
    PCI bus rescan and device removal that can be triggered via sysfs.
    
    To avoid those race conditions make PCI hotplug use global PCI
    rescan-remove locking.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index e9c044d15add..4fcdeedda31b 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -354,10 +354,15 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 {
 	struct pci_bus *bus;
 	struct slot *slot;
+	int ret = 0;
+
+	pci_lock_rescan_remove();
 
 	bus = pcibios_find_pci_bus(dn);
-	if (!bus)
-		return -EINVAL;
+	if (!bus) {
+		ret = -EINVAL;
+		goto out;
+	}
 
 	pr_debug("PCI: Removing PCI slot below EADS bridge %s\n",
 		 bus->self ? pci_name(bus->self) : "<!PHB!>");
@@ -371,7 +376,8 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 			printk(KERN_ERR
 				"%s: unable to remove hotplug slot %s\n",
 				__func__, drc_name);
-			return -EIO;
+			ret = -EIO;
+			goto out;
 		}
 	}
 
@@ -382,7 +388,8 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 	if (pcibios_unmap_io_space(bus)) {
 		printk(KERN_ERR "%s: failed to unmap bus range\n",
 			__func__);
-		return -ERANGE;
+		ret = -ERANGE;
+		goto out;
 	}
 
 	/* Remove the EADS bridge device itself */
@@ -390,7 +397,9 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 	pr_debug("PCI: Now removing bridge device %s\n", pci_name(bus->self));
 	pci_stop_and_remove_bus_device(bus->self);
 
-	return 0;
+ out:
+	pci_unlock_rescan_remove();
+	return ret;
 }
 
 /**

commit f7625980f5820edd1a73536e1a03bcbc1f889fec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 14 11:28:18 2013 -0700

    PCI: Fix whitespace, capitalization, and spelling errors
    
    Fix whitespace, capitalization, and spelling errors.  No functional change.
    I know "busses" is not an error, but "buses" was more common, so I used it
    consistently.
    
    Signed-off-by: Marta Rybczynska <rybczynska@gmail.com> (pci_reset_bridge_secondary_bus())
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index bb7af78e4eed..e9c044d15add 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -217,7 +217,7 @@ static int dlpar_remove_phb(char *drc_name, struct device_node *dn)
 	if (!pcibios_find_pci_bus(dn))
 		return -EINVAL;
 
-	/* If pci slot is hotplugable, use hotplug to remove it */
+	/* If pci slot is hotpluggable, use hotplug to remove it */
 	slot = find_php_slot(dn);
 	if (slot && rpaphp_deregister_slot(slot)) {
 		printk(KERN_ERR "%s: unable to remove hotplug slot %s\n",

commit c7b51bce636e4990662bb100bc17e1d4d6c02d34
Author: Gavin Shan <shangw@linux.vnet.ibm.com>
Date:   Wed Jul 24 10:24:54 2013 +0800

    powerpc/pci/hotplug: Don't need to remove from EEH cache twice
    
    Since pcibios_release_device() called by pci_stop_and_remove_bus_device()
    has removed the device from the EEH cache, we needn't do that again.
    
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Gavin Shan <shangw@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index b29e20b7862f..bb7af78e4eed 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -388,7 +388,6 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 	/* Remove the EADS bridge device itself */
 	BUG_ON(!bus->self);
 	pr_debug("PCI: Now removing bridge device %s\n", pci_name(bus->self));
-	eeh_remove_bus_device(bus->self, true);
 	pci_stop_and_remove_bus_device(bus->self);
 
 	return 0;

commit 20ee6a970858a0f5711ea32cb7f855a81704cb53
Author: Gavin Shan <shangw@linux.vnet.ibm.com>
Date:   Tue Sep 11 19:16:17 2012 +0000

    powerpc/eeh: Remove EEH PE for normal PCI hotplug
    
    Function eeh_rmv_from_parent_pe() could be called by the path of
    either normal PCI hotplug, or EEH recovery. For the former case,
    we need purge the corresponding PE on removal of the associated
    PE bus.
    
    The patch tries to cover that by passing more information to function
    pcibios_remove_pci_devices() so that we know if the corresponding PE
    needs to be purged or be marked as "invalid".
    
    Signed-off-by: Gavin Shan <shangw@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 1e117c2a3cad..b29e20b7862f 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -388,7 +388,7 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 	/* Remove the EADS bridge device itself */
 	BUG_ON(!bus->self);
 	pr_debug("PCI: Now removing bridge device %s\n", pci_name(bus->self));
-	eeh_remove_bus_device(bus->self);
+	eeh_remove_bus_device(bus->self, true);
 	pci_stop_and_remove_bus_device(bus->self);
 
 	return 0;

commit 210647af897af8ef2d00828aa2a6b1b42206aae6
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Feb 25 13:54:20 2012 -0800

    PCI: Rename pci_remove_bus_device to pci_stop_and_remove_bus_device
    
    The old pci_remove_bus_device actually did stop and remove.
    
    Make the name reflect that to reduce confusion.
    
    This patch is done by sed scripts and changes back some incorrect
    __pci_remove_bus_device changes.
    
    Suggested-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index c56a9413e1af..1e117c2a3cad 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -389,7 +389,7 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 	BUG_ON(!bus->self);
 	pr_debug("PCI: Now removing bridge device %s\n", pci_name(bus->self));
 	eeh_remove_bus_device(bus->self);
-	pci_remove_bus_device(bus->self);
+	pci_stop_and_remove_bus_device(bus->self);
 
 	return 0;
 }

commit eefa9cfc891d18aa83744353d2a3fbe95a86ee2d
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 27 09:42:30 2011 -0400

    pci: add module.h to files implicitly relying on its presence.
    
    These were getting module.h implicitly from device.h but we want
    to clean that up, so we fix it here to avoid things like:
    
    pci/slot.c: In function ‘pci_hp_create_module_link’:
    pci/slot.c:383: error: ‘module_kset’ undeclared (first use in this function)
    
    Similarly, rpadlpar_core.c is modular, so add module.h to its includes.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 1d002b1c2bf4..c56a9413e1af 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -18,6 +18,7 @@
 #undef DEBUG
 
 #include <linux/init.h>
+#include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/string.h>
 #include <linux/vmalloc.h>

commit 98d9f30c820d509145757e6ecbc36013aa02f7bc
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Apr 11 11:37:07 2011 +1000

    pci/of: Match PCI devices to OF nodes dynamically
    
    powerpc has two different ways of matching PCI devices to their
    corresponding OF node (if any) for historical reasons. The ppc64 one
    does a scan looking for matching bus/dev/fn, while the ppc32 one does a
    scan looking only for matching dev/fn on each level in order to be
    agnostic to busses being renumbered (which Linux does on some
    platforms).
    
    This removes both and instead moves the matching code to the PCI core
    itself. It's the most logical place to do it: when a pci_dev is created,
    we know the parent and thus can do a single level scan for the matching
    device_node (if any).
    
    The benefit is that all archs now get the matching for free. There's one
    hook the arch might want to provide to match a PHB bus to its device
    node. A default weak implementation is provided that looks for the
    parent device device node, but it's not entirely reliable on powerpc for
    various reasons so powerpc provides its own.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Michal Simek <monstr@monstr.eu>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 083034710fa6..1d002b1c2bf4 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -158,7 +158,7 @@ static void dlpar_pci_add_bus(struct device_node *dn)
 	/* Scan below the new bridge */
 	if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
 	    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)
-		of_scan_pci_bridge(dn, dev);
+		of_scan_pci_bridge(dev);
 
 	/* Map IO space for child bus, which may or may not succeed */
 	pcibios_map_io_space(dev->subordinate);

commit b4a26be9f6f8bb72998e445cc75fc6dc0c29513a
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Apr 6 15:03:40 2010 +0000

    powerpc/pseries: Flush lazy kernel mappings after unplug operations
    
    This ensures that the translations for unmapped IO mappings or
    unmapped memory are properly removed from the MMU hash table
    before such an unplug. Without this, the hypervisor refuses the
    unplug operations due to those resources still being mapped by
    the partition.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 4e3e0382c16e..083034710fa6 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -20,6 +20,7 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/string.h>
+#include <linux/vmalloc.h>
 
 #include <asm/pci-bridge.h>
 #include <linux/mutex.h>
@@ -430,6 +431,8 @@ int dlpar_remove_slot(char *drc_name)
 			rc = dlpar_remove_pci_slot(drc_name, dn);
 			break;
 	}
+	vm_unmap_aliases();
+
 	printk(KERN_INFO "%s: slot %s removed\n", DLPAR_MODULE_NAME, drc_name);
 exit:
 	mutex_unlock(&rpadlpar_mutex);

commit fd6852c8fa060bd45c82a2593e18f933f6c6204f
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Oct 27 19:48:52 2008 +0000

    powerpc/pci: Fix various pseries PCI hotplug issues
    
    The pseries PCI hotplug code has a number of issues, ranging from
    incorrect resource setup to crashes, depending on what is added,
    when, whether it contains a bridge, etc etc....
    
    This fixes a whole bunch of these, while actually simplifying the code
    a bit, using more generic code in the process and factoring out common
    code between adding of a PHB, a slot or a device.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 9c2a22fed18b..4e3e0382c16e 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -14,6 +14,9 @@
  *      as published by the Free Software Foundation; either version
  *      2 of the License, or (at your option) any later version.
  */
+
+#undef DEBUG
+
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/string.h>
@@ -151,20 +154,20 @@ static void dlpar_pci_add_bus(struct device_node *dn)
 		return;
 	}
 
+	/* Scan below the new bridge */
 	if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
 	    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)
 		of_scan_pci_bridge(dn, dev);
 
-	pcibios_fixup_new_pci_devices(dev->subordinate);
-
-	/* Claim new bus resources */
-	pcibios_claim_one_bus(dev->bus);
-
 	/* Map IO space for child bus, which may or may not succeed */
 	pcibios_map_io_space(dev->subordinate);
 
-	/* Add new devices to global lists.  Register in proc, sysfs. */
-	pci_bus_add_devices(phb->bus);
+	/* Finish adding it : resource allocation, adding devices, etc...
+	 * Note that we need to perform the finish pass on the -parent-
+	 * bus of the EADS bridge so the bridge device itself gets
+	 * properly added
+	 */
+	pcibios_finish_adding_to_bus(phb->bus);
 }
 
 static int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)
@@ -203,27 +206,6 @@ static int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)
 	return 0;
 }
 
-static int dlpar_remove_root_bus(struct pci_controller *phb)
-{
-	struct pci_bus *phb_bus;
-	int rc;
-
-	phb_bus = phb->bus;
-	if (!(list_empty(&phb_bus->children) &&
-	      list_empty(&phb_bus->devices))) {
-		return -EBUSY;
-	}
-
-	rc = pcibios_remove_root_bus(phb);
-	if (rc)
-		return -EIO;
-
-	device_unregister(phb_bus->bridge);
-	pci_remove_bus(phb_bus);
-
-	return 0;
-}
-
 static int dlpar_remove_phb(char *drc_name, struct device_node *dn)
 {
 	struct slot *slot;
@@ -235,18 +217,15 @@ static int dlpar_remove_phb(char *drc_name, struct device_node *dn)
 
 	/* If pci slot is hotplugable, use hotplug to remove it */
 	slot = find_php_slot(dn);
-	if (slot) {
-		if (rpaphp_deregister_slot(slot)) {
-			printk(KERN_ERR
-				"%s: unable to remove hotplug slot %s\n",
-				__func__, drc_name);
-			return -EIO;
-		}
+	if (slot && rpaphp_deregister_slot(slot)) {
+		printk(KERN_ERR "%s: unable to remove hotplug slot %s\n",
+		       __func__, drc_name);
+		return -EIO;
 	}
 
 	pdn = dn->data;
 	BUG_ON(!pdn || !pdn->phb);
-	rc = dlpar_remove_root_bus(pdn->phb);
+	rc = remove_phb_dynamic(pdn->phb);
 	if (rc < 0)
 		return rc;
 
@@ -378,26 +357,38 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 	if (!bus)
 		return -EINVAL;
 
-	/* If pci slot is hotplugable, use hotplug to remove it */
+	pr_debug("PCI: Removing PCI slot below EADS bridge %s\n",
+		 bus->self ? pci_name(bus->self) : "<!PHB!>");
+
 	slot = find_php_slot(dn);
 	if (slot) {
+		pr_debug("PCI: Removing hotplug slot for %04x:%02x...\n",
+			 pci_domain_nr(bus), bus->number);
+
 		if (rpaphp_deregister_slot(slot)) {
 			printk(KERN_ERR
 				"%s: unable to remove hotplug slot %s\n",
 				__func__, drc_name);
 			return -EIO;
 		}
-	} else
-		pcibios_remove_pci_devices(bus);
+	}
+
+	/* Remove all devices below slot */
+	pcibios_remove_pci_devices(bus);
 
+	/* Unmap PCI IO space */
 	if (pcibios_unmap_io_space(bus)) {
 		printk(KERN_ERR "%s: failed to unmap bus range\n",
 			__func__);
 		return -ERANGE;
 	}
 
+	/* Remove the EADS bridge device itself */
 	BUG_ON(!bus->self);
+	pr_debug("PCI: Now removing bridge device %s\n", pci_name(bus->self));
+	eeh_remove_bus_device(bus->self);
 	pci_remove_bus_device(bus->self);
+
 	return 0;
 }
 

commit 66bef8c059015ba2b36bb5759080336feb01e680
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 19:09:46 2008 -0800

    PCI: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 191954bc8e5b..9c2a22fed18b 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -147,7 +147,7 @@ static void dlpar_pci_add_bus(struct device_node *dn)
 	dev = of_create_pci_dev(dn, phb->bus, pdn->devfn);
 	if (!dev) {
 		printk(KERN_ERR "%s: failed to create pci dev for %s\n",
-				__FUNCTION__, dn->full_name);
+				__func__, dn->full_name);
 		return;
 	}
 
@@ -183,21 +183,21 @@ static int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)
 	dev = dlpar_find_new_dev(phb->bus, dn);
 
 	if (!dev) {
-		printk(KERN_ERR "%s: unable to add bus %s\n", __FUNCTION__,
+		printk(KERN_ERR "%s: unable to add bus %s\n", __func__,
 			drc_name);
 		return -EIO;
 	}
 
 	if (dev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {
 		printk(KERN_ERR "%s: unexpected header type %d, unable to add bus %s\n",
-			__FUNCTION__, dev->hdr_type, drc_name);
+			__func__, dev->hdr_type, drc_name);
 		return -EIO;
 	}
 
 	/* Add hotplug slot */
 	if (rpaphp_add_slot(dn)) {
 		printk(KERN_ERR "%s: unable to add hotplug slot %s\n",
-			__FUNCTION__, drc_name);
+			__func__, drc_name);
 		return -EIO;
 	}
 	return 0;
@@ -239,7 +239,7 @@ static int dlpar_remove_phb(char *drc_name, struct device_node *dn)
 		if (rpaphp_deregister_slot(slot)) {
 			printk(KERN_ERR
 				"%s: unable to remove hotplug slot %s\n",
-				__FUNCTION__, drc_name);
+				__func__, drc_name);
 			return -EIO;
 		}
 	}
@@ -270,7 +270,7 @@ static int dlpar_add_phb(char *drc_name, struct device_node *dn)
 
 	if (rpaphp_add_slot(dn)) {
 		printk(KERN_ERR "%s: unable to add hotplug slot %s\n",
-			__FUNCTION__, drc_name);
+			__func__, drc_name);
 		return -EIO;
 	}
 	return 0;
@@ -284,7 +284,7 @@ static int dlpar_add_vio_slot(char *drc_name, struct device_node *dn)
 	if (!vio_register_device_node(dn)) {
 		printk(KERN_ERR
 			"%s: failed to register vio node %s\n",
-			__FUNCTION__, drc_name);
+			__func__, drc_name);
 		return -EIO;
 	}
 	return 0;
@@ -384,7 +384,7 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 		if (rpaphp_deregister_slot(slot)) {
 			printk(KERN_ERR
 				"%s: unable to remove hotplug slot %s\n",
-				__FUNCTION__, drc_name);
+				__func__, drc_name);
 			return -EIO;
 		}
 	} else
@@ -392,7 +392,7 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 
 	if (pcibios_unmap_io_space(bus)) {
 		printk(KERN_ERR "%s: failed to unmap bus range\n",
-			__FUNCTION__);
+			__func__);
 		return -ERANGE;
 	}
 
@@ -458,7 +458,7 @@ int __init rpadlpar_io_init(void)
 
 	if (!is_dlpar_capable()) {
 		printk(KERN_WARNING "%s: partition not DLPAR capable\n",
-			__FUNCTION__);
+			__func__);
 		return -EPERM;
 	}
 

commit bf5e2ba28f24f82a64524ef4772c9ebe12e2cd2a
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu Dec 20 14:54:51 2007 +1100

    [POWERPC] Merge PCI resource fixups
    
    The PCI code in 32 and 64 bits fixes up resources differently.
    
    32 bits uses a header quirk plus handles bridges in pcibios_fixup_bus()
    while 64 bits does things in various places depending on whether you
    are using OF probing, using PCI hotplug, etc...
    
    This merges those by basically using the 32 bits approach for both,
    with various tweaks to make 64 bits work with the new approach.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index b169b0e2647f..191954bc8e5b 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -155,7 +155,7 @@ static void dlpar_pci_add_bus(struct device_node *dn)
 	    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)
 		of_scan_pci_bridge(dn, dev);
 
-	pcibios_fixup_new_pci_devices(dev->subordinate,0);
+	pcibios_fixup_new_pci_devices(dev->subordinate);
 
 	/* Claim new bus resources */
 	pcibios_claim_one_bus(dev->bus);

commit 26e6c66e47fe7f69ef6ddb078e312204a1f17823
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Wed Nov 28 09:04:30 2007 -0800

    pci hotplug: kernel-doc fixes
    
    acpiphp.h: not using kernel-doc, so change /** to /*
    acpiphp_core.c: lots of kernel-doc cleanups
    acpiphp_glue.c: lots of kernel-doc cleanups
    acpiphp_ibm.c: lots of kernel-doc cleanups
    cpqphp_core.c: lots of kernel-doc cleanups
    cpqphp_ctrl.c: lots of kernel-doc cleanups
    fakephp.c:  correct kernel-doc notation
    pciehp_ctrl.c: correct kernel-doc notation
    rpadlpar_core.c: correct function names & kernel-doc notation
    rpaphp_core.c: correct kernel-doc notation
    shpchp_ctrl.c: correct kernel-doc notation
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Kristen Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index deb6b5e35feb..b169b0e2647f 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -100,6 +100,7 @@ static struct device_node *find_dlpar_node(char *drc_name, int *node_type)
 
 /**
  * find_php_slot - return hotplug slot structure for device node
+ * @dn: target &device_node
  *
  * This routine will return the hotplug slot structure
  * for a given device node. Note that built-in PCI slots
@@ -293,9 +294,8 @@ static int dlpar_add_vio_slot(char *drc_name, struct device_node *dn)
  * dlpar_add_slot - DLPAR add an I/O Slot
  * @drc_name: drc-name of newly added slot
  *
- * Make the hotplug module and the kernel aware
- * of a newly added I/O Slot.
- * Return Codes -
+ * Make the hotplug module and the kernel aware of a newly added I/O Slot.
+ * Return Codes:
  * 0			Success
  * -ENODEV		Not a valid drc_name
  * -EINVAL		Slot already added
@@ -339,9 +339,9 @@ int dlpar_add_slot(char *drc_name)
 /**
  * dlpar_remove_vio_slot - DLPAR remove a virtual I/O Slot
  * @drc_name: drc-name of newly added slot
+ * @dn: &device_node
  *
- * Remove the kernel and hotplug representations
- * of an I/O Slot.
+ * Remove the kernel and hotplug representations of an I/O Slot.
  * Return Codes:
  * 0			Success
  * -EINVAL		Vio dev doesn't exist
@@ -359,11 +359,11 @@ static int dlpar_remove_vio_slot(char *drc_name, struct device_node *dn)
 }
 
 /**
- * dlpar_remove_slot - DLPAR remove a PCI I/O Slot
+ * dlpar_remove_pci_slot - DLPAR remove a PCI I/O Slot
  * @drc_name: drc-name of newly added slot
+ * @dn: &device_node
  *
- * Remove the kernel and hotplug representations
- * of a PCI I/O Slot.
+ * Remove the kernel and hotplug representations of a PCI I/O Slot.
  * Return Codes:
  * 0			Success
  * -ENODEV		Not a valid drc_name
@@ -405,8 +405,7 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
  * dlpar_remove_slot - DLPAR remove an I/O Slot
  * @drc_name: drc-name of newly added slot
  *
- * Remove the kernel and hotplug representations
- * of an I/O Slot.
+ * Remove the kernel and hotplug representations of an I/O Slot.
  * Return Codes:
  * 0			Success
  * -ENODEV		Not a valid drc_name

commit 3d5134ee8341bffc4f539049abb9e90d469b448d
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Jun 4 15:15:36 2007 +1000

    [POWERPC] Rewrite IO allocation & mapping on powerpc64
    
    This rewrites pretty much from scratch the handling of MMIO and PIO
    space allocations on powerpc64.  The main goals are:
    
     - Get rid of imalloc and use more common code where possible
     - Simplify the current mess so that PIO space is allocated and
       mapped in a single place for PCI bridges
     - Handle allocation constraints of PIO for all bridges including
       hot plugged ones within the 2GB space reserved for IO ports,
       so that devices on hotplugged busses will now work with drivers
       that assume IO ports fit in an int.
     - Cleanup and separate tracking of the ISA space in the reserved
       low 64K of IO space. No ISA -> Nothing mapped there.
    
    I booted a cell blade with IDE on PIO and MMIO and a dual G5 so
    far, that's it :-)
    
    With this patch, all allocations are done using the code in
    mm/vmalloc.c, though we use the low level __get_vm_area with
    explicit start/stop constraints in order to manage separate
    areas for vmalloc/vmap, ioremap, and PCI IOs.
    
    This greatly simplifies a lot of things, as you can see in the
    diffstat of that patch :-)
    
    A new pair of functions pcibios_map/unmap_io_space() now replace
    all of the previous code that used to manipulate PCI IOs space.
    The allocation is done at mapping time, which is now called from
    scan_phb's, just before the devices are probed (instead of after,
    which is by itself a bug fix). The only other caller is the PCI
    hotplug code for hot adding PCI-PCI bridges (slots).
    
    imalloc is gone, as is the "sub-allocation" thing, but I do beleive
    that hotplug should still work in the sense that the space allocation
    is always done by the PHB, but if you unmap a child bus of this PHB
    (which seems to be possible), then the code should properly tear
    down all the HPTE mappings for that area of the PHB allocated IO space.
    
    I now always reserve the first 64K of IO space for the bridge with
    the ISA bus on it. I have moved the code for tracking ISA in a separate
    file which should also make it smarter if we ever are capable of
    hot unplugging or re-plugging an ISA bridge.
    
    This should have a side effect on platforms like powermac where VGA IOs
    will no longer work. This is done on purpose though as they would have
    worked semi-randomly before. The idea at this point is to isolate drivers
    that might need to access those and fix them by providing a proper
    function to obtain an offset to the legacy IOs of a given bus.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index bb3c101c2c5a..deb6b5e35feb 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -159,8 +159,8 @@ static void dlpar_pci_add_bus(struct device_node *dn)
 	/* Claim new bus resources */
 	pcibios_claim_one_bus(dev->bus);
 
-	/* ioremap() for child bus, which may or may not succeed */
-	remap_bus_range(dev->subordinate);
+	/* Map IO space for child bus, which may or may not succeed */
+	pcibios_map_io_space(dev->subordinate);
 
 	/* Add new devices to global lists.  Register in proc, sysfs. */
 	pci_bus_add_devices(phb->bus);
@@ -390,7 +390,7 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 	} else
 		pcibios_remove_pci_devices(bus);
 
-	if (unmap_bus_range(bus)) {
+	if (pcibios_unmap_io_space(bus)) {
 		printk(KERN_ERR "%s: failed to unmap bus range\n",
 			__FUNCTION__);
 		return -ERANGE;

commit b5661479eeb863749ae28b9ee0dd288464311854
Author: Linas Vepstas <linas@austin.ibm.com>
Date:   Fri Apr 13 15:34:24 2007 -0700

    PCI: rpaphp: Ensure more pcibios_add/pcibios_remove symmetry
    
    Calls to pcibios_add should be symmetric with calls to pcibios_remove.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Cc: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 4d74f0b6079f..bb3c101c2c5a 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -387,13 +387,8 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 				__FUNCTION__, drc_name);
 			return -EIO;
 		}
-	} else {
-		struct pci_dev *dev, *tmp;
-		list_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {
-			eeh_remove_bus_device(dev);
-			pci_remove_bus_device(dev);
-		}
-	}
+	} else
+		pcibios_remove_pci_devices(bus);
 
 	if (unmap_bus_range(bus)) {
 		printk(KERN_ERR "%s: failed to unmap bus range\n",

commit 8485d1a123e0d367bbcbfec36acf134e6895f39a
Author: Linas Vepstas <linas@austin.ibm.com>
Date:   Fri Apr 13 15:34:21 2007 -0700

    PCI: rpaphp: Document find_php_slot()
    
    Document some of the interaction between dlpar and hotplug.
    viz, the a dlpar remove of a htoplug slot uses hotplug to remove it.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Cc: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 72383467a0d5..4d74f0b6079f 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -98,7 +98,15 @@ static struct device_node *find_dlpar_node(char *drc_name, int *node_type)
 	return NULL;
 }
 
-static struct slot *find_slot(struct device_node *dn)
+/**
+ * find_php_slot - return hotplug slot structure for device node
+ *
+ * This routine will return the hotplug slot structure
+ * for a given device node. Note that built-in PCI slots
+ * may be dlpar-able, but not hot-pluggable, so this routine
+ * will return NULL for built-in PCI slots.
+ */
+static struct slot *find_php_slot(struct device_node *dn)
 {
 	struct list_head *tmp, *n;
 	struct slot *slot;
@@ -224,9 +232,9 @@ static int dlpar_remove_phb(char *drc_name, struct device_node *dn)
 	if (!pcibios_find_pci_bus(dn))
 		return -EINVAL;
 
-	slot = find_slot(dn);
+	/* If pci slot is hotplugable, use hotplug to remove it */
+	slot = find_php_slot(dn);
 	if (slot) {
-		/* Remove hotplug slot */
 		if (rpaphp_deregister_slot(slot)) {
 			printk(KERN_ERR
 				"%s: unable to remove hotplug slot %s\n",
@@ -370,9 +378,9 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 	if (!bus)
 		return -EINVAL;
 
-	slot = find_slot(dn);
+	/* If pci slot is hotplugable, use hotplug to remove it */
+	slot = find_php_slot(dn);
 	if (slot) {
-		/* Remove hotplug slot */
 		if (rpaphp_deregister_slot(slot)) {
 			printk(KERN_ERR
 				"%s: unable to remove hotplug slot %s\n",

commit a57ed79ef1b71f6da44ebeabb41d019d172fb261
Author: John Rose <johnrose@austin.ibm.com>
Date:   Mon Nov 13 15:12:52 2006 -0800

    PCI: rpaphp: change device tree examination
    
    Change the criterion that RPA PCI Hotplug and RPA DLPAR use when
    determining the hotplug capabilities of a given device node.  The
    "device_type" property is less consistent than "name" across PCI nodes
    on newer hardware.
    
    Signed-off-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 46825fee3ae4..72383467a0d5 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -63,7 +63,7 @@ static struct device_node *find_php_slot_pci_node(char *drc_name,
 	char *type;
 	int rc;
 
-	while ((np = of_find_node_by_type(np, "pci"))) {
+	while ((np = of_find_node_by_name(np, "pci"))) {
 		rc = rpaphp_get_drc_props(np, NULL, &name, &type, NULL);
 		if (rc == 0)
 			if (!strcmp(drc_name, name) && !strcmp(drc_type, type))

commit 14cc3e2b633bb64063698980974df4535368e98f
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Mar 26 01:37:14 2006 -0800

    [PATCH] sem2mutex: misc static one-file mutexes
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Jens Axboe <axboe@suse.de>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Acked-by: Alasdair G Kergon <agk@redhat.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 3eefe2cec72d..46825fee3ae4 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -19,7 +19,7 @@
 #include <linux/string.h>
 
 #include <asm/pci-bridge.h>
-#include <asm/semaphore.h>
+#include <linux/mutex.h>
 #include <asm/rtas.h>
 #include <asm/vio.h>
 
@@ -27,7 +27,7 @@
 #include "rpaphp.h"
 #include "rpadlpar.h"
 
-static DECLARE_MUTEX(rpadlpar_sem);
+static DEFINE_MUTEX(rpadlpar_mutex);
 
 #define DLPAR_MODULE_NAME "rpadlpar_io"
 
@@ -300,7 +300,7 @@ int dlpar_add_slot(char *drc_name)
 	int node_type;
 	int rc = -EIO;
 
-	if (down_interruptible(&rpadlpar_sem))
+	if (mutex_lock_interruptible(&rpadlpar_mutex))
 		return -ERESTARTSYS;
 
 	/* Find newly added node */
@@ -324,7 +324,7 @@ int dlpar_add_slot(char *drc_name)
 
 	printk(KERN_INFO "%s: slot %s added\n", DLPAR_MODULE_NAME, drc_name);
 exit:
-	up(&rpadlpar_sem);
+	mutex_unlock(&rpadlpar_mutex);
 	return rc;
 }
 
@@ -417,7 +417,7 @@ int dlpar_remove_slot(char *drc_name)
 	int node_type;
 	int rc = 0;
 
-	if (down_interruptible(&rpadlpar_sem))
+	if (mutex_lock_interruptible(&rpadlpar_mutex))
 		return -ERESTARTSYS;
 
 	dn = find_dlpar_node(drc_name, &node_type);
@@ -439,7 +439,7 @@ int dlpar_remove_slot(char *drc_name)
 	}
 	printk(KERN_INFO "%s: slot %s removed\n", DLPAR_MODULE_NAME, drc_name);
 exit:
-	up(&rpadlpar_sem);
+	mutex_unlock(&rpadlpar_mutex);
 	return rc;
 }
 

commit 8737d6a90cd8b085c2ea9cb4c7443c87f86c3429
Author: linas@austin.ibm.com <linas@austin.ibm.com>
Date:   Thu Jan 12 18:35:23 2006 -0600

    [PATCH] powerpc/PCI hotplug: shuffle error checking to better location.
    
    Error checking is scattered through various layers of the dlpar code,
    leading to a somewhat opaque code structure. This patch consolidates
    error checking in one routine, simplifying the code a tad. There's
    also some whitespace cleanup here too.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index d3aa9df1acd4..3eefe2cec72d 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -103,13 +103,13 @@ static struct slot *find_slot(struct device_node *dn)
 	struct list_head *tmp, *n;
 	struct slot *slot;
 
-        list_for_each_safe(tmp, n, &rpaphp_slot_head) {
-                slot = list_entry(tmp, struct slot, rpaphp_slot_list);
-                if (slot->dn == dn)
-                        return slot;
-        }
+	list_for_each_safe(tmp, n, &rpaphp_slot_head) {
+		slot = list_entry(tmp, struct slot, rpaphp_slot_list);
+		if (slot->dn == dn)
+			return slot;
+	}
 
-        return NULL;
+	return NULL;
 }
 
 static struct pci_dev *dlpar_find_new_dev(struct pci_bus *parent,
@@ -126,9 +126,9 @@ static struct pci_dev *dlpar_find_new_dev(struct pci_bus *parent,
 	return NULL;
 }
 
-static struct pci_dev *dlpar_pci_add_bus(struct device_node *dn)
+static void dlpar_pci_add_bus(struct device_node *dn)
 {
-	struct pci_dn *pdn = dn->data;
+	struct pci_dn *pdn = PCI_DN(dn);
 	struct pci_controller *phb = pdn->phb;
 	struct pci_dev *dev = NULL;
 
@@ -139,7 +139,7 @@ static struct pci_dev *dlpar_pci_add_bus(struct device_node *dn)
 	if (!dev) {
 		printk(KERN_ERR "%s: failed to create pci dev for %s\n",
 				__FUNCTION__, dn->full_name);
-		return NULL;
+		return;
 	}
 
 	if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
@@ -156,35 +156,35 @@ static struct pci_dev *dlpar_pci_add_bus(struct device_node *dn)
 
 	/* Add new devices to global lists.  Register in proc, sysfs. */
 	pci_bus_add_devices(phb->bus);
-
-	/* Confirm new bridge dev was created */
-	dev = dlpar_find_new_dev(phb->bus, dn);
-	if (dev) {
-		if (dev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {
-			printk(KERN_ERR "%s: unexpected header type %d\n",
-				__FUNCTION__, dev->hdr_type);
-			return NULL;
-		}
-	}
-
-	return dev;
 }
 
 static int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)
 {
 	struct pci_dev *dev;
+	struct pci_controller *phb;
 
 	if (pcibios_find_pci_bus(dn))
 		return -EINVAL;
 
 	/* Add pci bus */
-	dev = dlpar_pci_add_bus(dn);
+	dlpar_pci_add_bus(dn);
+
+	/* Confirm new bridge dev was created */
+	phb = PCI_DN(dn)->phb;
+	dev = dlpar_find_new_dev(phb->bus, dn);
+
 	if (!dev) {
 		printk(KERN_ERR "%s: unable to add bus %s\n", __FUNCTION__,
 			drc_name);
 		return -EIO;
 	}
 
+	if (dev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {
+		printk(KERN_ERR "%s: unexpected header type %d, unable to add bus %s\n",
+			__FUNCTION__, dev->hdr_type, drc_name);
+		return -EIO;
+	}
+
 	/* Add hotplug slot */
 	if (rpaphp_add_slot(dn)) {
 		printk(KERN_ERR "%s: unable to add hotplug slot %s\n",

commit f6afbad82c6b7bab0198442592b110341fb419ba
Author: linas@austin.ibm.com <linas@austin.ibm.com>
Date:   Thu Jan 12 18:31:01 2006 -0600

    [PATCH] powerpc/PCI hotplug: cleanup: add prefix
    
    Minor cleanup. Add the prefix rpaphp_* to several generic-sounding routines.
    Remove rpaphp_remove_slot(), which is a one-liner.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 15e853e5e689..d3aa9df1acd4 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -227,7 +227,7 @@ static int dlpar_remove_phb(char *drc_name, struct device_node *dn)
 	slot = find_slot(dn);
 	if (slot) {
 		/* Remove hotplug slot */
-		if (rpaphp_remove_slot(slot)) {
+		if (rpaphp_deregister_slot(slot)) {
 			printk(KERN_ERR
 				"%s: unable to remove hotplug slot %s\n",
 				__FUNCTION__, drc_name);
@@ -373,7 +373,7 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 	slot = find_slot(dn);
 	if (slot) {
 		/* Remove hotplug slot */
-		if (rpaphp_remove_slot(slot)) {
+		if (rpaphp_deregister_slot(slot)) {
 			printk(KERN_ERR
 				"%s: unable to remove hotplug slot %s\n",
 				__FUNCTION__, drc_name);

commit 8fe64399cccf8dddcc4e5eaff270a12064f6fe9f
Author: linas@austin.ibm.com <linas@austin.ibm.com>
Date:   Thu Jan 12 18:26:27 2006 -0600

    [PATCH] powerpc/PCI hotplug: de-convolute rpaphp_unconfig_pci_adap
    
    Remove general baroqueness.  The function rpaphp_unconfig_pci_adapter()
    is really just three lines of code, once all the dbg printks are removed.
    And its called in only one place. So replace the call by the thre lines.
    Also, provide proper semaphore locking in the affected function
    disable_slot()
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 6c148106518e..15e853e5e689 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -380,7 +380,11 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 			return -EIO;
 		}
 	} else {
-		rpaphp_unconfig_pci_adapter(bus);
+		struct pci_dev *dev, *tmp;
+		list_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {
+			eeh_remove_bus_device(dev);
+			pci_remove_bus_device(dev);
+		}
 	}
 
 	if (unmap_bus_range(bus)) {

commit eca845c71816669dace4bf1954d9ab276abb0002
Author: linas@austin.ibm.com <linas@austin.ibm.com>
Date:   Thu Jan 12 18:20:26 2006 -0600

    [PATCH] powerpc/PCI hotplug: remove rpaphp_fixup_new_pci_devices()
    
    The function rpaphp_fixup_new_pci_devices() has been migrated to
    pcibios_fixup_new_pci_devices() in
    arch/powerpc/platforms/pseries/pci_dlpar.c
    This patch removes the old version.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index bc17a13fc82e..6c148106518e 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -146,7 +146,7 @@ static struct pci_dev *dlpar_pci_add_bus(struct device_node *dn)
 	    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)
 		of_scan_pci_bridge(dn, dev);
 
-	rpaphp_init_new_devs(dev->subordinate);
+	pcibios_fixup_new_pci_devices(dev->subordinate,0);
 
 	/* Claim new bus resources */
 	pcibios_claim_one_bus(dev->bus);

commit 01657868be1c21b2b8b0e683ea24bdcc2331d522
Author: linas@austin.ibm.com <linas@austin.ibm.com>
Date:   Thu Jan 12 18:18:26 2006 -0600

    [PATCH] powerpc/PCI hotplug: remove rpaphp_find_bus()
    
    The function rpaphp_find_pci_bus() has been migrated to
    pcibios_find_pci_bus() in arch/powerpc/platforms/pseries/pci_dlpar.c
    This patch removes the old version.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 7f504b380f26..bc17a13fc82e 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -174,7 +174,7 @@ static int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)
 {
 	struct pci_dev *dev;
 
-	if (rpaphp_find_pci_bus(dn))
+	if (pcibios_find_pci_bus(dn))
 		return -EINVAL;
 
 	/* Add pci bus */
@@ -221,7 +221,7 @@ static int dlpar_remove_phb(char *drc_name, struct device_node *dn)
 	struct pci_dn *pdn;
 	int rc = 0;
 
-	if (!rpaphp_find_pci_bus(dn))
+	if (!pcibios_find_pci_bus(dn))
 		return -EINVAL;
 
 	slot = find_slot(dn);
@@ -366,7 +366,7 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 	struct pci_bus *bus;
 	struct slot *slot;
 
-	bus = rpaphp_find_pci_bus(dn);
+	bus = pcibios_find_pci_bus(dn);
 	if (!bus)
 		return -EINVAL;
 

commit 3c0c6441883be7676b795939e268b90d6acab360
Author: linas <linas@austin.ibm.com>
Date:   Thu Jan 12 14:36:25 2006 -0600

    [PATCH] PCI Hotplug: PCI panic on dlpar add (add pci slot to running partition)
    
    Removing and then adding a PCI slot to a running partition results in
    a kernel panic. The current code attempts to add iospace for an entire
    root bus, which is inappropriate, and silently fails.  When a pci device
    tries to use the iospace, a page fault is taken, as the iospace had not
    been mapped, and of course the page fault cannot be resolved.
    
    This only occurs for PCI adapters using pio, which may be why it hadn't
    been seen earlier (this seems to have been broken for a while).
    This patch has survived testing of dozens of slot add and removes.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 7d93dbaf628d..7f504b380f26 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -152,7 +152,7 @@ static struct pci_dev *dlpar_pci_add_bus(struct device_node *dn)
 	pcibios_claim_one_bus(dev->bus);
 
 	/* ioremap() for child bus, which may or may not succeed */
-	(void) remap_bus_range(dev->bus);
+	remap_bus_range(dev->subordinate);
 
 	/* Add new devices to global lists.  Register in proc, sysfs. */
 	pci_bus_add_devices(phb->bus);

commit cd5b50be8d8e8e6170da3a261fc625fd603f9dc4
Author: linas@austin.ibm.com <linas@austin.ibm.com>
Date:   Thu Dec 1 18:59:58 2005 -0600

    [PATCH] PCI Hotplug/powerpc: more removal of duplicated code
    
    The RPAPHP code contains two routines that appear to be gratuitous copies
    of very similar pci code.  In particular,
    
       rpaphp_claim_resource ~~ pci_claim_resource
          (there is a minor, non-functional difference)
    
       rpadlpar_claim_one_bus == pcibios_claim_one_bus
          (the code is identical)
    
    This patch removes the rpaphp versions of the code.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 0173641c4149..7d93dbaf628d 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -112,28 +112,6 @@ static struct slot *find_slot(struct device_node *dn)
         return NULL;
 }
 
-static void rpadlpar_claim_one_bus(struct pci_bus *b)
-{
-	struct list_head *ld;
-	struct pci_bus *child_bus;
-
-	for (ld = b->devices.next; ld != &b->devices; ld = ld->next) {
-		struct pci_dev *dev = pci_dev_b(ld);
-		int i;
-
-		for (i = 0; i < PCI_NUM_RESOURCES; i++) {
-			struct resource *r = &dev->resource[i];
-
-			if (r->parent || !r->start || !r->flags)
-				continue;
-			rpaphp_claim_resource(dev, i);
-		}
-	}
-
-	list_for_each_entry(child_bus, &b->children, node)
-		rpadlpar_claim_one_bus(child_bus);
-}
-
 static struct pci_dev *dlpar_find_new_dev(struct pci_bus *parent,
 					struct device_node *dev_dn)
 {
@@ -171,7 +149,7 @@ static struct pci_dev *dlpar_pci_add_bus(struct device_node *dn)
 	rpaphp_init_new_devs(dev->subordinate);
 
 	/* Claim new bus resources */
-	rpadlpar_claim_one_bus(dev->bus);
+	pcibios_claim_one_bus(dev->bus);
 
 	/* ioremap() for child bus, which may or may not succeed */
 	(void) remap_bus_range(dev->bus);

commit d681db4aed4453c7d34adfbb64956271186514e9
Author: linas@austin.ibm.com <linas@austin.ibm.com>
Date:   Thu Dec 1 18:56:14 2005 -0600

    [PATCH] PCI Hotplug/powerpc: remove duplicated code
    
    The RPAPHP code contains a routine that duplicates some existing code.
    This patch removes the rpaphp version of the code.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Acked-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index cc03609f45d0..0173641c4149 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -154,7 +154,8 @@ static struct pci_dev *dlpar_pci_add_bus(struct device_node *dn)
 	struct pci_controller *phb = pdn->phb;
 	struct pci_dev *dev = NULL;
 
-	rpaphp_eeh_init_nodes(dn);
+	eeh_add_device_tree_early(dn);
+
 	/* Add EADS device to PHB bus, adding new entry to bus->devices */
 	dev = of_create_pci_dev(dn, phb->bus, pdn->devfn);
 	if (!dev) {

commit 5fa80fcdca9d20d30c9ecec30d4dbff4ed93a5c6
Author: John Rose <johnrose@austin.ibm.com>
Date:   Fri Nov 4 15:38:50 2005 -0600

    [PATCH] dlpar regression for ppc64 - probe change
    
    This patch contains the driver bits for enabling DLPAR and PCI Hotplug
    for the new OF-based PCI probe.  This functionality was regressed when
    the new PCI approach was introduced.  Please apply if appropriate.
    
    Signed-off-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index e8593a60ee89..cc03609f45d0 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -134,43 +134,6 @@ static void rpadlpar_claim_one_bus(struct pci_bus *b)
 		rpadlpar_claim_one_bus(child_bus);
 }
 
-static int pci_add_secondary_bus(struct device_node *dn,
-		struct pci_dev *bridge_dev)
-{
-	struct pci_dn *pdn = dn->data;
-	struct pci_controller *hose = pdn->phb;
-	struct pci_bus *child;
-	u8 sec_busno;
-
-	/* Get busno of downstream bus */
-	pci_read_config_byte(bridge_dev, PCI_SECONDARY_BUS, &sec_busno);
-
-	/* Allocate and add to children of bridge_dev->bus */
-	child = pci_add_new_bus(bridge_dev->bus, bridge_dev, sec_busno);
-	if (!child) {
-		printk(KERN_ERR "%s: could not add secondary bus\n", __FUNCTION__);
-		return -ENOMEM;
-	}
-
-	sprintf(child->name, "PCI Bus #%02x", child->number);
-
-	/* Fixup subordinate bridge bases and resources */
-	pcibios_fixup_bus(child);
-
-	/* Claim new bus resources */
-	rpadlpar_claim_one_bus(bridge_dev->bus);
-
-	if (hose->last_busno < child->number)
-		hose->last_busno = child->number;
-
-	pdn->bussubno = child->number;
-
-	/* ioremap() for child bus, which may or may not succeed */
-	remap_bus_range(child);
-
-	return 0;
-}
-
 static struct pci_dev *dlpar_find_new_dev(struct pci_bus *parent,
 					struct device_node *dev_dn)
 {
@@ -188,29 +151,41 @@ static struct pci_dev *dlpar_find_new_dev(struct pci_bus *parent,
 static struct pci_dev *dlpar_pci_add_bus(struct device_node *dn)
 {
 	struct pci_dn *pdn = dn->data;
-	struct pci_controller *hose = pdn->phb;
+	struct pci_controller *phb = pdn->phb;
 	struct pci_dev *dev = NULL;
 
-	/* Scan phb bus for EADS device, adding new one to bus->devices */
-	if (!pci_scan_single_device(hose->bus, pdn->devfn)) {
-		printk(KERN_ERR "%s: found no device on bus\n", __FUNCTION__);
+	rpaphp_eeh_init_nodes(dn);
+	/* Add EADS device to PHB bus, adding new entry to bus->devices */
+	dev = of_create_pci_dev(dn, phb->bus, pdn->devfn);
+	if (!dev) {
+		printk(KERN_ERR "%s: failed to create pci dev for %s\n",
+				__FUNCTION__, dn->full_name);
 		return NULL;
 	}
 
+	if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
+	    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)
+		of_scan_pci_bridge(dn, dev);
+
+	rpaphp_init_new_devs(dev->subordinate);
+
+	/* Claim new bus resources */
+	rpadlpar_claim_one_bus(dev->bus);
+
+	/* ioremap() for child bus, which may or may not succeed */
+	(void) remap_bus_range(dev->bus);
+
 	/* Add new devices to global lists.  Register in proc, sysfs. */
-	pci_bus_add_devices(hose->bus);
+	pci_bus_add_devices(phb->bus);
 
 	/* Confirm new bridge dev was created */
-	dev = dlpar_find_new_dev(hose->bus, dn);
+	dev = dlpar_find_new_dev(phb->bus, dn);
 	if (dev) {
 		if (dev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {
 			printk(KERN_ERR "%s: unexpected header type %d\n",
 				__FUNCTION__, dev->hdr_type);
 			return NULL;
 		}
-
-		if (pci_add_secondary_bus(dn, dev))
-			return NULL;
 	}
 
 	return dev;
@@ -219,7 +194,6 @@ static struct pci_dev *dlpar_pci_add_bus(struct device_node *dn)
 static int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)
 {
 	struct pci_dev *dev;
-	int rc;
 
 	if (rpaphp_find_pci_bus(dn))
 		return -EINVAL;
@@ -232,15 +206,6 @@ static int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)
 		return -EIO;
 	}
 
-	if (dn->child) {
-		rc = rpaphp_config_pci_adapter(dev->subordinate);
-		if (rc < 0) {
-			printk(KERN_ERR "%s: unable to enable slot %s\n",
-				__FUNCTION__, drc_name);
-			return -EIO;
-		}
-	}
-
 	/* Add hotplug slot */
 	if (rpaphp_add_slot(dn)) {
 		printk(KERN_ERR "%s: unable to add hotplug slot %s\n",
@@ -435,6 +400,8 @@ int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 				__FUNCTION__, drc_name);
 			return -EIO;
 		}
+	} else {
+		rpaphp_unconfig_pci_adapter(bus);
 	}
 
 	if (unmap_bus_range(bus)) {

commit fe98aeab8494cf431ef62e080cbe1dc1b6f5bd49
Author: Linas Vepstas <linas@linas.org>
Date:   Thu Nov 3 18:51:17 2005 -0600

    [PATCH] ppc64: bugfix: crash on PHB add
    
    19-rpaphp-crashing.patch
    
    This patch fixes a bug related to dlpar PHB add, after a PHB removal.
    
    -- The crash was due to the PHB not having a pci_dn structure yet,
       when the phb is being added.
    
    This code survived testing, of adding and removeig the PHB and all slots
    underneath it, 17 times so far, as of this writing.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index fcb66b9a0e28..e8593a60ee89 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -306,7 +306,7 @@ static int dlpar_add_phb(char *drc_name, struct device_node *dn)
 {
 	struct pci_controller *phb;
 
-	if (PCI_DN(dn)->phb) {
+	if (PCI_DN(dn) && PCI_DN(dn)->phb) {
 		/* PHB already exists */
 		return -EINVAL;
 	}

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index ad1017da8656..fcb66b9a0e28 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -16,10 +16,13 @@
  */
 #include <linux/init.h>
 #include <linux/pci.h>
+#include <linux/string.h>
+
 #include <asm/pci-bridge.h>
 #include <asm/semaphore.h>
 #include <asm/rtas.h>
 #include <asm/vio.h>
+
 #include "../pci.h"
 #include "rpaphp.h"
 #include "rpadlpar.h"

commit 1635317facea3094ddf34082cd86797efb1d9f7e
Author: Paul Mackerras <paulus@samba.org>
Date:   Tue Sep 6 13:17:54 2005 +1000

    [PATCH] Separate pci bits out of struct device_node
    
    This patch pulls the PCI-related junk out of struct device_node and
    puts it in a separate structure, struct pci_dn.  The device_node now
    just has a void * pointer in it, which points to a struct pci_dn for
    nodes that represent PCI devices.  It could potentially be used in
    future for device-specific data for other sorts of devices, such as
    virtual I/O devices.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 4ada15111af0..ad1017da8656 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -134,7 +134,8 @@ static void rpadlpar_claim_one_bus(struct pci_bus *b)
 static int pci_add_secondary_bus(struct device_node *dn,
 		struct pci_dev *bridge_dev)
 {
-	struct pci_controller *hose = dn->phb;
+	struct pci_dn *pdn = dn->data;
+	struct pci_controller *hose = pdn->phb;
 	struct pci_bus *child;
 	u8 sec_busno;
 
@@ -159,7 +160,7 @@ static int pci_add_secondary_bus(struct device_node *dn,
 	if (hose->last_busno < child->number)
 		hose->last_busno = child->number;
 
-	dn->bussubno = child->number;
+	pdn->bussubno = child->number;
 
 	/* ioremap() for child bus, which may or may not succeed */
 	remap_bus_range(child);
@@ -183,11 +184,12 @@ static struct pci_dev *dlpar_find_new_dev(struct pci_bus *parent,
 
 static struct pci_dev *dlpar_pci_add_bus(struct device_node *dn)
 {
-	struct pci_controller *hose = dn->phb;
+	struct pci_dn *pdn = dn->data;
+	struct pci_controller *hose = pdn->phb;
 	struct pci_dev *dev = NULL;
 
 	/* Scan phb bus for EADS device, adding new one to bus->devices */
-	if (!pci_scan_single_device(hose->bus, dn->devfn)) {
+	if (!pci_scan_single_device(hose->bus, pdn->devfn)) {
 		printk(KERN_ERR "%s: found no device on bus\n", __FUNCTION__);
 		return NULL;
 	}
@@ -269,6 +271,7 @@ static int dlpar_remove_root_bus(struct pci_controller *phb)
 static int dlpar_remove_phb(char *drc_name, struct device_node *dn)
 {
 	struct slot *slot;
+	struct pci_dn *pdn;
 	int rc = 0;
 
 	if (!rpaphp_find_pci_bus(dn))
@@ -285,12 +288,13 @@ static int dlpar_remove_phb(char *drc_name, struct device_node *dn)
 		}
 	}
 
-	BUG_ON(!dn->phb);
-	rc = dlpar_remove_root_bus(dn->phb);
+	pdn = dn->data;
+	BUG_ON(!pdn || !pdn->phb);
+	rc = dlpar_remove_root_bus(pdn->phb);
 	if (rc < 0)
 		return rc;
 
-	dn->phb = NULL;
+	pdn->phb = NULL;
 
 	return 0;
 }
@@ -299,7 +303,7 @@ static int dlpar_add_phb(char *drc_name, struct device_node *dn)
 {
 	struct pci_controller *phb;
 
-	if (dn->phb) {
+	if (PCI_DN(dn)->phb) {
 		/* PHB already exists */
 		return -EINVAL;
 	}

commit 56d8456b06ad1316bff3c75caed5e06e786f20d8
Author: John Rose <johnrose@austin.ibm.com>
Date:   Mon Jul 25 10:17:03 2005 -0500

    [PATCH] PCI Hotplug: rpaphp: Purify hotplug
    
    Currently rpaphp registers the following bus types as hotplug slots:
    1) Actual PCI Hotplug slots
    2) Embedded/Internal PCI slots
    3) PCI Host Bridges
    
    The second and third bus types are not actually direct parents of
    removable adapters.  As such, the rpaphp has special case code to fake
    results for attributes like power, adapter status, etc.  This patch
    removes types 2 and 3 from the rpaphp module.
    
    This patch also changes the DLPAR module so that slots can be
    DLPAR-added/removed without having been designated as hotplug-capable.
    
    Signed-off-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index f2a73f70e58c..4ada15111af0 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -26,6 +26,8 @@
 
 static DECLARE_MUTEX(rpadlpar_sem);
 
+#define DLPAR_MODULE_NAME "rpadlpar_io"
+
 #define NODE_TYPE_VIO  1
 #define NODE_TYPE_SLOT 2
 #define NODE_TYPE_PHB  3
@@ -93,14 +95,14 @@ static struct device_node *find_dlpar_node(char *drc_name, int *node_type)
 	return NULL;
 }
 
-static struct slot *find_slot(char *drc_name)
+static struct slot *find_slot(struct device_node *dn)
 {
 	struct list_head *tmp, *n;
 	struct slot *slot;
 
         list_for_each_safe(tmp, n, &rpaphp_slot_head) {
                 slot = list_entry(tmp, struct slot, rpaphp_slot_list);
-                if (strcmp(slot->location, drc_name) == 0)
+                if (slot->dn == dn)
                         return slot;
         }
 
@@ -214,6 +216,9 @@ static int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)
 	struct pci_dev *dev;
 	int rc;
 
+	if (rpaphp_find_pci_bus(dn))
+		return -EINVAL;
+
 	/* Add pci bus */
 	dev = dlpar_pci_add_bus(dn);
 	if (!dev) {
@@ -261,36 +266,32 @@ static int dlpar_remove_root_bus(struct pci_controller *phb)
 	return 0;
 }
 
-static int dlpar_remove_phb(struct slot *slot)
+static int dlpar_remove_phb(char *drc_name, struct device_node *dn)
 {
-	struct pci_controller *phb;
-	struct device_node *dn;
+	struct slot *slot;
 	int rc = 0;
 
-	dn = slot->dn;
-	if (!dn) {
-		printk(KERN_ERR "%s: unexpected NULL slot device node\n",
-				__FUNCTION__);
-		return -EIO;
-	}
-
-	phb = dn->phb;
-	if (!phb) {
-		printk(KERN_ERR "%s: unexpected NULL phb pointer\n",
-				__FUNCTION__);
-		return -EIO;
-	}
+	if (!rpaphp_find_pci_bus(dn))
+		return -EINVAL;
 
-	if (rpaphp_remove_slot(slot)) {
-		printk(KERN_ERR "%s: unable to remove hotplug slot %s\n",
-			__FUNCTION__, slot->location);
-		return -EIO;
+	slot = find_slot(dn);
+	if (slot) {
+		/* Remove hotplug slot */
+		if (rpaphp_remove_slot(slot)) {
+			printk(KERN_ERR
+				"%s: unable to remove hotplug slot %s\n",
+				__FUNCTION__, drc_name);
+			return -EIO;
+		}
 	}
 
-	rc = dlpar_remove_root_bus(phb);
+	BUG_ON(!dn->phb);
+	rc = dlpar_remove_root_bus(dn->phb);
 	if (rc < 0)
 		return rc;
 
+	dn->phb = NULL;
+
 	return 0;
 }
 
@@ -298,9 +299,14 @@ static int dlpar_add_phb(char *drc_name, struct device_node *dn)
 {
 	struct pci_controller *phb;
 
+	if (dn->phb) {
+		/* PHB already exists */
+		return -EINVAL;
+	}
+
 	phb = init_phb_dynamic(dn);
 	if (!phb)
-		return -EINVAL;
+		return -EIO;
 
 	if (rpaphp_add_slot(dn)) {
 		printk(KERN_ERR "%s: unable to add hotplug slot %s\n",
@@ -310,6 +316,20 @@ static int dlpar_add_phb(char *drc_name, struct device_node *dn)
 	return 0;
 }
 
+static int dlpar_add_vio_slot(char *drc_name, struct device_node *dn)
+{
+	if (vio_find_node(dn))
+		return -EINVAL;
+
+	if (!vio_register_device_node(dn)) {
+		printk(KERN_ERR
+			"%s: failed to register vio node %s\n",
+			__FUNCTION__, drc_name);
+		return -EIO;
+	}
+	return 0;
+}
+
 /**
  * dlpar_add_slot - DLPAR add an I/O Slot
  * @drc_name: drc-name of newly added slot
@@ -327,17 +347,11 @@ int dlpar_add_slot(char *drc_name)
 {
 	struct device_node *dn = NULL;
 	int node_type;
-	int rc;
+	int rc = -EIO;
 
 	if (down_interruptible(&rpadlpar_sem))
 		return -ERESTARTSYS;
 
-	/* Check for existing hotplug slot */
-	if (find_slot(drc_name)) {
-		rc = -EINVAL;
-		goto exit;
-	}
-
 	/* Find newly added node */
 	dn = find_dlpar_node(drc_name, &node_type);
 	if (!dn) {
@@ -345,32 +359,19 @@ int dlpar_add_slot(char *drc_name)
 		goto exit;
 	}
 
-	rc = -EIO;
 	switch (node_type) {
 		case NODE_TYPE_VIO:
-			if (!vio_register_device_node(dn)) {
-				printk(KERN_ERR
-					"%s: failed to register vio node %s\n",
-					__FUNCTION__, drc_name);
-				goto exit;
-			}
+			rc = dlpar_add_vio_slot(drc_name, dn);
 			break;
 		case NODE_TYPE_SLOT:
 			rc = dlpar_add_pci_slot(drc_name, dn);
-			if (rc)
-				goto exit;
 			break;
 		case NODE_TYPE_PHB:
 			rc = dlpar_add_phb(drc_name, dn);
-			if (rc)
-				goto exit;
 			break;
-		default:
-			printk("%s: unexpected node type\n", __FUNCTION__);
-			goto exit;
 	}
 
-	rc = 0;
+	printk(KERN_INFO "%s: slot %s added\n", DLPAR_MODULE_NAME, drc_name);
 exit:
 	up(&rpadlpar_sem);
 	return rc;
@@ -384,18 +385,15 @@ int dlpar_add_slot(char *drc_name)
  * of an I/O Slot.
  * Return Codes:
  * 0			Success
- * -EIO			Internal  Error
+ * -EINVAL		Vio dev doesn't exist
  */
-static int dlpar_remove_vio_slot(struct device_node *dn, char *drc_name)
+static int dlpar_remove_vio_slot(char *drc_name, struct device_node *dn)
 {
 	struct vio_dev *vio_dev;
 
 	vio_dev = vio_find_node(dn);
-	if (!vio_dev) {
-		printk(KERN_ERR "%s: %s does not correspond to a vio dev\n",
-				__FUNCTION__, drc_name);
-		return -EIO;
-	}
+	if (!vio_dev)
+		return -EINVAL;
 
 	vio_unregister_device(vio_dev);
 	return 0;
@@ -412,15 +410,24 @@ static int dlpar_remove_vio_slot(struct device_node *dn, char *drc_name)
  * -ENODEV		Not a valid drc_name
  * -EIO			Internal PCI Error
  */
-int dlpar_remove_pci_slot(struct slot *slot, char *drc_name)
+int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)
 {
-	struct pci_bus *bus = slot->bus;
+	struct pci_bus *bus;
+	struct slot *slot;
 
-	/* Remove hotplug slot */
-	if (rpaphp_remove_slot(slot)) {
-		printk(KERN_ERR "%s: unable to remove hotplug slot %s\n",
-			__FUNCTION__, drc_name);
-		return -EIO;
+	bus = rpaphp_find_pci_bus(dn);
+	if (!bus)
+		return -EINVAL;
+
+	slot = find_slot(dn);
+	if (slot) {
+		/* Remove hotplug slot */
+		if (rpaphp_remove_slot(slot)) {
+			printk(KERN_ERR
+				"%s: unable to remove hotplug slot %s\n",
+				__FUNCTION__, drc_name);
+			return -EIO;
+		}
 	}
 
 	if (unmap_bus_range(bus)) {
@@ -450,7 +457,6 @@ int dlpar_remove_pci_slot(struct slot *slot, char *drc_name)
 int dlpar_remove_slot(char *drc_name)
 {
 	struct device_node *dn;
-	struct slot *slot;
 	int node_type;
 	int rc = 0;
 
@@ -463,22 +469,18 @@ int dlpar_remove_slot(char *drc_name)
 		goto exit;
 	}
 
-	if (node_type == NODE_TYPE_VIO) {
-		rc = dlpar_remove_vio_slot(dn, drc_name);
-	} else {
-		slot = find_slot(drc_name);
-		if (!slot) {
-			rc = -EINVAL;
-			goto exit;
-		}
-
-		if (node_type == NODE_TYPE_PHB)
-			rc = dlpar_remove_phb(slot);
-		else {
-			/* NODE_TYPE_SLOT */
-			rc = dlpar_remove_pci_slot(slot, drc_name);
-		}
+	switch (node_type) {
+		case NODE_TYPE_VIO:
+			rc = dlpar_remove_vio_slot(drc_name, dn);
+			break;
+		case NODE_TYPE_PHB:
+			rc = dlpar_remove_phb(drc_name, dn);
+			break;
+		case NODE_TYPE_SLOT:
+			rc = dlpar_remove_pci_slot(drc_name, dn);
+			break;
 	}
+	printk(KERN_INFO "%s: slot %s removed\n", DLPAR_MODULE_NAME, drc_name);
 exit:
 	up(&rpadlpar_sem);
 	return rc;

commit 940903c5a5a906c622a79b3101586deb1a1b3480
Author: John Rose <johnrose@austin.ibm.com>
Date:   Mon Jul 25 10:16:58 2005 -0500

    [PATCH] PCI Hotplug: rpaphp: Export slot enable
    
    This patch exports rpaphp_config_pci_adapter() for use by the rpadlpar
    module.  It also changes this function by removing any dependencies on
    struct slot.  The patch also changes the RPA DLPAR-add path to enable
    newly-added slots in a separate step from that which registers them as
    hotplug slots.
    
    Signed-off-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 2ee7eb513e6c..f2a73f70e58c 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -209,9 +209,10 @@ static struct pci_dev *dlpar_pci_add_bus(struct device_node *dn)
 	return dev;
 }
 
-static inline int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)
+static int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)
 {
 	struct pci_dev *dev;
+	int rc;
 
 	/* Add pci bus */
 	dev = dlpar_pci_add_bus(dn);
@@ -221,6 +222,15 @@ static inline int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)
 		return -EIO;
 	}
 
+	if (dn->child) {
+		rc = rpaphp_config_pci_adapter(dev->subordinate);
+		if (rc < 0) {
+			printk(KERN_ERR "%s: unable to enable slot %s\n",
+				__FUNCTION__, drc_name);
+			return -EIO;
+		}
+	}
+
 	/* Add hotplug slot */
 	if (rpaphp_add_slot(dn)) {
 		printk(KERN_ERR "%s: unable to add hotplug slot %s\n",

commit 0945cd5f908a09ad99bf42d7ded16f26f24f317d
Author: John Rose <johnrose@austin.ibm.com>
Date:   Mon Jul 25 10:16:53 2005 -0500

    [PATCH] PCI Hotplug: rpaphp: Remove rpaphp_find_pci
    
    The rpaphp module currently uses a fragile method to find a pci device
    by its device node.  This function is unnecessary, so this patch scraps
    it.
    
    Signed-off-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 7f868edaa72d..2ee7eb513e6c 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -165,6 +165,20 @@ static int pci_add_secondary_bus(struct device_node *dn,
 	return 0;
 }
 
+static struct pci_dev *dlpar_find_new_dev(struct pci_bus *parent,
+					struct device_node *dev_dn)
+{
+	struct pci_dev *tmp = NULL;
+	struct device_node *child_dn;
+
+	list_for_each_entry(tmp, &parent->devices, bus_list) {
+		child_dn = pci_device_to_OF_node(tmp);
+		if (child_dn == dev_dn)
+			return tmp;
+	}
+	return NULL;
+}
+
 static struct pci_dev *dlpar_pci_add_bus(struct device_node *dn)
 {
 	struct pci_controller *hose = dn->phb;
@@ -180,21 +194,18 @@ static struct pci_dev *dlpar_pci_add_bus(struct device_node *dn)
 	pci_bus_add_devices(hose->bus);
 
 	/* Confirm new bridge dev was created */
-	dev = rpaphp_find_pci_dev(dn);
-	if (!dev) {
-		printk(KERN_ERR "%s: failed to add pci device\n", __FUNCTION__);
-		return NULL;
-	}
+	dev = dlpar_find_new_dev(hose->bus, dn);
+	if (dev) {
+		if (dev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {
+			printk(KERN_ERR "%s: unexpected header type %d\n",
+				__FUNCTION__, dev->hdr_type);
+			return NULL;
+		}
 
-	if (dev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {
-		printk(KERN_ERR "%s: unexpected header type %d\n",
-			__FUNCTION__, dev->hdr_type);
-		return NULL;
+		if (pci_add_secondary_bus(dn, dev))
+			return NULL;
 	}
 
-	if (pci_add_secondary_bus(dn, dev))
-		return NULL;
-
 	return dev;
 }
 

commit 9c209c919df95f83aa042b3352c43841ad15a02b
Author: John Rose <johnrose@austin.ibm.com>
Date:   Mon Jul 25 11:13:38 2005 -0500

    [PATCH] PCI Hotplug: rpaphp: Change slot pci reference
    
    The slot structure in the rpaphp module currently references the PCI
    contents of the slot using the PCI device of the parent bridge.  This
    is unnecessary, since the module is actually interested in the
    subordinate bus of the bridge.  The dependency on a PCI bridge device
    also prohibits the module from registering hotplug slots that have a
    root bridge as a parent, since root bridges on PPC64 don't have PCI
    devices.
    
    This patch changes struct slot to reference the PCI subsystem using a
    pci_bus rather than a pci_dev.
    
    Signed-off-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index d7f1319f167a..7f868edaa72d 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -198,28 +198,6 @@ static struct pci_dev *dlpar_pci_add_bus(struct device_node *dn)
 	return dev;
 }
 
-static int dlpar_pci_remove_bus(struct pci_dev *bridge_dev)
-{
-	struct pci_bus *secondary_bus;
-
-	if (!bridge_dev) {
-		printk(KERN_ERR "%s: unexpected null device\n",
-			__FUNCTION__);
-		return -EINVAL;
-	}
-
-	secondary_bus = bridge_dev->subordinate;
-
-	if (unmap_bus_range(secondary_bus)) {
-		printk(KERN_ERR "%s: failed to unmap bus range\n",
-			__FUNCTION__);
-		return -ERANGE;
-	}
-
-	pci_remove_bus_device(bridge_dev);
-	return 0;
-}
-
 static inline int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)
 {
 	struct pci_dev *dev;
@@ -415,14 +393,7 @@ static int dlpar_remove_vio_slot(struct device_node *dn, char *drc_name)
  */
 int dlpar_remove_pci_slot(struct slot *slot, char *drc_name)
 {
-	struct pci_dev *bridge_dev;
-
-	bridge_dev = slot->bridge;
-	if (!bridge_dev) {
-		printk(KERN_ERR "%s: unexpected null bridge device\n",
-			__FUNCTION__);
-		return -EIO;
-	}
+	struct pci_bus *bus = slot->bus;
 
 	/* Remove hotplug slot */
 	if (rpaphp_remove_slot(slot)) {
@@ -431,13 +402,14 @@ int dlpar_remove_pci_slot(struct slot *slot, char *drc_name)
 		return -EIO;
 	}
 
-	/* Remove pci bus */
-
-	if (dlpar_pci_remove_bus(bridge_dev)) {
-		printk(KERN_ERR "%s: unable to remove pci bus %s\n",
-			__FUNCTION__, drc_name);
-		return -EIO;
+	if (unmap_bus_range(bus)) {
+		printk(KERN_ERR "%s: failed to unmap bus range\n",
+			__FUNCTION__);
+		return -ERANGE;
 	}
+
+	BUG_ON(!bus->self);
+	pci_remove_bus_device(bus->self);
 	return 0;
 }
 

commit 5eeb8c63a38ff20285f3bbe7bcfe5e7c33c8ba14
Author: John Rose <johnrose@austin.ibm.com>
Date:   Mon Jul 25 10:16:42 2005 -0500

    [PATCH] PCI Hotplug: rpaphp: Move VIO registration
    
    Currently, rpaphp registers Virtual I/O slots as hotplug slots.  The
    only purpose of this registration is to ensure that the VIO subsystem
    is notified of new VIO buses during DLPAR adds.  Similarly, rpaphp
    notifies the VIO subsystem when a VIO bus is DLPAR-removed.  The rpaphp
    module has special case code to fake results for attributes like power,
    adapter status, etc.
    
    The VIO register/unregister functions could just as easily be made from
    the DLPAR module.  This patch moves the VIO registration calls to the
    DLPAR module, and removes the VIO fluff from rpaphp altogether.
    
    Signed-off-by: John Rose <johnrose@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index 86b384e42717..d7f1319f167a 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -19,6 +19,7 @@
 #include <asm/pci-bridge.h>
 #include <asm/semaphore.h>
 #include <asm/rtas.h>
+#include <asm/vio.h>
 #include "../pci.h"
 #include "rpaphp.h"
 #include "rpadlpar.h"
@@ -29,23 +30,23 @@ static DECLARE_MUTEX(rpadlpar_sem);
 #define NODE_TYPE_SLOT 2
 #define NODE_TYPE_PHB  3
 
-static struct device_node *find_php_slot_vio_node(char *drc_name)
+static struct device_node *find_vio_slot_node(char *drc_name)
 {
-	struct device_node *child;
 	struct device_node *parent = of_find_node_by_name(NULL, "vdevice");
-	char *loc_code;
+	struct device_node *dn = NULL;
+	char *name;
+	int rc;
 
 	if (!parent)
 		return NULL;
 
-	for (child = of_get_next_child(parent, NULL);
-		child; child = of_get_next_child(parent, child)) {
-		loc_code = get_property(child, "ibm,loc-code", NULL);
-		if (loc_code && !strncmp(loc_code, drc_name, strlen(drc_name)))
-			return child;
+	while ((dn = of_get_next_child(parent, dn))) {
+		rc = rpaphp_get_drc_props(dn, NULL, &name, NULL, NULL);
+		if ((rc == 0) && (!strcmp(drc_name, name)))
+			break;
 	}
 
-	return NULL;
+	return dn;
 }
 
 /* Find dlpar-capable pci node that contains the specified name and type */
@@ -67,7 +68,7 @@ static struct device_node *find_php_slot_pci_node(char *drc_name,
 	return np;
 }
 
-static struct device_node *find_newly_added_node(char *drc_name, int *node_type)
+static struct device_node *find_dlpar_node(char *drc_name, int *node_type)
 {
 	struct device_node *dn;
 
@@ -83,7 +84,7 @@ static struct device_node *find_newly_added_node(char *drc_name, int *node_type)
 		return dn;
 	}
 
-	dn = find_php_slot_vio_node(drc_name);
+	dn = find_vio_slot_node(drc_name);
 	if (dn) {
 		*node_type = NODE_TYPE_VIO;
 		return dn;
@@ -231,6 +232,12 @@ static inline int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)
 		return -EIO;
 	}
 
+	/* Add hotplug slot */
+	if (rpaphp_add_slot(dn)) {
+		printk(KERN_ERR "%s: unable to add hotplug slot %s\n",
+			__FUNCTION__, drc_name);
+		return -EIO;
+	}
 	return 0;
 }
 
@@ -288,7 +295,7 @@ static int dlpar_remove_phb(struct slot *slot)
 	return 0;
 }
 
-static int dlpar_add_phb(struct device_node *dn)
+static int dlpar_add_phb(char *drc_name, struct device_node *dn)
 {
 	struct pci_controller *phb;
 
@@ -296,6 +303,11 @@ static int dlpar_add_phb(struct device_node *dn)
 	if (!phb)
 		return -EINVAL;
 
+	if (rpaphp_add_slot(dn)) {
+		printk(KERN_ERR "%s: unable to add hotplug slot %s\n",
+			__FUNCTION__, drc_name);
+		return -EIO;
+	}
 	return 0;
 }
 
@@ -316,7 +328,7 @@ int dlpar_add_slot(char *drc_name)
 {
 	struct device_node *dn = NULL;
 	int node_type;
-	int rc = 0;
+	int rc;
 
 	if (down_interruptible(&rpadlpar_sem))
 		return -ERESTARTSYS;
@@ -327,32 +339,39 @@ int dlpar_add_slot(char *drc_name)
 		goto exit;
 	}
 
-	dn = find_newly_added_node(drc_name, &node_type);
+	/* Find newly added node */
+	dn = find_dlpar_node(drc_name, &node_type);
 	if (!dn) {
 		rc = -ENODEV;
 		goto exit;
 	}
 
+	rc = -EIO;
 	switch (node_type) {
 		case NODE_TYPE_VIO:
-			/* Just add hotplug slot */
+			if (!vio_register_device_node(dn)) {
+				printk(KERN_ERR
+					"%s: failed to register vio node %s\n",
+					__FUNCTION__, drc_name);
+				goto exit;
+			}
 			break;
 		case NODE_TYPE_SLOT:
 			rc = dlpar_add_pci_slot(drc_name, dn);
+			if (rc)
+				goto exit;
 			break;
 		case NODE_TYPE_PHB:
-			rc = dlpar_add_phb(dn);
+			rc = dlpar_add_phb(drc_name, dn);
+			if (rc)
+				goto exit;
 			break;
 		default:
 			printk("%s: unexpected node type\n", __FUNCTION__);
-			return -EIO;
+			goto exit;
 	}
 
-	if (!rc && rpaphp_add_slot(dn)) {
-		printk(KERN_ERR "%s: unable to add hotplug slot %s\n",
-			__FUNCTION__, drc_name);
-		rc = -EIO;
-	}
+	rc = 0;
 exit:
 	up(&rpadlpar_sem);
 	return rc;
@@ -368,15 +387,18 @@ int dlpar_add_slot(char *drc_name)
  * 0			Success
  * -EIO			Internal  Error
  */
-int dlpar_remove_vio_slot(struct slot *slot, char *drc_name)
+static int dlpar_remove_vio_slot(struct device_node *dn, char *drc_name)
 {
-	/* Remove hotplug slot */
+	struct vio_dev *vio_dev;
 
-	if (rpaphp_remove_slot(slot)) {
-		printk(KERN_ERR "%s: unable to remove hotplug slot %s\n",
-			__FUNCTION__, drc_name);
+	vio_dev = vio_find_node(dn);
+	if (!vio_dev) {
+		printk(KERN_ERR "%s: %s does not correspond to a vio dev\n",
+				__FUNCTION__, drc_name);
 		return -EIO;
 	}
+
+	vio_unregister_device(vio_dev);
 	return 0;
 }
 
@@ -434,36 +456,34 @@ int dlpar_remove_pci_slot(struct slot *slot, char *drc_name)
  */
 int dlpar_remove_slot(char *drc_name)
 {
+	struct device_node *dn;
 	struct slot *slot;
+	int node_type;
 	int rc = 0;
 
 	if (down_interruptible(&rpadlpar_sem))
 		return -ERESTARTSYS;
 
-	if (!find_php_slot_vio_node(drc_name) &&
-	    !find_php_slot_pci_node(drc_name, "SLOT") &&
-	    !find_php_slot_pci_node(drc_name, "PHB")) {
+	dn = find_dlpar_node(drc_name, &node_type);
+	if (!dn) {
 		rc = -ENODEV;
 		goto exit;
 	}
 
-	slot = find_slot(drc_name);
-	if (!slot) {
-		rc = -EINVAL;
-		goto exit;
-	}
-	
-	if (slot->type == PHB) {
-		rc = dlpar_remove_phb(slot);
+	if (node_type == NODE_TYPE_VIO) {
+		rc = dlpar_remove_vio_slot(dn, drc_name);
 	} else {
-		switch (slot->dev_type) {
-			case PCI_DEV:
-				rc = dlpar_remove_pci_slot(slot, drc_name);
-				break;
+		slot = find_slot(drc_name);
+		if (!slot) {
+			rc = -EINVAL;
+			goto exit;
+		}
 
-			case VIO_DEV:
-				rc = dlpar_remove_vio_slot(slot, drc_name);
-				break;
+		if (node_type == NODE_TYPE_PHB)
+			rc = dlpar_remove_phb(slot);
+		else {
+			/* NODE_TYPE_SLOT */
+			rc = dlpar_remove_pci_slot(slot, drc_name);
 		}
 	}
 exit:

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
new file mode 100644
index 000000000000..86b384e42717
--- /dev/null
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -0,0 +1,503 @@
+/*
+ * Interface for Dynamic Logical Partitioning of I/O Slots on
+ * RPA-compliant PPC64 platform.
+ *
+ * John Rose <johnrose@austin.ibm.com>
+ * Linda Xie <lxie@us.ibm.com>
+ *
+ * October 2003
+ *
+ * Copyright (C) 2003 IBM.
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <asm/pci-bridge.h>
+#include <asm/semaphore.h>
+#include <asm/rtas.h>
+#include "../pci.h"
+#include "rpaphp.h"
+#include "rpadlpar.h"
+
+static DECLARE_MUTEX(rpadlpar_sem);
+
+#define NODE_TYPE_VIO  1
+#define NODE_TYPE_SLOT 2
+#define NODE_TYPE_PHB  3
+
+static struct device_node *find_php_slot_vio_node(char *drc_name)
+{
+	struct device_node *child;
+	struct device_node *parent = of_find_node_by_name(NULL, "vdevice");
+	char *loc_code;
+
+	if (!parent)
+		return NULL;
+
+	for (child = of_get_next_child(parent, NULL);
+		child; child = of_get_next_child(parent, child)) {
+		loc_code = get_property(child, "ibm,loc-code", NULL);
+		if (loc_code && !strncmp(loc_code, drc_name, strlen(drc_name)))
+			return child;
+	}
+
+	return NULL;
+}
+
+/* Find dlpar-capable pci node that contains the specified name and type */
+static struct device_node *find_php_slot_pci_node(char *drc_name,
+						  char *drc_type)
+{
+	struct device_node *np = NULL;
+	char *name;
+	char *type;
+	int rc;
+
+	while ((np = of_find_node_by_type(np, "pci"))) {
+		rc = rpaphp_get_drc_props(np, NULL, &name, &type, NULL);
+		if (rc == 0)
+			if (!strcmp(drc_name, name) && !strcmp(drc_type, type))
+				break;
+	}
+
+	return np;
+}
+
+static struct device_node *find_newly_added_node(char *drc_name, int *node_type)
+{
+	struct device_node *dn;
+
+	dn = find_php_slot_pci_node(drc_name, "SLOT");
+	if (dn) {
+		*node_type = NODE_TYPE_SLOT;
+		return dn;
+	}
+
+	dn = find_php_slot_pci_node(drc_name, "PHB");
+	if (dn) {
+		*node_type = NODE_TYPE_PHB;
+		return dn;
+	}
+
+	dn = find_php_slot_vio_node(drc_name);
+	if (dn) {
+		*node_type = NODE_TYPE_VIO;
+		return dn;
+	}
+
+	return NULL;
+}
+
+static struct slot *find_slot(char *drc_name)
+{
+	struct list_head *tmp, *n;
+	struct slot *slot;
+
+        list_for_each_safe(tmp, n, &rpaphp_slot_head) {
+                slot = list_entry(tmp, struct slot, rpaphp_slot_list);
+                if (strcmp(slot->location, drc_name) == 0)
+                        return slot;
+        }
+
+        return NULL;
+}
+
+static void rpadlpar_claim_one_bus(struct pci_bus *b)
+{
+	struct list_head *ld;
+	struct pci_bus *child_bus;
+
+	for (ld = b->devices.next; ld != &b->devices; ld = ld->next) {
+		struct pci_dev *dev = pci_dev_b(ld);
+		int i;
+
+		for (i = 0; i < PCI_NUM_RESOURCES; i++) {
+			struct resource *r = &dev->resource[i];
+
+			if (r->parent || !r->start || !r->flags)
+				continue;
+			rpaphp_claim_resource(dev, i);
+		}
+	}
+
+	list_for_each_entry(child_bus, &b->children, node)
+		rpadlpar_claim_one_bus(child_bus);
+}
+
+static int pci_add_secondary_bus(struct device_node *dn,
+		struct pci_dev *bridge_dev)
+{
+	struct pci_controller *hose = dn->phb;
+	struct pci_bus *child;
+	u8 sec_busno;
+
+	/* Get busno of downstream bus */
+	pci_read_config_byte(bridge_dev, PCI_SECONDARY_BUS, &sec_busno);
+
+	/* Allocate and add to children of bridge_dev->bus */
+	child = pci_add_new_bus(bridge_dev->bus, bridge_dev, sec_busno);
+	if (!child) {
+		printk(KERN_ERR "%s: could not add secondary bus\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	sprintf(child->name, "PCI Bus #%02x", child->number);
+
+	/* Fixup subordinate bridge bases and resources */
+	pcibios_fixup_bus(child);
+
+	/* Claim new bus resources */
+	rpadlpar_claim_one_bus(bridge_dev->bus);
+
+	if (hose->last_busno < child->number)
+		hose->last_busno = child->number;
+
+	dn->bussubno = child->number;
+
+	/* ioremap() for child bus, which may or may not succeed */
+	remap_bus_range(child);
+
+	return 0;
+}
+
+static struct pci_dev *dlpar_pci_add_bus(struct device_node *dn)
+{
+	struct pci_controller *hose = dn->phb;
+	struct pci_dev *dev = NULL;
+
+	/* Scan phb bus for EADS device, adding new one to bus->devices */
+	if (!pci_scan_single_device(hose->bus, dn->devfn)) {
+		printk(KERN_ERR "%s: found no device on bus\n", __FUNCTION__);
+		return NULL;
+	}
+
+	/* Add new devices to global lists.  Register in proc, sysfs. */
+	pci_bus_add_devices(hose->bus);
+
+	/* Confirm new bridge dev was created */
+	dev = rpaphp_find_pci_dev(dn);
+	if (!dev) {
+		printk(KERN_ERR "%s: failed to add pci device\n", __FUNCTION__);
+		return NULL;
+	}
+
+	if (dev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {
+		printk(KERN_ERR "%s: unexpected header type %d\n",
+			__FUNCTION__, dev->hdr_type);
+		return NULL;
+	}
+
+	if (pci_add_secondary_bus(dn, dev))
+		return NULL;
+
+	return dev;
+}
+
+static int dlpar_pci_remove_bus(struct pci_dev *bridge_dev)
+{
+	struct pci_bus *secondary_bus;
+
+	if (!bridge_dev) {
+		printk(KERN_ERR "%s: unexpected null device\n",
+			__FUNCTION__);
+		return -EINVAL;
+	}
+
+	secondary_bus = bridge_dev->subordinate;
+
+	if (unmap_bus_range(secondary_bus)) {
+		printk(KERN_ERR "%s: failed to unmap bus range\n",
+			__FUNCTION__);
+		return -ERANGE;
+	}
+
+	pci_remove_bus_device(bridge_dev);
+	return 0;
+}
+
+static inline int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)
+{
+	struct pci_dev *dev;
+
+	/* Add pci bus */
+	dev = dlpar_pci_add_bus(dn);
+	if (!dev) {
+		printk(KERN_ERR "%s: unable to add bus %s\n", __FUNCTION__,
+			drc_name);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int dlpar_remove_root_bus(struct pci_controller *phb)
+{
+	struct pci_bus *phb_bus;
+	int rc;
+
+	phb_bus = phb->bus;
+	if (!(list_empty(&phb_bus->children) &&
+	      list_empty(&phb_bus->devices))) {
+		return -EBUSY;
+	}
+
+	rc = pcibios_remove_root_bus(phb);
+	if (rc)
+		return -EIO;
+
+	device_unregister(phb_bus->bridge);
+	pci_remove_bus(phb_bus);
+
+	return 0;
+}
+
+static int dlpar_remove_phb(struct slot *slot)
+{
+	struct pci_controller *phb;
+	struct device_node *dn;
+	int rc = 0;
+
+	dn = slot->dn;
+	if (!dn) {
+		printk(KERN_ERR "%s: unexpected NULL slot device node\n",
+				__FUNCTION__);
+		return -EIO;
+	}
+
+	phb = dn->phb;
+	if (!phb) {
+		printk(KERN_ERR "%s: unexpected NULL phb pointer\n",
+				__FUNCTION__);
+		return -EIO;
+	}
+
+	if (rpaphp_remove_slot(slot)) {
+		printk(KERN_ERR "%s: unable to remove hotplug slot %s\n",
+			__FUNCTION__, slot->location);
+		return -EIO;
+	}
+
+	rc = dlpar_remove_root_bus(phb);
+	if (rc < 0)
+		return rc;
+
+	return 0;
+}
+
+static int dlpar_add_phb(struct device_node *dn)
+{
+	struct pci_controller *phb;
+
+	phb = init_phb_dynamic(dn);
+	if (!phb)
+		return -EINVAL;
+
+	return 0;
+}
+
+/**
+ * dlpar_add_slot - DLPAR add an I/O Slot
+ * @drc_name: drc-name of newly added slot
+ *
+ * Make the hotplug module and the kernel aware
+ * of a newly added I/O Slot.
+ * Return Codes -
+ * 0			Success
+ * -ENODEV		Not a valid drc_name
+ * -EINVAL		Slot already added
+ * -ERESTARTSYS		Signalled before obtaining lock
+ * -EIO			Internal PCI Error
+ */
+int dlpar_add_slot(char *drc_name)
+{
+	struct device_node *dn = NULL;
+	int node_type;
+	int rc = 0;
+
+	if (down_interruptible(&rpadlpar_sem))
+		return -ERESTARTSYS;
+
+	/* Check for existing hotplug slot */
+	if (find_slot(drc_name)) {
+		rc = -EINVAL;
+		goto exit;
+	}
+
+	dn = find_newly_added_node(drc_name, &node_type);
+	if (!dn) {
+		rc = -ENODEV;
+		goto exit;
+	}
+
+	switch (node_type) {
+		case NODE_TYPE_VIO:
+			/* Just add hotplug slot */
+			break;
+		case NODE_TYPE_SLOT:
+			rc = dlpar_add_pci_slot(drc_name, dn);
+			break;
+		case NODE_TYPE_PHB:
+			rc = dlpar_add_phb(dn);
+			break;
+		default:
+			printk("%s: unexpected node type\n", __FUNCTION__);
+			return -EIO;
+	}
+
+	if (!rc && rpaphp_add_slot(dn)) {
+		printk(KERN_ERR "%s: unable to add hotplug slot %s\n",
+			__FUNCTION__, drc_name);
+		rc = -EIO;
+	}
+exit:
+	up(&rpadlpar_sem);
+	return rc;
+}
+
+/**
+ * dlpar_remove_vio_slot - DLPAR remove a virtual I/O Slot
+ * @drc_name: drc-name of newly added slot
+ *
+ * Remove the kernel and hotplug representations
+ * of an I/O Slot.
+ * Return Codes:
+ * 0			Success
+ * -EIO			Internal  Error
+ */
+int dlpar_remove_vio_slot(struct slot *slot, char *drc_name)
+{
+	/* Remove hotplug slot */
+
+	if (rpaphp_remove_slot(slot)) {
+		printk(KERN_ERR "%s: unable to remove hotplug slot %s\n",
+			__FUNCTION__, drc_name);
+		return -EIO;
+	}
+	return 0;
+}
+
+/**
+ * dlpar_remove_slot - DLPAR remove a PCI I/O Slot
+ * @drc_name: drc-name of newly added slot
+ *
+ * Remove the kernel and hotplug representations
+ * of a PCI I/O Slot.
+ * Return Codes:
+ * 0			Success
+ * -ENODEV		Not a valid drc_name
+ * -EIO			Internal PCI Error
+ */
+int dlpar_remove_pci_slot(struct slot *slot, char *drc_name)
+{
+	struct pci_dev *bridge_dev;
+
+	bridge_dev = slot->bridge;
+	if (!bridge_dev) {
+		printk(KERN_ERR "%s: unexpected null bridge device\n",
+			__FUNCTION__);
+		return -EIO;
+	}
+
+	/* Remove hotplug slot */
+	if (rpaphp_remove_slot(slot)) {
+		printk(KERN_ERR "%s: unable to remove hotplug slot %s\n",
+			__FUNCTION__, drc_name);
+		return -EIO;
+	}
+
+	/* Remove pci bus */
+
+	if (dlpar_pci_remove_bus(bridge_dev)) {
+		printk(KERN_ERR "%s: unable to remove pci bus %s\n",
+			__FUNCTION__, drc_name);
+		return -EIO;
+	}
+	return 0;
+}
+
+/**
+ * dlpar_remove_slot - DLPAR remove an I/O Slot
+ * @drc_name: drc-name of newly added slot
+ *
+ * Remove the kernel and hotplug representations
+ * of an I/O Slot.
+ * Return Codes:
+ * 0			Success
+ * -ENODEV		Not a valid drc_name
+ * -EINVAL		Slot already removed
+ * -ERESTARTSYS		Signalled before obtaining lock
+ * -EIO			Internal Error
+ */
+int dlpar_remove_slot(char *drc_name)
+{
+	struct slot *slot;
+	int rc = 0;
+
+	if (down_interruptible(&rpadlpar_sem))
+		return -ERESTARTSYS;
+
+	if (!find_php_slot_vio_node(drc_name) &&
+	    !find_php_slot_pci_node(drc_name, "SLOT") &&
+	    !find_php_slot_pci_node(drc_name, "PHB")) {
+		rc = -ENODEV;
+		goto exit;
+	}
+
+	slot = find_slot(drc_name);
+	if (!slot) {
+		rc = -EINVAL;
+		goto exit;
+	}
+	
+	if (slot->type == PHB) {
+		rc = dlpar_remove_phb(slot);
+	} else {
+		switch (slot->dev_type) {
+			case PCI_DEV:
+				rc = dlpar_remove_pci_slot(slot, drc_name);
+				break;
+
+			case VIO_DEV:
+				rc = dlpar_remove_vio_slot(slot, drc_name);
+				break;
+		}
+	}
+exit:
+	up(&rpadlpar_sem);
+	return rc;
+}
+
+static inline int is_dlpar_capable(void)
+{
+	int rc = rtas_token("ibm,configure-connector");
+
+	return (int) (rc != RTAS_UNKNOWN_SERVICE);
+}
+
+int __init rpadlpar_io_init(void)
+{
+	int rc = 0;
+
+	if (!is_dlpar_capable()) {
+		printk(KERN_WARNING "%s: partition not DLPAR capable\n",
+			__FUNCTION__);
+		return -EPERM;
+	}
+
+	rc = dlpar_sysfs_init();
+	return rc;
+}
+
+void rpadlpar_io_exit(void)
+{
+	dlpar_sysfs_exit();
+	return;
+}
+
+module_init(rpadlpar_io_init);
+module_exit(rpadlpar_io_exit);
+MODULE_LICENSE("GPL");
