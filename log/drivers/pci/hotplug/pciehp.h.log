commit a6cec3fdbd72e9f975f2db2bbfd1847831478195
Author: Ani Sinha <ani@anisinha.ca>
Date:   Tue Apr 21 08:57:50 2020 +0530

    PCI: pciehp: Remove unused EMI() and HP_SUPR_RM() macros
    
    EMI() and HP_SUPR_RM() are unused, so remove them.
    
    Link: https://lore.kernel.org/r/1587439673-39652-1-git-send-email-ani@anisinha.ca
    Signed-off-by: Ani Sinha <ani@anisinha.ca>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index ae44f46d1bf3..4fd200d8b0a9 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -148,8 +148,6 @@ struct controller {
 #define MRL_SENS(ctrl)		((ctrl)->slot_cap & PCI_EXP_SLTCAP_MRLSP)
 #define ATTN_LED(ctrl)		((ctrl)->slot_cap & PCI_EXP_SLTCAP_AIP)
 #define PWR_LED(ctrl)		((ctrl)->slot_cap & PCI_EXP_SLTCAP_PIP)
-#define HP_SUPR_RM(ctrl)	((ctrl)->slot_cap & PCI_EXP_SLTCAP_HPS)
-#define EMI(ctrl)		((ctrl)->slot_cap & PCI_EXP_SLTCAP_EIP)
 #define NO_CMD_CMPL(ctrl)	((ctrl)->slot_cap & PCI_EXP_SLTCAP_NCCS)
 #define PSN(ctrl)		(((ctrl)->slot_cap & PCI_EXP_SLTCAP_PSN) >> 19)
 

commit 202853595e53f981c86656c49fc1cc1e3620f558
Author: Alexandru Gagniuc <mr.nuke.me@gmail.com>
Date:   Fri Oct 25 15:00:45 2019 -0400

    PCI: pciehp: Disable in-band presence detect when possible
    
    The presence detect state (PDS) is normally a logical OR of in-band and
    out-of-band (OOB) presence detect.  As of PCIe 4.0, there is the option to
    disable in-band presence so that the PDS bit always reflects the state of
    the out-of-band presence.
    
    The recommendation of the PCIe spec is to disable in-band presence whenever
    supported (PCIe r5.0, appendix I implementation note):
    
      Due to architectural issues, the in-band (Physical-Layer-based) portion
      of the PD mechanism is deprecated for use with async hot-plug. One issue
      is that in-band PD as architected does not detect adapter removal during
      certain LTSSM states, notably the L1 and Disabled States.  Another issue
      is that when both in-band and OOB PD are being used together, the
      Presence Detect State bit and its associated interrupt mechanism always
      reflect the logical OR of the inband and OOB PD states, and with some
      hot-plug hardware configurations, it is important for software to detect
      and respond to in-band and OOB PD events independently.  If OOB PD is
      being used and the associated DSP supports In-Band PD Disable, it is
      recommended that the In-Band PD Disable bit be Set, and the Presence
      Detect State bit and its associated interrupt mechanism be used
      exclusively for OOB PD.  As a substitute for in-band PD with async
      hot-plug, the reference model uses either the DPC or the DLL Link Active
      mechanism.
    
    Link: https://lore.kernel.org/r/20191025190047.38130-2-stuart.w.hayes@gmail.com
    [bhelgaas: move PCI_EXP_SLTCAP2 read earlier & print PCI_EXP_SLTCAP2_IBPD
    value (suggested by Lukas)]
    Signed-off-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Lukas Wunner <lukas@wunner.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index aa61d4c219d7..ae44f46d1bf3 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -84,6 +84,7 @@ struct controller {
 	struct pcie_device *pcie;
 
 	u32 slot_cap;				/* capabilities and quirks */
+	unsigned int inband_presence_disabled:1;
 
 	u16 slot_ctrl;				/* control register access */
 	struct mutex ctrl_lock;

commit 87d0f2a5536fdf5053a6d341880f96135549a644
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Oct 29 20:00:22 2019 +0300

    PCI: pciehp: Prevent deadlock on disconnect
    
    This addresses deadlocks in these common cases in hierarchies containing
    two switches:
    
      - All involved ports are runtime suspended and they are unplugged. This
        can happen easily if the drivers involved automatically enable runtime
        PM (xHCI for example does that).
    
      - System is suspended (e.g., closing the lid on a laptop) with a dock +
        something else connected, and the dock is unplugged while suspended.
    
    These cases lead to the following deadlock:
    
      INFO: task irq/126-pciehp:198 blocked for more than 120 seconds.
      irq/126-pciehp  D    0   198      2 0x80000000
      Call Trace:
       schedule+0x2c/0x80
       schedule_timeout+0x246/0x350
       wait_for_completion+0xb7/0x140
       kthread_stop+0x49/0x110
       free_irq+0x32/0x70
       pcie_shutdown_notification+0x2f/0x50
       pciehp_remove+0x27/0x50
       pcie_port_remove_service+0x36/0x50
       device_release_driver+0x12/0x20
       bus_remove_device+0xec/0x160
       device_del+0x13b/0x350
       device_unregister+0x1a/0x60
       remove_iter+0x1e/0x30
       device_for_each_child+0x56/0x90
       pcie_port_device_remove+0x22/0x40
       pcie_portdrv_remove+0x20/0x60
       pci_device_remove+0x3e/0xc0
       device_release_driver_internal+0x18c/0x250
       device_release_driver+0x12/0x20
       pci_stop_bus_device+0x6f/0x90
       pci_stop_bus_device+0x31/0x90
       pci_stop_and_remove_bus_device+0x12/0x20
       pciehp_unconfigure_device+0x88/0x140
       pciehp_disable_slot+0x6a/0x110
       pciehp_handle_presence_or_link_change+0x263/0x400
       pciehp_ist+0x1c9/0x1d0
       irq_thread_fn+0x24/0x60
       irq_thread+0xeb/0x190
       kthread+0x120/0x140
    
      INFO: task irq/190-pciehp:2288 blocked for more than 120 seconds.
      irq/190-pciehp  D    0  2288      2 0x80000000
      Call Trace:
       __schedule+0x2a2/0x880
       schedule+0x2c/0x80
       schedule_preempt_disabled+0xe/0x10
       mutex_lock+0x2c/0x30
       pci_lock_rescan_remove+0x15/0x20
       pciehp_unconfigure_device+0x4d/0x140
       pciehp_disable_slot+0x6a/0x110
       pciehp_handle_presence_or_link_change+0x263/0x400
       pciehp_ist+0x1c9/0x1d0
       irq_thread_fn+0x24/0x60
       irq_thread+0xeb/0x190
       kthread+0x120/0x140
    
    What happens here is that the whole hierarchy is runtime resumed and the
    parent PCIe downstream port, which got the hot-remove event, starts
    removing devices below it, taking pci_lock_rescan_remove() lock. When the
    child PCIe port is runtime resumed it calls pciehp_check_presence() which
    ends up calling pciehp_card_present() and pciehp_check_link_active().  Both
    of these use pcie_capability_read_word(), which notices that the underlying
    device is already gone and returns PCIBIOS_DEVICE_NOT_FOUND with the
    capability value set to 0. When pciehp gets this value it thinks that its
    child device is also hot-removed and schedules its IRQ thread to handle the
    event.
    
    The deadlock happens when the child's IRQ thread runs and tries to acquire
    pci_lock_rescan_remove() which is already taken by the parent and the
    parent waits for the child's IRQ thread to finish.
    
    Prevent this from happening by checking the return value of
    pcie_capability_read_word() and if it is PCIBIOS_DEVICE_NOT_FOUND stop
    performing any hot-removal activities.
    
    [bhelgaas: add common scenarios to commit log]
    Link: https://lore.kernel.org/r/20191029170022.57528-2-mika.westerberg@linux.intel.com
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 882ce82c4699..aa61d4c219d7 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -174,10 +174,10 @@ void pciehp_set_indicators(struct controller *ctrl, int pwr, int attn);
 
 void pciehp_get_latch_status(struct controller *ctrl, u8 *status);
 int pciehp_query_power_fault(struct controller *ctrl);
-bool pciehp_card_present(struct controller *ctrl);
-bool pciehp_card_present_or_link_active(struct controller *ctrl);
+int pciehp_card_present(struct controller *ctrl);
+int pciehp_card_present_or_link_active(struct controller *ctrl);
 int pciehp_check_link_status(struct controller *ctrl);
-bool pciehp_check_link_active(struct controller *ctrl);
+int pciehp_check_link_active(struct controller *ctrl);
 void pciehp_release_ctrl(struct controller *ctrl);
 
 int pciehp_sysfs_enable_slot(struct hotplug_slot *hotplug_slot);

commit 157c1062fcd86ade3c674503705033051fd3d401
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Aug 9 12:28:43 2019 +0200

    PCI: pciehp: Avoid returning prematurely from sysfs requests
    
    A sysfs request to enable or disable a PCIe hotplug slot should not
    return before it has been carried out.  That is sought to be achieved by
    waiting until the controller's "pending_events" have been cleared.
    
    However the IRQ thread pciehp_ist() clears the "pending_events" before
    it acts on them.  If pciehp_sysfs_enable_slot() / _disable_slot() happen
    to check the "pending_events" after they have been cleared but while
    pciehp_ist() is still running, the functions may return prematurely
    with an incorrect return value.
    
    Fix by introducing an "ist_running" flag which must be false before a sysfs
    request is allowed to return.
    
    Fixes: 32a8cef274fe ("PCI: pciehp: Enable/disable exclusively from IRQ thread")
    Link: https://lore.kernel.org/linux-pci/1562226638-54134-1-git-send-email-wangxiongfeng2@huawei.com
    Link: https://lore.kernel.org/r/4174210466e27eb7e2243dd1d801d5f75baaffd8.1565345211.git.lukas@wunner.de
    Reported-and-tested-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: stable@vger.kernel.org # v4.19+

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 654c972b8ea0..882ce82c4699 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -72,6 +72,7 @@ extern int pciehp_poll_time;
  * @reset_lock: prevents access to the Data Link Layer Link Active bit in the
  *	Link Status register and to the Presence Detect State bit in the Slot
  *	Status register during a slot reset which may cause them to flap
+ * @ist_running: flag to keep user request waiting while IRQ thread is running
  * @request_result: result of last user request submitted to the IRQ thread
  * @requester: wait queue to wake up on completion of user request,
  *	used for synchronous slot enable/disable request via sysfs
@@ -101,6 +102,7 @@ struct controller {
 
 	struct hotplug_slot hotplug_slot;	/* hotplug core interface */
 	struct rw_semaphore reset_lock;
+	unsigned int ist_running;
 	int request_result;
 	wait_queue_head_t requester;
 };

commit 4a06c2c38235d4a0bc436131591e2927288992fe
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Sep 5 15:52:24 2019 -0500

    PCI: pciehp: Refer to "Indicators" instead of "LEDs" in comments
    
    The PCIe spec doesn't mention "green LEDs" or "amber LEDs".  Replace those
    terms with "Power Indicator" and "Attention Indicator" so the comments
    match the spec language.  Comment changes only.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 01706448b04a..654c972b8ea0 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -110,9 +110,9 @@ struct controller {
  *
  * @OFF_STATE: slot is powered off, no subordinate devices are enumerated
  * @BLINKINGON_STATE: slot will be powered on after the 5 second delay,
- *	green led is blinking
+ *	Power Indicator is blinking
  * @BLINKINGOFF_STATE: slot will be powered off after the 5 second delay,
- *	green led is blinking
+ *	Power Indicator is blinking
  * @POWERON_STATE: slot is currently powering on
  * @POWEROFF_STATE: slot is currently powering off
  * @ON_STATE: slot is powered on, subordinate devices have been enumerated

commit 9194094be418f4f13fbab3a6049ea18acb137178
Author: Denis Efremov <efremov@linux.com>
Date:   Tue Sep 3 14:10:21 2019 +0300

    PCI: pciehp: Remove pciehp_green_led_{on,off,blink}()
    
    Remove pciehp_green_led_{on,off,blink}() and use pciehp_set_indicators()
    instead, since the code is mostly the same.
    
    [bhelgaas: drop set_power_indicator() wrapper to reduce the number of
    interfaces]
    Link: https://lore.kernel.org/r/20190903111021.1559-5-efremov@linux.com
    Signed-off-by: Denis Efremov <efremov@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 1f69f43a3f29..01706448b04a 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -172,9 +172,6 @@ void pciehp_set_indicators(struct controller *ctrl, int pwr, int attn);
 
 void pciehp_get_latch_status(struct controller *ctrl, u8 *status);
 int pciehp_query_power_fault(struct controller *ctrl);
-void pciehp_green_led_on(struct controller *ctrl);
-void pciehp_green_led_off(struct controller *ctrl);
-void pciehp_green_led_blink(struct controller *ctrl);
 bool pciehp_card_present(struct controller *ctrl);
 bool pciehp_card_present_or_link_active(struct controller *ctrl);
 int pciehp_check_link_status(struct controller *ctrl);

commit 106feb2fdced0c240ca8ecb3d5db91b2b64e9a48
Author: Denis Efremov <efremov@linux.com>
Date:   Tue Sep 3 14:10:20 2019 +0300

    PCI: pciehp: Remove pciehp_set_attention_status()
    
    Remove pciehp_set_attention_status() and use pciehp_set_indicators()
    instead, since the code is mostly the same.
    
    Link: https://lore.kernel.org/r/20190903111021.1559-4-efremov@linux.com
    Signed-off-by: Denis Efremov <efremov@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 2ca0f35a6a23..1f69f43a3f29 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -170,7 +170,6 @@ void pciehp_get_power_status(struct controller *ctrl, u8 *status);
 #define INDICATOR_NOOP -1	/* Leave indicator unchanged */
 void pciehp_set_indicators(struct controller *ctrl, int pwr, int attn);
 
-void pciehp_set_attention_status(struct controller *ctrl, u8 status);
 void pciehp_get_latch_status(struct controller *ctrl, u8 *status);
 int pciehp_query_power_fault(struct controller *ctrl);
 void pciehp_green_led_on(struct controller *ctrl);

commit 688033f52d7192ea8ddf617b86af0a4120247b42
Author: Denis Efremov <efremov@linux.com>
Date:   Tue Sep 3 14:10:18 2019 +0300

    PCI: pciehp: Add pciehp_set_indicators() to set both indicators
    
    Add pciehp_set_indicators() to set power and attention indicators with a
    single register write.
    
    This is a minor optimization because we frequently set both indicators and
    this can do it with a single command.  It also reduces the number of
    interfaces related to the indicators and makes them more discoverable
    because callers use the PCI_EXP_SLTCTL_ATTN_IND_* and
    PCI_EXP_SLTCTL_PWR_IND_* definitions directly.
    
    [bhelgaas: extend commit log, s/PCI_EXP_SLTCTL_.*_IND_NONE/INDICATOR_NOOP/
    so they don't look like things defined by the spec, add function doc, mask
    commands to make it obvious we only send valid commands
    (pcie_do_write_cmd() does mask it, but requires more effort to verify)]
    Link: https://lore.kernel.org/r/20190903111021.1559-2-efremov@linux.com
    Signed-off-by: Denis Efremov <efremov@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 8c51a04b8083..2ca0f35a6a23 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -167,6 +167,9 @@ int pciehp_power_on_slot(struct controller *ctrl);
 void pciehp_power_off_slot(struct controller *ctrl);
 void pciehp_get_power_status(struct controller *ctrl, u8 *status);
 
+#define INDICATOR_NOOP -1	/* Leave indicator unchanged */
+void pciehp_set_indicators(struct controller *ctrl, int pwr, int attn);
+
 void pciehp_set_attention_status(struct controller *ctrl, u8 status);
 void pciehp_get_latch_status(struct controller *ctrl, u8 *status);
 int pciehp_query_power_fault(struct controller *ctrl);

commit e07ca82a5fde88b5caf2b7025e97c7980c60abe1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed May 8 16:34:01 2019 -0500

    PCI: pciehp: Remove pointless MY_NAME definition
    
    MY_NAME is only used once and offers no benefit, so remove it.
    
    Link: https://lore.kernel.org/lkml/20190509141456.223614-11-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Keith Busch <keith.busch@intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index c206fd9cd3d7..8c51a04b8083 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -25,8 +25,6 @@
 
 #include "../pcie/portdrv.h"
 
-#define MY_NAME	"pciehp"
-
 extern bool pciehp_poll_mode;
 extern int pciehp_poll_time;
 

commit 742ee16bc31f42b034a9b3b01731fd6dc20d0b19
Author: Frederick Lawler <fred@fredlawl.com>
Date:   Tue May 7 18:24:53 2019 -0500

    PCI: pciehp: Remove unused dbg/err/info/warn() wrappers
    
    Replace the last uses of dbg() with the equivalent pr_debug(), then remove
    unused dbg(), err(), info(), and warn() wrappers.
    
    Link: https://lore.kernel.org/lkml/20190509141456.223614-9-helgaas@kernel.org
    Signed-off-by: Frederick Lawler <fred@fredlawl.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Keith Busch <keith.busch@intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 2f0295b48d5d..c206fd9cd3d7 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -34,15 +34,6 @@ extern int pciehp_poll_time;
  * Set CONFIG_DYNAMIC_DEBUG=y and boot with 'dyndbg="file pciehp* +p"' to
  * enable debug messages.
  */
-#define dbg(format, arg...)						\
-	pr_debug(format, ## arg);
-#define err(format, arg...)						\
-	pr_err(format, ## arg)
-#define info(format, arg...)						\
-	pr_info(format, ## arg)
-#define warn(format, arg...)						\
-	pr_warn(format, ## arg)
-
 #define ctrl_dbg(ctrl, format, arg...)					\
 	pci_dbg(ctrl->pcie->port, format, ## arg)
 #define ctrl_err(ctrl, format, arg...)					\

commit 94dbc9562edc745d0549f1744ca1bd75e644473e
Author: Frederick Lawler <fred@fredlawl.com>
Date:   Tue May 7 18:24:51 2019 -0500

    PCI: pciehp: Log messages with pci_dev, not pcie_device
    
    Log messages with pci_dev, not pcie_device.  Factor out common message
    prefixes with dev_fmt().
    
    Example output change:
    
      - pciehp 0000:00:06.0:pcie004: Slot(0) Powering on due to button press
      + pcieport 0000:00:06.0: pciehp: Slot(0) Powering on due to button press
    
    Link: https://lore.kernel.org/lkml/20190509141456.223614-8-helgaas@kernel.org
    Signed-off-by: Frederick Lawler <fred@fredlawl.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Keith Busch <keith.busch@intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index af5d9f92e6d5..2f0295b48d5d 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -35,22 +35,22 @@ extern int pciehp_poll_time;
  * enable debug messages.
  */
 #define dbg(format, arg...)						\
-	pr_debug("%s: " format, MY_NAME, ## arg);
+	pr_debug(format, ## arg);
 #define err(format, arg...)						\
-	printk(KERN_ERR "%s: " format, MY_NAME, ## arg)
+	pr_err(format, ## arg)
 #define info(format, arg...)						\
-	printk(KERN_INFO "%s: " format, MY_NAME, ## arg)
+	pr_info(format, ## arg)
 #define warn(format, arg...)						\
-	printk(KERN_WARNING "%s: " format, MY_NAME, ## arg)
+	pr_warn(format, ## arg)
 
 #define ctrl_dbg(ctrl, format, arg...)					\
-	dev_dbg(&ctrl->pcie->device, format, ## arg)
+	pci_dbg(ctrl->pcie->port, format, ## arg)
 #define ctrl_err(ctrl, format, arg...)					\
-	dev_err(&ctrl->pcie->device, format, ## arg)
+	pci_err(ctrl->pcie->port, format, ## arg)
 #define ctrl_info(ctrl, format, arg...)					\
-	dev_info(&ctrl->pcie->device, format, ## arg)
+	pci_info(ctrl->pcie->port, format, ## arg)
 #define ctrl_warn(ctrl, format, arg...)					\
-	dev_warn(&ctrl->pcie->device, format, ## arg)
+	pci_warn(ctrl->pcie->port, format, ## arg)
 
 #define SLOT_NAME_SIZE 10
 

commit 017124725c155a3e1b09429d27c5846b0efafa89
Author: Frederick Lawler <fred@fredlawl.com>
Date:   Tue May 7 18:24:52 2019 -0500

    PCI: pciehp: Replace pciehp_debug module param with dyndbg
    
    Previously pciehp debug messages were enabled by the pciehp_debug module
    parameter, e.g., by booting with this kernel command line option:
    
      pciehp.pciehp_debug=1
    
    Convert this mechanism to use the generic dynamic debug (dyndbg) feature.
    After this commit, pciehp debug messages are enabled by building the kernel
    with CONFIG_DYNAMIC_DEBUG=y and booting with this command line option:
    
      dyndbg="file pciehp* +p"
    
    The dyndbg facility is much more flexible: messages can be enabled at boot-
    or run-time based on the file name, function name, line number, message
    test, etc.  See Documentation/admin-guide/dynamic-debug-howto.rst for more
    details.
    
    Link: https://lore.kernel.org/lkml/20190509141456.223614-7-helgaas@kernel.org
    Signed-off-by: Frederick Lawler <fred@fredlawl.com>
    [bhelgaas: commit log, comment, remove pciehp_debug parameter]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Keith Busch <keith.busch@intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 506e1d923a1f..af5d9f92e6d5 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -29,13 +29,13 @@
 
 extern bool pciehp_poll_mode;
 extern int pciehp_poll_time;
-extern bool pciehp_debug;
 
+/*
+ * Set CONFIG_DYNAMIC_DEBUG=y and boot with 'dyndbg="file pciehp* +p"' to
+ * enable debug messages.
+ */
 #define dbg(format, arg...)						\
-do {									\
-	if (pciehp_debug)						\
-		printk(KERN_DEBUG "%s: " format, MY_NAME, ## arg);	\
-} while (0)
+	pr_debug("%s: " format, MY_NAME, ## arg);
 #define err(format, arg...)						\
 	printk(KERN_ERR "%s: " format, MY_NAME, ## arg)
 #define info(format, arg...)						\
@@ -44,11 +44,7 @@ do {									\
 	printk(KERN_WARNING "%s: " format, MY_NAME, ## arg)
 
 #define ctrl_dbg(ctrl, format, arg...)					\
-	do {								\
-		if (pciehp_debug)					\
-			dev_printk(KERN_DEBUG, &ctrl->pcie->device,	\
-					format, ## arg);		\
-	} while (0)
+	dev_dbg(&ctrl->pcie->device, format, ## arg)
 #define ctrl_err(ctrl, format, arg...)					\
 	dev_err(&ctrl->pcie->device, format, ## arg)
 #define ctrl_info(ctrl, format, arg...)					\

commit eb34da60edee8cf7bac691a406a1ddaa4175e5bc
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Sep 27 16:38:19 2018 -0500

    PCI: pciehp: Disable hotplug interrupt during suspend
    
    When PCIe hotplug port is transitioned into D3hot, the link to the
    downstream component will go down. If hotplug interrupt generation is
    enabled when that happens, it will trigger immediately, waking up the
    system and bringing the link back up.
    
    To prevent this, disable hotplug interrupt generation when system suspend
    is entered. This does not prevent wakeup from low power states according
    to PCIe 4.0 spec section 6.7.3.4:
    
      Software enables a hot-plug event to generate a wakeup event by
      enabling software notification of the event as described in Section
      6.7.3.1. Note that in order for software to disable interrupt generation
      while keeping wakeup generation enabled, the Hot-Plug Interrupt Enable
      bit must be cleared.
    
    So as long as we have set the slot event mask accordingly, wakeup should
    work even if slot interrupt is disabled. The port should trigger wake and
    then send PME to the root port when the PCIe hierarchy is brought back up.
    
    Limit this to systems using native PME mechanism to make sure older Apple
    systems depending on commit e3354628c376 ("PCI: pciehp: Support interrupts
    sent from D3hot") still continue working.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 75fd52571107..506e1d923a1f 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -176,6 +176,8 @@ struct controller *pcie_init(struct pcie_device *dev);
 int pcie_init_notification(struct controller *ctrl);
 void pcie_shutdown_notification(struct controller *ctrl);
 void pcie_clear_hotplug_events(struct controller *ctrl);
+void pcie_enable_interrupt(struct controller *ctrl);
+void pcie_disable_interrupt(struct controller *ctrl);
 int pciehp_power_on_slot(struct controller *ctrl);
 void pciehp_power_off_slot(struct controller *ctrl);
 void pciehp_get_power_status(struct controller *ctrl, u8 *status);

commit f0157160b359b1d263ee9d4e0a435a7ad85bbcea
Author: Keith Busch <keith.busch@intel.com>
Date:   Thu Sep 20 10:27:17 2018 -0600

    PCI: Make link active reporting detection generic
    
    The spec has timing requirements when waiting for a link to become active
    after a conventional reset.  Implement those hard delays when waiting for
    an active link so pciehp and dpc drivers don't need to duplicate this.
    
    For devices that don't support data link layer active reporting, wait the
    fixed time recommended by the PCIe spec.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    [bhelgaas: changelog]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Sinan Kaya <okaya@kernel.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 3740f1a759c5..75fd52571107 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -62,11 +62,6 @@ do {									\
  * struct controller - PCIe hotplug controller
  * @pcie: pointer to the controller's PCIe port service device
  * @slot_cap: cached copy of the Slot Capabilities register
- * @link_active_reporting: cached copy of Data Link Layer Link Active Reporting
- *	Capable bit in Link Capabilities register; if this bit is zero, the
- *	Data Link Layer Link Active bit in the Link Status register will never
- *	be set and the driver is thus confined to wait 1 second before assuming
- *	the link to a hotplugged device is up and accessing it
  * @slot_ctrl: cached copy of the Slot Control register
  * @ctrl_lock: serializes writes to the Slot Control register
  * @cmd_started: jiffies when the Slot Control register was last written;
@@ -103,7 +98,6 @@ struct controller {
 	struct pcie_device *pcie;
 
 	u32 slot_cap;				/* capabilities and quirks */
-	unsigned int link_active_reporting:1;
 
 	u16 slot_ctrl;				/* control register access */
 	struct mutex ctrl_lock;

commit 125450f814418b9f889c9885831467d1b2e25a7d
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Sep 8 09:59:01 2018 +0200

    PCI: hotplug: Embed hotplug_slot
    
    When the PCI hotplug core and its first user, cpqphp, were introduced in
    February 2002 with historic commit a8a2069f432c, cpqphp allocated a slot
    struct for its internal use plus a hotplug_slot struct to be registered
    with the hotplug core and linked the two with pointers:
    https://git.kernel.org/tglx/history/c/a8a2069f432c
    
    Nowadays, the predominant pattern in the tree is to embed ("subclass")
    such structures in one another and cast to the containing struct with
    container_of().  But it wasn't until July 2002 that container_of() was
    introduced with historic commit ec4f214232cf:
    https://git.kernel.org/tglx/history/c/ec4f214232cf
    
    pnv_php, introduced in 2016, did the right thing and embedded struct
    hotplug_slot in its internal struct pnv_php_slot, but all other drivers
    cargo-culted cpqphp's design and linked separate structs with pointers.
    
    Embedding structs is preferrable to linking them with pointers because
    it requires fewer allocations, thereby reducing overhead and simplifying
    error paths.  Casting an embedded struct to the containing struct
    becomes a cheap subtraction rather than a dereference.  And having fewer
    pointers reduces the risk of them pointing nowhere either accidentally
    or due to an attack.
    
    Convert all drivers to embed struct hotplug_slot in their internal slot
    struct.  The "private" pointer in struct hotplug_slot thereby becomes
    unused, so drop it.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>  # drivers/pci/hotplug/rpa*
    Acked-by: Sebastian Ott <sebott@linux.ibm.com>        # drivers/pci/hotplug/s390*
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com> # drivers/platform/x86
    Cc: Len Brown <lenb@kernel.org>
    Cc: Scott Murray <scott@spiteful.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Oliver OHalloran <oliveroh@au1.ibm.com>
    Cc: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Cc: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Cc: Corentin Chary <corentin.chary@gmail.com>
    Cc: Darren Hart <dvhart@infradead.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 3cc88f3e4368..3740f1a759c5 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -88,7 +88,7 @@ do {									\
  *	protects scheduling, execution and cancellation of @button_work
  * @button_work: work item to turn the slot on or off after 5 seconds
  *	in response to an Attention Button press
- * @hotplug_slot: pointer to the structure registered with the PCI hotplug core
+ * @hotplug_slot: structure registered with the PCI hotplug core
  * @reset_lock: prevents access to the Data Link Layer Link Active bit in the
  *	Link Status register and to the Presence Detect State bit in the Slot
  *	Status register during a slot reset which may cause them to flap
@@ -120,7 +120,7 @@ struct controller {
 	struct mutex state_lock;
 	struct delayed_work button_work;
 
-	struct hotplug_slot *hotplug_slot;	/* hotplug core interface */
+	struct hotplug_slot hotplug_slot;	/* hotplug core interface */
 	struct rw_semaphore reset_lock;
 	int request_result;
 	wait_queue_head_t requester;
@@ -207,7 +207,12 @@ int pciehp_get_raw_indicator_status(struct hotplug_slot *h_slot, u8 *status);
 
 static inline const char *slot_name(struct controller *ctrl)
 {
-	return hotplug_slot_name(ctrl->hotplug_slot);
+	return hotplug_slot_name(&ctrl->hotplug_slot);
+}
+
+static inline struct controller *to_ctrl(struct hotplug_slot *hotplug_slot)
+{
+	return container_of(hotplug_slot, struct controller, hotplug_slot);
 }
 
 #endif				/* _PCIEHP_H */

commit d758714235e7abb7984468370c912ca2f4dc4e57
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Sep 8 09:59:01 2018 +0200

    PCI: pciehp: Reshuffle controller struct for clarity
    
    The members in pciehp's controller struct are arranged in a seemingly
    arbitrary order and have grown to an amount that I no longer consider
    easily graspable by contributors.
    
    Sort the members into 5 rubrics:
    * Slot Capabilities register and quirks
    * Slot Control register access
    * Slot Status register event handling
    * state machine
    * hotplug core interface
    
    Obviously, this is just my personal bikeshed color and if anyone has a
    better idea, please come forward.  Any ordering will do as long as the
    information is presented in a manageable manner.
    
    No functional change intended.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 39b97e2384c3..3cc88f3e4368 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -60,38 +60,38 @@ do {									\
 
 /**
  * struct controller - PCIe hotplug controller
- * @ctrl_lock: serializes writes to the Slot Control register
  * @pcie: pointer to the controller's PCIe port service device
- * @reset_lock: prevents access to the Data Link Layer Link Active bit in the
- *	Link Status register and to the Presence Detect State bit in the Slot
- *	Status register during a slot reset which may cause them to flap
- * @queue: wait queue to wake up on reception of a Command Completed event,
- *	used for synchronous writes to the Slot Control register
  * @slot_cap: cached copy of the Slot Capabilities register
+ * @link_active_reporting: cached copy of Data Link Layer Link Active Reporting
+ *	Capable bit in Link Capabilities register; if this bit is zero, the
+ *	Data Link Layer Link Active bit in the Link Status register will never
+ *	be set and the driver is thus confined to wait 1 second before assuming
+ *	the link to a hotplugged device is up and accessing it
  * @slot_ctrl: cached copy of the Slot Control register
- * @poll_thread: thread to poll for slot events if no IRQ is available,
- *	enabled with pciehp_poll_mode module parameter
+ * @ctrl_lock: serializes writes to the Slot Control register
  * @cmd_started: jiffies when the Slot Control register was last written;
  *	the next write is allowed 1 second later, absent a Command Completed
  *	interrupt (PCIe r4.0, sec 6.7.3.2)
  * @cmd_busy: flag set on Slot Control register write, cleared by IRQ handler
  *	on reception of a Command Completed event
- * @link_active_reporting: cached copy of Data Link Layer Link Active Reporting
- *	Capable bit in Link Capabilities register; if this bit is zero, the
- *	Data Link Layer Link Active bit in the Link Status register will never
- *	be set and the driver is thus confined to wait 1 second before assuming
- *	the link to a hotplugged device is up and accessing it
+ * @queue: wait queue to wake up on reception of a Command Completed event,
+ *	used for synchronous writes to the Slot Control register
+ * @pending_events: used by the IRQ handler to save events retrieved from the
+ *	Slot Status register for later consumption by the IRQ thread
  * @notification_enabled: whether the IRQ was requested successfully
  * @power_fault_detected: whether a power fault was detected by the hardware
  *	that has not yet been cleared by the user
- * @pending_events: used by the IRQ handler to save events retrieved from the
- *	Slot Status register for later consumption by the IRQ thread
+ * @poll_thread: thread to poll for slot events if no IRQ is available,
+ *	enabled with pciehp_poll_mode module parameter
  * @state: current state machine position
  * @state_lock: protects reads and writes of @state;
  *	protects scheduling, execution and cancellation of @button_work
  * @button_work: work item to turn the slot on or off after 5 seconds
  *	in response to an Attention Button press
  * @hotplug_slot: pointer to the structure registered with the PCI hotplug core
+ * @reset_lock: prevents access to the Data Link Layer Link Active bit in the
+ *	Link Status register and to the Presence Detect State bit in the Slot
+ *	Status register during a slot reset which may cause them to flap
  * @request_result: result of last user request submitted to the IRQ thread
  * @requester: wait queue to wake up on completion of user request,
  *	used for synchronous slot enable/disable request via sysfs
@@ -100,23 +100,28 @@ do {									\
  * unlike other drivers, the two aren't represented by separate structures.
  */
 struct controller {
-	struct mutex ctrl_lock;
 	struct pcie_device *pcie;
-	struct rw_semaphore reset_lock;
-	wait_queue_head_t queue;
-	u32 slot_cap;
-	u16 slot_ctrl;
-	struct task_struct *poll_thread;
-	unsigned long cmd_started;	/* jiffies */
-	unsigned int cmd_busy:1;
+
+	u32 slot_cap;				/* capabilities and quirks */
 	unsigned int link_active_reporting:1;
+
+	u16 slot_ctrl;				/* control register access */
+	struct mutex ctrl_lock;
+	unsigned long cmd_started;
+	unsigned int cmd_busy:1;
+	wait_queue_head_t queue;
+
+	atomic_t pending_events;		/* event handling */
 	unsigned int notification_enabled:1;
 	unsigned int power_fault_detected;
-	atomic_t pending_events;
-	u8 state;
+	struct task_struct *poll_thread;
+
+	u8 state;				/* state machine */
 	struct mutex state_lock;
 	struct delayed_work button_work;
-	struct hotplug_slot *hotplug_slot;
+
+	struct hotplug_slot *hotplug_slot;	/* hotplug core interface */
+	struct rw_semaphore reset_lock;
 	int request_result;
 	wait_queue_head_t requester;
 };

commit 4ff3126e80fc2db9d961467f783b5c2f4ccd1ca9
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Sep 8 09:59:01 2018 +0200

    PCI: pciehp: Rename controller struct members for clarity
    
    Of the members which were just moved from pciehp's slot struct to the
    controller struct, rename "lock" to "state_lock" and rename "work" to
    "button_work" for clarity.  Perform the rename separately to the
    unification of the two structs per Sinan's request.
    
    No functional change intended.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Sinan Kaya <okaya@kernel.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index df9308f6dafa..39b97e2384c3 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -87,9 +87,9 @@ do {									\
  * @pending_events: used by the IRQ handler to save events retrieved from the
  *	Slot Status register for later consumption by the IRQ thread
  * @state: current state machine position
- * @lock: protects reads and writes of @state;
- *	protects scheduling, execution and cancellation of @work
- * @work: work item to turn the slot on or off after 5 seconds
+ * @state_lock: protects reads and writes of @state;
+ *	protects scheduling, execution and cancellation of @button_work
+ * @button_work: work item to turn the slot on or off after 5 seconds
  *	in response to an Attention Button press
  * @hotplug_slot: pointer to the structure registered with the PCI hotplug core
  * @request_result: result of last user request submitted to the IRQ thread
@@ -114,8 +114,8 @@ struct controller {
 	unsigned int power_fault_detected;
 	atomic_t pending_events;
 	u8 state;
-	struct mutex lock;
-	struct delayed_work work;
+	struct mutex state_lock;
+	struct delayed_work button_work;
 	struct hotplug_slot *hotplug_slot;
 	int request_result;
 	wait_queue_head_t requester;

commit 5790a9c78e78aa2c35bb7439bee434301dff004c
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Sep 18 21:46:17 2018 +0200

    PCI: pciehp: Unify controller and slot structs
    
    pciehp was originally introduced together with shpchp in a single
    commit, c16b4b14d980 ("PCI Hotplug: Add SHPC and PCI Express hot-plug
    drivers"):
    https://git.kernel.org/tglx/history/c/c16b4b14d980
    
    shpchp supports up to 31 slots per controller, hence uses separate slot
    and controller structs.  pciehp has a 1:1 relationship between slot and
    controller and therefore never required this separation.  Nevertheless,
    because much of the code had been copy-pasted between the two drivers,
    pciehp likewise uses separate structs to this very day.
    
    The artificial separation of data structures adds unnecessary complexity
    and bloat to pciehp and requires constantly chasing pointers at runtime.
    
    Simplify the driver by merging struct slot into struct controller.
    Merge the slot constructor pcie_init_slot() and the destructor
    pcie_cleanup_slot() into the controller counterparts.
    
    No functional change intended.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index b9204ef3ecd7..df9308f6dafa 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -58,24 +58,6 @@ do {									\
 
 #define SLOT_NAME_SIZE 10
 
-/**
- * struct slot - PCIe hotplug slot
- * @state: current state machine position
- * @ctrl: pointer to the slot's controller structure
- * @hotplug_slot: pointer to the structure registered with the PCI hotplug core
- * @work: work item to turn the slot on or off after 5 seconds in response to
- *	an Attention Button press
- * @lock: protects reads and writes of @state;
- *	protects scheduling, execution and cancellation of @work
- */
-struct slot {
-	u8 state;
-	struct controller *ctrl;
-	struct hotplug_slot *hotplug_slot;
-	struct delayed_work work;
-	struct mutex lock;
-};
-
 /**
  * struct controller - PCIe hotplug controller
  * @ctrl_lock: serializes writes to the Slot Control register
@@ -83,7 +65,6 @@ struct slot {
  * @reset_lock: prevents access to the Data Link Layer Link Active bit in the
  *	Link Status register and to the Presence Detect State bit in the Slot
  *	Status register during a slot reset which may cause them to flap
- * @slot: pointer to the controller's slot structure
  * @queue: wait queue to wake up on reception of a Command Completed event,
  *	used for synchronous writes to the Slot Control register
  * @slot_cap: cached copy of the Slot Capabilities register
@@ -105,15 +86,23 @@ struct slot {
  *	that has not yet been cleared by the user
  * @pending_events: used by the IRQ handler to save events retrieved from the
  *	Slot Status register for later consumption by the IRQ thread
+ * @state: current state machine position
+ * @lock: protects reads and writes of @state;
+ *	protects scheduling, execution and cancellation of @work
+ * @work: work item to turn the slot on or off after 5 seconds
+ *	in response to an Attention Button press
+ * @hotplug_slot: pointer to the structure registered with the PCI hotplug core
  * @request_result: result of last user request submitted to the IRQ thread
  * @requester: wait queue to wake up on completion of user request,
  *	used for synchronous slot enable/disable request via sysfs
+ *
+ * PCIe hotplug has a 1:1 relationship between controller and slot, hence
+ * unlike other drivers, the two aren't represented by separate structures.
  */
 struct controller {
 	struct mutex ctrl_lock;
 	struct pcie_device *pcie;
 	struct rw_semaphore reset_lock;
-	struct slot *slot;
 	wait_queue_head_t queue;
 	u32 slot_cap;
 	u16 slot_ctrl;
@@ -124,6 +113,10 @@ struct controller {
 	unsigned int notification_enabled:1;
 	unsigned int power_fault_detected;
 	atomic_t pending_events;
+	u8 state;
+	struct mutex lock;
+	struct delayed_work work;
+	struct hotplug_slot *hotplug_slot;
 	int request_result;
 	wait_queue_head_t requester;
 };
@@ -174,26 +167,26 @@ struct controller {
 #define PSN(ctrl)		(((ctrl)->slot_cap & PCI_EXP_SLTCAP_PSN) >> 19)
 
 void pciehp_request(struct controller *ctrl, int action);
-void pciehp_handle_button_press(struct slot *slot);
-void pciehp_handle_disable_request(struct slot *slot);
-void pciehp_handle_presence_or_link_change(struct slot *slot, u32 events);
-int pciehp_configure_device(struct slot *p_slot);
-void pciehp_unconfigure_device(struct slot *p_slot, bool presence);
+void pciehp_handle_button_press(struct controller *ctrl);
+void pciehp_handle_disable_request(struct controller *ctrl);
+void pciehp_handle_presence_or_link_change(struct controller *ctrl, u32 events);
+int pciehp_configure_device(struct controller *ctrl);
+void pciehp_unconfigure_device(struct controller *ctrl, bool presence);
 void pciehp_queue_pushbutton_work(struct work_struct *work);
 struct controller *pcie_init(struct pcie_device *dev);
 int pcie_init_notification(struct controller *ctrl);
 void pcie_shutdown_notification(struct controller *ctrl);
 void pcie_clear_hotplug_events(struct controller *ctrl);
-int pciehp_power_on_slot(struct slot *slot);
-void pciehp_power_off_slot(struct slot *slot);
-void pciehp_get_power_status(struct slot *slot, u8 *status);
-
-void pciehp_set_attention_status(struct slot *slot, u8 status);
-void pciehp_get_latch_status(struct slot *slot, u8 *status);
-int pciehp_query_power_fault(struct slot *slot);
-void pciehp_green_led_on(struct slot *slot);
-void pciehp_green_led_off(struct slot *slot);
-void pciehp_green_led_blink(struct slot *slot);
+int pciehp_power_on_slot(struct controller *ctrl);
+void pciehp_power_off_slot(struct controller *ctrl);
+void pciehp_get_power_status(struct controller *ctrl, u8 *status);
+
+void pciehp_set_attention_status(struct controller *ctrl, u8 status);
+void pciehp_get_latch_status(struct controller *ctrl, u8 *status);
+int pciehp_query_power_fault(struct controller *ctrl);
+void pciehp_green_led_on(struct controller *ctrl);
+void pciehp_green_led_off(struct controller *ctrl);
+void pciehp_green_led_blink(struct controller *ctrl);
 bool pciehp_card_present(struct controller *ctrl);
 bool pciehp_card_present_or_link_active(struct controller *ctrl);
 int pciehp_check_link_status(struct controller *ctrl);
@@ -207,9 +200,9 @@ int pciehp_get_attention_status(struct hotplug_slot *hotplug_slot, u8 *status);
 int pciehp_set_raw_indicator_status(struct hotplug_slot *h_slot, u8 status);
 int pciehp_get_raw_indicator_status(struct hotplug_slot *h_slot, u8 *status);
 
-static inline const char *slot_name(struct slot *slot)
+static inline const char *slot_name(struct controller *ctrl)
 {
-	return hotplug_slot_name(slot->hotplug_slot);
+	return hotplug_slot_name(ctrl->hotplug_slot);
 }
 
 #endif				/* _PCIEHP_H */

commit 80696f991424d05a784c0cf9c314ac09ac280406
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Sep 8 09:59:01 2018 +0200

    PCI: pciehp: Tolerate Presence Detect hardwired to zero
    
    The WiGig Bus Extension (WBE) specification allows tunneling PCIe over
    IEEE 802.11.  A product implementing this spec is the wil6210 from
    Wilocity (now part of Qualcomm Atheros).  It integrates a PCIe switch
    with a wireless network adapter:
    
      00.0-+              [1ae9:0101]  Upstream Port
           +-00.0-+       [1ae9:0200]  Downstream Port
           |      +-00.0  [168c:0034]  Atheros AR9462 Wireless Network Adapter
           +-02.0         [1ae9:0201]  Downstream Port
           +-03.0         [1ae9:0201]  Downstream Port
    
    Wirelessly attached devices presumably appear below the hotplug ports
    with device ID [1ae9:0201].  Oddly, the Downstream Port [1ae9:0200]
    leading to the wireless network adapter is likewise Hotplug Capable,
    but has its Presence Detect State bit hardwired to zero.  Even if the
    Link Active bit is set, Presence Detect is zero, so this cannot be
    caused by in-band presence detection but only by broken hardware.
    
    pciehp assumes an empty slot if Presence Detect State is zero,
    regardless of Link Active being one.  Consequently, up until v4.18 it
    removes the wireless network adapter in pciehp_resume().  From v4.19 it
    already does so in pciehp_probe().
    
    Be lenient towards broken hardware and assume the slot is occupied if
    Link Active is set:  Introduce pciehp_card_present_or_link_active()
    and use it in lieu of pciehp_get_adapter_status() everywhere, except
    in pciehp_handle_presence_or_link_change() whose log messages depend
    on which of Presence Detect State or Link Active is set.
    
    Remove the Presence Detect State check from __pciehp_enable_slot()
    because it is only called if either of Presence Detect State or Link
    Active is set.
    
    Caution: There is a possibility that broken hardware exists which has
    working Presence Detect but hardwires Link Active to one.  On such
    hardware the slot will now incorrectly be considered always occupied.
    If such hardware is discovered, this commit can be rolled back and a
    quirk can be added which sets is_hotplug_bridge = 0 for [1ae9:0200].
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=200839
    Reported-and-tested-by: David Yang <mmyangfl@gmail.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Rajat Jain <rajatja@google.com>
    Cc: Ashok Raj <ashok.raj@intel.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 8131c08b21e5..b9204ef3ecd7 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -190,11 +190,12 @@ void pciehp_get_power_status(struct slot *slot, u8 *status);
 
 void pciehp_set_attention_status(struct slot *slot, u8 status);
 void pciehp_get_latch_status(struct slot *slot, u8 *status);
-void pciehp_get_adapter_status(struct slot *slot, u8 *status);
 int pciehp_query_power_fault(struct slot *slot);
 void pciehp_green_led_on(struct slot *slot);
 void pciehp_green_led_off(struct slot *slot);
 void pciehp_green_led_blink(struct slot *slot);
+bool pciehp_card_present(struct controller *ctrl);
+bool pciehp_card_present_or_link_active(struct controller *ctrl);
 int pciehp_check_link_status(struct controller *ctrl);
 bool pciehp_check_link_active(struct controller *ctrl);
 void pciehp_release_ctrl(struct controller *ctrl);

commit eee6e273843dc3084c15efc98a78702ac9a4c69b
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Aug 19 16:29:00 2018 +0200

    PCI: pciehp: Drop hotplug_slot_ops wrappers
    
    pciehp's ->enable_slot, ->disable_slot, ->get_attention_status and
    ->reset_slot callbacks are currently implemented by wrapper functions
    that do nothing else but call down to a backend function.  The backends
    are not called from anywhere else, so drop the wrappers and use the
    backends directly as callbacks, thereby shaving off a few lines of
    unnecessary code.
    
    No functional change intended.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 337f2a5a303f..8131c08b21e5 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -173,8 +173,6 @@ struct controller {
 #define NO_CMD_CMPL(ctrl)	((ctrl)->slot_cap & PCI_EXP_SLTCAP_NCCS)
 #define PSN(ctrl)		(((ctrl)->slot_cap & PCI_EXP_SLTCAP_PSN) >> 19)
 
-int pciehp_sysfs_enable_slot(struct slot *slot);
-int pciehp_sysfs_disable_slot(struct slot *slot);
 void pciehp_request(struct controller *ctrl, int action);
 void pciehp_handle_button_press(struct slot *slot);
 void pciehp_handle_disable_request(struct slot *slot);
@@ -189,7 +187,6 @@ void pcie_clear_hotplug_events(struct controller *ctrl);
 int pciehp_power_on_slot(struct slot *slot);
 void pciehp_power_off_slot(struct slot *slot);
 void pciehp_get_power_status(struct slot *slot, u8 *status);
-void pciehp_get_attention_status(struct slot *slot, u8 *status);
 
 void pciehp_set_attention_status(struct slot *slot, u8 status);
 void pciehp_get_latch_status(struct slot *slot, u8 *status);
@@ -201,8 +198,11 @@ void pciehp_green_led_blink(struct slot *slot);
 int pciehp_check_link_status(struct controller *ctrl);
 bool pciehp_check_link_active(struct controller *ctrl);
 void pciehp_release_ctrl(struct controller *ctrl);
-int pciehp_reset_slot(struct slot *slot, int probe);
 
+int pciehp_sysfs_enable_slot(struct hotplug_slot *hotplug_slot);
+int pciehp_sysfs_disable_slot(struct hotplug_slot *hotplug_slot);
+int pciehp_reset_slot(struct hotplug_slot *hotplug_slot, int probe);
+int pciehp_get_attention_status(struct hotplug_slot *hotplug_slot, u8 *status);
 int pciehp_set_raw_indicator_status(struct hotplug_slot *h_slot, u8 status);
 int pciehp_get_raw_indicator_status(struct hotplug_slot *h_slot, u8 *status);
 

commit 7d4ba52317c4aab6bbb266f31e28713d397e570c
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Aug 19 16:29:00 2018 +0200

    PCI: pciehp: Drop unnecessary includes
    
    Drop the following includes from pciehp source files which no longer use
    any of the included symbols:
    
    * <linux/sched/signal.h> in pciehp.h
      <linux/signal.h> in pciehp_hpc.c
      Added by commit de25968cc87c ("fix more missing includes") to
      accommodate for a call to signal_pending().
      The call was removed by commit 262303fe329a ("pciehp: fix wait command
      completion").
    
    * <linux/interrupt.h> in pciehp_core.c
      Added by historic commit f308a2dfbe63 ("PCI: add PCI Express Port Bus
      Driver subsystem") to accommodate for a call to free_irq():
      https://git.kernel.org/tglx/history/c/f308a2dfbe63
      The call was removed by commit 407f452b05f9 ("pciehp: remove
      unnecessary free_irq").
    
    * <linux/time.h> in pciehp_core.c and pciehp_hpc.c
      Added by commit 34d03419f03b ("PCIEHP: Add Electro Mechanical
      Interlock (EMI) support to the PCIE hotplug driver."),
      which was reverted by commit bd3d99c17039 ("PCI: Remove untested
      Electromechanical Interlock (EMI) support in pciehp.").
    
    * <linux/module.h> in pciehp_ctrl.c, pciehp_hpc.c and pciehp_pci.c
      Added by historic commit c16b4b14d980 ("PCI Hotplug: Add SHPC and PCI
      Express hot-plug drivers"):
      https://git.kernel.org/tglx/history/c/c16b4b14d980
      Module-related symbols were neither used back then in those files,
      nor are they used today.
    
    * <linux/slab.h> in pciehp_ctrl.c
      Added by commit 5a0e3ad6af86 ("include cleanup: Update gfp.h and
      slab.h includes to prepare for breaking implicit slab.h inclusion from
      percpu.h") to accommodate for calls to kmalloc().
      The calls were removed by commit 0e94916e6091 ("PCI: pciehp: Handle
      events synchronously").
    
    * "../pci.h" in pciehp_ctrl.c
      Added by historic commit 67f4660b72f2 ("PCI: ASPM patch for") to
      accommodate for usage of the global variable pcie_mch_quirk:
      https://git.kernel.org/tglx/history/c/67f4660b72f2
      The global variable was removed by commit 0ba379ec0fb1 ("PCI: Simplify
      hotplug mch quirk").
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 39c9c8815a35..337f2a5a303f 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -19,7 +19,6 @@
 #include <linux/pci.h>
 #include <linux/pci_hotplug.h>
 #include <linux/delay.h>
-#include <linux/sched/signal.h>		/* signal_pending() */
 #include <linux/mutex.h>
 #include <linux/rwsem.h>
 #include <linux/workqueue.h>

commit 11e87702be65780be92fb1f0a5b7b293954185f7
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Jul 31 07:50:37 2018 +0200

    PCI: pciehp: Differentiate between surprise and safe removal
    
    When removing PCI devices below a hotplug bridge, pciehp marks them as
    disconnected if the card is no longer present in the slot or it quiesces
    them if the card is still present (by disabling INTx interrupts, bus
    mastering and SERR# reporting).
    
    To detect whether the card is still present, pciehp checks the Presence
    Detect State bit in the Slot Status register.  The problem with this
    approach is that even if the card is present, the link to it may be
    down, and it that case it would be better to mark the devices as
    disconnected instead of trying to quiesce them.  Moreover, if the card
    in the slot was quickly replaced by another one, the Presence Detect
    State bit would be set, yet trying to quiesce the new card's devices
    would be wrong and the correct thing to do is to mark the previous
    card's devices as disconnected.
    
    Instead of looking at the Presence Detect State bit, it is better to
    differentiate whether the card was surprise removed versus safely
    removed (via sysfs or an Attention Button press).  On surprise removal,
    the devices should be marked as disconnected, whereas on safe removal it
    is correct to quiesce the devices.
    
    The knowledge whether a surprise removal or a safe removal is at hand
    does exist further up in the call stack:  A surprise removal is
    initiated by pciehp_handle_presence_or_link_change(), a safe removal by
    pciehp_handle_disable_request().
    
    Pass that information down to pciehp_unconfigure_device() and use it in
    lieu of the Presence Detect State bit.  While there, add kernel-doc to
    pciehp_unconfigure_device() and pciehp_configure_device().
    
    Tested-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Keith Busch <keith.busch@intel.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 811cf83f956d..39c9c8815a35 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -181,7 +181,7 @@ void pciehp_handle_button_press(struct slot *slot);
 void pciehp_handle_disable_request(struct slot *slot);
 void pciehp_handle_presence_or_link_change(struct slot *slot, u32 events);
 int pciehp_configure_device(struct slot *p_slot);
-void pciehp_unconfigure_device(struct slot *p_slot);
+void pciehp_unconfigure_device(struct slot *p_slot, bool presence);
 void pciehp_queue_pushbutton_work(struct work_struct *work);
 struct controller *pcie_init(struct pcie_device *dev);
 int pcie_init_notification(struct controller *ctrl);

commit 6b08c3854cfdc5d13165880e2b54642c47edc405
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Jul 28 07:18:00 2018 +0200

    PCI: pciehp: Support interrupts sent from D3hot
    
    If a hotplug port is able to send an interrupt, one would naively assume
    that it is accessible at that moment.  After all, if it wouldn't be
    accessible, i.e. if its parent is in D3hot and the link to the hotplug
    port is thus down, how should an interrupt come through?
    
    It turns out that assumption is wrong at least for Thunderbolt:  Even
    though its parents are in D3hot, a Thunderbolt hotplug port is able to
    signal interrupts.  Because the port's config space is inaccessible and
    resuming the parents may sleep, the hard IRQ handler has to defer
    runtime resuming the parents and reading the Slot Status register to the
    IRQ thread.
    
    If the hotplug port uses a level-triggered INTx interrupt, it needs to
    be masked until the IRQ thread has cleared the signaled events.  For
    simplicity, this commit also masks edge-triggered MSI/MSI-X interrupts.
    Note that if the interrupt is shared (which can only happen for INTx),
    other devices are starved from receiving interrupts until the IRQ thread
    is scheduled, has runtime resumed the hotplug port's parents and has
    read and cleared the Slot Status register.
    
    That delay is dominated by the 10 ms D3hot->D0 transition time of each
    parent port.  The worst case is a Thunderbolt downstream port at the
    end of a daisy chain:  There may be up to six Thunderbolt controllers
    in-between it and the root port, each comprising an upstream and
    downstream port, plus its own upstream port.  That's 13 x 10 = 130 ms.
    Possible mitigations are polling the interrupt while it's disabled or
    reducing the d3_delay of Thunderbolt ports if possible.
    
    Open code masking of the interrupt instead of requesting it with the
    IRQF_ONESHOT flag to minimize the period during which it is masked.
    (IRQF_ONESHOT unmasks the IRQ only after the IRQ thread has finished.)
    
    PCIe r4.0 sec 6.7.3.4 states that "If wake generation is required by the
    associated form factor specification, a hotplug capable Downstream Port
    must support generation of a wakeup event (using the PME mechanism) on
    hotplug events that occur when the system is in a sleep state or the
    Port is in device state D1, D2, or D3Hot."
    
    This would seem to imply that PME needs to be enabled on the hotplug
    port when it is runtime suspended.  pci_enable_wake() currently doesn't
    enable PME on bridges, it may be necessary to add an exemption for
    hotplug bridges there.  On "Light Ridge" Thunderbolt controllers, the
    PME_Status bit is not set when an interrupt occurs while the hotplug
    port is in D3hot, even if PME is enabled.  (I've tested this on a Mac
    and we hardcode the OSC_PCI_EXPRESS_PME_CONTROL bit to 0 on Macs in
    negotiate_os_control(), modifying it to 1 didn't change the behavior.)
    
    (Side note:  Section 6.7.3.4 also states that "PME and Hot-Plug Event
    interrupts (when both are implemented) always share the same MSI or
    MSI-X vector".  That would only seem to apply to Root Ports, however
    the section never mentions Root Ports, only Downstream Ports.  This is
    explained in the definition of "Downstream Port" in the "Terms and
    Acronyms" section of the PCIe Base Spec:  "The Ports on a Switch that
    are not the Upstream Port are Downstream Ports.  All Ports on a Root
    Complex are Downstream Ports.")
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Ashok Raj <ashok.raj@intel.com>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 247681963063..811cf83f956d 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -156,8 +156,13 @@ struct controller {
  *
  * %DISABLE_SLOT: Disable the slot in response to a user request via sysfs or
  *	an Attention Button press after the 5 second delay
+ * %RERUN_ISR: Used by the IRQ handler to inform the IRQ thread that the
+ *	hotplug port was inaccessible when the interrupt occurred, requiring
+ *	that the IRQ handler is rerun by the IRQ thread after it has made the
+ *	hotplug port accessible by runtime resuming its parents to D0
  */
 #define DISABLE_SLOT		(1 << 16)
+#define RERUN_ISR		(1 << 17)
 
 #define ATTN_BUTTN(ctrl)	((ctrl)->slot_cap & PCI_EXP_SLTCAP_ABP)
 #define POWER_CTRL(ctrl)	((ctrl)->slot_cap & PCI_EXP_SLTCAP_PCP)

commit 7903782460ee1813d6779c968b28d0ac71b9b3ae
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:53 2018 -0500

    PCI: pciehp: Clear spurious events earlier on resume
    
    Thunderbolt hotplug ports that were occupied before system sleep resume
    with their downstream link in "off" state.  Only after the Thunderbolt
    controller has reestablished the PCIe tunnels does the link go up.
    As a result, a spurious Presence Detect Changed and/or Data Link Layer
    State Changed event occurs.
    
    The events are not immediately acted upon because tunnel reestablishment
    happens in the ->resume_noirq phase, when interrupts are still disabled.
    Also, notification of events may initially be disabled in the Slot
    Control register when coming out of system sleep and is reenabled in the
    ->resume_noirq phase through:
    
      pci_pm_resume_noirq()
        pci_pm_default_resume_early()
          pci_restore_state()
            pci_restore_pcie_state()
    
    It is not guaranteed that the events are acted upon at all:  PCIe r4.0,
    sec 6.7.3.4 says that "a port may optionally send an MSI when there are
    hot-plug events that occur while interrupt generation is disabled, and
    interrupt generation is subsequently enabled."  Note the "optionally".
    
    If an MSI is sent, pciehp will gratuitously turn the slot off and back
    on once the ->resume_early phase has commenced.
    
    If an MSI is not sent, the extant, unacknowledged events in the Slot
    Status register will prevent future notification of presence or link
    changes.
    
    Commit 13c65840feab ("PCI: pciehp: Clear Presence Detect and Data Link
    Layer Status Changed on resume") fixed the latter by clearing the events
    in the ->resume phase.  Move this to the ->resume_noirq phase to also
    fix the gratuitous disable/enablement of the slot.
    
    The commit further restored the Slot Control register in the ->resume
    phase, but that's dispensable because as shown above it's already been
    done in the ->resume_noirq phase.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index bb015be34894..247681963063 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -181,7 +181,7 @@ void pciehp_queue_pushbutton_work(struct work_struct *work);
 struct controller *pcie_init(struct pcie_device *dev);
 int pcie_init_notification(struct controller *ctrl);
 void pcie_shutdown_notification(struct controller *ctrl);
-void pcie_reenable_notification(struct controller *ctrl);
+void pcie_clear_hotplug_events(struct controller *ctrl);
 int pciehp_power_on_slot(struct slot *slot);
 void pciehp_power_off_slot(struct slot *slot);
 void pciehp_get_power_status(struct slot *slot, u8 *status);

commit 5b3f7b7d062bc839fe0744bdfd0cfd7e8d1c4cd9
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Jul 28 07:18:00 2018 +0200

    PCI: pciehp: Avoid slot access during reset
    
    The ->reset_slot callback introduced by commits:
    
      2e35afaefe64 ("PCI: pciehp: Add reset_slot() method") and
      06a8d89af551 ("PCI: pciehp: Disable link notification across slot reset")
    
    disables notification of Presence Detect Changed and Data Link Layer
    State Changed events for the duration of a secondary bus reset.
    
    However a bus reset not only triggers these events, but may also clear
    the Presence Detect State bit in the Slot Status register and the Data
    Link Layer Link Active bit in the Link Status register momentarily.
    According to Sinan Kaya:
    
     "I know for a fact that bus reset clears the Data Link Layer Active bit
      as soon as link goes down.  It gets set again following link up.
      Presence detect depends on the HW implementation.  QDT root ports
      don't change presence detect for instance since nobody actually
      removed the card.  If an implementation supports in-band presence
      detect, the answer is yes.  As soon as the link goes down, presence
      detect bit will get cleared until recovery."
      https://lkml.kernel.org/r/42e72f83-3b24-f7ef-e5bc-290fae99259a@codeaurora.org
    
      In-band presence detect is also covered in Table 4-15 in PCIe r4.0,
      sec 4.2.6.
    
    pciehp should therefore ensure that any parts of the driver that access
    those bits do not run concurrently to a bus reset.  The only precaution
    the commits took to that effect was to halt interrupt polling.  They
    made no effort to drain the slot workqueue, cancel an outstanding
    Attention Button work, or block slot enable/disable requests via sysfs
    and in the ->probe hook.
    
    Now that pciehp is converted to enable/disable the slot exclusively from
    the IRQ thread, the only places accessing the two above-mentioned bits
    are the IRQ thread and the ->probe hook.  Add locking to serialize them
    with a bus reset.  This obviates the need to halt interrupt polling.
    Do not add locking to the ->get_adapter_status sysfs callback to afford
    users unfettered access to that bit.  Use an rw_semaphore in lieu of a
    regular mutex to allow parallel execution of the non-reset code paths
    accessing the critical bits, i.e. the IRQ thread and the ->probe hook.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Rajat Jain <rajatja@google.com>
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Cc: Sinan Kaya <okaya@kernel.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 47cd9af5caf3..bb015be34894 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -21,6 +21,7 @@
 #include <linux/delay.h>
 #include <linux/sched/signal.h>		/* signal_pending() */
 #include <linux/mutex.h>
+#include <linux/rwsem.h>
 #include <linux/workqueue.h>
 
 #include "../pcie/portdrv.h"
@@ -80,6 +81,9 @@ struct slot {
  * struct controller - PCIe hotplug controller
  * @ctrl_lock: serializes writes to the Slot Control register
  * @pcie: pointer to the controller's PCIe port service device
+ * @reset_lock: prevents access to the Data Link Layer Link Active bit in the
+ *	Link Status register and to the Presence Detect State bit in the Slot
+ *	Status register during a slot reset which may cause them to flap
  * @slot: pointer to the controller's slot structure
  * @queue: wait queue to wake up on reception of a Command Completed event,
  *	used for synchronous writes to the Slot Control register
@@ -109,6 +113,7 @@ struct slot {
 struct controller {
 	struct mutex ctrl_lock;
 	struct pcie_device *pcie;
+	struct rw_semaphore reset_lock;
 	struct slot *slot;
 	wait_queue_head_t queue;
 	u32 slot_cap;

commit d331710ea78fea8b10624c87546d8bc0cd0389c9
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:49 2018 -0500

    PCI: pciehp: Become resilient to missed events
    
    A hotplug port's Slot Status register does not count how often each type
    of event occurred, it only records the fact *that* an event has occurred.
    
    Previously pciehp queued a work item for each event.  But if it missed
    an event, e.g. removal of a card in-between two back-to-back insertions,
    it queued up the wrong work item or no work item at all.  Commit
    fad214b0aa72 ("PCI: pciehp: Process all hotplug events before looking
    for new ones") sought to improve the situation by shrinking the window
    during which events may be missed.
    
    But Stefan Roese reports unbalanced Card present and Link Up events,
    suggesting that we're still missing events if they occur very rapidly.
    Bjorn Helgaas responds that he considers pciehp's event handling
    "baroque" and calls for its simplification and rationalization:
    https://lkml.kernel.org/r/20180202192045.GA53759@bhelgaas-glaptop.roam.corp.google.com
    
    It gets worse once a hotplug port is runtime suspended:  The port can
    signal an interrupt while it and its parents are in D3hot, i.e. while
    it is inaccessible.  By the time we've runtime resumed all parents to D0
    and read the port's Slot Status register, we may have missed an arbitrary
    number of events.  Event handling therefore needs to be reworked to
    become resilient to missed events.
    
    Assume that a Presence Detect Changed event has occurred.
    Consider the following truth table:
    - Slot is in OFF_STATE and is currently empty.    => Do nothing.
      (The event is trailing a Link Down or we've
      missed an insertion and subsequent removal.)
    - Slot is in OFF_STATE and is currently occupied. => Turn the slot on.
    - Slot is in ON_STATE  and is currently empty.    => Turn the slot off.
    - Slot is in ON_STATE  and is currently occupied. => Turn the slot off,
      (Be cautious and assume the card in                then back on.
      the slot isn't the same as before.)
    
    This leads to the following simple algorithm:
    1 If the slot is in ON_STATE, turn it off unconditionally.
    2 If the slot is currently occupied, turn it on.
    
    Because those actions are now carried out synchronously, rather than by
    scheduled work items, pciehp reacts to the *current* situation and
    missed events no longer matter.
    
    Data Link Layer State Changed events can be handled identically to
    Presence Detect Changed events.  Note that in the above truth table,
    a Link Up trailing a Card present event didn't have to be accounted for:
    It is filtered out by pciehp_check_link_status().
    
    As for Attention Button Pressed events, PCIe r4.0, sec 6.7.1.5 says:
    "Once the Power Indicator begins blinking, a 5-second abort interval
    exists during which a second depression of the Attention Button cancels
    the operation."  In other words, the user can only expect the system to
    react to a button press after it starts blinking.  Missed button presses
    that occur in-between are irrelevant.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Stefan Roese <sr@denx.de>
    Cc: Mayurkumar Patel <mayurkumar.patel@intel.com>
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 9c75acd291fb..47cd9af5caf3 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -169,8 +169,7 @@ int pciehp_sysfs_disable_slot(struct slot *slot);
 void pciehp_request(struct controller *ctrl, int action);
 void pciehp_handle_button_press(struct slot *slot);
 void pciehp_handle_disable_request(struct slot *slot);
-void pciehp_handle_link_change(struct slot *slot);
-void pciehp_handle_presence_change(struct slot *slot);
+void pciehp_handle_presence_or_link_change(struct slot *slot, u32 events);
 int pciehp_configure_device(struct slot *p_slot);
 void pciehp_unconfigure_device(struct slot *p_slot);
 void pciehp_queue_pushbutton_work(struct work_struct *work);

commit 25c83b84b110f50efe6fcf62e329f1db2af4454a
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:47 2018 -0500

    PCI: pciehp: Declare pciehp_enable/disable_slot() static
    
    No callers of pciehp_enable/disable_slot() outside of pciehp_ctrl.c
    remain, so declare the functions static.  For now this requires forward
    declarations.  Those can be eliminated by reshuffling functions once the
    ongoing effort to refactor the driver has settled.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 5417180c3aff..9c75acd291fb 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -177,8 +177,6 @@ void pciehp_queue_pushbutton_work(struct work_struct *work);
 struct controller *pcie_init(struct pcie_device *dev);
 int pcie_init_notification(struct controller *ctrl);
 void pcie_shutdown_notification(struct controller *ctrl);
-int pciehp_enable_slot(struct slot *p_slot);
-int pciehp_disable_slot(struct slot *p_slot);
 void pcie_reenable_notification(struct controller *ctrl);
 int pciehp_power_on_slot(struct slot *slot);
 void pciehp_power_off_slot(struct slot *slot);

commit 1656716d45d0aae8c0a21a0553b9d27cd98fda61
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:46 2018 -0500

    PCI: pciehp: Drop enable/disable lock
    
    Previously slot enablement and disablement could happen concurrently.
    But now it's under the exclusive control of the IRQ thread, rendering
    the locking obsolete.  Drop it.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index ed42dde5f9ac..5417180c3aff 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -67,8 +67,6 @@ do {									\
  *	an Attention Button press
  * @lock: protects reads and writes of @state;
  *	protects scheduling, execution and cancellation of @work
- * @hotplug_lock: serializes calls to pciehp_enable_slot() and
- *	pciehp_disable_slot()
  */
 struct slot {
 	u8 state;
@@ -76,7 +74,6 @@ struct slot {
 	struct hotplug_slot *hotplug_slot;
 	struct delayed_work work;
 	struct mutex lock;
-	struct mutex hotplug_lock;
 };
 
 /**

commit 32a8cef274feacd00b748a4f13b84d60aa6d82ff
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:46 2018 -0500

    PCI: pciehp: Enable/disable exclusively from IRQ thread
    
    Besides the IRQ thread, there are several other places in the driver
    which enable or disable the slot:
    
    - pciehp_probe() enables the slot if it's occupied and the pciehp_force
      module parameter is used.
    
    - pciehp_resume() enables or disables the slot after system sleep.
    
    - pciehp_queue_pushbutton_work() enables or disables the slot after the
      5 second delay following an Attention Button press.
    
    - pciehp_sysfs_enable_slot() and pciehp_sysfs_disable_slot() enable or
      disable the slot on sysfs write.
    
    This requires locking and complicates pciehp's state machine.
    
    A simplification can be achieved by enabling and disabling the slot
    exclusively from the IRQ thread.
    
    Amend the functions listed above to request slot enable/disablement from
    the IRQ thread by either synthesizing a Presence Detect Changed event or,
    in the case of a disable user request (via sysfs or an Attention Button
    press), submitting a newly introduced force disable request.  The latter
    is needed because the slot shall be forced off despite being occupied.
    For this force disable request, avoid colliding with Slot Status register
    bits by using a bit number greater than 16.
    
    For synchronous execution of requests (on sysfs write), wait for the
    request to finish and retrieve the result.  There can only ever be one
    sysfs write in flight due to the locking in kernfs_fop_write(), hence
    there is no risk of returning the result of a different sysfs request to
    user space.
    
    The POWERON_STATE and POWEROFF_STATE is now no longer entered by the
    above-listed functions, but solely by the IRQ thread when it begins a
    power transition.  Afterwards, it moves to STATIC_STATE.  The same
    applies to canceling the Attention Button work, it likewise becomes an
    IRQ thread only operation.
    
    An immediate consequence is that the POWERON_STATE and POWEROFF_STATE is
    never observed by the IRQ thread itself, only by functions called in a
    different context, such as pciehp_sysfs_enable_slot().  So remove
    handling of these states from pciehp_handle_button_press() and
    pciehp_handle_link_change() which are exclusively called from the IRQ
    thread.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 1ba335d6563a..ed42dde5f9ac 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -105,6 +105,9 @@ struct slot {
  *	that has not yet been cleared by the user
  * @pending_events: used by the IRQ handler to save events retrieved from the
  *	Slot Status register for later consumption by the IRQ thread
+ * @request_result: result of last user request submitted to the IRQ thread
+ * @requester: wait queue to wake up on completion of user request,
+ *	used for synchronous slot enable/disable request via sysfs
  */
 struct controller {
 	struct mutex ctrl_lock;
@@ -120,6 +123,8 @@ struct controller {
 	unsigned int notification_enabled:1;
 	unsigned int power_fault_detected;
 	atomic_t pending_events;
+	int request_result;
+	wait_queue_head_t requester;
 };
 
 /**
@@ -141,6 +146,17 @@ struct controller {
 #define POWEROFF_STATE			4
 #define ON_STATE			5
 
+/**
+ * DOC: Flags to request an action from the IRQ thread
+ *
+ * These are stored together with events read from the Slot Status register,
+ * hence must be greater than its 16-bit width.
+ *
+ * %DISABLE_SLOT: Disable the slot in response to a user request via sysfs or
+ *	an Attention Button press after the 5 second delay
+ */
+#define DISABLE_SLOT		(1 << 16)
+
 #define ATTN_BUTTN(ctrl)	((ctrl)->slot_cap & PCI_EXP_SLTCAP_ABP)
 #define POWER_CTRL(ctrl)	((ctrl)->slot_cap & PCI_EXP_SLTCAP_PCP)
 #define MRL_SENS(ctrl)		((ctrl)->slot_cap & PCI_EXP_SLTCAP_MRLSP)
@@ -153,7 +169,9 @@ struct controller {
 
 int pciehp_sysfs_enable_slot(struct slot *slot);
 int pciehp_sysfs_disable_slot(struct slot *slot);
+void pciehp_request(struct controller *ctrl, int action);
 void pciehp_handle_button_press(struct slot *slot);
+void pciehp_handle_disable_request(struct slot *slot);
 void pciehp_handle_link_change(struct slot *slot);
 void pciehp_handle_presence_change(struct slot *slot);
 int pciehp_configure_device(struct slot *p_slot);

commit 9590192f2584c2cfc2fee88be22fe6e8921ed115
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:45 2018 -0500

    PCI: pciehp: Track enable/disable status
    
    handle_button_press_event() currently determines whether the slot has
    been turned on or off by looking at the Power Controller Control bit in
    the Slot Control register.  This assumes that an attention button
    implies presence of a power controller even though that's not mandated
    by the spec.  Moreover the Power Controller Control bit is unreliable
    when a power fault occurs (PCIe r4.0, sec 6.7.1.8).  This issue has
    existed since the driver was introduced in 2004.
    
    Fix by replacing STATIC_STATE with ON_STATE and OFF_STATE and tracking
    whether the slot has been turned on or off.  This is also a required
    ingredient to make pciehp resilient to missed events, which is the
    object of an upcoming commit.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 0d005c5fabfa..1ba335d6563a 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -122,11 +122,24 @@ struct controller {
 	atomic_t pending_events;
 };
 
-#define STATIC_STATE			0
+/**
+ * DOC: Slot state
+ *
+ * @OFF_STATE: slot is powered off, no subordinate devices are enumerated
+ * @BLINKINGON_STATE: slot will be powered on after the 5 second delay,
+ *	green led is blinking
+ * @BLINKINGOFF_STATE: slot will be powered off after the 5 second delay,
+ *	green led is blinking
+ * @POWERON_STATE: slot is currently powering on
+ * @POWEROFF_STATE: slot is currently powering off
+ * @ON_STATE: slot is powered on, subordinate devices have been enumerated
+ */
+#define OFF_STATE			0
 #define BLINKINGON_STATE		1
 #define BLINKINGOFF_STATE		2
 #define POWERON_STATE			3
 #define POWEROFF_STATE			4
+#define ON_STATE			5
 
 #define ATTN_BUTTN(ctrl)	((ctrl)->slot_cap & PCI_EXP_SLTCAP_ABP)
 #define POWER_CTRL(ctrl)	((ctrl)->slot_cap & PCI_EXP_SLTCAP_PCP)

commit 55a6b7a6576d6cba77bb2ce2bfb2126df83df58a
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:42 2018 -0500

    PCI: pciehp: Drop slot workqueue
    
    Previously the slot workqueue was used to handle events and enable or
    disable the slot.  That's no longer the case as those tasks are done
    synchronously in the IRQ thread.  The slot workqueue is thus merely used
    to handle a button press after the 5 second delay and only one such work
    item may be in flight at any given time.  A separate workqueue isn't
    necessary for this simple task, so use the system workqueue instead.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 82ff77cc92f5..0d005c5fabfa 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -69,7 +69,6 @@ do {									\
  *	protects scheduling, execution and cancellation of @work
  * @hotplug_lock: serializes calls to pciehp_enable_slot() and
  *	pciehp_disable_slot()
- * @wq: work queue on which @work is scheduled
  */
 struct slot {
 	u8 state;
@@ -78,7 +77,6 @@ struct slot {
 	struct delayed_work work;
 	struct mutex lock;
 	struct mutex hotplug_lock;
-	struct workqueue_struct *wq;
 };
 
 /**

commit 0e94916e6091f48391b65110e71c87c583021640
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:41 2018 -0500

    PCI: pciehp: Handle events synchronously
    
    Up until now, pciehp's IRQ handler schedules a work item for each event,
    which in turn schedules a work item to enable or disable the slot.  This
    double indirection was necessary because sleeping wasn't allowed in the
    IRQ handler.
    
    However it is now that pciehp has been converted to threaded IRQ handling
    and polling, so handle events synchronously in pciehp_ist() and remove
    the work item infrastructure (with the exception of work items to handle
    a button press after the 5 second delay).
    
    For link or presence change events, move the register read to determine
    the current link or presence state behind acquisition of the slot lock
    to prevent it from becoming stale while the lock is contended.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 9f11360e3318..82ff77cc92f5 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -69,8 +69,7 @@ do {									\
  *	protects scheduling, execution and cancellation of @work
  * @hotplug_lock: serializes calls to pciehp_enable_slot() and
  *	pciehp_disable_slot()
- * @wq: work queue on which @work is scheduled;
- *	also used to queue interrupt events and slot enablement and disablement
+ * @wq: work queue on which @work is scheduled
  */
 struct slot {
 	u8 state;
@@ -82,12 +81,6 @@ struct slot {
 	struct workqueue_struct *wq;
 };
 
-struct event_info {
-	u32 event_type;
-	struct slot *p_slot;
-	struct work_struct work;
-};
-
 /**
  * struct controller - PCIe hotplug controller
  * @ctrl_lock: serializes writes to the Slot Control register
@@ -131,13 +124,6 @@ struct controller {
 	atomic_t pending_events;
 };
 
-#define INT_PRESENCE_ON			1
-#define INT_PRESENCE_OFF		2
-#define INT_POWER_FAULT			3
-#define INT_BUTTON_PRESS		4
-#define INT_LINK_UP			5
-#define INT_LINK_DOWN			6
-
 #define STATIC_STATE			0
 #define BLINKINGON_STATE		1
 #define BLINKINGOFF_STATE		2
@@ -156,7 +142,9 @@ struct controller {
 
 int pciehp_sysfs_enable_slot(struct slot *slot);
 int pciehp_sysfs_disable_slot(struct slot *slot);
-void pciehp_queue_interrupt_event(struct slot *slot, u32 event_type);
+void pciehp_handle_button_press(struct slot *slot);
+void pciehp_handle_link_change(struct slot *slot);
+void pciehp_handle_presence_change(struct slot *slot);
 int pciehp_configure_device(struct slot *p_slot);
 void pciehp_unconfigure_device(struct slot *p_slot);
 void pciehp_queue_pushbutton_work(struct work_struct *work);

commit ec07a4473072ff0607e3126ce26c31dbf81f9a15
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:39 2018 -0500

    PCI: pciehp: Convert to threaded polling
    
    We've just converted pciehp to threaded IRQ handling, but still cannot
    sleep in pciehp_ist() because the function is also called in poll mode,
    which runs in softirq context (from a timer).
    
    Convert poll mode to a kthread so that pciehp_ist() always runs in task
    context.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index ab1d97a1822d..9f11360e3318 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -97,7 +97,7 @@ struct event_info {
  *	used for synchronous writes to the Slot Control register
  * @slot_cap: cached copy of the Slot Capabilities register
  * @slot_ctrl: cached copy of the Slot Control register
- * @poll_timer: timer to poll for slot events if no IRQ is available,
+ * @poll_thread: thread to poll for slot events if no IRQ is available,
  *	enabled with pciehp_poll_mode module parameter
  * @cmd_started: jiffies when the Slot Control register was last written;
  *	the next write is allowed 1 second later, absent a Command Completed
@@ -122,7 +122,7 @@ struct controller {
 	wait_queue_head_t queue;
 	u32 slot_cap;
 	u16 slot_ctrl;
-	struct timer_list poll_timer;
+	struct task_struct *poll_thread;
 	unsigned long cmd_started;	/* jiffies */
 	unsigned int cmd_busy:1;
 	unsigned int link_active_reporting:1;

commit 7b4ce26bcf697e3a4aa9ba2a5b456562e0fb7af4
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:38 2018 -0500

    PCI: pciehp: Convert to threaded IRQ
    
    pciehp's IRQ handler queues up a work item for each event signaled by
    the hardware.  A more modern alternative is to let a long running
    kthread service the events.  The IRQ handler's sole job is then to check
    whether the IRQ originated from the device in question, acknowledge its
    receipt to the hardware to quiesce the interrupt and wake up the kthread.
    
    One benefit is reduced latency to handle the IRQ, which is a necessity
    for realtime environments.  Another benefit is that we can make pciehp
    simpler and more robust by handling events synchronously in process
    context, rather than asynchronously by queueing up work items.  pciehp's
    usage of work items is a historic artifact, it predates the introduction
    of threaded IRQ handlers by two years.  (The former was introduced in
    2007 with commit 5d386e1ac402 ("pciehp: Event handling rework"), the
    latter in 2009 with commit 3aa551c9b4c4 ("genirq: add threaded interrupt
    handler support").)
    
    Convert pciehp to threaded IRQ handling by retrieving the pending events
    in pciehp_isr(), saving them for later consumption by the thread handler
    pciehp_ist() and clearing them in the Slot Status register.
    
    By clearing the Slot Status (and thereby acknowledging the events) in
    pciehp_isr(), we can avoid requesting the IRQ with IRQF_ONESHOT, which
    would have the unpleasant side effect of starving devices sharing the
    IRQ until pciehp_ist() has finished.
    
    pciehp_isr() does not count how many times each event occurred, but
    merely records the fact *that* an event occurred.  If the same event
    occurs a second time before pciehp_ist() is woken, that second event
    will not be recorded separately, which is problematic according to
    commit fad214b0aa72 ("PCI: pciehp: Process all hotplug events before
    looking for new ones") because we may miss removal of a card in-between
    two back-to-back insertions.  We're about to make pciehp_ist() resilient
    to missed events.  The present commit regresses the driver's behavior
    temporarily in order to separate the changes into reviewable chunks.
    This doesn't affect regular slow-motion hotplug, only plug-unplug-plug
    operations that happen in a timespan shorter than wakeup of the IRQ
    thread.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Mayurkumar Patel <mayurkumar.patel@intel.com>
    Cc: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index c3d63e5b650f..ab1d97a1822d 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -112,6 +112,8 @@ struct event_info {
  * @notification_enabled: whether the IRQ was requested successfully
  * @power_fault_detected: whether a power fault was detected by the hardware
  *	that has not yet been cleared by the user
+ * @pending_events: used by the IRQ handler to save events retrieved from the
+ *	Slot Status register for later consumption by the IRQ thread
  */
 struct controller {
 	struct mutex ctrl_lock;
@@ -126,6 +128,7 @@ struct controller {
 	unsigned int link_active_reporting:1;
 	unsigned int notification_enabled:1;
 	unsigned int power_fault_detected;
+	atomic_t pending_events;
 };
 
 #define INT_PRESENCE_ON			1

commit 4aed1cd6fb957fa8de5a9416a9adab98775878e9
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:36 2018 -0500

    PCI: pciehp: Document struct slot and struct controller
    
    Document the driver's data structures to lower the barrier to entry for
    contributors.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index acdeb08cbcba..c3d63e5b650f 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -57,11 +57,26 @@ do {									\
 	dev_warn(&ctrl->pcie->device, format, ## arg)
 
 #define SLOT_NAME_SIZE 10
+
+/**
+ * struct slot - PCIe hotplug slot
+ * @state: current state machine position
+ * @ctrl: pointer to the slot's controller structure
+ * @hotplug_slot: pointer to the structure registered with the PCI hotplug core
+ * @work: work item to turn the slot on or off after 5 seconds in response to
+ *	an Attention Button press
+ * @lock: protects reads and writes of @state;
+ *	protects scheduling, execution and cancellation of @work
+ * @hotplug_lock: serializes calls to pciehp_enable_slot() and
+ *	pciehp_disable_slot()
+ * @wq: work queue on which @work is scheduled;
+ *	also used to queue interrupt events and slot enablement and disablement
+ */
 struct slot {
 	u8 state;
 	struct controller *ctrl;
 	struct hotplug_slot *hotplug_slot;
-	struct delayed_work work;	/* work for button event */
+	struct delayed_work work;
 	struct mutex lock;
 	struct mutex hotplug_lock;
 	struct workqueue_struct *wq;
@@ -73,11 +88,36 @@ struct event_info {
 	struct work_struct work;
 };
 
+/**
+ * struct controller - PCIe hotplug controller
+ * @ctrl_lock: serializes writes to the Slot Control register
+ * @pcie: pointer to the controller's PCIe port service device
+ * @slot: pointer to the controller's slot structure
+ * @queue: wait queue to wake up on reception of a Command Completed event,
+ *	used for synchronous writes to the Slot Control register
+ * @slot_cap: cached copy of the Slot Capabilities register
+ * @slot_ctrl: cached copy of the Slot Control register
+ * @poll_timer: timer to poll for slot events if no IRQ is available,
+ *	enabled with pciehp_poll_mode module parameter
+ * @cmd_started: jiffies when the Slot Control register was last written;
+ *	the next write is allowed 1 second later, absent a Command Completed
+ *	interrupt (PCIe r4.0, sec 6.7.3.2)
+ * @cmd_busy: flag set on Slot Control register write, cleared by IRQ handler
+ *	on reception of a Command Completed event
+ * @link_active_reporting: cached copy of Data Link Layer Link Active Reporting
+ *	Capable bit in Link Capabilities register; if this bit is zero, the
+ *	Data Link Layer Link Active bit in the Link Status register will never
+ *	be set and the driver is thus confined to wait 1 second before assuming
+ *	the link to a hotplugged device is up and accessing it
+ * @notification_enabled: whether the IRQ was requested successfully
+ * @power_fault_detected: whether a power fault was detected by the hardware
+ *	that has not yet been cleared by the user
+ */
 struct controller {
-	struct mutex ctrl_lock;		/* controller lock */
-	struct pcie_device *pcie;	/* PCI Express port service */
+	struct mutex ctrl_lock;
+	struct pcie_device *pcie;
 	struct slot *slot;
-	wait_queue_head_t queue;	/* sleep & wake process */
+	wait_queue_head_t queue;
 	u32 slot_cap;
 	u16 slot_ctrl;
 	struct timer_list poll_timer;

commit 1d2e2673dc5b9b374513fd58d5909f0332b47407
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:36 2018 -0500

    PCI: pciehp: Declare pciehp_unconfigure_device() void
    
    Since commit 0f4bd8014db5 ("PCI: hotplug: Drop checking of PCI_BRIDGE_
    CONTROL in *_unconfigure_device()"), pciehp_unconfigure_device() can no
    longer fail, so declare it and its sole caller remove_board() void, in
    keeping with the usual kernel pattern that enablement can fail, but
    disablement cannot.  No functional change intended.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index fca87a1a2b22..acdeb08cbcba 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -115,7 +115,7 @@ int pciehp_sysfs_enable_slot(struct slot *slot);
 int pciehp_sysfs_disable_slot(struct slot *slot);
 void pciehp_queue_interrupt_event(struct slot *slot, u32 event_type);
 int pciehp_configure_device(struct slot *p_slot);
-int pciehp_unconfigure_device(struct slot *p_slot);
+void pciehp_unconfigure_device(struct slot *p_slot);
 void pciehp_queue_pushbutton_work(struct work_struct *work);
 struct controller *pcie_init(struct pcie_device *dev);
 int pcie_init_notification(struct controller *ctrl);

commit 281e878eab191cce4259abbbf1a0322e3adae02c
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:32 2018 -0500

    PCI: pciehp: Fix use-after-free on unplug
    
    When pciehp is unbound (e.g. on unplug of a Thunderbolt device), the
    hotplug_slot struct is deregistered and thus freed before freeing the
    IRQ.  The IRQ handler and the work items it schedules print the slot
    name referenced from the freed structure in various informational and
    debug log messages, each time resulting in a quadruple dereference of
    freed pointers (hotplug_slot -> pci_slot -> kobject -> name).
    
    At best the slot name is logged as "(null)", at worst kernel memory is
    exposed in logs or the driver crashes:
    
      pciehp 0000:10:00.0:pcie204: Slot((null)): Card not present
    
    An attacker may provoke the bug by unplugging multiple devices on a
    Thunderbolt daisy chain at once.  Unplugging can also be simulated by
    powering down slots via sysfs.  The bug is particularly easy to trigger
    in poll mode.
    
    It has been present since the driver's introduction in 2004:
    https://git.kernel.org/tglx/history/c/c16b4b14d980
    
    Fix by rearranging teardown such that the IRQ is freed first.  Run the
    work items queued by the IRQ handler to completion before freeing the
    hotplug_slot struct by draining the work queue from the ->release_slot
    callback which is invoked by pci_hp_deregister().
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: stable@vger.kernel.org # v2.6.4

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 5f892065585e..fca87a1a2b22 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -119,6 +119,7 @@ int pciehp_unconfigure_device(struct slot *p_slot);
 void pciehp_queue_pushbutton_work(struct work_struct *work);
 struct controller *pcie_init(struct pcie_device *dev);
 int pcie_init_notification(struct controller *ctrl);
+void pcie_shutdown_notification(struct controller *ctrl);
 int pciehp_enable_slot(struct slot *p_slot);
 int pciehp_disable_slot(struct slot *p_slot);
 void pcie_reenable_notification(struct controller *ctrl);

commit 13c65840feab8109194f9490c9870587173cb29d
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed May 23 17:14:39 2018 -0500

    PCI: pciehp: Clear Presence Detect and Data Link Layer Status Changed on resume
    
    After a suspend/resume cycle the Presence Detect or Data Link Layer Status
    Changed bits might be set.  If we don't clear them those events will not
    fire anymore and nothing happens for instance when a device is now
    hot-unplugged.
    
    Fix this by clearing those bits in a newly introduced function
    pcie_reenable_notification().  This should be fine because immediately
    after, we check if the adapter is still present by reading directly from
    the status register.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 88e917c9120f..5f892065585e 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -121,7 +121,7 @@ struct controller *pcie_init(struct pcie_device *dev);
 int pcie_init_notification(struct controller *ctrl);
 int pciehp_enable_slot(struct slot *p_slot);
 int pciehp_disable_slot(struct slot *p_slot);
-void pcie_enable_notification(struct controller *ctrl);
+void pcie_reenable_notification(struct controller *ctrl);
 int pciehp_power_on_slot(struct slot *slot);
 void pciehp_power_off_slot(struct slot *slot);
 void pciehp_get_power_status(struct slot *slot, u8 *status);

commit ef7942603e35e300e6967fa7c17ebc17a0c00f59
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:42:01 2018 -0600

    PCI/portdrv: Merge pcieport_if.h into portdrv.h
    
    pcieport_if.h contained the interfaces to register port service driver,
    e.g., pcie_port_service_register().  portdrv.h contained internal data
    structures of the port driver.
    
    I don't think it's worth keeping those files separate, since both headers
    and their users are all inside the PCI core.
    
    Merge pcieport_if.h directly in drivers/pci/pcie/portdrv.h and update the
    users to include that instead.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 08072bcaa381..88e917c9120f 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -23,7 +23,7 @@
 #include <linux/mutex.h>
 #include <linux/workqueue.h>
 
-#include "../pcie/pcieport_if.h"
+#include "../pcie/portdrv.h"
 
 #define MY_NAME	"pciehp"
 

commit c37e627f9565368ed7bd1f3cf59a2d223ddba85a
Author: Frederick Lawler <fred@fredlawl.com>
Date:   Tue Feb 13 21:52:18 2018 -0600

    PCI/portdrv: Move pcieport_if.h to drivers/pci/pcie/
    
    Move pcieport_if.h from include/linux to drivers/pci/pcie/pcieport_if.h
    because the interfaces there are only used by the PCI core.
    
    Replace all uses of #include<linux/pcieport_if.h> with relative paths to
    the new file location, e.g., #include "../pcieport_if.h"
    
    Signed-off-by: Frederick Lawler <fred@fredlawl.com>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 636ed8f4b869..08072bcaa381 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -20,10 +20,11 @@
 #include <linux/pci_hotplug.h>
 #include <linux/delay.h>
 #include <linux/sched/signal.h>		/* signal_pending() */
-#include <linux/pcieport_if.h>
 #include <linux/mutex.h>
 #include <linux/workqueue.h>
 
+#include "../pcie/pcieport_if.h"
+
 #define MY_NAME	"pciehp"
 
 extern bool pciehp_poll_mode;

commit 736759ef59d86a7bcefb1cdb629abecafc645a46
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 26 14:22:04 2018 -0600

    PCI: Add SPDX GPL-2.0+ to replace GPL v2 or later boilerplate
    
    Add SPDX GPL-2.0+ to all PCI files that specified the GPL and allowed
    either GPL version 2 or any later version.
    
    Remove the boilerplate GPL version 2 or later language, relying on the
    assertion in b24413180f56 ("License cleanup: add SPDX GPL-2.0 license
    identifier to files with no license") that the SPDX identifier may be used
    instead of the full boilerplate text.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 06109d40c4ac..636ed8f4b869 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
 /*
  * PCI Express Hot Plug Controller Driver
  *
@@ -8,21 +9,6 @@
  *
  * All rights reserved.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at
- * your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
- * NON INFRINGEMENT.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
  * Send feedback to <greg@kroah.com>, <kristen.c.accardi@intel.com>
  *
  */

commit 174cd4b1e5fbd0d74c68cf3a74f5bd4923485512
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 19:15:33 2017 +0100

    sched/headers: Prepare to move signal wakeup & sigpending methods from <linux/sched.h> into <linux/sched/signal.h>
    
    Fix up affected files that include this signal functionality via sched.h.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 37d70b5ad22f..06109d40c4ac 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -33,7 +33,7 @@
 #include <linux/pci.h>
 #include <linux/pci_hotplug.h>
 #include <linux/delay.h>
-#include <linux/sched.h>		/* signal_pending() */
+#include <linux/sched/signal.h>		/* signal_pending() */
 #include <linux/pcieport_if.h>
 #include <linux/mutex.h>
 #include <linux/workqueue.h>

commit 576243b3f9eaa47ab568ac49574b3a095c2365f1
Author: Keith Busch <keith.busch@intel.com>
Date:   Tue Sep 13 10:31:59 2016 -0600

    PCI: pciehp: Allow exclusive userspace control of indicators
    
    PCIe hotplug supports optional Attention and Power Indicators, which are
    used internally by pciehp.  Users can't control the Power Indicator, but
    they can control the Attention Indicator by writing to a sysfs "attention"
    file.
    
    The Slot Control register has two bits for each indicator, and the PCIe
    spec defines the encodings for each as (Reserved/On/Blinking/Off).  For
    sysfs "attention" writes, pciehp_set_attention_status() maps into these
    encodings, so the only useful write values are 0 (Off), 1 (On), and 2
    (Blinking).
    
    However, some platforms use all four bits for platform-specific indicators,
    and they need to allow direct user control of them while preventing pciehp
    from using them at all.
    
    Add a "hotplug_user_indicators" flag to the pci_dev structure.  When set,
    pciehp does not use either the Attention Indicator or the Power Indicator,
    and the low four bits (values 0x0 - 0xf) of sysfs "attention" write values
    are written directly to the Attention Indicator Control and Power Indicator
    Control fields.
    
    [bhelgaas: changelog, rename flag and accessors to s/attention/indicator/]
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index e764918641ae..37d70b5ad22f 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -152,6 +152,9 @@ bool pciehp_check_link_active(struct controller *ctrl);
 void pciehp_release_ctrl(struct controller *ctrl);
 int pciehp_reset_slot(struct slot *slot, int probe);
 
+int pciehp_set_raw_indicator_status(struct hotplug_slot *h_slot, u8 status);
+int pciehp_get_raw_indicator_status(struct hotplug_slot *h_slot, u8 *status);
+
 static inline const char *slot_name(struct slot *slot)
 {
 	return hotplug_slot_name(slot->hotplug_slot);

commit ff3ce480e8b59fbc0f459476fe1b5451464592a5
Author: Bogicevic Sasa <brutallesale@gmail.com>
Date:   Sun Dec 27 13:21:11 2015 -0800

    PCI: Fix all whitespace issues
    
    Fix all whitespace issues (missing or needed whitespace) in all files in
    drivers/pci.  Code is compiled with allyesconfig before and after code
    changes and objects are recorded and checked with objdiff and they are not
    changed after this commit.
    
    Signed-off-by: Bogicevic Sasa <brutallesale@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 62d6fe6c3714..e764918641ae 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -47,14 +47,14 @@ extern bool pciehp_debug;
 #define dbg(format, arg...)						\
 do {									\
 	if (pciehp_debug)						\
-		printk(KERN_DEBUG "%s: " format, MY_NAME , ## arg);	\
+		printk(KERN_DEBUG "%s: " format, MY_NAME, ## arg);	\
 } while (0)
 #define err(format, arg...)						\
-	printk(KERN_ERR "%s: " format, MY_NAME , ## arg)
+	printk(KERN_ERR "%s: " format, MY_NAME, ## arg)
 #define info(format, arg...)						\
-	printk(KERN_INFO "%s: " format, MY_NAME , ## arg)
+	printk(KERN_INFO "%s: " format, MY_NAME, ## arg)
 #define warn(format, arg...)						\
-	printk(KERN_WARNING "%s: " format, MY_NAME , ## arg)
+	printk(KERN_WARNING "%s: " format, MY_NAME, ## arg)
 
 #define ctrl_dbg(ctrl, format, arg...)					\
 	do {								\

commit 2db0f71f56795f6b04d386b15c3b32b570558ebd
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jul 1 17:17:49 2015 -0500

    PCI: pciehp: Remove ignored MRL sensor interrupt events
    
    We queued interrupt events for the MRL being opened or closed, but the code
    in interrupt_event_handler() that handles these events ignored them.
    
    Stop enabling MRL interrupts and remove the ignored events.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index aca84e1b81be..62d6fe6c3714 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -103,12 +103,10 @@ struct controller {
 
 #define INT_PRESENCE_ON			1
 #define INT_PRESENCE_OFF		2
-#define INT_SWITCH_CLOSE		3
-#define INT_SWITCH_OPEN			4
-#define INT_POWER_FAULT			5
-#define INT_BUTTON_PRESS		6
-#define INT_LINK_UP			7
-#define INT_LINK_DOWN			8
+#define INT_POWER_FAULT			3
+#define INT_BUTTON_PRESS		4
+#define INT_LINK_UP			5
+#define INT_LINK_DOWN			6
 
 #define STATIC_STATE			0
 #define BLINKINGON_STATE		1

commit 58fa2405bd44805cb6166603100b0183ce26a0c8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jul 1 17:01:03 2015 -0500

    PCI: pciehp: Remove unused interrupt events
    
    The list of interrupt events (INT_BUTTON_IGNORE, INT_PRESENCE_ON, etc.) was
    copied from other hotplug drivers, but pciehp doesn't use them all.
    
    Remove the interrupt events that aren't used by pciehp.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 57cd1327346f..aca84e1b81be 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -101,18 +101,14 @@ struct controller {
 	unsigned int power_fault_detected;
 };
 
-#define INT_BUTTON_IGNORE		0
 #define INT_PRESENCE_ON			1
 #define INT_PRESENCE_OFF		2
 #define INT_SWITCH_CLOSE		3
 #define INT_SWITCH_OPEN			4
 #define INT_POWER_FAULT			5
-#define INT_POWER_FAULT_CLEAR		6
-#define INT_BUTTON_PRESS		7
-#define INT_BUTTON_RELEASE		8
-#define INT_BUTTON_CANCEL		9
-#define INT_LINK_UP			10
-#define INT_LINK_DOWN			11
+#define INT_BUTTON_PRESS		6
+#define INT_LINK_UP			7
+#define INT_LINK_DOWN			8
 
 #define STATIC_STATE			0
 #define BLINKINGON_STATE		1

commit 4f092fec67191f899fa111a4eeffdf4368494c77
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sun Jun 14 21:35:13 2015 -0500

    PCI: pciehp: Inline the "handle event" functions into the ISR
    
    The pciehp_handle_*() functions (pciehp_handle_attention_button(), etc.)
    only contain a line or two of useful code, so it's clumsy to put
    them in separate functions.  All they so is add an event to a work queue,
    and it's clearer to see that directly in the ISR.
    
    Inline them directly into pcie_isr().  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rajat Jain <rajatja@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index ce4d12c4eff4..57cd1327346f 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -132,11 +132,7 @@ struct controller {
 
 int pciehp_sysfs_enable_slot(struct slot *slot);
 int pciehp_sysfs_disable_slot(struct slot *slot);
-u8 pciehp_handle_attention_button(struct slot *p_slot);
-u8 pciehp_handle_switch_change(struct slot *p_slot);
-u8 pciehp_handle_presence_change(struct slot *p_slot);
-u8 pciehp_handle_power_fault(struct slot *p_slot);
-void pciehp_handle_linkstate_change(struct slot *p_slot);
+void pciehp_queue_interrupt_event(struct slot *slot, u32 event_type);
 int pciehp_configure_device(struct slot *p_slot);
 int pciehp_unconfigure_device(struct slot *p_slot);
 void pciehp_queue_pushbutton_work(struct work_struct *work);

commit e705c2959b06b9db184842852da619a0b1672bbc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue May 19 15:27:58 2015 +0200

    PCI: pciehp: Drop pointless ACPI-based "slot detection" check
    
    Jarod Wilson reports that ExpressCard hotplug doesn't work on HP ZBook G2.
    The problem turns out to be the ACPI-based "slot detection" code called
    from pciehp_probe() which uses questionable heuristics based on what ACPI
    objects are present for the PCIe port device to figure out whether to
    register a hotplug slot for that port.
    
    That code is used if there is at least one PCIe port having an ACPI device
    configuration object related to hotplug (such as _EJ0 or _RMV), and the
    Thunderbolt port on the ZBook has _RMV.  Of course, Thunderbolt and PCIe
    native hotplug need not be mutually exclusive (as they aren't on the
    ZBook), so that rule is simply incorrect.
    
    Moreover, the ACPI-based "slot detection" check does not add any value if
    pciehp_probe() is called at all and the service type of the device object
    it has been called for is PCIE_PORT_SERVICE_HP, because PCIe hotplug
    services are only registered if the _OSC handshake in acpi_pci_root_add()
    allows the kernel to control the PCIe native hotplug feature.  No more
    checks need to be carried out to decide whether or not to register a native
    PCIe hotlug slot in that case.
    
    For the above reasons, make pciehp_probe() check if it has been called for
    the right service type and drop the pointless ACPI-based "slot detection"
    check from it.  Also remove the entire code whose only user is that check
    (the entire pciehp_acpi.c file goes away as a result) and drop function
    headers related to it from the internal pciehp header file.
    
    Link: http://lkml.kernel.org/r/1431632038-39917-1-git-send-email-jarod@redhat.com
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=98581
    Reported-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Jarod Wilson <jarod@redhat.com>
    Tested-by: Jarod Wilson <jarod@redhat.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index b11521953485..ce4d12c4eff4 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -167,21 +167,4 @@ static inline const char *slot_name(struct slot *slot)
 	return hotplug_slot_name(slot->hotplug_slot);
 }
 
-#ifdef CONFIG_ACPI
-#include <linux/pci-acpi.h>
-
-void __init pciehp_acpi_slot_detection_init(void);
-int pciehp_acpi_slot_detection_check(struct pci_dev *dev);
-
-static inline void pciehp_firmware_init(void)
-{
-	pciehp_acpi_slot_detection_init();
-}
-#else
-#define pciehp_firmware_init()				do {} while (0)
-static inline int pciehp_acpi_slot_detection_check(struct pci_dev *dev)
-{
-	return 0;
-}
-#endif				/* CONFIG_ACPI */
 #endif				/* _PCIEHP_H */

commit d537a3abb4b7085ebc3ce35e64acbad8ece1eece
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Aug 15 17:18:44 2014 -0600

    PCI: pciehp: Reduce PCIe slot_ctrl to 16 bits
    
    4283c70e91dc ("PCI: pciehp: Make pcie_wait_cmd() self-contained") added
    a cache of the most recent command written to the Slot Control register.
    This register is only 16 bits wide, but the cache ("slot_ctrl") is 32 bits.
    
    Reduce slot_ctrl to a u16 so it matches the register size.  No functional
    change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 9e5a9fbb93d7..b11521953485 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -92,7 +92,7 @@ struct controller {
 	struct slot *slot;
 	wait_queue_head_t queue;	/* sleep & wake process */
 	u32 slot_cap;
-	u32 slot_ctrl;
+	u16 slot_ctrl;
 	struct timer_list poll_timer;
 	unsigned long cmd_started;	/* jiffies */
 	unsigned int cmd_busy:1;

commit 6c1a32e06758ba1c997f81a3c41e780cfc77b3c2
Author: Rajat Jain <rajatxjain@gmail.com>
Date:   Thu Jun 26 11:58:55 2014 -0700

    PCI: pciehp: Remove struct controller.no_cmd_complete
    
    "no_cmd_complete" is only used once, and it duplicates read-only
    information we already have in the cached Slot Capabilities value.
    
    Remove the field and use the existing macro NO_CMD_CMPL() instead.
    
    [bhelgaas: changelog]
    Signed-off-by: Rajat Jain <rajatxjain@gmail.com>
    Signed-off-by: Rajat Jain <rajatjain@juniper.net>
    Signed-off-by: Guenter Roeck <groeck@juniper.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index c496258cd9a7..9e5a9fbb93d7 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -96,7 +96,6 @@ struct controller {
 	struct timer_list poll_timer;
 	unsigned long cmd_started;	/* jiffies */
 	unsigned int cmd_busy:1;
-	unsigned int no_cmd_complete:1;
 	unsigned int link_active_reporting:1;
 	unsigned int notification_enabled:1;
 	unsigned int power_fault_detected;

commit 40b960831cfa8ee34d4b1035ddd7074bc5b01ecf
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Jun 14 09:55:49 2014 -0600

    PCI: pciehp: Compute timeout from hotplug command start time
    
    If we issue a hotplug command, go do something else, then come back and
    wait for the command to complete, we don't have to wait the whole timeout
    period, because some of it elapsed while we were doing something else.
    
    Keep track of the time we issued the command, and wait only until the
    timeout period from that point has elapsed.
    
    For controllers with errata like Intel CF118, we previously timed out
    before issuing the second hotplug command:
    
      At time T1 (during boot):
        - Write DLLSCE, ABPE, PDCE, etc. to Slot Control
      At time T2 (hotplug event):
        - Wait for command completion (CC) in Slot Status
        - Timeout at T2 + 1 second because CC is never set in Slot Status
        - Write PCC, PIC, etc. to Slot Control
    
    With this change, we wait until T1 + 1 second instead of T2 + 1 second.
    If the hotplug event is more than 1 second after the boot-time
    initialization, we won't wait for the timeout at all.
    
    We still emit a "Timeout on hotplug command" message if it timed out; we
    should see this on the first hotplug event on every controller with this
    erratum, as well as on real errors on controllers without the erratum.
    
    Link: http://www.intel.com/content/www/us/en/processors/xeon/xeon-e7-v2-spec-update.html
    Tested-by: Rajat Jain <rajatxjain@gmail.com>    (IDT 807a controller)
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index f7bc886c20be..c496258cd9a7 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -94,6 +94,7 @@ struct controller {
 	u32 slot_cap;
 	u32 slot_ctrl;
 	struct timer_list poll_timer;
+	unsigned long cmd_started;	/* jiffies */
 	unsigned int cmd_busy:1;
 	unsigned int no_cmd_complete:1;
 	unsigned int link_active_reporting:1;

commit 4283c70e91dcabe36f3545afabc5ee2b7d4da34a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jun 13 13:58:35 2014 -0600

    PCI: pciehp: Make pcie_wait_cmd() self-contained
    
    pcie_wait_cmd() waits for the controller to finish a hotplug command.  Move
    the associated logic (to determine whether waiting is required and whether
    we're using interrupts or polling) from pcie_write_cmd() to
    pcie_wait_cmd().
    
    No functional change.
    
    Tested-by: Rajat Jain <rajatxjain@gmail.com>    (IDT 807a controller)
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 8e9012dca450..f7bc886c20be 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -92,6 +92,7 @@ struct controller {
 	struct slot *slot;
 	wait_queue_head_t queue;	/* sleep & wake process */
 	u32 slot_cap;
+	u32 slot_ctrl;
 	struct timer_list poll_timer;
 	unsigned int cmd_busy:1;
 	unsigned int no_cmd_complete:1;

commit 17f830bb83ff64533f02cfd4b114d4a5957c2ee7
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Apr 5 15:05:07 2014 -0600

    PCI: pciehp: Use PCI_EXP_SLTCAP_PSN define
    
    Use PCI_EXP_SLTCAP_PSN to make it easier to find code that uses the
    Physical Slot Number field in the PCIe Slot Capabilities register.
    
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 8a66866b8cf1..8e9012dca450 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -127,7 +127,7 @@ struct controller {
 #define HP_SUPR_RM(ctrl)	((ctrl)->slot_cap & PCI_EXP_SLTCAP_HPS)
 #define EMI(ctrl)		((ctrl)->slot_cap & PCI_EXP_SLTCAP_EIP)
 #define NO_CMD_CMPL(ctrl)	((ctrl)->slot_cap & PCI_EXP_SLTCAP_NCCS)
-#define PSN(ctrl)		((ctrl)->slot_cap >> 19)
+#define PSN(ctrl)		(((ctrl)->slot_cap & PCI_EXP_SLTCAP_PSN) >> 19)
 
 int pciehp_sysfs_enable_slot(struct slot *slot);
 int pciehp_sysfs_disable_slot(struct slot *slot);

commit 50b52fdee050745935d92e7026373edea2647e60
Author: Rajat Jain <rajatxjain@gmail.com>
Date:   Tue Feb 4 18:31:11 2014 -0800

    PCI: pciehp: Add hotplug_lock to serialize hotplug events
    
    Today it is there is no protection around pciehp_enable_slot() and
    pciehp_disable_slot() to ensure that they complete before another
    hot-plug operation can be done on that particular slot.
    
    This patch introduces the slot->hotplug_lock to ensure that any hotplug
    operations (add / remove) complete before another hotplug event can begin
    processing on that particular slot.
    
    Signed-off-by: Rajat Jain <rajatxjain@gmail.com>
    Signed-off-by: Rajat Jain <rajatjain@juniper.net>
    Signed-off-by: Guenter Roeck <groeck@juniper.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index d8d033619a77..8a66866b8cf1 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -76,6 +76,7 @@ struct slot {
 	struct hotplug_slot *hotplug_slot;
 	struct delayed_work work;	/* work for button event */
 	struct mutex lock;
+	struct mutex hotplug_lock;
 	struct workqueue_struct *wq;
 };
 

commit e48f1b67f668762003e8888eccd7acb71109e874
Author: Rajat Jain <rajatxjain@gmail.com>
Date:   Tue Feb 4 18:29:10 2014 -0800

    PCI: pciehp: Use link change notifications for hot-plug and removal
    
    A lot of systems do not have the fancy buttons and LEDs, and instead
    want to rely only on the Link state change events to drive the hotplug
    and removal state machinery.
    (http://www.spinics.net/lists/hotplug/msg05802.html)
    
    This patch adds support for that functionality. Here are the details
    about the patch itself:
    
    * Define and use interrupt events for linkup / linkdown.
    
    * Make the pcie_isr() also look at link events, and direct control to
      corresponding (new) link state change handler function.
    
    * Introduce the functions to handle link-up and link-down events and
      queue the add / removal work in the slot->wq to be processed by
      pciehp_power_thread()
    
    As a side note, this patch also fixes the bug
    https://bugzilla.kernel.org/show_bug.cgi?id=65521 "pciehp ignores Data Link
    Layer State Changed bit."
    
    Signed-off-by: Rajat Jain <rajatxjain@gmail.com>
    Signed-off-by: Rajat Jain <rajatjain@juniper.net>
    Signed-off-by: Guenter Roeck <groeck@juniper.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index f9524592da0f..d8d033619a77 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -109,6 +109,8 @@ struct controller {
 #define INT_BUTTON_PRESS		7
 #define INT_BUTTON_RELEASE		8
 #define INT_BUTTON_CANCEL		9
+#define INT_LINK_UP			10
+#define INT_LINK_DOWN			11
 
 #define STATIC_STATE			0
 #define BLINKINGON_STATE		1
@@ -132,6 +134,7 @@ u8 pciehp_handle_attention_button(struct slot *p_slot);
 u8 pciehp_handle_switch_change(struct slot *p_slot);
 u8 pciehp_handle_presence_change(struct slot *p_slot);
 u8 pciehp_handle_power_fault(struct slot *p_slot);
+void pciehp_handle_linkstate_change(struct slot *p_slot);
 int pciehp_configure_device(struct slot *p_slot);
 int pciehp_unconfigure_device(struct slot *p_slot);
 void pciehp_queue_pushbutton_work(struct work_struct *work);

commit 4703389f7df70518cc4ea584f3e64cb11f28aa7c
Author: Rajat Jain <rajatxjain@gmail.com>
Date:   Tue Feb 4 18:28:43 2014 -0800

    PCI: pciehp: Make check_link_active() non-static
    
    check_link_active() functionality needs to be used by subsequent patches
    (that introduce link state change based hotplug). Thus make the function
    non-static, and rename it to pciehp_check_link_active() so as to be
    consistent with other non-static functions.
    
    Signed-off-by: Rajat Jain <rajatxjain@gmail.com>
    Signed-off-by: Rajat Jain <rajatjain@juniper.net>
    Signed-off-by: Guenter Roeck <groeck@juniper.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 88b37cad4b35..f9524592da0f 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -153,6 +153,7 @@ void pciehp_green_led_on(struct slot *slot);
 void pciehp_green_led_off(struct slot *slot);
 void pciehp_green_led_blink(struct slot *slot);
 int pciehp_check_link_status(struct controller *ctrl);
+bool pciehp_check_link_active(struct controller *ctrl);
 void pciehp_release_ctrl(struct controller *ctrl);
 int pciehp_reset_slot(struct slot *slot, int probe);
 

commit 09da8dfa98682d871987145ed11e3232accac860
Merge: 3aacd625f201 7744064731a9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 24 15:51:02 2014 -0800

    Merge tag 'pm+acpi-3.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "As far as the number of commits goes, the top spot belongs to ACPI
      this time with cpufreq in the second position and a handful of PM
      core, PNP and cpuidle updates.  They are fixes and cleanups mostly, as
      usual, with a couple of new features in the mix.
    
      The most visible change is probably that we will create struct
      acpi_device objects (visible in sysfs) for all devices represented in
      the ACPI tables regardless of their status and there will be a new
      sysfs attribute under those objects allowing user space to check that
      status via _STA.
    
      Consequently, ACPI device eject or generally hot-removal will not
      delete those objects, unless the table containing the corresponding
      namespace nodes is unloaded, which is extremely rare.  Also ACPI
      container hotplug will be handled quite a bit differently and cpufreq
      will support CPU boost ("turbo") generically and not only in the
      acpi-cpufreq driver.
    
      Specifics:
    
       - ACPI core changes to make it create a struct acpi_device object for
         every device represented in the ACPI tables during all namespace
         scans regardless of the current status of that device.  In
         accordance with this, ACPI hotplug operations will not delete those
         objects, unless the underlying ACPI tables go away.
    
       - On top of the above, new sysfs attribute for ACPI device objects
         allowing user space to check device status by triggering the
         execution of _STA for its ACPI object.  From Srinivas Pandruvada.
    
       - ACPI core hotplug changes reducing code duplication, integrating
         the PCI root hotplug with the core and reworking container hotplug.
    
       - ACPI core simplifications making it use ACPI_COMPANION() in the
         code "glueing" ACPI device objects to "physical" devices.
    
       - ACPICA update to upstream version 20131218.  This adds support for
         the DBG2 and PCCT tables to ACPICA, fixes some bugs and improves
         debug facilities.  From Bob Moore, Lv Zheng and Betty Dall.
    
       - Init code change to carry out the early ACPI initialization
         earlier.  That should allow us to use ACPI during the timekeeping
         initialization and possibly to simplify the EFI initialization too.
         From Chun-Yi Lee.
    
       - Clenups of the inclusions of ACPI headers in many places all over
         from Lv Zheng and Rashika Kheria (work in progress).
    
       - New helper for ACPI _DSM execution and rework of the code in
         drivers that uses _DSM to execute it via the new helper.  From
         Jiang Liu.
    
       - New Win8 OSI blacklist entries from Takashi Iwai.
    
       - Assorted ACPI fixes and cleanups from Al Stone, Emil Goode, Hanjun
         Guo, Lan Tianyu, Masanari Iida, Oliver Neukum, Prarit Bhargava,
         Rashika Kheria, Tang Chen, Zhang Rui.
    
       - intel_pstate driver updates, including proper Baytrail support,
         from Dirk Brandewie and intel_pstate documentation from Ramkumar
         Ramachandra.
    
       - Generic CPU boost ("turbo") support for cpufreq from Lukasz
         Majewski.
    
       - powernow-k6 cpufreq driver fixes from Mikulas Patocka.
    
       - cpufreq core fixes and cleanups from Viresh Kumar, Jane Li, Mark
         Brown.
    
       - Assorted cpufreq drivers fixes and cleanups from Anson Huang, John
         Tobias, Paul Bolle, Paul Walmsley, Sachin Kamat, Shawn Guo, Viresh
         Kumar.
    
       - cpuidle cleanups from Bartlomiej Zolnierkiewicz.
    
       - Support for hibernation APM events from Bin Shi.
    
       - Hibernation fix to avoid bringing up nonboot CPUs with ACPI EC
         disabled during thaw transitions from Bjrn Mork.
    
       - PM core fixes and cleanups from Ben Dooks, Leonardo Potenza, Ulf
         Hansson.
    
       - PNP subsystem fixes and cleanups from Dmitry Torokhov, Levente
         Kurusa, Rashika Kheria.
    
       - New tool for profiling system suspend from Todd E Brandt and a
         cpupower tool cleanup from One Thousand Gnomes"
    
    * tag 'pm+acpi-3.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (153 commits)
      thermal: exynos: boost: Automatic enable/disable of BOOST feature (at Exynos4412)
      cpufreq: exynos4x12: Change L0 driver data to CPUFREQ_BOOST_FREQ
      Documentation: cpufreq / boost: Update BOOST documentation
      cpufreq: exynos: Extend Exynos cpufreq driver to support boost
      cpufreq / boost: Kconfig: Support for software-managed BOOST
      acpi-cpufreq: Adjust the code to use the common boost attribute
      cpufreq: Add boost frequency support in core
      intel_pstate: Add trace point to report internal state.
      cpufreq: introduce cpufreq_generic_get() routine
      ARM: SA1100: Create dummy clk_get_rate() to avoid build failures
      cpufreq: stats: create sysfs entries when cpufreq_stats is a module
      cpufreq: stats: free table and remove sysfs entry in a single routine
      cpufreq: stats: remove hotplug notifiers
      cpufreq: stats: handle cpufreq_unregister_driver() and suspend/resume properly
      cpufreq: speedstep: remove unused speedstep_get_state
      platform: introduce OF style 'modalias' support for platform bus
      PM / tools: new tool for suspend/resume performance optimization
      ACPI: fix module autoloading for ACPI enumerated devices
      ACPI: add module autoloading support for ACPI enumerated devices
      ACPI: fix create_modalias() return value handling
      ...

commit 597db6f38c4bcb90406d4e2f56446ba5a5dc20c6
Merge: 6b9bd1e3ee8f 0b950f0f3c67
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jan 13 16:47:08 2014 -0700

    Merge branch 'pci/dead-code' into next
    
    * pci/dead-code:
      PCI: Make local functions static
      PCI: Remove unused alloc_pci_dev()
      PCI: Remove unused pci_renumber_slot()
      PCI: Remove unused pcie_aspm_enabled()
      PCI: Remove unused pci_vpd_truncate()
      PCI: Remove unused ID-Based Ordering support
      PCI: Remove unused Optimized Buffer Flush/Fill support
      PCI: Remove unused Latency Tolerance Reporting support
      PCI: Removed unused parts of Page Request Interface support
    
    Conflicts:
            drivers/pci/pci.c
            include/linux/pci.h

commit 0b950f0f3c67e42f18c655a3ab3e36ea192635bb
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Fri Jan 10 17:14:48 2014 -0700

    PCI: Make local functions static
    
    Using 'make namespacecheck' identify code which should be declared static.
    Checked for users in other driver/archs as well.  Compile tested only.
    
    This stops exporting the following interfaces to modules:
    
        pci_target_state()
        pci_load_saved_state()
    
    [bhelgaas: retained pci_find_next_ext_capability() and pci_cfg_space_size()]
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 21e865ded1dc..8de88b052715 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -43,7 +43,6 @@
 extern bool pciehp_poll_mode;
 extern int pciehp_poll_time;
 extern bool pciehp_debug;
-extern bool pciehp_force;
 
 #define dbg(format, arg...)						\
 do {									\

commit 6dae62020f0e6a2ffe424c8cea542fa49d42ec6e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Dec 14 13:06:16 2013 -0700

    PCI: pciehp: Make various functions void since they can't fail
    
    These functions:
    
      pcie_enable_notification()
      pciehp_power_off_slot()
      pciehp_get_power_status()
      pciehp_get_attention_status()
      pciehp_set_attention_status()
      pciehp_get_latch_status()
      pciehp_get_adapter_status()
      pcie_write_cmd()
    
    now always return success, so this patch makes them void and drops the
    error-checking code in their callers.
    
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 21e865ded1dc..ffe6a6b336cf 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -140,15 +140,15 @@ struct controller *pcie_init(struct pcie_device *dev);
 int pcie_init_notification(struct controller *ctrl);
 int pciehp_enable_slot(struct slot *p_slot);
 int pciehp_disable_slot(struct slot *p_slot);
-int pcie_enable_notification(struct controller *ctrl);
+void pcie_enable_notification(struct controller *ctrl);
 int pciehp_power_on_slot(struct slot *slot);
-int pciehp_power_off_slot(struct slot *slot);
-int pciehp_get_power_status(struct slot *slot, u8 *status);
-int pciehp_get_attention_status(struct slot *slot, u8 *status);
+void pciehp_power_off_slot(struct slot *slot);
+void pciehp_get_power_status(struct slot *slot, u8 *status);
+void pciehp_get_attention_status(struct slot *slot, u8 *status);
 
-int pciehp_set_attention_status(struct slot *slot, u8 status);
-int pciehp_get_latch_status(struct slot *slot, u8 *status);
-int pciehp_get_adapter_status(struct slot *slot, u8 *status);
+void pciehp_set_attention_status(struct slot *slot, u8 status);
+void pciehp_get_latch_status(struct slot *slot, u8 *status);
+void pciehp_get_adapter_status(struct slot *slot, u8 *status);
 int pciehp_query_power_fault(struct slot *slot);
 void pciehp_green_led_on(struct slot *slot);
 void pciehp_green_led_off(struct slot *slot);

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 21e865ded1dc..24e147cae667 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -163,8 +163,6 @@ static inline const char *slot_name(struct slot *slot)
 }
 
 #ifdef CONFIG_ACPI
-#include <acpi/acpi.h>
-#include <acpi/acpi_bus.h>
 #include <linux/pci-acpi.h>
 
 void __init pciehp_acpi_slot_detection_init(void);

commit f7625980f5820edd1a73536e1a03bcbc1f889fec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 14 11:28:18 2013 -0700

    PCI: Fix whitespace, capitalization, and spelling errors
    
    Fix whitespace, capitalization, and spelling errors.  No functional change.
    I know "busses" is not an error, but "buses" was more common, so I used it
    consistently.
    
    Signed-off-by: Marta Rybczynska <rybczynska@gmail.com> (pci_reset_bridge_secondary_bus())
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 541bbe6d5343..21e865ded1dc 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -180,5 +180,5 @@ static inline int pciehp_acpi_slot_detection_check(struct pci_dev *dev)
 {
 	return 0;
 }
-#endif 				/* CONFIG_ACPI */
+#endif				/* CONFIG_ACPI */
 #endif				/* _PCIEHP_H */

commit 2e35afaefe64946caaecfacaf7fb568e46185e88
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Aug 8 14:09:37 2013 -0600

    PCI: pciehp: Add reset_slot() method
    
    PCIe hotplug has a bus per slot, so we can just use a normal
    secondary bus reset.  However, if a slot supports surprise removal,
    a bus reset can be seen as a presence detection change triggering
    a hot-remove followed by a hot-add.  Disable presence detection from
    triggering an interrupt or being polled around the bus reset.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 7fb326983ed6..541bbe6d5343 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -155,6 +155,7 @@ void pciehp_green_led_off(struct slot *slot);
 void pciehp_green_led_blink(struct slot *slot);
 int pciehp_check_link_status(struct controller *ctrl);
 void pciehp_release_ctrl(struct controller *ctrl);
+int pciehp_reset_slot(struct slot *slot, int probe);
 
 static inline const char *slot_name(struct slot *slot)
 {

commit f39d5b72913e2a9ff00ba5ab145ee05a888b1286
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 12 12:02:59 2013 -0600

    PCI: Remove "extern" from function declarations
    
    We had an inconsistent mix of using and omitting the "extern" keyword
    on function declarations in header files.  This removes them all.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 2c113de94323..7fb326983ed6 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -127,15 +127,15 @@ struct controller {
 #define NO_CMD_CMPL(ctrl)	((ctrl)->slot_cap & PCI_EXP_SLTCAP_NCCS)
 #define PSN(ctrl)		((ctrl)->slot_cap >> 19)
 
-extern int pciehp_sysfs_enable_slot(struct slot *slot);
-extern int pciehp_sysfs_disable_slot(struct slot *slot);
-extern u8 pciehp_handle_attention_button(struct slot *p_slot);
-extern u8 pciehp_handle_switch_change(struct slot *p_slot);
-extern u8 pciehp_handle_presence_change(struct slot *p_slot);
-extern u8 pciehp_handle_power_fault(struct slot *p_slot);
-extern int pciehp_configure_device(struct slot *p_slot);
-extern int pciehp_unconfigure_device(struct slot *p_slot);
-extern void pciehp_queue_pushbutton_work(struct work_struct *work);
+int pciehp_sysfs_enable_slot(struct slot *slot);
+int pciehp_sysfs_disable_slot(struct slot *slot);
+u8 pciehp_handle_attention_button(struct slot *p_slot);
+u8 pciehp_handle_switch_change(struct slot *p_slot);
+u8 pciehp_handle_presence_change(struct slot *p_slot);
+u8 pciehp_handle_power_fault(struct slot *p_slot);
+int pciehp_configure_device(struct slot *p_slot);
+int pciehp_unconfigure_device(struct slot *p_slot);
+void pciehp_queue_pushbutton_work(struct work_struct *work);
 struct controller *pcie_init(struct pcie_device *dev);
 int pcie_init_notification(struct controller *ctrl);
 int pciehp_enable_slot(struct slot *p_slot);
@@ -166,8 +166,8 @@ static inline const char *slot_name(struct slot *slot)
 #include <acpi/acpi_bus.h>
 #include <linux/pci-acpi.h>
 
-extern void __init pciehp_acpi_slot_detection_init(void);
-extern int pciehp_acpi_slot_detection_check(struct pci_dev *dev);
+void __init pciehp_acpi_slot_detection_init(void);
+int pciehp_acpi_slot_detection_check(struct pci_dev *dev);
 
 static inline void pciehp_firmware_init(void)
 {

commit c2be6f93b383c873a4f9d521afa49b1b67d06085
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Fri Jan 11 10:15:54 2013 +0800

    PCI: pciehp: Use per-slot workqueues to avoid deadlock
    
    When we have a hotplug-capable PCIe port with a second hotplug-capable
    PCIe port below it, removing the device below the upstream port causes
    a deadlock.
    
    The deadlock happens because we use the pciehp_wq workqueue to run
    pciehp_power_thread(), which uses pciehp_disable_slot() to remove devices
    below the upstream port.  When we remove the downstream PCIe port, we call
    pciehp_remove(), the pciehp driver's .remove() method.  That calls
    flush_workqueue(pciehp_wq), which deadlocks because the
    pciehp_power_thread() work item is still running.
    
    This patch avoids the deadlock by creating a workqueue for every PCIe port
    and removing the single shared workqueue.
    
    Here's the call path that leads to the deadlock:
    
      pciehp_queue_pushbutton_work
        queue_work(pciehp_wq)                   # queue pciehp_power_thread
        ...
    
      pciehp_power_thread
        pciehp_disable_slot
          remove_board
            pciehp_unconfigure_device
              pci_stop_and_remove_bus_device
                ...
                  pciehp_remove                 # pciehp driver .remove method
                    pciehp_release_ctrl
                      pcie_cleanup_slot
                        flush_workqueue(pciehp_wq)
    
    This is fairly urgent because it can be caused by simply unplugging a
    Thunderbolt adapter, as reported by Daniel below.
    
    [bhelgaas: changelog]
    Reference: http://lkml.kernel.org/r/CAMVG2ssiRgcTD1bej2tkUUfsWmpL5eNtPcNif9va2-Gzb2u8nQ@mail.gmail.com
    Reported-and-tested-by: Daniel J Blueman <daniel@quora.org>
    Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 26ffd3e3fb74..2c113de94323 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -44,7 +44,6 @@ extern bool pciehp_poll_mode;
 extern int pciehp_poll_time;
 extern bool pciehp_debug;
 extern bool pciehp_force;
-extern struct workqueue_struct *pciehp_wq;
 
 #define dbg(format, arg...)						\
 do {									\
@@ -78,6 +77,7 @@ struct slot {
 	struct hotplug_slot *hotplug_slot;
 	struct delayed_work work;	/* work for button event */
 	struct mutex lock;
+	struct workqueue_struct *wq;
 };
 
 struct event_info {

commit e73cfecdfca900098f807f9523f45573a1155429
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Jul 11 15:08:16 2012 -0700

    PCI: pciehp: remove unused pciehp_get_max_lnk_width(), pciehp_get_cur_lnk_width()
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 4b7cce1de6ec..26ffd3e3fb74 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -149,10 +149,6 @@ int pciehp_get_attention_status(struct slot *slot, u8 *status);
 int pciehp_set_attention_status(struct slot *slot, u8 status);
 int pciehp_get_latch_status(struct slot *slot, u8 *status);
 int pciehp_get_adapter_status(struct slot *slot, u8 *status);
-int pciehp_get_max_link_speed(struct slot *slot, enum pci_bus_speed *speed);
-int pciehp_get_max_link_width(struct slot *slot, enum pcie_link_width *val);
-int pciehp_get_cur_link_speed(struct slot *slot, enum pci_bus_speed *speed);
-int pciehp_get_cur_link_width(struct slot *slot, enum pcie_link_width *val);
 int pciehp_query_power_fault(struct slot *slot);
 void pciehp_green_led_on(struct slot *slot);
 void pciehp_green_led_off(struct slot *slot);

commit 90ab5ee94171b3e28de6bb42ee30b527014e0be7
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Jan 13 09:32:20 2012 +1030

    module_param: make bool parameters really bool (drivers & misc)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 9a33fdde2d16..4b7cce1de6ec 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -40,10 +40,10 @@
 
 #define MY_NAME	"pciehp"
 
-extern int pciehp_poll_mode;
+extern bool pciehp_poll_mode;
 extern int pciehp_poll_time;
-extern int pciehp_debug;
-extern int pciehp_force;
+extern bool pciehp_debug;
+extern bool pciehp_force;
 extern struct workqueue_struct *pciehp_wq;
 
 #define dbg(format, arg...)						\

commit 486b10b9f43500741cd63a878d0ef23cd87fc66d
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Mon Nov 7 20:56:50 2011 +0900

    PCI: pciehp: Handle push button event asynchronously
    
    Use non-ordered workqueue for attention button events.
    
    Attention button events on each slot can be handled asynchronously. So
    we should use non-ordered workqueue. This patch also removes ordered
    workqueue in pciehp as a result.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 838f571027b7..9a33fdde2d16 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -45,7 +45,6 @@ extern int pciehp_poll_time;
 extern int pciehp_debug;
 extern int pciehp_force;
 extern struct workqueue_struct *pciehp_wq;
-extern struct workqueue_struct *pciehp_ordered_wq;
 
 #define dbg(format, arg...)						\
 do {									\

commit a827ea307b147aeb050803433b3f6842582c6ced
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Oct 18 08:31:02 2010 +0200

    pciehp: update workqueue usage
    
    * Rename pciehp_wq to pciehp_ordered_wq and add non-ordered pciehp_wq
      which is used instead of the system workqueue.  This is to remove
      the use of flush_scheduled_work() which is deprecated and scheduled
      for removal.
    
    * With cmwq in place, there's no point in creating workqueues lazily.
      Create both pciehp_wq and pciehp_ordered_wq upfront.
    
    * Include workqueue.h from pciehp.h.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 73d513989263..838f571027b7 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -36,6 +36,7 @@
 #include <linux/sched.h>		/* signal_pending() */
 #include <linux/pcieport_if.h>
 #include <linux/mutex.h>
+#include <linux/workqueue.h>
 
 #define MY_NAME	"pciehp"
 
@@ -44,6 +45,7 @@ extern int pciehp_poll_time;
 extern int pciehp_debug;
 extern int pciehp_force;
 extern struct workqueue_struct *pciehp_wq;
+extern struct workqueue_struct *pciehp_ordered_wq;
 
 #define dbg(format, arg...)						\
 do {									\

commit 6e63e80d88521a176989ed14b420f42dc418e46a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 25 21:33:29 2010 +0200

    PCI hotplug: Fix build with CONFIG_ACPI unset
    
    One of the recent changes caused complilation of
    drivers/pci/hotplug/pciehp_core.c to fail.  Fix this issue.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 653de6ff8ac6..73d513989263 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -178,5 +178,9 @@ static inline void pciehp_firmware_init(void)
 }
 #else
 #define pciehp_firmware_init()				do {} while (0)
+static inline int pciehp_acpi_slot_detection_check(struct pci_dev *dev)
+{
+	return 0;
+}
 #endif 				/* CONFIG_ACPI */
 #endif				/* _PCIEHP_H */

commit 28eb5f274a305bf3a13b2c80c4804d4515d05c64
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Aug 21 22:02:38 2010 +0200

    PCI: PCIe: Ask BIOS for control of all native services at once
    
    After commit 852972acff8f10f3a15679be2059bb94916cba5d (ACPI: Disable
    ASPM if the platform won't provide _OSC control for PCIe) control of
    the PCIe Capability Structure is unconditionally requested by
    acpi_pci_root_add(), which in principle may cause problems to
    happen in two ways.  First, the BIOS may refuse to give control of
    the PCIe Capability Structure if it is not asked for any of the
    _OSC features depending on it at the same time.  Second, the BIOS may
    assume that control of the _OSC features depending on the PCIe
    Capability Structure will be requested in the future and may behave
    incorrectly if that doesn't happen.  For this reason, control of
    the PCIe Capability Structure should always be requested along with
    control of any other _OSC features that may depend on it (ie. PCIe
    native PME, PCIe native hot-plug, PCIe AER).
    
    Rework the PCIe port driver so that (1) it checks which native PCIe
    port services can be enabled, according to the BIOS, and (2) it
    requests control of all these services simultaneously.  In
    particular, this causes pcie_portdrv_probe() to fail if the BIOS
    refuses to grant control of the PCIe Capability Structure, which
    means that no native PCIe port services can be enabled for the PCIe
    Root Complex the given port belongs to.  If that happens, ASPM is
    disabled to avoid problems with mishandling it by the part of the
    PCIe hierarchy for which control of the PCIe Capability Structure
    has not been received.
    
    Make it possible to override this behavior using 'pcie_ports=native'
    (use the PCIe native services regardless of the BIOS response to the
    control request), or 'pcie_ports=compat' (do not use the PCIe native
    services at all).
    
    Accordingly, rework the existing PCIe port service drivers so that
    they don't request control of the services directly.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 4ed76b47b6dc..653de6ff8ac6 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -176,19 +176,7 @@ static inline void pciehp_firmware_init(void)
 {
 	pciehp_acpi_slot_detection_init();
 }
-
-static inline int pciehp_get_hp_hw_control_from_firmware(struct pci_dev *dev)
-{
-	int retval;
-	u32 flags = (OSC_PCI_EXPRESS_NATIVE_HP_CONTROL |
-		     OSC_PCI_EXPRESS_CAP_STRUCTURE_CONTROL);
-	retval = acpi_get_hp_hw_control_from_firmware(dev, flags);
-	if (retval)
-		return retval;
-	return pciehp_acpi_slot_detection_check(dev);
-}
 #else
 #define pciehp_firmware_init()				do {} while (0)
-#define pciehp_get_hp_hw_control_from_firmware(dev) 	0
 #endif 				/* CONFIG_ACPI */
 #endif				/* _PCIEHP_H */

commit 1518c17ab736303098843bd306a0fc4f8f5faa42
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 11 14:34:52 2009 +0900

    pciehp: use pci_pcie_cap()
    
    Use pci_pcie_cap() instead of pci_find_capability() to get PCIe capability
    offset in pciehp driver. This avoids unnecessary search in PCI
    configuration space. This patch also removes 'cap_base' field in
    struct controller, that was used to hold PCIe capability offset by
    pciehp itself.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 3070f77eb56a..4ed76b47b6dc 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -91,7 +91,6 @@ struct controller {
 	struct slot *slot;
 	wait_queue_head_t queue;	/* sleep & wake process */
 	u32 slot_cap;
-	u8 cap_base;
 	struct timer_list poll_timer;
 	unsigned int cmd_busy:1;
 	unsigned int no_cmd_complete:1;

commit 656927b119a6f2fe0ed453191e13eec6fe041f4c
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Sep 15 17:34:05 2009 +0900

    PCI: pciehp: remove slot capabilities definitions
    
    Use generic PCIe slot capabilities register definitions instead of
    internal definitions.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 13be51dd401e..3070f77eb56a 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -117,24 +117,14 @@ struct controller {
 #define POWERON_STATE			3
 #define POWEROFF_STATE			4
 
-/* Field definitions in Slot Capabilities Register */
-#define ATTN_BUTTN_PRSN	0x00000001
-#define	PWR_CTRL_PRSN	0x00000002
-#define MRL_SENS_PRSN	0x00000004
-#define ATTN_LED_PRSN	0x00000008
-#define PWR_LED_PRSN	0x00000010
-#define HP_SUPR_RM_SUP	0x00000020
-#define EMI_PRSN	0x00020000
-#define NO_CMD_CMPL_SUP	0x00040000
-
-#define ATTN_BUTTN(ctrl)	((ctrl)->slot_cap & ATTN_BUTTN_PRSN)
-#define POWER_CTRL(ctrl)	((ctrl)->slot_cap & PWR_CTRL_PRSN)
-#define MRL_SENS(ctrl)		((ctrl)->slot_cap & MRL_SENS_PRSN)
-#define ATTN_LED(ctrl)		((ctrl)->slot_cap & ATTN_LED_PRSN)
-#define PWR_LED(ctrl)		((ctrl)->slot_cap & PWR_LED_PRSN)
-#define HP_SUPR_RM(ctrl)	((ctrl)->slot_cap & HP_SUPR_RM_SUP)
-#define EMI(ctrl)		((ctrl)->slot_cap & EMI_PRSN)
-#define NO_CMD_CMPL(ctrl)	((ctrl)->slot_cap & NO_CMD_CMPL_SUP)
+#define ATTN_BUTTN(ctrl)	((ctrl)->slot_cap & PCI_EXP_SLTCAP_ABP)
+#define POWER_CTRL(ctrl)	((ctrl)->slot_cap & PCI_EXP_SLTCAP_PCP)
+#define MRL_SENS(ctrl)		((ctrl)->slot_cap & PCI_EXP_SLTCAP_MRLSP)
+#define ATTN_LED(ctrl)		((ctrl)->slot_cap & PCI_EXP_SLTCAP_AIP)
+#define PWR_LED(ctrl)		((ctrl)->slot_cap & PCI_EXP_SLTCAP_PIP)
+#define HP_SUPR_RM(ctrl)	((ctrl)->slot_cap & PCI_EXP_SLTCAP_HPS)
+#define EMI(ctrl)		((ctrl)->slot_cap & PCI_EXP_SLTCAP_EIP)
+#define NO_CMD_CMPL(ctrl)	((ctrl)->slot_cap & PCI_EXP_SLTCAP_NCCS)
 #define PSN(ctrl)		((ctrl)->slot_cap >> 19)
 
 extern int pciehp_sysfs_enable_slot(struct slot *slot);

commit d9fb42a845f8e56d91017462650ba41e854f5552
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Sep 15 17:33:30 2009 +0900

    PCI: pciehp: remove error message definitions
    
    Remove (almost) unused error message definitions.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index b20a38da7a80..13be51dd401e 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -117,17 +117,6 @@ struct controller {
 #define POWERON_STATE			3
 #define POWEROFF_STATE			4
 
-/* Error messages */
-#define INTERLOCK_OPEN			0x00000002
-#define ADD_NOT_SUPPORTED		0x00000003
-#define CARD_FUNCTIONING		0x00000005
-#define ADAPTER_NOT_SAME		0x00000006
-#define NO_ADAPTER_PRESENT		0x00000009
-#define NOT_ENOUGH_RESOURCES		0x0000000B
-#define DEVICE_TYPE_NOT_SUPPORTED	0x0000000C
-#define WRONG_BUS_FREQUENCY		0x0000000D
-#define POWER_FAILURE			0x0000000E
-
 /* Field definitions in Slot Capabilities Register */
 #define ATTN_BUTTN_PRSN	0x00000001
 #define	PWR_CTRL_PRSN	0x00000002

commit 07a09694de556f307b1c5035cdf0f17c6243d1cd
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Sep 15 17:31:16 2009 +0900

    PCI: pciehp: remove number field
    
    Since slot_cap field in struct controller contains physical slot
    number informationq, we don't need number field in struct slot.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index b7054cb885cf..b20a38da7a80 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -73,7 +73,6 @@ do {									\
 #define SLOT_NAME_SIZE 10
 struct slot {
 	u8 state;
-	u32 number;
 	struct controller *ctrl;
 	struct hotplug_slot *hotplug_slot;
 	struct delayed_work work;	/* work for button event */

commit 82a9e79ef132cbf77de58aae35c1a14237f2fcde
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Sep 15 17:30:48 2009 +0900

    PCI: pciehp: remove hpc_ops
    
    The struct hpc_ops seems a set of hooks to controller specific
    routines. But, it is meaningless because no hotplug controller driver
    follows this framework.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index b23f8ca03d82..b7054cb885cf 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -75,7 +75,6 @@ struct slot {
 	u8 state;
 	u32 number;
 	struct controller *ctrl;
-	struct hpc_ops *hpc_ops;
 	struct hotplug_slot *hotplug_slot;
 	struct delayed_work work;	/* work for button event */
 	struct mutex lock;
@@ -91,7 +90,6 @@ struct controller {
 	struct mutex ctrl_lock;		/* controller lock */
 	struct pcie_device *pcie;	/* PCI Express port service */
 	struct slot *slot;
-	struct hpc_ops *hpc_ops;
 	wait_queue_head_t queue;	/* sleep & wake process */
 	u32 slot_cap;
 	u8 cap_base;
@@ -154,7 +152,7 @@ struct controller {
 extern int pciehp_sysfs_enable_slot(struct slot *slot);
 extern int pciehp_sysfs_disable_slot(struct slot *slot);
 extern u8 pciehp_handle_attention_button(struct slot *p_slot);
-  extern u8 pciehp_handle_switch_change(struct slot *p_slot);
+extern u8 pciehp_handle_switch_change(struct slot *p_slot);
 extern u8 pciehp_handle_presence_change(struct slot *p_slot);
 extern u8 pciehp_handle_power_fault(struct slot *p_slot);
 extern int pciehp_configure_device(struct slot *p_slot);
@@ -165,32 +163,30 @@ int pcie_init_notification(struct controller *ctrl);
 int pciehp_enable_slot(struct slot *p_slot);
 int pciehp_disable_slot(struct slot *p_slot);
 int pcie_enable_notification(struct controller *ctrl);
+int pciehp_power_on_slot(struct slot *slot);
+int pciehp_power_off_slot(struct slot *slot);
+int pciehp_get_power_status(struct slot *slot, u8 *status);
+int pciehp_get_attention_status(struct slot *slot, u8 *status);
+
+int pciehp_set_attention_status(struct slot *slot, u8 status);
+int pciehp_get_latch_status(struct slot *slot, u8 *status);
+int pciehp_get_adapter_status(struct slot *slot, u8 *status);
+int pciehp_get_max_link_speed(struct slot *slot, enum pci_bus_speed *speed);
+int pciehp_get_max_link_width(struct slot *slot, enum pcie_link_width *val);
+int pciehp_get_cur_link_speed(struct slot *slot, enum pci_bus_speed *speed);
+int pciehp_get_cur_link_width(struct slot *slot, enum pcie_link_width *val);
+int pciehp_query_power_fault(struct slot *slot);
+void pciehp_green_led_on(struct slot *slot);
+void pciehp_green_led_off(struct slot *slot);
+void pciehp_green_led_blink(struct slot *slot);
+int pciehp_check_link_status(struct controller *ctrl);
+void pciehp_release_ctrl(struct controller *ctrl);
 
 static inline const char *slot_name(struct slot *slot)
 {
 	return hotplug_slot_name(slot->hotplug_slot);
 }
 
-struct hpc_ops {
-	int (*power_on_slot)(struct slot *slot);
-	int (*power_off_slot)(struct slot *slot);
-	int (*get_power_status)(struct slot *slot, u8 *status);
-	int (*get_attention_status)(struct slot *slot, u8 *status);
-	int (*set_attention_status)(struct slot *slot, u8 status);
-	int (*get_latch_status)(struct slot *slot, u8 *status);
-	int (*get_adapter_status)(struct slot *slot, u8 *status);
-	int (*get_max_bus_speed)(struct slot *slot, enum pci_bus_speed *speed);
-	int (*get_cur_bus_speed)(struct slot *slot, enum pci_bus_speed *speed);
-	int (*get_max_lnk_width)(struct slot *slot, enum pcie_link_width *val);
-	int (*get_cur_lnk_width)(struct slot *slot, enum pcie_link_width *val);
-	int (*query_power_fault)(struct slot *slot);
-	void (*green_led_on)(struct slot *slot);
-	void (*green_led_off)(struct slot *slot);
-	void (*green_led_blink)(struct slot *slot);
-	void (*release_ctlr)(struct controller *ctrl);
-	int (*check_lnk_status)(struct controller *ctrl);
-};
-
 #ifdef CONFIG_ACPI
 #include <acpi/acpi.h>
 #include <acpi/acpi_bus.h>

commit 385e24917ed8eeba25dddd8e63bf3fe3d53eafc5
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Sep 15 17:30:14 2009 +0900

    PCI: pciehp: remove pci_dev field
    
    Since we have a pointer to pcie_device in struct controller, we don't
    need a pointer to pci_dev.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 720844e0389d..b23f8ca03d82 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -89,7 +89,6 @@ struct event_info {
 
 struct controller {
 	struct mutex ctrl_lock;		/* controller lock */
-	struct pci_dev *pci_dev;
 	struct pcie_device *pcie;	/* PCI Express port service */
 	struct slot *slot;
 	struct hpc_ops *hpc_ops;

commit 6aaa6d06f57f3689afe27c1fad256c5d6aa9b271
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Sep 15 17:29:49 2009 +0900

    PCI: pciehp: remove crit_sect mutex
    
    The crit_sect mutex defined in struct controller is to serialize
    hot-plug operations against multiple slots under the same bus. But,
    since PCIe doesnstream port has only one slot at most, it is
    meaningless and we don't need it.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 2509984d9611..720844e0389d 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -88,7 +88,6 @@ struct event_info {
 };
 
 struct controller {
-	struct mutex crit_sect;		/* critical section mutex */
 	struct mutex ctrl_lock;		/* controller lock */
 	struct pci_dev *pci_dev;
 	struct pcie_device *pcie;	/* PCI Express port service */

commit 5f9cab7af6f7ef1e3cbb25217617eb5bd082aa7b
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Sep 15 17:29:21 2009 +0900

    PCI: pciehp: remove slot_bus field
    
    Remove unused slot_bus field in struct controller.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 0159960dbadc..2509984d9611 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -95,7 +95,6 @@ struct controller {
 	struct slot *slot;
 	struct hpc_ops *hpc_ops;
 	wait_queue_head_t queue;	/* sleep & wake process */
-	u8 slot_bus;		/* Bus where the slots handled by this controller sit */
 	u32 slot_cap;
 	u8 cap_base;
 	struct timer_list poll_timer;

commit d54798f034b247b9d95a31cd755a4236655ca502
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Sep 15 17:28:53 2009 +0900

    PCI: pciehp: remove first_slot field
    
    The slot number can be calculated only by physical slot number field
    in the slot capabilities register. So the first_slot field in struct
    controller is meaningless and we don't need it.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 979212d5d755..0159960dbadc 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -95,7 +95,6 @@ struct controller {
 	struct slot *slot;
 	struct hpc_ops *hpc_ops;
 	wait_queue_head_t queue;	/* sleep & wake process */
-	u32 first_slot;		/* First physical slot number */  /* PCIE only has 1 slot */
 	u8 slot_bus;		/* Bus where the slots handled by this controller sit */
 	u32 slot_cap;
 	u8 cap_base;
@@ -153,6 +152,7 @@ struct controller {
 #define HP_SUPR_RM(ctrl)	((ctrl)->slot_cap & HP_SUPR_RM_SUP)
 #define EMI(ctrl)		((ctrl)->slot_cap & EMI_PRSN)
 #define NO_CMD_CMPL(ctrl)	((ctrl)->slot_cap & NO_CMD_CMPL_SUP)
+#define PSN(ctrl)		((ctrl)->slot_cap >> 19)
 
 extern int pciehp_sysfs_enable_slot(struct slot *slot);
 extern int pciehp_sysfs_disable_slot(struct slot *slot);

commit a2359a334fb2c89347e031c4494282e6756e9ae7
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Sep 15 17:28:28 2009 +0900

    PCI: pciehp: remove slot_device_offset field
    
    Since the device number of the hot-slot under the PCIe downstream port
    is always 0, the slot_device_offset field in the slot is meaningless
    and we don't need it.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 382c939ef7ae..979212d5d755 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -95,7 +95,6 @@ struct controller {
 	struct slot *slot;
 	struct hpc_ops *hpc_ops;
 	wait_queue_head_t queue;	/* sleep & wake process */
-	u8 slot_device_offset;
 	u32 first_slot;		/* First physical slot number */  /* PCIE only has 1 slot */
 	u8 slot_bus;		/* Bus where the slots handled by this controller sit */
 	u32 slot_cap;

commit 0e3631593c38e8a09bf58a46c6f6a3426d3ad0f0
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Sep 15 17:27:24 2009 +0900

    PCI: pciehp: remove hp_slot field
    
    The hp_slot field is to identify the slot under the same
    controller. But, since PCIe downstream port has only one slot at most,
    it is meaningless and we don't need it.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index d69a96cd9681..382c939ef7ae 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -73,7 +73,6 @@ do {									\
 #define SLOT_NAME_SIZE 10
 struct slot {
 	u8 state;
-	u8 hp_slot;
 	u32 number;
 	struct controller *ctrl;
 	struct hpc_ops *hpc_ops;

commit d689f7eb364a51ccd857605dede0d6c22a1aad91
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Sep 15 17:26:56 2009 +0900

    PCI: pciehp: remove device field
    
    The device field in the struct slot is not necessary because it is
    always 0 in pciehp driver.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 44df330c1488..d69a96cd9681 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -72,7 +72,6 @@ do {									\
 
 #define SLOT_NAME_SIZE 10
 struct slot {
-	u8 device;
 	u8 state;
 	u8 hp_slot;
 	u32 number;

commit ab9c6c86701b498445334db746aa2e8dc473c7b6
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Sep 15 17:26:32 2009 +0900

    PCI: pciehp: remove bus field
    
    The bus field in struct slot is not necessary.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index cfd2f59b6100..44df330c1488 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -72,7 +72,6 @@ do {									\
 
 #define SLOT_NAME_SIZE 10
 struct slot {
-	u8 bus;
 	u8 device;
 	u8 state;
 	u8 hp_slot;

commit 6a11c135f3511743d09474ccaac2137d34c352a8
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Sep 15 17:25:54 2009 +0900

    PCI: pciehp: remove slot_num_inc field
    
    The slot_num_inc field in struct controller is unused and meaningless
    in pciehp driver.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 0282bae81eb1..cfd2f59b6100 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -93,7 +93,6 @@ struct event_info {
 struct controller {
 	struct mutex crit_sect;		/* critical section mutex */
 	struct mutex ctrl_lock;		/* controller lock */
-	int slot_num_inc;		/* 1 or -1 */
 	struct pci_dev *pci_dev;
 	struct pcie_device *pcie;	/* PCI Express port service */
 	struct slot *slot;

commit e23727da77109ef856f7a76c1a7d2e2282f600f5
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Sep 15 17:25:17 2009 +0900

    PCI: pciehp: remove num_slots field
    
    Since PCIe downstream port has only one slot at most, we don't need
    num_slots field in struct controller. Note that struct controller
    itself doesn't exist if PCIe downstream port has no slot.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index af397b1291ea..0282bae81eb1 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -93,7 +93,6 @@ struct event_info {
 struct controller {
 	struct mutex crit_sect;		/* critical section mutex */
 	struct mutex ctrl_lock;		/* controller lock */
-	int num_slots;			/* Number of slots on ctlr */
 	int slot_num_inc;		/* 1 or -1 */
 	struct pci_dev *pci_dev;
 	struct pcie_device *pcie;	/* PCI Express port service */

commit 8720d27dabf580278a7719fa8b5783d9878e2d42
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Sep 15 17:24:46 2009 +0900

    PCI: pciehp: remove slot_list field
    
    Since PCIe downstream port has only one slot at most, we don't need
    'slot_list' linked list to manage multiple slots under the port.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 36faa9a8e18f..af397b1291ea 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -80,7 +80,6 @@ struct slot {
 	struct controller *ctrl;
 	struct hpc_ops *hpc_ops;
 	struct hotplug_slot *hotplug_slot;
-	struct list_head	slot_list;
 	struct delayed_work work;	/* work for button event */
 	struct mutex lock;
 };
@@ -98,7 +97,7 @@ struct controller {
 	int slot_num_inc;		/* 1 or -1 */
 	struct pci_dev *pci_dev;
 	struct pcie_device *pcie;	/* PCI Express port service */
-	struct list_head slot_list;
+	struct slot *slot;
 	struct hpc_ops *hpc_ops;
 	wait_queue_head_t queue;	/* sleep & wake process */
 	u8 slot_device_offset;
@@ -181,19 +180,6 @@ static inline const char *slot_name(struct slot *slot)
 	return hotplug_slot_name(slot->hotplug_slot);
 }
 
-static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)
-{
-	struct slot *slot;
-
-	list_for_each_entry(slot, &ctrl->slot_list, slot_list) {
-		if (slot->device == device)
-			return slot;
-	}
-
-	ctrl_err(ctrl, "Slot (device=0x%02x) not found\n", device);
-	return NULL;
-}
-
 struct hpc_ops {
 	int (*power_on_slot)(struct slot *slot);
 	int (*power_off_slot)(struct slot *slot);

commit d569c74d78ffcde2f163256e4da934ec3bacff0e
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 14 16:35:25 2009 -0600

    PCI hotplug: pciehp: use generic pci_configure_slot()
    
    Use the generic pci_configure_slot() rather than the PCIe-specific
    program_fw_provided_values().
    
    Unlike the previous pciehp-specific code, we now walk through subordinate
    devices even if there are no settings for the parent.  This should be
    harmless because we won't change anything unless we discover firmware
    settings farther down.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Acked-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 86cdfd71ed27..36faa9a8e18f 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -237,15 +237,8 @@ static inline int pciehp_get_hp_hw_control_from_firmware(struct pci_dev *dev)
 		return retval;
 	return pciehp_acpi_slot_detection_check(dev);
 }
-
-static inline int pciehp_get_hp_params_from_firmware(struct pci_dev *dev,
-			struct hotplug_params *hpp)
-{
-	return acpi_get_hp_params_from_firmware(dev, hpp);
-}
 #else
 #define pciehp_firmware_init()				do {} while (0)
 #define pciehp_get_hp_hw_control_from_firmware(dev) 	0
-#define pciehp_get_hp_params_from_firmware(dev, hpp)    (-ENODEV)
 #endif 				/* CONFIG_ACPI */
 #endif				/* _PCIEHP_H */

commit 6a29172ba90e49c046245610caff9848307bfd6a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Sep 14 16:35:15 2009 -0600

    PCI hotplug: clean up acpi_get_hp_params_from_firmware() interface
    
    This patch makes acpi_get_hp_params_from_firmware() take a
    pci_dev rather than a pci_bus and makes it return a standard
    int errno rather than acpi_status.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Acked-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index e6cf096498be..86cdfd71ed27 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -241,9 +241,7 @@ static inline int pciehp_get_hp_hw_control_from_firmware(struct pci_dev *dev)
 static inline int pciehp_get_hp_params_from_firmware(struct pci_dev *dev,
 			struct hotplug_params *hpp)
 {
-	if (ACPI_FAILURE(acpi_get_hp_params_from_firmware(dev->bus, hpp)))
-		return -ENODEV;
-	return 0;
+	return acpi_get_hp_params_from_firmware(dev, hpp);
 }
 #else
 #define pciehp_firmware_init()				do {} while (0)

commit bd3d99c17039fd05a29587db3f4a180c48da115a
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Jun 2 13:52:26 2009 +0900

    PCI: Remove untested Electromechanical Interlock (EMI) support in pciehp.
    
    The EMI support in pciehp is obviously broken. It is implemented using
    struct hotplug_slot_attribute, but sysfs_ops for pci_slot_ktype is NOT
    for struct hotplug_slot_attribute, but for struct pci_slot_attribute.
    This bug had been there for a long time, maybe it was introduced when
    PCI slot framework was introduced. The reason why this bug didn't
    cause any problem is maybe the EMI support is not tested at all
    because of lack of test environment.
    
    As described above, the EMI support in pciehp seems not to be tested
    at all. So this patch removes EMI support from pciehp, instead of
    fixing the bug.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 0a368547e633..e6cf096498be 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -81,7 +81,6 @@ struct slot {
 	struct hpc_ops *hpc_ops;
 	struct hotplug_slot *hotplug_slot;
 	struct list_head	slot_list;
-	unsigned long last_emi_toggle;
 	struct delayed_work work;	/* work for button event */
 	struct mutex lock;
 };
@@ -203,8 +202,6 @@ struct hpc_ops {
 	int (*set_attention_status)(struct slot *slot, u8 status);
 	int (*get_latch_status)(struct slot *slot, u8 *status);
 	int (*get_adapter_status)(struct slot *slot, u8 *status);
-	int (*get_emi_status)(struct slot *slot, u8 *status);
-	int (*toggle_emi)(struct slot *slot);
 	int (*get_max_bus_speed)(struct slot *slot, enum pci_bus_speed *speed);
 	int (*get_cur_bus_speed)(struct slot *slot, enum pci_bus_speed *speed);
 	int (*get_max_lnk_width)(struct slot *slot, enum pcie_link_width *val);

commit 6a82e21823058eea95325005b79f3b8c9492460f
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Feb 3 15:06:18 2009 +0900

    PCI: pciehp: make cmd_busy flag one bit
    
    The cmd_busy field in struct controller takes only two values 0 or
    1. So it should be one bit.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 2bf8d28062e8..0a368547e633 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -108,7 +108,7 @@ struct controller {
 	u32 slot_cap;
 	u8 cap_base;
 	struct timer_list poll_timer;
-	int cmd_busy;
+	unsigned int cmd_busy:1;
 	unsigned int no_cmd_complete:1;
 	unsigned int link_active_reporting:1;
 	unsigned int notification_enabled:1;

commit 99f0169c17f334a11b0ace91188501c612f3e1e6
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Feb 3 15:06:16 2009 +0900

    PCI: pciehp: enable software notification on empty slots
    
    Current pciehp disables software notification of adapter presence
    changed event and MRL changed event when slot is turned off. Because
    of this, there is no way to detect those events on empty slots in the
    current pciehp implementation.
    
    According to the past discussion(*), this behavior was introduced to
    prevent endless loop that could happen if pcie_isr() runs after power
    fault is detected on a certain platform whose stickey power-fault bit
    remains on till the slot is powered on again.
    
    (*) http://sourceforge.net/mailarchive/message.php?msg_id=20051130135409.A14918%40unix-os.sc.intel.com
    
    I think this endless loop can be avoided using one bit flag that
    indicates power fault had been detected, instead of disabling software
    notification of adapter present changed event and MRL changed event.
    
    With this patch, we can enable software notification mechanism of
    presence changed and MRL changed event on the empty slots again.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 1f887f64e493..2bf8d28062e8 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -112,6 +112,7 @@ struct controller {
 	unsigned int no_cmd_complete:1;
 	unsigned int link_active_reporting:1;
 	unsigned int notification_enabled:1;
+	unsigned int power_fault_detected;
 };
 
 #define INT_BUTTON_IGNORE		0

commit 1c35b8e538cb6259accb215099cdb673310cad84
Author: Frank Seidel <frank@f-seidel.de>
Date:   Fri Feb 6 10:23:36 2009 +0100

    PCI: add missing KERN_* constants to printks
    
    According to kerneljanitors todo list all printk calls (beginning
    a new line) should have an according KERN_* constant.
    Those are the missing pieces here for the pci subsystem.
    
    Signed-off-by: Frank Seidel <frank@f-seidel.de>
    Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Tested-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 39ae37589fda..1f887f64e493 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -46,10 +46,10 @@ extern int pciehp_force;
 extern struct workqueue_struct *pciehp_wq;
 
 #define dbg(format, arg...)						\
-	do {								\
-		if (pciehp_debug)					\
-			printk("%s: " format, MY_NAME , ## arg);	\
-	} while (0)
+do {									\
+	if (pciehp_debug)						\
+		printk(KERN_DEBUG "%s: " format, MY_NAME , ## arg);	\
+} while (0)
 #define err(format, arg...)						\
 	printk(KERN_ERR "%s: " format, MY_NAME , ## arg)
 #define info(format, arg...)						\
@@ -60,7 +60,7 @@ extern struct workqueue_struct *pciehp_wq;
 #define ctrl_dbg(ctrl, format, arg...)					\
 	do {								\
 		if (pciehp_debug)					\
-			dev_printk(, &ctrl->pcie->device,		\
+			dev_printk(KERN_DEBUG, &ctrl->pcie->device,	\
 					format, ## arg);		\
 	} while (0)
 #define ctrl_err(ctrl, format, arg...)					\

commit dbc7e1e567ef8cfc4b792ef6acb51d4ceb15746a
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Jan 28 19:31:18 2009 -0800

    PCI: pciehp: Handle interrupts that happen during initialization.
    
    Move the enabling of interrupts after all of the data structures
    are setup so that we can safely run the interrupt handler as
    soon as it is registered.
    
    Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Tested-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Eric W. Biederman <ebiederm@aristanetworks.com>
    Signed-off-by: Jesse Barnes <jbarnes@hobbes.lan>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index db85284ffb62..39ae37589fda 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -111,6 +111,7 @@ struct controller {
 	int cmd_busy;
 	unsigned int no_cmd_complete:1;
 	unsigned int link_active_reporting:1;
+	unsigned int notification_enabled:1;
 };
 
 #define INT_BUTTON_IGNORE		0
@@ -170,6 +171,7 @@ extern int pciehp_configure_device(struct slot *p_slot);
 extern int pciehp_unconfigure_device(struct slot *p_slot);
 extern void pciehp_queue_pushbutton_work(struct work_struct *work);
 struct controller *pcie_init(struct pcie_device *dev);
+int pcie_init_notification(struct controller *ctrl);
 int pciehp_enable_slot(struct slot *p_slot);
 int pciehp_disable_slot(struct slot *p_slot);
 int pcie_enable_notification(struct controller *ctrl);

commit b2576e1d4408e134e2188c967b1f28af39cd79d4
Merge: 3cc8a5f4ba91 2150edc6c5cf
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 03:39:43 2009 -0500

    Merge branch 'linus' into release

commit c9ffa5a586a97da4d552f89b8f39eea79a63a612
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Dec 17 12:07:38 2008 +0900

    PCI: pciehp: add ACPI based slot detection
    
    There is a problem that some non hot-pluggable PCIe slots are detected
    as hot-pluggable by pciehp on some platforms. The immediate cause of
    this problem is that hot-plug capable bit in the Slot Capabilities
    register is set even for non hot-pluggable slots on those platforms.
    It seems a BIOS/hardware problem, but we need workaround about that.
    
    Some of those platforms define hot-pluggable PCIe slots on ACPI
    namespace properly, while hot-plug capable bit in the Slot
    Capabilities register is set improperly. So using ACPI namespace
    information in pciehp to detect PCIe hot-pluggable slots would be a
    workaround.
    
    This patch adds 'pciehp_detect_mode' module option. When 'acpi' is
    specified, pciehp uses ACPI namespace information to detect PCIe
    hot-pluggable slots.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index b2801a7ee37f..27fd18f019f8 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -220,11 +220,23 @@ struct hpc_ops {
 #include <acpi/actypes.h>
 #include <linux/pci-acpi.h>
 
+extern void __init pciehp_acpi_slot_detection_init(void);
+extern int pciehp_acpi_slot_detection_check(struct pci_dev *dev);
+
+static inline void pciehp_firmware_init(void)
+{
+	pciehp_acpi_slot_detection_init();
+}
+
 static inline int pciehp_get_hp_hw_control_from_firmware(struct pci_dev *dev)
 {
+	int retval;
 	u32 flags = (OSC_PCI_EXPRESS_NATIVE_HP_CONTROL |
 		     OSC_PCI_EXPRESS_CAP_STRUCTURE_CONTROL);
-	return acpi_get_hp_hw_control_from_firmware(dev, flags);
+	retval = acpi_get_hp_hw_control_from_firmware(dev, flags);
+	if (retval)
+		return retval;
+	return pciehp_acpi_slot_detection_check(dev);
 }
 
 static inline int pciehp_get_hp_params_from_firmware(struct pci_dev *dev,
@@ -235,6 +247,7 @@ static inline int pciehp_get_hp_params_from_firmware(struct pci_dev *dev,
 	return 0;
 }
 #else
+#define pciehp_firmware_init()				do {} while (0)
 #define pciehp_get_hp_hw_control_from_firmware(dev) 	0
 #define pciehp_get_hp_params_from_firmware(dev, hpp)    (-ENODEV)
 #endif 				/* CONFIG_ACPI */

commit ea7e96e0f2277107d9ea14c3f16c86ba82b2e560
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Tue Dec 16 16:28:17 2008 +0800

    ACPI: remove private acpica headers from driver files
    
    External driver files should not include any private acpica headers.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index b2801a7ee37f..7072952ea1d2 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -217,7 +217,6 @@ struct hpc_ops {
 #ifdef CONFIG_ACPI
 #include <acpi/acpi.h>
 #include <acpi/acpi_bus.h>
-#include <acpi/actypes.h>
 #include <linux/pci-acpi.h>
 
 static inline int pciehp_get_hp_hw_control_from_firmware(struct pci_dev *dev)

commit 18b341b76cd99ce949806ccf5565900465ec2e7f
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Thu Oct 23 11:47:32 2008 +0900

    PCI hotplug: pciehp: message refinement
    
    This patch refines messages in pciehp module.  The main changes are as
    follows:
    
     - remove the trailing "."
     - remove __func__ as much as possible
     - capitalize the first letter of messages
     - show PCI device address including its domain
    
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index a4817a841fae..b2801a7ee37f 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -188,7 +188,7 @@ static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)
 			return slot;
 	}
 
-	ctrl_err(ctrl, "%s: slot (device=0x%x) not found\n", __func__, device);
+	ctrl_err(ctrl, "Slot (device=0x%02x) not found\n", device);
 	return NULL;
 }
 

commit f18e9625e02bb3e5ba9e81104f14e9d904ab28c4
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Oct 22 14:31:44 2008 +0900

    PCI hotplug: pciehp: poll data link layer link active
    
    This patch adds polling mechanism for Data Link Layer Link Active bit
    after turning power on, instead of waiting for 1000 msec. This reduces
    reduce the unnecessary long wait.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 394f99852e6d..a4817a841fae 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -110,6 +110,7 @@ struct controller {
 	struct timer_list poll_timer;
 	int cmd_busy;
 	unsigned int no_cmd_complete:1;
+	unsigned int link_active_reporting:1;
 };
 
 #define INT_BUTTON_IGNORE		0

commit e1acb24f059defdaa0264e925f19cc21b0a3e592
Author: Alex Chiang <achiang@hp.com>
Date:   Mon Oct 20 17:41:38 2008 -0600

    PCI: pciehp: remove 'name' parameter
    
    We do not need to manage our own name parameter, especially since
    the PCI core can change it on our behalf, in the case of duplicate
    slot names.
    
    Remove 'name' from pciehp's version of struct slot, and remove
    unused 'task_list' as well.
    
    Cc: kristen.c.accardi@intel.com
    Acked-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index c367978bd7fe..394f99852e6d 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -74,15 +74,13 @@ extern struct workqueue_struct *pciehp_wq;
 struct slot {
 	u8 bus;
 	u8 device;
-	u32 number;
 	u8 state;
-	struct timer_list task_event;
 	u8 hp_slot;
+	u32 number;
 	struct controller *ctrl;
 	struct hpc_ops *hpc_ops;
 	struct hotplug_slot *hotplug_slot;
 	struct list_head	slot_list;
-	char name[SLOT_NAME_SIZE];
 	unsigned long last_emi_toggle;
 	struct delayed_work work;	/* work for button event */
 	struct mutex lock;
@@ -175,6 +173,11 @@ int pciehp_enable_slot(struct slot *p_slot);
 int pciehp_disable_slot(struct slot *p_slot);
 int pcie_enable_notification(struct controller *ctrl);
 
+static inline const char *slot_name(struct slot *slot)
+{
+	return hotplug_slot_name(slot->hotplug_slot);
+}
+
 static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)
 {
 	struct slot *slot;

commit 7f2feec140f1f1e4f701e013a2bf8284a9ec2a3c
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Fri Sep 5 12:11:26 2008 +0900

    PCI: pciehp: replace printk with dev_printk
    
    This patch replaces printks within pciehp module with dev_printks.
    
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 217427a0ead9..c367978bd7fe 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -57,6 +57,19 @@ extern struct workqueue_struct *pciehp_wq;
 #define warn(format, arg...)						\
 	printk(KERN_WARNING "%s: " format, MY_NAME , ## arg)
 
+#define ctrl_dbg(ctrl, format, arg...)					\
+	do {								\
+		if (pciehp_debug)					\
+			dev_printk(, &ctrl->pcie->device,		\
+					format, ## arg);		\
+	} while (0)
+#define ctrl_err(ctrl, format, arg...)					\
+	dev_err(&ctrl->pcie->device, format, ## arg)
+#define ctrl_info(ctrl, format, arg...)					\
+	dev_info(&ctrl->pcie->device, format, ## arg)
+#define ctrl_warn(ctrl, format, arg...)					\
+	dev_warn(&ctrl->pcie->device, format, ## arg)
+
 #define SLOT_NAME_SIZE 10
 struct slot {
 	u8 bus;
@@ -171,7 +184,7 @@ static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)
 			return slot;
 	}
 
-	err("%s: slot (device=0x%x) not found\n", __func__, device);
+	ctrl_err(ctrl, "%s: slot (device=0x%x) not found\n", __func__, device);
 	return NULL;
 }
 

commit f7a10e32a1a7ae240fa3925c5727d224eba3e31d
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Fri Aug 22 17:16:48 2008 +0900

    PCI: pciehp: fix irq initialization
    
    Current pciehp driver gets irq number from pci_dev->irq. But because
    pciehp driver is a pci express port service driver, it should get irq
    number from pcie_device->irq.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 9e6cec67e1cc..217427a0ead9 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -87,6 +87,7 @@ struct controller {
 	int num_slots;			/* Number of slots on ctlr */
 	int slot_num_inc;		/* 1 or -1 */
 	struct pci_dev *pci_dev;
+	struct pcie_device *pcie;	/* PCI Express port service */
 	struct list_head slot_list;
 	struct hpc_ops *hpc_ops;
 	wait_queue_head_t queue;	/* sleep & wake process */

commit 167e782e301188c7c7e31e486bbeea5f918324c1
Author: Alex Chiang <achiang@hp.com>
Date:   Thu Aug 21 15:13:29 2008 -0600

    PCI: pciehp: Rename duplicate slot name N as N-1, N-2, N-M...
    
    Commit 3800345f723fd130d50434d4717b99d4a9f383c8 (pciehp: fix slot name)
    introduces the pciehp_slot_with_bus module parameter, which was intended
    to help work around broken firmware that assigns the same name to multiple
    slots.
    
    Commit 9e4f2e8d4ddb04ad16a3828cd9a369a5a5287009 (pciehp: add message about
    pciehp_slot_with_bus option) tells the user to use the above parameter
    in the event of a name collision.
    
    This approach is sub-optimal because it requires too much work from
    the user.
    
    Instead, let's rename the slot on behalf of the user. If firmware
    assigns the name N to multiple slots, then:
    
            The first registered slot is assigned N
            The second registered slot is assigned N-1
            The third registered slot is assigned N-2
            The Mth registered slot becomes N-M
    
    In the event we overflow the slot->name parameter, we report an
    error to the user.
    
    This is a temporary fix until the entire PCI core can be reworked
    such that individual drivers no longer have to manage their own
    slot names.
    
    Tested-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Acked-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index e3a1e7e7dba2..9e6cec67e1cc 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -43,7 +43,6 @@ extern int pciehp_poll_mode;
 extern int pciehp_poll_time;
 extern int pciehp_debug;
 extern int pciehp_force;
-extern int pciehp_slot_with_bus;
 extern struct workqueue_struct *pciehp_wq;
 
 #define dbg(format, arg...)						\

commit 9fce1bc956c21dfe0f46be028f18c4d5057f2bd7
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Wed Jul 16 22:54:30 2008 +0800

    PCI: remove unnecessary volatile in PCIe hotplug struct controller
    
    Proper memory barriers have been added to order accesses
    to ->cmd_busy, so volatile declaration for cmd_busy can
    be removed.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index d17233ae06f5..e3a1e7e7dba2 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -97,7 +97,7 @@ struct controller {
 	u32 slot_cap;
 	u8 cap_base;
 	struct timer_list poll_timer;
-	volatile int cmd_busy;
+	int cmd_busy;
 	unsigned int no_cmd_complete:1;
 };
 

commit c4635eb06af700820d658a163f06aff12e17cfb2
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Fri Jun 20 12:07:08 2008 +0900

    pciehp: fix interrupt initialization
    
    Current pciehp driver's intialization sequence is as follows:
    
    (1) initialize controller data structure
    (2) install interrupt handler
    (3) enable software notification
    (4) initialize controller specific slot data structure
    (5) initialize generic slot data structure and register it to pci hotplug core
    
    The interrupt handler of pciehp assumes that controller specific slot
    data structure is already initialized. However, it is installed at (2)
    before initializing controller specific slot data structure at
    (4). Because of this, pciehp driver cannot handle the following cases
    properly.
    
    - If devices that shares IRQ with pciehp raise interrupts between (2) and (4).
    - If hotplug events (e.g. MRL open) happen between (3) and (4).
    
    We already have a workaround for this problem ("pciehp: fix NULL
    dereference in interrupt handler: dbd79aed1aea2bece0bf43cc2ff3b2f9baf48a08).
    But we still need fundamental fix.
    
    This patch fix the problem by changing the initilization sequence as follows:
    
    (1) initialize controller data structure
    (2) initialize controller specific slot data structure
    (3) install interrupt handler
    (4) enable software notification
    (5) initialize generic slot data structure and register it to pci hotplug core
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 8492fab800cc..d17233ae06f5 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -43,6 +43,7 @@ extern int pciehp_poll_mode;
 extern int pciehp_poll_time;
 extern int pciehp_debug;
 extern int pciehp_force;
+extern int pciehp_slot_with_bus;
 extern struct workqueue_struct *pciehp_wq;
 
 #define dbg(format, arg...)						\
@@ -156,10 +157,10 @@ extern u8 pciehp_handle_power_fault(struct slot *p_slot);
 extern int pciehp_configure_device(struct slot *p_slot);
 extern int pciehp_unconfigure_device(struct slot *p_slot);
 extern void pciehp_queue_pushbutton_work(struct work_struct *work);
-int pcie_init(struct controller *ctrl, struct pcie_device *dev);
+struct controller *pcie_init(struct pcie_device *dev);
 int pciehp_enable_slot(struct slot *p_slot);
 int pciehp_disable_slot(struct slot *p_slot);
-int pcie_init_hardware_part2(struct controller *ctrl, struct pcie_device *dev);
+int pcie_enable_notification(struct controller *ctrl);
 
 static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)
 {

commit ac9c052d10d8d6f46a30cb46c0d6d753997c299f
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed May 28 15:01:03 2008 +0900

    shpchp: check firmware before taking control
    
    Fix the following problems of shpchp driver about getting hotplug
    control from firmware.
    
      - The shpchp driver must not control the hotplug controller if it
        fails to get control from the firmware. But current shpchp
        controls the hotplug controller regardless the result, because it
        doesn't check the return value of get_hp_hw_control_from_firmware().
    
      - Current shpchp driver doesn't support _OSC.
    
    The pciehp driver already have the code for evaluating _OSC and OSHP
    and shpchp and pciehp can share it. So this patch move that code from
    pciehp to acpi_pcihp.c.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 084b73efacb3..8492fab800cc 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -202,9 +202,13 @@ struct hpc_ops {
 #include <acpi/actypes.h>
 #include <linux/pci-acpi.h>
 
-extern int pciehp_acpi_get_hp_hw_control_from_firmware(struct pci_dev *dev);
-#define pciehp_get_hp_hw_control_from_firmware(dev)			\
-	pciehp_acpi_get_hp_hw_control_from_firmware(dev)
+static inline int pciehp_get_hp_hw_control_from_firmware(struct pci_dev *dev)
+{
+	u32 flags = (OSC_PCI_EXPRESS_NATIVE_HP_CONTROL |
+		     OSC_PCI_EXPRESS_CAP_STRUCTURE_CONTROL);
+	return acpi_get_hp_hw_control_from_firmware(dev, flags);
+}
+
 static inline int pciehp_get_hp_params_from_firmware(struct pci_dev *dev,
 			struct hotplug_params *hpp)
 {

commit 125c39f7d233de28f342d80858025ffed0c4b7f4
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed May 28 14:57:30 2008 +0900

    pciehp: evaluate _OSC/OSHP before controller init
    
    Current pciehp evaluates _OSC/OSHP method after some controller
    initialization is done. So if evaluating _OSC/OSHP is failed, we need
    to cleanup already initialized data structures or hardware. This
    clearly is not robust way. With this patch, _OSC/OSHP evaluation is
    done first.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 79c9ddaad3fb..084b73efacb3 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -202,6 +202,7 @@ struct hpc_ops {
 #include <acpi/actypes.h>
 #include <linux/pci-acpi.h>
 
+extern int pciehp_acpi_get_hp_hw_control_from_firmware(struct pci_dev *dev);
 #define pciehp_get_hp_hw_control_from_firmware(dev)			\
 	pciehp_acpi_get_hp_hw_control_from_firmware(dev)
 static inline int pciehp_get_hp_params_from_firmware(struct pci_dev *dev,

commit 5808639bfa98d69f77a481d759570d85f164fea0
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue May 27 19:04:30 2008 +0900

    pciehp: fix slow probing
    
    Fix the "pciehp probing slow" problem reported from Jan C. Nordholz in
    http://bugzilla.kernel.org/show_bug.cgi?id=10751.
    
    The command completed bit in Slot Status register applies only to
    commands issued to control the attention indicator, power indicator,
    power controller, or electromechanical interlock. However, writes to
    other parts of the Slot Control register would end up writing to the
    control fields. Hence, any write to Slot Control register is
    considered as a command. However, if the controller doesn't support
    any of attention indicator, power indicator, power controller and
    electromechanical interlock, command completed bit would not set in
    writing to Slot Control register. In this case, we should not wait for
    command completed bit set, otherwise all commands would be considered
    not completed in timeout seconds (1 sec.).
    
    The cause of the problem is pciehp driver didn't take this situation
    into account. This patch changes pciehp to take it into account. This
    patch also add the check for "No Command Completed Support" bit in
    Slot Capability register. If it is set, we should not wait for command
    completed bit set as well.
    
    This problem seems to be revealed by the commit
    c27fb883dffe11aa4cb35ecea1fa1832ba45d4da that fixed the bug that
    pciehp did not wait for command completed properly (pciehp just
    ignored the command completion event).
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 920091c4b18d..79c9ddaad3fb 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -97,6 +97,7 @@ struct controller {
 	u8 cap_base;
 	struct timer_list poll_timer;
 	volatile int cmd_busy;
+	unsigned int no_cmd_complete:1;
 };
 
 #define INT_BUTTON_IGNORE		0
@@ -135,6 +136,7 @@ struct controller {
 #define PWR_LED_PRSN	0x00000010
 #define HP_SUPR_RM_SUP	0x00000020
 #define EMI_PRSN	0x00020000
+#define NO_CMD_CMPL_SUP	0x00040000
 
 #define ATTN_BUTTN(ctrl)	((ctrl)->slot_cap & ATTN_BUTTN_PRSN)
 #define POWER_CTRL(ctrl)	((ctrl)->slot_cap & PWR_CTRL_PRSN)
@@ -143,6 +145,7 @@ struct controller {
 #define PWR_LED(ctrl)		((ctrl)->slot_cap & PWR_LED_PRSN)
 #define HP_SUPR_RM(ctrl)	((ctrl)->slot_cap & HP_SUPR_RM_SUP)
 #define EMI(ctrl)		((ctrl)->slot_cap & EMI_PRSN)
+#define NO_CMD_CMPL(ctrl)	((ctrl)->slot_cap & NO_CMD_CMPL_SUP)
 
 extern int pciehp_sysfs_enable_slot(struct slot *slot);
 extern int pciehp_sysfs_disable_slot(struct slot *slot);

commit dbd79aed1aea2bece0bf43cc2ff3b2f9baf48a08
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue May 27 19:03:16 2008 +0900

    pciehp: fix NULL dereference in interrupt handler
    
    Fix the following NULL dereference problem reported from Pierre Ossman
    and Ingo Molnar.
    
    pciehp: HPC vendor_id 8086 device_id 27d0 ss_vid 0 ss_did 0
    pciehp: pciehp_find_slot: slot (device=0x0) not found
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000070
    IP: [<ffffffff80494a8b>] pciehp_handle_presence_change+0x7e/0x113
    PGD 0
    Oops: 0000 [1]
    CPU 0
    Modules linked in:
    Pid: 1, comm: swapper Tainted: G        W 2.6.26-rc3-sched-devel.git-00001-g2b99b26-dirty #170
    RIP: 0010:[<ffffffff80494a8b>]  [<ffffffff80494a8b>] pciehp_handle_presence_change+0x7e/0x113
    RSP: 0000:ffff81003f83fbb0  EFLAGS: 00010046
    RAX: 0000000000000039 RBX: 0000000000000000 RCX: 0000000000000000
    RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000000046
    RBP: ffff81003f83fbd0 R08: 0000000000000001 R09: ffffffff80245103
    R10: 0000000000000020 R11: 0000000000000000 R12: ffff81003ea53a30
    R13: 0000000000000000 R14: 0000000000000011 R15: ffffffff80495926
    FS:  0000000000000000(0000) GS:ffffffff80be7400(0000) knlGS:0000000000000000
    CS:  0010 DS: 0018 ES: 0018 CR0: 000000008005003b
    CR2: 0000000000000070 CR3: 0000000000201000 CR4: 00000000000006a0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    Process swapper (pid: 1, threadinfo ffff81003f83e000, task ffff81003f840000)
    Stack:  0000000000000008 ffff81003f83fbf6 ffff81003ea53a30 0000000000000008
     ffff81003f83fc10 ffffffff80495ab4 0000000000000011 0000000000000002
     0000000000000202 0000000000000202 00000000fffffff4 ffff81003ea53a30
    Call Trace:
     [<ffffffff80495ab4>] pcie_isr+0x18e/0x1bc
     [<ffffffff80260831>] request_irq+0x106/0x12f
     [<ffffffff80495fb6>] pcie_init+0x15e/0x6cc
     [<ffffffff804933a3>] pciehp_probe+0x64/0x541
     [<ffffffff8048f4e7>] pcie_port_probe_service+0x4c/0x76
     [<ffffffff8054af70>] driver_probe_device+0xd4/0x1f0
     [<ffffffff8054b108>] __driver_attach+0x7c/0x7e
     [<ffffffff8054b08c>] ? __driver_attach+0x0/0x7e
     [<ffffffff8054a4b6>] bus_for_each_dev+0x53/0x7d
     [<ffffffff8054ad3c>] driver_attach+0x1c/0x1e
     [<ffffffff8054a9c2>] bus_add_driver+0xdd/0x25b
     [<ffffffff80c09d3d>] ? pcied_init+0x0/0x8b
     [<ffffffff8054b288>] driver_register+0x5f/0x13e
     [<ffffffff80c09d3d>] ? pcied_init+0x0/0x8b
     [<ffffffff8048f441>] pcie_port_service_register+0x47/0x49
     [<ffffffff80c09d52>] pcied_init+0x15/0x8b
     [<ffffffff80bf3938>] kernel_init+0x75/0x243
     [<ffffffff808639d2>] ? _spin_unlock_irq+0x2b/0x3a
     [<ffffffff80228d1f>] ? finish_task_switch+0x57/0x9a
     [<ffffffff8020c258>] child_rip+0xa/0x12
     [<ffffffff8020bcec>] ? restore_args+0x0/0x30
     [<ffffffff80bf38c3>] ? kernel_init+0x0/0x243
     [<ffffffff8020c24e>] ? child_rip+0x0/0x12
    
    Code: 83 80 00 00 00 48 39 f0 75 e1 0f b6 c9 48 c7 c2 00 0e 8d 80 48 c7 c6 8a 60 a6 80 48 c7 c7 10 db a8 80 31 c0 e8 3f 8d d9 ff 31 db <48> 8b 43 70 48 8d 75 ef 48 89 df ff 50 30 80 7d ef 00 74 37 48
    RIP  [<ffffffff80494a8b>] pciehp_handle_presence_change+0x7e/0x113
     RSP <ffff81003f83fbb0>
    CR2: 0000000000000070
    Kernel panic - not syncing: Fatal exception
    
    The situation under which it occurs is hw and timing related: it appears
    to happen on a system that has PCI hotplug hardware but with no active
    hotplug cards, and another interrupt in the same (shared) IRQ line
    arrives too early, before the hotplug-slot entry has been set up - as
    triggered by CONFIG_DEBUG_SHIRQ=y:
    
    This patch contains the following two fixes.
    
    (1) Clear all events bits in Slot Status register to prevent the pciehp
        driver from detecting the spurious events that would have been occur
        before pciehp loading.
    
    (2) Add check whether slot initialization had been already done.
    
    This is short term fix. We need more structural fixes to install
    interrupt handler after slot initialization is done.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 8264a7680435..920091c4b18d 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -146,10 +146,10 @@ struct controller {
 
 extern int pciehp_sysfs_enable_slot(struct slot *slot);
 extern int pciehp_sysfs_disable_slot(struct slot *slot);
-extern u8 pciehp_handle_attention_button(u8 hp_slot, struct controller *ctrl);
-extern u8 pciehp_handle_switch_change(u8 hp_slot, struct controller *ctrl);
-extern u8 pciehp_handle_presence_change(u8 hp_slot, struct controller *ctrl);
-extern u8 pciehp_handle_power_fault(u8 hp_slot, struct controller *ctrl);
+extern u8 pciehp_handle_attention_button(struct slot *p_slot);
+  extern u8 pciehp_handle_switch_change(struct slot *p_slot);
+extern u8 pciehp_handle_presence_change(struct slot *p_slot);
+extern u8 pciehp_handle_power_fault(struct slot *p_slot);
 extern int pciehp_configure_device(struct slot *p_slot);
 extern int pciehp_unconfigure_device(struct slot *p_slot);
 extern void pciehp_queue_pushbutton_work(struct work_struct *work);

commit ae416e6b2936fdb70aeee6eb9066115d4521daa6
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Fri Apr 25 14:39:06 2008 -0700

    pciehp: Fix wrong slot capability check
    
    Current pciehp saves only 8bits of Slot Capability registers in
    ctrl->ctrlcap. But it refers more than 8bit for checking EMI capability.
    It is clearly a bug and EMI would never work. To fix this problem,
    this patch saves full Slot Capability contens in ctrl->slot_cap. It also
    reduce the redundant reads of Slot Capability register. And this pach
    also cleans up the macros to check the slot capabilitys (e.g. MRL_SENS(),
    and so on).
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by:  Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 9dd132925ffa..8264a7680435 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -93,7 +93,7 @@ struct controller {
 	u8 slot_device_offset;
 	u32 first_slot;		/* First physical slot number */  /* PCIE only has 1 slot */
 	u8 slot_bus;		/* Bus where the slots handled by this controller sit */
-	u8 ctrlcap;
+	u32 slot_cap;
 	u8 cap_base;
 	struct timer_list poll_timer;
 	volatile int cmd_busy;
@@ -136,13 +136,13 @@ struct controller {
 #define HP_SUPR_RM_SUP	0x00000020
 #define EMI_PRSN	0x00020000
 
-#define ATTN_BUTTN(cap)		(cap & ATTN_BUTTN_PRSN)
-#define POWER_CTRL(cap)		(cap & PWR_CTRL_PRSN)
-#define MRL_SENS(cap)		(cap & MRL_SENS_PRSN)
-#define ATTN_LED(cap)		(cap & ATTN_LED_PRSN)
-#define PWR_LED(cap)		(cap & PWR_LED_PRSN) 
-#define HP_SUPR_RM(cap)		(cap & HP_SUPR_RM_SUP)
-#define EMI(cap)		(cap & EMI_PRSN)
+#define ATTN_BUTTN(ctrl)	((ctrl)->slot_cap & ATTN_BUTTN_PRSN)
+#define POWER_CTRL(ctrl)	((ctrl)->slot_cap & PWR_CTRL_PRSN)
+#define MRL_SENS(ctrl)		((ctrl)->slot_cap & MRL_SENS_PRSN)
+#define ATTN_LED(ctrl)		((ctrl)->slot_cap & ATTN_LED_PRSN)
+#define PWR_LED(ctrl)		((ctrl)->slot_cap & PWR_LED_PRSN)
+#define HP_SUPR_RM(ctrl)	((ctrl)->slot_cap & HP_SUPR_RM_SUP)
+#define EMI(ctrl)		((ctrl)->slot_cap & EMI_PRSN)
 
 extern int pciehp_sysfs_enable_slot(struct slot *slot);
 extern int pciehp_sysfs_disable_slot(struct slot *slot);

commit c6b069e94601aea8887afbbd922afe20a3580a7d
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Fri Apr 25 14:38:57 2008 -0700

    pciehp: Fix interrupt event handlig
    
    Current pciehp implementation disables and re-enables hotplug interrupts
    in its interrupt handler. This operation might be intend to guarantee
    that interrupts for the events newly occured during previous events are
    being handled will be successfully generated. But current implementaion
    has the following prolems.
    
      - Current interrupt service routin clears status changes without
        waiting command completion. Because of this, events might not be
        cleared properly.
      - Current interrupt service routine clears status changes caused by
        disabling or enabling hotplug interrupts itself. This will lose new
        events that occurs during previous interrupts are being handled.
      - Current implementation doesn't have any serialization mechanism
        between the code to wait for command completion and the interrupt
        handler that clears the command completion events caused by itself.
        There is clearly race conditions between them, and it may cause
        the problem that waiting for command completion doesn't work for
        example.
    
    To fix those problems, this patch stops disabling/re-enabling hotplug
    interrupts in interrupt service routine. Instead of this, this patch
    re-inspects Slot Status register after clearing what is presumed to
    be the last bending interrupt in order to guarantee that all interrupt
    events are serviced.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by:  Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index f14267e197dd..9dd132925ffa 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -97,7 +97,6 @@ struct controller {
 	u8 cap_base;
 	struct timer_list poll_timer;
 	volatile int cmd_busy;
-	spinlock_t lock;
 };
 
 #define INT_BUTTON_IGNORE		0

commit 66bef8c059015ba2b36bb5759080336feb01e680
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 19:09:46 2008 -0800

    PCI: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index ca656b27a500..f14267e197dd 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -168,7 +168,7 @@ static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)
 			return slot;
 	}
 
-	err("%s: slot (device=0x%x) not found\n", __FUNCTION__, device);
+	err("%s: slot (device=0x%x) not found\n", __func__, device);
 	return NULL;
 }
 

commit 0837974ddbdef14d268b3ffe032158f6490cbe64
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Fri Nov 9 17:30:29 2007 +0900

    PCI Hotplug: pciehp: remove needless members from struct controller
    
    Remove needless members from struct controller. This has no functional
    changes.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 288fc4689103..ca656b27a500 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -82,24 +82,18 @@ struct event_info {
 };
 
 struct controller {
-	struct controller *next;
 	struct mutex crit_sect;		/* critical section mutex */
 	struct mutex ctrl_lock;		/* controller lock */
 	int num_slots;			/* Number of slots on ctlr */
 	int slot_num_inc;		/* 1 or -1 */
 	struct pci_dev *pci_dev;
 	struct list_head slot_list;
-	struct slot *slot;
 	struct hpc_ops *hpc_ops;
 	wait_queue_head_t queue;	/* sleep & wake process */
-	u8 bus;
-	u8 device;
-	u8 function;
 	u8 slot_device_offset;
 	u32 first_slot;		/* First physical slot number */  /* PCIE only has 1 slot */
 	u8 slot_bus;		/* Bus where the slots handled by this controller sit */
 	u8 ctrlcap;
-	u16 vendor_id;
 	u8 cap_base;
 	struct timer_list poll_timer;
 	volatile int cmd_busy;

commit ecdde93962eacd9c417977a4eabd318dbb612c11
Author: Mark Lord <lkml@rtr.ca>
Date:   Wed Nov 21 15:07:55 2007 -0800

    PCIe: fix double initialization bug
    
    Earlier patches to split out the hardware init for PCIe hotplug resulted in
    some one-time initializations being redone on every resume cycle.  Eg.
    irq/polling initialization.
    
    This patch splits the hardware init into two parts, and separates the
    one-time initializations from those so that they only ever get done once,
    as intended.
    
    Signed-off-by: Mark Lord <mlord@pobox.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index e4ad00a3448e..288fc4689103 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -163,7 +163,7 @@ extern void pciehp_queue_pushbutton_work(struct work_struct *work);
 int pcie_init(struct controller *ctrl, struct pcie_device *dev);
 int pciehp_enable_slot(struct slot *p_slot);
 int pciehp_disable_slot(struct slot *p_slot);
-int pcie_init_hardware(struct controller *ctrl, struct pcie_device *dev);
+int pcie_init_hardware_part2(struct controller *ctrl, struct pcie_device *dev);
 
 static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)
 {

commit cd2fe83a81510acfd1ae29b8ffe04f7ef675c993
Author: Mark Lord <lkml@rtr.ca>
Date:   Wed Nov 28 15:12:00 2007 -0800

    PCIE: Make use of the previously split out pcie_init_enable_events() function
    
    Make use of the previously split out pcie_init_enable_events() function
    to reinitialize the hotplug hardware on resume from suspend, but only
    when pciehp_force==1.  Otherwise behaviour is unmodified.
    
    Signed-off-by: Mark Lord <mlord@pobox.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 968f57087ce0..e4ad00a3448e 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -162,6 +162,8 @@ extern int pciehp_unconfigure_device(struct slot *p_slot);
 extern void pciehp_queue_pushbutton_work(struct work_struct *work);
 int pcie_init(struct controller *ctrl, struct pcie_device *dev);
 int pciehp_enable_slot(struct slot *p_slot);
+int pciehp_disable_slot(struct slot *p_slot);
+int pcie_init_hardware(struct controller *ctrl, struct pcie_device *dev);
 
 static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)
 {

commit 0a3c33d77ff7ad5b988997536a8f09c49e35ad20
Author: Mark Lord <lkml@rtr.ca>
Date:   Wed Nov 28 15:11:28 2007 -0800

    PCIE: fix PCIe Hotplug so that it works with ExpressCard slots on Dell notebooks (and others?) in conjunction with modparam of pciehp_force=1.
    
    Fix pciehp_probe() to deal with ExpressCard cards
    that were inserted prior to the driver being loaded.
    
    Signed-off-by: Mark Lord <mlord@pobox.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 7959c222dc24..968f57087ce0 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -161,6 +161,7 @@ extern int pciehp_configure_device(struct slot *p_slot);
 extern int pciehp_unconfigure_device(struct slot *p_slot);
 extern void pciehp_queue_pushbutton_work(struct work_struct *work);
 int pcie_init(struct controller *ctrl, struct pcie_device *dev);
+int pciehp_enable_slot(struct slot *p_slot);
 
 static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)
 {

commit f477836457730a2b925f625023ec4e5bf11015be
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu May 31 09:43:34 2007 -0700

    PCI: hotplug: pciehp: Fix possible race condition in writing slot
    
    The slot control register is modified as follows:
    
        (1) Read the register value
        (2) Change the value
        (3) Write the value to the register
    
    Those must be done atomically, otherwise writing to control register
    would cause an unexpected result.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index ccc57627201e..7959c222dc24 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -103,6 +103,7 @@ struct controller {
 	u8 cap_base;
 	struct timer_list poll_timer;
 	volatile int cmd_busy;
+	spinlock_t lock;
 };
 
 #define INT_BUTTON_IGNORE		0

commit e325e1f0783382298141c74737712637943c6063
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Wed Mar 21 11:45:31 2007 -0700

    PCI: fix multiple definition of `queue_pushbutton_work'
    
    Fix duplicate names in shpchp and pciehp.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 74d0bf62e649..ccc57627201e 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -158,7 +158,7 @@ extern u8 pciehp_handle_presence_change(u8 hp_slot, struct controller *ctrl);
 extern u8 pciehp_handle_power_fault(u8 hp_slot, struct controller *ctrl);
 extern int pciehp_configure_device(struct slot *p_slot);
 extern int pciehp_unconfigure_device(struct slot *p_slot);
-extern void queue_pushbutton_work(struct work_struct *work);
+extern void pciehp_queue_pushbutton_work(struct work_struct *work);
 int pcie_init(struct controller *ctrl, struct pcie_device *dev);
 
 static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)

commit 9233352628bc8e284f66fc90c4dc74473db1fbc1
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Mar 6 15:02:32 2007 -0800

    pciehp: Adapt to device driver model
    
    This patch adapts PCIEHP driver to PCI device driver model.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index c98e27128cc4..74d0bf62e649 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -161,9 +161,6 @@ extern int pciehp_unconfigure_device(struct slot *p_slot);
 extern void queue_pushbutton_work(struct work_struct *work);
 int pcie_init(struct controller *ctrl, struct pcie_device *dev);
 
-/* Global variables */
-extern struct controller *pciehp_ctrl_list;
-
 static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)
 {
 	struct slot *slot;

commit 5d386e1ac4025b4bcc6bad6811e771cb76064dfe
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Mar 6 15:02:26 2007 -0800

    pciehp: Event handling rework
    
    The event handler of PCIEHP driver is unnecessarily very complex. In
    addition, current event handler can only a fixed number of events at
    the same time, and some of events would be lost if several number of
    events happened at the same time.
    
    This patch simplify the event handler using 'work queue', and it also
    fix the above-mentioned issue.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index d19fcae8a7c0..c98e27128cc4 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -43,6 +43,7 @@ extern int pciehp_poll_mode;
 extern int pciehp_poll_time;
 extern int pciehp_debug;
 extern int pciehp_force;
+extern struct workqueue_struct *pciehp_wq;
 
 #define dbg(format, arg...)						\
 	do {								\
@@ -70,14 +71,16 @@ struct slot {
 	struct list_head	slot_list;
 	char name[SLOT_NAME_SIZE];
 	unsigned long last_emi_toggle;
+	struct delayed_work work;	/* work for button event */
+	struct mutex lock;
 };
 
 struct event_info {
 	u32 event_type;
-	u8 hp_slot;
+	struct slot *p_slot;
+	struct work_struct work;
 };
 
-#define MAX_EVENTS		10
 struct controller {
 	struct controller *next;
 	struct mutex crit_sect;		/* critical section mutex */
@@ -86,11 +89,9 @@ struct controller {
 	int slot_num_inc;		/* 1 or -1 */
 	struct pci_dev *pci_dev;
 	struct list_head slot_list;
-	struct event_info event_queue[MAX_EVENTS];
 	struct slot *slot;
 	struct hpc_ops *hpc_ops;
 	wait_queue_head_t queue;	/* sleep & wake process */
-	u8 next_event;
 	u8 bus;
 	u8 device;
 	u8 function;
@@ -149,16 +150,15 @@ struct controller {
 #define HP_SUPR_RM(cap)		(cap & HP_SUPR_RM_SUP)
 #define EMI(cap)		(cap & EMI_PRSN)
 
-extern int pciehp_event_start_thread(void);
-extern void pciehp_event_stop_thread(void);
-extern int pciehp_enable_slot(struct slot *slot);
-extern int pciehp_disable_slot(struct slot *slot);
+extern int pciehp_sysfs_enable_slot(struct slot *slot);
+extern int pciehp_sysfs_disable_slot(struct slot *slot);
 extern u8 pciehp_handle_attention_button(u8 hp_slot, struct controller *ctrl);
 extern u8 pciehp_handle_switch_change(u8 hp_slot, struct controller *ctrl);
 extern u8 pciehp_handle_presence_change(u8 hp_slot, struct controller *ctrl);
 extern u8 pciehp_handle_power_fault(u8 hp_slot, struct controller *ctrl);
 extern int pciehp_configure_device(struct slot *p_slot);
 extern int pciehp_unconfigure_device(struct slot *p_slot);
+extern void queue_pushbutton_work(struct work_struct *work);
 int pcie_init(struct controller *ctrl, struct pcie_device *dev);
 
 /* Global variables */

commit 34d03419f03bcfdf70d9617a9b90b60c93482c4a
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Tue Jan 9 13:02:36 2007 -0800

    PCIEHP: Add Electro Mechanical Interlock (EMI) support to the PCIE hotplug driver.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 927dba9911ed..d19fcae8a7c0 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -69,6 +69,7 @@ struct slot {
 	struct hotplug_slot *hotplug_slot;
 	struct list_head	slot_list;
 	char name[SLOT_NAME_SIZE];
+	unsigned long last_emi_toggle;
 };
 
 struct event_info {
@@ -138,6 +139,7 @@ struct controller {
 #define ATTN_LED_PRSN	0x00000008
 #define PWR_LED_PRSN	0x00000010
 #define HP_SUPR_RM_SUP	0x00000020
+#define EMI_PRSN	0x00020000
 
 #define ATTN_BUTTN(cap)		(cap & ATTN_BUTTN_PRSN)
 #define POWER_CTRL(cap)		(cap & PWR_CTRL_PRSN)
@@ -145,6 +147,7 @@ struct controller {
 #define ATTN_LED(cap)		(cap & ATTN_LED_PRSN)
 #define PWR_LED(cap)		(cap & PWR_LED_PRSN) 
 #define HP_SUPR_RM(cap)		(cap & HP_SUPR_RM_SUP)
+#define EMI(cap)		(cap & EMI_PRSN)
 
 extern int pciehp_event_start_thread(void);
 extern void pciehp_event_stop_thread(void);
@@ -182,6 +185,8 @@ struct hpc_ops {
 	int (*set_attention_status)(struct slot *slot, u8 status);
 	int (*get_latch_status)(struct slot *slot, u8 *status);
 	int (*get_adapter_status)(struct slot *slot, u8 *status);
+	int (*get_emi_status)(struct slot *slot, u8 *status);
+	int (*toggle_emi)(struct slot *slot);
 	int (*get_max_bus_speed)(struct slot *slot, enum pci_bus_speed *speed);
 	int (*get_cur_bus_speed)(struct slot *slot, enum pci_bus_speed *speed);
 	int (*get_max_lnk_width)(struct slot *slot, enum pcie_link_width *val);

commit 262303fe329a51463925f3749aafc358a4201397
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu Dec 21 17:01:10 2006 -0800

    pciehp: fix wait command completion
    
    This patch fixes this problem that pciehp driver will sleep
    unnecessarily long when waiting for command completion. With this
    patch, modprobe pciehp driver becomes very faster as follows for
    instance.
    
      o Without this patch
        # time /sbin/modprobe pciehp
    
        real    0m4.976s
        user    0m0.000s
        sys     0m0.004s
    
      o With this patch
        # time /sbin/modprobe pciehp
    
        real    0m0.640s
        user    0m0.000s
        sys     0m0.004s
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 17167d594472..927dba9911ed 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -100,6 +100,7 @@ struct controller {
 	u16 vendor_id;
 	u8 cap_base;
 	struct timer_list poll_timer;
+	volatile int cmd_busy;
 };
 
 #define INT_BUTTON_IGNORE		0

commit 44ef4cefb0168740184ee3d7d18254339741e9d5
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu Dec 21 17:01:09 2006 -0800

    pciehp: cleanup wait command completion
    
    This patch cleans up the code to wait for command completion.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index e4524cf02427..17167d594472 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -173,24 +173,6 @@ static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)
 	return NULL;
 }
 
-static inline int wait_for_ctrl_irq(struct controller *ctrl)
-{
-	DECLARE_WAITQUEUE(wait, current);
-
-	add_wait_queue(&ctrl->queue, &wait);
-	if (!pciehp_poll_mode)
-		/* Sleep for up to 1 second */
-		msleep_interruptible(1000);
-	else
-		msleep_interruptible(2500);
-	
-	remove_wait_queue(&ctrl->queue, &wait);
-	if (signal_pending(current))
-		return -EINTR;
-
-	return 0;
-}
-
 struct hpc_ops {
 	int (*power_on_slot)(struct slot *slot);
 	int (*power_off_slot)(struct slot *slot);

commit 15232ece5566710d24c81ac3dd629f7556a92818
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu Dec 21 17:01:07 2006 -0800

    pciehp: cleanup pciehp.h
    
    This patch cleans up pciehp.h. This has no functional change.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index b505515a07ae..e4524cf02427 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -44,11 +44,17 @@ extern int pciehp_poll_time;
 extern int pciehp_debug;
 extern int pciehp_force;
 
-/*#define dbg(format, arg...) do { if (pciehp_debug) printk(KERN_DEBUG "%s: " format, MY_NAME , ## arg); } while (0)*/
-#define dbg(format, arg...) do { if (pciehp_debug) printk("%s: " format, MY_NAME , ## arg); } while (0)
-#define err(format, arg...) printk(KERN_ERR "%s: " format, MY_NAME , ## arg)
-#define info(format, arg...) printk(KERN_INFO "%s: " format, MY_NAME , ## arg)
-#define warn(format, arg...) printk(KERN_WARNING "%s: " format, MY_NAME , ## arg)
+#define dbg(format, arg...)						\
+	do {								\
+		if (pciehp_debug)					\
+			printk("%s: " format, MY_NAME , ## arg);	\
+	} while (0)
+#define err(format, arg...)						\
+	printk(KERN_ERR "%s: " format, MY_NAME , ## arg)
+#define info(format, arg...)						\
+	printk(KERN_INFO "%s: " format, MY_NAME , ## arg)
+#define warn(format, arg...)						\
+	printk(KERN_WARNING "%s: " format, MY_NAME , ## arg)
 
 #define SLOT_NAME_SIZE 10
 struct slot {
@@ -113,8 +119,6 @@ struct controller {
 #define POWERON_STATE			3
 #define POWEROFF_STATE			4
 
-#define PCI_TO_PCI_BRIDGE_CLASS		0x00060400
-
 /* Error messages */
 #define INTERLOCK_OPEN			0x00000002
 #define ADD_NOT_SUPPORTED		0x00000003
@@ -126,10 +130,6 @@ struct controller {
 #define WRONG_BUS_FREQUENCY		0x0000000D
 #define POWER_FAILURE			0x0000000E
 
-#define REMOVE_NOT_SUPPORTED		0x00000003
-
-#define DISABLE_CARD			1
-
 /* Field definitions in Slot Capabilities Register */
 #define ATTN_BUTTN_PRSN	0x00000001
 #define	PWR_CTRL_PRSN	0x00000002
@@ -145,38 +145,21 @@ struct controller {
 #define PWR_LED(cap)		(cap & PWR_LED_PRSN) 
 #define HP_SUPR_RM(cap)		(cap & HP_SUPR_RM_SUP)
 
-/*
- * error Messages
- */
-#define msg_initialization_err	"Initialization failure, error=%d\n"
-#define msg_button_on		"PCI slot #%s - powering on due to button press.\n"
-#define msg_button_off		"PCI slot #%s - powering off due to button press.\n"
-#define msg_button_cancel	"PCI slot #%s - action canceled due to button press.\n"
-#define msg_button_ignore	"PCI slot #%s - button press ignored.  (action in progress...)\n"
-
-/* controller functions */
-extern int	pciehp_event_start_thread	(void);
-extern void	pciehp_event_stop_thread	(void);
-extern int	pciehp_enable_slot		(struct slot *slot);
-extern int	pciehp_disable_slot		(struct slot *slot);
-
+extern int pciehp_event_start_thread(void);
+extern void pciehp_event_stop_thread(void);
+extern int pciehp_enable_slot(struct slot *slot);
+extern int pciehp_disable_slot(struct slot *slot);
 extern u8 pciehp_handle_attention_button(u8 hp_slot, struct controller *ctrl);
 extern u8 pciehp_handle_switch_change(u8 hp_slot, struct controller *ctrl);
 extern u8 pciehp_handle_presence_change(u8 hp_slot, struct controller *ctrl);
 extern u8 pciehp_handle_power_fault(u8 hp_slot, struct controller *ctrl);
-/* extern void	long_delay (int delay); */
-
-/* pci functions */
-extern int	pciehp_configure_device		(struct slot *p_slot);
-extern int	pciehp_unconfigure_device	(struct slot *p_slot);
-
-
+extern int pciehp_configure_device(struct slot *p_slot);
+extern int pciehp_unconfigure_device(struct slot *p_slot);
+int pcie_init(struct controller *ctrl, struct pcie_device *dev);
 
 /* Global variables */
 extern struct controller *pciehp_ctrl_list;
 
-/* Inline functions */
-
 static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)
 {
 	struct slot *slot;
@@ -192,8 +175,6 @@ static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)
 
 static inline int wait_for_ctrl_irq(struct controller *ctrl)
 {
-	int retval = 0;
-
 	DECLARE_WAITQUEUE(wait, current);
 
 	add_wait_queue(&ctrl->queue, &wait);
@@ -205,44 +186,38 @@ static inline int wait_for_ctrl_irq(struct controller *ctrl)
 	
 	remove_wait_queue(&ctrl->queue, &wait);
 	if (signal_pending(current))
-		retval =  -EINTR;
+		return -EINTR;
 
-	return retval;
+	return 0;
 }
 
-int pcie_init(struct controller *ctrl, struct pcie_device *dev);
-
 struct hpc_ops {
-	int	(*power_on_slot)	(struct slot *slot);
-	int	(*power_off_slot)	(struct slot *slot);
-	int	(*get_power_status)	(struct slot *slot, u8 *status);
-	int	(*get_attention_status)	(struct slot *slot, u8 *status);
-	int	(*set_attention_status)	(struct slot *slot, u8 status);
-	int	(*get_latch_status)	(struct slot *slot, u8 *status);
-	int	(*get_adapter_status)	(struct slot *slot, u8 *status);
-
-	int	(*get_max_bus_speed)	(struct slot *slot, enum pci_bus_speed *speed);
-	int	(*get_cur_bus_speed)	(struct slot *slot, enum pci_bus_speed *speed);
-
-	int	(*get_max_lnk_width)	(struct slot *slot, enum pcie_link_width *value);
-	int	(*get_cur_lnk_width)	(struct slot *slot, enum pcie_link_width *value);
-	
-	int	(*query_power_fault)	(struct slot *slot);
-	void	(*green_led_on)		(struct slot *slot);
-	void	(*green_led_off)	(struct slot *slot);
-	void	(*green_led_blink)	(struct slot *slot);
-	void	(*release_ctlr)		(struct controller *ctrl);
-	int	(*check_lnk_status)	(struct controller *ctrl);
+	int (*power_on_slot)(struct slot *slot);
+	int (*power_off_slot)(struct slot *slot);
+	int (*get_power_status)(struct slot *slot, u8 *status);
+	int (*get_attention_status)(struct slot *slot, u8 *status);
+	int (*set_attention_status)(struct slot *slot, u8 status);
+	int (*get_latch_status)(struct slot *slot, u8 *status);
+	int (*get_adapter_status)(struct slot *slot, u8 *status);
+	int (*get_max_bus_speed)(struct slot *slot, enum pci_bus_speed *speed);
+	int (*get_cur_bus_speed)(struct slot *slot, enum pci_bus_speed *speed);
+	int (*get_max_lnk_width)(struct slot *slot, enum pcie_link_width *val);
+	int (*get_cur_lnk_width)(struct slot *slot, enum pcie_link_width *val);
+	int (*query_power_fault)(struct slot *slot);
+	void (*green_led_on)(struct slot *slot);
+	void (*green_led_off)(struct slot *slot);
+	void (*green_led_blink)(struct slot *slot);
+	void (*release_ctlr)(struct controller *ctrl);
+	int (*check_lnk_status)(struct controller *ctrl);
 };
 
-
 #ifdef CONFIG_ACPI
 #include <acpi/acpi.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/actypes.h>
 #include <linux/pci-acpi.h>
 
-#define pciehp_get_hp_hw_control_from_firmware(dev) \
+#define pciehp_get_hp_hw_control_from_firmware(dev)			\
 	pciehp_acpi_get_hp_hw_control_from_firmware(dev)
 static inline int pciehp_get_hp_params_from_firmware(struct pci_dev *dev,
 			struct hotplug_params *hpp)

commit a8c2b635979823043ea7766dea1d9371773b4d8e
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu Dec 21 17:01:05 2006 -0800

    pciehp: remove unused pci_bus from struct controller
    
    This patch removes unused pci_bus member from struct controller.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 202e4967a941..b505515a07ae 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -78,7 +78,6 @@ struct controller {
 	int num_slots;			/* Number of slots on ctlr */
 	int slot_num_inc;		/* 1 or -1 */
 	struct pci_dev *pci_dev;
-	struct pci_bus *pci_bus;
 	struct list_head slot_list;
 	struct event_info event_queue[MAX_EVENTS];
 	struct slot *slot;

commit 48fe39151727db350347e1dba09d71c8ca24207a
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu Dec 21 17:01:04 2006 -0800

    pciehp: remove unnecessary php_ctlr
    
    The struct php_ctlr seems to be only for complicating codes. This
    patch removes struct php_ctlr and related codes.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index d07ac45f1272..202e4967a941 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -70,30 +70,11 @@ struct event_info {
 	u8 hp_slot;
 };
 
-typedef u8(*php_intr_callback_t) (u8 hp_slot, void *instance_id);
-
-struct php_ctlr_state_s {
-	struct php_ctlr_state_s *pnext;
-	struct pci_dev *pci_dev;
-	unsigned int irq;
-	unsigned long flags;				/* spinlock's */
-	u32 slot_device_offset;
-	u32 num_slots;
-    	struct timer_list	int_poll_timer;		/* Added for poll event */
-	php_intr_callback_t 	attention_button_callback;
-	php_intr_callback_t 	switch_change_callback;
-	php_intr_callback_t 	presence_change_callback;
-	php_intr_callback_t 	power_fault_callback;
-	void 			*callback_instance_id;
-	struct ctrl_reg 	*creg;				/* Ptr to controller register space */
-};
-
 #define MAX_EVENTS		10
 struct controller {
 	struct controller *next;
 	struct mutex crit_sect;		/* critical section mutex */
 	struct mutex ctrl_lock;		/* controller lock */
-	struct php_ctlr_state_s *hpc_ctlr_handle; /* HPC controller handle */
 	int num_slots;			/* Number of slots on ctlr */
 	int slot_num_inc;		/* 1 or -1 */
 	struct pci_dev *pci_dev;
@@ -113,6 +94,7 @@ struct controller {
 	u8 ctrlcap;
 	u16 vendor_id;
 	u8 cap_base;
+	struct timer_list poll_timer;
 };
 
 #define INT_BUTTON_IGNORE		0
@@ -179,10 +161,10 @@ extern void	pciehp_event_stop_thread	(void);
 extern int	pciehp_enable_slot		(struct slot *slot);
 extern int	pciehp_disable_slot		(struct slot *slot);
 
-extern u8	pciehp_handle_attention_button	(u8 hp_slot, void *inst_id);
-extern u8	pciehp_handle_switch_change	(u8 hp_slot, void *inst_id);
-extern u8	pciehp_handle_presence_change	(u8 hp_slot, void *inst_id);
-extern u8	pciehp_handle_power_fault	(u8 hp_slot, void *inst_id);
+extern u8 pciehp_handle_attention_button(u8 hp_slot, struct controller *ctrl);
+extern u8 pciehp_handle_switch_change(u8 hp_slot, struct controller *ctrl);
+extern u8 pciehp_handle_presence_change(u8 hp_slot, struct controller *ctrl);
+extern u8 pciehp_handle_power_fault(u8 hp_slot, struct controller *ctrl);
 /* extern void	long_delay (int delay); */
 
 /* pci functions */
@@ -229,21 +211,8 @@ static inline int wait_for_ctrl_irq(struct controller *ctrl)
 	return retval;
 }
 
-enum php_ctlr_type {
-	PCI,
-	ISA,
-	ACPI
-};
-
 int pcie_init(struct controller *ctrl, struct pcie_device *dev);
 
-/* This has no meaning for PCI Express, as there is only 1 slot per port */
-int pcie_get_ctlr_slot_config(struct controller *ctrl,
-		int *num_ctlr_slots,
-		int *first_device_num,
-		int *physical_slot_num,
-		u8 *ctrlcap);
-
 struct hpc_ops {
 	int	(*power_on_slot)	(struct slot *slot);
 	int	(*power_off_slot)	(struct slot *slot);

commit 2410fa4eaec4133f9fa8968f277ddb28b89b92b3
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu Dec 21 17:01:03 2006 -0800

    pciehp: cleanup slot list
    
    This patch cleans up slot list handling (use list_head). This has no
    functional change.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 6a2f427768ca..d07ac45f1272 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -52,7 +52,6 @@ extern int pciehp_force;
 
 #define SLOT_NAME_SIZE 10
 struct slot {
-	struct slot *next;
 	u8 bus;
 	u8 device;
 	u32 number;
@@ -99,6 +98,7 @@ struct controller {
 	int slot_num_inc;		/* 1 or -1 */
 	struct pci_dev *pci_dev;
 	struct pci_bus *pci_bus;
+	struct list_head slot_list;
 	struct event_info event_queue[MAX_EVENTS];
 	struct slot *slot;
 	struct hpc_ops *hpc_ops;
@@ -198,20 +198,15 @@ extern struct controller *pciehp_ctrl_list;
 
 static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)
 {
-	struct slot *p_slot, *tmp_slot = NULL;
-
-	p_slot = ctrl->slot;
+	struct slot *slot;
 
-	while (p_slot && (p_slot->device != device)) {
-		tmp_slot = p_slot;
-		p_slot = p_slot->next;
-	}
-	if (p_slot == NULL) {
-		err("ERROR: pciehp_find_slot device=0x%x\n", device);
-		p_slot = tmp_slot;
+	list_for_each_entry(slot, &ctrl->slot_list, slot_list) {
+		if (slot->device == device)
+			return slot;
 	}
 
-	return p_slot;
+	err("%s: slot (device=0x%x) not found\n", __FUNCTION__, device);
+	return NULL;
 }
 
 static inline int wait_for_ctrl_irq(struct controller *ctrl)

commit a0b1725720d9a023a1dee129234f5972056038c6
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu Dec 21 17:01:02 2006 -0800

    pciehp: cleanup init_slot()
    
    This patch cleans up init_slots() in pciehp_core.c based on
    pcihp_skeleton.c. This has no functional change.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 4fb12fcda563..6a2f427768ca 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -50,7 +50,7 @@ extern int pciehp_force;
 #define info(format, arg...) printk(KERN_INFO "%s: " format, MY_NAME , ## arg)
 #define warn(format, arg...) printk(KERN_WARNING "%s: " format, MY_NAME , ## arg)
 
-
+#define SLOT_NAME_SIZE 10
 struct slot {
 	struct slot *next;
 	u8 bus;
@@ -63,6 +63,7 @@ struct slot {
 	struct hpc_ops *hpc_ops;
 	struct hotplug_slot *hotplug_slot;
 	struct list_head	slot_list;
+	char name[SLOT_NAME_SIZE];
 };
 
 struct event_info {
@@ -233,13 +234,6 @@ static inline int wait_for_ctrl_irq(struct controller *ctrl)
 	return retval;
 }
 
-#define SLOT_NAME_SIZE 10
-
-static inline void make_slot_name(char *buffer, int buffer_size, struct slot *slot)
-{
-	snprintf(buffer, buffer_size, "%04d_%04d", slot->bus, slot->number);
-}
-
 enum php_ctlr_type {
 	PCI,
 	ISA,

commit 7a54f25cef6c763f16c9fd49ae382de162147873
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 13 20:05:19 2006 -0700

    PCI Hotplug: move pci_hotplug.h to include/linux/
    
    This makes it possible to build pci hotplug drivers outside of the main
    kernel tree, and Sam keeps telling me to move local header files to
    their proper places...
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 30f021c55fe5..4fb12fcda563 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -31,11 +31,11 @@
 
 #include <linux/types.h>
 #include <linux/pci.h>
+#include <linux/pci_hotplug.h>
 #include <linux/delay.h>
 #include <linux/sched.h>		/* signal_pending() */
 #include <linux/pcieport_if.h>
 #include <linux/mutex.h>
-#include "pci_hotplug.h"
 
 #define MY_NAME	"pciehp"
 

commit dd5619cb4407e830a8921a93c949be37c81105b5
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Fri Sep 22 10:17:29 2006 -0700

    pciehp - add missing locking
    
    This patch fixes the problem that system will panic if multiple power
    on/off operations are issued to the same slot in parallel. This
    problem can be easily reproduced by commands below.
    
        # while true; do echo 1 > power; echo 0 > power; done &
        # while true; do echo 1 > power; echo 0 > power; done &
    
    The cause is lack of locking for enable/disable operations. This patch
    fixes this problem.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index b71f774aca16..30f021c55fe5 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -92,6 +92,7 @@ struct php_ctlr_state_s {
 struct controller {
 	struct controller *next;
 	struct mutex crit_sect;		/* critical section mutex */
+	struct mutex ctrl_lock;		/* controller lock */
 	struct php_ctlr_state_s *hpc_ctlr_handle; /* HPC controller handle */
 	int num_slots;			/* Number of slots on ctlr */
 	int slot_num_inc;		/* 1 or -1 */

commit 49ed2b4963cd00993eab518b820a6700f94f222d
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Fri Sep 22 10:17:10 2006 -0700

    pciehp: fix improper info messages
    
    The slot number displayed in info messages would cause a confusion
    because those are displayed in several ways (decimal and hex).
    Furthermore, those slot number is not same as slot name (directory
    name). This patch fixes those improper info messages.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index eaea9d36a1bb..b71f774aca16 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -166,10 +166,10 @@ struct controller {
  * error Messages
  */
 #define msg_initialization_err	"Initialization failure, error=%d\n"
-#define msg_button_on		"PCI slot #%d - powering on due to button press.\n"
-#define msg_button_off		"PCI slot #%d - powering off due to button press.\n"
-#define msg_button_cancel	"PCI slot #%d - action canceled due to button press.\n"
-#define msg_button_ignore	"PCI slot #%d - button press ignored.  (action in progress...)\n"
+#define msg_button_on		"PCI slot #%s - powering on due to button press.\n"
+#define msg_button_off		"PCI slot #%s - powering off due to button press.\n"
+#define msg_button_cancel	"PCI slot #%s - action canceled due to button press.\n"
+#define msg_button_ignore	"PCI slot #%s - button press ignored.  (action in progress...)\n"
 
 /* controller functions */
 extern int	pciehp_event_start_thread	(void);

commit e50d1088bf2e5a68068c5f602be1dcc3e52dc873
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Tue Aug 8 09:44:26 2006 -0400

    pciehp: make pciehp build for powerpc
    
    Make pciehp build on powerpc
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index ce89f5815861..eaea9d36a1bb 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -279,6 +279,11 @@ struct hpc_ops {
 
 
 #ifdef CONFIG_ACPI
+#include <acpi/acpi.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/actypes.h>
+#include <linux/pci-acpi.h>
+
 #define pciehp_get_hp_hw_control_from_firmware(dev) \
 	pciehp_acpi_get_hp_hw_control_from_firmware(dev)
 static inline int pciehp_get_hp_params_from_firmware(struct pci_dev *dev,

commit 7430e34c70106a9576fc61d77604d164b187a1b7
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue May 2 10:54:50 2006 +0900

    [PATCH] acpi_pcihp: Fix programming _HPP values
    
    This patch fixes the problem that hotplug parameters are not programed
    when PCI cards are hot-added by ACPIPHP, SHPCHP and PCIEHP driver. The
    pci_dev structure being hot-added is not bound to ACPI handle, so we
    need to trace PCI bus tree to find ACPI handle.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Cc: Kristen Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 92c1f0f1e1ad..ce89f5815861 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -284,7 +284,7 @@ struct hpc_ops {
 static inline int pciehp_get_hp_params_from_firmware(struct pci_dev *dev,
 			struct hotplug_params *hpp)
 {
-	if (ACPI_FAILURE(acpi_get_hp_params_from_firmware(dev, hpp)))
+	if (ACPI_FAILURE(acpi_get_hp_params_from_firmware(dev->bus, hpp)))
 		return -ENODEV;
 	return 0;
 }

commit 783c49fc506d9afe4784390b556fa25ede5d6d1f
Author: Kristen Accardi <kristen.c.accardi@intel.com>
Date:   Fri Mar 3 10:16:05 2006 -0800

    [PATCH] PCI Hotplug: add common acpi functions to core
    
    shpchprm_acpi.c and pciehprm_acpi.c are nearly identical.  In addition,
    there are functions in both these files that are also in acpiphp_glue.c.
    This patch will remove duplicate functions from shpchp, pciehp, and
    acpiphp and move this functionality to pci_hotplug, as it is not
    hardware specific.  Get rid of shpchprm* and pciehprm* files since they
    are no longer needed.  shpchprm_nonacpi.c and pciehprm_nonacpi.c are
    identical, as well as shpchprm_legacy.c and can be replaced with a
    macro.
    
    This patch also changes acpiphp to use the common hpp code.
    
    Signed-off-by:  Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index e0adf4bc89e8..92c1f0f1e1ad 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -50,12 +50,6 @@ extern int pciehp_force;
 #define info(format, arg...) printk(KERN_INFO "%s: " format, MY_NAME , ## arg)
 #define warn(format, arg...) printk(KERN_WARNING "%s: " format, MY_NAME , ## arg)
 
-struct hotplug_params {
-	u8 cache_line_size;
-	u8 latency_timer;
-	u8 enable_serr;
-	u8 enable_perr;
-};
 
 struct slot {
 	struct slot *next;
@@ -192,9 +186,6 @@ extern u8	pciehp_handle_power_fault	(u8 hp_slot, void *inst_id);
 /* pci functions */
 extern int	pciehp_configure_device		(struct slot *p_slot);
 extern int	pciehp_unconfigure_device	(struct slot *p_slot);
-extern int	pciehp_get_hp_hw_control_from_firmware(struct pci_dev *dev);
-extern void	pciehp_get_hp_params_from_firmware(struct pci_dev *dev,
-	       	struct hotplug_params *hpp);
 
 
 
@@ -286,4 +277,19 @@ struct hpc_ops {
 	int	(*check_lnk_status)	(struct controller *ctrl);
 };
 
+
+#ifdef CONFIG_ACPI
+#define pciehp_get_hp_hw_control_from_firmware(dev) \
+	pciehp_acpi_get_hp_hw_control_from_firmware(dev)
+static inline int pciehp_get_hp_params_from_firmware(struct pci_dev *dev,
+			struct hotplug_params *hpp)
+{
+	if (ACPI_FAILURE(acpi_get_hp_params_from_firmware(dev, hpp)))
+		return -ENODEV;
+	return 0;
+}
+#else
+#define pciehp_get_hp_hw_control_from_firmware(dev) 	0
+#define pciehp_get_hp_params_from_firmware(dev, hpp)    (-ENODEV)
+#endif 				/* CONFIG_ACPI */
 #endif				/* _PCIEHP_H */

commit 6aa4cdd07139ba4d5b89139b0070d795cc4dea88
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Jan 13 16:02:15 2006 +0100

    [PATCH] PCI hotplug: convert semaphores to mutex
    
    semaphore to mutex conversion.
    
    the conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    build tested with allyesconfig.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 0aac6a61337d..e0adf4bc89e8 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -34,6 +34,7 @@
 #include <linux/delay.h>
 #include <linux/sched.h>		/* signal_pending() */
 #include <linux/pcieport_if.h>
+#include <linux/mutex.h>
 #include "pci_hotplug.h"
 
 #define MY_NAME	"pciehp"
@@ -96,7 +97,7 @@ struct php_ctlr_state_s {
 #define MAX_EVENTS		10
 struct controller {
 	struct controller *next;
-	struct semaphore crit_sect;	/* critical section semaphore */
+	struct mutex crit_sect;		/* critical section mutex */
 	struct php_ctlr_state_s *hpc_ctlr_handle; /* HPC controller handle */
 	int num_slots;			/* Number of slots on ctlr */
 	int slot_num_inc;		/* 1 or -1 */

commit de25968cc87cc5b76d09de8b4cbddc8f24fcf5f7
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Jan 8 01:02:05 2006 -0800

    [PATCH] fix more missing includes
    
    Include fixes for 2.6.14-git11.  Should allow to remove sched.h from
    module.h on i386, x86_64, arm, ia64, ppc, ppc64, and s390.  Probably more
    to come since I haven't yet checked the other archs.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 6a61b9f286e1..0aac6a61337d 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -32,6 +32,7 @@
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
+#include <linux/sched.h>		/* signal_pending() */
 #include <linux/pcieport_if.h>
 #include "pci_hotplug.h"
 

commit 5a49f2036ad14092c11d09f186da86fd5ae49a05
Author: Rajesh Shah <rajesh.shah@intel.com>
Date:   Wed Nov 23 15:44:54 2005 -0800

    [PATCH] PCI Express Hotplug: clear sticky power-fault bit
    
    Per the PCI Express spec, the power-fault-detected bit in the
    slot status register can be set anytime hardware detects a power
    fault, regardless of whether the slot has a device populated in
    it or not. This bit is sticky and must be explicitly cleared.
    This patch is needed to allow hot-add after such a power fault
    has been detected.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index c42b68d3aa24..6a61b9f286e1 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -59,7 +59,6 @@ struct slot {
 	struct slot *next;
 	u8 bus;
 	u8 device;
-	u16 status;
 	u32 number;
 	u8 state;
 	struct timer_list task_event;

commit 6560aa5c430fd8a7002b6e7abc1ee6c42521b06b
Author: Rajesh Shah <rajesh.shah@intel.com>
Date:   Mon Nov 7 13:37:36 2005 -0800

    [PATCH] PCI: fix namespace clashes
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index e71f78318d6e..c42b68d3aa24 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -191,8 +191,8 @@ extern u8	pciehp_handle_power_fault	(u8 hp_slot, void *inst_id);
 /* pci functions */
 extern int	pciehp_configure_device		(struct slot *p_slot);
 extern int	pciehp_unconfigure_device	(struct slot *p_slot);
-extern int	get_hp_hw_control_from_firmware(struct pci_dev *dev);
-extern void	get_hp_params_from_firmware(struct pci_dev *dev,
+extern int	pciehp_get_hp_hw_control_from_firmware(struct pci_dev *dev);
+extern void	pciehp_get_hp_params_from_firmware(struct pci_dev *dev,
 	       	struct hotplug_params *hpp);
 
 

commit a3a45ec8f8edaf088449e37fe81c99cbf580b9bd
Author: rajesh.shah@intel.com <rajesh.shah@intel.com>
Date:   Mon Oct 31 16:20:12 2005 -0800

    [PATCH] pciehp: clean-up how we request control of hotplug hardware
    
    This patch further tweaks how we request control of hotplug
    controller hardware from BIOS. We first search the ACPI namespace
    corresponding to a specific hotplug controller looking for an
    _OSC or OSHP method. On failure, we successively move to the
    ACPI parent object, till we hit the highest level host bridge
    in the hierarchy. This allows for different types of BIOS's
    which place the _OSC/OSHP methods at various places in the acpi
    namespace, while still not encroaching on the namespace of
    some other root level host bridge.
    
    This patch also introduces a new load time option (pciehp_force)
    that allows us to bypass all _OSC/OSHP checking. Not supporting
    these methods seems to be be the most common ACPI firmware problem
    we've run into. This will still _not_ allow the pciehp driver to
    work correctly if the BIOS really doesn't support pciehp (i.e. if
    it doesn't generate a hotplug interrupt). Use this option with
    caution.  Some BIOS's may deliberately not build any _OSC/OSHP
    methods to make sure it retains control the hotplug hardware.
    Using the pciehp_force parameter for such systems can lead to
    two separate entities trying to control the same hardware.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index e1c2cea305f8..e71f78318d6e 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -40,6 +40,7 @@
 extern int pciehp_poll_mode;
 extern int pciehp_poll_time;
 extern int pciehp_debug;
+extern int pciehp_force;
 
 /*#define dbg(format, arg...) do { if (pciehp_debug) printk(KERN_DEBUG "%s: " format, MY_NAME , ## arg); } while (0)*/
 #define dbg(format, arg...) do { if (pciehp_debug) printk("%s: " format, MY_NAME , ## arg); } while (0)

commit 1a9ed1bfe2fb17cc30227a12a3c1212128bb78b6
Author: rajesh.shah@intel.com <rajesh.shah@intel.com>
Date:   Mon Oct 31 16:20:10 2005 -0800

    [PATCH] pciehp: reduce debug message verbosity
    
    Reduce the number of debug messages generated if pciehp debug is
    enabled. I tried to restrict this to removing debug messages that
    are either early-driver-debug type messages, or print information
    that can be inferred through other debug prints.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 314989a3a933..e1c2cea305f8 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -207,12 +207,9 @@ static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)
 
 	p_slot = ctrl->slot;
 
-	dbg("p_slot = %p\n", p_slot);
-
 	while (p_slot && (p_slot->device != device)) {
 		tmp_slot = p_slot;
 		p_slot = p_slot->next;
-		dbg("In while loop, p_slot = %p\n", p_slot);
 	}
 	if (p_slot == NULL) {
 		err("ERROR: pciehp_find_slot device=0x%x\n", device);
@@ -228,7 +225,6 @@ static inline int wait_for_ctrl_irq(struct controller *ctrl)
 
 	DECLARE_WAITQUEUE(wait, current);
 
-	dbg("%s : start\n", __FUNCTION__);
 	add_wait_queue(&ctrl->queue, &wait);
 	if (!pciehp_poll_mode)
 		/* Sleep for up to 1 second */
@@ -240,7 +236,6 @@ static inline int wait_for_ctrl_irq(struct controller *ctrl)
 	if (signal_pending(current))
 		retval =  -EINTR;
 
-	dbg("%s : end\n", __FUNCTION__);
 	return retval;
 }
 

commit ed6cbcf2ac706aa47194fd2f7a99865cc06833d7
Author: rajesh.shah@intel.com <rajesh.shah@intel.com>
Date:   Mon Oct 31 16:20:09 2005 -0800

    [PATCH] pciehp: miscellaneous cleanups
    
    Remove un-necessary header includes, remove dead code, remove
    some hardcoded constants...
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 3e17e3d4dd65..314989a3a933 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -32,8 +32,6 @@
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
-#include <asm/semaphore.h>
-#include <asm/io.h>		
 #include <linux/pcieport_if.h>
 #include "pci_hotplug.h"
 
@@ -62,13 +60,7 @@ struct slot {
 	u8 device;
 	u16 status;
 	u32 number;
-	u8 is_a_board;
-	u8 configured;
 	u8 state;
-	u8 switch_save;
-	u8 presence_save;
-	u32 capabilities;
-	u16 reserved2;
 	struct timer_list task_event;
 	u8 hp_slot;
 	struct controller *ctrl;
@@ -82,27 +74,42 @@ struct event_info {
 	u8 hp_slot;
 };
 
+typedef u8(*php_intr_callback_t) (u8 hp_slot, void *instance_id);
+
+struct php_ctlr_state_s {
+	struct php_ctlr_state_s *pnext;
+	struct pci_dev *pci_dev;
+	unsigned int irq;
+	unsigned long flags;				/* spinlock's */
+	u32 slot_device_offset;
+	u32 num_slots;
+    	struct timer_list	int_poll_timer;		/* Added for poll event */
+	php_intr_callback_t 	attention_button_callback;
+	php_intr_callback_t 	switch_change_callback;
+	php_intr_callback_t 	presence_change_callback;
+	php_intr_callback_t 	power_fault_callback;
+	void 			*callback_instance_id;
+	struct ctrl_reg 	*creg;				/* Ptr to controller register space */
+};
+
+#define MAX_EVENTS		10
 struct controller {
 	struct controller *next;
 	struct semaphore crit_sect;	/* critical section semaphore */
-	void *hpc_ctlr_handle;		/* HPC controller handle */
+	struct php_ctlr_state_s *hpc_ctlr_handle; /* HPC controller handle */
 	int num_slots;			/* Number of slots on ctlr */
 	int slot_num_inc;		/* 1 or -1 */
 	struct pci_dev *pci_dev;
 	struct pci_bus *pci_bus;
-	struct event_info event_queue[10];
+	struct event_info event_queue[MAX_EVENTS];
 	struct slot *slot;
 	struct hpc_ops *hpc_ops;
 	wait_queue_head_t queue;	/* sleep & wake process */
 	u8 next_event;
-	u8 seg;
 	u8 bus;
 	u8 device;
 	u8 function;
-	u8 rev;
 	u8 slot_device_offset;
-	u8 add_support;
-	enum pci_bus_speed speed;
 	u32 first_slot;		/* First physical slot number */  /* PCIE only has 1 slot */
 	u8 slot_bus;		/* Bus where the slots handled by this controller sit */
 	u8 ctrlcap;
@@ -250,14 +257,7 @@ enum php_ctlr_type {
 	ACPI
 };
 
-typedef u8(*php_intr_callback_t) (unsigned int change_id, void *instance_id);
-
-int pcie_init(struct controller *ctrl, struct pcie_device *dev,
-		php_intr_callback_t attention_button_callback,
-		php_intr_callback_t switch_change_callback,
-		php_intr_callback_t presence_change_callback,
-		php_intr_callback_t power_fault_callback);
-
+int pcie_init(struct controller *ctrl, struct pcie_device *dev);
 
 /* This has no meaning for PCI Express, as there is only 1 slot per port */
 int pcie_get_ctlr_slot_config(struct controller *ctrl,

commit ca22a5e4d70620b7f3d809e424daa5214b0aa00d
Author: rajesh.shah@intel.com <rajesh.shah@intel.com>
Date:   Mon Oct 31 16:20:08 2005 -0800

    [PATCH] pciehp: remove redundant data structures
    
    State information is currently stored in per-slot as well as
    per-pci-function data structures in pciehp. There's a lot of
    overlap in the information kept, and some of it is never used.
    This patch consolidates the state information to per-slot and
    eliminates unused data structures. The biggest change is to
    eliminate the pci_func structure and the code around managing
    its lists.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index e9c09566f851..3e17e3d4dd65 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -56,25 +56,11 @@ struct hotplug_params {
 	u8 enable_perr;
 };
 
-struct pci_func {
-	struct pci_func *next;
-	u8 bus;
-	u8 device;
-	u8 function;
-	u8 is_a_board;
-	u16 status;
-	u8 configured;
-	u8 switch_save;
-	u8 presence_save;
-	u16 reserved2;
-	u32 config_space[0x20];
-	struct pci_dev* pci_dev;
-};
-
 struct slot {
 	struct slot *next;
 	u8 bus;
 	u8 device;
+	u16 status;
 	u32 number;
 	u8 is_a_board;
 	u8 configured;
@@ -177,9 +163,6 @@ struct controller {
  * error Messages
  */
 #define msg_initialization_err	"Initialization failure, error=%d\n"
-#define msg_HPC_rev_error	"Unsupported revision of the PCI hot plug controller found.\n"
-#define msg_HPC_non_pcie	"The PCI hot plug controller is not supported by this driver.\n"
-#define msg_HPC_not_supported	"This system is not supported by this version of pciephd module. Upgrade to a newer version of pciehpd\n"
 #define msg_button_on		"PCI slot #%d - powering on due to button press.\n"
 #define msg_button_off		"PCI slot #%d - powering off due to button press.\n"
 #define msg_button_cancel	"PCI slot #%d - action canceled due to button press.\n"
@@ -188,8 +171,6 @@ struct controller {
 /* controller functions */
 extern int	pciehp_event_start_thread	(void);
 extern void	pciehp_event_stop_thread	(void);
-extern struct 	pci_func *pciehp_slot_create	(unsigned char busnumber);
-extern struct 	pci_func *pciehp_slot_find	(unsigned char bus, unsigned char device, unsigned char index);
 extern int	pciehp_enable_slot		(struct slot *slot);
 extern int	pciehp_disable_slot		(struct slot *slot);
 
@@ -200,12 +181,8 @@ extern u8	pciehp_handle_power_fault	(u8 hp_slot, void *inst_id);
 /* extern void	long_delay (int delay); */
 
 /* pci functions */
-extern int	pciehp_set_irq			(u8 bus_num, u8 dev_num, u8 int_pin, u8 irq_num);
-/*extern int	pciehp_get_bus_dev		(struct controller *ctrl, u8 *bus_num, u8 *dev_num, struct slot *slot);*/
-extern int	pciehp_save_config	 	(struct controller *ctrl, int busnumber, int num_ctlr_slots, int first_device_num);
-extern int	pciehp_save_slot_config		(struct controller *ctrl, struct pci_func * new_slot);
-extern int	pciehp_configure_device		(struct slot *ctrl);
-extern int	pciehp_unconfigure_device	(struct pci_func* func);
+extern int	pciehp_configure_device		(struct slot *p_slot);
+extern int	pciehp_unconfigure_device	(struct slot *p_slot);
 extern int	get_hp_hw_control_from_firmware(struct pci_dev *dev);
 extern void	get_hp_params_from_firmware(struct pci_dev *dev,
 	       	struct hotplug_params *hpp);
@@ -214,7 +191,6 @@ extern void	get_hp_params_from_firmware(struct pci_dev *dev,
 
 /* Global variables */
 extern struct controller *pciehp_ctrl_list;
-extern struct pci_func *pciehp_slot_list[256];
 
 /* Inline functions */
 

commit a8a2be949267cb0d1d933a92d9fb43eda4f4fe88
Author: rajesh.shah@intel.com <rajesh.shah@intel.com>
Date:   Mon Oct 31 16:20:07 2005 -0800

    [PATCH] pciehp: reduce dependence on ACPI
    
    Reduce the PCI Express hotplug driver's dependence on ACPI.
    We don't walk the acpi namespace anymore to build a list of
    bridges and devices. We go to ACPI only to run the _OSC or
    _OSHP methods to transition control of hotplug hardware from
    system BIOS to the hotplug driver, and to run the _HPP
    method to get hotplug device parameters like cache line size,
    latency timer and SERR/PERR enable from BIOS.
    
    Note that one of the side effects of this patch is that pciehp
    does not automatically enable the hot-added device or its DMA
    bus mastering capability now. It expects the device driver to
    do that. This may break some drivers and we will have to fix
    them as they are reported.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index e9480ddd5abf..e9c09566f851 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -49,6 +49,13 @@ extern int pciehp_debug;
 #define info(format, arg...) printk(KERN_INFO "%s: " format, MY_NAME , ## arg)
 #define warn(format, arg...) printk(KERN_WARNING "%s: " format, MY_NAME , ## arg)
 
+struct hotplug_params {
+	u8 cache_line_size;
+	u8 latency_timer;
+	u8 enable_serr;
+	u8 enable_perr;
+};
+
 struct pci_func {
 	struct pci_func *next;
 	u8 bus;
@@ -199,6 +206,10 @@ extern int	pciehp_save_config	 	(struct controller *ctrl, int busnumber, int num
 extern int	pciehp_save_slot_config		(struct controller *ctrl, struct pci_func * new_slot);
 extern int	pciehp_configure_device		(struct slot *ctrl);
 extern int	pciehp_unconfigure_device	(struct pci_func* func);
+extern int	get_hp_hw_control_from_firmware(struct pci_dev *dev);
+extern void	get_hp_params_from_firmware(struct pci_dev *dev,
+	       	struct hotplug_params *hpp);
+
 
 
 /* Global variables */

commit 71b720c0f96145f5868c87591c286b290bc1a6af
Author: rajesh.shah@intel.com <rajesh.shah@intel.com>
Date:   Mon Oct 31 16:20:06 2005 -0800

    [PATCH] patch 1/8] pciehp: use the PCI core for hotplug resource management
    
    This patch converts the pci express hotplug controller driver
    to use the PCI core for resource management. This eliminates a
    lot of duplicated code and integrates pciehp with the system's
    normal PCI handling code.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 061ead21ef14..e9480ddd5abf 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -59,14 +59,8 @@ struct pci_func {
 	u8 configured;
 	u8 switch_save;
 	u8 presence_save;
-	u32 base_length[0x06];
-	u8 base_type[0x06];
 	u16 reserved2;
 	u32 config_space[0x20];
-	struct pci_resource *mem_head;
-	struct pci_resource *p_mem_head;
-	struct pci_resource *io_head;
-	struct pci_resource *bus_head;
 	struct pci_dev* pci_dev;
 };
 
@@ -90,12 +84,6 @@ struct slot {
 	struct list_head	slot_list;
 };
 
-struct pci_resource {
-	struct pci_resource * next;
-	u32 base;
-	u32 length;
-};
-
 struct event_info {
 	u32 event_type;
 	u8 hp_slot;
@@ -107,10 +95,6 @@ struct controller {
 	void *hpc_ctlr_handle;		/* HPC controller handle */
 	int num_slots;			/* Number of slots on ctlr */
 	int slot_num_inc;		/* 1 or -1 */
-	struct pci_resource *mem_head;
-	struct pci_resource *p_mem_head;
-	struct pci_resource *io_head;
-	struct pci_resource *bus_head;
 	struct pci_dev *pci_dev;
 	struct pci_bus *pci_bus;
 	struct event_info event_queue[10];
@@ -133,20 +117,6 @@ struct controller {
 	u8 cap_base;
 };
 
-struct irq_mapping {
-	u8 barber_pole;
-	u8 valid_INT;
-	u8 interrupt[4];
-};
-
-struct resource_lists {
-	struct pci_resource *mem_head;
-	struct pci_resource *p_mem_head;
-	struct pci_resource *io_head;
-	struct pci_resource *bus_head;
-	struct irq_mapping *irqs;
-};
-
 #define INT_BUTTON_IGNORE		0
 #define INT_PRESENCE_ON			1
 #define INT_PRESENCE_OFF		2
@@ -203,14 +173,12 @@ struct resource_lists {
 #define msg_HPC_rev_error	"Unsupported revision of the PCI hot plug controller found.\n"
 #define msg_HPC_non_pcie	"The PCI hot plug controller is not supported by this driver.\n"
 #define msg_HPC_not_supported	"This system is not supported by this version of pciephd module. Upgrade to a newer version of pciehpd\n"
-#define msg_unable_to_save	"Unable to store PCI hot plug add resource information. This system must be rebooted before adding any PCI devices.\n"
 #define msg_button_on		"PCI slot #%d - powering on due to button press.\n"
 #define msg_button_off		"PCI slot #%d - powering off due to button press.\n"
 #define msg_button_cancel	"PCI slot #%d - action canceled due to button press.\n"
 #define msg_button_ignore	"PCI slot #%d - button press ignored.  (action in progress...)\n"
 
 /* controller functions */
-extern int	pciehprm_find_available_resources	(struct controller *ctrl);
 extern int	pciehp_event_start_thread	(void);
 extern void	pciehp_event_stop_thread	(void);
 extern struct 	pci_func *pciehp_slot_create	(unsigned char busnumber);
@@ -224,19 +192,12 @@ extern u8	pciehp_handle_presence_change	(u8 hp_slot, void *inst_id);
 extern u8	pciehp_handle_power_fault	(u8 hp_slot, void *inst_id);
 /* extern void	long_delay (int delay); */
 
-/* resource functions */
-extern int	pciehp_resource_sort_and_combine	(struct pci_resource **head);
-
 /* pci functions */
 extern int	pciehp_set_irq			(u8 bus_num, u8 dev_num, u8 int_pin, u8 irq_num);
 /*extern int	pciehp_get_bus_dev		(struct controller *ctrl, u8 *bus_num, u8 *dev_num, struct slot *slot);*/
 extern int	pciehp_save_config	 	(struct controller *ctrl, int busnumber, int num_ctlr_slots, int first_device_num);
-extern int	pciehp_save_used_resources	(struct controller *ctrl, struct pci_func * func, int flag);
 extern int	pciehp_save_slot_config		(struct controller *ctrl, struct pci_func * new_slot);
-extern void	pciehp_destroy_board_resources	(struct pci_func * func);
-extern int	pciehp_return_board_resources	(struct pci_func * func, struct resource_lists * resources);
-extern void	pciehp_destroy_resource_list	(struct resource_lists * resources);
-extern int	pciehp_configure_device		(struct controller* ctrl, struct pci_func* func);
+extern int	pciehp_configure_device		(struct slot *ctrl);
 extern int	pciehp_unconfigure_device	(struct pci_func* func);
 
 
@@ -289,15 +250,6 @@ static inline int wait_for_ctrl_irq(struct controller *ctrl)
 	return retval;
 }
 
-/* Puts node back in the resource list pointed to by head */
-static inline void return_resource(struct pci_resource **head, struct pci_resource *node)
-{
-	if (!node || !head)
-		return;
-	node->next = *head;
-	*head = node;
-}
-
 #define SLOT_NAME_SIZE 10
 
 static inline void make_slot_name(char *buffer, int buffer_size, struct slot *slot)

commit 1248d636122e4ec9d7802b850904e3bb48a0da23
Author: Kristen Accardi <kristen.c.accardi@intel.com>
Date:   Fri Aug 5 12:16:06 2005 -0700

    [PATCH] PCI Hotplug: use bus_slot number for name
    
    For systems with multiple hotplug controllers, you need to use more than
    just the slot number to uniquely name the slot.  Without a unique slot
    name, the pci_hp_register() will fail.  This patch adds the bus number
    to the name.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 2b92b9e8c910..061ead21ef14 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -302,7 +302,7 @@ static inline void return_resource(struct pci_resource **head, struct pci_resour
 
 static inline void make_slot_name(char *buffer, int buffer_size, struct slot *slot)
 {
-	snprintf(buffer, buffer_size, "%d", slot->number);
+	snprintf(buffer, buffer_size, "%04d_%04d", slot->bus, slot->number);
 }
 
 enum php_ctlr_type {

commit 8cf4c19523b7694c88bba716d88fb659fa702411
Author: Kristen Accardi <kristen.c.accardi@intel.com>
Date:   Tue Aug 16 15:16:10 2005 -0700

    [PATCH] PCI Hotplug: new contact info
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 46b294a12418..2b92b9e8c910 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -23,7 +23,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * Send feedback to <greg@kroah.com>, <dely.l.sy@intel.com>
+ * Send feedback to <greg@kroah.com>, <kristen.c.accardi@intel.com>
  *
  */
 #ifndef _PCIEHP_H

commit 8b245e45f34280ec61e3c8d643d4613b9e0eb7a4
Author: Dely Sy <dlsy@snoqualmie.dp.intel.com>
Date:   Fri May 6 17:19:09 2005 -0700

    [PATCH] PCI Hotplug: get pciehp to work on the downstream port of a switch
    
    Here is the updated patch to get pciehp driver to work for downstream
    port of a switch and handle the difference in the offset value of PCI
    Express capability list item of different ports.
    
    Signed-off-by: Dely Sy <dely.l.sy@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index f313121d5141..46b294a12418 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -130,6 +130,7 @@ struct controller {
 	u8 slot_bus;		/* Bus where the slots handled by this controller sit */
 	u8 ctrlcap;
 	u16 vendor_id;
+	u8 cap_base;
 };
 
 struct irq_mapping {

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
new file mode 100644
index 000000000000..f313121d5141
--- /dev/null
+++ b/drivers/pci/hotplug/pciehp.h
@@ -0,0 +1,352 @@
+/*
+ * PCI Express Hot Plug Controller Driver
+ *
+ * Copyright (C) 1995,2001 Compaq Computer Corporation
+ * Copyright (C) 2001 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2001 IBM Corp.
+ * Copyright (C) 2003-2004 Intel Corporation
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Send feedback to <greg@kroah.com>, <dely.l.sy@intel.com>
+ *
+ */
+#ifndef _PCIEHP_H
+#define _PCIEHP_H
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <asm/semaphore.h>
+#include <asm/io.h>		
+#include <linux/pcieport_if.h>
+#include "pci_hotplug.h"
+
+#define MY_NAME	"pciehp"
+
+extern int pciehp_poll_mode;
+extern int pciehp_poll_time;
+extern int pciehp_debug;
+
+/*#define dbg(format, arg...) do { if (pciehp_debug) printk(KERN_DEBUG "%s: " format, MY_NAME , ## arg); } while (0)*/
+#define dbg(format, arg...) do { if (pciehp_debug) printk("%s: " format, MY_NAME , ## arg); } while (0)
+#define err(format, arg...) printk(KERN_ERR "%s: " format, MY_NAME , ## arg)
+#define info(format, arg...) printk(KERN_INFO "%s: " format, MY_NAME , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING "%s: " format, MY_NAME , ## arg)
+
+struct pci_func {
+	struct pci_func *next;
+	u8 bus;
+	u8 device;
+	u8 function;
+	u8 is_a_board;
+	u16 status;
+	u8 configured;
+	u8 switch_save;
+	u8 presence_save;
+	u32 base_length[0x06];
+	u8 base_type[0x06];
+	u16 reserved2;
+	u32 config_space[0x20];
+	struct pci_resource *mem_head;
+	struct pci_resource *p_mem_head;
+	struct pci_resource *io_head;
+	struct pci_resource *bus_head;
+	struct pci_dev* pci_dev;
+};
+
+struct slot {
+	struct slot *next;
+	u8 bus;
+	u8 device;
+	u32 number;
+	u8 is_a_board;
+	u8 configured;
+	u8 state;
+	u8 switch_save;
+	u8 presence_save;
+	u32 capabilities;
+	u16 reserved2;
+	struct timer_list task_event;
+	u8 hp_slot;
+	struct controller *ctrl;
+	struct hpc_ops *hpc_ops;
+	struct hotplug_slot *hotplug_slot;
+	struct list_head	slot_list;
+};
+
+struct pci_resource {
+	struct pci_resource * next;
+	u32 base;
+	u32 length;
+};
+
+struct event_info {
+	u32 event_type;
+	u8 hp_slot;
+};
+
+struct controller {
+	struct controller *next;
+	struct semaphore crit_sect;	/* critical section semaphore */
+	void *hpc_ctlr_handle;		/* HPC controller handle */
+	int num_slots;			/* Number of slots on ctlr */
+	int slot_num_inc;		/* 1 or -1 */
+	struct pci_resource *mem_head;
+	struct pci_resource *p_mem_head;
+	struct pci_resource *io_head;
+	struct pci_resource *bus_head;
+	struct pci_dev *pci_dev;
+	struct pci_bus *pci_bus;
+	struct event_info event_queue[10];
+	struct slot *slot;
+	struct hpc_ops *hpc_ops;
+	wait_queue_head_t queue;	/* sleep & wake process */
+	u8 next_event;
+	u8 seg;
+	u8 bus;
+	u8 device;
+	u8 function;
+	u8 rev;
+	u8 slot_device_offset;
+	u8 add_support;
+	enum pci_bus_speed speed;
+	u32 first_slot;		/* First physical slot number */  /* PCIE only has 1 slot */
+	u8 slot_bus;		/* Bus where the slots handled by this controller sit */
+	u8 ctrlcap;
+	u16 vendor_id;
+};
+
+struct irq_mapping {
+	u8 barber_pole;
+	u8 valid_INT;
+	u8 interrupt[4];
+};
+
+struct resource_lists {
+	struct pci_resource *mem_head;
+	struct pci_resource *p_mem_head;
+	struct pci_resource *io_head;
+	struct pci_resource *bus_head;
+	struct irq_mapping *irqs;
+};
+
+#define INT_BUTTON_IGNORE		0
+#define INT_PRESENCE_ON			1
+#define INT_PRESENCE_OFF		2
+#define INT_SWITCH_CLOSE		3
+#define INT_SWITCH_OPEN			4
+#define INT_POWER_FAULT			5
+#define INT_POWER_FAULT_CLEAR		6
+#define INT_BUTTON_PRESS		7
+#define INT_BUTTON_RELEASE		8
+#define INT_BUTTON_CANCEL		9
+
+#define STATIC_STATE			0
+#define BLINKINGON_STATE		1
+#define BLINKINGOFF_STATE		2
+#define POWERON_STATE			3
+#define POWEROFF_STATE			4
+
+#define PCI_TO_PCI_BRIDGE_CLASS		0x00060400
+
+/* Error messages */
+#define INTERLOCK_OPEN			0x00000002
+#define ADD_NOT_SUPPORTED		0x00000003
+#define CARD_FUNCTIONING		0x00000005
+#define ADAPTER_NOT_SAME		0x00000006
+#define NO_ADAPTER_PRESENT		0x00000009
+#define NOT_ENOUGH_RESOURCES		0x0000000B
+#define DEVICE_TYPE_NOT_SUPPORTED	0x0000000C
+#define WRONG_BUS_FREQUENCY		0x0000000D
+#define POWER_FAILURE			0x0000000E
+
+#define REMOVE_NOT_SUPPORTED		0x00000003
+
+#define DISABLE_CARD			1
+
+/* Field definitions in Slot Capabilities Register */
+#define ATTN_BUTTN_PRSN	0x00000001
+#define	PWR_CTRL_PRSN	0x00000002
+#define MRL_SENS_PRSN	0x00000004
+#define ATTN_LED_PRSN	0x00000008
+#define PWR_LED_PRSN	0x00000010
+#define HP_SUPR_RM_SUP	0x00000020
+
+#define ATTN_BUTTN(cap)		(cap & ATTN_BUTTN_PRSN)
+#define POWER_CTRL(cap)		(cap & PWR_CTRL_PRSN)
+#define MRL_SENS(cap)		(cap & MRL_SENS_PRSN)
+#define ATTN_LED(cap)		(cap & ATTN_LED_PRSN)
+#define PWR_LED(cap)		(cap & PWR_LED_PRSN) 
+#define HP_SUPR_RM(cap)		(cap & HP_SUPR_RM_SUP)
+
+/*
+ * error Messages
+ */
+#define msg_initialization_err	"Initialization failure, error=%d\n"
+#define msg_HPC_rev_error	"Unsupported revision of the PCI hot plug controller found.\n"
+#define msg_HPC_non_pcie	"The PCI hot plug controller is not supported by this driver.\n"
+#define msg_HPC_not_supported	"This system is not supported by this version of pciephd module. Upgrade to a newer version of pciehpd\n"
+#define msg_unable_to_save	"Unable to store PCI hot plug add resource information. This system must be rebooted before adding any PCI devices.\n"
+#define msg_button_on		"PCI slot #%d - powering on due to button press.\n"
+#define msg_button_off		"PCI slot #%d - powering off due to button press.\n"
+#define msg_button_cancel	"PCI slot #%d - action canceled due to button press.\n"
+#define msg_button_ignore	"PCI slot #%d - button press ignored.  (action in progress...)\n"
+
+/* controller functions */
+extern int	pciehprm_find_available_resources	(struct controller *ctrl);
+extern int	pciehp_event_start_thread	(void);
+extern void	pciehp_event_stop_thread	(void);
+extern struct 	pci_func *pciehp_slot_create	(unsigned char busnumber);
+extern struct 	pci_func *pciehp_slot_find	(unsigned char bus, unsigned char device, unsigned char index);
+extern int	pciehp_enable_slot		(struct slot *slot);
+extern int	pciehp_disable_slot		(struct slot *slot);
+
+extern u8	pciehp_handle_attention_button	(u8 hp_slot, void *inst_id);
+extern u8	pciehp_handle_switch_change	(u8 hp_slot, void *inst_id);
+extern u8	pciehp_handle_presence_change	(u8 hp_slot, void *inst_id);
+extern u8	pciehp_handle_power_fault	(u8 hp_slot, void *inst_id);
+/* extern void	long_delay (int delay); */
+
+/* resource functions */
+extern int	pciehp_resource_sort_and_combine	(struct pci_resource **head);
+
+/* pci functions */
+extern int	pciehp_set_irq			(u8 bus_num, u8 dev_num, u8 int_pin, u8 irq_num);
+/*extern int	pciehp_get_bus_dev		(struct controller *ctrl, u8 *bus_num, u8 *dev_num, struct slot *slot);*/
+extern int	pciehp_save_config	 	(struct controller *ctrl, int busnumber, int num_ctlr_slots, int first_device_num);
+extern int	pciehp_save_used_resources	(struct controller *ctrl, struct pci_func * func, int flag);
+extern int	pciehp_save_slot_config		(struct controller *ctrl, struct pci_func * new_slot);
+extern void	pciehp_destroy_board_resources	(struct pci_func * func);
+extern int	pciehp_return_board_resources	(struct pci_func * func, struct resource_lists * resources);
+extern void	pciehp_destroy_resource_list	(struct resource_lists * resources);
+extern int	pciehp_configure_device		(struct controller* ctrl, struct pci_func* func);
+extern int	pciehp_unconfigure_device	(struct pci_func* func);
+
+
+/* Global variables */
+extern struct controller *pciehp_ctrl_list;
+extern struct pci_func *pciehp_slot_list[256];
+
+/* Inline functions */
+
+static inline struct slot *pciehp_find_slot(struct controller *ctrl, u8 device)
+{
+	struct slot *p_slot, *tmp_slot = NULL;
+
+	p_slot = ctrl->slot;
+
+	dbg("p_slot = %p\n", p_slot);
+
+	while (p_slot && (p_slot->device != device)) {
+		tmp_slot = p_slot;
+		p_slot = p_slot->next;
+		dbg("In while loop, p_slot = %p\n", p_slot);
+	}
+	if (p_slot == NULL) {
+		err("ERROR: pciehp_find_slot device=0x%x\n", device);
+		p_slot = tmp_slot;
+	}
+
+	return p_slot;
+}
+
+static inline int wait_for_ctrl_irq(struct controller *ctrl)
+{
+	int retval = 0;
+
+	DECLARE_WAITQUEUE(wait, current);
+
+	dbg("%s : start\n", __FUNCTION__);
+	add_wait_queue(&ctrl->queue, &wait);
+	if (!pciehp_poll_mode)
+		/* Sleep for up to 1 second */
+		msleep_interruptible(1000);
+	else
+		msleep_interruptible(2500);
+	
+	remove_wait_queue(&ctrl->queue, &wait);
+	if (signal_pending(current))
+		retval =  -EINTR;
+
+	dbg("%s : end\n", __FUNCTION__);
+	return retval;
+}
+
+/* Puts node back in the resource list pointed to by head */
+static inline void return_resource(struct pci_resource **head, struct pci_resource *node)
+{
+	if (!node || !head)
+		return;
+	node->next = *head;
+	*head = node;
+}
+
+#define SLOT_NAME_SIZE 10
+
+static inline void make_slot_name(char *buffer, int buffer_size, struct slot *slot)
+{
+	snprintf(buffer, buffer_size, "%d", slot->number);
+}
+
+enum php_ctlr_type {
+	PCI,
+	ISA,
+	ACPI
+};
+
+typedef u8(*php_intr_callback_t) (unsigned int change_id, void *instance_id);
+
+int pcie_init(struct controller *ctrl, struct pcie_device *dev,
+		php_intr_callback_t attention_button_callback,
+		php_intr_callback_t switch_change_callback,
+		php_intr_callback_t presence_change_callback,
+		php_intr_callback_t power_fault_callback);
+
+
+/* This has no meaning for PCI Express, as there is only 1 slot per port */
+int pcie_get_ctlr_slot_config(struct controller *ctrl,
+		int *num_ctlr_slots,
+		int *first_device_num,
+		int *physical_slot_num,
+		u8 *ctrlcap);
+
+struct hpc_ops {
+	int	(*power_on_slot)	(struct slot *slot);
+	int	(*power_off_slot)	(struct slot *slot);
+	int	(*get_power_status)	(struct slot *slot, u8 *status);
+	int	(*get_attention_status)	(struct slot *slot, u8 *status);
+	int	(*set_attention_status)	(struct slot *slot, u8 status);
+	int	(*get_latch_status)	(struct slot *slot, u8 *status);
+	int	(*get_adapter_status)	(struct slot *slot, u8 *status);
+
+	int	(*get_max_bus_speed)	(struct slot *slot, enum pci_bus_speed *speed);
+	int	(*get_cur_bus_speed)	(struct slot *slot, enum pci_bus_speed *speed);
+
+	int	(*get_max_lnk_width)	(struct slot *slot, enum pcie_link_width *value);
+	int	(*get_cur_lnk_width)	(struct slot *slot, enum pcie_link_width *value);
+	
+	int	(*query_power_fault)	(struct slot *slot);
+	void	(*green_led_on)		(struct slot *slot);
+	void	(*green_led_off)	(struct slot *slot);
+	void	(*green_led_blink)	(struct slot *slot);
+	void	(*release_ctlr)		(struct controller *ctrl);
+	int	(*check_lnk_status)	(struct controller *ctrl);
+};
+
+#endif				/* _PCIEHP_H */
