commit d09ddd8190fbdc07696bf34b548ae15aa1816714
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Apr 21 18:22:56 2020 +0200

    PCI: Allow pci_resize_resource() for devices on root bus
    
    When resizing a BAR, pci_reassign_bridge_resources() is invoked to bring
    the bridge windows of parent bridges in line with the new BAR assignment.
    
    This assumes the device whose BAR is being resized lives on a subordinate
    bus, but this is not necessarily the case. A device may live on the root
    bus, in which case dev->bus->self is NULL, and passing a NULL pci_dev
    pointer to pci_reassign_bridge_resources() will cause it to crash.
    
    So let's make the call to pci_reassign_bridge_resources() conditional on
    whether dev->bus->self is non-NULL in the first place.
    
    Fixes: 8bb705e3e79d84e7 ("PCI: Add pci_resize_resource() for resizing BARs")
    Link: https://lore.kernel.org/r/20200421162256.26887-1-ardb@kernel.org
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index d8ca40a97693..d21fa04fa44d 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -439,10 +439,11 @@ int pci_resize_resource(struct pci_dev *dev, int resno, int size)
 	res->end = res->start + pci_rebar_size_to_bytes(size) - 1;
 
 	/* Check if the new config works by trying to assign everything. */
-	ret = pci_reassign_bridge_resources(dev->bus->self, res->flags);
-	if (ret)
-		goto error_resize;
-
+	if (dev->bus->self) {
+		ret = pci_reassign_bridge_resources(dev->bus->self, res->flags);
+		if (ret)
+			goto error_resize;
+	}
 	return 0;
 
 error_resize:

commit adf58458bcb2890efe94e5a58506c27bfecf518d
Author: Desnes A. Nunes do Rosario <desnesn@linux.vnet.ibm.com>
Date:   Tue Apr 10 14:51:06 2018 -0500

    PCI: Remove messages about reassigning resources
    
    When reassigning device resources to increase their alignment, e.g.,
    because of a "pci=resource_alignment=" kernel parameter or because the
    platform aligns resources to its page size, we previously emitted messages
    like this:
    
      pci 0000:00:00.0: Disabling memory decoding and releasing memory resources
      pci 0000:00:00.0: disabling bridge mem windows
    
    These messages don't convey any useful information, so remove them.
    
    Fixes: 38274637699 ("powerpc/powernv: Override pcibios_default_alignment() to force PCI devices to be page aligned")
    Signed-off-by: Desnes A. Nunes do Rosario <desnesn@linux.vnet.ibm.com>
    [bhelgaas: changelog]
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 0cd83a4bd4c8..d8ca40a97693 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -168,8 +168,6 @@ EXPORT_SYMBOL(pci_claim_resource);
 
 void pci_disable_bridge_window(struct pci_dev *dev)
 {
-	pci_info(dev, "disabling bridge mem windows\n");
-
 	/* MMIO Base/Limit */
 	pci_write_config_dword(dev, PCI_MEMORY_BASE, 0x0000fff0);
 

commit 3c0d551e02b2590fa71a1354f2f1994551a33315
Merge: 19fd08b85bc7 5f7644190986
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 6 18:31:06 2018 -0700

    Merge tag 'pci-v4.17-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - move pci_uevent_ers() out of pci.h (Michael Ellerman)
    
     - skip ASPM common clock warning if BIOS already configured it (Sinan
       Kaya)
    
     - fix ASPM Coverity warning about threshold_ns (Gustavo A. R. Silva)
    
     - remove last user of pci_get_bus_and_slot() and the function itself
       (Sinan Kaya)
    
     - add decoding for 16 GT/s link speed (Jay Fang)
    
     - add interfaces to get max link speed and width (Tal Gilboa)
    
     - add pcie_bandwidth_capable() to compute max supported link bandwidth
       (Tal Gilboa)
    
     - add pcie_bandwidth_available() to compute bandwidth available to
       device (Tal Gilboa)
    
     - add pcie_print_link_status() to log link speed and whether it's
       limited (Tal Gilboa)
    
     - use PCI core interfaces to report when device performance may be
       limited by its slot instead of doing it in each driver (Tal Gilboa)
    
     - fix possible cpqphp NULL pointer dereference (Shawn Lin)
    
     - rescan more of the hierarchy on ACPI hotplug to fix Thunderbolt/xHCI
       hotplug (Mika Westerberg)
    
     - add support for PCI I/O port space that's neither directly accessible
       via CPU in/out instructions nor directly mapped into CPU physical
       memory space. This is fairly intrusive and includes minor changes to
       interfaces used for I/O space on most platforms (Zhichang Yuan, John
       Garry)
    
     - add support for HiSilicon Hip06/Hip07 LPC I/O space (Zhichang Yuan,
       John Garry)
    
     - use PCI_EXP_DEVCTL2_COMP_TIMEOUT in rapidio/tsi721 (Bjorn Helgaas)
    
     - remove possible NULL pointer dereference in of_pci_bus_find_domain_nr()
       (Shawn Lin)
    
     - report quirk timings with dev_info (Bjorn Helgaas)
    
     - report quirks that take longer than 10ms (Bjorn Helgaas)
    
     - add and use Altera Vendor ID (Johannes Thumshirn)
    
     - tidy Makefiles and comments (Bjorn Helgaas)
    
     - don't set up INTx if MSI or MSI-X is enabled to align cris, frv,
       ia64, and mn10300 with x86 (Bjorn Helgaas)
    
     - move pcieport_if.h to drivers/pci/pcie/ to encapsulate it (Frederick
       Lawler)
    
     - merge pcieport_if.h into portdrv.h (Bjorn Helgaas)
    
     - move workaround for BIOS PME issue from portdrv to PCI core (Bjorn
       Helgaas)
    
     - completely disable portdrv with "pcie_ports=compat" (Bjorn Helgaas)
    
     - remove portdrv link order dependency (Bjorn Helgaas)
    
     - remove support for unused VC portdrv service (Bjorn Helgaas)
    
     - simplify portdrv feature permission checking (Bjorn Helgaas)
    
     - remove "pcie_hp=nomsi" parameter (use "pci=nomsi" instead) (Bjorn
       Helgaas)
    
     - remove unnecessary "pcie_ports=auto" parameter (Bjorn Helgaas)
    
     - use cached AER capability offset (Frederick Lawler)
    
     - don't enable DPC if BIOS hasn't granted AER control (Mika Westerberg)
    
     - rename pcie-dpc.c to dpc.c (Bjorn Helgaas)
    
     - use generic pci_mmap_resource_range() instead of powerpc and xtensa
       arch-specific versions (David Woodhouse)
    
     - support arbitrary PCI host bridge offsets on sparc (Yinghai Lu)
    
     - remove System and Video ROM reservations on sparc (Bjorn Helgaas)
    
     - probe for device reset support during enumeration instead of runtime
       (Bjorn Helgaas)
    
     - add ACS quirk for Ampere (née APM) root ports (Feng Kan)
    
     - add function 1 DMA alias quirk for Marvell 88SE9220 (Thomas
       Vincent-Cross)
    
     - protect device restore with device lock (Sinan Kaya)
    
     - handle failure of FLR gracefully (Sinan Kaya)
    
     - handle CRS (config retry status) after device resets (Sinan Kaya)
    
     - skip various config reads for SR-IOV VFs as an optimization
       (KarimAllah Ahmed)
    
     - consolidate VPD code in vpd.c (Bjorn Helgaas)
    
     - add Tegra dependency on PCI_MSI_IRQ_DOMAIN (Arnd Bergmann)
    
     - add DT support for R-Car r8a7743 (Biju Das)
    
     - fix a PCI_EJECT vs PCI_BUS_RELATIONS race condition in Hyper-V host
       bridge driver that causes a general protection fault (Dexuan Cui)
    
     - fix Hyper-V host bridge hang in MSI setup on 1-vCPU VMs with SR-IOV
       (Dexuan Cui)
    
     - fix Hyper-V host bridge hang when ejecting a VF before setting up MSI
       (Dexuan Cui)
    
     - make several structures static (Fengguang Wu)
    
     - increase number of MSI IRQs supported by Synopsys DesignWare bridges
       from 32 to 256 (Gustavo Pimentel)
    
     - implemented multiplexed IRQ domain API and remove obsolete MSI IRQ
       API from DesignWare drivers (Gustavo Pimentel)
    
     - add Tegra power management support (Manikanta Maddireddy)
    
     - add Tegra loadable module support (Manikanta Maddireddy)
    
     - handle 64-bit BARs correctly in endpoint support (Niklas Cassel)
    
     - support optional regulator for HiSilicon STB (Shawn Guo)
    
     - use regulator bulk API for Qualcomm apq8064 (Srinivas Kandagatla)
    
     - support power supplies for Qualcomm msm8996 (Srinivas Kandagatla)
    
    * tag 'pci-v4.17-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (123 commits)
      MAINTAINERS: Add John Garry as maintainer for HiSilicon LPC driver
      HISI LPC: Add ACPI support
      ACPI / scan: Do not enumerate Indirect IO host children
      ACPI / scan: Rename acpi_is_serial_bus_slave() for more general use
      HISI LPC: Support the LPC host on Hip06/Hip07 with DT bindings
      of: Add missing I/O range exception for indirect-IO devices
      PCI: Apply the new generic I/O management on PCI IO hosts
      PCI: Add fwnode handler as input param of pci_register_io_range()
      PCI: Remove __weak tag from pci_register_io_range()
      MAINTAINERS: Add missing /drivers/pci/cadence directory entry
      fm10k: Report PCIe link properties with pcie_print_link_status()
      net/mlx5e: Use pcie_bandwidth_available() to compute bandwidth
      net/mlx5: Report PCIe link properties with pcie_print_link_status()
      net/mlx4_core: Report PCIe link properties with pcie_print_link_status()
      PCI: Add pcie_print_link_status() to log link speed and whether it's limited
      PCI: Add pcie_bandwidth_available() to compute bandwidth available to device
      misc: pci_endpoint_test: Handle 64-bit BARs properly
      PCI: designware-ep: Make dw_pcie_ep_reset_bar() handle 64-bit BARs properly
      PCI: endpoint: Make sure that BAR_5 does not have 64-bit flag set when clearing
      PCI: endpoint: Make epc->ops->clear_bar()/pci_epc_clear_bar() take struct *epf_bar
      ...

commit df62ab5e0f75608919df7442654b0fab78246b7b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 16:36:33 2018 -0600

    PCI: Tidy comments
    
    Remove pointless comments that tell us the file name, remove blank line
    comments, follow multi-line comment conventions.  No functional change
    intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 369d48d6c6f1..1ef01d79b52e 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -1,18 +1,14 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- *	drivers/pci/setup-res.c
+ * Support routines for initializing a PCI subsystem
  *
  * Extruded from code written by
  *      Dave Rusling (david.rusling@reo.mts.dec.com)
  *      David Mosberger (davidm@cs.arizona.edu)
  *	David Miller (davem@redhat.com)
  *
- * Support routines for initializing a PCI subsystem.
- */
-
-/* fixed for multiple pci buses, 1999 Andrea Arcangeli <andrea@suse.de> */
-
-/*
+ * Fixed for multiple PCI buses, 1999 Andrea Arcangeli <andrea@suse.de>
+ *
  * Nov 2000, Ivan Kokshaysky <ink@jurassic.park.msu.ru>
  *	     Resource sorting
  */

commit c37406e05d1e541df40b8b81c4bd40753fcaf414
Author: Christian König <ckoenig.leichtzumerken@gmail.com>
Date:   Mon Feb 26 14:51:13 2018 -0600

    PCI: Allow release of resources that were never assigned
    
    It is entirely possible that the BIOS wasn't able to assign resources to a
    device. In this case don't crash in pci_release_resource() when we try to
    resize the resource.
    
    Fixes: 8bb705e3e79d ("PCI: Add pci_resize_resource() for resizing BARs")
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    CC: stable@vger.kernel.org      # v4.15+

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 369d48d6c6f1..365447240d95 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -401,6 +401,10 @@ void pci_release_resource(struct pci_dev *dev, int resno)
 	struct resource *res = dev->resource + resno;
 
 	pci_info(dev, "BAR %d: releasing %pR\n", resno, res);
+
+	if (!res->parent)
+		return;
+
 	release_resource(res);
 	res->end = resource_size(res) - 1;
 	res->start = 0;

commit 7506dc7989933235e6fc23f3d0516bdbf0f7d1a8
Author: Frederick Lawler <fred@fredlawl.com>
Date:   Thu Jan 18 12:55:24 2018 -0600

    PCI: Add wrappers for dev_printk()
    
    Add PCI-specific dev_printk() wrappers and use them to simplify the code
    slightly.  No functional change intended.
    
    Signed-off-by: Frederick Lawler <fred@fredlawl.com>
    [bhelgaas: squash into one patch]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index e815111f3f81..369d48d6c6f1 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -103,7 +103,7 @@ static void pci_std_update_resource(struct pci_dev *dev, int resno)
 	pci_read_config_dword(dev, reg, &check);
 
 	if ((new ^ check) & mask) {
-		dev_err(&dev->dev, "BAR %d: error updating (%#08x != %#08x)\n",
+		pci_err(dev, "BAR %d: error updating (%#08x != %#08x)\n",
 			resno, new, check);
 	}
 
@@ -112,7 +112,7 @@ static void pci_std_update_resource(struct pci_dev *dev, int resno)
 		pci_write_config_dword(dev, reg + 4, new);
 		pci_read_config_dword(dev, reg + 4, &check);
 		if (check != new) {
-			dev_err(&dev->dev, "BAR %d: error updating (high %#08x != %#08x)\n",
+			pci_err(dev, "BAR %d: error updating (high %#08x != %#08x)\n",
 				resno, new, check);
 		}
 	}
@@ -137,7 +137,7 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 	struct resource *root, *conflict;
 
 	if (res->flags & IORESOURCE_UNSET) {
-		dev_info(&dev->dev, "can't claim BAR %d %pR: no address assigned\n",
+		pci_info(dev, "can't claim BAR %d %pR: no address assigned\n",
 			 resource, res);
 		return -EINVAL;
 	}
@@ -152,7 +152,7 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 
 	root = pci_find_parent_resource(dev, res);
 	if (!root) {
-		dev_info(&dev->dev, "can't claim BAR %d %pR: no compatible bridge window\n",
+		pci_info(dev, "can't claim BAR %d %pR: no compatible bridge window\n",
 			 resource, res);
 		res->flags |= IORESOURCE_UNSET;
 		return -EINVAL;
@@ -160,7 +160,7 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 
 	conflict = request_resource_conflict(root, res);
 	if (conflict) {
-		dev_info(&dev->dev, "can't claim BAR %d %pR: address conflict with %s %pR\n",
+		pci_info(dev, "can't claim BAR %d %pR: address conflict with %s %pR\n",
 			 resource, res, conflict->name, conflict);
 		res->flags |= IORESOURCE_UNSET;
 		return -EBUSY;
@@ -172,7 +172,7 @@ EXPORT_SYMBOL(pci_claim_resource);
 
 void pci_disable_bridge_window(struct pci_dev *dev)
 {
-	dev_info(&dev->dev, "disabling bridge mem windows\n");
+	pci_info(dev, "disabling bridge mem windows\n");
 
 	/* MMIO Base/Limit */
 	pci_write_config_dword(dev, PCI_MEMORY_BASE, 0x0000fff0);
@@ -221,11 +221,11 @@ static int pci_revert_fw_address(struct resource *res, struct pci_dev *dev,
 			root = &iomem_resource;
 	}
 
-	dev_info(&dev->dev, "BAR %d: trying firmware assignment %pR\n",
+	pci_info(dev, "BAR %d: trying firmware assignment %pR\n",
 		 resno, res);
 	conflict = request_resource_conflict(root, res);
 	if (conflict) {
-		dev_info(&dev->dev, "BAR %d: %pR conflicts with %s %pR\n",
+		pci_info(dev, "BAR %d: %pR conflicts with %s %pR\n",
 			 resno, res, conflict->name, conflict);
 		res->start = start;
 		res->end = end;
@@ -324,7 +324,7 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	res->flags |= IORESOURCE_UNSET;
 	align = pci_resource_alignment(dev, res);
 	if (!align) {
-		dev_info(&dev->dev, "BAR %d: can't assign %pR (bogus alignment)\n",
+		pci_info(dev, "BAR %d: can't assign %pR (bogus alignment)\n",
 			 resno, res);
 		return -EINVAL;
 	}
@@ -338,19 +338,18 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	 * working, which is better than just leaving it disabled.
 	 */
 	if (ret < 0) {
-		dev_info(&dev->dev, "BAR %d: no space for %pR\n", resno, res);
+		pci_info(dev, "BAR %d: no space for %pR\n", resno, res);
 		ret = pci_revert_fw_address(res, dev, resno, size);
 	}
 
 	if (ret < 0) {
-		dev_info(&dev->dev, "BAR %d: failed to assign %pR\n", resno,
-			 res);
+		pci_info(dev, "BAR %d: failed to assign %pR\n", resno, res);
 		return ret;
 	}
 
 	res->flags &= ~IORESOURCE_UNSET;
 	res->flags &= ~IORESOURCE_STARTALIGN;
-	dev_info(&dev->dev, "BAR %d: assigned %pR\n", resno, res);
+	pci_info(dev, "BAR %d: assigned %pR\n", resno, res);
 	if (resno < PCI_BRIDGE_RESOURCES)
 		pci_update_resource(dev, resno);
 
@@ -372,7 +371,7 @@ int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsiz
 	flags = res->flags;
 	res->flags |= IORESOURCE_UNSET;
 	if (!res->parent) {
-		dev_info(&dev->dev, "BAR %d: can't reassign an unassigned resource %pR\n",
+		pci_info(dev, "BAR %d: can't reassign an unassigned resource %pR\n",
 			 resno, res);
 		return -EINVAL;
 	}
@@ -382,14 +381,14 @@ int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsiz
 	ret = _pci_assign_resource(dev, resno, new_size, min_align);
 	if (ret) {
 		res->flags = flags;
-		dev_info(&dev->dev, "BAR %d: %pR (failed to expand by %#llx)\n",
+		pci_info(dev, "BAR %d: %pR (failed to expand by %#llx)\n",
 			 resno, res, (unsigned long long) addsize);
 		return ret;
 	}
 
 	res->flags &= ~IORESOURCE_UNSET;
 	res->flags &= ~IORESOURCE_STARTALIGN;
-	dev_info(&dev->dev, "BAR %d: reassigned %pR (expanded by %#llx)\n",
+	pci_info(dev, "BAR %d: reassigned %pR (expanded by %#llx)\n",
 		 resno, res, (unsigned long long) addsize);
 	if (resno < PCI_BRIDGE_RESOURCES)
 		pci_update_resource(dev, resno);
@@ -401,7 +400,7 @@ void pci_release_resource(struct pci_dev *dev, int resno)
 {
 	struct resource *res = dev->resource + resno;
 
-	dev_info(&dev->dev, "BAR %d: releasing %pR\n", resno, res);
+	pci_info(dev, "BAR %d: releasing %pR\n", resno, res);
 	release_resource(res);
 	res->end = resource_size(res) - 1;
 	res->start = 0;
@@ -477,13 +476,13 @@ int pci_enable_resources(struct pci_dev *dev, int mask)
 			continue;
 
 		if (r->flags & IORESOURCE_UNSET) {
-			dev_err(&dev->dev, "can't enable device: BAR %d %pR not assigned\n",
+			pci_err(dev, "can't enable device: BAR %d %pR not assigned\n",
 				i, r);
 			return -EINVAL;
 		}
 
 		if (!r->parent) {
-			dev_err(&dev->dev, "can't enable device: BAR %d %pR not claimed\n",
+			pci_err(dev, "can't enable device: BAR %d %pR not claimed\n",
 				i, r);
 			return -EINVAL;
 		}
@@ -495,8 +494,7 @@ int pci_enable_resources(struct pci_dev *dev, int mask)
 	}
 
 	if (cmd != old_cmd) {
-		dev_info(&dev->dev, "enabling device (%04x -> %04x)\n",
-			 old_cmd, cmd);
+		pci_info(dev, "enabling device (%04x -> %04x)\n", old_cmd, cmd);
 		pci_write_config_word(dev, PCI_COMMAND, cmd);
 	}
 	return 0;

commit 1b6115fbe3b3db746d7baa11399dd617fc75e1c4
Merge: ad0835a93008 91f3140fdef6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 15 15:01:28 2017 -0800

    Merge tag 'pci-v4.15-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
      - detach driver before tearing down procfs/sysfs (Alex Williamson)
    
      - disable PCIe services during shutdown (Sinan Kaya)
    
      - fix ASPM oops on systems with no Root Ports (Ard Biesheuvel)
    
      - fix ASPM LTR_L1.2_THRESHOLD programming (Bjorn Helgaas)
    
      - fix ASPM Common_Mode_Restore_Time computation (Bjorn Helgaas)
    
      - fix portdrv MSI/MSI-X vector allocation (Dongdong Liu, Bjorn
        Helgaas)
    
      - report non-fatal AER errors only to the affected endpoint (Gabriele
        Paoloni)
    
      - distribute bus numbers, MMIO, and I/O space among hotplug bridges to
        allow more devices to be hot-added (Mika Westerberg)
    
      - fix pciehp races during initialization and surprise link down (Mika
        Westerberg)
    
      - handle surprise-removed devices in PME handling (Qiang)
    
      - support resizable BARs for large graphics devices (Christian König)
    
      - expose SR-IOV offset, stride, and VF device ID via sysfs (Filippo
        Sironi)
    
      - create SR-IOV virtfn/physfn sysfs links before attaching driver
        (Stuart Hayes)
    
      - fix SR-IOV "ARI Capable Hierarchy" restore issue (Tony Nguyen)
    
      - enforce Kconfig IOV/REALLOC dependency (Sascha El-Sharkawy)
    
      - avoid slot reset if bridge itself is broken (Jan Glauber)
    
      - clean up pci_reset_function() path (Jan H. Schönherr)
    
      - make pci_map_rom() fail if the option ROM is invalid (Changbin Du)
    
      - convert timers to timer_setup() (Kees Cook)
    
      - move PCI_QUIRKS to PCI bus Kconfig menu (Randy Dunlap)
    
      - constify pci_dev_type and intel_mid_pci_ops (Bhumika Goyal)
    
      - remove unnecessary pci_dev, pci_bus, resource, pcibios_set_master()
        declarations (Bjorn Helgaas)
    
      - fix endpoint framework overflows and BUG()s (Dan Carpenter)
    
      - fix endpoint framework issues (Kishon Vijay Abraham I)
    
      - avoid broken Cavium CN8xxx bus reset behavior (David Daney)
    
      - extend Cavium ACS capability quirks (Vadim Lomovtsev)
    
      - support Synopsys DesignWare RC in ECAM mode (Ard Biesheuvel)
    
      - turn off dra7xx clocks cleanly on shutdown (Keerthy)
    
      - fix Faraday probe error path (Wei Yongjun)
    
      - support HiSilicon STB SoC PCIe host controller (Jianguo Sun)
    
      - fix Hyper-V interrupt affinity issue (Dexuan Cui)
    
      - remove useless ACPI warning for Hyper-V pass-through devices (Vitaly
        Kuznetsov)
    
      - support multiple MSI on iProc (Sandor Bodo-Merle)
    
      - support Layerscape LS1012a and LS1046a PCIe host controllers (Hou
        Zhiqiang)
    
      - fix Layerscape default error response (Minghuan Lian)
    
      - support MSI on Tango host controller (Marc Gonzalez)
    
      - support Tegra186 PCIe host controller (Manikanta Maddireddy)
    
      - use generic accessors on Tegra when possible (Thierry Reding)
    
      - support V3 Semiconductor PCI host controller (Linus Walleij)
    
    * tag 'pci-v4.15-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (85 commits)
      PCI/ASPM: Add L1 Substates definitions
      PCI/ASPM: Reformat ASPM register definitions
      PCI/ASPM: Use correct capability pointer to program LTR_L1.2_THRESHOLD
      PCI/ASPM: Account for downstream device's Port Common_Mode_Restore_Time
      PCI: xgene: Rename xgene_pcie_probe_bridge() to xgene_pcie_probe()
      PCI: xilinx: Rename xilinx_pcie_link_is_up() to xilinx_pcie_link_up()
      PCI: altera: Rename altera_pcie_link_is_up() to altera_pcie_link_up()
      PCI: Fix kernel-doc build warning
      PCI: Fail pci_map_rom() if the option ROM is invalid
      PCI: Move pci_map_rom() error path
      PCI: Move PCI_QUIRKS to the PCI bus menu
      alpha/PCI: Make pdev_save_srm_config() static
      PCI: Remove unused declarations
      PCI: Remove redundant pci_dev, pci_bus, resource declarations
      PCI: Remove redundant pcibios_set_master() declarations
      PCI/PME: Handle invalid data when reading Root Status
      PCI: hv: Use effective affinity mask
      PCI: pciehp: Do not clear Presence Detect Changed during initialization
      PCI: pciehp: Fix race condition handling surprise link down
      PCI: Distribute available resources to hotplug-capable bridges
      ...

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index e576e1a8d978..c039149cacb0 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *	drivers/pci/setup-res.c
  *

commit 8bb705e3e79d84e77edd4499e74483dd96a4626c
Author: Christian König <christian.koenig@amd.com>
Date:   Tue Oct 24 14:40:26 2017 -0500

    PCI: Add pci_resize_resource() for resizing BARs
    
    Add a pci_resize_resource() interface to allow device drivers to resize
    BARs of their devices.
    
    This is useful for devices with large local storage, e.g., graphics
    devices.  These devices often only expose 256MB BARs initially to be
    compatible with 32-bit systems.
    
    This function only tries to reprogram the windows of the bridge directly
    above the requesting device and only the BAR of the same type (usually mem,
    64bit, prefetchable).  This is done to avoid disturbing other drivers by
    changing the BARs of their devices.
    
    Drivers should use the following sequence to resize their BARs:
    1. Disable memory decoding of the device using the PCI cfg dword.
    2. Use pci_release_resource() to release all BARs which can move during the
       resize, including the one you want to resize.
    3. Call pci_resize_resource() for each BAR you want to resize.
    4. Call pci_assign_unassigned_bus_resources() to reassign new locations
       for all BARs which are not resized, but could move.
    5. If everything worked as expected, enable memory decoding in the device
       again using the PCI cfg dword.
    
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index e576e1a8d978..bf0089ef2177 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -396,6 +396,64 @@ int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsiz
 	return 0;
 }
 
+void pci_release_resource(struct pci_dev *dev, int resno)
+{
+	struct resource *res = dev->resource + resno;
+
+	dev_info(&dev->dev, "BAR %d: releasing %pR\n", resno, res);
+	release_resource(res);
+	res->end = resource_size(res) - 1;
+	res->start = 0;
+	res->flags |= IORESOURCE_UNSET;
+}
+EXPORT_SYMBOL(pci_release_resource);
+
+int pci_resize_resource(struct pci_dev *dev, int resno, int size)
+{
+	struct resource *res = dev->resource + resno;
+	int old, ret;
+	u32 sizes;
+	u16 cmd;
+
+	/* Make sure the resource isn't assigned before resizing it. */
+	if (!(res->flags & IORESOURCE_UNSET))
+		return -EBUSY;
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	if (cmd & PCI_COMMAND_MEMORY)
+		return -EBUSY;
+
+	sizes = pci_rebar_get_possible_sizes(dev, resno);
+	if (!sizes)
+		return -ENOTSUPP;
+
+	if (!(sizes & BIT(size)))
+		return -EINVAL;
+
+	old = pci_rebar_get_current_size(dev, resno);
+	if (old < 0)
+		return old;
+
+	ret = pci_rebar_set_size(dev, resno, size);
+	if (ret)
+		return ret;
+
+	res->end = res->start + pci_rebar_size_to_bytes(size) - 1;
+
+	/* Check if the new config works by trying to assign everything. */
+	ret = pci_reassign_bridge_resources(dev->bus->self, res->flags);
+	if (ret)
+		goto error_resize;
+
+	return 0;
+
+error_resize:
+	pci_rebar_set_size(dev, resno, old);
+	res->end = res->start + pci_rebar_size_to_bytes(old) - 1;
+	return ret;
+}
+EXPORT_SYMBOL(pci_resize_resource);
+
 int pci_enable_resources(struct pci_dev *dev, int mask)
 {
 	u16 cmd, old_cmd;

commit ecf677c8dcaa7bf13eee31b4d9e4639d559984ad
Author: Palmer Dabbelt <palmer@dabbelt.com>
Date:   Wed Aug 2 14:44:50 2017 -0500

    PCI: Add a generic weak pcibios_align_resource()
    
    Multiple architectures define this as a trivial function, and I'm adding
    another one as part of the RISC-V port.  Add a __weak version of
    pcibios_align_resource() and delete the now-obselete ones in a handful of
    ports.
    
    The only functional change should be that a handful of ports used to export
    pcibios_fixup_bus().  Only some architectures export this, so I just
    dropped it.
    
    Signed-off-by: Palmer Dabbelt <palmer@dabbelt.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 85774b7a316a..e576e1a8d978 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -234,6 +234,19 @@ static int pci_revert_fw_address(struct resource *res, struct pci_dev *dev,
 	return 0;
 }
 
+/*
+ * We don't have to worry about legacy ISA devices, so nothing to do here.
+ * This is marked as __weak because multiple architectures define it; it should
+ * eventually go away.
+ */
+resource_size_t __weak pcibios_align_resource(void *data,
+					      const struct resource *res,
+					      resource_size_t size,
+					      resource_size_t align)
+{
+       return res->start;
+}
+
 static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
 		int resno, resource_size_t size, resource_size_t align)
 {

commit 76dc52684d0f72971d9f6cc7d5ae198061b715bd
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Fri Apr 14 13:38:02 2017 -0700

    PCI: Make PCI_ROM_ADDRESS_MASK a 32-bit constant
    
    A 64-bit value is not needed since a PCI ROM address consists in 32 bits.
    This fixes a clang warning about "implicit conversion from 'unsigned long'
    to 'u32'".
    
    Also remove now unnecessary casts to u32 from __pci_read_base() and
    pci_std_update_resource().
    
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 4bc589ee78d0..85774b7a316a 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -63,7 +63,7 @@ static void pci_std_update_resource(struct pci_dev *dev, int resno)
 		mask = (u32)PCI_BASE_ADDRESS_IO_MASK;
 		new |= res->flags & ~PCI_BASE_ADDRESS_IO_MASK;
 	} else if (resno == PCI_ROM_RESOURCE) {
-		mask = (u32)PCI_ROM_ADDRESS_MASK;
+		mask = PCI_ROM_ADDRESS_MASK;
 	} else {
 		mask = (u32)PCI_BASE_ADDRESS_MEM_MASK;
 		new |= res->flags & ~PCI_BASE_ADDRESS_MEM_MASK;

commit 44b83b32e7c8d6fcd6a7e877ce3db65f6afdf87c
Merge: a1d9190d9682 0722bdd2962a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Dec 12 11:25:11 2016 -0600

    Merge branch 'pci/host-rockchip' into next
    
    * pci/host-rockchip:
      PCI: rockchip: Move the deassert of pm/aclk/pclk after phy_init()
      PCI: rockchip: Split out rockchip_cfg_atu()
      PCI: rockchip: Clean up bit definitions for PCIE_RC_CONFIG_LCS
      PCI: rockchip: Correct the use of FTS mask
      PCI: rockchip: Remove the pointer to L1 substate cap
      PCI: rockchip: Specify the link capability
      PCI: rockchip: Fix negotiated lanes calculation
      PCI: rockchip: Add Kconfig COMPILE_TEST
      PCI: rockchip: Mark RC as common clock architecture
      PCI: rockchip: Provide captured slot power limit and scale
      PCI: rockchip: Add three new resets as required properties
      PCI: Don't attempt to claim shadow copies of ROM
      PCI: designware: Check for iATU unroll support after initializing host
      PCI: qcom: Fix pp->dev usage before assignment
      PCI: designware-plat: Update author email address
      PCI: layerscape: Fix drvdata usage before assignment
      PCI: designware-plat: Change maintainer to Jose Abreu

commit 0b457dde3cf8b7c76a60f8e960f21bbd4abdc416
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Nov 28 16:17:41 2016 -0600

    PCI: Add comments about ROM BAR updating
    
    pci_update_resource() updates a hardware BAR so its address matches the
    kernel's struct resource UNLESS it's a disabled ROM BAR.  We only update
    those when we enable the ROM.
    
    It's not obvious from the code why ROM BARs should be handled specially.
    Apparently there are Matrox devices with defective ROM BARs that read as
    zero when disabled.  That means that if pci_enable_rom() reads the disabled
    BAR, sets PCI_ROM_ADDRESS_ENABLE (without re-inserting the address), and
    writes it back, it would enable the ROM at address zero.
    
    Add comments and references to explain why we can't make the code look more
    rational.
    
    The code changes are from 755528c860b0 ("Ignore disabled ROM resources at
    setup") and 8085ce084c0f ("[PATCH] Fix PCI ROM mapping").
    
    Link: https://lkml.org/lkml/2005/8/30/138
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 99c9e32775ee..045427336e11 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -72,6 +72,12 @@ static void pci_std_update_resource(struct pci_dev *dev, int resno)
 	if (resno < PCI_ROM_RESOURCE) {
 		reg = PCI_BASE_ADDRESS_0 + 4 * resno;
 	} else if (resno == PCI_ROM_RESOURCE) {
+
+		/*
+		 * Apparently some Matrox devices have ROM BARs that read
+		 * as zero when disabled, so don't update ROM BARs unless
+		 * they're enabled.  See https://lkml.org/lkml/2005/8/30/138.
+		 */
 		if (!(res->flags & IORESOURCE_ROM_ENABLE))
 			return;
 

commit 286c2378aaccc7343ebf17ec6cd86567659caf70
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Nov 28 16:51:19 2016 -0600

    PCI: Remove pci_resource_bar() and pci_iov_resource_bar()
    
    pci_std_update_resource() only deals with standard BARs, so we don't have
    to worry about the complications of VF BARs in an SR-IOV capability.
    
    Compute the BAR address inline and remove pci_resource_bar().  That makes
    pci_iov_resource_bar() unused, so remove that as well.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 5ddeb6737f99..99c9e32775ee 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -32,7 +32,6 @@ static void pci_std_update_resource(struct pci_dev *dev, int resno)
 	u16 cmd;
 	u32 new, check, mask;
 	int reg;
-	enum pci_bar_type type;
 	struct resource *res = dev->resource + resno;
 
 	/* Per SR-IOV spec 3.4.1.11, VF BARs are RO zero */
@@ -70,14 +69,16 @@ static void pci_std_update_resource(struct pci_dev *dev, int resno)
 		new |= res->flags & ~PCI_BASE_ADDRESS_MEM_MASK;
 	}
 
-	reg = pci_resource_bar(dev, resno, &type);
-	if (!reg)
-		return;
-	if (type != pci_bar_unknown) {
+	if (resno < PCI_ROM_RESOURCE) {
+		reg = PCI_BASE_ADDRESS_0 + 4 * resno;
+	} else if (resno == PCI_ROM_RESOURCE) {
 		if (!(res->flags & IORESOURCE_ROM_ENABLE))
 			return;
+
+		reg = dev->rom_base_reg;
 		new |= PCI_ROM_ADDRESS_ENABLE;
-	}
+	} else
+		return;
 
 	/*
 	 * We can't update a 64-bit BAR atomically, so when possible,

commit 6ffa2489c51da77564a0881a73765ea2169f955d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Nov 28 09:15:52 2016 -0600

    PCI: Separate VF BAR updates from standard BAR updates
    
    Previously pci_update_resource() used the same code path for updating
    standard BARs and VF BARs in SR-IOV capabilities.
    
    Split the VF BAR update into a new pci_iov_update_resource() internal
    interface, which makes it simpler to compute the BAR address (we can get
    rid of pci_resource_bar() and pci_iov_resource_bar()).
    
    This patch:
    
      - Renames pci_update_resource() to pci_std_update_resource(),
      - Adds pci_iov_update_resource(),
      - Makes pci_update_resource() a wrapper that calls the appropriate one,
    
    No functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 53bc0638cac6..5ddeb6737f99 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -25,8 +25,7 @@
 #include <linux/slab.h>
 #include "pci.h"
 
-
-void pci_update_resource(struct pci_dev *dev, int resno)
+static void pci_std_update_resource(struct pci_dev *dev, int resno)
 {
 	struct pci_bus_region region;
 	bool disable;
@@ -114,6 +113,16 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 		pci_write_config_word(dev, PCI_COMMAND, cmd);
 }
 
+void pci_update_resource(struct pci_dev *dev, int resno)
+{
+	if (resno <= PCI_ROM_RESOURCE)
+		pci_std_update_resource(dev, resno);
+#ifdef CONFIG_PCI_IOV
+	else if (resno >= PCI_IOV_RESOURCES && resno <= PCI_IOV_RESOURCE_END)
+		pci_iov_update_resource(dev, resno);
+#endif
+}
+
 int pci_claim_resource(struct pci_dev *dev, int resource)
 {
 	struct resource *res = &dev->resource[resource];

commit 45d004f4afefdd8d79916ee6d97a9ecd94bb1ffe
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Nov 29 08:14:47 2016 -0600

    PCI: Update BARs using property bits appropriate for type
    
    The BAR property bits (0-3 for memory BARs, 0-1 for I/O BARs) are supposed
    to be read-only, but we do save them in res->flags and include them when
    updating the BAR.
    
    Mask the I/O property bits with ~PCI_BASE_ADDRESS_IO_MASK (0x3) instead of
    PCI_REGION_FLAG_MASK (0xf) to make it obvious that we can't corrupt bits
    2-3 of I/O addresses.
    
    Use PCI_ROM_ADDRESS_MASK for ROM BARs.  This means we'll only check the top
    21 bits (instead of the 28 bits we used to check) of a ROM BAR to see if
    the update was successful.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index d2a32d88d2ae..53bc0638cac6 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -59,12 +59,17 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 		return;
 
 	pcibios_resource_to_bus(dev->bus, &region, res);
+	new = region.start;
 
-	new = region.start | (res->flags & PCI_REGION_FLAG_MASK);
-	if (res->flags & IORESOURCE_IO)
+	if (res->flags & IORESOURCE_IO) {
 		mask = (u32)PCI_BASE_ADDRESS_IO_MASK;
-	else
+		new |= res->flags & ~PCI_BASE_ADDRESS_IO_MASK;
+	} else if (resno == PCI_ROM_RESOURCE) {
+		mask = (u32)PCI_ROM_ADDRESS_MASK;
+	} else {
 		mask = (u32)PCI_BASE_ADDRESS_MEM_MASK;
+		new |= res->flags & ~PCI_BASE_ADDRESS_MEM_MASK;
+	}
 
 	reg = pci_resource_bar(dev, resno, &type);
 	if (!reg)

commit 63880b230a4af502c56dde3d4588634c70c66006
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Nov 28 11:19:27 2016 -0600

    PCI: Ignore BAR updates on virtual functions
    
    VF BARs are read-only zero, so updating VF BARs will not have any effect.
    See the SR-IOV spec r1.1, sec 3.4.1.11.
    
    We already ignore these updates because of 70675e0b6a1a ("PCI: Don't try to
    restore VF BARs"); this merely restructures it slightly to make it easier
    to split updates for standard and SR-IOV BARs.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 66c4d8f42233..d2a32d88d2ae 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -36,10 +36,9 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 	enum pci_bar_type type;
 	struct resource *res = dev->resource + resno;
 
-	if (dev->is_virtfn) {
-		dev_warn(&dev->dev, "can't update VF BAR%d\n", resno);
+	/* Per SR-IOV spec 3.4.1.11, VF BARs are RO zero */
+	if (dev->is_virtfn)
 		return;
-	}
 
 	/*
 	 * Ignore resources for unimplemented BARs and unused resource slots

commit 16d917b130d782b94fa02afc7bdf0d4aae689da4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Nov 8 14:25:24 2016 -0600

    PCI: Don't attempt to claim shadow copies of ROM
    
    If we're using a shadow copy of a PCI device ROM, the shadow copy is in RAM
    and the device never sees accesses to it and doesn't respond to it.  We
    don't have to route the shadow range to the PCI device, and the device
    doesn't have to claim the range.
    
    Previously we treated the shadow copy as though it were the ROM BAR, and we
    failed to claim it because the region wasn't routed to the device:
    
      pci 0000:01:00.0: Video device with shadowed ROM at [mem 0x000c0000-0x000dffff]
      pci_bus 0000:01: Allocating resources
      pci 0000:01:00.0: can't claim BAR 6 [mem 0x000c0000-0x000dffff]: no compatible bridge window
    
    The failure path of pcibios_allocate_dev_rom_resource() cleared out the
    resource start address, which also caused the following ioremap() warning:
    
      WARNING: CPU: 0 PID: 116 at /build/linux-akdJXO/linux-4.8.0/arch/x86/mm/ioremap.c:121 __ioremap_caller+0x1ec/0x370
      ioremap on RAM at 0x0000000000000000 - 0x000000000001ffff
    
    Handle an option ROM shadow copy as RAM, without trying to insert it into
    the iomem resource tree.
    
    This fixes a regression caused by 0c0e0736acad ("PCI: Set ROM shadow
    location in arch code, not in PCI core"), which appeared in v4.6.  The
    regression causes video device initialization to fail.  This was reported
    on AMD Turks, but it likely affects others as well.
    
    Fixes: 0c0e0736acad ("PCI: Set ROM shadow location in arch code, not in PCI core")
    Reported-and-tested-by: Vecu Bosseur <vecu.bosseur@gmail.com>
    Link: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1627496
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=175391
    Link: https://bugzilla.redhat.com/show_bug.cgi?id=1352272
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v4.6+

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 66c4d8f42233..9526e341988b 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -121,6 +121,14 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 		return -EINVAL;
 	}
 
+	/*
+	 * If we have a shadow copy in RAM, the PCI device doesn't respond
+	 * to the shadow range, so we don't need to claim it, and upstream
+	 * bridges don't need to route the range to the device.
+	 */
+	if (res->flags & IORESOURCE_ROM_SHADOW)
+		return 0;
+
 	root = pci_find_parent_resource(dev, res);
 	if (!root) {
 		dev_info(&dev->dev, "can't claim BAR %d %pR: no compatible bridge window\n",

commit 2ea4adf75235c14c5a52a90eb3c282383f79a86b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Mar 1 10:58:04 2016 -0600

    PCI: Don't assign or reassign immutable resources
    
    IORESOURCE_PCI_FIXED means the resource can't be moved, so if it's set,
    don't bother trying to assign or reassign the resource.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 604011e047d6..66c4d8f42233 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -276,6 +276,9 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	resource_size_t align, size;
 	int ret;
 
+	if (res->flags & IORESOURCE_PCI_FIXED)
+		return 0;
+
 	res->flags |= IORESOURCE_UNSET;
 	align = pci_resource_alignment(dev, res);
 	if (!align) {
@@ -321,6 +324,9 @@ int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsiz
 	resource_size_t new_size;
 	int ret;
 
+	if (res->flags & IORESOURCE_PCI_FIXED)
+		return 0;
+
 	flags = res->flags;
 	res->flags |= IORESOURCE_UNSET;
 	if (!res->parent) {

commit 1f9a30ec2a4acee9a4d664e7405c7eb26a7c4b5e
Merge: 6ff33f3902c3 b07461a8e45b bee67756eb4a c56d4450eb68 8affb487d4a4 af86fa4001ca c23b613507b8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Nov 2 15:57:03 2015 -0600

    Merge branches 'pci/aer', 'pci/hotplug', 'pci/misc', 'pci/msi', 'pci/resource' and 'pci/virtualization' into next
    
    * pci/aer:
      PCI/AER: Clear error status registers during enumeration and restore
    
    * pci/hotplug:
      PCI: pciehp: Queue power work requests in dedicated function
    
    * pci/misc:
      PCI: Turn off Request Attributes to avoid Chelsio T5 Completion erratum
      x86/PCI: Make pci_subsys_init() static
      PCI: Add builtin_pci_driver() to avoid registration boilerplate
      PCI: Remove unnecessary "if" statement
    
    * pci/msi:
      x86/PCI: Don't alloc pcibios-irq when MSI is enabled
      PCI/MSI: Export all remapped MSIs to sysfs attributes
      PCI: Disable MSI on SiS 761
    
    * pci/resource:
      sparc/PCI: Add mem64 resource parsing for root bus
      PCI: Expand Enhanced Allocation BAR output
      PCI: Make Enhanced Allocation bitmasks more obvious
      PCI: Handle Enhanced Allocation capability for SR-IOV devices
      PCI: Add support for Enhanced Allocation devices
      PCI: Add Enhanced Allocation register entries
      PCI: Handle IORESOURCE_PCI_FIXED when assigning resources
      PCI: Handle IORESOURCE_PCI_FIXED when sizing resources
      PCI: Clear IORESOURCE_UNSET when reverting to firmware-assigned address
    
    * pci/virtualization:
      PCI: Fix sriov_enable() error path for pcibios_enable_sriov() failures
      PCI: Wait 1 second between disabling VFs and clearing NumVFs
      PCI: Reorder pcibios_sriov_disable()
      PCI: Remove VFs in reverse order if virtfn_add() fails
      PCI: Remove redundant validation of SR-IOV offset/stride registers
      PCI: Set SR-IOV NumVFs to zero after enumeration
      PCI: Enable SR-IOV ARI Capable Hierarchy before reading TotalVFs
      PCI: Don't try to restore VF BARs

commit 0b26cd69480d4d99f39042c6621a05af7496b3da
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Sep 21 18:26:45 2015 -0500

    PCI: Clear IORESOURCE_UNSET when reverting to firmware-assigned address
    
    If pci_assign_resource() fails to assign space for a BAR, we may restore
    the BAR to whatever firmware left there at boot-time (this depends on
    whether the arch implements pcibios_retrieve_fw_addr()).  The messages we
    print are not as useful as they could be:
    
      pci 0000:00:01.0: BAR 15: assigned [mem 0xc0000000-0xc01fffff 64bit pref]
      pci 0000:01:00.0: BAR 0: no space for [mem size 0x10000000 pref]
      pci 0000:01:00.0: BAR 0: trying firmware assignment [mem size 0x10000000 pref]
      pci 0000:01:00.0: BAR 0: [mem size 0x10000000 pref] conflicts with PCI Bus 0000:00 [mem 0xc0000000-0xffffffff window]
    
    The last two lines should contain the actual BAR address, not the size.
    Clear IORESOURCE_UNSET so we print the address.  If requesting the
    firmware-assigned resource fails, mark it IORESOURCE_UNSET again.
    
    This is a cosmetic change to clarify the message: previously, if
    pci_revert_fw_address() succeeded, pci_assign_resource() cleared
    IORESOURCE_UNSET anyway, so this isn't really a functional change.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=85491#c50
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 232f9254c11a..54c4f4f8105d 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -177,6 +177,7 @@ static int pci_revert_fw_address(struct resource *res, struct pci_dev *dev,
 	end = res->end;
 	res->start = fw_addr;
 	res->end = res->start + size - 1;
+	res->flags &= ~IORESOURCE_UNSET;
 
 	root = pci_find_parent_resource(dev, res);
 	if (!root) {
@@ -194,6 +195,7 @@ static int pci_revert_fw_address(struct resource *res, struct pci_dev *dev,
 			 resno, res, conflict->name, conflict);
 		res->start = start;
 		res->end = end;
+		res->flags |= IORESOURCE_UNSET;
 		return -EBUSY;
 	}
 	return 0;

commit 70675e0b6a1ae20f8e93f9fc083d28034ad38948
Author: Wei Yang <weiyang@linux.vnet.ibm.com>
Date:   Wed Jul 29 16:52:58 2015 +0800

    PCI: Don't try to restore VF BARs
    
    VF BARs are read-only zero, so updating VF BARs will not have any effect.
    See the SR-IOV spec r1.1, sec 3.4.1.11.
    
    Don't update VF BARs in pci_restore_bars().
    
    This avoids spurious "BAR %d: error updating" messages that we see when
    doing vfio pass-through after 6eb7018705de ("vfio-pci: Move idle devices to
    D3hot power state").
    
    [bhelgaas: changelog, fix whitespace]
    Signed-off-by: Wei Yang <weiyang@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 232f9254c11a..152de5cd1cfc 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -36,6 +36,11 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 	enum pci_bar_type type;
 	struct resource *res = dev->resource + resno;
 
+	if (dev->is_virtfn) {
+		dev_warn(&dev->dev, "can't update VF BAR%d\n", resno);
+		return;
+	}
+
 	/*
 	 * Ignore resources for unimplemented BARs and unused resource slots
 	 * for 64 bit BARs.

commit c770cb4cb505c096eaca0fbbca3169c3aa4c3474
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Mar 12 12:30:06 2015 -0500

    PCI: Mark invalid BARs as unassigned
    
    If a BAR is not inside any upstream bridge window, or if it conflicts with
    another resource, mark it as IORESOURCE_UNSET so we don't try to use it.
    We may be able to assign a different address for it.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index b7c3a5ea1fca..232f9254c11a 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -120,6 +120,7 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 	if (!root) {
 		dev_info(&dev->dev, "can't claim BAR %d %pR: no compatible bridge window\n",
 			 resource, res);
+		res->flags |= IORESOURCE_UNSET;
 		return -EINVAL;
 	}
 
@@ -127,6 +128,7 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 	if (conflict) {
 		dev_info(&dev->dev, "can't claim BAR %d %pR: address conflict with %s %pR\n",
 			 resource, res, conflict->name, conflict);
+		res->flags |= IORESOURCE_UNSET;
 		return -EBUSY;
 	}
 

commit 64da465e9841f93183744a9dadf992f938ac3910
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jul 8 16:04:22 2014 -0600

    PCI: Tidy resource assignment messages
    
    Print messages about failures in pci_assign_resource().  We can drop the
    "by-hand" message from _pci_assign_resource() because %pR now prints the
    size rather than the address if the resource hasn't been assigned.
    
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 74eb6febdf87..b7c3a5ea1fca 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -248,10 +248,8 @@ static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
 static int _pci_assign_resource(struct pci_dev *dev, int resno,
 				resource_size_t size, resource_size_t min_align)
 {
-	struct resource *res = dev->resource + resno;
 	struct pci_bus *bus;
 	int ret;
-	char *type;
 
 	bus = dev->bus;
 	while ((ret = __pci_assign_resource(bus, dev, resno, size, min_align))) {
@@ -260,21 +258,6 @@ static int _pci_assign_resource(struct pci_dev *dev, int resno,
 		bus = bus->parent;
 	}
 
-	if (ret) {
-		if (res->flags & IORESOURCE_MEM)
-			if (res->flags & IORESOURCE_PREFETCH)
-				type = "mem pref";
-			else
-				type = "mem";
-		else if (res->flags & IORESOURCE_IO)
-			type = "io";
-		else
-			type = "unknown";
-		dev_info(&dev->dev,
-			 "BAR %d: can't assign %s (size %#llx)\n",
-			 resno, type, (unsigned long long) resource_size(res));
-	}
-
 	return ret;
 }
 
@@ -300,11 +283,16 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	 * where firmware left it.  That at least has a chance of
 	 * working, which is better than just leaving it disabled.
 	 */
-	if (ret < 0)
+	if (ret < 0) {
+		dev_info(&dev->dev, "BAR %d: no space for %pR\n", resno, res);
 		ret = pci_revert_fw_address(res, dev, resno, size);
+	}
 
-	if (ret < 0)
+	if (ret < 0) {
+		dev_info(&dev->dev, "BAR %d: failed to assign %pR\n", resno,
+			 res);
 		return ret;
+	}
 
 	res->flags &= ~IORESOURCE_UNSET;
 	res->flags &= ~IORESOURCE_STARTALIGN;
@@ -344,7 +332,8 @@ int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsiz
 
 	res->flags &= ~IORESOURCE_UNSET;
 	res->flags &= ~IORESOURCE_STARTALIGN;
-	dev_info(&dev->dev, "BAR %d: reassigned %pR\n", resno, res);
+	dev_info(&dev->dev, "BAR %d: reassigned %pR (expanded by %#llx)\n",
+		 resno, res, (unsigned long long) addsize);
 	if (resno < PCI_BRIDGE_RESOURCES)
 		pci_update_resource(dev, resno);
 

commit 947788359527d9598356c274c50522e0f6d0ad0f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jul 8 16:00:42 2014 -0600

    PCI: Return conventional error values from pci_revert_fw_address()
    
    Previously we returned zero for success or 1 for failure.  This changes
    that so we return zero for success or a negative errno for failure.
    
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 532dc540dc5d..74eb6febdf87 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -166,11 +166,10 @@ static int pci_revert_fw_address(struct resource *res, struct pci_dev *dev,
 {
 	struct resource *root, *conflict;
 	resource_size_t fw_addr, start, end;
-	int ret = 0;
 
 	fw_addr = pcibios_retrieve_fw_addr(dev, resno);
 	if (!fw_addr)
-		return 1;
+		return -ENOMEM;
 
 	start = res->start;
 	end = res->end;
@@ -189,14 +188,13 @@ static int pci_revert_fw_address(struct resource *res, struct pci_dev *dev,
 		 resno, res);
 	conflict = request_resource_conflict(root, res);
 	if (conflict) {
-		dev_info(&dev->dev,
-			 "BAR %d: %pR conflicts with %s %pR\n", resno,
-			 res, conflict->name, conflict);
+		dev_info(&dev->dev, "BAR %d: %pR conflicts with %s %pR\n",
+			 resno, res, conflict->name, conflict);
 		res->start = start;
 		res->end = end;
-		ret = 1;
+		return -EBUSY;
 	}
-	return ret;
+	return 0;
 }
 
 static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
@@ -305,7 +303,7 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	if (ret < 0)
 		ret = pci_revert_fw_address(res, dev, resno, size);
 
-	if (ret)
+	if (ret < 0)
 		return ret;
 
 	res->flags &= ~IORESOURCE_UNSET;

commit 28f6dbe2c669c6a02c04c8ece21cafbcb20370ab
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jul 4 15:58:15 2014 -0600

    PCI: Cleanup control flow
    
    Return errors immediately so the straightline path is the normal,
    no-error path.  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 481c4e18693a..532dc540dc5d 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -305,14 +305,16 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	if (ret < 0)
 		ret = pci_revert_fw_address(res, dev, resno, size);
 
-	if (!ret) {
-		res->flags &= ~IORESOURCE_UNSET;
-		res->flags &= ~IORESOURCE_STARTALIGN;
-		dev_info(&dev->dev, "BAR %d: assigned %pR\n", resno, res);
-		if (resno < PCI_BRIDGE_RESOURCES)
-			pci_update_resource(dev, resno);
-	}
-	return ret;
+	if (ret)
+		return ret;
+
+	res->flags &= ~IORESOURCE_UNSET;
+	res->flags &= ~IORESOURCE_STARTALIGN;
+	dev_info(&dev->dev, "BAR %d: assigned %pR\n", resno, res);
+	if (resno < PCI_BRIDGE_RESOURCES)
+		pci_update_resource(dev, resno);
+
+	return 0;
 }
 EXPORT_SYMBOL(pci_assign_resource);
 
@@ -335,19 +337,20 @@ int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsiz
 	/* already aligned with min_align */
 	new_size = resource_size(res) + addsize;
 	ret = _pci_assign_resource(dev, resno, new_size, min_align);
-	if (!ret) {
-		res->flags &= ~IORESOURCE_UNSET;
-		res->flags &= ~IORESOURCE_STARTALIGN;
-		dev_info(&dev->dev, "BAR %d: reassigned %pR\n", resno, res);
-		if (resno < PCI_BRIDGE_RESOURCES)
-			pci_update_resource(dev, resno);
-	} else {
+	if (ret) {
 		res->flags = flags;
 		dev_info(&dev->dev, "BAR %d: %pR (failed to expand by %#llx)\n",
 			 resno, res, (unsigned long long) addsize);
+		return ret;
 	}
 
-	return ret;
+	res->flags &= ~IORESOURCE_UNSET;
+	res->flags &= ~IORESOURCE_STARTALIGN;
+	dev_info(&dev->dev, "BAR %d: reassigned %pR\n", resno, res);
+	if (resno < PCI_BRIDGE_RESOURCES)
+		pci_update_resource(dev, resno);
+
+	return 0;
 }
 
 int pci_enable_resources(struct pci_dev *dev, int mask)

commit c33377082dd9ede1e998f7ce416077e4b1c2276c
Author: Guo Chao <yan@linux.vnet.ibm.com>
Date:   Thu Jul 3 18:30:29 2014 -0600

    PCI: Keep original resource if we fail to expand it
    
    If we have space assigned to a resource, we try to expand the resource
    (e.g., to accommodate SR-IOV resources), and the expansion attempt fails,
    we should keep the original assignment.
    
    After bd064f0a231a ("PCI: Mark resources as IORESOURCE_UNSET if we can't
    assign them"), we left the resource marked IORESOURCE_UNSET when the
    expansion failed, even if it had originally been set.  That caused errors
    like this:
    
      pci 0003:00:00.0: can't enable device: BAR 15 [mem size 0x0c000000 64bit pref] not assigned
      pci 0003:00:00.0: Error enabling bridge (-22), continuing
    
    Fix this by restoring the original flags when reassignment fails.
    
    [bhelgaas: reworked to simplify, changelog]
    Fixes: bd064f0a231a ("PCI: Mark resources as IORESOURCE_UNSET if we can't assign them")
    Signed-off-by: Guo Chao <yan@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v3.15+

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index caed1ce6facd..481c4e18693a 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -320,9 +320,11 @@ int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsiz
 			resource_size_t min_align)
 {
 	struct resource *res = dev->resource + resno;
+	unsigned long flags;
 	resource_size_t new_size;
 	int ret;
 
+	flags = res->flags;
 	res->flags |= IORESOURCE_UNSET;
 	if (!res->parent) {
 		dev_info(&dev->dev, "BAR %d: can't reassign an unassigned resource %pR\n",
@@ -339,7 +341,12 @@ int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsiz
 		dev_info(&dev->dev, "BAR %d: reassigned %pR\n", resno, res);
 		if (resno < PCI_BRIDGE_RESOURCES)
 			pci_update_resource(dev, resno);
+	} else {
+		res->flags = flags;
+		dev_info(&dev->dev, "BAR %d: %pR (failed to expand by %#llx)\n",
+			 resno, res, (unsigned long long) addsize);
 	}
+
 	return ret;
 }
 

commit 227f06470502c4fea3d93df1f12a77e3e37f6263
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 18 20:13:50 2014 -0400

    PCI: Merge multi-line quoted strings
    
    Merge quoted strings that are broken across lines into a single entity.
    The compiler merges them anyway, but checkpatch complains about it, and
    merging them makes it easier to grep for strings.
    
    No functional change.
    
    [bhelgaas: changelog, do the same for everything under drivers/pci]
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 211b36f96ff3..caed1ce6facd 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -96,8 +96,8 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 		pci_write_config_dword(dev, reg + 4, new);
 		pci_read_config_dword(dev, reg + 4, &check);
 		if (check != new) {
-			dev_err(&dev->dev, "BAR %d: error updating "
-			       "(high %#08x != %#08x)\n", resno, new, check);
+			dev_err(&dev->dev, "BAR %d: error updating (high %#08x != %#08x)\n",
+				resno, new, check);
 		}
 	}
 
@@ -289,8 +289,8 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	res->flags |= IORESOURCE_UNSET;
 	align = pci_resource_alignment(dev, res);
 	if (!align) {
-		dev_info(&dev->dev, "BAR %d: can't assign %pR "
-			 "(bogus alignment)\n", resno, res);
+		dev_info(&dev->dev, "BAR %d: can't assign %pR (bogus alignment)\n",
+			 resno, res);
 		return -EINVAL;
 	}
 
@@ -325,8 +325,8 @@ int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsiz
 
 	res->flags |= IORESOURCE_UNSET;
 	if (!res->parent) {
-		dev_info(&dev->dev, "BAR %d: can't reassign an unassigned resource %pR "
-			 "\n", resno, res);
+		dev_info(&dev->dev, "BAR %d: can't reassign an unassigned resource %pR\n",
+			 resno, res);
 		return -EINVAL;
 	}
 

commit b7fe943421396b61b9f7a97c2554ed999e0f3658
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 25 14:32:25 2014 -0600

    PCI: Move EXPORT_SYMBOL so it immediately follows function/variable
    
    Move EXPORT_SYMBOL so it immediately follows the function or variable.
    
    No functional change.
    
    [bhelgaas: squash similar changes, fix hotplug, probe, rom, search, too]
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 33f9e32d94d0..211b36f96ff3 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -314,6 +314,7 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	}
 	return ret;
 }
+EXPORT_SYMBOL(pci_assign_resource);
 
 int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsize,
 			resource_size_t min_align)

commit e5558d1a516fa6924fa8d53152b665d4c26f142e
Merge: 518a6a34f645 14574674e461 3cb30b73ad71 034cd97ebda4 9edbcd2252b5 67d29b5c6c40
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon May 26 17:29:17 2014 -0600

    Merge branches 'dma-api', 'pci/virtualization', 'pci/msi', 'pci/misc' and 'pci/resource' into next
    
    * dma-api:
      iommu/exynos: Remove unnecessary "&" from function pointers
      DMA-API: Update dma_pool_create ()and dma_pool_alloc() descriptions
      DMA-API: Fix duplicated word in DMA-API-HOWTO.txt
      DMA-API: Capitalize "CPU" consistently
      sh/PCI: Pass GAPSPCI_DMA_BASE CPU & bus address to dma_declare_coherent_memory()
      DMA-API: Change dma_declare_coherent_memory() CPU address to phys_addr_t
      DMA-API: Clarify physical/bus address distinction
    
    * pci/virtualization:
      PCI: Mark RTL8110SC INTx masking as broken
    
    * pci/msi:
      PCI/MSI: Remove pci_enable_msi_block()
    
    * pci/misc:
      PCI: Remove pcibios_add_platform_entries()
      s390/pci: use pdev->dev.groups for attribute creation
      PCI: Move Open Firmware devspec attribute to PCI common code
    
    * pci/resource:
      PCI: Add resource allocation comments
      PCI: Simplify __pci_assign_resource() coding style
      PCI: Change pbus_size_mem() return values to be more conventional
      PCI: Restrict 64-bit prefetchable bridge windows to 64-bit resources
      PCI: Support BAR sizes up to 8GB
      resources: Clarify sanity check message
      PCI: Don't add disabled subtractive decode bus resources
      PCI: Don't print anything while decoding is disabled
      PCI: Don't set BAR to zero if dma_addr_t is too small
      PCI: Don't convert BAR address to resource if dma_addr_t is too small
      PCI: Reject BAR above 4GB if dma_addr_t is too small
      PCI: Fail safely if we can't handle BARs larger than 4GB
      x86/gart: Tidy messages and add bridge device info
      x86/gart: Replace printk() with pr_info()
      x86/PCI: Move pcibios_assign_resources() annotation to definition
      x86/PCI: Mark ATI SBx00 HPET BAR as IORESOURCE_PCI_FIXED
      x86/PCI: Don't try to move IORESOURCE_PCI_FIXED resources
      x86/PCI: Fix Broadcom CNB20LE unintended sign extension

commit 67d29b5c6c40e91b124695e9250c2fd24915e24a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon May 19 18:32:18 2014 -0600

    PCI: Add resource allocation comments
    
    Add comments in the code to match the allocation strategy of 7c671426dfc3
    ("PCI: Restrict 64-bit prefetchable bridge windows to 64-bit resources").
    
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 3bdac9dc4a88..3da2542eb4df 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -209,20 +209,25 @@ static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
 
 	min = (res->flags & IORESOURCE_IO) ? PCIBIOS_MIN_IO : PCIBIOS_MIN_MEM;
 
-	/* First, try exact prefetching match.. */
+	/*
+	 * First, try exact prefetching match.  Even if a 64-bit
+	 * prefetchable bridge window is below 4GB, we can't put a 32-bit
+	 * prefetchable resource in it because pbus_size_mem() assumes a
+	 * 64-bit window will contain no 32-bit resources.  If we assign
+	 * things differently than they were sized, not everything will fit.
+	 */
 	ret = pci_bus_alloc_resource(bus, res, size, align, min,
 				     IORESOURCE_PREFETCH | IORESOURCE_MEM_64,
 				     pcibios_align_resource, dev);
 	if (ret == 0)
 		return 0;
 
+	/*
+	 * If the prefetchable window is only 32 bits wide, we can put
+	 * 64-bit prefetchable resources in it.
+	 */
 	if ((res->flags & (IORESOURCE_PREFETCH | IORESOURCE_MEM_64)) ==
 	     (IORESOURCE_PREFETCH | IORESOURCE_MEM_64)) {
-		/*
-		 * That failed.
-		 *
-		 * Try 32bit pref
-		 */
 		ret = pci_bus_alloc_resource(bus, res, size, align, min,
 					     IORESOURCE_PREFETCH,
 					     pcibios_align_resource, dev);
@@ -230,18 +235,16 @@ static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
 			return 0;
 	}
 
-	if (res->flags & (IORESOURCE_PREFETCH | IORESOURCE_MEM_64)) {
-		/*
-		 * That failed.
-		 *
-		 * But a prefetching area can handle a non-prefetching
-		 * window (it will just not perform as well).
-		 *
-		 * Also can put 64bit under 32bit range. (below 4g).
-		 */
+	/*
+	 * If we didn't find a better match, we can put any memory resource
+	 * in a non-prefetchable window.  If this resource is 32 bits and
+	 * non-prefetchable, the first call already tried the only possibility
+	 * so we don't need to try again.
+	 */
+	if (res->flags & (IORESOURCE_PREFETCH | IORESOURCE_MEM_64))
 		ret = pci_bus_alloc_resource(bus, res, size, align, min, 0,
 					     pcibios_align_resource, dev);
-	}
+
 	return ret;
 }
 

commit d3689df04445c568c8b3dfcd8db4b562e1b18cfb
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon May 19 18:39:07 2014 -0600

    PCI: Simplify __pci_assign_resource() coding style
    
    If an allocation succeeds, we can return success immediately.  Then we
    don't have to test for success in the subsequent code.
    
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 2473f091a9cc..3bdac9dc4a88 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -213,9 +213,10 @@ static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
 	ret = pci_bus_alloc_resource(bus, res, size, align, min,
 				     IORESOURCE_PREFETCH | IORESOURCE_MEM_64,
 				     pcibios_align_resource, dev);
+	if (ret == 0)
+		return 0;
 
-	if (ret < 0 &&
-	    (res->flags & (IORESOURCE_PREFETCH | IORESOURCE_MEM_64)) ==
+	if ((res->flags & (IORESOURCE_PREFETCH | IORESOURCE_MEM_64)) ==
 	     (IORESOURCE_PREFETCH | IORESOURCE_MEM_64)) {
 		/*
 		 * That failed.
@@ -225,10 +226,11 @@ static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
 		ret = pci_bus_alloc_resource(bus, res, size, align, min,
 					     IORESOURCE_PREFETCH,
 					     pcibios_align_resource, dev);
+		if (ret == 0)
+			return 0;
 	}
 
-	if (ret < 0 &&
-	    (res->flags & (IORESOURCE_PREFETCH | IORESOURCE_MEM_64))) {
+	if (res->flags & (IORESOURCE_PREFETCH | IORESOURCE_MEM_64)) {
 		/*
 		 * That failed.
 		 *

commit 5b28541552ef5eeffc41d6936105f38c2508e566
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon May 19 17:01:55 2014 -0600

    PCI: Restrict 64-bit prefetchable bridge windows to 64-bit resources
    
    This patch changes the way we handle 64-bit prefetchable bridge windows to
    make it more likely that we can assign space to all devices.
    
    Previously we put all prefetchable resources in the prefetchable bridge
    window.  If any of those resources was 32-bit only, we restricted the
    window to be below 4GB.
    
    After this patch, we only put 64-bit prefetchable resources in a 64-bit
    prefetchable window.  We put all 32-bit prefetchable resources in the
    non-prefetchable window, even if there are no 64-bit prefetchable
    resources.
    
    With the previous approach, if there was a 32-bit prefetchable resource
    behind a bridge, we forced the bridge's prefetchable window below 4GB,
    which meant that even if there was plenty of space above 4GB available, we
    couldn't use it, and assignment of large 64-bit resources could fail, as
    in the bugzilla below.
    
    The new strategy is:
    
      1) If the prefetchable window is 64 bits wide, we put only 64-bit
         prefetchable resources in it.  Any 32-bit prefetchable resources go in
         the non-prefetchable window.
    
      2) If the prefetchable window is 32 bits wide, we put both 32- and 64-bit
         prefetchable resources in it.
    
      3) If there is no prefetchable window, all MMIO resources go in the
         non-prefetchable window.
    
    This reduces performance for 32-bit prefetchable resources below a bridge
    with a 64-bit prefetchable window.  We previously assigned prefetchable
    space, but now we'll assign non-prefetchable space.  This is the case even
    if there are no 64-bit prefetchable resources, or if they would all fit
    below 4GB.  In those cases, the old strategy would work and would have
    better performance.
    
    [bhelgaas: write changelog, add bugzilla link, fold in mem64_mask removal]
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=74151
    Tested-by: Guo Chao <yan@linux.vnet.ibm.com>
    Tested-by: Wei Yang <weiyang@linux.vnet.ibm.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 7eed671d5586..2473f091a9cc 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -211,15 +211,31 @@ static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
 
 	/* First, try exact prefetching match.. */
 	ret = pci_bus_alloc_resource(bus, res, size, align, min,
-				     IORESOURCE_PREFETCH,
+				     IORESOURCE_PREFETCH | IORESOURCE_MEM_64,
 				     pcibios_align_resource, dev);
 
-	if (ret < 0 && (res->flags & IORESOURCE_PREFETCH)) {
+	if (ret < 0 &&
+	    (res->flags & (IORESOURCE_PREFETCH | IORESOURCE_MEM_64)) ==
+	     (IORESOURCE_PREFETCH | IORESOURCE_MEM_64)) {
+		/*
+		 * That failed.
+		 *
+		 * Try 32bit pref
+		 */
+		ret = pci_bus_alloc_resource(bus, res, size, align, min,
+					     IORESOURCE_PREFETCH,
+					     pcibios_align_resource, dev);
+	}
+
+	if (ret < 0 &&
+	    (res->flags & (IORESOURCE_PREFETCH | IORESOURCE_MEM_64))) {
 		/*
 		 * That failed.
 		 *
 		 * But a prefetching area can handle a non-prefetching
 		 * window (it will just not perform as well).
+		 *
+		 * Also can put 64bit under 32bit range. (below 4g).
 		 */
 		ret = pci_bus_alloc_resource(bus, res, size, align, min, 0,
 					     pcibios_align_resource, dev);

commit 56a3d18279f00c7ccbcdc193ceaf1a2f88c51457
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sat Apr 5 15:13:33 2014 -0600

    PCI: Remove unnecessary includes of <linux/init.h>
    
    None of these files are actually using any __init type directives and hence
    don't need to include <linux/init.h>.   Most are just a left over from
    __devinit and __cpuinit removal, or simply due to code getting copied from
    one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 7eed671d5586..1e37c590a183 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -16,7 +16,6 @@
  *	     Resource sorting
  */
 
-#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/export.h>
 #include <linux/pci.h>

commit 3cedcc3621289d41bd21c5dbe0b886d57c83a1ea
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Feb 26 11:26:00 2014 -0700

    PCI: Don't enable decoding if BAR hasn't been assigned an address
    
    Don't enable memory or I/O decoding if we haven't assigned or claimed the
    BAR's resource.
    
    If we enable decoding for a BAR that hasn't been assigned an address, we'll
    likely cause bus conflicts.  This declines to enable decoding for resources
    with IORESOURCE_UNSET.
    
    Note that drivers can use pci_enable_device_io() or pci_enable_device_mem()
    if they only care about specific types of BARs.  In that case, we don't
    bother checking whether the corresponding resources are assigned or
    claimed.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 6e443135ba24..7eed671d5586 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -343,9 +343,15 @@ int pci_enable_resources(struct pci_dev *dev, int mask)
 				(!(r->flags & IORESOURCE_ROM_ENABLE)))
 			continue;
 
+		if (r->flags & IORESOURCE_UNSET) {
+			dev_err(&dev->dev, "can't enable device: BAR %d %pR not assigned\n",
+				i, r);
+			return -EINVAL;
+		}
+
 		if (!r->parent) {
-			dev_err(&dev->dev, "device not available "
-				"(can't reserve %pR)\n", r);
+			dev_err(&dev->dev, "can't enable device: BAR %d %pR not claimed\n",
+				i, r);
 			return -EINVAL;
 		}
 

commit 29003beb7f15d3daa5a8f9afb8d007b64baa2357
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Feb 26 11:25:59 2014 -0700

    PCI: Don't try to claim IORESOURCE_UNSET resources
    
    If the IORESOURCE_UNSET bit is set, it means we haven't assigned an address
    yet, so don't try to claim the region.
    
    Also, make the error messages more uniform and add info about which BAR is
    involved.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 7f7652176fc5..6e443135ba24 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -111,18 +111,23 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 	struct resource *res = &dev->resource[resource];
 	struct resource *root, *conflict;
 
+	if (res->flags & IORESOURCE_UNSET) {
+		dev_info(&dev->dev, "can't claim BAR %d %pR: no address assigned\n",
+			 resource, res);
+		return -EINVAL;
+	}
+
 	root = pci_find_parent_resource(dev, res);
 	if (!root) {
-		dev_info(&dev->dev, "no compatible bridge window for %pR\n",
-			 res);
+		dev_info(&dev->dev, "can't claim BAR %d %pR: no compatible bridge window\n",
+			 resource, res);
 		return -EINVAL;
 	}
 
 	conflict = request_resource_conflict(root, res);
 	if (conflict) {
-		dev_info(&dev->dev,
-			 "address space collision: %pR conflicts with %s %pR\n",
-			 res, conflict->name, conflict);
+		dev_info(&dev->dev, "can't claim BAR %d %pR: address conflict with %s %pR\n",
+			 resource, res, conflict->name, conflict);
 		return -EBUSY;
 	}
 

commit cd8a4d3657c3f2cf9ce3780707be1debb8fea6e2
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Feb 26 11:25:59 2014 -0700

    PCI: Check IORESOURCE_UNSET before updating BAR
    
    Check to make sure we don't update a BAR with an address we haven't
    assigned.
    
    If we haven't assigned an address to a resource, we shouldn't write it to a
    BAR.  This isn't a problem for the usual path via pci_assign_resource(),
    which clears IORESOURCE_UNSET before calling pci_update_resource(), but
    paths like pci_restore_bars() can call this for resources we haven't
    assigned.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 725d5b28398c..7f7652176fc5 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -44,6 +44,9 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 	if (!res->flags)
 		return;
 
+	if (res->flags & IORESOURCE_UNSET)
+		return;
+
 	/*
 	 * Ignore non-moveable resources.  This might be legacy resources for
 	 * which no functional BAR register exists or another important

commit 434aafc1aefb5eb6e8c8d15284c8f929be756521
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Feb 26 11:25:59 2014 -0700

    PCI: Don't clear IORESOURCE_UNSET when updating BAR
    
    Clear IORESOURCE_UNSET when we assign an address to a resource, not when we
    write the address to the BAR.
    
    Also, drop the "BAR %d: set to %pR" message; this is mostly redundant with
    the "BAR %d: assigned %pR" message from pci_assign_resource().
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 0474b0217fdf..725d5b28398c 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -101,11 +101,6 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 
 	if (disable)
 		pci_write_config_word(dev, PCI_COMMAND, cmd);
-
-	res->flags &= ~IORESOURCE_UNSET;
-	dev_dbg(&dev->dev, "BAR %d: set to %pR (PCI address [%#llx-%#llx])\n",
-		resno, res, (unsigned long long)region.start,
-		(unsigned long long)region.end);
 }
 
 int pci_claim_resource(struct pci_dev *dev, int resource)

commit bd064f0a231af336218838474ea45a64f1672190
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Feb 26 11:25:58 2014 -0700

    PCI: Mark resources as IORESOURCE_UNSET if we can't assign them
    
    When assigning addresses to resources, mark them with IORESOURCE_UNSET
    before we start and clear IORESOURCE_UNSET if assignment is successful.
    That means that if we print the resource during assignment, we will show
    the size, not a meaningless address.
    
    Also, clear IORESOURCE_UNSET if we do assign an address, so we print the
    address when it is valid.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 5c060b152ce6..0474b0217fdf 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -263,6 +263,7 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	resource_size_t align, size;
 	int ret;
 
+	res->flags |= IORESOURCE_UNSET;
 	align = pci_resource_alignment(dev, res);
 	if (!align) {
 		dev_info(&dev->dev, "BAR %d: can't assign %pR "
@@ -282,6 +283,7 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 		ret = pci_revert_fw_address(res, dev, resno, size);
 
 	if (!ret) {
+		res->flags &= ~IORESOURCE_UNSET;
 		res->flags &= ~IORESOURCE_STARTALIGN;
 		dev_info(&dev->dev, "BAR %d: assigned %pR\n", resno, res);
 		if (resno < PCI_BRIDGE_RESOURCES)
@@ -297,6 +299,7 @@ int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsiz
 	resource_size_t new_size;
 	int ret;
 
+	res->flags |= IORESOURCE_UNSET;
 	if (!res->parent) {
 		dev_info(&dev->dev, "BAR %d: can't reassign an unassigned resource %pR "
 			 "\n", resno, res);
@@ -307,6 +310,7 @@ int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsiz
 	new_size = resource_size(res) + addsize;
 	ret = _pci_assign_resource(dev, resno, new_size, min_align);
 	if (!ret) {
+		res->flags &= ~IORESOURCE_UNSET;
 		res->flags &= ~IORESOURCE_STARTALIGN;
 		dev_info(&dev->dev, "BAR %d: reassigned %pR\n", resno, res);
 		if (resno < PCI_BRIDGE_RESOURCES)

commit fc2798502f860b18f3c7121e4dc659d3d9d28d74
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Dec 9 22:54:40 2013 -0800

    PCI: Convert pcibios_resource_to_bus() to take a pci_bus, not a pci_dev
    
    These interfaces:
    
      pcibios_resource_to_bus(struct pci_dev *dev, *bus_region, *resource)
      pcibios_bus_to_resource(struct pci_dev *dev, *resource, *bus_region)
    
    took a pci_dev, but they really depend only on the pci_bus.  And we want to
    use them in resource allocation paths where we have the bus but not a
    device, so this patch converts them to take the pci_bus instead of the
    pci_dev:
    
      pcibios_resource_to_bus(struct pci_bus *bus, *bus_region, *resource)
      pcibios_bus_to_resource(struct pci_bus *bus, *resource, *bus_region)
    
    In fact, with standard PCI-PCI bridges, they only depend on the host
    bridge, because that's the only place address translation occurs, but
    we aren't going that far yet.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 83c4d3bc47ab..5c060b152ce6 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -52,7 +52,7 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 	if (res->flags & IORESOURCE_PCI_FIXED)
 		return;
 
-	pcibios_resource_to_bus(dev, &region, res);
+	pcibios_resource_to_bus(dev->bus, &region, res);
 
 	new = region.start | (res->flags & PCI_REGION_FLAG_MASK);
 	if (res->flags & IORESOURCE_IO)

commit f7625980f5820edd1a73536e1a03bcbc1f889fec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 14 11:28:18 2013 -0700

    PCI: Fix whitespace, capitalization, and spelling errors
    
    Fix whitespace, capitalization, and spelling errors.  No functional change.
    I know "busses" is not an error, but "buses" was more common, so I used it
    consistently.
    
    Signed-off-by: Marta Rybczynska <rybczynska@gmail.com> (pci_reset_bridge_secondary_bus())
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 07f2eddc09ce..83c4d3bc47ab 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -159,7 +159,7 @@ resource_size_t __weak pcibios_retrieve_fw_addr(struct pci_dev *dev, int idx)
 	return 0;
 }
 
-static int pci_revert_fw_address(struct resource *res, struct pci_dev *dev, 
+static int pci_revert_fw_address(struct resource *res, struct pci_dev *dev,
 		int resno, resource_size_t size)
 {
 	struct resource *root, *conflict;

commit b638d7e7b849ad402aaecfe7edb599687b5eb3a8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 12 11:18:01 2013 -0600

    PCI: Remove unused variables
    
    This fixes "set but not used" warnings found via "make W=1".
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 81b88bda7930..07f2eddc09ce 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -261,7 +261,6 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 {
 	struct resource *res = dev->resource + resno;
 	resource_size_t align, size;
-	struct pci_bus *bus;
 	int ret;
 
 	align = pci_resource_alignment(dev, res);
@@ -271,7 +270,6 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 		return -EINVAL;
 	}
 
-	bus = dev->bus;
 	size = resource_size(res);
 	ret = _pci_assign_resource(dev, resno, size, align);
 

commit 5f9dca96696ee88f9f2b33dd6fba5877270c559c
Merge: d47557e46169 fe6dacdb1a31
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jul 18 14:06:20 2012 -0600

    Merge branch 'pci/nikhil-big-bar-fixes' into next
    
    * pci/nikhil-big-bar-fixes:
      PCI: reorder __pci_assign_resource() (no change)
      PCI: fix truncation of resource size to 32 bits

commit fe6dacdb1a31957825c0876de7cdea4c356aca30
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jul 11 17:05:43 2012 -0600

    PCI: reorder __pci_assign_resource() (no change)
    
    Reorder functions so __pci_assign_resource(), _pci_assign_resource(),
    and pci_assign_resource() are closer together.  No code change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index be76ebacf486..3ce9fa317d1d 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -127,33 +127,6 @@ void pci_disable_bridge_window(struct pci_dev *dev)
 	pci_write_config_dword(dev, PCI_PREF_BASE_UPPER32, 0xffffffff);
 }
 
-static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
-		int resno, resource_size_t size, resource_size_t align)
-{
-	struct resource *res = dev->resource + resno;
-	resource_size_t min;
-	int ret;
-
-	min = (res->flags & IORESOURCE_IO) ? PCIBIOS_MIN_IO : PCIBIOS_MIN_MEM;
-
-	/* First, try exact prefetching match.. */
-	ret = pci_bus_alloc_resource(bus, res, size, align, min,
-				     IORESOURCE_PREFETCH,
-				     pcibios_align_resource, dev);
-
-	if (ret < 0 && (res->flags & IORESOURCE_PREFETCH)) {
-		/*
-		 * That failed.
-		 *
-		 * But a prefetching area can handle a non-prefetching
-		 * window (it will just not perform as well).
-		 */
-		ret = pci_bus_alloc_resource(bus, res, size, align, min, 0,
-					     pcibios_align_resource, dev);
-	}
-	return ret;
-}
-
 /*
  * Generic function that returns a value indicating that the device's
  * original BIOS BAR address was not saved and so is not available for
@@ -206,6 +179,33 @@ static int pci_revert_fw_address(struct resource *res, struct pci_dev *dev,
 	return ret;
 }
 
+static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
+		int resno, resource_size_t size, resource_size_t align)
+{
+	struct resource *res = dev->resource + resno;
+	resource_size_t min;
+	int ret;
+
+	min = (res->flags & IORESOURCE_IO) ? PCIBIOS_MIN_IO : PCIBIOS_MIN_MEM;
+
+	/* First, try exact prefetching match.. */
+	ret = pci_bus_alloc_resource(bus, res, size, align, min,
+				     IORESOURCE_PREFETCH,
+				     pcibios_align_resource, dev);
+
+	if (ret < 0 && (res->flags & IORESOURCE_PREFETCH)) {
+		/*
+		 * That failed.
+		 *
+		 * But a prefetching area can handle a non-prefetching
+		 * window (it will just not perform as well).
+		 */
+		ret = pci_bus_alloc_resource(bus, res, size, align, min, 0,
+					     pcibios_align_resource, dev);
+	}
+	return ret;
+}
+
 static int _pci_assign_resource(struct pci_dev *dev, int resno,
 				resource_size_t size, resource_size_t min_align)
 {
@@ -239,31 +239,6 @@ static int _pci_assign_resource(struct pci_dev *dev, int resno,
 	return ret;
 }
 
-int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsize,
-			resource_size_t min_align)
-{
-	struct resource *res = dev->resource + resno;
-	resource_size_t new_size;
-	int ret;
-
-	if (!res->parent) {
-		dev_info(&dev->dev, "BAR %d: can't reassign an unassigned resource %pR "
-			 "\n", resno, res);
-		return -EINVAL;
-	}
-
-	/* already aligned with min_align */
-	new_size = resource_size(res) + addsize;
-	ret = _pci_assign_resource(dev, resno, new_size, min_align);
-	if (!ret) {
-		res->flags &= ~IORESOURCE_STARTALIGN;
-		dev_info(&dev->dev, "BAR %d: reassigned %pR\n", resno, res);
-		if (resno < PCI_BRIDGE_RESOURCES)
-			pci_update_resource(dev, resno);
-	}
-	return ret;
-}
-
 int pci_assign_resource(struct pci_dev *dev, int resno)
 {
 	struct resource *res = dev->resource + resno;
@@ -299,6 +274,31 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	return ret;
 }
 
+int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsize,
+			resource_size_t min_align)
+{
+	struct resource *res = dev->resource + resno;
+	resource_size_t new_size;
+	int ret;
+
+	if (!res->parent) {
+		dev_info(&dev->dev, "BAR %d: can't reassign an unassigned resource %pR "
+			 "\n", resno, res);
+		return -EINVAL;
+	}
+
+	/* already aligned with min_align */
+	new_size = resource_size(res) + addsize;
+	ret = _pci_assign_resource(dev, resno, new_size, min_align);
+	if (!ret) {
+		res->flags &= ~IORESOURCE_STARTALIGN;
+		dev_info(&dev->dev, "BAR %d: reassigned %pR\n", resno, res);
+		if (resno < PCI_BRIDGE_RESOURCES)
+			pci_update_resource(dev, resno);
+	}
+	return ret;
+}
+
 int pci_enable_resources(struct pci_dev *dev, int mask)
 {
 	u16 cmd, old_cmd;

commit d6776e6d5c2f8db0252f447b09736075e1bbe387
Author: Nikhil P Rao <nikhil.rao@intel.com>
Date:   Wed Jun 20 12:56:00 2012 -0700

    PCI: fix truncation of resource size to 32 bits
    
    _pci_assign_resource() took an int "size" argument, which meant that
    sizes larger than 4GB were truncated.  Change type to resource_size_t.
    
    [bhelgaas: changelog]
    Signed-off-by: Nikhil P Rao <nikhil.rao@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index eea85dafc763..be76ebacf486 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -206,7 +206,8 @@ static int pci_revert_fw_address(struct resource *res, struct pci_dev *dev,
 	return ret;
 }
 
-static int _pci_assign_resource(struct pci_dev *dev, int resno, int size, resource_size_t min_align)
+static int _pci_assign_resource(struct pci_dev *dev, int resno,
+				resource_size_t size, resource_size_t min_align)
 {
 	struct resource *res = dev->resource + resno;
 	struct pci_bus *bus;

commit 9aac537e0e33f4e4f28b8e7472c283fb6460c650
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jul 9 19:49:37 2012 -0600

    PCI: disable MEM decoding while updating 64-bit MEM BARs
    
    When we update 64-bit BARs, we have to perform two config writes.  Between
    the writes, the half-written BAR value could match a MEM access intended
    for another device.  This could result in corruption of this device (for
    writes) or an unexpected response machine check (for reads).
    
    To prevent this, disable MEM decoding while updating such BARs.  This uses
    the same safety test as 253d2e5498, which disables both MEM and IO while
    sizing BARs, namely, we don't disable decoding for host bridge devices.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index eea85dafc763..1a0e60e265ea 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -30,6 +30,8 @@
 void pci_update_resource(struct pci_dev *dev, int resno)
 {
 	struct pci_bus_region region;
+	bool disable;
+	u16 cmd;
 	u32 new, check, mask;
 	int reg;
 	enum pci_bar_type type;
@@ -67,6 +69,18 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 		new |= PCI_ROM_ADDRESS_ENABLE;
 	}
 
+	/*
+	 * We can't update a 64-bit BAR atomically, so when possible,
+	 * disable decoding so that a half-updated BAR won't conflict
+	 * with another device.
+	 */
+	disable = (res->flags & IORESOURCE_MEM_64) && !dev->mmio_always_on;
+	if (disable) {
+		pci_read_config_word(dev, PCI_COMMAND, &cmd);
+		pci_write_config_word(dev, PCI_COMMAND,
+				      cmd & ~PCI_COMMAND_MEMORY);
+	}
+
 	pci_write_config_dword(dev, reg, new);
 	pci_read_config_dword(dev, reg, &check);
 
@@ -84,6 +98,10 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 			       "(high %#08x != %#08x)\n", resno, new, check);
 		}
 	}
+
+	if (disable)
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+
 	res->flags &= ~IORESOURCE_UNSET;
 	dev_dbg(&dev->dev, "BAR %d: set to %pR (PCI address [%#llx-%#llx])\n",
 		resno, res, (unsigned long long)region.start,

commit 2069ecfbe14ebd71a6f98e8a00724e9adf4fe4ee
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Feb 15 21:40:31 2012 -0800

    PCI: Move "pci reassigndev resource alignment" out of quirks.c
    
    This isn't really a quirk; calling it directly from pci_add_device makes
    more sense.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index f968185aa192..eea85dafc763 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -114,7 +114,6 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 }
 EXPORT_SYMBOL(pci_claim_resource);
 
-#ifdef CONFIG_PCI_QUIRKS
 void pci_disable_bridge_window(struct pci_dev *dev)
 {
 	dev_info(&dev->dev, "disabling bridge mem windows\n");
@@ -127,9 +126,6 @@ void pci_disable_bridge_window(struct pci_dev *dev)
 	pci_write_config_dword(dev, PCI_PREF_MEMORY_BASE, 0x0000fff0);
 	pci_write_config_dword(dev, PCI_PREF_BASE_UPPER32, 0xffffffff);
 }
-#endif	/* CONFIG_PCI_QUIRKS */
-
-
 
 static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
 		int resno, resource_size_t size, resource_size_t align)

commit 78c3b329b9dd7097781cb900146e503e499cccfe
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Jan 21 02:08:25 2012 -0800

    PCI: Move pdev_sort_resources() to setup-bus.c
    
    This allows us to move the definition of struct resource_list to
    setup_bus.c and later convert resource_list to a regular list.
    
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 241de6c2b9cd..f968185aa192 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -302,53 +302,6 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	return ret;
 }
 
-
-/* Sort resources by alignment */
-void pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
-{
-	int i;
-
-	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
-		struct resource *r;
-		struct resource_list *list, *tmp;
-		resource_size_t r_align;
-
-		r = &dev->resource[i];
-
-		if (r->flags & IORESOURCE_PCI_FIXED)
-			continue;
-
-		if (!(r->flags) || r->parent)
-			continue;
-
-		r_align = pci_resource_alignment(dev, r);
-		if (!r_align) {
-			dev_warn(&dev->dev, "BAR %d: %pR has bogus alignment\n",
-				 i, r);
-			continue;
-		}
-		for (list = head; ; list = list->next) {
-			resource_size_t align = 0;
-			struct resource_list *ln = list->next;
-
-			if (ln)
-				align = pci_resource_alignment(ln->dev, ln->res);
-
-			if (r_align > align) {
-				tmp = kmalloc(sizeof(*tmp), GFP_KERNEL);
-				if (!tmp)
-					panic("pdev_sort_resources(): "
-					      "kmalloc() failed!\n");
-				tmp->next = ln;
-				tmp->res = r;
-				tmp->dev = dev;
-				list->next = tmp;
-				break;
-			}
-		}
-	}
-}
-
 int pci_enable_resources(struct pci_dev *dev, int mask)
 {
 	u16 cmd, old_cmd;

commit a4ac9fea016fc5c09227eb479bd35e34978323a4
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Jan 21 02:08:17 2012 -0800

    PCI : Calculate right add_size
    
    During debug of one SRIOV enabled hotplug device, we found found that
    add_size is not passed properly.
    
    The device has devices under two level bridges:
    
     +-[0000:80]-+-00.0-[81-8f]--
     |           +-01.0-[90-9f]--
     |           +-02.0-[a0-af]----00.0-[a1-a3]--+-02.0-[a2]--+-00.0  Oracle Corporation Device
     |           |                               \-03.0-[a3]--+-00.0  Oracle Corporation Device
    
    Which means later the parent bridge will not try to add a big enough range:
    
    [  557.455077] pci 0000:a0:00.0: BAR 14: assigned [mem 0xf9000000-0xf93fffff]
    [  557.461974] pci 0000:a0:00.0: BAR 15: assigned [mem 0xf6000000-0xf61fffff pref]
    [  557.469340] pci 0000:a1:02.0: BAR 14: assigned [mem 0xf9000000-0xf91fffff]
    [  557.476231] pci 0000:a1:02.0: BAR 15: assigned [mem 0xf6000000-0xf60fffff pref]
    [  557.483582] pci 0000:a1:03.0: BAR 14: assigned [mem 0xf9200000-0xf93fffff]
    [  557.490468] pci 0000:a1:03.0: BAR 15: assigned [mem 0xf6100000-0xf61fffff pref]
    [  557.497833] pci 0000:a1:03.0: BAR 14: can't assign mem (size 0x200000)
    [  557.504378] pci 0000:a1:03.0: failed to add optional resources res=[mem 0xf9200000-0xf93fffff]
    [  557.513026] pci 0000:a1:02.0: BAR 14: can't assign mem (size 0x200000)
    [  557.519578] pci 0000:a1:02.0: failed to add optional resources res=[mem 0xf9000000-0xf91fffff]
    
    It turns out we did not calculate size1 properly.
    
    static resource_size_t calculate_memsize(resource_size_t size,
                    resource_size_t min_size,
                    resource_size_t size1,
                    resource_size_t old_size,
                    resource_size_t align)
    {
            if (size < min_size)
                    size = min_size;
            if (old_size == 1 )
                    old_size = 0;
            if (size < old_size)
                    size = old_size;
            size = ALIGN(size + size1, align);
            return size;
    }
    
    We should not pass add_size with min_size in calculate_memsize since
    that will make add_size not contribute final add_size.
    
    So just pass add_size with size1 to calculate_memsize().
    
    With this change, we should have chance to remove extra addon in
    pci_reassign_resource.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 6923a9bce49e..241de6c2b9cd 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -255,11 +255,12 @@ int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsiz
 		return -EINVAL;
 	}
 
-	new_size = resource_size(res) + addsize + min_align;
+	/* already aligned with min_align */
+	new_size = resource_size(res) + addsize;
 	ret = _pci_assign_resource(dev, resno, new_size, min_align);
 	if (!ret) {
 		res->flags &= ~IORESOURCE_STARTALIGN;
-		dev_info(&dev->dev, "BAR %d: assigned %pR\n", resno, res);
+		dev_info(&dev->dev, "BAR %d: reassigned %pR\n", resno, res);
 		if (resno < PCI_BRIDGE_RESOURCES)
 			pci_update_resource(dev, resno);
 	}

commit 0dea210b1769f191d6b2bc3cc86e51481837ec5e
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Thu Jan 26 23:45:47 2012 +0900

    PCI: Fix typo in setup-res.c
    
    Correct spelling "resouce" to "resource" in
    dricers/pci/setup-res.c
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 85c8470c35e2..6923a9bce49e 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -250,7 +250,7 @@ int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsiz
 	int ret;
 
 	if (!res->parent) {
-		dev_info(&dev->dev, "BAR %d: can't reassign an unassigned resouce %pR "
+		dev_info(&dev->dev, "BAR %d: can't reassign an unassigned resource %pR "
 			 "\n", resno, res);
 		return -EINVAL;
 	}

commit 6535943fbf25c8e9419a6b20ca992633baa0bf99
Author: Myron Stowe <mstowe@redhat.com>
Date:   Mon Nov 21 11:54:19 2011 -0700

    x86/PCI: Convert maintaining FW-assigned BIOS BAR values to use a list
    
    This patch converts the underlying maintenance aspects of FW-assigned
    BIOS BAR values from a statically allocated array within struct pci_dev
    to a list of temporary, stand alone, entries.
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 3cf47d34becf..85c8470c35e2 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -158,16 +158,34 @@ static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
 	return ret;
 }
 
+/*
+ * Generic function that returns a value indicating that the device's
+ * original BIOS BAR address was not saved and so is not available for
+ * reinstatement.
+ *
+ * Can be over-ridden by architecture specific code that implements
+ * reinstatement functionality rather than leaving it disabled when
+ * normal allocation attempts fail.
+ */
+resource_size_t __weak pcibios_retrieve_fw_addr(struct pci_dev *dev, int idx)
+{
+	return 0;
+}
+
 static int pci_revert_fw_address(struct resource *res, struct pci_dev *dev, 
 		int resno, resource_size_t size)
 {
 	struct resource *root, *conflict;
-	resource_size_t start, end;
+	resource_size_t fw_addr, start, end;
 	int ret = 0;
 
+	fw_addr = pcibios_retrieve_fw_addr(dev, resno);
+	if (!fw_addr)
+		return 1;
+
 	start = res->start;
 	end = res->end;
-	res->start = dev->fw_addr[resno];
+	res->start = fw_addr;
 	res->end = res->start + size - 1;
 
 	root = pci_find_parent_resource(dev, res);
@@ -271,7 +289,7 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	 * where firmware left it.  That at least has a chance of
 	 * working, which is better than just leaving it disabled.
 	 */
-	if (ret < 0 && dev->fw_addr[resno])
+	if (ret < 0)
 		ret = pci_revert_fw_address(res, dev, resno, size);
 
 	if (!ret) {

commit 351fc6d1a5175d587d4f2b00ec7bff79b13ec48a
Author: Myron Stowe <mstowe@redhat.com>
Date:   Mon Nov 21 11:54:07 2011 -0700

    PCI: Fix starting basis for resource requests
    
    pci_revert_fw_address() is used to reinstate a PCI device's original
    FW-assigned BIOS BAR value(s) if normal resource assignment fails.
    
    When attempting to reinstate an address, the point within the resource
    tree from which to attempt the new resource request should be the parent
    resource corresponding to the device, not the base of the resource tree
    (ioport_resource or iomem_resource).  For PCI devices this would
    typically be the resource corresponding to the upstream PCI host bridge
    or P2P bridge aperture.
    
    This patch sets the point within the resource tree to attempt a new
    resource assignment request to the PCI device's parent resource and only
    if that fails does it fall back to the base ioport_resource or
    iomem_resource.
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index b66bfdbd21f7..3cf47d34becf 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -165,15 +165,19 @@ static int pci_revert_fw_address(struct resource *res, struct pci_dev *dev,
 	resource_size_t start, end;
 	int ret = 0;
 
-	if (res->flags & IORESOURCE_IO)
-		root = &ioport_resource;
-	else
-		root = &iomem_resource;
-
 	start = res->start;
 	end = res->end;
 	res->start = dev->fw_addr[resno];
 	res->end = res->start + size - 1;
+
+	root = pci_find_parent_resource(dev, res);
+	if (!root) {
+		if (res->flags & IORESOURCE_IO)
+			root = &ioport_resource;
+		else
+			root = &iomem_resource;
+	}
+
 	dev_info(&dev->dev, "BAR %d: trying firmware assignment %pR\n",
 		 resno, res);
 	conflict = request_resource_conflict(root, res);

commit 85b8582d7ca516030efb84d94fa29a73c1d9a125
Author: Vincent Palatin <vpalatin@chromium.org>
Date:   Mon Dec 5 11:51:18 2011 -0800

    PCI/PM/Runtime: make PCI traces quieter
    
    When the runtime PM is activated on PCI, if a device switches state
    frequently (e.g. an EHCI controller with autosuspending USB devices
    connected) the PCI configuration traces might be very verbose in the
    kernel log.  Let's guard those traces with DEBUG condition.
    
    Acked-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Vincent Palatin <vpalatin@chromium.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 5717509becbe..b66bfdbd21f7 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -85,9 +85,9 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 		}
 	}
 	res->flags &= ~IORESOURCE_UNSET;
-	dev_info(&dev->dev, "BAR %d: set to %pR (PCI address [%#llx-%#llx])\n",
-		 resno, res, (unsigned long long)region.start,
-		 (unsigned long long)region.end);
+	dev_dbg(&dev->dev, "BAR %d: set to %pR (PCI address [%#llx-%#llx])\n",
+		resno, res, (unsigned long long)region.start,
+		(unsigned long long)region.end);
 }
 
 int pci_claim_resource(struct pci_dev *dev, int resource)

commit 363c75db1d7bbda0aa90e680565f2673bab92ee4
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 27 09:37:25 2011 -0400

    pci: Fix files needing export.h for EXPORT_SYMBOL/THIS_MODULE
    
    They were implicitly getting it from device.h --> module.h but
    we want to clean that up.  So add the minimal header for these
    macros.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 51a9095c7da4..5717509becbe 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -18,6 +18,7 @@
 
 #include <linux/init.h>
 #include <linux/kernel.h>
+#include <linux/export.h>
 #include <linux/pci.h>
 #include <linux/errno.h>
 #include <linux/ioport.h>

commit 2bbc6942273b5b3097bd265d82227bdd84b351b2
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Mon Jul 25 13:08:39 2011 -0700

    PCI : ability to relocate assigned pci-resources
    
    Currently pci-bridges are allocated enough resources to satisfy their immediate
    requirements.  Any additional resource-requests fail if additional free space,
    contiguous to the one already allocated, is not available. This behavior is not
    reasonable since sufficient contiguous resources, that can satisfy the request,
    are available at a different location.
    
    This patch provides the ability to expand and relocate a allocated resource.
    
            v2: Changelog: Fixed size calculation in pci_reassign_resource()
            v3: Changelog : Split this patch. The resource.c changes are already
                            upstream. All the pci driver changes are in here.
    
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 319f359906e8..51a9095c7da4 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -128,16 +128,16 @@ void pci_disable_bridge_window(struct pci_dev *dev)
 }
 #endif	/* CONFIG_PCI_QUIRKS */
 
+
+
 static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
-				 int resno)
+		int resno, resource_size_t size, resource_size_t align)
 {
 	struct resource *res = dev->resource + resno;
-	resource_size_t size, min, align;
+	resource_size_t min;
 	int ret;
 
-	size = resource_size(res);
 	min = (res->flags & IORESOURCE_IO) ? PCIBIOS_MIN_IO : PCIBIOS_MIN_MEM;
-	align = pci_resource_alignment(dev, res);
 
 	/* First, try exact prefetching match.. */
 	ret = pci_bus_alloc_resource(bus, res, size, align, min,
@@ -154,56 +154,101 @@ static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
 		ret = pci_bus_alloc_resource(bus, res, size, align, min, 0,
 					     pcibios_align_resource, dev);
 	}
+	return ret;
+}
 
-	if (ret < 0 && dev->fw_addr[resno]) {
-		struct resource *root, *conflict;
-		resource_size_t start, end;
+static int pci_revert_fw_address(struct resource *res, struct pci_dev *dev, 
+		int resno, resource_size_t size)
+{
+	struct resource *root, *conflict;
+	resource_size_t start, end;
+	int ret = 0;
 
-		/*
-		 * If we failed to assign anything, let's try the address
-		 * where firmware left it.  That at least has a chance of
-		 * working, which is better than just leaving it disabled.
-		 */
+	if (res->flags & IORESOURCE_IO)
+		root = &ioport_resource;
+	else
+		root = &iomem_resource;
+
+	start = res->start;
+	end = res->end;
+	res->start = dev->fw_addr[resno];
+	res->end = res->start + size - 1;
+	dev_info(&dev->dev, "BAR %d: trying firmware assignment %pR\n",
+		 resno, res);
+	conflict = request_resource_conflict(root, res);
+	if (conflict) {
+		dev_info(&dev->dev,
+			 "BAR %d: %pR conflicts with %s %pR\n", resno,
+			 res, conflict->name, conflict);
+		res->start = start;
+		res->end = end;
+		ret = 1;
+	}
+	return ret;
+}
+
+static int _pci_assign_resource(struct pci_dev *dev, int resno, int size, resource_size_t min_align)
+{
+	struct resource *res = dev->resource + resno;
+	struct pci_bus *bus;
+	int ret;
+	char *type;
 
-		if (res->flags & IORESOURCE_IO)
-			root = &ioport_resource;
+	bus = dev->bus;
+	while ((ret = __pci_assign_resource(bus, dev, resno, size, min_align))) {
+		if (!bus->parent || !bus->self->transparent)
+			break;
+		bus = bus->parent;
+	}
+
+	if (ret) {
+		if (res->flags & IORESOURCE_MEM)
+			if (res->flags & IORESOURCE_PREFETCH)
+				type = "mem pref";
+			else
+				type = "mem";
+		else if (res->flags & IORESOURCE_IO)
+			type = "io";
 		else
-			root = &iomem_resource;
-
-		start = res->start;
-		end = res->end;
-		res->start = dev->fw_addr[resno];
-		res->end = res->start + size - 1;
-		dev_info(&dev->dev, "BAR %d: trying firmware assignment %pR\n",
-			 resno, res);
-		conflict = request_resource_conflict(root, res);
-		if (conflict) {
-			dev_info(&dev->dev,
-				 "BAR %d: %pR conflicts with %s %pR\n", resno,
-				 res, conflict->name, conflict);
-			res->start = start;
-			res->end = end;
-		} else
-			ret = 0;
+			type = "unknown";
+		dev_info(&dev->dev,
+			 "BAR %d: can't assign %s (size %#llx)\n",
+			 resno, type, (unsigned long long) resource_size(res));
 	}
 
+	return ret;
+}
+
+int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsize,
+			resource_size_t min_align)
+{
+	struct resource *res = dev->resource + resno;
+	resource_size_t new_size;
+	int ret;
+
+	if (!res->parent) {
+		dev_info(&dev->dev, "BAR %d: can't reassign an unassigned resouce %pR "
+			 "\n", resno, res);
+		return -EINVAL;
+	}
+
+	new_size = resource_size(res) + addsize + min_align;
+	ret = _pci_assign_resource(dev, resno, new_size, min_align);
 	if (!ret) {
 		res->flags &= ~IORESOURCE_STARTALIGN;
 		dev_info(&dev->dev, "BAR %d: assigned %pR\n", resno, res);
 		if (resno < PCI_BRIDGE_RESOURCES)
 			pci_update_resource(dev, resno);
 	}
-
 	return ret;
 }
 
 int pci_assign_resource(struct pci_dev *dev, int resno)
 {
 	struct resource *res = dev->resource + resno;
-	resource_size_t align;
+	resource_size_t align, size;
 	struct pci_bus *bus;
 	int ret;
-	char *type;
 
 	align = pci_resource_alignment(dev, res);
 	if (!align) {
@@ -213,34 +258,27 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	}
 
 	bus = dev->bus;
-	while ((ret = __pci_assign_resource(bus, dev, resno))) {
-		if (bus->parent && bus->self->transparent)
-			bus = bus->parent;
-		else
-			bus = NULL;
-		if (bus)
-			continue;
-		break;
-	}
+	size = resource_size(res);
+	ret = _pci_assign_resource(dev, resno, size, align);
 
-	if (ret) {
-		if (res->flags & IORESOURCE_MEM)
-			if (res->flags & IORESOURCE_PREFETCH)
-				type = "mem pref";
-			else
-				type = "mem";
-		else if (res->flags & IORESOURCE_IO)
-			type = "io";
-		else
-			type = "unknown";
-		dev_info(&dev->dev,
-			 "BAR %d: can't assign %s (size %#llx)\n",
-			 resno, type, (unsigned long long) resource_size(res));
-	}
+	/*
+	 * If we failed to assign anything, let's try the address
+	 * where firmware left it.  That at least has a chance of
+	 * working, which is better than just leaving it disabled.
+	 */
+	if (ret < 0 && dev->fw_addr[resno])
+		ret = pci_revert_fw_address(res, dev, resno, size);
 
+	if (!ret) {
+		res->flags &= ~IORESOURCE_STARTALIGN;
+		dev_info(&dev->dev, "BAR %d: assigned %pR\n", resno, res);
+		if (resno < PCI_BRIDGE_RESOURCES)
+			pci_update_resource(dev, resno);
+	}
 	return ret;
 }
 
+
 /* Sort resources by alignment */
 void pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 {

commit 28c6821a0f8e686d4f1a6107d970705d37475d87
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jun 14 13:04:35 2011 -0600

    PCI: fold pci_calc_resource_flags() into decode_bar()
    
    decode_bar() and pci_calc_resource_flags() both looked at the PCI BAR
    type information, and it's simpler to just do it all in one place.
    
    decode_bar() sets IORESOURCE_IO, IORESOURCE_MEM, and IORESOURCE_MEM_64
    as appropriate, so res->flags contains all the information pci_bar_type
    does, so we don't need to test the pci_bar_type return value.
    
    decode_bar() used to return pci_bar_type, which we no longer need.  We
    can simplify it a bit by returning the struct resource flags rather than
    updating them internally.
    
    In pci_update_resource(), there's no need to decode the BAR type bits
    again; we can just test for IORESOURCE_MEM_64 directly.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index bc0e6eea0fff..319f359906e8 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -74,8 +74,7 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 			resno, new, check);
 	}
 
-	if ((new & (PCI_BASE_ADDRESS_SPACE|PCI_BASE_ADDRESS_MEM_TYPE_MASK)) ==
-	    (PCI_BASE_ADDRESS_SPACE_MEMORY|PCI_BASE_ADDRESS_MEM_TYPE_64)) {
+	if (res->flags & IORESOURCE_MEM_64) {
 		new = region.start >> 16 >> 16;
 		pci_write_config_dword(dev, reg + 4, new);
 		pci_read_config_dword(dev, reg + 4, &check);

commit 1bcd495be9ed3194f618e8af0446459dc52a1423
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Sep 29 12:23:54 2010 -0600

    PCI: fix message typo
    
    I missed the closing parenthesis on "(PCI address ...)".
    
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Reported-by: Peter Maydell <peter.maydell@linaro.org>
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 2aaa13150de3..bc0e6eea0fff 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -85,7 +85,7 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 		}
 	}
 	res->flags &= ~IORESOURCE_UNSET;
-	dev_info(&dev->dev, "BAR %d: set to %pR (PCI address [%#llx-%#llx]\n",
+	dev_info(&dev->dev, "BAR %d: set to %pR (PCI address [%#llx-%#llx])\n",
 		 resno, res, (unsigned long long)region.start,
 		 (unsigned long long)region.end);
 }

commit 58c84eda07560a6b75b03e8d3b26d6eddfc14011
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jul 15 09:41:42 2010 -0600

    PCI: fall back to original BIOS BAR addresses
    
    If we fail to assign resources to a PCI BAR, this patch makes us try the
    original address from BIOS rather than leaving it disabled.
    
    Linux tries to make sure all PCI device BARs are inside the upstream
    PCI host bridge or P2P bridge apertures, reassigning BARs if necessary.
    Windows does similar reassignment.
    
    Before this patch, if we could not move a BAR into an aperture, we left
    the resource unassigned, i.e., at address zero.  Windows leaves such BARs
    at the original BIOS addresses, and this patch makes Linux do the same.
    
    This is a bit ugly because we disable the resource long before we try to
    reassign it, so we have to keep track of the BIOS BAR address somewhere.
    For lack of a better place, I put it in the struct pci_dev.
    
    I think it would be cleaner to attempt the assignment immediately when the
    claim fails, so we could easily remember the original address.  But we
    currently claim motherboard resources in the middle, after attempting to
    claim PCI resources and before assigning new PCI resources, and changing
    that is a fairly big job.
    
    Addresses https://bugzilla.kernel.org/show_bug.cgi?id=16263
    
    Reported-by: Andrew <nitr0@seti.kr.ua>
    Tested-by: Andrew <nitr0@seti.kr.ua>
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 92379e2d37e7..2aaa13150de3 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -156,6 +156,38 @@ static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
 					     pcibios_align_resource, dev);
 	}
 
+	if (ret < 0 && dev->fw_addr[resno]) {
+		struct resource *root, *conflict;
+		resource_size_t start, end;
+
+		/*
+		 * If we failed to assign anything, let's try the address
+		 * where firmware left it.  That at least has a chance of
+		 * working, which is better than just leaving it disabled.
+		 */
+
+		if (res->flags & IORESOURCE_IO)
+			root = &ioport_resource;
+		else
+			root = &iomem_resource;
+
+		start = res->start;
+		end = res->end;
+		res->start = dev->fw_addr[resno];
+		res->end = res->start + size - 1;
+		dev_info(&dev->dev, "BAR %d: trying firmware assignment %pR\n",
+			 resno, res);
+		conflict = request_resource_conflict(root, res);
+		if (conflict) {
+			dev_info(&dev->dev,
+				 "BAR %d: %pR conflicts with %s %pR\n", resno,
+				 res, conflict->name, conflict);
+			res->start = start;
+			res->end = end;
+		} else
+			ret = 0;
+	}
+
 	if (!ret) {
 		res->flags &= ~IORESOURCE_STARTALIGN;
 		dev_info(&dev->dev, "BAR %d: assigned %pR\n", resno, res);

commit f6d440daebd12be66ea1f834faf2966a49a07bd6
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jun 3 13:47:18 2010 -0600

    PCI: change resource collision messages from KERN_ERR to KERN_INFO
    
    We can often deal with PCI resource issues by moving devices around.  In
    that case, there's no point in alarming the user with messages like these.
    There are many bug reports where the message itself is the only problem,
    e.g., https://bugs.launchpad.net/ubuntu/+source/linux/+bug/413419 .
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 17bed18d24ad..92379e2d37e7 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -97,16 +97,16 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 
 	root = pci_find_parent_resource(dev, res);
 	if (!root) {
-		dev_err(&dev->dev, "no compatible bridge window for %pR\n",
-			res);
+		dev_info(&dev->dev, "no compatible bridge window for %pR\n",
+			 res);
 		return -EINVAL;
 	}
 
 	conflict = request_resource_conflict(root, res);
 	if (conflict) {
-		dev_err(&dev->dev,
-			"address space collision: %pR conflicts with %s %pR\n",
-			res, conflict->name, conflict);
+		dev_info(&dev->dev,
+			 "address space collision: %pR conflicts with %s %pR\n",
+			 res, conflict->name, conflict);
 		return -EBUSY;
 	}
 

commit 966f3a7570447c5025d67a618d408e68a3ae3167
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Mar 11 17:01:19 2010 -0700

    PCI: for address space collisions, show conflicting resource
    
    With request_resource_conflict(), we can learn what the actual conflict is,
    so print that info for debugging purposes.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 7d678bb15ffb..17bed18d24ad 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -93,8 +93,7 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 int pci_claim_resource(struct pci_dev *dev, int resource)
 {
 	struct resource *res = &dev->resource[resource];
-	struct resource *root;
-	int err;
+	struct resource *root, *conflict;
 
 	root = pci_find_parent_resource(dev, res);
 	if (!root) {
@@ -103,12 +102,15 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 		return -EINVAL;
 	}
 
-	err = request_resource(root, res);
-	if (err)
+	conflict = request_resource_conflict(root, res);
+	if (conflict) {
 		dev_err(&dev->dev,
-			"address space collision: %pR already in use\n", res);
+			"address space collision: %pR conflicts with %s %pR\n",
+			res, conflict->name, conflict);
+		return -EBUSY;
+	}
 
-	return err;
+	return 0;
 }
 EXPORT_SYMBOL(pci_claim_resource);
 

commit 865df576e8fc70daf297b53e61a4fbefc719d065
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Nov 4 10:32:57 2009 -0700

    PCI: improve discovery/configuration messages
    
    This makes PCI resource management messages more consistent and adds a few
    new messages to aid debugging.
    
    Whenever we assign resources to a device, update a BAR, or change a
    bridge aperture, it's worth noting it.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 357ca5c54607..7d678bb15ffb 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -51,12 +51,6 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 
 	pcibios_resource_to_bus(dev, &region, res);
 
-	dev_dbg(&dev->dev, "BAR %d: got res %pR bus [%#llx-%#llx] "
-		"flags %#lx\n", resno, res,
-		 (unsigned long long)region.start,
-		 (unsigned long long)region.end,
-		 (unsigned long)res->flags);
-
 	new = region.start | (res->flags & PCI_REGION_FLAG_MASK);
 	if (res->flags & IORESOURCE_IO)
 		mask = (u32)PCI_BASE_ADDRESS_IO_MASK;
@@ -91,9 +85,9 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 		}
 	}
 	res->flags &= ~IORESOURCE_UNSET;
-	dev_dbg(&dev->dev, "BAR %d: moved to %pR (bus addr [%#llx-%#llx])\n",
-		resno, res, (unsigned long long)region.start,
-		(unsigned long long)region.end);
+	dev_info(&dev->dev, "BAR %d: set to %pR (PCI address [%#llx-%#llx]\n",
+		 resno, res, (unsigned long long)region.start,
+		 (unsigned long long)region.end);
 }
 
 int pci_claim_resource(struct pci_dev *dev, int resource)
@@ -103,20 +97,17 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 	int err;
 
 	root = pci_find_parent_resource(dev, res);
-
-	err = -EINVAL;
-	if (root != NULL)
-		err = request_resource(root, res);
-
-	if (err) {
-		const char *dtype = resource < PCI_BRIDGE_RESOURCES ? "device" : "bridge";
-		dev_err(&dev->dev, "BAR %d: %s of %s %pR\n",
-			resource,
-			root ? "address space collision on" :
-				"no parent found for",
-			dtype, res);
+	if (!root) {
+		dev_err(&dev->dev, "no compatible bridge window for %pR\n",
+			res);
+		return -EINVAL;
 	}
 
+	err = request_resource(root, res);
+	if (err)
+		dev_err(&dev->dev,
+			"address space collision: %pR already in use\n", res);
+
 	return err;
 }
 EXPORT_SYMBOL(pci_claim_resource);
@@ -124,7 +115,7 @@ EXPORT_SYMBOL(pci_claim_resource);
 #ifdef CONFIG_PCI_QUIRKS
 void pci_disable_bridge_window(struct pci_dev *dev)
 {
-	dev_dbg(&dev->dev, "Disabling bridge window.\n");
+	dev_info(&dev->dev, "disabling bridge mem windows\n");
 
 	/* MMIO Base/Limit */
 	pci_write_config_dword(dev, PCI_MEMORY_BASE, 0x0000fff0);
@@ -165,6 +156,7 @@ static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
 
 	if (!ret) {
 		res->flags &= ~IORESOURCE_STARTALIGN;
+		dev_info(&dev->dev, "BAR %d: assigned %pR\n", resno, res);
 		if (resno < PCI_BRIDGE_RESOURCES)
 			pci_update_resource(dev, resno);
 	}
@@ -178,10 +170,11 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	resource_size_t align;
 	struct pci_bus *bus;
 	int ret;
+	char *type;
 
 	align = pci_resource_alignment(dev, res);
 	if (!align) {
-		dev_info(&dev->dev, "BAR %d: can't allocate %pR "
+		dev_info(&dev->dev, "BAR %d: can't assign %pR "
 			 "(bogus alignment)\n", resno, res);
 		return -EINVAL;
 	}
@@ -197,9 +190,20 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 		break;
 	}
 
-	if (ret)
-		dev_info(&dev->dev, "BAR %d: can't allocate %pR\n",
-			 resno, res);
+	if (ret) {
+		if (res->flags & IORESOURCE_MEM)
+			if (res->flags & IORESOURCE_PREFETCH)
+				type = "mem pref";
+			else
+				type = "mem";
+		else if (res->flags & IORESOURCE_IO)
+			type = "io";
+		else
+			type = "unknown";
+		dev_info(&dev->dev,
+			 "BAR %d: can't assign %s (size %#llx)\n",
+			 resno, type, (unsigned long long) resource_size(res));
+	}
 
 	return ret;
 }
@@ -272,8 +276,8 @@ int pci_enable_resources(struct pci_dev *dev, int mask)
 			continue;
 
 		if (!r->parent) {
-			dev_err(&dev->dev, "device not available because of "
-				"BAR %d %pR collisions\n", i, r);
+			dev_err(&dev->dev, "device not available "
+				"(can't reserve %pR)\n", r);
 			return -EINVAL;
 		}
 

commit c7dabef8a2c59e6a3de9d66fc35fb6a43ef7172d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 27 13:26:47 2009 -0600

    vsprintf: use %pR, %pr instead of %pRt, %pRf
    
    Jesse accidentally applied v1 [1] of the patchset instead of v2 [2].  This
    is the diff between v1 and v2.
    
    The changes in this patch are:
        - tidied vsprintf stack buffer to shrink and compute size more
          accurately
        - use %pR for decoding and %pr for "raw" (with type and flags) instead
          of adding %pRt and %pRf
    
    [1] http://lkml.org/lkml/2009/10/6/491
    [2] http://lkml.org/lkml/2009/10/13/441
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 5e78f2096ce8..357ca5c54607 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -51,9 +51,11 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 
 	pcibios_resource_to_bus(dev, &region, res);
 
-	dev_dbg(&dev->dev, "BAR %d: got %pRf (bus addr [%#llx-%#llx])\n",
-		resno, res, (unsigned long long)region.start,
-		(unsigned long long)region.end);
+	dev_dbg(&dev->dev, "BAR %d: got res %pR bus [%#llx-%#llx] "
+		"flags %#lx\n", resno, res,
+		 (unsigned long long)region.start,
+		 (unsigned long long)region.end,
+		 (unsigned long)res->flags);
 
 	new = region.start | (res->flags & PCI_REGION_FLAG_MASK);
 	if (res->flags & IORESOURCE_IO)
@@ -89,8 +91,8 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 		}
 	}
 	res->flags &= ~IORESOURCE_UNSET;
-	dev_dbg(&dev->dev, "BAR %d: moved to bus addr [%#llx-%#llx]\n",
-		resno, (unsigned long long)region.start,
+	dev_dbg(&dev->dev, "BAR %d: moved to %pR (bus addr [%#llx-%#llx])\n",
+		resno, res, (unsigned long long)region.start,
 		(unsigned long long)region.end);
 }
 
@@ -108,7 +110,7 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 
 	if (err) {
 		const char *dtype = resource < PCI_BRIDGE_RESOURCES ? "device" : "bridge";
-		dev_err(&dev->dev, "BAR %d: %s %s %pRt\n",
+		dev_err(&dev->dev, "BAR %d: %s of %s %pR\n",
 			resource,
 			root ? "address space collision on" :
 				"no parent found for",
@@ -179,7 +181,7 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 
 	align = pci_resource_alignment(dev, res);
 	if (!align) {
-		dev_info(&dev->dev, "BAR %d: can't allocate %pRf "
+		dev_info(&dev->dev, "BAR %d: can't allocate %pR "
 			 "(bogus alignment)\n", resno, res);
 		return -EINVAL;
 	}
@@ -196,7 +198,7 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	}
 
 	if (ret)
-		dev_info(&dev->dev, "BAR %d: can't allocate %pRt\n",
+		dev_info(&dev->dev, "BAR %d: can't allocate %pR\n",
 			 resno, res);
 
 	return ret;
@@ -222,7 +224,7 @@ void pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 
 		r_align = pci_resource_alignment(dev, r);
 		if (!r_align) {
-			dev_warn(&dev->dev, "BAR %d: bogus alignment %pRf\n",
+			dev_warn(&dev->dev, "BAR %d: %pR has bogus alignment\n",
 				 i, r);
 			continue;
 		}

commit a369c791e881503a6253dafc0d0ad5e41e5557e5
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 6 15:33:44 2009 -0600

    PCI: print resources consistently with %pRt
    
    This uses %pRt to print additional resource information (type, size,
    prefetchability, etc.) consistently.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index c54526b206b5..5e78f2096ce8 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -51,11 +51,9 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 
 	pcibios_resource_to_bus(dev, &region, res);
 
-	dev_dbg(&dev->dev, "BAR %d: got res %pR bus [%#llx-%#llx] "
-		"flags %#lx\n", resno, res,
-		 (unsigned long long)region.start,
-		 (unsigned long long)region.end,
-		 (unsigned long)res->flags);
+	dev_dbg(&dev->dev, "BAR %d: got %pRf (bus addr [%#llx-%#llx])\n",
+		resno, res, (unsigned long long)region.start,
+		(unsigned long long)region.end);
 
 	new = region.start | (res->flags & PCI_REGION_FLAG_MASK);
 	if (res->flags & IORESOURCE_IO)
@@ -91,9 +89,9 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 		}
 	}
 	res->flags &= ~IORESOURCE_UNSET;
-	dev_dbg(&dev->dev, "BAR %d: moved to bus [%#llx-%#llx] flags %#lx\n",
+	dev_dbg(&dev->dev, "BAR %d: moved to bus addr [%#llx-%#llx]\n",
 		resno, (unsigned long long)region.start,
-		(unsigned long long)region.end, res->flags);
+		(unsigned long long)region.end);
 }
 
 int pci_claim_resource(struct pci_dev *dev, int resource)
@@ -110,7 +108,7 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 
 	if (err) {
 		const char *dtype = resource < PCI_BRIDGE_RESOURCES ? "device" : "bridge";
-		dev_err(&dev->dev, "BAR %d: %s of %s %pR\n",
+		dev_err(&dev->dev, "BAR %d: %s %s %pRt\n",
 			resource,
 			root ? "address space collision on" :
 				"no parent found for",
@@ -181,9 +179,8 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 
 	align = pci_resource_alignment(dev, res);
 	if (!align) {
-		dev_info(&dev->dev, "BAR %d: can't allocate resource (bogus "
-			"alignment) %pR flags %#lx\n",
-			resno, res, res->flags);
+		dev_info(&dev->dev, "BAR %d: can't allocate %pRf "
+			 "(bogus alignment)\n", resno, res);
 		return -EINVAL;
 	}
 
@@ -199,8 +196,8 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	}
 
 	if (ret)
-		dev_info(&dev->dev, "BAR %d: can't allocate %s resource %pR\n",
-			resno, res->flags & IORESOURCE_IO ? "I/O" : "mem", res);
+		dev_info(&dev->dev, "BAR %d: can't allocate %pRt\n",
+			 resno, res);
 
 	return ret;
 }
@@ -225,9 +222,8 @@ void pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 
 		r_align = pci_resource_alignment(dev, r);
 		if (!r_align) {
-			dev_warn(&dev->dev, "BAR %d: bogus alignment "
-				"%pR flags %#lx\n",
-				i, r, r->flags);
+			dev_warn(&dev->dev, "BAR %d: bogus alignment %pRf\n",
+				 i, r);
 			continue;
 		}
 		for (list = head; ; list = list->next) {

commit b812cca4e2efe9a05de20ccf3f8587e7ac6e12fa
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Oct 5 16:38:13 2009 -0600

    PCI: remove pci_assign_resource_fixed()
    
    Adrian commented out this function in 2baad5f96b49, but I don't think
    it's even worth cluttering the file with the unused code.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 706f82d8111f..c54526b206b5 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -205,43 +205,6 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	return ret;
 }
 
-#if 0
-int pci_assign_resource_fixed(struct pci_dev *dev, int resno)
-{
-	struct pci_bus *bus = dev->bus;
-	struct resource *res = dev->resource + resno;
-	unsigned int type_mask;
-	int i, ret = -EBUSY;
-
-	type_mask = IORESOURCE_IO | IORESOURCE_MEM | IORESOURCE_PREFETCH;
-
-	for (i = 0; i < PCI_BUS_NUM_RESOURCES; i++) {
-		struct resource *r = bus->resource[i];
-		if (!r)
-			continue;
-
-		/* type_mask must match */
-		if ((res->flags ^ r->flags) & type_mask)
-			continue;
-
-		ret = request_resource(r, res);
-
-		if (ret == 0)
-			break;
-	}
-
-	if (ret) {
-		dev_err(&dev->dev, "BAR %d: can't allocate %s resource %pR\n",
-			resno, res->flags & IORESOURCE_IO ? "I/O" : "mem", res);
-	} else if (resno < PCI_BRIDGE_RESOURCES) {
-		pci_update_resource(dev, resno);
-	}
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(pci_assign_resource_fixed);
-#endif
-
 /* Sort resources by alignment */
 void pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 {

commit eaa959df299157e2640fcb3321537501b6afd9e6
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Tue Jun 30 21:45:44 2009 -0700

    PCI: export pci_claim_resource for driver use
    
    yenta needs this for example.
    
    Acked-by: Matthew Wilcox <willy@linux.intel.com>
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 88cdd1a937d6..706f82d8111f 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -119,6 +119,7 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 
 	return err;
 }
+EXPORT_SYMBOL(pci_claim_resource);
 
 #ifdef CONFIG_PCI_QUIRKS
 void pci_disable_bridge_window(struct pci_dev *dev)

commit 6faf17f6f1ffc586d16efc2f9fa2083a7785ee74
Author: Chris Wright <chrisw@sous-sol.org>
Date:   Fri Aug 28 13:00:06 2009 -0700

    PCI SR-IOV: correct broken resource alignment calculations
    
    An SR-IOV capable device includes an SR-IOV PCIe capability which
    describes the Virtual Function (VF) BAR requirements.  A typical SR-IOV
    device can support multiple VFs whose BARs must be in a contiguous region,
    effectively an array of VF BARs.  The BAR reports the size requirement
    for a single VF.  We calculate the full range needed by simply multiplying
    the VF BAR size with the number of possible VFs and create a resource
    spanning the full range.
    
    This all seems sane enough except it artificially inflates the alignment
    requirement for the VF BAR.  The VF BAR need only be aligned to the size
    of a single BAR not the contiguous range of VF BARs.  This can cause us
    to fail to allocate resources for the BAR despite the fact that we
    actually have enough space.
    
    This patch adds a thin PCI specific layer over the generic
    resource_alignment() function which is aware of the special nature of
    VF BARs and does sorting and allocation based on the smaller alignment
    requirement.
    
    I recognize that while resource_alignment is generic, it's basically a
    PCI helper.  An alternative to this patch is to add PCI VF BAR specific
    information to struct resource.  I opted for the extra layer rather than
    adding such PCI specific information to struct resource.  This does
    have the slight downside that we don't cache the BAR size and re-read
    for each alignment query (happens a small handful of times during boot
    for each VF BAR).
    
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Yu Zhao <yu.zhao@intel.com>
    Cc: stable@kernel.org
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 1898c7b47907..88cdd1a937d6 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -144,7 +144,7 @@ static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
 
 	size = resource_size(res);
 	min = (res->flags & IORESOURCE_IO) ? PCIBIOS_MIN_IO : PCIBIOS_MIN_MEM;
-	align = resource_alignment(res);
+	align = pci_resource_alignment(dev, res);
 
 	/* First, try exact prefetching match.. */
 	ret = pci_bus_alloc_resource(bus, res, size, align, min,
@@ -178,7 +178,7 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	struct pci_bus *bus;
 	int ret;
 
-	align = resource_alignment(res);
+	align = pci_resource_alignment(dev, res);
 	if (!align) {
 		dev_info(&dev->dev, "BAR %d: can't allocate resource (bogus "
 			"alignment) %pR flags %#lx\n",
@@ -259,7 +259,7 @@ void pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 		if (!(r->flags) || r->parent)
 			continue;
 
-		r_align = resource_alignment(r);
+		r_align = pci_resource_alignment(dev, r);
 		if (!r_align) {
 			dev_warn(&dev->dev, "BAR %d: bogus alignment "
 				"%pR flags %#lx\n",
@@ -271,7 +271,7 @@ void pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 			struct resource_list *ln = list->next;
 
 			if (ln)
-				align = resource_alignment(ln->res);
+				align = pci_resource_alignment(ln->dev, ln->res);
 
 			if (r_align > align) {
 				tmp = kmalloc(sizeof(*tmp), GFP_KERNEL);

commit 79896cf42f6a96d7e14f2dc3473443d68d74031d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Aug 2 14:04:19 2009 -0700

    Make pci_claim_resource() use request_resource() rather than insert_resource()
    
    This function has traditionally used "insert_resource()", because before
    commit cebd78a8c5 ("Fix pci_claim_resource") it used to just insert the
    resource into whatever root resource tree that was indicated by
    "pcibios_select_root()".
    
    So there Matthew fixed it to actually look up the proper parent
    resource, which means that now it's actively wrong to then traverse the
    resource tree any more: we already know exactly where the new resource
    should go.
    
    And when we then did commit a76117dfd6 ("x86: Use pci_claim_resource"),
    which changed the x86 PCI code from the open-coded
    
            pr = pci_find_parent_resource(dev, r);
            if (!pr || request_resource(pr, r) < 0) {
    
    to using
    
            if (pci_claim_resource(dev, idx) < 0) {
    
    that "insert_resource()" now suddenly became a problem, and causes a
    regression covered by
    
            http://bugzilla.kernel.org/show_bug.cgi?id=13891
    
    which this fixes.
    
    Reported-and-tested-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Matthew Wilcox <willy@linux.intel.com>
    Cc: Andrew Patterson <andrew.patterson@hp.com>
    Cc: Linux PCI <linux-pci@vger.kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index b711fb7181e2..1898c7b47907 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -100,16 +100,16 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 {
 	struct resource *res = &dev->resource[resource];
 	struct resource *root;
-	char *dtype = resource < PCI_BRIDGE_RESOURCES ? "device" : "bridge";
 	int err;
 
 	root = pci_find_parent_resource(dev, res);
 
 	err = -EINVAL;
 	if (root != NULL)
-		err = insert_resource(root, res);
+		err = request_resource(root, res);
 
 	if (err) {
+		const char *dtype = resource < PCI_BRIDGE_RESOURCES ? "device" : "bridge";
 		dev_err(&dev->dev, "BAR %d: %s of %s %pR\n",
 			resource,
 			root ? "address space collision on" :

commit 59ef7a83f1127038a433464597df02e2dc9540e7
Merge: 5165aece0efa 2af5066f664c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 22 11:59:51 2009 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (74 commits)
      PCI: make msi_free_irqs() to use msix_mask_irq() instead of open coded write
      PCI: Fix the NIU MSI-X problem in a better way
      PCI ASPM: remove get_root_port_link
      PCI ASPM: cleanup pcie_aspm_sanity_check
      PCI ASPM: remove has_switch field
      PCI ASPM: cleanup calc_Lx_latency
      PCI ASPM: cleanup pcie_aspm_get_cap_device
      PCI ASPM: cleanup clkpm checks
      PCI ASPM: cleanup __pcie_aspm_check_state_one
      PCI ASPM: cleanup initialization
      PCI ASPM: cleanup change input argument of aspm functions
      PCI ASPM: cleanup misc in struct pcie_link_state
      PCI ASPM: cleanup clkpm state in struct pcie_link_state
      PCI ASPM: cleanup latency field in struct pcie_link_state
      PCI ASPM: cleanup aspm state field in struct pcie_link_state
      PCI ASPM: fix typo in struct pcie_link_state
      PCI: drivers/pci/slot.c should depend on CONFIG_SYSFS
      PCI: remove redundant __msi_set_enable()
      PCI PM: consistently use type bool for wake enable variable
      x86/ACPI: Correct maximum allowed _CRS returned resources and warn if exceeded
      ...

commit cebd78a8c5624b5cf04c39c3335a5fc8670a7b69
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Wed Jun 17 16:33:33 2009 -0400

    Fix pci_claim_resource
    
    Instead of starting from the iomem or ioport roots, start from the
    parent bus' resources.  This fixes a bug where child resources would
    appear above their parents resources if they had the same size.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Tested-by: Andrew Patterson <andrew.patterson@hp.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 3039fcb86afc..12403516776a 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -99,11 +99,11 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 int pci_claim_resource(struct pci_dev *dev, int resource)
 {
 	struct resource *res = &dev->resource[resource];
-	struct resource *root = NULL;
+	struct resource *root;
 	char *dtype = resource < PCI_BRIDGE_RESOURCES ? "device" : "bridge";
 	int err;
 
-	root = pcibios_select_root(dev, res);
+	root = pci_find_parent_resource(dev, res);
 
 	err = -EINVAL;
 	if (root != NULL)

commit d09ee9687e027fc7d2c6b95daf05a8ef3ff06340
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Apr 23 20:49:25 2009 -0700

    PCI: improve resource allocation under transparent bridges
    
    We could run out of space under under 4g, but devices under transparent
    bridges can use 64bit resources, so keep trying on the parent bus until
    we hit a non-transparent bridge.
    
    Impact: better support for assigning unassigned resources
    
    Reviewed-by: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 3039fcb86afc..0b6908b48935 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -135,23 +135,16 @@ void pci_disable_bridge_window(struct pci_dev *dev)
 }
 #endif	/* CONFIG_PCI_QUIRKS */
 
-int pci_assign_resource(struct pci_dev *dev, int resno)
+static int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
+				 int resno)
 {
-	struct pci_bus *bus = dev->bus;
 	struct resource *res = dev->resource + resno;
 	resource_size_t size, min, align;
 	int ret;
 
 	size = resource_size(res);
 	min = (res->flags & IORESOURCE_IO) ? PCIBIOS_MIN_IO : PCIBIOS_MIN_MEM;
-
 	align = resource_alignment(res);
-	if (!align) {
-		dev_info(&dev->dev, "BAR %d: can't allocate resource (bogus "
-			"alignment) %pR flags %#lx\n",
-			resno, res, res->flags);
-		return -EINVAL;
-	}
 
 	/* First, try exact prefetching match.. */
 	ret = pci_bus_alloc_resource(bus, res, size, align, min,
@@ -169,10 +162,7 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 					     pcibios_align_resource, dev);
 	}
 
-	if (ret) {
-		dev_info(&dev->dev, "BAR %d: can't allocate %s resource %pR\n",
-			resno, res->flags & IORESOURCE_IO ? "I/O" : "mem", res);
-	} else {
+	if (!ret) {
 		res->flags &= ~IORESOURCE_STARTALIGN;
 		if (resno < PCI_BRIDGE_RESOURCES)
 			pci_update_resource(dev, resno);
@@ -181,6 +171,39 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	return ret;
 }
 
+int pci_assign_resource(struct pci_dev *dev, int resno)
+{
+	struct resource *res = dev->resource + resno;
+	resource_size_t align;
+	struct pci_bus *bus;
+	int ret;
+
+	align = resource_alignment(res);
+	if (!align) {
+		dev_info(&dev->dev, "BAR %d: can't allocate resource (bogus "
+			"alignment) %pR flags %#lx\n",
+			resno, res, res->flags);
+		return -EINVAL;
+	}
+
+	bus = dev->bus;
+	while ((ret = __pci_assign_resource(bus, dev, resno))) {
+		if (bus->parent && bus->self->transparent)
+			bus = bus->parent;
+		else
+			bus = NULL;
+		if (bus)
+			continue;
+		break;
+	}
+
+	if (ret)
+		dev_info(&dev->dev, "BAR %d: can't allocate %s resource %pR\n",
+			resno, res->flags & IORESOURCE_IO ? "I/O" : "mem", res);
+
+	return ret;
+}
+
 #if 0
 int pci_assign_resource_fixed(struct pci_dev *dev, int resno)
 {

commit 32a9a682bef2f6fce7026bd94d1ce20028b0e52d
Author: Yuji Shimada <shimada-yxb@necst.nec.co.jp>
Date:   Mon Mar 16 17:13:39 2009 +0900

    PCI: allow assignment of memory resources with a specified alignment
    
    This patch allows memory resources to be assigned with a specified
    alignment at boot-time or run-time. The patch is useful when we use PCI
    pass-through, because page-aligned memory resources are required to
    securely share PCI resources with guest drivers.
    
    If you want to assign the resource at boot time, please set
    "pci=resource_alignment=" boot parameter.
    
    This is format of "pci=resource_alignment=" boot parameter:
    
            [<order of align>@][<domain>:]<bus>:<slot>.<func>[; ...]
                    Specifies alignment and device to reassign
                    aligned memory resources.
                    If <order of align> is not specified, PAGE_SIZE is
                    used as alignment.
                    PCI-PCI bridge can be specified, if resource
                    windows need to be expanded.
    
    This is example:
    
            pci=resource_alignment=20@07:00.0;18@0f:00.0;00:1d.7
    
    If you want to assign the resource at run-time, please set
    "/sys/bus/pci/resource_alignment" file, and hot-remove the device and
    hot-add the device.  For this purpose, fakephp or PCI hotplug interfaces
    can be used.
    
    The format of "/sys/bus/pci/resource_alignment" file is the same with
    boot parameter. You can use "," instead of ";".
    
    For example:
    
            # cd /sys/bus/pci
            # echo -n 20@12:00.0 > resource_alignment
            # echo 1 > devices/0000:12:00.0/remove
            # echo 1 > rescan
    
    Reviewed-by: Alex Chiang <achiang@hp.com>
    Reviewed-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Yuji Shimada <shimada-yxb@necst.nec.co.jp>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 32e8d88a4619..3039fcb86afc 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -120,6 +120,21 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 	return err;
 }
 
+#ifdef CONFIG_PCI_QUIRKS
+void pci_disable_bridge_window(struct pci_dev *dev)
+{
+	dev_dbg(&dev->dev, "Disabling bridge window.\n");
+
+	/* MMIO Base/Limit */
+	pci_write_config_dword(dev, PCI_MEMORY_BASE, 0x0000fff0);
+
+	/* Prefetchable MMIO Base/Limit */
+	pci_write_config_dword(dev, PCI_PREF_LIMIT_UPPER32, 0);
+	pci_write_config_dword(dev, PCI_PREF_MEMORY_BASE, 0x0000fff0);
+	pci_write_config_dword(dev, PCI_PREF_BASE_UPPER32, 0xffffffff);
+}
+#endif	/* CONFIG_PCI_QUIRKS */
+
 int pci_assign_resource(struct pci_dev *dev, int resno)
 {
 	struct pci_bus *bus = dev->bus;

commit 613e7ed6f72b1a115f7ece8ce1b66cf095de1348
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Sat Nov 22 02:41:27 2008 +0800

    PCI: add a new function to map BAR offsets
    
    Add a function to map a given resource number to a corresponding
    register so drivers can get the offset and type of device specific BARs.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 3c5203ff53c7..32e8d88a4619 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -31,6 +31,7 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 	struct pci_bus_region region;
 	u32 new, check, mask;
 	int reg;
+	enum pci_bar_type type;
 	struct resource *res = dev->resource + resno;
 
 	/*
@@ -62,17 +63,13 @@ void pci_update_resource(struct pci_dev *dev, int resno)
 	else
 		mask = (u32)PCI_BASE_ADDRESS_MEM_MASK;
 
-	if (resno < 6) {
-		reg = PCI_BASE_ADDRESS_0 + 4 * resno;
-	} else if (resno == PCI_ROM_RESOURCE) {
+	reg = pci_resource_bar(dev, resno, &type);
+	if (!reg)
+		return;
+	if (type != pci_bar_unknown) {
 		if (!(res->flags & IORESOURCE_ROM_ENABLE))
 			return;
 		new |= PCI_ROM_ADDRESS_ENABLE;
-		reg = dev->rom_base_reg;
-	} else {
-		/* Hmm, non-standard resource. */
-	
-		return;		/* kill uninitialised var warning */
 	}
 
 	pci_write_config_dword(dev, reg, new);

commit 14add80b5120966fe0659d61815b9e9b4b68fdc5
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Sat Nov 22 02:38:52 2008 +0800

    PCI: remove unnecessary arg of pci_update_resource()
    
    This cleanup removes unnecessary argument 'struct resource *res' in
    pci_update_resource(), so it takes same arguments as other companion
    functions (pci_assign_resource(), etc.).
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 4e375632499a..3c5203ff53c7 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -26,11 +26,12 @@
 #include "pci.h"
 
 
-void pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
+void pci_update_resource(struct pci_dev *dev, int resno)
 {
 	struct pci_bus_region region;
 	u32 new, check, mask;
 	int reg;
+	struct resource *res = dev->resource + resno;
 
 	/*
 	 * Ignore resources for unimplemented BARs and unused resource slots
@@ -162,7 +163,7 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	} else {
 		res->flags &= ~IORESOURCE_STARTALIGN;
 		if (resno < PCI_BRIDGE_RESOURCES)
-			pci_update_resource(dev, res, resno);
+			pci_update_resource(dev, resno);
 	}
 
 	return ret;
@@ -197,7 +198,7 @@ int pci_assign_resource_fixed(struct pci_dev *dev, int resno)
 		dev_err(&dev->dev, "BAR %d: can't allocate %s resource %pR\n",
 			resno, res->flags & IORESOURCE_IO ? "I/O" : "mem", res);
 	} else if (resno < PCI_BRIDGE_RESOURCES) {
-		pci_update_resource(dev, res, resno);
+		pci_update_resource(dev, resno);
 	}
 
 	return ret;

commit 104bafcfab7ce3031399e60069949f10acecc022
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Dec 12 06:49:40 2008 +0100

    PCI: Don't carp about BAR allocation failures in quiet boot
    
    These are easy to trigger (more or less harmlessly) with multiple video
    cards, since the ROM BAR will typically not be given any space by the
    BIOS bridge setup.  No reason to punish quiet boot for this.
    
    Signed-off-by: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 2dbd96cce2d8..4e375632499a 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -134,7 +134,7 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 
 	align = resource_alignment(res);
 	if (!align) {
-		dev_err(&dev->dev, "BAR %d: can't allocate resource (bogus "
+		dev_info(&dev->dev, "BAR %d: can't allocate resource (bogus "
 			"alignment) %pR flags %#lx\n",
 			resno, res, res->flags);
 		return -EINVAL;
@@ -157,7 +157,7 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	}
 
 	if (ret) {
-		dev_err(&dev->dev, "BAR %d: can't allocate %s resource %pR\n",
+		dev_info(&dev->dev, "BAR %d: can't allocate %s resource %pR\n",
 			resno, res->flags & IORESOURCE_IO ? "I/O" : "mem", res);
 	} else {
 		res->flags &= ~IORESOURCE_STARTALIGN;

commit 022edd86d7c864bc8fadc3c8ac4e6a464472ab05
Author: Zhao, Yu <yu.zhao@intel.com>
Date:   Mon Oct 13 19:24:28 2008 +0800

    PCI: use resource_size() everywhere.
    
    This is a cleanup that replaces the resource calculation formula with
    resource_size().
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index d4b5c690eaa7..2dbd96cce2d8 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -129,7 +129,7 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	resource_size_t size, min, align;
 	int ret;
 
-	size = res->end - res->start + 1;
+	size = resource_size(res);
 	min = (res->flags & IORESOURCE_IO) ? PCIBIOS_MIN_IO : PCIBIOS_MIN_MEM;
 
 	align = resource_alignment(res);

commit 096e6f673dc02a6394dc9a7d8f8735c6978f5b91
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Oct 20 15:07:37 2008 +1100

    pci: Use new %pR to print resource ranges
    
    This converts things in drivers/pci to use %pR to printout the
    content of a struct resource instead of hand-casted %llx or
    other variants.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 1a5fc83c71b3..d4b5c690eaa7 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -49,10 +49,8 @@ void pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
 
 	pcibios_resource_to_bus(dev, &region, res);
 
-	dev_dbg(&dev->dev, "BAR %d: got res [%#llx-%#llx] bus [%#llx-%#llx] "
-		"flags %#lx\n", resno,
-		 (unsigned long long)res->start,
-		 (unsigned long long)res->end,
+	dev_dbg(&dev->dev, "BAR %d: got res %pR bus [%#llx-%#llx] "
+		"flags %#lx\n", resno, res,
 		 (unsigned long long)region.start,
 		 (unsigned long long)region.end,
 		 (unsigned long)res->flags);
@@ -114,13 +112,11 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 		err = insert_resource(root, res);
 
 	if (err) {
-		dev_err(&dev->dev, "BAR %d: %s of %s [%#llx-%#llx]\n",
+		dev_err(&dev->dev, "BAR %d: %s of %s %pR\n",
 			resource,
 			root ? "address space collision on" :
 				"no parent found for",
-			dtype,
-			(unsigned long long)res->start,
-			(unsigned long long)res->end);
+			dtype, res);
 	}
 
 	return err;
@@ -139,9 +135,8 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	align = resource_alignment(res);
 	if (!align) {
 		dev_err(&dev->dev, "BAR %d: can't allocate resource (bogus "
-			"alignment) [%#llx-%#llx] flags %#lx\n",
-			resno, (unsigned long long)res->start,
-			(unsigned long long)res->end, res->flags);
+			"alignment) %pR flags %#lx\n",
+			resno, res, res->flags);
 		return -EINVAL;
 	}
 
@@ -162,11 +157,8 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	}
 
 	if (ret) {
-		dev_err(&dev->dev, "BAR %d: can't allocate %s resource "
-			"[%#llx-%#llx]\n", resno,
-			res->flags & IORESOURCE_IO ? "I/O" : "mem",
-			(unsigned long long)res->start,
-			(unsigned long long)res->end);
+		dev_err(&dev->dev, "BAR %d: can't allocate %s resource %pR\n",
+			resno, res->flags & IORESOURCE_IO ? "I/O" : "mem", res);
 	} else {
 		res->flags &= ~IORESOURCE_STARTALIGN;
 		if (resno < PCI_BRIDGE_RESOURCES)
@@ -202,11 +194,8 @@ int pci_assign_resource_fixed(struct pci_dev *dev, int resno)
 	}
 
 	if (ret) {
-		dev_err(&dev->dev, "BAR %d: can't allocate %s resource "
-			"[%#llx-%#llx\n]", resno,
-			res->flags & IORESOURCE_IO ? "I/O" : "mem",
-			(unsigned long long)res->start,
-			(unsigned long long)res->end);
+		dev_err(&dev->dev, "BAR %d: can't allocate %s resource %pR\n",
+			resno, res->flags & IORESOURCE_IO ? "I/O" : "mem", res);
 	} else if (resno < PCI_BRIDGE_RESOURCES) {
 		pci_update_resource(dev, res, resno);
 	}
@@ -237,9 +226,8 @@ void pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 		r_align = resource_alignment(r);
 		if (!r_align) {
 			dev_warn(&dev->dev, "BAR %d: bogus alignment "
-				"[%#llx-%#llx] flags %#lx\n",
-				i, (unsigned long long)r->start,
-				(unsigned long long)r->end, r->flags);
+				"%pR flags %#lx\n",
+				i, r, r->flags);
 			continue;
 		}
 		for (list = head; ; list = list->next) {
@@ -287,9 +275,7 @@ int pci_enable_resources(struct pci_dev *dev, int mask)
 
 		if (!r->parent) {
 			dev_err(&dev->dev, "device not available because of "
-				"BAR %d [%#llx-%#llx] collisions\n", i,
-				(unsigned long long) r->start,
-				(unsigned long long) r->end);
+				"BAR %d %pR collisions\n", i, r);
 			return -EINVAL;
 		}
 

commit 80ccba1186d48fa728dc4b1456cc07ffb07da501
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 13 10:52:11 2008 -0600

    PCI: use dev_printk when possible
    
    Convert printks to use dev_printk().
    
    I converted pr_debug() to dev_dbg().  Both use KERN_DEBUG and are enabled
    only when DEBUG is defined.
    
    I converted printk(KERN_DEBUG) to dev_printk(KERN_DEBUG), not to dev_dbg(),
    because dev_dbg() is only enabled when DEBUG is defined.
    
    I converted DBG(KERN_INFO) (only in setup-bus.c) to dev_info().  The DBG()
    name makes it sound like debug, but it's been enabled forever, so dev_info()
    preserves the previous behavior.
    
    I tried to make the resource assignment formats more consistent, e.g.,
      "BAR %d: got res [%#llx-%#llx] bus [%#llx-%#llx] flags %#lx\n"
    instead of sometimes using "start-end" and sometimes using "size@start".
    I'm not attached to one or the other; I'd just like them consistent.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 7d35cdf4579f..1a5fc83c71b3 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -26,8 +26,7 @@
 #include "pci.h"
 
 
-void
-pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
+void pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
 {
 	struct pci_bus_region region;
 	u32 new, check, mask;
@@ -43,20 +42,20 @@ pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
 	/*
 	 * Ignore non-moveable resources.  This might be legacy resources for
 	 * which no functional BAR register exists or another important
-	 * system resource we should better not move around in system address
-	 * space.
+	 * system resource we shouldn't move around.
 	 */
 	if (res->flags & IORESOURCE_PCI_FIXED)
 		return;
 
 	pcibios_resource_to_bus(dev, &region, res);
 
-	pr_debug("  got res [%llx:%llx] bus [%llx:%llx] flags %lx for "
-		 "BAR %d of %s\n", (unsigned long long)res->start,
+	dev_dbg(&dev->dev, "BAR %d: got res [%#llx-%#llx] bus [%#llx-%#llx] "
+		"flags %#lx\n", resno,
+		 (unsigned long long)res->start,
 		 (unsigned long long)res->end,
 		 (unsigned long long)region.start,
 		 (unsigned long long)region.end,
-		 (unsigned long)res->flags, resno, pci_name(dev));
+		 (unsigned long)res->flags);
 
 	new = region.start | (res->flags & PCI_REGION_FLAG_MASK);
 	if (res->flags & IORESOURCE_IO)
@@ -81,9 +80,8 @@ pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
 	pci_read_config_dword(dev, reg, &check);
 
 	if ((new ^ check) & mask) {
-		printk(KERN_ERR "PCI: Error while updating region "
-		       "%s/%d (%08x != %08x)\n", pci_name(dev), resno,
-		       new, check);
+		dev_err(&dev->dev, "BAR %d: error updating (%#08x != %#08x)\n",
+			resno, new, check);
 	}
 
 	if ((new & (PCI_BASE_ADDRESS_SPACE|PCI_BASE_ADDRESS_MEM_TYPE_MASK)) ==
@@ -92,15 +90,14 @@ pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
 		pci_write_config_dword(dev, reg + 4, new);
 		pci_read_config_dword(dev, reg + 4, &check);
 		if (check != new) {
-			printk(KERN_ERR "PCI: Error updating region "
-			       "%s/%d (high %08x != %08x)\n",
-			       pci_name(dev), resno, new, check);
+			dev_err(&dev->dev, "BAR %d: error updating "
+			       "(high %#08x != %#08x)\n", resno, new, check);
 		}
 	}
 	res->flags &= ~IORESOURCE_UNSET;
-	pr_debug("PCI: moved device %s resource %d (%lx) to %x\n",
-		pci_name(dev), resno, res->flags,
-		new & ~PCI_REGION_FLAG_MASK);
+	dev_dbg(&dev->dev, "BAR %d: moved to bus [%#llx-%#llx] flags %#lx\n",
+		resno, (unsigned long long)region.start,
+		(unsigned long long)region.end, res->flags);
 }
 
 int pci_claim_resource(struct pci_dev *dev, int resource)
@@ -117,10 +114,11 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 		err = insert_resource(root, res);
 
 	if (err) {
-		printk(KERN_ERR "PCI: %s region %d of %s %s [%llx:%llx]\n",
-			root ? "Address space collision on" :
-				"No parent found for",
-			resource, dtype, pci_name(dev),
+		dev_err(&dev->dev, "BAR %d: %s of %s [%#llx-%#llx]\n",
+			resource,
+			root ? "address space collision on" :
+				"no parent found for",
+			dtype,
 			(unsigned long long)res->start,
 			(unsigned long long)res->end);
 	}
@@ -140,11 +138,10 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 
 	align = resource_alignment(res);
 	if (!align) {
-		printk(KERN_ERR "PCI: Cannot allocate resource (bogus "
-			"alignment) %d [%llx:%llx] (flags %lx) of %s\n",
+		dev_err(&dev->dev, "BAR %d: can't allocate resource (bogus "
+			"alignment) [%#llx-%#llx] flags %#lx\n",
 			resno, (unsigned long long)res->start,
-			(unsigned long long)res->end, res->flags,
-			pci_name(dev));
+			(unsigned long long)res->end, res->flags);
 		return -EINVAL;
 	}
 
@@ -165,11 +162,11 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	}
 
 	if (ret) {
-		printk(KERN_ERR "PCI: Failed to allocate %s resource "
-			"#%d:%llx@%llx for %s\n",
+		dev_err(&dev->dev, "BAR %d: can't allocate %s resource "
+			"[%#llx-%#llx]\n", resno,
 			res->flags & IORESOURCE_IO ? "I/O" : "mem",
-			resno, (unsigned long long)size,
-			(unsigned long long)res->start, pci_name(dev));
+			(unsigned long long)res->start,
+			(unsigned long long)res->end);
 	} else {
 		res->flags &= ~IORESOURCE_STARTALIGN;
 		if (resno < PCI_BRIDGE_RESOURCES)
@@ -205,11 +202,11 @@ int pci_assign_resource_fixed(struct pci_dev *dev, int resno)
 	}
 
 	if (ret) {
-		printk(KERN_ERR "PCI: Failed to allocate %s resource "
-				"#%d:%llx@%llx for %s\n",
+		dev_err(&dev->dev, "BAR %d: can't allocate %s resource "
+			"[%#llx-%#llx\n]", resno,
 			res->flags & IORESOURCE_IO ? "I/O" : "mem",
-			resno, (unsigned long long)(res->end - res->start + 1),
-			(unsigned long long)res->start, pci_name(dev));
+			(unsigned long long)res->start,
+			(unsigned long long)res->end);
 	} else if (resno < PCI_BRIDGE_RESOURCES) {
 		pci_update_resource(dev, res, resno);
 	}
@@ -239,11 +236,10 @@ void pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 
 		r_align = resource_alignment(r);
 		if (!r_align) {
-			printk(KERN_WARNING "PCI: bogus alignment of resource "
-				"%d [%llx:%llx] (flags %lx) of %s\n",
+			dev_warn(&dev->dev, "BAR %d: bogus alignment "
+				"[%#llx-%#llx] flags %#lx\n",
 				i, (unsigned long long)r->start,
-				(unsigned long long)r->end, r->flags,
-				pci_name(dev));
+				(unsigned long long)r->end, r->flags);
 			continue;
 		}
 		for (list = head; ; list = list->next) {
@@ -291,7 +287,7 @@ int pci_enable_resources(struct pci_dev *dev, int mask)
 
 		if (!r->parent) {
 			dev_err(&dev->dev, "device not available because of "
-				"BAR %d [%llx:%llx] collisions\n", i,
+				"BAR %d [%#llx-%#llx] collisions\n", i,
 				(unsigned long long) r->start,
 				(unsigned long long) r->end);
 			return -EINVAL;

commit 884525655d07fdee9245716b998ecdc45cdd8007
Author: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
Date:   Sun Mar 30 19:50:14 2008 +0400

    PCI: clean up resource alignment management
    
    Done per Linus' request and suggestions. Linus has explained that
    better than I'll be able to explain:
    
    On Thu, Mar 27, 2008 at 10:12:10AM -0700, Linus Torvalds wrote:
    > Actually, before we go any further, there might be a less intrusive
    > alternative: add just a couple of flags to the resource flags field (we
    > still have something like 8 unused bits on 32-bit), and use those to
    > implement a generic "resource_alignment()" routine.
    >
    > Two flags would do it:
    >
    >  - IORESOURCE_SIZEALIGN: size indicates alignment (regular PCI device
    >    resources)
    >
    >  - IORESOURCE_STARTALIGN: start field is alignment (PCI bus resources
    >    during probing)
    >
    > and then the case of both flags zero (or both bits set) would actually be
    > "invalid", and we would also clear the IORESOURCE_STARTALIGN flag when we
    > actually allocate the resource (so that we don't use the "start" field as
    > alignment incorrectly when it no longer indicates alignment).
    >
    > That wouldn't be totally generic, but it would have the nice property of
    > automatically at least add sanity checking for that whole "res->start has
    > the odd meaning of 'alignment' during probing" and remove the need for a
    > new field, and it would allow us to have a generic "resource_alignment()"
    > routine that just gets a resource pointer.
    
    Besides, I removed IORESOURCE_BUS_HAS_VGA flag which was unused for ages.
    
    Signed-off-by: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Gary Hade <garyhade@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index bad509e40fbc..7d35cdf4579f 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -137,10 +137,16 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 
 	size = res->end - res->start + 1;
 	min = (res->flags & IORESOURCE_IO) ? PCIBIOS_MIN_IO : PCIBIOS_MIN_MEM;
-	/* The bridge resources are special, as their
-	   size != alignment. Sizing routines return
-	   required alignment in the "start" field. */
-	align = (resno < PCI_BRIDGE_RESOURCES) ? size : res->start;
+
+	align = resource_alignment(res);
+	if (!align) {
+		printk(KERN_ERR "PCI: Cannot allocate resource (bogus "
+			"alignment) %d [%llx:%llx] (flags %lx) of %s\n",
+			resno, (unsigned long long)res->start,
+			(unsigned long long)res->end, res->flags,
+			pci_name(dev));
+		return -EINVAL;
+	}
 
 	/* First, try exact prefetching match.. */
 	ret = pci_bus_alloc_resource(bus, res, size, align, min,
@@ -164,8 +170,10 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 			res->flags & IORESOURCE_IO ? "I/O" : "mem",
 			resno, (unsigned long long)size,
 			(unsigned long long)res->start, pci_name(dev));
-	} else if (resno < PCI_BRIDGE_RESOURCES) {
-		pci_update_resource(dev, res, resno);
+	} else {
+		res->flags &= ~IORESOURCE_STARTALIGN;
+		if (resno < PCI_BRIDGE_RESOURCES)
+			pci_update_resource(dev, res, resno);
 	}
 
 	return ret;
@@ -226,29 +234,25 @@ void pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 		if (r->flags & IORESOURCE_PCI_FIXED)
 			continue;
 
-		r_align = r->end - r->start;
-		
 		if (!(r->flags) || r->parent)
 			continue;
+
+		r_align = resource_alignment(r);
 		if (!r_align) {
-			printk(KERN_WARNING "PCI: Ignore bogus resource %d "
-				"[%llx:%llx] of %s\n",
+			printk(KERN_WARNING "PCI: bogus alignment of resource "
+				"%d [%llx:%llx] (flags %lx) of %s\n",
 				i, (unsigned long long)r->start,
-				(unsigned long long)r->end, pci_name(dev));
+				(unsigned long long)r->end, r->flags,
+				pci_name(dev));
 			continue;
 		}
-		r_align = (i < PCI_BRIDGE_RESOURCES) ? r_align + 1 : r->start;
 		for (list = head; ; list = list->next) {
 			resource_size_t align = 0;
 			struct resource_list *ln = list->next;
-			int idx;
 
-			if (ln) {
-				idx = ln->res - &ln->dev->resource[0];
-				align = (idx < PCI_BRIDGE_RESOURCES) ?
-					ln->res->end - ln->res->start + 1 :
-					ln->res->start;
-			}
+			if (ln)
+				align = resource_alignment(ln->res);
+
 			if (r_align > align) {
 				tmp = kmalloc(sizeof(*tmp), GFP_KERNEL);
 				if (!tmp)

commit 842de40d93e00a5c40a1a7f520a6fbe422994e99
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 4 11:56:47 2008 -0700

    PCI: add generic pci_enable_resources()
    
    Each architecture has its own pcibios_enable_resources() implementation.
    These differ in many minor ways that have nothing to do with actual
    architectural differences.  Follow-on patches will make most arches
    use this generic version instead.
    
    This version is based on powerpc, which seemed most up-to-date.  The only
    functional difference from the x86 version is that this uses "!r->parent"
    to check for resource collisions instead of "!r->start && r->end".
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 9e4d485ba9cd..bad509e40fbc 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -263,3 +263,46 @@ void pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 		}
 	}
 }
+
+int pci_enable_resources(struct pci_dev *dev, int mask)
+{
+	u16 cmd, old_cmd;
+	int i;
+	struct resource *r;
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	old_cmd = cmd;
+
+	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
+		if (!(mask & (1 << i)))
+			continue;
+
+		r = &dev->resource[i];
+
+		if (!(r->flags & (IORESOURCE_IO | IORESOURCE_MEM)))
+			continue;
+		if ((i == PCI_ROM_RESOURCE) &&
+				(!(r->flags & IORESOURCE_ROM_ENABLE)))
+			continue;
+
+		if (!r->parent) {
+			dev_err(&dev->dev, "device not available because of "
+				"BAR %d [%llx:%llx] collisions\n", i,
+				(unsigned long long) r->start,
+				(unsigned long long) r->end);
+			return -EINVAL;
+		}
+
+		if (r->flags & IORESOURCE_IO)
+			cmd |= PCI_COMMAND_IO;
+		if (r->flags & IORESOURCE_MEM)
+			cmd |= PCI_COMMAND_MEMORY;
+	}
+
+	if (cmd != old_cmd) {
+		dev_info(&dev->dev, "enabling device (%04x -> %04x)\n",
+			 old_cmd, cmd);
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+	}
+	return 0;
+}

commit 2baad5f96b498812626eadb6f6af3eb41d8656a3
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Feb 13 23:30:12 2008 +0200

    PCI: #if 0 pci_assign_resource_fixed()
    
    An unused function that bloated the kernel only when CONFIG_EMBEDDED was
    enabled...
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 4be7ccf7e3ae..9e4d485ba9cd 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -171,7 +171,7 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	return ret;
 }
 
-#ifdef CONFIG_EMBEDDED
+#if 0
 int pci_assign_resource_fixed(struct pci_dev *dev, int resno)
 {
 	struct pci_bus *bus = dev->bus;

commit 6015fbefc4dfe1706b64d33c256878b8296d1470
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Dec 10 17:32:16 2007 +1100

    PCI: Fix warning in setup-res.c on 32-bit platforms with 64-bit resources
    
    This adds appropriate casts to avoid a warning and print the correct
    values in pr_debug.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index cb7388c0406f..4be7ccf7e3ae 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -51,10 +51,12 @@ pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
 
 	pcibios_resource_to_bus(dev, &region, res);
 
-	pr_debug("  got res [%llx:%llx] bus [%lx:%lx] flags %lx for "
+	pr_debug("  got res [%llx:%llx] bus [%llx:%llx] flags %lx for "
 		 "BAR %d of %s\n", (unsigned long long)res->start,
 		 (unsigned long long)res->end,
-		 region.start, region.end, res->flags, resno, pci_name(dev));
+		 (unsigned long long)region.start,
+		 (unsigned long long)region.end,
+		 (unsigned long)res->flags, resno, pci_name(dev));
 
 	new = region.start | (res->flags & PCI_REGION_FLAG_MASK);
 	if (res->flags & IORESOURCE_IO)

commit eb003ec26556057e5f27d4b989bbb432d0bdc0f4
Author: Adrian Bunk <bunk@kernel.org>
Date:   Sat Oct 27 03:06:33 2007 +0200

    PCI: drivers/pci/: remove unused exports
    
    This patch removes the following unused exports:
    - remove the following unused EXPORT_SYMBOL's:
     - pci-acpi.c: pci_osc_support_set
     - proc.c: pci_proc_detach_bus
    - remove the following unused EXPORT_SYMBOL_GPL's:
      - bus.c: pci_walk_bus
      - probe.c: pci_create_bus
      - setup-res.c: pci_claim_resource
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 6dfd86167e39..cb7388c0406f 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -125,7 +125,6 @@ int pci_claim_resource(struct pci_dev *dev, int resource)
 
 	return err;
 }
-EXPORT_SYMBOL_GPL(pci_claim_resource);
 
 int pci_assign_resource(struct pci_dev *dev, int resno)
 {

commit 96bde06a2df1b363206d3cdef53134b84ff37813
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Mar 26 21:53:30 2007 -0800

    pci: do not mark exported functions as __devinit
    
    Functions marked __devinit will be removed after kernel init.  But being
    exported they are potentially called by a module much later.
    
    So the safer choice seems to be to keep the function even in the non
    CONFIG_HOTPLUG case.
    
    This silence the follwoing section mismatch warnings:
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_add_device from __ksymtab_gpl between '__ksymtab_pci_bus_add_device' (at offset 0x20) and '__ksymtab_pci_walk_bus'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_create_bus from __ksymtab_gpl between '__ksymtab_pci_create_bus' (at offset 0x40) and '__ksymtab_pci_stop_bus_device'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_max_busnr from __ksymtab_gpl between '__ksymtab_pci_bus_max_busnr' (at offset 0xc0) and '__ksymtab_pci_assign_resource_fixed'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_claim_resource from __ksymtab_gpl between '__ksymtab_pci_claim_resource' (at offset 0xe0) and '__ksymtab_pcie_port_bus_type'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_add_devices from __ksymtab between '__ksymtab_pci_bus_add_devices' (at offset 0x70) and '__ksymtab_pci_bus_alloc_resource'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_scan_bus_parented from __ksymtab between '__ksymtab_pci_scan_bus_parented' (at offset 0x90) and '__ksymtab_pci_root_buses'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_assign_resources from __ksymtab between '__ksymtab_pci_bus_assign_resources' (at offset 0x4d0) and '__ksymtab_pci_bus_size_bridges'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_size_bridges from __ksymtab between '__ksymtab_pci_bus_size_bridges' (at offset 0x4e0) and '__ksymtab_pci_setup_cardbus'
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index cb4ced3560e9..6dfd86167e39 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -101,8 +101,7 @@ pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
 		new & ~PCI_REGION_FLAG_MASK);
 }
 
-int __devinit
-pci_claim_resource(struct pci_dev *dev, int resource)
+int pci_claim_resource(struct pci_dev *dev, int resource)
 {
 	struct resource *res = &dev->resource[resource];
 	struct resource *root = NULL;
@@ -212,8 +211,7 @@ EXPORT_SYMBOL_GPL(pci_assign_resource_fixed);
 #endif
 
 /* Sort resources by alignment */
-void __devinit
-pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
+void pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 {
 	int i;
 

commit fb0f2b40faff41f03acaa2ee6e6231fc96ca497c
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Dec 19 13:12:08 2006 -0800

    PCI legacy resource fix
    
    Since commit 368c73d4f689dae0807d0a2aa74c61fd2b9b075f the kernel will try
    to update the non-writeable BAR registers 0..3 of PIIX4 IDE adapters if
    pci_assign_unassigned_resources() is used to do full resource assignment of
    the bus.  This fails because in the PIIX4 these BAR registers have
    implicitly assumed values and read back as zero; it used to work because
    the kernel used to just write zero to that register the read back value did
    match what was written.
    
    The fix is a new resource flag IORESOURCE_PCI_FIXED used to mark a resource
    as non-movable.  This will also be useful to keep other import system
    resources from being moved around - for example system consoles on PCI
    busses.
    
    [akpm@osdl.org: cleanup]
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index ab78e4bbdd83..cb4ced3560e9 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -33,11 +33,22 @@ pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
 	u32 new, check, mask;
 	int reg;
 
-	/* Ignore resources for unimplemented BARs and unused resource slots
-	   for 64 bit BARs. */
+	/*
+	 * Ignore resources for unimplemented BARs and unused resource slots
+	 * for 64 bit BARs.
+	 */
 	if (!res->flags)
 		return;
 
+	/*
+	 * Ignore non-moveable resources.  This might be legacy resources for
+	 * which no functional BAR register exists or another important
+	 * system resource we should better not move around in system address
+	 * space.
+	 */
+	if (res->flags & IORESOURCE_PCI_FIXED)
+		return;
+
 	pcibios_resource_to_bus(dev, &region, res);
 
 	pr_debug("  got res [%llx:%llx] bus [%lx:%lx] flags %lx for "
@@ -212,6 +223,10 @@ pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 		resource_size_t r_align;
 
 		r = &dev->resource[i];
+
+		if (r->flags & IORESOURCE_PCI_FIXED)
+			continue;
+
 		r_align = r->end - r->start;
 		
 		if (!(r->flags) || r->parent)

commit e31dd6e4520439ceae4753f32dd2da2c345e929a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 17:06:02 2006 -0700

    [PATCH] 64bit resource: change pci core and arch code to use resource_size_t
    
    Based on a patch series originally from Vivek Goyal <vgoyal@in.ibm.com>
    
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index f5ff0d3ba620..ab78e4bbdd83 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -121,7 +121,7 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 {
 	struct pci_bus *bus = dev->bus;
 	struct resource *res = dev->resource + resno;
-	unsigned long size, min, align;
+	resource_size_t size, min, align;
 	int ret;
 
 	size = res->end - res->start + 1;
@@ -209,7 +209,7 @@ pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
 		struct resource *r;
 		struct resource_list *list, *tmp;
-		unsigned long r_align;
+		resource_size_t r_align;
 
 		r = &dev->resource[i];
 		r_align = r->end - r->start;
@@ -225,7 +225,7 @@ pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 		}
 		r_align = (i < PCI_BRIDGE_RESOURCES) ? r_align + 1 : r->start;
 		for (list = head; ; list = list->next) {
-			unsigned long align = 0;
+			resource_size_t align = 0;
 			struct resource_list *ln = list->next;
 			int idx;
 

commit 1396a8c3f7cec9f5e0d00bd089be21fc468f0f1c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 15:14:29 2006 -0700

    [PATCH] 64bit resource: fix up printks for resources in pci core and hotplug drivers
    
    This is needed if we wish to change the size of the resource structures.
    
    Based on an original patch from Vivek Goyal <vgoyal@in.ibm.com>
    
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 577f4b55c46d..f5ff0d3ba620 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -40,8 +40,9 @@ pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
 
 	pcibios_resource_to_bus(dev, &region, res);
 
-	pr_debug("  got res [%lx:%lx] bus [%lx:%lx] flags %lx for "
-		 "BAR %d of %s\n", res->start, res->end,
+	pr_debug("  got res [%llx:%llx] bus [%lx:%lx] flags %lx for "
+		 "BAR %d of %s\n", (unsigned long long)res->start,
+		 (unsigned long long)res->end,
 		 region.start, region.end, res->flags, resno, pci_name(dev));
 
 	new = region.start | (res->flags & PCI_REGION_FLAG_MASK);
@@ -104,10 +105,12 @@ pci_claim_resource(struct pci_dev *dev, int resource)
 		err = insert_resource(root, res);
 
 	if (err) {
-		printk(KERN_ERR "PCI: %s region %d of %s %s [%lx:%lx]\n",
-		       root ? "Address space collision on" :
-			      "No parent found for",
-		       resource, dtype, pci_name(dev), res->start, res->end);
+		printk(KERN_ERR "PCI: %s region %d of %s %s [%llx:%llx]\n",
+			root ? "Address space collision on" :
+				"No parent found for",
+			resource, dtype, pci_name(dev),
+			(unsigned long long)res->start,
+			(unsigned long long)res->end);
 	}
 
 	return err;
@@ -145,9 +148,11 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	}
 
 	if (ret) {
-		printk(KERN_ERR "PCI: Failed to allocate %s resource #%d:%lx@%lx for %s\n",
-		       res->flags & IORESOURCE_IO ? "I/O" : "mem",
-		       resno, size, res->start, pci_name(dev));
+		printk(KERN_ERR "PCI: Failed to allocate %s resource "
+			"#%d:%llx@%llx for %s\n",
+			res->flags & IORESOURCE_IO ? "I/O" : "mem",
+			resno, (unsigned long long)size,
+			(unsigned long long)res->start, pci_name(dev));
 	} else if (resno < PCI_BRIDGE_RESOURCES) {
 		pci_update_resource(dev, res, resno);
 	}
@@ -213,8 +218,9 @@ pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 			continue;
 		if (!r_align) {
 			printk(KERN_WARNING "PCI: Ignore bogus resource %d "
-					    "[%lx:%lx] of %s\n",
-					    i, r->start, r->end, pci_name(dev));
+				"[%llx:%llx] of %s\n",
+				i, (unsigned long long)r->start,
+				(unsigned long long)r->end, pci_name(dev));
 			continue;
 		}
 		r_align = (i < PCI_BRIDGE_RESOURCES) ? r_align + 1 : r->start;

commit 75acfecaa031c0e1bc412cee4fe58ba49ff3406c
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Mon May 1 10:43:46 2006 -0500

    [PATCH] PCI: Add pci_assign_resource_fixed -- allow fixed address assignments
    
    PCI: Add pci_assign_resource_fixed -- allow fixed address assignments
    
    On some embedded systems the PCI address for hotplug devices are not only
    known a priori but are required to be at a given PCI address for other
    master in the system to be able to access.
    
    An example of such a system would be an FPGA which is setup from user space
    after the system has booted.  The FPGA may be access by DSPs in the system
    and those DSPs expect the FPGA at a fixed PCI address.
    
    Added pci_assign_resource_fixed() as a way to allow assignment of the PCI
    devices's BARs at fixed PCI addresses.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index ea9277b7f899..577f4b55c46d 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -155,6 +155,46 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 	return ret;
 }
 
+#ifdef CONFIG_EMBEDDED
+int pci_assign_resource_fixed(struct pci_dev *dev, int resno)
+{
+	struct pci_bus *bus = dev->bus;
+	struct resource *res = dev->resource + resno;
+	unsigned int type_mask;
+	int i, ret = -EBUSY;
+
+	type_mask = IORESOURCE_IO | IORESOURCE_MEM | IORESOURCE_PREFETCH;
+
+	for (i = 0; i < PCI_BUS_NUM_RESOURCES; i++) {
+		struct resource *r = bus->resource[i];
+		if (!r)
+			continue;
+
+		/* type_mask must match */
+		if ((res->flags ^ r->flags) & type_mask)
+			continue;
+
+		ret = request_resource(r, res);
+
+		if (ret == 0)
+			break;
+	}
+
+	if (ret) {
+		printk(KERN_ERR "PCI: Failed to allocate %s resource "
+				"#%d:%llx@%llx for %s\n",
+			res->flags & IORESOURCE_IO ? "I/O" : "mem",
+			resno, (unsigned long long)(res->end - res->start + 1),
+			(unsigned long long)res->start, pci_name(dev));
+	} else if (resno < PCI_BRIDGE_RESOURCES) {
+		pci_update_resource(dev, res, resno);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pci_assign_resource_fixed);
+#endif
+
 /* Sort resources by alignment */
 void __devinit
 pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)

commit dd8c49966854a5245f3ed4769c9114e7afd819ef
Author: linas <linas@austin.ibm.com>
Date:   Tue Jan 10 15:15:47 2006 -0600

    [PATCH] PCI Hotplug/powerpc: module build break
    
    The RPAPHP hoplug driver will not build as a module, because it calls
    on pci_claim_resource(), which is not exported. This exports the symbol.
    Problem reported by Olaf Hering <olh@suse.de>
    
    A grep indicates that building drivers/parisc/lba_pci.c
    would have trouble building as a module for the same reason.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 50d6685dcbcc..ea9277b7f899 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -112,6 +112,7 @@ pci_claim_resource(struct pci_dev *dev, int resource)
 
 	return err;
 }
+EXPORT_SYMBOL_GPL(pci_claim_resource);
 
 int pci_assign_resource(struct pci_dev *dev, int resno)
 {

commit 085ae41f66657a9655ce832b0a61832a06f0e1dc
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Aug 8 13:19:08 2005 -0700

    [PATCH] Make sparc64 use setup-res.c
    
    There were three changes necessary in order to allow
    sparc64 to use setup-res.c:
    
    1) Sparc64 roots the PCI I/O and MEM address space using
       parent resources contained in the PCI controller structure.
       I'm actually surprised no other platforms do this, especially
       ones like Alpha and PPC{,64}.  These resources get linked into the
       iomem/ioport tree when PCI controllers are probed.
    
       So the hierarchy looks like this:
    
       iomem --|
               PCI controller 1 MEM space --|
                                            device 1
                                            device 2
                                            etc.
               PCI controller 2 MEM space --|
                                            ...
       ioport --|
                PCI controller 1 IO space --|
                                            ...
                PCI controller 2 IO space --|
                                            ...
    
       You get the idea.  The drivers/pci/setup-res.c code allocates
       using plain iomem_space and ioport_space as the root, so that
       wouldn't work with the above setup.
    
       So I added a pcibios_select_root() that is used to handle this.
       It uses the PCI controller struct's io_space and mem_space on
       sparc64, and io{port,mem}_resource on every other platform to
       keep current behavior.
    
    2) quirk_io_region() is buggy.  It takes in raw BUS view addresses
       and tries to use them as a PCI resource.
    
       pci_claim_resource() expects the resource to be fully formed when
       it gets called.  The sparc64 implementation would do the translation
       but that's absolutely wrong, because if the same resource gets
       released then re-claimed we'll adjust things twice.
    
       So I fixed up quirk_io_region() to do the proper pcibios_bus_to_resource()
       conversion before passing it on to pci_claim_resource().
    
    3) I was mistakedly __init'ing the function methods the PCI controller
       drivers provide on sparc64 to implement some parts of these
       routines.  This was, of course, easy to fix.
    
    So we end up with the following, and that nasty SPARC64 makefile
    ifdef in drivers/pci/Makefile is finally zapped.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 362f93337a34..50d6685dcbcc 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -97,10 +97,7 @@ pci_claim_resource(struct pci_dev *dev, int resource)
 	char *dtype = resource < PCI_BRIDGE_RESOURCES ? "device" : "bridge";
 	int err;
 
-	if (res->flags & IORESOURCE_IO)
-		root = &ioport_resource;
-	if (res->flags & IORESOURCE_MEM)
-		root = &iomem_resource;
+	root = pcibios_select_root(dev, res);
 
 	err = -EINVAL;
 	if (root != NULL)

commit 064b53dbcc977dbf2753a67c2b8fc1c061d74f21
Author: John W. Linville <linville@tuxdriver.com>
Date:   Wed Jul 27 10:19:44 2005 -0400

    [PATCH] PCI: restore BAR values after D3hot->D0 for devices that need it
    
    Some PCI devices (e.g. 3c905B, 3c556B) lose all configuration
    (including BARs) when transitioning from D3hot->D0.  This leaves such
    a device in an inaccessible state.  The patch below causes the BARs
    to be restored when enabling such a device, so that its driver will
    be able to access it.
    
    The patch also adds pci_restore_bars as a new global symbol, and adds a
    correpsonding EXPORT_SYMBOL_GPL for that.
    
    Some firmware (e.g. Thinkpad T21) leaves devices in D3hot after a
    (re)boot.  Most drivers call pci_enable_device very early, so devices
    left in D3hot that lose configuration during the D3hot->D0 transition
    will be inaccessible to their drivers.
    
    Drivers could be modified to account for this, but it would
    be difficult to know which drivers need modification.  This is
    especially true since often many devices are covered by the same
    driver.  It likely would be necessary to replicate code across dozens
    of drivers.
    
    The patch below should trigger only when transitioning from D3hot->D0
    (or at boot), and only for devices that have the "no soft reset" bit
    cleared in the PM control register.  I believe it is safe to include
    this patch as part of the PCI infrastructure.
    
    The cleanest implementation of pci_restore_bars was to call
    pci_update_resource.  Unfortunately, that does not currently exist
    for the sparc64 architecture.  The patch below includes a null
    implemenation of pci_update_resource for sparc64.
    
    Some have expressed interest in making general use of the the
    pci_restore_bars function, so that has been exported to GPL licensed
    modules.
    
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 5598b4714f77..362f93337a34 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -26,7 +26,7 @@
 #include "pci.h"
 
 
-static void
+void
 pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
 {
 	struct pci_bus_region region;

commit 755528c860b05fcecda1c88a2bdaffcb50760a7f
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Fri Aug 26 10:49:22 2005 -0700

    Ignore disabled ROM resources at setup
    
    Writing even a disabled value seems to mess up some matrox graphics
    cards.  It may be a card-related issue, but we may also be writing
    reserved low bits in the result.
    
    This was a fall-out of switching x86 over to the generic PCI resource
    allocation code, and needs more debugging.  In particular, the old x86
    code defaulted to not doing any resource allocations at all for ROM
    resources.
    
    In the meantime, this has been reported to make X happier by Helge
    Hafting <helgehaf@aitel.hist.no>.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 84eedc965688..5598b4714f77 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -53,7 +53,9 @@ pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
 	if (resno < 6) {
 		reg = PCI_BASE_ADDRESS_0 + 4 * resno;
 	} else if (resno == PCI_ROM_RESOURCE) {
-		new |= res->flags & IORESOURCE_ROM_ENABLE;
+		if (!(res->flags & IORESOURCE_ROM_ENABLE))
+			return;
+		new |= PCI_ROM_ADDRESS_ENABLE;
 		reg = dev->rom_base_reg;
 	} else {
 		/* Hmm, non-standard resource. */

commit dc836b5b6fcde95f750a4790d8200fabaf563dc9
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon Aug 8 18:46:09 2005 -0700

    Revert "[PATCH] PCI: restore BAR values..."
    
    Revert commit fec59a711eef002d4ef9eb8de09dd0a26986eb77, which is
    breaking sparc64 that doesn't have a working pci_update_resource.
    
    We'll re-do this after 2.6.13 when we'll do it all properly.

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 589486704ce3..84eedc965688 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -26,7 +26,7 @@
 #include "pci.h"
 
 
-void
+static void
 pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
 {
 	struct pci_bus_region region;

commit cf7bee5a0bf270a4eace0be39329d6ac0136cc47
Author: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
Date:   Sun Aug 7 13:49:59 2005 +0400

    [PATCH] Fix restore of 64-bit PCI BAR's
    
    For 64-bit BAR[i] only pci_dev->resource[i] is valid, ->resource[i+1]
    slot is unused and contains zeroes in all fields.
    
    So when we update a PCI BAR, all we need is just to check that we're
    going to update a _valid_ resource.
    
    Also make sure to write high bits - use "x >> 16 >> 16" (rather than the
    simpler ">> 32") to avoid warnings on 32-bit architectures where we're
    not going to have any high bits.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 878fd0a65c02..589486704ce3 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -33,6 +33,11 @@ pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
 	u32 new, check, mask;
 	int reg;
 
+	/* Ignore resources for unimplemented BARs and unused resource slots
+	   for 64 bit BARs. */
+	if (!res->flags)
+		return;
+
 	pcibios_resource_to_bus(dev, &region, res);
 
 	pr_debug("  got res [%lx:%lx] bus [%lx:%lx] flags %lx for "
@@ -67,7 +72,7 @@ pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
 
 	if ((new & (PCI_BASE_ADDRESS_SPACE|PCI_BASE_ADDRESS_MEM_TYPE_MASK)) ==
 	    (PCI_BASE_ADDRESS_SPACE_MEMORY|PCI_BASE_ADDRESS_MEM_TYPE_64)) {
-		new = 0; /* currently everyone zeros the high address */
+		new = region.start >> 16 >> 16;
 		pci_write_config_dword(dev, reg + 4, new);
 		pci_read_config_dword(dev, reg + 4, &check);
 		if (check != new) {

commit fec59a711eef002d4ef9eb8de09dd0a26986eb77
Author: John W. Linville <linville@tuxdriver.com>
Date:   Thu Aug 4 18:06:10 2005 -0700

    [PATCH] PCI: restore BAR values after D3hot->D0 for devices that need it
    
    Some PCI devices (e.g. 3c905B, 3c556B) lose all configuration
    (including BARs) when transitioning from D3hot->D0.  This leaves such
    a device in an inaccessible state.  The patch below causes the BARs
    to be restored when enabling such a device, so that its driver will
    be able to access it.
    
    The patch also adds pci_restore_bars as a new global symbol, and adds a
    correpsonding EXPORT_SYMBOL_GPL for that.
    
    Some firmware (e.g. Thinkpad T21) leaves devices in D3hot after a
    (re)boot.  Most drivers call pci_enable_device very early, so devices
    left in D3hot that lose configuration during the D3hot->D0 transition
    will be inaccessible to their drivers.
    
    Drivers could be modified to account for this, but it would
    be difficult to know which drivers need modification.  This is
    especially true since often many devices are covered by the same
    driver.  It likely would be necessary to replicate code across dozens
    of drivers.
    
    The patch below should trigger only when transitioning from D3hot->D0
    (or at boot), and only for devices that have the "no soft reset" bit
    cleared in the PM control register.  I believe it is safe to include
    this patch as part of the PCI infrastructure.
    
    The cleanest implementation of pci_restore_bars was to call
    pci_update_resource.  Unfortunately, that does not currently exist
    for the sparc64 architecture.  The patch below includes a null
    implemenation of pci_update_resource for sparc64.
    
    Some have expressed interest in making general use of the the
    pci_restore_bars function, so that has been exported to GPL licensed
    modules.
    
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 1ca21d2ba11c..878fd0a65c02 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -26,7 +26,7 @@
 #include "pci.h"
 
 
-static void
+void
 pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
 {
 	struct pci_bus_region region;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
new file mode 100644
index 000000000000..1ca21d2ba11c
--- /dev/null
+++ b/drivers/pci/setup-res.c
@@ -0,0 +1,200 @@
+/*
+ *	drivers/pci/setup-res.c
+ *
+ * Extruded from code written by
+ *      Dave Rusling (david.rusling@reo.mts.dec.com)
+ *      David Mosberger (davidm@cs.arizona.edu)
+ *	David Miller (davem@redhat.com)
+ *
+ * Support routines for initializing a PCI subsystem.
+ */
+
+/* fixed for multiple pci buses, 1999 Andrea Arcangeli <andrea@suse.de> */
+
+/*
+ * Nov 2000, Ivan Kokshaysky <ink@jurassic.park.msu.ru>
+ *	     Resource sorting
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/cache.h>
+#include <linux/slab.h>
+#include "pci.h"
+
+
+static void
+pci_update_resource(struct pci_dev *dev, struct resource *res, int resno)
+{
+	struct pci_bus_region region;
+	u32 new, check, mask;
+	int reg;
+
+	pcibios_resource_to_bus(dev, &region, res);
+
+	pr_debug("  got res [%lx:%lx] bus [%lx:%lx] flags %lx for "
+		 "BAR %d of %s\n", res->start, res->end,
+		 region.start, region.end, res->flags, resno, pci_name(dev));
+
+	new = region.start | (res->flags & PCI_REGION_FLAG_MASK);
+	if (res->flags & IORESOURCE_IO)
+		mask = (u32)PCI_BASE_ADDRESS_IO_MASK;
+	else
+		mask = (u32)PCI_BASE_ADDRESS_MEM_MASK;
+
+	if (resno < 6) {
+		reg = PCI_BASE_ADDRESS_0 + 4 * resno;
+	} else if (resno == PCI_ROM_RESOURCE) {
+		new |= res->flags & IORESOURCE_ROM_ENABLE;
+		reg = dev->rom_base_reg;
+	} else {
+		/* Hmm, non-standard resource. */
+	
+		return;		/* kill uninitialised var warning */
+	}
+
+	pci_write_config_dword(dev, reg, new);
+	pci_read_config_dword(dev, reg, &check);
+
+	if ((new ^ check) & mask) {
+		printk(KERN_ERR "PCI: Error while updating region "
+		       "%s/%d (%08x != %08x)\n", pci_name(dev), resno,
+		       new, check);
+	}
+
+	if ((new & (PCI_BASE_ADDRESS_SPACE|PCI_BASE_ADDRESS_MEM_TYPE_MASK)) ==
+	    (PCI_BASE_ADDRESS_SPACE_MEMORY|PCI_BASE_ADDRESS_MEM_TYPE_64)) {
+		new = 0; /* currently everyone zeros the high address */
+		pci_write_config_dword(dev, reg + 4, new);
+		pci_read_config_dword(dev, reg + 4, &check);
+		if (check != new) {
+			printk(KERN_ERR "PCI: Error updating region "
+			       "%s/%d (high %08x != %08x)\n",
+			       pci_name(dev), resno, new, check);
+		}
+	}
+	res->flags &= ~IORESOURCE_UNSET;
+	pr_debug("PCI: moved device %s resource %d (%lx) to %x\n",
+		pci_name(dev), resno, res->flags,
+		new & ~PCI_REGION_FLAG_MASK);
+}
+
+int __devinit
+pci_claim_resource(struct pci_dev *dev, int resource)
+{
+	struct resource *res = &dev->resource[resource];
+	struct resource *root = NULL;
+	char *dtype = resource < PCI_BRIDGE_RESOURCES ? "device" : "bridge";
+	int err;
+
+	if (res->flags & IORESOURCE_IO)
+		root = &ioport_resource;
+	if (res->flags & IORESOURCE_MEM)
+		root = &iomem_resource;
+
+	err = -EINVAL;
+	if (root != NULL)
+		err = insert_resource(root, res);
+
+	if (err) {
+		printk(KERN_ERR "PCI: %s region %d of %s %s [%lx:%lx]\n",
+		       root ? "Address space collision on" :
+			      "No parent found for",
+		       resource, dtype, pci_name(dev), res->start, res->end);
+	}
+
+	return err;
+}
+
+int pci_assign_resource(struct pci_dev *dev, int resno)
+{
+	struct pci_bus *bus = dev->bus;
+	struct resource *res = dev->resource + resno;
+	unsigned long size, min, align;
+	int ret;
+
+	size = res->end - res->start + 1;
+	min = (res->flags & IORESOURCE_IO) ? PCIBIOS_MIN_IO : PCIBIOS_MIN_MEM;
+	/* The bridge resources are special, as their
+	   size != alignment. Sizing routines return
+	   required alignment in the "start" field. */
+	align = (resno < PCI_BRIDGE_RESOURCES) ? size : res->start;
+
+	/* First, try exact prefetching match.. */
+	ret = pci_bus_alloc_resource(bus, res, size, align, min,
+				     IORESOURCE_PREFETCH,
+				     pcibios_align_resource, dev);
+
+	if (ret < 0 && (res->flags & IORESOURCE_PREFETCH)) {
+		/*
+		 * That failed.
+		 *
+		 * But a prefetching area can handle a non-prefetching
+		 * window (it will just not perform as well).
+		 */
+		ret = pci_bus_alloc_resource(bus, res, size, align, min, 0,
+					     pcibios_align_resource, dev);
+	}
+
+	if (ret) {
+		printk(KERN_ERR "PCI: Failed to allocate %s resource #%d:%lx@%lx for %s\n",
+		       res->flags & IORESOURCE_IO ? "I/O" : "mem",
+		       resno, size, res->start, pci_name(dev));
+	} else if (resno < PCI_BRIDGE_RESOURCES) {
+		pci_update_resource(dev, res, resno);
+	}
+
+	return ret;
+}
+
+/* Sort resources by alignment */
+void __devinit
+pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
+{
+	int i;
+
+	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
+		struct resource *r;
+		struct resource_list *list, *tmp;
+		unsigned long r_align;
+
+		r = &dev->resource[i];
+		r_align = r->end - r->start;
+		
+		if (!(r->flags) || r->parent)
+			continue;
+		if (!r_align) {
+			printk(KERN_WARNING "PCI: Ignore bogus resource %d "
+					    "[%lx:%lx] of %s\n",
+					    i, r->start, r->end, pci_name(dev));
+			continue;
+		}
+		r_align = (i < PCI_BRIDGE_RESOURCES) ? r_align + 1 : r->start;
+		for (list = head; ; list = list->next) {
+			unsigned long align = 0;
+			struct resource_list *ln = list->next;
+			int idx;
+
+			if (ln) {
+				idx = ln->res - &ln->dev->resource[0];
+				align = (idx < PCI_BRIDGE_RESOURCES) ?
+					ln->res->end - ln->res->start + 1 :
+					ln->res->start;
+			}
+			if (r_align > align) {
+				tmp = kmalloc(sizeof(*tmp), GFP_KERNEL);
+				if (!tmp)
+					panic("pdev_sort_resources(): "
+					      "kmalloc() failed!\n");
+				tmp->next = ln;
+				tmp->res = r;
+				tmp->dev = dev;
+				list->next = tmp;
+				break;
+			}
+		}
+	}
+}
