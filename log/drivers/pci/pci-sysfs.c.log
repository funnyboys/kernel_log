commit 10e8141baa7c5585c2d1ad98397186689ccf99b3
Merge: 74f0862cc983 bd641fd8303a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Apr 2 14:26:38 2020 -0500

    Merge branch 'pci/misc'
    
      - Move _HPX type array from stack to static data (Colin Ian King)
    
      - Avoid an ASMedia XHCI USB PME# defect; apparently it doesn't assert
        PME# when USB3.0 devices are hotplugged in D0 (Kai-Heng Feng)
    
      - Revert sysfs "rescan" file renames that broke an application (Kelsey
        Skunberg)
    
    * pci/misc:
      PCI: sysfs: Revert "rescan" file renames
      PCI: Avoid ASMedia XHCI USB PME# from D0 defect
      PCI/ACPI: Move pcie_to_hpx3_type[] from stack to static data

commit bd641fd8303a371e789e924291086268256766b0
Author: Kelsey Skunberg <kelsey.skunberg@gmail.com>
Date:   Wed Mar 25 09:17:08 2020 -0600

    PCI: sysfs: Revert "rescan" file renames
    
    We changed these sysfs filenames:
    
      .../pci_bus/<domain:bus>/rescan  ->  .../pci_bus/<domain:bus>/bus_rescan
      .../<domain:bus:dev.fn>/rescan   ->  .../<domain:bus:dev.fn>/dev_rescan
    
    and Ruslan reported [1] that this broke a userspace application.
    
    Revert these name changes so both files are named "rescan" again.
    
    Note that we have to use __ATTR() to assign custom C symbols, i.e.,
    "struct device_attribute <symbol>".
    
    [1] https://lore.kernel.org/r/CAB=otbSYozS-ZfxB0nCiNnxcbqxwrHOSYxJJtDKa63KzXbXgpw@mail.gmail.com
    
    [bhelgaas: commit log, use __ATTR() both places so we don't have to rename
    the attributes]
    Fixes: 8bdfa145f582 ("PCI: sysfs: Define device attributes with DEVICE_ATTR*()")
    Fixes: 4e2b79436e4f ("PCI: sysfs: Change DEVICE_ATTR() to DEVICE_ATTR_WO()")
    Link: https://lore.kernel.org/r/20200325151708.32612-1-skunberg.kelsey@gmail.com
    Signed-off-by: Kelsey Skunberg <kelsey.skunberg@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: stable@vger.kernel.org      # v5.4+

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 13f766db0684..335dd6fbf039 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -464,7 +464,8 @@ static ssize_t dev_rescan_store(struct device *dev,
 	}
 	return count;
 }
-static DEVICE_ATTR_WO(dev_rescan);
+static struct device_attribute dev_attr_dev_rescan = __ATTR(rescan, 0200, NULL,
+							    dev_rescan_store);
 
 static ssize_t remove_store(struct device *dev, struct device_attribute *attr,
 			    const char *buf, size_t count)
@@ -501,7 +502,8 @@ static ssize_t bus_rescan_store(struct device *dev,
 	}
 	return count;
 }
-static DEVICE_ATTR_WO(bus_rescan);
+static struct device_attribute dev_attr_bus_rescan = __ATTR(rescan, 0200, NULL,
+							    bus_rescan_store);
 
 #if defined(CONFIG_PM) && defined(CONFIG_ACPI)
 static ssize_t d3cold_allowed_store(struct device *dev,

commit 6348a34dcb98d8e285685a205f2a601817fa2d38
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 28 15:24:52 2020 -0600

    PCI: Use pci_speed_string() for all PCI/PCI-X/PCIe strings
    
    Previously some PCI speed strings came from pci_speed_string(), some came
    from the PCIe-specific PCIE_SPEED2STR(), and some came from a PCIe-specific
    switch statement.  These methods were inconsistent:
    
      pci_speed_string()     PCIE_SPEED2STR()     switch
      ------------------     ----------------     ------
      33 MHz PCI
      ...
      2.5 GT/s PCIe          2.5 GT/s             2.5 GT/s
      5.0 GT/s PCIe          5 GT/s               5 GT/s
      8.0 GT/s PCIe          8 GT/s               8 GT/s
      16.0 GT/s PCIe         16 GT/s              16 GT/s
      32.0 GT/s PCIe         32 GT/s              32 GT/s
    
    Standardize on pci_speed_string() as the single source of these strings.
    
    Note that this adds ".0" and "PCIe" to some messages, including sysfs
    "max_link_speed" files, a brcmstb "link up" message, and the link status
    dmesg logging, e.g.,
    
      nvme 0000:01:00.0: 16.000 Gb/s available PCIe bandwidth, limited by 5.0 GT/s PCIe x4 link at 0000:00:01.1 (capable of 31.504 Gb/s with 8.0 GT/s PCIe x4 link)
    
    I think it's better to standardize on a single version of the speed text.
    Previously we had strings like this:
    
      /sys/bus/pci/slots/0/cur_bus_speed: 8.0 GT/s PCIe
      /sys/bus/pci/slots/0/max_bus_speed: 8.0 GT/s PCIe
      /sys/devices/pci0000:00/0000:00:1c.0/current_link_speed: 8 GT/s
      /sys/devices/pci0000:00/0000:00:1c.0/max_link_speed: 8 GT/s
    
    This changes the latter two to match the slots files:
    
      /sys/devices/pci0000:00/0000:00:1c.0/current_link_speed: 8.0 GT/s PCIe
      /sys/devices/pci0000:00/0000:00:1c.0/max_link_speed: 8.0 GT/s PCIe
    
    Based-on-patch by: Yicong Yang <yangyicong@hisilicon.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 13f766db0684..d123d1087061 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -156,7 +156,8 @@ static ssize_t max_link_speed_show(struct device *dev,
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 
-	return sprintf(buf, "%s\n", PCIE_SPEED2STR(pcie_get_speed_cap(pdev)));
+	return sprintf(buf, "%s\n",
+		       pci_speed_string(pcie_get_speed_cap(pdev)));
 }
 static DEVICE_ATTR_RO(max_link_speed);
 
@@ -175,33 +176,15 @@ static ssize_t current_link_speed_show(struct device *dev,
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	u16 linkstat;
 	int err;
-	const char *speed;
+	enum pci_bus_speed speed;
 
 	err = pcie_capability_read_word(pci_dev, PCI_EXP_LNKSTA, &linkstat);
 	if (err)
 		return -EINVAL;
 
-	switch (linkstat & PCI_EXP_LNKSTA_CLS) {
-	case PCI_EXP_LNKSTA_CLS_32_0GB:
-		speed = "32 GT/s";
-		break;
-	case PCI_EXP_LNKSTA_CLS_16_0GB:
-		speed = "16 GT/s";
-		break;
-	case PCI_EXP_LNKSTA_CLS_8_0GB:
-		speed = "8 GT/s";
-		break;
-	case PCI_EXP_LNKSTA_CLS_5_0GB:
-		speed = "5 GT/s";
-		break;
-	case PCI_EXP_LNKSTA_CLS_2_5GB:
-		speed = "2.5 GT/s";
-		break;
-	default:
-		speed = "Unknown speed";
-	}
+	speed = pcie_link_speed[linkstat & PCI_EXP_LNKSTA_CLS];
 
-	return sprintf(buf, "%s\n", speed);
+	return sprintf(buf, "%s\n", pci_speed_string(speed));
 }
 static DEVICE_ATTR_RO(current_link_speed);
 

commit 774800cb099f8ee2f0f5c55ddb1809802d7c7cf8
Merge: 7cfe16393c3c 73884a7082f4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 28 08:54:36 2019 -0600

    Merge branch 'pci/resource'
    
      - Protect pci_reassign_bridge_resources() against concurrent
        addition/removal (Benjamin Herrenschmidt)
    
      - Fix bridge dma_ranges resource list cleanup (Rob Herring)
    
      - Add PCI_STD_NUM_BARS for the number of standard BARs (Denis Efremov)
    
      - Add "pci=hpmmiosize" and "pci=hpmmioprefsize" parameters to control the
        MMIO and prefetchable MMIO window sizes of hotplug bridges
        independently (Nicholas Johnson)
    
      - Fix MMIO/MMIO_PREF window assignment that assigned more space than
        desired (Nicholas Johnson)
    
      - Only enforce bus numbers from bridge EA if the bridge has EA devices
        downstream (Subbaraya Sundeep)
    
    * pci/resource:
      PCI: Do not use bus number zero from EA capability
      PCI: Avoid double hpmemsize MMIO window assignment
      PCI: Add "pci=hpmmiosize" and "pci=hpmmioprefsize" parameters
      PCI: Add PCI_STD_NUM_BARS for the number of standard BARs
      PCI: Fix missing bridge dma_ranges resource list cleanup
      PCI: Protect pci_reassign_bridge_resources() against concurrent addition/removal

commit e87eb585d31fadb5e9e549a1de4b2da60a79bfc9
Merge: 2df08822a643 3d581b11e34a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 28 08:54:32 2019 -0600

    Merge branch 'pci/misc'
    
      - Add NumaChip SPDX header (Krzysztof Wilczynski)
    
      - Replace EXTRA_CFLAGS with ccflags-y (Krzysztof Wilczynski)
    
      - Remove unused includes (Krzysztof Wilczynski)
    
      - Avoid AMD FCH XHCI USB PME# from D0 defect that prevents wakeup on USB
        2.0 or 1.1 connect events (Kai-Heng Feng)
    
      - Removed unused sysfs attribute groups (Ben Dooks)
    
      - Remove PTM and ASPM dependencies on PCIEPORTBUS (Bjorn Helgaas)
    
      - Add PCIe Link Control 2 register field definitions to replace magic
        numbers in AMDGPU and Radeon CIK/SI (Bjorn Helgaas)
    
      - Fix incorrect Link Control 2 Transmit Margin usage in AMDGPU and Radeon
        CIK/SI PCIe Gen3 link training (Bjorn Helgaas)
    
      - Use pcie_capability_read_word() instead of pci_read_config_word() in
        AMDGPU and Radeon CIK/SI (Frederick Lawler)
    
    * pci/misc:
      drm/radeon: Prefer pcie_capability_read_word()
      drm/radeon: Replace numbers with PCI_EXP_LNKCTL2 definitions
      drm/radeon: Correct Transmit Margin masks
      drm/amdgpu: Prefer pcie_capability_read_word()
      drm/amdgpu: Replace numbers with PCI_EXP_LNKCTL2 definitions
      drm/amdgpu: Correct Transmit Margin masks
      PCI: Add #defines for Enter Compliance, Transmit Margin
      PCI: Allow building PCIe things without PCIEPORTBUS
      PCI: Remove PCIe Kconfig dependencies on PCI
      PCI/ASPM: Remove dependency on PCIEPORTBUS
      PCI/PTM: Remove dependency on PCIEPORTBUS
      PCI/PTM: Remove spurious "d" from granularity message
      PCI: sysfs: Remove unused attribute groups
      x86/PCI: Avoid AMD FCH XHCI USB PME# from D0 defect
      PCI: Remove unused includes and superfluous struct declaration
      x86/PCI: Replace deprecated EXTRA_CFLAGS with ccflags-y
      x86/PCI: Correct SPDX comment style
      x86/PCI: Add NumaChip SPDX GPL-2.0 to replace COPYING boilerplate

commit 87e90283c94c76ee11d379ab5a0973382bbd0baf
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sat Oct 5 14:08:52 2019 +0200

    PCI/ASPM: Remove PCIEASPM_DEBUG Kconfig option and related code
    
    Previously, CONFIG_PCIEASPM_DEBUG enabled "link_state" and "clk_ctl" sysfs
    files that controlled ASPM.  We believe these files were rarely if ever
    used.
    
    We recently added sysfs ASPM controls that are always present, so the debug
    code is no longer needed.  Removing this debug code has been discussed for
    quite some time, see e.g. [0].
    
    Remove PCIEASPM_DEBUG and the related code.
    
    [0] https://lore.kernel.org/lkml/20180727202619.GD173328@bhelgaas-glaptop.roam.corp.google.com/
    Link: https://lore.kernel.org/r/ec935d8e-c084-3938-f1d1-748617596b25@gmail.com
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 0e76c02e0b7d..92bf1b1ce280 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1330,7 +1330,6 @@ static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 	int retval;
 
 	pcie_vpd_create_sysfs_dev_files(dev);
-	pcie_aspm_create_sysfs_dev_files(dev);
 
 	if (dev->reset_fn) {
 		retval = device_create_file(&dev->dev, &dev_attr_reset);
@@ -1340,7 +1339,6 @@ static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 	return 0;
 
 error:
-	pcie_aspm_remove_sysfs_dev_files(dev);
 	pcie_vpd_remove_sysfs_dev_files(dev);
 	return retval;
 }
@@ -1416,7 +1414,6 @@ int __must_check pci_create_sysfs_dev_files(struct pci_dev *pdev)
 static void pci_remove_capabilities_sysfs(struct pci_dev *dev)
 {
 	pcie_vpd_remove_sysfs_dev_files(dev);
-	pcie_aspm_remove_sysfs_dev_files(dev);
 	if (dev->reset_fn) {
 		device_remove_file(&dev->dev, &dev_attr_reset);
 		dev->reset_fn = 0;

commit 72ea91afbfb08619696ccde610ee4d0d29cf4a1d
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sat Oct 5 14:07:56 2019 +0200

    PCI/ASPM: Add sysfs attributes for controlling ASPM link states
    
    Add sysfs attributes to Endpoints and other Upstream Ports to control ASPM,
    Clock PM, and L1 PM Substates.  The new attributes are:
    
      /sys/devices/pci*/.../link/clkpm
      /sys/devices/pci*/.../link/l0s_aspm
      /sys/devices/pci*/.../link/l1_aspm
      /sys/devices/pci*/.../link/l1_1_aspm
      /sys/devices/pci*/.../link/l1_2_aspm
      /sys/devices/pci*/.../link/l1_1_pcipm
      /sys/devices/pci*/.../link/l1_2_pcipm
    
    An attribute is only visible if both ends of the Link leading to the device
    support the state.  Writing y/1/on to the file enables the state; n/0/off
    disables it.
    
    These attributes can be used to tune the power/performance tradeoff for
    individual devices.
    
    [bhelgaas: commit log, rename directory to "link"]
    Link: https://lore.kernel.org/r/b1c83f8a-9bf6-eac5-82d0-cf5b90128fbf@gmail.com
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 793412954529..0e76c02e0b7d 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1587,6 +1587,9 @@ static const struct attribute_group *pci_dev_attr_groups[] = {
 	&pcie_dev_attr_group,
 #ifdef CONFIG_PCIEAER
 	&aer_stats_attr_group,
+#endif
+#ifdef CONFIG_PCIEASPM
+	&aspm_ctrl_attr_group,
 #endif
 	NULL,
 };

commit ca22d1f5474a7278d317bb86296723e9e563c44d
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Wed Oct 16 09:03:24 2019 +0100

    PCI: sysfs: Remove unused attribute groups
    
    56c1af4606f0 ("PCI: Add sysfs max_link_speed/width,
    current_link_speed/width, etc") added the following objects, but they are
    unused, so remove them:
    
      pci_bridge_group
      pci_bridge_groups
      pcie_dev_group
      pcie_dev_groups
    
    This fixes the following warnings from sparse:
    
      drivers/pci/pci-sysfs.c:1546:30: warning: symbol 'pci_bridge_groups' was not declared. Should it be static?
      drivers/pci/pci-sysfs.c:1555:30: warning: symbol 'pcie_dev_groups' was not declared. Should it be static?
    
    Link: https://lore.kernel.org/r/20191016080324.12864-1-ben.dooks@codethink.co.uk
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 793412954529..eaffb477c5bf 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1539,24 +1539,6 @@ const struct attribute_group *pci_dev_groups[] = {
 	NULL,
 };
 
-static const struct attribute_group pci_bridge_group = {
-	.attrs = pci_bridge_attrs,
-};
-
-const struct attribute_group *pci_bridge_groups[] = {
-	&pci_bridge_group,
-	NULL,
-};
-
-static const struct attribute_group pcie_dev_group = {
-	.attrs = pcie_dev_attrs,
-};
-
-const struct attribute_group *pcie_dev_groups[] = {
-	&pcie_dev_group,
-	NULL,
-};
-
 static const struct attribute_group pci_dev_hp_attr_group = {
 	.attrs = pci_dev_hp_attrs,
 	.is_visible = pci_dev_hp_attrs_are_visible,

commit c9c13ba428ef90a9b408a6cdf874e14ab5754516
Author: Denis Efremov <efremov@linux.com>
Date:   Sat Sep 28 02:43:08 2019 +0300

    PCI: Add PCI_STD_NUM_BARS for the number of standard BARs
    
    Code that iterates over all standard PCI BARs typically uses
    PCI_STD_RESOURCE_END.  However, that requires the unusual test
    "i <= PCI_STD_RESOURCE_END" rather than something the typical
    "i < PCI_STD_NUM_BARS".
    
    Add a definition for PCI_STD_NUM_BARS and change loops to use the more
    idiomatic C style to help avoid fencepost errors.
    
    Link: https://lore.kernel.org/r/20190927234026.23342-1-efremov@linux.com
    Link: https://lore.kernel.org/r/20190927234308.23935-1-efremov@linux.com
    Link: https://lore.kernel.org/r/20190916204158.6889-3-efremov@linux.com
    Signed-off-by: Denis Efremov <efremov@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Sebastian Ott <sebott@linux.ibm.com>                  # arch/s390/
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>  # video/fbdev/
    Acked-by: Gustavo Pimentel <gustavo.pimentel@synopsys.com>      # pci/controller/dwc/
    Acked-by: Jack Wang <jinpu.wang@cloud.ionos.com>                # scsi/pm8001/
    Acked-by: Martin K. Petersen <martin.petersen@oracle.com>       # scsi/pm8001/
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>                  # memstick/

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 793412954529..07bd84c50238 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1122,7 +1122,7 @@ static void pci_remove_resource_files(struct pci_dev *pdev)
 {
 	int i;
 
-	for (i = 0; i < PCI_ROM_RESOURCE; i++) {
+	for (i = 0; i < PCI_STD_NUM_BARS; i++) {
 		struct bin_attribute *res_attr;
 
 		res_attr = pdev->res_attr[i];
@@ -1193,7 +1193,7 @@ static int pci_create_resource_files(struct pci_dev *pdev)
 	int retval;
 
 	/* Expose the PCI resources from this device as files */
-	for (i = 0; i < PCI_ROM_RESOURCE; i++) {
+	for (i = 0; i < PCI_STD_NUM_BARS; i++) {
 
 		/* skip empty resources */
 		if (!pci_resource_len(pdev, i))

commit aefcf2f4b58155d27340ba5f9ddbe9513da8286d
Merge: f1f2f614d535 45893a0abee6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 28 08:14:15 2019 -0700

    Merge branch 'next-lockdown' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull kernel lockdown mode from James Morris:
     "This is the latest iteration of the kernel lockdown patchset, from
      Matthew Garrett, David Howells and others.
    
      From the original description:
    
        This patchset introduces an optional kernel lockdown feature,
        intended to strengthen the boundary between UID 0 and the kernel.
        When enabled, various pieces of kernel functionality are restricted.
        Applications that rely on low-level access to either hardware or the
        kernel may cease working as a result - therefore this should not be
        enabled without appropriate evaluation beforehand.
    
        The majority of mainstream distributions have been carrying variants
        of this patchset for many years now, so there's value in providing a
        doesn't meet every distribution requirement, but gets us much closer
        to not requiring external patches.
    
      There are two major changes since this was last proposed for mainline:
    
       - Separating lockdown from EFI secure boot. Background discussion is
         covered here: https://lwn.net/Articles/751061/
    
       -  Implementation as an LSM, with a default stackable lockdown LSM
          module. This allows the lockdown feature to be policy-driven,
          rather than encoding an implicit policy within the mechanism.
    
      The new locked_down LSM hook is provided to allow LSMs to make a
      policy decision around whether kernel functionality that would allow
      tampering with or examining the runtime state of the kernel should be
      permitted.
    
      The included lockdown LSM provides an implementation with a simple
      policy intended for general purpose use. This policy provides a coarse
      level of granularity, controllable via the kernel command line:
    
        lockdown={integrity|confidentiality}
    
      Enable the kernel lockdown feature. If set to integrity, kernel features
      that allow userland to modify the running kernel are disabled. If set to
      confidentiality, kernel features that allow userland to extract
      confidential information from the kernel are also disabled.
    
      This may also be controlled via /sys/kernel/security/lockdown and
      overriden by kernel configuration.
    
      New or existing LSMs may implement finer-grained controls of the
      lockdown features. Refer to the lockdown_reason documentation in
      include/linux/security.h for details.
    
      The lockdown feature has had signficant design feedback and review
      across many subsystems. This code has been in linux-next for some
      weeks, with a few fixes applied along the way.
    
      Stephen Rothwell noted that commit 9d1f8be5cf42 ("bpf: Restrict bpf
      when kernel lockdown is in confidentiality mode") is missing a
      Signed-off-by from its author. Matthew responded that he is providing
      this under category (c) of the DCO"
    
    * 'next-lockdown' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (31 commits)
      kexec: Fix file verification on S390
      security: constify some arrays in lockdown LSM
      lockdown: Print current->comm in restriction messages
      efi: Restrict efivar_ssdt_load when the kernel is locked down
      tracefs: Restrict tracefs when the kernel is locked down
      debugfs: Restrict debugfs when the kernel is locked down
      kexec: Allow kexec_file() with appropriate IMA policy when locked down
      lockdown: Lock down perf when in confidentiality mode
      bpf: Restrict bpf when kernel lockdown is in confidentiality mode
      lockdown: Lock down tracing and perf kprobes when in confidentiality mode
      lockdown: Lock down /proc/kcore
      x86/mmiotrace: Lock down the testmmiotrace module
      lockdown: Lock down module params that specify hardware parameters (eg. ioport)
      lockdown: Lock down TIOCSSERIAL
      lockdown: Prohibit PCMCIA CIS storage when the kernel is locked down
      acpi: Disable ACPI table override if the kernel is locked down
      acpi: Ignore acpi_rsdp kernel param when the kernel has been locked down
      ACPI: Limit access to custom_method when the kernel is locked down
      x86/msr: Restrict MSR access when the kernel is locked down
      x86: Lock down IO port access when the kernel is locked down
      ...

commit aaee0c1ffd6399d291b030b49d622b81dd5071c5
Author: Kelsey Skunberg <skunberg.kelsey@gmail.com>
Date:   Tue Aug 13 14:45:13 2019 -0600

    PCI/IOV: Move sysfs SR-IOV functions to iov.c
    
    The sysfs SR-IOV functions are only needed when the kernel is built with
    SR-IOV support.  Rather than put them in pci-sysfs.c under #ifdef
    CONFIG_PCI_IOV, move them to iov.c, which is only compiled when
    CONFIG_PCI_IOV=y.
    
    Link: https://lore.kernel.org/r/20190813204513.4790-4-skunberg.kelsey@gmail.com
    Signed-off-by: Kelsey Skunberg <skunberg.kelsey@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Donald Dutile <ddutile@redhat.com>
    Reviewed-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 5bb301efec98..868e35109284 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -548,151 +548,6 @@ static ssize_t devspec_show(struct device *dev,
 static DEVICE_ATTR_RO(devspec);
 #endif
 
-#ifdef CONFIG_PCI_IOV
-static ssize_t sriov_totalvfs_show(struct device *dev,
-				   struct device_attribute *attr,
-				   char *buf)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-
-	return sprintf(buf, "%u\n", pci_sriov_get_totalvfs(pdev));
-}
-
-
-static ssize_t sriov_numvfs_show(struct device *dev,
-				 struct device_attribute *attr,
-				 char *buf)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-
-	return sprintf(buf, "%u\n", pdev->sriov->num_VFs);
-}
-
-/*
- * num_vfs > 0; number of VFs to enable
- * num_vfs = 0; disable all VFs
- *
- * Note: SRIOV spec doesn't allow partial VF
- *       disable, so it's all or none.
- */
-static ssize_t sriov_numvfs_store(struct device *dev,
-				  struct device_attribute *attr,
-				  const char *buf, size_t count)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-	int ret;
-	u16 num_vfs;
-
-	ret = kstrtou16(buf, 0, &num_vfs);
-	if (ret < 0)
-		return ret;
-
-	if (num_vfs > pci_sriov_get_totalvfs(pdev))
-		return -ERANGE;
-
-	device_lock(&pdev->dev);
-
-	if (num_vfs == pdev->sriov->num_VFs)
-		goto exit;
-
-	/* is PF driver loaded w/callback */
-	if (!pdev->driver || !pdev->driver->sriov_configure) {
-		pci_info(pdev, "Driver doesn't support SRIOV configuration via sysfs\n");
-		ret = -ENOENT;
-		goto exit;
-	}
-
-	if (num_vfs == 0) {
-		/* disable VFs */
-		ret = pdev->driver->sriov_configure(pdev, 0);
-		goto exit;
-	}
-
-	/* enable VFs */
-	if (pdev->sriov->num_VFs) {
-		pci_warn(pdev, "%d VFs already enabled. Disable before enabling %d VFs\n",
-			 pdev->sriov->num_VFs, num_vfs);
-		ret = -EBUSY;
-		goto exit;
-	}
-
-	ret = pdev->driver->sriov_configure(pdev, num_vfs);
-	if (ret < 0)
-		goto exit;
-
-	if (ret != num_vfs)
-		pci_warn(pdev, "%d VFs requested; only %d enabled\n",
-			 num_vfs, ret);
-
-exit:
-	device_unlock(&pdev->dev);
-
-	if (ret < 0)
-		return ret;
-
-	return count;
-}
-
-static ssize_t sriov_offset_show(struct device *dev,
-				 struct device_attribute *attr,
-				 char *buf)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-
-	return sprintf(buf, "%u\n", pdev->sriov->offset);
-}
-
-static ssize_t sriov_stride_show(struct device *dev,
-				 struct device_attribute *attr,
-				 char *buf)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-
-	return sprintf(buf, "%u\n", pdev->sriov->stride);
-}
-
-static ssize_t sriov_vf_device_show(struct device *dev,
-				    struct device_attribute *attr,
-				    char *buf)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-
-	return sprintf(buf, "%x\n", pdev->sriov->vf_device);
-}
-
-static ssize_t sriov_drivers_autoprobe_show(struct device *dev,
-					    struct device_attribute *attr,
-					    char *buf)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-
-	return sprintf(buf, "%u\n", pdev->sriov->drivers_autoprobe);
-}
-
-static ssize_t sriov_drivers_autoprobe_store(struct device *dev,
-					     struct device_attribute *attr,
-					     const char *buf, size_t count)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-	bool drivers_autoprobe;
-
-	if (kstrtobool(buf, &drivers_autoprobe) < 0)
-		return -EINVAL;
-
-	pdev->sriov->drivers_autoprobe = drivers_autoprobe;
-
-	return count;
-}
-
-static DEVICE_ATTR_RO(sriov_totalvfs);
-static DEVICE_ATTR(sriov_numvfs, 0664, sriov_numvfs_show, sriov_numvfs_store);
-static DEVICE_ATTR_RO(sriov_offset);
-static DEVICE_ATTR_RO(sriov_stride);
-static DEVICE_ATTR_RO(sriov_vf_device);
-static DEVICE_ATTR(sriov_drivers_autoprobe, 0664, sriov_drivers_autoprobe_show,
-		   sriov_drivers_autoprobe_store);
-#endif /* CONFIG_PCI_IOV */
-
 static ssize_t driver_override_store(struct device *dev,
 				     struct device_attribute *attr,
 				     const char *buf, size_t count)
@@ -1691,34 +1546,6 @@ static const struct attribute_group pci_dev_hp_attr_group = {
 	.is_visible = pci_dev_hp_attrs_are_visible,
 };
 
-#ifdef CONFIG_PCI_IOV
-static struct attribute *sriov_dev_attrs[] = {
-	&dev_attr_sriov_totalvfs.attr,
-	&dev_attr_sriov_numvfs.attr,
-	&dev_attr_sriov_offset.attr,
-	&dev_attr_sriov_stride.attr,
-	&dev_attr_sriov_vf_device.attr,
-	&dev_attr_sriov_drivers_autoprobe.attr,
-	NULL,
-};
-
-static umode_t sriov_attrs_are_visible(struct kobject *kobj,
-				       struct attribute *a, int n)
-{
-	struct device *dev = kobj_to_dev(kobj);
-
-	if (!dev_is_pf(dev))
-		return 0;
-
-	return a->mode;
-}
-
-static const struct attribute_group sriov_dev_attr_group = {
-	.attrs = sriov_dev_attrs,
-	.is_visible = sriov_attrs_are_visible,
-};
-#endif /* CONFIG_PCI_IOV */
-
 static const struct attribute_group pci_dev_attr_group = {
 	.attrs = pci_dev_dev_attrs,
 	.is_visible = pci_dev_attrs_are_visible,

commit e2154044dd4168bc25c70170dfa6179b57f63914
Author: Kelsey Skunberg <skunberg.kelsey@gmail.com>
Date:   Tue Aug 13 14:45:12 2019 -0600

    PCI: sysfs: Change permissions from symbolic to octal
    
    We prefer octal permissions over symbolic permissions such as "(S_IWUSR |
    S_IWGRP)".  Change all symbolic permissions to octal permissions, e.g.,
    
      - (S_IWUSR | S_IWGRP)
      + 0220
    
    Link: https://lore.kernel.org/r/20190813204513.4790-3-skunberg.kelsey@gmail.com
    Signed-off-by: Kelsey Skunberg <skunberg.kelsey@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Donald Dutile <ddutile@redhat.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 4fe988d54807..5bb301efec98 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -478,7 +478,7 @@ static ssize_t remove_store(struct device *dev, struct device_attribute *attr,
 		pci_stop_and_remove_bus_device_locked(to_pci_dev(dev));
 	return count;
 }
-static DEVICE_ATTR_IGNORE_LOCKDEP(remove, (S_IWUSR | S_IWGRP), NULL,
+static DEVICE_ATTR_IGNORE_LOCKDEP(remove, 0220, NULL,
 				  remove_store);
 
 static ssize_t bus_rescan_store(struct device *dev,
@@ -685,13 +685,12 @@ static ssize_t sriov_drivers_autoprobe_store(struct device *dev,
 }
 
 static DEVICE_ATTR_RO(sriov_totalvfs);
-static DEVICE_ATTR(sriov_numvfs, (S_IRUGO | S_IWUSR | S_IWGRP),
-				  sriov_numvfs_show, sriov_numvfs_store);
+static DEVICE_ATTR(sriov_numvfs, 0664, sriov_numvfs_show, sriov_numvfs_store);
 static DEVICE_ATTR_RO(sriov_offset);
 static DEVICE_ATTR_RO(sriov_stride);
 static DEVICE_ATTR_RO(sriov_vf_device);
-static DEVICE_ATTR(sriov_drivers_autoprobe, (S_IRUGO | S_IWUSR | S_IWGRP),
-		   sriov_drivers_autoprobe_show, sriov_drivers_autoprobe_store);
+static DEVICE_ATTR(sriov_drivers_autoprobe, 0664, sriov_drivers_autoprobe_show,
+		   sriov_drivers_autoprobe_store);
 #endif /* CONFIG_PCI_IOV */
 
 static ssize_t driver_override_store(struct device *dev,
@@ -1080,7 +1079,7 @@ void pci_create_legacy_files(struct pci_bus *b)
 	sysfs_bin_attr_init(b->legacy_io);
 	b->legacy_io->attr.name = "legacy_io";
 	b->legacy_io->size = 0xffff;
-	b->legacy_io->attr.mode = S_IRUSR | S_IWUSR;
+	b->legacy_io->attr.mode = 0600;
 	b->legacy_io->read = pci_read_legacy_io;
 	b->legacy_io->write = pci_write_legacy_io;
 	b->legacy_io->mmap = pci_mmap_legacy_io;
@@ -1094,7 +1093,7 @@ void pci_create_legacy_files(struct pci_bus *b)
 	sysfs_bin_attr_init(b->legacy_mem);
 	b->legacy_mem->attr.name = "legacy_mem";
 	b->legacy_mem->size = 1024*1024;
-	b->legacy_mem->attr.mode = S_IRUSR | S_IWUSR;
+	b->legacy_mem->attr.mode = 0600;
 	b->legacy_mem->mmap = pci_mmap_legacy_mem;
 	pci_adjust_legacy_attr(b, pci_mmap_mem);
 	error = device_create_bin_file(&b->dev, b->legacy_mem);
@@ -1301,7 +1300,7 @@ static int pci_create_attr(struct pci_dev *pdev, int num, int write_combine)
 		}
 	}
 	res_attr->attr.name = res_attr_name;
-	res_attr->attr.mode = S_IRUSR | S_IWUSR;
+	res_attr->attr.mode = 0600;
 	res_attr->size = pci_resource_len(pdev, num);
 	res_attr->private = (void *)(unsigned long)num;
 	retval = sysfs_create_bin_file(&pdev->dev.kobj, res_attr);
@@ -1414,7 +1413,7 @@ static ssize_t pci_read_rom(struct file *filp, struct kobject *kobj,
 static const struct bin_attribute pci_config_attr = {
 	.attr =	{
 		.name = "config",
-		.mode = S_IRUGO | S_IWUSR,
+		.mode = 0644,
 	},
 	.size = PCI_CFG_SPACE_SIZE,
 	.read = pci_read_config,
@@ -1424,7 +1423,7 @@ static const struct bin_attribute pci_config_attr = {
 static const struct bin_attribute pcie_config_attr = {
 	.attr =	{
 		.name = "config",
-		.mode = S_IRUGO | S_IWUSR,
+		.mode = 0644,
 	},
 	.size = PCI_CFG_SPACE_EXP_SIZE,
 	.read = pci_read_config,
@@ -1506,7 +1505,7 @@ int __must_check pci_create_sysfs_dev_files(struct pci_dev *pdev)
 		sysfs_bin_attr_init(attr);
 		attr->size = rom_size;
 		attr->attr.name = "rom";
-		attr->attr.mode = S_IRUSR | S_IWUSR;
+		attr->attr.mode = 0600;
 		attr->read = pci_read_rom;
 		attr->write = pci_write_rom;
 		retval = sysfs_create_bin_file(&pdev->dev.kobj, attr);

commit 4e2b79436e4f22b225ee445832705bb7c4675807
Author: Kelsey Skunberg <skunberg.kelsey@gmail.com>
Date:   Thu Aug 15 09:33:52 2019 -0600

    PCI: sysfs: Change DEVICE_ATTR() to DEVICE_ATTR_WO()
    
    DEVICE_ATTR() should only be used when files have unusual permissions.
    Change DEVICE_ATTR() with '0220' write-only permissions to
    DEVICE_ATTR_WO(), e.g.,
    
      - static DEVICE_ATTR(_name, (S_IWUSR | S_IWGRP), NULL, _store);
      + static DEVICE_ATTR_WO(_name);
    
    Since _store is no longer passed, make the _name passed by DEVICE_ATTR_WO()
    and the related _name##_store() name match with each other, e.g.,
    
      DEVICE_ATTR_WO(bus_rescan) must be able to call bus_rescan_store()
    
    Link: https://lore.kernel.org/r/20190815153352.86143-4-skunberg.kelsey@gmail.com
    Signed-off-by: Kelsey Skunberg <skunberg.kelsey@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Donald Dutile <ddutile@redhat.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 8af7944fdccb..4fe988d54807 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -464,7 +464,7 @@ static ssize_t dev_rescan_store(struct device *dev,
 	}
 	return count;
 }
-static DEVICE_ATTR(rescan, (S_IWUSR | S_IWGRP), NULL, dev_rescan_store);
+static DEVICE_ATTR_WO(dev_rescan);
 
 static ssize_t remove_store(struct device *dev, struct device_attribute *attr,
 			    const char *buf, size_t count)
@@ -481,9 +481,9 @@ static ssize_t remove_store(struct device *dev, struct device_attribute *attr,
 static DEVICE_ATTR_IGNORE_LOCKDEP(remove, (S_IWUSR | S_IWGRP), NULL,
 				  remove_store);
 
-static ssize_t dev_bus_rescan_store(struct device *dev,
-				    struct device_attribute *attr,
-				    const char *buf, size_t count)
+static ssize_t bus_rescan_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
 {
 	unsigned long val;
 	struct pci_bus *bus = to_pci_bus(dev);
@@ -501,7 +501,7 @@ static ssize_t dev_bus_rescan_store(struct device *dev,
 	}
 	return count;
 }
-static DEVICE_ATTR(bus_rescan, (S_IWUSR | S_IWGRP), NULL, dev_bus_rescan_store);
+static DEVICE_ATTR_WO(bus_rescan);
 
 #if defined(CONFIG_PM) && defined(CONFIG_ACPI)
 static ssize_t d3cold_allowed_store(struct device *dev,
@@ -1620,7 +1620,7 @@ static umode_t pci_dev_attrs_are_visible(struct kobject *kobj,
 
 static struct attribute *pci_dev_hp_attrs[] = {
 	&dev_attr_remove.attr,
-	&dev_attr_rescan.attr,
+	&dev_attr_dev_rescan.attr,
 	NULL,
 };
 

commit 8bdfa145f58220796abddc93b5038efa6e7e90fc
Author: Kelsey Skunberg <skunberg.kelsey@gmail.com>
Date:   Tue Aug 13 14:45:11 2019 -0600

    PCI: sysfs: Define device attributes with DEVICE_ATTR*()
    
    Device attributes should be defined using DEVICE_ATTR*(_name, _mode, _show,
    _store).  Convert them all from __ATTR*() to DEVICE_ATTR*(), e.g.,
    
      - struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show,
                                                          _store)
      + static DEVICE_ATTR(foo, S_IWUSR | S_IRUGO, show_foo, store_foo)
    
    Link: https://lore.kernel.org/r/20190813204513.4790-2-skunberg.kelsey@gmail.com
    Signed-off-by: Kelsey Skunberg <skunberg.kelsey@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Donald Dutile <ddutile@redhat.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 965c72104150..8af7944fdccb 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -464,9 +464,7 @@ static ssize_t dev_rescan_store(struct device *dev,
 	}
 	return count;
 }
-static struct device_attribute dev_rescan_attr = __ATTR(rescan,
-							(S_IWUSR|S_IWGRP),
-							NULL, dev_rescan_store);
+static DEVICE_ATTR(rescan, (S_IWUSR | S_IWGRP), NULL, dev_rescan_store);
 
 static ssize_t remove_store(struct device *dev, struct device_attribute *attr,
 			    const char *buf, size_t count)
@@ -480,9 +478,8 @@ static ssize_t remove_store(struct device *dev, struct device_attribute *attr,
 		pci_stop_and_remove_bus_device_locked(to_pci_dev(dev));
 	return count;
 }
-static struct device_attribute dev_remove_attr = __ATTR_IGNORE_LOCKDEP(remove,
-							(S_IWUSR|S_IWGRP),
-							NULL, remove_store);
+static DEVICE_ATTR_IGNORE_LOCKDEP(remove, (S_IWUSR | S_IWGRP), NULL,
+				  remove_store);
 
 static ssize_t dev_bus_rescan_store(struct device *dev,
 				    struct device_attribute *attr,
@@ -504,7 +501,7 @@ static ssize_t dev_bus_rescan_store(struct device *dev,
 	}
 	return count;
 }
-static DEVICE_ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, dev_bus_rescan_store);
+static DEVICE_ATTR(bus_rescan, (S_IWUSR | S_IWGRP), NULL, dev_bus_rescan_store);
 
 #if defined(CONFIG_PM) && defined(CONFIG_ACPI)
 static ssize_t d3cold_allowed_store(struct device *dev,
@@ -687,16 +684,14 @@ static ssize_t sriov_drivers_autoprobe_store(struct device *dev,
 	return count;
 }
 
-static struct device_attribute sriov_totalvfs_attr = __ATTR_RO(sriov_totalvfs);
-static struct device_attribute sriov_numvfs_attr =
-		__ATTR(sriov_numvfs, (S_IRUGO|S_IWUSR|S_IWGRP),
-		       sriov_numvfs_show, sriov_numvfs_store);
-static struct device_attribute sriov_offset_attr = __ATTR_RO(sriov_offset);
-static struct device_attribute sriov_stride_attr = __ATTR_RO(sriov_stride);
-static struct device_attribute sriov_vf_device_attr = __ATTR_RO(sriov_vf_device);
-static struct device_attribute sriov_drivers_autoprobe_attr =
-		__ATTR(sriov_drivers_autoprobe, (S_IRUGO|S_IWUSR|S_IWGRP),
-		       sriov_drivers_autoprobe_show, sriov_drivers_autoprobe_store);
+static DEVICE_ATTR_RO(sriov_totalvfs);
+static DEVICE_ATTR(sriov_numvfs, (S_IRUGO | S_IWUSR | S_IWGRP),
+				  sriov_numvfs_show, sriov_numvfs_store);
+static DEVICE_ATTR_RO(sriov_offset);
+static DEVICE_ATTR_RO(sriov_stride);
+static DEVICE_ATTR_RO(sriov_vf_device);
+static DEVICE_ATTR(sriov_drivers_autoprobe, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   sriov_drivers_autoprobe_show, sriov_drivers_autoprobe_store);
 #endif /* CONFIG_PCI_IOV */
 
 static ssize_t driver_override_store(struct device *dev,
@@ -792,7 +787,7 @@ static struct attribute *pcie_dev_attrs[] = {
 };
 
 static struct attribute *pcibus_attrs[] = {
-	&dev_attr_rescan.attr,
+	&dev_attr_bus_rescan.attr,
 	&dev_attr_cpuaffinity.attr,
 	&dev_attr_cpulistaffinity.attr,
 	NULL,
@@ -820,7 +815,7 @@ static ssize_t boot_vga_show(struct device *dev, struct device_attribute *attr,
 		!!(pdev->resource[PCI_ROM_RESOURCE].flags &
 		   IORESOURCE_ROM_SHADOW));
 }
-static struct device_attribute vga_attr = __ATTR_RO(boot_vga);
+static DEVICE_ATTR_RO(boot_vga);
 
 static ssize_t pci_read_config(struct file *filp, struct kobject *kobj,
 			       struct bin_attribute *bin_attr, char *buf,
@@ -1458,7 +1453,7 @@ static ssize_t reset_store(struct device *dev, struct device_attribute *attr,
 	return count;
 }
 
-static struct device_attribute reset_attr = __ATTR(reset, 0200, NULL, reset_store);
+static DEVICE_ATTR(reset, 0200, NULL, reset_store);
 
 static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 {
@@ -1468,7 +1463,7 @@ static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 	pcie_aspm_create_sysfs_dev_files(dev);
 
 	if (dev->reset_fn) {
-		retval = device_create_file(&dev->dev, &reset_attr);
+		retval = device_create_file(&dev->dev, &dev_attr_reset);
 		if (retval)
 			goto error;
 	}
@@ -1553,7 +1548,7 @@ static void pci_remove_capabilities_sysfs(struct pci_dev *dev)
 	pcie_vpd_remove_sysfs_dev_files(dev);
 	pcie_aspm_remove_sysfs_dev_files(dev);
 	if (dev->reset_fn) {
-		device_remove_file(&dev->dev, &reset_attr);
+		device_remove_file(&dev->dev, &dev_attr_reset);
 		dev->reset_fn = 0;
 	}
 }
@@ -1606,7 +1601,7 @@ static int __init pci_sysfs_init(void)
 late_initcall(pci_sysfs_init);
 
 static struct attribute *pci_dev_dev_attrs[] = {
-	&vga_attr.attr,
+	&dev_attr_boot_vga.attr,
 	NULL,
 };
 
@@ -1616,7 +1611,7 @@ static umode_t pci_dev_attrs_are_visible(struct kobject *kobj,
 	struct device *dev = kobj_to_dev(kobj);
 	struct pci_dev *pdev = to_pci_dev(dev);
 
-	if (a == &vga_attr.attr)
+	if (a == &dev_attr_boot_vga.attr)
 		if ((pdev->class >> 8) != PCI_CLASS_DISPLAY_VGA)
 			return 0;
 
@@ -1624,8 +1619,8 @@ static umode_t pci_dev_attrs_are_visible(struct kobject *kobj,
 }
 
 static struct attribute *pci_dev_hp_attrs[] = {
-	&dev_remove_attr.attr,
-	&dev_rescan_attr.attr,
+	&dev_attr_remove.attr,
+	&dev_attr_rescan.attr,
 	NULL,
 };
 
@@ -1699,12 +1694,12 @@ static const struct attribute_group pci_dev_hp_attr_group = {
 
 #ifdef CONFIG_PCI_IOV
 static struct attribute *sriov_dev_attrs[] = {
-	&sriov_totalvfs_attr.attr,
-	&sriov_numvfs_attr.attr,
-	&sriov_offset_attr.attr,
-	&sriov_stride_attr.attr,
-	&sriov_vf_device_attr.attr,
-	&sriov_drivers_autoprobe_attr.attr,
+	&dev_attr_sriov_totalvfs.attr,
+	&dev_attr_sriov_numvfs.attr,
+	&dev_attr_sriov_offset.attr,
+	&dev_attr_sriov_stride.attr,
+	&dev_attr_sriov_vf_device.attr,
+	&dev_attr_sriov_drivers_autoprobe.attr,
 	NULL,
 };
 

commit eb627e17727ebeede70697ae1798688b0d328b54
Author: Matthew Garrett <mjg59@srcf.ucam.org>
Date:   Mon Aug 19 17:17:47 2019 -0700

    PCI: Lock down BAR access when the kernel is locked down
    
    Any hardware that can potentially generate DMA has to be locked down in
    order to avoid it being possible for an attacker to modify kernel code,
    allowing them to circumvent disabled module loading or module signing.
    Default to paranoid - in future we can potentially relax this for
    sufficiently IOMMU-isolated devices.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    cc: linux-pci@vger.kernel.org
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 6d27475e39b2..ec103a7e13fc 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -903,6 +903,11 @@ static ssize_t pci_write_config(struct file *filp, struct kobject *kobj,
 	unsigned int size = count;
 	loff_t init_off = off;
 	u8 *data = (u8 *) buf;
+	int ret;
+
+	ret = security_locked_down(LOCKDOWN_PCI_ACCESS);
+	if (ret)
+		return ret;
 
 	if (off > dev->cfg_size)
 		return 0;
@@ -1164,6 +1169,11 @@ static int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 	int bar = (unsigned long)attr->private;
 	enum pci_mmap_state mmap_type;
 	struct resource *res = &pdev->resource[bar];
+	int ret;
+
+	ret = security_locked_down(LOCKDOWN_PCI_ACCESS);
+	if (ret)
+		return ret;
 
 	if (res->flags & IORESOURCE_MEM && iomem_is_exclusive(res->start))
 		return -EINVAL;
@@ -1240,6 +1250,12 @@ static ssize_t pci_write_resource_io(struct file *filp, struct kobject *kobj,
 				     struct bin_attribute *attr, char *buf,
 				     loff_t off, size_t count)
 {
+	int ret;
+
+	ret = security_locked_down(LOCKDOWN_PCI_ACCESS);
+	if (ret)
+		return ret;
+
 	return pci_resource_io(filp, kobj, attr, buf, off, count, true);
 }
 

commit dc6b698a86fe40a50525433eb8e92a267847f6f9
Author: Marek Vasut <marek.vasut+renesas@gmail.com>
Date:   Mon May 27 00:51:51 2019 +0200

    PCI: sysfs: Ignore lockdep for remove attribute
    
    With CONFIG_PROVE_LOCKING=y, using sysfs to remove a bridge with a device
    below it causes a lockdep warning, e.g.,
    
      # echo 1 > /sys/class/pci_bus/0000:00/device/0000:00:00.0/remove
      ============================================
      WARNING: possible recursive locking detected
      ...
      pci_bus 0000:01: busn_res: [bus 01] is released
    
    The remove recursively removes the subtree below the bridge.  Each call
    uses a different lock so there's no deadlock, but the locks were all
    created with the same lockdep key so the lockdep checker can't tell them
    apart.
    
    Mark the "remove" sysfs attribute with __ATTR_IGNORE_LOCKDEP() as it is
    safe to ignore the lockdep check between different "remove" kernfs
    instances.
    
    There's discussion about a similar issue in USB at [1], which resulted in
    356c05d58af0 ("sysfs: get rid of some lockdep false positives") and
    e9b526fe7048 ("i2c: suppress lockdep warning on delete_device"), which do
    basically the same thing for USB "remove" and i2c "delete_device" files.
    
    [1] https://lore.kernel.org/r/Pine.LNX.4.44L0.1204251436140.1206-100000@iolanthe.rowland.org
    Link: https://lore.kernel.org/r/20190526225151.3865-1-marek.vasut@gmail.com
    Signed-off-by: Marek Vasut <marek.vasut+renesas@gmail.com>
    [bhelgaas: trim commit log, details at above links]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Phil Edworthy <phil.edworthy@renesas.com>
    Cc: Simon Horman <horms+renesas@verge.net.au>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index d52d30448e41..965c72104150 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -480,7 +480,7 @@ static ssize_t remove_store(struct device *dev, struct device_attribute *attr,
 		pci_stop_and_remove_bus_device_locked(to_pci_dev(dev));
 	return count;
 }
-static struct device_attribute dev_remove_attr = __ATTR(remove,
+static struct device_attribute dev_remove_attr = __ATTR_IGNORE_LOCKDEP(remove,
 							(S_IWUSR|S_IWGRP),
 							NULL, remove_store);
 

commit de76cda215d56256ffcda7ffa538b70f9fb301a7
Author: Gustavo Pimentel <Gustavo.Pimentel@synopsys.com>
Date:   Tue Jun 4 18:24:43 2019 +0200

    PCI: Decode PCIe 32 GT/s link speed
    
    PCIe r5.0, sec 7.5.3.18, defines a new 32.0 GT/s bit in the Supported Link
    Speeds Vector of Link Capabilities 2.  Decode this new speed.  This does
    not affect the speed of the link, which should be negotiated automatically
    by the hardware; it only adds decoding when showing the speed to the user.
    
    Previously, reading the speed of a link operating at this speed showed
    "Unknown speed" instead of "32.0 GT/s".
    
    Link: https://lore.kernel.org/lkml/92365e3caf0fc559f9ab14bcd053bfc92d4f661c.1559664969.git.gustavo.pimentel@synopsys.com
    Signed-off-by: Gustavo Pimentel <gustavo.pimentel@synopsys.com>
    [bhelgaas: changelog]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 6d27475e39b2..d52d30448e41 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -182,6 +182,9 @@ static ssize_t current_link_speed_show(struct device *dev,
 		return -EINVAL;
 
 	switch (linkstat & PCI_EXP_LNKSTA_CLS) {
+	case PCI_EXP_LNKSTA_CLS_32_0GB:
+		speed = "32 GT/s";
+		break;
 	case PCI_EXP_LNKSTA_CLS_16_0GB:
 		speed = "16 GT/s";
 		break;

commit 7db4af43c97b68dc65394c799b86cdd0fffe5f8d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue May 7 17:37:53 2019 -0500

    PCI: Use dev_printk() when possible
    
    Use dev_printk() when possible.  This makes messages more consistent with
    other device-related messages and, in some cases, adds useful information.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 25794c27c7a4..6d27475e39b2 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1111,8 +1111,7 @@ void pci_create_legacy_files(struct pci_bus *b)
 	kfree(b->legacy_io);
 	b->legacy_io = NULL;
 kzalloc_err:
-	printk(KERN_WARNING "pci: warning: could not create legacy I/O port and ISA memory resources to sysfs\n");
-	return;
+	dev_warn(&b->dev, "could not create legacy I/O port and ISA memory resources in sysfs\n");
 }
 
 void pci_remove_legacy_files(struct pci_bus *b)

commit 1094f6d06703bd489cea444f9ba03bd4ef123acc
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 08:54:34 2018 +0100

    PCI: pci-sysfs.c: convert to use BUS_ATTR_WO
    
    We are trying to get rid of BUS_ATTR() and the usage of that in
    pci-sysfs.c can be trivially converted to use BUS_ATTR_WO(), so use that
    instead.
    
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 9ecfe13157c0..25794c27c7a4 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -412,8 +412,7 @@ static ssize_t msi_bus_store(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR_RW(msi_bus);
 
-static ssize_t bus_rescan_store(struct bus_type *bus, const char *buf,
-				size_t count)
+static ssize_t rescan_store(struct bus_type *bus, const char *buf, size_t count)
 {
 	unsigned long val;
 	struct pci_bus *b = NULL;
@@ -429,7 +428,7 @@ static ssize_t bus_rescan_store(struct bus_type *bus, const char *buf,
 	}
 	return count;
 }
-static BUS_ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, bus_rescan_store);
+static BUS_ATTR_WO(rescan);
 
 static struct attribute *pci_bus_attrs[] = {
 	&bus_attr_rescan.attr,

commit c0638a455382e01e42bf66d8d41e4b703f1550a5
Merge: a8bcb5e5966c 4e6a13356f1c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:58:52 2018 -0500

    Merge branch 'pci/hotplug'
    
      - Simplify SHPC existence/permission checks (Bjorn Helgaas)
    
      - Remove hotplug sample skeleton driver (Lukas Wunner)
    
      - Convert pciehp to threaded IRQ handling (Lukas Wunner)
    
      - Improve pciehp tolerance of missed events and initially unstable links
        (Lukas Wunner)
    
      - Clear spurious pciehp events on resume (Lukas Wunner)
    
      - Add pciehp runtime PM support, including for Thunderbolt controllers
        (Lukas Wunner)
    
      - Support interrupts from pciehp bridges in D3hot (Lukas Wunner)
    
    * pci/hotplug:
      PCI: pciehp: Deduplicate presence check on probe & resume
      PCI: pciehp: Avoid implicit fallthroughs in switch statements
      PCI: Whitelist Thunderbolt ports for runtime D3
      PCI: Whitelist native hotplug ports for runtime D3
      PCI: sysfs: Resume to D0 on function reset
      PCI: pciehp: Resume parent to D0 on config space access
      PCI: pciehp: Resume to D0 on enable/disable
      PCI: pciehp: Support interrupts sent from D3hot
      PCI: pciehp: Obey compulsory command delay after resume
      PCI: pciehp: Clear spurious events earlier on resume
      PCI: portdrv: Deduplicate PM callback iterator
      PCI: pciehp: Avoid slot access during reset
      PCI: pciehp: Always enable occupied slot on probe
      PCI: pciehp: Become resilient to missed events
      PCI: pciehp: Tolerate initially unstable link
      PCI: pciehp: Declare pciehp_enable/disable_slot() static
      PCI: pciehp: Drop enable/disable lock
      PCI: pciehp: Enable/disable exclusively from IRQ thread
      PCI: pciehp: Track enable/disable status
      PCI: pciehp: Publish to user space last on probe
      PCI: hotplug: Demidlayer registration with the core
      PCI: pciehp: Drop slot workqueue
      PCI: pciehp: Handle events synchronously
      PCI: pciehp: Stop blinking on slot enable failure
      PCI: pciehp: Convert to threaded polling
      PCI: pciehp: Convert to threaded IRQ
      PCI: pciehp: Document struct slot and struct controller
      PCI: pciehp: Declare pciehp_unconfigure_device() void
      PCI: pciehp: Drop unnecessary NULL pointer check
      PCI: pciehp: Fix unprotected list iteration in IRQ handler
      PCI: pciehp: Fix use-after-free on unplug
      PCI: hotplug: Don't leak pci_slot on registration failure
      PCI: hotplug: Delete skeleton driver
      PCI: shpchp: Separate existence of SHPC and permission to use it

commit 187dacce194216c4d86c2afd0ca490a6d7fbb981
Merge: 3c3ab37f4c03 ce29af2a5056
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:58:46 2018 -0500

    Merge branch 'pci/aspm'
    
      - Use sysfs_match_string() to simplify ASPM sysfs parsing (Andy
        Shevchenko)
    
      - Remove unnecessary includes of <linux/pci-aspm.h> (Bjorn Helgaas)
    
    * pci/aspm:
      PCI: Remove unnecessary include of <linux/pci-aspm.h>
      iwlwifi: Remove unnecessary include of <linux/pci-aspm.h>
      ath9k: Remove unnecessary include of <linux/pci-aspm.h>
      igb: Remove unnecessary include of <linux/pci-aspm.h>
      PCI/ASPM: Convert to use sysfs_match_string() helper

commit ce29af2a505627cc8f1deddb84bcbaf186b0bfd5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jul 25 14:53:42 2018 -0500

    PCI: Remove unnecessary include of <linux/pci-aspm.h>
    
    Several PCI core files include pci-aspm.h even though they don't need
    anything provided by that file.  Remove the unnecessary includes of it.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Sinan Kaya <okaya@kernel.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 0c4653c1d2ce..91337faae60d 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -23,7 +23,6 @@
 #include <linux/fs.h>
 #include <linux/capability.h>
 #include <linux/security.h>
-#include <linux/pci-aspm.h>
 #include <linux/slab.h>
 #include <linux/vgaarb.h>
 #include <linux/pm_runtime.h>

commit 82c3fbff6ed3582f2b14b5548fb976c22d7a7255
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:58 2018 -0500

    PCI: sysfs: Resume to D0 on function reset
    
    When performing a function reset via sysfs, the device's config space is
    accessed in places such as pcie_flr() and its MMIO space is accessed e.g.
    in reset_ivb_igd(), so ensure accessibility by resuming the device to D0.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Ashok Raj <ashok.raj@intel.com>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 0c4653c1d2ce..a3df6b57df0f 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1449,7 +1449,9 @@ static ssize_t reset_store(struct device *dev, struct device_attribute *attr,
 	if (val != 1)
 		return -EINVAL;
 
+	pm_runtime_get_sync(dev);
 	result = pci_reset_function(pdev);
+	pm_runtime_put(dev);
 	if (result < 0)
 		return result;
 

commit 81aa5206f9a7c9793e2f7971400351664e40b04f
Author: Rajat Jain <rajatja@google.com>
Date:   Thu Jun 21 16:48:28 2018 -0700

    PCI/AER: Add sysfs attributes to provide AER stats and breakdown
    
    Add sysfs attributes to provide total and breakdown of the AERs seen,
    into different type of correctable, fatal and nonfatal errors:
    
      /sys/bus/pci/devices/<dev>/aer_dev_correctable
      /sys/bus/pci/devices/<dev>/aer_dev_fatal
      /sys/bus/pci/devices/<dev>/aer_dev_nonfatal
    
    Signed-off-by: Rajat Jain <rajatja@google.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 0c4653c1d2ce..9f1cb9051d7d 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1746,6 +1746,9 @@ static const struct attribute_group *pci_dev_attr_groups[] = {
 #endif
 	&pci_bridge_attr_group,
 	&pcie_dev_attr_group,
+#ifdef CONFIG_PCIEAER
+	&aer_stats_attr_group,
+#endif
 	NULL,
 };
 

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 788a200fb2dc..0c4653c1d2ce 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1076,7 +1076,7 @@ void pci_create_legacy_files(struct pci_bus *b)
 {
 	int error;
 
-	b->legacy_io = kzalloc(sizeof(struct bin_attribute) * 2,
+	b->legacy_io = kcalloc(2, sizeof(struct bin_attribute),
 			       GFP_ATOMIC);
 	if (!b->legacy_io)
 		goto kzalloc_err;

commit 6f5cdfa802733dcb561bf664cc89d203f2fd958f
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri May 18 18:56:24 2018 +0200

    PCI: Prevent sysfs disable of device while driver is attached
    
    Manipulating the enable_cnt behind the back of the driver will wreak
    complete havoc with the kernel state, so disallow it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Acked-by: Keith Busch <keith.busch@intel.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 366d93af051d..788a200fb2dc 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -288,13 +288,16 @@ static ssize_t enable_store(struct device *dev, struct device_attribute *attr,
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
-	if (!val) {
-		if (pci_is_enabled(pdev))
-			pci_disable_device(pdev);
-		else
-			result = -EIO;
-	} else
+	device_lock(dev);
+	if (dev->driver)
+		result = -EBUSY;
+	else if (val)
 		result = pci_enable_device(pdev);
+	else if (pci_is_enabled(pdev))
+		pci_disable_device(pdev);
+	else
+		result = -EIO;
+	device_unlock(dev);
 
 	return result < 0 ? result : count;
 }

commit c8afd5ef001b85034c31025686d3b7419103d729
Merge: a4b88505ac1f f9ea894ca59a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 4 13:28:40 2018 -0500

    Merge branch 'pci/vpd'
    
      - consolidate VPD code in vpd.c (Bjorn Helgaas)
    
    * pci/vpd:
      PCI/VPD: Move VPD structures to vpd.c
      PCI/VPD: Move VPD quirks to vpd.c
      PCI/VPD: Move VPD sysfs code to vpd.c
      PCI/VPD: Move VPD access code to vpd.c

commit a4b88505ac1f77cf4fa75fa6845fe95aa43aac9e
Merge: 0eb6de7872d9 619e6f340cec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 4 13:28:26 2018 -0500

    Merge branch 'pci/virtualization'
    
      - probe for device reset support during enumeration instead of runtime
        (Bjorn Helgaas)
    
      - add ACS quirk for Ampere (née APM) root ports (Feng Kan)
    
      - add function 1 DMA alias quirk for Marvell 88SE9220 (Thomas
        Vincent-Cross)
    
      - protect device restore with device lock (Sinan Kaya)
    
      - handle failure of FLR gracefully (Sinan Kaya)
    
      - handle CRS (config retry status) after device resets (Sinan Kaya)
    
      - skip various config reads for SR-IOV VFs as an optimization (KarimAllah
        Ahmed)
    
    * pci/virtualization:
      PCI/IOV: Add missing prototypes for powerpc pcibios interfaces
      PCI/IOV: Use VF0 cached config registers for other VFs
      PCI/IOV: Skip BAR sizing for VFs
      PCI/IOV: Skip INTx config reads for VFs
      PCI: Wait for device to become ready after secondary bus reset
      PCI: Add a return type for pci_reset_bridge_secondary_bus()
      PCI: Wait for device to become ready after a power management reset
      PCI: Rename pci_flr_wait() to pci_dev_wait() and make it generic
      PCI: Handle FLR failure and allow other reset types
      PCI: Protect restore with device lock to be consistent
      PCI: Add function 1 DMA alias quirk for Marvell 88SE9220
      PCI: Add ACS quirk for Ampere root ports
      PCI: Remove redundant probes for device reset support
      PCI: Probe for device reset support during enumeration
    
    Conflicts:
            include/linux/pci.h

commit 43b90eaed57679731ae340a47cef49e59a321c2e
Merge: 3da1b6174ba3 ad32eb2df801
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 4 13:27:45 2018 -0500

    Merge branch 'pci/misc'
    
      - use PCI_EXP_DEVCTL2_COMP_TIMEOUT in rapidio/tsi721 (Bjorn Helgaas)
    
      - remove possible NULL pointer dereference in of_pci_bus_find_domain_nr()
        (Shawn Lin)
    
      - report quirk timings with dev_info (Bjorn Helgaas)
    
      - report quirks that take longer than 10ms (Bjorn Helgaas)
    
      - add and use Altera Vendor ID (Johannes Thumshirn)
    
      - tidy Makefiles and comments (Bjorn Helgaas)
    
    * pci/misc:
      PCI: Always define the of_node helpers
      PCI: Tidy comments
      PCI: Tidy Makefiles
      mcb: Add Altera PCI ID to mcb-pci
      PCI: Add Altera vendor ID
      PCI: Report quirks that take more than 10ms
      PCI: Report quirk timings with pci_info() instead of pr_debug()
      PCI: Fix NULL pointer dereference in of_pci_bus_find_domain_nr()
      rapidio/tsi721: use PCI_EXP_DEVCTL2_COMP_TIMEOUT macro

commit c70b65fb7f121da7d01f62588ce6abb4741f513f
Author: Tal Gilboa <talgi@mellanox.com>
Date:   Fri Mar 30 08:24:36 2018 -0500

    PCI: Add pcie_get_width_cap() to find max supported link width
    
    Add pcie_get_width_cap() to find the max link width supported by a device.
    Change max_link_width_show() to use pcie_get_width_cap().
    
    Signed-off-by: Tal Gilboa <talgi@mellanox.com>
    [bhelgaas: return width directly instead of error and *width, don't export
    outside drivers/pci]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Tariq Toukan <tariqt@mellanox.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index c2ea05fbbf1d..63d0952684fb 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -167,15 +167,9 @@ static DEVICE_ATTR_RO(max_link_speed);
 static ssize_t max_link_width_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
-	struct pci_dev *pci_dev = to_pci_dev(dev);
-	u32 linkcap;
-	int err;
-
-	err = pcie_capability_read_dword(pci_dev, PCI_EXP_LNKCAP, &linkcap);
-	if (err)
-		return -EINVAL;
+	struct pci_dev *pdev = to_pci_dev(dev);
 
-	return sprintf(buf, "%u\n", (linkcap & PCI_EXP_LNKCAP_MLW) >> 4);
+	return sprintf(buf, "%u\n", pcie_get_width_cap(pdev));
 }
 static DEVICE_ATTR_RO(max_link_width);
 

commit 6cf57be0f78e289aaf236f8bc55c40ea6c422c75
Author: Tal Gilboa <talgi@mellanox.com>
Date:   Fri Mar 30 07:44:05 2018 -0500

    PCI: Add pcie_get_speed_cap() to find max supported link speed
    
    Add pcie_get_speed_cap() to find the max link speed supported by a device.
    Change max_link_speed_show() to use pcie_get_speed_cap().
    
    Signed-off-by: Tal Gilboa <talgi@mellanox.com>
    [bhelgaas: return speed directly instead of error and *speed, don't export
    outside drivers/pci]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Tariq Toukan <tariqt@mellanox.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 7dc5be545d18..c2ea05fbbf1d 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -158,33 +158,9 @@ static DEVICE_ATTR_RO(resource);
 static ssize_t max_link_speed_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
-	struct pci_dev *pci_dev = to_pci_dev(dev);
-	u32 linkcap;
-	int err;
-	const char *speed;
-
-	err = pcie_capability_read_dword(pci_dev, PCI_EXP_LNKCAP, &linkcap);
-	if (err)
-		return -EINVAL;
-
-	switch (linkcap & PCI_EXP_LNKCAP_SLS) {
-	case PCI_EXP_LNKCAP_SLS_16_0GB:
-		speed = "16 GT/s";
-		break;
-	case PCI_EXP_LNKCAP_SLS_8_0GB:
-		speed = "8 GT/s";
-		break;
-	case PCI_EXP_LNKCAP_SLS_5_0GB:
-		speed = "5 GT/s";
-		break;
-	case PCI_EXP_LNKCAP_SLS_2_5GB:
-		speed = "2.5 GT/s";
-		break;
-	default:
-		speed = "Unknown speed";
-	}
+	struct pci_dev *pdev = to_pci_dev(dev);
 
-	return sprintf(buf, "%s\n", speed);
+	return sprintf(buf, "%s\n", PCIE_SPEED2STR(pcie_get_speed_cap(pdev)));
 }
 static DEVICE_ATTR_RO(max_link_speed);
 

commit 1acfb9b7ee0b1881bb8e875b6757976e48293ec4
Author: Jay Fang <f.fangjian@huawei.com>
Date:   Mon Mar 12 17:13:32 2018 +0800

    PCI: Add decoding for 16 GT/s link speed
    
    PCIe 4.0 defines the 16.0 GT/s link speed.  Links can run at that speed
    without any Linux changes, but previously their sysfs "max_link_speed" and
    "current_link_speed" files contained "Unknown speed", not the expected
    "16.0 GT/s".
    
    Add decoding for the new 16 GT/s link speed.
    
    Signed-off-by: Jay Fang <f.fangjian@huawei.com>
    [bhelgaas: add PCI_EXP_LNKCAP2_SLS_16_0GB]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Dongdong Liu <liudongdong3@huawei.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index eb6bee8724cc..7dc5be545d18 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -168,6 +168,9 @@ static ssize_t max_link_speed_show(struct device *dev,
 		return -EINVAL;
 
 	switch (linkcap & PCI_EXP_LNKCAP_SLS) {
+	case PCI_EXP_LNKCAP_SLS_16_0GB:
+		speed = "16 GT/s";
+		break;
 	case PCI_EXP_LNKCAP_SLS_8_0GB:
 		speed = "8 GT/s";
 		break;
@@ -213,6 +216,9 @@ static ssize_t current_link_speed_show(struct device *dev,
 		return -EINVAL;
 
 	switch (linkstat & PCI_EXP_LNKSTA_CLS) {
+	case PCI_EXP_LNKSTA_CLS_16_0GB:
+		speed = "16 GT/s";
+		break;
 	case PCI_EXP_LNKSTA_CLS_8_0GB:
 		speed = "8 GT/s";
 		break;

commit df62ab5e0f75608919df7442654b0fab78246b7b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 16:36:33 2018 -0600

    PCI: Tidy comments
    
    Remove pointless comments that tell us the file name, remove blank line
    comments, follow multi-line comment conventions.  No functional change
    intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index eb6bee8724cc..db6b9bb86452 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1,7 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * drivers/pci/pci-sysfs.c
- *
  * (C) Copyright 2002-2004 Greg Kroah-Hartman <greg@kroah.com>
  * (C) Copyright 2002-2004 IBM Corp.
  * (C) Copyright 2003 Matthew Wilcox
@@ -12,7 +10,6 @@
  * File attributes for PCI devices
  *
  * Modeled after usb's driverfs.c
- *
  */
 
 

commit b1c615c48fa93db64310e8d1a457b364a486fde8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Mar 19 13:06:17 2018 -0500

    PCI/VPD: Move VPD sysfs code to vpd.c
    
    Move the VPD-related sysfs code from pci-sysfs.c to vpd.c.  This follows
    the pattern of pcie_aspm_create_sysfs_dev_files().  The goal is to
    encapsulate all the VPD code and structures in vpd.c.
    
    No functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index eb6bee8724cc..4415e624cf7e 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -982,38 +982,6 @@ static ssize_t pci_write_config(struct file *filp, struct kobject *kobj,
 	return count;
 }
 
-static ssize_t read_vpd_attr(struct file *filp, struct kobject *kobj,
-			     struct bin_attribute *bin_attr, char *buf,
-			     loff_t off, size_t count)
-{
-	struct pci_dev *dev = to_pci_dev(kobj_to_dev(kobj));
-
-	if (bin_attr->size > 0) {
-		if (off > bin_attr->size)
-			count = 0;
-		else if (count > bin_attr->size - off)
-			count = bin_attr->size - off;
-	}
-
-	return pci_read_vpd(dev, off, count, buf);
-}
-
-static ssize_t write_vpd_attr(struct file *filp, struct kobject *kobj,
-			      struct bin_attribute *bin_attr, char *buf,
-			      loff_t off, size_t count)
-{
-	struct pci_dev *dev = to_pci_dev(kobj_to_dev(kobj));
-
-	if (bin_attr->size > 0) {
-		if (off > bin_attr->size)
-			count = 0;
-		else if (count > bin_attr->size - off)
-			count = bin_attr->size - off;
-	}
-
-	return pci_write_vpd(dev, off, count, buf);
-}
-
 #ifdef HAVE_PCI_LEGACY
 /**
  * pci_read_legacy_io - read byte(s) from legacy I/O port space
@@ -1517,29 +1485,8 @@ static struct device_attribute reset_attr = __ATTR(reset, 0200, NULL, reset_stor
 static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 {
 	int retval;
-	struct bin_attribute *attr;
-
-	/* If the device has VPD, try to expose it in sysfs. */
-	if (dev->vpd) {
-		attr = kzalloc(sizeof(*attr), GFP_ATOMIC);
-		if (!attr)
-			return -ENOMEM;
 
-		sysfs_bin_attr_init(attr);
-		attr->size = 0;
-		attr->attr.name = "vpd";
-		attr->attr.mode = S_IRUSR | S_IWUSR;
-		attr->read = read_vpd_attr;
-		attr->write = write_vpd_attr;
-		retval = sysfs_create_bin_file(&dev->dev.kobj, attr);
-		if (retval) {
-			kfree(attr);
-			return retval;
-		}
-		dev->vpd->attr = attr;
-	}
-
-	/* Active State Power Management */
+	pcie_vpd_create_sysfs_dev_files(dev);
 	pcie_aspm_create_sysfs_dev_files(dev);
 
 	if (!pci_probe_reset_function(dev)) {
@@ -1552,11 +1499,7 @@ static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 
 error:
 	pcie_aspm_remove_sysfs_dev_files(dev);
-	if (dev->vpd && dev->vpd->attr) {
-		sysfs_remove_bin_file(&dev->dev.kobj, dev->vpd->attr);
-		kfree(dev->vpd->attr);
-	}
-
+	pcie_vpd_remove_sysfs_dev_files(dev);
 	return retval;
 }
 
@@ -1630,11 +1573,7 @@ int __must_check pci_create_sysfs_dev_files(struct pci_dev *pdev)
 
 static void pci_remove_capabilities_sysfs(struct pci_dev *dev)
 {
-	if (dev->vpd && dev->vpd->attr) {
-		sysfs_remove_bin_file(&dev->dev.kobj, dev->vpd->attr);
-		kfree(dev->vpd->attr);
-	}
-
+	pcie_vpd_remove_sysfs_dev_files(dev);
 	pcie_aspm_remove_sysfs_dev_files(dev);
 	if (dev->reset_fn) {
 		device_remove_file(&dev->dev, &reset_attr);

commit 5b0764cac9f1b70a6704b0e546be67c24cc05517
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 16 10:55:38 2018 -0600

    PCI: Probe for device reset support during enumeration
    
    Previously we called pci_probe_reset_function() in this path:
    
      pci_sysfs_init                              # late_initcall
        for_each_pci_dev(dev)
          pci_create_sysfs_dev_files(dev)
            pci_create_capabilities_sysfs(dev)
              pci_probe_reset_function
                pci_dev_specific_reset
                pcie_has_flr
                  pcie_capability_read_dword
    
    pci_sysfs_init() is a late_initcall, and a driver may have already claimed
    one of these devices and enabled runtime power management for it, so the
    device could already be in D3 by the time we get to pci_sysfs_init().
    
    The device itself should respond to the config read even while it's in
    D3hot, but if an upstream bridge is also in D3hot, the read won't even
    reach the device because the bridge won't forward it downstream to the
    device.  If the bridge is a PCIe port, it should complete the read as an
    Unsupported Request, which may be reported to the CPU as an exception or as
    invalid data.
    
    Avoid this case by probing for reset support from pci_init_capabilities(),
    before a driver can claim the device.  The device may be in D3hot, but any
    bridges leading to it should be in D0, so the device's config space should
    be fully accessible at that point.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index eb6bee8724cc..4933f0270471 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1542,11 +1542,10 @@ static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 	/* Active State Power Management */
 	pcie_aspm_create_sysfs_dev_files(dev);
 
-	if (!pci_probe_reset_function(dev)) {
+	if (dev->reset_fn) {
 		retval = device_create_file(&dev->dev, &reset_attr);
 		if (retval)
 			goto error;
-		dev->reset_fn = 1;
 	}
 	return 0;
 

commit a07ae842e209196ffe0fe8feacd489aba772d8a0
Merge: 01f095e46ba3 0077a845f7e3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 31 10:13:09 2018 -0600

    Merge branch 'pci/virtualization' into next
    
    * pci/virtualization:
      PCI: Expose ari_enabled in sysfs
      PCI: Add function 1 DMA alias quirk for Marvell 9128
      PCI: Mark Ceton InfiniTV4 INTx masking as broken
      xen/pci: Use acpi_noirq_set() helper to avoid #ifdef

commit 414ae7609e19580a56647344e61f13f3768e0820
Merge: 11377725da46 a9b94b74806b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 31 10:12:56 2018 -0600

    Merge branch 'pci/resource' into next
    
    * pci/resource:
      PCI: tegra: Remove PCI_REASSIGN_ALL_BUS use on Tegra
      resource: Set type when reserving new regions
      resource: Set type of "reserve=" user-specified resources
      irqchip/i8259: Set I/O port resource types correctly
      powerpc: Set I/O port resource types correctly
      MIPS: Set I/O port resource types correctly
      vgacon: Set VGA struct resource types
      PCI: Use dev_info() rather than dev_err() for ROM validation
      PCI: Remove PCI_REASSIGN_ALL_RSRC use on arm and arm64
      PCI: Remove sysfs resource mmap warning
    
    Conflicts:
            drivers/pci/rom.c

commit 0077a845f7e31a6eabafaefc99540903b65439d4
Author: Stuart Hayes <stuart.w.hayes@gmail.com>
Date:   Fri Jan 5 12:51:55 2018 -0600

    PCI: Expose ari_enabled in sysfs
    
    Some multifunction PCI devices with more than 8 functions use "alternative
    routing-ID interpretation" (ARI), which means the 8-bit device/function
    number field will be interpreted as 8 bits specifying the function number
    (the device number is 0 implicitly), rather than the upper 5 bits
    specifying the device number and the lower 3 bits specifying the function
    number. The kernel can enable and use this.
    
    Expose in a sysfs attribute whether the kernel has enabled ARI, so that a
    program in userspace won't have to parse PCI devices and PCI configuration
    space to figure out if it is enabled. This will allow better predictable
    network naming using PCI function numbers without using PCI bus or device
    numbers, which is desirable because bus and device numbers can change with
    system configuration but function numbers will not.
    
    Signed-off-by: Stuart Hayes <stuart.w.hayes@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 06c7f0b85cd2..707a4b46b97a 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -278,6 +278,16 @@ static ssize_t subordinate_bus_number_show(struct device *dev,
 }
 static DEVICE_ATTR_RO(subordinate_bus_number);
 
+static ssize_t ari_enabled_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+
+	return sprintf(buf, "%u\n", pci_ari_enabled(pci_dev->bus));
+}
+static DEVICE_ATTR_RO(ari_enabled);
+
 static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,
 			     char *buf)
 {
@@ -786,6 +796,7 @@ static struct attribute *pci_dev_attrs[] = {
 	&dev_attr_devspec.attr,
 #endif
 	&dev_attr_driver_override.attr,
+	&dev_attr_ari_enabled.attr,
 	NULL,
 };
 

commit 7506dc7989933235e6fc23f3d0516bdbf0f7d1a8
Author: Frederick Lawler <fred@fredlawl.com>
Date:   Thu Jan 18 12:55:24 2018 -0600

    PCI: Add wrappers for dev_printk()
    
    Add PCI-specific dev_printk() wrappers and use them to simplify the code
    slightly.  No functional change intended.
    
    Signed-off-by: Frederick Lawler <fred@fredlawl.com>
    [bhelgaas: squash into one patch]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 06c7f0b85cd2..c7941a0512a5 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -348,7 +348,7 @@ static ssize_t numa_node_store(struct device *dev,
 		return -EINVAL;
 
 	add_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);
-	dev_alert(&pdev->dev, FW_BUG "Overriding NUMA node to %d.  Contact your vendor for updates.",
+	pci_alert(pdev, FW_BUG "Overriding NUMA node to %d.  Contact your vendor for updates.",
 		  node);
 
 	dev->numa_node = node;
@@ -411,7 +411,7 @@ static ssize_t msi_bus_store(struct device *dev, struct device_attribute *attr,
 	 */
 	if (!subordinate) {
 		pdev->no_msi = !val;
-		dev_info(&pdev->dev, "MSI/MSI-X %s for future drivers\n",
+		pci_info(pdev, "MSI/MSI-X %s for future drivers\n",
 			 val ? "allowed" : "disallowed");
 		return count;
 	}
@@ -613,7 +613,7 @@ static ssize_t sriov_numvfs_store(struct device *dev,
 
 	/* is PF driver loaded w/callback */
 	if (!pdev->driver || !pdev->driver->sriov_configure) {
-		dev_info(&pdev->dev, "Driver doesn't support SRIOV configuration via sysfs\n");
+		pci_info(pdev, "Driver doesn't support SRIOV configuration via sysfs\n");
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -626,7 +626,7 @@ static ssize_t sriov_numvfs_store(struct device *dev,
 
 	/* enable VFs */
 	if (pdev->sriov->num_VFs) {
-		dev_warn(&pdev->dev, "%d VFs already enabled. Disable before enabling %d VFs\n",
+		pci_warn(pdev, "%d VFs already enabled. Disable before enabling %d VFs\n",
 			 pdev->sriov->num_VFs, num_vfs);
 		ret = -EBUSY;
 		goto exit;
@@ -637,7 +637,7 @@ static ssize_t sriov_numvfs_store(struct device *dev,
 		goto exit;
 
 	if (ret != num_vfs)
-		dev_warn(&pdev->dev, "%d VFs requested; only %d enabled\n",
+		pci_warn(pdev, "%d VFs requested; only %d enabled\n",
 			 num_vfs, ret);
 
 exit:

commit 7a09490966bd4e36fd1cee33775b3ed15344f93d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Nov 29 11:47:29 2017 -0600

    PCI: Remove sysfs resource mmap warning
    
    When a process uses sysfs and tries to mmap more space than is available in
    a PCI BAR, we emit a warning and a backtrace.  The mmap fails anyway, so
    the backtrace is mainly for debugging.  But in general we don't emit kernel
    messages when syscalls return failure.
    
    The similar procfs mmap path simply fails the mmap with no warning.  Remove
    the sysfs warning.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 06c7f0b85cd2..ccc0e28c6678 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1216,14 +1216,9 @@ static int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 	if (res->flags & IORESOURCE_MEM && iomem_is_exclusive(res->start))
 		return -EINVAL;
 
-	if (!pci_mmap_fits(pdev, bar, vma, PCI_MMAP_SYSFS)) {
-		WARN(1, "process \"%s\" tried to map 0x%08lx bytes at page 0x%08lx on %s BAR %d (start 0x%16Lx, size 0x%16Lx)\n",
-			current->comm, vma->vm_end-vma->vm_start, vma->vm_pgoff,
-			pci_name(pdev), bar,
-			(u64)pci_resource_start(pdev, bar),
-			(u64)pci_resource_len(pdev, bar));
+	if (!pci_mmap_fits(pdev, bar, vma, PCI_MMAP_SYSFS))
 		return -EINVAL;
-	}
+
 	mmap_type = res->flags & IORESOURCE_MEM ? pci_mmap_mem : pci_mmap_io;
 
 	return pci_mmap_resource_range(pdev, bar, vma, mmap_type, write_combine);

commit 1b6115fbe3b3db746d7baa11399dd617fc75e1c4
Merge: ad0835a93008 91f3140fdef6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 15 15:01:28 2017 -0800

    Merge tag 'pci-v4.15-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
      - detach driver before tearing down procfs/sysfs (Alex Williamson)
    
      - disable PCIe services during shutdown (Sinan Kaya)
    
      - fix ASPM oops on systems with no Root Ports (Ard Biesheuvel)
    
      - fix ASPM LTR_L1.2_THRESHOLD programming (Bjorn Helgaas)
    
      - fix ASPM Common_Mode_Restore_Time computation (Bjorn Helgaas)
    
      - fix portdrv MSI/MSI-X vector allocation (Dongdong Liu, Bjorn
        Helgaas)
    
      - report non-fatal AER errors only to the affected endpoint (Gabriele
        Paoloni)
    
      - distribute bus numbers, MMIO, and I/O space among hotplug bridges to
        allow more devices to be hot-added (Mika Westerberg)
    
      - fix pciehp races during initialization and surprise link down (Mika
        Westerberg)
    
      - handle surprise-removed devices in PME handling (Qiang)
    
      - support resizable BARs for large graphics devices (Christian König)
    
      - expose SR-IOV offset, stride, and VF device ID via sysfs (Filippo
        Sironi)
    
      - create SR-IOV virtfn/physfn sysfs links before attaching driver
        (Stuart Hayes)
    
      - fix SR-IOV "ARI Capable Hierarchy" restore issue (Tony Nguyen)
    
      - enforce Kconfig IOV/REALLOC dependency (Sascha El-Sharkawy)
    
      - avoid slot reset if bridge itself is broken (Jan Glauber)
    
      - clean up pci_reset_function() path (Jan H. Schönherr)
    
      - make pci_map_rom() fail if the option ROM is invalid (Changbin Du)
    
      - convert timers to timer_setup() (Kees Cook)
    
      - move PCI_QUIRKS to PCI bus Kconfig menu (Randy Dunlap)
    
      - constify pci_dev_type and intel_mid_pci_ops (Bhumika Goyal)
    
      - remove unnecessary pci_dev, pci_bus, resource, pcibios_set_master()
        declarations (Bjorn Helgaas)
    
      - fix endpoint framework overflows and BUG()s (Dan Carpenter)
    
      - fix endpoint framework issues (Kishon Vijay Abraham I)
    
      - avoid broken Cavium CN8xxx bus reset behavior (David Daney)
    
      - extend Cavium ACS capability quirks (Vadim Lomovtsev)
    
      - support Synopsys DesignWare RC in ECAM mode (Ard Biesheuvel)
    
      - turn off dra7xx clocks cleanly on shutdown (Keerthy)
    
      - fix Faraday probe error path (Wei Yongjun)
    
      - support HiSilicon STB SoC PCIe host controller (Jianguo Sun)
    
      - fix Hyper-V interrupt affinity issue (Dexuan Cui)
    
      - remove useless ACPI warning for Hyper-V pass-through devices (Vitaly
        Kuznetsov)
    
      - support multiple MSI on iProc (Sandor Bodo-Merle)
    
      - support Layerscape LS1012a and LS1046a PCIe host controllers (Hou
        Zhiqiang)
    
      - fix Layerscape default error response (Minghuan Lian)
    
      - support MSI on Tango host controller (Marc Gonzalez)
    
      - support Tegra186 PCIe host controller (Manikanta Maddireddy)
    
      - use generic accessors on Tegra when possible (Thierry Reding)
    
      - support V3 Semiconductor PCI host controller (Linus Walleij)
    
    * tag 'pci-v4.15-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (85 commits)
      PCI/ASPM: Add L1 Substates definitions
      PCI/ASPM: Reformat ASPM register definitions
      PCI/ASPM: Use correct capability pointer to program LTR_L1.2_THRESHOLD
      PCI/ASPM: Account for downstream device's Port Common_Mode_Restore_Time
      PCI: xgene: Rename xgene_pcie_probe_bridge() to xgene_pcie_probe()
      PCI: xilinx: Rename xilinx_pcie_link_is_up() to xilinx_pcie_link_up()
      PCI: altera: Rename altera_pcie_link_is_up() to altera_pcie_link_up()
      PCI: Fix kernel-doc build warning
      PCI: Fail pci_map_rom() if the option ROM is invalid
      PCI: Move pci_map_rom() error path
      PCI: Move PCI_QUIRKS to the PCI bus menu
      alpha/PCI: Make pdev_save_srm_config() static
      PCI: Remove unused declarations
      PCI: Remove redundant pci_dev, pci_bus, resource declarations
      PCI: Remove redundant pcibios_set_master() declarations
      PCI/PME: Handle invalid data when reading Root Status
      PCI: hv: Use effective affinity mask
      PCI: pciehp: Do not clear Presence Detect Changed during initialization
      PCI: pciehp: Fix race condition handling surprise link down
      PCI: Distribute available resources to hotplug-capable bridges
      ...

commit 9ceb09cce1a30bdbcff861d1bbbbe0dbb7de05de
Merge: 9af21ac53f97 832c418a1530
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Nov 14 12:11:26 2017 -0600

    Merge branch 'pci/virtualization' into next
    
    * pci/virtualization:
      PCI: Document reset method return values
      PCI: Detach driver before procfs & sysfs teardown on device remove
      PCI: Apply Cavium ThunderX ACS quirk to more Root Ports
      PCI: Set Cavium ACS capability quirk flags to assert RR/CR/SV/UF
      PCI: Restore ARI Capable Hierarchy before setting numVFs
      PCI: Create SR-IOV virtfn/physfn links before attaching driver
      PCI: Expose SR-IOV offset, stride, and VF device ID via sysfs
      PCI: Cache the VF device ID in the SR-IOV structure
      PCI: Add Kconfig PCI_IOV dependency for PCI_REALLOC_ENABLE_AUTO
      PCI: Remove unused function __pci_reset_function()
      PCI: Remove reset argument from pci_iov_{add,remove}_virtfn()

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 8e075ea2743e..00fa4278c1f4 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * drivers/pci/pci-sysfs.c
  *

commit 7dfca15276fc3f18411a2b2182704fa1222bcb60
Author: Filippo Sironi <sironi@amazon.de>
Date:   Mon Oct 9 01:09:11 2017 +0200

    PCI: Expose SR-IOV offset, stride, and VF device ID via sysfs
    
    Expose the SR-IOV device offset, stride, and VF device ID via sysfs to make
    it easier for userspace applications to consume them.
    
    Signed-off-by: Filippo Sironi <sironi@amazon.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 8e075ea2743e..3ea7a62a5d4f 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -648,6 +648,33 @@ static ssize_t sriov_numvfs_store(struct device *dev,
 	return count;
 }
 
+static ssize_t sriov_offset_show(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	return sprintf(buf, "%u\n", pdev->sriov->offset);
+}
+
+static ssize_t sriov_stride_show(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	return sprintf(buf, "%u\n", pdev->sriov->stride);
+}
+
+static ssize_t sriov_vf_device_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	return sprintf(buf, "%x\n", pdev->sriov->vf_device);
+}
+
 static ssize_t sriov_drivers_autoprobe_show(struct device *dev,
 					    struct device_attribute *attr,
 					    char *buf)
@@ -676,6 +703,9 @@ static struct device_attribute sriov_totalvfs_attr = __ATTR_RO(sriov_totalvfs);
 static struct device_attribute sriov_numvfs_attr =
 		__ATTR(sriov_numvfs, (S_IRUGO|S_IWUSR|S_IWGRP),
 		       sriov_numvfs_show, sriov_numvfs_store);
+static struct device_attribute sriov_offset_attr = __ATTR_RO(sriov_offset);
+static struct device_attribute sriov_stride_attr = __ATTR_RO(sriov_stride);
+static struct device_attribute sriov_vf_device_attr = __ATTR_RO(sriov_vf_device);
 static struct device_attribute sriov_drivers_autoprobe_attr =
 		__ATTR(sriov_drivers_autoprobe, (S_IRUGO|S_IWUSR|S_IWGRP),
 		       sriov_drivers_autoprobe_show, sriov_drivers_autoprobe_store);
@@ -1748,6 +1778,9 @@ static const struct attribute_group pci_dev_hp_attr_group = {
 static struct attribute *sriov_dev_attrs[] = {
 	&sriov_totalvfs_attr.attr,
 	&sriov_numvfs_attr.attr,
+	&sriov_offset_attr.attr,
+	&sriov_stride_attr.attr,
+	&sriov_vf_device_attr.attr,
 	&sriov_drivers_autoprobe_attr.attr,
 	NULL,
 };

commit 69f2dc24ff32ae61291dc63525d70c06ac9d8ba3
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Tue Sep 12 16:43:33 2017 +0530

    PCI: Constify pci_dev_type structure
    
    Make this const as it not modified in the file referencing it.  It is only
    stored in a const field 'type' of a device structure.  Also, add const to
    the variable declaration in the header file.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 8e075ea2743e..5aa81ad91a88 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1795,6 +1795,6 @@ static const struct attribute_group *pci_dev_attr_groups[] = {
 	NULL,
 };
 
-struct device_type pci_dev_type = {
+const struct device_type pci_dev_type = {
 	.groups = pci_dev_attr_groups,
 };

commit 9561475db680f7144d2223a409dd3d7e322aca03
Author: Nicolai Stange <nstange@suse.de>
Date:   Mon Sep 11 09:45:40 2017 +0200

    PCI: Fix race condition with driver_override
    
    The driver_override implementation is susceptible to a race condition when
    different threads are reading vs. storing a different driver override.  Add
    locking to avoid the race condition.
    
    This is in close analogy to commit 6265539776a0 ("driver core: platform:
    fix race condition with driver_override") from Adrian Salido.
    
    Fixes: 782a985d7af2 ("PCI: Introduce new device binding path using pci_dev.driver_override")
    Signed-off-by: Nicolai Stange <nstange@suse.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: stable@vger.kernel.org      # v3.16+

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 1eecfa301f7f..8e075ea2743e 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -686,7 +686,7 @@ static ssize_t driver_override_store(struct device *dev,
 				     const char *buf, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
-	char *driver_override, *old = pdev->driver_override, *cp;
+	char *driver_override, *old, *cp;
 
 	/* We need to keep extra room for a newline */
 	if (count >= (PAGE_SIZE - 1))
@@ -700,12 +700,15 @@ static ssize_t driver_override_store(struct device *dev,
 	if (cp)
 		*cp = '\0';
 
+	device_lock(dev);
+	old = pdev->driver_override;
 	if (strlen(driver_override)) {
 		pdev->driver_override = driver_override;
 	} else {
 		kfree(driver_override);
 		pdev->driver_override = NULL;
 	}
+	device_unlock(dev);
 
 	kfree(old);
 
@@ -716,8 +719,12 @@ static ssize_t driver_override_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
+	ssize_t len;
 
-	return snprintf(buf, PAGE_SIZE, "%s\n", pdev->driver_override);
+	device_lock(dev);
+	len = snprintf(buf, PAGE_SIZE, "%s\n", pdev->driver_override);
+	device_unlock(dev);
+	return len;
 }
 static DEVICE_ATTR_RW(driver_override);
 

commit 27e87395ae3497ebb63942150e43999c93a83ed0
Merge: 9198407e23ec 96291d565550
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Sep 7 13:24:20 2017 -0500

    Merge branch 'pci/trivial' into next
    
    * pci/trivial:
      PCI: Fix typos and whitespace errors
      PCI: Remove unused "res" variable from pci_resource_io()
      PCI: Correct kernel-doc of pci_vpd_srdt_size(), pci_vpd_srdt_tag()

commit cacf7eaf2a36cc51c24b591d681676b6d27a7a6e
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Fri Sep 1 16:35:30 2017 -0500

    PCI: Remove unused "res" variable from pci_resource_io()
    
    The "res" variable in pci_resource_io() is never used.  Remove it.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 2f3780b50723..0e4370540786 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1211,11 +1211,8 @@ static ssize_t pci_resource_io(struct file *filp, struct kobject *kobj,
 {
 	struct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));
 	int bar = (unsigned long)attr->private;
-	struct resource *res;
 	unsigned long port = off;
 
-	res = &pdev->resource[bar];
-
 	port += pci_resource_start(pdev, bar);
 
 	if (port > pci_resource_end(pdev, bar))

commit b63773a801ff7f7f047894a9be23616f4491aca8
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:43:21 2017 -0500

    PCI: Convert to using %pOF instead of full_name()
    
    Now that we have a custom printf format specifier, convert users of
    full_name() to use %pOF instead.  This is preparation for removing storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 93e7b97765d7..c9cdc8a1d48a 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -556,9 +556,9 @@ static ssize_t devspec_show(struct device *dev,
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct device_node *np = pci_device_to_OF_node(pdev);
 
-	if (np == NULL || np->full_name == NULL)
+	if (np == NULL)
 		return 0;
-	return sprintf(buf, "%s", np->full_name);
+	return sprintf(buf, "%pOF", np);
 }
 static DEVICE_ATTR_RO(devspec);
 #endif

commit 8bdc50ac56ab97e7585ee928a1017284afeee17a
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Wed Aug 2 20:57:27 2017 +0530

    PCI: Constify bin_attribute structures
    
    Add const to bin_attribute structures as they are only passed to the
    functions sysfs_{remove/create}_bin_file. The corresponding arguments are
    of type const, so declare the structures to be const.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 2eed0dce258b..93e7b97765d7 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1431,7 +1431,7 @@ static ssize_t pci_read_rom(struct file *filp, struct kobject *kobj,
 	return count;
 }
 
-static struct bin_attribute pci_config_attr = {
+static const struct bin_attribute pci_config_attr = {
 	.attr =	{
 		.name = "config",
 		.mode = S_IRUGO | S_IWUSR,
@@ -1441,7 +1441,7 @@ static struct bin_attribute pci_config_attr = {
 	.write = pci_write_config,
 };
 
-static struct bin_attribute pcie_config_attr = {
+static const struct bin_attribute pcie_config_attr = {
 	.attr =	{
 		.name = "config",
 		.mode = S_IRUGO | S_IWUSR,

commit e7ea9825fa18eccaa25142bf574cfef769d225ed
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Tue Jul 11 14:57:07 2017 +0530

    PCI: Constify sysfs attribute_group structures
    
    attribute_groups are not supposed to change at runtime.  All functions
    working with attribute_groups provided by <linux/sysfs.h> work with const
    attribute_group.  So mark the non-const structs as const.
    
    File size before:
       text    data     bss     dec     hex filename
       8480    2024       4   10508    290c drivers/pci/pci-sysfs.o
    
    File size After adding 'const':
       text    data     bss     dec     hex filename
       8736    1768       4   10508    290c drivers/pci/pci-sysfs.o
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 2f3780b50723..2eed0dce258b 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1735,7 +1735,7 @@ const struct attribute_group *pcie_dev_groups[] = {
 	NULL,
 };
 
-static struct attribute_group pci_dev_hp_attr_group = {
+static const struct attribute_group pci_dev_hp_attr_group = {
 	.attrs = pci_dev_hp_attrs,
 	.is_visible = pci_dev_hp_attrs_are_visible,
 };
@@ -1759,23 +1759,23 @@ static umode_t sriov_attrs_are_visible(struct kobject *kobj,
 	return a->mode;
 }
 
-static struct attribute_group sriov_dev_attr_group = {
+static const struct attribute_group sriov_dev_attr_group = {
 	.attrs = sriov_dev_attrs,
 	.is_visible = sriov_attrs_are_visible,
 };
 #endif /* CONFIG_PCI_IOV */
 
-static struct attribute_group pci_dev_attr_group = {
+static const struct attribute_group pci_dev_attr_group = {
 	.attrs = pci_dev_dev_attrs,
 	.is_visible = pci_dev_attrs_are_visible,
 };
 
-static struct attribute_group pci_bridge_attr_group = {
+static const struct attribute_group pci_bridge_attr_group = {
 	.attrs = pci_bridge_attrs,
 	.is_visible = pci_bridge_attrs_are_visible,
 };
 
-static struct attribute_group pcie_dev_attr_group = {
+static const struct attribute_group pcie_dev_attr_group = {
 	.attrs = pcie_dev_attrs,
 	.is_visible = pcie_dev_attrs_are_visible,
 };

commit bb02ce95a59ee5b96579fab2e2e7635ee26d535b
Merge: c781f85bc195 52354b9d1f46
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jul 3 08:00:29 2017 -0500

    Merge branch 'pci/virtualization' into next
    
    * pci/virtualization:
      PCI: Remove __pci_dev_reset() and pci_dev_reset()
      PCI: Split ->reset_notify() method into ->reset_prepare() and ->reset_done()
      PCI: Protect pci_error_handlers->reset_notify() usage with device_lock()
      PCI: Protect pci_driver->sriov_configure() usage with device_lock()
      PCI: Mark Intel XXV710 NIC INTx masking as broken
      PCI: Restore PRI and PASID state after Function-Level Reset
      PCI: Cache PRI and PASID bits in pci_dev

commit 56c1af4606f04048e3ae9ab2027a708b9684ff37
Author: Wong Vee Khee <vee.khee.wong@ni.com>
Date:   Thu Jun 1 17:43:06 2017 +0800

    PCI: Add sysfs max_link_speed/width, current_link_speed/width, etc
    
    Expose PCIe bridges attributes such as secondary bus number, subordinate
    bus number, max link speed and link width, current link speed and link
    width via sysfs in /sys/bus/pci/devices/...
    
    This information is available via lspci, but that requires root privilege.
    
    Signed-off-by: Wong Vee Khee <vee.khee.wong@ni.com>
    Signed-off-by: Hui Chun Ong <hui.chun.ong@ni.com>
    [bhelgaas: changelog, return errors early to unindent usual case, return
    errors with same style throughout]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 31e99613a12e..a3537cf58a20 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -154,6 +154,129 @@ static ssize_t resource_show(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR_RO(resource);
 
+static ssize_t max_link_speed_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	u32 linkcap;
+	int err;
+	const char *speed;
+
+	err = pcie_capability_read_dword(pci_dev, PCI_EXP_LNKCAP, &linkcap);
+	if (err)
+		return -EINVAL;
+
+	switch (linkcap & PCI_EXP_LNKCAP_SLS) {
+	case PCI_EXP_LNKCAP_SLS_8_0GB:
+		speed = "8 GT/s";
+		break;
+	case PCI_EXP_LNKCAP_SLS_5_0GB:
+		speed = "5 GT/s";
+		break;
+	case PCI_EXP_LNKCAP_SLS_2_5GB:
+		speed = "2.5 GT/s";
+		break;
+	default:
+		speed = "Unknown speed";
+	}
+
+	return sprintf(buf, "%s\n", speed);
+}
+static DEVICE_ATTR_RO(max_link_speed);
+
+static ssize_t max_link_width_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	u32 linkcap;
+	int err;
+
+	err = pcie_capability_read_dword(pci_dev, PCI_EXP_LNKCAP, &linkcap);
+	if (err)
+		return -EINVAL;
+
+	return sprintf(buf, "%u\n", (linkcap & PCI_EXP_LNKCAP_MLW) >> 4);
+}
+static DEVICE_ATTR_RO(max_link_width);
+
+static ssize_t current_link_speed_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	u16 linkstat;
+	int err;
+	const char *speed;
+
+	err = pcie_capability_read_word(pci_dev, PCI_EXP_LNKSTA, &linkstat);
+	if (err)
+		return -EINVAL;
+
+	switch (linkstat & PCI_EXP_LNKSTA_CLS) {
+	case PCI_EXP_LNKSTA_CLS_8_0GB:
+		speed = "8 GT/s";
+		break;
+	case PCI_EXP_LNKSTA_CLS_5_0GB:
+		speed = "5 GT/s";
+		break;
+	case PCI_EXP_LNKSTA_CLS_2_5GB:
+		speed = "2.5 GT/s";
+		break;
+	default:
+		speed = "Unknown speed";
+	}
+
+	return sprintf(buf, "%s\n", speed);
+}
+static DEVICE_ATTR_RO(current_link_speed);
+
+static ssize_t current_link_width_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	u16 linkstat;
+	int err;
+
+	err = pcie_capability_read_word(pci_dev, PCI_EXP_LNKSTA, &linkstat);
+	if (err)
+		return -EINVAL;
+
+	return sprintf(buf, "%u\n",
+		(linkstat & PCI_EXP_LNKSTA_NLW) >> PCI_EXP_LNKSTA_NLW_SHIFT);
+}
+static DEVICE_ATTR_RO(current_link_width);
+
+static ssize_t secondary_bus_number_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	u8 sec_bus;
+	int err;
+
+	err = pci_read_config_byte(pci_dev, PCI_SECONDARY_BUS, &sec_bus);
+	if (err)
+		return -EINVAL;
+
+	return sprintf(buf, "%u\n", sec_bus);
+}
+static DEVICE_ATTR_RO(secondary_bus_number);
+
+static ssize_t subordinate_bus_number_show(struct device *dev,
+					   struct device_attribute *attr,
+					   char *buf)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	u8 sub_bus;
+	int err;
+
+	err = pci_read_config_byte(pci_dev, PCI_SUBORDINATE_BUS, &sub_bus);
+	if (err)
+		return -EINVAL;
+
+	return sprintf(buf, "%u\n", sub_bus);
+}
+static DEVICE_ATTR_RO(subordinate_bus_number);
+
 static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,
 			     char *buf)
 {
@@ -629,12 +752,17 @@ static struct attribute *pci_dev_attrs[] = {
 	NULL,
 };
 
-static const struct attribute_group pci_dev_group = {
-	.attrs = pci_dev_attrs,
+static struct attribute *pci_bridge_attrs[] = {
+	&dev_attr_subordinate_bus_number.attr,
+	&dev_attr_secondary_bus_number.attr,
+	NULL,
 };
 
-const struct attribute_group *pci_dev_groups[] = {
-	&pci_dev_group,
+static struct attribute *pcie_dev_attrs[] = {
+	&dev_attr_current_link_speed.attr,
+	&dev_attr_current_link_width.attr,
+	&dev_attr_max_link_width.attr,
+	&dev_attr_max_link_speed.attr,
 	NULL,
 };
 
@@ -1557,6 +1685,57 @@ static umode_t pci_dev_hp_attrs_are_visible(struct kobject *kobj,
 	return a->mode;
 }
 
+static umode_t pci_bridge_attrs_are_visible(struct kobject *kobj,
+					    struct attribute *a, int n)
+{
+	struct device *dev = kobj_to_dev(kobj);
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	if (pci_is_bridge(pdev))
+		return a->mode;
+
+	return 0;
+}
+
+static umode_t pcie_dev_attrs_are_visible(struct kobject *kobj,
+					  struct attribute *a, int n)
+{
+	struct device *dev = kobj_to_dev(kobj);
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	if (pci_is_pcie(pdev))
+		return a->mode;
+
+	return 0;
+}
+
+static const struct attribute_group pci_dev_group = {
+	.attrs = pci_dev_attrs,
+};
+
+const struct attribute_group *pci_dev_groups[] = {
+	&pci_dev_group,
+	NULL,
+};
+
+static const struct attribute_group pci_bridge_group = {
+	.attrs = pci_bridge_attrs,
+};
+
+const struct attribute_group *pci_bridge_groups[] = {
+	&pci_bridge_group,
+	NULL,
+};
+
+static const struct attribute_group pcie_dev_group = {
+	.attrs = pcie_dev_attrs,
+};
+
+const struct attribute_group *pcie_dev_groups[] = {
+	&pcie_dev_group,
+	NULL,
+};
+
 static struct attribute_group pci_dev_hp_attr_group = {
 	.attrs = pci_dev_hp_attrs,
 	.is_visible = pci_dev_hp_attrs_are_visible,
@@ -1592,12 +1771,24 @@ static struct attribute_group pci_dev_attr_group = {
 	.is_visible = pci_dev_attrs_are_visible,
 };
 
+static struct attribute_group pci_bridge_attr_group = {
+	.attrs = pci_bridge_attrs,
+	.is_visible = pci_bridge_attrs_are_visible,
+};
+
+static struct attribute_group pcie_dev_attr_group = {
+	.attrs = pcie_dev_attrs,
+	.is_visible = pcie_dev_attrs_are_visible,
+};
+
 static const struct attribute_group *pci_dev_attr_groups[] = {
 	&pci_dev_attr_group,
 	&pci_dev_hp_attr_group,
 #ifdef CONFIG_PCI_IOV
 	&sriov_dev_attr_group,
 #endif
+	&pci_bridge_attr_group,
+	&pcie_dev_attr_group,
 	NULL,
 };
 

commit 17530e71e0166a37f8e20a9b7bcf1d50ae3cff8e
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Mon May 22 15:50:23 2017 -0700

    PCI: Protect pci_driver->sriov_configure() usage with device_lock()
    
    Every method in struct device_driver or structures derived from it like
    struct pci_driver MUST provide exclusion vs the driver's ->remove() method,
    usually by using device_lock().
    
    Protect use of pci_driver->sriov_configure() by holding the device lock
    while calling it.
    
    The PCI core sets the pci_dev->driver pointer in local_pci_probe() before
    calling ->probe() and only clears it after ->remove().  This means driver's
    ->sriov_configure() callback will happily race with probe() and remove(),
    most likely leading to BUGs, since drivers don't expect this.
    
    Remove the iov lock completely, since we remove the last user.
    
    [bhelgaas: changelog, thanks to Christoph for locking rule]
    Link: http://lkml.kernel.org/r/20170522225023.14010-1-jakub.kicinski@netronome.com
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 31e99613a12e..7755559558df 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -472,7 +472,6 @@ static ssize_t sriov_numvfs_store(struct device *dev,
 				  const char *buf, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
-	struct pci_sriov *iov = pdev->sriov;
 	int ret;
 	u16 num_vfs;
 
@@ -483,7 +482,7 @@ static ssize_t sriov_numvfs_store(struct device *dev,
 	if (num_vfs > pci_sriov_get_totalvfs(pdev))
 		return -ERANGE;
 
-	mutex_lock(&iov->dev->sriov->lock);
+	device_lock(&pdev->dev);
 
 	if (num_vfs == pdev->sriov->num_VFs)
 		goto exit;
@@ -518,7 +517,7 @@ static ssize_t sriov_numvfs_store(struct device *dev,
 			 num_vfs, ret);
 
 exit:
-	mutex_unlock(&iov->dev->sriov->lock);
+	device_unlock(&pdev->dev);
 
 	if (ret < 0)
 		return ret;

commit ef1b5dad5a386885998d11eb45ca7fd183079965
Merge: 889e4dd916a1 63af8f7a8293
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 28 10:36:12 2017 -0500

    Merge branch 'pci/virtualization' into next
    
    * pci/virtualization:
      ixgbe: Use pcie_flr() instead of duplicating it
      IB/hfi1: Use pcie_flr() instead of duplicating it
      PCI: Call pcie_flr() from reset_chelsio_generic_dev()
      PCI: Call pcie_flr() from reset_intel_82599_sfp_virtfn()
      PCI: Export pcie_flr()
      PCI: Add sysfs sriov_drivers_autoprobe to control VF driver binding
      PCI: Avoid FLR for Intel 82579 NICs
    
    Conflicts:
            include/linux/pci.h

commit 0e7df22401a3dfd403b26dea62dd00e0598b538b
Author: Bodong Wang <bodong@mellanox.com>
Date:   Thu Apr 13 01:51:40 2017 +0300

    PCI: Add sysfs sriov_drivers_autoprobe to control VF driver binding
    
    Sometimes it is not desirable to bind SR-IOV VFs to drivers.  This can save
    host side resource usage by VF instances that will be assigned to VMs.
    
    Add a new PCI sysfs interface "sriov_drivers_autoprobe" to control that
    from the PF.  To modify it, echo 0/n/N (disable probe) or 1/y/Y (enable
    probe) to:
    
      /sys/bus/pci/devices/<DOMAIN:BUS:DEVICE.FUNCTION>/sriov_drivers_autoprobe
    
    Note that this must be done before enabling VFs.  The change will not take
    effect if VFs are already enabled.  Simply, one can disable VFs by setting
    sriov_numvfs to 0, choose whether to probe or not, and then re-enable the
    VFs by restoring sriov_numvfs.
    
    [bhelgaas: changelog, ABI doc]
    Signed-off-by: Bodong Wang <bodong@mellanox.com>
    Signed-off-by: Eli Cohen <eli@mellanox.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 25d010d449a3..369c999683ca 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -526,10 +526,37 @@ static ssize_t sriov_numvfs_store(struct device *dev,
 	return count;
 }
 
+static ssize_t sriov_drivers_autoprobe_show(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	return sprintf(buf, "%u\n", pdev->sriov->drivers_autoprobe);
+}
+
+static ssize_t sriov_drivers_autoprobe_store(struct device *dev,
+					     struct device_attribute *attr,
+					     const char *buf, size_t count)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	bool drivers_autoprobe;
+
+	if (kstrtobool(buf, &drivers_autoprobe) < 0)
+		return -EINVAL;
+
+	pdev->sriov->drivers_autoprobe = drivers_autoprobe;
+
+	return count;
+}
+
 static struct device_attribute sriov_totalvfs_attr = __ATTR_RO(sriov_totalvfs);
 static struct device_attribute sriov_numvfs_attr =
 		__ATTR(sriov_numvfs, (S_IRUGO|S_IWUSR|S_IWGRP),
 		       sriov_numvfs_show, sriov_numvfs_store);
+static struct device_attribute sriov_drivers_autoprobe_attr =
+		__ATTR(sriov_drivers_autoprobe, (S_IRUGO|S_IWUSR|S_IWGRP),
+		       sriov_drivers_autoprobe_show, sriov_drivers_autoprobe_store);
 #endif /* CONFIG_PCI_IOV */
 
 static ssize_t driver_override_store(struct device *dev,
@@ -1549,6 +1576,7 @@ static struct attribute_group pci_dev_hp_attr_group = {
 static struct attribute *sriov_dev_attrs[] = {
 	&sriov_totalvfs_attr.attr,
 	&sriov_numvfs_attr.attr,
+	&sriov_drivers_autoprobe_attr.attr,
 	NULL,
 };
 

commit f719582435afe9c7985206e42d804ea6aa315d33
Author: David Woodhouse <dwmw@amazon.co.uk>
Date:   Wed Apr 12 13:25:59 2017 +0100

    PCI: Add pci_mmap_resource_range() and use it for ARM64
    
    Starting to leave behind the legacy of the pci_mmap_page_range() interface
    which takes "user-visible" BAR addresses.  This takes just the resource and
    offset.
    
    For now, both APIs coexist and depending on the platform, one is
    implemented as a wrapper around the other.
    
    Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index bfd9efe637c4..10feb98a2b1d 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -980,7 +980,7 @@ void pci_remove_legacy_files(struct pci_bus *b)
 }
 #endif /* HAVE_PCI_LEGACY */
 
-#ifdef HAVE_PCI_MMAP
+#if defined(HAVE_PCI_MMAP) || defined(ARCH_GENERIC_PCI_MMAP_RESOURCE)
 
 int pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vma,
 		  enum pci_mmap_api mmap_api)
@@ -1019,7 +1019,6 @@ static int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 	struct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));
 	int bar = (unsigned long)attr->private;
 	enum pci_mmap_state mmap_type;
-	resource_size_t start, end;
 	struct resource *res = &pdev->resource[bar];
 
 	if (res->flags & IORESOURCE_MEM && iomem_is_exclusive(res->start))
@@ -1033,15 +1032,9 @@ static int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 			(u64)pci_resource_len(pdev, bar));
 		return -EINVAL;
 	}
-
-	/* pci_mmap_page_range() expects the same kind of entry as coming
-	 * from /proc/bus/pci/ which is a "user visible" value. If this is
-	 * different from the resource itself, arch will do necessary fixup.
-	 */
-	pci_resource_to_user(pdev, bar, res, &start, &end);
-	vma->vm_pgoff += start >> PAGE_SHIFT;
 	mmap_type = res->flags & IORESOURCE_MEM ? pci_mmap_mem : pci_mmap_io;
-	return pci_mmap_page_range(pdev, bar, vma, mmap_type, write_combine);
+
+	return pci_mmap_resource_range(pdev, bar, vma, mmap_type, write_combine);
 }
 
 static int pci_mmap_resource_uc(struct file *filp, struct kobject *kobj,

commit f66e225828c1b046c7db1db65b0dd2d135f6a2da
Author: David Woodhouse <dwmw@amazon.co.uk>
Date:   Wed Apr 12 13:25:58 2017 +0100

    PCI: Add BAR index argument to pci_mmap_page_range()
    
    In all cases we know which BAR it is.  Passing it in means that arch code
    (or generic code; watch this space) won't have to go looking for it again.
    
    Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 534844df8bf5..bfd9efe637c4 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1041,7 +1041,7 @@ static int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 	pci_resource_to_user(pdev, bar, res, &start, &end);
 	vma->vm_pgoff += start >> PAGE_SHIFT;
 	mmap_type = res->flags & IORESOURCE_MEM ? pci_mmap_mem : pci_mmap_io;
-	return pci_mmap_page_range(pdev, vma, mmap_type, write_combine);
+	return pci_mmap_page_range(pdev, bar, vma, mmap_type, write_combine);
 }
 
 static int pci_mmap_resource_uc(struct file *filp, struct kobject *kobj,

commit dca40b186b757c7f9a05f870f69e0dfaeca59d7b
Author: David Woodhouse <dwmw@amazon.co.uk>
Date:   Wed Apr 12 13:25:57 2017 +0100

    PCI: Use BAR index in sysfs attr->private instead of resource pointer
    
    We store the pointer, and then on *every* use of it we loop over the
    device's resources to find out the index.  That's kind of silly.
    
    Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index cb04bc29943f..534844df8bf5 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1017,26 +1017,20 @@ static int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 			     struct vm_area_struct *vma, int write_combine)
 {
 	struct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));
-	struct resource *res = attr->private;
+	int bar = (unsigned long)attr->private;
 	enum pci_mmap_state mmap_type;
 	resource_size_t start, end;
-	int i;
-
-	for (i = 0; i < PCI_ROM_RESOURCE; i++)
-		if (res == &pdev->resource[i])
-			break;
-	if (i >= PCI_ROM_RESOURCE)
-		return -ENODEV;
+	struct resource *res = &pdev->resource[bar];
 
 	if (res->flags & IORESOURCE_MEM && iomem_is_exclusive(res->start))
 		return -EINVAL;
 
-	if (!pci_mmap_fits(pdev, i, vma, PCI_MMAP_SYSFS)) {
+	if (!pci_mmap_fits(pdev, bar, vma, PCI_MMAP_SYSFS)) {
 		WARN(1, "process \"%s\" tried to map 0x%08lx bytes at page 0x%08lx on %s BAR %d (start 0x%16Lx, size 0x%16Lx)\n",
 			current->comm, vma->vm_end-vma->vm_start, vma->vm_pgoff,
-			pci_name(pdev), i,
-			(u64)pci_resource_start(pdev, i),
-			(u64)pci_resource_len(pdev, i));
+			pci_name(pdev), bar,
+			(u64)pci_resource_start(pdev, bar),
+			(u64)pci_resource_len(pdev, bar));
 		return -EINVAL;
 	}
 
@@ -1044,7 +1038,7 @@ static int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 	 * from /proc/bus/pci/ which is a "user visible" value. If this is
 	 * different from the resource itself, arch will do necessary fixup.
 	 */
-	pci_resource_to_user(pdev, i, res, &start, &end);
+	pci_resource_to_user(pdev, bar, res, &start, &end);
 	vma->vm_pgoff += start >> PAGE_SHIFT;
 	mmap_type = res->flags & IORESOURCE_MEM ? pci_mmap_mem : pci_mmap_io;
 	return pci_mmap_page_range(pdev, vma, mmap_type, write_combine);
@@ -1069,22 +1063,18 @@ static ssize_t pci_resource_io(struct file *filp, struct kobject *kobj,
 			       loff_t off, size_t count, bool write)
 {
 	struct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));
-	struct resource *res = attr->private;
+	int bar = (unsigned long)attr->private;
+	struct resource *res;
 	unsigned long port = off;
-	int i;
 
-	for (i = 0; i < PCI_ROM_RESOURCE; i++)
-		if (res == &pdev->resource[i])
-			break;
-	if (i >= PCI_ROM_RESOURCE)
-		return -ENODEV;
+	res = &pdev->resource[bar];
 
-	port += pci_resource_start(pdev, i);
+	port += pci_resource_start(pdev, bar);
 
-	if (port > pci_resource_end(pdev, i))
+	if (port > pci_resource_end(pdev, bar))
 		return 0;
 
-	if (port + count - 1 > pci_resource_end(pdev, i))
+	if (port + count - 1 > pci_resource_end(pdev, bar))
 		return -EINVAL;
 
 	switch (count) {
@@ -1186,7 +1176,7 @@ static int pci_create_attr(struct pci_dev *pdev, int num, int write_combine)
 	res_attr->attr.name = res_attr_name;
 	res_attr->attr.mode = S_IRUSR | S_IWUSR;
 	res_attr->size = pci_resource_len(pdev, num);
-	res_attr->private = &pdev->resource[num];
+	res_attr->private = (void *)(unsigned long)num;
 	retval = sysfs_create_bin_file(&pdev->dev.kobj, res_attr);
 	if (retval)
 		kfree(res_attr);

commit e854d8b2a82ef76521ad2bed68211fde0511d417
Author: David Woodhouse <dwmw@amazon.co.uk>
Date:   Wed Apr 12 13:25:56 2017 +0100

    PCI: Add arch_can_pci_mmap_io() on architectures which can mmap() I/O space
    
    This is relatively esoteric, and knowing that we don't have it makes life
    easier in some cases rather than just an eventual -EINVAL from
    pci_mmap_page_range().
    
    Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 7d494bd66a97..cb04bc29943f 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1174,11 +1174,14 @@ static int pci_create_attr(struct pci_dev *pdev, int num, int write_combine)
 	} else {
 		pdev->res_attr[num] = res_attr;
 		sprintf(res_attr_name, "resource%d", num);
-		res_attr->mmap = pci_mmap_resource_uc;
-	}
-	if (pci_resource_flags(pdev, num) & IORESOURCE_IO) {
-		res_attr->read = pci_read_resource_io;
-		res_attr->write = pci_write_resource_io;
+		if (pci_resource_flags(pdev, num) & IORESOURCE_IO) {
+			res_attr->read = pci_read_resource_io;
+			res_attr->write = pci_write_resource_io;
+			if (arch_can_pci_mmap_io())
+				res_attr->mmap = pci_mmap_resource_uc;
+		} else {
+			res_attr->mmap = pci_mmap_resource_uc;
+		}
 	}
 	res_attr->attr.name = res_attr_name;
 	res_attr->attr.mode = S_IRUSR | S_IWUSR;

commit ae749c7ab475de2c9c427058db19921c91846e89
Author: David Woodhouse <dwmw@amazon.co.uk>
Date:   Wed Apr 12 13:25:54 2017 +0100

    PCI: Add arch_can_pci_mmap_wc() macro
    
    Most of the almost-identical versions of pci_mmap_page_range() silently
    ignore the 'write_combine' argument and give uncached mappings.
    
    Yet we allow the PCIIOC_WRITE_COMBINE ioctl in /proc/bus/pci, expose the
    'resourceX_wc' file in sysfs, and allow an attempted mapping to apparently
    succeed.
    
    To fix this, introduce a macro arch_can_pci_mmap_wc() which indicates
    whether the platform can do a write-combining mapping.  On x86 this ends up
    being pat_enabled(), while the few other platforms that support it can just
    set it to a literal '1'.
    
    Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 7ac258fd3c5c..7d494bd66a97 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1211,9 +1211,9 @@ static int pci_create_resource_files(struct pci_dev *pdev)
 
 		retval = pci_create_attr(pdev, i, 0);
 		/* for prefetchable resources, create a WC mappable file */
-		if (!retval && pdev->resource[i].flags & IORESOURCE_PREFETCH)
+		if (!retval && arch_can_pci_mmap_wc() &&
+		    pdev->resource[i].flags & IORESOURCE_PREFETCH)
 			retval = pci_create_attr(pdev, i, 1);
-
 		if (retval) {
 			pci_remove_resource_files(pdev);
 			return retval;

commit 6bccc7f426abd640f08d8c75fb22f99483f201b4
Author: David Woodhouse <dwmw@amazon.co.uk>
Date:   Wed Apr 12 13:25:50 2017 +0100

    PCI: Fix pci_mmap_fits() for HAVE_PCI_RESOURCE_TO_USER platforms
    
    In the PCI_MMAP_PROCFS case when the address being passed by the user is a
    'user visible' resource address based on the bus window, and not the actual
    contents of the resource, that's what we need to be checking it against.
    
    Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 25d010d449a3..7ac258fd3c5c 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -985,15 +985,19 @@ void pci_remove_legacy_files(struct pci_bus *b)
 int pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vma,
 		  enum pci_mmap_api mmap_api)
 {
-	unsigned long nr, start, size, pci_start;
+	unsigned long nr, start, size;
+	resource_size_t pci_start = 0, pci_end;
 
 	if (pci_resource_len(pdev, resno) == 0)
 		return 0;
 	nr = vma_pages(vma);
 	start = vma->vm_pgoff;
 	size = ((pci_resource_len(pdev, resno) - 1) >> PAGE_SHIFT) + 1;
-	pci_start = (mmap_api == PCI_MMAP_PROCFS) ?
-			pci_resource_start(pdev, resno) >> PAGE_SHIFT : 0;
+	if (mmap_api == PCI_MMAP_PROCFS) {
+		pci_resource_to_user(pdev, resno, &pdev->resource[resno],
+				     &pci_start, &pci_end);
+		pci_start >>= PAGE_SHIFT;
+	}
 	if (start >= pci_start && start < pci_start + size &&
 			start + nr <= pci_start + size)
 		return 1;

commit 5b0948dfe138f0837699f46f5877f4f81c252dac
Author: Emil Tantilov <emil.s.tantilov@intel.com>
Date:   Fri Jan 6 13:59:08 2017 -0800

    PCI: Lock each enable/disable num_vfs operation in sysfs
    
    Enabling/disabling SRIOV via sysfs by echo-ing multiple values
    simultaneously:
    
      # echo 63 > /sys/class/net/ethX/device/sriov_numvfs&
      # echo 63 > /sys/class/net/ethX/device/sriov_numvfs
    
      # sleep 5
    
      # echo 0 > /sys/class/net/ethX/device/sriov_numvfs&
      # echo 0 > /sys/class/net/ethX/device/sriov_numvfs
    
    results in the following bug:
    
      kernel BUG at drivers/pci/iov.c:495!
      invalid opcode: 0000 [#1] SMP
      CPU: 1 PID: 8050 Comm: bash Tainted: G   W   4.9.0-rc7-net-next #2092
      RIP: 0010:[<ffffffff813b1647>]
                [<ffffffff813b1647>] pci_iov_release+0x57/0x60
    
      Call Trace:
       [<ffffffff81391726>] pci_release_dev+0x26/0x70
       [<ffffffff8155be6e>] device_release+0x3e/0xb0
       [<ffffffff81365ee7>] kobject_cleanup+0x67/0x180
       [<ffffffff81365d9d>] kobject_put+0x2d/0x60
       [<ffffffff8155bc27>] put_device+0x17/0x20
       [<ffffffff8139c08a>] pci_dev_put+0x1a/0x20
       [<ffffffff8139cb6b>] pci_get_dev_by_id+0x5b/0x90
       [<ffffffff8139cca5>] pci_get_subsys+0x35/0x40
       [<ffffffff8139ccc8>] pci_get_device+0x18/0x20
       [<ffffffff8139ccfb>] pci_get_domain_bus_and_slot+0x2b/0x60
       [<ffffffff813b09e7>] pci_iov_remove_virtfn+0x57/0x180
       [<ffffffff813b0b95>] pci_disable_sriov+0x65/0x140
       [<ffffffffa00a1af7>] ixgbe_disable_sriov+0xc7/0x1d0 [ixgbe]
       [<ffffffffa00a1e9d>] ixgbe_pci_sriov_configure+0x3d/0x170 [ixgbe]
       [<ffffffff8139d28c>] sriov_numvfs_store+0xdc/0x130
      ...
      RIP  [<ffffffff813b1647>] pci_iov_release+0x57/0x60
    
    Use the existing mutex lock to protect each enable/disable operation.
    
    Signed-off-by: Emil Tantilov <emil.s.tantilov@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    CC: Alexander Duyck <alexander.h.duyck@intel.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 066628776e1b..25d010d449a3 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -472,6 +472,7 @@ static ssize_t sriov_numvfs_store(struct device *dev,
 				  const char *buf, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
+	struct pci_sriov *iov = pdev->sriov;
 	int ret;
 	u16 num_vfs;
 
@@ -482,38 +483,46 @@ static ssize_t sriov_numvfs_store(struct device *dev,
 	if (num_vfs > pci_sriov_get_totalvfs(pdev))
 		return -ERANGE;
 
+	mutex_lock(&iov->dev->sriov->lock);
+
 	if (num_vfs == pdev->sriov->num_VFs)
-		return count;		/* no change */
+		goto exit;
 
 	/* is PF driver loaded w/callback */
 	if (!pdev->driver || !pdev->driver->sriov_configure) {
 		dev_info(&pdev->dev, "Driver doesn't support SRIOV configuration via sysfs\n");
-		return -ENOSYS;
+		ret = -ENOENT;
+		goto exit;
 	}
 
 	if (num_vfs == 0) {
 		/* disable VFs */
 		ret = pdev->driver->sriov_configure(pdev, 0);
-		if (ret < 0)
-			return ret;
-		return count;
+		goto exit;
 	}
 
 	/* enable VFs */
 	if (pdev->sriov->num_VFs) {
 		dev_warn(&pdev->dev, "%d VFs already enabled. Disable before enabling %d VFs\n",
 			 pdev->sriov->num_VFs, num_vfs);
-		return -EBUSY;
+		ret = -EBUSY;
+		goto exit;
 	}
 
 	ret = pdev->driver->sriov_configure(pdev, num_vfs);
 	if (ret < 0)
-		return ret;
+		goto exit;
 
 	if (ret != num_vfs)
 		dev_warn(&pdev->dev, "%d VFs requested; only %d enabled\n",
 			 num_vfs, ret);
 
+exit:
+	mutex_unlock(&iov->dev->sriov->lock);
+
+	if (ret < 0)
+		return ret;
+
 	return count;
 }
 

commit 702ed3be1b1bf4dea05954168321741c0910c645
Author: Emil Velikov <emil.velikov@collabora.com>
Date:   Mon Nov 21 16:24:49 2016 -0600

    PCI: Create revision file in sysfs
    
    Currently the revision isn't available via sysfs/libudev thus if one wants
    to know the value one needs to read through the config file, which can be
    quite time-consuming because it wakes/powers up the device.
    
    There are at least two userspace components which could make use the new
    file: libpciaccess and libdrm.  The former wakes up _every_ PCI device,
    which can be observed via glxinfo when using Mesa 10.0+ drivers.  The
    latter, in association with Mesa 13.0, can lead to 2-3 second delays while
    starting firefox, thunderbird or chromium.
    
    Link: https://bugs.freedesktop.org/show_bug.cgi?id=98502
    Tested-by: Mauro Santos <registo.mailling@gmail.com>
    Signed-off-by: Emil Velikov <emil.velikov@collabora.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch
    CC: Greg KH <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index bcd10c795284..066628776e1b 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -50,6 +50,7 @@ pci_config_attr(vendor, "0x%04x\n");
 pci_config_attr(device, "0x%04x\n");
 pci_config_attr(subsystem_vendor, "0x%04x\n");
 pci_config_attr(subsystem_device, "0x%04x\n");
+pci_config_attr(revision, "0x%02x\n");
 pci_config_attr(class, "0x%06x\n");
 pci_config_attr(irq, "%u\n");
 
@@ -568,6 +569,7 @@ static struct attribute *pci_dev_attrs[] = {
 	&dev_attr_device.attr,
 	&dev_attr_subsystem_vendor.attr,
 	&dev_attr_subsystem_device.attr,
+	&dev_attr_revision.attr,
 	&dev_attr_class.attr,
 	&dev_attr_irq.attr,
 	&dev_attr_local_cpus.attr,

commit 9d26d3a8f1b0c442339a235f9508bdad8af91043
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Jun 2 11:17:12 2016 +0300

    PCI: Put PCIe ports into D3 during suspend
    
    Currently the Linux PCI core does not touch power state of PCI bridges and
    PCIe ports when system suspend is entered.  Leaving them in D0 consumes
    power unnecessarily and may prevent the CPU from entering deeper C-states.
    
    With recent PCIe hardware we can power down the ports to save power given
    that we take into account few restrictions:
    
      - The PCIe port hardware is recent enough, starting from 2015.
    
      - Devices connected to PCIe ports are effectively in D3cold once the port
        is transitioned to D3 (the config space is not accessible anymore and
        the link may be powered down).
    
      - Devices behind the PCIe port need to be allowed to transition to D3cold
        and back.  There is a way both drivers and userspace can forbid this.
    
      - If the device behind the PCIe port is capable of waking the system it
        needs to be able to do so from D3cold.
    
    This patch adds a new flag to struct pci_device called 'bridge_d3'.  This
    flag is set and cleared by the PCI core whenever there is a change in power
    management state of any of the devices behind the PCIe port.  When system
    later on is suspended we only need to check this flag and if it is true
    transition the port to D3 otherwise we leave it in D0.
    
    Also provide override mechanism via command line parameter
    "pcie_port_pm=[off|force]" that can be used to disable or enable the
    feature regardless of the BIOS manufacturing date.
    
    Tested-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index d319a9ca9b7b..bcd10c795284 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -406,6 +406,11 @@ static ssize_t d3cold_allowed_store(struct device *dev,
 		return -EINVAL;
 
 	pdev->d3cold_allowed = !!val;
+	if (pdev->d3cold_allowed)
+		pci_d3cold_enable(pdev);
+	else
+		pci_d3cold_disable(pdev);
+
 	pm_runtime_resume(dev);
 
 	return count;

commit 7afd16f882887c9adc69cd1794f5e57777723217
Merge: a37571a29eca e257ef55ce51
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 19 13:10:54 2016 -0700

    Merge tag 'pci-v4.7-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Enumeration:
       - Refine PCI support check in pcibios_init() (Adrian-Ken Rueegsegger)
       - Provide common functions for ECAM mapping (Jayachandran C)
       - Allow all PCIe services on non-ACPI host bridges (Jon Derrick)
       - Remove return values from pcie_port_platform_notify() and relatives (Jon Derrick)
       - Widen portdrv service type from 4 bits to 8 bits (Keith Busch)
       - Add Downstream Port Containment portdrv service type (Keith Busch)
       - Add Downstream Port Containment driver (Keith Busch)
    
      Resource management:
       - Identify Enhanced Allocation (EA) BAR Equivalent resources in sysfs (Alex Williamson)
       - Supply CPU physical address (not bus address) to iomem_is_exclusive() (Bjorn Helgaas)
       - alpha: Call iomem_is_exclusive() for IORESOURCE_MEM, but not IORESOURCE_IO (Bjorn Helgaas)
       - Mark Broadwell-EP Home Agent 1 as having non-compliant BARs (Prarit Bhargava)
       - Disable all BAR sizing for devices with non-compliant BARs (Prarit Bhargava)
       - Move PCI I/O space management from OF to PCI core code (Tomasz Nowicki)
    
      PCI device hotplug:
       - acpiphp_ibm: Avoid uninitialized variable reference (Dan Carpenter)
       - Use cached copy of PCI_EXP_SLTCAP_HPC bit (Lukas Wunner)
    
      Virtualization:
       - Mark Intel i40e NIC INTx masking as broken (Alex Williamson)
       - Reverse standard ACS vs device-specific ACS enabling (Alex Williamson)
       - Work around Intel Sunrise Point PCH incorrect ACS capability (Alex Williamson)
    
      IOMMU:
       - Add pci_add_dma_alias() to abstract implementation (Bjorn Helgaas)
       - Move informational printk to pci_add_dma_alias() (Bjorn Helgaas)
       - Add support for multiple DMA aliases (Jacek Lawrynowicz)
       - Add DMA alias quirk for mic_x200_dma (Jacek Lawrynowicz)
    
      Thunderbolt:
       - Fix double free of drom buffer (Andreas Noever)
       - Add Intel Thunderbolt device IDs (Lukas Wunner)
       - Fix typos and magic number (Lukas Wunner)
       - Support 1st gen Light Ridge controller (Lukas Wunner)
    
      Generic host bridge driver:
       - Use generic ECAM API (Jayachandran C)
    
      Cavium ThunderX host bridge driver:
       - Don't clobber read-only bits in bridge config registers (David Daney)
       - Use generic ECAM API (Jayachandran C)
    
      Freescale i.MX6 host bridge driver:
       - Use enum instead of bool for variant indicator (Andrey Smirnov)
       - Implement reset sequence for i.MX6+ (Andrey Smirnov)
       - Factor out ref clock enable (Bjorn Helgaas)
       - Add initial imx6sx support (Christoph Fritz)
       - Add reset-gpio-active-high boolean property to DT (Petr Štetiar)
       - Add DT property for link gen, default to Gen1 (Tim Harvey)
       - dts: Specify imx6qp version of PCIe core (Andrey Smirnov)
       - dts: Fix PCIe reset GPIO polarity on Toradex Apalis Ixora (Petr Štetiar)
    
      Marvell Armada host bridge driver:
       - add DT binding for Marvell Armada 7K/8K PCIe controller (Thomas Petazzoni)
       - Add driver for Marvell Armada 7K/8K PCIe controller (Thomas Petazzoni)
    
      Marvell MVEBU host bridge driver:
       - Constify mvebu_pcie_pm_ops structure (Jisheng Zhang)
       - Use SET_NOIRQ_SYSTEM_SLEEP_PM_OPS for mvebu_pcie_pm_ops (Jisheng Zhang)
    
      Microsoft Hyper-V host bridge driver:
       - Report resources release after stopping the bus (Vitaly Kuznetsov)
       - Add explicit barriers to config space access (Vitaly Kuznetsov)
    
      Renesas R-Car host bridge driver:
       - Select PCI_MSI_IRQ_DOMAIN (Arnd Bergmann)
    
      Synopsys DesignWare host bridge driver:
       - Remove incorrect RC memory base/limit configuration (Gabriele Paoloni)
       - Move Root Complex setup code to dw_pcie_setup_rc() (Jisheng Zhang)
    
      TI Keystone host bridge driver:
       - Add error IRQ handler (Murali Karicheri)
       - Remove unnecessary goto statement (Murali Karicheri)
    
      Miscellaneous:
       - Fix spelling errors (Colin Ian King)"
    
    * tag 'pci-v4.7-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (48 commits)
      PCI: Disable all BAR sizing for devices with non-compliant BARs
      x86/PCI: Mark Broadwell-EP Home Agent 1 as having non-compliant BARs
      PCI: Identify Enhanced Allocation (EA) BAR Equivalent resources in sysfs
      PCI, of: Move PCI I/O space management to PCI core code
      PCI: generic, thunder: Use generic ECAM API
      PCI: Provide common functions for ECAM mapping
      PCI: hv: Add explicit barriers to config space access
      PCI: Use cached copy of PCI_EXP_SLTCAP_HPC bit
      PCI: Add Downstream Port Containment driver
      PCI: Add Downstream Port Containment portdrv service type
      PCI: Widen portdrv service type from 4 bits to 8 bits
      PCI: designware: Remove incorrect RC memory base/limit configuration
      PCI: hv: Report resources release after stopping the bus
      ARM: dts: imx6qp: Specify imx6qp version of PCIe core
      PCI: imx6: Implement reset sequence for i.MX6+
      PCI: imx6: Use enum instead of bool for variant indicator
      PCI: thunder: Don't clobber read-only bits in bridge config registers
      thunderbolt: Fix double free of drom buffer
      PCI: rcar: Select PCI_MSI_IRQ_DOMAIN
      PCI: armada: Add driver for Marvell Armada 7K/8K PCIe controller
      ...

commit ca620723d4ff9ea7ed484eab46264c3af871b9ae
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Apr 7 17:15:14 2016 -0700

    PCI: Supply CPU physical address (not bus address) to iomem_is_exclusive()
    
    iomem_is_exclusive() requires a CPU physical address, but on some arches we
    supplied a PCI bus address instead.
    
    On most arches, pci_resource_to_user(res) returns "res->start", which is a
    CPU physical address.  But on microblaze, mips, powerpc, and sparc, it
    returns the PCI bus address corresponding to "res->start".
    
    The result is that pci_mmap_resource() may fail when it shouldn't (if the
    bus address happens to match an existing resource), or it may succeed when
    it should fail (if the resource is exclusive but the bus address doesn't
    match it).
    
    Call iomem_is_exclusive() with "res->start", which is always a CPU physical
    address, not the result of pci_resource_to_user().
    
    Fixes: e8de1481fd71 ("resource: allow MMIO exclusivity for device drivers")
    Suggested-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Arjan van de Ven <arjan@linux.intel.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index e982010f0ed1..cbb13be1ba28 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1008,6 +1008,9 @@ static int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 	if (i >= PCI_ROM_RESOURCE)
 		return -ENODEV;
 
+	if (res->flags & IORESOURCE_MEM && iomem_is_exclusive(res->start))
+		return -EINVAL;
+
 	if (!pci_mmap_fits(pdev, i, vma, PCI_MMAP_SYSFS)) {
 		WARN(1, "process \"%s\" tried to map 0x%08lx bytes at page 0x%08lx on %s BAR %d (start 0x%16Lx, size 0x%16Lx)\n",
 			current->comm, vma->vm_end-vma->vm_start, vma->vm_pgoff,
@@ -1024,10 +1027,6 @@ static int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 	pci_resource_to_user(pdev, i, res, &start, &end);
 	vma->vm_pgoff += start >> PAGE_SHIFT;
 	mmap_type = res->flags & IORESOURCE_MEM ? pci_mmap_mem : pci_mmap_io;
-
-	if (res->flags & IORESOURCE_MEM && iomem_is_exclusive(start))
-		return -EINVAL;
-
 	return pci_mmap_page_range(pdev, vma, mmap_type, write_combine);
 }
 

commit ab0fa82b2df96ddadb327ac39f26b5d80cb3d104
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 14 12:00:21 2016 -0700

    pci-sysfs: use proper file capability helper function
    
    The PCI config access checked the file capabilities correctly, but used
    the itnernal security capability check rather than the helper function
    that is actually meant for that.
    
    The security_capable() has unusual return values and is not meant to be
    used elsewhere (the only other use is in the capability checking
    functions that we actually intend people to use, and this odd PCI usage
    really stood out when looking around the capability code.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index e982010f0ed1..342b6918bbde 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -636,7 +636,7 @@ static ssize_t pci_read_config(struct file *filp, struct kobject *kobj,
 	u8 *data = (u8 *) buf;
 
 	/* Several chips lock up trying to read undefined config space */
-	if (security_capable(filp->f_cred, &init_user_ns, CAP_SYS_ADMIN) == 0)
+	if (file_ns_capable(filp, &init_user_ns, CAP_SYS_ADMIN))
 		size = dev->cfg_size;
 	else if (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)
 		size = 128;

commit 6e6f498b039aa5558c7377fbbe65f7421d34cea4
Merge: cfeb8139a1fb bd5174dfb6f1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Mar 15 08:56:28 2016 -0500

    Merge branch 'pci/resource' into next
    
    * pci/resource:
      PCI: Simplify pci_create_attr() control flow
      PCI: Don't leak memory if sysfs_create_bin_file() fails
      PCI: Simplify sysfs ROM cleanup
      PCI: Remove unused IORESOURCE_ROM_COPY and IORESOURCE_ROM_BIOS_COPY
      MIPS: Loongson 3: Keep CPU physical (not virtual) addresses in shadow ROM resource
      MIPS: Loongson 3: Use temporary struct resource * to avoid repetition
      ia64/PCI: Keep CPU physical (not virtual) addresses in shadow ROM resource
      ia64/PCI: Use ioremap() instead of open-coded equivalent
      ia64/PCI: Use temporary struct resource * to avoid repetition
      PCI: Clean up pci_map_rom() whitespace
      PCI: Remove arch-specific IORESOURCE_ROM_SHADOW size from sysfs
      PCI: Set ROM shadow location in arch code, not in PCI core
      PCI: Don't enable/disable ROM BAR if we're using a RAM shadow copy
      PCI: Don't assign or reassign immutable resources
      PCI: Mark shadow copy of VGA ROM as IORESOURCE_PCI_FIXED
      x86/PCI: Mark Broadwell-EP Home Agent & PCU as having non-compliant BARs
      PCI: Disable IO/MEM decoding for devices with non-compliant BARs

commit bd5174dfb6f171fa06e638664ec6ee54692cf7b2
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Mar 10 14:36:34 2016 -0600

    PCI: Simplify pci_create_attr() control flow
    
    Return error immediately to simplify the control flow in pci_create_attr().
    No functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 847a97351030..684f27bb68ba 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1134,35 +1134,36 @@ static int pci_create_attr(struct pci_dev *pdev, int num, int write_combine)
 	/* allocate attribute structure, piggyback attribute name */
 	int name_len = write_combine ? 13 : 10;
 	struct bin_attribute *res_attr;
+	char *res_attr_name;
 	int retval;
 
 	res_attr = kzalloc(sizeof(*res_attr) + name_len, GFP_ATOMIC);
-	if (res_attr) {
-		char *res_attr_name = (char *)(res_attr + 1);
-
-		sysfs_bin_attr_init(res_attr);
-		if (write_combine) {
-			pdev->res_attr_wc[num] = res_attr;
-			sprintf(res_attr_name, "resource%d_wc", num);
-			res_attr->mmap = pci_mmap_resource_wc;
-		} else {
-			pdev->res_attr[num] = res_attr;
-			sprintf(res_attr_name, "resource%d", num);
-			res_attr->mmap = pci_mmap_resource_uc;
-		}
-		if (pci_resource_flags(pdev, num) & IORESOURCE_IO) {
-			res_attr->read = pci_read_resource_io;
-			res_attr->write = pci_write_resource_io;
-		}
-		res_attr->attr.name = res_attr_name;
-		res_attr->attr.mode = S_IRUSR | S_IWUSR;
-		res_attr->size = pci_resource_len(pdev, num);
-		res_attr->private = &pdev->resource[num];
-		retval = sysfs_create_bin_file(&pdev->dev.kobj, res_attr);
-		if (retval)
-			kfree(res_attr);
-	} else
-		retval = -ENOMEM;
+	if (!res_attr)
+		return -ENOMEM;
+
+	res_attr_name = (char *)(res_attr + 1);
+
+	sysfs_bin_attr_init(res_attr);
+	if (write_combine) {
+		pdev->res_attr_wc[num] = res_attr;
+		sprintf(res_attr_name, "resource%d_wc", num);
+		res_attr->mmap = pci_mmap_resource_wc;
+	} else {
+		pdev->res_attr[num] = res_attr;
+		sprintf(res_attr_name, "resource%d", num);
+		res_attr->mmap = pci_mmap_resource_uc;
+	}
+	if (pci_resource_flags(pdev, num) & IORESOURCE_IO) {
+		res_attr->read = pci_read_resource_io;
+		res_attr->write = pci_write_resource_io;
+	}
+	res_attr->attr.name = res_attr_name;
+	res_attr->attr.mode = S_IRUSR | S_IWUSR;
+	res_attr->size = pci_resource_len(pdev, num);
+	res_attr->private = &pdev->resource[num];
+	retval = sysfs_create_bin_file(&pdev->dev.kobj, res_attr);
+	if (retval)
+		kfree(res_attr);
 
 	return retval;
 }

commit b562ec8f74e4edb532a53d26f0002d6fb4a6c79b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Mar 10 14:36:28 2016 -0600

    PCI: Don't leak memory if sysfs_create_bin_file() fails
    
    If sysfs_create_bin_file() fails, pci_create_attr() leaks the struct
    bin_attribute it allocated previously.
    
    Free the struct bin_attribute if pci_create_attr() fails.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 4ca8af3d5eda..847a97351030 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1159,6 +1159,8 @@ static int pci_create_attr(struct pci_dev *pdev, int num, int write_combine)
 		res_attr->size = pci_resource_len(pdev, num);
 		res_attr->private = &pdev->resource[num];
 		retval = sysfs_create_bin_file(&pdev->dev.kobj, res_attr);
+		if (retval)
+			kfree(res_attr);
 	} else
 		retval = -ENOMEM;
 

commit 9d88b93bea5937c0c5c5fc30089d4e6e3c9ca508
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Mar 1 09:37:10 2016 -0600

    PCI: Simplify sysfs ROM cleanup
    
    The value of pdev->rom_attr is the definitive indicator of the fact that
    we're created a sysfs attribute.  Check that rather than rom_size, which is
    only used incidentally when deciding whether to create a sysfs attribute.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 51d4dadcf552..4ca8af3d5eda 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1405,7 +1405,7 @@ int __must_check pci_create_sysfs_dev_files(struct pci_dev *pdev)
 	return 0;
 
 err_rom_file:
-	if (rom_size) {
+	if (pdev->rom_attr) {
 		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->rom_attr);
 		kfree(pdev->rom_attr);
 		pdev->rom_attr = NULL;
@@ -1443,8 +1443,6 @@ static void pci_remove_capabilities_sysfs(struct pci_dev *dev)
  */
 void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
 {
-	int rom_size = 0;
-
 	if (!sysfs_initialized)
 		return;
 
@@ -1457,18 +1455,13 @@ void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
 
 	pci_remove_resource_files(pdev);
 
-	if (pci_resource_len(pdev, PCI_ROM_RESOURCE))
-		rom_size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
-	else if (pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW)
-		rom_size = 0x20000;
-
-	if (rom_size && pdev->rom_attr) {
+	if (pdev->rom_attr) {
 		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->rom_attr);
 		kfree(pdev->rom_attr);
+		pdev->rom_attr = NULL;
 	}
 
 	pci_remove_firmware_label_files(pdev);
-
 }
 
 static int __init pci_sysfs_init(void)

commit ac0c302a919ba7b68dbf274babdc08c83df6f532
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Mar 12 05:48:08 2016 -0600

    PCI: Remove arch-specific IORESOURCE_ROM_SHADOW size from sysfs
    
    When pci_create_sysfs_dev_files() created the "rom" sysfs file, it set the
    sysfs file size to the actual size of a ROM BAR, or if there was no ROM BAR
    but the platform provided a shadow copy in RAM, to 0x20000.  0x20000 is an
    arch-specific length that should not be baked into the PCI core.
    
    Every place that sets IORESOURCE_ROM_SHADOW also sets the size of the
    PCI_ROM_RESOURCE, so use the resource length always.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 95d9e7bd933b..51d4dadcf552 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1356,7 +1356,7 @@ static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 int __must_check pci_create_sysfs_dev_files(struct pci_dev *pdev)
 {
 	int retval;
-	int rom_size = 0;
+	int rom_size;
 	struct bin_attribute *attr;
 
 	if (!sysfs_initialized)
@@ -1373,12 +1373,8 @@ int __must_check pci_create_sysfs_dev_files(struct pci_dev *pdev)
 	if (retval)
 		goto err_config_file;
 
-	if (pci_resource_len(pdev, PCI_ROM_RESOURCE))
-		rom_size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
-	else if (pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW)
-		rom_size = 0x20000;
-
 	/* If the device has a ROM, try to expose it in sysfs. */
+	rom_size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
 	if (rom_size) {
 		attr = kzalloc(sizeof(*attr), GFP_ATOMIC);
 		if (!attr) {

commit 104daa71b39614343929e1982170d5fcb0569bb5
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Feb 15 09:42:01 2016 +0100

    PCI: Determine actual VPD size on first access
    
    PCI-2.2 VPD entries have a maximum size of 32k, but might actually be
    smaller than that.  To figure out the actual size one has to read the VPD
    area until the 'end marker' is reached.
    
    Per spec, reading outside of the VPD space is "not allowed."  In practice,
    it may cause simple read errors or even crash the card.  To make matters
    worse not every PCI card implements this properly, leaving us with no 'end'
    marker or even completely invalid data.
    
    Try to determine the size of the VPD data when it's first accessed.  If no
    valid data can be read an I/O error will be returned when reading or
    writing the sysfs attribute.
    
    As the amount of VPD data is unknown initially the size of the sysfs
    attribute will always be set to '0'.
    
    [bhelgaas: changelog, use 0/1 (not false/true) for bitfield, tweak
    pci_vpd_pci22_read() error checking]
    Tested-by: Shane Seymour <shane.seymour@hpe.com>
    Tested-by: Babu Moger <babu.moger@oracle.com>
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Alexander Duyck <alexander.duyck@gmail.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index a730f54d1247..ed39c093aa15 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1323,7 +1323,7 @@ static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 			return -ENOMEM;
 
 		sysfs_bin_attr_init(attr);
-		attr->size = dev->vpd->len;
+		attr->size = 0;
 		attr->attr.name = "vpd";
 		attr->attr.mode = S_IRUSR | S_IWUSR;
 		attr->read = read_vpd_attr;

commit f52e5629f66d5fd79ae8b8145d76ae0ddb47e142
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Feb 15 09:42:00 2016 +0100

    PCI: Allow access to VPD attributes with size 0
    
    It is not always possible to determine the actual size of the VPD
    data, so allow access to them if the size is set to '0'.
    
    Tested-by: Shane Seymour <shane.seymour@hpe.com>
    Tested-by: Babu Moger <babu.moger@oracle.com>
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Alexander Duyck <alexander.duyck@gmail.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 95d9e7bd933b..a730f54d1247 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -769,10 +769,12 @@ static ssize_t read_vpd_attr(struct file *filp, struct kobject *kobj,
 {
 	struct pci_dev *dev = to_pci_dev(kobj_to_dev(kobj));
 
-	if (off > bin_attr->size)
-		count = 0;
-	else if (count > bin_attr->size - off)
-		count = bin_attr->size - off;
+	if (bin_attr->size > 0) {
+		if (off > bin_attr->size)
+			count = 0;
+		else if (count > bin_attr->size - off)
+			count = bin_attr->size - off;
+	}
 
 	return pci_read_vpd(dev, off, count, buf);
 }
@@ -783,10 +785,12 @@ static ssize_t write_vpd_attr(struct file *filp, struct kobject *kobj,
 {
 	struct pci_dev *dev = to_pci_dev(kobj_to_dev(kobj));
 
-	if (off > bin_attr->size)
-		count = 0;
-	else if (count > bin_attr->size - off)
-		count = bin_attr->size - off;
+	if (bin_attr->size > 0) {
+		if (off > bin_attr->size)
+			count = 0;
+		else if (count > bin_attr->size - off)
+			count = bin_attr->size - off;
+	}
 
 	return pci_write_vpd(dev, off, count, buf);
 }

commit d43421565bf0510d35e6a39ebf96586ad486f3aa
Merge: 859e76254490 9662e32c810a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 21 11:52:16 2016 -0800

    Merge tag 'pci-v4.5-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "PCI changes for the v4.5 merge window:
    
      Enumeration:
       - Simplify config space size computation (Bjorn Helgaas)
       - Avoid iterating through ROM outside the resource window (Edward O'Callaghan)
       - Support PCIe devices with short cfg_size (Jason S. McMullan)
       - Add Netronome vendor and device IDs (Jason S. McMullan)
       - Limit config space size for Netronome NFP6000 family (Jason S. McMullan)
       - Add Netronome NFP4000 PF device ID (Simon Horman)
       - Limit config space size for Netronome NFP4000 (Simon Horman)
       - Print warnings for all invalid expansion ROM headers (Vladis Dronov)
    
      Resource management:
       - Fix minimum allocation address overwrite (Christoph Biedl)
    
      PCI device hotplug:
       - acpiphp_ibm: Fix null dereferences on null ibm_slot (Colin Ian King)
       - pciehp: Always protect pciehp_disable_slot() with hotplug mutex (Guenter Roeck)
       - shpchp: Constify hpc_ops structure (Julia Lawall)
       - ibmphp: Remove unneeded NULL test (Julia Lawall)
    
      Power management:
       - Make ASPM sysfs link_state_store() consistent with link_state_show() (Andy Lutomirski)
    
      Virtualization
       - Add function 1 DMA alias quirk for Lite-On/Plextor M6e/Marvell 88SS9183 (Tim Sander)
    
      MSI:
       - Remove empty pci_msi_init_pci_dev() (Bjorn Helgaas)
       - Mark PCIe/PCI (MSI) IRQ cascade handlers as IRQF_NO_THREAD (Grygorii Strashko)
       - Initialize MSI capability for all architectures (Guilherme G. Piccoli)
       - Relax msi_domain_alloc() to support parentless MSI irqdomains (Liu Jiang)
    
      ARM Versatile host bridge driver:
       - Remove unused pci_sys_data structures (Lorenzo Pieralisi)
    
      Broadcom iProc host bridge driver:
       - Hide CONFIG_PCIE_IPROC (Arnd Bergmann)
       - Do not use 0x in front of %pap (Dmitry V. Krivenok)
       - Update iProc PCIe device tree binding (Ray Jui)
       - Add PAXC interface support (Ray Jui)
       - Add iProc PCIe MSI device tree binding (Ray Jui)
       - Add iProc PCIe MSI support (Ray Jui)
    
      Freescale i.MX6 host bridge driver:
       - Use gpio_set_value_cansleep() (Fabio Estevam)
       - Add support for active-low reset GPIO (Petr Štetiar)
    
      HiSilicon host bridge driver:
       - Add support for HiSilicon Hip06 PCIe host controllers (Gabriele Paoloni)
    
      Intel VMD host bridge driver:
       - Export irq_domain_set_info() for module use (Keith Busch)
       - x86/PCI: Allow DMA ops specific to a PCI domain (Keith Busch)
       - Use 32 bit PCI domain numbers (Keith Busch)
       - Add driver for Intel Volume Management Device (VMD) (Keith Busch)
    
      Qualcomm host bridge driver:
       - Document PCIe devicetree bindings (Stanimir Varbanov)
       - Add Qualcomm PCIe controller driver (Stanimir Varbanov)
       - dts: apq8064: add PCIe devicetree node (Stanimir Varbanov)
       - dts: ifc6410: enable PCIe DT node for this board (Stanimir Varbanov)
    
      Renesas R-Car host bridge driver:
       - Add support for R-Car H3 to pcie-rcar (Harunobu Kurokawa)
       - Allow DT to override default window settings (Phil Edworthy)
       - Convert to DT resource parsing API (Phil Edworthy)
       - Revert "PCI: rcar: Build pcie-rcar.c only on ARM" (Phil Edworthy)
       - Remove unused pci_sys_data struct from pcie-rcar (Phil Edworthy)
       - Add runtime PM support to pcie-rcar (Phil Edworthy)
       - Add Gen2 PHY setup to pcie-rcar (Phil Edworthy)
       - Add gen2 fallback compatibility string for pci-rcar-gen2 (Simon Horman)
       - Add gen2 fallback compatibility string for pcie-rcar (Simon Horman)
    
      Synopsys DesignWare host bridge driver:
       - Simplify control flow (Bjorn Helgaas)
       - Make config accessor override checking symmetric (Bjorn Helgaas)
       - Ensure ATU is enabled before IO/conf space accesses (Stanimir Varbanov)
    
      Miscellaneous:
       - Add of_pci_get_host_bridge_resources() stub (Arnd Bergmann)
       - Check for PCI_HEADER_TYPE_BRIDGE equality, not bitmask (Bjorn Helgaas)
       - Fix all whitespace issues (Bogicevic Sasa)
       - x86/PCI: Simplify pci_bios_{read,write} (Geliang Tang)
       - Use to_pci_dev() instead of open-coding it (Geliang Tang)
       - Use kobj_to_dev() instead of open-coding it (Geliang Tang)
       - Use list_for_each_entry() to simplify code (Geliang Tang)
       - Fix typos in <linux/msi.h> (Thomas Petazzoni)
       - x86/PCI: Clarify AMD Fam10h config access restrictions comment (Tomasz Nowicki)"
    
    * tag 'pci-v4.5-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (58 commits)
      PCI: Add function 1 DMA alias quirk for Lite-On/Plextor M6e/Marvell 88SS9183
      PCI: Limit config space size for Netronome NFP4000
      PCI: Add Netronome NFP4000 PF device ID
      x86/PCI: Add driver for Intel Volume Management Device (VMD)
      PCI/AER: Use 32 bit PCI domain numbers
      x86/PCI: Allow DMA ops specific to a PCI domain
      irqdomain: Export irq_domain_set_info() for module use
      PCI: host: Add of_pci_get_host_bridge_resources() stub
      genirq/MSI: Relax msi_domain_alloc() to support parentless MSI irqdomains
      PCI: rcar: Add Gen2 PHY setup to pcie-rcar
      PCI: rcar: Add runtime PM support to pcie-rcar
      PCI: designware: Make config accessor override checking symmetric
      PCI: ibmphp: Remove unneeded NULL test
      ARM: dts: ifc6410: enable PCIe DT node for this board
      ARM: dts: apq8064: add PCIe devicetree node
      PCI: hotplug: Use list_for_each_entry() to simplify code
      PCI: rcar: Remove unused pci_sys_data struct from pcie-rcar
      PCI: hisi: Add support for HiSilicon Hip06 PCIe host controllers
      PCI: Avoid iterating through memory outside the resource window
      PCI: acpiphp_ibm: Fix null dereferences on null ibm_slot
      ...

commit 9662e32c810ad3e6ce49832d5f585a54f8fbdbdb
Merge: 904f664b585c bd7900825a3d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 20 11:48:25 2016 -0600

    Merge branch 'pci/trivial' into next
    
    * pci/trivial:
      PCI: shpchp: Constify hpc_ops structure
      PCI: Use kobj_to_dev() instead of open-coding it
      PCI: Use to_pci_dev() instead of open-coding it
      PCI: Fix all whitespace issues
      PCI/MSI: Fix typos in <linux/msi.h>

commit 554a60379aaa502def3c77ae1af69247588c020a
Author: Geliang Tang <geliangtang@163.com>
Date:   Wed Dec 23 20:28:13 2015 +0800

    PCI: Use kobj_to_dev() instead of open-coding it
    
    Use kobj_to_dev() instead of open-coding it.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 92618686604c..69ef1572ec70 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -627,8 +627,7 @@ static ssize_t pci_read_config(struct file *filp, struct kobject *kobj,
 			       struct bin_attribute *bin_attr, char *buf,
 			       loff_t off, size_t count)
 {
-	struct pci_dev *dev = to_pci_dev(container_of(kobj, struct device,
-						      kobj));
+	struct pci_dev *dev = to_pci_dev(kobj_to_dev(kobj));
 	unsigned int size = 64;
 	loff_t init_off = off;
 	u8 *data = (u8 *) buf;
@@ -704,8 +703,7 @@ static ssize_t pci_write_config(struct file *filp, struct kobject *kobj,
 				struct bin_attribute *bin_attr, char *buf,
 				loff_t off, size_t count)
 {
-	struct pci_dev *dev = to_pci_dev(container_of(kobj, struct device,
-						      kobj));
+	struct pci_dev *dev = to_pci_dev(kobj_to_dev(kobj));
 	unsigned int size = count;
 	loff_t init_off = off;
 	u8 *data = (u8 *) buf;
@@ -766,8 +764,7 @@ static ssize_t read_vpd_attr(struct file *filp, struct kobject *kobj,
 			     struct bin_attribute *bin_attr, char *buf,
 			     loff_t off, size_t count)
 {
-	struct pci_dev *dev =
-		to_pci_dev(container_of(kobj, struct device, kobj));
+	struct pci_dev *dev = to_pci_dev(kobj_to_dev(kobj));
 
 	if (off > bin_attr->size)
 		count = 0;
@@ -781,8 +778,7 @@ static ssize_t write_vpd_attr(struct file *filp, struct kobject *kobj,
 			      struct bin_attribute *bin_attr, char *buf,
 			      loff_t off, size_t count)
 {
-	struct pci_dev *dev =
-		to_pci_dev(container_of(kobj, struct device, kobj));
+	struct pci_dev *dev = to_pci_dev(kobj_to_dev(kobj));
 
 	if (off > bin_attr->size)
 		count = 0;
@@ -809,8 +805,7 @@ static ssize_t pci_read_legacy_io(struct file *filp, struct kobject *kobj,
 				  struct bin_attribute *bin_attr, char *buf,
 				  loff_t off, size_t count)
 {
-	struct pci_bus *bus = to_pci_bus(container_of(kobj, struct device,
-						      kobj));
+	struct pci_bus *bus = to_pci_bus(kobj_to_dev(kobj));
 
 	/* Only support 1, 2 or 4 byte accesses */
 	if (count != 1 && count != 2 && count != 4)
@@ -835,8 +830,7 @@ static ssize_t pci_write_legacy_io(struct file *filp, struct kobject *kobj,
 				   struct bin_attribute *bin_attr, char *buf,
 				   loff_t off, size_t count)
 {
-	struct pci_bus *bus = to_pci_bus(container_of(kobj, struct device,
-						      kobj));
+	struct pci_bus *bus = to_pci_bus(kobj_to_dev(kobj));
 
 	/* Only support 1, 2 or 4 byte accesses */
 	if (count != 1 && count != 2 && count != 4)
@@ -860,8 +854,7 @@ static int pci_mmap_legacy_mem(struct file *filp, struct kobject *kobj,
 			       struct bin_attribute *attr,
 			       struct vm_area_struct *vma)
 {
-	struct pci_bus *bus = to_pci_bus(container_of(kobj, struct device,
-						      kobj));
+	struct pci_bus *bus = to_pci_bus(kobj_to_dev(kobj));
 
 	return pci_mmap_legacy_page_range(bus, vma, pci_mmap_mem);
 }
@@ -881,8 +874,7 @@ static int pci_mmap_legacy_io(struct file *filp, struct kobject *kobj,
 			      struct bin_attribute *attr,
 			      struct vm_area_struct *vma)
 {
-	struct pci_bus *bus = to_pci_bus(container_of(kobj, struct device,
-						      kobj));
+	struct pci_bus *bus = to_pci_bus(kobj_to_dev(kobj));
 
 	return pci_mmap_legacy_page_range(bus, vma, pci_mmap_io);
 }
@@ -997,8 +989,7 @@ int pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vma,
 static int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 			     struct vm_area_struct *vma, int write_combine)
 {
-	struct pci_dev *pdev = to_pci_dev(container_of(kobj,
-						       struct device, kobj));
+	struct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));
 	struct resource *res = attr->private;
 	enum pci_mmap_state mmap_type;
 	resource_size_t start, end;
@@ -1051,8 +1042,7 @@ static ssize_t pci_resource_io(struct file *filp, struct kobject *kobj,
 			       struct bin_attribute *attr, char *buf,
 			       loff_t off, size_t count, bool write)
 {
-	struct pci_dev *pdev = to_pci_dev(container_of(kobj,
-						       struct device, kobj));
+	struct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));
 	struct resource *res = attr->private;
 	unsigned long port = off;
 	int i;
@@ -1222,7 +1212,7 @@ static ssize_t pci_write_rom(struct file *filp, struct kobject *kobj,
 			     struct bin_attribute *bin_attr, char *buf,
 			     loff_t off, size_t count)
 {
-	struct pci_dev *pdev = to_pci_dev(container_of(kobj, struct device, kobj));
+	struct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));
 
 	if ((off ==  0) && (*buf == '0') && (count == 2))
 		pdev->rom_attr_enabled = 0;
@@ -1248,7 +1238,7 @@ static ssize_t pci_read_rom(struct file *filp, struct kobject *kobj,
 			    struct bin_attribute *bin_attr, char *buf,
 			    loff_t off, size_t count)
 {
-	struct pci_dev *pdev = to_pci_dev(container_of(kobj, struct device, kobj));
+	struct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));
 	void __iomem *rom;
 	size_t size;
 
@@ -1508,7 +1498,7 @@ static struct attribute *pci_dev_dev_attrs[] = {
 static umode_t pci_dev_attrs_are_visible(struct kobject *kobj,
 					 struct attribute *a, int n)
 {
-	struct device *dev = container_of(kobj, struct device, kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	struct pci_dev *pdev = to_pci_dev(dev);
 
 	if (a == &vga_attr.attr)
@@ -1527,7 +1517,7 @@ static struct attribute *pci_dev_hp_attrs[] = {
 static umode_t pci_dev_hp_attrs_are_visible(struct kobject *kobj,
 					    struct attribute *a, int n)
 {
-	struct device *dev = container_of(kobj, struct device, kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	struct pci_dev *pdev = to_pci_dev(dev);
 
 	if (pdev->is_virtfn)
@@ -1551,7 +1541,7 @@ static struct attribute *sriov_dev_attrs[] = {
 static umode_t sriov_attrs_are_visible(struct kobject *kobj,
 				       struct attribute *a, int n)
 {
-	struct device *dev = container_of(kobj, struct device, kobj);
+	struct device *dev = kobj_to_dev(kobj);
 
 	if (!dev_is_pf(dev))
 		return 0;

commit c20aecf6963d1273d8f6d61c042b4845441ca592
Author: Jason S. McMullan <jason.mcmullan@netronome.com>
Date:   Wed Sep 30 15:35:05 2015 +0900

    PCI: Support PCIe devices with short cfg_size
    
    If a device quirk modifies the pci_dev->cfg_size to be less than
    PCI_CFG_SPACE_EXP_SIZE (4096), but greater than PCI_CFG_SPACE_SIZE (256),
    the PCI sysfs interface truncates the readable size to PCI_CFG_SPACE_SIZE.
    
    Allow sysfs access to config space up to cfg_size, even if the device
    doesn't support the entire 4096-byte PCIe config space.
    
    Note that pci_read_config() and pci_write_config() limit access to
    dev->cfg_size even though pcie_config_attr contains 4096 (the maximum
    size).
    
    Signed-off-by: Jason S. McMullan <jason.mcmullan@netronome.com>
    [simon: edited changelog]
    Signed-off-by: Simon Horman <simon.horman@netronome.com>
    [bhelgaas: more changelog edits]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 92618686604c..9cd27b703dd6 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1369,10 +1369,10 @@ int __must_check pci_create_sysfs_dev_files(struct pci_dev *pdev)
 	if (!sysfs_initialized)
 		return -EACCES;
 
-	if (pdev->cfg_size < PCI_CFG_SPACE_EXP_SIZE)
-		retval = sysfs_create_bin_file(&pdev->dev.kobj, &pci_config_attr);
-	else
+	if (pdev->cfg_size > PCI_CFG_SPACE_SIZE)
 		retval = sysfs_create_bin_file(&pdev->dev.kobj, &pcie_config_attr);
+	else
+		retval = sysfs_create_bin_file(&pdev->dev.kobj, &pci_config_attr);
 	if (retval)
 		goto err;
 
@@ -1424,10 +1424,10 @@ int __must_check pci_create_sysfs_dev_files(struct pci_dev *pdev)
 err_resource_files:
 	pci_remove_resource_files(pdev);
 err_config_file:
-	if (pdev->cfg_size < PCI_CFG_SPACE_EXP_SIZE)
-		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
-	else
+	if (pdev->cfg_size > PCI_CFG_SPACE_SIZE)
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pcie_config_attr);
+	else
+		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
 err:
 	return retval;
 }
@@ -1461,10 +1461,10 @@ void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
 
 	pci_remove_capabilities_sysfs(pdev);
 
-	if (pdev->cfg_size < PCI_CFG_SPACE_EXP_SIZE)
-		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
-	else
+	if (pdev->cfg_size > PCI_CFG_SPACE_SIZE)
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pcie_config_attr);
+	else
+		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
 
 	pci_remove_resource_files(pdev);
 

commit 3dcc8d39cf15fa3ceabedcffcbd3958fe953555a
Author: Mathias Krause <minipli@googlemail.com>
Date:   Mon Nov 9 20:00:27 2015 +0100

    PCI: Prevent out of bounds access in numa_node override
    
    Commit 1266963170f5 ("PCI: Prevent out of bounds access in numa_node
    override") missed that the user-provided node could also be negative.
    Handle this case as well to avoid out-of-bounds accesses to the
    node_states[] array.  However, allow the special value -1, i.e.
    NUMA_NO_NODE, to be able to set the 'no specific node' configuration.
    
    Fixes: 1266963170f5 ("PCI: Prevent out of bounds access in numa_node override")
    Fixes: 63692df103e9 ("PCI: Allow numa_node override via sysfs")
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Sasha Levin <sasha.levin@oracle.com>
    CC: Prarit Bhargava <prarit@redhat.com>
    CC: stable@vger.kernel.org      # v3.19+

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 92618686604c..eead54cd01b2 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -216,7 +216,10 @@ static ssize_t numa_node_store(struct device *dev,
 	if (ret)
 		return ret;
 
-	if (node >= MAX_NUMNODES || !node_online(node))
+	if ((node < 0 && node != NUMA_NO_NODE) || node >= MAX_NUMNODES)
+		return -EINVAL;
+
+	if (node != NUMA_NO_NODE && !node_online(node))
 		return -EINVAL;
 
 	add_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);

commit 1266963170f576d4d08e6310b6963e26d3ff9d1e
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Wed Oct 7 11:03:28 2015 -0500

    PCI: Prevent out of bounds access in numa_node override
    
    63692df103e9 ("PCI: Allow numa_node override via sysfs") didn't check that
    the numa node provided by userspace is valid.  Passing a node number too
    high would attempt to access invalid memory and trigger a kernel panic.
    
    Fixes: 63692df103e9 ("PCI: Allow numa_node override via sysfs")
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v3.19+

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 312f23a8429c..92618686604c 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -216,7 +216,7 @@ static ssize_t numa_node_store(struct device *dev,
 	if (ret)
 		return ret;
 
-	if (!node_online(node))
+	if (node >= MAX_NUMNODES || !node_online(node))
 		return -EINVAL;
 
 	add_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);

commit 4efe874aace57dba967624ce1c48322da2447b75
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Wed Feb 4 17:38:15 2015 -0500

    PCI: Don't read past the end of sysfs "driver_override" buffer
    
    When printing the driver_override parameter when it is 4095 and 4094 bytes
    long, the printing code would access invalid memory because we need count+1
    bytes for printing.
    
    Fixes: 782a985d7af2 ("PCI: Introduce new device binding path using pci_dev.driver_override")
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Alex Williamson <alex.williamson@redhat.com>
    CC: stable@vger.kernel.org      # v3.16+
    CC: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    CC: Alexander Graf <agraf@suse.de>
    CC: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index aa012fb3834b..312f23a8429c 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -521,7 +521,8 @@ static ssize_t driver_override_store(struct device *dev,
 	struct pci_dev *pdev = to_pci_dev(dev);
 	char *driver_override, *old = pdev->driver_override, *cp;
 
-	if (count > PATH_MAX)
+	/* We need to keep extra room for a newline */
+	if (count >= (PAGE_SIZE - 1))
 		return -EINVAL;
 
 	driver_override = kstrndup(buf, count, GFP_KERNEL);
@@ -549,7 +550,7 @@ static ssize_t driver_override_show(struct device *dev,
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 
-	return sprintf(buf, "%s\n", pdev->driver_override);
+	return snprintf(buf, PAGE_SIZE, "%s\n", pdev->driver_override);
 }
 static DEVICE_ATTR_RW(driver_override);
 

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit 92a578b064d0227a3a7fbbdb9e29dbab7f8d400e
Merge: c75059c46293 e3d857e1ae78
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 10 21:17:00 2014 -0800

    Merge tag 'pm+acpi-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "This time we have some more new material than we used to have during
      the last couple of development cycles.
    
      The most important part of it to me is the introduction of a unified
      interface for accessing device properties provided by platform
      firmware.  It works with Device Trees and ACPI in a uniform way and
      drivers using it need not worry about where the properties come from
      as long as the platform firmware (either DT or ACPI) makes them
      available.  It covers both devices and "bare" device node objects
      without struct device representation as that turns out to be necessary
      in some cases.  This has been in the works for quite a few months (and
      development cycles) and has been approved by all of the relevant
      maintainers.
    
      On top of that, some drivers are switched over to the new interface
      (at25, leds-gpio, gpio_keys_polled) and some additional changes are
      made to the core GPIO subsystem to allow device drivers to manipulate
      GPIOs in the "canonical" way on platforms that provide GPIO
      information in their ACPI tables, but don't assign names to GPIO lines
      (in which case the driver needs to do that on the basis of what it
      knows about the device in question).  That also has been approved by
      the GPIO core maintainers and the rfkill driver is now going to use
      it.
    
      Second is support for hardware P-states in the intel_pstate driver.
      It uses CPUID to detect whether or not the feature is supported by the
      processor in which case it will be enabled by default.  However, it
      can be disabled entirely from the kernel command line if necessary.
    
      Next is support for a platform firmware interface based on ACPI
      operation regions used by the PMIC (Power Management Integrated
      Circuit) chips on the Intel Baytrail-T and Baytrail-T-CR platforms.
      That interface is used for manipulating power resources and for
      thermal management: sensor temperature reporting, trip point setting
      and so on.
    
      Also the ACPI core is now going to support the _DEP configuration
      information in a limited way.  Basically, _DEP it supposed to reflect
      off-the-hierarchy dependencies between devices which may be very
      indirect, like when AML for one device accesses locations in an
      operation region handled by another device's driver (usually, the
      device depended on this way is a serial bus or GPIO controller).  The
      support added this time is sufficient to make the ACPI battery driver
      work on Asus T100A, but it is general enough to be able to cover some
      other use cases in the future.
    
      Finally, we have a new cpufreq driver for the Loongson1B processor.
    
      In addition to the above, there are fixes and cleanups all over the
      place as usual and a traditional ACPICA update to a recent upstream
      release.
    
      As far as the fixes go, the ACPI LPSS (Low-power Subsystem) driver for
      Intel platforms should be able to handle power management of the DMA
      engine correctly, the cpufreq-dt driver should interact with the
      thermal subsystem in a better way and the ACPI backlight driver should
      handle some more corner cases, among other things.
    
      On top of the ACPICA update there are fixes for race conditions in the
      ACPICA's interrupt handling code which might lead to some random and
      strange looking failures on some systems.
    
      In the cleanups department the most visible part is the series of
      commits targeted at getting rid of the CONFIG_PM_RUNTIME configuration
      option.  That was triggered by a discussion regarding the generic
      power domains code during which we realized that trying to support
      certain combinations of PM config options was painful and not really
      worth it, because nobody would use them in production anyway.  For
      this reason, we decided to make CONFIG_PM_SLEEP select
      CONFIG_PM_RUNTIME and that lead to the conclusion that the latter
      became redundant and CONFIG_PM could be used instead of it.  The
      material here makes that replacement in a major part of the tree, but
      there will be at least one more batch of that in the second part of
      the merge window.
    
      Specifics:
    
       - Support for retrieving device properties information from ACPI _DSD
         device configuration objects and a unified device properties
         interface for device drivers (and subsystems) on top of that.  As
         stated above, this works with Device Trees and ACPI and allows
         device drivers to be written in a platform firmware (DT or ACPI)
         agnostic way.  The at25, leds-gpio and gpio_keys_polled drivers are
         now going to use this new interface and the GPIO subsystem is
         additionally modified to allow device drivers to assign names to
         GPIO resources returned by ACPI _CRS objects (in case _DSD is not
         present or does not provide the expected data).  The changes in
         this set are mostly from Mika Westerberg, Rafael J Wysocki, Aaron
         Lu, and Darren Hart with some fixes from others (Fabio Estevam,
         Geert Uytterhoeven).
    
       - Support for Hardware Managed Performance States (HWP) as described
         in Volume 3, section 14.4, of the Intel SDM in the intel_pstate
         driver.  CPUID is used to detect whether or not the feature is
         supported by the processor.  If supported, it will be enabled
         automatically unless the intel_pstate=no_hwp switch is present in
         the kernel command line.  From Dirk Brandewie.
    
       - New Intel Broadwell-H ID for intel_pstate (Dirk Brandewie).
    
       - Support for firmware interface based on ACPI operation regions used
         by the PMIC chips on the Intel Baytrail-T and Baytrail-T-CR
         platforms for power resource control and thermal management (Aaron
         Lu).
    
       - Limited support for retrieving off-the-hierarchy dependencies
         between devices from ACPI _DEP device configuration objects and
         deferred probing support for the ACPI battery driver based on the
         _DEP information to make that driver work on Asus T100A (Lan
         Tianyu).
    
       - New cpufreq driver for the Loongson1B processor (Kelvin Cheung).
    
       - ACPICA update to upstream revision 20141107 which only affects
         tools (Bob Moore).
    
       - Fixes for race conditions in the ACPICA's interrupt handling code
         and in the ACPI code related to system suspend and resume (Lv Zheng
         and Rafael J Wysocki).
    
       - ACPI core fix for an RCU-related issue in the ioremap() regions
         management code that slowed down significantly after CPUs had been
         allowed to enter idle states even if they'd had RCU callbakcs
         queued and triggered some problems in certain proprietary graphics
         driver (and elsewhere).  The fix replaces synchronize_rcu() in that
         code with synchronize_rcu_expedited() which makes the issue go
         away.  From Konstantin Khlebnikov.
    
       - ACPI LPSS (Low-Power Subsystem) driver fix to handle power
         management of the DMA engine included into the LPSS correctly.  The
         problem is that the DMA engine doesn't have ACPI PM support of its
         own and it simply is turned off when the last LPSS device having
         ACPI PM support goes into D3cold.  To work around that, the PM
         domain used by the ACPI LPSS driver is redesigned so at least one
         device with ACPI PM support will be on as long as the DMA engine is
         in use.  From Andy Shevchenko.
    
       - ACPI backlight driver fix to avoid using it on "Win8-compatible"
         systems where it doesn't work and where it was used by default by
         mistake (Aaron Lu).
    
       - Assorted minor ACPI core fixes and cleanups from Tomasz Nowicki,
         Sudeep Holla, Huang Rui, Hanjun Guo, Fabian Frederick, and Ashwin
         Chaugule (mostly related to the upcoming ARM64 support).
    
       - Intel RAPL (Running Average Power Limit) power capping driver fixes
         and improvements including new processor IDs (Jacob Pan).
    
       - Generic power domains modification to power up domains after
         attaching devices to them to meet the expectations of device
         drivers and bus types assuming devices to be accessible at probe
         time (Ulf Hansson).
    
       - Preliminary support for controlling device clocks from the generic
         power domains core code and modifications of the ARM/shmobile
         platform to use that feature (Ulf Hansson).
    
       - Assorted minor fixes and cleanups of the generic power domains core
         code (Ulf Hansson, Geert Uytterhoeven).
    
       - Assorted minor fixes and cleanups of the device clocks control code
         in the PM core (Geert Uytterhoeven, Grygorii Strashko).
    
       - Consolidation of device power management Kconfig options by making
         CONFIG_PM_SLEEP select CONFIG_PM_RUNTIME and removing the latter
         which is now redundant (Rafael J Wysocki and Kevin Hilman).  That
         is the first batch of the changes needed for this purpose.
    
       - Core device runtime power management support code cleanup related
         to the execution of callbacks (Andrzej Hajda).
    
       - cpuidle ARM support improvements (Lorenzo Pieralisi).
    
       - cpuidle cleanup related to the CPUIDLE_FLAG_TIME_VALID flag and a
         new MAINTAINERS entry for ARM Exynos cpuidle (Daniel Lezcano and
         Bartlomiej Zolnierkiewicz).
    
       - New cpufreq driver callback (->ready) to be executed when the
         cpufreq core is ready to use a given policy object and cpufreq-dt
         driver modification to use that callback for cooling device
         registration (Viresh Kumar).
    
       - cpufreq core fixes and cleanups (Viresh Kumar, Vince Hsu, James
         Geboski, Tomeu Vizoso).
    
       - Assorted fixes and cleanups in the cpufreq-pcc, intel_pstate,
         cpufreq-dt, pxa2xx cpufreq drivers (Lenny Szubowicz, Ethan Zhao,
         Stefan Wahren, Petr Cvek).
    
       - OPP (Operating Performance Points) framework modification to allow
         OPPs to be removed too and update of a few cpufreq drivers
         (cpufreq-dt, exynos5440, imx6q, cpufreq) to remove OPPs (added
         during initialization) on driver removal (Viresh Kumar).
    
       - Hibernation core fixes and cleanups (Tina Ruchandani and Markus
         Elfring).
    
       - PM Kconfig fix related to CPU power management (Pankaj Dubey).
    
       - cpupower tool fix (Prarit Bhargava)"
    
    * tag 'pm+acpi-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (120 commits)
      i2c-omap / PM: Drop CONFIG_PM_RUNTIME from i2c-omap.c
      dmaengine / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      tools: cpupower: fix return checks for sysfs_get_idlestate_count()
      drivers: sh / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      e1000e / igb / PM: Eliminate CONFIG_PM_RUNTIME
      MMC / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      MFD / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      misc / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      media / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      input / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      leds: leds-gpio: Fix multiple instances registration without 'label' property
      iio / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      hsi / OMAP / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      i2c-hid / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      drm / exynos / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      gpio / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      hwrandom / exynos / PM: Use CONFIG_PM in #ifdef
      block / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      USB / PM: Drop CONFIG_PM_RUNTIME from the USB core
      PM: Merge the SET*_RUNTIME_PM_OPS() macros
      ...

commit c75059c46293adf1560162c17148ab94624f5ed2
Merge: f74ea36848ad 149792795d2b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 10 20:58:52 2014 -0800

    Merge tag 'pci-v3.19-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI changes from Bjorn Helgaas:
     "Here are the PCI changes intended for v3.19.  I don't think there's
      anything very exciting here, but there was a lot of MSI-related stuff
      coming via Thomas.
    
      Details:
    
      NUMA
        - Allow numa_node override via sysfs (Prarit Bhargava)
    
      Resource management
        - Restore detection of read-only BARs (Myron Stowe)
        - Shrink decoding-disabled window while sizing BARs (Myron Stowe)
        - Add informational printk for invalid BARs (Myron Stowe)
        - Remove fixed parameter in pci_iov_resource_bar() (Myron Stowe)
    
      MSI
        - Add pci_msi_ignore_mask to prevent writes to MSI/MSI-X Mask Bits (Yijing Wang)
        - Revert "PCI: Add x86_msi.msi_mask_irq() and msix_mask_irq()" (Yijing Wang)
        - s390/MSI: Use __msi_mask_irq() instead of default_msi_mask_irq() (Yijing Wang)
    
      Virtualization
        - xen: Process failure for pcifront_(re)scan_root() (Chen Gang)
        - Make FLR and AF FLR reset warning messages different (Gavin Shan)
    
      Generic host bridge driver
        - Allocate config space windows after limiting bus number range (Lorenzo Pieralisi)
        - Convert to DT resource parsing API (Lorenzo Pieralisi)
    
      Freescale Layerscape
        - Add Freescale Layerscape PCIe driver (Minghuan Lian)
    
      NVIDIA Tegra
        - Do not build on 64-bit ARM (Thierry Reding)
        - Add Kconfig help text (Thierry Reding)
    
      Renesas R-Car
        - Make rcar_pci static (Jingoo Han)
    
      Samsung Exynos
        - Add exynos prefix to add_pcie_port(), pcie_init() (Jingoo Han)
    
      ST Microelectronics SPEAr13xx
        - Add spear prefix to add_pcie_port(), pcie_init() (Jingoo Han)
        - Make spear13xx_add_pcie_port() __init (Jingoo Han)
        - Remove unnecessary OOM message (Jingoo Han)
    
      TI DRA7xx
        - Add dra7xx prefix to add_pcie_port() (Jingoo Han)
        - Make dra7xx_add_pcie_port() __init (Jingoo Han)
    
      TI Keystone
        - Make ks_dw_pcie_msi_domain_ops static (Jingoo Han)
        - Remove unnecessary OOM message (Jingoo Han)
    
      Miscellaneous
        - Delete unnecessary NULL pointer checks (Markus Elfring)
        - Remove unused to_hotplug_slot() (Gavin Shan)
        - Whitespace cleanup (Jingoo Han)
        - Simplify if-return sequences (Quentin Lambert)"
    
    * tag 'pci-v3.19-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (28 commits)
      PCI: Remove fixed parameter in pci_iov_resource_bar()
      PCI: Add informational printk for invalid BARs
      PCI: tegra: Add Kconfig help text
      PCI: tegra: Do not build on 64-bit ARM
      PCI: spear: Remove unnecessary OOM message
      PCI: mvebu: Add a blank line after declarations
      PCI: designware: Add a blank line after declarations
      PCI: exynos: Remove unnecessary return statement
      PCI: imx6: Use tabs for indentation
      PCI: keystone: Remove unnecessary OOM message
      PCI: Remove unused and broken to_hotplug_slot()
      PCI: Make FLR and AF FLR reset warning messages different
      PCI: dra7xx: Add __init annotation to dra7xx_add_pcie_port()
      PCI: spear: Add __init annotation to spear13xx_add_pcie_port()
      PCI: spear: Rename add_pcie_port(), pcie_init() to spear13xx_add_pcie_port(), etc.
      PCI: dra7xx: Rename add_pcie_port() to dra7xx_add_pcie_port()
      PCI: layerscape: Add Freescale Layerscape PCIe driver
      PCI: Simplify if-return sequences
      PCI: Delete unnecessary NULL pointer checks
      PCI: Shrink decoding-disabled window while sizing BARs
      ...

commit fbb988be7f691599f17c6915c605bd09ec4318b4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 27 23:16:57 2014 +0100

    PCI / PM: Drop CONFIG_PM_RUNTIME from the PCI core
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so quite a few
    depend on CONFIG_PM.
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM in the PCI core code.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 2c6643fdc0cf..5c21e81b7caf 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -385,7 +385,7 @@ static ssize_t dev_bus_rescan_store(struct device *dev,
 }
 static DEVICE_ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, dev_bus_rescan_store);
 
-#if defined(CONFIG_PM_RUNTIME) && defined(CONFIG_ACPI)
+#if defined(CONFIG_PM) && defined(CONFIG_ACPI)
 static ssize_t d3cold_allowed_store(struct device *dev,
 				    struct device_attribute *attr,
 				    const char *buf, size_t count)
@@ -566,7 +566,7 @@ static struct attribute *pci_dev_attrs[] = {
 	&dev_attr_enable.attr,
 	&dev_attr_broken_parity_status.attr,
 	&dev_attr_msi_bus.attr,
-#if defined(CONFIG_PM_RUNTIME) && defined(CONFIG_ACPI)
+#if defined(CONFIG_PM) && defined(CONFIG_ACPI)
 	&dev_attr_d3cold_allowed.attr,
 #endif
 #ifdef CONFIG_OF

commit 5aaba36318e5995e8c95d077a46d9a4d00fcc1cd
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Tue Sep 30 14:48:22 2014 +0100

    cpumask: factor out show_cpumap into separate helper function
    
    Many sysfs *_show function use cpu{list,mask}_scnprintf to copy cpumap
    to the buffer aligned to PAGE_SIZE, append '\n' and '\0' to return null
    terminated buffer with newline.
    
    This patch creates a new helper function cpumap_print_to_pagebuf in
    cpumask.h using newly added bitmap_print_to_pagebuf and consolidates
    most of those sysfs functions using the new helper function.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Suggested-by: Stephen Boyd <sboyd@codeaurora.org>
    Tested-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: x86@kernel.org
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-pci@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 2c6643fdc0cf..368bdac42603 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -77,11 +77,10 @@ static ssize_t broken_parity_status_store(struct device *dev,
 }
 static DEVICE_ATTR_RW(broken_parity_status);
 
-static ssize_t pci_dev_show_local_cpu(struct device *dev, int type,
+static ssize_t pci_dev_show_local_cpu(struct device *dev, bool list,
 				      struct device_attribute *attr, char *buf)
 {
 	const struct cpumask *mask;
-	int len;
 
 #ifdef CONFIG_NUMA
 	mask = (dev_to_node(dev) == -1) ? cpu_online_mask :
@@ -89,59 +88,41 @@ static ssize_t pci_dev_show_local_cpu(struct device *dev, int type,
 #else
 	mask = cpumask_of_pcibus(to_pci_dev(dev)->bus);
 #endif
-	len = type ?
-		cpumask_scnprintf(buf, PAGE_SIZE-2, mask) :
-		cpulist_scnprintf(buf, PAGE_SIZE-2, mask);
-
-	buf[len++] = '\n';
-	buf[len] = '\0';
-	return len;
+	return cpumap_print_to_pagebuf(list, buf, mask);
 }
 
 static ssize_t local_cpus_show(struct device *dev,
 			       struct device_attribute *attr, char *buf)
 {
-	return pci_dev_show_local_cpu(dev, 1, attr, buf);
+	return pci_dev_show_local_cpu(dev, false, attr, buf);
 }
 static DEVICE_ATTR_RO(local_cpus);
 
 static ssize_t local_cpulist_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
-	return pci_dev_show_local_cpu(dev, 0, attr, buf);
+	return pci_dev_show_local_cpu(dev, true, attr, buf);
 }
 static DEVICE_ATTR_RO(local_cpulist);
 
 /*
  * PCI Bus Class Devices
  */
-static ssize_t pci_bus_show_cpuaffinity(struct device *dev, int type,
-					struct device_attribute *attr,
-					char *buf)
-{
-	int ret;
-	const struct cpumask *cpumask;
-
-	cpumask = cpumask_of_pcibus(to_pci_bus(dev));
-	ret = type ?
-		cpulist_scnprintf(buf, PAGE_SIZE-2, cpumask) :
-		cpumask_scnprintf(buf, PAGE_SIZE-2, cpumask);
-	buf[ret++] = '\n';
-	buf[ret] = '\0';
-	return ret;
-}
-
 static ssize_t cpuaffinity_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	return pci_bus_show_cpuaffinity(dev, 0, attr, buf);
+	const struct cpumask *cpumask = cpumask_of_pcibus(to_pci_bus(dev));
+
+	return cpumap_print_to_pagebuf(false, buf, cpumask);
 }
 static DEVICE_ATTR_RO(cpuaffinity);
 
 static ssize_t cpulistaffinity_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
-	return pci_bus_show_cpuaffinity(dev, 1, attr, buf);
+	const struct cpumask *cpumask = cpumask_of_pcibus(to_pci_bus(dev));
+
+	return cpumap_print_to_pagebuf(true, buf, cpumask);
 }
 static DEVICE_ATTR_RO(cpulistaffinity);
 

commit 63692df103e9c76b26c382ce8079283b7df9a99a
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Oct 23 14:22:12 2014 -0400

    PCI: Allow numa_node override via sysfs
    
    NUMA systems with ACPI normally describe the physical topology via _PXM
    methods.  But many BIOSes don't implement _PXM, which leaves the kernel
    with no way to discover the device topology, which reduces performance
    because we can't put memory and processes close to the device.
    
    The NUMA node of a PCI device is already exported in the sysfs "numa_node"
    file.  Make that file writable so users can workaround the lack of _PXM
    methods in the BIOS.  For example:
    
      echo 3 > /sys/devices/pci0000:ff/0000:03:1f.3/numa_node
    
    sets the node for PCI device 0000:03:1f.3.
    
    Writing the file emits a FW_BUG warning to encourage users to request
    firmware updates.  It also taints the kernel with TAINT_FIRMWARE_WORKAROUND
    because overriding the node incorrectly can cause performance issues.
    
    [bhelgaas: changelog, documentation text]
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Myron Stowe <mstowe@redhat.com>
    CC: Alexander Ducyk <alexander.h.duyck@redhat.com>
    CC: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 92b6d9ab00e4..91e760f9655b 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -221,12 +221,37 @@ static ssize_t enabled_show(struct device *dev, struct device_attribute *attr,
 static DEVICE_ATTR_RW(enabled);
 
 #ifdef CONFIG_NUMA
+static ssize_t numa_node_store(struct device *dev,
+			       struct device_attribute *attr, const char *buf,
+			       size_t count)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	int node, ret;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	ret = kstrtoint(buf, 0, &node);
+	if (ret)
+		return ret;
+
+	if (!node_online(node))
+		return -EINVAL;
+
+	add_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);
+	dev_alert(&pdev->dev, FW_BUG "Overriding NUMA node to %d.  Contact your vendor for updates.",
+		  node);
+
+	dev->numa_node = node;
+	return count;
+}
+
 static ssize_t numa_node_show(struct device *dev, struct device_attribute *attr,
 			      char *buf)
 {
 	return sprintf(buf, "%d\n", dev->numa_node);
 }
-static DEVICE_ATTR_RO(numa_node);
+static DEVICE_ATTR_RW(numa_node);
 #endif
 
 static ssize_t dma_mask_bits_show(struct device *dev,

commit d8e7d53a2fc14e0830ab728cb84ee19933d3ac8d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Oct 30 09:30:28 2014 -0700

    PCI: Rename sysfs 'enabled' file back to 'enable'
    
    Back in commit 5136b2da770d ("PCI: convert bus code to use dev_groups"),
    I misstyped the 'enable' sysfs filename as 'enabled', which broke the
    userspace API.  This patch fixes that issue by renaming the file back.
    
    Fixes: 5136b2da770d ("PCI: convert bus code to use dev_groups")
    Reported-by: Jeff Epler <jepler@unpythonic.net>
    Tested-by: Jeff Epler <jepler@unpythonic.net>   # on v3.14-rt
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # 3.13

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 92b6d9ab00e4..2c6643fdc0cf 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -185,7 +185,7 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR_RO(modalias);
 
-static ssize_t enabled_store(struct device *dev, struct device_attribute *attr,
+static ssize_t enable_store(struct device *dev, struct device_attribute *attr,
 			     const char *buf, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
@@ -210,7 +210,7 @@ static ssize_t enabled_store(struct device *dev, struct device_attribute *attr,
 	return result < 0 ? result : count;
 }
 
-static ssize_t enabled_show(struct device *dev, struct device_attribute *attr,
+static ssize_t enable_show(struct device *dev, struct device_attribute *attr,
 			    char *buf)
 {
 	struct pci_dev *pdev;
@@ -218,7 +218,7 @@ static ssize_t enabled_show(struct device *dev, struct device_attribute *attr,
 	pdev = to_pci_dev(dev);
 	return sprintf(buf, "%u\n", atomic_read(&pdev->enable_cnt));
 }
-static DEVICE_ATTR_RW(enabled);
+static DEVICE_ATTR_RW(enable);
 
 #ifdef CONFIG_NUMA
 static ssize_t numa_node_show(struct device *dev, struct device_attribute *attr,
@@ -563,7 +563,7 @@ static struct attribute *pci_dev_attrs[] = {
 #endif
 	&dev_attr_dma_mask_bits.attr,
 	&dev_attr_consistent_dma_mask_bits.attr,
-	&dev_attr_enabled.attr,
+	&dev_attr_enable.attr,
 	&dev_attr_broken_parity_status.attr,
 	&dev_attr_msi_bus.attr,
 #if defined(CONFIG_PM_RUNTIME) && defined(CONFIG_ACPI)

commit 359c660e99d1431a9b08b240bfc31acc3d658efe
Merge: 07a7cbd3b815 5ec094057c7d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Oct 1 12:31:46 2014 -0600

    Merge branch 'pci/msi' into next
    
    * pci/msi:
      PCI/MSI: Remove unnecessary temporary variable
      PCI/MSI: Use __write_msi_msg() instead of write_msi_msg()
      MSI/powerpc: Use __read_msi_msg() instead of read_msi_msg()
      PCI/MSI: Use __get_cached_msi_msg() instead of get_cached_msi_msg()
      PCI/MSI: Add "msi_bus" sysfs MSI/MSI-X control for endpoints
      PCI/MSI: Remove "pos" from the struct msi_desc msi_attrib
      PCI/MSI: Remove unused kobject from struct msi_desc
      PCI/MSI: Rename pci_msi_check_device() to pci_msi_supported()
      PCI/MSI: Move D0 check into pci_msi_check_device()
      PCI/MSI: Remove arch_msi_check_device()
      irqchip: armada-370-xp: Remove arch_msi_check_device()
      PCI/MSI/PPC: Remove arch_msi_check_device()
    
    Conflicts:
            drivers/pci/host/pcie-designware.c

commit 468ff15a3ab98ed7153c29c68229ffb97f15a251
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue Sep 23 13:27:24 2014 +0800

    PCI/MSI: Add "msi_bus" sysfs MSI/MSI-X control for endpoints
    
    The "msi_bus" sysfs file for bridges sets a bus flag to allow or disallow
    future driver requests for MSI or MSI-X.  Previously, the sysfs file
    existed for endpoints but did nothing.
    
    Add "msi_bus" support for endpoints, so an administrator can prevent the
    use of MSI and MSI-X for individual devices.
    
    Note that as for bridges, these changes only affect future driver requests
    for MSI or MSI-X, so drivers may need to be reloaded.
    
    Add documentation for the "msi_bus" sysfs file.
    
    [bhelgaas: changelog, comments, add "subordinate", add endpoint printk,
    rework bus_flags setting, make bus_flags printk unconditional]
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 9ff0a901ecf7..dbf63e23988d 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -250,46 +250,45 @@ static ssize_t msi_bus_show(struct device *dev, struct device_attribute *attr,
 			    char *buf)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
+	struct pci_bus *subordinate = pdev->subordinate;
 
-	if (!pdev->subordinate)
-		return 0;
-
-	return sprintf(buf, "%u\n",
-		       !(pdev->subordinate->bus_flags & PCI_BUS_FLAGS_NO_MSI));
+	return sprintf(buf, "%u\n", subordinate ?
+		       !(subordinate->bus_flags & PCI_BUS_FLAGS_NO_MSI)
+			   : !pdev->no_msi);
 }
 
 static ssize_t msi_bus_store(struct device *dev, struct device_attribute *attr,
 			     const char *buf, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
+	struct pci_bus *subordinate = pdev->subordinate;
 	unsigned long val;
 
 	if (kstrtoul(buf, 0, &val) < 0)
 		return -EINVAL;
 
-	/*
-	 * Bad things may happen if the no_msi flag is changed
-	 * while drivers are loaded.
-	 */
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/*
-	 * Maybe devices without subordinate buses shouldn't have this
-	 * attribute in the first place?
+	 * "no_msi" and "bus_flags" only affect what happens when a driver
+	 * requests MSI or MSI-X.  They don't affect any drivers that have
+	 * already requested MSI or MSI-X.
 	 */
-	if (!pdev->subordinate)
+	if (!subordinate) {
+		pdev->no_msi = !val;
+		dev_info(&pdev->dev, "MSI/MSI-X %s for future drivers\n",
+			 val ? "allowed" : "disallowed");
 		return count;
-
-	/* Is the flag going to change, or keep the value it already had? */
-	if (!(pdev->subordinate->bus_flags & PCI_BUS_FLAGS_NO_MSI) ^
-	    !!val) {
-		pdev->subordinate->bus_flags ^= PCI_BUS_FLAGS_NO_MSI;
-
-		dev_warn(&pdev->dev, "forced subordinate bus to%s support MSI, bad things could happen\n",
-			 val ? "" : " not");
 	}
 
+	if (val)
+		subordinate->bus_flags &= ~PCI_BUS_FLAGS_NO_MSI;
+	else
+		subordinate->bus_flags |= PCI_BUS_FLAGS_NO_MSI;
+
+	dev_info(&subordinate->dev, "MSI/MSI-X %s for future drivers of devices on this bus\n",
+		 val ? "allowed" : "disallowed");
 	return count;
 }
 static DEVICE_ATTR_RW(msi_bus);

commit 89ec3dcf17fd3fa009ecf8faaba36828dd6bc416
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Wed Aug 27 14:57:57 2014 +0200

    PCI: Generate uppercase hex for modalias interface class
    
    Some implementations of modprobe fail to load the driver for a PCI device
    automatically because the "interface" part of the modalias from the kernel
    is lowercase, and the modalias from file2alias is uppercase.
    
    The "interface" is the low-order byte of the Class Code, defined in PCI
    r3.0, Appendix D.  Most interface types defined in the spec do not use
    alpha characters, so they won't be affected.  For example, 00h, 01h, 10h,
    20h, etc. are unaffected.
    
    Print the "interface" byte of the Class Code in uppercase hex, as we
    already do for the Vendor ID, Device ID, Class, etc.
    
    [bhelgaas: changelog]
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    CC: stable@vger.kernel.org

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 9ff0a901ecf7..76ef7914c9aa 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -177,7 +177,7 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 
-	return sprintf(buf, "pci:v%08Xd%08Xsv%08Xsd%08Xbc%02Xsc%02Xi%02x\n",
+	return sprintf(buf, "pci:v%08Xd%08Xsv%08Xsd%08Xbc%02Xsc%02Xi%02X\n",
 		       pci_dev->vendor, pci_dev->device,
 		       pci_dev->subsystem_vendor, pci_dev->subsystem_device,
 		       (u8)(pci_dev->class >> 16), (u8)(pci_dev->class >> 8),

commit 227f06470502c4fea3d93df1f12a77e3e37f6263
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 18 20:13:50 2014 -0400

    PCI: Merge multi-line quoted strings
    
    Merge quoted strings that are broken across lines into a single entity.
    The compiler merges them anyway, but checkpatch complains about it, and
    merging them makes it easier to grep for strings.
    
    No functional change.
    
    [bhelgaas: changelog, do the same for everything under drivers/pci]
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 41d8d0307347..9ff0a901ecf7 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -286,8 +286,8 @@ static ssize_t msi_bus_store(struct device *dev, struct device_attribute *attr,
 	    !!val) {
 		pdev->subordinate->bus_flags ^= PCI_BUS_FLAGS_NO_MSI;
 
-		dev_warn(&pdev->dev, "forced subordinate bus to%s support MSI,"
-			 " bad things could happen\n", val ? "" : " not");
+		dev_warn(&pdev->dev, "forced subordinate bus to%s support MSI, bad things could happen\n",
+			 val ? "" : " not");
 	}
 
 	return count;
@@ -945,8 +945,7 @@ void pci_create_legacy_files(struct pci_bus *b)
 	kfree(b->legacy_io);
 	b->legacy_io = NULL;
 kzalloc_err:
-	printk(KERN_WARNING "pci: warning: could not create legacy I/O port "
-	       "and ISA memory resources to sysfs\n");
+	printk(KERN_WARNING "pci: warning: could not create legacy I/O port and ISA memory resources to sysfs\n");
 	return;
 }
 
@@ -1006,8 +1005,7 @@ static int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 		return -ENODEV;
 
 	if (!pci_mmap_fits(pdev, i, vma, PCI_MMAP_SYSFS)) {
-		WARN(1, "process \"%s\" tried to map 0x%08lx bytes "
-			"at page 0x%08lx on %s BAR %d (start 0x%16Lx, size 0x%16Lx)\n",
+		WARN(1, "process \"%s\" tried to map 0x%08lx bytes at page 0x%08lx on %s BAR %d (start 0x%16Lx, size 0x%16Lx)\n",
 			current->comm, vma->vm_end-vma->vm_start, vma->vm_pgoff,
 			pci_name(pdev), i,
 			(u64)pci_resource_start(pdev, i),

commit 3c78bc61f5ef3bc87e7f94f67ec737d2273f120b
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 18 20:13:49 2014 -0400

    PCI: Whitespace cleanup
    
    Fix various whitespace errors.
    
    No functional change.
    
    [bhelgaas: fix other similar problems]
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 84c350994b06..41d8d0307347 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -41,8 +41,8 @@ field##_show(struct device *dev, struct device_attribute *attr, char *buf)				\
 {									\
 	struct pci_dev *pdev;						\
 									\
-	pdev = to_pci_dev (dev);					\
-	return sprintf (buf, format_string, pdev->field);		\
+	pdev = to_pci_dev(dev);						\
+	return sprintf(buf, format_string, pdev->field);		\
 }									\
 static DEVICE_ATTR_RO(field)
 
@@ -58,7 +58,7 @@ static ssize_t broken_parity_status_show(struct device *dev,
 					 char *buf)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
-	return sprintf (buf, "%u\n", pdev->broken_parity_status);
+	return sprintf(buf, "%u\n", pdev->broken_parity_status);
 }
 
 static ssize_t broken_parity_status_store(struct device *dev,
@@ -77,10 +77,8 @@ static ssize_t broken_parity_status_store(struct device *dev,
 }
 static DEVICE_ATTR_RW(broken_parity_status);
 
-static ssize_t pci_dev_show_local_cpu(struct device *dev,
-		int type,
-		struct device_attribute *attr,
-		char *buf)
+static ssize_t pci_dev_show_local_cpu(struct device *dev, int type,
+				      struct device_attribute *attr, char *buf)
 {
 	const struct cpumask *mask;
 	int len;
@@ -101,14 +99,14 @@ static ssize_t pci_dev_show_local_cpu(struct device *dev,
 }
 
 static ssize_t local_cpus_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
+			       struct device_attribute *attr, char *buf)
 {
 	return pci_dev_show_local_cpu(dev, 1, attr, buf);
 }
 static DEVICE_ATTR_RO(local_cpus);
 
 static ssize_t local_cpulist_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
+				  struct device_attribute *attr, char *buf)
 {
 	return pci_dev_show_local_cpu(dev, 0, attr, buf);
 }
@@ -117,8 +115,7 @@ static DEVICE_ATTR_RO(local_cpulist);
 /*
  * PCI Bus Class Devices
  */
-static ssize_t pci_bus_show_cpuaffinity(struct device *dev,
-					int type,
+static ssize_t pci_bus_show_cpuaffinity(struct device *dev, int type,
 					struct device_attribute *attr,
 					char *buf)
 {
@@ -149,11 +146,11 @@ static ssize_t cpulistaffinity_show(struct device *dev,
 static DEVICE_ATTR_RO(cpulistaffinity);
 
 /* show resources */
-static ssize_t
-resource_show(struct device * dev, struct device_attribute *attr, char * buf)
+static ssize_t resource_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
 {
-	struct pci_dev * pci_dev = to_pci_dev(dev);
-	char * str = buf;
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	char *str = buf;
 	int i;
 	int max;
 	resource_size_t start, end;
@@ -166,7 +163,7 @@ resource_show(struct device * dev, struct device_attribute *attr, char * buf)
 	for (i = 0; i < max; i++) {
 		struct resource *res =  &pci_dev->resource[i];
 		pci_resource_to_user(pci_dev, i, res, &start, &end);
-		str += sprintf(str,"0x%016llx 0x%016llx 0x%016llx\n",
+		str += sprintf(str, "0x%016llx 0x%016llx 0x%016llx\n",
 			       (unsigned long long)start,
 			       (unsigned long long)end,
 			       (unsigned long long)res->flags);
@@ -175,7 +172,8 @@ resource_show(struct device * dev, struct device_attribute *attr, char * buf)
 }
 static DEVICE_ATTR_RO(resource);
 
-static ssize_t modalias_show(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 
@@ -187,9 +185,8 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR_RO(modalias);
 
-static ssize_t enabled_store(struct device *dev,
-			     struct device_attribute *attr, const char *buf,
-			     size_t count)
+static ssize_t enabled_store(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	unsigned long val;
@@ -213,57 +210,56 @@ static ssize_t enabled_store(struct device *dev,
 	return result < 0 ? result : count;
 }
 
-static ssize_t enabled_show(struct device *dev,
-			    struct device_attribute *attr, char *buf)
+static ssize_t enabled_show(struct device *dev, struct device_attribute *attr,
+			    char *buf)
 {
 	struct pci_dev *pdev;
 
-	pdev = to_pci_dev (dev);
-	return sprintf (buf, "%u\n", atomic_read(&pdev->enable_cnt));
+	pdev = to_pci_dev(dev);
+	return sprintf(buf, "%u\n", atomic_read(&pdev->enable_cnt));
 }
 static DEVICE_ATTR_RW(enabled);
 
 #ifdef CONFIG_NUMA
-static ssize_t
-numa_node_show(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t numa_node_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
 {
-	return sprintf (buf, "%d\n", dev->numa_node);
+	return sprintf(buf, "%d\n", dev->numa_node);
 }
 static DEVICE_ATTR_RO(numa_node);
 #endif
 
-static ssize_t
-dma_mask_bits_show(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t dma_mask_bits_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 
-	return sprintf (buf, "%d\n", fls64(pdev->dma_mask));
+	return sprintf(buf, "%d\n", fls64(pdev->dma_mask));
 }
 static DEVICE_ATTR_RO(dma_mask_bits);
 
-static ssize_t
-consistent_dma_mask_bits_show(struct device *dev, struct device_attribute *attr,
-				 char *buf)
+static ssize_t consistent_dma_mask_bits_show(struct device *dev,
+					     struct device_attribute *attr,
+					     char *buf)
 {
-	return sprintf (buf, "%d\n", fls64(dev->coherent_dma_mask));
+	return sprintf(buf, "%d\n", fls64(dev->coherent_dma_mask));
 }
 static DEVICE_ATTR_RO(consistent_dma_mask_bits);
 
-static ssize_t
-msi_bus_show(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t msi_bus_show(struct device *dev, struct device_attribute *attr,
+			    char *buf)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 
 	if (!pdev->subordinate)
 		return 0;
 
-	return sprintf (buf, "%u\n",
-			!(pdev->subordinate->bus_flags & PCI_BUS_FLAGS_NO_MSI));
+	return sprintf(buf, "%u\n",
+		       !(pdev->subordinate->bus_flags & PCI_BUS_FLAGS_NO_MSI));
 }
 
-static ssize_t
-msi_bus_store(struct device *dev, struct device_attribute *attr,
-	      const char *buf, size_t count)
+static ssize_t msi_bus_store(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	unsigned long val;
@@ -331,9 +327,9 @@ const struct attribute_group *pci_bus_groups[] = {
 	NULL,
 };
 
-static ssize_t
-dev_rescan_store(struct device *dev, struct device_attribute *attr,
-		 const char *buf, size_t count)
+static ssize_t dev_rescan_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
 {
 	unsigned long val;
 	struct pci_dev *pdev = to_pci_dev(dev);
@@ -352,9 +348,8 @@ static struct device_attribute dev_rescan_attr = __ATTR(rescan,
 							(S_IWUSR|S_IWGRP),
 							NULL, dev_rescan_store);
 
-static ssize_t
-remove_store(struct device *dev, struct device_attribute *attr,
-	     const char *buf, size_t count)
+static ssize_t remove_store(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
 {
 	unsigned long val;
 
@@ -369,9 +364,9 @@ static struct device_attribute dev_remove_attr = __ATTR(remove,
 							(S_IWUSR|S_IWGRP),
 							NULL, remove_store);
 
-static ssize_t
-dev_bus_rescan_store(struct device *dev, struct device_attribute *attr,
-		 const char *buf, size_t count)
+static ssize_t dev_bus_rescan_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
 {
 	unsigned long val;
 	struct pci_bus *bus = to_pci_bus(dev);
@@ -412,7 +407,7 @@ static ssize_t d3cold_allowed_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
-	return sprintf (buf, "%u\n", pdev->d3cold_allowed);
+	return sprintf(buf, "%u\n", pdev->d3cold_allowed);
 }
 static DEVICE_ATTR_RW(d3cold_allowed);
 #endif
@@ -607,8 +602,8 @@ const struct attribute_group *pcibus_groups[] = {
 	NULL,
 };
 
-static ssize_t
-boot_vga_show(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t boot_vga_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct pci_dev *vga_dev = vga_default_device();
@@ -622,22 +617,21 @@ boot_vga_show(struct device *dev, struct device_attribute *attr, char *buf)
 }
 static struct device_attribute vga_attr = __ATTR_RO(boot_vga);
 
-static ssize_t
-pci_read_config(struct file *filp, struct kobject *kobj,
-		struct bin_attribute *bin_attr,
-		char *buf, loff_t off, size_t count)
+static ssize_t pci_read_config(struct file *filp, struct kobject *kobj,
+			       struct bin_attribute *bin_attr, char *buf,
+			       loff_t off, size_t count)
 {
-	struct pci_dev *dev = to_pci_dev(container_of(kobj,struct device,kobj));
+	struct pci_dev *dev = to_pci_dev(container_of(kobj, struct device,
+						      kobj));
 	unsigned int size = 64;
 	loff_t init_off = off;
-	u8 *data = (u8*) buf;
+	u8 *data = (u8 *) buf;
 
 	/* Several chips lock up trying to read undefined config space */
-	if (security_capable(filp->f_cred, &init_user_ns, CAP_SYS_ADMIN) == 0) {
+	if (security_capable(filp->f_cred, &init_user_ns, CAP_SYS_ADMIN) == 0)
 		size = dev->cfg_size;
-	} else if (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS) {
+	else if (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)
 		size = 128;
-	}
 
 	if (off > size)
 		return 0;
@@ -700,15 +694,15 @@ pci_read_config(struct file *filp, struct kobject *kobj,
 	return count;
 }
 
-static ssize_t
-pci_write_config(struct file* filp, struct kobject *kobj,
-		 struct bin_attribute *bin_attr,
-		 char *buf, loff_t off, size_t count)
+static ssize_t pci_write_config(struct file *filp, struct kobject *kobj,
+				struct bin_attribute *bin_attr, char *buf,
+				loff_t off, size_t count)
 {
-	struct pci_dev *dev = to_pci_dev(container_of(kobj,struct device,kobj));
+	struct pci_dev *dev = to_pci_dev(container_of(kobj, struct device,
+						      kobj));
 	unsigned int size = count;
 	loff_t init_off = off;
-	u8 *data = (u8*) buf;
+	u8 *data = (u8 *) buf;
 
 	if (off > dev->cfg_size)
 		return 0;
@@ -728,10 +722,10 @@ pci_write_config(struct file* filp, struct kobject *kobj,
 	if ((off & 3) && size > 2) {
 		u16 val = data[off - init_off];
 		val |= (u16) data[off - init_off + 1] << 8;
-                pci_user_write_config_word(dev, off, val);
-                off += 2;
-                size -= 2;
-        }
+		pci_user_write_config_word(dev, off, val);
+		off += 2;
+		size -= 2;
+	}
 
 	while (size > 3) {
 		u32 val = data[off - init_off];
@@ -762,10 +756,9 @@ pci_write_config(struct file* filp, struct kobject *kobj,
 	return count;
 }
 
-static ssize_t
-read_vpd_attr(struct file *filp, struct kobject *kobj,
-	      struct bin_attribute *bin_attr,
-	      char *buf, loff_t off, size_t count)
+static ssize_t read_vpd_attr(struct file *filp, struct kobject *kobj,
+			     struct bin_attribute *bin_attr, char *buf,
+			     loff_t off, size_t count)
 {
 	struct pci_dev *dev =
 		to_pci_dev(container_of(kobj, struct device, kobj));
@@ -778,10 +771,9 @@ read_vpd_attr(struct file *filp, struct kobject *kobj,
 	return pci_read_vpd(dev, off, count, buf);
 }
 
-static ssize_t
-write_vpd_attr(struct file *filp, struct kobject *kobj,
-	       struct bin_attribute *bin_attr,
-	       char *buf, loff_t off, size_t count)
+static ssize_t write_vpd_attr(struct file *filp, struct kobject *kobj,
+			      struct bin_attribute *bin_attr, char *buf,
+			      loff_t off, size_t count)
 {
 	struct pci_dev *dev =
 		to_pci_dev(container_of(kobj, struct device, kobj));
@@ -807,20 +799,18 @@ write_vpd_attr(struct file *filp, struct kobject *kobj,
  * Reads 1, 2, or 4 bytes from legacy I/O port space using an arch specific
  * callback routine (pci_legacy_read).
  */
-static ssize_t
-pci_read_legacy_io(struct file *filp, struct kobject *kobj,
-		   struct bin_attribute *bin_attr,
-		   char *buf, loff_t off, size_t count)
+static ssize_t pci_read_legacy_io(struct file *filp, struct kobject *kobj,
+				  struct bin_attribute *bin_attr, char *buf,
+				  loff_t off, size_t count)
 {
-        struct pci_bus *bus = to_pci_bus(container_of(kobj,
-                                                      struct device,
+	struct pci_bus *bus = to_pci_bus(container_of(kobj, struct device,
 						      kobj));
 
-        /* Only support 1, 2 or 4 byte accesses */
-        if (count != 1 && count != 2 && count != 4)
-                return -EINVAL;
+	/* Only support 1, 2 or 4 byte accesses */
+	if (count != 1 && count != 2 && count != 4)
+		return -EINVAL;
 
-        return pci_legacy_read(bus, off, (u32 *)buf, count);
+	return pci_legacy_read(bus, off, (u32 *)buf, count);
 }
 
 /**
@@ -835,19 +825,18 @@ pci_read_legacy_io(struct file *filp, struct kobject *kobj,
  * Writes 1, 2, or 4 bytes from legacy I/O port space using an arch specific
  * callback routine (pci_legacy_write).
  */
-static ssize_t
-pci_write_legacy_io(struct file *filp, struct kobject *kobj,
-		    struct bin_attribute *bin_attr,
-		    char *buf, loff_t off, size_t count)
+static ssize_t pci_write_legacy_io(struct file *filp, struct kobject *kobj,
+				   struct bin_attribute *bin_attr, char *buf,
+				   loff_t off, size_t count)
 {
-        struct pci_bus *bus = to_pci_bus(container_of(kobj,
-						      struct device,
+	struct pci_bus *bus = to_pci_bus(container_of(kobj, struct device,
 						      kobj));
-        /* Only support 1, 2 or 4 byte accesses */
-        if (count != 1 && count != 2 && count != 4)
-                return -EINVAL;
 
-        return pci_legacy_write(bus, off, *(u32 *)buf, count);
+	/* Only support 1, 2 or 4 byte accesses */
+	if (count != 1 && count != 2 && count != 4)
+		return -EINVAL;
+
+	return pci_legacy_write(bus, off, *(u32 *)buf, count);
 }
 
 /**
@@ -861,16 +850,14 @@ pci_write_legacy_io(struct file *filp, struct kobject *kobj,
  * legacy memory space (first meg of bus space) into application virtual
  * memory space.
  */
-static int
-pci_mmap_legacy_mem(struct file *filp, struct kobject *kobj,
-		    struct bin_attribute *attr,
-                    struct vm_area_struct *vma)
+static int pci_mmap_legacy_mem(struct file *filp, struct kobject *kobj,
+			       struct bin_attribute *attr,
+			       struct vm_area_struct *vma)
 {
-        struct pci_bus *bus = to_pci_bus(container_of(kobj,
-                                                      struct device,
+	struct pci_bus *bus = to_pci_bus(container_of(kobj, struct device,
 						      kobj));
 
-        return pci_mmap_legacy_page_range(bus, vma, pci_mmap_mem);
+	return pci_mmap_legacy_page_range(bus, vma, pci_mmap_mem);
 }
 
 /**
@@ -884,16 +871,14 @@ pci_mmap_legacy_mem(struct file *filp, struct kobject *kobj,
  * legacy IO space (first meg of bus space) into application virtual
  * memory space. Returns -ENOSYS if the operation isn't supported
  */
-static int
-pci_mmap_legacy_io(struct file *filp, struct kobject *kobj,
-		   struct bin_attribute *attr,
-		   struct vm_area_struct *vma)
+static int pci_mmap_legacy_io(struct file *filp, struct kobject *kobj,
+			      struct bin_attribute *attr,
+			      struct vm_area_struct *vma)
 {
-        struct pci_bus *bus = to_pci_bus(container_of(kobj,
-                                                      struct device,
+	struct pci_bus *bus = to_pci_bus(container_of(kobj, struct device,
 						      kobj));
 
-        return pci_mmap_legacy_page_range(bus, vma, pci_mmap_io);
+	return pci_mmap_legacy_page_range(bus, vma, pci_mmap_io);
 }
 
 /**
@@ -903,10 +888,9 @@ pci_mmap_legacy_io(struct file *filp, struct kobject *kobj,
  *
  * Stub implementation. Can be overridden by arch if necessary.
  */
-void __weak
-pci_adjust_legacy_attr(struct pci_bus *b, enum pci_mmap_state mmap_type)
+void __weak pci_adjust_legacy_attr(struct pci_bus *b,
+				   enum pci_mmap_state mmap_type)
 {
-	return;
 }
 
 /**
@@ -1005,9 +989,8 @@ int pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vma,
  *
  * Use the regular PCI mapping routines to map a PCI resource into userspace.
  */
-static int
-pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
-		  struct vm_area_struct *vma, int write_combine)
+static int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
+			     struct vm_area_struct *vma, int write_combine)
 {
 	struct pci_dev *pdev = to_pci_dev(container_of(kobj,
 						       struct device, kobj));
@@ -1046,26 +1029,23 @@ pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 	return pci_mmap_page_range(pdev, vma, mmap_type, write_combine);
 }
 
-static int
-pci_mmap_resource_uc(struct file *filp, struct kobject *kobj,
-		     struct bin_attribute *attr,
-		     struct vm_area_struct *vma)
+static int pci_mmap_resource_uc(struct file *filp, struct kobject *kobj,
+				struct bin_attribute *attr,
+				struct vm_area_struct *vma)
 {
 	return pci_mmap_resource(kobj, attr, vma, 0);
 }
 
-static int
-pci_mmap_resource_wc(struct file *filp, struct kobject *kobj,
-		     struct bin_attribute *attr,
-		     struct vm_area_struct *vma)
+static int pci_mmap_resource_wc(struct file *filp, struct kobject *kobj,
+				struct bin_attribute *attr,
+				struct vm_area_struct *vma)
 {
 	return pci_mmap_resource(kobj, attr, vma, 1);
 }
 
-static ssize_t
-pci_resource_io(struct file *filp, struct kobject *kobj,
-		struct bin_attribute *attr, char *buf,
-		loff_t off, size_t count, bool write)
+static ssize_t pci_resource_io(struct file *filp, struct kobject *kobj,
+			       struct bin_attribute *attr, char *buf,
+			       loff_t off, size_t count, bool write)
 {
 	struct pci_dev *pdev = to_pci_dev(container_of(kobj,
 						       struct device, kobj));
@@ -1110,18 +1090,16 @@ pci_resource_io(struct file *filp, struct kobject *kobj,
 	return -EINVAL;
 }
 
-static ssize_t
-pci_read_resource_io(struct file *filp, struct kobject *kobj,
-		     struct bin_attribute *attr, char *buf,
-		     loff_t off, size_t count)
+static ssize_t pci_read_resource_io(struct file *filp, struct kobject *kobj,
+				    struct bin_attribute *attr, char *buf,
+				    loff_t off, size_t count)
 {
 	return pci_resource_io(filp, kobj, attr, buf, off, count, false);
 }
 
-static ssize_t
-pci_write_resource_io(struct file *filp, struct kobject *kobj,
-		      struct bin_attribute *attr, char *buf,
-		      loff_t off, size_t count)
+static ssize_t pci_write_resource_io(struct file *filp, struct kobject *kobj,
+				     struct bin_attribute *attr, char *buf,
+				     loff_t off, size_t count)
 {
 	return pci_resource_io(filp, kobj, attr, buf, off, count, true);
 }
@@ -1133,8 +1111,7 @@ pci_write_resource_io(struct file *filp, struct kobject *kobj,
  * If we created resource files for @pdev, remove them from sysfs and
  * free their resources.
  */
-static void
-pci_remove_resource_files(struct pci_dev *pdev)
+static void pci_remove_resource_files(struct pci_dev *pdev)
 {
 	int i;
 
@@ -1237,10 +1214,9 @@ void __weak pci_remove_resource_files(struct pci_dev *dev) { return; }
  *
  * writing anything except 0 enables it
  */
-static ssize_t
-pci_write_rom(struct file *filp, struct kobject *kobj,
-	      struct bin_attribute *bin_attr,
-	      char *buf, loff_t off, size_t count)
+static ssize_t pci_write_rom(struct file *filp, struct kobject *kobj,
+			     struct bin_attribute *bin_attr, char *buf,
+			     loff_t off, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(container_of(kobj, struct device, kobj));
 
@@ -1264,10 +1240,9 @@ pci_write_rom(struct file *filp, struct kobject *kobj,
  * Put @count bytes starting at @off into @buf from the ROM in the PCI
  * device corresponding to @kobj.
  */
-static ssize_t
-pci_read_rom(struct file *filp, struct kobject *kobj,
-	     struct bin_attribute *bin_attr,
-	     char *buf, loff_t off, size_t count)
+static ssize_t pci_read_rom(struct file *filp, struct kobject *kobj,
+			    struct bin_attribute *bin_attr, char *buf,
+			    loff_t off, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(container_of(kobj, struct device, kobj));
 	void __iomem *rom;
@@ -1313,9 +1288,8 @@ static struct bin_attribute pcie_config_attr = {
 	.write = pci_write_config,
 };
 
-static ssize_t reset_store(struct device *dev,
-			   struct device_attribute *attr, const char *buf,
-			   size_t count)
+static ssize_t reset_store(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	unsigned long val;
@@ -1382,7 +1356,7 @@ static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 	return retval;
 }
 
-int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
+int __must_check pci_create_sysfs_dev_files(struct pci_dev *pdev)
 {
 	int retval;
 	int rom_size = 0;
@@ -1520,7 +1494,6 @@ static int __init pci_sysfs_init(void)
 
 	return 0;
 }
-
 late_initcall(pci_sysfs_init);
 
 static struct attribute *pci_dev_dev_attrs[] = {
@@ -1529,7 +1502,7 @@ static struct attribute *pci_dev_dev_attrs[] = {
 };
 
 static umode_t pci_dev_attrs_are_visible(struct kobject *kobj,
-						struct attribute *a, int n)
+					 struct attribute *a, int n)
 {
 	struct device *dev = container_of(kobj, struct device, kobj);
 	struct pci_dev *pdev = to_pci_dev(dev);
@@ -1548,7 +1521,7 @@ static struct attribute *pci_dev_hp_attrs[] = {
 };
 
 static umode_t pci_dev_hp_attrs_are_visible(struct kobject *kobj,
-						struct attribute *a, int n)
+					    struct attribute *a, int n)
 {
 	struct device *dev = container_of(kobj, struct device, kobj);
 	struct pci_dev *pdev = to_pci_dev(dev);
@@ -1572,7 +1545,7 @@ static struct attribute *sriov_dev_attrs[] = {
 };
 
 static umode_t sriov_attrs_are_visible(struct kobject *kobj,
-					 struct attribute *a, int n)
+				       struct attribute *a, int n)
 {
 	struct device *dev = container_of(kobj, struct device, kobj);
 

commit d1a2523d2adc0b6910dbc2a9aed44c4217134db1
Merge: 79d458bf4743 cab9a128dad0 56604faed112 782a985d7af2
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed May 28 16:21:07 2014 -0600

    Merge branches 'pci/hotplug', 'pci/pci_is_bridge' and 'pci/virtualization' into next
    
    * pci/hotplug:
      PCI: cpqphp: Fix possible null pointer dereference
      NVMe: Implement PCIe reset notification callback
      PCI: Notify driver before and after device reset
    
    * pci/pci_is_bridge:
      pcmcia: Use pci_is_bridge() to simplify code
      PCI: pciehp: Use pci_is_bridge() to simplify code
      PCI: acpiphp: Use pci_is_bridge() to simplify code
      PCI: cpcihp: Use pci_is_bridge() to simplify code
      PCI: shpchp: Use pci_is_bridge() to simplify code
      PCI: rpaphp: Use pci_is_bridge() to simplify code
      sparc/PCI: Use pci_is_bridge() to simplify code
      powerpc/PCI: Use pci_is_bridge() to simplify code
      ia64/PCI: Use pci_is_bridge() to simplify code
      x86/PCI: Use pci_is_bridge() to simplify code
      PCI: Use pci_is_bridge() to simplify code
      PCI: Add new pci_is_bridge() interface
      PCI: Rename pci_is_bridge() to pci_has_subordinate()
    
    * pci/virtualization:
      PCI: Introduce new device binding path using pci_dev.driver_override
    
    Conflicts:
            drivers/pci/pci-sysfs.c

commit 782a985d7af26db39e86070d28f987cad21313c0
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue May 20 08:53:21 2014 -0600

    PCI: Introduce new device binding path using pci_dev.driver_override
    
    The driver_override field allows us to specify the driver for a device
    rather than relying on the driver to provide a positive match of the
    device.  This shortcuts the existing process of looking up the vendor and
    device ID, adding them to the driver new_id, binding the device, then
    removing the ID, but it also provides a couple advantages.
    
    First, the above existing process allows the driver to bind to any device
    matching the new_id for the window where it's enabled.  This is often not
    desired, such as the case of trying to bind a single device to a meta
    driver like pci-stub or vfio-pci.  Using driver_override we can do this
    deterministically using:
    
      echo pci-stub > /sys/bus/pci/devices/0000:03:00.0/driver_override
      echo 0000:03:00.0 > /sys/bus/pci/devices/0000:03:00.0/driver/unbind
      echo 0000:03:00.0 > /sys/bus/pci/drivers_probe
    
    Previously we could not invoke drivers_probe after adding a device to
    new_id for a driver as we get non-deterministic behavior whether the driver
    we intend or the standard driver will claim the device.  Now it becomes a
    deterministic process, only the driver matching driver_override will probe
    the device.
    
    To return the device to the standard driver, we simply clear the
    driver_override and reprobe the device:
    
      echo > /sys/bus/pci/devices/0000:03:00.0/driver_override
      echo 0000:03:00.0 > /sys/bus/pci/devices/0000:03:00.0/driver/unbind
      echo 0000:03:00.0 > /sys/bus/pci/drivers_probe
    
    Another advantage to this approach is that we can specify a driver override
    to force a specific binding or prevent any binding.  For instance when an
    IOMMU group is exposed to userspace through VFIO we require that all
    devices within that group are owned by VFIO.  However, devices can be
    hot-added into an IOMMU group, in which case we want to prevent the device
    from binding to any driver (override driver = "none") or perhaps have it
    automatically bind to vfio-pci.  With driver_override it's a simple matter
    for this field to be set internally when the device is first discovered to
    prevent driver matches.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Reviewed-by: Alexander Graf <agraf@suse.de>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 4e0acefb7565..faa4ab554d68 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -499,6 +499,45 @@ static struct device_attribute sriov_numvfs_attr =
 		       sriov_numvfs_show, sriov_numvfs_store);
 #endif /* CONFIG_PCI_IOV */
 
+static ssize_t driver_override_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	char *driver_override, *old = pdev->driver_override, *cp;
+
+	if (count > PATH_MAX)
+		return -EINVAL;
+
+	driver_override = kstrndup(buf, count, GFP_KERNEL);
+	if (!driver_override)
+		return -ENOMEM;
+
+	cp = strchr(driver_override, '\n');
+	if (cp)
+		*cp = '\0';
+
+	if (strlen(driver_override)) {
+		pdev->driver_override = driver_override;
+	} else {
+		kfree(driver_override);
+		pdev->driver_override = NULL;
+	}
+
+	kfree(old);
+
+	return count;
+}
+
+static ssize_t driver_override_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	return sprintf(buf, "%s\n", pdev->driver_override);
+}
+static DEVICE_ATTR_RW(driver_override);
+
 static struct attribute *pci_dev_attrs[] = {
 	&dev_attr_resource.attr,
 	&dev_attr_vendor.attr,
@@ -521,6 +560,7 @@ static struct attribute *pci_dev_attrs[] = {
 #if defined(CONFIG_PM_RUNTIME) && defined(CONFIG_ACPI)
 	&dev_attr_d3cold_allowed.attr,
 #endif
+	&dev_attr_driver_override.attr,
 	NULL,
 };
 

commit 9edbcd2252b5ef148177c9f2c11a56469cf5db52
Author: Sebastian Ott <sebott@linux.vnet.ibm.com>
Date:   Thu Apr 17 19:48:07 2014 +0200

    PCI: Remove pcibios_add_platform_entries()
    
    Remove pcibios_add_platform_entries().  Architecture-specific attributes
    can be achieved by setting pdev->dev.groups.
    
    Link: https://lkml.kernel.org/r/alpine.LFD.2.11.1404141101500.1529@denkbrett
    Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 3db1c7ff5dd3..b7333fa5f80d 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1273,11 +1273,6 @@ static struct bin_attribute pcie_config_attr = {
 	.write = pci_write_config,
 };
 
-int __weak pcibios_add_platform_entries(struct pci_dev *dev)
-{
-	return 0;
-}
-
 static ssize_t reset_store(struct device *dev,
 			   struct device_attribute *attr, const char *buf,
 			   size_t count)
@@ -1393,11 +1388,6 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 		pdev->rom_attr = attr;
 	}
 
-	/* add platform-specific attributes */
-	retval = pcibios_add_platform_entries(pdev);
-	if (retval)
-		goto err_rom_file;
-
 	/* add sysfs entries for various capabilities */
 	retval = pci_create_capabilities_sysfs(pdev);
 	if (retval)

commit dfc73e7acd9925b434a355eeeed86d44cb435f9c
Author: Sebastian Ott <sebott@linux.vnet.ibm.com>
Date:   Thu Apr 17 19:46:15 2014 +0200

    PCI: Move Open Firmware devspec attribute to PCI common code
    
    Move the devspec OF attribute to PCI common code's set of device attributes
    since it's not architecture dependent.  As a side effect microblaze and
    powerpc no longer need to use pcibios_add_platform_entries().
    
    [bhelgaas: fold in #include for compile error]
    Link: https://lkml.kernel.org/r/alpine.LFD.2.11.1404141101500.1529@denkbrett
    Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 4e0acefb7565..3db1c7ff5dd3 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -29,6 +29,7 @@
 #include <linux/slab.h>
 #include <linux/vgaarb.h>
 #include <linux/pm_runtime.h>
+#include <linux/of.h>
 #include "pci.h"
 
 static int sysfs_initialized;	/* = 0 */
@@ -416,6 +417,20 @@ static ssize_t d3cold_allowed_show(struct device *dev,
 static DEVICE_ATTR_RW(d3cold_allowed);
 #endif
 
+#ifdef CONFIG_OF
+static ssize_t devspec_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct device_node *np = pci_device_to_OF_node(pdev);
+
+	if (np == NULL || np->full_name == NULL)
+		return 0;
+	return sprintf(buf, "%s", np->full_name);
+}
+static DEVICE_ATTR_RO(devspec);
+#endif
+
 #ifdef CONFIG_PCI_IOV
 static ssize_t sriov_totalvfs_show(struct device *dev,
 				   struct device_attribute *attr,
@@ -520,6 +535,9 @@ static struct attribute *pci_dev_attrs[] = {
 	&dev_attr_msi_bus.attr,
 #if defined(CONFIG_PM_RUNTIME) && defined(CONFIG_ACPI)
 	&dev_attr_d3cold_allowed.attr,
+#endif
+#ifdef CONFIG_OF
+	&dev_attr_devspec.attr,
 #endif
 	NULL,
 };

commit bc6caf02cccedd30c9458e26dfdd8118af574ae5
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:03:02 2014 -0500

    pci: use device_remove_file_self() instead of device_schedule_callback()
    
    driver-core now supports synchrnous self-deletion of attributes and
    the asynchrnous removal mechanism is scheduled for removal.  Use it
    instead of device_schedule_callback().  This makes "remove" behave
    synchronously.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: linux-pci@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 276ef9c18802..4e0acefb7565 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -351,28 +351,17 @@ static struct device_attribute dev_rescan_attr = __ATTR(rescan,
 							(S_IWUSR|S_IWGRP),
 							NULL, dev_rescan_store);
 
-static void remove_callback(struct device *dev)
-{
-	pci_stop_and_remove_bus_device_locked(to_pci_dev(dev));
-}
-
 static ssize_t
-remove_store(struct device *dev, struct device_attribute *dummy,
+remove_store(struct device *dev, struct device_attribute *attr,
 	     const char *buf, size_t count)
 {
-	int ret = 0;
 	unsigned long val;
 
 	if (kstrtoul(buf, 0, &val) < 0)
 		return -EINVAL;
 
-	/* An attribute cannot be unregistered by one of its own methods,
-	 * so we have to use this roundabout approach.
-	 */
-	if (val)
-		ret = device_schedule_callback(dev, remove_callback);
-	if (ret)
-		count = ret;
+	if (val && device_remove_file_self(dev, attr))
+		pci_stop_and_remove_bus_device_locked(to_pci_dev(dev));
 	return count;
 }
 static struct device_attribute dev_remove_attr = __ATTR(remove,

commit 9d16947b75831acd317ab9a53e0e94d160731d33
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 10 15:22:18 2014 +0100

    PCI: Add global pci_lock_rescan_remove()
    
    There are multiple PCI device addition and removal code paths that may be
    run concurrently with the generic PCI bus rescan and device removal that
    can be triggered via sysfs.  If that happens, it may lead to multiple
    different, potentially dangerous race conditions.
    
    The most straightforward way to address those problems is to run
    the code in question under the same lock that is used by the
    generic rescan/remove code in pci-sysfs.c.  To prepare for those
    changes, move the definition of the global PCI remove/rescan lock
    to probe.c and provide global wrappers, pci_lock_rescan_remove()
    and pci_unlock_rescan_remove(), allowing drivers to manipulate
    that lock.  Also provide pci_stop_and_remove_bus_device_locked()
    for the callers of pci_stop_and_remove_bus_device() who only need
    to hold the rescan/remove lock around it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index c91e6c18debc..276ef9c18802 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -297,7 +297,6 @@ msi_bus_store(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR_RW(msi_bus);
 
-static DEFINE_MUTEX(pci_remove_rescan_mutex);
 static ssize_t bus_rescan_store(struct bus_type *bus, const char *buf,
 				size_t count)
 {
@@ -308,10 +307,10 @@ static ssize_t bus_rescan_store(struct bus_type *bus, const char *buf,
 		return -EINVAL;
 
 	if (val) {
-		mutex_lock(&pci_remove_rescan_mutex);
+		pci_lock_rescan_remove();
 		while ((b = pci_find_next_bus(b)) != NULL)
 			pci_rescan_bus(b);
-		mutex_unlock(&pci_remove_rescan_mutex);
+		pci_unlock_rescan_remove();
 	}
 	return count;
 }
@@ -342,9 +341,9 @@ dev_rescan_store(struct device *dev, struct device_attribute *attr,
 		return -EINVAL;
 
 	if (val) {
-		mutex_lock(&pci_remove_rescan_mutex);
+		pci_lock_rescan_remove();
 		pci_rescan_bus(pdev->bus);
-		mutex_unlock(&pci_remove_rescan_mutex);
+		pci_unlock_rescan_remove();
 	}
 	return count;
 }
@@ -354,11 +353,7 @@ static struct device_attribute dev_rescan_attr = __ATTR(rescan,
 
 static void remove_callback(struct device *dev)
 {
-	struct pci_dev *pdev = to_pci_dev(dev);
-
-	mutex_lock(&pci_remove_rescan_mutex);
-	pci_stop_and_remove_bus_device(pdev);
-	mutex_unlock(&pci_remove_rescan_mutex);
+	pci_stop_and_remove_bus_device_locked(to_pci_dev(dev));
 }
 
 static ssize_t
@@ -395,12 +390,12 @@ dev_bus_rescan_store(struct device *dev, struct device_attribute *attr,
 		return -EINVAL;
 
 	if (val) {
-		mutex_lock(&pci_remove_rescan_mutex);
+		pci_lock_rescan_remove();
 		if (!pci_is_root_bus(bus) && list_empty(&bus->devices))
 			pci_rescan_bus_bridge_resize(bus->self);
 		else
 			pci_rescan_bus(bus);
-		mutex_unlock(&pci_remove_rescan_mutex);
+		pci_unlock_rescan_remove();
 	}
 	return count;
 }

commit f7625980f5820edd1a73536e1a03bcbc1f889fec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 14 11:28:18 2013 -0700

    PCI: Fix whitespace, capitalization, and spelling errors
    
    Fix whitespace, capitalization, and spelling errors.  No functional change.
    I know "busses" is not an error, but "buses" was more common, so I used it
    consistently.
    
    Signed-off-by: Marta Rybczynska <rybczynska@gmail.com> (pci_reset_bridge_secondary_bus())
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 2aaa83c85a4e..c91e6c18debc 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -10,7 +10,7 @@
  *
  * File attributes for PCI devices
  *
- * Modeled after usb's driverfs.c 
+ * Modeled after usb's driverfs.c
  *
  */
 
@@ -270,13 +270,17 @@ msi_bus_store(struct device *dev, struct device_attribute *attr,
 	if (kstrtoul(buf, 0, &val) < 0)
 		return -EINVAL;
 
-	/* bad things may happen if the no_msi flag is changed
-	 * while some drivers are loaded */
+	/*
+	 * Bad things may happen if the no_msi flag is changed
+	 * while drivers are loaded.
+	 */
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
-	/* Maybe pci devices without subordinate busses shouldn't even have this
-	 * attribute in the first place?  */
+	/*
+	 * Maybe devices without subordinate buses shouldn't have this
+	 * attribute in the first place?
+	 */
 	if (!pdev->subordinate)
 		return count;
 
@@ -670,7 +674,7 @@ pci_write_config(struct file* filp, struct kobject *kobj,
 		size = dev->cfg_size - off;
 		count = size;
 	}
-	
+
 	pci_config_pm_runtime_get(dev);
 
 	if ((off & 1) && size) {
@@ -678,7 +682,7 @@ pci_write_config(struct file* filp, struct kobject *kobj,
 		off++;
 		size--;
 	}
-	
+
 	if ((off & 3) && size > 2) {
 		u16 val = data[off - init_off];
 		val |= (u16) data[off - init_off + 1] << 8;
@@ -696,7 +700,7 @@ pci_write_config(struct file* filp, struct kobject *kobj,
 		off += 4;
 		size -= 4;
 	}
-	
+
 	if (size >= 2) {
 		u16 val = data[off - init_off];
 		val |= (u16) data[off - init_off + 1] << 8;
@@ -1229,21 +1233,21 @@ pci_read_rom(struct file *filp, struct kobject *kobj,
 
 	if (!pdev->rom_attr_enabled)
 		return -EINVAL;
-	
+
 	rom = pci_map_rom(pdev, &size);	/* size starts out as PCI window size */
 	if (!rom || !size)
 		return -EIO;
-		
+
 	if (off >= size)
 		count = 0;
 	else {
 		if (off + count > size)
 			count = size - off;
-		
+
 		memcpy_fromio(buf, rom + off, count);
 	}
 	pci_unmap_rom(pdev, rom);
-		
+
 	return count;
 }
 

commit 33de1b8bf6e11a3bc69faf2f7ffb3692c723bdf5
Merge: cc17a67c0762 0394cb192db4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Oct 31 14:12:40 2013 -0600

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Report pci_pme_active() kmalloc failure
      mn10300/PCI: Remove useless pcibios_last_bus
      frv/PCI: Remove pcibios_last_bus
      PCI: Fail MSI/MSI-X initialization if device is not in PCI_D0
      x86/PCI: Coalesce multiple overlapping host bridge windows
      MAINTAINERS: Add arch/x86/pci to PCI file patterns
      PCI/PM: Remove pci_pm_complete()
      PCI: Add pci_dev_show_local_cpu() to simplify code
      mn10300/PCI: Remove unused pci_mem_start
      cris/PCI: Remove unused pci_mem_start
      PCI: Make pci_dev_pm_ops static
    
    Conflicts:
            drivers/pci/pci-sysfs.c

commit c489f5fbb1f5a770f98e492af5c47befb32890cd
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Mon Sep 30 15:02:38 2013 +0800

    PCI: Add pci_dev_show_local_cpu() to simplify code
    
    local_cpus_show() and local_cpulist_show() are almost the same.
    This adds a new helper function, pci_dev_show_local_cpu(), to simplify
    code.
    
    The same strategy is already used by cpuaffinity_show() and
    cpulistaffinity_show().
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 7128cfdd64aa..d9252dd89ea9 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -74,9 +74,11 @@ static ssize_t broken_parity_status_store(struct device *dev,
 	return count;
 }
 
-static ssize_t local_cpus_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
-{		
+static ssize_t pci_dev_show_local_cpu(struct device *dev,
+		int type,
+		struct device_attribute *attr,
+		char *buf)
+{
 	const struct cpumask *mask;
 	int len;
 
@@ -86,29 +88,25 @@ static ssize_t local_cpus_show(struct device *dev,
 #else
 	mask = cpumask_of_pcibus(to_pci_dev(dev)->bus);
 #endif
-	len = cpumask_scnprintf(buf, PAGE_SIZE-2, mask);
+	len = type ?
+		cpumask_scnprintf(buf, PAGE_SIZE-2, mask) :
+		cpulist_scnprintf(buf, PAGE_SIZE-2, mask);
+
 	buf[len++] = '\n';
 	buf[len] = '\0';
 	return len;
 }
 
+static ssize_t local_cpus_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return pci_dev_show_local_cpu(dev, 1, attr, buf);
+}
 
 static ssize_t local_cpulist_show(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {
-	const struct cpumask *mask;
-	int len;
-
-#ifdef CONFIG_NUMA
-	mask = (dev_to_node(dev) == -1) ? cpu_online_mask :
-					  cpumask_of_node(dev_to_node(dev));
-#else
-	mask = cpumask_of_pcibus(to_pci_dev(dev)->bus);
-#endif
-	len = cpulist_scnprintf(buf, PAGE_SIZE-2, mask);
-	buf[len++] = '\n';
-	buf[len] = '\0';
-	return len;
+	return pci_dev_show_local_cpu(dev, 0, attr, buf);
 }
 
 /*

commit bf22c90fb190e837173d61368e3c80f5b78751a8
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Sat Sep 28 15:42:00 2013 +0530

    PCI: Make pci_bus_attrs, pci_dev_attrs, dev_rescan_attr, dev_remove_attr, vga_attr static
    
    Local variables used only in this file are made static.
    
    [bhelgaas: also make pci_dev_attrs[] static (from Fengguang)]
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 618c06094295..82cc45867eaa 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -314,7 +314,7 @@ static ssize_t bus_rescan_store(struct bus_type *bus, const char *buf,
 }
 static BUS_ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, bus_rescan_store);
 
-struct attribute *pci_bus_attrs[] = {
+static struct attribute *pci_bus_attrs[] = {
 	&bus_attr_rescan.attr,
 	NULL,
 };
@@ -345,8 +345,9 @@ dev_rescan_store(struct device *dev, struct device_attribute *attr,
 	}
 	return count;
 }
-struct device_attribute dev_rescan_attr = __ATTR(rescan, (S_IWUSR|S_IWGRP),
-						 NULL, dev_rescan_store);
+static struct device_attribute dev_rescan_attr = __ATTR(rescan,
+							(S_IWUSR|S_IWGRP),
+							NULL, dev_rescan_store);
 
 static void remove_callback(struct device *dev)
 {
@@ -376,8 +377,9 @@ remove_store(struct device *dev, struct device_attribute *dummy,
 		count = ret;
 	return count;
 }
-struct device_attribute dev_remove_attr = __ATTR(remove, (S_IWUSR|S_IWGRP),
-						 NULL, remove_store);
+static struct device_attribute dev_remove_attr = __ATTR(remove,
+							(S_IWUSR|S_IWGRP),
+							NULL, remove_store);
 
 static ssize_t
 dev_bus_rescan_store(struct device *dev, struct device_attribute *attr,
@@ -510,7 +512,7 @@ static struct device_attribute sriov_numvfs_attr =
 		       sriov_numvfs_show, sriov_numvfs_store);
 #endif /* CONFIG_PCI_IOV */
 
-struct attribute *pci_dev_attrs[] = {
+static struct attribute *pci_dev_attrs[] = {
 	&dev_attr_resource.attr,
 	&dev_attr_vendor.attr,
 	&dev_attr_device.attr,
@@ -573,7 +575,7 @@ boot_vga_show(struct device *dev, struct device_attribute *attr, char *buf)
 		!!(pdev->resource[PCI_ROM_RESOURCE].flags &
 		   IORESOURCE_ROM_SHADOW));
 }
-struct device_attribute vga_attr = __ATTR_RO(boot_vga);
+static struct device_attribute vga_attr = __ATTR_RO(boot_vga);
 
 static ssize_t
 pci_read_config(struct file *filp, struct kobject *kobj,

commit 5136b2da770d53f026ab091f0423729ebf37a6b5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Oct 6 23:55:40 2013 -0700

    PCI: convert bus code to use dev_groups
    
    The dev_attrs field of struct bus_type is going away soon, dev_groups
    should be used instead.  This converts the PCI bus code to use the
    correct field.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index d8eb880bd1fc..618c06094295 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -42,7 +42,8 @@ field##_show(struct device *dev, struct device_attribute *attr, char *buf)				\
 									\
 	pdev = to_pci_dev (dev);					\
 	return sprintf (buf, format_string, pdev->field);		\
-}
+}									\
+static DEVICE_ATTR_RO(field)
 
 pci_config_attr(vendor, "0x%04x\n");
 pci_config_attr(device, "0x%04x\n");
@@ -73,6 +74,7 @@ static ssize_t broken_parity_status_store(struct device *dev,
 
 	return count;
 }
+static DEVICE_ATTR_RW(broken_parity_status);
 
 static ssize_t local_cpus_show(struct device *dev,
 			struct device_attribute *attr, char *buf)
@@ -91,7 +93,7 @@ static ssize_t local_cpus_show(struct device *dev,
 	buf[len] = '\0';
 	return len;
 }
-
+static DEVICE_ATTR_RO(local_cpus);
 
 static ssize_t local_cpulist_show(struct device *dev,
 			struct device_attribute *attr, char *buf)
@@ -110,6 +112,7 @@ static ssize_t local_cpulist_show(struct device *dev,
 	buf[len] = '\0';
 	return len;
 }
+static DEVICE_ATTR_RO(local_cpulist);
 
 /*
  * PCI Bus Class Devices
@@ -170,6 +173,7 @@ resource_show(struct device * dev, struct device_attribute *attr, char * buf)
 	}
 	return (str - buf);
 }
+static DEVICE_ATTR_RO(resource);
 
 static ssize_t modalias_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
@@ -181,10 +185,11 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,
 		       (u8)(pci_dev->class >> 16), (u8)(pci_dev->class >> 8),
 		       (u8)(pci_dev->class));
 }
+static DEVICE_ATTR_RO(modalias);
 
-static ssize_t is_enabled_store(struct device *dev,
-				struct device_attribute *attr, const char *buf,
-				size_t count)
+static ssize_t enabled_store(struct device *dev,
+			     struct device_attribute *attr, const char *buf,
+			     size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	unsigned long val;
@@ -208,14 +213,15 @@ static ssize_t is_enabled_store(struct device *dev,
 	return result < 0 ? result : count;
 }
 
-static ssize_t is_enabled_show(struct device *dev,
-			       struct device_attribute *attr, char *buf)
+static ssize_t enabled_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
 {
 	struct pci_dev *pdev;
 
 	pdev = to_pci_dev (dev);
 	return sprintf (buf, "%u\n", atomic_read(&pdev->enable_cnt));
 }
+static DEVICE_ATTR_RW(enabled);
 
 #ifdef CONFIG_NUMA
 static ssize_t
@@ -223,6 +229,7 @@ numa_node_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	return sprintf (buf, "%d\n", dev->numa_node);
 }
+static DEVICE_ATTR_RO(numa_node);
 #endif
 
 static ssize_t
@@ -232,6 +239,7 @@ dma_mask_bits_show(struct device *dev, struct device_attribute *attr, char *buf)
 
 	return sprintf (buf, "%d\n", fls64(pdev->dma_mask));
 }
+static DEVICE_ATTR_RO(dma_mask_bits);
 
 static ssize_t
 consistent_dma_mask_bits_show(struct device *dev, struct device_attribute *attr,
@@ -239,6 +247,7 @@ consistent_dma_mask_bits_show(struct device *dev, struct device_attribute *attr,
 {
 	return sprintf (buf, "%d\n", fls64(dev->coherent_dma_mask));
 }
+static DEVICE_ATTR_RO(consistent_dma_mask_bits);
 
 static ssize_t
 msi_bus_show(struct device *dev, struct device_attribute *attr, char *buf)
@@ -283,6 +292,7 @@ msi_bus_store(struct device *dev, struct device_attribute *attr,
 
 	return count;
 }
+static DEVICE_ATTR_RW(msi_bus);
 
 static DEFINE_MUTEX(pci_remove_rescan_mutex);
 static ssize_t bus_rescan_store(struct bus_type *bus, const char *buf,
@@ -414,6 +424,7 @@ static ssize_t d3cold_allowed_show(struct device *dev,
 	struct pci_dev *pdev = to_pci_dev(dev);
 	return sprintf (buf, "%u\n", pdev->d3cold_allowed);
 }
+static DEVICE_ATTR_RW(d3cold_allowed);
 #endif
 
 #ifdef CONFIG_PCI_IOV
@@ -499,30 +510,38 @@ static struct device_attribute sriov_numvfs_attr =
 		       sriov_numvfs_show, sriov_numvfs_store);
 #endif /* CONFIG_PCI_IOV */
 
-struct device_attribute pci_dev_attrs[] = {
-	__ATTR_RO(resource),
-	__ATTR_RO(vendor),
-	__ATTR_RO(device),
-	__ATTR_RO(subsystem_vendor),
-	__ATTR_RO(subsystem_device),
-	__ATTR_RO(class),
-	__ATTR_RO(irq),
-	__ATTR_RO(local_cpus),
-	__ATTR_RO(local_cpulist),
-	__ATTR_RO(modalias),
+struct attribute *pci_dev_attrs[] = {
+	&dev_attr_resource.attr,
+	&dev_attr_vendor.attr,
+	&dev_attr_device.attr,
+	&dev_attr_subsystem_vendor.attr,
+	&dev_attr_subsystem_device.attr,
+	&dev_attr_class.attr,
+	&dev_attr_irq.attr,
+	&dev_attr_local_cpus.attr,
+	&dev_attr_local_cpulist.attr,
+	&dev_attr_modalias.attr,
 #ifdef CONFIG_NUMA
-	__ATTR_RO(numa_node),
+	&dev_attr_numa_node.attr,
 #endif
-	__ATTR_RO(dma_mask_bits),
-	__ATTR_RO(consistent_dma_mask_bits),
-	__ATTR(enable, 0600, is_enabled_show, is_enabled_store),
-	__ATTR(broken_parity_status,(S_IRUGO|S_IWUSR),
-		broken_parity_status_show,broken_parity_status_store),
-	__ATTR(msi_bus, 0644, msi_bus_show, msi_bus_store),
+	&dev_attr_dma_mask_bits.attr,
+	&dev_attr_consistent_dma_mask_bits.attr,
+	&dev_attr_enabled.attr,
+	&dev_attr_broken_parity_status.attr,
+	&dev_attr_msi_bus.attr,
 #if defined(CONFIG_PM_RUNTIME) && defined(CONFIG_ACPI)
-	__ATTR(d3cold_allowed, 0644, d3cold_allowed_show, d3cold_allowed_store),
+	&dev_attr_d3cold_allowed.attr,
 #endif
-	__ATTR_NULL,
+	NULL,
+};
+
+static const struct attribute_group pci_dev_group = {
+	.attrs = pci_dev_attrs,
+};
+
+const struct attribute_group *pci_dev_groups[] = {
+	&pci_dev_group,
+	NULL,
 };
 
 static struct attribute *pcibus_attrs[] = {

commit 0f49ba5599048aae2fb3479a1814736e969cf38c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Oct 7 14:51:02 2013 -0600

    PCI: convert bus code to use bus_groups
    
    The bus_attrs field of struct bus_type is going away soon, dev_groups
    should be used instead.  This converts the PCI bus code to use the
    correct field.
    
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 7128cfdd64aa..d8eb880bd1fc 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -302,10 +302,20 @@ static ssize_t bus_rescan_store(struct bus_type *bus, const char *buf,
 	}
 	return count;
 }
+static BUS_ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, bus_rescan_store);
 
-struct bus_attribute pci_bus_attrs[] = {
-	__ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, bus_rescan_store),
-	__ATTR_NULL
+struct attribute *pci_bus_attrs[] = {
+	&bus_attr_rescan.attr,
+	NULL,
+};
+
+static const struct attribute_group pci_bus_group = {
+	.attrs = pci_bus_attrs,
+};
+
+const struct attribute_group *pci_bus_groups[] = {
+	&pci_bus_group,
+	NULL,
 };
 
 static ssize_t

commit 56039e658cc902fe6e3d1276bb78f7e69768cd35
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 24 15:05:17 2013 -0700

    PCI: Convert class code to use dev_groups
    
    The dev_attrs field of struct class is going away soon, dev_groups
    should be used instead.  This converts the PCI class code to use the
    correct field.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index c0dbe1f61362..7128cfdd64aa 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -131,19 +131,19 @@ static ssize_t pci_bus_show_cpuaffinity(struct device *dev,
 	return ret;
 }
 
-static inline ssize_t pci_bus_show_cpumaskaffinity(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
+static ssize_t cpuaffinity_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
 {
 	return pci_bus_show_cpuaffinity(dev, 0, attr, buf);
 }
+static DEVICE_ATTR_RO(cpuaffinity);
 
-static inline ssize_t pci_bus_show_cpulistaffinity(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
+static ssize_t cpulistaffinity_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
 {
 	return pci_bus_show_cpuaffinity(dev, 1, attr, buf);
 }
+static DEVICE_ATTR_RO(cpulistaffinity);
 
 /* show resources */
 static ssize_t
@@ -379,6 +379,7 @@ dev_bus_rescan_store(struct device *dev, struct device_attribute *attr,
 	}
 	return count;
 }
+static DEVICE_ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, dev_bus_rescan_store);
 
 #if defined(CONFIG_PM_RUNTIME) && defined(CONFIG_ACPI)
 static ssize_t d3cold_allowed_store(struct device *dev,
@@ -514,11 +515,20 @@ struct device_attribute pci_dev_attrs[] = {
 	__ATTR_NULL,
 };
 
-struct device_attribute pcibus_dev_attrs[] = {
-	__ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, dev_bus_rescan_store),
-	__ATTR(cpuaffinity, S_IRUGO, pci_bus_show_cpumaskaffinity, NULL),
-	__ATTR(cpulistaffinity, S_IRUGO, pci_bus_show_cpulistaffinity, NULL),
-	__ATTR_NULL,
+static struct attribute *pcibus_attrs[] = {
+	&dev_attr_rescan.attr,
+	&dev_attr_cpuaffinity.attr,
+	&dev_attr_cpulistaffinity.attr,
+	NULL,
+};
+
+static const struct attribute_group pcibus_group = {
+	.attrs = pcibus_attrs,
+};
+
+const struct attribute_group *pcibus_groups[] = {
+	&pcibus_group,
+	NULL,
 };
 
 static ssize_t

commit bb4bac9308bf8df5027dcbf27f1016104e3a504f
Merge: 06886e804387 dfab88beda88
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jun 5 12:27:19 2013 -0600

    Merge branch 'pci/jiang-iov-fixes' into next
    
    * pci/jiang-iov-fixes:
      PCI: Hide remove and rescan sysfs interfaces for SR-IOV virtual functions
      PCI: Finish SR-IOV VF setup before adding the device

commit dfab88beda88d6c24111e5966b08ecf813c3a18a
Author: Jiang Liu <liuj97@gmail.com>
Date:   Fri May 31 12:21:31 2013 +0800

    PCI: Hide remove and rescan sysfs interfaces for SR-IOV virtual functions
    
    PCI devices for SR-IOV virtual functions should only be created/
    destroyed by pci_enable_sriov()/pci_disable_sriov() because special
    data structures are associated with SR-IOV virtual functions.
    So hide hotplug related sysfs interfaces "remove" and "rescan" for
    SR-IOV virtual functions, otherwise it may cause memory leakage
    and other issues.
    
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Donald Dutile <ddutile@redhat.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Ram Pai <linuxram@us.ibm.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 5b4a9d9cd200..403da60cd983 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -325,6 +325,8 @@ dev_rescan_store(struct device *dev, struct device_attribute *attr,
 	}
 	return count;
 }
+struct device_attribute dev_rescan_attr = __ATTR(rescan, (S_IWUSR|S_IWGRP),
+						 NULL, dev_rescan_store);
 
 static void remove_callback(struct device *dev)
 {
@@ -354,6 +356,8 @@ remove_store(struct device *dev, struct device_attribute *dummy,
 		count = ret;
 	return count;
 }
+struct device_attribute dev_remove_attr = __ATTR(remove, (S_IWUSR|S_IWGRP),
+						 NULL, remove_store);
 
 static ssize_t
 dev_bus_rescan_store(struct device *dev, struct device_attribute *attr,
@@ -504,8 +508,6 @@ struct device_attribute pci_dev_attrs[] = {
 	__ATTR(broken_parity_status,(S_IRUGO|S_IWUSR),
 		broken_parity_status_show,broken_parity_status_store),
 	__ATTR(msi_bus, 0644, msi_bus_show, msi_bus_store),
-	__ATTR(remove, (S_IWUSR|S_IWGRP), NULL, remove_store),
-	__ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, dev_rescan_store),
 #if defined(CONFIG_PM_RUNTIME) && defined(CONFIG_ACPI)
 	__ATTR(d3cold_allowed, 0644, d3cold_allowed_show, d3cold_allowed_store),
 #endif
@@ -1463,6 +1465,29 @@ static umode_t pci_dev_attrs_are_visible(struct kobject *kobj,
 	return a->mode;
 }
 
+static struct attribute *pci_dev_hp_attrs[] = {
+	&dev_remove_attr.attr,
+	&dev_rescan_attr.attr,
+	NULL,
+};
+
+static umode_t pci_dev_hp_attrs_are_visible(struct kobject *kobj,
+						struct attribute *a, int n)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	if (pdev->is_virtfn)
+		return 0;
+
+	return a->mode;
+}
+
+static struct attribute_group pci_dev_hp_attr_group = {
+	.attrs = pci_dev_hp_attrs,
+	.is_visible = pci_dev_hp_attrs_are_visible,
+};
+
 #ifdef CONFIG_PCI_IOV
 static struct attribute *sriov_dev_attrs[] = {
 	&sriov_totalvfs_attr.attr,
@@ -1494,6 +1519,7 @@ static struct attribute_group pci_dev_attr_group = {
 
 static const struct attribute_group *pci_dev_attr_groups[] = {
 	&pci_dev_attr_group,
+	&pci_dev_hp_attr_group,
 #ifdef CONFIG_PCI_IOV
 	&sriov_dev_attr_group,
 #endif

commit 9a994e8ec7e7d6b1a66c74a683596b0f38f4e345
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Sat Jun 1 16:25:25 2013 +0900

    PCI: Replace strict_strtoul() with kstrtoul()
    
    The usage of strict_strtoul() is not preferred, because
    strict_strtoul() is obsolete.  Thus, kstrtoul() should be
    used.
    
    [bhelgaas: "#define strict_strtoul  kstrtoul", so no functional change]
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 5b4a9d9cd200..0b56e0865f38 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -66,7 +66,7 @@ static ssize_t broken_parity_status_store(struct device *dev,
 	struct pci_dev *pdev = to_pci_dev(dev);
 	unsigned long val;
 
-	if (strict_strtoul(buf, 0, &val) < 0)
+	if (kstrtoul(buf, 0, &val) < 0)
 		return -EINVAL;
 
 	pdev->broken_parity_status = !!val;
@@ -188,7 +188,7 @@ static ssize_t is_enabled_store(struct device *dev,
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	unsigned long val;
-	ssize_t result = strict_strtoul(buf, 0, &val);
+	ssize_t result = kstrtoul(buf, 0, &val);
 
 	if (result < 0)
 		return result;
@@ -259,7 +259,7 @@ msi_bus_store(struct device *dev, struct device_attribute *attr,
 	struct pci_dev *pdev = to_pci_dev(dev);
 	unsigned long val;
 
-	if (strict_strtoul(buf, 0, &val) < 0)
+	if (kstrtoul(buf, 0, &val) < 0)
 		return -EINVAL;
 
 	/* bad things may happen if the no_msi flag is changed
@@ -291,7 +291,7 @@ static ssize_t bus_rescan_store(struct bus_type *bus, const char *buf,
 	unsigned long val;
 	struct pci_bus *b = NULL;
 
-	if (strict_strtoul(buf, 0, &val) < 0)
+	if (kstrtoul(buf, 0, &val) < 0)
 		return -EINVAL;
 
 	if (val) {
@@ -315,7 +315,7 @@ dev_rescan_store(struct device *dev, struct device_attribute *attr,
 	unsigned long val;
 	struct pci_dev *pdev = to_pci_dev(dev);
 
-	if (strict_strtoul(buf, 0, &val) < 0)
+	if (kstrtoul(buf, 0, &val) < 0)
 		return -EINVAL;
 
 	if (val) {
@@ -342,7 +342,7 @@ remove_store(struct device *dev, struct device_attribute *dummy,
 	int ret = 0;
 	unsigned long val;
 
-	if (strict_strtoul(buf, 0, &val) < 0)
+	if (kstrtoul(buf, 0, &val) < 0)
 		return -EINVAL;
 
 	/* An attribute cannot be unregistered by one of its own methods,
@@ -362,7 +362,7 @@ dev_bus_rescan_store(struct device *dev, struct device_attribute *attr,
 	unsigned long val;
 	struct pci_bus *bus = to_pci_bus(dev);
 
-	if (strict_strtoul(buf, 0, &val) < 0)
+	if (kstrtoul(buf, 0, &val) < 0)
 		return -EINVAL;
 
 	if (val) {
@@ -384,7 +384,7 @@ static ssize_t d3cold_allowed_store(struct device *dev,
 	struct pci_dev *pdev = to_pci_dev(dev);
 	unsigned long val;
 
-	if (strict_strtoul(buf, 0, &val) < 0)
+	if (kstrtoul(buf, 0, &val) < 0)
 		return -EINVAL;
 
 	pdev->d3cold_allowed = !!val;
@@ -1236,7 +1236,7 @@ static ssize_t reset_store(struct device *dev,
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	unsigned long val;
-	ssize_t result = strict_strtoul(buf, 0, &val);
+	ssize_t result = kstrtoul(buf, 0, &val);
 
 	if (result < 0)
 		return result;

commit 64b001758e778b2b1aad08aa1f6c5896da5f5773
Author: Libin <huawei.libin@huawei.com>
Date:   Mon Apr 15 02:48:54 2013 +0000

    PCI: Use vma_pages() to replace (vm_end - vm_start) >> PAGE_SHIFT
    
    (*->vm_end - *->vm_start) >> PAGE_SHIFT operation is implemented
    as an inline funcion vma_pages() in linux/mm.h, so use it.
    
    Signed-off-by: Libin <huawei.libin@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 9c6e9bb674ec..5b4a9d9cd200 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -897,7 +897,7 @@ int pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vma,
 
 	if (pci_resource_len(pdev, resno) == 0)
 		return 0;
-	nr = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
+	nr = vma_pages(vma);
 	start = vma->vm_pgoff;
 	size = ((pci_resource_len(pdev, resno) - 1) >> PAGE_SHIFT) + 1;
 	pci_start = (mmap_api == PCI_MMAP_PROCFS) ?

commit faa48a507fd328013886426f9437fd7e2e7b820b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Dec 26 10:39:22 2012 -0700

    PCI: Remove spurious error for sriov_numvfs store and simplify flow
    
    If we request "num_vfs" and the driver's sriov_configure() method enables
    exactly that number ("num_vfs_enabled"), we complain "Invalid value for
    number of VFs to enable" and return an error.  We should silently return
    success instead.
    
    Also, use kstrtou16() since numVFs is defined to be a 16-bit field and
    rework to simplify control flow.
    
    Reported-by: Greg Rose <gregory.v.rose@intel.com>
    Reference: http://lkml.kernel.org/r/20121214101911.00002f59@unknown
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Tested-by: Donald Dutile <ddutile@redhat.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 05b78b16d20b..9c6e9bb674ec 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -422,77 +422,60 @@ static ssize_t sriov_numvfs_show(struct device *dev,
 }
 
 /*
- * num_vfs > 0; number of vfs to enable
- * num_vfs = 0; disable all vfs
+ * num_vfs > 0; number of VFs to enable
+ * num_vfs = 0; disable all VFs
  *
  * Note: SRIOV spec doesn't allow partial VF
- *       disable, so its all or none.
+ *       disable, so it's all or none.
  */
 static ssize_t sriov_numvfs_store(struct device *dev,
 				  struct device_attribute *attr,
 				  const char *buf, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
-	int num_vfs_enabled = 0;
-	int num_vfs;
-	int ret = 0;
-	u16 total;
+	int ret;
+	u16 num_vfs;
 
-	if (kstrtoint(buf, 0, &num_vfs) < 0)
-		return -EINVAL;
+	ret = kstrtou16(buf, 0, &num_vfs);
+	if (ret < 0)
+		return ret;
+
+	if (num_vfs > pci_sriov_get_totalvfs(pdev))
+		return -ERANGE;
+
+	if (num_vfs == pdev->sriov->num_VFs)
+		return count;		/* no change */
 
 	/* is PF driver loaded w/callback */
 	if (!pdev->driver || !pdev->driver->sriov_configure) {
-		dev_info(&pdev->dev,
-			 "Driver doesn't support SRIOV configuration via sysfs\n");
+		dev_info(&pdev->dev, "Driver doesn't support SRIOV configuration via sysfs\n");
 		return -ENOSYS;
 	}
 
-	/* if enabling vf's ... */
-	total = pci_sriov_get_totalvfs(pdev);
-	/* Requested VFs to enable < totalvfs and none enabled already */
-	if ((num_vfs > 0) && (num_vfs <= total)) {
-		if (pdev->sriov->num_VFs == 0) {
-			num_vfs_enabled =
-				pdev->driver->sriov_configure(pdev, num_vfs);
-			if ((num_vfs_enabled >= 0) &&
-			    (num_vfs_enabled != num_vfs)) {
-				dev_warn(&pdev->dev,
-					 "Only %d VFs enabled\n",
-					 num_vfs_enabled);
-				return count;
-			} else if (num_vfs_enabled < 0)
-				/* error code from driver callback */
-				return num_vfs_enabled;
-		} else if (num_vfs == pdev->sriov->num_VFs) {
-			dev_warn(&pdev->dev,
-				 "%d VFs already enabled; no enable action taken\n",
-				 num_vfs);
-			return count;
-		} else {
-			dev_warn(&pdev->dev,
-				 "%d VFs already enabled. Disable before enabling %d VFs\n",
-				 pdev->sriov->num_VFs, num_vfs);
-			return -EINVAL;
-		}
+	if (num_vfs == 0) {
+		/* disable VFs */
+		ret = pdev->driver->sriov_configure(pdev, 0);
+		if (ret < 0)
+			return ret;
+		return count;
 	}
 
-	/* disable vfs */
-	if (num_vfs == 0) {
-		if (pdev->sriov->num_VFs != 0) {
-			ret = pdev->driver->sriov_configure(pdev, 0);
-			return ret ? ret : count;
-		} else {
-			dev_warn(&pdev->dev,
-				 "All VFs disabled; no disable action taken\n");
-			return count;
-		}
+	/* enable VFs */
+	if (pdev->sriov->num_VFs) {
+		dev_warn(&pdev->dev, "%d VFs already enabled. Disable before enabling %d VFs\n",
+			 pdev->sriov->num_VFs, num_vfs);
+		return -EBUSY;
 	}
 
-	dev_err(&pdev->dev,
-		"Invalid value for number of VFs to enable: %d\n", num_vfs);
+	ret = pdev->driver->sriov_configure(pdev, num_vfs);
+	if (ret < 0)
+		return ret;
 
-	return -EINVAL;
+	if (ret != num_vfs)
+		dev_warn(&pdev->dev, "%d VFs requested; only %d enabled\n",
+			 num_vfs, ret);
+
+	return count;
 }
 
 static struct device_attribute sriov_totalvfs_attr = __ATTR_RO(sriov_totalvfs);

commit 193c0d682525987db59ac3a24531a77e4947aa95
Merge: 8b0cab14951f 1cb73f8c479e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 13 12:14:47 2012 -0800

    Merge tag 'for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI update from Bjorn Helgaas:
     "Host bridge hotplug:
       - Untangle _PRT from struct pci_bus (Bjorn Helgaas)
       - Request _OSC control before scanning root bus (Taku Izumi)
       - Assign resources when adding host bridge (Yinghai Lu)
       - Remove root bus when removing host bridge (Yinghai Lu)
       - Remove _PRT during hot remove (Yinghai Lu)
    
      SRIOV
        - Add sysfs knobs to control numVFs (Don Dutile)
    
      Power management
       - Notify devices when power resource turned on (Huang Ying)
    
      Bug fixes
       - Work around broken _SEG on HP xw9300 (Bjorn Helgaas)
       - Keep runtime PM enabled for unbound PCI devices (Huang Ying)
       - Fix Optimus dual-GPU runtime D3 suspend issue (Dave Airlie)
       - Fix xen frontend shutdown issue (David Vrabel)
       - Work around PLX PCI 9050 BAR alignment erratum (Ian Abbott)
    
      Miscellaneous
       - Add GPL license for drivers/pci/ioapic (Andrew Cooks)
       - Add standard PCI-X, PCIe ASPM register #defines (Bjorn Helgaas)
       - NumaChip remote PCI support (Daniel Blueman)
       - Fix PCIe Link Capabilities Supported Link Speed definition (Jingoo
         Han)
       - Convert dev_printk() to dev_info(), etc (Joe Perches)
       - Add support for non PCI BAR ROM data (Matthew Garrett)
       - Add x86 support for host bridge translation offset (Mike Yoknis)
       - Report success only when every driver supports AER (Vijay
         Pandarathil)"
    
    Fix up trivial conflicts.
    
    * tag 'for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (48 commits)
      PCI: Use phys_addr_t for physical ROM address
      x86/PCI: Add NumaChip remote PCI support
      ath9k: Use standard #defines for PCIe Capability ASPM fields
      iwlwifi: Use standard #defines for PCIe Capability ASPM fields
      iwlwifi: collapse wrapper for pcie_capability_read_word()
      iwlegacy: Use standard #defines for PCIe Capability ASPM fields
      iwlegacy: collapse wrapper for pcie_capability_read_word()
      cxgb3: Use standard #defines for PCIe Capability ASPM fields
      PCI: Add standard PCIe Capability Link ASPM field names
      PCI/portdrv: Use PCI Express Capability accessors
      PCI: Use standard PCIe Capability Link register field names
      x86: Use PCI setup data
      PCI: Add support for non-BAR ROMs
      PCI: Add pcibios_add_device
      EFI: Stash ROMs if they're not in the PCI BAR
      PCI: Add and use standard PCI-X Capability register names
      PCI/PM: Keep runtime PM enabled for unbound PCI devices
      xen-pcifront: Handle backend CLOSED without CLOSING
      PCI: SRIOV control and status via sysfs (documentation)
      PCI/AER: Report success only when every device has AER-aware driver
      ...

commit b40b97ae736cad3084b13d2969b10c474572de89
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Nov 21 15:34:57 2012 -0500

    PCI: Remove CONFIG_HOTPLUG ifdefs
    
    Remove conditional code based on CONFIG_HOTPLUG being false.  It's
    always on now in preparation of it going away as an option.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index f39378d9da15..68d56f02e721 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -284,7 +284,6 @@ msi_bus_store(struct device *dev, struct device_attribute *attr,
 	return count;
 }
 
-#ifdef CONFIG_HOTPLUG
 static DEFINE_MUTEX(pci_remove_rescan_mutex);
 static ssize_t bus_rescan_store(struct bus_type *bus, const char *buf,
 				size_t count)
@@ -377,8 +376,6 @@ dev_bus_rescan_store(struct device *dev, struct device_attribute *attr,
 	return count;
 }
 
-#endif
-
 #if defined(CONFIG_PM_RUNTIME) && defined(CONFIG_ACPI)
 static ssize_t d3cold_allowed_store(struct device *dev,
 				    struct device_attribute *attr,
@@ -424,10 +421,8 @@ struct device_attribute pci_dev_attrs[] = {
 	__ATTR(broken_parity_status,(S_IRUGO|S_IWUSR),
 		broken_parity_status_show,broken_parity_status_store),
 	__ATTR(msi_bus, 0644, msi_bus_show, msi_bus_store),
-#ifdef CONFIG_HOTPLUG
 	__ATTR(remove, (S_IWUSR|S_IWGRP), NULL, remove_store),
 	__ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, dev_rescan_store),
-#endif
 #if defined(CONFIG_PM_RUNTIME) && defined(CONFIG_ACPI)
 	__ATTR(d3cold_allowed, 0644, d3cold_allowed_show, d3cold_allowed_store),
 #endif
@@ -435,9 +430,7 @@ struct device_attribute pci_dev_attrs[] = {
 };
 
 struct device_attribute pcibus_dev_attrs[] = {
-#ifdef CONFIG_HOTPLUG
 	__ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, dev_bus_rescan_store),
-#endif
 	__ATTR(cpuaffinity, S_IRUGO, pci_bus_show_cpumaskaffinity, NULL),
 	__ATTR(cpulistaffinity, S_IRUGO, pci_bus_show_cpulistaffinity, NULL),
 	__ATTR_NULL,

commit d3fe3988fb24e5ed13b2243b789a652882d3b26c
Merge: 7db78a9c864d ff8e59bc4ec3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Nov 26 13:00:57 2012 -0700

    Merge branch 'for-linus' into next
    
    * for-linus:
      PCI/portdrv: Don't create hotplug slots unless port supports hotplug
      PCI/PM: Fix proc config reg access for D3cold and bridge suspending
      PCI/PM: Resume device before shutdown
      PCI/PM: Fix deadlock when unbinding device if parent in D3cold

commit 6b136724691a6f247ada0c6a5f02370ed46de9f4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Nov 9 20:27:53 2012 -0700

    PCI: Use spec names for SR-IOV capability fields
    
    Use the same names (almost) as the spec for TotalVFs, InitialVFs, NumVFs.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 99b5f83d2468..2f21991b8bcd 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -421,7 +421,7 @@ static ssize_t sriov_numvfs_show(struct device *dev,
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 
-	return sprintf(buf, "%u\n", pdev->sriov->nr_virtfn);
+	return sprintf(buf, "%u\n", pdev->sriov->num_VFs);
 }
 
 /*
@@ -455,7 +455,7 @@ static ssize_t sriov_numvfs_store(struct device *dev,
 	total = pci_sriov_get_totalvfs(pdev);
 	/* Requested VFs to enable < totalvfs and none enabled already */
 	if ((num_vfs > 0) && (num_vfs <= total)) {
-		if (pdev->sriov->nr_virtfn == 0) {
+		if (pdev->sriov->num_VFs == 0) {
 			num_vfs_enabled =
 				pdev->driver->sriov_configure(pdev, num_vfs);
 			if ((num_vfs_enabled >= 0) &&
@@ -467,7 +467,7 @@ static ssize_t sriov_numvfs_store(struct device *dev,
 			} else if (num_vfs_enabled < 0)
 				/* error code from driver callback */
 				return num_vfs_enabled;
-		} else if (num_vfs == pdev->sriov->nr_virtfn) {
+		} else if (num_vfs == pdev->sriov->num_VFs) {
 			dev_warn(&pdev->dev,
 				 "%d VFs already enabled; no enable action taken\n",
 				 num_vfs);
@@ -475,14 +475,14 @@ static ssize_t sriov_numvfs_store(struct device *dev,
 		} else {
 			dev_warn(&pdev->dev,
 				 "%d VFs already enabled. Disable before enabling %d VFs\n",
-				 pdev->sriov->nr_virtfn, num_vfs);
+				 pdev->sriov->num_VFs, num_vfs);
 			return -EINVAL;
 		}
 	}
 
 	/* disable vfs */
 	if (num_vfs == 0) {
-		if (pdev->sriov->nr_virtfn != 0) {
+		if (pdev->sriov->num_VFs != 0) {
 			ret = pdev->driver->sriov_configure(pdev, 0);
 			return ret ? ret : count;
 		} else {

commit bff73156d3ad661655e6d9ef04c2284cf3abb0f1
Author: Donald Dutile <ddutile@redhat.com>
Date:   Mon Nov 5 15:20:37 2012 -0500

    PCI: Provide method to reduce the number of total VFs supported
    
    Some implementations of SRIOV provide a capability structure
    value of TotalVFs that is greater than what the software can support.
    Provide a method to reduce the capability structure reported value
    to the value the driver can support.
    This ensures sysfs reports the current capability of the system,
    hardware and software.
    Example for its use: igb & ixgbe -- report 8 & 64 as TotalVFs,
    but drivers only support 7 & 63 maximum.
    
    Signed-off-by: Donald Dutile <ddutile@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 74508c63bd47..99b5f83d2468 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -411,7 +411,7 @@ static ssize_t sriov_totalvfs_show(struct device *dev,
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 
-	return sprintf(buf, "%u\n", pdev->sriov->total);
+	return sprintf(buf, "%u\n", pci_sriov_get_totalvfs(pdev));
 }
 
 
@@ -452,7 +452,7 @@ static ssize_t sriov_numvfs_store(struct device *dev,
 	}
 
 	/* if enabling vf's ... */
-	total = pdev->sriov->total;
+	total = pci_sriov_get_totalvfs(pdev);
 	/* Requested VFs to enable < totalvfs and none enabled already */
 	if ((num_vfs > 0) && (num_vfs <= total)) {
 		if (pdev->sriov->nr_virtfn == 0) {

commit 1789382a72a537447d65ea4131d8bcc1ad85ce7b
Author: Donald Dutile <ddutile@redhat.com>
Date:   Mon Nov 5 15:20:36 2012 -0500

    PCI: SRIOV control and status via sysfs
    
    Provide files under sysfs to determine the maximum number of VFs
    an SR-IOV-capable PCIe device supports, and methods to enable and
    disable the VFs on a per-device basis.
    
    Currently, VF enablement by SR-IOV-capable PCIe devices is done
    via driver-specific module parameters.  If not setup in modprobe files,
    it requires admin to unload & reload PF drivers with number of desired
    VFs to enable.  Additionally, the enablement is system wide: all
    devices controlled by the same driver have the same number of VFs
    enabled.  Although the latter is probably desired, there are PCI
    configurations setup by system BIOS that may not enable that to occur.
    
    Two files are created for the PF of PCIe devices with SR-IOV support:
    
        sriov_totalvfs      Contains the maximum number of VFs the device
                            could support as reported by the TotalVFs register
                            in the SR-IOV extended capability.
    
        sriov_numvfs        Contains the number of VFs currently enabled on
                            this device as reported by the NumVFs register in
                            the SR-IOV extended capability.
    
                            Writing zero to this file disables all VFs.
    
                            Writing a positive number to this file enables that
                            number of VFs.
    
    These files are readable for all SR-IOV PF devices.  Writes to the
    sriov_numvfs file are effective only if a driver that supports the
    sriov_configure() method is attached.
    
    Signed-off-by: Donald Dutile <ddutile@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index fbbb97f28259..74508c63bd47 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -404,6 +404,106 @@ static ssize_t d3cold_allowed_show(struct device *dev,
 }
 #endif
 
+#ifdef CONFIG_PCI_IOV
+static ssize_t sriov_totalvfs_show(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	return sprintf(buf, "%u\n", pdev->sriov->total);
+}
+
+
+static ssize_t sriov_numvfs_show(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	return sprintf(buf, "%u\n", pdev->sriov->nr_virtfn);
+}
+
+/*
+ * num_vfs > 0; number of vfs to enable
+ * num_vfs = 0; disable all vfs
+ *
+ * Note: SRIOV spec doesn't allow partial VF
+ *       disable, so its all or none.
+ */
+static ssize_t sriov_numvfs_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	int num_vfs_enabled = 0;
+	int num_vfs;
+	int ret = 0;
+	u16 total;
+
+	if (kstrtoint(buf, 0, &num_vfs) < 0)
+		return -EINVAL;
+
+	/* is PF driver loaded w/callback */
+	if (!pdev->driver || !pdev->driver->sriov_configure) {
+		dev_info(&pdev->dev,
+			 "Driver doesn't support SRIOV configuration via sysfs\n");
+		return -ENOSYS;
+	}
+
+	/* if enabling vf's ... */
+	total = pdev->sriov->total;
+	/* Requested VFs to enable < totalvfs and none enabled already */
+	if ((num_vfs > 0) && (num_vfs <= total)) {
+		if (pdev->sriov->nr_virtfn == 0) {
+			num_vfs_enabled =
+				pdev->driver->sriov_configure(pdev, num_vfs);
+			if ((num_vfs_enabled >= 0) &&
+			    (num_vfs_enabled != num_vfs)) {
+				dev_warn(&pdev->dev,
+					 "Only %d VFs enabled\n",
+					 num_vfs_enabled);
+				return count;
+			} else if (num_vfs_enabled < 0)
+				/* error code from driver callback */
+				return num_vfs_enabled;
+		} else if (num_vfs == pdev->sriov->nr_virtfn) {
+			dev_warn(&pdev->dev,
+				 "%d VFs already enabled; no enable action taken\n",
+				 num_vfs);
+			return count;
+		} else {
+			dev_warn(&pdev->dev,
+				 "%d VFs already enabled. Disable before enabling %d VFs\n",
+				 pdev->sriov->nr_virtfn, num_vfs);
+			return -EINVAL;
+		}
+	}
+
+	/* disable vfs */
+	if (num_vfs == 0) {
+		if (pdev->sriov->nr_virtfn != 0) {
+			ret = pdev->driver->sriov_configure(pdev, 0);
+			return ret ? ret : count;
+		} else {
+			dev_warn(&pdev->dev,
+				 "All VFs disabled; no disable action taken\n");
+			return count;
+		}
+	}
+
+	dev_err(&pdev->dev,
+		"Invalid value for number of VFs to enable: %d\n", num_vfs);
+
+	return -EINVAL;
+}
+
+static struct device_attribute sriov_totalvfs_attr = __ATTR_RO(sriov_totalvfs);
+static struct device_attribute sriov_numvfs_attr =
+		__ATTR(sriov_numvfs, (S_IRUGO|S_IWUSR|S_IWGRP),
+		       sriov_numvfs_show, sriov_numvfs_store);
+#endif /* CONFIG_PCI_IOV */
+
 struct device_attribute pci_dev_attrs[] = {
 	__ATTR_RO(resource),
 	__ATTR_RO(vendor),
@@ -1421,6 +1521,30 @@ static umode_t pci_dev_attrs_are_visible(struct kobject *kobj,
 	return a->mode;
 }
 
+#ifdef CONFIG_PCI_IOV
+static struct attribute *sriov_dev_attrs[] = {
+	&sriov_totalvfs_attr.attr,
+	&sriov_numvfs_attr.attr,
+	NULL,
+};
+
+static umode_t sriov_attrs_are_visible(struct kobject *kobj,
+					 struct attribute *a, int n)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+
+	if (!dev_is_pf(dev))
+		return 0;
+
+	return a->mode;
+}
+
+static struct attribute_group sriov_dev_attr_group = {
+	.attrs = sriov_dev_attrs,
+	.is_visible = sriov_attrs_are_visible,
+};
+#endif /* CONFIG_PCI_IOV */
+
 static struct attribute_group pci_dev_attr_group = {
 	.attrs = pci_dev_dev_attrs,
 	.is_visible = pci_dev_attrs_are_visible,
@@ -1428,6 +1552,9 @@ static struct attribute_group pci_dev_attr_group = {
 
 static const struct attribute_group *pci_dev_attr_groups[] = {
 	&pci_dev_attr_group,
+#ifdef CONFIG_PCI_IOV
+	&sriov_dev_attr_group,
+#endif
 	NULL,
 };
 

commit 625e1d59a89f50bace376f429d8cf50347af75f7
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Nov 5 15:20:35 2012 -0500

    PCI: Use is_visible() with boot_vga attribute for pci_dev
    
    Should make pci_create_sysfs_dev_files() simpler.  Also fix possible
    memleak in remove path.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 3d160aa608c1..fbbb97f28259 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1303,29 +1303,20 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 		pdev->rom_attr = attr;
 	}
 
-	if ((pdev->class >> 8) == PCI_CLASS_DISPLAY_VGA) {
-		retval = device_create_file(&pdev->dev, &vga_attr);
-		if (retval)
-			goto err_rom_file;
-	}
-
 	/* add platform-specific attributes */
 	retval = pcibios_add_platform_entries(pdev);
 	if (retval)
-		goto err_vga_file;
+		goto err_rom_file;
 
 	/* add sysfs entries for various capabilities */
 	retval = pci_create_capabilities_sysfs(pdev);
 	if (retval)
-		goto err_vga_file;
+		goto err_rom_file;
 
 	pci_create_firmware_label_files(pdev);
 
 	return 0;
 
-err_vga_file:
-	if ((pdev->class >> 8) == PCI_CLASS_DISPLAY_VGA)
-		device_remove_file(&pdev->dev, &vga_attr);
 err_rom_file:
 	if (rom_size) {
 		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->rom_attr);
@@ -1413,12 +1404,20 @@ static int __init pci_sysfs_init(void)
 late_initcall(pci_sysfs_init);
 
 static struct attribute *pci_dev_dev_attrs[] = {
+	&vga_attr.attr,
 	NULL,
 };
 
 static umode_t pci_dev_attrs_are_visible(struct kobject *kobj,
 						struct attribute *a, int n)
 {
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	if (a == &vga_attr.attr)
+		if ((pdev->class >> 8) != PCI_CLASS_DISPLAY_VGA)
+			return 0;
+
 	return a->mode;
 }
 

commit 4e15c46bdc4d5ea0e7991a05edbd807328d38a2c
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Nov 5 15:20:34 2012 -0500

    PCI: Add pci_device_type to pdev's device struct
    
    Need type filled in device structure so it can be used for visible
    attribute control in sysfs for pci_dev.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 02d107b15281..3d160aa608c1 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1411,3 +1411,27 @@ static int __init pci_sysfs_init(void)
 }
 
 late_initcall(pci_sysfs_init);
+
+static struct attribute *pci_dev_dev_attrs[] = {
+	NULL,
+};
+
+static umode_t pci_dev_attrs_are_visible(struct kobject *kobj,
+						struct attribute *a, int n)
+{
+	return a->mode;
+}
+
+static struct attribute_group pci_dev_attr_group = {
+	.attrs = pci_dev_dev_attrs,
+	.is_visible = pci_dev_attrs_are_visible,
+};
+
+static const struct attribute_group *pci_dev_attr_groups[] = {
+	&pci_dev_attr_group,
+	NULL,
+};
+
+struct device_type pci_dev_type = {
+	.groups = pci_dev_attr_groups,
+};

commit b3c32c4f9565f93407921c0d8a4458042eb8998e
Author: Huang Ying <ying.huang@intel.com>
Date:   Thu Oct 25 09:36:03 2012 +0800

    PCI/PM: Fix proc config reg access for D3cold and bridge suspending
    
    In https://bugzilla.kernel.org/show_bug.cgi?id=48981
    Peter reported that /proc/bus/pci/??/??.? does not work for 3.6.
    This is because the device configuration space registers are
    not accessible if the corresponding parent bridge is suspended or
    the device is put into D3cold state.
    
    This is the same as /sys/bus/pci/devices/0000:??:??.?/config access
    issue.  So the function used to solve sysfs issue is used to solve
    this issue.
    
    This patch moves pci_config_pm_runtime_get()/_put() from pci/pci-sysfs.c
    to pci/pci.c and makes them extern so they can be used by both the
    sysfs and proc paths.
    
    [bhelgaas: changelog, references, reporters]
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=48981
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=49031
    Reported-by: Forrest Loomis <cybercyst@gmail.com>
    Reported-by: Peter <lekensteyn@gmail.com>
    Reported-by: Micael Dias <kam1kaz3@gmail.com>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    CC: stable@vger.kernel.org              # v3.6+

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 02d107b15281..f39378d9da15 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -458,40 +458,6 @@ boot_vga_show(struct device *dev, struct device_attribute *attr, char *buf)
 }
 struct device_attribute vga_attr = __ATTR_RO(boot_vga);
 
-static void
-pci_config_pm_runtime_get(struct pci_dev *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct device *parent = dev->parent;
-
-	if (parent)
-		pm_runtime_get_sync(parent);
-	pm_runtime_get_noresume(dev);
-	/*
-	 * pdev->current_state is set to PCI_D3cold during suspending,
-	 * so wait until suspending completes
-	 */
-	pm_runtime_barrier(dev);
-	/*
-	 * Only need to resume devices in D3cold, because config
-	 * registers are still accessible for devices suspended but
-	 * not in D3cold.
-	 */
-	if (pdev->current_state == PCI_D3cold)
-		pm_runtime_resume(dev);
-}
-
-static void
-pci_config_pm_runtime_put(struct pci_dev *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct device *parent = dev->parent;
-
-	pm_runtime_put(dev);
-	if (parent)
-		pm_runtime_put_sync(parent);
-}
-
 static ssize_t
 pci_read_config(struct file *filp, struct kobject *kobj,
 		struct bin_attribute *bin_attr,

commit 3d8387efe1ad9eb5bfe8a2e58cdbd1b88b247eef
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Aug 15 09:43:03 2012 +0800

    PCI/PM: Fix config reg access for D3cold and bridge suspending
    
    This patch fixes the following bug:
    
    http://marc.info/?l=linux-pci&m=134338059022620&w=2
    
    Where lspci does not work properly if a device and the corresponding
    parent bridge (such as PCIe port) is suspended.  This is because the
    device configuration space registers will be not accessible if the
    corresponding parent bridge is suspended or the device is put into
    D3cold state.
    
    To solve the issue, the bridge/PCIe port connected to the device is
    put into active state before read/write configuration space registers.
    If the device is in D3cold state, it will be put into active state
    too.
    
    To avoid resume/suspend PCIe port for each configuration register
    read/write, a small delay is added before the PCIe port to go
    suspended.
    
    Reported-by: Bjorn Mork <bjorn@mork.no>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 6869009c7393..02d107b15281 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -458,6 +458,40 @@ boot_vga_show(struct device *dev, struct device_attribute *attr, char *buf)
 }
 struct device_attribute vga_attr = __ATTR_RO(boot_vga);
 
+static void
+pci_config_pm_runtime_get(struct pci_dev *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device *parent = dev->parent;
+
+	if (parent)
+		pm_runtime_get_sync(parent);
+	pm_runtime_get_noresume(dev);
+	/*
+	 * pdev->current_state is set to PCI_D3cold during suspending,
+	 * so wait until suspending completes
+	 */
+	pm_runtime_barrier(dev);
+	/*
+	 * Only need to resume devices in D3cold, because config
+	 * registers are still accessible for devices suspended but
+	 * not in D3cold.
+	 */
+	if (pdev->current_state == PCI_D3cold)
+		pm_runtime_resume(dev);
+}
+
+static void
+pci_config_pm_runtime_put(struct pci_dev *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device *parent = dev->parent;
+
+	pm_runtime_put(dev);
+	if (parent)
+		pm_runtime_put_sync(parent);
+}
+
 static ssize_t
 pci_read_config(struct file *filp, struct kobject *kobj,
 		struct bin_attribute *bin_attr,
@@ -484,6 +518,8 @@ pci_read_config(struct file *filp, struct kobject *kobj,
 		size = count;
 	}
 
+	pci_config_pm_runtime_get(dev);
+
 	if ((off & 1) && size) {
 		u8 val;
 		pci_user_read_config_byte(dev, off, &val);
@@ -529,6 +565,8 @@ pci_read_config(struct file *filp, struct kobject *kobj,
 		--size;
 	}
 
+	pci_config_pm_runtime_put(dev);
+
 	return count;
 }
 
@@ -549,6 +587,8 @@ pci_write_config(struct file* filp, struct kobject *kobj,
 		count = size;
 	}
 	
+	pci_config_pm_runtime_get(dev);
+
 	if ((off & 1) && size) {
 		pci_user_write_config_byte(dev, off, data[off - init_off]);
 		off++;
@@ -587,6 +627,8 @@ pci_write_config(struct file* filp, struct kobject *kobj,
 		--size;
 	}
 
+	pci_config_pm_runtime_put(dev);
+
 	return count;
 }
 

commit 35e7f73c32ad44a931d918d04e317a7fb0c63e6e
Merge: e5028b52e46e 448bd857d48e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Jun 23 11:59:43 2012 -0600

    Merge branch 'topic/huang-d3cold-v7' into next
    
    * topic/huang-d3cold-v7:
      PCI/PM: add PCIe runtime D3cold support
      PCI: do not call pci_set_power_state with PCI_D3cold
      PCI/PM: add runtime PM support to PCIe port
      ACPI/PM: specify lowest allowed state for device sleep state

commit 448bd857d48e69b33ef323739dc6d8ca20d4cda7
Author: Huang Ying <ying.huang@intel.com>
Date:   Sat Jun 23 10:23:51 2012 +0800

    PCI/PM: add PCIe runtime D3cold support
    
    This patch adds runtime D3cold support and corresponding ACPI platform
    support.  This patch only enables runtime D3cold support; it does not
    enable D3cold support during system suspend/hibernate.
    
    D3cold is the deepest power saving state for a PCIe device, where its main
    power is removed.  While it is in D3cold, you can't access the device at
    all, not even its configuration space (which is still accessible in D3hot).
    Therefore the PCI PM registers can not be used to transition into/out of
    the D3cold state; that must be done by platform logic such as ACPI _PR3.
    
    To support wakeup from D3cold, a system may provide auxiliary power, which
    allows a device to request wakeup using a Beacon or the sideband WAKE#
    signal.  WAKE# is usually connected to platform logic such as ACPI GPE.
    This is quite different from other power saving states, where devices
    request wakeup via a PME message on the PCIe link.
    
    Some devices, such as those in plug-in slots, have no direct platform
    logic.  For example, there is usually no ACPI _PR3 for them.  D3cold
    support for these devices can be done via the PCIe Downstream Port leading
    to the device.  When the PCIe port is powered on/off, the device is powered
    on/off too.  Wakeup events from the device will be notified to the
    corresponding PCIe port.
    
    For more information about PCIe D3cold and corresponding ACPI support,
    please refer to:
    
    - PCI Express Base Specification Revision 2.0
    - Advanced Configuration and Power Interface Specification Revision 5.0
    
    [bhelgaas: changelog]
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>
    Originally-by: Zheng Yan <zheng.z.yan@intel.com>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 86c63fe45d11..1426db0c0607 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -28,6 +28,7 @@
 #include <linux/pci-aspm.h>
 #include <linux/slab.h>
 #include <linux/vgaarb.h>
+#include <linux/pm_runtime.h>
 #include "pci.h"
 
 static int sysfs_initialized;	/* = 0 */
@@ -378,6 +379,31 @@ dev_bus_rescan_store(struct device *dev, struct device_attribute *attr,
 
 #endif
 
+#if defined(CONFIG_PM_RUNTIME) && defined(CONFIG_ACPI)
+static ssize_t d3cold_allowed_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 0, &val) < 0)
+		return -EINVAL;
+
+	pdev->d3cold_allowed = !!val;
+	pm_runtime_resume(dev);
+
+	return count;
+}
+
+static ssize_t d3cold_allowed_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	return sprintf (buf, "%u\n", pdev->d3cold_allowed);
+}
+#endif
+
 struct device_attribute pci_dev_attrs[] = {
 	__ATTR_RO(resource),
 	__ATTR_RO(vendor),
@@ -401,6 +427,9 @@ struct device_attribute pci_dev_attrs[] = {
 #ifdef CONFIG_HOTPLUG
 	__ATTR(remove, (S_IWUSR|S_IWGRP), NULL, remove_store),
 	__ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, dev_rescan_store),
+#endif
+#if defined(CONFIG_PM_RUNTIME) && defined(CONFIG_ACPI)
+	__ATTR(d3cold_allowed, 0644, d3cold_allowed_show, d3cold_allowed_store),
 #endif
 	__ATTR_NULL,
 };

commit d6d88c832eaea6c6947ddf7b664601930a9f8a14
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jun 19 06:54:49 2012 -0600

    PCI: use __weak consistently
    
    Use "__weak" instead of the gcc-specific "__attribute__ ((weak))"
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 86c63fe45d11..a0b435f20bd6 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1112,7 +1112,7 @@ static struct bin_attribute pcie_config_attr = {
 	.write = pci_write_config,
 };
 
-int __attribute__ ((weak)) pcibios_add_platform_entries(struct pci_dev *dev)
+int __weak pcibios_add_platform_entries(struct pci_dev *dev)
 {
 	return 0;
 }

commit 1a39b310e920bb7098067d96411b31e459ae8f32
Author: Matthew Garrett <mjg@redhat.com>
Date:   Mon Apr 16 16:26:02 2012 -0400

    vgaarb: Add support for setting the default video device (v2)
    
    The default VGA device is a somewhat fluid concept on platforms with
    multiple GPUs. Add support for setting it so switching code can update
    things appropriately, and make sure that the sysfs code returns the right
    device if it's changed.
    
    v2: Updated to fix builds when __ARCH_HAS_VGA_DEFAULT_DEVICE is false.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Acked-by: benh@kernel.crashing.org
    Cc: airlied@redhat.com
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index a55e248618cd..86c63fe45d11 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -27,6 +27,7 @@
 #include <linux/security.h>
 #include <linux/pci-aspm.h>
 #include <linux/slab.h>
+#include <linux/vgaarb.h>
 #include "pci.h"
 
 static int sysfs_initialized;	/* = 0 */
@@ -417,6 +418,10 @@ static ssize_t
 boot_vga_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
+	struct pci_dev *vga_dev = vga_default_device();
+
+	if (vga_dev)
+		return sprintf(buf, "%u\n", (pdev == vga_dev));
 
 	return sprintf(buf, "%u\n",
 		!!(pdev->resource[PCI_ROM_RESOURCE].flags &

commit 210647af897af8ef2d00828aa2a6b1b42206aae6
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Feb 25 13:54:20 2012 -0800

    PCI: Rename pci_remove_bus_device to pci_stop_and_remove_bus_device
    
    The old pci_remove_bus_device actually did stop and remove.
    
    Make the name reflect that to reduce confusion.
    
    This patch is done by sed scripts and changes back some incorrect
    __pci_remove_bus_device changes.
    
    Suggested-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index d9723039e99a..a55e248618cd 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -330,7 +330,7 @@ static void remove_callback(struct device *dev)
 	struct pci_dev *pdev = to_pci_dev(dev);
 
 	mutex_lock(&pci_remove_rescan_mutex);
-	pci_remove_bus_device(pdev);
+	pci_stop_and_remove_bus_device(pdev);
 	mutex_unlock(&pci_remove_rescan_mutex);
 }
 

commit 2f320521a0d2d11fb857be09d05e2fbbf3ef8c13
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Jan 21 02:08:22 2012 -0800

    PCI: Make rescan bus increase bridge resource size if needed
    
    Current rescan will not touch bridge MMIO and IO.
    
    Try to reuse pci_assign_unassigned_bridge_resources(bridge) to update bridge
    resources, if child devices need more resources.
    
    Only do that for bridges whose children are all removed already; i.e. don't
    release resources that could already be in use by drivers on child devices.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index a3cd8cad532a..d9723039e99a 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -366,7 +366,10 @@ dev_bus_rescan_store(struct device *dev, struct device_attribute *attr,
 
 	if (val) {
 		mutex_lock(&pci_remove_rescan_mutex);
-		pci_rescan_bus(bus);
+		if (!pci_is_root_bus(bus) && list_empty(&bus->devices))
+			pci_rescan_bus_bridge_resize(bus->self);
+		else
+			pci_rescan_bus(bus);
 		mutex_unlock(&pci_remove_rescan_mutex);
 	}
 	return count;

commit c49c41a4134679cecb77362e7f6b59acb6320aa7
Merge: 892d208bcf79 f423e5ba76e7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 14 18:36:33 2012 -0800

    Merge branch 'for-linus' of git://selinuxproject.org/~jmorris/linux-security
    
    * 'for-linus' of git://selinuxproject.org/~jmorris/linux-security:
      capabilities: remove __cap_full_set definition
      security: remove the security_netlink_recv hook as it is equivalent to capable()
      ptrace: do not audit capability check when outputing /proc/pid/stat
      capabilities: remove task_ns_* functions
      capabitlies: ns_capable can use the cap helpers rather than lsm call
      capabilities: style only - move capable below ns_capable
      capabilites: introduce new has_ns_capabilities_noaudit
      capabilities: call has_ns_capability from has_capability
      capabilities: remove all _real_ interfaces
      capabilities: introduce security_capable_noaudit
      capabilities: reverse arguments to security_capable
      capabilities: remove the task from capable LSM hook entirely
      selinux: sparse fix: fix several warnings in the security server cod
      selinux: sparse fix: fix warnings in netlink code
      selinux: sparse fix: eliminate warnings for selinuxfs
      selinux: sparse fix: declare selinux_disable() in security.h
      selinux: sparse fix: move selinux_complete_init
      selinux: sparse fix: make selinux_secmark_refcount static
      SELinux: Fix RCU deref check warning in sel_netport_insert()
    
    Manually fix up a semantic mis-merge wrt security_netlink_recv():
    
     - the interface was removed in commit fd7784615248 ("security: remove
       the security_netlink_recv hook as it is equivalent to capable()")
    
     - a new user of it appeared in commit a38f7907b926 ("crypto: Add
       userspace configuration API")
    
    causing no automatic merge conflict, but Eric Paris pointed out the
    issue.

commit b7e724d303b684655e4ca3dabd5a6840ad19012d
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 12:25:15 2012 -0500

    capabilities: reverse arguments to security_capable
    
    security_capable takes ns, cred, cap.  But the LSM capable() hook takes
    cred, ns, cap.  The capability helper functions also take cred, ns, cap.
    Rather than flip argument order just to flip it back, leave them alone.
    Heck, this should be a little faster since argument will be in the right
    place!
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 7bcf12adced7..a4457ab61342 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -431,7 +431,7 @@ pci_read_config(struct file *filp, struct kobject *kobj,
 	u8 *data = (u8*) buf;
 
 	/* Several chips lock up trying to read undefined config space */
-	if (security_capable(&init_user_ns, filp->f_cred, CAP_SYS_ADMIN) == 0) {
+	if (security_capable(filp->f_cred, &init_user_ns, CAP_SYS_ADMIN) == 0) {
 		size = dev->cfg_size;
 	} else if (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS) {
 		size = 128;

commit 363c75db1d7bbda0aa90e680565f2673bab92ee4
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 27 09:37:25 2011 -0400

    pci: Fix files needing export.h for EXPORT_SYMBOL/THIS_MODULE
    
    They were implicitly getting it from device.h --> module.h but
    we want to clean that up.  So add the minimal header for these
    macros.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 7bcf12adced7..106be0d08f81 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -19,6 +19,7 @@
 #include <linux/sched.h>
 #include <linux/pci.h>
 #include <linux/stat.h>
+#include <linux/export.h>
 #include <linux/topology.h>
 #include <linux/mm.h>
 #include <linux/fs.h>

commit dc2c2c9dd513dec6c17df04e8abff795e20a5271
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 12 17:11:40 2011 -0700

    PCI/sysfs: move bus cpuaffinity to class dev_attrs
    
    Requested by Greg KH to fix a race condition in the creating of PCI bus
    cpuaffinity files.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index c690abc0e5b8..7bcf12adced7 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -108,6 +108,40 @@ static ssize_t local_cpulist_show(struct device *dev,
 	return len;
 }
 
+/*
+ * PCI Bus Class Devices
+ */
+static ssize_t pci_bus_show_cpuaffinity(struct device *dev,
+					int type,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int ret;
+	const struct cpumask *cpumask;
+
+	cpumask = cpumask_of_pcibus(to_pci_bus(dev));
+	ret = type ?
+		cpulist_scnprintf(buf, PAGE_SIZE-2, cpumask) :
+		cpumask_scnprintf(buf, PAGE_SIZE-2, cpumask);
+	buf[ret++] = '\n';
+	buf[ret] = '\0';
+	return ret;
+}
+
+static inline ssize_t pci_bus_show_cpumaskaffinity(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	return pci_bus_show_cpuaffinity(dev, 0, attr, buf);
+}
+
+static inline ssize_t pci_bus_show_cpulistaffinity(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	return pci_bus_show_cpuaffinity(dev, 1, attr, buf);
+}
+
 /* show resources */
 static ssize_t
 resource_show(struct device * dev, struct device_attribute *attr, char * buf)
@@ -370,6 +404,8 @@ struct device_attribute pcibus_dev_attrs[] = {
 #ifdef CONFIG_HOTPLUG
 	__ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, dev_bus_rescan_store),
 #endif
+	__ATTR(cpuaffinity, S_IRUGO, pci_bus_show_cpumaskaffinity, NULL),
+	__ATTR(cpulistaffinity, S_IRUGO, pci_bus_show_cpulistaffinity, NULL),
 	__ATTR_NULL,
 };
 

commit b9d320fcb6259baffaeaf93a5fce252cd09333d6
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 12 17:11:39 2011 -0700

    PCI: add rescan to /sys/.../pci_bus/.../
    
    After remove the device from /sys, we have to rescan all or
    find out the bridge and access /sys../device/rescan there.
    
    this patch add /sys/.../pci_bus/.../rescan. So user can rescan more easy.
    that is more clean and easy to understand.
    
    like after remove 0000:c4:00.0, you can rescan 0000:c4 directly.
    
    -v2: According to Jesse, use function instead of exposing attr, so could hide
            #ifdef in header file.
         also add code to remove rescan file in remove path.
    -v3: GregKH pointed out that we should use dev_attrs to avoid racing.
         So add pcibus_attrs and make it to be member of pcibus_attrs.
    -v4: Change name to pcibus_dev_attrs according to GregKH
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index f8deb3e380a2..c690abc0e5b8 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -318,6 +318,25 @@ remove_store(struct device *dev, struct device_attribute *dummy,
 		count = ret;
 	return count;
 }
+
+static ssize_t
+dev_bus_rescan_store(struct device *dev, struct device_attribute *attr,
+		 const char *buf, size_t count)
+{
+	unsigned long val;
+	struct pci_bus *bus = to_pci_bus(dev);
+
+	if (strict_strtoul(buf, 0, &val) < 0)
+		return -EINVAL;
+
+	if (val) {
+		mutex_lock(&pci_remove_rescan_mutex);
+		pci_rescan_bus(bus);
+		mutex_unlock(&pci_remove_rescan_mutex);
+	}
+	return count;
+}
+
 #endif
 
 struct device_attribute pci_dev_attrs[] = {
@@ -347,6 +366,13 @@ struct device_attribute pci_dev_attrs[] = {
 	__ATTR_NULL,
 };
 
+struct device_attribute pcibus_dev_attrs[] = {
+#ifdef CONFIG_HOTPLUG
+	__ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, dev_bus_rescan_store),
+#endif
+	__ATTR_NULL,
+};
+
 static ssize_t
 boot_vga_show(struct device *dev, struct device_attribute *attr, char *buf)
 {

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index a8a277a2e0d0..f8deb3e380a2 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -645,7 +645,7 @@ pci_adjust_legacy_attr(struct pci_bus *b, enum pci_mmap_state mmap_type)
  * a per-bus basis.  This routine creates the files and ties them into
  * their associated read, write and mmap files from pci-sysfs.c
  *
- * On error unwind, but don't propogate the error to the caller
+ * On error unwind, but don't propagate the error to the caller
  * as it is ok to set up the PCI bus without these files.
  */
 void pci_create_legacy_files(struct pci_bus *b)

commit 3486740a4f32a6a466f5ac931654d154790ba648
Author: Serge E. Hallyn <serge@hallyn.com>
Date:   Wed Mar 23 16:43:17 2011 -0700

    userns: security: make capabilities relative to the user namespace
    
    - Introduce ns_capable to test for a capability in a non-default
      user namespace.
    - Teach cap_capable to handle capabilities in a non-default
      user namespace.
    
    The motivation is to get to the unprivileged creation of new
    namespaces.  It looks like this gets us 90% of the way there, with
    only potential uid confusion issues left.
    
    I still need to handle getting all caps after creation but otherwise I
    think I have a good starter patch that achieves all of your goals.
    
    Changelog:
            11/05/2010: [serge] add apparmor
            12/14/2010: [serge] fix capabilities to created user namespaces
            Without this, if user serge creates a user_ns, he won't have
            capabilities to the user_ns he created.  THis is because we
            were first checking whether his effective caps had the caps
            he needed and returning -EPERM if not, and THEN checking whether
            he was the creator.  Reverse those checks.
            12/16/2010: [serge] security_real_capable needs ns argument in !security case
            01/11/2011: [serge] add task_ns_capable helper
            01/11/2011: [serge] add nsown_capable() helper per Bastian Blank suggestion
            02/16/2011: [serge] fix a logic bug: the root user is always creator of
                        init_user_ns, but should not always have capabilities to
                        it!  Fix the check in cap_capable().
            02/21/2011: Add the required user_ns parameter to security_capable,
                        fixing a compile failure.
            02/23/2011: Convert some macros to functions as per akpm comments.  Some
                        couldn't be converted because we can't easily forward-declare
                        them (they are inline if !SECURITY, extern if SECURITY).  Add
                        a current_user_ns function so we can use it in capability.h
                        without #including cred.h.  Move all forward declarations
                        together to the top of the #ifdef __KERNEL__ section, and use
                        kernel-doc format.
            02/23/2011: Per dhowells, clean up comment in cap_capable().
            02/23/2011: Per akpm, remove unreachable 'return -EPERM' in cap_capable.
    
    (Original written and signed off by Eric;  latest, modified version
    acked by him)
    
    [akpm@linux-foundation.org: fix build]
    [akpm@linux-foundation.org: export current_user_ns() for ecryptfs]
    [serge.hallyn@canonical.com: remove unneeded extra argument in selinux's task_has_capability]
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Serge E. Hallyn <serge.hallyn@canonical.com>
    Acked-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@free.fr>
    Acked-by: David Howells <dhowells@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Serge E. Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index c85438a367d5..a8a277a2e0d0 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -369,7 +369,7 @@ pci_read_config(struct file *filp, struct kobject *kobj,
 	u8 *data = (u8*) buf;
 
 	/* Several chips lock up trying to read undefined config space */
-	if (security_capable(filp->f_cred, CAP_SYS_ADMIN) == 0) {
+	if (security_capable(&init_user_ns, filp->f_cred, CAP_SYS_ADMIN) == 0) {
 		size = dev->cfg_size;
 	} else if (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS) {
 		size = 128;

commit 99759619b27662d1290901228d77a293e6e83200
Merge: b061c59c27e0 65d8defe2e13
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 18 10:56:44 2011 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6:
      PCI: label: remove #include of ACPI header to avoid warnings
      PCI: label: Fix compilation error when CONFIG_ACPI is unset
      PCI: pre-allocate additional resources to devices only after successful allocation of essential resources.
      PCI: introduce reset_resource()
      PCI: data structure agnostic free list function
      PCI: refactor io size calculation code
      PCI: do not create quirk I/O regions below PCIBIOS_MIN_IO for ICH
      PCI hotplug: acpiphp: set current_state to D0 in register_slot
      PCI: Export ACPI _DSM provided firmware instance number and string name to sysfs
      PCI: add more checking to ICH region quirks
      PCI: aer-inject: Override PCIe AER Mask Registers
      PCI: fix tlan build when CONFIG_PCI is not enabled
      PCI: remove quirk for pre-production systems
      PCI: Avoid potential NULL pointer dereference in pci_scan_bridge
      PCI/lpc: irq and pci_ids patch for Intel DH89xxCC DeviceIDs
      PCI: sysfs: Fix failure path for addition of "vpd" attribute

commit a628e7b87e100befac9702aa0c3b9848a7685e49
Author: Chris Wright <chrisw@sous-sol.org>
Date:   Mon Feb 14 17:21:49 2011 -0800

    pci: use security_capable() when checking capablities during config space read
    
    This reintroduces commit 47970b1b which was subsequently reverted
    as f00eaeea.  The original change was broken and caused X startup
    failures and generally made privileged processes incapable of reading
    device dependent config space.  The normal capable() interface returns
    true on success, but the LSM interface returns 0 on success.  This thinko
    is now fixed in this patch, and has been confirmed to work properly.
    
    So, once again...Eric Paris noted that commit de139a3 ("pci: check caps
    from sysfs file open to read device dependent config space") caused the
    capability check to bypass security modules and potentially auditing.
    Rectify this by calling security_capable() when checking the open file's
    capabilities for config space reads.
    
    Reported-by: Eric Paris <eparis@redhat.com>
    Tested-by: Dave Young <hidave.darkstar@gmail.com>
    Acked-by: James Morris <jmorris@namei.org>
    Cc: Dave Airlie <airlied@gmail.com>
    Cc: Alex Riesen <raa.lkml@gmail.com>
    Cc: Sedat Dilek <sedat.dilek@googlemail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 8ecaac983923..ea25e5bfcf23 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -23,6 +23,7 @@
 #include <linux/mm.h>
 #include <linux/fs.h>
 #include <linux/capability.h>
+#include <linux/security.h>
 #include <linux/pci-aspm.h>
 #include <linux/slab.h>
 #include "pci.h"
@@ -368,7 +369,7 @@ pci_read_config(struct file *filp, struct kobject *kobj,
 	u8 *data = (u8*) buf;
 
 	/* Several chips lock up trying to read undefined config space */
-	if (cap_raised(filp->f_cred->cap_effective, CAP_SYS_ADMIN)) {
+	if (security_capable(filp->f_cred, CAP_SYS_ADMIN) == 0) {
 		size = dev->cfg_size;
 	} else if (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS) {
 		size = 128;

commit f00eaeea7a42b5ea327e9ce8839cb0b53d3bdb4e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 13 07:50:50 2011 -0800

    Revert "pci: use security_capable() when checking capablities during config space read"
    
    This reverts commit 47970b1b2aa64464bc0a9543e86361a622ae7c03.
    
    It turns out it breaks several distributions.  Looks like the stricter
    selinux checks fail due to selinux policies not being set to allow the
    access - breaking X, but also lspci.
    
    So while the change was clearly the RightThing(tm) to do in theory, in
    practice we have backwards compatibility issues making it not work.
    
    Reported-by: Dave Young <hidave.darkstar@gmail.com>
    Acked-by: David Airlie <airlied@linux.ie>
    Acked-by: Alex Riesen <raa.lkml@gmail.com>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index f7771f336b7d..8ecaac983923 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -23,7 +23,6 @@
 #include <linux/mm.h>
 #include <linux/fs.h>
 #include <linux/capability.h>
-#include <linux/security.h>
 #include <linux/pci-aspm.h>
 #include <linux/slab.h>
 #include "pci.h"
@@ -369,7 +368,7 @@ pci_read_config(struct file *filp, struct kobject *kobj,
 	u8 *data = (u8*) buf;
 
 	/* Several chips lock up trying to read undefined config space */
-	if (security_capable(filp->f_cred, CAP_SYS_ADMIN)) {
+	if (cap_raised(filp->f_cred->cap_effective, CAP_SYS_ADMIN)) {
 		size = dev->cfg_size;
 	} else if (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS) {
 		size = 128;

commit 47970b1b2aa64464bc0a9543e86361a622ae7c03
Author: Chris Wright <chrisw@sous-sol.org>
Date:   Thu Feb 10 15:58:56 2011 -0800

    pci: use security_capable() when checking capablities during config space read
    
    Eric Paris noted that commit de139a3 ("pci: check caps from sysfs file
    open to read device dependent config space") caused the capability check
    to bypass security modules and potentially auditing.  Rectify this by
    calling security_capable() when checking the open file's capabilities
    for config space reads.
    
    Reported-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 8ecaac983923..f7771f336b7d 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -23,6 +23,7 @@
 #include <linux/mm.h>
 #include <linux/fs.h>
 #include <linux/capability.h>
+#include <linux/security.h>
 #include <linux/pci-aspm.h>
 #include <linux/slab.h>
 #include "pci.h"
@@ -368,7 +369,7 @@ pci_read_config(struct file *filp, struct kobject *kobj,
 	u8 *data = (u8*) buf;
 
 	/* Several chips lock up trying to read undefined config space */
-	if (cap_raised(filp->f_cred->cap_effective, CAP_SYS_ADMIN)) {
+	if (security_capable(filp->f_cred, CAP_SYS_ADMIN)) {
 		size = dev->cfg_size;
 	} else if (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS) {
 		size = 128;

commit 0f12a4e29368a9476076515881d9ef4e5876c6e2
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Thu Jan 13 19:47:56 2011 +0000

    PCI: sysfs: Fix failure path for addition of "vpd" attribute
    
    Commit 280c73d ("PCI: centralize the capabilities code in
    pci-sysfs.c") changed the initialisation of the "rom" and "vpd"
    attributes, and made the failure path for the "vpd" attribute
    incorrect.  We must free the new attribute structure (attr), but
    instead we currently free dev->vpd->attr.  That will normally be NULL,
    resulting in a memory leak, but it might be a stale pointer, resulting
    in a double-free.
    
    Found by inspection; compile-tested only.
    
    Cc: stable@kernel.org
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 8ecaac983923..cf2b3654b4a8 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1087,7 +1087,7 @@ static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 		attr->write = write_vpd_attr;
 		retval = sysfs_create_bin_file(&dev->dev.kobj, attr);
 		if (retval) {
-			kfree(dev->vpd->attr);
+			kfree(attr);
 			return retval;
 		}
 		dev->vpd->attr = attr;

commit ff29530e651a3449aea6b0ef4c7048db9e22ef27
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Wed Jan 5 10:26:41 2011 -0700

    PCI: sysfs: Update ROM to include default owner write access
    
    The PCI sysfs ROM interface requires an enabling write to access the ROM
    image, but the default file mode is 0400.  The original proposed patch
    adding sysfs ROM support was a true read-only interface, with the
    enabling bit coming in as a feature request.  I suspect it was simply an
    oversight that the file mode didn't get updated to match the API.
    
    Acked-by: Chris Wright <chrisw@redhat.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 63d5042f2079..8ecaac983923 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1149,7 +1149,7 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 		sysfs_bin_attr_init(attr);
 		attr->size = rom_size;
 		attr->attr.name = "rom";
-		attr->attr.mode = S_IRUSR;
+		attr->attr.mode = S_IRUSR | S_IWUSR;
 		attr->read = pci_read_rom;
 		attr->write = pci_write_rom;
 		retval = sysfs_create_bin_file(&pdev->dev.kobj, attr);

commit 8c05cd08a7504b855c265263e84af61aabafa329
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Tue Nov 16 09:13:41 2010 -0800

    PCI: fix offset check for sysfs mmapped files
    
    I just loaded 2.6.37-rc2 on my machines, and I noticed that X no longer starts.
    Running an strace of the X server shows that it's doing this:
    
    open("/sys/bus/pci/devices/0000:07:00.0/resource0", O_RDWR) = 10
    mmap(NULL, 16777216, PROT_READ|PROT_WRITE, MAP_SHARED, 10, 0) = -1 EINVAL (Invalid argument)
    
    This code seems to be asking for a shared read/write mapping of 16MB worth of
    BAR0 starting at file offset 0, and letting the kernel assign a starting
    address.  Unfortunately, this -EINVAL causes X not to start.  Looking into
    dmesg, there's a complaint like so:
    
    process "Xorg" tried to map 0x01000000 bytes at page 0x00000000 on 0000:07:00.0 BAR 0 (start 0x        96000000, size 0x         1000000)
    
    ...with the following code in pci_mmap_fits:
    
            pci_start = (mmap_api == PCI_MMAP_SYSFS) ?
                    pci_resource_start(pdev, resno) >> PAGE_SHIFT : 0;
            if (start >= pci_start && start < pci_start + size &&
                            start + nr <= pci_start + size)
    
    It looks like the logic here is set up such that when the mmap call comes via
    sysfs, the check in pci_mmap_fits wants vma->vm_pgoff to be between the
    resource's start and end address, and the end of the vma to be no farther than
    the end.  However, the sysfs PCI resource files always start at offset zero,
    which means that this test always fails for programs that mmap the sysfs files.
    Given the comment in the original commit
    3b519e4ea618b6943a82931630872907f9ac2c2b, I _think_ the old procfs files
    require that the file offset be equal to the resource's base address when
    mmapping.
    
    I think what we want here is for pci_start to be 0 when mmap_api ==
    PCI_MMAP_PROCFS.  The following patch makes that change, after which the Matrox
    and Mach64 X drivers work again.
    
    Acked-by: Martin Wilck <martin.wilck@ts.fujitsu.com>
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 95712a375cd5..63d5042f2079 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -715,7 +715,7 @@ int pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vma,
 	nr = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
 	start = vma->vm_pgoff;
 	size = ((pci_resource_len(pdev, resno) - 1) >> PAGE_SHIFT) + 1;
-	pci_start = (mmap_api == PCI_MMAP_SYSFS) ?
+	pci_start = (mmap_api == PCI_MMAP_PROCFS) ?
 			pci_resource_start(pdev, resno) >> PAGE_SHIFT : 0;
 	if (start >= pci_start && start < pci_start + size &&
 			start + nr <= pci_start + size)

commit e25cd062b16ed1d41a157aec5a108abd6ff2e9f9
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Sat Nov 13 08:44:33 2010 -0800

    PCI: sysfs: fix printk warnings
    
    Cast pci_resource_start() and pci_resource_len() to u64 for printk.
    
    drivers/pci/pci-sysfs.c:753: warning: format '%16Lx' expects type 'long long unsigned int', but argument 9 has type 'resource_size_t'
    drivers/pci/pci-sysfs.c:753: warning: format '%16Lx' expects type 'long long unsigned int', but argument 10 has type 'resource_size_t'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 25accc9dda3b..95712a375cd5 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -754,7 +754,8 @@ pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 			"at page 0x%08lx on %s BAR %d (start 0x%16Lx, size 0x%16Lx)\n",
 			current->comm, vma->vm_end-vma->vm_start, vma->vm_pgoff,
 			pci_name(pdev), i,
-			pci_resource_start(pdev, i), pci_resource_len(pdev, i));
+			(u64)pci_resource_start(pdev, i),
+			(u64)pci_resource_len(pdev, i));
 		return -EINVAL;
 	}
 

commit 3b519e4ea618b6943a82931630872907f9ac2c2b
Author: Martin Wilck <martin.wilck@ts.fujitsu.com>
Date:   Wed Nov 10 11:03:21 2010 +0100

    PCI: fix size checks for mmap() on /proc/bus/pci files
    
    The checks for valid mmaps of PCI resources made through /proc/bus/pci files
    that were introduced in 9eff02e2042f96fb2aedd02e032eca1c5333d767 have several
    problems:
    
    1. mmap() calls on /proc/bus/pci files are made with real file offsets > 0,
    whereas under /sys/bus/pci/devices, the start of the resource corresponds
    to offset 0. This may lead to false negatives in pci_mmap_fits(), which
    implicitly assumes the /sys/bus/pci/devices layout.
    
    2. The loop in proc_bus_pci_mmap doesn't skip empty resouces. This leads
    to false positives, because pci_mmap_fits() doesn't treat empty resources
    correctly (the calculated size is 1 << (8*sizeof(resource_size_t)-PAGE_SHIFT)
    in this case!).
    
    3. If a user maps resources with BAR > 0, pci_mmap_fits will emit bogus
    WARNINGS for the first resources that don't fit until the correct one is found.
    
    On many controllers the first 2-4 BARs are used, and the others are empty.
    In this case, an mmap attempt will first fail on the non-empty BARs
    (including the "right" BAR because of 1.) and emit bogus WARNINGS because
    of 3., and finally succeed on the first empty BAR because of 2.
    This is certainly not the intended behaviour.
    
    This patch addresses all 3 issues.
    Updated with an enum type for the additional parameter for pci_mmap_fits().
    
    Cc: stable@kernel.org
    Signed-off-by: Martin Wilck <martin.wilck@ts.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index b5a7d9bfcb24..25accc9dda3b 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -705,17 +705,21 @@ void pci_remove_legacy_files(struct pci_bus *b)
 
 #ifdef HAVE_PCI_MMAP
 
-int pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vma)
+int pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vma,
+		  enum pci_mmap_api mmap_api)
 {
-	unsigned long nr, start, size;
+	unsigned long nr, start, size, pci_start;
 
+	if (pci_resource_len(pdev, resno) == 0)
+		return 0;
 	nr = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
 	start = vma->vm_pgoff;
 	size = ((pci_resource_len(pdev, resno) - 1) >> PAGE_SHIFT) + 1;
-	if (start < size && size - start >= nr)
+	pci_start = (mmap_api == PCI_MMAP_SYSFS) ?
+			pci_resource_start(pdev, resno) >> PAGE_SHIFT : 0;
+	if (start >= pci_start && start < pci_start + size &&
+			start + nr <= pci_start + size)
 		return 1;
-	WARN(1, "process \"%s\" tried to map 0x%08lx-0x%08lx on %s BAR %d (size 0x%08lx)\n",
-		current->comm, start, start+nr, pci_name(pdev), resno, size);
 	return 0;
 }
 
@@ -745,8 +749,14 @@ pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 	if (i >= PCI_ROM_RESOURCE)
 		return -ENODEV;
 
-	if (!pci_mmap_fits(pdev, i, vma))
+	if (!pci_mmap_fits(pdev, i, vma, PCI_MMAP_SYSFS)) {
+		WARN(1, "process \"%s\" tried to map 0x%08lx bytes "
+			"at page 0x%08lx on %s BAR %d (start 0x%16Lx, size 0x%16Lx)\n",
+			current->comm, vma->vm_end-vma->vm_start, vma->vm_pgoff,
+			pci_name(pdev), i,
+			pci_resource_start(pdev, i), pci_resource_len(pdev, i));
 		return -EINVAL;
+	}
 
 	/* pci_mmap_page_range() expects the same kind of entry as coming
 	 * from /proc/bus/pci/ which is a "user visible" value. If this is

commit 911e1c9b05a8e3559a7aa89083930700a0b9e7ee
Author: Narendra K <Narendra_K@dell.com>
Date:   Mon Jul 26 05:56:50 2010 -0500

    PCI: export SMBIOS provided firmware instance and label to sysfs
    
    This patch exports SMBIOS provided firmware instance and label of
    onboard PCI devices to sysfs.  New files are:
      /sys/bus/pci/devices/.../label which contains the firmware name for
    the device in question, and
      /sys/bus/pci/devices/.../index which contains the firmware device type
    instance for the given device.
    
    Signed-off-by: Jordan Hargrave <jordan_hargrave@dell.com>
    Signed-off-by: Narendra K <narendra_k@dell.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index f7692dc531e4..b5a7d9bfcb24 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1165,6 +1165,8 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 	if (retval)
 		goto err_vga_file;
 
+	pci_create_firmware_label_files(pdev);
+
 	return 0;
 
 err_vga_file:
@@ -1232,6 +1234,9 @@ void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
 		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->rom_attr);
 		kfree(pdev->rom_attr);
 	}
+
+	pci_remove_firmware_label_files(pdev);
+
 }
 
 static int __init pci_sysfs_init(void)

commit 8633328be242677fdedc42052838dd0608e7f342
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Mon Jul 19 09:45:34 2010 -0600

    PCI: Allow read/write access to sysfs I/O port resources
    
    PCI sysfs resource files currently only allow mmap'ing.  On x86 this
    works fine for memory backed BARs, but doesn't work at all for I/O
    port backed BARs.  Add read/write to I/O port PCI sysfs resource
    files to allow userspace access to these device regions.
    
    Acked-by: Chris Wright <chrisw@redhat.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 5935b854917f..f7692dc531e4 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -778,6 +778,70 @@ pci_mmap_resource_wc(struct file *filp, struct kobject *kobj,
 	return pci_mmap_resource(kobj, attr, vma, 1);
 }
 
+static ssize_t
+pci_resource_io(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *attr, char *buf,
+		loff_t off, size_t count, bool write)
+{
+	struct pci_dev *pdev = to_pci_dev(container_of(kobj,
+						       struct device, kobj));
+	struct resource *res = attr->private;
+	unsigned long port = off;
+	int i;
+
+	for (i = 0; i < PCI_ROM_RESOURCE; i++)
+		if (res == &pdev->resource[i])
+			break;
+	if (i >= PCI_ROM_RESOURCE)
+		return -ENODEV;
+
+	port += pci_resource_start(pdev, i);
+
+	if (port > pci_resource_end(pdev, i))
+		return 0;
+
+	if (port + count - 1 > pci_resource_end(pdev, i))
+		return -EINVAL;
+
+	switch (count) {
+	case 1:
+		if (write)
+			outb(*(u8 *)buf, port);
+		else
+			*(u8 *)buf = inb(port);
+		return 1;
+	case 2:
+		if (write)
+			outw(*(u16 *)buf, port);
+		else
+			*(u16 *)buf = inw(port);
+		return 2;
+	case 4:
+		if (write)
+			outl(*(u32 *)buf, port);
+		else
+			*(u32 *)buf = inl(port);
+		return 4;
+	}
+	return -EINVAL;
+}
+
+static ssize_t
+pci_read_resource_io(struct file *filp, struct kobject *kobj,
+		     struct bin_attribute *attr, char *buf,
+		     loff_t off, size_t count)
+{
+	return pci_resource_io(filp, kobj, attr, buf, off, count, false);
+}
+
+static ssize_t
+pci_write_resource_io(struct file *filp, struct kobject *kobj,
+		      struct bin_attribute *attr, char *buf,
+		      loff_t off, size_t count)
+{
+	return pci_resource_io(filp, kobj, attr, buf, off, count, true);
+}
+
 /**
  * pci_remove_resource_files - cleanup resource files
  * @pdev: dev to cleanup
@@ -828,6 +892,10 @@ static int pci_create_attr(struct pci_dev *pdev, int num, int write_combine)
 			sprintf(res_attr_name, "resource%d", num);
 			res_attr->mmap = pci_mmap_resource_uc;
 		}
+		if (pci_resource_flags(pdev, num) & IORESOURCE_IO) {
+			res_attr->read = pci_read_resource_io;
+			res_attr->write = pci_write_resource_io;
+		}
 		res_attr->attr.name = res_attr_name;
 		res_attr->attr.mode = S_IRUSR | S_IWUSR;
 		res_attr->size = pci_resource_len(pdev, num);

commit a3f5835a8e0bd25ed15becd65e01aa3d5ac8d771
Author: Kulikov Vasiliy <segooon@gmail.com>
Date:   Tue Jun 29 14:15:28 2010 +0400

    PCI: pci-sysfs: remove casts from void*
    
    Remove unnesessary casts from void*.
    
    Signed-off-by: Kulikov Vasiliy <segooon@gmail.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index c9957f68ac9b..5935b854917f 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -734,7 +734,7 @@ pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 {
 	struct pci_dev *pdev = to_pci_dev(container_of(kobj,
 						       struct device, kobj));
-	struct resource *res = (struct resource *)attr->private;
+	struct resource *res = attr->private;
 	enum pci_mmap_state mmap_type;
 	resource_size_t start, end;
 	int i;

commit 3be434f0244ee059432f92de7e891ee514f41738
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Jun 11 13:08:37 2010 -0700

    Revert "PCI: create function symlinks in /sys/bus/pci/slots/N/"
    
    This reverts commit 75568f8094eb0333e9c2109b23cbc8b82d318a3c.
    
    Since they're just a convenience anyway, remove these symlinks since
    they're causing duplicate filename errors in the wild.
    
    Acked-by: Alex Chiang <achiang@canonical.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index afd2fbf7d797..c9957f68ac9b 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1035,39 +1035,6 @@ static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 	return retval;
 }
 
-static void pci_remove_slot_links(struct pci_dev *dev)
-{
-	char func[10];
-	struct pci_slot *slot;
-
-	sysfs_remove_link(&dev->dev.kobj, "slot");
-	list_for_each_entry(slot, &dev->bus->slots, list) {
-		if (slot->number != PCI_SLOT(dev->devfn))
-			continue;
-		snprintf(func, 10, "function%d", PCI_FUNC(dev->devfn));
-		sysfs_remove_link(&slot->kobj, func);
-	}
-}
-
-static int pci_create_slot_links(struct pci_dev *dev)
-{
-	int result = 0;
-	char func[10];
-	struct pci_slot *slot;
-
-	list_for_each_entry(slot, &dev->bus->slots, list) {
-		if (slot->number != PCI_SLOT(dev->devfn))
-			continue;
-		result = sysfs_create_link(&dev->dev.kobj, &slot->kobj, "slot");
-		if (result)
-			goto out;
-		snprintf(func, 10, "function%d", PCI_FUNC(dev->devfn));
-		result = sysfs_create_link(&slot->kobj, &dev->dev.kobj, func);
-	}
-out:
-	return result;
-}
-
 int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 {
 	int retval;
@@ -1130,8 +1097,6 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 	if (retval)
 		goto err_vga_file;
 
-	pci_create_slot_links(pdev);
-
 	return 0;
 
 err_vga_file:
@@ -1181,8 +1146,6 @@ void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
 	if (!sysfs_initialized)
 		return;
 
-	pci_remove_slot_links(pdev);
-
 	pci_remove_capabilities_sysfs(pdev);
 
 	if (pdev->cfg_size < PCI_CFG_SPACE_EXP_SIZE)

commit 6109e2ce2600e2db26cd0424bb9c6ed019723288
Merge: 0961d6581c87 ac81860ea073
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 21 18:58:52 2010 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (36 commits)
      PCI: hotplug: pciehp: Removed check for hotplug of display devices
      PCI: read memory ranges out of Broadcom CNB20LE host bridge
      PCI: Allow manual resource allocation for PCI hotplug bridges
      x86/PCI: make ACPI MCFG reserved error messages ACPI specific
      PCI hotplug: Use kmemdup
      PM/PCI: Update PCI power management documentation
      PCI: output FW warning in pci_read/write_vpd
      PCI: fix typos pci_device_dis/enable to pci_dis/enable_device in comments
      PCI quirks: disable msi on AMD rs4xx internal gfx bridges
      PCI: Disable MSI for MCP55 on P5N32-E SLI
      x86/PCI: irq and pci_ids patch for additional Intel Cougar Point DeviceIDs
      PCI: aerdrv: trivial cleanup for aerdrv_core.c
      PCI: aerdrv: trivial cleanup for aerdrv.c
      PCI: aerdrv: introduce default_downstream_reset_link
      PCI: aerdrv: rework find_aer_service
      PCI: aerdrv: remove is_downstream
      PCI: aerdrv: remove magical ROOT_ERR_STATUS_MASKS
      PCI: aerdrv: redefine PCI_ERR_ROOT_*_SRC
      PCI: aerdrv: rework do_recovery
      PCI: aerdrv: rework get_e_source()
      ...

commit de139a3393958c5adc75b7df7619d7e48d9ea559
Author: Chris Wright <chrisw@sous-sol.org>
Date:   Thu May 13 10:43:07 2010 -0700

    pci: check caps from sysfs file open to read device dependent config space
    
    The PCI config space bin_attr read handler has a hardcoded CAP_SYS_ADMIN
    check to verify privileges before allowing a user to read device
    dependent config space.  This is meant to protect from an unprivileged
    user potentially locking up the box.
    
    When assigning a PCI device directly to a guest with libvirt and KVM,
    the sysfs config space file is chown'd to the unprivileged user that
    the KVM guest will run as.  The guest needs to have full access to the
    device's config space since it's responsible for driving the device.
    However, despite being the owner of the sysfs file, the CAP_SYS_ADMIN
    check will not allow read access beyond the config header.
    
    With this patch we check privileges against the capabilities used when
    openining the sysfs file.  The allows a privileged process to open the
    file and hand it to an unprivileged process, and the unprivileged process
    can still read all of the config space.
    
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index ad44557e65c4..6309c5a2528f 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -21,6 +21,7 @@
 #include <linux/stat.h>
 #include <linux/topology.h>
 #include <linux/mm.h>
+#include <linux/fs.h>
 #include <linux/capability.h>
 #include <linux/pci-aspm.h>
 #include <linux/slab.h>
@@ -367,7 +368,7 @@ pci_read_config(struct file *filp, struct kobject *kobj,
 	u8 *data = (u8*) buf;
 
 	/* Several chips lock up trying to read undefined config space */
-	if (capable(CAP_SYS_ADMIN)) {
+	if (cap_raised(filp->f_cred->cap_effective, CAP_SYS_ADMIN)) {
 		size = dev->cfg_size;
 	} else if (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS) {
 		size = 128;

commit 2c3c8bea608866d8bd9dcf92657d57fdcac011c5
Author: Chris Wright <chrisw@sous-sol.org>
Date:   Wed May 12 18:28:57 2010 -0700

    sysfs: add struct file* to bin_attr callbacks
    
    This allows bin_attr->read,write,mmap callbacks to check file specific data
    (such as inode owner) as part of any privilege validation.
    
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index fad93983bfed..ad44557e65c4 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -357,7 +357,8 @@ boot_vga_show(struct device *dev, struct device_attribute *attr, char *buf)
 struct device_attribute vga_attr = __ATTR_RO(boot_vga);
 
 static ssize_t
-pci_read_config(struct kobject *kobj, struct bin_attribute *bin_attr,
+pci_read_config(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *bin_attr,
 		char *buf, loff_t off, size_t count)
 {
 	struct pci_dev *dev = to_pci_dev(container_of(kobj,struct device,kobj));
@@ -430,7 +431,8 @@ pci_read_config(struct kobject *kobj, struct bin_attribute *bin_attr,
 }
 
 static ssize_t
-pci_write_config(struct kobject *kobj, struct bin_attribute *bin_attr,
+pci_write_config(struct file* filp, struct kobject *kobj,
+		 struct bin_attribute *bin_attr,
 		 char *buf, loff_t off, size_t count)
 {
 	struct pci_dev *dev = to_pci_dev(container_of(kobj,struct device,kobj));
@@ -487,7 +489,8 @@ pci_write_config(struct kobject *kobj, struct bin_attribute *bin_attr,
 }
 
 static ssize_t
-read_vpd_attr(struct kobject *kobj, struct bin_attribute *bin_attr,
+read_vpd_attr(struct file *filp, struct kobject *kobj,
+	      struct bin_attribute *bin_attr,
 	      char *buf, loff_t off, size_t count)
 {
 	struct pci_dev *dev =
@@ -502,7 +505,8 @@ read_vpd_attr(struct kobject *kobj, struct bin_attribute *bin_attr,
 }
 
 static ssize_t
-write_vpd_attr(struct kobject *kobj, struct bin_attribute *bin_attr,
+write_vpd_attr(struct file *filp, struct kobject *kobj,
+	       struct bin_attribute *bin_attr,
 	       char *buf, loff_t off, size_t count)
 {
 	struct pci_dev *dev =
@@ -519,6 +523,7 @@ write_vpd_attr(struct kobject *kobj, struct bin_attribute *bin_attr,
 #ifdef HAVE_PCI_LEGACY
 /**
  * pci_read_legacy_io - read byte(s) from legacy I/O port space
+ * @filp: open sysfs file
  * @kobj: kobject corresponding to file to read from
  * @bin_attr: struct bin_attribute for this file
  * @buf: buffer to store results
@@ -529,7 +534,8 @@ write_vpd_attr(struct kobject *kobj, struct bin_attribute *bin_attr,
  * callback routine (pci_legacy_read).
  */
 static ssize_t
-pci_read_legacy_io(struct kobject *kobj, struct bin_attribute *bin_attr,
+pci_read_legacy_io(struct file *filp, struct kobject *kobj,
+		   struct bin_attribute *bin_attr,
 		   char *buf, loff_t off, size_t count)
 {
         struct pci_bus *bus = to_pci_bus(container_of(kobj,
@@ -545,6 +551,7 @@ pci_read_legacy_io(struct kobject *kobj, struct bin_attribute *bin_attr,
 
 /**
  * pci_write_legacy_io - write byte(s) to legacy I/O port space
+ * @filp: open sysfs file
  * @kobj: kobject corresponding to file to read from
  * @bin_attr: struct bin_attribute for this file
  * @buf: buffer containing value to be written
@@ -555,7 +562,8 @@ pci_read_legacy_io(struct kobject *kobj, struct bin_attribute *bin_attr,
  * callback routine (pci_legacy_write).
  */
 static ssize_t
-pci_write_legacy_io(struct kobject *kobj, struct bin_attribute *bin_attr,
+pci_write_legacy_io(struct file *filp, struct kobject *kobj,
+		    struct bin_attribute *bin_attr,
 		    char *buf, loff_t off, size_t count)
 {
         struct pci_bus *bus = to_pci_bus(container_of(kobj,
@@ -570,6 +578,7 @@ pci_write_legacy_io(struct kobject *kobj, struct bin_attribute *bin_attr,
 
 /**
  * pci_mmap_legacy_mem - map legacy PCI memory into user memory space
+ * @filp: open sysfs file
  * @kobj: kobject corresponding to device to be mapped
  * @attr: struct bin_attribute for this file
  * @vma: struct vm_area_struct passed to mmap
@@ -579,7 +588,8 @@ pci_write_legacy_io(struct kobject *kobj, struct bin_attribute *bin_attr,
  * memory space.
  */
 static int
-pci_mmap_legacy_mem(struct kobject *kobj, struct bin_attribute *attr,
+pci_mmap_legacy_mem(struct file *filp, struct kobject *kobj,
+		    struct bin_attribute *attr,
                     struct vm_area_struct *vma)
 {
         struct pci_bus *bus = to_pci_bus(container_of(kobj,
@@ -591,6 +601,7 @@ pci_mmap_legacy_mem(struct kobject *kobj, struct bin_attribute *attr,
 
 /**
  * pci_mmap_legacy_io - map legacy PCI IO into user memory space
+ * @filp: open sysfs file
  * @kobj: kobject corresponding to device to be mapped
  * @attr: struct bin_attribute for this file
  * @vma: struct vm_area_struct passed to mmap
@@ -600,7 +611,8 @@ pci_mmap_legacy_mem(struct kobject *kobj, struct bin_attribute *attr,
  * memory space. Returns -ENOSYS if the operation isn't supported
  */
 static int
-pci_mmap_legacy_io(struct kobject *kobj, struct bin_attribute *attr,
+pci_mmap_legacy_io(struct file *filp, struct kobject *kobj,
+		   struct bin_attribute *attr,
 		   struct vm_area_struct *vma)
 {
         struct pci_bus *bus = to_pci_bus(container_of(kobj,
@@ -750,14 +762,16 @@ pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 }
 
 static int
-pci_mmap_resource_uc(struct kobject *kobj, struct bin_attribute *attr,
+pci_mmap_resource_uc(struct file *filp, struct kobject *kobj,
+		     struct bin_attribute *attr,
 		     struct vm_area_struct *vma)
 {
 	return pci_mmap_resource(kobj, attr, vma, 0);
 }
 
 static int
-pci_mmap_resource_wc(struct kobject *kobj, struct bin_attribute *attr,
+pci_mmap_resource_wc(struct file *filp, struct kobject *kobj,
+		     struct bin_attribute *attr,
 		     struct vm_area_struct *vma)
 {
 	return pci_mmap_resource(kobj, attr, vma, 1);
@@ -861,6 +875,7 @@ void __weak pci_remove_resource_files(struct pci_dev *dev) { return; }
 
 /**
  * pci_write_rom - used to enable access to the PCI ROM display
+ * @filp: sysfs file
  * @kobj: kernel object handle
  * @bin_attr: struct bin_attribute for this file
  * @buf: user input
@@ -870,7 +885,8 @@ void __weak pci_remove_resource_files(struct pci_dev *dev) { return; }
  * writing anything except 0 enables it
  */
 static ssize_t
-pci_write_rom(struct kobject *kobj, struct bin_attribute *bin_attr,
+pci_write_rom(struct file *filp, struct kobject *kobj,
+	      struct bin_attribute *bin_attr,
 	      char *buf, loff_t off, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(container_of(kobj, struct device, kobj));
@@ -885,6 +901,7 @@ pci_write_rom(struct kobject *kobj, struct bin_attribute *bin_attr,
 
 /**
  * pci_read_rom - read a PCI ROM
+ * @filp: sysfs file
  * @kobj: kernel object handle
  * @bin_attr: struct bin_attribute for this file
  * @buf: where to put the data we read from the ROM
@@ -895,7 +912,8 @@ pci_write_rom(struct kobject *kobj, struct bin_attribute *bin_attr,
  * device corresponding to @kobj.
  */
 static ssize_t
-pci_read_rom(struct kobject *kobj, struct bin_attribute *bin_attr,
+pci_read_rom(struct file *filp, struct kobject *kobj,
+	     struct bin_attribute *bin_attr,
 	     char *buf, loff_t off, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(container_of(kobj, struct device, kobj));

commit 447c5dd7338638f526e9bcf7dcf69b4da5835c7d
Author: Michal Schmidt <mschmidt@redhat.com>
Date:   Tue May 11 11:44:54 2010 +0200

    PCI: return correct value when writing to the "reset" attribute
    
    A successful write() to the "reset" sysfs attribute should return the
    number of bytes written, not 0. Otherwise userspace (bash) retries the
    write over and over again.
    
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Michal Schmidt <mschmidt@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 941e939d1da9..89a08ed39c94 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -960,7 +960,12 @@ static ssize_t reset_store(struct device *dev,
 
 	if (val != 1)
 		return -EINVAL;
-	return pci_reset_function(pdev);
+
+	result = pci_reset_function(pdev);
+	if (result < 0)
+		return result;
+
+	return count;
 }
 
 static struct device_attribute reset_attr = __ATTR(reset, 0200, NULL, reset_store);

commit 75568f8094eb0333e9c2109b23cbc8b82d318a3c
Author: Alex Chiang <achiang@hp.com>
Date:   Mon Mar 8 10:24:29 2010 -0700

    PCI: create function symlinks in /sys/bus/pci/slots/N/
    
    Create convenience symlinks in sysfs, linking slots to device
    functions, and vice versa. These links make it easier for users to
    figure out which devices actually live in what slots.
    
    For example:
    
    sapphire:/sys/bus/pci/slots # ls
    1  10  2  3  4  5  6  7  8  9
    
    sapphire:/sys/bus/pci/slots # ls -l 3
    total 0
    -r--r--r-- 1 root root 65536 Aug 18 14:10 address
    lrwxrwxrwx 1 root root     0 Aug 18 14:10 function0 ->
    ../../../../devices/pci0000:23/0000:23:01.0
    lrwxrwxrwx 1 root root     0 Aug 18 14:10 function1 ->
    ../../../../devices/pci0000:23/0000:23:01.1
    
    sapphire:/sys/bus/pci/slots # ls -l 3/function0/slot
    lrwxrwxrwx 1 root root 0 Aug 18 14:13 3/function0/slot ->
    ../../../bus/pci/slots/3
    
    The original form of this patch was written by Matthew Wilcox,
    and was enhanced to include links from the sysfs slots/ directory
    pointing back at the device functions.
    
    Cc: willy@linux.intel.com
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index fad93983bfed..941e939d1da9 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1011,6 +1011,39 @@ static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 	return retval;
 }
 
+static void pci_remove_slot_links(struct pci_dev *dev)
+{
+	char func[10];
+	struct pci_slot *slot;
+
+	sysfs_remove_link(&dev->dev.kobj, "slot");
+	list_for_each_entry(slot, &dev->bus->slots, list) {
+		if (slot->number != PCI_SLOT(dev->devfn))
+			continue;
+		snprintf(func, 10, "function%d", PCI_FUNC(dev->devfn));
+		sysfs_remove_link(&slot->kobj, func);
+	}
+}
+
+static int pci_create_slot_links(struct pci_dev *dev)
+{
+	int result = 0;
+	char func[10];
+	struct pci_slot *slot;
+
+	list_for_each_entry(slot, &dev->bus->slots, list) {
+		if (slot->number != PCI_SLOT(dev->devfn))
+			continue;
+		result = sysfs_create_link(&dev->dev.kobj, &slot->kobj, "slot");
+		if (result)
+			goto out;
+		snprintf(func, 10, "function%d", PCI_FUNC(dev->devfn));
+		result = sysfs_create_link(&slot->kobj, &dev->dev.kobj, func);
+	}
+out:
+	return result;
+}
+
 int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 {
 	int retval;
@@ -1073,6 +1106,8 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 	if (retval)
 		goto err_vga_file;
 
+	pci_create_slot_links(pdev);
+
 	return 0;
 
 err_vga_file:
@@ -1122,6 +1157,8 @@ void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
 	if (!sysfs_initialized)
 		return;
 
+	pci_remove_slot_links(pdev);
+
 	pci_remove_capabilities_sysfs(pdev);
 
 	if (pdev->cfg_size < PCI_CFG_SPACE_EXP_SIZE)

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 997668558e79..fad93983bfed 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -23,6 +23,7 @@
 #include <linux/mm.h>
 #include <linux/capability.h>
 #include <linux/pci-aspm.h>
+#include <linux/slab.h>
 #include "pci.h"
 
 static int sysfs_initialized;	/* = 0 */

commit 6757eca348fbbdd4ab1020e565f325cd6a6b2698
Author: Mel Gorman <mel@csn.ul.ie>
Date:   Wed Mar 10 22:48:34 2010 +0000

    sysfs: Initialised pci bus legacy_mem field before use
    
    PPC64 is failing to boot the latest mmotm due to an uninitialised pointer in
    pci_create_legacy_files(). The surprise is that machines boot at all and it
    would appear to affect current mainline as well.  This patch fixes the problem.
    
    Signed-off-by: Mel Gorman <mel@csn.ul.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index de296452c957..997668558e79 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -655,8 +655,8 @@ void pci_create_legacy_files(struct pci_bus *b)
 		goto legacy_io_err;
 
 	/* Allocated above after the legacy_io struct */
-	sysfs_bin_attr_init(b->legacy_mem);
 	b->legacy_mem = b->legacy_io + 1;
+	sysfs_bin_attr_init(b->legacy_mem);
 	b->legacy_mem->attr.name = "legacy_mem";
 	b->legacy_mem->size = 1024*1024;
 	b->legacy_mem->attr.mode = S_IRUSR | S_IWUSR;

commit 62e877b893e6350c900d381f353aa62ed48dcc97
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Mon Mar 1 20:38:36 2010 +1100

    sysfs: fix for thinko with sysfs_bin_attr_init()
    
    After merging the final tree, today's linux-next build (powerpc
    allyesconfig) failed like this:
    
    drivers/pci/pci-sysfs.c: In function 'pci_create_legacy_files':
    drivers/pci/pci-sysfs.c:645: error: lvalue required as unary '&' operand
    drivers/pci/pci-sysfs.c:658: error: lvalue required as unary '&' operand
    
    Caused by commit "sysfs: Use sysfs_attr_init and sysfs_bin_attr_init on
    dynamic attributes" interacting with commit "sysfs: Use one lockdep
    class per sysfs attribute") both from the driver-core tree.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 9fa183cfb0e9..de296452c957 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -642,7 +642,7 @@ void pci_create_legacy_files(struct pci_bus *b)
 	if (!b->legacy_io)
 		goto kzalloc_err;
 
-	sysfs_bin_attr_init(&b->legacy_io);
+	sysfs_bin_attr_init(b->legacy_io);
 	b->legacy_io->attr.name = "legacy_io";
 	b->legacy_io->size = 0xffff;
 	b->legacy_io->attr.mode = S_IRUSR | S_IWUSR;
@@ -655,7 +655,7 @@ void pci_create_legacy_files(struct pci_bus *b)
 		goto legacy_io_err;
 
 	/* Allocated above after the legacy_io struct */
-	sysfs_bin_attr_init(&b->legacy_mem);
+	sysfs_bin_attr_init(b->legacy_mem);
 	b->legacy_mem = b->legacy_io + 1;
 	b->legacy_mem->attr.name = "legacy_mem";
 	b->legacy_mem->size = 1024*1024;

commit a07e4156a2ee6359d31a44946d7ee7f85dbf6bca
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Feb 11 15:23:05 2010 -0800

    sysfs: Use sysfs_attr_init and sysfs_bin_attr_init on dynamic attributes
    
    These are the non-static sysfs attributes that exist on
    my test machine.  Fix them to use sysfs_attr_init or
    sysfs_bin_attr_init as appropriate.   It simply requires
    making a sysfs attribute present to see this.  So this
    is a little bit tedious but otherwise not too bad.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Acked-by: WANG Cong <xiyou.wangcong@gmail.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 807224ec8351..9fa183cfb0e9 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -642,6 +642,7 @@ void pci_create_legacy_files(struct pci_bus *b)
 	if (!b->legacy_io)
 		goto kzalloc_err;
 
+	sysfs_bin_attr_init(&b->legacy_io);
 	b->legacy_io->attr.name = "legacy_io";
 	b->legacy_io->size = 0xffff;
 	b->legacy_io->attr.mode = S_IRUSR | S_IWUSR;
@@ -654,6 +655,7 @@ void pci_create_legacy_files(struct pci_bus *b)
 		goto legacy_io_err;
 
 	/* Allocated above after the legacy_io struct */
+	sysfs_bin_attr_init(&b->legacy_mem);
 	b->legacy_mem = b->legacy_io + 1;
 	b->legacy_mem->attr.name = "legacy_mem";
 	b->legacy_mem->size = 1024*1024;
@@ -800,6 +802,7 @@ static int pci_create_attr(struct pci_dev *pdev, int num, int write_combine)
 	if (res_attr) {
 		char *res_attr_name = (char *)(res_attr + 1);
 
+		sysfs_bin_attr_init(res_attr);
 		if (write_combine) {
 			pdev->res_attr_wc[num] = res_attr;
 			sprintf(res_attr_name, "resource%d_wc", num);
@@ -972,6 +975,7 @@ static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 		if (!attr)
 			return -ENOMEM;
 
+		sysfs_bin_attr_init(attr);
 		attr->size = dev->vpd->len;
 		attr->attr.name = "vpd";
 		attr->attr.mode = S_IRUSR | S_IWUSR;
@@ -1038,6 +1042,7 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 			retval = -ENOMEM;
 			goto err_resource_files;
 		}
+		sysfs_bin_attr_init(attr);
 		attr->size = rom_size;
 		attr->attr.name = "rom";
 		attr->attr.mode = S_IRUSR;

commit 6be954d1f91b81ca85c74792b13654069278c577
Author: David John <davidjon@xenontk.org>
Date:   Mon Jan 4 20:28:57 2010 +0530

    PCI: Check the node argument passed to cpumask_of_node
    
    Commit e0cd516 "PCI: derive nearby CPUs from device's instead of bus'
    NUMA information" causes an null pointer dereference when reading from
    the sysfs attributes local_cpu* on Intel machines with no ACPI NUMA
    proximity info, since dev->numa_node gets set to -1 for all PCI devices,
    which then gets passed to cpumask_of_node.
    
    Add a check to prevent this.
    
    Signed-off-by: David John <davidjon@xenontk.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index c5df94e86678..807224ec8351 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -75,7 +75,8 @@ static ssize_t local_cpus_show(struct device *dev,
 	int len;
 
 #ifdef CONFIG_NUMA
-	mask = cpumask_of_node(dev_to_node(dev));
+	mask = (dev_to_node(dev) == -1) ? cpu_online_mask :
+					  cpumask_of_node(dev_to_node(dev));
 #else
 	mask = cpumask_of_pcibus(to_pci_dev(dev)->bus);
 #endif
@@ -93,7 +94,8 @@ static ssize_t local_cpulist_show(struct device *dev,
 	int len;
 
 #ifdef CONFIG_NUMA
-	mask = cpumask_of_node(dev_to_node(dev));
+	mask = (dev_to_node(dev) == -1) ? cpu_online_mask :
+					  cpumask_of_node(dev_to_node(dev));
 #else
 	mask = cpumask_of_pcibus(to_pci_dev(dev)->bus);
 #endif

commit bb965401fd2afa26629b244e7bb2e48a117dc238
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Tue Nov 24 18:21:21 2009 -0800

    PCI: show dma_mask bits in /sys
    
    So we can catch if the driver sets an incorrect dma_mask.
    
    Reviewed-by: Grant Grundler <grundler@google.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 0fa707e2a0f8..c5df94e86678 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -183,6 +183,21 @@ numa_node_show(struct device *dev, struct device_attribute *attr, char *buf)
 }
 #endif
 
+static ssize_t
+dma_mask_bits_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	return sprintf (buf, "%d\n", fls64(pdev->dma_mask));
+}
+
+static ssize_t
+consistent_dma_mask_bits_show(struct device *dev, struct device_attribute *attr,
+				 char *buf)
+{
+	return sprintf (buf, "%d\n", fls64(dev->coherent_dma_mask));
+}
+
 static ssize_t
 msi_bus_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
@@ -314,6 +329,8 @@ struct device_attribute pci_dev_attrs[] = {
 #ifdef CONFIG_NUMA
 	__ATTR_RO(numa_node),
 #endif
+	__ATTR_RO(dma_mask_bits),
+	__ATTR_RO(consistent_dma_mask_bits),
 	__ATTR(enable, 0600, is_enabled_show, is_enabled_store),
 	__ATTR(broken_parity_status,(S_IRUGO|S_IWUSR),
 		broken_parity_status_show,broken_parity_status_store),

commit e0cd5160346f5b88fe536f529066f102518f8acd
Author: Andreas Herrmann <andreas.herrmann3@amd.com>
Date:   Fri Apr 17 12:01:55 2009 +0200

    PCI: derive nearby CPUs from device's instead of bus' NUMA information
    
    In case of AMD CPU northbridge functions this NUMA information might
    differ.  Here is an example from a 4-socket system.
    
    Currently Linux shows
    
      root@hagen:/sys/devices/pci0000:00/0000:00:1a.4# cat numa_node
      0
      root@hagen:/sys/devices/pci0000:00/0000:00:1a.4# cat local_cpu*
      0-3
      00000000,0000000f
    
    which is not correct for northbridge functions as the local CPUs
    are those of the same socket.
    
    With this patch and a quirk for AMD CPU NB functions Linux can
    do better and correctly show
    
      root@hagen:/sys/devices/pci0000:00/0000:00:1a.4# cat numa_node
      2
      root@hagen:/sys/devices/pci0000:00/0000:00:1a.4# cat local_cpu*
      8-11
      00000000,00000f00
    
    Signed-off-by: Andreas Herrmann <andreas.herrmann3@amd.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 0f6382f090ee..0fa707e2a0f8 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -74,7 +74,11 @@ static ssize_t local_cpus_show(struct device *dev,
 	const struct cpumask *mask;
 	int len;
 
+#ifdef CONFIG_NUMA
+	mask = cpumask_of_node(dev_to_node(dev));
+#else
 	mask = cpumask_of_pcibus(to_pci_dev(dev)->bus);
+#endif
 	len = cpumask_scnprintf(buf, PAGE_SIZE-2, mask);
 	buf[len++] = '\n';
 	buf[len] = '\0';
@@ -88,7 +92,11 @@ static ssize_t local_cpulist_show(struct device *dev,
 	const struct cpumask *mask;
 	int len;
 
+#ifdef CONFIG_NUMA
+	mask = cpumask_of_node(dev_to_node(dev));
+#else
 	mask = cpumask_of_pcibus(to_pci_dev(dev)->bus);
+#endif
 	len = cpulist_scnprintf(buf, PAGE_SIZE-2, mask);
 	buf[len++] = '\n';
 	buf[len] = '\0';

commit 711d57796f5ce2d02d6e62c9034afbb16aedda31
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Mon Jul 27 23:37:48 2009 +0300

    PCI: expose function reset capability in sysfs
    
    Some devices allow an individual function to be reset without affecting
    other functions in the same device: that's what pci_reset_function does.
    For devices that have this support, expose reset attribite in sysfs.
    
    This is useful e.g. for virtualization, where a qemu userspace
    process wants to reset the device when the guest is reset,
    to emulate machine reboot as closely as possible.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 85ebd02a64a7..0f6382f090ee 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -916,6 +916,24 @@ int __attribute__ ((weak)) pcibios_add_platform_entries(struct pci_dev *dev)
 	return 0;
 }
 
+static ssize_t reset_store(struct device *dev,
+			   struct device_attribute *attr, const char *buf,
+			   size_t count)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	unsigned long val;
+	ssize_t result = strict_strtoul(buf, 0, &val);
+
+	if (result < 0)
+		return result;
+
+	if (val != 1)
+		return -EINVAL;
+	return pci_reset_function(pdev);
+}
+
+static struct device_attribute reset_attr = __ATTR(reset, 0200, NULL, reset_store);
+
 static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 {
 	int retval;
@@ -943,7 +961,22 @@ static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 	/* Active State Power Management */
 	pcie_aspm_create_sysfs_dev_files(dev);
 
+	if (!pci_probe_reset_function(dev)) {
+		retval = device_create_file(&dev->dev, &reset_attr);
+		if (retval)
+			goto error;
+		dev->reset_fn = 1;
+	}
 	return 0;
+
+error:
+	pcie_aspm_remove_sysfs_dev_files(dev);
+	if (dev->vpd && dev->vpd->attr) {
+		sysfs_remove_bin_file(&dev->dev.kobj, dev->vpd->attr);
+		kfree(dev->vpd->attr);
+	}
+
+	return retval;
 }
 
 int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
@@ -1037,6 +1070,10 @@ static void pci_remove_capabilities_sysfs(struct pci_dev *dev)
 	}
 
 	pcie_aspm_remove_sysfs_dev_files(dev);
+	if (dev->reset_fn) {
+		device_remove_file(&dev->dev, &reset_attr);
+		dev->reset_fn = 0;
+	}
 }
 
 /**

commit cffb2fafb726c898fec1c5ae33717741f94fda83
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri Apr 10 15:17:50 2009 -0700

    docbooks: add/fix PCI kernel-doc
    
    Add drivers/pci/*.c source files to DocBook/kernel-api.tmpl
    and update those pci/*.c source files that need kernel-doc fixes.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index a7eb1b46a5a8..85ebd02a64a7 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -492,6 +492,7 @@ write_vpd_attr(struct kobject *kobj, struct bin_attribute *bin_attr,
 /**
  * pci_read_legacy_io - read byte(s) from legacy I/O port space
  * @kobj: kobject corresponding to file to read from
+ * @bin_attr: struct bin_attribute for this file
  * @buf: buffer to store results
  * @off: offset into legacy I/O port space
  * @count: number of bytes to read
@@ -517,6 +518,7 @@ pci_read_legacy_io(struct kobject *kobj, struct bin_attribute *bin_attr,
 /**
  * pci_write_legacy_io - write byte(s) to legacy I/O port space
  * @kobj: kobject corresponding to file to read from
+ * @bin_attr: struct bin_attribute for this file
  * @buf: buffer containing value to be written
  * @off: offset into legacy I/O port space
  * @count: number of bytes to write
@@ -733,9 +735,9 @@ pci_mmap_resource_wc(struct kobject *kobj, struct bin_attribute *attr,
 
 /**
  * pci_remove_resource_files - cleanup resource files
- * @dev: dev to cleanup
+ * @pdev: dev to cleanup
  *
- * If we created resource files for @dev, remove them from sysfs and
+ * If we created resource files for @pdev, remove them from sysfs and
  * free their resources.
  */
 static void
@@ -793,9 +795,9 @@ static int pci_create_attr(struct pci_dev *pdev, int num, int write_combine)
 
 /**
  * pci_create_resource_files - create resource files in sysfs for @dev
- * @dev: dev in question
+ * @pdev: dev in question
  *
- * Walk the resources in @dev creating files for each resource available.
+ * Walk the resources in @pdev creating files for each resource available.
  */
 static int pci_create_resource_files(struct pci_dev *pdev)
 {
@@ -829,6 +831,7 @@ void __weak pci_remove_resource_files(struct pci_dev *dev) { return; }
 /**
  * pci_write_rom - used to enable access to the PCI ROM display
  * @kobj: kernel object handle
+ * @bin_attr: struct bin_attribute for this file
  * @buf: user input
  * @off: file offset
  * @count: number of byte in input
@@ -852,6 +855,7 @@ pci_write_rom(struct kobject *kobj, struct bin_attribute *bin_attr,
 /**
  * pci_read_rom - read a PCI ROM
  * @kobj: kernel object handle
+ * @bin_attr: struct bin_attribute for this file
  * @buf: where to put the data we read from the ROM
  * @off: file offset
  * @count: number of bytes to read

commit c2ac7cdc6707a8a3fc5cdaebb65cb724ba8ecdef
Author: Alex Chiang <achiang@hp.com>
Date:   Mon Mar 30 10:50:09 2009 -0600

    PCI: allow PCI core hotplug to remove PCI root bus
    
    There is no reason to prevent removal of root bus devices. A subsequent
    rescan will find them just fine.
    
    Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index cd8e682c04aa..a7eb1b46a5a8 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -277,14 +277,10 @@ remove_store(struct device *dev, struct device_attribute *dummy,
 {
 	int ret = 0;
 	unsigned long val;
-	struct pci_dev *pdev = to_pci_dev(dev);
 
 	if (strict_strtoul(buf, 0, &val) < 0)
 		return -EINVAL;
 
-	if (pci_is_root_bus(pdev->bus))
-		return -EBUSY;
-
 	/* An attribute cannot be unregistered by one of its own methods,
 	 * so we have to use this roundabout approach.
 	 */

commit 296ccb086dfb89b5b8d73ef08c795ffdff12a597
Author: Yuji Shimada <shimada-yxb@necst.nec.co.jp>
Date:   Fri Apr 3 16:41:46 2009 +0900

    PCI: Setup disabled bridges even if buses are added
    
    This patch sets up disabled bridges even if buses have already been
    added.
    
    pci_assign_unassigned_resources is called after buses are added.
    pci_assign_unassigned_resources calls pci_bus_assign_resources.
    pci_bus_assign_resources calls pci_setup_bridge to configure BARs of
    bridges.
    
    Currently pci_setup_bridge returns immediately if the bus have already
    been added. So pci_assign_unassigned_resources can't configure BARs of
    bridges that were added in a disabled state; this patch fixes the issue.
    
    On logical hot-add, we need to prevent the kernel from re-initializing
    bridges that have already been initialized. To achieve this,
    pci_setup_bridge returns immediately if the bridge have already been
    enabled.
    
    We don't need to check whether the specified bus is a root bus or not.
    pci_setup_bridge is not called on a root bus, because a root bus does
    not have a bridge.
    
    The patch adds a new helper function, pci_is_enabled. I made the
    function name similar to pci_is_managed. The codes which use
    enable_cnt directly are changed to use pci_is_enabled.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Yuji Shimada <shimada-yxb@necst.nec.co.jp>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index e9a8706a6401..cd8e682c04aa 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -148,7 +148,7 @@ static ssize_t is_enabled_store(struct device *dev,
 		return -EPERM;
 
 	if (!val) {
-		if (atomic_read(&pdev->enable_cnt) != 0)
+		if (pci_is_enabled(pdev))
 			pci_disable_device(pdev);
 		else
 			result = -EIO;

commit 738a6396c223b486304dda778119dbbca563f019
Author: Alex Chiang <achiang@hp.com>
Date:   Fri Mar 20 14:56:41 2009 -0600

    PCI: Introduce /sys/bus/pci/devices/.../rescan
    
    This interface allows the user to force a rescan of the device's
    parent bus and all subordinate buses, and rediscover devices removed
    earlier from this part of the device tree.
    
    Cc: Trent Piepho <xyzzy@speakeasy.org>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index e16990ecc024..e9a8706a6401 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -244,6 +244,24 @@ struct bus_attribute pci_bus_attrs[] = {
 	__ATTR_NULL
 };
 
+static ssize_t
+dev_rescan_store(struct device *dev, struct device_attribute *attr,
+		 const char *buf, size_t count)
+{
+	unsigned long val;
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	if (strict_strtoul(buf, 0, &val) < 0)
+		return -EINVAL;
+
+	if (val) {
+		mutex_lock(&pci_remove_rescan_mutex);
+		pci_rescan_bus(pdev->bus);
+		mutex_unlock(&pci_remove_rescan_mutex);
+	}
+	return count;
+}
+
 static void remove_callback(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
@@ -298,6 +316,7 @@ struct device_attribute pci_dev_attrs[] = {
 	__ATTR(msi_bus, 0644, msi_bus_show, msi_bus_store),
 #ifdef CONFIG_HOTPLUG
 	__ATTR(remove, (S_IWUSR|S_IWGRP), NULL, remove_store),
+	__ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, dev_rescan_store),
 #endif
 	__ATTR_NULL,
 };

commit 77c27c7b49d69d45ccb94e481653f024f1ac6650
Author: Alex Chiang <achiang@hp.com>
Date:   Fri Mar 20 14:56:36 2009 -0600

    PCI: Introduce /sys/bus/pci/devices/.../remove
    
    This patch adds an attribute named "remove" to a PCI device's sysfs
    directory.  Writing a non-zero value to this attribute will remove the PCI
    device and any children of it.
    
    Trent Piepho wrote the original implementation and documentation.
    
    Thanks to Vegard Nossum for testing under kmemcheck and finding locking
    issues with the sysfs interface.
    
    Cc: Trent Piepho <xyzzy@speakeasy.org>
    Tested-by: Vegard Nossum <vegard.nossum@gmail.com>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index be7468a5eb72..e16990ecc024 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -243,6 +243,39 @@ struct bus_attribute pci_bus_attrs[] = {
 	__ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, bus_rescan_store),
 	__ATTR_NULL
 };
+
+static void remove_callback(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	mutex_lock(&pci_remove_rescan_mutex);
+	pci_remove_bus_device(pdev);
+	mutex_unlock(&pci_remove_rescan_mutex);
+}
+
+static ssize_t
+remove_store(struct device *dev, struct device_attribute *dummy,
+	     const char *buf, size_t count)
+{
+	int ret = 0;
+	unsigned long val;
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	if (strict_strtoul(buf, 0, &val) < 0)
+		return -EINVAL;
+
+	if (pci_is_root_bus(pdev->bus))
+		return -EBUSY;
+
+	/* An attribute cannot be unregistered by one of its own methods,
+	 * so we have to use this roundabout approach.
+	 */
+	if (val)
+		ret = device_schedule_callback(dev, remove_callback);
+	if (ret)
+		count = ret;
+	return count;
+}
 #endif
 
 struct device_attribute pci_dev_attrs[] = {
@@ -263,6 +296,9 @@ struct device_attribute pci_dev_attrs[] = {
 	__ATTR(broken_parity_status,(S_IRUGO|S_IWUSR),
 		broken_parity_status_show,broken_parity_status_store),
 	__ATTR(msi_bus, 0644, msi_bus_show, msi_bus_store),
+#ifdef CONFIG_HOTPLUG
+	__ATTR(remove, (S_IWUSR|S_IWGRP), NULL, remove_store),
+#endif
 	__ATTR_NULL,
 };
 

commit 705b1aaa823e800490f157cd9366ad8cff385f5f
Author: Alex Chiang <achiang@hp.com>
Date:   Fri Mar 20 14:56:31 2009 -0600

    PCI: Introduce /sys/bus/pci/rescan
    
    This interface allows the user to force a rescan of all PCI buses
    in system, and rediscover devices that have been removed earlier.
    
    pci_bus_attrs implementation from Trent Piepho.
    
    Thanks to Vegard Nossum for discovering locking issues with the
    sysfs interface.
    
    Cc: Trent Piepho <xyzzy@speakeasy.org>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index ec7a175dcbaf..be7468a5eb72 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -219,6 +219,32 @@ msi_bus_store(struct device *dev, struct device_attribute *attr,
 	return count;
 }
 
+#ifdef CONFIG_HOTPLUG
+static DEFINE_MUTEX(pci_remove_rescan_mutex);
+static ssize_t bus_rescan_store(struct bus_type *bus, const char *buf,
+				size_t count)
+{
+	unsigned long val;
+	struct pci_bus *b = NULL;
+
+	if (strict_strtoul(buf, 0, &val) < 0)
+		return -EINVAL;
+
+	if (val) {
+		mutex_lock(&pci_remove_rescan_mutex);
+		while ((b = pci_find_next_bus(b)) != NULL)
+			pci_rescan_bus(b);
+		mutex_unlock(&pci_remove_rescan_mutex);
+	}
+	return count;
+}
+
+struct bus_attribute pci_bus_attrs[] = {
+	__ATTR(rescan, (S_IWUSR|S_IWGRP), NULL, bus_rescan_store),
+	__ATTR_NULL
+};
+#endif
+
 struct device_attribute pci_dev_attrs[] = {
 	__ATTR_RO(resource),
 	__ATTR_RO(vendor),

commit 217f45de3d2f68b6d0b646bb4f2a155a71648396
Author: Dave Airlie <airlied@linux.ie>
Date:   Wed Mar 4 05:57:05 2009 +0000

    PCI: expose boot VGA device via sysfs.
    
    X really would like to know which VGA device was considered the boot
    device by the system. The x86 PCI fixups have support for discovering
    this but we provide no way to expose it to userspace.
    
    This adds a sysfs file per VGA class device which has the value 0 for
    non the boot device or unknown, and 1 if the VGA device is the boot
    device.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 1c8929801400..ec7a175dcbaf 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -240,6 +240,17 @@ struct device_attribute pci_dev_attrs[] = {
 	__ATTR_NULL,
 };
 
+static ssize_t
+boot_vga_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	return sprintf(buf, "%u\n",
+		!!(pdev->resource[PCI_ROM_RESOURCE].flags &
+		   IORESOURCE_ROM_SHADOW));
+}
+struct device_attribute vga_attr = __ATTR_RO(boot_vga);
+
 static ssize_t
 pci_read_config(struct kobject *kobj, struct bin_attribute *bin_attr,
 		char *buf, loff_t off, size_t count)
@@ -899,18 +910,27 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 		pdev->rom_attr = attr;
 	}
 
+	if ((pdev->class >> 8) == PCI_CLASS_DISPLAY_VGA) {
+		retval = device_create_file(&pdev->dev, &vga_attr);
+		if (retval)
+			goto err_rom_file;
+	}
+
 	/* add platform-specific attributes */
 	retval = pcibios_add_platform_entries(pdev);
 	if (retval)
-		goto err_rom_file;
+		goto err_vga_file;
 
 	/* add sysfs entries for various capabilities */
 	retval = pci_create_capabilities_sysfs(pdev);
 	if (retval)
-		goto err_rom_file;
+		goto err_vga_file;
 
 	return 0;
 
+err_vga_file:
+	if ((pdev->class >> 8) == PCI_CLASS_DISPLAY_VGA)
+		device_remove_file(&pdev->dev, &vga_attr);
 err_rom_file:
 	if (rom_size) {
 		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->rom_attr);

commit 10a0ef39fbd1d484c2bbc1ffd83d57ecef209140
Author: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
Date:   Tue Feb 17 13:46:53 2009 +0300

    PCI/alpha: pci sysfs resources
    
    This closes http://bugzilla.kernel.org/show_bug.cgi?id=10893
    which is a showstopper for X development on alpha.
    
    The generic HAVE_PCI_MMAP code (drivers/pci-sysfs.c) is not
    very useful since we have to deal with three different types
    of MMIO address spaces: sparse and dense mappings for old
    ev4/ev5 machines and "normal" 1:1 MMIO space (bwx) for ev56 and
    later.
    Also "write combine" mappings are meaningless on alpha - roughly
    speaking, alpha does write combining, IO reordering and other
    optimizations by default, unless user splits IO accesses
    with memory barriers.
    
    I think the cleanest way to deal with resource files on alpha
    is to convert the default no-op pci_create_resource_files() and
    pci_remove_resource_files() for !HAVE_PCI_MMAP case into __weak
    functions and override them with alpha specific ones.
    
    Another alpha hook is needed for "legacy_" resource files
    to handle sparse addressing (pci_adjust_legacy_attr).
    
    With the "standard" resourceN files on ev56/ev6 libpciaccess
    works "out of the box". Handling of resourceN_sparse/resourceN_dense
    files on older machines obviously requires some userland work.
    
    Sparse/dense stuff has been tested on sx164 (pca56/pyxis, normally
    uses bwx IO) with the kernel hacked into "cia compatible" mode.
    
    Signed-off-by: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index dfc4e0ddf241..1c8929801400 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -492,6 +492,19 @@ pci_mmap_legacy_io(struct kobject *kobj, struct bin_attribute *attr,
         return pci_mmap_legacy_page_range(bus, vma, pci_mmap_io);
 }
 
+/**
+ * pci_adjust_legacy_attr - adjustment of legacy file attributes
+ * @b: bus to create files under
+ * @mmap_type: I/O port or memory
+ *
+ * Stub implementation. Can be overridden by arch if necessary.
+ */
+void __weak
+pci_adjust_legacy_attr(struct pci_bus *b, enum pci_mmap_state mmap_type)
+{
+	return;
+}
+
 /**
  * pci_create_legacy_files - create legacy I/O port and memory files
  * @b: bus to create files under
@@ -518,6 +531,7 @@ void pci_create_legacy_files(struct pci_bus *b)
 	b->legacy_io->read = pci_read_legacy_io;
 	b->legacy_io->write = pci_write_legacy_io;
 	b->legacy_io->mmap = pci_mmap_legacy_io;
+	pci_adjust_legacy_attr(b, pci_mmap_io);
 	error = device_create_bin_file(&b->dev, b->legacy_io);
 	if (error)
 		goto legacy_io_err;
@@ -528,6 +542,7 @@ void pci_create_legacy_files(struct pci_bus *b)
 	b->legacy_mem->size = 1024*1024;
 	b->legacy_mem->attr.mode = S_IRUSR | S_IWUSR;
 	b->legacy_mem->mmap = pci_mmap_legacy_mem;
+	pci_adjust_legacy_attr(b, pci_mmap_mem);
 	error = device_create_bin_file(&b->dev, b->legacy_mem);
 	if (error)
 		goto legacy_mem_err;
@@ -719,8 +734,8 @@ static int pci_create_resource_files(struct pci_dev *pdev)
 	return 0;
 }
 #else /* !HAVE_PCI_MMAP */
-static inline int pci_create_resource_files(struct pci_dev *dev) { return 0; }
-static inline void pci_remove_resource_files(struct pci_dev *dev) { return; }
+int __weak pci_create_resource_files(struct pci_dev *dev) { return 0; }
+void __weak pci_remove_resource_files(struct pci_dev *dev) { return; }
 #endif /* HAVE_PCI_MMAP */
 
 /**

commit 97c44836cdec1ea713a15d84098a1a908157e68f
Author: Timothy S. Nelson <wayland@wayland.id.au>
Date:   Fri Jan 30 06:12:47 2009 +1100

    PCI: return error on failure to read PCI ROMs
    
    This patch makes the ROM reading code return an error to user space if
    the size of the ROM read is equal to 0.
    
    The patch also emits a warnings if the contents of the ROM are invalid,
    and documents the effects of the "enable" file on ROM reading.
    
    Signed-off-by: Timothy S. Nelson <wayland@wayland.id.au>
    Acked-by: Alex Villacis-Lasso <a_villacis@palosanto.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index db7ec14fa719..dfc4e0ddf241 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -768,8 +768,8 @@ pci_read_rom(struct kobject *kobj, struct bin_attribute *bin_attr,
 		return -EINVAL;
 	
 	rom = pci_map_rom(pdev, &size);	/* size starts out as PCI window size */
-	if (!rom)
-		return 0;
+	if (!rom || !size)
+		return -EIO;
 		
 	if (off >= size)
 		count = 0;

commit 4e9b1c184cadbece3694603de5f880b6e35bd7a7
Merge: 0176260fc308 36c401a44abc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 10 06:12:18 2009 -0800

    Merge branch 'cpus4096-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'cpus4096-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      [IA64] fix typo in cpumask_of_pcibus()
      x86: fix x86_32 builds for summit and es7000 arch's
      cpumask: use work_on_cpu in acpi-cpufreq.c for read_measured_perf_ctrs
      cpumask: use work_on_cpu in acpi-cpufreq.c for drv_read and drv_write
      cpumask: use cpumask_var_t in acpi-cpufreq.c
      cpumask: use work_on_cpu in acpi/cstate.c
      cpumask: convert struct cpufreq_policy to cpumask_var_t
      cpumask: replace CPUMASK_ALLOC etc with cpumask_var_t
      x86: cleanup remaining cpumask_t ops in smpboot code
      cpumask: update pci_bus_show_cpuaffinity to use new cpumask API
      cpumask: update local_cpus_show to use new cpumask API
      ia64: cpumask fix for is_affinity_mask_valid()

commit 287d19ce2e67c15e79a187b3bdcbbea1a0a51a7d
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Thu Dec 18 09:17:16 2008 -0800

    PCI: revise VPD access interface
    
    Change PCI VPD API which was only used by sysfs to something usable
    in drivers.
       * move iteration over multiple words to the low level
       * use conventional types for arguments
       * add exportable wrapper
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index ea54cedcdfc6..c23619fb6c4b 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -371,55 +371,33 @@ pci_write_config(struct kobject *kobj, struct bin_attribute *bin_attr,
 }
 
 static ssize_t
-pci_read_vpd(struct kobject *kobj, struct bin_attribute *bin_attr,
-	     char *buf, loff_t off, size_t count)
+read_vpd_attr(struct kobject *kobj, struct bin_attribute *bin_attr,
+	      char *buf, loff_t off, size_t count)
 {
 	struct pci_dev *dev =
 		to_pci_dev(container_of(kobj, struct device, kobj));
-	int end;
-	int ret;
 
 	if (off > bin_attr->size)
 		count = 0;
 	else if (count > bin_attr->size - off)
 		count = bin_attr->size - off;
-	end = off + count;
-
-	while (off < end) {
-		ret = dev->vpd->ops->read(dev, off, end - off, buf);
-		if (ret < 0)
-			return ret;
-		buf += ret;
-		off += ret;
-	}
 
-	return count;
+	return pci_read_vpd(dev, off, count, buf);
 }
 
 static ssize_t
-pci_write_vpd(struct kobject *kobj, struct bin_attribute *bin_attr,
-	      char *buf, loff_t off, size_t count)
+write_vpd_attr(struct kobject *kobj, struct bin_attribute *bin_attr,
+	       char *buf, loff_t off, size_t count)
 {
 	struct pci_dev *dev =
 		to_pci_dev(container_of(kobj, struct device, kobj));
-	int end;
-	int ret;
 
 	if (off > bin_attr->size)
 		count = 0;
 	else if (count > bin_attr->size - off)
 		count = bin_attr->size - off;
-	end = off + count;
-
-	while (off < end) {
-		ret = dev->vpd->ops->write(dev, off, end - off, buf);
-		if (ret < 0)
-			return ret;
-		buf += ret;
-		off += ret;
-	}
 
-	return count;
+	return pci_write_vpd(dev, off, count, buf);
 }
 
 #ifdef HAVE_PCI_LEGACY
@@ -845,8 +823,8 @@ static int pci_create_capabilities_sysfs(struct pci_dev *dev)
 		attr->size = dev->vpd->len;
 		attr->attr.name = "vpd";
 		attr->attr.mode = S_IRUSR | S_IWUSR;
-		attr->read = pci_read_vpd;
-		attr->write = pci_write_vpd;
+		attr->read = read_vpd_attr;
+		attr->write = write_vpd_attr;
 		retval = sysfs_create_bin_file(&dev->dev.kobj, attr);
 		if (retval) {
 			kfree(dev->vpd->attr);

commit fde09c6d8f92de0c9f75698a75f0989f2234c517
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Sat Nov 22 02:39:32 2008 +0800

    PCI: define PCI resource names in an 'enum'
    
    This patch moves all definitions of the PCI resource names to an 'enum',
    and also replaces some hard-coded resource variables with symbol
    names. This change eases introduction of device specific resources.
    
    Reviewed-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index d2f1354fd189..ea54cedcdfc6 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -102,11 +102,13 @@ resource_show(struct device * dev, struct device_attribute *attr, char * buf)
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	char * str = buf;
 	int i;
-	int max = 7;
+	int max;
 	resource_size_t start, end;
 
 	if (pci_dev->subordinate)
 		max = DEVICE_COUNT_RESOURCE;
+	else
+		max = PCI_BRIDGE_RESOURCES;
 
 	for (i = 0; i < max; i++) {
 		struct resource *res =  &pci_dev->resource[i];

commit 92425a405ea482209b43093a5e35be7de02acf18
Author: Trent Piepho <xyzzy@speakeasy.org>
Date:   Sun Nov 30 17:10:12 2008 -0800

    PCI: Make settable sysfs attributes more consistent
    
    PCI devices have three settable boolean attributes, enable,
    broken_parity_status, and msi_bus.
    
    The store functions for these would silently interpret "0x01" as false,
    "1llogical" as true, and "true" would be (silently!) ignored and do
    nothing.
    
    This is inconsistent with typical sysfs handling of settable attributes,
    and just plain doesn't make much sense.
    
    So, use strict_strtoul(), which was created for this purpose.  The store
    functions will treat a value of 0 as false, non-zero as true, and return
    -EINVAL for a parse failure.
    
    Additionally, is_enabled_store() and msi_bus_store() return -EPERM if
    CAP_SYS_ADMIN is lacking, rather than silently doing nothing.  This is more
    typical behavior for sysfs attributes that need a capability.
    
    And msi_bus_store() will only print the "forced subordinate bus ..."
    warning if the MSI flag was actually forced to a different value.
    
    Signed-off-by: Trent Piepho <xyzzy@speakeasy.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index d5cdccf27a69..d2f1354fd189 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -58,13 +58,14 @@ static ssize_t broken_parity_status_store(struct device *dev,
 					  const char *buf, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
-	ssize_t consumed = -EINVAL;
+	unsigned long val;
 
-	if ((count > 0) && (*buf == '0' || *buf == '1')) {
-		pdev->broken_parity_status = *buf == '1' ? 1 : 0;
-		consumed = count;
-	}
-	return consumed;
+	if (strict_strtoul(buf, 0, &val) < 0)
+		return -EINVAL;
+
+	pdev->broken_parity_status = !!val;
+
+	return count;
 }
 
 static ssize_t local_cpus_show(struct device *dev,
@@ -133,19 +134,23 @@ static ssize_t is_enabled_store(struct device *dev,
 				struct device_attribute *attr, const char *buf,
 				size_t count)
 {
-	ssize_t result = -EINVAL;
 	struct pci_dev *pdev = to_pci_dev(dev);
+	unsigned long val;
+	ssize_t result = strict_strtoul(buf, 0, &val);
+
+	if (result < 0)
+		return result;
 
 	/* this can crash the machine when done on the "wrong" device */
 	if (!capable(CAP_SYS_ADMIN))
-		return count;
+		return -EPERM;
 
-	if (*buf == '0') {
+	if (!val) {
 		if (atomic_read(&pdev->enable_cnt) != 0)
 			pci_disable_device(pdev);
 		else
 			result = -EIO;
-	} else if (*buf == '1')
+	} else
 		result = pci_enable_device(pdev);
 
 	return result < 0 ? result : count;
@@ -185,25 +190,28 @@ msi_bus_store(struct device *dev, struct device_attribute *attr,
 	      const char *buf, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 0, &val) < 0)
+		return -EINVAL;
 
 	/* bad things may happen if the no_msi flag is changed
 	 * while some drivers are loaded */
 	if (!capable(CAP_SYS_ADMIN))
-		return count;
+		return -EPERM;
 
+	/* Maybe pci devices without subordinate busses shouldn't even have this
+	 * attribute in the first place?  */
 	if (!pdev->subordinate)
 		return count;
 
-	if (*buf == '0') {
-		pdev->subordinate->bus_flags |= PCI_BUS_FLAGS_NO_MSI;
-		dev_warn(&pdev->dev, "forced subordinate bus to not support MSI,"
-			 " bad things could happen.\n");
-	}
+	/* Is the flag going to change, or keep the value it already had? */
+	if (!(pdev->subordinate->bus_flags & PCI_BUS_FLAGS_NO_MSI) ^
+	    !!val) {
+		pdev->subordinate->bus_flags ^= PCI_BUS_FLAGS_NO_MSI;
 
-	if (*buf == '1') {
-		pdev->subordinate->bus_flags &= ~PCI_BUS_FLAGS_NO_MSI;
-		dev_warn(&pdev->dev, "forced subordinate bus to support MSI,"
-			 " bad things could happen.\n");
+		dev_warn(&pdev->dev, "forced subordinate bus to%s support MSI,"
+			 " bad things could happen\n", val ? "" : " not");
 	}
 
 	return count;

commit e8de1481fd7126ee9e93d6889da6f00c05e1e019
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Wed Oct 22 19:55:31 2008 -0700

    resource: allow MMIO exclusivity for device drivers
    
    Device drivers that use pci_request_regions() (and similar APIs) have a
    reasonable expectation that they are the only ones accessing their device.
    As part of the e1000e hunt, we were afraid that some userland (X or some
    bootsplash stuff) was mapping the MMIO region that the driver thought it
    had exclusively via /dev/mem or via various sysfs resource mappings.
    
    This patch adds the option for device drivers to cause their reserved
    regions to the "banned from /dev/mem use" list, so now both kernel memory
    and device-exclusive MMIO regions are banned.
    NOTE: This is only active when CONFIG_STRICT_DEVMEM is set.
    
    In addition to the config option, a kernel parameter iomem=relaxed is
    provided for the cases where developers want to diagnose, in the field,
    drivers issues from userspace.
    
    Reviewed-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 388440e0d222..d5cdccf27a69 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -620,6 +620,9 @@ pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 	vma->vm_pgoff += start >> PAGE_SHIFT;
 	mmap_type = res->flags & IORESOURCE_MEM ? pci_mmap_mem : pci_mmap_io;
 
+	if (res->flags & IORESOURCE_MEM && iomem_is_exclusive(start))
+		return -EINVAL;
+
 	return pci_mmap_page_range(pdev, vma, mmap_type, write_combine);
 }
 

commit 9eff02e2042f96fb2aedd02e032eca1c5333d767
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Oct 24 10:32:33 2008 -0700

    PCI: check mmap range of /proc/bus/pci files too
    
    /proc/bus/pci allows you to mmap resource ranges too, so we should probably be
    checking to make sure the mapping is somewhat valid.  Uses the same code as the recent sysfs mmap range checking patch from Linus.
    
    Acked-by: David Miller <davem@davemloft.net>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index c88485860a0a..388440e0d222 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -569,7 +569,7 @@ void pci_remove_legacy_files(struct pci_bus *b)
 
 #ifdef HAVE_PCI_MMAP
 
-static int pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vma)
+int pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vma)
 {
 	unsigned long nr, start, size;
 

commit 3be83050d0143b515c5effe9c9d54edc41f1a2fa
Author: Mike Travis <travis@sgi.com>
Date:   Sun Jan 4 05:18:01 2009 -0800

    cpumask: update local_cpus_show to use new cpumask API
    
    Impact: use new cpumask API to reduce stack usage
    
    Replace the local cpumask_t variable with a pointer to the
    const cpumask that needs to be printed.
    
    Signed-off-by: Mike Travis <travis@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index c88485860a0a..e4957e2c92c9 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -70,11 +70,11 @@ static ssize_t broken_parity_status_store(struct device *dev,
 static ssize_t local_cpus_show(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {		
-	cpumask_t mask;
+	const struct cpumask *mask;
 	int len;
 
-	mask = pcibus_to_cpumask(to_pci_dev(dev)->bus);
-	len = cpumask_scnprintf(buf, PAGE_SIZE-2, &mask);
+	mask = cpumask_of_pcibus(to_pci_dev(dev)->bus);
+	len = cpumask_scnprintf(buf, PAGE_SIZE-2, mask);
 	buf[len++] = '\n';
 	buf[len] = '\0';
 	return len;
@@ -84,11 +84,11 @@ static ssize_t local_cpus_show(struct device *dev,
 static ssize_t local_cpulist_show(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {
-	cpumask_t mask;
+	const struct cpumask *mask;
 	int len;
 
-	mask = pcibus_to_cpumask(to_pci_dev(dev)->bus);
-	len = cpulist_scnprintf(buf, PAGE_SIZE-2, &mask);
+	mask = cpumask_of_pcibus(to_pci_dev(dev)->bus);
+	len = cpulist_scnprintf(buf, PAGE_SIZE-2, mask);
 	buf[len++] = '\n';
 	buf[len] = '\0';
 	return len;

commit 29c0177e6a4ac094302bed54a1d4bbb6b740a9ef
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sat Dec 13 21:20:25 2008 +1030

    cpumask: change cpumask_scnprintf, cpumask_parse_user, cpulist_parse, and cpulist_scnprintf to take pointers.
    
    Impact: change calling convention of existing cpumask APIs
    
    Most cpumask functions started with cpus_: these have been replaced by
    cpumask_ ones which take struct cpumask pointers as expected.
    
    These four functions don't have good replacement names; fortunately
    they're rarely used, so we just change them over.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Mike Travis <travis@sgi.com>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Cc: paulus@samba.org
    Cc: mingo@redhat.com
    Cc: tony.luck@intel.com
    Cc: ralf@linux-mips.org
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: cl@linux-foundation.org
    Cc: srostedt@redhat.com

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 5d72866897a8..c88485860a0a 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -74,7 +74,7 @@ static ssize_t local_cpus_show(struct device *dev,
 	int len;
 
 	mask = pcibus_to_cpumask(to_pci_dev(dev)->bus);
-	len = cpumask_scnprintf(buf, PAGE_SIZE-2, mask);
+	len = cpumask_scnprintf(buf, PAGE_SIZE-2, &mask);
 	buf[len++] = '\n';
 	buf[len] = '\0';
 	return len;
@@ -88,7 +88,7 @@ static ssize_t local_cpulist_show(struct device *dev,
 	int len;
 
 	mask = pcibus_to_cpumask(to_pci_dev(dev)->bus);
-	len = cpulist_scnprintf(buf, PAGE_SIZE-2, mask);
+	len = cpulist_scnprintf(buf, PAGE_SIZE-2, &mask);
 	buf[len++] = '\n';
 	buf[len] = '\0';
 	return len;

commit 88e7df0b7ee717f9db3333fb1248827bbdb2d4d3
Author: Ed Swierk <eswierk@aristanetworks.com>
Date:   Mon Nov 3 14:41:16 2008 -0800

    PCI: fix range check on mmapped sysfs resource files
    
    pci_mmap_fits() returns the wrong answer if the sysfs resource file size
    is not a multiple of the page size.  vm_end and vm_start are already
    page-aligned, so size - start < nr, causing mmap() to return EINVAL.
    
    Signed-off-by: Ed Swierk <eswierk@aristanetworks.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 110022d78689..5d72866897a8 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -575,7 +575,7 @@ static int pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct
 
 	nr = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
 	start = vma->vm_pgoff;
-	size = pci_resource_len(pdev, resno) >> PAGE_SHIFT;
+	size = ((pci_resource_len(pdev, resno) - 1) >> PAGE_SHIFT) + 1;
 	if (start < size && size - start >= nr)
 		return 1;
 	WARN(1, "process \"%s\" tried to map 0x%08lx-0x%08lx on %s BAR %d (size 0x%08lx)\n",

commit f19aeb1f3638b7bb4ca21eb361f004fac2bfe259
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Oct 3 19:49:32 2008 +1000

    PCI: Add ability to mmap legacy_io on some platforms
    
    This adds the ability to mmap legacy IO space to the legacy_io files
    in sysfs on platforms that support it. This will allow to clean up
    X to use this instead of /dev/mem for legacy IO accesses such as
    those performed by Int10.
    
    While at it I moved pci_create/remove_legacy_files() to pci-sysfs.c
    where I think they belong, thus making more things statis in there
    and cleaned up some spurrious prototypes in the ia64 pci.h file
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 2cad6da2e4aa..110022d78689 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -423,7 +423,7 @@ pci_write_vpd(struct kobject *kobj, struct bin_attribute *bin_attr,
  * Reads 1, 2, or 4 bytes from legacy I/O port space using an arch specific
  * callback routine (pci_legacy_read).
  */
-ssize_t
+static ssize_t
 pci_read_legacy_io(struct kobject *kobj, struct bin_attribute *bin_attr,
 		   char *buf, loff_t off, size_t count)
 {
@@ -448,7 +448,7 @@ pci_read_legacy_io(struct kobject *kobj, struct bin_attribute *bin_attr,
  * Writes 1, 2, or 4 bytes from legacy I/O port space using an arch specific
  * callback routine (pci_legacy_write).
  */
-ssize_t
+static ssize_t
 pci_write_legacy_io(struct kobject *kobj, struct bin_attribute *bin_attr,
 		    char *buf, loff_t off, size_t count)
 {
@@ -468,11 +468,11 @@ pci_write_legacy_io(struct kobject *kobj, struct bin_attribute *bin_attr,
  * @attr: struct bin_attribute for this file
  * @vma: struct vm_area_struct passed to mmap
  *
- * Uses an arch specific callback, pci_mmap_legacy_page_range, to mmap
+ * Uses an arch specific callback, pci_mmap_legacy_mem_page_range, to mmap
  * legacy memory space (first meg of bus space) into application virtual
  * memory space.
  */
-int
+static int
 pci_mmap_legacy_mem(struct kobject *kobj, struct bin_attribute *attr,
                     struct vm_area_struct *vma)
 {
@@ -480,7 +480,90 @@ pci_mmap_legacy_mem(struct kobject *kobj, struct bin_attribute *attr,
                                                       struct device,
 						      kobj));
 
-        return pci_mmap_legacy_page_range(bus, vma);
+        return pci_mmap_legacy_page_range(bus, vma, pci_mmap_mem);
+}
+
+/**
+ * pci_mmap_legacy_io - map legacy PCI IO into user memory space
+ * @kobj: kobject corresponding to device to be mapped
+ * @attr: struct bin_attribute for this file
+ * @vma: struct vm_area_struct passed to mmap
+ *
+ * Uses an arch specific callback, pci_mmap_legacy_io_page_range, to mmap
+ * legacy IO space (first meg of bus space) into application virtual
+ * memory space. Returns -ENOSYS if the operation isn't supported
+ */
+static int
+pci_mmap_legacy_io(struct kobject *kobj, struct bin_attribute *attr,
+		   struct vm_area_struct *vma)
+{
+        struct pci_bus *bus = to_pci_bus(container_of(kobj,
+                                                      struct device,
+						      kobj));
+
+        return pci_mmap_legacy_page_range(bus, vma, pci_mmap_io);
+}
+
+/**
+ * pci_create_legacy_files - create legacy I/O port and memory files
+ * @b: bus to create files under
+ *
+ * Some platforms allow access to legacy I/O port and ISA memory space on
+ * a per-bus basis.  This routine creates the files and ties them into
+ * their associated read, write and mmap files from pci-sysfs.c
+ *
+ * On error unwind, but don't propogate the error to the caller
+ * as it is ok to set up the PCI bus without these files.
+ */
+void pci_create_legacy_files(struct pci_bus *b)
+{
+	int error;
+
+	b->legacy_io = kzalloc(sizeof(struct bin_attribute) * 2,
+			       GFP_ATOMIC);
+	if (!b->legacy_io)
+		goto kzalloc_err;
+
+	b->legacy_io->attr.name = "legacy_io";
+	b->legacy_io->size = 0xffff;
+	b->legacy_io->attr.mode = S_IRUSR | S_IWUSR;
+	b->legacy_io->read = pci_read_legacy_io;
+	b->legacy_io->write = pci_write_legacy_io;
+	b->legacy_io->mmap = pci_mmap_legacy_io;
+	error = device_create_bin_file(&b->dev, b->legacy_io);
+	if (error)
+		goto legacy_io_err;
+
+	/* Allocated above after the legacy_io struct */
+	b->legacy_mem = b->legacy_io + 1;
+	b->legacy_mem->attr.name = "legacy_mem";
+	b->legacy_mem->size = 1024*1024;
+	b->legacy_mem->attr.mode = S_IRUSR | S_IWUSR;
+	b->legacy_mem->mmap = pci_mmap_legacy_mem;
+	error = device_create_bin_file(&b->dev, b->legacy_mem);
+	if (error)
+		goto legacy_mem_err;
+
+	return;
+
+legacy_mem_err:
+	device_remove_bin_file(&b->dev, b->legacy_io);
+legacy_io_err:
+	kfree(b->legacy_io);
+	b->legacy_io = NULL;
+kzalloc_err:
+	printk(KERN_WARNING "pci: warning: could not create legacy I/O port "
+	       "and ISA memory resources to sysfs\n");
+	return;
+}
+
+void pci_remove_legacy_files(struct pci_bus *b)
+{
+	if (b->legacy_io) {
+		device_remove_bin_file(&b->dev, b->legacy_io);
+		device_remove_bin_file(&b->dev, b->legacy_mem);
+		kfree(b->legacy_io); /* both are allocated here */
+	}
 }
 #endif /* HAVE_PCI_LEGACY */
 

commit 280c73d3691fb182fa55b0160737c2c0feb79471
Author: Zhao, Yu <yu.zhao@intel.com>
Date:   Mon Oct 13 20:01:00 2008 +0800

    PCI: centralize the capabilities code in pci-sysfs.c
    
    This patch centralizes functions used to add and remove sysfs entries
    for various capabilities. With this cleanup, the code is more readable
    and easier for adding new capability related functions.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 00a9947cb7cc..2cad6da2e4aa 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -735,10 +735,41 @@ int __attribute__ ((weak)) pcibios_add_platform_entries(struct pci_dev *dev)
 	return 0;
 }
 
+static int pci_create_capabilities_sysfs(struct pci_dev *dev)
+{
+	int retval;
+	struct bin_attribute *attr;
+
+	/* If the device has VPD, try to expose it in sysfs. */
+	if (dev->vpd) {
+		attr = kzalloc(sizeof(*attr), GFP_ATOMIC);
+		if (!attr)
+			return -ENOMEM;
+
+		attr->size = dev->vpd->len;
+		attr->attr.name = "vpd";
+		attr->attr.mode = S_IRUSR | S_IWUSR;
+		attr->read = pci_read_vpd;
+		attr->write = pci_write_vpd;
+		retval = sysfs_create_bin_file(&dev->dev.kobj, attr);
+		if (retval) {
+			kfree(dev->vpd->attr);
+			return retval;
+		}
+		dev->vpd->attr = attr;
+	}
+
+	/* Active State Power Management */
+	pcie_aspm_create_sysfs_dev_files(dev);
+
+	return 0;
+}
+
 int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 {
-	struct bin_attribute *attr = NULL;
 	int retval;
+	int rom_size = 0;
+	struct bin_attribute *attr;
 
 	if (!sysfs_initialized)
 		return -EACCES;
@@ -750,69 +781,55 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 	if (retval)
 		goto err;
 
-	/* If the device has VPD, try to expose it in sysfs. */
-	if (pdev->vpd) {
-		attr = kzalloc(sizeof(*attr), GFP_ATOMIC);
-		if (attr) {
-			pdev->vpd->attr = attr;
-			attr->size = pdev->vpd->len;
-			attr->attr.name = "vpd";
-			attr->attr.mode = S_IRUSR | S_IWUSR;
-			attr->read = pci_read_vpd;
-			attr->write = pci_write_vpd;
-			retval = sysfs_create_bin_file(&pdev->dev.kobj, attr);
-			if (retval)
-				goto err_vpd;
-		} else {
-			retval = -ENOMEM;
-			goto err_config_file;
-		}
-	}
-
 	retval = pci_create_resource_files(pdev);
 	if (retval)
-		goto err_vpd_file;
+		goto err_config_file;
+
+	if (pci_resource_len(pdev, PCI_ROM_RESOURCE))
+		rom_size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
+	else if (pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW)
+		rom_size = 0x20000;
 
 	/* If the device has a ROM, try to expose it in sysfs. */
-	if (pci_resource_len(pdev, PCI_ROM_RESOURCE) ||
-	    (pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW)) {
+	if (rom_size) {
 		attr = kzalloc(sizeof(*attr), GFP_ATOMIC);
-		if (attr) {
-			pdev->rom_attr = attr;
-			attr->size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
-			attr->attr.name = "rom";
-			attr->attr.mode = S_IRUSR;
-			attr->read = pci_read_rom;
-			attr->write = pci_write_rom;
-			retval = sysfs_create_bin_file(&pdev->dev.kobj, attr);
-			if (retval)
-				goto err_rom;
-		} else {
+		if (!attr) {
 			retval = -ENOMEM;
 			goto err_resource_files;
 		}
+		attr->size = rom_size;
+		attr->attr.name = "rom";
+		attr->attr.mode = S_IRUSR;
+		attr->read = pci_read_rom;
+		attr->write = pci_write_rom;
+		retval = sysfs_create_bin_file(&pdev->dev.kobj, attr);
+		if (retval) {
+			kfree(attr);
+			goto err_resource_files;
+		}
+		pdev->rom_attr = attr;
 	}
+
 	/* add platform-specific attributes */
-	if (pcibios_add_platform_entries(pdev))
+	retval = pcibios_add_platform_entries(pdev);
+	if (retval)
 		goto err_rom_file;
 
-	pcie_aspm_create_sysfs_dev_files(pdev);
+	/* add sysfs entries for various capabilities */
+	retval = pci_create_capabilities_sysfs(pdev);
+	if (retval)
+		goto err_rom_file;
 
 	return 0;
 
 err_rom_file:
-	if (pci_resource_len(pdev, PCI_ROM_RESOURCE))
+	if (rom_size) {
 		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->rom_attr);
-err_rom:
-	kfree(pdev->rom_attr);
+		kfree(pdev->rom_attr);
+		pdev->rom_attr = NULL;
+	}
 err_resource_files:
 	pci_remove_resource_files(pdev);
-err_vpd_file:
-	if (pdev->vpd) {
-		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->vpd->attr);
-err_vpd:
-		kfree(pdev->vpd->attr);
-	}
 err_config_file:
 	if (pdev->cfg_size < PCI_CFG_SPACE_EXP_SIZE)
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
@@ -822,6 +839,16 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 	return retval;
 }
 
+static void pci_remove_capabilities_sysfs(struct pci_dev *dev)
+{
+	if (dev->vpd && dev->vpd->attr) {
+		sysfs_remove_bin_file(&dev->dev.kobj, dev->vpd->attr);
+		kfree(dev->vpd->attr);
+	}
+
+	pcie_aspm_remove_sysfs_dev_files(dev);
+}
+
 /**
  * pci_remove_sysfs_dev_files - cleanup PCI specific sysfs files
  * @pdev: device whose entries we should free
@@ -830,15 +857,13 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
  */
 void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
 {
+	int rom_size = 0;
+
 	if (!sysfs_initialized)
 		return;
 
-	pcie_aspm_remove_sysfs_dev_files(pdev);
+	pci_remove_capabilities_sysfs(pdev);
 
-	if (pdev->vpd) {
-		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->vpd->attr);
-		kfree(pdev->vpd->attr);
-	}
 	if (pdev->cfg_size < PCI_CFG_SPACE_EXP_SIZE)
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
 	else
@@ -846,11 +871,14 @@ void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
 
 	pci_remove_resource_files(pdev);
 
-	if (pci_resource_len(pdev, PCI_ROM_RESOURCE)) {
-		if (pdev->rom_attr) {
-			sysfs_remove_bin_file(&pdev->dev.kobj, pdev->rom_attr);
-			kfree(pdev->rom_attr);
-		}
+	if (pci_resource_len(pdev, PCI_ROM_RESOURCE))
+		rom_size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
+	else if (pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW)
+		rom_size = 0x20000;
+
+	if (rom_size && pdev->rom_attr) {
+		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->rom_attr);
+		kfree(pdev->rom_attr);
 	}
 }
 

commit 557848c3c03ad1d1e66cb3b5b06698e3a9ebc33c
Author: Zhao, Yu <yu.zhao@intel.com>
Date:   Mon Oct 13 19:18:07 2008 +0800

    PCI: replace cfg space size (256/4096) by macros.
    
    This is a cleanup that changes all PCI configuration space size
    representations to the macros (PCI_CFG_SPACE_SIZE and
    PCI_CFG_SPACE_EXP_SIZE). And the macros are also moved from
    drivers/pci/probe.c to drivers/pci/pci.h.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 77baff022f71..00a9947cb7cc 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -715,7 +715,7 @@ static struct bin_attribute pci_config_attr = {
 		.name = "config",
 		.mode = S_IRUGO | S_IWUSR,
 	},
-	.size = 256,
+	.size = PCI_CFG_SPACE_SIZE,
 	.read = pci_read_config,
 	.write = pci_write_config,
 };
@@ -725,7 +725,7 @@ static struct bin_attribute pcie_config_attr = {
 		.name = "config",
 		.mode = S_IRUGO | S_IWUSR,
 	},
-	.size = 4096,
+	.size = PCI_CFG_SPACE_EXP_SIZE,
 	.read = pci_read_config,
 	.write = pci_write_config,
 };
@@ -743,7 +743,7 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 	if (!sysfs_initialized)
 		return -EACCES;
 
-	if (pdev->cfg_size < 4096)
+	if (pdev->cfg_size < PCI_CFG_SPACE_EXP_SIZE)
 		retval = sysfs_create_bin_file(&pdev->dev.kobj, &pci_config_attr);
 	else
 		retval = sysfs_create_bin_file(&pdev->dev.kobj, &pcie_config_attr);
@@ -814,7 +814,7 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 		kfree(pdev->vpd->attr);
 	}
 err_config_file:
-	if (pdev->cfg_size < 4096)
+	if (pdev->cfg_size < PCI_CFG_SPACE_EXP_SIZE)
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
 	else
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pcie_config_attr);
@@ -839,7 +839,7 @@ void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
 		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->vpd->attr);
 		kfree(pdev->vpd->attr);
 	}
-	if (pdev->cfg_size < 4096)
+	if (pdev->cfg_size < PCI_CFG_SPACE_EXP_SIZE)
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
 	else
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pcie_config_attr);

commit b5ff7df3df9efab511244d5a299fce706c71af48
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 2 18:52:51 2008 -0700

    Check mapped ranges on sysfs resource files
    
    This is loosely based on a patch by Jesse Barnes to check the user-space
    PCI mappings though the sysfs interfaces.  Quoting Jesse's original
    explanation:
    
      It's fairly common for applications to map PCI resources through sysfs.
      However, with the current implementation, it's possible for an application
      to map far more than the range corresponding to the resourceN file it
      opened.  This patch plugs that hole by checking the range at mmap time,
      similar to what is done on platforms like sparc64 in their lower level
      PCI remapping routines.
    
      It was initially put together to help debug the e1000e NVRAM corruption
      problem, since we initially thought an X driver might be walking past the
      end of one of its mappings and clobbering the NVRAM.  It now looks like
      that's not the case, but doing the check is still important for obvious
      reasons.
    
    and this version of the patch differs in that it uses a helper function
    to clarify the code, and does all the checks in pages (instead of bytes)
    in order to avoid overflows when doing "<< PAGE_SHIFT" etc.
    
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 9c718583a237..77baff022f71 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -16,6 +16,7 @@
 
 
 #include <linux/kernel.h>
+#include <linux/sched.h>
 #include <linux/pci.h>
 #include <linux/stat.h>
 #include <linux/topology.h>
@@ -484,6 +485,21 @@ pci_mmap_legacy_mem(struct kobject *kobj, struct bin_attribute *attr,
 #endif /* HAVE_PCI_LEGACY */
 
 #ifdef HAVE_PCI_MMAP
+
+static int pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vma)
+{
+	unsigned long nr, start, size;
+
+	nr = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
+	start = vma->vm_pgoff;
+	size = pci_resource_len(pdev, resno) >> PAGE_SHIFT;
+	if (start < size && size - start >= nr)
+		return 1;
+	WARN(1, "process \"%s\" tried to map 0x%08lx-0x%08lx on %s BAR %d (size 0x%08lx)\n",
+		current->comm, start, start+nr, pci_name(pdev), resno, size);
+	return 0;
+}
+
 /**
  * pci_mmap_resource - map a PCI resource into user memory space
  * @kobj: kobject for mapping
@@ -510,6 +526,9 @@ pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 	if (i >= PCI_ROM_RESOURCE)
 		return -ENODEV;
 
+	if (!pci_mmap_fits(pdev, i, vma))
+		return -EINVAL;
+
 	/* pci_mmap_page_range() expects the same kind of entry as coming
 	 * from /proc/bus/pci/ which is a "user visible" value. If this is
 	 * different from the resource itself, arch will do necessary fixup.

commit 99cb233d60cbe644203f19938c729ea2bb004d70
Author: Benjamin Li <benli@broadcom.com>
Date:   Wed Jul 2 10:59:04 2008 -0700

    PCI: Limit VPD read/write lengths for Broadcom 5706, 5708, 5709 rev.
    
    For Broadcom 5706, 5708, 5709 rev. A nics, any read beyond the
    VPD end tag will hang the device.  This problem was initially
    observed when a vpd entry was created in sysfs
    ('/sys/bus/pci/devices/<id>/vpd').   A read to this sysfs entry
    will dump 32k of data.  Reading a full 32k will cause an access
    beyond the VPD end tag causing the device to hang.  Once the device
    is hung, the bnx2 driver will not be able to reset the device.
    We believe that it is legal to read beyond the end tag and
    therefore the solution is to limit the read/write length.
    
    A majority of this patch is from Matthew Wilcox who gave code for
    reworking the PCI vpd size information.  A PCI quirk added for the
    Broadcom NIC's to limit the read/write's.
    
    Signed-off-by: Benjamin Li <benli@broadcom.com>
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 1f855f028e92..9c718583a237 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -736,7 +736,7 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 		attr = kzalloc(sizeof(*attr), GFP_ATOMIC);
 		if (attr) {
 			pdev->vpd->attr = attr;
-			attr->size = pdev->vpd->ops->get_size(pdev);
+			attr->size = pdev->vpd->len;
 			attr->attr.name = "vpd";
 			attr->attr.mode = S_IRUSR | S_IWUSR;
 			attr->read = pci_read_vpd;

commit a94c248113b86bbbc47d027a4004b70f2be298b1
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Tue Jul 1 17:18:17 2008 +0100

    PCI: Restrict VPD read permission to root
    
    Some PCI devices will lock up if we attempt to read from VPD addresses
    beyond some device-dependent limit.  Until we can identify these
    devices and adjust the file size accordingly, only let root read VPD
    through sysfs to prevent a DoS by normal users.
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 6f3c7446c329..1f855f028e92 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -738,7 +738,7 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 			pdev->vpd->attr = attr;
 			attr->size = pdev->vpd->ops->get_size(pdev);
 			attr->attr.name = "vpd";
-			attr->attr.mode = S_IRUGO | S_IWUSR;
+			attr->attr.mode = S_IRUSR | S_IWUSR;
 			attr->read = pci_read_vpd;
 			attr->write = pci_write_vpd;
 			retval = sysfs_create_bin_file(&pdev->dev.kobj, attr);

commit 81d5575a48f49f494289a1299a32e4e5e41fbf40
Author: Jesse Barnes <jbarnes@hobbes.lan>
Date:   Thu Jun 12 13:51:46 2008 -0700

    PCI: fixup write combine comment in pci_mmap_resource
    
    Now that we can actually do write combining properly, there's no need to have
    the FIXME.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 9ec7d3977a82..6f3c7446c329 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -492,7 +492,6 @@ pci_mmap_legacy_mem(struct kobject *kobj, struct bin_attribute *attr,
  * @write_combine: 1 for write_combine mapping
  *
  * Use the regular PCI mapping routines to map a PCI resource into userspace.
- * FIXME: write combining?  maybe automatic for prefetchable regions?
  */
 static int
 pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,

commit 45aec1ae72fc592f231e9e73ed9ed4d10cfbc0b5
Author: venkatesh.pallipadi@intel.com <venkatesh.pallipadi@intel.com>
Date:   Tue Mar 18 17:00:22 2008 -0700

    x86: PAT export resource_wc in pci sysfs
    
    For the ranges with IORESOURCE_PREFETCH, export a new resource_wc interface in
    pci /sysfs along with resource (which is uncached).
    
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 271d41cc05ab..9ec7d3977a82 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -489,13 +489,14 @@ pci_mmap_legacy_mem(struct kobject *kobj, struct bin_attribute *attr,
  * @kobj: kobject for mapping
  * @attr: struct bin_attribute for the file being mapped
  * @vma: struct vm_area_struct passed into the mmap
+ * @write_combine: 1 for write_combine mapping
  *
  * Use the regular PCI mapping routines to map a PCI resource into userspace.
  * FIXME: write combining?  maybe automatic for prefetchable regions?
  */
 static int
 pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
-		  struct vm_area_struct *vma)
+		  struct vm_area_struct *vma, int write_combine)
 {
 	struct pci_dev *pdev = to_pci_dev(container_of(kobj,
 						       struct device, kobj));
@@ -518,7 +519,21 @@ pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 	vma->vm_pgoff += start >> PAGE_SHIFT;
 	mmap_type = res->flags & IORESOURCE_MEM ? pci_mmap_mem : pci_mmap_io;
 
-	return pci_mmap_page_range(pdev, vma, mmap_type, 0);
+	return pci_mmap_page_range(pdev, vma, mmap_type, write_combine);
+}
+
+static int
+pci_mmap_resource_uc(struct kobject *kobj, struct bin_attribute *attr,
+		     struct vm_area_struct *vma)
+{
+	return pci_mmap_resource(kobj, attr, vma, 0);
+}
+
+static int
+pci_mmap_resource_wc(struct kobject *kobj, struct bin_attribute *attr,
+		     struct vm_area_struct *vma)
+{
+	return pci_mmap_resource(kobj, attr, vma, 1);
 }
 
 /**
@@ -541,9 +556,46 @@ pci_remove_resource_files(struct pci_dev *pdev)
 			sysfs_remove_bin_file(&pdev->dev.kobj, res_attr);
 			kfree(res_attr);
 		}
+
+		res_attr = pdev->res_attr_wc[i];
+		if (res_attr) {
+			sysfs_remove_bin_file(&pdev->dev.kobj, res_attr);
+			kfree(res_attr);
+		}
 	}
 }
 
+static int pci_create_attr(struct pci_dev *pdev, int num, int write_combine)
+{
+	/* allocate attribute structure, piggyback attribute name */
+	int name_len = write_combine ? 13 : 10;
+	struct bin_attribute *res_attr;
+	int retval;
+
+	res_attr = kzalloc(sizeof(*res_attr) + name_len, GFP_ATOMIC);
+	if (res_attr) {
+		char *res_attr_name = (char *)(res_attr + 1);
+
+		if (write_combine) {
+			pdev->res_attr_wc[num] = res_attr;
+			sprintf(res_attr_name, "resource%d_wc", num);
+			res_attr->mmap = pci_mmap_resource_wc;
+		} else {
+			pdev->res_attr[num] = res_attr;
+			sprintf(res_attr_name, "resource%d", num);
+			res_attr->mmap = pci_mmap_resource_uc;
+		}
+		res_attr->attr.name = res_attr_name;
+		res_attr->attr.mode = S_IRUSR | S_IWUSR;
+		res_attr->size = pci_resource_len(pdev, num);
+		res_attr->private = &pdev->resource[num];
+		retval = sysfs_create_bin_file(&pdev->dev.kobj, res_attr);
+	} else
+		retval = -ENOMEM;
+
+	return retval;
+}
+
 /**
  * pci_create_resource_files - create resource files in sysfs for @dev
  * @dev: dev in question
@@ -557,31 +609,19 @@ static int pci_create_resource_files(struct pci_dev *pdev)
 
 	/* Expose the PCI resources from this device as files */
 	for (i = 0; i < PCI_ROM_RESOURCE; i++) {
-		struct bin_attribute *res_attr;
 
 		/* skip empty resources */
 		if (!pci_resource_len(pdev, i))
 			continue;
 
-		/* allocate attribute structure, piggyback attribute name */
-		res_attr = kzalloc(sizeof(*res_attr) + 10, GFP_ATOMIC);
-		if (res_attr) {
-			char *res_attr_name = (char *)(res_attr + 1);
-
-			pdev->res_attr[i] = res_attr;
-			sprintf(res_attr_name, "resource%d", i);
-			res_attr->attr.name = res_attr_name;
-			res_attr->attr.mode = S_IRUSR | S_IWUSR;
-			res_attr->size = pci_resource_len(pdev, i);
-			res_attr->mmap = pci_mmap_resource;
-			res_attr->private = &pdev->resource[i];
-			retval = sysfs_create_bin_file(&pdev->dev.kobj, res_attr);
-			if (retval) {
-				pci_remove_resource_files(pdev);
-				return retval;
-			}
-		} else {
-			return -ENOMEM;
+		retval = pci_create_attr(pdev, i, 0);
+		/* for prefetchable resources, create a WC mappable file */
+		if (!retval && pdev->resource[i].flags & IORESOURCE_PREFETCH)
+			retval = pci_create_attr(pdev, i, 1);
+
+		if (retval) {
+			pci_remove_resource_files(pdev);
+			return retval;
 		}
 	}
 	return 0;

commit bda0c0afa7a694bb1459fd023515aca681e4d79a
Merge: 904e0ab54b75 af40b485ea2d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 21 15:58:35 2008 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/pci-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/pci-2.6: (42 commits)
      PCI: Change PCI subsystem MAINTAINER
      PCI: pci-iommu-iotlb-flushing-speedup
      PCI: pci_setup_bridge() mustn't be __devinit
      PCI: pci_bus_size_cardbus() mustn't be __devinit
      PCI: pci_scan_device() mustn't be __devinit
      PCI: pci_alloc_child_bus() mustn't be __devinit
      PCI: replace remaining __FUNCTION__ occurrences
      PCI: Hotplug: fakephp: Return success, not ENODEV, when bus rescan is triggered
      PCI: Hotplug: Fix leaks in IBM Hot Plug Controller Driver - ibmphp_init_devno()
      PCI: clean up resource alignment management
      PCI: aerdrv_acpi.c: remove unneeded NULL check
      PCI: Update VIA CX700 quirk
      PCI: Expose PCI VPD through sysfs
      PCI: iommu: iotlb flushing
      PCI: simplify quirk debug output
      PCI: iova RB tree setup tweak
      PCI: parisc: use generic pci_enable_resources()
      PCI: ppc: use generic pci_enable_resources()
      PCI: powerpc: use generic pci_enable_resources()
      PCI: ia64: use generic pci_enable_resources()
      ...

commit 94e6108803469a37ee1e3c92dafdd1d59298602f
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Wed Mar 5 16:52:39 2008 +0000

    PCI: Expose PCI VPD through sysfs
    
    Vital Product Data (VPD) may be exposed by PCI devices in several
    ways.  It is generally unsafe to read this information through the
    existing interfaces to user-land because of stateful interfaces.
    
    This adds:
    - abstract operations for VPD access (struct pci_vpd_ops)
    - VPD state information in struct pci_dev (struct pci_vpd)
    - an implementation of the VPD access method specified in PCI 2.2
      (in access.c)
    - a 'vpd' binary file in sysfs directories for PCI devices with VPD
      operations defined
    
    It adds a probe for PCI 2.2 VPD in pci_scan_device() and release of
    VPD state in pci_release_dev().
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index f5b0b622c189..ae9a7695be97 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -343,6 +343,58 @@ pci_write_config(struct kobject *kobj, struct bin_attribute *bin_attr,
 	return count;
 }
 
+static ssize_t
+pci_read_vpd(struct kobject *kobj, struct bin_attribute *bin_attr,
+	     char *buf, loff_t off, size_t count)
+{
+	struct pci_dev *dev =
+		to_pci_dev(container_of(kobj, struct device, kobj));
+	int end;
+	int ret;
+
+	if (off > bin_attr->size)
+		count = 0;
+	else if (count > bin_attr->size - off)
+		count = bin_attr->size - off;
+	end = off + count;
+
+	while (off < end) {
+		ret = dev->vpd->ops->read(dev, off, end - off, buf);
+		if (ret < 0)
+			return ret;
+		buf += ret;
+		off += ret;
+	}
+
+	return count;
+}
+
+static ssize_t
+pci_write_vpd(struct kobject *kobj, struct bin_attribute *bin_attr,
+	      char *buf, loff_t off, size_t count)
+{
+	struct pci_dev *dev =
+		to_pci_dev(container_of(kobj, struct device, kobj));
+	int end;
+	int ret;
+
+	if (off > bin_attr->size)
+		count = 0;
+	else if (count > bin_attr->size - off)
+		count = bin_attr->size - off;
+	end = off + count;
+
+	while (off < end) {
+		ret = dev->vpd->ops->write(dev, off, end - off, buf);
+		if (ret < 0)
+			return ret;
+		buf += ret;
+		off += ret;
+	}
+
+	return count;
+}
+
 #ifdef HAVE_PCI_LEGACY
 /**
  * pci_read_legacy_io - read byte(s) from legacy I/O port space
@@ -611,7 +663,7 @@ int __attribute__ ((weak)) pcibios_add_platform_entries(struct pci_dev *dev)
 
 int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 {
-	struct bin_attribute *rom_attr = NULL;
+	struct bin_attribute *attr = NULL;
 	int retval;
 
 	if (!sysfs_initialized)
@@ -624,22 +676,41 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 	if (retval)
 		goto err;
 
+	/* If the device has VPD, try to expose it in sysfs. */
+	if (pdev->vpd) {
+		attr = kzalloc(sizeof(*attr), GFP_ATOMIC);
+		if (attr) {
+			pdev->vpd->attr = attr;
+			attr->size = pdev->vpd->ops->get_size(pdev);
+			attr->attr.name = "vpd";
+			attr->attr.mode = S_IRUGO | S_IWUSR;
+			attr->read = pci_read_vpd;
+			attr->write = pci_write_vpd;
+			retval = sysfs_create_bin_file(&pdev->dev.kobj, attr);
+			if (retval)
+				goto err_vpd;
+		} else {
+			retval = -ENOMEM;
+			goto err_config_file;
+		}
+	}
+
 	retval = pci_create_resource_files(pdev);
 	if (retval)
-		goto err_bin_file;
+		goto err_vpd_file;
 
 	/* If the device has a ROM, try to expose it in sysfs. */
 	if (pci_resource_len(pdev, PCI_ROM_RESOURCE) ||
 	    (pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW)) {
-		rom_attr = kzalloc(sizeof(*rom_attr), GFP_ATOMIC);
-		if (rom_attr) {
-			pdev->rom_attr = rom_attr;
-			rom_attr->size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
-			rom_attr->attr.name = "rom";
-			rom_attr->attr.mode = S_IRUSR;
-			rom_attr->read = pci_read_rom;
-			rom_attr->write = pci_write_rom;
-			retval = sysfs_create_bin_file(&pdev->dev.kobj, rom_attr);
+		attr = kzalloc(sizeof(*attr), GFP_ATOMIC);
+		if (attr) {
+			pdev->rom_attr = attr;
+			attr->size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
+			attr->attr.name = "rom";
+			attr->attr.mode = S_IRUSR;
+			attr->read = pci_read_rom;
+			attr->write = pci_write_rom;
+			retval = sysfs_create_bin_file(&pdev->dev.kobj, attr);
 			if (retval)
 				goto err_rom;
 		} else {
@@ -657,12 +728,18 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 
 err_rom_file:
 	if (pci_resource_len(pdev, PCI_ROM_RESOURCE))
-		sysfs_remove_bin_file(&pdev->dev.kobj, rom_attr);
+		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->rom_attr);
 err_rom:
-	kfree(rom_attr);
+	kfree(pdev->rom_attr);
 err_resource_files:
 	pci_remove_resource_files(pdev);
-err_bin_file:
+err_vpd_file:
+	if (pdev->vpd) {
+		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->vpd->attr);
+err_vpd:
+		kfree(pdev->vpd->attr);
+	}
+err_config_file:
 	if (pdev->cfg_size < 4096)
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
 	else
@@ -684,6 +761,10 @@ void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
 
 	pcie_aspm_remove_sysfs_dev_files(pdev);
 
+	if (pdev->vpd) {
+		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->vpd->attr);
+		kfree(pdev->vpd->attr);
+	}
 	if (pdev->cfg_size < 4096)
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
 	else

commit 7d715a6c1ae5785d00fb9a876b5abdfc43abc44b
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Mon Feb 25 09:46:41 2008 +0800

    PCI: add PCI Express ASPM support
    
    PCI Express ASPM defines a protocol for PCI Express components in the D0
    state to reduce Link power by placing their Links into a low power state
    and instructing the other end of the Link to do likewise. This
    capability allows hardware-autonomous, dynamic Link power reduction
    beyond what is achievable by software-only controlled power management.
    However, The device should be configured by software appropriately.
    Enabling ASPM will save power, but will introduce device latency.
    
    This patch adds ASPM support in Linux. It introduces a global policy for
    ASPM, a sysfs file /sys/module/pcie_aspm/parameters/policy can control
    it. The interface can be used as a boot option too. Currently we have
    below setting:
            -default, BIOS default setting
            -powersave, highest power saving mode, enable all available ASPM
    state and clock power management
            -performance, highest performance, disable ASPM and clock power
    management
    By default, the 'default' policy is used currently.
    
    In my test, power difference between powersave mode and performance mode
    is about 1.3w in a system with 3 PCIE links.
    
    Note: some devices might not work well with aspm, either because chipset
    issue or device issue. The patch provide API (pci_disable_link_state),
    driver can disable ASPM for specific device.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 8dcf1458aa2f..f5b0b622c189 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -21,6 +21,7 @@
 #include <linux/topology.h>
 #include <linux/mm.h>
 #include <linux/capability.h>
+#include <linux/pci-aspm.h>
 #include "pci.h"
 
 static int sysfs_initialized;	/* = 0 */
@@ -650,6 +651,8 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 	if (pcibios_add_platform_entries(pdev))
 		goto err_rom_file;
 
+	pcie_aspm_create_sysfs_dev_files(pdev);
+
 	return 0;
 
 err_rom_file:
@@ -679,6 +682,8 @@ void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
 	if (!sysfs_initialized)
 		return;
 
+	pcie_aspm_remove_sysfs_dev_files(pdev);
+
 	if (pdev->cfg_size < 4096)
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
 	else

commit 39106dcf85285e78f3b290022122c76f851379b8
Author: Mike Travis <travis@sgi.com>
Date:   Tue Apr 8 11:43:03 2008 -0700

    cpumask: use new cpus_scnprintf function
    
      * Cleaned up references to cpumask_scnprintf() and added new
        cpulist_scnprintf() interfaces where appropriate.
    
      * Fix some small bugs (or code efficiency improvments) for various uses
        of cpumask_scnprintf.
    
      * Clean up some checkpatch errors.
    
    Signed-off-by: Mike Travis <travis@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 8dcf1458aa2f..8d9d648daeba 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -73,8 +73,23 @@ static ssize_t local_cpus_show(struct device *dev,
 
 	mask = pcibus_to_cpumask(to_pci_dev(dev)->bus);
 	len = cpumask_scnprintf(buf, PAGE_SIZE-2, mask);
-	strcat(buf,"\n"); 
-	return 1+len;
+	buf[len++] = '\n';
+	buf[len] = '\0';
+	return len;
+}
+
+
+static ssize_t local_cpulist_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	cpumask_t mask;
+	int len;
+
+	mask = pcibus_to_cpumask(to_pci_dev(dev)->bus);
+	len = cpulist_scnprintf(buf, PAGE_SIZE-2, mask);
+	buf[len++] = '\n';
+	buf[len] = '\0';
+	return len;
 }
 
 /* show resources */
@@ -201,6 +216,7 @@ struct device_attribute pci_dev_attrs[] = {
 	__ATTR_RO(class),
 	__ATTR_RO(irq),
 	__ATTR_RO(local_cpus),
+	__ATTR_RO(local_cpulist),
 	__ATTR_RO(modalias),
 #ifdef CONFIG_NUMA
 	__ATTR_RO(numa_node),

commit cc3a1378b4dd45d3e78dd4aeb10641b06a87d614
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sat Feb 2 11:32:01 2008 -0800

    Revert "PCI: PCIE ASPM support"
    
    This reverts commit 6c723d5bd89f03fc3ef627d50f89ade054d2ee3b.
    
    It caused build errors on non-x86 platforms, config file confusion, and
    even some boot errors on some x86-64 boxes.  All around, not quite ready
    for prime-time :(
    
    Cc: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index abf4203304e4..8dcf1458aa2f 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -21,7 +21,6 @@
 #include <linux/topology.h>
 #include <linux/mm.h>
 #include <linux/capability.h>
-#include <linux/aspm.h>
 #include "pci.h"
 
 static int sysfs_initialized;	/* = 0 */
@@ -651,8 +650,6 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 	if (pcibios_add_platform_entries(pdev))
 		goto err_rom_file;
 
-	pcie_aspm_create_sysfs_dev_files(pdev);
-
 	return 0;
 
 err_rom_file:
@@ -682,8 +679,6 @@ void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
 	if (!sysfs_initialized)
 		return;
 
-	pcie_aspm_remove_sysfs_dev_files(pdev);
-
 	if (pdev->cfg_size < 4096)
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
 	else

commit fd7d1ced29e5beb88c9068801da7a362606d8273
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue May 22 22:47:54 2007 -0400

    PCI: make pci_bus a struct device
    
    This moves the pci_bus class device to be a real struct device and at
    the same time, place it in the device tree in the correct location.
    
    Note, the old "bridge" symlink is now gone, but this was a non-standard
    link and no userspace program used it.  If you need to determine the
    device that the bus is on, follow the standard device symlink, or walk
    up the device tree.
    
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index d05c1b252386..abf4203304e4 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -359,7 +359,7 @@ pci_read_legacy_io(struct kobject *kobj, struct bin_attribute *bin_attr,
 		   char *buf, loff_t off, size_t count)
 {
         struct pci_bus *bus = to_pci_bus(container_of(kobj,
-                                                      struct class_device,
+                                                      struct device,
 						      kobj));
 
         /* Only support 1, 2 or 4 byte accesses */
@@ -384,7 +384,7 @@ pci_write_legacy_io(struct kobject *kobj, struct bin_attribute *bin_attr,
 		    char *buf, loff_t off, size_t count)
 {
         struct pci_bus *bus = to_pci_bus(container_of(kobj,
-						      struct class_device,
+						      struct device,
 						      kobj));
         /* Only support 1, 2 or 4 byte accesses */
         if (count != 1 && count != 2 && count != 4)
@@ -408,7 +408,7 @@ pci_mmap_legacy_mem(struct kobject *kobj, struct bin_attribute *attr,
                     struct vm_area_struct *vma)
 {
         struct pci_bus *bus = to_pci_bus(container_of(kobj,
-                                                      struct class_device,
+                                                      struct device,
 						      kobj));
 
         return pci_mmap_legacy_page_range(bus, vma);

commit 6c723d5bd89f03fc3ef627d50f89ade054d2ee3b
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Thu Jan 24 10:21:57 2008 +0800

    PCI: PCIE ASPM support
    
    PCI Express ASPM defines a protocol for PCI Express components in the D0
    state to reduce Link power by placing their Links into a low power state
    and instructing the other end of the Link to do likewise. This
    capability allows hardware-autonomous, dynamic Link power reduction
    beyond what is achievable by software-only controlled power management.
    However, The device should be configured by software appropriately.
    Enabling ASPM will save power, but will introduce device latency.
    
    This patch adds ASPM support in Linux. It introduces a global policy for
    ASPM, a sysfs file /sys/module/pcie_aspm/parameters/policy can control
    it. The interface can be used as a boot option too. Currently we have
    below setting:
            -default, BIOS default setting
            -powersave, highest power saving mode, enable all available ASPM
    state
    and clock power management
            -performance, highest performance, disable ASPM and clock power
    management
    By default, the 'default' policy is used currently.
    
    In my test, power difference between powersave mode and performance mode
    is about 1.3w in a system with 3 PCIE links.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 7d1877341aad..d05c1b252386 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -21,6 +21,7 @@
 #include <linux/topology.h>
 #include <linux/mm.h>
 #include <linux/capability.h>
+#include <linux/aspm.h>
 #include "pci.h"
 
 static int sysfs_initialized;	/* = 0 */
@@ -650,6 +651,8 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 	if (pcibios_add_platform_entries(pdev))
 		goto err_rom_file;
 
+	pcie_aspm_create_sysfs_dev_files(pdev);
+
 	return 0;
 
 err_rom_file:
@@ -679,6 +682,8 @@ void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
 	if (!sysfs_initialized)
 		return;
 
+	pcie_aspm_remove_sysfs_dev_files(pdev);
+
 	if (pdev->cfg_size < 4096)
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
 	else

commit 151fc5dfc87964e85a1cbbb9cc2c0703c017c2ed
Author: Julia Lawall <julia@diku.dk>
Date:   Tue Nov 20 08:41:16 2007 +0100

    PCI: drivers/pci/pci-sysfs.c: Add missing pci_dev_put
    
    There should be a pci_dev_put when breaking out of a loop that iterates
    over calls to pci_get_device and similar functions.
    
    This was fixed using the following semantic patch.
    
    // <smpl>
    @@
    identifier d;
    type T;
    expression e;
    iterator for_each_pci_dev;
    @@
    
    T *d;
    ...
    for_each_pci_dev(d)
      {... when != pci_dev_put(d)
           when != e = d
    (
       return d;
    |
    +  pci_dev_put(d);
    ?  return ...;
    )
    ...}
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 1b7b2812bf2d..7d1877341aad 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -702,8 +702,10 @@ static int __init pci_sysfs_init(void)
 	sysfs_initialized = 1;
 	for_each_pci_dev(pdev) {
 		retval = pci_create_sysfs_dev_files(pdev);
-		if (retval)
+		if (retval) {
+			pci_dev_put(pdev);
 			return retval;
+		}
 	}
 
 	return 0;

commit aa0ac36518be648dda3a32f0b37a8b2b546e1b24
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sun Jul 15 23:40:39 2007 -0700

    Remove capability.h from mm.h
    
    I forgot to remove capability.h from mm.h while removing sched.h!  This
    patch remedies that, because the only inline function which was using
    CAP_something was made out of line.
    
    Cross-compile tested without regressions on:
    
            all powerpc defconfigs
            all mips defconfigs
            all m68k defconfigs
            all arm defconfigs
            all ia64 defconfigs
    
            alpha alpha-allnoconfig alpha-defconfig alpha-up
            arm
            i386 i386-allnoconfig i386-defconfig i386-up
            ia64 ia64-allnoconfig ia64-defconfig ia64-up
            m68k
            mips
            parisc parisc-allnoconfig parisc-defconfig parisc-up
            powerpc powerpc-up
            s390 s390-allnoconfig s390-defconfig s390-up
            sparc sparc-allnoconfig sparc-defconfig sparc-up
            sparc64 sparc64-allnoconfig sparc64-defconfig sparc64-up
            um-x86_64
            x86_64 x86_64-allnoconfig x86_64-defconfig x86_64-up
    
    as well as my two usual configs.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 10dbdec80416..1b7b2812bf2d 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -20,7 +20,7 @@
 #include <linux/stat.h>
 #include <linux/topology.h>
 #include <linux/mm.h>
-
+#include <linux/capability.h>
 #include "pci.h"
 
 static int sysfs_initialized;	/* = 0 */

commit 21ba0f88ae56da82a3a15fe54d729208b64c4f4b
Merge: dc690d8ef842 36e235901f90
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Thu Jul 12 13:40:57 2007 -0700

    Merge master.kernel.org:/pub/scm/linux/kernel/git/gregkh/pci-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/gregkh/pci-2.6: (34 commits)
      PCI: Only build PCI syscalls on architectures that want them
      PCI: limit pci_get_bus_and_slot to domain 0
      PCI: hotplug: acpiphp: avoid acpiphp "cannot get bridge info" PCI hotplug failure
      PCI: hotplug: acpiphp: remove hot plug parameter write to PCI host bridge
      PCI: hotplug: acpiphp: fix slot poweroff problem on systems without _PS3
      PCI: hotplug: pciehp: wait for 1 second after power off slot
      PCI: pci_set_power_state(): check for PM capabilities earlier
      PCI: cpci_hotplug: Convert to use the kthread API
      PCI: add pci_try_set_mwi
      PCI: pcie: remove SPIN_LOCK_UNLOCKED
      PCI: ROUND_UP macro cleanup in drivers/pci
      PCI: remove pci_dac_dma_... APIs
      PCI: pci-x-pci-express-read-control-interfaces cleanups
      PCI: Fix typo in include/linux/pci.h
      PCI: pci_ids, remove double or more empty lines
      PCI: pci_ids, add atheros and 3com_2 vendors
      PCI: pci_ids, reorder some entries
      PCI: i386: traps, change VENDOR to DEVICE
      PCI: ATM: lanai, change VENDOR to DEVICE
      PCI: Change all drivers to use pci_device->revision
      ...

commit 91a6902958f052358899f58683d44e36228d85c2
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Sat Jun 9 13:57:22 2007 +0800

    sysfs: add parameter "struct bin_attribute *" in .read/.write methods for sysfs binary attributes
    
    Well, first of all, I don't want to change so many files either.
    
    What I do:
    Adding a new parameter "struct bin_attribute *" in the
    .read/.write methods for the sysfs binary attributes.
    
    In fact, only the four lines change in fs/sysfs/bin.c and
    include/linux/sysfs.h do the real work.
    But I have to update all the files that use binary attributes
    to make them compatible with the new .read and .write methods.
    I'm not sure if I missed any. :(
    
    Why I do this:
    For a sysfs attribute, we can get a pointer pointing to the
    struct attribute in the .show/.store method,
    while we can't do this for the binary attributes.
    I don't know why this is different, but this does make it not
    so handy to use the binary attributes as the regular ones.
    So I think this patch is reasonable. :)
    
    Who benefits from it:
    The patch that exposes ACPI tables in sysfs
    requires such an improvement.
    All the table binary attributes share the same .read method.
    Parameter "struct bin_attribute *" is used to get
    the table signature and instance number which are used to
    distinguish different ACPI table binary attributes.
    
    Without this parameter, we need to offer different .read methods
    for different ACPI table binary attributes.
    This is impossible as there are various ACPI tables on different
    platforms, and we don't know what they are until they are loaded.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index d448f8df8613..6543cbe83be5 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -213,7 +213,8 @@ struct device_attribute pci_dev_attrs[] = {
 };
 
 static ssize_t
-pci_read_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
+pci_read_config(struct kobject *kobj, struct bin_attribute *bin_attr,
+		char *buf, loff_t off, size_t count)
 {
 	struct pci_dev *dev = to_pci_dev(container_of(kobj,struct device,kobj));
 	unsigned int size = 64;
@@ -285,7 +286,8 @@ pci_read_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
 }
 
 static ssize_t
-pci_write_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
+pci_write_config(struct kobject *kobj, struct bin_attribute *bin_attr,
+		 char *buf, loff_t off, size_t count)
 {
 	struct pci_dev *dev = to_pci_dev(container_of(kobj,struct device,kobj));
 	unsigned int size = count;
@@ -352,7 +354,8 @@ pci_write_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
  * callback routine (pci_legacy_read).
  */
 ssize_t
-pci_read_legacy_io(struct kobject *kobj, char *buf, loff_t off, size_t count)
+pci_read_legacy_io(struct kobject *kobj, struct bin_attribute *bin_attr,
+		   char *buf, loff_t off, size_t count)
 {
         struct pci_bus *bus = to_pci_bus(container_of(kobj,
                                                       struct class_device,
@@ -376,7 +379,8 @@ pci_read_legacy_io(struct kobject *kobj, char *buf, loff_t off, size_t count)
  * callback routine (pci_legacy_write).
  */
 ssize_t
-pci_write_legacy_io(struct kobject *kobj, char *buf, loff_t off, size_t count)
+pci_write_legacy_io(struct kobject *kobj, struct bin_attribute *bin_attr,
+		    char *buf, loff_t off, size_t count)
 {
         struct pci_bus *bus = to_pci_bus(container_of(kobj,
 						      struct class_device,
@@ -528,7 +532,8 @@ static inline void pci_remove_resource_files(struct pci_dev *dev) { return; }
  * writing anything except 0 enables it
  */
 static ssize_t
-pci_write_rom(struct kobject *kobj, char *buf, loff_t off, size_t count)
+pci_write_rom(struct kobject *kobj, struct bin_attribute *bin_attr,
+	      char *buf, loff_t off, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(container_of(kobj, struct device, kobj));
 
@@ -551,7 +556,8 @@ pci_write_rom(struct kobject *kobj, char *buf, loff_t off, size_t count)
  * device corresponding to @kobj.
  */
 static ssize_t
-pci_read_rom(struct kobject *kobj, char *buf, loff_t off, size_t count)
+pci_read_rom(struct kobject *kobj, struct bin_attribute *bin_attr,
+	     char *buf, loff_t off, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(container_of(kobj, struct device, kobj));
 	void __iomem *rom;

commit 7b595756ec1f49e0049a9e01a1298d53a7faaa15
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jun 14 03:45:17 2007 +0900

    sysfs: kill unnecessary attribute->owner
    
    sysfs is now completely out of driver/module lifetime game.  After
    deletion, a sysfs node doesn't access anything outside sysfs proper,
    so there's no reason to hold onto the attribute owners.  Note that
    often the wrong modules were accounted for as owners leading to
    accessing removed modules.
    
    This patch kills now unnecessary attribute->owner.  Note that with
    this change, userland holding a sysfs node does not prevent the
    backing module from being unloaded.
    
    For more info regarding lifetime rule cleanup, please read the
    following message.
    
      http://article.gmane.org/gmane.linux.kernel/510293
    
    (tweaked by Greg to not delete the field just yet, to make it easier to
    merge things properly.)
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 284e83a527f9..d448f8df8613 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -499,7 +499,6 @@ static int pci_create_resource_files(struct pci_dev *pdev)
 			sprintf(res_attr_name, "resource%d", i);
 			res_attr->attr.name = res_attr_name;
 			res_attr->attr.mode = S_IRUSR | S_IWUSR;
-			res_attr->attr.owner = THIS_MODULE;
 			res_attr->size = pci_resource_len(pdev, i);
 			res_attr->mmap = pci_mmap_resource;
 			res_attr->private = &pdev->resource[i];
@@ -582,7 +581,6 @@ static struct bin_attribute pci_config_attr = {
 	.attr =	{
 		.name = "config",
 		.mode = S_IRUGO | S_IWUSR,
-		.owner = THIS_MODULE,
 	},
 	.size = 256,
 	.read = pci_read_config,
@@ -593,7 +591,6 @@ static struct bin_attribute pcie_config_attr = {
 	.attr =	{
 		.name = "config",
 		.mode = S_IRUGO | S_IWUSR,
-		.owner = THIS_MODULE,
 	},
 	.size = 4096,
 	.read = pci_read_config,
@@ -628,7 +625,6 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 			rom_attr->size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
 			rom_attr->attr.name = "rom";
 			rom_attr->attr.mode = S_IRUSR;
-			rom_attr->attr.owner = THIS_MODULE;
 			rom_attr->read = pci_read_rom;
 			rom_attr->write = pci_write_rom;
 			retval = sysfs_create_bin_file(&pdev->dev.kobj, rom_attr);

commit a2cd52ca904f5913651e71764755e712894ccc2f
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Tue May 8 12:03:08 2007 +1000

    PCI: Make pcibios_add_platform_entries() return errors
    
    Currently pcibios_add_platform_entries() returns void, but could fail,
    so instead have it return an int and propagate errors up to
    pci_create_sysfs_dev_files().
    
    Fixes:
    arch/powerpc/kernel/pci_64.c: In function 'pcibios_add_platform_entries':
    arch/powerpc/kernel/pci_64.c:878: warning: ignoring return value of
            'device_create_file', declared with attribute warn_unused_result
    arch/powerpc/kernel/pci_32.c: In function 'pcibios_add_platform_entries':
      arch/powerpc/kernel/pci_32.c:1043: warning: ignoring return value of
            'device_create_file', declared with attribute warn_unused_result
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index e5737f0b3997..9c4a123eacd1 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -600,9 +600,9 @@ static struct bin_attribute pcie_config_attr = {
 	.write = pci_write_config,
 };
 
-void __attribute__ ((weak)) pcibios_add_platform_entries(struct pci_dev *dev)
+int __attribute__ ((weak)) pcibios_add_platform_entries(struct pci_dev *dev)
 {
-	return;
+	return 0;
 }
 
 int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
@@ -645,10 +645,14 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 		}
 	}
 	/* add platform-specific attributes */
-	pcibios_add_platform_entries(pdev);
+	if (pcibios_add_platform_entries(pdev))
+		goto err_rom_file;
 
 	return 0;
 
+err_rom_file:
+	if (pci_resource_len(pdev, PCI_ROM_RESOURCE))
+		sysfs_remove_bin_file(&pdev->dev.kobj, rom_attr);
 err_rom:
 	kfree(rom_attr);
 err_resource_files:

commit 575e3348cb80c3265278756778d5091d5ca4efbf
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Tue May 8 12:03:07 2007 +1000

    PCI: Use a weak symbol for the empty version of pcibios_add_platform_entries()
    
    I'm not sure if this is going to fly, weak symbols work on the compilers I'm
    using, but whether they work for all of the affected architectures I can't say.
    I've cc'ed as many arch maintainers/lists as I could find.
    
    But assuming they do, we can use a weak empty definition of
    pcibios_add_platform_entries() to avoid having an empty definition on every
    arch.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 284e83a527f9..e5737f0b3997 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -600,6 +600,11 @@ static struct bin_attribute pcie_config_attr = {
 	.write = pci_write_config,
 };
 
+void __attribute__ ((weak)) pcibios_add_platform_entries(struct pci_dev *dev)
+{
+	return;
+}
+
 int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 {
 	struct bin_attribute *rom_attr = NULL;

commit 9890b12a4a65a7b3181dd963421740edf0e14d69
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Wed Apr 18 13:34:12 2007 +1000

    PCI: Free resource files in error path of pci_create_sysfs_dev_files()
    
    pci_create_sysfs_dev_files() should call pci_remove_resource_files() in
    its error path, to match the call it makes to pci_create_resource_files().
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 29676fe4f23e..284e83a527f9 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -636,7 +636,7 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 				goto err_rom;
 		} else {
 			retval = -ENOMEM;
-			goto err_bin_file;
+			goto err_resource_files;
 		}
 	}
 	/* add platform-specific attributes */
@@ -646,6 +646,8 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 
 err_rom:
 	kfree(rom_attr);
+err_resource_files:
+	pci_remove_resource_files(pdev);
 err_bin_file:
 	if (pdev->cfg_size < 4096)
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);

commit 40ee9e9f8d52d85f2446bbdda7823a3f1de62f3f
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Sat Mar 24 11:03:32 2007 -0700

    PCI: fix sysfs rom file creation for BIOS ROM shadows
    
    At one time, if a BIOS ROM shadow was detected for the boot video
    device (stored at offset 0xc0000), we'd set a special resource flag,
    IORESOURCE_ROM_SHADOW, so that the sysfs ROM file code could handle
    it properly.  That broke along the way somewhere though, so current
    kernels will be missing 'rom' files in sysfs if the video device
    doesn't have an explicit ROM BAR.
    
    This patch fixes the regression by moving the video fixup quirk to a
    little later in the boot cycle (to avoid having its work undone by
    PCI resource allocation) and checking in the PCI sysfs code whether
    a rom file should be created due to a shadow resource, which is also
    moved to a little later in the boot cycle so it will occur after the
    video fixup.  Tested and works on my i386 test box.
    
    Signed-off-by:  Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index cd913a2a416f..29676fe4f23e 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -620,7 +620,8 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 		goto err_bin_file;
 
 	/* If the device has a ROM, try to expose it in sysfs. */
-	if (pci_resource_len(pdev, PCI_ROM_RESOURCE)) {
+	if (pci_resource_len(pdev, PCI_ROM_RESOURCE) ||
+	    (pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW)) {
 		rom_attr = kzalloc(sizeof(*rom_attr), GFP_ATOMIC);
 		if (rom_attr) {
 			pdev->rom_attr = rom_attr;
@@ -695,4 +696,4 @@ static int __init pci_sysfs_init(void)
 	return 0;
 }
 
-__initcall(pci_sysfs_init);
+late_initcall(pci_sysfs_init);

commit 81bb0e198b4638ac65233b316f4588639dfe1fcd
Author: Brice Goglin <Brice.Goglin@ens-lyon.org>
Date:   Sun Jan 28 10:53:40 2007 +0100

    PCI: Make PCI device numa-node attribute visible in sysfs
    
    Export the numa-node attribute of PCI devices in sysfs so that
    user applications may choose where to be placed accordingly.
    
    Signed-off-by: Brice Goglin <Brice.Goglin@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 7a94076752d0..cd913a2a416f 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -143,6 +143,14 @@ static ssize_t is_enabled_show(struct device *dev,
 	return sprintf (buf, "%u\n", atomic_read(&pdev->enable_cnt));
 }
 
+#ifdef CONFIG_NUMA
+static ssize_t
+numa_node_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf (buf, "%d\n", dev->numa_node);
+}
+#endif
+
 static ssize_t
 msi_bus_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
@@ -194,6 +202,9 @@ struct device_attribute pci_dev_attrs[] = {
 	__ATTR_RO(irq),
 	__ATTR_RO(local_cpus),
 	__ATTR_RO(modalias),
+#ifdef CONFIG_NUMA
+	__ATTR_RO(numa_node),
+#endif
 	__ATTR(enable, 0600, is_enabled_show, is_enabled_store),
 	__ATTR(broken_parity_status,(S_IRUGO|S_IWUSR),
 		broken_parity_status_show,broken_parity_status_store),

commit bae94d02371c402408a4edfb95e71e88dbd3e973
Author: Inaky Perez-Gonzalez <inaky@linux.intel.com>
Date:   Wed Nov 22 12:40:31 2006 -0800

    PCI: switch pci_{enable,disable}_device() to be nestable
    
    Changes the pci_{enable,disable}_device() functions to work in a
    nested basis, so that eg, three calls to enable_device() require three
    calls to disable_device().
    
    The reason for this is to simplify PCI drivers for
    multi-interface/capability devices. These are devices that cram more
    than one interface in a single function. A relevant example of that is
    the Wireless [USB] Host Controller Interface (similar to EHCI) [see
    http://www.intel.com/technology/comms/wusb/whci.htm].
    
    In these kind of devices, multiple interfaces are accessed through a
    single bar and IRQ line. For that, the drivers map only the smallest
    area of the bar to access their register banks and use shared IRQ
    handlers.
    
    However, because the order at which those drivers load cannot be known
    ahead of time, the sequence in which the calls to pci_enable_device()
    and pci_disable_device() cannot be predicted. Thus:
    
    1. driverA     starts     pci_enable_device()
    2. driverB     starts     pci_enable_device()
    3. driverA     shutdown   pci_disable_device()
    4. driverB     shutdown   pci_disable_device()
    
    between steps 3 and 4, driver B would loose access to it's device,
    even if it didn't intend to.
    
    By using this modification, the device won't be disabled until all the
    callers to enable() have called disable().
    
    This is implemented by replacing 'struct pci_dev->is_enabled' from a
    bitfield to an atomic use count. Each caller to enable increments it,
    each caller to disable decrements it. When the count increments from 0
    to 1, __pci_enable_device() is called to actually enable the
    device. When it drops to zero, pci_disable_device() actually does the
    disabling.
    
    We keep the backend __pci_enable_device() for pci_default_resume() to
    use and also change the sysfs method implementation, so that userspace
    enabling/disabling the device doesn't disable it one time too much.
    
    Signed-off-by: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index f952bfea48a6..7a94076752d0 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -42,7 +42,6 @@ pci_config_attr(subsystem_vendor, "0x%04x\n");
 pci_config_attr(subsystem_device, "0x%04x\n");
 pci_config_attr(class, "0x%06x\n");
 pci_config_attr(irq, "%u\n");
-pci_config_attr(is_enabled, "%u\n");
 
 static ssize_t broken_parity_status_show(struct device *dev,
 					 struct device_attribute *attr,
@@ -112,26 +111,36 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,
 		       (u8)(pci_dev->class >> 16), (u8)(pci_dev->class >> 8),
 		       (u8)(pci_dev->class));
 }
-static ssize_t
-is_enabled_store(struct device *dev, struct device_attribute *attr,
-		const char *buf, size_t count)
+
+static ssize_t is_enabled_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
 {
+	ssize_t result = -EINVAL;
 	struct pci_dev *pdev = to_pci_dev(dev);
-	int retval = 0;
 
 	/* this can crash the machine when done on the "wrong" device */
 	if (!capable(CAP_SYS_ADMIN))
 		return count;
 
-	if (*buf == '0')
-		pci_disable_device(pdev);
+	if (*buf == '0') {
+		if (atomic_read(&pdev->enable_cnt) != 0)
+			pci_disable_device(pdev);
+		else
+			result = -EIO;
+	} else if (*buf == '1')
+		result = pci_enable_device(pdev);
+
+	return result < 0 ? result : count;
+}
 
-	if (*buf == '1')
-		retval = pci_enable_device(pdev);
+static ssize_t is_enabled_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct pci_dev *pdev;
 
-	if (retval)
-		return retval;
-	return count;
+	pdev = to_pci_dev (dev);
+	return sprintf (buf, "%u\n", atomic_read(&pdev->enable_cnt));
 }
 
 static ssize_t

commit d67afe5ed00070de0965bfc98de5f6ed3a80a73e
Author: David Miller <davem@davemloft.net>
Date:   Fri Nov 10 12:27:48 2006 -0800

    [PATCH] pci: don't try to remove sysfs files before they are setup.
    
    The PCI sysfs attributes are created after the initial PCI bus scan.  With
    the addition of more return value checking and assertions in the device and
    sysfs layers we now can get dumps like this on sparc64:
    
    [   20.135032] Call Trace:
    [   20.135042]  [0000000000537f88] pci_remove_bus_device+0x30/0xc0
    [   20.135076]  [000000000078f890] pci_fill_in_pbm_cookies+0x98/0x440
    [   20.135109]  [000000000042e828] sabre_scan_bus+0x230/0x400
    [   20.135139]  [000000000078c710] pcibios_init+0x58/0xa0
    [   20.135159]  [0000000000416f14] init+0x9c/0x2e0
    [   20.135190]  [0000000000417a50] kernel_thread+0x38/0x60
    [   20.135211]  [0000000000417170] rest_init+0x18/0x40
    [   20.135514] PCI0(PBMB): Bus running at 33MHz
    
    It's triggering because removal of the "config" PCI sysfs file for the
    device fails.
    
    On sparc64, after probing the device, we'll delete the PCI device via
    pci_remove_bus_device() if we cannot find the firmware device tree node
    corresponding to it.
    
    This is fine, but at this point the sysfs files for the PCI device won't be
    setup yet.
    
    So we should not try to do anything in pci_remove_sysfs_dev_files() if
    pci_sysfs_init() has not run yet.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index a1d2e979b17f..f952bfea48a6 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -642,6 +642,9 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
  */
 void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
 {
+	if (!sysfs_initialized)
+		return;
+
 	if (pdev->cfg_size < 4096)
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
 	else

commit b19441af185559118e8247382ea4f2f76ebffc6d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 28 11:43:25 2006 -0700

    PCI: fix __must_check warnings
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 010e01c4bd43..a1d2e979b17f 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -117,6 +117,7 @@ is_enabled_store(struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
+	int retval = 0;
 
 	/* this can crash the machine when done on the "wrong" device */
 	if (!capable(CAP_SYS_ADMIN))
@@ -126,8 +127,10 @@ is_enabled_store(struct device *dev, struct device_attribute *attr,
 		pci_disable_device(pdev);
 
 	if (*buf == '1')
-		pci_enable_device(pdev);
+		retval = pci_enable_device(pdev);
 
+	if (retval)
+		return retval;
 	return count;
 }
 
@@ -425,16 +428,39 @@ pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 	return pci_mmap_page_range(pdev, vma, mmap_type, 0);
 }
 
+/**
+ * pci_remove_resource_files - cleanup resource files
+ * @dev: dev to cleanup
+ *
+ * If we created resource files for @dev, remove them from sysfs and
+ * free their resources.
+ */
+static void
+pci_remove_resource_files(struct pci_dev *pdev)
+{
+	int i;
+
+	for (i = 0; i < PCI_ROM_RESOURCE; i++) {
+		struct bin_attribute *res_attr;
+
+		res_attr = pdev->res_attr[i];
+		if (res_attr) {
+			sysfs_remove_bin_file(&pdev->dev.kobj, res_attr);
+			kfree(res_attr);
+		}
+	}
+}
+
 /**
  * pci_create_resource_files - create resource files in sysfs for @dev
  * @dev: dev in question
  *
  * Walk the resources in @dev creating files for each resource available.
  */
-static void
-pci_create_resource_files(struct pci_dev *pdev)
+static int pci_create_resource_files(struct pci_dev *pdev)
 {
 	int i;
+	int retval;
 
 	/* Expose the PCI resources from this device as files */
 	for (i = 0; i < PCI_ROM_RESOURCE; i++) {
@@ -457,35 +483,19 @@ pci_create_resource_files(struct pci_dev *pdev)
 			res_attr->size = pci_resource_len(pdev, i);
 			res_attr->mmap = pci_mmap_resource;
 			res_attr->private = &pdev->resource[i];
-			sysfs_create_bin_file(&pdev->dev.kobj, res_attr);
-		}
-	}
-}
-
-/**
- * pci_remove_resource_files - cleanup resource files
- * @dev: dev to cleanup
- *
- * If we created resource files for @dev, remove them from sysfs and
- * free their resources.
- */
-static void
-pci_remove_resource_files(struct pci_dev *pdev)
-{
-	int i;
-
-	for (i = 0; i < PCI_ROM_RESOURCE; i++) {
-		struct bin_attribute *res_attr;
-
-		res_attr = pdev->res_attr[i];
-		if (res_attr) {
-			sysfs_remove_bin_file(&pdev->dev.kobj, res_attr);
-			kfree(res_attr);
+			retval = sysfs_create_bin_file(&pdev->dev.kobj, res_attr);
+			if (retval) {
+				pci_remove_resource_files(pdev);
+				return retval;
+			}
+		} else {
+			return -ENOMEM;
 		}
 	}
+	return 0;
 }
 #else /* !HAVE_PCI_MMAP */
-static inline void pci_create_resource_files(struct pci_dev *dev) { return; }
+static inline int pci_create_resource_files(struct pci_dev *dev) { return 0; }
 static inline void pci_remove_resource_files(struct pci_dev *dev) { return; }
 #endif /* HAVE_PCI_MMAP */
 
@@ -570,22 +580,27 @@ static struct bin_attribute pcie_config_attr = {
 	.write = pci_write_config,
 };
 
-int pci_create_sysfs_dev_files (struct pci_dev *pdev)
+int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 {
+	struct bin_attribute *rom_attr = NULL;
+	int retval;
+
 	if (!sysfs_initialized)
 		return -EACCES;
 
 	if (pdev->cfg_size < 4096)
-		sysfs_create_bin_file(&pdev->dev.kobj, &pci_config_attr);
+		retval = sysfs_create_bin_file(&pdev->dev.kobj, &pci_config_attr);
 	else
-		sysfs_create_bin_file(&pdev->dev.kobj, &pcie_config_attr);
+		retval = sysfs_create_bin_file(&pdev->dev.kobj, &pcie_config_attr);
+	if (retval)
+		goto err;
 
-	pci_create_resource_files(pdev);
+	retval = pci_create_resource_files(pdev);
+	if (retval)
+		goto err_bin_file;
 
 	/* If the device has a ROM, try to expose it in sysfs. */
 	if (pci_resource_len(pdev, PCI_ROM_RESOURCE)) {
-		struct bin_attribute *rom_attr;
-		
 		rom_attr = kzalloc(sizeof(*rom_attr), GFP_ATOMIC);
 		if (rom_attr) {
 			pdev->rom_attr = rom_attr;
@@ -595,13 +610,28 @@ int pci_create_sysfs_dev_files (struct pci_dev *pdev)
 			rom_attr->attr.owner = THIS_MODULE;
 			rom_attr->read = pci_read_rom;
 			rom_attr->write = pci_write_rom;
-			sysfs_create_bin_file(&pdev->dev.kobj, rom_attr);
+			retval = sysfs_create_bin_file(&pdev->dev.kobj, rom_attr);
+			if (retval)
+				goto err_rom;
+		} else {
+			retval = -ENOMEM;
+			goto err_bin_file;
 		}
 	}
 	/* add platform-specific attributes */
 	pcibios_add_platform_entries(pdev);
-	
+
 	return 0;
+
+err_rom:
+	kfree(rom_attr);
+err_bin_file:
+	if (pdev->cfg_size < 4096)
+		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
+	else
+		sysfs_remove_bin_file(&pdev->dev.kobj, &pcie_config_attr);
+err:
+	return retval;
 }
 
 /**
@@ -630,10 +660,14 @@ void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
 static int __init pci_sysfs_init(void)
 {
 	struct pci_dev *pdev = NULL;
-	
+	int retval;
+
 	sysfs_initialized = 1;
-	for_each_pci_dev(pdev)
-		pci_create_sysfs_dev_files(pdev);
+	for_each_pci_dev(pdev) {
+		retval = pci_create_sysfs_dev_files(pdev);
+		if (retval)
+			return retval;
+	}
 
 	return 0;
 }

commit fe97064c2870e174a6ff4a93feb11a70c4b71cc5
Author: Brice Goglin <brice@myri.com>
Date:   Thu Aug 31 01:55:15 2006 -0400

    MSI: Export the PCI_BUS_FLAGS_NO_MSI flag in sysfs
    
    Export the PCI_BUS_FLAGS_NO_MSI flag of a PCI bus in the sysfs files
    of its parent device and make it writable. Could be used to:
    * disable MSI on a device which has not been blacklisted yet
    * allow MSI when some setpci hacks enable MSI support (for instance
      on the ServerWorks HT2000 chipset where the MSI HT cap is disabled
      by default).
    Architecture where some bus have no parent chipset cannot use this
    strategy to change MSI support.
    
    If the chipset does not have a subordinate bus, its 'bus_msi' file
    is empty.
    
    Also document and warn about the possible danger of changing the flag.
    
    Signed-off-by: Brice Goglin <brice@myri.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index fdefa7dcd156..010e01c4bd43 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -131,6 +131,46 @@ is_enabled_store(struct device *dev, struct device_attribute *attr,
 	return count;
 }
 
+static ssize_t
+msi_bus_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	if (!pdev->subordinate)
+		return 0;
+
+	return sprintf (buf, "%u\n",
+			!(pdev->subordinate->bus_flags & PCI_BUS_FLAGS_NO_MSI));
+}
+
+static ssize_t
+msi_bus_store(struct device *dev, struct device_attribute *attr,
+	      const char *buf, size_t count)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	/* bad things may happen if the no_msi flag is changed
+	 * while some drivers are loaded */
+	if (!capable(CAP_SYS_ADMIN))
+		return count;
+
+	if (!pdev->subordinate)
+		return count;
+
+	if (*buf == '0') {
+		pdev->subordinate->bus_flags |= PCI_BUS_FLAGS_NO_MSI;
+		dev_warn(&pdev->dev, "forced subordinate bus to not support MSI,"
+			 " bad things could happen.\n");
+	}
+
+	if (*buf == '1') {
+		pdev->subordinate->bus_flags &= ~PCI_BUS_FLAGS_NO_MSI;
+		dev_warn(&pdev->dev, "forced subordinate bus to support MSI,"
+			 " bad things could happen.\n");
+	}
+
+	return count;
+}
 
 struct device_attribute pci_dev_attrs[] = {
 	__ATTR_RO(resource),
@@ -145,6 +185,7 @@ struct device_attribute pci_dev_attrs[] = {
 	__ATTR(enable, 0600, is_enabled_show, is_enabled_store),
 	__ATTR(broken_parity_status,(S_IRUGO|S_IWUSR),
 		broken_parity_status_show,broken_parity_status_store),
+	__ATTR(msi_bus, 0644, msi_bus_show, msi_bus_store),
 	__ATTR_NULL,
 };
 

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 606f9b6f70eb..fdefa7dcd156 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -15,7 +15,6 @@
  */
 
 
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <linux/stat.h>

commit e31dd6e4520439ceae4753f32dd2da2c345e929a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 17:06:02 2006 -0700

    [PATCH] 64bit resource: change pci core and arch code to use resource_size_t
    
    Based on a patch series originally from Vivek Goyal <vgoyal@in.ibm.com>
    
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index bc405c035ce3..606f9b6f70eb 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -87,7 +87,7 @@ resource_show(struct device * dev, struct device_attribute *attr, char * buf)
 	char * str = buf;
 	int i;
 	int max = 7;
-	u64 start, end;
+	resource_size_t start, end;
 
 	if (pci_dev->subordinate)
 		max = DEVICE_COUNT_RESOURCE;
@@ -365,7 +365,7 @@ pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 						       struct device, kobj));
 	struct resource *res = (struct resource *)attr->private;
 	enum pci_mmap_state mmap_type;
-	u64 start, end;
+	resource_size_t start, end;
 	int i;
 
 	for (i = 0; i < PCI_ROM_RESOURCE; i++)

commit bdee9d98d281d84718eaff6bf0dd2b6ad418b36f
Author: Doug Thompson <norsk5@yahoo.com>
Date:   Wed Jun 14 16:59:48 2006 -0700

    [PATCH] PCI: Bus Parity Status sysfs interface
    
    From: Doug Thompson <norsk5@yahoo.com>
    
    This patch adds the 'broken_parity_status' sysfs attribute file to a PCI device.
    Reading this attribute a userland program can determine if PCI device provides false
    positives (value of 1) in its generation of PCI Parity status, or not (value of 0).
    As PCI devices are found to be 'bad' in this regard, userland programs can also set
    the appropriate value (root access only) of a faulty device. This per device
    information will be used in the EDAC PCI Parity scanner code in a future patch once
    this interface becomes available.
    
    Signed-off-by: Doug Thompson <norsk5@yahoo.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 37897a8c95e0..bc405c035ce3 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -45,6 +45,28 @@ pci_config_attr(class, "0x%06x\n");
 pci_config_attr(irq, "%u\n");
 pci_config_attr(is_enabled, "%u\n");
 
+static ssize_t broken_parity_status_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	return sprintf (buf, "%u\n", pdev->broken_parity_status);
+}
+
+static ssize_t broken_parity_status_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	ssize_t consumed = -EINVAL;
+
+	if ((count > 0) && (*buf == '0' || *buf == '1')) {
+		pdev->broken_parity_status = *buf == '1' ? 1 : 0;
+		consumed = count;
+	}
+	return consumed;
+}
+
 static ssize_t local_cpus_show(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {		
@@ -122,6 +144,8 @@ struct device_attribute pci_dev_attrs[] = {
 	__ATTR_RO(local_cpus),
 	__ATTR_RO(modalias),
 	__ATTR(enable, 0600, is_enabled_show, is_enabled_store),
+	__ATTR(broken_parity_status,(S_IRUGO|S_IWUSR),
+		broken_parity_status_show,broken_parity_status_store),
 	__ATTR_NULL,
 };
 

commit 9f125d30487cea72542a84b4835c037163c7f3d5
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Sat Apr 29 10:59:08 2006 +0200

    [PATCH] PCI: Add a "enable" sysfs attribute to the pci devices to allow userspace (Xorg) to enable devices without doing foul direct access
    
    This patch adds an "enable" sysfs attribute to each PCI device. When read it
    shows the "enabled-ness" of the device, but you can write a "0" into it to
    disable a device, and a "1" to enable it.
    
    This later is needed for X and other cases where userspace wants to enable
    the BARs on a device (typical example: to run the video bios on a secundary
    head). Right now X does all this "by hand" via bitbanging, that's just evil.
    This allows X to no longer do that but to just let the kernel do this.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    CC: Peter Jones <pjones@redhat.com>
    Acked-by: Dave Airlie <airlied@linux.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 56ac2bc003c7..37897a8c95e0 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -43,6 +43,7 @@ pci_config_attr(subsystem_vendor, "0x%04x\n");
 pci_config_attr(subsystem_device, "0x%04x\n");
 pci_config_attr(class, "0x%06x\n");
 pci_config_attr(irq, "%u\n");
+pci_config_attr(is_enabled, "%u\n");
 
 static ssize_t local_cpus_show(struct device *dev,
 			struct device_attribute *attr, char *buf)
@@ -90,6 +91,25 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,
 		       (u8)(pci_dev->class >> 16), (u8)(pci_dev->class >> 8),
 		       (u8)(pci_dev->class));
 }
+static ssize_t
+is_enabled_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	/* this can crash the machine when done on the "wrong" device */
+	if (!capable(CAP_SYS_ADMIN))
+		return count;
+
+	if (*buf == '0')
+		pci_disable_device(pdev);
+
+	if (*buf == '1')
+		pci_enable_device(pdev);
+
+	return count;
+}
+
 
 struct device_attribute pci_dev_attrs[] = {
 	__ATTR_RO(resource),
@@ -101,6 +121,7 @@ struct device_attribute pci_dev_attrs[] = {
 	__ATTR_RO(irq),
 	__ATTR_RO(local_cpus),
 	__ATTR_RO(modalias),
+	__ATTR(enable, 0600, is_enabled_show, is_enabled_store),
 	__ATTR_NULL,
 };
 

commit f5afe8064f3087bead8fea7e32547c2a3ada5fd0
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Tue Feb 28 15:34:49 2006 +0100

    [PATCH] PCI: kzalloc() conversion in drivers/pci
    
    this patch converts drivers/pci to kzalloc usage.
    Compile tested with allyes config.
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 965a5934623a..56ac2bc003c7 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -501,9 +501,8 @@ int pci_create_sysfs_dev_files (struct pci_dev *pdev)
 	if (pci_resource_len(pdev, PCI_ROM_RESOURCE)) {
 		struct bin_attribute *rom_attr;
 		
-		rom_attr = kmalloc(sizeof(*rom_attr), GFP_ATOMIC);
+		rom_attr = kzalloc(sizeof(*rom_attr), GFP_ATOMIC);
 		if (rom_attr) {
-			memset(rom_attr, 0x00, sizeof(*rom_attr));
 			pdev->rom_attr = rom_attr;
 			rom_attr->size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
 			rom_attr->attr.name = "rom";

commit e04b0ea2e0f9c1bb0d874db4493fc7f7a623116b
Author: Brian King <brking@us.ibm.com>
Date:   Tue Sep 27 01:21:55 2005 -0700

    [PATCH] PCI: Block config access during BIST
    
    Some PCI adapters (eg.  ipr scsi adapters) have an exposure today in that they
    issue BIST to the adapter to reset the card.  If, during the time it takes to
    complete BIST, userspace attempts to access PCI config space, the host bus
    bridge will master abort the access since the ipr adapter does not respond on
    the PCI bus for a brief period of time when running BIST.  On PPC64 hardware,
    this master abort results in the host PCI bridge isolating that PCI device
    from the rest of the system, making the device unusable until Linux is
    rebooted.  This patch is an attempt to close that exposure by introducing some
    blocking code in the PCI code.  When blocked, writes will be humored and reads
    will return the cached value.  Ben Herrenschmidt has also mentioned that he
    plans to use this in PPC power management.
    
    Signed-off-by: Brian King <brking@us.ibm.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/pci/access.c    |   89 ++++++++++++++++++++++++++++++++++++++++++++++++
     drivers/pci/pci-sysfs.c |   20 +++++-----
     drivers/pci/pci.h       |    7 +++
     drivers/pci/proc.c      |   28 +++++++--------
     drivers/pci/syscall.c   |   14 +++----
     include/linux/pci.h     |    7 +++
     6 files changed, 134 insertions(+), 31 deletions(-)

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 2898830c496f..965a5934623a 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -130,7 +130,7 @@ pci_read_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
 
 	if ((off & 1) && size) {
 		u8 val;
-		pci_read_config_byte(dev, off, &val);
+		pci_user_read_config_byte(dev, off, &val);
 		data[off - init_off] = val;
 		off++;
 		size--;
@@ -138,7 +138,7 @@ pci_read_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
 
 	if ((off & 3) && size > 2) {
 		u16 val;
-		pci_read_config_word(dev, off, &val);
+		pci_user_read_config_word(dev, off, &val);
 		data[off - init_off] = val & 0xff;
 		data[off - init_off + 1] = (val >> 8) & 0xff;
 		off += 2;
@@ -147,7 +147,7 @@ pci_read_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
 
 	while (size > 3) {
 		u32 val;
-		pci_read_config_dword(dev, off, &val);
+		pci_user_read_config_dword(dev, off, &val);
 		data[off - init_off] = val & 0xff;
 		data[off - init_off + 1] = (val >> 8) & 0xff;
 		data[off - init_off + 2] = (val >> 16) & 0xff;
@@ -158,7 +158,7 @@ pci_read_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
 
 	if (size >= 2) {
 		u16 val;
-		pci_read_config_word(dev, off, &val);
+		pci_user_read_config_word(dev, off, &val);
 		data[off - init_off] = val & 0xff;
 		data[off - init_off + 1] = (val >> 8) & 0xff;
 		off += 2;
@@ -167,7 +167,7 @@ pci_read_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
 
 	if (size > 0) {
 		u8 val;
-		pci_read_config_byte(dev, off, &val);
+		pci_user_read_config_byte(dev, off, &val);
 		data[off - init_off] = val;
 		off++;
 		--size;
@@ -192,7 +192,7 @@ pci_write_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
 	}
 	
 	if ((off & 1) && size) {
-		pci_write_config_byte(dev, off, data[off - init_off]);
+		pci_user_write_config_byte(dev, off, data[off - init_off]);
 		off++;
 		size--;
 	}
@@ -200,7 +200,7 @@ pci_write_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
 	if ((off & 3) && size > 2) {
 		u16 val = data[off - init_off];
 		val |= (u16) data[off - init_off + 1] << 8;
-                pci_write_config_word(dev, off, val);
+                pci_user_write_config_word(dev, off, val);
                 off += 2;
                 size -= 2;
         }
@@ -210,7 +210,7 @@ pci_write_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
 		val |= (u32) data[off - init_off + 1] << 8;
 		val |= (u32) data[off - init_off + 2] << 16;
 		val |= (u32) data[off - init_off + 3] << 24;
-		pci_write_config_dword(dev, off, val);
+		pci_user_write_config_dword(dev, off, val);
 		off += 4;
 		size -= 4;
 	}
@@ -218,13 +218,13 @@ pci_write_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
 	if (size >= 2) {
 		u16 val = data[off - init_off];
 		val |= (u16) data[off - init_off + 1] << 8;
-		pci_write_config_word(dev, off, val);
+		pci_user_write_config_word(dev, off, val);
 		off += 2;
 		size -= 2;
 	}
 
 	if (size) {
-		pci_write_config_byte(dev, off, data[off - init_off]);
+		pci_user_write_config_byte(dev, off, data[off - init_off]);
 		off++;
 		--size;
 	}

commit 656da9da3745abcbbbdca598745d04c6de2c8843
Author: Pekka Enberg <penberg@cs.helsinki.fi>
Date:   Thu Sep 22 00:48:11 2005 -0700

    [PATCH] PCI: convert kcalloc to kzalloc
    
    This patch converts kcalloc(1, ...) calls to use the new kzalloc() function.
    
    Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 56a3b397efee..2898830c496f 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -360,7 +360,7 @@ pci_create_resource_files(struct pci_dev *pdev)
 			continue;
 
 		/* allocate attribute structure, piggyback attribute name */
-		res_attr = kcalloc(1, sizeof(*res_attr) + 10, GFP_ATOMIC);
+		res_attr = kzalloc(sizeof(*res_attr) + 10, GFP_ATOMIC);
 		if (res_attr) {
 			char *res_attr_name = (char *)(res_attr + 1);
 

commit 4327edf6b8a7ac7dce144313947995538842d8fd
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Sat Sep 10 00:25:49 2005 -0700

    [PATCH] Subject: PATCH: fix numa caused compile warnings
    
    pcibus_to_cpumask expands into more than just an initialiser so gcc
    moans about code before variable declarations.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index cc9d65388e62..56a3b397efee 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -44,10 +44,14 @@ pci_config_attr(subsystem_device, "0x%04x\n");
 pci_config_attr(class, "0x%06x\n");
 pci_config_attr(irq, "%u\n");
 
-static ssize_t local_cpus_show(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t local_cpus_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
 {		
-	cpumask_t mask = pcibus_to_cpumask(to_pci_dev(dev)->bus);
-	int len = cpumask_scnprintf(buf, PAGE_SIZE-2, mask);
+	cpumask_t mask;
+	int len;
+
+	mask = pcibus_to_cpumask(to_pci_dev(dev)->bus);
+	len = cpumask_scnprintf(buf, PAGE_SIZE-2, mask);
 	strcat(buf,"\n"); 
 	return 1+len;
 }

commit 2311b1f2bbd36fa5f366a7448c718b2556e0f02c
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Fri May 13 17:44:10 2005 +1000

    [PATCH] PCI: fix-pci-mmap-on-ppc-and-ppc64.patch
    
    This is an updated version of Ben's fix-pci-mmap-on-ppc-and-ppc64.patch
    which is in 2.6.12-rc4-mm1.
    
    It fixes the patch to work on PPC iSeries, removes some debug printks
    at Ben's request, and incorporates your
    fix-pci-mmap-on-ppc-and-ppc64-fix.patch also.
    
    Originally from Benjamin Herrenschmidt <benh@kernel.crashing.org>
    
    This patch was discussed at length on linux-pci and so far, the last
    iteration of it didn't raise any comment.  It's effect is a nop on
    architecture that don't define the new pci_resource_to_user() callback
    anyway.  It allows architecture like ppc who put weird things inside of
    PCI resource structures to convert to some different value for user
    visible ones.  It also fixes mmap'ing of IO space on those archs.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index a15f94072a6f..cc9d65388e62 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -60,15 +60,18 @@ resource_show(struct device * dev, struct device_attribute *attr, char * buf)
 	char * str = buf;
 	int i;
 	int max = 7;
+	u64 start, end;
 
 	if (pci_dev->subordinate)
 		max = DEVICE_COUNT_RESOURCE;
 
 	for (i = 0; i < max; i++) {
-		str += sprintf(str,"0x%016lx 0x%016lx 0x%016lx\n",
-			       pci_resource_start(pci_dev,i),
-			       pci_resource_end(pci_dev,i),
-			       pci_resource_flags(pci_dev,i));
+		struct resource *res =  &pci_dev->resource[i];
+		pci_resource_to_user(pci_dev, i, res, &start, &end);
+		str += sprintf(str,"0x%016llx 0x%016llx 0x%016llx\n",
+			       (unsigned long long)start,
+			       (unsigned long long)end,
+			       (unsigned long long)res->flags);
 	}
 	return (str - buf);
 }
@@ -313,8 +316,21 @@ pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
 						       struct device, kobj));
 	struct resource *res = (struct resource *)attr->private;
 	enum pci_mmap_state mmap_type;
+	u64 start, end;
+	int i;
 
-	vma->vm_pgoff += res->start >> PAGE_SHIFT;
+	for (i = 0; i < PCI_ROM_RESOURCE; i++)
+		if (res == &pdev->resource[i])
+			break;
+	if (i >= PCI_ROM_RESOURCE)
+		return -ENODEV;
+
+	/* pci_mmap_page_range() expects the same kind of entry as coming
+	 * from /proc/bus/pci/ which is a "user visible" value. If this is
+	 * different from the resource itself, arch will do necessary fixup.
+	 */
+	pci_resource_to_user(pdev, i, res, &start, &end);
+	vma->vm_pgoff += start >> PAGE_SHIFT;
 	mmap_type = res->flags & IORESOURCE_MEM ? pci_mmap_mem : pci_mmap_io;
 
 	return pci_mmap_page_range(pdev, vma, mmap_type, 0);

commit 87c8a4433b608261a9becdb0ce2d2f2ed4b71d05
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sun Jun 19 12:21:43 2005 +0200

    [PATCH] PCI: fix show_modalias() function due to attribute change
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 8b79609a3a03..a15f94072a6f 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -73,7 +73,7 @@ resource_show(struct device * dev, struct device_attribute *attr, char * buf)
 	return (str - buf);
 }
 
-static ssize_t modalias_show(struct device *dev, char *buf)
+static ssize_t modalias_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 

commit e404e274f62665f3333d6a539d0d3701f678a598
Author: Yani Ioannou <yani.ioannou@gmail.com>
Date:   Tue May 17 06:42:58 2005 -0400

    [PATCH] Driver Core: drivers/i2c/chips/w83781d.c - drivers/s390/block/dcssblk.c: update device attribute callbacks
    
    Signed-off-by: Yani Ioannou <yani.ioannou@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index e8aad151175f..8b79609a3a03 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -29,7 +29,7 @@ static int sysfs_initialized;	/* = 0 */
 /* show configuration fields */
 #define pci_config_attr(field, format_string)				\
 static ssize_t								\
-field##_show(struct device *dev, char *buf)				\
+field##_show(struct device *dev, struct device_attribute *attr, char *buf)				\
 {									\
 	struct pci_dev *pdev;						\
 									\
@@ -44,7 +44,7 @@ pci_config_attr(subsystem_device, "0x%04x\n");
 pci_config_attr(class, "0x%06x\n");
 pci_config_attr(irq, "%u\n");
 
-static ssize_t local_cpus_show(struct device *dev, char *buf)
+static ssize_t local_cpus_show(struct device *dev, struct device_attribute *attr, char *buf)
 {		
 	cpumask_t mask = pcibus_to_cpumask(to_pci_dev(dev)->bus);
 	int len = cpumask_scnprintf(buf, PAGE_SIZE-2, mask);
@@ -54,7 +54,7 @@ static ssize_t local_cpus_show(struct device *dev, char *buf)
 
 /* show resources */
 static ssize_t
-resource_show(struct device * dev, char * buf)
+resource_show(struct device * dev, struct device_attribute *attr, char * buf)
 {
 	struct pci_dev * pci_dev = to_pci_dev(dev);
 	char * str = buf;

commit d48593bf208e0d046c35fb0707ae5b23fef8c4ff
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Fri Apr 29 00:58:46 2005 -0500

    [PATCH] Make attributes names const char *
    
    sysfs: make attributes and attribute_group's names const char *
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 6ca0061137a6..e8aad151175f 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -339,16 +339,17 @@ pci_create_resource_files(struct pci_dev *pdev)
 		if (!pci_resource_len(pdev, i))
 			continue;
 
-		res_attr = kmalloc(sizeof(*res_attr) + 10, GFP_ATOMIC);
+		/* allocate attribute structure, piggyback attribute name */
+		res_attr = kcalloc(1, sizeof(*res_attr) + 10, GFP_ATOMIC);
 		if (res_attr) {
-			memset(res_attr, 0, sizeof(*res_attr) + 10);
+			char *res_attr_name = (char *)(res_attr + 1);
+
 			pdev->res_attr[i] = res_attr;
-			/* Allocated above after the res_attr struct */
-			res_attr->attr.name = (char *)(res_attr + 1);
-			sprintf(res_attr->attr.name, "resource%d", i);
-			res_attr->size = pci_resource_len(pdev, i);
+			sprintf(res_attr_name, "resource%d", i);
+			res_attr->attr.name = res_attr_name;
 			res_attr->attr.mode = S_IRUSR | S_IWUSR;
 			res_attr->attr.owner = THIS_MODULE;
+			res_attr->size = pci_resource_len(pdev, i);
 			res_attr->mmap = pci_mmap_resource;
 			res_attr->private = &pdev->resource[i];
 			sysfs_create_bin_file(&pdev->dev.kobj, res_attr);

commit 9888549e0507cc95d1d7ade1595c00ff8e902659
Author: Greg KH <gregkh@suse.de>
Date:   Thu May 5 11:57:25 2005 -0700

    [PATCH] PCI: add modalias sysfs file for pci devices
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 8568b207f189..6ca0061137a6 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -73,6 +73,17 @@ resource_show(struct device * dev, char * buf)
 	return (str - buf);
 }
 
+static ssize_t modalias_show(struct device *dev, char *buf)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+
+	return sprintf(buf, "pci:v%08Xd%08Xsv%08Xsd%08Xbc%02Xsc%02Xi%02x\n",
+		       pci_dev->vendor, pci_dev->device,
+		       pci_dev->subsystem_vendor, pci_dev->subsystem_device,
+		       (u8)(pci_dev->class >> 16), (u8)(pci_dev->class >> 8),
+		       (u8)(pci_dev->class));
+}
+
 struct device_attribute pci_dev_attrs[] = {
 	__ATTR_RO(resource),
 	__ATTR_RO(vendor),
@@ -82,6 +93,7 @@ struct device_attribute pci_dev_attrs[] = {
 	__ATTR_RO(class),
 	__ATTR_RO(irq),
 	__ATTR_RO(local_cpus),
+	__ATTR_RO(modalias),
 	__ATTR_NULL,
 };
 

commit 4c0619add8c3a8b28e7fae8b15cc7b62de2f8148
Author: ssant@in.ibm.com <ssant@in.ibm.com>
Date:   Fri Apr 8 14:53:31 2005 +0900

    [PATCH] PCI: fix up word-aligned 16-bit PCI config access through sysfs
    
    This patch adds the possibility to do word-aligned 16-bit atomic PCI
    configuration space accesses via the sysfs PCI interface. As a result, problems
    with Emulex LFPC on IBM PowerPC64 are fixed.
    
    Patch is present in SLES 9 SP1.
    
    Signed-off-by: Vojtech Pavlik <vojtech@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index d57ae71d32b1..8568b207f189 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -91,6 +91,7 @@ pci_read_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
 	struct pci_dev *dev = to_pci_dev(container_of(kobj,struct device,kobj));
 	unsigned int size = 64;
 	loff_t init_off = off;
+	u8 *data = (u8*) buf;
 
 	/* Several chips lock up trying to read undefined config space */
 	if (capable(CAP_SYS_ADMIN)) {
@@ -108,30 +109,47 @@ pci_read_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
 		size = count;
 	}
 
-	while (off & 3) {
-		unsigned char val;
+	if ((off & 1) && size) {
+		u8 val;
 		pci_read_config_byte(dev, off, &val);
-		buf[off - init_off] = val;
+		data[off - init_off] = val;
 		off++;
-		if (--size == 0)
-			break;
+		size--;
+	}
+
+	if ((off & 3) && size > 2) {
+		u16 val;
+		pci_read_config_word(dev, off, &val);
+		data[off - init_off] = val & 0xff;
+		data[off - init_off + 1] = (val >> 8) & 0xff;
+		off += 2;
+		size -= 2;
 	}
 
 	while (size > 3) {
-		unsigned int val;
+		u32 val;
 		pci_read_config_dword(dev, off, &val);
-		buf[off - init_off] = val & 0xff;
-		buf[off - init_off + 1] = (val >> 8) & 0xff;
-		buf[off - init_off + 2] = (val >> 16) & 0xff;
-		buf[off - init_off + 3] = (val >> 24) & 0xff;
+		data[off - init_off] = val & 0xff;
+		data[off - init_off + 1] = (val >> 8) & 0xff;
+		data[off - init_off + 2] = (val >> 16) & 0xff;
+		data[off - init_off + 3] = (val >> 24) & 0xff;
 		off += 4;
 		size -= 4;
 	}
 
-	while (size > 0) {
-		unsigned char val;
+	if (size >= 2) {
+		u16 val;
+		pci_read_config_word(dev, off, &val);
+		data[off - init_off] = val & 0xff;
+		data[off - init_off + 1] = (val >> 8) & 0xff;
+		off += 2;
+		size -= 2;
+	}
+
+	if (size > 0) {
+		u8 val;
 		pci_read_config_byte(dev, off, &val);
-		buf[off - init_off] = val;
+		data[off - init_off] = val;
 		off++;
 		--size;
 	}
@@ -145,6 +163,7 @@ pci_write_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
 	struct pci_dev *dev = to_pci_dev(container_of(kobj,struct device,kobj));
 	unsigned int size = count;
 	loff_t init_off = off;
+	u8 *data = (u8*) buf;
 
 	if (off > dev->cfg_size)
 		return 0;
@@ -152,26 +171,41 @@ pci_write_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
 		size = dev->cfg_size - off;
 		count = size;
 	}
-
-	while (off & 3) {
-		pci_write_config_byte(dev, off, buf[off - init_off]);
+	
+	if ((off & 1) && size) {
+		pci_write_config_byte(dev, off, data[off - init_off]);
 		off++;
-		if (--size == 0)
-			break;
+		size--;
 	}
+	
+	if ((off & 3) && size > 2) {
+		u16 val = data[off - init_off];
+		val |= (u16) data[off - init_off + 1] << 8;
+                pci_write_config_word(dev, off, val);
+                off += 2;
+                size -= 2;
+        }
 
 	while (size > 3) {
-		unsigned int val = buf[off - init_off];
-		val |= (unsigned int) buf[off - init_off + 1] << 8;
-		val |= (unsigned int) buf[off - init_off + 2] << 16;
-		val |= (unsigned int) buf[off - init_off + 3] << 24;
+		u32 val = data[off - init_off];
+		val |= (u32) data[off - init_off + 1] << 8;
+		val |= (u32) data[off - init_off + 2] << 16;
+		val |= (u32) data[off - init_off + 3] << 24;
 		pci_write_config_dword(dev, off, val);
 		off += 4;
 		size -= 4;
 	}
+	
+	if (size >= 2) {
+		u16 val = data[off - init_off];
+		val |= (u16) data[off - init_off + 1] << 8;
+		pci_write_config_word(dev, off, val);
+		off += 2;
+		size -= 2;
+	}
 
-	while (size > 0) {
-		pci_write_config_byte(dev, off, buf[off - init_off]);
+	if (size) {
+		pci_write_config_byte(dev, off, data[off - init_off]);
 		off++;
 		--size;
 	}

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
new file mode 100644
index 000000000000..d57ae71d32b1
--- /dev/null
+++ b/drivers/pci/pci-sysfs.c
@@ -0,0 +1,490 @@
+/*
+ * drivers/pci/pci-sysfs.c
+ *
+ * (C) Copyright 2002-2004 Greg Kroah-Hartman <greg@kroah.com>
+ * (C) Copyright 2002-2004 IBM Corp.
+ * (C) Copyright 2003 Matthew Wilcox
+ * (C) Copyright 2003 Hewlett-Packard
+ * (C) Copyright 2004 Jon Smirl <jonsmirl@yahoo.com>
+ * (C) Copyright 2004 Silicon Graphics, Inc. Jesse Barnes <jbarnes@sgi.com>
+ *
+ * File attributes for PCI devices
+ *
+ * Modeled after usb's driverfs.c 
+ *
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/stat.h>
+#include <linux/topology.h>
+#include <linux/mm.h>
+
+#include "pci.h"
+
+static int sysfs_initialized;	/* = 0 */
+
+/* show configuration fields */
+#define pci_config_attr(field, format_string)				\
+static ssize_t								\
+field##_show(struct device *dev, char *buf)				\
+{									\
+	struct pci_dev *pdev;						\
+									\
+	pdev = to_pci_dev (dev);					\
+	return sprintf (buf, format_string, pdev->field);		\
+}
+
+pci_config_attr(vendor, "0x%04x\n");
+pci_config_attr(device, "0x%04x\n");
+pci_config_attr(subsystem_vendor, "0x%04x\n");
+pci_config_attr(subsystem_device, "0x%04x\n");
+pci_config_attr(class, "0x%06x\n");
+pci_config_attr(irq, "%u\n");
+
+static ssize_t local_cpus_show(struct device *dev, char *buf)
+{		
+	cpumask_t mask = pcibus_to_cpumask(to_pci_dev(dev)->bus);
+	int len = cpumask_scnprintf(buf, PAGE_SIZE-2, mask);
+	strcat(buf,"\n"); 
+	return 1+len;
+}
+
+/* show resources */
+static ssize_t
+resource_show(struct device * dev, char * buf)
+{
+	struct pci_dev * pci_dev = to_pci_dev(dev);
+	char * str = buf;
+	int i;
+	int max = 7;
+
+	if (pci_dev->subordinate)
+		max = DEVICE_COUNT_RESOURCE;
+
+	for (i = 0; i < max; i++) {
+		str += sprintf(str,"0x%016lx 0x%016lx 0x%016lx\n",
+			       pci_resource_start(pci_dev,i),
+			       pci_resource_end(pci_dev,i),
+			       pci_resource_flags(pci_dev,i));
+	}
+	return (str - buf);
+}
+
+struct device_attribute pci_dev_attrs[] = {
+	__ATTR_RO(resource),
+	__ATTR_RO(vendor),
+	__ATTR_RO(device),
+	__ATTR_RO(subsystem_vendor),
+	__ATTR_RO(subsystem_device),
+	__ATTR_RO(class),
+	__ATTR_RO(irq),
+	__ATTR_RO(local_cpus),
+	__ATTR_NULL,
+};
+
+static ssize_t
+pci_read_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+	struct pci_dev *dev = to_pci_dev(container_of(kobj,struct device,kobj));
+	unsigned int size = 64;
+	loff_t init_off = off;
+
+	/* Several chips lock up trying to read undefined config space */
+	if (capable(CAP_SYS_ADMIN)) {
+		size = dev->cfg_size;
+	} else if (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS) {
+		size = 128;
+	}
+
+	if (off > size)
+		return 0;
+	if (off + count > size) {
+		size -= off;
+		count = size;
+	} else {
+		size = count;
+	}
+
+	while (off & 3) {
+		unsigned char val;
+		pci_read_config_byte(dev, off, &val);
+		buf[off - init_off] = val;
+		off++;
+		if (--size == 0)
+			break;
+	}
+
+	while (size > 3) {
+		unsigned int val;
+		pci_read_config_dword(dev, off, &val);
+		buf[off - init_off] = val & 0xff;
+		buf[off - init_off + 1] = (val >> 8) & 0xff;
+		buf[off - init_off + 2] = (val >> 16) & 0xff;
+		buf[off - init_off + 3] = (val >> 24) & 0xff;
+		off += 4;
+		size -= 4;
+	}
+
+	while (size > 0) {
+		unsigned char val;
+		pci_read_config_byte(dev, off, &val);
+		buf[off - init_off] = val;
+		off++;
+		--size;
+	}
+
+	return count;
+}
+
+static ssize_t
+pci_write_config(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+	struct pci_dev *dev = to_pci_dev(container_of(kobj,struct device,kobj));
+	unsigned int size = count;
+	loff_t init_off = off;
+
+	if (off > dev->cfg_size)
+		return 0;
+	if (off + count > dev->cfg_size) {
+		size = dev->cfg_size - off;
+		count = size;
+	}
+
+	while (off & 3) {
+		pci_write_config_byte(dev, off, buf[off - init_off]);
+		off++;
+		if (--size == 0)
+			break;
+	}
+
+	while (size > 3) {
+		unsigned int val = buf[off - init_off];
+		val |= (unsigned int) buf[off - init_off + 1] << 8;
+		val |= (unsigned int) buf[off - init_off + 2] << 16;
+		val |= (unsigned int) buf[off - init_off + 3] << 24;
+		pci_write_config_dword(dev, off, val);
+		off += 4;
+		size -= 4;
+	}
+
+	while (size > 0) {
+		pci_write_config_byte(dev, off, buf[off - init_off]);
+		off++;
+		--size;
+	}
+
+	return count;
+}
+
+#ifdef HAVE_PCI_LEGACY
+/**
+ * pci_read_legacy_io - read byte(s) from legacy I/O port space
+ * @kobj: kobject corresponding to file to read from
+ * @buf: buffer to store results
+ * @off: offset into legacy I/O port space
+ * @count: number of bytes to read
+ *
+ * Reads 1, 2, or 4 bytes from legacy I/O port space using an arch specific
+ * callback routine (pci_legacy_read).
+ */
+ssize_t
+pci_read_legacy_io(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+        struct pci_bus *bus = to_pci_bus(container_of(kobj,
+                                                      struct class_device,
+						      kobj));
+
+        /* Only support 1, 2 or 4 byte accesses */
+        if (count != 1 && count != 2 && count != 4)
+                return -EINVAL;
+
+        return pci_legacy_read(bus, off, (u32 *)buf, count);
+}
+
+/**
+ * pci_write_legacy_io - write byte(s) to legacy I/O port space
+ * @kobj: kobject corresponding to file to read from
+ * @buf: buffer containing value to be written
+ * @off: offset into legacy I/O port space
+ * @count: number of bytes to write
+ *
+ * Writes 1, 2, or 4 bytes from legacy I/O port space using an arch specific
+ * callback routine (pci_legacy_write).
+ */
+ssize_t
+pci_write_legacy_io(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+        struct pci_bus *bus = to_pci_bus(container_of(kobj,
+						      struct class_device,
+						      kobj));
+        /* Only support 1, 2 or 4 byte accesses */
+        if (count != 1 && count != 2 && count != 4)
+                return -EINVAL;
+
+        return pci_legacy_write(bus, off, *(u32 *)buf, count);
+}
+
+/**
+ * pci_mmap_legacy_mem - map legacy PCI memory into user memory space
+ * @kobj: kobject corresponding to device to be mapped
+ * @attr: struct bin_attribute for this file
+ * @vma: struct vm_area_struct passed to mmap
+ *
+ * Uses an arch specific callback, pci_mmap_legacy_page_range, to mmap
+ * legacy memory space (first meg of bus space) into application virtual
+ * memory space.
+ */
+int
+pci_mmap_legacy_mem(struct kobject *kobj, struct bin_attribute *attr,
+                    struct vm_area_struct *vma)
+{
+        struct pci_bus *bus = to_pci_bus(container_of(kobj,
+                                                      struct class_device,
+						      kobj));
+
+        return pci_mmap_legacy_page_range(bus, vma);
+}
+#endif /* HAVE_PCI_LEGACY */
+
+#ifdef HAVE_PCI_MMAP
+/**
+ * pci_mmap_resource - map a PCI resource into user memory space
+ * @kobj: kobject for mapping
+ * @attr: struct bin_attribute for the file being mapped
+ * @vma: struct vm_area_struct passed into the mmap
+ *
+ * Use the regular PCI mapping routines to map a PCI resource into userspace.
+ * FIXME: write combining?  maybe automatic for prefetchable regions?
+ */
+static int
+pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,
+		  struct vm_area_struct *vma)
+{
+	struct pci_dev *pdev = to_pci_dev(container_of(kobj,
+						       struct device, kobj));
+	struct resource *res = (struct resource *)attr->private;
+	enum pci_mmap_state mmap_type;
+
+	vma->vm_pgoff += res->start >> PAGE_SHIFT;
+	mmap_type = res->flags & IORESOURCE_MEM ? pci_mmap_mem : pci_mmap_io;
+
+	return pci_mmap_page_range(pdev, vma, mmap_type, 0);
+}
+
+/**
+ * pci_create_resource_files - create resource files in sysfs for @dev
+ * @dev: dev in question
+ *
+ * Walk the resources in @dev creating files for each resource available.
+ */
+static void
+pci_create_resource_files(struct pci_dev *pdev)
+{
+	int i;
+
+	/* Expose the PCI resources from this device as files */
+	for (i = 0; i < PCI_ROM_RESOURCE; i++) {
+		struct bin_attribute *res_attr;
+
+		/* skip empty resources */
+		if (!pci_resource_len(pdev, i))
+			continue;
+
+		res_attr = kmalloc(sizeof(*res_attr) + 10, GFP_ATOMIC);
+		if (res_attr) {
+			memset(res_attr, 0, sizeof(*res_attr) + 10);
+			pdev->res_attr[i] = res_attr;
+			/* Allocated above after the res_attr struct */
+			res_attr->attr.name = (char *)(res_attr + 1);
+			sprintf(res_attr->attr.name, "resource%d", i);
+			res_attr->size = pci_resource_len(pdev, i);
+			res_attr->attr.mode = S_IRUSR | S_IWUSR;
+			res_attr->attr.owner = THIS_MODULE;
+			res_attr->mmap = pci_mmap_resource;
+			res_attr->private = &pdev->resource[i];
+			sysfs_create_bin_file(&pdev->dev.kobj, res_attr);
+		}
+	}
+}
+
+/**
+ * pci_remove_resource_files - cleanup resource files
+ * @dev: dev to cleanup
+ *
+ * If we created resource files for @dev, remove them from sysfs and
+ * free their resources.
+ */
+static void
+pci_remove_resource_files(struct pci_dev *pdev)
+{
+	int i;
+
+	for (i = 0; i < PCI_ROM_RESOURCE; i++) {
+		struct bin_attribute *res_attr;
+
+		res_attr = pdev->res_attr[i];
+		if (res_attr) {
+			sysfs_remove_bin_file(&pdev->dev.kobj, res_attr);
+			kfree(res_attr);
+		}
+	}
+}
+#else /* !HAVE_PCI_MMAP */
+static inline void pci_create_resource_files(struct pci_dev *dev) { return; }
+static inline void pci_remove_resource_files(struct pci_dev *dev) { return; }
+#endif /* HAVE_PCI_MMAP */
+
+/**
+ * pci_write_rom - used to enable access to the PCI ROM display
+ * @kobj: kernel object handle
+ * @buf: user input
+ * @off: file offset
+ * @count: number of byte in input
+ *
+ * writing anything except 0 enables it
+ */
+static ssize_t
+pci_write_rom(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+	struct pci_dev *pdev = to_pci_dev(container_of(kobj, struct device, kobj));
+
+	if ((off ==  0) && (*buf == '0') && (count == 2))
+		pdev->rom_attr_enabled = 0;
+	else
+		pdev->rom_attr_enabled = 1;
+
+	return count;
+}
+
+/**
+ * pci_read_rom - read a PCI ROM
+ * @kobj: kernel object handle
+ * @buf: where to put the data we read from the ROM
+ * @off: file offset
+ * @count: number of bytes to read
+ *
+ * Put @count bytes starting at @off into @buf from the ROM in the PCI
+ * device corresponding to @kobj.
+ */
+static ssize_t
+pci_read_rom(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+	struct pci_dev *pdev = to_pci_dev(container_of(kobj, struct device, kobj));
+	void __iomem *rom;
+	size_t size;
+
+	if (!pdev->rom_attr_enabled)
+		return -EINVAL;
+	
+	rom = pci_map_rom(pdev, &size);	/* size starts out as PCI window size */
+	if (!rom)
+		return 0;
+		
+	if (off >= size)
+		count = 0;
+	else {
+		if (off + count > size)
+			count = size - off;
+		
+		memcpy_fromio(buf, rom + off, count);
+	}
+	pci_unmap_rom(pdev, rom);
+		
+	return count;
+}
+
+static struct bin_attribute pci_config_attr = {
+	.attr =	{
+		.name = "config",
+		.mode = S_IRUGO | S_IWUSR,
+		.owner = THIS_MODULE,
+	},
+	.size = 256,
+	.read = pci_read_config,
+	.write = pci_write_config,
+};
+
+static struct bin_attribute pcie_config_attr = {
+	.attr =	{
+		.name = "config",
+		.mode = S_IRUGO | S_IWUSR,
+		.owner = THIS_MODULE,
+	},
+	.size = 4096,
+	.read = pci_read_config,
+	.write = pci_write_config,
+};
+
+int pci_create_sysfs_dev_files (struct pci_dev *pdev)
+{
+	if (!sysfs_initialized)
+		return -EACCES;
+
+	if (pdev->cfg_size < 4096)
+		sysfs_create_bin_file(&pdev->dev.kobj, &pci_config_attr);
+	else
+		sysfs_create_bin_file(&pdev->dev.kobj, &pcie_config_attr);
+
+	pci_create_resource_files(pdev);
+
+	/* If the device has a ROM, try to expose it in sysfs. */
+	if (pci_resource_len(pdev, PCI_ROM_RESOURCE)) {
+		struct bin_attribute *rom_attr;
+		
+		rom_attr = kmalloc(sizeof(*rom_attr), GFP_ATOMIC);
+		if (rom_attr) {
+			memset(rom_attr, 0x00, sizeof(*rom_attr));
+			pdev->rom_attr = rom_attr;
+			rom_attr->size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
+			rom_attr->attr.name = "rom";
+			rom_attr->attr.mode = S_IRUSR;
+			rom_attr->attr.owner = THIS_MODULE;
+			rom_attr->read = pci_read_rom;
+			rom_attr->write = pci_write_rom;
+			sysfs_create_bin_file(&pdev->dev.kobj, rom_attr);
+		}
+	}
+	/* add platform-specific attributes */
+	pcibios_add_platform_entries(pdev);
+	
+	return 0;
+}
+
+/**
+ * pci_remove_sysfs_dev_files - cleanup PCI specific sysfs files
+ * @pdev: device whose entries we should free
+ *
+ * Cleanup when @pdev is removed from sysfs.
+ */
+void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
+{
+	if (pdev->cfg_size < 4096)
+		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
+	else
+		sysfs_remove_bin_file(&pdev->dev.kobj, &pcie_config_attr);
+
+	pci_remove_resource_files(pdev);
+
+	if (pci_resource_len(pdev, PCI_ROM_RESOURCE)) {
+		if (pdev->rom_attr) {
+			sysfs_remove_bin_file(&pdev->dev.kobj, pdev->rom_attr);
+			kfree(pdev->rom_attr);
+		}
+	}
+}
+
+static int __init pci_sysfs_init(void)
+{
+	struct pci_dev *pdev = NULL;
+	
+	sysfs_initialized = 1;
+	for_each_pci_dev(pdev)
+		pci_create_sysfs_dev_files(pdev);
+
+	return 0;
+}
+
+__initcall(pci_sysfs_init);
